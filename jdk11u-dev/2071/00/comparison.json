{"files":[{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4394789\n+  @summary KeyboardFocusManager.upFocusCycle is not working for Swing properly\n+  @key headful\n+  @run main AsyncUpFocusCycleTest\n+*\/\n+\n+\n+import javax.swing.DefaultFocusManager;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Color;\n+import java.awt.Container;\n+import java.awt.DefaultKeyboardFocusManager;\n+import java.awt.EventQueue;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class AsyncUpFocusCycleTest {\n+    volatile boolean isFailed = true;\n+    Object sema = new Object();\n+    JFrame frame;\n+    Point location;\n+    JButton button;\n+    Insets insets;\n+    int width;\n+\n+    public void start() throws InterruptedException,\n+            InvocationTargetException {\n+        try {\n+            Robot robot = new Robot();\n+            robot.mouseMove(100, 100);\n+\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new JFrame(\"AsyncUpFocusCycleTest\") {\n+                    public void requestFocus() {\n+                        boolean ret = super.requestFocus(false);\n+                        System.err.println(\"requestFocus() on Frame \" + ret);\n+                    }\n+\n+                    protected boolean requestFocus(boolean temporary) {\n+                        boolean ret = super.requestFocus(temporary);\n+                        System.err.println(\"requestFocus(\" + temporary + \") on Frame \" + ret);\n+                        return ret;\n+                    }\n+\n+                    public boolean requestFocusInWindow() {\n+                        boolean ret = super.requestFocusInWindow();\n+                        System.err.println(\"requestFocusInWindow() on Frame \" + ret);\n+                        return ret;\n+                    }\n+\n+                    protected boolean requestFocusInWindow(boolean temporary) {\n+                        boolean ret = super.requestFocusInWindow(temporary);\n+                        System.err.println(\"requestFocusInWindow(\" + temporary + \") on Frame \" + ret);\n+                        return ret;\n+                    }\n+                };\n+\n+                Container container1 = frame.getContentPane();\n+                container1.setBackground(Color.yellow);\n+\n+                button = new JButton(\"Button\") {\n+                    public void requestFocus() {\n+                        boolean ret = super.requestFocus(false);\n+                        System.err.println(\"requestFocus() on Button \" + ret);\n+                    }\n+\n+                    public boolean requestFocus(boolean temporary) {\n+                        boolean ret = super.requestFocus(temporary);\n+                        System.err.println(\"requestFocus(\" + temporary + \") on Button \" + ret);\n+                        return ret;\n+                    }\n+\n+                    public boolean requestFocusInWindow() {\n+                        boolean ret = super.requestFocusInWindow();\n+                        System.err.println(\"requestFocusInWindow() on Button \" + ret);\n+                        return ret;\n+                    }\n+\n+                    protected boolean requestFocusInWindow(boolean temporary) {\n+                        boolean ret = super.requestFocusInWindow(temporary);\n+                        System.err.println(\"requestFocusInWindow(\" + temporary + \") on Button \" + ret);\n+                        return ret;\n+                    }\n+                };\n+                button.addFocusListener(new FocusAdapter() {\n+                    public void focusGained(FocusEvent fe) {\n+                        System.out.println(\"Button receive focus\");\n+                        frame.addFocusListener(new FocusAdapter() {\n+                            public void focusGained(FocusEvent fe) {\n+                                System.out.println(\"Frame receive focus\");\n+                                synchronized (sema) {\n+                                    isFailed = false;\n+                                    sema.notifyAll();\n+                                }\n+                            }\n+                        });\n+                    }\n+                });\n+                container1.add(new JButton(\"empty button\"), BorderLayout.WEST);\n+                container1.add(button, BorderLayout.EAST);\n+                frame.setBounds(0, 0, 300, 300);\n+                frame.setVisible(true);\n+            });\n+\n+            robot.delay(2000);\n+            robot.waitForIdle();\n+\n+            EventQueue.invokeAndWait(() -> {\n+                location = frame.getLocationOnScreen();\n+                insets = frame.getInsets();\n+                width = frame.getWidth();\n+            });\n+\n+            robot.mouseMove(location.x + width \/ 2, location.y + insets.top \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            DefaultKeyboardFocusManager manager = new DefaultFocusManager();\n+            robot.delay(1000);\n+            EventQueue.invokeAndWait(button::requestFocus);\n+            robot.delay(1000);\n+            EventQueue.invokeAndWait(() -> {\n+                manager.upFocusCycle(button);\n+            });\n+\n+            try {\n+                synchronized (sema) {\n+                    sema.wait(5000);\n+                }\n+\n+                if (isFailed) {\n+                    System.out.println(\"Test FAILED\");\n+                    throw new RuntimeException(\"Test FAILED\");\n+                } else {\n+                    System.out.println(\"Test PASSED\");\n+                }\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(\"Test was interrupted\");\n+            }\n+        } catch (AWTException e) {\n+            System.out.println(\"Problem creating Robot.\");\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        AsyncUpFocusCycleTest test = new AsyncUpFocusCycleTest();\n+        test.start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/AsyncUpFocusCycleTest.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -0,0 +1,307 @@\n+\/*\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4525962\n+  @summary Opposite component calculated inaccurately\n+  @key headful\n+  @run main ClearMostRecentFocusOwnerTest\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.AWTException;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Panel;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.Toolkit;\n+\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+public class ClearMostRecentFocusOwnerTest implements AWTEventListener {\n+    final static int ROBOT_DELAY = 50;\n+    volatile Frame firstFrame;\n+    volatile Frame secondFrame;\n+    volatile Button actionButton;\n+    volatile Button btnToRemove;\n+    volatile Button btnToHide;\n+    volatile Button btnToDisable;\n+    volatile Button btnToNonFocusable;\n+    volatile Panel pnlToHide;\n+    volatile Button btnInPanel;\n+\n+    Robot robot;\n+\n+    volatile Component opposite = null;\n+    volatile Component focusOwner = null;\n+    volatile Object monitor = null;\n+\n+    public void init() throws InterruptedException,\n+            InvocationTargetException {\n+        try {\n+            robot = new Robot();\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\"Can not create awt-robot.\");\n+        }\n+        EventQueue.invokeAndWait(() -> {\n+            firstFrame = new Frame(\"The First Frame\");\n+            firstFrame.setName(\"\\\"1st Frame\\\"\");\n+            secondFrame = new Frame(\"The Second Frame\");\n+            secondFrame.setName(\"\\\"2nd Frame\\\"\");\n+            pnlToHide = new Panel();\n+            pnlToHide.setName(\"Panel\");\n+            actionButton = new Button(\"Action Button\");\n+            actionButton.setName(\"\\\"\" + actionButton.getLabel() + \"\\\"\");\n+            btnToRemove = new Button(\"To Remove\");\n+            btnToRemove.setName(\"\\\"\" + btnToRemove.getLabel() + \"\\\"\");\n+            btnToHide = new Button(\"ToHide\");\n+            btnToHide.setName(\"\\\"\" + btnToHide.getLabel() + \"\\\"\");\n+            btnToDisable = new Button(\"To Disable\");\n+            btnToDisable.setName(\"\\\"\" + btnToDisable.getLabel() + \"\\\"\");\n+            btnToNonFocusable = new Button(\"To setFocusable(false)\");\n+            btnToNonFocusable.setName(\"\\\"\" + btnToNonFocusable.getLabel() + \"\\\"\");\n+            btnInPanel = new Button(\"Int Panel\");\n+            btnInPanel.setName(\"\\\"\" + btnInPanel.getLabel() + \"\\\"\");\n+\n+            firstFrame.add(actionButton);\n+\n+            secondFrame.setLayout(new FlowLayout());\n+            secondFrame.add(btnToRemove);\n+            secondFrame.add(btnToHide);\n+            secondFrame.add(btnToDisable);\n+            secondFrame.add(btnToNonFocusable);\n+            secondFrame.add(pnlToHide);\n+            pnlToHide.add(btnInPanel);\n+\n+            firstFrame.pack();\n+            firstFrame.setVisible(true);\n+            secondFrame.pack();\n+            secondFrame.setLocation(0, firstFrame.getHeight() + 50);\n+            secondFrame.setVisible(true);\n+        });\n+    }\n+\n+    public void start() throws InterruptedException, InvocationTargetException {\n+        try {\n+            Toolkit.getDefaultToolkit().\n+                    addAWTEventListener(this,\n+                            AWTEvent.FOCUS_EVENT_MASK);\n+\n+            makeFocusOwner(btnToRemove);\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(false);\n+                secondFrame.remove(btnToRemove);\n+            });\n+            makeFocusOwner(actionButton);\n+            opposite = null;\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(true);\n+            });\n+            makeActiveFrame(secondFrame);\n+            if (opposite != btnToHide) {\n+                System.out.println(\"opposite = \" + opposite);\n+                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.remove().\");\n+            }\n+\n+            makeFocusOwner(btnToHide);\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(false);\n+                btnToHide.setVisible(false);\n+            });\n+            makeFocusOwner(actionButton);\n+            opposite = null;\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(true);\n+            });\n+            makeActiveFrame(secondFrame);\n+            if (opposite != btnToDisable) {\n+                System.out.println(\"opposite = \" + opposite);\n+                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.setVisible(false).\");\n+            }\n+\n+            makeFocusOwner(btnToDisable);\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(false);\n+                btnToDisable.setEnabled(false);\n+            });\n+            makeFocusOwner(actionButton);\n+            opposite = null;\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(true);\n+            });\n+            makeActiveFrame(secondFrame);\n+            if (opposite != btnToNonFocusable) {\n+                System.out.println(\"opposite = \" + opposite);\n+                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.rsetEnabled(false).\");\n+            }\n+\n+            makeFocusOwner(btnToNonFocusable);\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(false);\n+                btnToNonFocusable.setFocusable(false);\n+            });\n+            makeFocusOwner(actionButton);\n+            opposite = null;\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(true);\n+            });\n+            makeActiveFrame(secondFrame);\n+            if (opposite != btnInPanel) {\n+                System.out.println(\"opposite = \" + opposite);\n+                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.setFocusable(false).\");\n+            }\n+\n+            makeFocusOwner(btnInPanel);\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(false);\n+                pnlToHide.setVisible(false);\n+            });\n+            makeFocusOwner(actionButton);\n+            opposite = null;\n+            EventQueue.invokeAndWait(() -> {\n+                secondFrame.setVisible(true);\n+            });\n+            makeActiveFrame(secondFrame);\n+            if (opposite == btnInPanel) {\n+                System.out.println(\"opposite = \" + opposite);\n+                throw new RuntimeException(\"Test FAILED: wrong opposite after Container.setVisible(false).\");\n+            }\n+        } finally {\n+            if (firstFrame != null) {\n+                EventQueue.invokeAndWait(firstFrame::dispose);\n+            }\n+            if (secondFrame != null) {\n+                EventQueue.invokeAndWait(secondFrame::dispose);\n+            }\n+\n+        }\n+    }\n+\n+    public void eventDispatched(AWTEvent event) {\n+        switch (event.getID()) {\n+            case FocusEvent.FOCUS_GAINED:\n+                if (focusOwner == ((FocusEvent) event).getComponent()\n+                        && monitor != null) {\n+                    synchronized (monitor) {\n+                        monitor.notify();\n+                    }\n+                }\n+                break;\n+            case FocusEvent.FOCUS_LOST:\n+                opposite = ((FocusEvent) event).getOppositeComponent();\n+                break;\n+        }\n+        System.out.println(event);\n+    }\n+\n+    void clickOnComponent(Component comp) throws InterruptedException,\n+            InvocationTargetException {\n+        System.err.println(\"clickOnComopnent \" + comp.getName());\n+        robot.delay(3000);\n+        int[] point = new int[2];\n+        EventQueue.invokeAndWait(() -> {\n+            Point origin = comp.getLocationOnScreen();\n+            Dimension dim = comp.getSize();\n+            point[0] = origin.x + (int) dim.getWidth() \/ 2;\n+            point[1] = origin.y + (int) dim.getHeight() \/ 2;\n+        });\n+        robot.mouseMove(point[0], point[1]);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.delay(ROBOT_DELAY);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+    }\n+\n+    void makeFocusOwner(Component comp) throws InterruptedException,\n+            InvocationTargetException {\n+        AtomicBoolean isOwner = new AtomicBoolean(false);\n+        EventQueue.invokeAndWait(() -> {\n+            isOwner.set(comp.isFocusOwner());\n+        });\n+        if (!isOwner.get()) {\n+            clickOnComponent(comp);\n+            try {\n+                EventQueue.invokeAndWait(() -> {\n+                    isOwner.set(comp.isFocusOwner());\n+                });\n+                if (!isOwner.get()) {\n+                    monitor = new Object();\n+                    focusOwner = comp;\n+                    synchronized (monitor) {\n+                        monitor.wait(3000);\n+                    }\n+                }\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(\"Test was interrupted.\");\n+            }\n+        }\n+        EventQueue.invokeAndWait(() -> {\n+            isOwner.set(comp.isFocusOwner());\n+        });\n+        if (!isOwner.get()) {\n+            throw new RuntimeException(\"Test can not make \"\n+                    + comp.getName() + \" a focus owner.\");\n+        }\n+    }\n+\n+    void makeActiveFrame(Frame frame) throws InvocationTargetException,\n+            InterruptedException {\n+        robot.delay(3000);\n+        if (!frame.isActive()) {\n+            System.err.println(\"frame is not active\");\n+            int[] point = new int[2];\n+            EventQueue.invokeAndWait(() -> {\n+                Point origin = frame.getLocationOnScreen();\n+                Insets ins = frame.getInsets();\n+                point[0] = origin.x + frame.getWidth() \/ 2;\n+                point[1] = origin.y + ins.top \/ 2;\n+            });\n+            robot.mouseMove(point[0], point[1]);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.delay(ROBOT_DELAY);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+        }\n+        robot.delay(3000);\n+        EventQueue.invokeAndWait(() -> {\n+            if (!frame.isActive()) {\n+                throw new RuntimeException(\"Test can not activate \" + frame.getName() + \".\");\n+            }\n+        });\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n+        ClearMostRecentFocusOwnerTest test = new ClearMostRecentFocusOwnerTest();\n+        test.init();\n+        test.start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/ClearMostRecentFocusOwnerTest.java","additions":307,"deletions":0,"binary":false,"changes":307,"status":"added"},{"patch":"@@ -0,0 +1,232 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+@test\n+@bug 4715649\n+@summary Tests that KEY_TYPED event for Tab key arrives if Tab key is not focus traversal key\n+@key headful\n+@run main ConsumedTabKeyTest\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.TextField;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ConsumedTabKeyTest extends Panel {\n+    TextField text;\n+    Button button = new Button(\"none\");\n+    Semaphore focusSema = new Semaphore();\n+    Semaphore releaseSema = new Semaphore();\n+    Semaphore buttonFocusSema = new Semaphore();\n+    Robot robot;\n+    volatile boolean keyTyped;\n+    volatile boolean hasFocus;\n+    static Frame frame;\n+\n+    public void init() {\n+        this.setLayout(new FlowLayout());\n+        text = new TextField();\n+\n+        text.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent e) {\n+                focusSema.raise();\n+            }\n+        });\n+        button.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent e) {\n+                buttonFocusSema.raise();\n+            }\n+        });\n+        add(text);\n+        add(button);\n+        setSize(200, 200);\n+        setVisible(true);\n+        validate();\n+        Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {\n+            public void eventDispatched(AWTEvent e) {\n+                if (e.getID() == KeyEvent.KEY_RELEASED) {\n+                    releaseSema.raise();\n+                }\n+                if (e.getID() == KeyEvent.KEY_TYPED) {\n+                    keyTyped = true;\n+                }\n+            }\n+        }, InputEvent.KEY_EVENT_MASK);\n+        try {\n+            robot = new Robot();\n+        } catch (Exception re) {\n+            throw new RuntimeException(\"Couldn't create Robot\");\n+        }\n+    }\n+\n+    public void start() throws InterruptedException,\n+            InvocationTargetException {\n+        EventQueue.invokeAndWait(() -> {\n+            if (!text.isFocusOwner()) {\n+                text.requestFocus();\n+            }\n+\n+            text.setFocusTraversalKeysEnabled(false);\n+        });\n+\n+        try {\n+            focusSema.doWait(1000);\n+        } catch (InterruptedException ie1) {\n+            throw new RuntimeException(\"Interrupted\");\n+        }\n+\n+        EventQueue.invokeAndWait(() -> {\n+            hasFocus = text.isFocusOwner();\n+        });\n+\n+        if (!focusSema.getState() && !hasFocus) {\n+            throw new RuntimeException(\"Text didn't receive focus\");\n+        }\n+\n+        robot.keyPress(KeyEvent.VK_TAB);\n+        robot.keyRelease(KeyEvent.VK_TAB);\n+        try {\n+            releaseSema.doWait(1000);\n+        } catch (InterruptedException ie2) {\n+            throw new RuntimeException(\"Interrupted\");\n+        }\n+\n+        if (!releaseSema.getState()) {\n+            throw new RuntimeException(\"KEY_RELEASED hasn't arrived\");\n+        }\n+\n+        if (!keyTyped) {\n+            throw new RuntimeException(\"KEY_TYPED for Tab key hasn't arrived\");\n+        }\n+\n+        EventQueue.invokeAndWait(() -> {\n+            text.setFocusTraversalKeysEnabled(true);\n+        });\n+\n+        releaseSema.setState(false);\n+        robot.keyPress(KeyEvent.VK_TAB);\n+        robot.keyRelease(KeyEvent.VK_TAB);\n+        try {\n+            buttonFocusSema.doWait(1000);\n+            releaseSema.doWait(1000);\n+        } catch (InterruptedException ie2) {\n+            throw new RuntimeException(\"Interrupted\");\n+        }\n+\n+        EventQueue.invokeAndWait(() -> {\n+            hasFocus = button.isFocusOwner();\n+        });\n+\n+        if (!buttonFocusSema.getState() && !hasFocus) {\n+            throw new RuntimeException(\"Button hasn't received focus\");\n+        }\n+        keyTyped = false;\n+        releaseSema.setState(false);\n+        robot.keyPress(KeyEvent.VK_A);\n+        robot.keyRelease(KeyEvent.VK_A);\n+        try {\n+            releaseSema.doWait(1000);\n+        } catch (InterruptedException ie2) {\n+            throw new RuntimeException(\"Interrupted\");\n+        }\n+\n+        if (!releaseSema.getState()) {\n+            throw new RuntimeException(\"KEY_RELEASED hasn't arrived\");\n+        }\n+        if (!keyTyped) {\n+            throw new RuntimeException(\"KEY_TYPED for A key hasn't arrived\");\n+        }\n+        System.err.println(\"PASSED\");\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        ConsumedTabKeyTest test = new ConsumedTabKeyTest();\n+\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame(\"InvocationTargetException\");\n+                frame.setLayout(new BorderLayout());\n+                frame.add(test, BorderLayout.CENTER);\n+                test.init();\n+                frame.setLocationRelativeTo(null);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            test.start();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n+\n+class Semaphore {\n+    boolean state = false;\n+    int waiting = 0;\n+\n+    public void doWait(int timeout) throws InterruptedException {\n+        synchronized (this) {\n+            if (state) return;\n+            waiting++;\n+            wait(timeout);\n+            waiting--;\n+        }\n+    }\n+\n+    public void raise() {\n+        synchronized (this) {\n+            state = true;\n+            if (waiting > 0) {\n+                notifyAll();\n+            }\n+        }\n+    }\n+\n+    public boolean getState() {\n+        synchronized (this) {\n+            return state;\n+        }\n+    }\n+\n+    public void setState(boolean newState) {\n+        synchronized (this) {\n+            state = newState;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/ConsumedTabKeyTest.java","additions":232,"deletions":0,"binary":false,"changes":232,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 4846162 4626092\n+  @summary (Key|Window|Focus)Events should not be retargeted when dispatchEvent() is called directly.\n+  @run main EventRetargetTest\n+*\/\n+\n+import java.awt.AWTEvent;\n+import java.awt.Component;\n+import java.awt.Toolkit;\n+import java.awt.event.AWTEventListener;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.event.KeyAdapter;\n+import java.awt.event.KeyEvent;\n+\n+public class EventRetargetTest {\n+    boolean isKEProcessed1;\n+    boolean isKEProcessed2;\n+    boolean isKEProcessed3;\n+    boolean isFEProcessed1;\n+    boolean isFEProcessed2;\n+    boolean isFEProcessed3;\n+\n+    public void start () {\n+        final Component comp = new Component() {\n+                public boolean isShowing() {\n+                    return true;\n+                }\n+\n+                public boolean isVisible() {\n+                    return true;\n+                }\n+\n+                public boolean isDisplayable() {\n+                    return true;\n+                }\n+\n+                protected void processKeyEvent(KeyEvent e) {\n+                    System.err.println(\"processKeyEvent >> \" + e);\n+                    isKEProcessed1 = true;\n+                    super.processKeyEvent(e);\n+                }\n+\n+                protected void processFocusEvent(FocusEvent e) {\n+                    System.err.println(\"processFocusEvent >> \" + e);\n+                    isFEProcessed1 = true;\n+                    super.processFocusEvent(e);\n+                }\n+            };\n+        Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {\n+                public void eventDispatched(AWTEvent e) {\n+                    if (e instanceof KeyEvent) {\n+                        isKEProcessed2 = (e.getSource() == comp);\n+                    }\n+                    else if (e instanceof FocusEvent) {\n+                        isFEProcessed2 = (e.getSource() == comp);\n+                    }\n+                    System.err.println(\"Toolkit >> \" + e);\n+                }\n+            }, AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);\n+\n+        comp.addKeyListener(new KeyAdapter() {\n+                public void keyTyped(KeyEvent e) {\n+                    isKEProcessed3 = true;\n+                    System.err.println(\"Listener >> \" + e);\n+                }\n+            });\n+        comp.addFocusListener(new FocusAdapter() {\n+                public void focusGained(FocusEvent e) {\n+                    isFEProcessed3 = true;\n+                    System.err.println(\"Listener >> \" + e);\n+                }\n+            });\n+\n+        KeyEvent ke = new KeyEvent(comp, KeyEvent.KEY_TYPED, System.currentTimeMillis(), 0,\n+                                   KeyEvent.VK_UNDEFINED, 'a');\n+        comp.dispatchEvent(ke);\n+\n+        if (!(isKEProcessed1 && isKEProcessed2 && isKEProcessed3)) {\n+            System.err.println(\"(\" + isKEProcessed1 + \",\" + isKEProcessed2\n+                    + \",\" + isKEProcessed3 + \")\");\n+            throw new RuntimeException(\"KeyEvent is not correctly retargeted.\");\n+        }\n+\n+        FocusEvent fe = new FocusEvent(comp, FocusEvent.FOCUS_GAINED,\n+                                       false, null);\n+        comp.dispatchEvent(fe);\n+\n+        if (!(isFEProcessed1 && isFEProcessed2 && isFEProcessed3)) {\n+            System.err.println(\"(\" + isFEProcessed1 + \",\"\n+                    + isFEProcessed2 + \",\" + isFEProcessed3 + \")\");\n+            throw new RuntimeException(\"FocusEvent is not correctly retargeted.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        EventRetargetTest test = new EventRetargetTest();\n+        test.start();\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/EventRetargetTest.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,113 @@\n+\/*\n+ * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+  @test\n+  @bug 5072554\n+  @summary Tests that vetoing focus doesn't generate extra PropertyChange notification.\n+  @key headful\n+  @run main ExtraPropChangeNotifVetoingTest\n+*\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Button;\n+import java.awt.EventQueue;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.KeyboardFocusManager;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyVetoException;\n+import java.beans.VetoableChangeListener;\n+import java.lang.reflect.InvocationTargetException;\n+\n+public class ExtraPropChangeNotifVetoingTest extends Panel {\n+    Button one = new Button(\"One\");\n+    Button two = new Button(\"Two\");\n+    Robot robot;\n+    static Frame frame;\n+\n+    int i = 0;\n+\n+    public void init() {\n+        try {\n+            robot = new Robot();\n+        } catch (AWTException e) {\n+            throw new RuntimeException(\"Error: unable to create robot\", e);\n+        }\n+\n+        setLayout(new FlowLayout());\n+        add(one);\n+        add(two);\n+\n+        KeyboardFocusManager.getCurrentKeyboardFocusManager().\n+                addVetoableChangeListener(\"permanentFocusOwner\",\n+                        new VetoableChangeListener() {\n+                    public void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException {\n+                        System.out.println((i++) + \". Old=\" + e.getOldValue() + \", New=\" + e.getNewValue());\n+\n+                        if (e.getOldValue() == e.getNewValue()) {\n+                            throw new RuntimeException(\"Test failed!\");\n+                        }\n+\n+                        if (e.getNewValue() == two) {\n+                            System.out.println(\"VETOING\");\n+                            throw new PropertyVetoException(\"vetoed\", e);\n+                        }\n+                    }\n+                });\n+        setVisible(true);\n+    }\n+\n+    public void start() throws InterruptedException, InvocationTargetException {\n+        EventQueue.invokeAndWait(one::requestFocusInWindow);\n+        robot.waitForIdle();\n+        robot.delay(200);\n+        EventQueue.invokeAndWait(two::requestFocusInWindow);\n+        robot.waitForIdle();\n+        robot.delay(200);\n+    }\n+\n+    public static void main(String[] args) throws InterruptedException,\n+            InvocationTargetException {\n+        ExtraPropChangeNotifVetoingTest test = new ExtraPropChangeNotifVetoingTest();\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame(\"ExtraPropChangeNotifVetoingTest\");\n+                frame.setLayout(new BorderLayout());\n+                frame.add(test, BorderLayout.CENTER);\n+                test.init();\n+                frame.setLocationRelativeTo(null);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+            test.start();\n+        } finally {\n+            if (frame != null) {\n+                EventQueue.invokeAndWait(frame::dispose);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Focus\/ExtraPropChangeNotifVetoingTest.java","additions":113,"deletions":0,"binary":false,"changes":113,"status":"added"}]}