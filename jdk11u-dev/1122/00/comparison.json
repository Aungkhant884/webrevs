{"files":[{"patch":"@@ -0,0 +1,410 @@\n+\/*\n+ * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+import sun.misc.Unsafe;\n+import java.util.Random;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import static java.lang.Math.abs;\n+import static java.lang.Math.pow;\n+import static java.lang.Math.round;\n+import static java.math.BigInteger.TEN;\n+import java.lang.reflect.Field;\n+import java.math.BigInteger;\n+import java.nio.ByteOrder;\n+import static java.lang.String.format;\n+import static java.lang.System.arraycopy;\n+\n+\/* @test\n+ * @bug 8235385\n+ * @summary Verifies non-volatile memory access with long offset\n+ * @requires os.arch == \"aarch64\"\n+ *\/\n+public class NonVolatileMemoryAccessWithLongOffset {\n+    private static final Unsafe unsafe;\n+    static Random random = new Random();\n+\n+    static {\n+        Field f = null;\n+        try {\n+            f = Unsafe.class.getDeclaredField(\"theUnsafe\");\n+            f.setAccessible(true);\n+            unsafe = (Unsafe) f.get(null);\n+        } catch (ReflectiveOperationException e) {\n+            throw new Error(e);\n+        }\n+    }\n+    private static final int MAX_LENGTH = 10000;\n+\n+    private static byte[] input0 = new byte[MAX_LENGTH];\n+    private static byte[] input1 = new byte[MAX_LENGTH];\n+    private static final int MAX_VALUE_LENGTH = random.nextInt(200) + 20;\n+    private static final byte[] maxValue = new byte[MAX_VALUE_LENGTH];\n+    private static final byte[] minValue = new byte[MAX_VALUE_LENGTH];\n+    private static final int DECIMAL_MAX_VALUE_LENGTH = MAX_VALUE_LENGTH - 15;\n+    private static byte[] byteArray;\n+\n+    private static final    int valueType = random.nextInt(100);\n+    private static final    int numNulls = random.nextInt(100);\n+    private static final    int numRows = random.nextInt(100);\n+    private static final    int countDistinct = random.nextInt(100);\n+    private static final    long rawDataSize = (long)random.nextInt(100);\n+    private static final    long sum = (long)random.nextInt(1000);\n+    private static final    int version = random.nextInt(100);\n+\n+\n+    private static final    int dictOffset = random.nextInt(100);\n+    private static final    int dictLength = random.nextInt(100);\n+    private static final    int histOffset = random.nextInt(100);\n+    private static final    int histLength = random.nextInt(100);\n+    private static final    int dpnOffset = random.nextInt(100);\n+    private static final    int dpnCount = random.nextInt(100);\n+\n+    private static final    long maxRowCount = (long)random.nextInt(1000);\n+    private static final    long minRowCount = (long)random.nextInt(1000);\n+    private static final    long totalRowCount = (long)random.nextInt(100);\n+    private static final    long maxMemSize = (long)random.nextInt(1000);\n+    private static final    long minMemSize = (long)random.nextInt(100);\n+    private static final    long totalMemSize = (long)random.nextInt(1000);\n+\n+    private static final    long toastOffset = (long)random.nextInt(1000);\n+    private static final    boolean hasToast = random.nextInt(100) > 50;\n+\n+\n+    private static final int MAX_STRING_LENGTH = random.nextInt(300) + 20;\n+    private static final byte[] maxString = new byte[MAX_STRING_LENGTH];\n+    private static final byte[] minString = new byte[MAX_STRING_LENGTH];\n+    private static int maxStringLength = random.nextInt(100);\n+    private static int minStringLength = random.nextInt(100);\n+    private static final boolean maxStringIsNull = random.nextInt(100) > 20;\n+    private static final boolean minStringIsNull = random.nextInt(100) > 60;\n+\n+    private static final short precision = (short)random.nextInt(100);\n+    private static final short scale = (short)random.nextInt(100);\n+    private static final boolean    useShortCompressFloat = random.nextInt(100) > 60;\n+    private static final int SHORT_SIZE = 2;\n+    private static final int CHAR_SIZE = 2;\n+    private static final int INT_SIZE = 4;\n+    private static final int LONG_SIZE = 8;\n+    private static final int FLOAT_SIZE = 4;\n+    private static final int DOUBLE_SIZE = 8;\n+    private static final int    BOOLEAN_SIZE = 1;\n+\n+    private static void premitiveAssert(boolean flag) {\n+        if (flag == false) {\n+            throw new RuntimeException(\"overflow!\");\n+        }\n+    }\n+\n+    private static long BYTE_ARRAY_OFFSET = unsafe.ARRAY_BYTE_BASE_OFFSET;\n+\n+\n+    public static final void toBytes(short obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         SHORT_SIZE));\n+        unsafe.putShort(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(int obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         INT_SIZE));\n+        unsafe.putInt(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(long obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         LONG_SIZE));\n+        unsafe.putLong(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(float obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         FLOAT_SIZE));\n+        unsafe.putFloat(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(double obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         DOUBLE_SIZE));\n+        unsafe.putDouble(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(char obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         CHAR_SIZE));\n+        unsafe.putChar(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    public static final void toBytes(boolean obj, byte[] rawBytes, int start) {\n+        premitiveAssert(rawBytes.length >= (start +         1));\n+        unsafe.putBoolean(rawBytes, (long) BYTE_ARRAY_OFFSET + start, obj);\n+    }\n+\n+    private static int bytesSize() {\n+        return MAX_LENGTH;\n+    }\n+    static byte[] toBytesDup() {\n+        byte[] rawBytes = input1;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+\n+    static byte[] toBytes() {\n+        byte[] rawBytes = input0;\n+\n+        int offset = 0;\n+\n+        toBytes(valueType, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numNulls, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(numRows, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(countDistinct, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(rawDataSize, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        toBytes(sum, rawBytes, offset);\n+        offset +=         LONG_SIZE;\n+\n+        \/\/if (version.getVersion() < DetailColumn.VERSION_EIGHT) {\n+        if (version > 50) {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, MAX_VALUE_LENGTH);\n+            offset += MAX_VALUE_LENGTH;\n+        } else {\n+            System.arraycopy(maxValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+\n+            System.arraycopy(minValue, 0, rawBytes, offset, DECIMAL_MAX_VALUE_LENGTH);\n+            offset += DECIMAL_MAX_VALUE_LENGTH;\n+        }\n+\n+        toBytes(dictOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dictLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(histLength, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnOffset, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        toBytes(dpnCount, rawBytes, offset);\n+        offset +=         INT_SIZE;\n+\n+        if (version >= 60) {\n+            toBytes(maxRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalRowCount, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(maxMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(minMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+\n+            toBytes(totalMemSize, rawBytes, offset);\n+            offset +=         LONG_SIZE;\n+        }\n+\n+       if (version >= 65) {\n+           toBytes(toastOffset, rawBytes, offset);\n+           offset +=         LONG_SIZE;\n+           toBytes(hasToast, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 70) {\n+          System.arraycopy(maxString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          System.arraycopy(minString, 0, rawBytes, offset, MAX_STRING_LENGTH);\n+          offset += MAX_STRING_LENGTH;\n+\n+          toBytes(maxStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(minStringLength, rawBytes, offset);\n+          offset +=         INT_SIZE;\n+\n+          toBytes(maxStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+\n+          toBytes(minStringIsNull, rawBytes, offset);\n+          offset +=         BOOLEAN_SIZE;\n+       }\n+\n+       if (version >= 75) {\n+           toBytes(precision, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+\n+           toBytes(scale, rawBytes, offset);\n+           offset +=         SHORT_SIZE;\n+       }\n+\n+       if (version >= 80) {\n+           toBytes(useShortCompressFloat, rawBytes, offset);\n+           offset +=         BOOLEAN_SIZE;\n+       }\n+        return rawBytes;\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        long s = 0, s1 = 0;\n+        for (int i = 0; i < input0.length; i++) {\n+            input0[i] = 0;\n+            input1[i] = 0;\n+        }\n+        for (int i = 0; i < 100000; i++) {\n+            s += toBytes()[0];\n+            s1 += toBytesDup()[0];\n+            for (int j = 0; j < input0.length; j++) {\n+                if (input0[j] != input1[j]) {\n+                    throw new RuntimeException(\"not match!\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/unsafe\/NonVolatileMemoryAccessWithLongOffset.java","additions":410,"deletions":0,"binary":false,"changes":410,"status":"added"}]}