{"files":[{"patch":"@@ -45,0 +45,3 @@\n+const char* C2Compiler::retry_no_locks_coarsening() {\n+  return \"retry without locks coarsening\";\n+}\n@@ -107,0 +110,1 @@\n+  bool do_locks_coarsening = EliminateLocks;\n@@ -110,1 +114,1 @@\n-    Compile C(env, this, target, entry_bci, subsume_loads, do_escape_analysis, eliminate_boxing, directive);\n+    Compile C(env, this, target, entry_bci, subsume_loads, do_escape_analysis, eliminate_boxing, do_locks_coarsening, directive);\n@@ -130,0 +134,6 @@\n+      if (C.failure_reason_is(retry_no_locks_coarsening())) {\n+        assert(do_locks_coarsening, \"must make progress\");\n+        do_locks_coarsening = false;\n+        env->report_failure(C.failure_reason());\n+        continue;  \/\/ retry\n+      }\n@@ -151,0 +161,4 @@\n+      if (do_locks_coarsening) {\n+        do_locks_coarsening = false;\n+        continue;  \/\/ retry\n+      }\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+  static const char* retry_no_locks_coarsening();\n","filename":"src\/hotspot\/share\/opto\/c2compiler.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1775,0 +1775,6 @@\n+const char* AbstractLockNode::_kind_names[] = {\"Regular\", \"NonEscObj\", \"Coarsened\", \"Nested\"};\n+\n+const char * AbstractLockNode::kind_as_string() const {\n+  return _kind_names[_kind];\n+}\n+\n@@ -1792,2 +1798,0 @@\n-const char* AbstractLockNode::_kind_names[] = {\"Regular\", \"NonEscObj\", \"Coarsened\", \"Nested\"};\n-\n@@ -1845,0 +1849,3 @@\n+    if (!phase->C->do_locks_coarsening()) {\n+      return result; \/\/ Compiling without locks coarsening\n+    }\n@@ -1882,0 +1889,3 @@\n+          if (Verbose) {\n+            tty->print_cr(\"=== Locks coarsening ===\");\n+          }\n@@ -1889,1 +1899,2 @@\n-              lock->dump(1);\n+              tty->print(\" %d: \", i);\n+              lock->dump();\n@@ -1892,1 +1903,1 @@\n-          tty->print_cr(\"***Eliminated %d unlocks and %d locks\", unlocks, locks);\n+          tty->print_cr(\"=== Coarsened %d unlocks and %d locks\", unlocks, locks);\n@@ -1907,0 +1918,2 @@\n+        \/\/ Record this coarsened group.\n+        phase->C->add_coarsened_locks(lock_ops);\n@@ -1940,1 +1953,2 @@\n-  if (!box->is_simple_lock_region(&unique_lock, obj)) {\n+  Node* bad_lock = NULL;\n+  if (!box->is_simple_lock_region(&unique_lock, obj, &bad_lock)) {\n@@ -1942,1 +1956,1 @@\n-    this->log_lock_optimization(c, \"eliminate_lock_INLR_2a\");\n+    this->log_lock_optimization(c, \"eliminate_lock_INLR_2a\", bad_lock);\n@@ -1948,1 +1962,19 @@\n-    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\");\n+    this->log_lock_optimization(c, \"eliminate_lock_INLR_2b\", (unique_lock != NULL ? unique_lock : bad_lock));\n+    if (PrintEliminateLocks && Verbose) {\n+      tty->print_cr(\"=============== unique_lock != this ============\");\n+      tty->print(\" this: \");\n+      this->dump();\n+      tty->print(\" box: \");\n+      box->dump();\n+      tty->print(\" obj: \");\n+      obj->dump();\n+      if (unique_lock != NULL) {\n+        tty->print(\" unique_lock: \");\n+        unique_lock->dump();\n+      }\n+      if (bad_lock != NULL) {\n+        tty->print(\" bad_lock: \");\n+        bad_lock->dump();\n+      }\n+      tty->print_cr(\"===============\");\n+    }\n@@ -2015,8 +2047,1 @@\n-const char * AbstractLockNode::kind_as_string() const {\n-  return is_coarsened()   ? \"coarsened\" :\n-         is_nested()      ? \"nested\" :\n-         is_non_esc_obj() ? \"non_escaping\" :\n-         \"?\";\n-}\n-\n-void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag)  const {\n+void AbstractLockNode::log_lock_optimization(Compile *C, const char * tag, Node* bad_lock)  const {\n@@ -2028,2 +2053,7 @@\n-    log->begin_head(\"%s lock='%d' compile_id='%d' class_id='%s' kind='%s'\",\n-          tag, is_Lock(), C->compile_id(),\n+    Node* box = box_node();\n+    Node* obj = obj_node();\n+    int box_id = box != NULL ? box->_idx : -1;\n+    int obj_id = obj != NULL ? obj->_idx : -1;\n+\n+    log->begin_head(\"%s compile_id='%d' lock_id='%d' class='%s' kind='%s' box_id='%d' obj_id='%d' bad_id='%d'\",\n+          tag, C->compile_id(), this->_idx,\n@@ -2031,1 +2061,1 @@\n-          kind_as_string());\n+          kind_as_string(), box_id, obj_id, (bad_lock != NULL ? bad_lock->_idx : -1));\n","filename":"src\/hotspot\/share\/opto\/callnode.cpp","additions":48,"deletions":18,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -988,0 +988,3 @@\n+\n+  static const char* _kind_names[Nested+1];\n+\n@@ -990,1 +993,0 @@\n-  static const char* _kind_names[Nested+1];\n@@ -1033,1 +1035,1 @@\n-  void log_lock_optimization(Compile* c, const char * tag) const;\n+  void log_lock_optimization(Compile* c, const char * tag, Node* bad_lock = NULL) const;\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -426,0 +426,1 @@\n+  remove_useless_coarsened_locks(useful);            \/\/ remove useless coarsened locks nodes\n@@ -515,0 +516,6 @@\n+  if ((_do_locks_coarsening != EliminateLocks) && PrintOpto) {\n+    \/\/ Recompiling without locks coarsening\n+    tty->print_cr(\"*********************************************************\");\n+    tty->print_cr(\"** Bailout: Recompile without locks coarsening         **\");\n+    tty->print_cr(\"*********************************************************\");\n+  }\n@@ -640,1 +647,2 @@\n-                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)\n+                  bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing,\n+                  bool do_locks_coarsening, DirectiveSet* directive)\n@@ -647,0 +655,1 @@\n+                  _do_locks_coarsening(do_locks_coarsening),\n@@ -671,0 +680,1 @@\n+                  _coarsened_locks   (comp_arena(), 8, 0, NULL),\n@@ -970,0 +980,1 @@\n+    _do_locks_coarsening(false),\n@@ -4722,0 +4733,95 @@\n+\/**\n+ * Track coarsened Lock and Unlock nodes.\n+ *\/\n+\n+class Lock_List : public Node_List {\n+  uint _origin_cnt;\n+public:\n+  Lock_List(Arena *a, uint cnt) : Node_List(a), _origin_cnt(cnt) {}\n+  uint origin_cnt() const { return _origin_cnt; }\n+};\n+\n+void Compile::add_coarsened_locks(GrowableArray<AbstractLockNode*>& locks) {\n+  int length = locks.length();\n+  if (length > 0) {\n+    \/\/ Have to keep this list until locks elimination during Macro nodes elimination.\n+    Lock_List* locks_list = new (comp_arena()) Lock_List(comp_arena(), length);\n+    for (int i = 0; i < length; i++) {\n+      AbstractLockNode* lock = locks.at(i);\n+      assert(lock->is_coarsened(), \"expecting only coarsened AbstractLock nodes, but got '%s'[%d] node\", lock->Name(), lock->_idx);\n+      locks_list->push(lock);\n+    }\n+    _coarsened_locks.append(locks_list);\n+  }\n+}\n+\n+void Compile::remove_useless_coarsened_locks(Unique_Node_List& useful) {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    Node_List* locks_list = _coarsened_locks.at(i);\n+    for (uint j = 0; j < locks_list->size(); j++) {\n+      Node* lock = locks_list->at(j);\n+      assert(lock->is_AbstractLock(), \"sanity\");\n+      if (!useful.member(lock)) {\n+        locks_list->yank(lock);\n+      }\n+    }\n+  }\n+}\n+\n+void Compile::remove_coarsened_lock(Node* n) {\n+  if (n->is_AbstractLock()) {\n+    int count = coarsened_count();\n+    for (int i = 0; i < count; i++) {\n+      Node_List* locks_list = _coarsened_locks.at(i);\n+      locks_list->yank(n);\n+    }\n+  }\n+}\n+\n+bool Compile::coarsened_locks_consistent() {\n+  int count = coarsened_count();\n+  for (int i = 0; i < count; i++) {\n+    bool unbalanced = false;\n+    bool modified = false; \/\/ track locks kind modifications\n+    Lock_List* locks_list = (Lock_List*)_coarsened_locks.at(i);\n+    uint size = locks_list->size();\n+    if (size != locks_list->origin_cnt()) {\n+      unbalanced = true; \/\/ Some locks were removed from list\n+    } else {\n+      for (uint j = 0; j < size; j++) {\n+        Node* lock = locks_list->at(j);\n+        \/\/ All nodes in group should have the same state (modified or not)\n+        if (!lock->as_AbstractLock()->is_coarsened()) {\n+          if (j == 0) {\n+            \/\/ first on list was modified, the rest should be too for consistency\n+            modified = true;\n+          } else if (!modified) {\n+            \/\/ this lock was modified but previous locks on the list were not\n+            unbalanced = true;\n+            break;\n+          }\n+        } else if (modified) {\n+          \/\/ previous locks on list were modified but not this lock\n+          unbalanced = true;\n+          break;\n+        }\n+      }\n+    }\n+    if (unbalanced) {\n+      \/\/ unbalanced monitor enter\/exit - only some [un]lock nodes were removed or modified\n+#ifdef ASSERT\n+      if (PrintEliminateLocks) {\n+        tty->print_cr(\"=== unbalanced coarsened locks ===\");\n+        for (uint l = 0; l < size; l++) {\n+          locks_list->at(l)->dump();\n+        }\n+      }\n+#endif\n+      record_failure(C2Compiler::retry_no_locks_coarsening());\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":107,"deletions":1,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -48,0 +48,1 @@\n+class AbstractLockNode;\n@@ -66,0 +67,1 @@\n+class Node_List;\n@@ -367,0 +369,1 @@\n+  const bool            _do_locks_coarsening;   \/\/ Do locks coarsening\n@@ -434,0 +437,1 @@\n+  GrowableArray<Node_List*> _coarsened_locks;   \/\/ List of coarsened Lock and Unlock nodes\n@@ -640,0 +644,2 @@\n+  \/** Do locks coarsening. *\/\n+  bool              do_locks_coarsening() const { return _do_locks_coarsening; }\n@@ -789,0 +795,1 @@\n+  int           coarsened_count()         const { return _coarsened_locks.length(); }\n@@ -808,0 +815,4 @@\n+    \/\/ Remove from coarsened locks list if present\n+    if (coarsened_count() > 0) {\n+      remove_coarsened_lock(n);\n+    }\n@@ -832,0 +843,3 @@\n+  void add_coarsened_locks(GrowableArray<AbstractLockNode*>& locks);\n+  void remove_coarsened_lock(Node* n);\n+  bool coarsened_locks_consistent();\n@@ -1083,0 +1097,2 @@\n+  void remove_useless_coarsened_locks(Unique_Node_List& useful);\n+\n@@ -1189,1 +1205,2 @@\n-          bool eliminate_boxing, DirectiveSet* directive);\n+          bool eliminate_boxing, bool do_locks_coarsening,\n+          DirectiveSet* directive);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-bool BoxLockNode::is_simple_lock_region(LockNode** unique_lock, Node* obj) {\n+bool BoxLockNode::is_simple_lock_region(LockNode** unique_lock, Node* obj, Node** bad_lock) {\n@@ -105,0 +105,3 @@\n+              if (bad_lock != NULL) {\n+                *bad_lock = alock;\n+              }\n@@ -108,0 +111,3 @@\n+          if (bad_lock != NULL) {\n+            *bad_lock = alock;\n+          }\n","filename":"src\/hotspot\/share\/opto\/locknode.cpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-  bool is_simple_lock_region(LockNode** unique_lock, Node* obj);\n+  bool is_simple_lock_region(LockNode** unique_lock, Node* obj, Node** bad_lock);\n","filename":"src\/hotspot\/share\/opto\/locknode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2020,1 +2020,1 @@\n-  if (oldbox->as_BoxLock()->is_eliminated())\n+  if (oldbox->as_BoxLock()->is_eliminated()) {\n@@ -2022,1 +2022,1 @@\n-\n+  }\n@@ -2028,1 +2028,1 @@\n-      oldbox->as_BoxLock()->is_simple_lock_region(NULL, obj)) {\n+      oldbox->as_BoxLock()->is_simple_lock_region(NULL, obj, NULL)) {\n@@ -2200,5 +2200,1 @@\n-    if (alock->is_Lock()) {\n-      tty->print_cr(\"++++ Eliminated: %d Lock\", alock->_idx);\n-    } else {\n-      tty->print_cr(\"++++ Eliminated: %d Unlock\", alock->_idx);\n-    }\n+    tty->print_cr(\"++++ Eliminated: %d %s '%s'\", alock->_idx, (alock->is_Lock() ? \"Lock\" : \"Unlock\"), alock->kind_as_string());\n@@ -2576,1 +2572,2 @@\n-  \/\/ First, attempt to eliminate locks\n+  \/\/ Before elimination may re-mark (change to Nested or NonEscObj)\n+  \/\/ all associated (same box and obj) lock and unlock nodes.\n@@ -2581,2 +2578,0 @@\n-      \/\/ Before elimination mark all associated (same box and obj)\n-      \/\/ lock and unlock nodes.\n@@ -2586,0 +2581,6 @@\n+  \/\/ Re-marking may break consistency of Coarsened locks.\n+  if (!C->coarsened_locks_consistent()) {\n+    return; \/\/ recompile without Coarsened locks if broken\n+  }\n+\n+  \/\/ First, attempt to eliminate locks\n@@ -2646,0 +2647,1 @@\n+  if (C->failing())  return true;\n","filename":"src\/hotspot\/share\/opto\/macro.cpp","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -130,0 +130,1 @@\n+  compiler\/locks\/ \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,150 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8268347\n+ * @summary Nested locks optimization may create unbalanced monitor enter\/exit code\n+ *\n+ * @run main\/othervm -XX:-BackgroundCompilation\n+ *                   -XX:CompileCommand=dontinline,TestNestedLocksElimination::foo\n+ *                   -XX:CompileCommand=dontinline,TestNestedLocksElimination::getNext\n+ *                   -XX:CompileCommand=dontinline,TestNestedLocksElimination::getHolder\n+ *                   TestNestedLocksElimination\n+ *\/\n+\n+import java.util.LinkedList;\n+\n+public class TestNestedLocksElimination {\n+\n+    private LinkedList<char[]> buffers = new LinkedList<>();\n+    private boolean complete = false;\n+    private int bufferSize;\n+\n+    void foo(char[] ca) {\n+        \/\/ Don't inline dummy method\n+    }\n+\n+    \/\/ Don't inline\n+    char[] getNext(int length, int count) {\n+        if (this.buffers.isEmpty()) {\n+            return new char[100];\n+        }\n+        char[] b = (char[]) this.buffers.getFirst();\n+        if (count >= 100) {\n+            this.complete = true;\n+            this.buffers.clear(); \/\/ empty\n+        }\n+        return b;\n+    }\n+\n+    synchronized boolean isComplete() {\n+        return this.complete;\n+    }\n+\n+    synchronized boolean availableSegment() {\n+        return (buffers.isEmpty() == false);\n+    }\n+\n+    \/\/ Don't inline\n+    TestNestedLocksElimination getHolder(TestNestedLocksElimination s1, TestNestedLocksElimination s2, int count) {\n+        return (count & 7) == 0 ? s2 : s1;\n+    }\n+\n+    int test(TestNestedLocksElimination s1, TestNestedLocksElimination s2, int maxToSend) {\n+        boolean isComplete = true;\n+        boolean availableSegment = false;\n+        int size = 0;\n+        int count = 0;\n+        do {\n+            TestNestedLocksElimination s = getHolder(s1, s2, count++);\n+\n+            synchronized(s) {\n+                isComplete = s.isComplete();\n+                availableSegment = s.availableSegment();\n+            }\n+\n+            synchronized (this) {\n+                size = 0;\n+                while (size < maxToSend) {\n+                    char[] b = null;\n+                    \/\/ This is outer Lock region for object 's'.\n+                    \/\/ Locks from following inlined methods are \"nested\"\n+                    \/\/ because they reference the same object.\n+                    synchronized(s) {\n+                        b = s.getNext(maxToSend - size, count);\n+\n+                        \/\/ The next is bi-morphic call with both calls inlined.\n+                        \/\/ But one is synchronized and the other is not.\n+                        \/\/ Class check for bi-morphic call is loop invariant\n+                        \/\/ and will trigger loop unswitching.\n+                        \/\/ Loop unswitching will create two versions of loop\n+                        \/\/ with gollowing calls inlinined in both versions.\n+\n+                        isComplete = s.isComplete();\n+\n+                        \/\/ The next synchronized method availableSegment() is\n+                        \/\/ inlined and its Lock will be \"coarsened\" with Unlock\n+                        \/\/ in version of loop with inlined synchronized method\n+                        \/\/ isComplete().\n+                        \/\/ Nested Lock Optimization will mark only this Unlock\n+                        \/\/ as nested (as part of \"nested\" pair lock\/unlock).\n+                        \/\/ Locks elimination will remove \"coarsened\" Lock from\n+                        \/\/ availableSegment() method leaving unmatched unlock.\n+\n+                        availableSegment = s.availableSegment();\n+                    }\n+                    foo(b);\n+                    size += b.length;\n+                }\n+            }\n+      } while (availableSegment == true || isComplete == false);\n+        return size;\n+    }\n+\n+    public static void main(String[] args) {\n+        int count = 0;\n+        int n = 0;\n+\n+        TestNestedLocksElimination t = new TestNestedLocksElimination();\n+        TestNestedLocksElimination s1 = new TestNestedLocksElimination();\n+        TestNestedLocksElimination s2 = new TestNestedLocksEliminationSub();\n+\n+        char[] c = new char[100];\n+        while (n++ < 20_000) {\n+            s1.buffers.add(c);\n+            s2.buffers.add(c);\n+            count += t.test(s1, s2, 10000);\n+        }\n+\n+        System.out.println(\" count: \" + count);\n+    }\n+}\n+\n+class TestNestedLocksEliminationSub extends TestNestedLocksElimination {\n+    public boolean isComplete() {\n+        return true;\n+    }\n+}\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/locks\/TestNestedLocksElimination.java","additions":150,"deletions":0,"binary":false,"changes":150,"status":"added"}]}