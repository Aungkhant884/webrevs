{"files":[{"patch":"@@ -2339,0 +2339,28 @@\n+bool os::Linux::query_process_memory_info(os::Linux::meminfo_t* info) {\n+  FILE* f = os::fopen(\"\/proc\/self\/status\", \"r\");\n+  const int num_values = sizeof(os::Linux::meminfo_t) \/ sizeof(size_t);\n+  int num_found = 0;\n+  char buf[256];\n+  info->vmsize = info->vmpeak = info->vmrss = info->vmhwm = info->vmswap =\n+      info->rssanon = info->rssfile = info->rssshmem = -1;\n+  if (f != NULL) {\n+    while (::fgets(buf, sizeof(buf), f) != NULL && num_found < num_values) {\n+      if ( (info->vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &info->vmsize) == 1) ||\n+           (info->vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &info->vmpeak) == 1) ||\n+           (info->vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &info->vmswap) == 1) ||\n+           (info->vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &info->vmhwm) == 1) ||\n+           (info->vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &info->vmrss) == 1) ||\n+           (info->rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &info->rssanon) == 1) || \/\/ Needs Linux 4.5\n+           (info->rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &info->rssfile) == 1) || \/\/ Needs Linux 4.5\n+           (info->rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &info->rssshmem) == 1)  \/\/ Needs Linux 4.5\n+           )\n+      {\n+        num_found ++;\n+      }\n+    }\n+    fclose(f);\n+    return true;\n+  }\n+  return false;\n+}\n+\n@@ -2373,26 +2401,5 @@\n-  ssize_t vmsize = -1, vmpeak = -1, vmswap = -1,\n-      vmrss = -1, vmhwm = -1, rssanon = -1, rssfile = -1, rssshmem = -1;\n-  const int num_values = 8;\n-  int num_found = 0;\n-  FILE* f = ::fopen(\"\/proc\/self\/status\", \"r\");\n-  char buf[256];\n-  if (f != NULL) {\n-    while (::fgets(buf, sizeof(buf), f) != NULL && num_found < num_values) {\n-      if ( (vmsize == -1    && sscanf(buf, \"VmSize: \" SSIZE_FORMAT \" kB\", &vmsize) == 1) ||\n-           (vmpeak == -1    && sscanf(buf, \"VmPeak: \" SSIZE_FORMAT \" kB\", &vmpeak) == 1) ||\n-           (vmswap == -1    && sscanf(buf, \"VmSwap: \" SSIZE_FORMAT \" kB\", &vmswap) == 1) ||\n-           (vmhwm == -1     && sscanf(buf, \"VmHWM: \" SSIZE_FORMAT \" kB\", &vmhwm) == 1) ||\n-           (vmrss == -1     && sscanf(buf, \"VmRSS: \" SSIZE_FORMAT \" kB\", &vmrss) == 1) ||\n-           (rssanon == -1   && sscanf(buf, \"RssAnon: \" SSIZE_FORMAT \" kB\", &rssanon) == 1) ||\n-           (rssfile == -1   && sscanf(buf, \"RssFile: \" SSIZE_FORMAT \" kB\", &rssfile) == 1) ||\n-           (rssshmem == -1  && sscanf(buf, \"RssShmem: \" SSIZE_FORMAT \" kB\", &rssshmem) == 1)\n-           )\n-      {\n-        num_found ++;\n-      }\n-    }\n-    fclose(f);\n-\n-    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmsize, vmpeak);\n-    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", vmrss, vmhwm);\n-    if (rssanon != -1) { \/\/ requires kernel >= 4.5\n+  meminfo_t info;\n+  if (query_process_memory_info(&info)) {\n+    st->print_cr(\"Virtual Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmsize, info.vmpeak);\n+    st->print(\"Resident Set Size: \" SSIZE_FORMAT \"K (peak: \" SSIZE_FORMAT \"K)\", info.vmrss, info.vmhwm);\n+    if (info.rssanon != -1) { \/\/ requires kernel >= 4.5\n@@ -2400,1 +2407,1 @@\n-                  rssanon, rssfile, rssshmem);\n+                info.rssanon, info.rssfile, info.rssshmem);\n@@ -2403,2 +2410,2 @@\n-    if (vmswap != -1) { \/\/ requires kernel >= 2.6.34\n-      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", vmswap);\n+    if (info.vmswap != -1) { \/\/ requires kernel >= 2.6.34\n+      st->print_cr(\"Swapped out: \" SSIZE_FORMAT \"K\", info.vmswap);\n@@ -2430,1 +2437,1 @@\n-    might_have_wrapped = (vmrss * K) > UINT_MAX && (vmrss * K) > (total_allocated + UINT_MAX);\n+    might_have_wrapped = (info.vmrss * K) > UINT_MAX && (info.vmrss * K) > (total_allocated + UINT_MAX);\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":37,"deletions":30,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -231,0 +231,17 @@\n+  \/\/ Output structure for query_process_memory_info()\n+  struct meminfo_t {\n+    ssize_t vmsize;     \/\/ current virtual size\n+    ssize_t vmpeak;     \/\/ peak virtual size\n+    ssize_t vmrss;      \/\/ current resident set size\n+    ssize_t vmhwm;      \/\/ peak resident set size\n+    ssize_t vmswap;     \/\/ swapped out\n+    ssize_t rssanon;    \/\/ resident set size (anonymous mappings, needs 4.5)\n+    ssize_t rssfile;    \/\/ resident set size (file mappings, needs 4.5)\n+    ssize_t rssshmem;   \/\/ resident set size (shared mappings, needs 4.5)\n+  };\n+\n+  \/\/ Attempts to query memory information about the current process and return it in the output structure.\n+  \/\/ May fail (returns false) or succeed (returns true) but not all output fields are available; unavailable\n+  \/\/ fields will contain -1.\n+  static bool query_process_memory_info(meminfo_t* info);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+#include \"trimCHeapDCmd.hpp\"\n+\n+#include <malloc.h>\n+\n+void TrimCLibcHeapDCmd::execute(DCmdSource source, TRAPS) {\n+#ifdef __GLIBC__\n+  stringStream ss_report(1024); \/\/ Note: before calling trim\n+\n+  os::Linux::meminfo_t info1;\n+  os::Linux::meminfo_t info2;\n+  \/\/ Query memory before...\n+  bool have_info1 = os::Linux::query_process_memory_info(&info1);\n+\n+  _output->print_cr(\"Attempting trim...\");\n+  ::malloc_trim(0);\n+  _output->print_cr(\"Done.\");\n+\n+  \/\/ ...and after trim.\n+  bool have_info2 = os::Linux::query_process_memory_info(&info2);\n+\n+  \/\/ Print report both to output stream as well to UL\n+  bool wrote_something = false;\n+  if (have_info1 && have_info2) {\n+    if (info1.vmsize != -1 && info2.vmsize != -1) {\n+      ss_report.print_cr(\"Virtual size before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmsize, info2.vmsize, (info2.vmsize - info1.vmsize));\n+      wrote_something = true;\n+    }\n+    if (info1.vmrss != -1 && info2.vmrss != -1) {\n+      ss_report.print_cr(\"RSS before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmrss, info2.vmrss, (info2.vmrss - info1.vmrss));\n+      wrote_something = true;\n+    }\n+    if (info1.vmswap != -1 && info2.vmswap != -1) {\n+      ss_report.print_cr(\"Swap before: \" SSIZE_FORMAT \"k, after: \" SSIZE_FORMAT \"k, (\" SSIZE_FORMAT \"k)\",\n+                         info1.vmswap, info2.vmswap, (info2.vmswap - info1.vmswap));\n+      wrote_something = true;\n+    }\n+  }\n+  if (!wrote_something) {\n+    ss_report.print_raw(\"No details available.\");\n+  }\n+\n+  _output->print_raw(ss_report.base());\n+  log_info(os)(\"malloc_trim:\\n%s\", ss_report.base());\n+#else\n+  _output->print_cr(\"Not available.\");\n+#endif\n+}\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.cpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_LINUX_TRIMCHEAPDCMD_HPP\n+#define OS_LINUX_TRIMCHEAPDCMD_HPP\n+\n+#include \"services\/diagnosticCommand.hpp\"\n+\n+class outputStream;\n+\n+class TrimCLibcHeapDCmd : public DCmd {\n+public:\n+  TrimCLibcHeapDCmd(outputStream* output, bool heap) : DCmd(output, heap) {}\n+  static const char* name() {\n+    return \"System.trim_native_heap\";\n+  }\n+  static const char* description() {\n+    return \"Attempts to free up memory by trimming the C-heap.\";\n+  }\n+  static const char* impact() {\n+    return \"Low\";\n+  }\n+  static const JavaPermission permission() {\n+    JavaPermission p = { \"java.lang.management.ManagementPermission\", \"control\", NULL };\n+    return p;\n+  }\n+  virtual void execute(DCmdSource source, TRAPS);\n+};\n+\n+#endif \/\/ OS_LINUX_TRIMCHEAPDCMD_HPP\n","filename":"src\/hotspot\/os\/linux\/trimCHeapDCmd.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -53,1 +53,3 @@\n-\n+#ifdef LINUX\n+#include \"trimCHeapDCmd.hpp\"\n+#endif\n@@ -111,0 +113,3 @@\n+#ifdef LINUX\n+  DCmdFactory::register_DCmdFactory(new DCmdFactoryImpl<TrimCLibcHeapDCmd>(full_export, true, false));\n+#endif \/\/ LINUX\n","filename":"src\/hotspot\/share\/services\/diagnosticCommand.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.annotations.Test;\n+import jdk.test.lib.dcmd.CommandExecutor;\n+import jdk.test.lib.dcmd.JMXExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+\/*\n+ * @test\n+ * @summary Test of diagnostic command VM.trim_libc_heap\n+ * @library \/test\/lib\n+ * @requires os.family == \"linux\"\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.compiler\n+ *          java.management\n+ *          jdk.internal.jvmstat\/sun.jvmstat.monitor\n+ * @run testng TrimLibcHeapTest\n+ *\/\n+public class TrimLibcHeapTest {\n+    public void run(CommandExecutor executor) {\n+        OutputAnalyzer output = executor.execute(\"System.trim_native_heap\");\n+        output.reportDiagnosticSummary();\n+        output.shouldMatch(\"(Done|Not available)\"); \/\/ Not available could happen on Linux + non-glibc (eg. muslc)\n+        if (output.firstMatch(\"Done\") != null) {\n+            output.shouldMatch(\"(Virtual size before|RSS before|Swap before|No details available)\");\n+        }\n+    }\n+\n+    @Test\n+    public void jmx() {\n+        run(new JMXExecutor());\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/dcmd\/vm\/TrimLibcHeapTest.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"}]}