{"files":[{"patch":"@@ -27,1 +27,1 @@\n- * @key stress\n+ * @key stress randomness\n@@ -30,2 +30,1 @@\n- * VM testbase keywords: [stress, quick, feature_283, nonconcurrent, exclude]\n- * VM testbase comments: 8208207\n+ * VM testbase keywords: [stress, quick, feature_283, nonconcurrent]\n@@ -40,3 +39,2 @@\n- *    4. Check isCopy == false\n- *    5. Return from native\n- *    6. Check data to be processed correctly\n+ *    4. Return from native\n+ *    5. Check data to be processed correctly\n@@ -50,1 +48,0 @@\n- * @ignore 8208207\n@@ -231,0 +228,1 @@\n+            javaHash += javaHash;\n@@ -264,1 +262,1 @@\n-\n+            javaHash += javaHash;\n@@ -299,1 +297,1 @@\n-\n+            javaHash += javaHash;\n@@ -334,1 +332,1 @@\n-\n+            javaHash += javaHash;\n@@ -367,1 +365,1 @@\n-\n+            javaHash += javaHash;\n@@ -402,1 +400,1 @@\n-\n+            javaHash += javaHash;\n@@ -437,1 +435,1 @@\n-\n+            javaHash += javaHash;\n@@ -471,1 +469,1 @@\n-\n+            javaHash += javaHash;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/gclocker\/gcl001.java","additions":12,"deletions":14,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+\n@@ -27,1 +28,36 @@\n-extern \"C\" {\n+\/*\n+  basic routine: provide critical sections and calculations\n+    enter array CS\n+    enter first string CS\n+    leave first string CS\n+    enter second string CS\n+    leave array CS\n+    leave second string CS\n+*\/\n+#define BODY(type)                                                          \\\n+  int hash = 0;                                                             \\\n+  jsize i, arraySize, stringSize;                                           \\\n+  jchar *nativeStr = NULL;                                                  \\\n+  type *nativeArray = NULL;                                                 \\\n+                                                                            \\\n+  arraySize = env->GetArrayLength(array); CE                                \\\n+  stringSize = env->GetStringLength(str); CE                                \\\n+                                                                            \\\n+  nativeArray = (type *)env->GetPrimitiveArrayCritical(array, NULL); CE     \\\n+  qsort(nativeArray, arraySize, sizeof(type), *type##comp);                 \\\n+                                                                            \\\n+  nativeStr = (jchar *)env->GetStringCritical(str, NULL); CE                \\\n+                                                                            \\\n+  for (i = 0; i < stringSize; ++i)                                          \\\n+    hash += (int)nativeStr[i];                                              \\\n+  env->ReleaseStringCritical(str, nativeStr); CE                            \\\n+                                                                            \\\n+  nativeStr = (jchar *)env->GetStringCritical(str, NULL); CE                \\\n+                                                                            \\\n+  env->ReleasePrimitiveArrayCritical(array, nativeArray, 0); CE             \\\n+                                                                            \\\n+  for (i = 0; i < stringSize; ++i)                                          \\\n+    hash += (int)nativeStr[i];                                              \\\n+  env->ReleaseStringCritical(str, nativeStr); CE                            \\\n+                                                                            \\\n+  return hash;\n@@ -30,74 +66,11 @@\n-#define COMP(type) \\\n-int type##comp(const void *s1, const void *s2)\\\n-{\\\n-    type st1 = *((type *)s1);\\\n-    type st2 = *((type *)s2);\\\n-    if (st1 < st2)\\\n-        return -1;\\\n-    else if (st1 > st2)\\\n-        return 1;\\\n-    else\\\n-        return 0;\\\n-}\n-\n-\/\/ basic routine: provide critical sections and calculations\n-    \/\/ enter array CS\n-    \/\/ check isCopy for native referencing\n-    \/\/ enter first string CS\n-    \/\/ leave first string CS\n-    \/\/ enter second string CS\n-    \/\/ leave array CS\n-    \/\/ enter second string CS\n-\n-#define BODY(type) \\\n-int hash = 0; int i; jboolean isCopy = JNI_FALSE; jchar *nativeStr; jsize size; type *nativeArray; \\\n-size = env->GetArrayLength(array); CE \\\n-nativeArray = (type *)env->GetPrimitiveArrayCritical(array, &isCopy); CE \\\n-EnterCS(env); \\\n-if (isCopy == JNI_TRUE) return 0;\\\n-qsort(nativeArray, size, sizeof(type), *type##comp);\\\n-\\\n-size = env->GetStringLength(str); CE \\\n-nativeStr = (jchar *)env->GetStringCritical(str, &isCopy); CE \\\n-if (isCopy == JNI_TRUE) return 0;\\\n-for (i = 0; i < size; ++i)\\\n-    hash += (int)nativeStr[i];\\\n-\\\n-env->ReleasePrimitiveArrayCritical(array, nativeArray, 0); CE \\\n-LeaveCS(env); \\\n-env->ReleaseStringCritical(str, nativeStr); CE \\\n-\\\n-hash = 0;\\\n-size = env->GetStringLength(str); CE \\\n-nativeStr = (jchar *)env->GetStringCritical(str, &isCopy); CE \\\n-EnterCS(env); \\\n-if (isCopy == JNI_TRUE) return 0;\\\n-for (i = 0; i < size; ++i)\\\n-    hash += (int)nativeStr[i];\\\n-LeaveCS(env); \\\n-env->ReleaseStringCritical(str, nativeStr); CE \\\n-return hash;\n-\n-static int CSEntered = 0;\n-static int CSLeft = 0;\n-\n-void EnterCS(JNIEnv *env)\n-{\n-    \/\/ unsafe but where are no better ideas\n-    \/\/++CSEntered;\n-    \/\/printf(\"CS Entered -> Entered: %d\\n\", CSEntered);\n-\/\/    jclass trace = 0; jmethodID method = 0;\n-\/\/    trace = env->FindClass(\"nsk\/stress\/jni\/gclocker\/Trace\"); CE\n-\/\/    method = env->GetStaticMethodID(trace, \"EnterCS\", \"()V\"); CE\n-\/\/    env->CallStaticVoidMethod(trace, method); CE\n-}\n-\n-void LeaveCS(JNIEnv *env)\n-{\n-    \/\/ unsafe but where are no better ideas\n-    \/\/++CSLeft;\n-    \/\/printf(\"CS Left -> Completed: %d\\tActive: %d\\n\", CSLeft, CSEntered - CSLeft);\n-\/\/    jclass trace = 0; jmethodID method = 0;\n-\/\/    trace = env->FindClass(\"nsk\/stress\/jni\/gclocker\/Trace\"); CE\n-\/\/    method = env->GetStaticMethodID(trace, \"LeaveCS\", \"()V\"); CE\n-\/\/    env->CallStaticVoidMethod(trace, method); CE\n+#define COMP(type)                                                          \\\n+int type##comp(const void *s1, const void *s2)                              \\\n+{                                                                           \\\n+  type st1 = *((type *)s1);                                                 \\\n+  type st2 = *((type *)s2);                                                 \\\n+  if (st1 < st2)                                                            \\\n+    return -1;                                                              \\\n+  else if (st1 > st2)                                                       \\\n+    return 1;                                                               \\\n+  else                                                                      \\\n+    return 0;                                                               \\\n@@ -115,0 +88,2 @@\n+extern \"C\" {\n+\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/jni\/gclocker\/libgcl001.cpp","additions":51,"deletions":76,"binary":false,"changes":127,"status":"modified"}]}