{"files":[{"patch":"@@ -58,0 +58,2 @@\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+\n@@ -227,0 +229,1 @@\n+        String responder = responderURI.toString();\n@@ -229,1 +232,1 @@\n-            debug.println(\"connecting to OCSP service at: \" + responderURI);\n+            debug.println(\"connecting to OCSP service at: \" + responder);\n@@ -235,3 +238,6 @@\n-            String encodedGetReq = responderURI.toString() + \"\/\" +\n-                    URLEncoder.encode(Base64.getEncoder().encodeToString(bytes),\n-                            \"UTF-8\");\n+            StringBuilder encodedGetReq = new StringBuilder(responder);\n+            if (!responder.endsWith(\"\/\")) {\n+                encodedGetReq.append(\"\/\");\n+            }\n+            encodedGetReq.append(URLEncoder.encode(\n+                    Base64.getEncoder().encodeToString(bytes), UTF_8));\n@@ -240,1 +246,1 @@\n-                url = new URL(encodedGetReq);\n+                url = new URL(encodedGetReq.toString());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSP.java","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -643,1 +643,4 @@\n-            respSignature.initVerify(cert.getPublicKey());\n+            SignatureUtil.initVerifyWithParam(respSignature,\n+                    cert.getPublicKey(),\n+                    SignatureUtil.getParamSpec(sigAlgId.getName(),\n+                            sigAlgId.getEncodedParams()));\n@@ -659,2 +662,2 @@\n-        } catch (InvalidKeyException | NoSuchAlgorithmException |\n-                 SignatureException e)\n+        } catch (InvalidAlgorithmParameterException | InvalidKeyException\n+                | NoSuchAlgorithmException | SignatureException e)\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSPResponse.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import java.security.interfaces.RSAKey;\n@@ -33,0 +34,1 @@\n+import sun.security.x509.AlgorithmId;\n@@ -148,2 +150,1 @@\n-            throws ProviderException, InvalidAlgorithmParameterException,\n-            InvalidKeyException {\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n@@ -158,2 +159,1 @@\n-            throws ProviderException, InvalidAlgorithmParameterException,\n-            InvalidKeyException {\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n@@ -167,2 +167,1 @@\n-            throws ProviderException, InvalidAlgorithmParameterException,\n-            InvalidKeyException {\n+            throws InvalidAlgorithmParameterException, InvalidKeyException {\n@@ -171,0 +170,324 @@\n+\n+    public static class EdDSADigestAlgHolder {\n+        public static final AlgorithmId sha512;\n+        public static final AlgorithmId shake256;\n+\n+        static {\n+            \/\/ try {\n+                sha512 = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.SHA_512));\n+                shake256 = new AlgorithmId(ObjectIdentifier.of(KnownOIDs.SHAKE256));\n+            \/\/ }\n+            \/\/  catch (IOException e) {\n+            \/\/     throw new AssertionError(\"Should not happen\", e);\n+            \/\/ }\n+        }\n+    }\n+    \/**\n+     * Determines the digestEncryptionAlgorithmId in PKCS7 SignerInfo.\n+     *\n+     * @param signer Signature object that tells you RSASSA-PSS params\n+     * @param sigalg Signature algorithm\n+     * @param privateKey key tells you EdDSA params\n+     * @param directsign Ed448 uses different digest algs depending on this\n+     * @return the digest algId\n+     * @throws NoSuchAlgorithmException\n+     *\/\n+    public static AlgorithmId getDigestAlgInPkcs7SignerInfo(\n+            Signature signer, String sigalg, PrivateKey privateKey, boolean directsign)\n+            throws NoSuchAlgorithmException {\n+        AlgorithmId digAlgID;\n+        String kAlg = privateKey.getAlgorithm();\n+        if (sigalg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n+            try {\n+                digAlgID = AlgorithmId.get(signer.getParameters()\n+                        .getParameterSpec(PSSParameterSpec.class)\n+                        .getDigestAlgorithm());\n+            } catch (InvalidParameterSpecException e) {\n+                throw new AssertionError(\"Should not happen\", e);\n+            }\n+        } else {\n+            digAlgID = AlgorithmId.get(extractDigestAlgFromDwithE(sigalg));\n+        }\n+        return digAlgID;\n+    }\n+\n+    \/**\n+     * Extracts the digest algorithm name from a signature\n+     * algorithm name in either the \"DIGESTwithENCRYPTION\" or the\n+     * \"DIGESTwithENCRYPTIONandWHATEVER\" format.\n+     *\n+     * It's OK to return \"SHA1\" instead of \"SHA-1\".\n+     *\/\n+    public static String extractDigestAlgFromDwithE(String signatureAlgorithm) {\n+        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\n+        int with = signatureAlgorithm.indexOf(\"WITH\");\n+        if (with > 0) {\n+            return signatureAlgorithm.substring(0, with);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    \"Unknown algorithm: \" + signatureAlgorithm);\n+        }\n+    }\n+\n+    \/**\n+     * Extracts the key algorithm name from a signature\n+     * algorithm name in either the \"DIGESTwithENCRYPTION\" or the\n+     * \"DIGESTwithENCRYPTIONandWHATEVER\" format.\n+     *\n+     * @return the key algorithm name, or null if the input\n+     *      is not in either of the formats.\n+     *\/\n+    public static String extractKeyAlgFromDwithE(String signatureAlgorithm) {\n+        signatureAlgorithm = signatureAlgorithm.toUpperCase(Locale.ENGLISH);\n+        int with = signatureAlgorithm.indexOf(\"WITH\");\n+        String keyAlgorithm = null;\n+        if (with > 0) {\n+            int and = signatureAlgorithm.indexOf(\"AND\", with + 4);\n+            if (and > 0) {\n+                keyAlgorithm = signatureAlgorithm.substring(with + 4, and);\n+            } else {\n+                keyAlgorithm = signatureAlgorithm.substring(with + 4);\n+            }\n+            if (keyAlgorithm.equalsIgnoreCase(\"ECDSA\")) {\n+                keyAlgorithm = \"EC\";\n+            }\n+        }\n+        return keyAlgorithm;\n+    }\n+\n+    \/**\n+     * Returns default AlgorithmParameterSpec for a key used in a signature.\n+     * This is only useful for RSASSA-PSS now, which is the only algorithm\n+     * that must be initialized with a AlgorithmParameterSpec now.\n+     *\/\n+    public static AlgorithmParameterSpec getDefaultParamSpec(\n+            String sigAlg, Key k) {\n+        sigAlg = checkName(sigAlg);\n+        if (sigAlg.equalsIgnoreCase(\"RSASSA-PSS\")) {\n+            if (k instanceof RSAKey) {\n+                AlgorithmParameterSpec spec = ((RSAKey) k).getParams();\n+                if (spec instanceof PSSParameterSpec) {\n+                    return spec;\n+                }\n+            }\n+            switch (ifcFfcStrength(KeyUtil.getKeySize(k))) {\n+                case \"SHA256\":\n+                    return PSSParamsHolder.PSS_256_SPEC;\n+                case \"SHA384\":\n+                    return PSSParamsHolder.PSS_384_SPEC;\n+                case \"SHA512\":\n+                    return PSSParamsHolder.PSS_512_SPEC;\n+                default:\n+                    throw new AssertionError(\"Should not happen\");\n+            }\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    \/**\n+     * Create a Signature that has been initialized with proper key and params.\n+     *\n+     * @param sigAlg signature algorithms\n+     * @param key private key\n+     * @param provider (optional) provider\n+     *\/\n+    public static Signature fromKey(String sigAlg, PrivateKey key, String provider)\n+            throws NoSuchAlgorithmException, NoSuchProviderException,\n+                   InvalidKeyException{\n+        Signature sigEngine = (provider == null || provider.isEmpty())\n+                ? Signature.getInstance(sigAlg)\n+                : Signature.getInstance(sigAlg, provider);\n+        return autoInitInternal(sigAlg, key, sigEngine);\n+    }\n+\n+    \/**\n+     * Create a Signature that has been initialized with proper key and params.\n+     *\n+     * @param sigAlg signature algorithms\n+     * @param key private key\n+     * @param provider (optional) provider\n+     *\/\n+    public static Signature fromKey(String sigAlg, PrivateKey key, Provider provider)\n+            throws NoSuchAlgorithmException, InvalidKeyException{\n+        Signature sigEngine = (provider == null)\n+                ? Signature.getInstance(sigAlg)\n+                : Signature.getInstance(sigAlg, provider);\n+        return autoInitInternal(sigAlg, key, sigEngine);\n+    }\n+\n+    private static Signature autoInitInternal(String alg, PrivateKey key, Signature s)\n+            throws InvalidKeyException {\n+        AlgorithmParameterSpec params = SignatureUtil\n+                .getDefaultParamSpec(alg, key);\n+        try {\n+            SignatureUtil.initSignWithParam(s, key, params, null);\n+        } catch (InvalidAlgorithmParameterException e) {\n+            throw new AssertionError(\"Should not happen\", e);\n+        }\n+        return s;\n+    }\n+\n+    \/**\n+     * Derives AlgorithmId from a signature object and a key.\n+     * @param sigEngine the signature object\n+     * @param key the private key\n+     * @return the AlgorithmId, not null\n+     * @throws SignatureException if cannot find one\n+     *\/\n+    public static AlgorithmId fromSignature(Signature sigEngine, PrivateKey key)\n+            throws SignatureException {\n+        try {\n+            AlgorithmParameters params = null;\n+            try {\n+                params = sigEngine.getParameters();\n+            } catch (UnsupportedOperationException e) {\n+                \/\/ some provider does not support it\n+            }\n+            if (params != null) {\n+                return AlgorithmId.get(sigEngine.getParameters());\n+            } else {\n+                String sigAlg = sigEngine.getAlgorithm();\n+                if (sigAlg.equalsIgnoreCase(\"EdDSA\")) {\n+                    \/\/ Hopefully key knows if it's Ed25519 or Ed448\n+                    sigAlg = key.getAlgorithm();\n+                }\n+                return AlgorithmId.get(sigAlg);\n+            }\n+        } catch (NoSuchAlgorithmException e) {\n+            \/\/ This could happen if both sig alg and key alg is EdDSA,\n+            \/\/ we don't know which provider does this.\n+            throw new SignatureException(\"Cannot derive AlgorithmIdentifier\", e);\n+        }\n+    }\n+\n+    \/**\n+     * Checks if a signature algorithm matches a key, i.e. if this\n+     * signature can be initialized with this key. Currently used\n+     * in {@link jdk.security.jarsigner.JarSigner} to fail early.\n+     *\n+     * Note: Unknown signature algorithms are allowed.\n+     *\n+     * @param key must not be null\n+     * @param sAlg must not be null\n+     * @throws IllegalArgumentException if they are known to not match\n+     *\/\n+    public static void checkKeyAndSigAlgMatch(PrivateKey key, String sAlg) {\n+        String kAlg = key.getAlgorithm().toUpperCase(Locale.ENGLISH);\n+        sAlg = checkName(sAlg).toUpperCase(Locale.ENGLISH);\n+        switch (sAlg) {\n+            case \"RSASSA-PSS\" : {\n+                if (!kAlg.equals(\"RSASSA-PSS\")\n+                        && !kAlg.equals(\"RSA\")) {\n+                    throw new IllegalArgumentException(\n+                            \"key algorithm not compatible with signature algorithm\");\n+                }\n+            }\n+            break;\n+            case \"EDDSA\" : {\n+                \/\/ General EdDSA, any EDDSA name variance is OK\n+                if (!kAlg.equals(\"EDDSA\") && !kAlg.equals(\"ED448\")\n+                        && !kAlg.equals(\"ED25519\")) {\n+                    throw new IllegalArgumentException(\n+                            \"key algorithm not compatible with signature algorithm\");\n+                }\n+            }\n+            break;\n+            case \"ED25519\":\n+            case \"ED448\": {\n+                \/\/ Other vendor might be generalized or fix-size\n+                if (!kAlg.equals(\"EDDSA\") && !kAlg.equals(sAlg)) {\n+                    throw new IllegalArgumentException(\n+                            \"key algorithm not compatible with signature algorithm\");\n+                }\n+            }\n+            break;\n+            default : {\n+                if (sAlg.contains(\"WITH\")) {\n+                    if ((sAlg.endsWith(\"WITHRSA\") && !kAlg.equals(\"RSA\")) ||\n+                            (sAlg.endsWith(\"WITHECDSA\") && !kAlg.equals(\"EC\")) ||\n+                            (sAlg.endsWith(\"WITHDSA\") && !kAlg.equals(\"DSA\"))) {\n+                        throw new IllegalArgumentException(\n+                                \"key algorithm not compatible with signature algorithm\");\n+                    }\n+                }\n+                \/\/ Do not fail now. Maybe new algorithm we don't know.\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Returns the default signature algorithm for a private key.\n+     *\n+     * @param k cannot be null\n+     * @return the default alg, might be null if unsupported\n+     *\/\n+    public static String getDefaultSigAlgForKey(PrivateKey k) {\n+        String kAlg = k.getAlgorithm();\n+        switch (kAlg.toUpperCase(Locale.ENGLISH)) {\n+            case \"DSA\":\n+            case \"RSA\":\n+                return ifcFfcStrength(KeyUtil.getKeySize(k)) + \"with\" + kAlg;\n+            case \"EC\":\n+                return ecStrength(KeyUtil.getKeySize(k)) + \"withECDSA\";\n+            case \"EDDSA\" :\n+            case \"RSASSA-PSS\":\n+            case \"ED25519\":\n+            case \"ED448\":\n+                return kAlg;\n+            default:\n+                return null;\n+        }\n+    }\n+\n+    \/\/ Useful PSSParameterSpec objects\n+    private static class PSSParamsHolder {\n+        static final PSSParameterSpec PSS_256_SPEC = new PSSParameterSpec(\n+                \"SHA-256\", \"MGF1\",\n+                MGF1ParameterSpec.SHA256,\n+                32, PSSParameterSpec.TRAILER_FIELD_BC);\n+        static final PSSParameterSpec PSS_384_SPEC = new PSSParameterSpec(\n+                \"SHA-384\", \"MGF1\",\n+                MGF1ParameterSpec.SHA384,\n+                48, PSSParameterSpec.TRAILER_FIELD_BC);\n+        static final PSSParameterSpec PSS_512_SPEC = new PSSParameterSpec(\n+                \"SHA-512\", \"MGF1\",\n+                MGF1ParameterSpec.SHA512,\n+                64, PSSParameterSpec.TRAILER_FIELD_BC);\n+    }\n+\n+    \/\/ The following values are from SP800-57 part 1 rev 4 tables 2 and 3\n+\n+    \/**\n+     * Return the default message digest algorithm with the same security\n+     * strength as the specified EC key size.\n+     *\n+     * Attention: sync with the @implNote inside\n+     * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm}.\n+     *\/\n+    private static String ecStrength (int bitLength) {\n+        if (bitLength >= 512) { \/\/ 256 bits of strength\n+            return \"SHA512\";\n+        } else if (bitLength >= 384) {  \/\/ 192 bits of strength\n+            return \"SHA384\";\n+        } else { \/\/ 128 bits of strength and less\n+            return \"SHA256\";\n+        }\n+    }\n+\n+    \/**\n+     * Return the default message digest algorithm with the same security\n+     * strength as the specified IFC\/FFC key size.\n+     *\n+     * Attention: sync with the @implNote inside\n+     * {@link jdk.security.jarsigner.JarSigner.Builder#getDefaultSignatureAlgorithm}.\n+     *\/\n+    private static String ifcFfcStrength (int bitLength) {\n+        if (bitLength > 7680) { \/\/ 256 bits\n+            return \"SHA512\";\n+        } else if (bitLength > 3072) {  \/\/ 192 bits\n+            return \"SHA384\";\n+        } else  { \/\/ 128 bits and less\n+            return \"SHA256\";\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/SignatureUtil.java","additions":330,"deletions":7,"binary":false,"changes":337,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-    public byte[] getEncodedParams() throws IOException {\n+    public byte[] getEncodedParams() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/AlgorithmId.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -842,7 +842,1 @@\n-        if (sigAlgId == null)\n-            return null;\n-        try {\n-            return sigAlgId.getEncodedParams();\n-        } catch (IOException e) {\n-            return null;\n-        }\n+        return sigAlgId == null ? null : sigAlgId.getEncodedParams();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CRLImpl.java","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1087,7 +1087,1 @@\n-        if (algId == null)\n-            return null;\n-        try {\n-            return algId.getEncodedParams();\n-        } catch (IOException e) {\n-            return null;\n-        }\n+        return algId == null ? null : algId.getEncodedParams();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import sun.security.util.SignatureUtil;\n@@ -367,2 +368,1 @@\n-        AlgorithmId signAlg = AlgorithmId.get(algName);\n-        byte[] encodedCert = encodeTopLevel(issuerCert, issuerKey, signAlg);\n+        byte[] encodedCert = encodeTopLevel(issuerCert, issuerKey, algName);\n@@ -395,2 +395,4 @@\n-            PrivateKey issuerKey, AlgorithmId signAlg)\n-            throws CertificateException, IOException {\n+            PrivateKey issuerKey, String algName)\n+            throws CertificateException, IOException, NoSuchAlgorithmException {\n+\n+        AlgorithmId signAlg = AlgorithmId.get(algName);\n@@ -400,2 +402,0 @@\n-        tbsCertBytes = encodeTbsCert(issuerCert, signAlg);\n-        topLevelItems.write(tbsCertBytes);\n@@ -403,1 +403,6 @@\n-            signatureBytes = signCert(issuerKey, signAlg);\n+            Signature sig = SignatureUtil.fromKey(signAlg.getName(), issuerKey, (Provider)null);\n+            \/\/ Rewrite signAlg, RSASSA-PSS needs some parameters.\n+            signAlg = SignatureUtil.fromSignature(sig, issuerKey);\n+            tbsCertBytes = encodeTbsCert(issuerCert, signAlg);\n+            sig.update(tbsCertBytes);\n+            signatureBytes = sig.sign();\n@@ -407,0 +412,1 @@\n+        topLevelItems.write(tbsCertBytes);\n@@ -521,19 +527,1 @@\n-    \/**\n-     * Digitally sign the X.509 certificate.\n-     *\n-     * @param issuerKey The private key of the issuing authority\n-     * @param signAlg The signature algorithm object\n-     *\n-     * @return The digital signature bytes.\n-     *\n-     * @throws GeneralSecurityException If any errors occur during the\n-     * digital signature process.\n-     *\/\n-    private byte[] signCert(PrivateKey issuerKey, AlgorithmId signAlg)\n-            throws GeneralSecurityException {\n-        Signature sig = Signature.getInstance(signAlg.getName());\n-        sig.initSign(issuerKey);\n-        sig.update(tbsCertBytes);\n-        return sig.sign();\n-    }\n- }\n+}\n","filename":"test\/jdk\/java\/security\/testlibrary\/CertificateBuilder.java","additions":15,"deletions":27,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,1 @@\n+import sun.security.util.SignatureUtil;\n@@ -181,2 +182,1 @@\n-\n-        sigAlgId = AlgorithmId.get(\"Sha256withRSA\");\n+        sigAlgId = AlgorithmId.get(SignatureUtil.getDefaultSigAlgForKey(signerKey));\n@@ -1355,2 +1355,0 @@\n-                sigAlgId.derEncode(basicORItemStream);\n-\n@@ -1358,2 +1356,2 @@\n-                Signature sig = Signature.getInstance(sigAlgId.getName());\n-                sig.initSign(signerKey);\n+                Signature sig = SignatureUtil.fromKey(\n+                        sigAlgId.getName(), signerKey, (Provider)null);\n@@ -1362,0 +1360,3 @@\n+                \/\/ Rewrite signAlg, RSASSA-PSS needs some parameters.\n+                sigAlgId = SignatureUtil.fromSignature(sig, signerKey);\n+                sigAlgId.derEncode(basicORItemStream);\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n- * @run main\/othervm HttpsUrlConnClient\n+ * @run main\/othervm HttpsUrlConnClient RSA SHA256withRSA\n+ * @run main\/othervm HttpsUrlConnClient RSASSA-PSS RSASSA-PSS\n@@ -63,1 +64,0 @@\n-import sun.security.validator.ValidatorException;\n@@ -76,0 +76,3 @@\n+    static String SIGALG;\n+    static String KEYALG;\n+\n@@ -140,0 +143,3 @@\n+        KEYALG = args[0];\n+        SIGALG = args[1];\n+\n@@ -517,1 +523,1 @@\n-        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(\"RSA\");\n+        KeyPairGenerator keyGen = KeyPairGenerator.getInstance(KEYALG);\n@@ -543,1 +549,1 @@\n-                \"SHA256withRSA\");\n+                SIGALG);\n@@ -585,1 +591,1 @@\n-                \"SHA256withRSA\");\n+                SIGALG);\n@@ -647,1 +653,1 @@\n-                \"SHA256withRSA\");\n+                SIGALG);\n","filename":"test\/jdk\/javax\/net\/ssl\/Stapling\/HttpsUrlConnClient.java","additions":13,"deletions":7,"binary":false,"changes":20,"status":"modified"}]}