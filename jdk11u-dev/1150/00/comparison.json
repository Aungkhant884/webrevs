{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import jdk.internal.event.DeserializationEvent;\n@@ -1317,1 +1318,2 @@\n-     * Invoke the serialization filter if non-null.\n+     * Invokes the serialization filter if non-null.\n+     *\n@@ -1320,0 +1322,2 @@\n+     * Logs and\/or commits a {@code DeserializationEvent}, if configured.\n+     *\n@@ -1327,0 +1331,5 @@\n+        \/\/ Info about the stream is not available if overridden by subclass, return 0\n+        long bytesRead = (bin == null) ? 0 : bin.getBytesRead();\n+        RuntimeException ex = null;\n+        ObjectInputFilter.Status status = null;\n+\n@@ -1328,4 +1337,0 @@\n-            RuntimeException ex = null;\n-            ObjectInputFilter.Status status;\n-            \/\/ Info about the stream is not available if overridden by subclass, return 0\n-            long bytesRead = (bin == null) ? 0 : bin.getBytesRead();\n@@ -1349,6 +1354,18 @@\n-            if (status == null ||\n-                    status == ObjectInputFilter.Status.REJECTED) {\n-                InvalidClassException ice = new InvalidClassException(\"filter status: \" + status);\n-                ice.initCause(ex);\n-                throw ice;\n-            }\n+        }\n+        DeserializationEvent event = new DeserializationEvent();\n+        if (event.shouldCommit()) {\n+            event.filterConfigured = serialFilter != null;\n+            event.filterStatus = status != null ? status.name() : null;\n+            event.type = clazz;\n+            event.arrayLength = arrayLength;\n+            event.objectReferences = totalObjectRefs;\n+            event.depth = depth;\n+            event.bytesRead = bytesRead;\n+            event.exceptionType = ex != null ? ex.getClass() : null;\n+            event.exceptionMessage = ex != null ? ex.getMessage() : null;\n+            event.commit();\n+        }\n+        if (serialFilter != null && (status == null || status == ObjectInputFilter.Status.REJECTED)) {\n+            InvalidClassException ice = new InvalidClassException(\"filter status: \" + status);\n+            ice.initCause(ex);\n+            throw ice;\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectInputStream.java","additions":29,"deletions":12,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.event;\n+\n+\/**\n+ * Event details relating to deserialization.\n+ *\/\n+\n+public final class DeserializationEvent extends Event {\n+    public boolean filterConfigured;\n+    public String filterStatus;\n+    public Class<?> type;\n+    public int arrayLength;\n+    public long objectReferences;\n+    public long depth;\n+    public long bytesRead;\n+    public Class<?> exceptionType;\n+    public String exceptionMessage;\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/DeserializationEvent.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.events;\n+\n+import jdk.jfr.Category;\n+import jdk.jfr.Description;\n+import jdk.jfr.Label;\n+import jdk.jfr.Name;\n+import jdk.jfr.internal.MirrorEvent;\n+\n+@Category({\"Java Development Kit\", \"Serialization\"})\n+@Label(\"Deserialization\")\n+@Name(\"jdk.Deserialization\")\n+@Description(\"Results of deserialiation and ObjectInputFilter checks\")\n+@MirrorEvent(className = \"jdk.internal.event.DeserializationEvent\")\n+public final class DeserializationEvent extends AbstractJDKEvent {\n+\n+    @Label(\"Filter Configured\")\n+    public boolean filterConfigured;\n+\n+    @Label(\"Filter Status\")\n+    public String filterStatus;\n+\n+    @Label (\"Type\")\n+    public Class<?> type;\n+\n+    @Label (\"Array Length\")\n+    public int arrayLength;\n+\n+    @Label (\"Object References\")\n+    public long objectReferences;\n+\n+    @Label (\"Depth\")\n+    public long depth;\n+\n+    @Label (\"Bytes Read\")\n+    public long bytesRead;\n+\n+    @Label (\"Exception Type\")\n+    public Class<?> exceptionType;\n+\n+    @Label (\"Exception Message\")\n+    public String exceptionMessage;\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/DeserializationEvent.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import jdk.jfr.events.DeserializationEvent;\n@@ -57,0 +58,1 @@\n+        DeserializationEvent.class,\n@@ -74,0 +76,1 @@\n+        jdk.internal.event.DeserializationEvent.class,\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -606,0 +606,5 @@\n+    <event name=\"jdk.Deserialization\">\n+       <setting name=\"enabled\">false<\/setting>\n+       <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/default.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -606,0 +606,5 @@\n+    <event name=\"jdk.Deserialization\">\n+       <setting name=\"enabled\">false<\/setting>\n+       <setting name=\"stackTrace\">true<\/setting>\n+    <\/event>\n+\n","filename":"src\/jdk.jfr\/share\/conf\/jfr\/profile.jfc","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,12 @@\n+\n+\/* @test\n+ * @bug 8261160\n+ * @summary Add a deserialization JFR event\n+ * @build GlobalFilterTest SerialFilterTest\n+ * @requires vm.hasJFR\n+ * @run testng\/othervm\/policy=security.policy\n+ *        -XX:StartFlightRecording=name=DeserializationEvent,dumponexit=true\n+ *        -Djava.security.properties=${test.src}\/java.security-extra1\n+ *        -Djava.security.debug=properties GlobalFilterTest\n+ *\/\n+\n","filename":"test\/jdk\/java\/io\/Serializable\/serialFilter\/GlobalFilterTest.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,444 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.event.io;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InvalidClassException;\n+import java.io.ObjectInputFilter.Status;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.jfr.EventNames;\n+import jdk.test.lib.jfr.Events;\n+import jdk.test.lib.serial.SerialObjectBuilder;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static java.lang.System.out;\n+import static org.testng.Assert.*;\n+\n+\/*\n+ * @test\n+ * @bug 8261160\n+ * @summary Add a deserialization JFR event\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @modules java.base\/sun.invoke.util\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.serial.SerialObjectBuilder\n+ * @run testng\/othervm jdk.jfr.event.io.TestDeserializationEvent\n+ *\/\n+\/\/ sun.invoke.util needed for SerialObjectBuilder.\n+public class TestDeserializationEvent {\n+\n+\n+    @DataProvider(name = \"scenarios\")\n+    public Object[][] scenarios() throws Exception {\n+        byte[] ba1 = serialize(new R());\n+        byte[] ba2 = serialize(new int[] { 56, 67, 58, 59, 60 });\n+        byte[] ba3 = serialize(new R[] { new R(), new R() });\n+        byte[] ba4 = serialize(new char[][] { new char[] {'a', 'b'}, new char[] {'c'} });\n+\n+        \/\/ data provider columns- 1:id, 2:deserialize-operation, 3:expected-event-checkers\n+        return new Object[][] {\n+            {   1,  \/\/ single stream object, R\n+                (Runnable)() -> deserialize(ba1),\n+                List.of(\n+                    Set.of(\n+                        assertFilterStatus(null),\n+                        assertType(R.class),\n+                        assertArrayLength(-1),\n+                        assertObjectReferences(1),\n+                        assertDepth(1),\n+                        assertHasBytesRead(),\n+                        assertExceptionType(null),\n+                        assertExceptionMessage(null))) },\n+            {   2,  \/\/ primitive int array\n+                (Runnable)() -> deserialize(ba2),\n+                List.of(\n+                    Set.of(  \/\/ TC_CLASS, for array class int[]\n+                        assertType(int[].class),\n+                        assertArrayLength(-1)),\n+                    Set.of(  \/\/ TC_ARRAY, actual array\n+                        assertType(int[].class),\n+                        assertArrayLength(5))) },\n+            {   3,  \/\/ reference array, R\n+                (Runnable)() -> deserialize(ba3),\n+                List.of(\n+                    Set.of(  \/\/ TC_CLASS, for array class R[]\n+                        assertType(R[].class),\n+                        assertArrayLength(-1)),\n+                    Set.of(  \/\/ TC_ARRAY, actual array\n+                        assertType(R[].class),\n+                        assertArrayLength(2)),\n+                    Set.of(  \/\/ TC_CLASS, for R\n+                        assertType(R.class),\n+                        assertArrayLength(-1)),\n+                    Set.of(  \/\/ TC_REFERENCE, for TC_CLASS relating second stream obj\n+                        assertType(null),\n+                        assertArrayLength(-1))) },\n+            {  4,  \/\/ multi-dimensional prim char array\n+               (Runnable)() -> deserialize(ba4),\n+               List.of(\n+                    Set.of(  \/\/ TC_CLASS, for array class char[][]\n+                        assertType(char[][].class),\n+                        assertArrayLength(-1),\n+                        assertDepth(1)),\n+                    Set.of(  \/\/ TC_ARRAY, actual char[][] array\n+                        assertType(char[][].class),\n+                        assertArrayLength(2),\n+                        assertDepth(1)),\n+                    Set.of(  \/\/ TC_CLASS, for array class char[]\n+                        assertType(char[].class),\n+                        assertArrayLength(-1),\n+                        assertDepth(2)),\n+                    Set.of(  \/\/ TC_ARRAY, first char[] array\n+                        assertType(char[].class),\n+                        assertArrayLength(2),\n+                        assertDepth(2)),\n+                    Set.of(  \/\/ TC_REFERENCE, for TC_CLASS relating to second stream array\n+                        assertType(null),\n+                        assertArrayLength(-1),\n+                        assertDepth(2)),\n+                    Set.of(  \/\/ TC_ARRAY, second char[] array\n+                        assertType(char[].class),\n+                        assertArrayLength(1),\n+                        assertDepth(2))) }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"scenarios\")\n+    public void test(int id,\n+                     Runnable thunk,\n+                     List<Set<Consumer<RecordedEvent>>> expectedValuesChecker)\n+       throws IOException\n+    {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            thunk.run();\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), expectedValuesChecker.size());\n+            assertEventList(events, expectedValuesChecker);\n+        }\n+    }\n+\n+    static final Class<InvalidClassException> ICE = InvalidClassException.class;\n+\n+    @DataProvider(name = \"filterDisallowedValues\")\n+    public Object[][] filterDisallowedValues() {\n+        return new Object[][] {\n+                { Status.REJECTED,   \"REJECTED\" },\n+                { null,              null       }\n+        };\n+    }\n+\n+    @Test(dataProvider = \"filterDisallowedValues\")\n+    public void testFilterDisallow(Status filterStatus,\n+                                   String expectedValue)\n+        throws Exception\n+    {\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(serialize(new R()));\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> filterStatus);\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            assertThrows(ICE, () -> ois.readObject());\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertFilterStatus(expectedValue).accept(events.get(0));\n+        }\n+    }\n+\n+    @DataProvider(name = \"filterAllowedValues\")\n+    public Object[][] filterAllowedValues() {\n+        return new Object[][] {\n+                { Status.ALLOWED,   \"ALLOWED\"   },\n+                { Status.UNDECIDED, \"UNDECIDED\" },\n+        };\n+    }\n+\n+    @Test(dataProvider = \"filterAllowedValues\")\n+    public void testFilterAllowed(Status filterStatus,\n+                                  String expectedValue) throws Exception {\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(serialize(new R()));\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> filterStatus);\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            ois.readObject();\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertFilterStatus(expectedValue).accept(events.get(0));\n+        }\n+    }\n+\n+    static class XYZException extends RuntimeException {\n+        XYZException(String msg) { super(msg); }\n+    }\n+\n+    @Test\n+    public void testException() throws Exception {\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(serialize(new R()));\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> { throw new XYZException(\"I am a bad filter!!!\"); });\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            assertThrows(ICE, () -> ois.readObject());\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertExceptionType(XYZException.class).accept(events.get(0));\n+            assertExceptionMessage(\"I am a bad filter!!!\").accept(events.get(0));\n+        }\n+    }\n+\n+    static void assertEventList(List<RecordedEvent> actualEvents,\n+                                List<Set<Consumer<RecordedEvent>>> expectedValuesChecker) {\n+        int found = 0;\n+        for (RecordedEvent recordedEvent : actualEvents) {\n+            assertEquals(recordedEvent.getEventType().getName(), \"jdk.Deserialization\");\n+            out.println(\"Checking recorded event:\" + recordedEvent);\n+            Set<Consumer<RecordedEvent>> checkers = expectedValuesChecker.get(found);\n+            for (Consumer<RecordedEvent> checker : checkers) {\n+                out.println(\"  checking:\" + checker);\n+                checker.accept(recordedEvent);\n+            }\n+            assertFilterConfigured(false).accept(recordedEvent); \/\/ no filter expected\n+            assertExceptionType(null).accept(recordedEvent);     \/\/ no exception type expected\n+            assertExceptionMessage(null).accept(recordedEvent);  \/\/ no exception message expected\n+            found++;\n+        }\n+        assertEquals(found, expectedValuesChecker.size());\n+    }\n+\n+    static Consumer<RecordedEvent> assertFilterConfigured(boolean expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"filterConfigured\"));\n+                assertEquals((boolean)recordedEvent.getValue(\"filterConfigured\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertFilterConfigured, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertFilterStatus(String expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"filterStatus\"));\n+                assertEquals(recordedEvent.getValue(\"filterStatus\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertFilterStatus, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertType(Class<?> expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"type\"));\n+                assertClassOrNull(expectedValue, recordedEvent, \"type\");\n+            }\n+            @Override public String toString() {\n+                return \"assertType, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertArrayLength(int expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"arrayLength\"));\n+                assertEquals((int)recordedEvent.getValue(\"arrayLength\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertArrayLength, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertObjectReferences(long expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"objectReferences\"));\n+                assertEquals((long)recordedEvent.getValue(\"objectReferences\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertObjectReferences, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertDepth(long expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"depth\"));\n+                assertEquals((long)recordedEvent.getValue(\"depth\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertDepth, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertHasBytesRead() {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"bytesRead\"));\n+            }\n+            @Override public String toString() {\n+                return \"assertHasBytesRead,\";\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertBytesRead(long expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertHasBytesRead().accept(recordedEvent);\n+                assertEquals((long)recordedEvent.getValue(\"bytesRead\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertBytesRead, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertExceptionType(Class<?> expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"exceptionType\"));\n+                assertClassOrNull(expectedValue, recordedEvent, \"exceptionType\");\n+            }\n+            @Override public String toString() {\n+                return \"assertExceptionType, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static Consumer<RecordedEvent> assertExceptionMessage(String expectedValue) {\n+        return new Consumer<>() {\n+            @Override public void accept(RecordedEvent recordedEvent) {\n+                assertTrue(recordedEvent.hasField(\"exceptionMessage\"));\n+                assertEquals(recordedEvent.getValue(\"exceptionMessage\"), expectedValue);\n+            }\n+            @Override public String toString() {\n+                return \"assertExceptionMessage, expectedValue=\" + expectedValue;\n+            }\n+        };\n+    }\n+\n+    static void assertClassOrNull(Class<?> expectedValue,\n+                                  RecordedEvent recordedEvent,\n+                                  String valueName) {\n+        if (expectedValue == null && recordedEvent.getValue(valueName) == null)\n+            return;\n+\n+        if (recordedEvent.getValue(valueName) instanceof RecordedClass) {\n+            RecordedClass recordedClass = (RecordedClass) recordedEvent.getValue(valueName);\n+            assertEquals(recordedClass.getName(), expectedValue.getName());\n+        } else {\n+            fail(\"Expected RecordedClass, got:\" + recordedEvent.getValue(valueName).getClass());\n+        }\n+    }\n+\n+    static <T> byte[] serialize(T obj) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ObjectOutputStream oos = new ObjectOutputStream(baos);\n+        System.out.println(\"GL: serializing \" + obj.getClass().getName());\n+        oos.writeObject(obj);\n+        oos.close();\n+        return baos.toByteArray();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static <T> T deserialize(byte[] streamBytes) {\n+        try {\n+            ByteArrayInputStream bais = new ByteArrayInputStream(streamBytes);\n+            ObjectInputStream ois  = new ObjectInputStream(bais);\n+            return (T) ois.readObject();\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    \/\/ ---\n+    static volatile boolean initializedFoo; \/\/ false\n+    \/\/ Do not inadvertently initialize this class, Foo.\n+    static class Foo implements Serializable {\n+        static { TestDeserializationEvent.initializedFoo = true; }\n+    }\n+\n+    \/**\n+     * Checks that the creation and recording of the Deserialization event does\n+     * not inadvertently trigger initialization of the class of the stream\n+     * object, when deserialization is rejected by the filter.\n+     *\/\n+    @Test\n+    public void testRejectedClassNotInitialized() throws Exception {\n+        byte[] bytes = SerialObjectBuilder.newBuilder(\"Foo\").build();\n+        assertFalse(initializedFoo);  \/\/ sanity\n+\n+        try (Recording recording = new Recording();\n+             var bais = new ByteArrayInputStream(bytes);\n+             var ois = new ObjectInputStream(bais)) {\n+            ois.setObjectInputFilter(fv -> Status.REJECTED);\n+            recording.enable(EventNames.Deserialization);\n+            recording.start();\n+            assertThrows(ICE, () -> ois.readObject());\n+            recording.stop();\n+            List<RecordedEvent> events = Events.fromRecording(recording);\n+            assertEquals(events.size(), 1);\n+            assertEquals(events.get(0).getEventType().getName(), \"jdk.Deserialization\");\n+            assertFilterConfigured(true).accept(events.get(0));\n+            assertFilterStatus(\"REJECTED\").accept(events.get(0));\n+            assertFalse(initializedFoo);\n+            assertType(Foo.class);\n+        }\n+    }\n+}\n+\n+class R implements Serializable { }\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/jfr\/event\/io\/TestDeserializationEvent.java","additions":444,"deletions":0,"binary":false,"changes":444,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -180,0 +180,1 @@\n+        insertSetting(doc, EventNames.Deserialization, \"threshold\", \"0 ns\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestDefaultConfigurations.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -211,1 +211,1 @@\n-        Asserts.assertFalse(lowerCased.contains(\"config\") && !lowerCased.contains(\"configuration\"), \"Use 'configuration' instead of 'config' in name\");\n+        Asserts.assertFalse(lowerCased.contains(\"config\") && !(lowerCased.contains(\"configuration\") || lowerCased.contains(\"filterconfigured\")), \"Use 'configuration' instead of 'config' in name\");\n@@ -213,1 +213,1 @@\n-        Asserts.assertFalse(lowerCased.contains(\"stat\") && !(lowerCased.contains(\"state\") ||lowerCased.contains(\"statistic\")) , \"Use 'statistics' instead of 'stat' in name\");\n+        Asserts.assertFalse(lowerCased.contains(\"stat\") && !(lowerCased.contains(\"state\") ||lowerCased.contains(\"statistic\") ||lowerCased.contains(\"filterstatus\")) , \"Use 'statistics' instead of 'stat' in name\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/metadata\/TestEventMetadata.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -208,0 +208,1 @@\n+        settingValues.put(EventNames.Deserialization + \"#threshold\", \"0 ns\");\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestActiveSettingEvent.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,0 +178,1 @@\n+    public final static String Deserialization = PREFIX + \"Deserialization\";\n","filename":"test\/lib\/jdk\/test\/lib\/jfr\/EventNames.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,229 @@\n+\/*\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.serial;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectOutputStream;\n+import java.io.UncheckedIOException;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import static java.io.ObjectStreamConstants.*;\n+import sun.invoke.util.Wrapper;\n+\n+\/**\n+ * A basic builder of a serial object.\n+ *\/\n+public class SerialObjectBuilder {\n+\n+    private final ObjectOutputStream objectOutputStream;\n+    private final ByteArrayOutputStream byteArrayOutputStream;\n+\n+    private class NameAndType<T> {\n+        String name;\n+        Class<T> type;\n+        public NameAndType(String nm, Class<T>tp) {\n+            name = nm;\n+            type = tp;\n+        }\n+        String name() { return name; }\n+        Class<T> type() { return type; }\n+    }\n+\n+    private String className;\n+    private long suid;\n+    private SerialObjectBuilder superClass;\n+    private final LinkedHashMap<NameAndType<?>, Object> primFields = new LinkedHashMap<>();\n+    private final LinkedHashMap<NameAndType<?>, Object> objectFields = new LinkedHashMap<>();\n+\n+    private SerialObjectBuilder() {\n+        try {\n+            byteArrayOutputStream = new ByteArrayOutputStream();\n+            objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    public static SerialObjectBuilder newBuilder(String className) {\n+        return (new SerialObjectBuilder()).className(className);\n+    }\n+\n+    private SerialObjectBuilder className(String className) {\n+        this.className = className;\n+        return this;\n+    }\n+\n+    public SerialObjectBuilder suid(long suid) {\n+        this.suid = suid;\n+        return this;\n+    }\n+\n+    public SerialObjectBuilder superClass(SerialObjectBuilder superClass) {\n+        this.superClass = superClass;\n+        return this;\n+    }\n+\n+    public <T> SerialObjectBuilder addPrimitiveField(String name, Class<T> type, T value) {\n+        if (!type.isPrimitive())\n+            throw new IllegalArgumentException(\"Unexpected non-primitive field: \" + type);\n+        primFields.put(new NameAndType<>(name, type), value);\n+        return this;\n+    }\n+\n+    public <T> SerialObjectBuilder addField(String name, Class<T> type, T value) {\n+        if (type.isPrimitive())\n+            throw new IllegalArgumentException(\"Unexpected primitive field: \" + type);\n+        objectFields.put(new NameAndType<>(name, type), value);\n+        return this;\n+    }\n+\n+    private static void writeUTF(DataOutputStream out, String str) throws IOException {\n+        assert str.codePoints().noneMatch(cp -> cp > 127); \/\/ only ASCII for now\n+        int utflen = str.length();\n+        assert utflen <= 0xFFFF;  \/\/ only small strings for now\n+        out.writeShort(utflen);\n+        out.writeBytes(str);\n+    }\n+\n+    private void writePrimFieldsDesc(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : primFields.entrySet()) {\n+            Class<?> primClass = entry.getKey().type();\n+            assert primClass.isPrimitive();\n+            assert primClass != void.class;\n+            String pC = descriptorString(primClass);\n+            out.writeByte(pC.getBytes()[0]);   \/\/ prim_typecode\n+            out.writeUTF(entry.getKey().name());                         \/\/ fieldName\n+        }\n+    }\n+\n+    private void writePrimFieldsValues(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : primFields.entrySet()) {\n+            Class<?> cl = entry.getKey().type();\n+            Object value = entry.getValue();\n+            if (cl == Integer.TYPE) out.writeInt((int) value);\n+            else if (cl == Byte.TYPE) out.writeByte((byte) value);\n+            else if (cl == Long.TYPE) out.writeLong((long) value);\n+            else if (cl == Float.TYPE) out.writeFloat((float) value);\n+            else if (cl == Double.TYPE) out.writeDouble((double) value);\n+            else if (cl == Short.TYPE) out.writeShort((short) value);\n+            else if (cl == Character.TYPE) out.writeChar((char) value);\n+            else if (cl == Boolean.TYPE) out.writeBoolean((boolean) value);\n+            else throw new InternalError();\n+        }\n+    }\n+\n+    private void writeObjectFieldDesc(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : objectFields.entrySet()) {\n+            Class<?> cl = entry.getKey().type();\n+            assert !cl.isPrimitive();\n+            \/\/ obj_typecode\n+            if (cl.isArray()) {\n+                out.writeByte('[');\n+            } else {\n+                out.writeByte('L');\n+            }\n+            writeUTF(out, entry.getKey().name());\n+            out.writeByte(TC_STRING);\n+            writeUTF(out, descriptorString(cl));\n+        }\n+    }\n+\n+    private void writeObject(DataOutputStream out, Object value) throws IOException {\n+        objectOutputStream.reset();\n+        byteArrayOutputStream.reset();\n+        objectOutputStream.writeUnshared(value);\n+        out.write(byteArrayOutputStream.toByteArray());\n+    }\n+\n+    private void writeObjectFieldValues(DataOutputStream out) throws IOException {\n+        for (Map.Entry<NameAndType<?>, Object> entry : objectFields.entrySet()) {\n+            Class<?> cl = entry.getKey().type();\n+            assert !cl.isPrimitive();\n+            if (cl == String.class) {\n+                out.writeByte(TC_STRING);\n+                writeUTF(out, (String) entry.getValue());\n+            } else {\n+                writeObject(out, entry.getValue());\n+            }\n+        }\n+    }\n+\n+    private int numFields() {\n+        return primFields.size() + objectFields.size();\n+    }\n+\n+    private static void writeClassDesc(DataOutputStream dos,\n+                                       SerialObjectBuilder sb)\n+        throws IOException\n+    {\n+        dos.writeByte(TC_CLASSDESC);\n+        dos.writeUTF(sb.className);\n+        dos.writeLong(sb.suid);\n+        dos.writeByte(SC_SERIALIZABLE);\n+        dos.writeShort(sb.numFields());      \/\/ number of fields\n+        sb.writePrimFieldsDesc(dos);\n+        sb.writeObjectFieldDesc(dos);\n+        dos.writeByte(TC_ENDBLOCKDATA);   \/\/ no annotations\n+        if (sb.superClass == null) {\n+            dos.writeByte(TC_NULL);       \/\/ no superclasses\n+        } else {\n+            writeClassDesc(dos, sb.superClass);\n+        }\n+    }\n+\n+    public byte[] build() {\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            DataOutputStream dos = new DataOutputStream(baos);\n+            dos.writeShort(STREAM_MAGIC);\n+            dos.writeShort(STREAM_VERSION);\n+            dos.writeByte(TC_OBJECT);\n+            writeClassDesc(dos, this);\n+            if (superClass != null) {\n+                superClass.writePrimFieldsValues(dos);\n+                superClass.writeObjectFieldValues(dos);\n+            }\n+            writePrimFieldsValues(dos);\n+            writeObjectFieldValues(dos);\n+            dos.close();\n+            return baos.toByteArray();\n+        } catch (IOException unexpected) {\n+            throw new AssertionError(unexpected);\n+        }\n+    }\n+\n+    \/\/ Taken from java.lang.Class in OpenJDK 12.\n+    \/\/ Turned into static function. basicTypeString() not in 11.\n+    private static String descriptorString(Class cl) {\n+        if (cl.isPrimitive()) {\n+            return String.valueOf(Wrapper.forPrimitiveType(cl).basicTypeChar());\n+        } else if (cl.isArray()) {\n+            return \"[\" + descriptorString(cl.getComponentType());\n+        } else {\n+            return \"L\" + cl.getName().replace('.', '\/') + \";\";\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/serial\/SerialObjectBuilder.java","additions":229,"deletions":0,"binary":false,"changes":229,"status":"added"}]}