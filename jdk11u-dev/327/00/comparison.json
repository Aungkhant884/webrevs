{"files":[{"patch":"@@ -40,11 +40,3 @@\n-ciMethodData::ciMethodData(MethodData* md) : ciMetadata(md) {\n-  assert(md != NULL, \"no null method data\");\n-  Copy::zero_to_words((HeapWord*) &_orig, sizeof(_orig) \/ sizeof(HeapWord));\n-  _data = NULL;\n-  _data_size = 0;\n-  _extra_data_size = 0;\n-  _current_mileage = 0;\n-  _invocation_counter = 0;\n-  _backedge_counter = 0;\n-  _state = empty_state;\n-  _saw_free_extra_data = false;\n+ciMethodData::ciMethodData(MethodData* md)\n+: ciMetadata(md),\n+  _data_size(0), _extra_data_size(0), _data(NULL),\n@@ -53,1 +45,3 @@\n-  _hint_di = first_di();\n+  _hint_di(first_di()),\n+  _state(empty_state),\n+  _saw_free_extra_data(false),\n@@ -55,25 +49,6 @@\n-  _eflags = _arg_local = _arg_stack = _arg_returned = 0;\n-  _parameters = NULL;\n-}\n-\n-\/\/ ------------------------------------------------------------------\n-\/\/ ciMethodData::ciMethodData\n-\/\/\n-\/\/ No MethodData*.\n-ciMethodData::ciMethodData() : ciMetadata(NULL) {\n-  Copy::zero_to_words((HeapWord*) &_orig, sizeof(_orig) \/ sizeof(HeapWord));\n-  _data = NULL;\n-  _data_size = 0;\n-  _extra_data_size = 0;\n-  _current_mileage = 0;\n-  _invocation_counter = 0;\n-  _backedge_counter = 0;\n-  _state = empty_state;\n-  _saw_free_extra_data = false;\n-  \/\/ Set an initial hint. Don't use set_hint_di() because\n-  \/\/ first_di() may be out of bounds if data_size is 0.\n-  _hint_di = first_di();\n-  \/\/ Initialize the escape information (to \"don't know.\");\n-  _eflags = _arg_local = _arg_stack = _arg_returned = 0;\n-  _parameters = NULL;\n-}\n+  _eflags(0), _arg_local(0), _arg_stack(0), _arg_returned(0),\n+  _current_mileage(0),\n+  _invocation_counter(0),\n+  _backedge_counter(0),\n+  _orig(),\n+  _parameters(NULL) {}\n@@ -144,1 +119,2 @@\n-  Copy::disjoint_words_atomic((HeapWord*) mdo,\n+  STATIC_ASSERT(sizeof(_orig) % HeapWordSize == 0); \/\/ \"align\"\n+  Copy::disjoint_words_atomic((HeapWord*) &mdo->_compiler_counters,\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":14,"deletions":38,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -403,4 +403,4 @@\n-  intx              _eflags;          \/\/ flags on escape information\n-  intx              _arg_local;       \/\/ bit set of non-escaping arguments\n-  intx              _arg_stack;       \/\/ bit set of stack-allocatable arguments\n-  intx              _arg_returned;    \/\/ bit set of returned arguments\n+  intx _eflags;       \/\/ flags on escape information\n+  intx _arg_local;    \/\/ bit set of non-escaping arguments\n+  intx _arg_stack;    \/\/ bit set of stack-allocatable arguments\n+  intx _arg_returned; \/\/ bit set of returned arguments\n@@ -418,1 +418,1 @@\n-  MethodData _orig;\n+  MethodData::CompilerCounters _orig;\n@@ -420,2 +420,1 @@\n-  \/\/ Area dedicated to parameters. NULL if no parameter profiling for\n-  \/\/ this method.\n+  \/\/ Area dedicated to parameters. NULL if no parameter profiling for this method.\n@@ -427,2 +426,1 @@\n-  ciMethodData(MethodData* md);\n-  ciMethodData();\n+  ciMethodData(MethodData* md = NULL);\n@@ -557,2 +555,2 @@\n-  uint trap_reason_limit() const { return _orig.trap_reason_limit(); }\n-  uint trap_count_limit()  const { return _orig.trap_count_limit(); }\n+  uint trap_reason_limit() const { return MethodData::trap_reason_limit(); }\n+  uint trap_count_limit()  const { return MethodData::trap_count_limit(); }\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -242,4 +242,4 @@\n-  nonstatic_field(MethodData,                  _nof_decompiles,                               uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_recompiles,                      uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_traps,                           uint)                                  \\\n-  nonstatic_field(MethodData,                  _trap_hist._array[0],                          u1)                                    \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_decompiles,            uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_recompiles,   uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_traps,        uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._trap_hist._array[0],       u1)                                    \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"ci\/ciMethodData.hpp\"\n@@ -712,1 +713,1 @@\n-    MethodData(method(), size, THREAD);\n+    MethodData(method());\n@@ -1134,2 +1135,4 @@\n-MethodData::MethodData(const methodHandle& method, int size, TRAPS)\n-  : _extra_data_lock(Monitor::leaf, \"MDO extra data lock\"),\n+MethodData::MethodData(const methodHandle& method)\n+  : _method(method()),\n+    _extra_data_lock(Mutex::leaf, \"MDO extra data lock\"),\n+    _compiler_counters(method()),\n@@ -1137,2 +1140,0 @@\n-  \/\/ Set the method back-pointer.\n-  _method = method();\n@@ -1147,1 +1148,0 @@\n-  set_creation_mileage(mileage_of(method()));\n@@ -1247,4 +1247,1 @@\n-  \/\/ Initialize flags and trap history.\n-  _nof_decompiles = 0;\n-  _nof_overflow_recompiles = 0;\n-  _nof_overflow_traps = 0;\n+  \/\/ Initialize escape flags.\n@@ -1252,3 +1249,0 @@\n-  assert(sizeof(_trap_hist) % sizeof(HeapWord) == 0, \"align\");\n-  Copy::zero_to_words((HeapWord*) &_trap_hist,\n-                      sizeof(_trap_hist) \/ sizeof(HeapWord));\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"utilities\/copy.hpp\"\n@@ -1948,0 +1949,2 @@\n+class ciMethodData;\n+\n@@ -1954,0 +1957,1 @@\n+  friend class ciMethodData;\n@@ -1969,1 +1973,1 @@\n-  MethodData(const methodHandle& method, int size, TRAPS);\n+  MethodData(const methodHandle& method);\n@@ -1972,1 +1976,0 @@\n-  MethodData() : _extra_data_lock(Monitor::leaf, \"MDO extra data lock\") {}; \/\/ For ciMethodData\n@@ -1983,0 +1986,73 @@\n+\n+  \/\/ Compiler-related counters.\n+  class CompilerCounters {\n+    friend class VMStructs;\n+    friend class JVMCIVMStructs;\n+\n+    int  _creation_mileage;           \/\/ method mileage at MDO creation\n+    uint _nof_decompiles;             \/\/ count of all nmethod removals\n+    uint _nof_overflow_recompiles;    \/\/ recompile count, excluding recomp. bits\n+    uint _nof_overflow_traps;         \/\/ trap count, excluding _trap_hist\n+    union {\n+      intptr_t _align;\n+      u1 _array[JVMCI_ONLY(2 *) MethodData::_trap_hist_limit];\n+    } _trap_hist;\n+\n+    void init_trap_hist() {\n+      STATIC_ASSERT(sizeof(_trap_hist) % HeapWordSize == 0); \/\/ \"align\"\n+      uint size_in_words = sizeof(_trap_hist) \/ HeapWordSize;\n+      Copy::zero_to_words((HeapWord*) &_trap_hist, size_in_words);\n+    }\n+  public:\n+    CompilerCounters(Method* m) : _creation_mileage(MethodData::mileage_of(m)),\n+      _nof_decompiles(0), _nof_overflow_recompiles(0), _nof_overflow_traps(0) {\n+      init_trap_hist();\n+    }\n+    CompilerCounters() : _creation_mileage(0), \/\/ for ciMethodData\n+      _nof_decompiles(0), _nof_overflow_recompiles(0), _nof_overflow_traps(0) {\n+      init_trap_hist();\n+    }\n+\n+    int      creation_mileage() const { return _creation_mileage; }\n+\n+    \/\/ Return (uint)-1 for overflow.\n+    uint trap_count(int reason) const {\n+      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      return (int)((_trap_hist._array[reason]+1) & _trap_hist_mask) - 1;\n+    }\n+\n+    uint inc_trap_count(int reason) {\n+      \/\/ Count another trap, anywhere in this method.\n+      assert(reason >= 0, \"must be single trap\");\n+      assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n+      uint cnt1 = 1 + _trap_hist._array[reason];\n+      if ((cnt1 & _trap_hist_mask) != 0) {  \/\/ if no counter overflow...\n+        _trap_hist._array[reason] = cnt1;\n+        return cnt1;\n+      } else {\n+        return _trap_hist_mask + (++_nof_overflow_traps);\n+      }\n+    }\n+\n+    uint overflow_trap_count() const {\n+      return _nof_overflow_traps;\n+    }\n+    uint overflow_recompile_count() const {\n+      return _nof_overflow_recompiles;\n+    }\n+    uint inc_overflow_recompile_count() {\n+      return ++_nof_overflow_recompiles;\n+    }\n+    uint decompile_count() const {\n+      return _nof_decompiles;\n+    }\n+    uint inc_decompile_count() {\n+      return ++_nof_decompiles;\n+    }\n+\n+    \/\/ Support for code generation\n+    static ByteSize trap_history_offset() {\n+      return byte_offset_of(CompilerCounters, _trap_hist._array);\n+    }\n+  };\n+\n@@ -1984,7 +2060,1 @@\n-  uint _nof_decompiles;             \/\/ count of all nmethod removals\n-  uint _nof_overflow_recompiles;    \/\/ recompile count, excluding recomp. bits\n-  uint _nof_overflow_traps;         \/\/ trap count, excluding _trap_hist\n-  union {\n-    intptr_t _align;\n-    u1 _array[JVMCI_ONLY(2 *) _trap_hist_limit];\n-  } _trap_hist;\n+  CompilerCounters _compiler_counters;\n@@ -1998,2 +2068,0 @@\n-  int _creation_mileage;              \/\/ method mileage at MDO creation\n-\n@@ -2148,2 +2216,1 @@\n-  int      creation_mileage() const  { return _creation_mileage; }\n-  void set_creation_mileage(int x)   { _creation_mileage = x; }\n+  int      creation_mileage() const { return _compiler_counters.creation_mileage(); }\n@@ -2311,2 +2378,1 @@\n-    assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n-    return (int)((_trap_hist._array[reason]+1) & _trap_hist_mask) - 1;\n+    return _compiler_counters.trap_count(reason);\n@@ -2318,10 +2384,1 @@\n-    \/\/ Count another trap, anywhere in this method.\n-    assert(reason >= 0, \"must be single trap\");\n-    assert((uint)reason < JVMCI_ONLY(2*) _trap_hist_limit, \"oob\");\n-    uint cnt1 = 1 + _trap_hist._array[reason];\n-    if ((cnt1 & _trap_hist_mask) != 0) {  \/\/ if no counter overflow...\n-      _trap_hist._array[reason] = cnt1;\n-      return cnt1;\n-    } else {\n-      return _trap_hist_mask + (++_nof_overflow_traps);\n-    }\n+    return _compiler_counters.inc_trap_count(reason);\n@@ -2331,1 +2388,1 @@\n-    return _nof_overflow_traps;\n+    return _compiler_counters.overflow_trap_count();\n@@ -2334,1 +2391,1 @@\n-    return _nof_overflow_recompiles;\n+    return _compiler_counters.overflow_recompile_count();\n@@ -2336,2 +2393,2 @@\n-  void inc_overflow_recompile_count() {\n-    _nof_overflow_recompiles += 1;\n+  uint inc_overflow_recompile_count() {\n+    return _compiler_counters.inc_overflow_recompile_count();\n@@ -2340,1 +2397,1 @@\n-    return _nof_decompiles;\n+    return _compiler_counters.decompile_count();\n@@ -2342,3 +2399,3 @@\n-  void inc_decompile_count() {\n-    _nof_decompiles += 1;\n-    if (decompile_count() > (uint)PerMethodRecompilationCutoff) {\n+  uint inc_decompile_count() {\n+    uint dec_count = _compiler_counters.inc_decompile_count();\n+    if (dec_count > (uint)PerMethodRecompilationCutoff) {\n@@ -2347,0 +2404,1 @@\n+    return dec_count;\n@@ -2372,1 +2430,1 @@\n-    return byte_offset_of(MethodData, _trap_hist._array);\n+    return byte_offset_of(MethodData, _compiler_counters) + CompilerCounters::trap_history_offset();\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":92,"deletions":34,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -280,4 +280,4 @@\n-  nonstatic_field(MethodData,                  _nof_decompiles,                               uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_recompiles,                      uint)                                  \\\n-  nonstatic_field(MethodData,                  _nof_overflow_traps,                           uint)                                  \\\n-  nonstatic_field(MethodData,                  _trap_hist._array[0],                          u1)                                    \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_decompiles,            uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_recompiles,   uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._nof_overflow_traps,        uint)                                  \\\n+  nonstatic_field(MethodData,                  _compiler_counters._trap_hist._array[0],       u1)                                    \\\n@@ -904,1 +904,1 @@\n-  nonstatic_field(ciMethodData,                _orig,                                         MethodData)                            \\\n+  nonstatic_field(ciMethodData,                _orig,                                         MethodData::CompilerCounters)          \\\n@@ -1313,0 +1313,2 @@\n+  declare_toplevel_type(MethodData::CompilerCounters)                     \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -167,1 +167,1 @@\n-    final int methodDataOopTrapHistoryOffset = getFieldOffset(\"MethodData::_trap_hist._array[0]\", Integer.class, \"u1\");\n+    final int methodDataOopTrapHistoryOffset = getFieldOffset(\"MethodData::_compiler_counters._trap_hist._array[0]\", Integer.class, \"u1\");\n@@ -170,3 +170,3 @@\n-    final int methodDataDecompiles = getFieldOffset(\"MethodData::_nof_decompiles\", Integer.class, \"uint\");\n-    final int methodDataOverflowRecompiles = getFieldOffset(\"MethodData::_nof_overflow_recompiles\", Integer.class, \"uint\");\n-    final int methodDataOverflowTraps = getFieldOffset(\"MethodData::_nof_overflow_traps\", Integer.class, \"uint\");\n+    final int methodDataDecompiles = getFieldOffset(\"MethodData::_compiler_counters._nof_decompiles\", Integer.class, \"uint\");\n+    final int methodDataOverflowRecompiles = getFieldOffset(\"MethodData::_compiler_counters._nof_overflow_recompiles\", Integer.class, \"uint\");\n+    final int methodDataOverflowTraps = getFieldOffset(\"MethodData::_compiler_counters._nof_overflow_traps\", Integer.class, \"uint\");\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk.vm.ci.hotspot\/src\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"}]}