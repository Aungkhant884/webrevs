{"files":[{"patch":"@@ -29,4 +29,0 @@\n-import java.util.Collection;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n@@ -37,0 +33,4 @@\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n@@ -355,1 +355,3 @@\n-        return certFacSpi.engineGenerateCertificate(inStream);\n+        Certificate c = certFacSpi.engineGenerateCertificate(inStream);\n+        JCAUtil.tryCommitCertEvent(c);\n+        return c;\n","filename":"src\/java.base\/share\/classes\/java\/security\/cert\/CertificateFactory.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,9 @@\n+    private static final X509CertificateEvent EVENT = new X509CertificateEvent();\n+\n+    \/**\n+     * Returns {@code true} if event is enabled, {@code false} otherwise.\n+     *\/\n+    public static boolean isTurnedOn() {\n+        return EVENT.isEnabled();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/X509CertificateEvent.java","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -30,0 +30,7 @@\n+import java.security.PublicKey;\n+import java.security.cert.Certificate;\n+import java.security.cert.X509Certificate;\n+\n+import jdk.internal.event.EventHelper;\n+import jdk.internal.event.X509CertificateEvent;\n+import sun.security.util.KeyUtil;\n@@ -96,0 +103,42 @@\n+\n+    public static void tryCommitCertEvent(Certificate cert) {\n+        if ((X509CertificateEvent.isTurnedOn() || EventHelper.isLoggingSecurity())) {\n+            if (cert instanceof X509Certificate) {\n+                X509Certificate x509 = (X509Certificate) cert;\n+            PublicKey pKey = x509.getPublicKey();\n+            String algId = x509.getSigAlgName();\n+            String serNum = x509.getSerialNumber().toString(16);\n+            String subject = x509.getSubjectX500Principal().toString();\n+            String issuer = x509.getIssuerX500Principal().toString();\n+            String keyType = pKey.getAlgorithm();\n+            int length = KeyUtil.getKeySize(pKey);\n+            int hashCode = x509.hashCode();\n+            long beginDate = x509.getNotBefore().getTime();\n+            long endDate = x509.getNotAfter().getTime();\n+            if (X509CertificateEvent.isTurnedOn()) {\n+                X509CertificateEvent xce = new X509CertificateEvent();\n+                xce.algorithm = algId;\n+                xce.serialNumber = serNum;\n+                xce.subject = subject;\n+                xce.issuer = issuer;\n+                xce.keyType = keyType;\n+                xce.keyLength = length;\n+                xce.certificateId = hashCode;\n+                xce.validFrom = beginDate;\n+                xce.validUntil = endDate;\n+                xce.commit();\n+            }\n+            if (EventHelper.isLoggingSecurity()) {\n+                EventHelper.logX509CertificateEvent(algId,\n+                        serNum,\n+                        subject,\n+                        issuer,\n+                        keyType,\n+                        length,\n+                        hashCode,\n+                        beginDate,\n+                        endDate);\n+            }\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/jca\/JCAUtil.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import java.security.PublicKey;\n@@ -33,2 +32,0 @@\n-import jdk.internal.event.EventHelper;\n-import jdk.internal.event.X509CertificateEvent;\n@@ -107,2 +104,0 @@\n-                \/\/ record cert details if necessary\n-                commitEvent(cert);\n@@ -476,1 +471,1 @@\n-                coll.add(new X509CertImpl(data));\n+                coll.add(X509CertImpl.newX509CertImpl(data));\n@@ -769,39 +764,0 @@\n-\n-    private void commitEvent(X509CertImpl info) {\n-        X509CertificateEvent xce = new X509CertificateEvent();\n-        if (xce.shouldCommit() || EventHelper.isLoggingSecurity()) {\n-            PublicKey pKey = info.getPublicKey();\n-            String algId = info.getSigAlgName();\n-            String serNum = info.getSerialNumber().toString(16);\n-            String subject = info.getSubjectDN().getName();\n-            String issuer = info.getIssuerDN().getName();\n-            String keyType = pKey.getAlgorithm();\n-            int length = KeyUtil.getKeySize(pKey);\n-            int hashCode = info.hashCode();\n-            long beginDate = info.getNotBefore().getTime();\n-            long endDate = info.getNotAfter().getTime();\n-            if (xce.shouldCommit()) {\n-                xce.algorithm = algId;\n-                xce.serialNumber = serNum;\n-                xce.subject = subject;\n-                xce.issuer = issuer;\n-                xce.keyType = keyType;\n-                xce.keyLength = length;\n-                xce.certificateId = hashCode;\n-                xce.validFrom = beginDate;\n-                xce.validUntil = endDate;\n-                xce.commit();\n-            }\n-            if (EventHelper.isLoggingSecurity()) {\n-                EventHelper.logX509CertificateEvent(algId,\n-                        serNum,\n-                        subject,\n-                        issuer,\n-                        keyType,\n-                        length,\n-                        hashCode,\n-                        beginDate,\n-                        endDate);\n-            }\n-        }\n-    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/X509Factory.java","additions":1,"deletions":45,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -357,1 +357,1 @@\n-                        new X509CertImpl(derCerts[i].toByteArray());\n+                        X509CertImpl.newX509CertImpl(derCerts[i].toByteArray());\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/OCSPResponse.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,1 +243,1 @@\n-                                        (new X509CertImpl(opt.toByteArray()));\n+                                        (X509CertImpl.newX509CertImpl(opt.toByteArray()));\n@@ -254,1 +254,1 @@\n-                                        (new X509CertImpl(opt.toByteArray()));\n+                                        (X509CertImpl.newX509CertImpl(opt.toByteArray()));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/provider\/certpath\/X509CertificatePair.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+import sun.security.jca.JCAUtil;\n@@ -307,0 +308,7 @@\n+    \/\/ helper method to record certificate, if necessary, after construction\n+    public static X509CertImpl newX509CertImpl(byte[] certData) throws CertificateException {\n+        var cert = new X509CertImpl(certData);\n+        JCAUtil.tryCommitCertEvent(cert);\n+        return cert;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/x509\/X509CertImpl.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -34,0 +33,1 @@\n+import jdk.test.lib.jfr.VoidFunction;\n@@ -38,1 +38,1 @@\n- * @bug 8148188\n+ * @bug 8148188 8292033\n@@ -42,0 +42,1 @@\n+ * @modules java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n@@ -46,5 +47,3 @@\n-    public static void main(String[] args) throws Exception {\n-        try (Recording recording = new Recording()) {\n-            recording.enable(EventNames.X509Certificate);\n-            recording.start();\n-\n+    public static void main(String[] args) throws Throwable {\n+        testCall(() -> {\n+            \/\/ test regular cert construction\n@@ -53,1 +52,1 @@\n-            \/\/ Generate twice to make sure only one event per certificate is generated\n+            \/\/ Generate twice to make sure we (now) capture all generate cert events\n@@ -56,0 +55,1 @@\n+        }, 4, true);\n@@ -57,1 +57,18 @@\n-            recording.stop();\n+        testCall(() -> {\n+            \/\/ test generateCertificates method\n+            TestCertificate.certificates();\n+        }, 2, true);\n+\n+        testCall(() -> {\n+            \/\/ test generateCertPath method\n+            TestCertificate.certPath();\n+        }, 4, true);\n+\n+        testCall(() -> {\n+            \/\/ test keytool cert generation with JFR enabled\n+            \/\/ The keytool test will load the dedicated keystore\n+            \/\/ and call CertificateFactory.generateCertificate\n+            \/\/ cacerts\n+            TestCertificate.keyToolTest();\n+        }, -1, false);\n+    }\n@@ -59,0 +76,6 @@\n+    private static void testCall(VoidFunction f, int expected, boolean runAsserts) throws Throwable {\n+        try (Recording recording = new Recording()) {\n+            recording.enable(EventNames.X509Certificate);\n+            recording.start();\n+            f.run();\n+            recording.stop();\n@@ -60,3 +83,7 @@\n-            Asserts.assertEquals(events.size(), 2, \"Incorrect number of X509Certificate events\");\n-            assertEvent(events, TestCertificate.ONE);\n-            assertEvent(events, TestCertificate.TWO);\n+            if (expected >= 0) {\n+                Asserts.assertEquals(events.size(), expected, \"Incorrect number of events\");\n+            }\n+            if (runAsserts) {\n+                assertEvent(events, TestCertificate.ONE);\n+                assertEvent(events, TestCertificate.TWO);\n+            }\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestX509CertificateEvent.java","additions":40,"deletions":13,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n- * @modules jdk.jfr\/jdk.jfr.events\n+ * @modules jdk.jfr\/jdk.jfr.events java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n","filename":"test\/jdk\/jdk\/jfr\/event\/security\/TestX509ValidationEvent.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-import java.security.cert.CertificateFactory;\n@@ -34,0 +33,1 @@\n+ * @modules java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n","filename":"test\/jdk\/jdk\/security\/logging\/TestX509CertificateLog.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+ * @modules java.base\/sun.security.x509 java.base\/sun.security.tools.keytool\n","filename":"test\/jdk\/jdk\/security\/logging\/TestX509ValidationLog.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,10 +27,15 @@\n-import java.security.cert.CertPath;\n-import java.security.cert.CertPathValidator;\n-import java.security.cert.CertificateException;\n-import java.security.cert.CertificateFactory;\n-import java.security.cert.PKIXParameters;\n-import java.security.cert.TrustAnchor;\n-import java.security.cert.X509Certificate;\n-import java.util.Collections;\n-import java.util.Date;\n-import java.util.List;\n+import java.io.IOException;\n+import java.io.SequenceInputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.security.cert.Certificate;\n+import java.util.*;\n+\n+import sun.security.tools.keytool.CertAndKeyGen;\n+import sun.security.x509.X500Name;\n+\n+import jdk.test.lib.JDKToolFinder;\n+import jdk.test.lib.SecurityTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n@@ -161,0 +166,45 @@\n+    public static Collection<? extends Certificate> certificates() throws CertificateException {\n+        ByteArrayInputStream is1 = new ByteArrayInputStream((TestCertificate.ONE.encoded + \"\\n\").getBytes());\n+        ByteArrayInputStream is2 = new ByteArrayInputStream(TestCertificate.TWO.encoded.getBytes());\n+        return CERTIFICATE_FACTORY.generateCertificates(new SequenceInputStream(is1, is2));\n+    }\n+\n+    public static void certPath() throws CertificateException {\n+        CertPath cp = CERTIFICATE_FACTORY.generateCertPath(List.of(TestCertificate.ONE.certificate(),\n+                TestCertificate.TWO.certificate()));\n+\n+        \/\/ Get the encoded form of the CertPath we made\n+        byte[] encoded = cp.getEncoded(\"PKCS7\");\n+        CERTIFICATE_FACTORY.generateCertPath(new ByteArrayInputStream(encoded), \"PKCS7\");\n+    }\n+\n+    public static void keyToolTest() throws Exception {\n+        String config =\n+                \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\\n\" +\n+                \"<configuration version=\\\"2.0\\\" description=\\\"test\\\">\\n\" +\n+                \"    <event name=\\\"jdk.X509Certificate\\\">\\n\" +\n+                \"       <setting name=\\\"enabled\\\">true<\/setting>\\n\" +\n+                \"       <setting name=\\\"stackTrace\\\">true<\/setting>\\n\" +\n+                \"    <\/event>\\n\" +\n+                \"<\/configuration>\";\n+        Files.writeString(Path.of(\"config.jfc\"), config);\n+\n+        SecurityTools.keytool(\"-J-XX:StartFlightRecording=filename=keytool.jfr,settings=config.jfc\",\n+            \"-genkeypair\", \"-alias\", \"testkey\", \"-keyalg\", \"RSA\", \"-keysize\", \"2048\", \"-dname\",\n+            \"CN=8292033.oracle.com,OU=JPG,C=US\", \"-keypass\", \"changeit\",\n+            \"-validity\", \"365\", \"-keystore\", \"keystore.pkcs12\", \"-storepass\", \"changeit\")\n+            .shouldHaveExitValue(0);\n+        \/\/ The keytool command will load the keystore and call CertificateFactory.generateCertificate\n+        jfrTool(\"keytool.jfr\")\n+            .shouldContain(\"8292033.oracle.com\") \/\/ should record our new cert\n+            .shouldNotContain(\"algorithm = N\/A\") \/\/ shouldn't record cert under construction\n+            .shouldHaveExitValue(0);\n+    }\n+\n+    private static OutputAnalyzer jfrTool(String jfrFile) throws Exception {\n+        ProcessBuilder pb = new ProcessBuilder();\n+        pb.command(new String[] { JDKToolFinder.getJDKTool(\"jfr\"), \"print\", \"--events\",\n+                \"jdk.X509Certificate\", jfrFile});\n+        return new OutputAnalyzer(pb.start());\n+    }\n+\n@@ -190,1 +240,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/security\/TestCertificate.java","additions":62,"deletions":12,"binary":false,"changes":74,"status":"modified"}]}