{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,11 +74,1 @@\n-  static void set_path(char* path) {\n-    if (path == NULL) {\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n+  static bool _atexit_registered;\n@@ -97,0 +87,13 @@\n+  static void set_path(char* path) {\n+    if (path == NULL) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n@@ -133,0 +136,1 @@\n+bool AixAttachListener::_atexit_registered = false;\n@@ -180,11 +184,9 @@\n-    static int cleanup_done;\n-    if (!cleanup_done) {\n-      cleanup_done = 1;\n-      AixAttachListener::set_shutdown(true);\n-      int s = AixAttachListener::listener();\n-      if (s != -1) {\n-        ::shutdown(s, 2);\n-      }\n-      if (AixAttachListener::has_path()) {\n-        ::unlink(AixAttachListener::path());\n-      }\n+    AixAttachListener::set_shutdown(true);\n+    int s = AixAttachListener::listener();\n+    if (s != -1) {\n+      AixAttachListener::set_listener(-1);\n+      ::shutdown(s, 2);\n+    }\n+    if (AixAttachListener::has_path()) {\n+      ::unlink(AixAttachListener::path());\n+      AixAttachListener::set_path(NULL);\n@@ -203,1 +205,4 @@\n-  ::atexit(listener_cleanup);\n+  if (!_atexit_registered) {\n+    _atexit_registered = true;\n+    ::atexit(listener_cleanup);\n+  }\n@@ -518,0 +523,20 @@\n+bool AttachListener::check_socket_file() {\n+  int ret;\n+  struct stat64 st;\n+  ret = stat64(AixAttachListener::path(), &st);\n+  if (ret == -1) { \/\/ need to restart attach listener.\n+    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n+                      AixAttachListener::path());\n+\n+    listener_cleanup();\n+\n+    \/\/ wait to terminate current attach listener instance...\n+    while (AttachListener::transit_state(AL_INITIALIZING,\n+                                         AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+      os::naked_yield();\n+    }\n+    return is_init_trigger();\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/os\/aix\/attachListener_aix.cpp","additions":49,"deletions":24,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,11 +71,1 @@\n-  static void set_path(char* path) {\n-    if (path == NULL) {\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n+  static bool _atexit_registered;\n@@ -94,0 +84,13 @@\n+  static void set_path(char* path) {\n+    if (path == NULL) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n@@ -127,0 +130,1 @@\n+bool BsdAttachListener::_atexit_registered = false;\n@@ -161,10 +165,9 @@\n-    static int cleanup_done;\n-    if (!cleanup_done) {\n-      cleanup_done = 1;\n-      int s = BsdAttachListener::listener();\n-      if (s != -1) {\n-        ::close(s);\n-      }\n-      if (BsdAttachListener::has_path()) {\n-        ::unlink(BsdAttachListener::path());\n-      }\n+    int s = BsdAttachListener::listener();\n+    if (s != -1) {\n+      BsdAttachListener::set_listener(-1);\n+      ::shutdown(s, SHUT_RDWR);\n+      ::close(s);\n+    }\n+    if (BsdAttachListener::has_path()) {\n+      ::unlink(BsdAttachListener::path());\n+      BsdAttachListener::set_path(NULL);\n@@ -183,1 +186,4 @@\n-  ::atexit(listener_cleanup);\n+  if (!_atexit_registered) {\n+    _atexit_registered = true;\n+    ::atexit(listener_cleanup);\n+  }\n@@ -488,0 +494,22 @@\n+bool AttachListener::check_socket_file() {\n+  int ret;\n+  struct stat st;\n+  ret = stat(BsdAttachListener::path(), &st);\n+  if (ret == -1) { \/\/ need to restart attach listener.\n+    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n+                      BsdAttachListener::path());\n+\n+    listener_cleanup();\n+\n+    \/\/ wait to terminate current attach listener instance...\n+\n+    while (AttachListener::transit_state(AL_INITIALIZING,\n+\n+                                         AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+      os::naked_yield();\n+    }\n+    return is_init_trigger();\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/os\/bsd\/attachListener_bsd.cpp","additions":51,"deletions":23,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,11 +72,1 @@\n-  static void set_path(char* path) {\n-    if (path == NULL) {\n-      _has_path = false;\n-    } else {\n-      strncpy(_path, path, UNIX_PATH_MAX);\n-      _path[UNIX_PATH_MAX-1] = '\\0';\n-      _has_path = true;\n-    }\n-  }\n-\n-  static void set_listener(int s)               { _listener = s; }\n+  static bool _atexit_registered;\n@@ -95,0 +85,13 @@\n+  static void set_path(char* path) {\n+    if (path == NULL) {\n+      _path[0] = '\\0';\n+      _has_path = false;\n+    } else {\n+      strncpy(_path, path, UNIX_PATH_MAX);\n+      _path[UNIX_PATH_MAX-1] = '\\0';\n+      _has_path = true;\n+    }\n+  }\n+\n+  static void set_listener(int s)               { _listener = s; }\n+\n@@ -128,0 +131,1 @@\n+bool LinuxAttachListener::_atexit_registered = false;\n@@ -162,10 +166,9 @@\n-    static int cleanup_done;\n-    if (!cleanup_done) {\n-      cleanup_done = 1;\n-      int s = LinuxAttachListener::listener();\n-      if (s != -1) {\n-        ::close(s);\n-      }\n-      if (LinuxAttachListener::has_path()) {\n-        ::unlink(LinuxAttachListener::path());\n-      }\n+    int s = LinuxAttachListener::listener();\n+    if (s != -1) {\n+      LinuxAttachListener::set_listener(-1);\n+      ::shutdown(s, SHUT_RDWR);\n+      ::close(s);\n+    }\n+    if (LinuxAttachListener::has_path()) {\n+      ::unlink(LinuxAttachListener::path());\n+      LinuxAttachListener::set_path(NULL);\n@@ -184,1 +187,4 @@\n-  ::atexit(listener_cleanup);\n+  if (!_atexit_registered) {\n+    _atexit_registered = true;\n+    ::atexit(listener_cleanup);\n+  }\n@@ -488,0 +494,20 @@\n+bool AttachListener::check_socket_file() {\n+  int ret;\n+  struct stat64 st;\n+  ret = stat64(LinuxAttachListener::path(), &st);\n+  if (ret == -1) { \/\/ need to restart attach listener.\n+    log_debug(attach)(\"Socket file %s does not exist - Restart Attach Listener\",\n+                      LinuxAttachListener::path());\n+\n+    listener_cleanup();\n+\n+    \/\/ wait to terminate current attach listener instance...\n+    while (AttachListener::transit_state(AL_INITIALIZING,\n+                                         AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+      os::naked_yield();\n+    }\n+    return is_init_trigger();\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/os\/linux\/attachListener_linux.cpp","additions":49,"deletions":23,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,11 +78,1 @@\n-  static void set_door_path(char* path) {\n-    if (path == NULL) {\n-      _has_door_path = false;\n-    } else {\n-      strncpy(_door_path, path, PATH_MAX);\n-      _door_path[PATH_MAX] = '\\0';      \/\/ ensure it's nul terminated\n-      _has_door_path = true;\n-    }\n-  }\n-\n-  static void set_door_descriptor(int dd)               { _door_descriptor = dd; }\n+  static bool _atexit_registered;\n@@ -124,0 +114,13 @@\n+  static void set_door_path(char* path) {\n+    if (path == NULL) {\n+      _door_path[0] = '\\0';\n+      _has_door_path = false;\n+    } else {\n+      strncpy(_door_path, path, PATH_MAX);\n+      _door_path[PATH_MAX] = '\\0';      \/\/ ensure it's nul terminated\n+      _has_door_path = true;\n+    }\n+  }\n+\n+  static void set_door_descriptor(int dd)               { _door_descriptor = dd; }\n+\n@@ -172,0 +175,1 @@\n+bool SolarisAttachListener::_atexit_registered = false;\n@@ -362,12 +366,10 @@\n-    static int cleanup_done;\n-    if (!cleanup_done) {\n-      cleanup_done = 1;\n-      int dd = SolarisAttachListener::door_descriptor();\n-      if (dd >= 0) {\n-        ::close(dd);\n-      }\n-      if (SolarisAttachListener::has_door_path()) {\n-        char* path = SolarisAttachListener::door_path();\n-        ::fdetach(path);\n-        ::unlink(path);\n-      }\n+    int dd = SolarisAttachListener::door_descriptor();\n+    if (dd >= 0) {\n+      SolarisAttachListener::set_door_descriptor(-1);\n+      ::close(dd);\n+    }\n+    if (SolarisAttachListener::has_door_path()) {\n+      char* path = SolarisAttachListener::door_path();\n+      ::fdetach(path);\n+      ::unlink(path);\n+      SolarisAttachListener::set_door_path(NULL);\n@@ -385,1 +387,4 @@\n-  ::atexit(listener_cleanup);\n+  if (!_atexit_registered) {\n+    _atexit_registered = true;\n+    ::atexit(listener_cleanup);\n+  }\n@@ -641,0 +646,20 @@\n+bool AttachListener::check_socket_file() {\n+  int ret;\n+  struct stat64 st;\n+  ret = stat64(SolarisAttachListener::door_path(), &st);\n+  if (ret == -1) { \/\/ need to restart attach listener.\n+    log_debug(attach)(\"Door file %s does not exist - Restart Attach Listener\",\n+                      SolarisAttachListener::door_path());\n+\n+    listener_cleanup();\n+\n+    \/\/ wait to terminate current attach listener instance...\n+    while (AttachListener::transit_state(AL_INITIALIZING,\n+                                         AL_NOT_INITIALIZED) != AL_NOT_INITIALIZED) {\n+      os::naked_yield();\n+    }\n+    return is_init_trigger();\n+  }\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/os\/solaris\/attachListener_solaris.cpp","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -390,0 +390,6 @@\n+\/\/ This function is used for Un*x OSes only.\n+\/\/ We need not to implement it for Windows.\n+bool AttachListener::check_socket_file() {\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -364,2 +364,19 @@\n-        if (!DisableAttachMechanism && AttachListener::is_init_trigger()) {\n-          continue;\n+        if (!DisableAttachMechanism) {\n+          \/\/ Attempt to transit state to AL_INITIALIZING.\n+          AttachListenerState cur_state = AttachListener::transit_state(AL_INITIALIZING, AL_NOT_INITIALIZED);\n+          if (cur_state == AL_INITIALIZING) {\n+            \/\/ Attach Listener has been started to initialize. Ignore this signal.\n+            continue;\n+          } else if (cur_state == AL_NOT_INITIALIZED) {\n+            \/\/ Start to initialize.\n+            if (!AttachListener::is_init_trigger()) {\n+              \/\/ Attach Listener could not be started.\n+              \/\/ So we need to transit the state to AL_NOT_INITIALIZED.\n+              AttachListener::set_state(AL_NOT_INITIALIZED);\n+            }\n+            continue;\n+          } else if (AttachListener::check_socket_file()) {\n+            \/\/ Attach Listener has been started, but unix domain socket file\n+            \/\/ does not exist. So restart Attach Listener.\n+            continue;\n+          }\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-volatile bool AttachListener::_initialized;\n+volatile AttachListenerState AttachListener::_state = AL_NOT_INITIALIZED;\n@@ -351,0 +351,1 @@\n+    AttachListener::set_state(AL_NOT_INITIALIZED);\n@@ -358,0 +359,1 @@\n+      AttachListener::set_state(AL_NOT_INITIALIZED);\n@@ -401,0 +403,2 @@\n+\n+  ShouldNotReachHere();\n@@ -424,0 +428,1 @@\n+    set_state(AL_NOT_INITIALIZED);\n@@ -435,0 +440,1 @@\n+    set_state(AL_NOT_INITIALIZED);\n@@ -448,0 +454,1 @@\n+    set_state(AL_NOT_INITIALIZED);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"metaprogramming\/isRegisteredEnum.hpp\"\n+#include \"runtime\/atomic.hpp\"\n@@ -52,0 +54,8 @@\n+enum AttachListenerState {\n+  AL_NOT_INITIALIZED,\n+  AL_INITIALIZING,\n+  AL_INITIALIZED\n+};\n+\n+template<> struct IsRegisteredEnum<AttachListenerState> : public TrueType {};\n+\n@@ -61,0 +71,3 @@\n+  \/\/ check unix domain socket file on filesystem\n+  static bool check_socket_file() NOT_SERVICES_RETURN_(false);\n+\n@@ -70,0 +83,1 @@\n+\n@@ -71,1 +85,1 @@\n-  static volatile bool _initialized;\n+  static volatile AttachListenerState _state;\n@@ -74,2 +88,20 @@\n-  static bool is_initialized()                  { return _initialized; }\n-  static void set_initialized()                 { _initialized = true; }\n+  static void set_state(AttachListenerState new_state) {\n+    Atomic::store(new_state, &_state);\n+  }\n+\n+  static AttachListenerState get_state() {\n+    return Atomic::load(&_state);\n+  }\n+\n+  static AttachListenerState transit_state(AttachListenerState new_state,\n+                                           AttachListenerState cmp_state) {\n+    return Atomic::cmpxchg(new_state, &_state, cmp_state);\n+  }\n+\n+  static bool is_initialized() {\n+    return Atomic::load(&_state) == AL_INITIALIZED;\n+  }\n+\n+  static void set_initialized() {\n+    Atomic::store(AL_INITIALIZED, &_state);\n+  }\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":35,"deletions":3,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8225690\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @modules jdk.attach\/com.sun.tools.attach\n+ * @run main ConcAttachTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import com.sun.tools.attach.VirtualMachine;\n+import com.sun.tools.attach.AttachNotSupportedException;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class ConcAttachTest implements Runnable {\n+\n+    private static final int NUM_CONC_REQUESTS = 100;\n+\n+    private static final int THREAD_POOL_TIMEOUT_IN_SEC = 30;\n+\n+    private static CountDownLatch latch;\n+\n+    private static String strPID;\n+\n+    \/\/ Attach to LingeredApp concurrently.\n+    public void run() {\n+        VirtualMachine vm = null;\n+\n+        try {\n+            latch.countDown();\n+            latch.await();\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            vm = VirtualMachine.attach(strPID);\n+        } catch (AttachNotSupportedException | IOException e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            try {\n+                vm.detach();\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    private static void checkAttachListenerThread() throws InterruptedException, IOException {\n+        JDKToolLauncher jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\");\n+        jcmd.addToolArg(strPID);\n+        jcmd.addToolArg(\"Thread.print\");\n+\n+        ProcessBuilder pb = new ProcessBuilder(jcmd.getCommand());\n+        Process jcmdProc = pb.start();\n+\n+        OutputAnalyzer out = new OutputAnalyzer(jcmdProc);\n+\n+        jcmdProc.waitFor();\n+\n+        System.out.println(out.getStdout());\n+        System.err.println(out.getStderr());\n+\n+        long numOfAttachListener = out.asLines()\n+                                      .stream()\n+                                      .filter(l -> l.contains(\"Attach Listener\"))\n+                                      .count();\n+\n+        Asserts.assertEquals(1L, numOfAttachListener, \"AttachListener should exist only 1 thread.\");\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        LingeredApp app = null;\n+        latch = new CountDownLatch(NUM_CONC_REQUESTS);\n+        ExecutorService pool = Executors.newFixedThreadPool(NUM_CONC_REQUESTS);\n+\n+        try {\n+            app = LingeredApp.startApp();\n+            strPID = Long.toString(app.getPid());\n+\n+            for (int i = 0; i < NUM_CONC_REQUESTS; i++) {\n+                pool.submit(new ConcAttachTest());\n+            }\n+\n+            pool.shutdown();\n+            pool.awaitTermination(THREAD_POOL_TIMEOUT_IN_SEC, TimeUnit.SECONDS);\n+\n+            checkAttachListenerThread();\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/ConcAttachTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8225193\n+ * @requires os.family != \"windows\"\n+ * @library \/test\/lib\n+ * @run main RemovingUnixDomainSocketTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+import jdk.test.lib.apps.LingeredApp;\n+import jdk.test.lib.JDKToolLauncher;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class RemovingUnixDomainSocketTest {\n+\n+    private static void runJCmd(long pid) throws InterruptedException, IOException {\n+        JDKToolLauncher jcmd = JDKToolLauncher.createUsingTestJDK(\"jcmd\");\n+        jcmd.addToolArg(Long.toString(pid));\n+        jcmd.addToolArg(\"VM.version\");\n+\n+        ProcessBuilder pb = new ProcessBuilder(jcmd.getCommand());\n+        Process jcmdProc = pb.start();\n+\n+        OutputAnalyzer out = new OutputAnalyzer(jcmdProc);\n+\n+        jcmdProc.waitFor();\n+\n+        System.out.println(out.getStdout());\n+        System.err.println(out.getStderr());\n+\n+        out.stderrShouldBeEmpty();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        LingeredApp app = null;\n+        try {\n+            app = LingeredApp.startApp();\n+\n+            \/\/ Access to Attach Listener\n+            runJCmd(app.getPid());\n+\n+            \/\/ Remove unix domain socket file\n+            var sockFile = Path.of(System.getProperty(\"java.io.tmpdir\"),\n+                                   \".java_pid\" + app.getPid())\n+                               .toFile();\n+            System.out.println(\"Remove \" + sockFile.toString());\n+            sockFile.delete();\n+\n+            \/\/ Access to Attach Listener again\n+            runJCmd(app.getPid());\n+        } finally {\n+            LingeredApp.stopApp(app);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/attach\/RemovingUnixDomainSocketTest.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"}]}