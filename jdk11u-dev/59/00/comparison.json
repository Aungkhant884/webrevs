{"files":[{"patch":"@@ -73,0 +73,3 @@\n+    TLS_CHACHA20_POLY1305_SHA256(\n+            0x1303, true, \"TLS_CHACHA20_POLY1305_SHA256\",\n+            ProtocolVersion.PROTOCOLS_OF_13, B_CC20_P1305, H_SHA256),\n@@ -94,0 +97,7 @@\n+    \/\/ Not suite B, but we want it to position the suite early in the list\n+    \/\/ of 1.2 suites.\n+    TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256(\n+            0xCCA9, true, \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\", \"\",\n+            ProtocolVersion.PROTOCOLS_OF_12,\n+            K_ECDHE_ECDSA, B_CC20_P1305, M_NULL, H_SHA256),\n+\n@@ -99,0 +109,4 @@\n+    TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256(\n+            0xCCA8, true, \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", \"\",\n+            ProtocolVersion.PROTOCOLS_OF_12,\n+            K_ECDHE_RSA, B_CC20_P1305, M_NULL, H_SHA256),\n@@ -115,0 +129,4 @@\n+    TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256(\n+            0xCCAA, true, \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\", \"\",\n+            ProtocolVersion.PROTOCOLS_OF_12,\n+            K_DHE_RSA, B_CC20_P1305, M_NULL, H_SHA256),\n@@ -487,2 +505,0 @@\n-    TLS_CHACHA20_POLY1305_SHA256(                    \/\/ TLS 1.3\n-            \"TLS_CHACHA20_POLY1305_SHA256\", 0x1303),\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/CipherSuite.java","additions":18,"deletions":2,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -132,0 +132,5 @@\n+    \/**\n+     * JCE transformation string for ChaCha20-Poly1305\n+     *\/\n+    static final String CIPHER_CHACHA20_POLY1305 = \"ChaCha20-Poly1305\";\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/JsseJce.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -333,0 +333,26 @@\n+        })),\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    B_CC20_P1305(CIPHER_CHACHA20_POLY1305, AEAD_CIPHER, 32, 32, 12,\n+            12, true, false,\n+        (Map.Entry<ReadCipherGenerator,\n+                ProtocolVersion[]>[])(new Map.Entry[] {\n+            new SimpleImmutableEntry<ReadCipherGenerator, ProtocolVersion[]>(\n+                new T12CC20P1305ReadCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_12\n+            ),\n+            new SimpleImmutableEntry<ReadCipherGenerator, ProtocolVersion[]>(\n+                new T13CC20P1305ReadCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_13\n+            )\n+        }),\n+        (Map.Entry<WriteCipherGenerator,\n+                ProtocolVersion[]>[])(new Map.Entry[] {\n+            new SimpleImmutableEntry<WriteCipherGenerator, ProtocolVersion[]>(\n+                new T12CC20P1305WriteCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_12\n+            ),\n+            new SimpleImmutableEntry<WriteCipherGenerator, ProtocolVersion[]>(\n+                new T13CC20P1305WriteCipherGenerator(),\n+                ProtocolVersion.PROTOCOLS_OF_13\n+            )\n@@ -2101,0 +2127,543 @@\n+    private static final class T12CC20P1305ReadCipherGenerator\n+            implements ReadCipherGenerator {\n+\n+        @Override\n+        public SSLReadCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305ReadCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        static final class CC20P1305ReadCipher extends SSLReadCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305ReadCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public Plaintext decrypt(byte contentType, ByteBuffer bb,\n+                    byte[] sequence) throws GeneralSecurityException {\n+                if (bb.remaining() <= tagSize) {\n+                    throw new BadPaddingException(\n+                        \"Insufficient buffer remaining for AEAD cipher \" +\n+                        \"fragment (\" + bb.remaining() + \"). Needs to be \" +\n+                        \"more than tag size (\" + tagSize + \")\");\n+                }\n+\n+                byte[] sn = sequence;\n+                if (sn == null) {\n+                    sn = authenticator.sequenceNumber();\n+                }\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher with the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.DECRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ update the additional authentication data\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                        contentType, bb.remaining() - tagSize, sequence);\n+                cipher.updateAAD(aad);\n+\n+                \/\/ DON'T decrypt the nonce_explicit for AEAD mode. The buffer\n+                \/\/ position has moved out of the nonce_explicit range.\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                ByteBuffer dup = bb.duplicate();\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                        \"Cipher error in AEAD mode \\\"\" + ibse.getMessage() +\n+                        \" \\\"in JCE provider \" + cipher.getProvider().getName());\n+                } catch (ShortBufferException sbe) {\n+                    \/\/ catch BouncyCastle buffering error\n+                    throw new RuntimeException(\"Cipher buffering error in \" +\n+                        \"JCE provider \" + cipher.getProvider().getName(), sbe);\n+                }\n+                \/\/ reset the limit to the end of the decrypted data\n+                bb.position(pos);\n+                bb.limit(pos + len);\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                }\n+\n+                return new Plaintext(contentType,\n+                        ProtocolVersion.NONE.major, ProtocolVersion.NONE.minor,\n+                        -1, -1L, bb.slice());\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int estimateFragmentSize(int packetSize, int headerSize) {\n+                return packetSize - headerSize - tagSize;\n+            }\n+        }\n+    }\n+\n+    private static final class T12CC20P1305WriteCipherGenerator\n+            implements WriteCipherGenerator {\n+        @Override\n+        public SSLWriteCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305WriteCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        private static final class CC20P1305WriteCipher extends SSLWriteCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305WriteCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                keyLimitCountdown = cipherLimits.getOrDefault(\n+                        algorithm.toUpperCase() + \":\" + tag[0], 0L);\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.fine(\"algorithm = \" + algorithm.toUpperCase() +\n+                            \":\" + tag[0] + \"\\ncountdown value = \" +\n+                            keyLimitCountdown);\n+                }\n+                if (keyLimitCountdown > 0) {\n+                    keyLimitEnabled = true;\n+                }\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public int encrypt(byte contentType,\n+                    ByteBuffer bb) {\n+                byte[] sn = authenticator.sequenceNumber();\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher for the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.ENCRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ Update the additional authentication data, using the\n+                \/\/ implicit sequence number of the authenticator.\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                                        contentType, bb.remaining(), null);\n+                cipher.updateAAD(aad);\n+\n+                \/\/ DON'T encrypt the nonce for AEAD mode.\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext before ENCRYPTION\",\n+                            bb.duplicate());\n+                }\n+\n+                ByteBuffer dup = bb.duplicate();\n+                int outputSize = cipher.getOutputSize(dup.remaining());\n+                if (outputSize > bb.remaining()) {\n+                    \/\/ Need to expand the limit of the output buffer for\n+                    \/\/ the authentication tag.\n+                    \/\/\n+                    \/\/ DON'T worry about the buffer's capacity, we have\n+                    \/\/ reserved space for the authentication tag.\n+                    bb.limit(pos + outputSize);\n+                }\n+\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException |\n+                            BadPaddingException | ShortBufferException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                            \"Cipher error in AEAD mode in JCE provider \" +\n+                            cipher.getProvider().getName(), ibse);\n+                }\n+\n+                if (len != outputSize) {\n+                    throw new RuntimeException(\n+                            \"Cipher buffering error in JCE provider \" +\n+                            cipher.getProvider().getName());\n+                }\n+\n+                return len;\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int getExplicitNonceSize() {\n+                return 0;\n+            }\n+\n+            @Override\n+            int calculateFragmentSize(int packetLimit, int headerSize) {\n+                return packetLimit - headerSize - tagSize;\n+            }\n+\n+            @Override\n+            int calculatePacketSize(int fragmentSize, int headerSize) {\n+                return fragmentSize + headerSize + tagSize;\n+            }\n+        }\n+    }\n+\n+    private static final class T13CC20P1305ReadCipherGenerator\n+            implements ReadCipherGenerator {\n+\n+        @Override\n+        public SSLReadCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305ReadCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        static final class CC20P1305ReadCipher extends SSLReadCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305ReadCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public Plaintext decrypt(byte contentType, ByteBuffer bb,\n+                    byte[] sequence) throws GeneralSecurityException {\n+                \/\/ An implementation may receive an unencrypted record of type\n+                \/\/ change_cipher_spec consisting of the single byte value 0x01\n+                \/\/ at any time after the first ClientHello message has been\n+                \/\/ sent or received and before the peer's Finished message has\n+                \/\/ been received and MUST simply drop it without further\n+                \/\/ processing.\n+                if (contentType == ContentType.CHANGE_CIPHER_SPEC.id) {\n+                    return new Plaintext(contentType,\n+                        ProtocolVersion.NONE.major, ProtocolVersion.NONE.minor,\n+                        -1, -1L, bb.slice());\n+                }\n+\n+                if (bb.remaining() <= tagSize) {\n+                    throw new BadPaddingException(\n+                        \"Insufficient buffer remaining for AEAD cipher \" +\n+                        \"fragment (\" + bb.remaining() + \"). Needs to be \" +\n+                        \"more than tag size (\" + tagSize + \")\");\n+                }\n+\n+                byte[] sn = sequence;\n+                if (sn == null) {\n+                    sn = authenticator.sequenceNumber();\n+                }\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher with the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.DECRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ Update the additional authentication data, using the\n+                \/\/ implicit sequence number of the authenticator.\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                                        contentType, bb.remaining(), sn);\n+                cipher.updateAAD(aad);\n+\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                ByteBuffer dup = bb.duplicate();\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                        \"Cipher error in AEAD mode \\\"\" + ibse.getMessage() +\n+                        \" \\\"in JCE provider \" + cipher.getProvider().getName());\n+                } catch (ShortBufferException sbe) {\n+                    \/\/ catch BouncyCastle buffering error\n+                    throw new RuntimeException(\"Cipher buffering error in \" +\n+                        \"JCE provider \" + cipher.getProvider().getName(), sbe);\n+                }\n+                \/\/ reset the limit to the end of the decrypted data\n+                bb.position(pos);\n+                bb.limit(pos + len);\n+\n+                \/\/ remove inner plaintext padding\n+                int i = bb.limit() - 1;\n+                for (; i > 0 && bb.get(i) == 0; i--) {\n+                    \/\/ blank\n+                }\n+                if (i < (pos + 1)) {\n+                    throw new BadPaddingException(\n+                            \"Incorrect inner plaintext: no content type\");\n+                }\n+                contentType = bb.get(i);\n+                bb.limit(i);\n+\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext after DECRYPTION\", bb.duplicate());\n+                }\n+\n+                return new Plaintext(contentType,\n+                        ProtocolVersion.NONE.major, ProtocolVersion.NONE.minor,\n+                        -1, -1L, bb.slice());\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int estimateFragmentSize(int packetSize, int headerSize) {\n+                return packetSize - headerSize - tagSize;\n+            }\n+        }\n+    }\n+\n+    private static final class T13CC20P1305WriteCipherGenerator\n+            implements WriteCipherGenerator {\n+        @Override\n+        public SSLWriteCipher createCipher(SSLCipher sslCipher,\n+                Authenticator authenticator, ProtocolVersion protocolVersion,\n+                String algorithm, Key key, AlgorithmParameterSpec params,\n+                SecureRandom random) throws GeneralSecurityException {\n+            return new CC20P1305WriteCipher(authenticator, protocolVersion,\n+                    sslCipher, algorithm, key, params, random);\n+        }\n+\n+        private static final class CC20P1305WriteCipher extends SSLWriteCipher {\n+            private final Cipher cipher;\n+            private final int tagSize;\n+            private final Key key;\n+            private final byte[] iv;\n+            private final SecureRandom random;\n+\n+            CC20P1305WriteCipher(Authenticator authenticator,\n+                    ProtocolVersion protocolVersion,\n+                    SSLCipher sslCipher, String algorithm,\n+                    Key key, AlgorithmParameterSpec params,\n+                    SecureRandom random) throws GeneralSecurityException {\n+                super(authenticator, protocolVersion);\n+                this.cipher = JsseJce.getCipher(algorithm);\n+                this.tagSize = sslCipher.tagSize;\n+                this.key = key;\n+                this.iv = ((IvParameterSpec)params).getIV();\n+                this.random = random;\n+\n+                keyLimitCountdown = cipherLimits.getOrDefault(\n+                        algorithm.toUpperCase() + \":\" + tag[0], 0L);\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.fine(\"algorithm = \" + algorithm.toUpperCase() +\n+                            \":\" + tag[0] + \"\\ncountdown value = \" +\n+                            keyLimitCountdown);\n+                }\n+                if (keyLimitCountdown > 0) {\n+                    keyLimitEnabled = true;\n+                }\n+\n+                \/\/ DON'T initialize the cipher for AEAD!\n+            }\n+\n+            @Override\n+            public int encrypt(byte contentType,\n+                    ByteBuffer bb) {\n+                byte[] sn = authenticator.sequenceNumber();\n+                byte[] nonce = new byte[iv.length];\n+                System.arraycopy(sn, 0, nonce, nonce.length - sn.length,\n+                        sn.length);\n+                for (int i = 0; i < nonce.length; i++) {\n+                    nonce[i] ^= iv[i];\n+                }\n+\n+                \/\/ initialize the AEAD cipher for the unique IV\n+                AlgorithmParameterSpec spec = new IvParameterSpec(nonce);\n+                try {\n+                    cipher.init(Cipher.ENCRYPT_MODE, key, spec, random);\n+                } catch (InvalidKeyException |\n+                            InvalidAlgorithmParameterException ikae) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                                \"invalid key or spec in AEAD mode\", ikae);\n+                }\n+\n+                \/\/ Update the additional authentication data, using the\n+                \/\/ implicit sequence number of the authenticator.\n+                int outputSize = cipher.getOutputSize(bb.remaining());\n+                byte[] aad = authenticator.acquireAuthenticationBytes(\n+                                        contentType, outputSize, sn);\n+                cipher.updateAAD(aad);\n+\n+                int len = bb.remaining();\n+                int pos = bb.position();\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"plaintext\")) {\n+                    SSLLogger.fine(\n+                            \"Plaintext before ENCRYPTION\",\n+                            bb.duplicate());\n+                }\n+\n+                ByteBuffer dup = bb.duplicate();\n+                if (outputSize > bb.remaining()) {\n+                    \/\/ Need to expand the limit of the output buffer for\n+                    \/\/ the authentication tag.\n+                    \/\/\n+                    \/\/ DON'T worry about the buffer's capacity, we have\n+                    \/\/ reserved space for the authentication tag.\n+                    bb.limit(pos + outputSize);\n+                }\n+\n+                try {\n+                    len = cipher.doFinal(dup, bb);\n+                } catch (IllegalBlockSizeException |\n+                            BadPaddingException | ShortBufferException ibse) {\n+                    \/\/ unlikely to happen\n+                    throw new RuntimeException(\n+                            \"Cipher error in AEAD mode in JCE provider \" +\n+                            cipher.getProvider().getName(), ibse);\n+                }\n+\n+                if (len != outputSize) {\n+                    throw new RuntimeException(\n+                            \"Cipher buffering error in JCE provider \" +\n+                            cipher.getProvider().getName());\n+                }\n+\n+                if (keyLimitEnabled) {\n+                    keyLimitCountdown -= len;\n+                }\n+                return len;\n+            }\n+\n+            @Override\n+            void dispose() {\n+                if (cipher != null) {\n+                    try {\n+                        cipher.doFinal();\n+                    } catch (Exception e) {\n+                        \/\/ swallow all types of exceptions.\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            int getExplicitNonceSize() {\n+                return 0;\n+            }\n+\n+            @Override\n+            int calculateFragmentSize(int packetLimit, int headerSize) {\n+                return packetLimit - headerSize - tagSize;\n+            }\n+\n+            @Override\n+            int calculatePacketSize(int fragmentSize, int headerSize) {\n+                return fragmentSize + headerSize + tagSize;\n+            }\n+        }\n+    }\n+\n@@ -2386,1 +2955,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLCipher.java","additions":569,"deletions":1,"binary":false,"changes":570,"status":"modified"},{"patch":"@@ -121,0 +121,2 @@\n+    TLS_CHACHA20_POLY1305_SHA256(\n+            0x1303, null, Protocol.TLSV1_3, Protocol.TLSV1_3),\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/CipherSuite.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -185,1 +185,2 @@\n-            \"TLS_AES_128_GCM_SHA256\"\n+            \"TLS_AES_128_GCM_SHA256\",\n+            \"TLS_CHACHA20_POLY1305_SHA256\"\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/SSLEngineTestCase.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+        \"TLS_CHACHA20_POLY1305_SHA256\",\n@@ -45,0 +46,1 @@\n+        \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -46,0 +48,1 @@\n+        \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -50,0 +53,1 @@\n+        \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -121,0 +125,1 @@\n+        \"TLS_CHACHA20_POLY1305_SHA256\",\n@@ -123,0 +128,1 @@\n+        \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -124,0 +130,1 @@\n+        \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -128,0 +135,1 @@\n+        \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n","filename":"test\/jdk\/javax\/net\/ssl\/sanity\/ciphersuites\/CheckCipherSuites.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+        \"TLS_CHACHA20_POLY1305_SHA256\",\n@@ -48,0 +49,1 @@\n+        \"TLS_ECDHE_ECDSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -49,0 +51,1 @@\n+        \"TLS_ECDHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n@@ -53,0 +56,1 @@\n+        \"TLS_DHE_RSA_WITH_CHACHA20_POLY1305_SHA256\",\n","filename":"test\/jdk\/javax\/net\/ssl\/sanity\/ciphersuites\/CipherSuitesInOrder.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"}]}