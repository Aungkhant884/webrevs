{"files":[{"patch":"@@ -50,1 +50,1 @@\n-  ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm->masm(), addr, cmpval, newval, \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, result);\n+  ShenandoahBarrierSet::assembler()->cmpxchg_oop(masm->masm(), addr, cmpval, newval, \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, result);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/c1\/shenandoahBarrierSetC1_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -409,3 +409,58 @@\n-\n-void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm, Register addr, Register expected, Register new_val,\n-                                                bool acquire, bool release, bool weak, bool is_cae,\n+\/\/ Special Shenandoah CAS implementation that handles false negatives due\n+\/\/ to concurrent evacuation.  The service is more complex than a\n+\/\/ traditional CAS operation because the CAS operation is intended to\n+\/\/ succeed if the reference at addr exactly matches expected or if the\n+\/\/ reference at addr holds a pointer to a from-space object that has\n+\/\/ been relocated to the location named by expected.  There are two\n+\/\/ races that must be addressed:\n+\/\/  a) A parallel thread may mutate the contents of addr so that it points\n+\/\/     to a different object.  In this case, the CAS operation should fail.\n+\/\/  b) A parallel thread may heal the contents of addr, replacing a\n+\/\/     from-space pointer held in addr with the to-space pointer\n+\/\/     representing the new location of the object.\n+\/\/ Upon entry to cmpxchg_oop, it is assured that new_val equals NULL\n+\/\/ or it refers to an object that is not being evacuated out of\n+\/\/ from-space, or it refers to the to-space version of an object that\n+\/\/ is being evacuated out of from-space.\n+\/\/\n+\/\/ By default, this operation implements sequential consistency and the\n+\/\/ value held in the result register following execution of the\n+\/\/ generated code sequence is 0 to indicate failure of CAS, non-zero\n+\/\/ to indicate success.  Arguments support variations on this theme:\n+\/\/\n+\/\/  acquire: Allow relaxation of the memory ordering on CAS from\n+\/\/           sequential consistency.  This can be useful when\n+\/\/           sequential consistency is not required, such as when\n+\/\/           another sequentially consistent operation is already\n+\/\/           present in the execution stream.  If acquire, successful\n+\/\/           execution has the side effect of assuring that memory\n+\/\/           values updated by other threads and \"released\" will be\n+\/\/           visible to any read operations perfomed by this thread\n+\/\/           which follow this operation in program order.  This is a\n+\/\/           special optimization that should not be enabled by default.\n+\/\/  release: Allow relaxation of the memory ordering on CAS from\n+\/\/           sequential consistency.  This can be useful when\n+\/\/           sequential consistency is not required, such as when\n+\/\/           another sequentially consistent operation is already\n+\/\/           present in the execution stream.  If release, successful\n+\/\/           completion of this operation has the side effect of\n+\/\/           assuring that all writes to memory performed by this\n+\/\/           thread that precede this operation in program order are\n+\/\/           visible to all other threads that subsequently \"acquire\"\n+\/\/           before reading the respective memory values.  This is a\n+\/\/           special optimization that should not be enabled by default.\n+\/\/  is_cae:  This turns CAS (compare and swap) into CAE (compare and\n+\/\/           exchange).  This HotSpot convention is that CAE makes\n+\/\/           available to the caller the \"failure witness\", which is\n+\/\/           the value that was stored in memory which did not match\n+\/\/           the expected value.  If is_cae, the result is the value\n+\/\/           most recently fetched from addr rather than a boolean\n+\/\/           success indicator.\n+\/\/\n+\/\/ Clobbers rscratch1, rscratch2\n+void ShenandoahBarrierSetAssembler::cmpxchg_oop(MacroAssembler* masm,\n+                                                Register addr,\n+                                                Register expected,\n+                                                Register new_val,\n+                                                bool acquire, bool release,\n+                                                bool is_cae,\n@@ -421,1 +476,1 @@\n-  Label retry, done, fail;\n+  Label step4, done;\n@@ -423,16 +478,60 @@\n-  \/\/ CAS, using LL\/SC pair.\n-  __ bind(retry);\n-  __ load_exclusive(tmp1, addr, size, acquire);\n-  if (is_narrow) {\n-    __ cmpw(tmp1, expected);\n-  } else {\n-    __ cmp(tmp1, expected);\n-  }\n-  __ br(Assembler::NE, fail);\n-  __ store_exclusive(tmp2, new_val, addr, size, release);\n-  if (weak) {\n-    __ cmpw(tmp2, 0u); \/\/ If the store fails, return NE to our caller\n-  } else {\n-    __ cbnzw(tmp2, retry);\n-  }\n-  __ b(done);\n+  \/\/ There are two ways to reach this label.  Initial entry into the\n+  \/\/ cmpxchg_oop code expansion starts at step1 (which is equivalent\n+  \/\/ to label step4).  Additionally, in the rare case that four steps\n+  \/\/ are required to perform the requested operation, the fourth step\n+  \/\/ is the same as the first.  On a second pass through step 1,\n+  \/\/ control may flow through step 2 on its way to failure.  It will\n+  \/\/ not flow from step 2 to step 3 since we are assured that the\n+  \/\/ memory at addr no longer holds a from-space pointer.\n+  \/\/\n+  \/\/ The comments that immediately follow the step4 label apply only\n+  \/\/ to the case in which control reaches this label by branch from\n+  \/\/ step 3.\n+\n+  __ bind (step4);\n+\n+  \/\/ Step 4. CAS has failed because the value most recently fetched\n+  \/\/ from addr (which is now held in tmp1) is no longer the from-space\n+  \/\/ pointer held in tmp2.  If a different thread replaced the\n+  \/\/ in-memory value with its equivalent to-space pointer, then CAS\n+  \/\/ may still be able to succeed.  The value held in the expected\n+  \/\/ register has not changed.\n+  \/\/\n+  \/\/ It is extremely rare we reach this point.  For this reason, the\n+  \/\/ implementation opts for smaller rather than potentially faster\n+  \/\/ code.  Ultimately, smaller code for this rare case most likely\n+  \/\/ delivers higher overall throughput by enabling improved icache\n+  \/\/ performance.\n+\n+  \/\/ Step 1. Fast-path.\n+  \/\/\n+  \/\/ Try to CAS with given arguments.  If successful, then we are done.\n+  \/\/\n+  \/\/ No label required for step 1.\n+\n+  __ cmpxchg(addr, expected, new_val, size, acquire, release, false, tmp2);\n+  \/\/ EQ flag set iff success.  tmp2 holds value fetched.\n+\n+  \/\/ If expected equals null but tmp2 does not equal null, the\n+  \/\/ following branches to done to report failure of CAS.  If both\n+  \/\/ expected and tmp2 equal null, the following branches to done to\n+  \/\/ report success of CAS.  There's no need for a special test of\n+  \/\/ expected equal to null.\n+\n+  __ br(Assembler::EQ, done);\n+  \/\/ if CAS failed, fall through to step 2\n+\n+  \/\/ Step 2. CAS has failed because the value held at addr does not\n+  \/\/ match expected.  This may be a false negative because the value fetched\n+  \/\/ from addr (now held in tmp2) may be a from-space pointer to the\n+  \/\/ original copy of same object referenced by to-space pointer expected.\n+  \/\/\n+  \/\/ To resolve this, it suffices to find the forward pointer associated\n+  \/\/ with fetched value.  If this matches expected, retry CAS with new\n+  \/\/ parameters.  If this mismatches, then we have a legitimate\n+  \/\/ failure, and we're done.\n+  \/\/\n+  \/\/ No need for step2 label.\n+\n+  \/\/ overwrite tmp1 with from-space pointer fetched from memory\n+  __ mov(tmp1, tmp2);\n@@ -440,5 +539,0 @@\n- __  bind(fail);\n-  \/\/ Check if rb(expected)==rb(tmp1)\n-  \/\/ Shuffle registers so that we have memory value ready for next expected.\n-  __ mov(tmp2, expected);\n-  __ mov(expected, tmp1);\n@@ -446,0 +540,1 @@\n+    \/\/ Decode tmp1 in order to resolve its forward pointer\n@@ -447,1 +542,0 @@\n-    __ decode_heap_oop(tmp2, tmp2);\n@@ -450,8 +544,40 @@\n-  resolve_forward_pointer(masm, tmp2);\n-  __ cmp(tmp1, tmp2);\n-  \/\/ Retry with expected now being the value we just loaded from addr.\n-  __ br(Assembler::EQ, retry);\n-  if (is_cae && is_narrow) {\n-    \/\/ For cmp-and-exchange and narrow oops, we need to restore\n-    \/\/ the compressed old-value. We moved it to 'expected' a few lines up.\n-    __ mov(tmp1, expected);\n+  \/\/ Encode tmp1 to compare against expected.\n+  __ encode_heap_oop(tmp1, tmp1);\n+\n+  \/\/ Does forwarded value of fetched from-space pointer match original\n+  \/\/ value of expected?  If tmp1 holds null, this comparison will fail\n+  \/\/ because we know from step1 that expected is not null.  There is\n+  \/\/ no need for a separate test for tmp1 (the value originally held\n+  \/\/ in memory) equal to null.\n+  __ cmp(tmp1, expected);\n+\n+  \/\/ If not, then the failure was legitimate and we're done.\n+  \/\/ Branching to done with NE condition denotes failure.\n+  __ br(Assembler::NE, done);\n+\n+  \/\/ Fall through to step 3.  No need for step3 label.\n+\n+  \/\/ Step 3.  We've confirmed that the value originally held in memory\n+  \/\/ (now held in tmp2) pointed to from-space version of original\n+  \/\/ expected value.  Try the CAS again with the from-space expected\n+  \/\/ value.  If it now succeeds, we're good.\n+  \/\/\n+  \/\/ Note: tmp2 holds encoded from-space pointer that matches to-space\n+  \/\/ object residing at expected.  tmp2 is the new \"expected\".\n+\n+  \/\/ Note that macro implementation of __cmpxchg cannot use same register\n+  \/\/ tmp2 for result and expected since it overwrites result before it\n+  \/\/ compares result with expected.\n+  __ cmpxchg(addr, tmp2, new_val, size, acquire, release, false, tmp1);\n+  \/\/ EQ flag set iff success.  tmp2 holds value fetched.\n+\n+  \/\/ If fetched value did not equal the new expected, this could\n+  \/\/ still be a false negative because some other thread may have\n+  \/\/ newly overwritten the memory value with its to-space equivalent.\n+  __ br(Assembler::NE, step4);\n+\n+  if (is_cae) {\n+    \/\/ We're falling through to done to indicate success.  Success\n+    \/\/ with is_cae is denoted by returning the value of expected as\n+    \/\/ result.\n+    __ mov(tmp2, expected);\n@@ -459,0 +585,1 @@\n+\n@@ -460,0 +587,4 @@\n+  \/\/ At entry to done, the Z (EQ) flag is on iff if the CAS\n+  \/\/ operation was successful.  Additionally, if is_cae, tmp2 holds\n+  \/\/ the value most recently fetched from addr. In this case, success\n+  \/\/ is denoted by tmp2 matching expected.\n@@ -462,1 +593,1 @@\n-    __ mov(result, tmp1);\n+    __ mov(result, tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.cpp","additions":166,"deletions":35,"binary":false,"changes":201,"status":"modified"},{"patch":"@@ -85,1 +85,1 @@\n-                           bool acquire, bool release, bool weak, bool is_cae, Register result);\n+                           bool acquire, bool release, bool is_cae, Register result);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoahBarrierSetAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-                                                   \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, $res$$Register);\n+                                                   \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n@@ -45,1 +45,1 @@\n-                                                   \/*acquire*\/ true, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, $res$$Register);\n+                                                   \/*acquire*\/ true, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n@@ -79,1 +79,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, $res$$Register);\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n@@ -117,1 +117,1 @@\n-    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ true, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ false, $res$$Register);\n+    ShenandoahBarrierSet::assembler()->cmpxchg_oop(&_masm, $mem$$Register, tmp, $newval$$Register, \/*acquire*\/ true, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n@@ -134,1 +134,1 @@\n-                   \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ true, $res$$Register);\n+                                                   \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ true, $res$$Register);\n@@ -150,1 +150,1 @@\n-                   \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ false, \/*is_cae*\/ true, $res$$Register);\n+                                                   \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ true, $res$$Register);\n@@ -165,0 +165,1 @@\n+    \/\/ Weak is not currently supported by ShenandoahBarrierSet::cmpxchg_oop\n@@ -166,1 +167,1 @@\n-                   \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ true, \/*is_cae*\/ false, $res$$Register);\n+                                                   \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n@@ -181,0 +182,1 @@\n+    \/\/ Weak is not currently supported by ShenandoahBarrierSet::cmpxchg_oop\n@@ -182,1 +184,1 @@\n-                   \/*acquire*\/ false, \/*release*\/ true, \/*weak*\/ true, \/*is_cae*\/ false, $res$$Register);\n+                                                   \/*acquire*\/ false, \/*release*\/ true, \/*is_cae*\/ false, $res$$Register);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shenandoah\/shenandoah_aarch64.ad","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"}]}