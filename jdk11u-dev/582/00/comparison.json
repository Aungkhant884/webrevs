{"files":[{"patch":"@@ -49,1 +49,1 @@\n-define_pd_global(intx, LoopPercentProfileLimit,      30);\n+define_pd_global(intx, LoopPercentProfileLimit,      10);\n","filename":"src\/hotspot\/cpu\/x86\/c2_globals_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (C) 2021 THL A29 Limited, a Tencent company. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.*;\n+import java.util.concurrent.TimeUnit;\n+\n+@Warmup(iterations = 3, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@BenchmarkMode(Mode.Throughput)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@State(Scope.Thread)\n+@Fork(value=1)\n+public class LoopUnroll {\n+    @Param({\"16\", \"32\", \"64\", \"128\", \"256\", \"512\", \"1024\"})\n+    private int VECLEN;\n+\n+    private byte[][] a;\n+    private byte[][] b;\n+    private byte[][] c;\n+\n+    @Setup\n+    public void init() {\n+        a = new byte[VECLEN][VECLEN];\n+        b = new byte[VECLEN][VECLEN];\n+        c = new byte[VECLEN][VECLEN];\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private int run_workload1(int count, byte[][] a , byte[][] b, byte[][] c) {\n+        for(int i = 0; i < a.length; i++) {\n+            for (int j = 0; j < a[0].length; j++) {\n+                a[i][j] = (byte)(b[i][j] + c[i][j]);\n+            }\n+        }\n+        return a[count][count];\n+    }\n+\n+    @Benchmark\n+    public void workload1_caller(Blackhole bh) {\n+        int r = 0;\n+        for(int i = 0 ; i < 100; i++) {\n+            r += run_workload1(i % a.length, a, b, c);\n+        }\n+        bh.consume(r);\n+    }\n+\n+    @CompilerControl(CompilerControl.Mode.DONT_INLINE)\n+    private int run_workload2(int count, byte[][] a , byte[][] b) {\n+        for(int i = 0; i < b.length; i++) {\n+            for (int j = 0; j < b[0].length; j++) {\n+                a[i][j] = b[i][j];\n+            }\n+        }\n+        return a[count][count];\n+    }\n+\n+    @Benchmark\n+    public void workload2_caller(Blackhole bh) {\n+        int r = 0;\n+        for(int i = 0 ; i < 100; i++) {\n+            r += run_workload2(i % a.length, a, b);\n+        }\n+        bh.consume(r);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/LoopUnroll.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"}]}