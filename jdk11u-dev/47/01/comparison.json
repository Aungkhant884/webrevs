{"files":[{"patch":"@@ -42,0 +42,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -63,0 +64,1 @@\n+static bool _clear_artifacts = false;\n@@ -83,0 +85,4 @@\n+static bool is_initial_typeset_for_chunk() {\n+  return _clear_artifacts && !_class_unload;\n+}\n+\n@@ -99,0 +105,29 @@\n+static const char* primitive_name(KlassPtr type_array_klass) {\n+  switch (type_array_klass->name()->base()[1]) {\n+    case JVM_SIGNATURE_BOOLEAN: return \"boolean\";\n+    case JVM_SIGNATURE_BYTE: return \"byte\";\n+    case JVM_SIGNATURE_CHAR: return \"char\";\n+    case JVM_SIGNATURE_SHORT: return \"short\";\n+    case JVM_SIGNATURE_INT: return \"int\";\n+    case JVM_SIGNATURE_LONG: return \"long\";\n+    case JVM_SIGNATURE_FLOAT: return \"float\";\n+    case JVM_SIGNATURE_DOUBLE: return \"double\";\n+  }\n+  assert(false, \"invalid type array klass\");\n+  return NULL;\n+}\n+\n+static Symbol* primitive_symbol(KlassPtr type_array_klass) {\n+  if (type_array_klass == NULL) {\n+    \/\/ void.class\n+    static Symbol* const void_class_name = SymbolTable::probe(\"void\", 4);\n+    assert(void_class_name != NULL, \"invariant\");\n+    return void_class_name;\n+  }\n+  const char* const primitive_type_str = primitive_name(type_array_klass);\n+  assert(primitive_type_str != NULL, \"invariant\");\n+  Symbol* const primitive_type_sym = SymbolTable::probe(primitive_type_str, (int)strlen(primitive_type_str));\n+  assert(primitive_type_sym != NULL, \"invariant\");\n+  return primitive_type_sym;\n+}\n+\n@@ -155,0 +190,5 @@\n+\/\/ Same as JVM_GetClassModifiers\n+static u4 get_primitive_flags() {\n+  return JVM_ACC_ABSTRACT | JVM_ACC_FINAL | JVM_ACC_PUBLIC;\n+}\n+\n@@ -263,0 +303,41 @@\n+static traceid primitive_id(KlassPtr array_klass) {\n+  if (array_klass == NULL) {\n+    \/\/ The first klass id is reserved for the void.class.\n+    return MaxJfrEventId + 101;\n+  }\n+  \/\/ Derive the traceid for a primitive mirror from its associated array klass (+1).\n+  return JfrTraceId::get(array_klass) + 1;\n+}\n+\n+static void write_primitive(JfrCheckpointWriter* writer, KlassPtr type_array_klass) {\n+  assert(writer != NULL, \"invariant\");\n+  assert(_artifacts != NULL, \"invariant\");\n+  writer->write(primitive_id(type_array_klass));\n+  writer->write(cld_id(get_cld(Universe::boolArrayKlassObj()), false));\n+  writer->write(mark_symbol(primitive_symbol(type_array_klass), false));\n+  writer->write(package_id(Universe::boolArrayKlassObj(), false));\n+  writer->write(get_primitive_flags());\n+}\n+\n+static int primitives_count = 9;\n+\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static void do_primitives() {\n+  \/\/ Only write the primitive classes once per chunk.\n+  if (is_initial_typeset_for_chunk()) {\n+    write_primitive(_writer, Universe::boolArrayKlassObj());\n+    write_primitive(_writer, Universe::byteArrayKlassObj());\n+    write_primitive(_writer, Universe::charArrayKlassObj());\n+    write_primitive(_writer, Universe::shortArrayKlassObj());\n+    write_primitive(_writer, Universe::intArrayKlassObj());\n+    write_primitive(_writer, Universe::longArrayKlassObj());\n+    write_primitive(_writer, Universe::singleArrayKlassObj());\n+    write_primitive(_writer, Universe::doubleArrayKlassObj());\n+    write_primitive(_writer, NULL); \/\/ void.class\n+  }\n+}\n+\n@@ -269,0 +350,1 @@\n+  do_primitives();\n@@ -313,0 +395,5 @@\n+  if (is_initial_typeset_for_chunk()) {\n+    \/\/ Because the set of primitives is written outside the callback,\n+    \/\/ their count is not automatically incremented.\n+    kw.add(primitives_count);\n+  }\n@@ -890,2 +977,0 @@\n-static bool clear_artifacts = false;\n-\n@@ -893,1 +978,1 @@\n-  clear_artifacts = true;\n+  _clear_artifacts = true;\n@@ -907,1 +992,1 @@\n-    JfrTypeSet::clear();\n+    _clear_artifacts = true;\n@@ -909,0 +994,2 @@\n+  } else {\n+    _clear_artifacts = false;\n@@ -920,1 +1007,1 @@\n-    _artifacts->initialize(class_unload, clear_artifacts);\n+    _artifacts->initialize(class_unload, _clear_artifacts);\n@@ -922,1 +1009,0 @@\n-  clear_artifacts = false;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":92,"deletions":6,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n-  static volatile traceid class_id_counter = MaxJfrEventId + 100;\n+  static volatile traceid class_id_counter = MaxJfrEventId + 101; \/\/ + 101 is for the void.class primitive\n@@ -151,0 +151,4 @@\n+traceid JfrTraceId::assign_primitive_klass_id() {\n+  return next_class_id();\n+}\n+\n@@ -174,0 +178,4 @@\n+  if (k->is_typeArray_klass()) {\n+    \/\/ the next id is reserved for the corresponding primitive class\n+    next_class_id();\n+  }\n@@ -184,1 +192,19 @@\n-traceid JfrTraceId::use(jclass jc) {\n+\/\/ A mirror representing a primitive class (e.g. int.class) has no reified Klass*,\n+\/\/ instead it has an associated TypeArrayKlass* (e.g. int[].class).\n+\/\/ We can use the TypeArrayKlass* as a proxy for deriving the id of the primitive class.\n+\/\/ The exception is the void.class, which has neither a Klass* nor a TypeArrayKlass*.\n+\/\/ It will use a reserved constant.\n+static traceid load_primitive(const oop mirror) {\n+  assert(java_lang_Class::is_primitive(mirror), \"invariant\");\n+  const Klass* const tak = java_lang_Class::array_klass_acquire(mirror);\n+  traceid id;\n+  if (tak == NULL) {\n+    \/\/ The first klass id is reserved for the void.class\n+    id = MaxJfrEventId + 101;\n+  } else {\n+    id = JfrTraceId::get(tak) + 1;\n+  }\n+  return id;\n+}\n+\n+traceid JfrTraceId::use(jclass jc, bool raw \/* false *\/) {\n@@ -187,3 +213,4 @@\n-  const oop my_oop = JNIHandles::resolve(jc);\n-  assert(my_oop != NULL, \"invariant\");\n-  return use(java_lang_Class::as_Klass(my_oop));\n+  const oop mirror = JNIHandles::resolve(jc);\n+  assert(mirror != NULL, \"invariant\");\n+  const Klass* const k = java_lang_Class::as_Klass(mirror);\n+  return k != NULL ? (raw ? get(k) : use(k)) : load_primitive(mirror);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":33,"deletions":6,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -86,0 +86,1 @@\n+  static traceid assign_primitive_klass_id();\n@@ -94,1 +95,1 @@\n-  static traceid use(jclass jc);\n+  static traceid use(jclass jc, bool raw = false);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#define ASSIGN_PRIMITIVE_CLASS_ID(data) JfrTraceId::assign_primitive_klass_id()\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrTraceIdExtension.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  JFR_ONLY(ASSIGN_PRIMITIVE_CLASS_ID(ak);)\n","filename":"src\/hotspot\/share\/oops\/typeArrayKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2021, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.util.List;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedClass;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.Events;\n+\n+\/**\n+ * @test TestPrimitiveClasses\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestPrimitiveClasses\n+ *\/\n+public class TestPrimitiveClasses {\n+\n+    private static class MyEvent extends Event {\n+        Class<?> booleanClass = boolean.class;\n+        Class<?> charClass = char.class;\n+        Class<?> floatClass = float.class;\n+        Class<?> doubleClass = double.class;\n+        Class<?> byteClass = byte.class;\n+        Class<?> shortClass = short.class;\n+        Class<?> intClass = int.class;\n+        Class<?> longClass = long.class;\n+        Class<?> voidClass = void.class;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.enable(MyEvent.class);\n+            r.start();\n+            MyEvent myEvent = new MyEvent();\n+            myEvent.commit();\n+            r.stop();\n+            List<RecordedEvent> events = Events.fromRecording(r);\n+            Events.hasEvents(events);\n+            RecordedEvent event = events.get(0);\n+            System.out.println(event);\n+            testField(event, \"booleanClass\", boolean.class);\n+            testField(event, \"charClass\", char.class);\n+            testField(event, \"floatClass\", float.class);\n+            testField(event, \"doubleClass\", double.class);\n+            testField(event, \"byteClass\", byte.class);\n+            testField(event, \"shortClass\", short.class);\n+            testField(event, \"intClass\", int.class);\n+            testField(event, \"longClass\", long.class);\n+            testField(event, \"voidClass\", void.class);\n+        }\n+    }\n+\n+    private static void testField(RecordedEvent event, String fieldName, Class<?> expected) {\n+        Asserts.assertTrue(event.hasField(fieldName));\n+        RecordedClass classField = event.getValue(fieldName);\n+        Asserts.assertEquals(classField.getName(), expected.getName());\n+        Asserts.assertEquals(classField.getClassLoader().getName(), \"bootstrap\");\n+        Asserts.assertEquals(classField.getModifiers(), expected.getModifiers());\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestPrimitiveClasses.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}