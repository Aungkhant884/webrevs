{"files":[{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8231595\n+ * @summary [TEST] develop a test case for SuspendThreadList including current thread\n+ * @library \/test\/lib\n+ * @compile SuspendWithCurrentThread.java\n+ * @run main\/othervm\/native -agentlib:SuspendWithCurrentThread SuspendWithCurrentThread SuspenderIndex=first\n+ * @run main\/othervm\/native -agentlib:SuspendWithCurrentThread SuspendWithCurrentThread SuspenderIndex=last\n+ *\/\n+\n+import java.io.PrintStream;\n+\n+public class SuspendWithCurrentThread {\n+    private static final String AGENT_LIB = \"SuspendWithCurrentThread\";\n+    private static final String SUSPENDER_OPT = \"SuspenderIndex=\";\n+    private static final int THREADS_COUNT = 10;\n+\n+    private static void log(String msg) { System.out.println(msg); }\n+\n+    private static native void    registerTestedThreads(Thread[] threads);\n+    private static native boolean checkTestedThreadsSuspended();\n+    private static native void    resumeTestedThreads();\n+    private static native void    releaseTestedThreadsInfo();\n+\n+    \/\/ The suspender thread index defines the thread which has to suspend\n+    \/\/ the tested threads including itself with the JVMTI SuspendThreadList\n+    private static int suspenderIndex;\n+\n+    public static void main(String args[]) throws Exception {\n+        try {\n+            System.loadLibrary(AGENT_LIB);\n+            log(\"Loaded library: \" + AGENT_LIB);\n+        } catch (UnsatisfiedLinkError ule) {\n+            log(\"Failed to load library: \" + AGENT_LIB);\n+            log(\"java.library.path: \" + System.getProperty(\"java.library.path\"));\n+            throw ule;\n+        }\n+        if (args.length != 1) {\n+            throw new RuntimeException(\"Main: wrong arguments count: \" + args.length + \", expected: 1\");\n+        }\n+        String arg = args[0];\n+        if (arg.equals(SUSPENDER_OPT + \"first\")) {\n+            suspenderIndex = 0;\n+        } else if (arg.equals(SUSPENDER_OPT + \"last\")) {\n+            suspenderIndex = THREADS_COUNT - 1;\n+        } else {\n+            throw new RuntimeException(\"Main: wrong argument: \" + arg + \", expected: SuspenderIndex={first|last}\");\n+        }\n+        log(\"Main: suspenderIndex: \" + suspenderIndex);\n+\n+        SuspendWithCurrentThread test = new SuspendWithCurrentThread();\n+        test.run();\n+    }\n+\n+    private ThreadToSuspend[] startTestedThreads(int threadsCount) throws RuntimeException  {\n+        ThreadToSuspend[]threads = new ThreadToSuspend[threadsCount];\n+\n+        \/\/ create tested threads\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i] = new ThreadToSuspend(\"ThreadToSuspend#\" + i,\n+                                             i == suspenderIndex \/\/ isSuspender\n+                                            );\n+        }\n+        log(\"Main: starting tested threads\");\n+        for (int i = 0; i < threads.length; i++) {\n+            threads[i].start();\n+            if (!threads[i].checkReady()) {\n+                throw new RuntimeException(\"Main: unable to prepare tested thread: \" + threads[i]);\n+            }\n+        }\n+        log(\"Main: tested threads started\");\n+\n+        registerTestedThreads(threads);\n+        return threads;\n+    }\n+\n+    private boolean checkSuspendedStatus() throws RuntimeException  {\n+        log(\"Main: checking all tested threads have been suspended\");\n+        return checkTestedThreadsSuspended();\n+    }\n+\n+    \/* The test does the following steps:\n+     *  - main thread starts several (THREADS_COUNT) ThreadToSuspend tested threads\n+     *  - main thread waits for threads to be ready with the thread.checkReady()\n+     *  - main thread registers tested threads within the native agent library\n+     *    with the native method registerTestedThreads()\n+     *  - main thread triggers the suspender tested thread with the\n+     *    ThreadToSuspend.setAllThreadsReady() to suspend tested threads\n+     *  - suspender thread suspends tested threads including itself with the native\n+     *    method suspendTestedThreads() (uses the JVMTI SuspendThreadList function)\n+     *  - main thread checks tested threads suspended status with the native method\n+     *    checkSuspendedStatus(); the tested threads are expected to have suspended status\n+     *  - main thread resumes tested threads with the native method resumeTestedThreads()\n+     *  - main thread releases tested threads with the native method releaseTestedThreads()\n+     *  - main thread triggers the tested threads to finish with the thread.letFinish()\n+     *\/\n+    private void run() throws Exception {\n+        ThreadToSuspend[] threads = null; \/\/ tested threads\n+\n+        log(\"Main: started\");\n+        try {\n+            threads = startTestedThreads(THREADS_COUNT);\n+\n+            log(\"Main: trigger \" + threads[suspenderIndex].getName() +\n+                \" to suspend all tested threads including itself\");\n+            ThreadToSuspend.setAllThreadsReady();\n+\n+            if (!checkSuspendedStatus()) {\n+                throw new RuntimeException(\"Main: FAILED status returned from checkTestedThreadsSuspended\");\n+            }\n+\n+            log(\"Main: resuming all tested threads\");\n+            resumeTestedThreads();\n+        } finally {\n+            \/\/ let threads to finish\n+            for (int i = 0; i < threads.length; i++) {\n+                threads[i].letFinish();\n+            }\n+            log(\"Main: tested threads finished\");\n+        }\n+\n+        \/\/ wait for threads to finish\n+        log(\"Main: joining tested threads\");\n+        try {\n+            for (int i = 0; i < threads.length; i++) {\n+                threads[i].join();\n+            }\n+            log(\"Main: tested thread joined\");\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+        log(\"Main: releasing tested threads native info\");\n+        releaseTestedThreadsInfo();\n+\n+        log(\"Main: finished\");\n+    }\n+}\n+\n+\/* =================================================================== *\/\n+\n+\/\/ tested threads\n+class ThreadToSuspend extends Thread {\n+    private static void log(String msg) { System.out.println(msg); }\n+\n+    private static native void init();\n+    private static native void suspendTestedThreads();\n+    private static volatile boolean allThreadsReady = false;\n+\n+    public static void setAllThreadsReady() {\n+        allThreadsReady = true;\n+    }\n+\n+    private volatile boolean threadReady = false;\n+    private volatile boolean shouldFinish = false;\n+    private boolean isSuspender = false;\n+\n+    \/\/ make thread with specific name\n+    public ThreadToSuspend(String name, boolean isSuspender) {\n+        super(name);\n+        this.isSuspender = isSuspender;\n+    }\n+\n+    \/\/ run thread continuously\n+    public void run() {\n+        boolean needSuspend = true;\n+\n+        if (isSuspender) {\n+            init();\n+        }\n+        threadReady = true;\n+\n+        \/\/ run in a loop\n+        while (!shouldFinish) {\n+            if (isSuspender && needSuspend && allThreadsReady) {\n+                log(getName() + \": before suspending all tested threads including myself\");\n+                needSuspend = false;\n+                suspendTestedThreads();\n+                log(getName() + \": after suspending all tested threads including myself\");\n+            }\n+        }\n+    }\n+\n+    \/\/ check if thread is ready\n+    public boolean checkReady() {\n+        try {\n+            while (!threadReady) {\n+                sleep(1);\n+            }\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(\"checkReady: sleep was interrupted\\n\\t\" + e);\n+        }\n+        return threadReady;\n+    }\n+\n+    \/\/ let thread to finish\n+    public void letFinish() {\n+        shouldFinish = true;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithCurrentThread\/SuspendWithCurrentThread.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <string.h>\n+#include \"jvmti.h\"\n+\n+extern \"C\" {\n+\n+static jvmtiEnv* jvmti = NULL;\n+static jthread* threads = NULL;\n+static jsize threads_count = 0;\n+static jrawMonitorID agent_monitor = NULL;\n+\n+#define LOG(...) \\\n+  do { \\\n+    printf(__VA_ARGS__); \\\n+    printf(\"\\n\"); \\\n+    fflush(stdout); \\\n+  } while (0)\n+\n+static void\n+check_jvmti_status(JNIEnv* jni, jvmtiError err, const char* msg) {\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"check_jvmti_status: JVMTI function returned error: %d\", err);\n+    jni->FatalError(msg);\n+  }\n+}\n+\n+static void\n+agent_lock(JNIEnv* jni) {\n+  jvmtiError err = jvmti->RawMonitorEnter(agent_monitor);\n+  check_jvmti_status(jni, err, \"monitor_enter: error in JVMTI RawMonitorEnter\");\n+}\n+\n+static void\n+agent_unlock(JNIEnv* jni) {\n+  jvmtiError err = jvmti->RawMonitorExit(agent_monitor);\n+  check_jvmti_status(jni, err, \"monitor_exit: error in JVMTI RawMonitorExit\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_SuspendWithCurrentThread_registerTestedThreads(JNIEnv *jni, jclass cls, jobjectArray threadsArr) {\n+  LOG(\"\\nregisterTestedThreads: started\");\n+  threads_count = jni->GetArrayLength(threadsArr);\n+\n+  jvmtiError err = jvmti->Allocate((threads_count * sizeof(jthread)),\n+                                   (unsigned char**)&threads);\n+  check_jvmti_status(jni, err, \"registerTestedThreads: error in JVMTI Allocate threads array\");\n+\n+  for (int i = 0; i < threads_count; i++) {\n+    jobject elem = jni->GetObjectArrayElement(threadsArr, i);\n+    threads[i] = (jthread)jni->NewGlobalRef(elem);\n+  }\n+  LOG(\"registerTestedThreads: finished\\n\");\n+}\n+\n+\/* This function is executed on the suspender thread, not the Main thread *\/\n+JNIEXPORT void JNICALL\n+Java_ThreadToSuspend_init(JNIEnv *jni, jclass cls) {\n+  jvmtiError err = jvmti->CreateRawMonitor(\"Agent monitor\", &agent_monitor);\n+  check_jvmti_status(jni, err, \"Java_ThreadToSuspend_init: error in JVMTI CreateRawMonitor\");\n+\n+  \/\/ Main thread has to wait for the suspender thread to complete tested threads suspension\n+  agent_lock(jni);\n+}\n+\n+\/* This function is executed on the suspender thread which is not Main thread *\/\n+JNIEXPORT void JNICALL\n+Java_ThreadToSuspend_suspendTestedThreads(JNIEnv *jni, jclass cls) {\n+  jvmtiError* results = NULL;\n+  jvmtiError err;\n+\n+  LOG(\"\\nsuspendTestedThreads: started\");\n+  err = jvmti->Allocate((threads_count * sizeof(jvmtiError)),\n+                        (unsigned char**)&results);\n+  check_jvmti_status(jni, err, \"suspendTestedThreads: error in JVMTI Allocate results array\");\n+\n+  LOG(\"suspendTestedThreads: before JVMTI SuspendThreadList\");\n+  err = jvmti->SuspendThreadList(threads_count, threads, results);\n+  check_jvmti_status(jni, err, \"suspendTestedThreads: error in JVMTI SuspendThreadList\");\n+\n+  LOG(\"suspendTestedThreads: check and print SuspendThreadList results:\");\n+  for (int i = 0; i < threads_count; i++) {\n+    LOG(\"  thread #%d: (%d)\", i, (int)results[i]);\n+    check_jvmti_status(jni, results[i], \"suspendTestedThreads: error in SuspendThreadList results[i]\");\n+  }\n+  LOG(\"suspendTestedThreads: finished\\n\");\n+\n+  \/\/ Allow the Main thread to inspect the result of tested threads suspension\n+  agent_unlock(jni);\n+\n+  err = jvmti->Deallocate((unsigned char*)results);\n+  check_jvmti_status(jni, err, \"suspendTestedThreads: error in JVMTI Deallocate results\");\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_SuspendWithCurrentThread_checkTestedThreadsSuspended(JNIEnv *jni, jclass cls) {\n+  LOG(\"checkTestedThreadsSuspended: started\");\n+\n+  \/\/ Block until the suspender thread competes the tested threads suspension\n+  agent_lock(jni);\n+  agent_unlock(jni);\n+\n+  for (int i = 0; i < threads_count; i++) {\n+    jint state = 0;\n+    jvmtiError err = jvmti->GetThreadState(threads[i], &state);\n+    check_jvmti_status(jni, err, \"checkTestedThreadsSuspended: error in GetThreadState\");\n+\n+    if ((state & JVMTI_THREAD_STATE_SUSPENDED) == 0) {\n+      LOG(\"thread #%d has not been suspended yet: \"\n+             \"#   state: (%#x)\", i, (int)state);\n+      jni->FatalError(\"checkTestedThreadsSuspended: error: expected all tested threads suspended\");\n+    }\n+  }\n+  LOG(\"checkTestedThreadsSuspended: finished\\n\");\n+  return JNI_TRUE;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_SuspendWithCurrentThread_resumeTestedThreads(JNIEnv *jni, jclass cls) {\n+  jvmtiError* results = NULL;\n+  jvmtiError err;\n+\n+  LOG(\"\\nresumeTestedThreads: started\");\n+  err = jvmti->Allocate((threads_count * sizeof(jvmtiError)),\n+                        (unsigned char**)&results);\n+  check_jvmti_status(jni, err, \"resumeTestedThreads: error in JVMTI Allocate results array\");\n+\n+  LOG(\"resumeTestedThreads: before JVMTI ResumeThreadList\");\n+  err = jvmti->ResumeThreadList(threads_count, threads, results);\n+  check_jvmti_status(jni, err, \"resumeTestedThreads: error in ResumeThreadList\");\n+\n+  LOG(\"resumeTestedThreads: check and print ResumeThreadList results:\");\n+  for (int i = 0; i < threads_count; i++) {\n+    LOG(\"  thread #%d: (%d)\", i, (int)results[i]);\n+    check_jvmti_status(jni, results[i], \"resumeTestedThreads: error in ResumeThreadList results[i]\");\n+  }\n+\n+  err = jvmti->Deallocate((unsigned char*)results);\n+  check_jvmti_status(jni, err, \"resumeTestedThreads: error in JVMTI Deallocate results\");\n+\n+  LOG(\"resumeTestedThreads: finished\\n\");\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_SuspendWithCurrentThread_releaseTestedThreadsInfo(JNIEnv *jni, jclass cls) {\n+  jvmtiError err;\n+\n+  LOG(\"\\nreleaseTestedThreadsInfo: started\");\n+  err = jvmti->DestroyRawMonitor(agent_monitor);\n+  check_jvmti_status(jni, err, \"releaseTestedThreadsInfo: error in JVMTI DestroyRawMonitor\");\n+\n+  for (int i = 0; i < threads_count; i++) {\n+    if (threads[i] != NULL) {\n+      jni->DeleteGlobalRef(threads[i]);\n+    }\n+  }\n+  err = jvmti->Deallocate((unsigned char*)threads);\n+  check_jvmti_status(jni, err, \"releaseTestedThreadsInfo: error in JVMTI Deallocate threads\");\n+\n+  LOG(\"releaseTestedThreadsInfo: finished\\n\");\n+}\n+\n+\n+\/** Agent library initialization. *\/\n+\n+JNIEXPORT jint JNICALL\n+Agent_OnLoad(JavaVM *jvm, char *options, void *reserved) {\n+  LOG(\"\\nAgent_OnLoad started\");\n+\n+  \/\/ create JVMTI environment\n+  if (jvm->GetEnv((void **) (&jvmti), JVMTI_VERSION) != JNI_OK) {\n+    return JNI_ERR;\n+  }\n+\n+  \/\/ add specific capabilities for suspending thread\n+  jvmtiCapabilities suspendCaps;\n+  memset(&suspendCaps, 0, sizeof(suspendCaps));\n+  suspendCaps.can_suspend = 1;\n+\n+  jvmtiError err = jvmti->AddCapabilities(&suspendCaps);\n+  if (err != JVMTI_ERROR_NONE) {\n+    return JNI_ERR;\n+  }\n+  LOG(\"Agent_OnLoad finished\\n\");\n+  return JNI_OK;\n+}\n+\n+}\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/SuspendWithCurrentThread\/libSuspendWithCurrentThread.cpp","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}