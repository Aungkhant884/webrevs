{"files":[{"patch":"@@ -345,0 +345,3 @@\n+  \/\/ To call this, one must have the MultiArray_lock held, but the _klasses list still has lock free reads.\n+  assert_locked_or_safepoint(MultiArray_lock);\n+\n@@ -1163,0 +1166,40 @@\n+\/\/ Iterating over the CLDG needs to be locked because\n+\/\/ unloading can remove entries concurrently soon.\n+class ClassLoaderDataGraphIterator : public StackObj {\n+  ClassLoaderData* _next;\n+  Thread*          _thread;\n+  HandleMark       _hm;  \/\/ clean up handles when this is done.\n+  Handle           _holder;\n+  NoSafepointVerifier _nsv; \/\/ No safepoints allowed in this scope\n+                            \/\/ unless verifying at a safepoint.\n+\n+public:\n+  ClassLoaderDataGraphIterator() : _next(ClassLoaderDataGraph::_head), _thread(Thread::current()), _hm(_thread) {\n+    _thread = Thread::current();\n+    assert_locked_or_safepoint(ClassLoaderDataGraph_lock);\n+  }\n+\n+  ClassLoaderData* get_next() {\n+    ClassLoaderData* cld = _next;\n+    \/\/ Skip already unloaded CLD for concurrent unloading.\n+    while (cld != NULL && !cld->is_alive()) {\n+      cld = cld->next();\n+    }\n+    if (cld != NULL) {\n+      \/\/ Keep cld that is being returned alive.\n+      _holder = Handle(_thread, cld->holder_phantom());\n+      _next = cld->next();\n+    } else {\n+      _next = NULL;\n+    }\n+    return cld;\n+  }\n+};\n+\n+void ClassLoaderDataGraph::loaded_cld_do(CLDClosure* cl) {\n+  ClassLoaderDataGraphIterator iter;\n+  while (ClassLoaderData* cld = iter.get_next()) {\n+    cl->do_cld(cld);\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -73,0 +73,1 @@\n+  friend class ClassLoaderDataGraphIterator;\n@@ -105,0 +106,2 @@\n+  \/\/ Iteration through CLDG not by GC.\n+  static void loaded_cld_do(CLDClosure* cl);\n@@ -181,0 +184,1 @@\n+  friend class ClassLoaderDataGraphIterator;\n@@ -290,0 +294,2 @@\n+\n+  oop holder_phantom() const;\n@@ -295,1 +301,0 @@\n-  oop holder_phantom() const;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/jniHandles.inline.hpp\"\n@@ -1590,7 +1591,9 @@\n-      \/\/ Link the class to cause the bytecodes to be rewritten and the\n-      \/\/ cpcache to be created. Class verification is done according\n-      \/\/ to -Xverify setting.\n-      _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);\n-      guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n-\n-      ik->constants()->resolve_class_constants(THREAD);\n+      if (ik->is_loaded()) {\n+        \/\/ Link the class to cause the bytecodes to be rewritten and the\n+        \/\/ cpcache to be created. Class verification is done according\n+        \/\/ to -Xverify setting.\n+        _made_progress |= MetaspaceShared::try_link_class(ik, THREAD);\n+        guarantee(!HAS_PENDING_EXCEPTION, \"exception in link_class\");\n+\n+        ik->constants()->resolve_class_constants(THREAD);\n+      }\n@@ -1625,0 +1628,21 @@\n+class CollectCLDClosure : public CLDClosure {\n+  GrowableArray<ClassLoaderData*> _loaded_cld;\n+  GrowableArray<jobject> _loaded_cld_handles; \/\/ keep the CLDs alive\n+  Thread* _current_thread;\n+public:\n+  CollectCLDClosure(Thread* thread) : _current_thread(thread) {}\n+  ~CollectCLDClosure() {\n+      for (int i = 0; i < _loaded_cld_handles.length(); i++) {\n+        JNIHandles::destroy_local(_loaded_cld_handles.at(i));\n+      }\n+  }\n+  void do_cld(ClassLoaderData* cld) {\n+    assert(cld->is_alive(), \"must be\");\n+    _loaded_cld.append(cld);\n+    oop holder = cld->holder_phantom();\n+    _loaded_cld_handles.append(JNIHandles::make_local(_current_thread, holder));\n+  }\n+\n+  int nof_cld() const                { return _loaded_cld.length(); }\n+  ClassLoaderData* cld_at(int index) { return _loaded_cld.at(index); }\n+};\n@@ -1627,0 +1651,12 @@\n+  \/\/ Collect all loaded ClassLoaderData.\n+  CollectCLDClosure collect_cld(THREAD);\n+  {\n+    MutexLocker ml(MultiArray_lock);\n+    \/\/ ClassLoaderDataGraph::loaded_cld_do requires ClassLoaderDataGraph_lock.\n+    \/\/ We cannot link the classes while holding this lock (or else we may run into deadlock).\n+    \/\/ Therefore, we need to first collect all the CLDs, and then link their classes after\n+    \/\/ releasing the lock.\n+    MutexLocker lock(ClassLoaderDataGraph_lock);\n+    ClassLoaderDataGraph::loaded_cld_do(&collect_cld);\n+  }\n+\n@@ -1632,1 +1668,4 @@\n-    ClassLoaderDataGraph::loaded_classes_do(&link_closure);\n+    for (int i = 0; i < collect_cld.nof_cld(); i++) {\n+      ClassLoaderData* cld = collect_cld.cld_at(i);\n+      cld->classes_do(&link_closure);\n+    }\n@@ -1637,0 +1676,1 @@\n+    MutexLocker ml(MultiArray_lock);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":48,"deletions":8,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2381,0 +2381,3 @@\n+    \/\/ To get a consistent list of classes we need MultiArray_lock to ensure\n+    \/\/ array classes aren't observed while they are being restored.\n+    MutexLocker ml(MultiArray_lock);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}