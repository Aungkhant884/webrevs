{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,0 +72,2 @@\n+DECLARE_SRCOVER_MASKBLIT(FourByteAbgrPre, IntArgbPre);\n+DECLARE_ALPHA_MASKBLIT(FourByteAbgrPre, IntArgbPre);\n@@ -106,0 +108,2 @@\n+    REGISTER_SRCOVER_MASKBLIT(FourByteAbgrPre, IntArgbPre),\n+    REGISTER_ALPHA_MASKBLIT(FourByteAbgrPre, IntArgbPre),\n@@ -180,0 +184,4 @@\n+DEFINE_SRCOVER_MASKBLIT(FourByteAbgrPre, IntArgbPre, 4ByteArgb)\n+\n+DEFINE_ALPHA_MASKBLIT(FourByteAbgrPre, IntArgbPre, 4ByteArgb)\n+\n","filename":"src\/java.desktop\/share\/native\/libawt\/java2d\/loops\/FourByteAbgrPre.c","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AlphaComposite;\n+import java.awt.Graphics2D;\n+import java.awt.image.BufferedImage;\n+import java.util.Arrays;\n+\n+import static java.awt.image.BufferedImage.TYPE_3BYTE_BGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR;\n+import static java.awt.image.BufferedImage.TYPE_4BYTE_ABGR_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB;\n+import static java.awt.image.BufferedImage.TYPE_INT_ARGB_PRE;\n+import static java.awt.image.BufferedImage.TYPE_INT_BGR;\n+import static java.awt.image.BufferedImage.TYPE_INT_RGB;\n+\n+\/**\n+ * @test\n+ * @bug 8297681\n+ * @summary The blit TYPE_4BYTE_ABGR_PRE to TYPE_INT_ARGB_PRE should be \"direct\"\n+ *\/\n+public final class SkipConversionIfPossible {\n+\n+    private static final int SIZE = 256;\n+\n+    public static void main(String[] args) {\n+        \/\/ Initial bug was in the TYPE_4BYTE_ABGR_PRE to TYPE_INT_ARGB_PRE blit.\n+        \/\/ But I checked other blits just in case.\n+        test(new int[]{TYPE_INT_ARGB_PRE, TYPE_4BYTE_ABGR_PRE});\n+        test(new int[]{TYPE_INT_RGB, TYPE_INT_BGR, TYPE_3BYTE_BGR});\n+        test(new int[]{TYPE_INT_ARGB, TYPE_4BYTE_ABGR});\n+    }\n+\n+    private static void test(int[] types) {\n+        for (int src : types) {\n+            for (int dst : types) {\n+                render(src, dst);\n+            }\n+        }\n+    }\n+\n+    private static void render(int src, int dst) {\n+        BufferedImage from = new BufferedImage(SIZE, SIZE, src);\n+        for (int a = 0; a < SIZE; ++a) {\n+            for (int c = 0; c < SIZE; ++c) {\n+                \/\/ The data is intentionally broken for the argb_pre format, but\n+                \/\/ it should be stored as is in dst if no conversion was done.\n+                from.getRaster().setPixel(c, a, new int[]{c, c << 24, -c, a});\n+            }\n+        }\n+        BufferedImage to = new BufferedImage(SIZE, SIZE, dst);\n+        Graphics2D g = to.createGraphics();\n+        g.setComposite(AlphaComposite.Src);\n+        g.drawImage(from, 0, 0, null);\n+        g.dispose();\n+\n+        for (int a = 0; a < SIZE; ++a) {\n+            for (int c = 0; c < SIZE; ++c) {\n+                int[] pixel1 = from.getRaster().getPixel(c, a, (int[]) null);\n+                int[] pixel2 = to.getRaster().getPixel(c, a, (int[]) null);\n+                if (!Arrays.equals(pixel1, pixel2)) {\n+                    System.err.println(Arrays.toString(pixel1));\n+                    System.err.println(Arrays.toString(pixel2));\n+                    throw new RuntimeException();\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/java2d\/loops\/SkipConversionIfPossible.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"}]}