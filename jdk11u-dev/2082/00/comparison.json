{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: May 2023\n@@ -33,2407 +33,3209 @@\n-  \/**\n-   * Java class file format Magic number (0xCAFEBABE)\n-   *\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.1-200-A\">\n-   * The ClassFile Structure in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final int JVM_CLASSFILE_MAGIC = 0xCAFEBABE;\n-\n-  \/** Major version number of class files for Java 1.1.\n-   *  @see #MINOR_1_1\n-   *  *\/\n-  public static final short MAJOR_1_1 = 45;\n-\n-  \/** Minor version number of class files for Java 1.1.\n-   *  @see #MAJOR_1_1\n-   *  *\/\n-  public static final short MINOR_1_1 = 3;\n-\n-  \/** Major version number of class files for Java 1.2.\n-   *  @see #MINOR_1_2\n-   *  *\/\n-  public static final short MAJOR_1_2 = 46;\n-\n-  \/** Minor version number of class files for Java 1.2.\n-   *  @see #MAJOR_1_2\n-   *  *\/\n-  public static final short MINOR_1_2 = 0;\n-\n-  \/** Major version number of class files for Java 1.2.\n-   *  @see #MINOR_1_2\n-   *  *\/\n-  public static final short MAJOR_1_3 = 47;\n-\n-  \/** Minor version number of class files for Java 1.3.\n-   *  @see #MAJOR_1_3\n-   *  *\/\n-  public static final short MINOR_1_3 = 0;\n-\n-  \/** Major version number of class files for Java 1.3.\n-   *  @see #MINOR_1_3\n-   *  *\/\n-  public static final short MAJOR_1_4 = 48;\n-\n-  \/** Minor version number of class files for Java 1.4.\n-   *  @see #MAJOR_1_4\n-   *  *\/\n-  public static final short MINOR_1_4 = 0;\n-\n-  \/** Major version number of class files for Java 1.4.\n-   *  @see #MINOR_1_4\n-   *  *\/\n-  public static final short MAJOR_1_5 = 49;\n-\n-  \/** Minor version number of class files for Java 1.5.\n-   *  @see #MAJOR_1_5\n-   *  *\/\n-  public static final short MINOR_1_5 = 0;\n-\n-  \/** Major version number of class files for Java 1.6.\n-   *  @see #MINOR_1_6\n-   *  *\/\n-  public static final short MAJOR_1_6 = 50;\n-\n-  \/** Minor version number of class files for Java 1.6.\n-   *  @see #MAJOR_1_6\n-   *  *\/\n-  public static final short MINOR_1_6 = 0;\n-\n-  \/** Major version number of class files for Java 1.7.\n-   *  @see #MINOR_1_7\n-   *  *\/\n-  public static final short MAJOR_1_7 = 51;\n-\n-  \/** Minor version number of class files for Java 1.7.\n-   *  @see #MAJOR_1_7\n-   *  *\/\n-  public static final short MINOR_1_7 = 0;\n-\n-  \/** Major version number of class files for Java 1.8.\n-   *  @see #MINOR_1_8\n-   *  *\/\n-  public static final short MAJOR_1_8 = 52;\n-\n-  \/** Minor version number of class files for Java 1.8.\n-   *  @see #MAJOR_1_8\n-   *  *\/\n-  public static final short MINOR_1_8 = 0;\n-\n-  \/** Major version number of class files for Java 9.\n-   *  @see #MINOR_9\n-   *  *\/\n-  public static final short MAJOR_9 = 53;\n-\n-  \/** Minor version number of class files for Java 9.\n-   *  @see #MAJOR_9\n-   *  *\/\n-  public static final short MINOR_9 = 0;\n-\n-  \/**\n-   * @deprecated Use {@link #MAJOR_9} instead\n-   *\/\n-  @Deprecated\n-  public static final short MAJOR_1_9 = MAJOR_9;\n-\n-  \/**\n-   * @deprecated Use {@link #MINOR_9} instead\n-   *\/\n-  @Deprecated\n-  public static final short MINOR_1_9 = MINOR_9;\n-\n-  \/** Major version number of class files for Java 10.\n-   *  @see #MINOR_10\n-   *  *\/\n-  public static final short MAJOR_10 = 54;\n-\n-  \/** Minor version number of class files for Java 10.\n-   *  @see #MAJOR_10\n-   *  *\/\n-  public static final short MINOR_10 = 0;\n-\n-  \/** Major version number of class files for Java 11.\n-   *  @see #MINOR_11\n-   *  *\/\n-  public static final short MAJOR_11 = 55;\n-\n-  \/** Minor version number of class files for Java 11.\n-   *  @see #MAJOR_11\n-   *  *\/\n-  public static final short MINOR_11 = 0;\n-\n-  \/** Major version number of class files for Java 12.\n-   *  @see #MINOR_12\n-   *  *\/\n-  public static final short MAJOR_12 = 56;\n-\n-  \/** Minor version number of class files for Java 12.\n-   *  @see #MAJOR_12\n-   *  *\/\n-  public static final short MINOR_12 = 0;\n-\n-  \/** Major version number of class files for Java 13.\n-   *  @see #MINOR_13\n-   *  *\/\n-  public static final short MAJOR_13 = 57;\n-\n-  \/** Minor version number of class files for Java 13.\n-   *  @see #MAJOR_13\n-   *  *\/\n-  public static final short MINOR_13 = 0;\n-\n-  \/** Major version number of class files for Java 14.\n-   *  @see #MINOR_14\n-   *  @since 6.4.0\n-   *  *\/\n-  public static final short MAJOR_14 = 58;\n-\n-  \/** Minor version number of class files for Java 14.\n-   *  @see #MAJOR_14\n-   *  @since 6.4.0\n-   *  *\/\n-  public static final short MINOR_14 = 0;\n-\n-  \/** Default major version number.  Class file is for Java 1.1.\n-   *  @see #MAJOR_1_1\n-   *  *\/\n-  public static final short MAJOR = MAJOR_1_1;\n-\n-  \/** Default major version number.  Class file is for Java 1.1.\n-   *  @see #MAJOR_1_1\n-   *  *\/\n-  public static final short MINOR     = MINOR_1_1;\n-\n-  \/** Maximum value for an unsigned short.\n-   *\/\n-  public static final int MAX_SHORT = 65535; \/\/ 2^16 - 1\n-\n-  \/** Maximum value for an unsigned byte.\n-   *\/\n-  public static final int MAX_BYTE  = 255; \/\/ 2^8 - 1\n-\n-  \/** One of the access flags for fields, methods, or classes.\n-   *\n-   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.1-200-E.1\">\n-   *  Flag definitions for Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.5\">\n-   *  Flag definitions for Fields in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.6\">\n-   *  Flag definitions for Methods in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.7.6-300-D.1-D.1\">\n-   *  Flag definitions for Inner Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-   *\/\n-  public static final short ACC_PUBLIC       = 0x0001;\n-\n-  \/** One of the access flags for fields, methods, or classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_PRIVATE      = 0x0002;\n-\n-  \/** One of the access flags for fields, methods, or classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_PROTECTED    = 0x0004;\n-\n-  \/** One of the access flags for fields, methods, or classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_STATIC       = 0x0008;\n-\n-  \/** One of the access flags for fields, methods, or classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_FINAL        = 0x0010;\n-\n-  \/** One of the access flags for the Module attribute.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_OPEN         = 0x0020;\n-\n-  \/** One of the access flags for classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_SUPER        = 0x0020;\n-\n-  \/** One of the access flags for methods.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_SYNCHRONIZED = 0x0020;\n-\n-  \/** One of the access flags for the Module attribute.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_TRANSITIVE   = 0x0020;\n-\n-  \/** One of the access flags for methods.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_BRIDGE       = 0x0040;\n-\n-  \/** One of the access flags for the Module attribute.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_STATIC_PHASE = 0x0040;\n-\n-  \/** One of the access flags for fields.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_VOLATILE     = 0x0040;\n-\n-  \/** One of the access flags for fields.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_TRANSIENT    = 0x0080;\n-\n-  \/** One of the access flags for methods.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_VARARGS      = 0x0080;\n-\n-  \/** One of the access flags for methods.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_NATIVE       = 0x0100;\n-\n-  \/** One of the access flags for classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_INTERFACE    = 0x0200;\n-\n-  \/** One of the access flags for methods or classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_ABSTRACT     = 0x0400;\n-\n-  \/** One of the access flags for methods.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_STRICT       = 0x0800;\n-\n-  \/** One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_SYNTHETIC    = 0x1000;\n-\n-  \/** One of the access flags for classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_ANNOTATION   = 0x2000;\n-\n-  \/** One of the access flags for fields or classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_ENUM         = 0x4000;\n-\n-  \/\/ Applies to classes compiled by new compilers only\n-  \/** One of the access flags for MethodParameter or Module attributes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_MANDATED     = (short) 0x8000;\n-\n-  \/** One of the access flags for classes.\n-   *  @see #ACC_PUBLIC\n-   *\/\n-  public static final short ACC_MODULE       = (short) 0x8000;\n-\n-  \/** One of the access flags for fields, methods, or classes.\n-   *  @see #ACC_PUBLIC\n-   *  @deprecated Use {@link #MAX_ACC_FLAG_I}\n-   *\/\n-  @Deprecated\n-  public static final short MAX_ACC_FLAG     = ACC_ENUM;\n-\n-  \/** One of the access flags for fields, methods, or classes.\n-   * ACC_MODULE is negative as a short.\n-   * @see #ACC_PUBLIC\n-   * @since 6.4.0\n-   *\/\n-  public static final int MAX_ACC_FLAG_I = 0x8000; \/\/ ACC_MODULE is negative as a short\n-\n-  \/\/ Note that do to overloading:\n-  \/\/ 'synchronized' is for methods, might be 'open' (if Module), 'super' (if class), or 'transitive' (if Module).\n-  \/\/ 'volatile'     is for fields,  might be 'bridge' (if method) or 'static_phase' (if Module)\n-  \/\/ 'transient'    is for fields,  might be 'varargs' (if method)\n-  \/\/ 'module'       is for classes, might be 'mandated' (if Module or MethodParameters)\n-  \/**\n-   * The names of the access flags.\n-   *\/\n-  private static final String[] ACCESS_NAMES = {\n-    \"public\", \"private\", \"protected\", \"static\", \"final\", \"synchronized\",\n-    \"volatile\", \"transient\", \"native\", \"interface\", \"abstract\", \"strictfp\",\n-    \"synthetic\", \"annotation\", \"enum\", \"module\"\n-  };\n-\n-  \/** @since 6.0 *\/\n-  public static final int ACCESS_NAMES_LENGTH = ACCESS_NAMES.length;\n-\n-  \/**\n-   * @param index\n-   * @return the ACCESS_NAMES entry at the given index\n-   * @since 6.0\n-   *\/\n-  public static String getAccessName(final int index) {\n-      return ACCESS_NAMES[index];\n-  }\n-\n-  \/*\n-   * The description of the constant pool is at:\n-   * http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4\n-   * References below are to the individual sections\n-   *\/\n-\n-  \/**\n-   * Marks a constant pool entry as type UTF-8.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.7\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_Utf8               = 1;\n-\n-  \/**\n-   * Marks a constant pool entry as type Integer.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_Integer            = 3;\n-\n-  \/**\n-   * Marks a constant pool entry as type Float.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_Float              = 4;\n-\n-  \/**\n-   * Marks a constant pool entry as type Long.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_Long               = 5;\n-\n-  \/**\n-   * Marks a constant pool entry as type Double.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_Double             = 6;\n-\n-  \/**\n-   * Marks a constant pool entry as a Class\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.1\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_Class              = 7;\n-\n-  \/**\n-   * Marks a constant pool entry as a Field Reference.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_Fieldref           = 9;\n-\n-  \/**\n-   * Marks a constant pool entry as type String\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.3\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_String             = 8;\n-\n-  \/** Marks a constant pool entry as a Method Reference.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a> *\/\n-  public static final byte CONSTANT_Methodref          = 10;\n-\n-  \/**\n-   * Marks a constant pool entry as an Interface Method Reference.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_InterfaceMethodref = 11;\n-\n-  \/** Marks a constant pool entry as a name and type.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.6\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a> *\/\n-  public static final byte CONSTANT_NameAndType        = 12;\n-\n-  \/**\n-   * Marks a constant pool entry as a Method Handle.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.8\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_MethodHandle       = 15;\n-\n-  \/**\n-   * Marks a constant pool entry as a Method Type.\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.9\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_MethodType         = 16;\n-\n-  \/**\n-   * Marks a constant pool entry as dynamically computed.\n-   * @see  <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\">\n-   * Change request for JEP 309<\/a>\n-   * @since 6.3\n-   *\/\n-  public static final byte CONSTANT_Dynamic            = 17;\n-\n-  \/**\n-   * Marks a constant pool entry as an Invoke Dynamic\n-   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final byte CONSTANT_InvokeDynamic      = 18;\n-\n-  \/**\n-   * Marks a constant pool entry as a Module Reference.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.11\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   * @since 6.1\n-   *\/\n-  public static final byte CONSTANT_Module             = 19;\n-\n-  \/**\n-   * Marks a constant pool entry as a Package Reference.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.12\">\n-   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n-   * @since 6.1\n-   *\/\n-  public static final byte CONSTANT_Package            = 20;\n-\n-  \/**\n-   * The names of the types of entries in a constant pool.\n-   * Use getConstantName instead\n-   *\/\n-  private static final String[] CONSTANT_NAMES = {\n-    \"\", \"CONSTANT_Utf8\", \"\", \"CONSTANT_Integer\",\n-    \"CONSTANT_Float\", \"CONSTANT_Long\", \"CONSTANT_Double\",\n-    \"CONSTANT_Class\", \"CONSTANT_String\", \"CONSTANT_Fieldref\",\n-    \"CONSTANT_Methodref\", \"CONSTANT_InterfaceMethodref\",\n-    \"CONSTANT_NameAndType\", \"\", \"\", \"CONSTANT_MethodHandle\",\n-    \"CONSTANT_MethodType\", \"CONSTANT_Dynamic\", \"CONSTANT_InvokeDynamic\",\n-    \"CONSTANT_Module\", \"CONSTANT_Package\"};\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return the CONSTANT_NAMES entry at the given index\n-   * @since 6.0\n-   *\/\n-  public static String getConstantName(final int index) {\n-      return CONSTANT_NAMES[index];\n-  }\n-\n-  \/** The name of the static initializer, also called &quot;class\n-   *  initialization method&quot; or &quot;interface initialization\n-   *   method&quot;. This is &quot;&lt;clinit&gt;&quot;.\n-   *\/\n-  public static final String STATIC_INITIALIZER_NAME = \"<clinit>\";\n-\n-  \/** The name of every constructor method in a class, also called\n-   * &quot;instance initialization method&quot;. This is &quot;&lt;init&gt;&quot;.\n-   *\/\n-  public static final String CONSTRUCTOR_NAME = \"<init>\";\n-\n-  \/**\n-   * The names of the interfaces implemented by arrays\n-   *\/\n-  private static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = {\"java.lang.Cloneable\", \"java.io.Serializable\"};\n-\n-  \/**\n-   * @since 6.0\n-   *\/\n-  public static Iterable<String> getInterfacesImplementedByArrays() {\n-      return Collections.unmodifiableList(Arrays.asList(INTERFACES_IMPLEMENTED_BY_ARRAYS));\n-  }\n-\n-  \/**\n-   * Maximum Constant Pool entries.\n-   * One of the limitations of the Java Virtual Machine.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.11-100-A\">\n-   * The Java Virtual Machine Specification, Java SE 8 Edition, page 330, chapter 4.11.<\/a>\n-   *\/\n-  public static final int MAX_CP_ENTRIES     = 65535;\n-\n-  \/**\n-   * Maximum code size (plus one; the code size must be LESS than this)\n-   * One of the limitations of the Java Virtual Machine.\n-   * Note vmspec2 page 152 (\"Limitations\") says:\n-   * \"The amount of code per non-native, non-abstract method is limited to 65536 bytes by\n-   * the sizes of the indices in the exception_table of the Code attribute (4.7.3),\n-   * in the LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\"\n-   * However this should be taken as an upper limit rather than the defined maximum.\n-   * On page 134 (4.8.1 Static Constants) of the same spec, it says:\n-   * \"The value of the code_length item must be less than 65536.\"\n-   * The entry in the Limitations section has been removed from later versions of the spec;\n-   * it is not present in the Java SE 8 edition.\n-   *\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\">\n-   * The Java Virtual Machine Specification, Java SE 8 Edition, page 104, chapter 4.7.<\/a>\n-   *\/\n-  public static final int MAX_CODE_SIZE      = 65536; \/\/bytes\n-\n-  \/**\n-   * The maximum number of dimensions in an array ({@value}).\n-   * One of the limitations of the Java Virtual Machine.\n-   *\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3.2-150\">\n-   * Field Descriptors in The Java Virtual Machine Specification<\/a>\n-   *\/\n-  public static final int MAX_ARRAY_DIMENSIONS = 255;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.nop\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short NOP              = 0;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aconst_null\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ACONST_NULL      = 1;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ICONST_M1        = 2;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ICONST_0         = 3;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ICONST_1         = 4;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ICONST_2         = 5;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ICONST_3         = 6;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ICONST_4         = 7;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ICONST_5         = 8;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LCONST_0         = 9;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LCONST_1         = 10;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FCONST_0         = 11;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FCONST_1         = 12;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FCONST_2         = 13;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DCONST_0         = 14;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DCONST_1         = 15;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bipush\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short BIPUSH           = 16;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sipush\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short SIPUSH           = 17;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LDC              = 18;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc_w\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LDC_W            = 19;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc2_w\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LDC2_W           = 20;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ILOAD            = 21;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LLOAD            = 22;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FLOAD            = 23;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DLOAD            = 24;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ALOAD            = 25;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ILOAD_0          = 26;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ILOAD_1          = 27;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ILOAD_2          = 28;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ILOAD_3          = 29;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LLOAD_0          = 30;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LLOAD_1          = 31;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LLOAD_2          = 32;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LLOAD_3          = 33;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FLOAD_0          = 34;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FLOAD_1          = 35;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FLOAD_2          = 36;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FLOAD_3          = 37;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DLOAD_0          = 38;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DLOAD_1          = 39;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DLOAD_2          = 40;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DLOAD_3          = 41;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ALOAD_0          = 42;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ALOAD_1          = 43;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ALOAD_2          = 44;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ALOAD_3          = 45;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iaload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IALOAD           = 46;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.laload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LALOAD           = 47;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.faload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FALOAD           = 48;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.daload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DALOAD           = 49;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aaload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short AALOAD           = 50;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.baload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short BALOAD           = 51;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.caload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short CALOAD           = 52;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.saload\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short SALOAD           = 53;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISTORE           = 54;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSTORE           = 55;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FSTORE           = 56;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DSTORE           = 57;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ASTORE           = 58;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISTORE_0         = 59;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISTORE_1         = 60;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISTORE_2         = 61;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISTORE_3         = 62;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSTORE_0         = 63;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSTORE_1         = 64;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSTORE_2         = 65;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSTORE_3         = 66;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FSTORE_0         = 67;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FSTORE_1         = 68;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FSTORE_2         = 69;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FSTORE_3         = 70;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DSTORE_0         = 71;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DSTORE_1         = 72;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DSTORE_2         = 73;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DSTORE_3         = 74;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ASTORE_0         = 75;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ASTORE_1         = 76;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ASTORE_2         = 77;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ASTORE_3         = 78;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iastore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IASTORE          = 79;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lastore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LASTORE          = 80;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fastore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FASTORE          = 81;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dastore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DASTORE          = 82;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aastore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short AASTORE          = 83;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bastore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short BASTORE          = 84;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.castore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short CASTORE          = 85;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sastore\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short SASTORE          = 86;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short POP              = 87;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop2\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short POP2             = 88;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DUP              = 89;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x1\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DUP_X1           = 90;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x2\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DUP_X2           = 91;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DUP2             = 92;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x1\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DUP2_X1          = 93;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x2\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DUP2_X2          = 94;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.swap\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short SWAP             = 95;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iadd\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IADD             = 96;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ladd\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LADD             = 97;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fadd\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FADD             = 98;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dadd\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DADD             = 99;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.isub\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISUB             = 100;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lsub\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSUB             = 101;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fsub\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FSUB             = 102;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dsub\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DSUB             = 103;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.imul\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IMUL             = 104;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lmul\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LMUL             = 105;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fmul\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FMUL             = 106;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dmul\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DMUL             = 107;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.idiv\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IDIV             = 108;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldiv\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LDIV             = 109;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fdiv\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FDIV             = 110;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ddiv\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DDIV             = 111;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.irem\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IREM             = 112;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lrem\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LREM             = 113;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.frem\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FREM             = 114;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.drem\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DREM             = 115;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ineg\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INEG             = 116;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lneg\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LNEG             = 117;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fneg\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FNEG             = 118;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dneg\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DNEG             = 119;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishl\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISHL             = 120;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshl\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSHL             = 121;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishr\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ISHR             = 122;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshr\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LSHR             = 123;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iushr\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IUSHR            = 124;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lushr\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LUSHR            = 125;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iand\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IAND             = 126;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.land\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LAND             = 127;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ior\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IOR              = 128;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lor\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LOR              = 129;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ixor\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IXOR             = 130;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lxor\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LXOR             = 131;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iinc\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IINC             = 132;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2l\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short I2L              = 133;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2f\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short I2F              = 134;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2d\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short I2D              = 135;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short L2I              = 136;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2f\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short L2F              = 137;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2d\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short L2D              = 138;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short F2I              = 139;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2l\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short F2L              = 140;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2d\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short F2D              = 141;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2i\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short D2I              = 142;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2l\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short D2L              = 143;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2f\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short D2F              = 144;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2b\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short I2B              = 145;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INT2BYTE         = 145; \/\/ Old notation\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2c\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short I2C              = 146;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INT2CHAR         = 146; \/\/ Old notation\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2s\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short I2S              = 147;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INT2SHORT        = 147; \/\/ Old notation\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lcmp\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LCMP             = 148;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpl\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FCMPL            = 149;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpg\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FCMPG            = 150;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpl\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DCMPL            = 151;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpg\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DCMPG            = 152;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifeq\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFEQ             = 153;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifne\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFNE             = 154;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iflt\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFLT             = 155;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifge\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFGE             = 156;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifgt\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFGT             = 157;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifle\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFLE             = 158;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ICMPEQ        = 159;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ICMPNE        = 160;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ICMPLT        = 161;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ICMPGE        = 162;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ICMPGT        = 163;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ICMPLE        = 164;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ACMPEQ        = 165;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IF_ACMPNE        = 166;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short GOTO             = 167;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short JSR              = 168;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ret\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short RET              = 169;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.tableswitch\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short TABLESWITCH      = 170;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lookupswitch\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LOOKUPSWITCH     = 171;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ireturn\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IRETURN          = 172;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lreturn\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short LRETURN          = 173;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.freturn\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short FRETURN          = 174;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dreturn\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short DRETURN          = 175;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.areturn\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ARETURN          = 176;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.return\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short RETURN           = 177;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getstatic\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short GETSTATIC        = 178;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putstatic\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short PUTSTATIC        = 179;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getfield\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short GETFIELD         = 180;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putfield\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short PUTFIELD         = 181;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INVOKEVIRTUAL    = 182;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INVOKESPECIAL    = 183;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INVOKENONVIRTUAL = 183; \/\/ Old name in JDK 1.0\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INVOKESTATIC     = 184;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INVOKEINTERFACE  = 185;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INVOKEDYNAMIC    = 186;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.new\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short NEW              = 187;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.newarray\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short NEWARRAY         = 188;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.anewarray\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ANEWARRAY        = 189;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.arraylength\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ARRAYLENGTH      = 190;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.athrow\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short ATHROW           = 191;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.checkcast\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short CHECKCAST        = 192;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.instanceof\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short INSTANCEOF       = 193;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorenter\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short MONITORENTER     = 194;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorexit\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short MONITOREXIT      = 195;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.wide\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short WIDE             = 196;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.multianewarray\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short MULTIANEWARRAY   = 197;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnull\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFNULL           = 198;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnonnull\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short IFNONNULL        = 199;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto_w\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short GOTO_W           = 200;\n-\n-  \/** Java VM opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr_w\">\n-   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n-  public static final short JSR_W            = 201;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n-   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n-  public static final short BREAKPOINT                = 202;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short LDC_QUICK                 = 203;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short LDC_W_QUICK               = 204;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short LDC2_W_QUICK              = 205;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short GETFIELD_QUICK            = 206;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short PUTFIELD_QUICK            = 207;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short GETFIELD2_QUICK           = 208;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short PUTFIELD2_QUICK           = 209;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short GETSTATIC_QUICK           = 210;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short PUTSTATIC_QUICK           = 211;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short GETSTATIC2_QUICK          = 212;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short PUTSTATIC2_QUICK          = 213;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INVOKEVIRTUAL_QUICK       = 214;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INVOKENONVIRTUAL_QUICK    = 215;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INVOKESUPER_QUICK         = 216;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INVOKESTATIC_QUICK        = 217;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INVOKEINTERFACE_QUICK     = 218;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INVOKEVIRTUALOBJECT_QUICK = 219;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short NEW_QUICK                 = 221;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short ANEWARRAY_QUICK           = 222;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short MULTIANEWARRAY_QUICK      = 223;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short CHECKCAST_QUICK           = 224;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INSTANCEOF_QUICK          = 225;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short INVOKEVIRTUAL_QUICK_W     = 226;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short GETFIELD_QUICK_W          = 227;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n-   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n-  public static final short PUTFIELD_QUICK_W          = 228;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n-   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n-  public static final short IMPDEP1                   = 254;\n-\n-  \/** JVM internal opcode.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n-   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n-  public static final short IMPDEP2                   = 255;\n-\n-  \/**\n-   * BCEL virtual instruction for pushing an arbitrary data type onto the stack.  Will be converted to the appropriate JVM\n-   * opcode when the class is dumped.\n-   *\/\n-  public static final short PUSH             = 4711;\n-\n-  \/**\n-   * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH.  Will be converted to the appropriate JVM\n-   * opcode when the class is dumped.\n-   *\/\n-  public static final short SWITCH           = 4712;\n-\n-  \/** Illegal opcode. *\/\n-  public static final short  UNDEFINED      = -1;\n-\n-  \/** Illegal opcode. *\/\n-  public static final short  UNPREDICTABLE  = -2;\n-\n-  \/** Illegal opcode. *\/\n-  public static final short  RESERVED       = -3;\n-\n-  \/** Mnemonic for an illegal opcode. *\/\n-  public static final String ILLEGAL_OPCODE = \"<illegal opcode>\";\n-\n-  \/** Mnemonic for an illegal type. *\/\n-  public static final String ILLEGAL_TYPE   = \"<illegal type>\";\n-\n-  \/** Boolean data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_BOOLEAN = 4;\n-\n-  \/** Char data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_CHAR    = 5;\n-\n-  \/** Float data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_FLOAT   = 6;\n-\n-  \/** Double data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_DOUBLE  = 7;\n-\n-  \/** Byte data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_BYTE    = 8;\n-\n-  \/** Short data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_SHORT   = 9;\n-\n-  \/** Int data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_INT     = 10;\n-\n-  \/** Long data type.\n-   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n-   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n-  public static final byte T_LONG    = 11;\n-\n-  \/** Void data type (non-standard). *\/\n-  public static final byte T_VOID      = 12; \/\/ Non-standard\n-\n-  \/** Array data type. *\/\n-  public static final byte T_ARRAY     = 13;\n-\n-  \/** Object data type. *\/\n-  public static final byte T_OBJECT    = 14;\n-\n-  \/** Reference data type (deprecated). *\/\n-  public static final byte T_REFERENCE = 14; \/\/ Deprecated\n-\n-  \/** Unknown data type. *\/\n-  public static final byte T_UNKNOWN   = 15;\n-\n-  \/** Address data type. *\/\n-  public static final byte T_ADDRESS   = 16;\n-\n-  \/** The primitive type names corresponding to the T_XX constants,\n-   * e.g., TYPE_NAMES[T_INT] = \"int\"\n-   *\/\n-  private static final String[] TYPE_NAMES = {\n-    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n-    \"boolean\", \"char\", \"float\", \"double\", \"byte\", \"short\", \"int\", \"long\",\n-    \"void\", \"array\", \"object\", \"unknown\", \"address\"\n-  };\n-\n-  \/**\n-   * The primitive type names corresponding to the T_XX constants,\n-   * e.g., TYPE_NAMES[T_INT] = \"int\"\n-   * @param index\n-   * @return the type name\n-   * @since 6.0\n-   *\/\n-  public static String getTypeName(final int index) {\n-      return TYPE_NAMES[index];\n-  }\n-\n-  \/** The primitive class names corresponding to the T_XX constants,\n-   * e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n-   *\/\n-  private static final String[] CLASS_TYPE_NAMES = {\n-    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n-    \"java.lang.Boolean\", \"java.lang.Character\", \"java.lang.Float\",\n-    \"java.lang.Double\", \"java.lang.Byte\", \"java.lang.Short\",\n-    \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Void\",\n-    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE,  ILLEGAL_TYPE\n-  };\n-\n-  \/**\n-   * The primitive class names corresponding to the T_XX constants,\n-   * e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n-   * @param index\n-   * @return the class name\n-   * @since 6.0\n-   *\/\n-  public static String getClassTypeName(final int index) {\n-      return CLASS_TYPE_NAMES[index];\n-  }\n-\n-  \/** The signature characters corresponding to primitive types,\n-   * e.g., SHORT_TYPE_NAMES[T_INT] = \"I\"\n-   *\/\n-  private static final String[] SHORT_TYPE_NAMES = {\n-    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n-    \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\",\n-    \"V\", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE\n-  };\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return the short type name\n-   * @since 6.0\n-   *\/\n-  public static String getShortTypeName(final int index) {\n-      return SHORT_TYPE_NAMES[index];\n-  }\n-\n-\n-  \/**\n-   * Number of byte code operands for each opcode, i.e., number of bytes after the tag byte\n-   * itself.  Indexed by opcode, so NO_OF_OPERANDS[BIPUSH] = the number of operands for a bipush\n-   * instruction.\n-   *\/\n-  private static final short[] NO_OF_OPERANDS = {\n-    0\/*nop*\/, 0\/*aconst_null*\/, 0\/*iconst_m1*\/, 0\/*iconst_0*\/,\n-    0\/*iconst_1*\/, 0\/*iconst_2*\/, 0\/*iconst_3*\/, 0\/*iconst_4*\/,\n-    0\/*iconst_5*\/, 0\/*lconst_0*\/, 0\/*lconst_1*\/, 0\/*fconst_0*\/,\n-    0\/*fconst_1*\/, 0\/*fconst_2*\/, 0\/*dconst_0*\/, 0\/*dconst_1*\/,\n-    1\/*bipush*\/, 2\/*sipush*\/, 1\/*ldc*\/, 2\/*ldc_w*\/, 2\/*ldc2_w*\/,\n-    1\/*iload*\/, 1\/*lload*\/, 1\/*fload*\/, 1\/*dload*\/, 1\/*aload*\/,\n-    0\/*iload_0*\/, 0\/*iload_1*\/, 0\/*iload_2*\/, 0\/*iload_3*\/,\n-    0\/*lload_0*\/, 0\/*lload_1*\/, 0\/*lload_2*\/, 0\/*lload_3*\/,\n-    0\/*fload_0*\/, 0\/*fload_1*\/, 0\/*fload_2*\/, 0\/*fload_3*\/,\n-    0\/*dload_0*\/, 0\/*dload_1*\/, 0\/*dload_2*\/, 0\/*dload_3*\/,\n-    0\/*aload_0*\/, 0\/*aload_1*\/, 0\/*aload_2*\/, 0\/*aload_3*\/,\n-    0\/*iaload*\/, 0\/*laload*\/, 0\/*faload*\/, 0\/*daload*\/,\n-    0\/*aaload*\/, 0\/*baload*\/, 0\/*caload*\/, 0\/*saload*\/,\n-    1\/*istore*\/, 1\/*lstore*\/, 1\/*fstore*\/, 1\/*dstore*\/,\n-    1\/*astore*\/, 0\/*istore_0*\/, 0\/*istore_1*\/, 0\/*istore_2*\/,\n-    0\/*istore_3*\/, 0\/*lstore_0*\/, 0\/*lstore_1*\/, 0\/*lstore_2*\/,\n-    0\/*lstore_3*\/, 0\/*fstore_0*\/, 0\/*fstore_1*\/, 0\/*fstore_2*\/,\n-    0\/*fstore_3*\/, 0\/*dstore_0*\/, 0\/*dstore_1*\/, 0\/*dstore_2*\/,\n-    0\/*dstore_3*\/, 0\/*astore_0*\/, 0\/*astore_1*\/, 0\/*astore_2*\/,\n-    0\/*astore_3*\/, 0\/*iastore*\/, 0\/*lastore*\/, 0\/*fastore*\/,\n-    0\/*dastore*\/, 0\/*aastore*\/, 0\/*bastore*\/, 0\/*castore*\/,\n-    0\/*sastore*\/, 0\/*pop*\/, 0\/*pop2*\/, 0\/*dup*\/, 0\/*dup_x1*\/,\n-    0\/*dup_x2*\/, 0\/*dup2*\/, 0\/*dup2_x1*\/, 0\/*dup2_x2*\/, 0\/*swap*\/,\n-    0\/*iadd*\/, 0\/*ladd*\/, 0\/*fadd*\/, 0\/*dadd*\/, 0\/*isub*\/,\n-    0\/*lsub*\/, 0\/*fsub*\/, 0\/*dsub*\/, 0\/*imul*\/, 0\/*lmul*\/,\n-    0\/*fmul*\/, 0\/*dmul*\/, 0\/*idiv*\/, 0\/*ldiv*\/, 0\/*fdiv*\/,\n-    0\/*ddiv*\/, 0\/*irem*\/, 0\/*lrem*\/, 0\/*frem*\/, 0\/*drem*\/,\n-    0\/*ineg*\/, 0\/*lneg*\/, 0\/*fneg*\/, 0\/*dneg*\/, 0\/*ishl*\/,\n-    0\/*lshl*\/, 0\/*ishr*\/, 0\/*lshr*\/, 0\/*iushr*\/, 0\/*lushr*\/,\n-    0\/*iand*\/, 0\/*land*\/, 0\/*ior*\/, 0\/*lor*\/, 0\/*ixor*\/, 0\/*lxor*\/,\n-    2\/*iinc*\/, 0\/*i2l*\/, 0\/*i2f*\/, 0\/*i2d*\/, 0\/*l2i*\/, 0\/*l2f*\/,\n-    0\/*l2d*\/, 0\/*f2i*\/, 0\/*f2l*\/, 0\/*f2d*\/, 0\/*d2i*\/, 0\/*d2l*\/,\n-    0\/*d2f*\/, 0\/*i2b*\/, 0\/*i2c*\/, 0\/*i2s*\/, 0\/*lcmp*\/, 0\/*fcmpl*\/,\n-    0\/*fcmpg*\/, 0\/*dcmpl*\/, 0\/*dcmpg*\/, 2\/*ifeq*\/, 2\/*ifne*\/,\n-    2\/*iflt*\/, 2\/*ifge*\/, 2\/*ifgt*\/, 2\/*ifle*\/, 2\/*if_icmpeq*\/,\n-    2\/*if_icmpne*\/, 2\/*if_icmplt*\/, 2\/*if_icmpge*\/, 2\/*if_icmpgt*\/,\n-    2\/*if_icmple*\/, 2\/*if_acmpeq*\/, 2\/*if_acmpne*\/, 2\/*goto*\/,\n-    2\/*jsr*\/, 1\/*ret*\/, UNPREDICTABLE\/*tableswitch*\/, UNPREDICTABLE\/*lookupswitch*\/,\n-    0\/*ireturn*\/, 0\/*lreturn*\/, 0\/*freturn*\/,\n-    0\/*dreturn*\/, 0\/*areturn*\/, 0\/*return*\/,\n-    2\/*getstatic*\/, 2\/*putstatic*\/, 2\/*getfield*\/,\n-    2\/*putfield*\/, 2\/*invokevirtual*\/, 2\/*invokespecial*\/, 2\/*invokestatic*\/,\n-    4\/*invokeinterface*\/, 4\/*invokedynamic*\/, 2\/*new*\/,\n-    1\/*newarray*\/, 2\/*anewarray*\/,\n-    0\/*arraylength*\/, 0\/*athrow*\/, 2\/*checkcast*\/,\n-    2\/*instanceof*\/, 0\/*monitorenter*\/,\n-    0\/*monitorexit*\/, UNPREDICTABLE\/*wide*\/, 3\/*multianewarray*\/,\n-    2\/*ifnull*\/, 2\/*ifnonnull*\/, 4\/*goto_w*\/,\n-    4\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, RESERVED\/*impdep1*\/, RESERVED\/*impdep2*\/\n-  };\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return Number of byte code operands\n-   * @since 6.0\n-   *\/\n-  public static short getNoOfOperands(final int index) {\n-      return NO_OF_OPERANDS[index];\n-  }\n-\n-  \/**\n-   * How the byte code operands are to be interpreted for each opcode.\n-   * Indexed by opcode.  TYPE_OF_OPERANDS[ILOAD] = an array of shorts\n-   * describing the data types for the instruction.\n-   *\/\n-  private static final short[][] TYPE_OF_OPERANDS = {\n-    {}\/*nop*\/, {}\/*aconst_null*\/, {}\/*iconst_m1*\/, {}\/*iconst_0*\/,\n-    {}\/*iconst_1*\/, {}\/*iconst_2*\/, {}\/*iconst_3*\/, {}\/*iconst_4*\/,\n-    {}\/*iconst_5*\/, {}\/*lconst_0*\/, {}\/*lconst_1*\/, {}\/*fconst_0*\/,\n-    {}\/*fconst_1*\/, {}\/*fconst_2*\/, {}\/*dconst_0*\/, {}\/*dconst_1*\/,\n-    {T_BYTE}\/*bipush*\/, {T_SHORT}\/*sipush*\/, {T_BYTE}\/*ldc*\/,\n-    {T_SHORT}\/*ldc_w*\/, {T_SHORT}\/*ldc2_w*\/,\n-    {T_BYTE}\/*iload*\/, {T_BYTE}\/*lload*\/, {T_BYTE}\/*fload*\/,\n-    {T_BYTE}\/*dload*\/, {T_BYTE}\/*aload*\/, {}\/*iload_0*\/,\n-    {}\/*iload_1*\/, {}\/*iload_2*\/, {}\/*iload_3*\/, {}\/*lload_0*\/,\n-    {}\/*lload_1*\/, {}\/*lload_2*\/, {}\/*lload_3*\/, {}\/*fload_0*\/,\n-    {}\/*fload_1*\/, {}\/*fload_2*\/, {}\/*fload_3*\/, {}\/*dload_0*\/,\n-    {}\/*dload_1*\/, {}\/*dload_2*\/, {}\/*dload_3*\/, {}\/*aload_0*\/,\n-    {}\/*aload_1*\/, {}\/*aload_2*\/, {}\/*aload_3*\/, {}\/*iaload*\/,\n-    {}\/*laload*\/, {}\/*faload*\/, {}\/*daload*\/, {}\/*aaload*\/,\n-    {}\/*baload*\/, {}\/*caload*\/, {}\/*saload*\/, {T_BYTE}\/*istore*\/,\n-    {T_BYTE}\/*lstore*\/, {T_BYTE}\/*fstore*\/, {T_BYTE}\/*dstore*\/,\n-    {T_BYTE}\/*astore*\/, {}\/*istore_0*\/, {}\/*istore_1*\/,\n-    {}\/*istore_2*\/, {}\/*istore_3*\/, {}\/*lstore_0*\/, {}\/*lstore_1*\/,\n-    {}\/*lstore_2*\/, {}\/*lstore_3*\/, {}\/*fstore_0*\/, {}\/*fstore_1*\/,\n-    {}\/*fstore_2*\/, {}\/*fstore_3*\/, {}\/*dstore_0*\/, {}\/*dstore_1*\/,\n-    {}\/*dstore_2*\/, {}\/*dstore_3*\/, {}\/*astore_0*\/, {}\/*astore_1*\/,\n-    {}\/*astore_2*\/, {}\/*astore_3*\/, {}\/*iastore*\/, {}\/*lastore*\/,\n-    {}\/*fastore*\/, {}\/*dastore*\/, {}\/*aastore*\/, {}\/*bastore*\/,\n-    {}\/*castore*\/, {}\/*sastore*\/, {}\/*pop*\/, {}\/*pop2*\/, {}\/*dup*\/,\n-    {}\/*dup_x1*\/, {}\/*dup_x2*\/, {}\/*dup2*\/, {}\/*dup2_x1*\/,\n-    {}\/*dup2_x2*\/, {}\/*swap*\/, {}\/*iadd*\/, {}\/*ladd*\/, {}\/*fadd*\/,\n-    {}\/*dadd*\/, {}\/*isub*\/, {}\/*lsub*\/, {}\/*fsub*\/, {}\/*dsub*\/,\n-    {}\/*imul*\/, {}\/*lmul*\/, {}\/*fmul*\/, {}\/*dmul*\/, {}\/*idiv*\/,\n-    {}\/*ldiv*\/, {}\/*fdiv*\/, {}\/*ddiv*\/, {}\/*irem*\/, {}\/*lrem*\/,\n-    {}\/*frem*\/, {}\/*drem*\/, {}\/*ineg*\/, {}\/*lneg*\/, {}\/*fneg*\/,\n-    {}\/*dneg*\/, {}\/*ishl*\/, {}\/*lshl*\/, {}\/*ishr*\/, {}\/*lshr*\/,\n-    {}\/*iushr*\/, {}\/*lushr*\/, {}\/*iand*\/, {}\/*land*\/, {}\/*ior*\/,\n-    {}\/*lor*\/, {}\/*ixor*\/, {}\/*lxor*\/, {T_BYTE, T_BYTE}\/*iinc*\/,\n-    {}\/*i2l*\/, {}\/*i2f*\/, {}\/*i2d*\/, {}\/*l2i*\/, {}\/*l2f*\/, {}\/*l2d*\/,\n-    {}\/*f2i*\/, {}\/*f2l*\/, {}\/*f2d*\/, {}\/*d2i*\/, {}\/*d2l*\/, {}\/*d2f*\/,\n-    {}\/*i2b*\/, {}\/*i2c*\/, {}\/*i2s*\/, {}\/*lcmp*\/, {}\/*fcmpl*\/,\n-    {}\/*fcmpg*\/, {}\/*dcmpl*\/, {}\/*dcmpg*\/, {T_SHORT}\/*ifeq*\/,\n-    {T_SHORT}\/*ifne*\/, {T_SHORT}\/*iflt*\/, {T_SHORT}\/*ifge*\/,\n-    {T_SHORT}\/*ifgt*\/, {T_SHORT}\/*ifle*\/, {T_SHORT}\/*if_icmpeq*\/,\n-    {T_SHORT}\/*if_icmpne*\/, {T_SHORT}\/*if_icmplt*\/,\n-    {T_SHORT}\/*if_icmpge*\/, {T_SHORT}\/*if_icmpgt*\/,\n-    {T_SHORT}\/*if_icmple*\/, {T_SHORT}\/*if_acmpeq*\/,\n-    {T_SHORT}\/*if_acmpne*\/, {T_SHORT}\/*goto*\/, {T_SHORT}\/*jsr*\/,\n-    {T_BYTE}\/*ret*\/, {}\/*tableswitch*\/, {}\/*lookupswitch*\/,\n-    {}\/*ireturn*\/, {}\/*lreturn*\/, {}\/*freturn*\/, {}\/*dreturn*\/,\n-    {}\/*areturn*\/, {}\/*return*\/, {T_SHORT}\/*getstatic*\/,\n-    {T_SHORT}\/*putstatic*\/, {T_SHORT}\/*getfield*\/,\n-    {T_SHORT}\/*putfield*\/, {T_SHORT}\/*invokevirtual*\/,\n-    {T_SHORT}\/*invokespecial*\/, {T_SHORT}\/*invokestatic*\/,\n-    {T_SHORT, T_BYTE, T_BYTE}\/*invokeinterface*\/, {T_SHORT, T_BYTE, T_BYTE}\/*invokedynamic*\/,\n-    {T_SHORT}\/*new*\/, {T_BYTE}\/*newarray*\/,\n-    {T_SHORT}\/*anewarray*\/, {}\/*arraylength*\/, {}\/*athrow*\/,\n-    {T_SHORT}\/*checkcast*\/, {T_SHORT}\/*instanceof*\/,\n-    {}\/*monitorenter*\/, {}\/*monitorexit*\/, {T_BYTE}\/*wide*\/,\n-    {T_SHORT, T_BYTE}\/*multianewarray*\/, {T_SHORT}\/*ifnull*\/,\n-    {T_SHORT}\/*ifnonnull*\/, {T_INT}\/*goto_w*\/, {T_INT}\/*jsr_w*\/,\n-    {}\/*breakpoint*\/, {}, {}, {}, {}, {}, {}, {},\n-    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n-    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n-    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n-    {}\/*impdep1*\/, {}\/*impdep2*\/\n-  };\n-\n-  \/**\n-   * @since 6.0\n-   *\/\n-  public static short getOperandType(final int opcode, final int index) {\n-      return TYPE_OF_OPERANDS[opcode][index];\n-  }\n-\n-  \/**\n-   * @since 6.0\n-   *\/\n-  public static long getOperandTypeCount(final int opcode) {\n-      return TYPE_OF_OPERANDS[opcode].length;\n-  }\n-\n-  \/**\n-   * Names of opcodes.  Indexed by opcode.  OPCODE_NAMES[ALOAD] = \"aload\".\n-   *\/\n-  private static final String[] OPCODE_NAMES = {\n-    \"nop\", \"aconst_null\", \"iconst_m1\", \"iconst_0\", \"iconst_1\",\n-    \"iconst_2\", \"iconst_3\", \"iconst_4\", \"iconst_5\", \"lconst_0\",\n-    \"lconst_1\", \"fconst_0\", \"fconst_1\", \"fconst_2\", \"dconst_0\",\n-    \"dconst_1\", \"bipush\", \"sipush\", \"ldc\", \"ldc_w\", \"ldc2_w\", \"iload\",\n-    \"lload\", \"fload\", \"dload\", \"aload\", \"iload_0\", \"iload_1\", \"iload_2\",\n-    \"iload_3\", \"lload_0\", \"lload_1\", \"lload_2\", \"lload_3\", \"fload_0\",\n-    \"fload_1\", \"fload_2\", \"fload_3\", \"dload_0\", \"dload_1\", \"dload_2\",\n-    \"dload_3\", \"aload_0\", \"aload_1\", \"aload_2\", \"aload_3\", \"iaload\",\n-    \"laload\", \"faload\", \"daload\", \"aaload\", \"baload\", \"caload\", \"saload\",\n-    \"istore\", \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore_0\",\n-    \"istore_1\", \"istore_2\", \"istore_3\", \"lstore_0\", \"lstore_1\",\n-    \"lstore_2\", \"lstore_3\", \"fstore_0\", \"fstore_1\", \"fstore_2\",\n-    \"fstore_3\", \"dstore_0\", \"dstore_1\", \"dstore_2\", \"dstore_3\",\n-    \"astore_0\", \"astore_1\", \"astore_2\", \"astore_3\", \"iastore\", \"lastore\",\n-    \"fastore\", \"dastore\", \"aastore\", \"bastore\", \"castore\", \"sastore\",\n-    \"pop\", \"pop2\", \"dup\", \"dup_x1\", \"dup_x2\", \"dup2\", \"dup2_x1\",\n-    \"dup2_x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\", \"dadd\", \"isub\", \"lsub\",\n-    \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\", \"dmul\", \"idiv\", \"ldiv\",\n-    \"fdiv\", \"ddiv\", \"irem\", \"lrem\", \"frem\", \"drem\", \"ineg\", \"lneg\",\n-    \"fneg\", \"dneg\", \"ishl\", \"lshl\", \"ishr\", \"lshr\", \"iushr\", \"lushr\",\n-    \"iand\", \"land\", \"ior\", \"lor\", \"ixor\", \"lxor\", \"iinc\", \"i2l\", \"i2f\",\n-    \"i2d\", \"l2i\", \"l2f\", \"l2d\", \"f2i\", \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\",\n-    \"i2b\", \"i2c\", \"i2s\", \"lcmp\", \"fcmpl\", \"fcmpg\",\n-    \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\", \"ifgt\", \"ifle\",\n-    \"if_icmpeq\", \"if_icmpne\", \"if_icmplt\", \"if_icmpge\", \"if_icmpgt\",\n-    \"if_icmple\", \"if_acmpeq\", \"if_acmpne\", \"goto\", \"jsr\", \"ret\",\n-    \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\",\n-    \"dreturn\", \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\",\n-    \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\",\n-    \"invokeinterface\", \"invokedynamic\", \"new\", \"newarray\", \"anewarray\",\n-    \"arraylength\", \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\",\n-    \"monitorexit\", \"wide\", \"multianewarray\", \"ifnull\", \"ifnonnull\",\n-    \"goto_w\", \"jsr_w\", \"breakpoint\", ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-    ILLEGAL_OPCODE, \"impdep1\", \"impdep2\"\n-  };\n-\n-  \/**\n-   * @since 6.0\n-   *\/\n-  public static final int OPCODE_NAMES_LENGTH = OPCODE_NAMES.length;\n-\n-\n-  \/**\n-   * @since 6.0\n-   *\/\n-  public static String getOpcodeName(final int index) {\n-      return OPCODE_NAMES[index];\n-  }\n-\n-  \/**\n-   * Number of words consumed on operand stack by instructions.\n-   * Indexed by opcode.  CONSUME_STACK[FALOAD] = number of words\n-   * consumed from the stack by a faload instruction.\n-   *\/\n-  private static final int[] CONSUME_STACK = {\n-    0\/*nop*\/, 0\/*aconst_null*\/, 0\/*iconst_m1*\/, 0\/*iconst_0*\/, 0\/*iconst_1*\/,\n-    0\/*iconst_2*\/, 0\/*iconst_3*\/, 0\/*iconst_4*\/, 0\/*iconst_5*\/, 0\/*lconst_0*\/,\n-    0\/*lconst_1*\/, 0\/*fconst_0*\/, 0\/*fconst_1*\/, 0\/*fconst_2*\/, 0\/*dconst_0*\/,\n-    0\/*dconst_1*\/, 0\/*bipush*\/, 0\/*sipush*\/, 0\/*ldc*\/, 0\/*ldc_w*\/, 0\/*ldc2_w*\/, 0\/*iload*\/,\n-    0\/*lload*\/, 0\/*fload*\/, 0\/*dload*\/, 0\/*aload*\/, 0\/*iload_0*\/, 0\/*iload_1*\/, 0\/*iload_2*\/,\n-    0\/*iload_3*\/, 0\/*lload_0*\/, 0\/*lload_1*\/, 0\/*lload_2*\/, 0\/*lload_3*\/, 0\/*fload_0*\/,\n-    0\/*fload_1*\/, 0\/*fload_2*\/, 0\/*fload_3*\/, 0\/*dload_0*\/, 0\/*dload_1*\/, 0\/*dload_2*\/,\n-    0\/*dload_3*\/, 0\/*aload_0*\/, 0\/*aload_1*\/, 0\/*aload_2*\/, 0\/*aload_3*\/, 2\/*iaload*\/,\n-    2\/*laload*\/, 2\/*faload*\/, 2\/*daload*\/, 2\/*aaload*\/, 2\/*baload*\/, 2\/*caload*\/, 2\/*saload*\/,\n-    1\/*istore*\/, 2\/*lstore*\/, 1\/*fstore*\/, 2\/*dstore*\/, 1\/*astore*\/, 1\/*istore_0*\/,\n-    1\/*istore_1*\/, 1\/*istore_2*\/, 1\/*istore_3*\/, 2\/*lstore_0*\/, 2\/*lstore_1*\/,\n-    2\/*lstore_2*\/, 2\/*lstore_3*\/, 1\/*fstore_0*\/, 1\/*fstore_1*\/, 1\/*fstore_2*\/,\n-    1\/*fstore_3*\/, 2\/*dstore_0*\/, 2\/*dstore_1*\/, 2\/*dstore_2*\/, 2\/*dstore_3*\/,\n-    1\/*astore_0*\/, 1\/*astore_1*\/, 1\/*astore_2*\/, 1\/*astore_3*\/, 3\/*iastore*\/, 4\/*lastore*\/,\n-    3\/*fastore*\/, 4\/*dastore*\/, 3\/*aastore*\/, 3\/*bastore*\/, 3\/*castore*\/, 3\/*sastore*\/,\n-    1\/*pop*\/, 2\/*pop2*\/, 1\/*dup*\/, 2\/*dup_x1*\/, 3\/*dup_x2*\/, 2\/*dup2*\/, 3\/*dup2_x1*\/,\n-    4\/*dup2_x2*\/, 2\/*swap*\/, 2\/*iadd*\/, 4\/*ladd*\/, 2\/*fadd*\/, 4\/*dadd*\/, 2\/*isub*\/, 4\/*lsub*\/,\n-    2\/*fsub*\/, 4\/*dsub*\/, 2\/*imul*\/, 4\/*lmul*\/, 2\/*fmul*\/, 4\/*dmul*\/, 2\/*idiv*\/, 4\/*ldiv*\/,\n-    2\/*fdiv*\/, 4\/*ddiv*\/, 2\/*irem*\/, 4\/*lrem*\/, 2\/*frem*\/, 4\/*drem*\/, 1\/*ineg*\/, 2\/*lneg*\/,\n-    1\/*fneg*\/, 2\/*dneg*\/, 2\/*ishl*\/, 3\/*lshl*\/, 2\/*ishr*\/, 3\/*lshr*\/, 2\/*iushr*\/, 3\/*lushr*\/,\n-    2\/*iand*\/, 4\/*land*\/, 2\/*ior*\/, 4\/*lor*\/, 2\/*ixor*\/, 4\/*lxor*\/, 0\/*iinc*\/,\n-    1\/*i2l*\/, 1\/*i2f*\/, 1\/*i2d*\/, 2\/*l2i*\/, 2\/*l2f*\/, 2\/*l2d*\/, 1\/*f2i*\/, 1\/*f2l*\/,\n-    1\/*f2d*\/, 2\/*d2i*\/, 2\/*d2l*\/, 2\/*d2f*\/, 1\/*i2b*\/, 1\/*i2c*\/, 1\/*i2s*\/,\n-    4\/*lcmp*\/, 2\/*fcmpl*\/, 2\/*fcmpg*\/, 4\/*dcmpl*\/, 4\/*dcmpg*\/, 1\/*ifeq*\/, 1\/*ifne*\/,\n-    1\/*iflt*\/, 1\/*ifge*\/, 1\/*ifgt*\/, 1\/*ifle*\/, 2\/*if_icmpeq*\/, 2\/*if_icmpne*\/, 2\/*if_icmplt*\/,\n-    2 \/*if_icmpge*\/, 2\/*if_icmpgt*\/, 2\/*if_icmple*\/, 2\/*if_acmpeq*\/, 2\/*if_acmpne*\/,\n-    0\/*goto*\/, 0\/*jsr*\/, 0\/*ret*\/, 1\/*tableswitch*\/, 1\/*lookupswitch*\/, 1\/*ireturn*\/,\n-    2\/*lreturn*\/, 1\/*freturn*\/, 2\/*dreturn*\/, 1\/*areturn*\/, 0\/*return*\/, 0\/*getstatic*\/,\n-    UNPREDICTABLE\/*putstatic*\/, 1\/*getfield*\/, UNPREDICTABLE\/*putfield*\/,\n-    UNPREDICTABLE\/*invokevirtual*\/, UNPREDICTABLE\/*invokespecial*\/,\n-    UNPREDICTABLE\/*invokestatic*\/,\n-    UNPREDICTABLE\/*invokeinterface*\/, UNPREDICTABLE\/*invokedynamic*\/, 0\/*new*\/, 1\/*newarray*\/, 1\/*anewarray*\/,\n-    1\/*arraylength*\/, 1\/*athrow*\/, 1\/*checkcast*\/, 1\/*instanceof*\/, 1\/*monitorenter*\/,\n-    1\/*monitorexit*\/, 0\/*wide*\/, UNPREDICTABLE\/*multianewarray*\/, 1\/*ifnull*\/, 1\/*ifnonnull*\/,\n-    0\/*goto_w*\/, 0\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNPREDICTABLE\/*impdep1*\/, UNPREDICTABLE\/*impdep2*\/\n-  };\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return Number of words consumed on operand stack\n-   * @since 6.0\n-   *\/\n-  public static int getConsumeStack(final int index) {\n-      return CONSUME_STACK[index];\n-  }\n-\n-\n-  \/**\n-   * Number of words produced onto operand stack by instructions.\n-   * Indexed by opcode.  CONSUME_STACK[DALOAD] = number of words\n-   * consumed from the stack by a daload instruction.\n-   *\/\n-  private static final int[] PRODUCE_STACK = {\n-    0\/*nop*\/, 1\/*aconst_null*\/, 1\/*iconst_m1*\/, 1\/*iconst_0*\/, 1\/*iconst_1*\/,\n-    1\/*iconst_2*\/, 1\/*iconst_3*\/, 1\/*iconst_4*\/, 1\/*iconst_5*\/, 2\/*lconst_0*\/,\n-    2\/*lconst_1*\/, 1\/*fconst_0*\/, 1\/*fconst_1*\/, 1\/*fconst_2*\/, 2\/*dconst_0*\/,\n-    2\/*dconst_1*\/, 1\/*bipush*\/, 1\/*sipush*\/, 1\/*ldc*\/, 1\/*ldc_w*\/, 2\/*ldc2_w*\/, 1\/*iload*\/,\n-    2\/*lload*\/, 1\/*fload*\/, 2\/*dload*\/, 1\/*aload*\/, 1\/*iload_0*\/, 1\/*iload_1*\/, 1\/*iload_2*\/,\n-    1\/*iload_3*\/, 2\/*lload_0*\/, 2\/*lload_1*\/, 2\/*lload_2*\/, 2\/*lload_3*\/, 1\/*fload_0*\/,\n-    1\/*fload_1*\/, 1\/*fload_2*\/, 1\/*fload_3*\/, 2\/*dload_0*\/, 2\/*dload_1*\/, 2\/*dload_2*\/,\n-    2\/*dload_3*\/, 1\/*aload_0*\/, 1\/*aload_1*\/, 1\/*aload_2*\/, 1\/*aload_3*\/, 1\/*iaload*\/,\n-    2\/*laload*\/, 1\/*faload*\/, 2\/*daload*\/, 1\/*aaload*\/, 1\/*baload*\/, 1\/*caload*\/, 1\/*saload*\/,\n-    0\/*istore*\/, 0\/*lstore*\/, 0\/*fstore*\/, 0\/*dstore*\/, 0\/*astore*\/, 0\/*istore_0*\/,\n-    0\/*istore_1*\/, 0\/*istore_2*\/, 0\/*istore_3*\/, 0\/*lstore_0*\/, 0\/*lstore_1*\/,\n-    0\/*lstore_2*\/, 0\/*lstore_3*\/, 0\/*fstore_0*\/, 0\/*fstore_1*\/, 0\/*fstore_2*\/,\n-    0\/*fstore_3*\/, 0\/*dstore_0*\/, 0\/*dstore_1*\/, 0\/*dstore_2*\/, 0\/*dstore_3*\/,\n-    0\/*astore_0*\/, 0\/*astore_1*\/, 0\/*astore_2*\/, 0\/*astore_3*\/, 0\/*iastore*\/, 0\/*lastore*\/,\n-    0\/*fastore*\/, 0\/*dastore*\/, 0\/*aastore*\/, 0\/*bastore*\/, 0\/*castore*\/, 0\/*sastore*\/,\n-    0\/*pop*\/, 0\/*pop2*\/, 2\/*dup*\/, 3\/*dup_x1*\/, 4\/*dup_x2*\/, 4\/*dup2*\/, 5\/*dup2_x1*\/,\n-    6\/*dup2_x2*\/, 2\/*swap*\/, 1\/*iadd*\/, 2\/*ladd*\/, 1\/*fadd*\/, 2\/*dadd*\/, 1\/*isub*\/, 2\/*lsub*\/,\n-    1\/*fsub*\/, 2\/*dsub*\/, 1\/*imul*\/, 2\/*lmul*\/, 1\/*fmul*\/, 2\/*dmul*\/, 1\/*idiv*\/, 2\/*ldiv*\/,\n-    1\/*fdiv*\/, 2\/*ddiv*\/, 1\/*irem*\/, 2\/*lrem*\/, 1\/*frem*\/, 2\/*drem*\/, 1\/*ineg*\/, 2\/*lneg*\/,\n-    1\/*fneg*\/, 2\/*dneg*\/, 1\/*ishl*\/, 2\/*lshl*\/, 1\/*ishr*\/, 2\/*lshr*\/, 1\/*iushr*\/, 2\/*lushr*\/,\n-    1\/*iand*\/, 2\/*land*\/, 1\/*ior*\/, 2\/*lor*\/, 1\/*ixor*\/, 2\/*lxor*\/,\n-    0\/*iinc*\/, 2\/*i2l*\/, 1\/*i2f*\/, 2\/*i2d*\/, 1\/*l2i*\/, 1\/*l2f*\/, 2\/*l2d*\/, 1\/*f2i*\/,\n-    2\/*f2l*\/, 2\/*f2d*\/, 1\/*d2i*\/, 2\/*d2l*\/, 1\/*d2f*\/,\n-    1\/*i2b*\/, 1\/*i2c*\/, 1\/*i2s*\/, 1\/*lcmp*\/, 1\/*fcmpl*\/, 1\/*fcmpg*\/,\n-    1\/*dcmpl*\/, 1\/*dcmpg*\/, 0\/*ifeq*\/, 0\/*ifne*\/, 0\/*iflt*\/, 0\/*ifge*\/, 0\/*ifgt*\/, 0\/*ifle*\/,\n-    0\/*if_icmpeq*\/, 0\/*if_icmpne*\/, 0\/*if_icmplt*\/, 0\/*if_icmpge*\/, 0\/*if_icmpgt*\/,\n-    0\/*if_icmple*\/, 0\/*if_acmpeq*\/, 0\/*if_acmpne*\/, 0\/*goto*\/, 1\/*jsr*\/, 0\/*ret*\/,\n-    0\/*tableswitch*\/, 0\/*lookupswitch*\/, 0\/*ireturn*\/, 0\/*lreturn*\/, 0\/*freturn*\/,\n-    0\/*dreturn*\/, 0\/*areturn*\/, 0\/*return*\/, UNPREDICTABLE\/*getstatic*\/, 0\/*putstatic*\/,\n-    UNPREDICTABLE\/*getfield*\/, 0\/*putfield*\/, UNPREDICTABLE\/*invokevirtual*\/,\n-    UNPREDICTABLE\/*invokespecial*\/, UNPREDICTABLE\/*invokestatic*\/,\n-    UNPREDICTABLE\/*invokeinterface*\/, UNPREDICTABLE\/*invokedynamic*\/, 1\/*new*\/, 1\/*newarray*\/, 1\/*anewarray*\/,\n-    1\/*arraylength*\/, 1\/*athrow*\/, 1\/*checkcast*\/, 1\/*instanceof*\/, 0\/*monitorenter*\/,\n-    0\/*monitorexit*\/, 0\/*wide*\/, 1\/*multianewarray*\/, 0\/*ifnull*\/, 0\/*ifnonnull*\/,\n-    0\/*goto_w*\/, 1\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-    UNDEFINED, UNPREDICTABLE\/*impdep1*\/, UNPREDICTABLE\/*impdep2*\/\n-  };\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return Number of words produced onto operand stack\n-   * @since 6.0\n-   *\/\n-  public static int getProduceStack(final int index) {\n-      return PRODUCE_STACK[index];\n-  }\n-\n-  \/** Attributes and their corresponding names.\n-   *\/\n-  public static final byte ATTR_UNKNOWN                                 = -1;\n-  public static final byte ATTR_SOURCE_FILE                             = 0;\n-  public static final byte ATTR_CONSTANT_VALUE                          = 1;\n-  public static final byte ATTR_CODE                                    = 2;\n-  public static final byte ATTR_EXCEPTIONS                              = 3;\n-  public static final byte ATTR_LINE_NUMBER_TABLE                       = 4;\n-  public static final byte ATTR_LOCAL_VARIABLE_TABLE                    = 5;\n-  public static final byte ATTR_INNER_CLASSES                           = 6;\n-  public static final byte ATTR_SYNTHETIC                               = 7;\n-  public static final byte ATTR_DEPRECATED                              = 8;\n-  public static final byte ATTR_PMG                                     = 9;\n-  public static final byte ATTR_SIGNATURE                               = 10;\n-  public static final byte ATTR_STACK_MAP                               = 11;\n-  public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS             = 12;\n-  public static final byte ATTR_RUNTIME_INVISIBLE_ANNOTATIONS           = 13;\n-  public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS   = 14;\n-  public static final byte ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = 15;\n-  public static final byte ATTR_ANNOTATION_DEFAULT                      = 16;\n-  public static final byte ATTR_LOCAL_VARIABLE_TYPE_TABLE               = 17;\n-  public static final byte ATTR_ENCLOSING_METHOD                        = 18;\n-  public static final byte ATTR_STACK_MAP_TABLE                         = 19;\n-  public static final byte ATTR_BOOTSTRAP_METHODS                       = 20;\n-  public static final byte ATTR_METHOD_PARAMETERS                       = 21;\n-  public static final byte ATTR_MODULE                                  = 22;\n-  public static final byte ATTR_MODULE_PACKAGES                         = 23;\n-  public static final byte ATTR_MODULE_MAIN_CLASS                       = 24;\n-  public static final byte ATTR_NEST_HOST                               = 25;\n-  public static final byte ATTR_NEST_MEMBERS                            = 26;\n-\n-  public static final short KNOWN_ATTRIBUTES = 27; \/\/ count of attributes\n-\n-  private static final String[] ATTRIBUTE_NAMES = {\n-    \"SourceFile\", \"ConstantValue\", \"Code\", \"Exceptions\",\n-    \"LineNumberTable\", \"LocalVariableTable\",\n-    \"InnerClasses\", \"Synthetic\", \"Deprecated\",\n-    \"PMGClass\", \"Signature\", \"StackMap\",\n-    \"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\",\n-    \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\",\n-    \"AnnotationDefault\", \"LocalVariableTypeTable\", \"EnclosingMethod\", \"StackMapTable\",\n-    \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\",\n-    \"ModuleMainClass\", \"NestHost\", \"NestMembers\"\n-  };\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return the attribute name\n-   * @since 6.0\n-   *\/\n-  public static String getAttributeName(final int index) {\n-      return ATTRIBUTE_NAMES[index];\n-  }\n-\n-  \/** Constants used in the StackMap attribute.\n-   *\/\n-  public static final byte ITEM_Bogus      = 0;\n-  public static final byte ITEM_Integer    = 1;\n-  public static final byte ITEM_Float      = 2;\n-  public static final byte ITEM_Double     = 3;\n-  public static final byte ITEM_Long       = 4;\n-  public static final byte ITEM_Null       = 5;\n-  public static final byte ITEM_InitObject = 6;\n-  public static final byte ITEM_Object     = 7;\n-  public static final byte ITEM_NewObject  = 8;\n-\n-  private static final String[] ITEM_NAMES = {\n-    \"Bogus\", \"Integer\", \"Float\", \"Double\", \"Long\",\n-    \"Null\", \"InitObject\", \"Object\", \"NewObject\"\n-  };\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return the item name\n-   * @since 6.0\n-   *\/\n-  public static String getItemName(final int index) {\n-      return ITEM_NAMES[index];\n-  }\n-\n-  \/** Constants used to identify StackMapEntry types.\n-   *\n-   * For those types which can specify a range, the\n-   * constant names the lowest value.\n-   *\/\n-  public static final int SAME_FRAME = 0;\n-  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n-  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n-  public static final int CHOP_FRAME = 248;\n-  public static final int SAME_FRAME_EXTENDED = 251;\n-  public static final int APPEND_FRAME = 252;\n-  public static final int FULL_FRAME = 255;\n-\n-  \/** Constants that define the maximum value of\n-   * those constants which store ranges. *\/\n-\n-  public static final int SAME_FRAME_MAX = 63;\n-  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX = 127;\n-  public static final int CHOP_FRAME_MAX = 250;\n-  public static final int APPEND_FRAME_MAX = 254;\n-\n-\n-  \/\/ Constants defining the behavior of the Method Handles (JVMS 5.4.3.5)\n-\n-  public static final byte REF_getField         = 1;\n-  public static final byte REF_getStatic        = 2;\n-  public static final byte REF_putField         = 3;\n-  public static final byte REF_putStatic        = 4;\n-  public static final byte REF_invokeVirtual    = 5;\n-  public static final byte REF_invokeStatic     = 6;\n-  public static final byte REF_invokeSpecial    = 7;\n-  public static final byte REF_newInvokeSpecial = 8;\n-  public static final byte REF_invokeInterface  = 9;\n-\n-  \/**\n-   * The names of the reference_kinds of a CONSTANT_MethodHandle_info.\n-   *\/\n-  private static final String[] METHODHANDLE_NAMES = {\n-      \"\", \"getField\", \"getStatic\", \"putField\", \"putStatic\", \"invokeVirtual\",\n-      \"invokeStatic\", \"invokeSpecial\", \"newInvokeSpecial\", \"invokeInterface\" };\n-\n-  \/**\n-   *\n-   * @param index\n-   * @return the method handle name\n-   * @since 6.0\n-   *\/\n-  public static String getMethodHandleName(final int index) {\n-      return METHODHANDLE_NAMES[index];\n-  }\n-\n-  private Const() { } \/\/ not instantiable\n+    \/**\n+     * Java class file format Magic number (0xCAFEBABE)\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.1-200-A\"> The ClassFile Structure\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final int JVM_CLASSFILE_MAGIC = 0xCAFEBABE;\n+\n+    \/**\n+     * Major version number of class files for Java 1.1.\n+     *\n+     * @see #MINOR_1_1\n+     *\/\n+    public static final short MAJOR_1_1 = 45;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.1.\n+     *\n+     * @see #MAJOR_1_1\n+     *\/\n+    public static final short MINOR_1_1 = 3;\n+\n+    \/**\n+     * Major version number of class files for Java 1.2.\n+     *\n+     * @see #MINOR_1_2\n+     *\/\n+    public static final short MAJOR_1_2 = 46;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.2.\n+     *\n+     * @see #MAJOR_1_2\n+     *\/\n+    public static final short MINOR_1_2 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 1.2.\n+     *\n+     * @see #MINOR_1_2\n+     *\/\n+    public static final short MAJOR_1_3 = 47;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.3.\n+     *\n+     * @see #MAJOR_1_3\n+     *\/\n+    public static final short MINOR_1_3 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 1.3.\n+     *\n+     * @see #MINOR_1_3\n+     *\/\n+    public static final short MAJOR_1_4 = 48;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.4.\n+     *\n+     * @see #MAJOR_1_4\n+     *\/\n+    public static final short MINOR_1_4 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 1.4.\n+     *\n+     * @see #MINOR_1_4\n+     *\/\n+    public static final short MAJOR_1_5 = 49;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.5.\n+     *\n+     * @see #MAJOR_1_5\n+     *\/\n+    public static final short MINOR_1_5 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 1.6.\n+     *\n+     * @see #MINOR_1_6\n+     *\/\n+    public static final short MAJOR_1_6 = 50;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.6.\n+     *\n+     * @see #MAJOR_1_6\n+     *\/\n+    public static final short MINOR_1_6 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 1.7.\n+     *\n+     * @see #MINOR_1_7\n+     *\/\n+    public static final short MAJOR_1_7 = 51;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.7.\n+     *\n+     * @see #MAJOR_1_7\n+     *\/\n+    public static final short MINOR_1_7 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 1.8.\n+     *\n+     * @see #MINOR_1_8\n+     *\/\n+    public static final short MAJOR_1_8 = 52;\n+\n+    \/**\n+     * Minor version number of class files for Java 1.8.\n+     *\n+     * @see #MAJOR_1_8\n+     *\/\n+    public static final short MINOR_1_8 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 9.\n+     *\n+     * @see #MINOR_9\n+     *\/\n+    public static final short MAJOR_9 = 53;\n+\n+    \/**\n+     * Minor version number of class files for Java 9.\n+     *\n+     * @see #MAJOR_9\n+     *\/\n+    public static final short MINOR_9 = 0;\n+\n+    \/**\n+     * @deprecated Use {@link #MAJOR_9} instead\n+     *\/\n+    @Deprecated\n+    public static final short MAJOR_1_9 = MAJOR_9;\n+\n+    \/**\n+     * @deprecated Use {@link #MINOR_9} instead\n+     *\/\n+    @Deprecated\n+    public static final short MINOR_1_9 = MINOR_9;\n+\n+    \/**\n+     * Major version number of class files for Java 10.\n+     *\n+     * @see #MINOR_10\n+     *\/\n+    public static final short MAJOR_10 = 54;\n+\n+    \/**\n+     * Minor version number of class files for Java 10.\n+     *\n+     * @see #MAJOR_10\n+     *\/\n+    public static final short MINOR_10 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 11.\n+     *\n+     * @see #MINOR_11\n+     *\/\n+    public static final short MAJOR_11 = 55;\n+\n+    \/**\n+     * Minor version number of class files for Java 11.\n+     *\n+     * @see #MAJOR_11\n+     *\/\n+    public static final short MINOR_11 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 12.\n+     *\n+     * @see #MINOR_12\n+     *\/\n+    public static final short MAJOR_12 = 56;\n+\n+    \/**\n+     * Minor version number of class files for Java 12.\n+     *\n+     * @see #MAJOR_12\n+     *\/\n+    public static final short MINOR_12 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 13.\n+     *\n+     * @see #MINOR_13\n+     *\/\n+    public static final short MAJOR_13 = 57;\n+\n+    \/**\n+     * Minor version number of class files for Java 13.\n+     *\n+     * @see #MAJOR_13\n+     *\/\n+    public static final short MINOR_13 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 14.\n+     *\n+     * @see #MAJOR_14\n+     * @since 6.4.0\n+     *\/\n+    public static final short MINOR_14 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 15.\n+     *\n+     * @see #MAJOR_15\n+     * @since 6.6.0\n+     *\/\n+    public static final short MINOR_15 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 16.\n+     *\n+     * @see #MAJOR_16\n+     * @since 6.6.0\n+     *\/\n+    public static final short MINOR_16 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 17.\n+     *\n+     * @see #MAJOR_17\n+     * @since 6.6.0\n+     *\/\n+    public static final short MINOR_17 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 18.\n+     *\n+     * @see #MAJOR_18\n+     * @since 6.6.0\n+     *\/\n+    public static final short MINOR_18 = 0;\n+\n+    \/**\n+     * Minor version number of class files for Java 19.\n+     *\n+     * @see #MAJOR_19\n+     * @since 6.6.0\n+     *\/\n+    public static final short MINOR_19 = 0;\n+\n+    \/**\n+     * Major version number of class files for Java 14.\n+     *\n+     * @see #MINOR_14\n+     * @since 6.4.0\n+     *\/\n+    public static final short MAJOR_14 = 58;\n+\n+    \/**\n+     * Major version number of class files for Java 15.\n+     *\n+     * @see #MINOR_15\n+     * @since 6.6.0\n+     *\/\n+    public static final short MAJOR_15 = 59;\n+\n+    \/**\n+     * Major version number of class files for Java 16.\n+     *\n+     * @see #MINOR_16\n+     * @since 6.6.0\n+     *\/\n+    public static final short MAJOR_16 = 60;\n+\n+    \/**\n+     * Major version number of class files for Java 17.\n+     *\n+     * @see #MINOR_17\n+     * @since 6.6.0\n+     *\/\n+    public static final short MAJOR_17 = 61;\n+\n+    \/**\n+     * Major version number of class files for Java 18.\n+     *\n+     * @see #MINOR_18\n+     * @since 6.6.0\n+     *\/\n+    public static final short MAJOR_18 = 62;\n+\n+    \/**\n+     * Major version number of class files for Java 19.\n+     *\n+     * @see #MINOR_19\n+     * @since 6.6.0\n+     *\/\n+    public static final short MAJOR_19 = 63;\n+\n+    \/**\n+     * Default major version number. Class file is for Java 1.1.\n+     *\n+     * @see #MAJOR_1_1\n+     *\/\n+    public static final short MAJOR = MAJOR_1_1;\n+\n+    \/**\n+     * Default major version number. Class file is for Java 1.1.\n+     *\n+     * @see #MAJOR_1_1\n+     *\/\n+    public static final short MINOR = MINOR_1_1;\n+\n+    \/**\n+     * Maximum value for an unsigned short.\n+     *\/\n+    public static final int MAX_SHORT = 65535; \/\/ 2^16 - 1\n+\n+    \/**\n+     * Maximum value for an unsigned byte.\n+     *\/\n+    public static final int MAX_BYTE = 255; \/\/ 2^8 - 1\n+\n+    \/**\n+     * One of the access flags for fields, methods, or classes.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.1-200-E.1\"> Flag definitions for\n+     *      Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.5\"> Flag definitions for Fields\n+     *      in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.6\"> Flag definitions for Methods\n+     *      in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.7.6-300-D.1-D.1\"> Flag\n+     *      definitions for Inner Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+     *\/\n+    public static final short ACC_PUBLIC = 0x0001;\n+\n+    \/**\n+     * One of the access flags for fields, methods, or classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_PRIVATE = 0x0002;\n+\n+    \/**\n+     * One of the access flags for fields, methods, or classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_PROTECTED = 0x0004;\n+\n+    \/**\n+     * One of the access flags for fields, methods, or classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_STATIC = 0x0008;\n+\n+    \/**\n+     * One of the access flags for fields, methods, or classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_FINAL = 0x0010;\n+\n+    \/**\n+     * One of the access flags for the Module attribute.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_OPEN = 0x0020;\n+\n+    \/**\n+     * One of the access flags for classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_SUPER = 0x0020;\n+\n+    \/**\n+     * One of the access flags for methods.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_SYNCHRONIZED = 0x0020;\n+\n+    \/**\n+     * One of the access flags for the Module attribute.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_TRANSITIVE = 0x0020;\n+\n+    \/**\n+     * One of the access flags for methods.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_BRIDGE = 0x0040;\n+\n+    \/**\n+     * One of the access flags for the Module attribute.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_STATIC_PHASE = 0x0040;\n+\n+    \/**\n+     * One of the access flags for fields.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_VOLATILE = 0x0040;\n+\n+    \/**\n+     * One of the access flags for fields.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_TRANSIENT = 0x0080;\n+\n+    \/**\n+     * One of the access flags for methods.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_VARARGS = 0x0080;\n+\n+    \/**\n+     * One of the access flags for methods.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_NATIVE = 0x0100;\n+\n+    \/**\n+     * One of the access flags for classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_INTERFACE = 0x0200;\n+\n+    \/**\n+     * One of the access flags for methods or classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_ABSTRACT = 0x0400;\n+\n+    \/**\n+     * One of the access flags for methods.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_STRICT = 0x0800;\n+\n+    \/**\n+     * One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_SYNTHETIC = 0x1000;\n+\n+    \/**\n+     * One of the access flags for classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_ANNOTATION = 0x2000;\n+\n+    \/**\n+     * One of the access flags for fields or classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_ENUM = 0x4000;\n+\n+    \/\/ Applies to classes compiled by new compilers only\n+    \/**\n+     * One of the access flags for MethodParameter or Module attributes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_MANDATED = (short) 0x8000;\n+\n+    \/**\n+     * One of the access flags for classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     *\/\n+    public static final short ACC_MODULE = (short) 0x8000;\n+\n+    \/**\n+     * One of the access flags for fields, methods, or classes.\n+     *\n+     * @see #ACC_PUBLIC\n+     * @deprecated Use {@link #MAX_ACC_FLAG_I}\n+     *\/\n+    @Deprecated\n+    public static final short MAX_ACC_FLAG = ACC_ENUM;\n+\n+    \/**\n+     * One of the access flags for fields, methods, or classes. ACC_MODULE is negative as a short.\n+     *\n+     * @see #ACC_PUBLIC\n+     * @since 6.4.0\n+     *\/\n+    public static final int MAX_ACC_FLAG_I = 0x8000; \/\/ ACC_MODULE is negative as a short\n+\n+    \/\/ Note that do to overloading:\n+    \/\/ 'synchronized' is for methods, might be 'open' (if Module), 'super' (if class), or 'transitive' (if Module).\n+    \/\/ 'volatile' is for fields, might be 'bridge' (if method) or 'static_phase' (if Module)\n+    \/\/ 'transient' is for fields, might be 'varargs' (if method)\n+    \/\/ 'module' is for classes, might be 'mandated' (if Module or MethodParameters)\n+    \/**\n+     * The names of the access flags.\n+     *\/\n+    private static final String[] ACCESS_NAMES = {\"public\", \"private\", \"protected\", \"static\", \"final\", \"synchronized\", \"volatile\", \"transient\", \"native\",\n+        \"interface\", \"abstract\", \"strictfp\", \"synthetic\", \"annotation\", \"enum\", \"module\"};\n+\n+    \/** @since 6.0 *\/\n+    public static final int ACCESS_NAMES_LENGTH = ACCESS_NAMES.length;\n+\n+    \/**\n+     * Marks a constant pool entry as type UTF-8.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.7\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Utf8 = 1;\n+\n+    \/*\n+     * The description of the constant pool is at: https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4\n+     * References below are to the individual sections\n+     *\/\n+\n+    \/**\n+     * Marks a constant pool entry as type Integer.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Integer = 3;\n+\n+    \/**\n+     * Marks a constant pool entry as type Float.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Float = 4;\n+\n+    \/**\n+     * Marks a constant pool entry as type Long.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Long = 5;\n+\n+    \/**\n+     * Marks a constant pool entry as type Double.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Double = 6;\n+\n+    \/**\n+     * Marks a constant pool entry as a Class\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.1\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Class = 7;\n+\n+    \/**\n+     * Marks a constant pool entry as a Field Reference.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Fieldref = 9;\n+\n+    \/**\n+     * Marks a constant pool entry as type String\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.3\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_String = 8;\n+\n+    \/**\n+     * Marks a constant pool entry as a Method Reference.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_Methodref = 10;\n+\n+    \/**\n+     * Marks a constant pool entry as an Interface Method Reference.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_InterfaceMethodref = 11;\n+\n+    \/**\n+     * Marks a constant pool entry as a name and type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.6\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_NameAndType = 12;\n+\n+    \/**\n+     * Marks a constant pool entry as a Method Handle.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.8\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_MethodHandle = 15;\n+\n+    \/**\n+     * Marks a constant pool entry as a Method Type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.9\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_MethodType = 16;\n+\n+    \/**\n+     * Marks a constant pool entry as dynamically computed.\n+     *\n+     * @see <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\"> Change request for JEP\n+     *      309<\/a>\n+     * @since 6.3\n+     *\/\n+    public static final byte CONSTANT_Dynamic = 17;\n+\n+    \/**\n+     * Marks a constant pool entry as an Invoke Dynamic\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte CONSTANT_InvokeDynamic = 18;\n+\n+    \/**\n+     * Marks a constant pool entry as a Module Reference.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.11\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     * @since 6.1\n+     *\/\n+    public static final byte CONSTANT_Module = 19;\n+\n+    \/**\n+     * Marks a constant pool entry as a Package Reference.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.12\"> The Constant Pool in The\n+     *      Java Virtual Machine Specification<\/a>\n+     * @since 6.1\n+     *\/\n+    public static final byte CONSTANT_Package = 20;\n+\n+    \/**\n+     * The names of the types of entries in a constant pool. Use getConstantName instead\n+     *\/\n+    private static final String[] CONSTANT_NAMES = {\"\", \"CONSTANT_Utf8\", \"\", \"CONSTANT_Integer\", \"CONSTANT_Float\", \"CONSTANT_Long\", \"CONSTANT_Double\",\n+        \"CONSTANT_Class\", \"CONSTANT_String\", \"CONSTANT_Fieldref\", \"CONSTANT_Methodref\", \"CONSTANT_InterfaceMethodref\", \"CONSTANT_NameAndType\", \"\", \"\",\n+        \"CONSTANT_MethodHandle\", \"CONSTANT_MethodType\", \"CONSTANT_Dynamic\", \"CONSTANT_InvokeDynamic\", \"CONSTANT_Module\", \"CONSTANT_Package\"};\n+\n+    \/**\n+     * The name of the static initializer, also called &quot;class initialization method&quot; or &quot;interface\n+     * initialization method&quot;. This is &quot;&lt;clinit&gt;&quot;.\n+     *\/\n+    public static final String STATIC_INITIALIZER_NAME = \"<clinit>\";\n+\n+    \/**\n+     * The name of every constructor method in a class, also called &quot;instance initialization method&quot;. This is\n+     * &quot;&lt;init&gt;&quot;.\n+     *\/\n+    public static final String CONSTRUCTOR_NAME = \"<init>\";\n+\n+    \/**\n+     * The names of the interfaces implemented by arrays\n+     *\/\n+    private static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = {\"java.lang.Cloneable\", \"java.io.Serializable\"};\n+\n+    \/**\n+     * Maximum Constant Pool entries. One of the limitations of the Java Virtual Machine.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.11-100-A\"> The Java Virtual\n+     *      Machine Specification, Java SE 8 Edition, page 330, chapter 4.11.<\/a>\n+     *\/\n+    public static final int MAX_CP_ENTRIES = 65535;\n+\n+    \/**\n+     * Maximum code size (plus one; the code size must be LESS than this) One of the limitations of the Java Virtual\n+     * Machine. Note vmspec2 page 152 (\"Limitations\") says: \"The amount of code per non-native, non-abstract method is\n+     * limited to 65536 bytes by the sizes of the indices in the exception_table of the Code attribute (4.7.3), in the\n+     * LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\" However this should be taken\n+     * as an upper limit rather than the defined maximum. On page 134 (4.8.1 Static Constants) of the same spec, it says:\n+     * \"The value of the code_length item must be less than 65536.\" The entry in the Limitations section has been removed\n+     * from later versions of the spec; it is not present in the Java SE 8 edition.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\"> The Java Virtual\n+     *      Machine Specification, Java SE 8 Edition, page 104, chapter 4.7.<\/a>\n+     *\/\n+    public static final int MAX_CODE_SIZE = 65536; \/\/ bytes\n+\n+    \/**\n+     * The maximum number of dimensions in an array ({@value}). One of the limitations of the Java Virtual Machine.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3.2-150\"> Field Descriptors in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final int MAX_ARRAY_DIMENSIONS = 255;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.nop\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short NOP = 0;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aconst_null\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ACONST_NULL = 1;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ICONST_M1 = 2;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ICONST_0 = 3;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ICONST_1 = 4;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ICONST_2 = 5;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ICONST_3 = 6;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ICONST_4 = 7;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ICONST_5 = 8;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LCONST_0 = 9;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LCONST_1 = 10;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FCONST_0 = 11;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FCONST_1 = 12;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FCONST_2 = 13;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DCONST_0 = 14;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DCONST_1 = 15;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bipush\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short BIPUSH = 16;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sipush\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short SIPUSH = 17;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LDC = 18;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc_w\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LDC_W = 19;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc2_w\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LDC2_W = 20;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ILOAD = 21;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LLOAD = 22;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FLOAD = 23;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DLOAD = 24;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ALOAD = 25;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ILOAD_0 = 26;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ILOAD_1 = 27;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ILOAD_2 = 28;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ILOAD_3 = 29;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LLOAD_0 = 30;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LLOAD_1 = 31;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LLOAD_2 = 32;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LLOAD_3 = 33;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FLOAD_0 = 34;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FLOAD_1 = 35;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FLOAD_2 = 36;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FLOAD_3 = 37;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DLOAD_0 = 38;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DLOAD_1 = 39;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DLOAD_2 = 40;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DLOAD_3 = 41;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ALOAD_0 = 42;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ALOAD_1 = 43;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ALOAD_2 = 44;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ALOAD_3 = 45;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iaload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IALOAD = 46;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.laload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LALOAD = 47;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.faload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FALOAD = 48;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.daload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DALOAD = 49;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aaload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short AALOAD = 50;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.baload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short BALOAD = 51;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.caload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short CALOAD = 52;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.saload\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short SALOAD = 53;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISTORE = 54;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSTORE = 55;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FSTORE = 56;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DSTORE = 57;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ASTORE = 58;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISTORE_0 = 59;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISTORE_1 = 60;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISTORE_2 = 61;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISTORE_3 = 62;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSTORE_0 = 63;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSTORE_1 = 64;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSTORE_2 = 65;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSTORE_3 = 66;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FSTORE_0 = 67;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FSTORE_1 = 68;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FSTORE_2 = 69;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FSTORE_3 = 70;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DSTORE_0 = 71;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DSTORE_1 = 72;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DSTORE_2 = 73;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DSTORE_3 = 74;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ASTORE_0 = 75;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ASTORE_1 = 76;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ASTORE_2 = 77;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ASTORE_3 = 78;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iastore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IASTORE = 79;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lastore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LASTORE = 80;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fastore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FASTORE = 81;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dastore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DASTORE = 82;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aastore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short AASTORE = 83;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bastore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short BASTORE = 84;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.castore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short CASTORE = 85;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sastore\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short SASTORE = 86;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short POP = 87;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop2\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short POP2 = 88;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DUP = 89;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x1\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DUP_X1 = 90;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x2\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DUP_X2 = 91;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DUP2 = 92;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x1\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DUP2_X1 = 93;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x2\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DUP2_X2 = 94;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.swap\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short SWAP = 95;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iadd\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IADD = 96;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ladd\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LADD = 97;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fadd\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FADD = 98;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dadd\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DADD = 99;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.isub\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISUB = 100;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lsub\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSUB = 101;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fsub\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FSUB = 102;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dsub\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DSUB = 103;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.imul\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IMUL = 104;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lmul\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LMUL = 105;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fmul\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FMUL = 106;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dmul\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DMUL = 107;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.idiv\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IDIV = 108;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldiv\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LDIV = 109;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fdiv\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FDIV = 110;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ddiv\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DDIV = 111;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.irem\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IREM = 112;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lrem\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LREM = 113;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.frem\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FREM = 114;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.drem\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DREM = 115;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ineg\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INEG = 116;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lneg\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LNEG = 117;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fneg\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FNEG = 118;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dneg\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DNEG = 119;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishl\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISHL = 120;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshl\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSHL = 121;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishr\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ISHR = 122;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshr\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LSHR = 123;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iushr\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IUSHR = 124;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lushr\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LUSHR = 125;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iand\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IAND = 126;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.land\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LAND = 127;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ior\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IOR = 128;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lor\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LOR = 129;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ixor\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IXOR = 130;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lxor\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LXOR = 131;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iinc\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IINC = 132;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2l\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short I2L = 133;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2f\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short I2F = 134;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2d\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short I2D = 135;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2i\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short L2I = 136;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2f\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short L2F = 137;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2d\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short L2D = 138;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2i\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short F2I = 139;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2l\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short F2L = 140;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2d\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short F2D = 141;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2i\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short D2I = 142;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2l\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short D2L = 143;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2f\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short D2F = 144;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2b\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short I2B = 145;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INT2BYTE = 145; \/\/ Old notation\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2c\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short I2C = 146;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INT2CHAR = 146; \/\/ Old notation\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2s\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short I2S = 147;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INT2SHORT = 147; \/\/ Old notation\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lcmp\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LCMP = 148;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpl\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FCMPL = 149;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpg\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FCMPG = 150;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpl\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DCMPL = 151;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpg\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DCMPG = 152;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifeq\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFEQ = 153;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifne\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFNE = 154;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iflt\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFLT = 155;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifge\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFGE = 156;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifgt\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFGT = 157;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifle\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFLE = 158;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ICMPEQ = 159;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ICMPNE = 160;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ICMPLT = 161;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ICMPGE = 162;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ICMPGT = 163;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ICMPLE = 164;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ACMPEQ = 165;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IF_ACMPNE = 166;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short GOTO = 167;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short JSR = 168;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ret\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short RET = 169;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.tableswitch\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short TABLESWITCH = 170;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lookupswitch\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LOOKUPSWITCH = 171;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ireturn\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IRETURN = 172;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lreturn\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short LRETURN = 173;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.freturn\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short FRETURN = 174;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dreturn\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short DRETURN = 175;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.areturn\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ARETURN = 176;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.return\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short RETURN = 177;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getstatic\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short GETSTATIC = 178;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putstatic\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short PUTSTATIC = 179;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getfield\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short GETFIELD = 180;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putfield\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short PUTFIELD = 181;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INVOKEVIRTUAL = 182;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INVOKESPECIAL = 183;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INVOKENONVIRTUAL = 183; \/\/ Old name in JDK 1.0\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INVOKESTATIC = 184;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INVOKEINTERFACE = 185;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INVOKEDYNAMIC = 186;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.new\"> Opcode definitions in The\n+     *      Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short NEW = 187;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.newarray\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short NEWARRAY = 188;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.anewarray\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ANEWARRAY = 189;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.arraylength\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ARRAYLENGTH = 190;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.athrow\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short ATHROW = 191;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.checkcast\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short CHECKCAST = 192;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.instanceof\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short INSTANCEOF = 193;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorenter\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short MONITORENTER = 194;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorexit\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short MONITOREXIT = 195;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.wide\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short WIDE = 196;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.multianewarray\"> Opcode\n+     *      definitions in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short MULTIANEWARRAY = 197;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnull\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFNULL = 198;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnonnull\"> Opcode definitions\n+     *      in The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IFNONNULL = 199;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto_w\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short GOTO_W = 200;\n+\n+    \/**\n+     * Java VM opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr_w\"> Opcode definitions in\n+     *      The Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short JSR_W = 201;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n+     *      Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short BREAKPOINT = 202;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short LDC_QUICK = 203;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short LDC_W_QUICK = 204;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short LDC2_W_QUICK = 205;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short GETFIELD_QUICK = 206;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short PUTFIELD_QUICK = 207;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short GETFIELD2_QUICK = 208;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short PUTFIELD2_QUICK = 209;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short GETSTATIC_QUICK = 210;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short PUTSTATIC_QUICK = 211;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short GETSTATIC2_QUICK = 212;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short PUTSTATIC2_QUICK = 213;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INVOKEVIRTUAL_QUICK = 214;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INVOKENONVIRTUAL_QUICK = 215;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INVOKESUPER_QUICK = 216;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INVOKESTATIC_QUICK = 217;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INVOKEINTERFACE_QUICK = 218;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INVOKEVIRTUALOBJECT_QUICK = 219;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short NEW_QUICK = 221;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short ANEWARRAY_QUICK = 222;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short MULTIANEWARRAY_QUICK = 223;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short CHECKCAST_QUICK = 224;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INSTANCEOF_QUICK = 225;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short INVOKEVIRTUAL_QUICK_W = 226;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short GETFIELD_QUICK_W = 227;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n+     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n+     *\/\n+    public static final short PUTFIELD_QUICK_W = 228;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n+     *      Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IMPDEP1 = 254;\n+\n+    \/**\n+     * JVM internal opcode.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n+     *      Virtual Machine Specification<\/a>\n+     *\/\n+    public static final short IMPDEP2 = 255;\n+\n+    \/**\n+     * BCEL virtual instruction for pushing an arbitrary data type onto the stack. Will be converted to the appropriate JVM\n+     * opcode when the class is dumped.\n+     *\/\n+    public static final short PUSH = 4711;\n+\n+    \/**\n+     * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH. Will be converted to the appropriate JVM opcode when\n+     * the class is dumped.\n+     *\/\n+    public static final short SWITCH = 4712;\n+\n+    \/** Illegal opcode. *\/\n+    public static final short UNDEFINED = -1;\n+\n+    \/** Illegal opcode. *\/\n+    public static final short UNPREDICTABLE = -2;\n+\n+    \/** Illegal opcode. *\/\n+    public static final short RESERVED = -3;\n+\n+    \/** Mnemonic for an illegal opcode. *\/\n+    public static final String ILLEGAL_OPCODE = \"<illegal opcode>\";\n+\n+    \/** Mnemonic for an illegal type. *\/\n+    public static final String ILLEGAL_TYPE = \"<illegal type>\";\n+\n+    \/**\n+     * Boolean data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_BOOLEAN = 4;\n+\n+    \/**\n+     * Char data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_CHAR = 5;\n+\n+    \/**\n+     * Float data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_FLOAT = 6;\n+\n+    \/**\n+     * Double data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_DOUBLE = 7;\n+\n+    \/**\n+     * Byte data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_BYTE = 8;\n+\n+    \/**\n+     * Short data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_SHORT = 9;\n+\n+    \/**\n+     * Int data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_INT = 10;\n+\n+    \/**\n+     * Long data type.\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n+     *      the Java Virtual Machine Specification<\/a>\n+     *\/\n+    public static final byte T_LONG = 11;\n+\n+    \/** Void data type (non-standard). *\/\n+    public static final byte T_VOID = 12; \/\/ Non-standard\n+\n+    \/** Array data type. *\/\n+    public static final byte T_ARRAY = 13;\n+\n+    \/** Object data type. *\/\n+    public static final byte T_OBJECT = 14;\n+\n+    \/** Reference data type (deprecated). *\/\n+    public static final byte T_REFERENCE = 14; \/\/ Deprecated\n+\n+    \/** Unknown data type. *\/\n+    public static final byte T_UNKNOWN = 15;\n+\n+    \/** Address data type. *\/\n+    public static final byte T_ADDRESS = 16;\n+\n+    \/** Empty arrays used to replace references to ArrayUtils *\/\n+    public static final byte[] EMPTY_BYTE_ARRAY = {};\n+    public static final int[] EMPTY_INT_ARRAY = {};\n+    public static final String[] EMPTY_STRING_ARRAY = {};\n+\n+    \/**\n+     * The primitive type names corresponding to the T_XX constants, e.g., TYPE_NAMES[T_INT] = \"int\"\n+     *\/\n+    private static final String[] TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"boolean\", \"char\", \"float\", \"double\", \"byte\", \"short\",\n+        \"int\", \"long\", \"void\", \"array\", \"object\", \"unknown\", \"address\"};\n+\n+    \/**\n+     * The primitive class names corresponding to the T_XX constants, e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n+     *\/\n+    private static final String[] CLASS_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"java.lang.Boolean\", \"java.lang.Character\",\n+        \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Byte\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Void\", ILLEGAL_TYPE,\n+        ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE};\n+\n+    \/**\n+     * The signature characters corresponding to primitive types, e.g., SHORT_TYPE_NAMES[T_INT] = \"I\"\n+     *\/\n+    private static final String[] SHORT_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\", \"V\",\n+        ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE};\n+\n+    \/**\n+     * Number of byte code operands for each opcode, i.e., number of bytes after the tag byte itself. Indexed by opcode, so\n+     * NO_OF_OPERANDS[BIPUSH] = the number of operands for a bipush instruction.\n+     *\/\n+    static final short[] NO_OF_OPERANDS = {0\/* nop *\/, 0\/* aconst_null *\/, 0\/* iconst_m1 *\/, 0\/* iconst_0 *\/, 0\/* iconst_1 *\/, 0\/* iconst_2 *\/,\n+        0\/* iconst_3 *\/, 0\/* iconst_4 *\/, 0\/* iconst_5 *\/, 0\/* lconst_0 *\/, 0\/* lconst_1 *\/, 0\/* fconst_0 *\/, 0\/* fconst_1 *\/, 0\/* fconst_2 *\/, 0\/* dconst_0 *\/,\n+        0\/* dconst_1 *\/, 1\/* bipush *\/, 2\/* sipush *\/, 1\/* ldc *\/, 2\/* ldc_w *\/, 2\/* ldc2_w *\/, 1\/* iload *\/, 1\/* lload *\/, 1\/* fload *\/, 1\/* dload *\/,\n+        1\/* aload *\/, 0\/* iload_0 *\/, 0\/* iload_1 *\/, 0\/* iload_2 *\/, 0\/* iload_3 *\/, 0\/* lload_0 *\/, 0\/* lload_1 *\/, 0\/* lload_2 *\/, 0\/* lload_3 *\/,\n+        0\/* fload_0 *\/, 0\/* fload_1 *\/, 0\/* fload_2 *\/, 0\/* fload_3 *\/, 0\/* dload_0 *\/, 0\/* dload_1 *\/, 0\/* dload_2 *\/, 0\/* dload_3 *\/, 0\/* aload_0 *\/,\n+        0\/* aload_1 *\/, 0\/* aload_2 *\/, 0\/* aload_3 *\/, 0\/* iaload *\/, 0\/* laload *\/, 0\/* faload *\/, 0\/* daload *\/, 0\/* aaload *\/, 0\/* baload *\/, 0\/* caload *\/,\n+        0\/* saload *\/, 1\/* istore *\/, 1\/* lstore *\/, 1\/* fstore *\/, 1\/* dstore *\/, 1\/* astore *\/, 0\/* istore_0 *\/, 0\/* istore_1 *\/, 0\/* istore_2 *\/,\n+        0\/* istore_3 *\/, 0\/* lstore_0 *\/, 0\/* lstore_1 *\/, 0\/* lstore_2 *\/, 0\/* lstore_3 *\/, 0\/* fstore_0 *\/, 0\/* fstore_1 *\/, 0\/* fstore_2 *\/, 0\/* fstore_3 *\/,\n+        0\/* dstore_0 *\/, 0\/* dstore_1 *\/, 0\/* dstore_2 *\/, 0\/* dstore_3 *\/, 0\/* astore_0 *\/, 0\/* astore_1 *\/, 0\/* astore_2 *\/, 0\/* astore_3 *\/, 0\/* iastore *\/,\n+        0\/* lastore *\/, 0\/* fastore *\/, 0\/* dastore *\/, 0\/* aastore *\/, 0\/* bastore *\/, 0\/* castore *\/, 0\/* sastore *\/, 0\/* pop *\/, 0\/* pop2 *\/, 0\/* dup *\/,\n+        0\/* dup_x1 *\/, 0\/* dup_x2 *\/, 0\/* dup2 *\/, 0\/* dup2_x1 *\/, 0\/* dup2_x2 *\/, 0\/* swap *\/, 0\/* iadd *\/, 0\/* ladd *\/, 0\/* fadd *\/, 0\/* dadd *\/, 0\/* isub *\/,\n+        0\/* lsub *\/, 0\/* fsub *\/, 0\/* dsub *\/, 0\/* imul *\/, 0\/* lmul *\/, 0\/* fmul *\/, 0\/* dmul *\/, 0\/* idiv *\/, 0\/* ldiv *\/, 0\/* fdiv *\/, 0\/* ddiv *\/,\n+        0\/* irem *\/, 0\/* lrem *\/, 0\/* frem *\/, 0\/* drem *\/, 0\/* ineg *\/, 0\/* lneg *\/, 0\/* fneg *\/, 0\/* dneg *\/, 0\/* ishl *\/, 0\/* lshl *\/, 0\/* ishr *\/,\n+        0\/* lshr *\/, 0\/* iushr *\/, 0\/* lushr *\/, 0\/* iand *\/, 0\/* land *\/, 0\/* ior *\/, 0\/* lor *\/, 0\/* ixor *\/, 0\/* lxor *\/, 2\/* iinc *\/, 0\/* i2l *\/,\n+        0\/* i2f *\/, 0\/* i2d *\/, 0\/* l2i *\/, 0\/* l2f *\/, 0\/* l2d *\/, 0\/* f2i *\/, 0\/* f2l *\/, 0\/* f2d *\/, 0\/* d2i *\/, 0\/* d2l *\/, 0\/* d2f *\/, 0\/* i2b *\/,\n+        0\/* i2c *\/, 0\/* i2s *\/, 0\/* lcmp *\/, 0\/* fcmpl *\/, 0\/* fcmpg *\/, 0\/* dcmpl *\/, 0\/* dcmpg *\/, 2\/* ifeq *\/, 2\/* ifne *\/, 2\/* iflt *\/, 2\/* ifge *\/,\n+        2\/* ifgt *\/, 2\/* ifle *\/, 2\/* if_icmpeq *\/, 2\/* if_icmpne *\/, 2\/* if_icmplt *\/, 2\/* if_icmpge *\/, 2\/* if_icmpgt *\/, 2\/* if_icmple *\/, 2\/* if_acmpeq *\/,\n+        2\/* if_acmpne *\/, 2\/* goto *\/, 2\/* jsr *\/, 1\/* ret *\/, UNPREDICTABLE\/* tableswitch *\/, UNPREDICTABLE\/* lookupswitch *\/, 0\/* ireturn *\/, 0\/* lreturn *\/,\n+        0\/* freturn *\/, 0\/* dreturn *\/, 0\/* areturn *\/, 0\/* return *\/, 2\/* getstatic *\/, 2\/* putstatic *\/, 2\/* getfield *\/, 2\/* putfield *\/,\n+        2\/* invokevirtual *\/, 2\/* invokespecial *\/, 2\/* invokestatic *\/, 4\/* invokeinterface *\/, 4\/* invokedynamic *\/, 2\/* new *\/, 1\/* newarray *\/,\n+        2\/* anewarray *\/, 0\/* arraylength *\/, 0\/* athrow *\/, 2\/* checkcast *\/, 2\/* instanceof *\/, 0\/* monitorenter *\/, 0\/* monitorexit *\/,\n+        UNPREDICTABLE\/* wide *\/, 3\/* multianewarray *\/, 2\/* ifnull *\/, 2\/* ifnonnull *\/, 4\/* goto_w *\/, 4\/* jsr_w *\/, 0\/* breakpoint *\/, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED\/* impdep1 *\/,\n+        RESERVED\/* impdep2 *\/\n+    };\n+\n+    \/**\n+     * How the byte code operands are to be interpreted for each opcode. Indexed by opcode. TYPE_OF_OPERANDS[ILOAD] = an\n+     * array of shorts describing the data types for the instruction.\n+     *\/\n+    static final short[][] TYPE_OF_OPERANDS = {{}\/* nop *\/, {}\/* aconst_null *\/, {}\/* iconst_m1 *\/, {}\/* iconst_0 *\/, {}\/* iconst_1 *\/,\n+        {}\/* iconst_2 *\/, {}\/* iconst_3 *\/, {}\/* iconst_4 *\/, {}\/* iconst_5 *\/, {}\/* lconst_0 *\/, {}\/* lconst_1 *\/, {}\/* fconst_0 *\/, {}\/* fconst_1 *\/,\n+        {}\/* fconst_2 *\/, {}\/* dconst_0 *\/, {}\/* dconst_1 *\/, {T_BYTE}\/* bipush *\/, {T_SHORT}\/* sipush *\/, {T_BYTE}\/* ldc *\/, {T_SHORT}\/* ldc_w *\/,\n+        {T_SHORT}\/* ldc2_w *\/, {T_BYTE}\/* iload *\/, {T_BYTE}\/* lload *\/, {T_BYTE}\/* fload *\/, {T_BYTE}\/* dload *\/, {T_BYTE}\/* aload *\/, {}\/* iload_0 *\/,\n+        {}\/* iload_1 *\/, {}\/* iload_2 *\/, {}\/* iload_3 *\/, {}\/* lload_0 *\/, {}\/* lload_1 *\/, {}\/* lload_2 *\/, {}\/* lload_3 *\/, {}\/* fload_0 *\/, {}\/* fload_1 *\/,\n+        {}\/* fload_2 *\/, {}\/* fload_3 *\/, {}\/* dload_0 *\/, {}\/* dload_1 *\/, {}\/* dload_2 *\/, {}\/* dload_3 *\/, {}\/* aload_0 *\/, {}\/* aload_1 *\/, {}\/* aload_2 *\/,\n+        {}\/* aload_3 *\/, {}\/* iaload *\/, {}\/* laload *\/, {}\/* faload *\/, {}\/* daload *\/, {}\/* aaload *\/, {}\/* baload *\/, {}\/* caload *\/, {}\/* saload *\/,\n+        {T_BYTE}\/* istore *\/, {T_BYTE}\/* lstore *\/, {T_BYTE}\/* fstore *\/, {T_BYTE}\/* dstore *\/, {T_BYTE}\/* astore *\/, {}\/* istore_0 *\/, {}\/* istore_1 *\/,\n+        {}\/* istore_2 *\/, {}\/* istore_3 *\/, {}\/* lstore_0 *\/, {}\/* lstore_1 *\/, {}\/* lstore_2 *\/, {}\/* lstore_3 *\/, {}\/* fstore_0 *\/, {}\/* fstore_1 *\/,\n+        {}\/* fstore_2 *\/, {}\/* fstore_3 *\/, {}\/* dstore_0 *\/, {}\/* dstore_1 *\/, {}\/* dstore_2 *\/, {}\/* dstore_3 *\/, {}\/* astore_0 *\/, {}\/* astore_1 *\/,\n+        {}\/* astore_2 *\/, {}\/* astore_3 *\/, {}\/* iastore *\/, {}\/* lastore *\/, {}\/* fastore *\/, {}\/* dastore *\/, {}\/* aastore *\/, {}\/* bastore *\/,\n+        {}\/* castore *\/, {}\/* sastore *\/, {}\/* pop *\/, {}\/* pop2 *\/, {}\/* dup *\/, {}\/* dup_x1 *\/, {}\/* dup_x2 *\/, {}\/* dup2 *\/, {}\/* dup2_x1 *\/,\n+        {}\/* dup2_x2 *\/, {}\/* swap *\/, {}\/* iadd *\/, {}\/* ladd *\/, {}\/* fadd *\/, {}\/* dadd *\/, {}\/* isub *\/, {}\/* lsub *\/, {}\/* fsub *\/, {}\/* dsub *\/,\n+        {}\/* imul *\/, {}\/* lmul *\/, {}\/* fmul *\/, {}\/* dmul *\/, {}\/* idiv *\/, {}\/* ldiv *\/, {}\/* fdiv *\/, {}\/* ddiv *\/, {}\/* irem *\/, {}\/* lrem *\/,\n+        {}\/* frem *\/, {}\/* drem *\/, {}\/* ineg *\/, {}\/* lneg *\/, {}\/* fneg *\/, {}\/* dneg *\/, {}\/* ishl *\/, {}\/* lshl *\/, {}\/* ishr *\/, {}\/* lshr *\/,\n+        {}\/* iushr *\/, {}\/* lushr *\/, {}\/* iand *\/, {}\/* land *\/, {}\/* ior *\/, {}\/* lor *\/, {}\/* ixor *\/, {}\/* lxor *\/, {T_BYTE, T_BYTE}\/* iinc *\/, {}\/* i2l *\/,\n+        {}\/* i2f *\/, {}\/* i2d *\/, {}\/* l2i *\/, {}\/* l2f *\/, {}\/* l2d *\/, {}\/* f2i *\/, {}\/* f2l *\/, {}\/* f2d *\/, {}\/* d2i *\/, {}\/* d2l *\/, {}\/* d2f *\/,\n+        {}\/* i2b *\/, {}\/* i2c *\/, {}\/* i2s *\/, {}\/* lcmp *\/, {}\/* fcmpl *\/, {}\/* fcmpg *\/, {}\/* dcmpl *\/, {}\/* dcmpg *\/, {T_SHORT}\/* ifeq *\/,\n+        {T_SHORT}\/* ifne *\/, {T_SHORT}\/* iflt *\/, {T_SHORT}\/* ifge *\/, {T_SHORT}\/* ifgt *\/, {T_SHORT}\/* ifle *\/, {T_SHORT}\/* if_icmpeq *\/,\n+        {T_SHORT}\/* if_icmpne *\/, {T_SHORT}\/* if_icmplt *\/, {T_SHORT}\/* if_icmpge *\/, {T_SHORT}\/* if_icmpgt *\/, {T_SHORT}\/* if_icmple *\/,\n+        {T_SHORT}\/* if_acmpeq *\/, {T_SHORT}\/* if_acmpne *\/, {T_SHORT}\/* goto *\/, {T_SHORT}\/* jsr *\/, {T_BYTE}\/* ret *\/, {}\/* tableswitch *\/,\n+        {}\/* lookupswitch *\/, {}\/* ireturn *\/, {}\/* lreturn *\/, {}\/* freturn *\/, {}\/* dreturn *\/, {}\/* areturn *\/, {}\/* return *\/, {T_SHORT}\/* getstatic *\/,\n+        {T_SHORT}\/* putstatic *\/, {T_SHORT}\/* getfield *\/, {T_SHORT}\/* putfield *\/, {T_SHORT}\/* invokevirtual *\/, {T_SHORT}\/* invokespecial *\/,\n+        {T_SHORT}\/* invokestatic *\/, {T_SHORT, T_BYTE, T_BYTE}\/* invokeinterface *\/, {T_SHORT, T_BYTE, T_BYTE}\/* invokedynamic *\/, {T_SHORT}\/* new *\/,\n+        {T_BYTE}\/* newarray *\/, {T_SHORT}\/* anewarray *\/, {}\/* arraylength *\/, {}\/* athrow *\/, {T_SHORT}\/* checkcast *\/, {T_SHORT}\/* instanceof *\/,\n+        {}\/* monitorenter *\/, {}\/* monitorexit *\/, {T_BYTE}\/* wide *\/, {T_SHORT, T_BYTE}\/* multianewarray *\/, {T_SHORT}\/* ifnull *\/, {T_SHORT}\/* ifnonnull *\/,\n+        {T_INT}\/* goto_w *\/, {T_INT}\/* jsr_w *\/, {}\/* breakpoint *\/, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n+        {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}\/* impdep1 *\/, {}\/* impdep2 *\/\n+    };\n+\n+    \/**\n+     * Names of opcodes. Indexed by opcode. OPCODE_NAMES[ALOAD] = \"aload\".\n+     *\/\n+    static final String[] OPCODE_NAMES = {\"nop\", \"aconst_null\", \"iconst_m1\", \"iconst_0\", \"iconst_1\", \"iconst_2\", \"iconst_3\", \"iconst_4\", \"iconst_5\",\n+        \"lconst_0\", \"lconst_1\", \"fconst_0\", \"fconst_1\", \"fconst_2\", \"dconst_0\", \"dconst_1\", \"bipush\", \"sipush\", \"ldc\", \"ldc_w\", \"ldc2_w\", \"iload\", \"lload\",\n+        \"fload\", \"dload\", \"aload\", \"iload_0\", \"iload_1\", \"iload_2\", \"iload_3\", \"lload_0\", \"lload_1\", \"lload_2\", \"lload_3\", \"fload_0\", \"fload_1\", \"fload_2\",\n+        \"fload_3\", \"dload_0\", \"dload_1\", \"dload_2\", \"dload_3\", \"aload_0\", \"aload_1\", \"aload_2\", \"aload_3\", \"iaload\", \"laload\", \"faload\", \"daload\", \"aaload\",\n+        \"baload\", \"caload\", \"saload\", \"istore\", \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore_0\", \"istore_1\", \"istore_2\", \"istore_3\", \"lstore_0\", \"lstore_1\",\n+        \"lstore_2\", \"lstore_3\", \"fstore_0\", \"fstore_1\", \"fstore_2\", \"fstore_3\", \"dstore_0\", \"dstore_1\", \"dstore_2\", \"dstore_3\", \"astore_0\", \"astore_1\",\n+        \"astore_2\", \"astore_3\", \"iastore\", \"lastore\", \"fastore\", \"dastore\", \"aastore\", \"bastore\", \"castore\", \"sastore\", \"pop\", \"pop2\", \"dup\", \"dup_x1\",\n+        \"dup_x2\", \"dup2\", \"dup2_x1\", \"dup2_x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\", \"dadd\", \"isub\", \"lsub\", \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\", \"dmul\", \"idiv\",\n+        \"ldiv\", \"fdiv\", \"ddiv\", \"irem\", \"lrem\", \"frem\", \"drem\", \"ineg\", \"lneg\", \"fneg\", \"dneg\", \"ishl\", \"lshl\", \"ishr\", \"lshr\", \"iushr\", \"lushr\", \"iand\",\n+        \"land\", \"ior\", \"lor\", \"ixor\", \"lxor\", \"iinc\", \"i2l\", \"i2f\", \"i2d\", \"l2i\", \"l2f\", \"l2d\", \"f2i\", \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\", \"i2b\", \"i2c\", \"i2s\",\n+        \"lcmp\", \"fcmpl\", \"fcmpg\", \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\", \"ifgt\", \"ifle\", \"if_icmpeq\", \"if_icmpne\", \"if_icmplt\", \"if_icmpge\",\n+        \"if_icmpgt\", \"if_icmple\", \"if_acmpeq\", \"if_acmpne\", \"goto\", \"jsr\", \"ret\", \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\", \"dreturn\",\n+        \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\", \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\", \"invokeinterface\",\n+        \"invokedynamic\", \"new\", \"newarray\", \"anewarray\", \"arraylength\", \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\", \"monitorexit\", \"wide\",\n+        \"multianewarray\", \"ifnull\", \"ifnonnull\", \"goto_w\", \"jsr_w\", \"breakpoint\", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+        ILLEGAL_OPCODE, ILLEGAL_OPCODE, \"impdep1\", \"impdep2\"};\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public static final int OPCODE_NAMES_LENGTH = OPCODE_NAMES.length;\n+\n+    \/**\n+     * Number of words consumed on operand stack by instructions. Indexed by opcode. CONSUME_STACK[FALOAD] = number of words\n+     * consumed from the stack by a faload instruction.\n+     *\/\n+    static final int[] CONSUME_STACK = {0\/* nop *\/, 0\/* aconst_null *\/, 0\/* iconst_m1 *\/, 0\/* iconst_0 *\/, 0\/* iconst_1 *\/, 0\/* iconst_2 *\/,\n+        0\/* iconst_3 *\/, 0\/* iconst_4 *\/, 0\/* iconst_5 *\/, 0\/* lconst_0 *\/, 0\/* lconst_1 *\/, 0\/* fconst_0 *\/, 0\/* fconst_1 *\/, 0\/* fconst_2 *\/, 0\/* dconst_0 *\/,\n+        0\/* dconst_1 *\/, 0\/* bipush *\/, 0\/* sipush *\/, 0\/* ldc *\/, 0\/* ldc_w *\/, 0\/* ldc2_w *\/, 0\/* iload *\/, 0\/* lload *\/, 0\/* fload *\/, 0\/* dload *\/,\n+        0\/* aload *\/, 0\/* iload_0 *\/, 0\/* iload_1 *\/, 0\/* iload_2 *\/, 0\/* iload_3 *\/, 0\/* lload_0 *\/, 0\/* lload_1 *\/, 0\/* lload_2 *\/, 0\/* lload_3 *\/,\n+        0\/* fload_0 *\/, 0\/* fload_1 *\/, 0\/* fload_2 *\/, 0\/* fload_3 *\/, 0\/* dload_0 *\/, 0\/* dload_1 *\/, 0\/* dload_2 *\/, 0\/* dload_3 *\/, 0\/* aload_0 *\/,\n+        0\/* aload_1 *\/, 0\/* aload_2 *\/, 0\/* aload_3 *\/, 2\/* iaload *\/, 2\/* laload *\/, 2\/* faload *\/, 2\/* daload *\/, 2\/* aaload *\/, 2\/* baload *\/, 2\/* caload *\/,\n+        2\/* saload *\/, 1\/* istore *\/, 2\/* lstore *\/, 1\/* fstore *\/, 2\/* dstore *\/, 1\/* astore *\/, 1\/* istore_0 *\/, 1\/* istore_1 *\/, 1\/* istore_2 *\/,\n+        1\/* istore_3 *\/, 2\/* lstore_0 *\/, 2\/* lstore_1 *\/, 2\/* lstore_2 *\/, 2\/* lstore_3 *\/, 1\/* fstore_0 *\/, 1\/* fstore_1 *\/, 1\/* fstore_2 *\/, 1\/* fstore_3 *\/,\n+        2\/* dstore_0 *\/, 2\/* dstore_1 *\/, 2\/* dstore_2 *\/, 2\/* dstore_3 *\/, 1\/* astore_0 *\/, 1\/* astore_1 *\/, 1\/* astore_2 *\/, 1\/* astore_3 *\/, 3\/* iastore *\/,\n+        4\/* lastore *\/, 3\/* fastore *\/, 4\/* dastore *\/, 3\/* aastore *\/, 3\/* bastore *\/, 3\/* castore *\/, 3\/* sastore *\/, 1\/* pop *\/, 2\/* pop2 *\/, 1\/* dup *\/,\n+        2\/* dup_x1 *\/, 3\/* dup_x2 *\/, 2\/* dup2 *\/, 3\/* dup2_x1 *\/, 4\/* dup2_x2 *\/, 2\/* swap *\/, 2\/* iadd *\/, 4\/* ladd *\/, 2\/* fadd *\/, 4\/* dadd *\/, 2\/* isub *\/,\n+        4\/* lsub *\/, 2\/* fsub *\/, 4\/* dsub *\/, 2\/* imul *\/, 4\/* lmul *\/, 2\/* fmul *\/, 4\/* dmul *\/, 2\/* idiv *\/, 4\/* ldiv *\/, 2\/* fdiv *\/, 4\/* ddiv *\/,\n+        2\/* irem *\/, 4\/* lrem *\/, 2\/* frem *\/, 4\/* drem *\/, 1\/* ineg *\/, 2\/* lneg *\/, 1\/* fneg *\/, 2\/* dneg *\/, 2\/* ishl *\/, 3\/* lshl *\/, 2\/* ishr *\/,\n+        3\/* lshr *\/, 2\/* iushr *\/, 3\/* lushr *\/, 2\/* iand *\/, 4\/* land *\/, 2\/* ior *\/, 4\/* lor *\/, 2\/* ixor *\/, 4\/* lxor *\/, 0\/* iinc *\/, 1\/* i2l *\/,\n+        1\/* i2f *\/, 1\/* i2d *\/, 2\/* l2i *\/, 2\/* l2f *\/, 2\/* l2d *\/, 1\/* f2i *\/, 1\/* f2l *\/, 1\/* f2d *\/, 2\/* d2i *\/, 2\/* d2l *\/, 2\/* d2f *\/, 1\/* i2b *\/,\n+        1\/* i2c *\/, 1\/* i2s *\/, 4\/* lcmp *\/, 2\/* fcmpl *\/, 2\/* fcmpg *\/, 4\/* dcmpl *\/, 4\/* dcmpg *\/, 1\/* ifeq *\/, 1\/* ifne *\/, 1\/* iflt *\/, 1\/* ifge *\/,\n+        1\/* ifgt *\/, 1\/* ifle *\/, 2\/* if_icmpeq *\/, 2\/* if_icmpne *\/, 2\/* if_icmplt *\/, 2 \/* if_icmpge *\/, 2\/* if_icmpgt *\/, 2\/* if_icmple *\/, 2\/* if_acmpeq *\/,\n+        2\/* if_acmpne *\/, 0\/* goto *\/, 0\/* jsr *\/, 0\/* ret *\/, 1\/* tableswitch *\/, 1\/* lookupswitch *\/, 1\/* ireturn *\/, 2\/* lreturn *\/, 1\/* freturn *\/,\n+        2\/* dreturn *\/, 1\/* areturn *\/, 0\/* return *\/, 0\/* getstatic *\/, UNPREDICTABLE\/* putstatic *\/, 1\/* getfield *\/, UNPREDICTABLE\/* putfield *\/,\n+        UNPREDICTABLE\/* invokevirtual *\/, UNPREDICTABLE\/* invokespecial *\/, UNPREDICTABLE\/* invokestatic *\/, UNPREDICTABLE\/* invokeinterface *\/,\n+        UNPREDICTABLE\/* invokedynamic *\/, 0\/* new *\/, 1\/* newarray *\/, 1\/* anewarray *\/, 1\/* arraylength *\/, 1\/* athrow *\/, 1\/* checkcast *\/, 1\/* instanceof *\/,\n+        1\/* monitorenter *\/, 1\/* monitorexit *\/, 0\/* wide *\/, UNPREDICTABLE\/* multianewarray *\/, 1\/* ifnull *\/, 1\/* ifnonnull *\/, 0\/* goto_w *\/, 0\/* jsr_w *\/,\n+        0\/* breakpoint *\/, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNPREDICTABLE\/* impdep1 *\/, UNPREDICTABLE\/* impdep2 *\/\n+    };\n+\n+    \/**\n+     * Number of words produced onto operand stack by instructions. Indexed by opcode. CONSUME_STACK[DALOAD] = number of\n+     * words consumed from the stack by a daload instruction.\n+     *\/\n+    static final int[] PRODUCE_STACK = {0\/* nop *\/, 1\/* aconst_null *\/, 1\/* iconst_m1 *\/, 1\/* iconst_0 *\/, 1\/* iconst_1 *\/, 1\/* iconst_2 *\/,\n+        1\/* iconst_3 *\/, 1\/* iconst_4 *\/, 1\/* iconst_5 *\/, 2\/* lconst_0 *\/, 2\/* lconst_1 *\/, 1\/* fconst_0 *\/, 1\/* fconst_1 *\/, 1\/* fconst_2 *\/, 2\/* dconst_0 *\/,\n+        2\/* dconst_1 *\/, 1\/* bipush *\/, 1\/* sipush *\/, 1\/* ldc *\/, 1\/* ldc_w *\/, 2\/* ldc2_w *\/, 1\/* iload *\/, 2\/* lload *\/, 1\/* fload *\/, 2\/* dload *\/,\n+        1\/* aload *\/, 1\/* iload_0 *\/, 1\/* iload_1 *\/, 1\/* iload_2 *\/, 1\/* iload_3 *\/, 2\/* lload_0 *\/, 2\/* lload_1 *\/, 2\/* lload_2 *\/, 2\/* lload_3 *\/,\n+        1\/* fload_0 *\/, 1\/* fload_1 *\/, 1\/* fload_2 *\/, 1\/* fload_3 *\/, 2\/* dload_0 *\/, 2\/* dload_1 *\/, 2\/* dload_2 *\/, 2\/* dload_3 *\/, 1\/* aload_0 *\/,\n+        1\/* aload_1 *\/, 1\/* aload_2 *\/, 1\/* aload_3 *\/, 1\/* iaload *\/, 2\/* laload *\/, 1\/* faload *\/, 2\/* daload *\/, 1\/* aaload *\/, 1\/* baload *\/, 1\/* caload *\/,\n+        1\/* saload *\/, 0\/* istore *\/, 0\/* lstore *\/, 0\/* fstore *\/, 0\/* dstore *\/, 0\/* astore *\/, 0\/* istore_0 *\/, 0\/* istore_1 *\/, 0\/* istore_2 *\/,\n+        0\/* istore_3 *\/, 0\/* lstore_0 *\/, 0\/* lstore_1 *\/, 0\/* lstore_2 *\/, 0\/* lstore_3 *\/, 0\/* fstore_0 *\/, 0\/* fstore_1 *\/, 0\/* fstore_2 *\/, 0\/* fstore_3 *\/,\n+        0\/* dstore_0 *\/, 0\/* dstore_1 *\/, 0\/* dstore_2 *\/, 0\/* dstore_3 *\/, 0\/* astore_0 *\/, 0\/* astore_1 *\/, 0\/* astore_2 *\/, 0\/* astore_3 *\/, 0\/* iastore *\/,\n+        0\/* lastore *\/, 0\/* fastore *\/, 0\/* dastore *\/, 0\/* aastore *\/, 0\/* bastore *\/, 0\/* castore *\/, 0\/* sastore *\/, 0\/* pop *\/, 0\/* pop2 *\/, 2\/* dup *\/,\n+        3\/* dup_x1 *\/, 4\/* dup_x2 *\/, 4\/* dup2 *\/, 5\/* dup2_x1 *\/, 6\/* dup2_x2 *\/, 2\/* swap *\/, 1\/* iadd *\/, 2\/* ladd *\/, 1\/* fadd *\/, 2\/* dadd *\/, 1\/* isub *\/,\n+        2\/* lsub *\/, 1\/* fsub *\/, 2\/* dsub *\/, 1\/* imul *\/, 2\/* lmul *\/, 1\/* fmul *\/, 2\/* dmul *\/, 1\/* idiv *\/, 2\/* ldiv *\/, 1\/* fdiv *\/, 2\/* ddiv *\/,\n+        1\/* irem *\/, 2\/* lrem *\/, 1\/* frem *\/, 2\/* drem *\/, 1\/* ineg *\/, 2\/* lneg *\/, 1\/* fneg *\/, 2\/* dneg *\/, 1\/* ishl *\/, 2\/* lshl *\/, 1\/* ishr *\/,\n+        2\/* lshr *\/, 1\/* iushr *\/, 2\/* lushr *\/, 1\/* iand *\/, 2\/* land *\/, 1\/* ior *\/, 2\/* lor *\/, 1\/* ixor *\/, 2\/* lxor *\/, 0\/* iinc *\/, 2\/* i2l *\/,\n+        1\/* i2f *\/, 2\/* i2d *\/, 1\/* l2i *\/, 1\/* l2f *\/, 2\/* l2d *\/, 1\/* f2i *\/, 2\/* f2l *\/, 2\/* f2d *\/, 1\/* d2i *\/, 2\/* d2l *\/, 1\/* d2f *\/, 1\/* i2b *\/,\n+        1\/* i2c *\/, 1\/* i2s *\/, 1\/* lcmp *\/, 1\/* fcmpl *\/, 1\/* fcmpg *\/, 1\/* dcmpl *\/, 1\/* dcmpg *\/, 0\/* ifeq *\/, 0\/* ifne *\/, 0\/* iflt *\/, 0\/* ifge *\/,\n+        0\/* ifgt *\/, 0\/* ifle *\/, 0\/* if_icmpeq *\/, 0\/* if_icmpne *\/, 0\/* if_icmplt *\/, 0\/* if_icmpge *\/, 0\/* if_icmpgt *\/, 0\/* if_icmple *\/, 0\/* if_acmpeq *\/,\n+        0\/* if_acmpne *\/, 0\/* goto *\/, 1\/* jsr *\/, 0\/* ret *\/, 0\/* tableswitch *\/, 0\/* lookupswitch *\/, 0\/* ireturn *\/, 0\/* lreturn *\/, 0\/* freturn *\/,\n+        0\/* dreturn *\/, 0\/* areturn *\/, 0\/* return *\/, UNPREDICTABLE\/* getstatic *\/, 0\/* putstatic *\/, UNPREDICTABLE\/* getfield *\/, 0\/* putfield *\/,\n+        UNPREDICTABLE\/* invokevirtual *\/, UNPREDICTABLE\/* invokespecial *\/, UNPREDICTABLE\/* invokestatic *\/, UNPREDICTABLE\/* invokeinterface *\/,\n+        UNPREDICTABLE\/* invokedynamic *\/, 1\/* new *\/, 1\/* newarray *\/, 1\/* anewarray *\/, 1\/* arraylength *\/, 1\/* athrow *\/, 1\/* checkcast *\/, 1\/* instanceof *\/,\n+        0\/* monitorenter *\/, 0\/* monitorexit *\/, 0\/* wide *\/, 1\/* multianewarray *\/, 0\/* ifnull *\/, 0\/* ifnonnull *\/, 0\/* goto_w *\/, 1\/* jsr_w *\/,\n+        0\/* breakpoint *\/, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+        UNPREDICTABLE\/* impdep1 *\/, UNPREDICTABLE\/* impdep2 *\/\n+    };\n+\n+    \/**\n+     * Attributes and their corresponding names.\n+     *\/\n+    public static final byte ATTR_UNKNOWN = -1;\n+\n+    public static final byte ATTR_SOURCE_FILE = 0;\n+\n+    public static final byte ATTR_CONSTANT_VALUE = 1;\n+\n+    public static final byte ATTR_CODE = 2;\n+\n+    public static final byte ATTR_EXCEPTIONS = 3;\n+\n+    public static final byte ATTR_LINE_NUMBER_TABLE = 4;\n+\n+    public static final byte ATTR_LOCAL_VARIABLE_TABLE = 5;\n+\n+    public static final byte ATTR_INNER_CLASSES = 6;\n+\n+    public static final byte ATTR_SYNTHETIC = 7;\n+\n+    public static final byte ATTR_DEPRECATED = 8;\n+\n+    public static final byte ATTR_PMG = 9;\n+\n+    public static final byte ATTR_SIGNATURE = 10;\n+\n+    public static final byte ATTR_STACK_MAP = 11;\n+    public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS = 12;\n+    public static final byte ATTR_RUNTIME_INVISIBLE_ANNOTATIONS = 13;\n+    public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = 14;\n+    public static final byte ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = 15;\n+    public static final byte ATTR_ANNOTATION_DEFAULT = 16;\n+    public static final byte ATTR_LOCAL_VARIABLE_TYPE_TABLE = 17;\n+    public static final byte ATTR_ENCLOSING_METHOD = 18;\n+    public static final byte ATTR_STACK_MAP_TABLE = 19;\n+    public static final byte ATTR_BOOTSTRAP_METHODS = 20;\n+    public static final byte ATTR_METHOD_PARAMETERS = 21;\n+    public static final byte ATTR_MODULE = 22;\n+    public static final byte ATTR_MODULE_PACKAGES = 23;\n+    public static final byte ATTR_MODULE_MAIN_CLASS = 24;\n+    public static final byte ATTR_NEST_HOST = 25;\n+    public static final byte ATTR_NEST_MEMBERS = 26;\n+    public static final short KNOWN_ATTRIBUTES = 27; \/\/ count of attributes\n+    private static final String[] ATTRIBUTE_NAMES = {\"SourceFile\", \"ConstantValue\", \"Code\", \"Exceptions\", \"LineNumberTable\", \"LocalVariableTable\",\n+        \"InnerClasses\", \"Synthetic\", \"Deprecated\", \"PMGClass\", \"Signature\", \"StackMap\", \"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\",\n+        \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", \"AnnotationDefault\", \"LocalVariableTypeTable\", \"EnclosingMethod\",\n+        \"StackMapTable\", \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\", \"ModuleMainClass\", \"NestHost\", \"NestMembers\"};\n+    \/**\n+     * Constants used in the StackMap attribute.\n+     *\/\n+    public static final byte ITEM_Bogus = 0;\n+    public static final byte ITEM_Integer = 1;\n+    public static final byte ITEM_Float = 2;\n+    public static final byte ITEM_Double = 3;\n+    public static final byte ITEM_Long = 4;\n+    public static final byte ITEM_Null = 5;\n+    public static final byte ITEM_InitObject = 6;\n+    public static final byte ITEM_Object = 7;\n+    public static final byte ITEM_NewObject = 8;\n+    private static final String[] ITEM_NAMES = {\"Bogus\", \"Integer\", \"Float\", \"Double\", \"Long\", \"Null\", \"InitObject\", \"Object\", \"NewObject\"};\n+\n+    \/**\n+     * Constants used to identify StackMapEntry types.\n+     *\n+     * For those types which can specify a range, the constant names the lowest value.\n+     *\/\n+    public static final int SAME_FRAME = 0;\n+\n+    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n+\n+    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n+\n+    public static final int CHOP_FRAME = 248;\n+    public static final int SAME_FRAME_EXTENDED = 251;\n+    public static final int APPEND_FRAME = 252;\n+    public static final int FULL_FRAME = 255;\n+    \/**\n+     * Constants that define the maximum value of those constants which store ranges.\n+     *\/\n+\n+    public static final int SAME_FRAME_MAX = 63;\n+    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX = 127;\n+    public static final int CHOP_FRAME_MAX = 250;\n+    public static final int APPEND_FRAME_MAX = 254;\n+    public static final byte REF_getField = 1;\n+\n+    public static final byte REF_getStatic = 2;\n+\n+    public static final byte REF_putField = 3;\n+\n+    public static final byte REF_putStatic = 4;\n+    public static final byte REF_invokeVirtual = 5;\n+    public static final byte REF_invokeStatic = 6;\n+    public static final byte REF_invokeSpecial = 7;\n+    public static final byte REF_newInvokeSpecial = 8;\n+    public static final byte REF_invokeInterface = 9;\n+    \/**\n+     * The names of the reference_kinds of a CONSTANT_MethodHandle_info.\n+     *\/\n+    private static final String[] METHODHANDLE_NAMES = {\"\", \"getField\", \"getStatic\", \"putField\", \"putStatic\", \"invokeVirtual\", \"invokeStatic\", \"invokeSpecial\",\n+        \"newInvokeSpecial\", \"invokeInterface\"};\n+\n+    \/**\n+     * @param index\n+     * @return the ACCESS_NAMES entry at the given index\n+     * @since 6.0\n+     *\/\n+    public static String getAccessName(final int index) {\n+        return ACCESS_NAMES[index];\n+    }\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return the attribute name\n+     * @since 6.0\n+     *\/\n+    public static String getAttributeName(final int index) {\n+        return ATTRIBUTE_NAMES[index];\n+    }\n+\n+    \/**\n+     * The primitive class names corresponding to the T_XX constants, e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n+     *\n+     * @param index\n+     * @return the class name\n+     * @since 6.0\n+     *\/\n+    public static String getClassTypeName(final int index) {\n+        return CLASS_TYPE_NAMES[index];\n+    }\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return the CONSTANT_NAMES entry at the given index\n+     * @since 6.0\n+     *\/\n+    public static String getConstantName(final int index) {\n+        return CONSTANT_NAMES[index];\n+    }\n+\n+    \/\/ Constants defining the behavior of the Method Handles (JVMS 5.4.3.5)\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return Number of words consumed on operand stack\n+     * @since 6.0\n+     *\/\n+    public static int getConsumeStack(final int index) {\n+        return CONSUME_STACK[index];\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public static Iterable<String> getInterfacesImplementedByArrays() {\n+        return Collections.unmodifiableList(Arrays.asList(INTERFACES_IMPLEMENTED_BY_ARRAYS));\n+    }\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return the item name\n+     * @since 6.0\n+     *\/\n+    public static String getItemName(final int index) {\n+        return ITEM_NAMES[index];\n+    }\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return the method handle name\n+     * @since 6.0\n+     *\/\n+    public static String getMethodHandleName(final int index) {\n+        return METHODHANDLE_NAMES[index];\n+    }\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return Number of byte code operands\n+     * @since 6.0\n+     *\/\n+    public static short getNoOfOperands(final int index) {\n+        return NO_OF_OPERANDS[index];\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public static String getOpcodeName(final int index) {\n+        return OPCODE_NAMES[index];\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public static short getOperandType(final int opcode, final int index) {\n+        return TYPE_OF_OPERANDS[opcode][index];\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public static long getOperandTypeCount(final int opcode) {\n+        return TYPE_OF_OPERANDS[opcode].length;\n+    }\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return Number of words produced onto operand stack\n+     * @since 6.0\n+     *\/\n+    public static int getProduceStack(final int index) {\n+        return PRODUCE_STACK[index];\n+    }\n+\n+    \/**\n+     *\n+     * @param index\n+     * @return the short type name\n+     * @since 6.0\n+     *\/\n+    public static String getShortTypeName(final int index) {\n+        return SHORT_TYPE_NAMES[index];\n+    }\n+\n+    \/**\n+     * The primitive type names corresponding to the T_XX constants, e.g., TYPE_NAMES[T_INT] = \"int\"\n+     *\n+     * @param index\n+     * @return the type name\n+     * @since 6.0\n+     *\/\n+    public static String getTypeName(final int index) {\n+        return TYPE_NAMES[index];\n+    }\n+\n+    private Const() {\n+    } \/\/ not instantiable\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Const.java","additions":3211,"deletions":2409,"binary":false,"changes":5620,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021 Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,2 @@\n+import jdk.xml.internal.Utils;\n+\n@@ -25,0 +27,1 @@\n+ *\n@@ -26,1 +29,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -30,0 +33,8 @@\n+    \/**\n+     * Enum corresponding to the various Exception Class arrays, used by\n+     * {@link ExceptionConst#createExceptions(EXCS, Class...)}\n+     *\/\n+    public enum EXCS {\n+        EXCS_CLASS_AND_INTERFACE_RESOLUTION, EXCS_FIELD_AND_METHOD_RESOLUTION, EXCS_INTERFACE_METHOD_RESOLUTION, EXCS_STRING_RESOLUTION, EXCS_ARRAY_EXCEPTION,\n+    }\n+\n@@ -67,2 +78,1 @@\n-    public static final Class<ArrayIndexOutOfBoundsException> ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION\n-                                                            = ArrayIndexOutOfBoundsException.class;\n+    public static final Class<ArrayIndexOutOfBoundsException> ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION = ArrayIndexOutOfBoundsException.class;\n@@ -72,0 +82,1 @@\n+\n@@ -73,0 +84,7 @@\n+    \/**\n+     * Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual Machine Specification\n+     *\/\n+    private static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = {NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR,\n+        EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR}; \/\/ Chapter 5.1\n+\n+    private static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = {NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR}; \/\/ Chapter 5.2\n@@ -75,2 +93,1 @@\n-     * Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual\n-     * Machine Specification\n+     * Empty array.\n@@ -78,7 +95,0 @@\n-    private static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = {\n-            NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR,\n-            EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR\n-    }; \/\/ Chapter 5.1\n-    private static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = {\n-            NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR\n-    }; \/\/ Chapter 5.2\n@@ -86,5 +96,0 @@\n-    private static final Class<?>[] EXCS_STRING_RESOLUTION = new Class<?>[0];\n-    \/\/ Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)\n-    private static final Class<?>[] EXCS_ARRAY_EXCEPTION = {\n-            NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION\n-    };\n@@ -93,2 +98,1 @@\n-     * Enum corresponding to the various Exception Class arrays,\n-     * used by {@link ExceptionConst#createExceptions(EXCS, Class...)}\n+     * Empty array.\n@@ -96,7 +100,1 @@\n-    public enum EXCS {\n-        EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n-        EXCS_FIELD_AND_METHOD_RESOLUTION,\n-        EXCS_INTERFACE_METHOD_RESOLUTION,\n-        EXCS_STRING_RESOLUTION,\n-        EXCS_ARRAY_EXCEPTION,\n-    }\n+    private static final Class<?>[] EXCS_STRING_RESOLUTION = new Class<?>[0];\n@@ -104,10 +102,2 @@\n-    \/\/ helper method to merge exception class arrays\n-    private static Class<?>[] mergeExceptions(final Class<?>[] input, final Class<?> ... extraClasses) {\n-        final int extraLen = extraClasses == null ? 0 : extraClasses.length;\n-        final Class<?>[] excs = new Class<?>[input.length + extraLen];\n-        System.arraycopy(input, 0, excs, 0, input.length);\n-        if (extraLen > 0) {\n-            System.arraycopy(extraClasses, 0, excs, input.length, extraLen);\n-        }\n-        return excs;\n-    }\n+    \/\/ Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)\n+    private static final Class<?>[] EXCS_ARRAY_EXCEPTION = {NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION};\n@@ -117,0 +107,1 @@\n+     *\n@@ -121,1 +112,1 @@\n-    public static Class<?>[] createExceptions(final EXCS type, final Class<?> ... extraClasses) {\n+    public static Class<?>[] createExceptions(final EXCS type, final Class<?>... extraClasses) {\n@@ -138,1 +129,4 @@\n-\n+    \/\/ helper method to merge exception class arrays\n+    private static Class<?>[] mergeExceptions(final Class<?>[] input, final Class<?>... extraClasses) {\n+        return Utils.arraysAppend(input, extraClasses);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/ExceptionConst.java","additions":33,"deletions":39,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,2 @@\n- * The repository maintains informations about class interdependencies, e.g.,\n- * whether a class is a sub-class of another. Delegates actual class loading\n- * to SyntheticRepository with current class path by default.\n+ * The repository maintains informations about class interdependencies, e.g., whether a class is a sub-class of another.\n+ * Delegates actual class loading to SyntheticRepository with current class path by default.\n@@ -34,1 +33,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Feb 2023\n@@ -38,3 +37,1 @@\n-    private static com.sun.org.apache.bcel.internal.util.Repository repository\n-            = SyntheticRepository.getInstance();\n-\n+    private static com.sun.org.apache.bcel.internal.util.Repository repository = SyntheticRepository.getInstance();\n@@ -43,1 +40,3 @@\n-     * @return currently used repository instance\n+     * Adds clazz to repository if there isn't an equally named class already in there.\n+     *\n+     * @return old entry in repository\n@@ -45,2 +44,4 @@\n-    public static com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n-        return repository;\n+    public static JavaClass addClass(final JavaClass clazz) {\n+        final JavaClass old = repository.findClass(clazz.getClassName());\n+        repository.storeClass(clazz);\n+        return old;\n@@ -49,1 +50,0 @@\n-\n@@ -51,1 +51,1 @@\n-     * Sets repository instance to be used for class loading\n+     * Clears the repository.\n@@ -53,2 +53,2 @@\n-    public static void setRepository( final com.sun.org.apache.bcel.internal.util.Repository rep ) {\n-        repository = rep;\n+    public static void clearCache() {\n+        repository.clear();\n@@ -57,1 +57,0 @@\n-\n@@ -59,6 +58,3 @@\n-     * Lookups class somewhere found on your CLASSPATH, or whereever the\n-     * repository instance looks for it.\n-     *\n-     * @return class object for given fully qualified class name\n-     * @throws ClassNotFoundException if the class could not be found or\n-     * parsed correctly\n+     * @return all interfaces implemented by class and its super classes and the interfaces that those interfaces extend,\n+     *         and so on. (Some people call this a transitive hull).\n+     * @throws ClassNotFoundException if any of the class's superclasses or superinterfaces can't be found\n@@ -66,2 +62,2 @@\n-    public static JavaClass lookupClass( final String class_name ) throws ClassNotFoundException {\n-        return repository.loadClass(class_name);\n+    public static JavaClass[] getInterfaces(final JavaClass clazz) throws ClassNotFoundException {\n+        return clazz.getAllInterfaces();\n@@ -70,1 +66,0 @@\n-\n@@ -72,6 +67,4 @@\n-     * Tries to find class source using the internal repository instance.\n-     *\n-     * @see Class\n-     * @return JavaClass object for given runtime class\n-     * @throws ClassNotFoundException if the class could not be found or\n-     * parsed correctly\n+     * @return all interfaces implemented by class and its super classes and the interfaces that extend those interfaces,\n+     *         and so on\n+     * @throws ClassNotFoundException if the named class can't be found, or if any of its superclasses or superinterfaces\n+     *         can't be found\n@@ -79,2 +72,2 @@\n-    public static JavaClass lookupClass( final Class<?> clazz ) throws ClassNotFoundException {\n-        return repository.loadClass(clazz);\n+    public static JavaClass[] getInterfaces(final String className) throws ClassNotFoundException {\n+        return getInterfaces(lookupClass(className));\n@@ -83,1 +76,0 @@\n-\n@@ -85,1 +77,1 @@\n-     * Clear the repository.\n+     * @return currently used repository instance\n@@ -87,2 +79,2 @@\n-    public static void clearCache() {\n-        repository.clear();\n+    public static com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n+        return repository;\n@@ -91,1 +83,0 @@\n-\n@@ -93,3 +84,2 @@\n-     * Adds clazz to repository if there isn't an equally named class already in there.\n-     *\n-     * @return old entry in repository\n+     * @return list of super classes of clazz in ascending order, i.e., Object is always the last element\n+     * @throws ClassNotFoundException if any of the superclasses can't be found\n@@ -97,4 +87,2 @@\n-    public static JavaClass addClass( final JavaClass clazz ) {\n-        final JavaClass old = repository.findClass(clazz.getClassName());\n-        repository.storeClass(clazz);\n-        return old;\n+    public static JavaClass[] getSuperClasses(final JavaClass clazz) throws ClassNotFoundException {\n+        return clazz.getSuperClasses();\n@@ -103,1 +91,0 @@\n-\n@@ -105,1 +92,2 @@\n-     * Removes class with given (fully qualified) name from repository.\n+     * @return list of super classes of clazz in ascending order, i.e., Object is always the last element.\n+     * @throws ClassNotFoundException if the named class or any of its superclasses can't be found\n@@ -107,2 +95,2 @@\n-    public static void removeClass( final String clazz ) {\n-        repository.removeClass(repository.findClass(clazz));\n+    public static JavaClass[] getSuperClasses(final String className) throws ClassNotFoundException {\n+        return getSuperClasses(lookupClass(className));\n@@ -111,1 +99,0 @@\n-\n@@ -113,1 +100,2 @@\n-     * Removes given class from repository.\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if any superclasses or superinterfaces of clazz can't be found\n@@ -115,2 +103,2 @@\n-    public static void removeClass( final JavaClass clazz ) {\n-        repository.removeClass(clazz);\n+    public static boolean implementationOf(final JavaClass clazz, final JavaClass inter) throws ClassNotFoundException {\n+        return clazz.implementationOf(inter);\n@@ -119,1 +107,0 @@\n-\n@@ -121,3 +108,2 @@\n-     * @return list of super classes of clazz in ascending order, i.e.,\n-     * Object is always the last element\n-     * @throws ClassNotFoundException if any of the superclasses can't be found\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if inter or any superclasses or superinterfaces of clazz can't be found\n@@ -125,2 +111,2 @@\n-    public static JavaClass[] getSuperClasses( final JavaClass clazz ) throws ClassNotFoundException {\n-        return clazz.getSuperClasses();\n+    public static boolean implementationOf(final JavaClass clazz, final String inter) throws ClassNotFoundException {\n+        return implementationOf(clazz, lookupClass(inter));\n@@ -129,1 +115,0 @@\n-\n@@ -131,4 +116,2 @@\n-     * @return list of super classes of clazz in ascending order, i.e.,\n-     * Object is always the last element.\n-     * @throws ClassNotFoundException if the named class or any of its\n-     *  superclasses can't be found\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if clazz or any superclasses or superinterfaces of clazz can't be found\n@@ -136,3 +119,2 @@\n-    public static JavaClass[] getSuperClasses( final String class_name ) throws ClassNotFoundException {\n-        final JavaClass jc = lookupClass(class_name);\n-        return getSuperClasses(jc);\n+    public static boolean implementationOf(final String clazz, final JavaClass inter) throws ClassNotFoundException {\n+        return implementationOf(lookupClass(clazz), inter);\n@@ -141,1 +123,0 @@\n-\n@@ -143,5 +124,2 @@\n-     * @return all interfaces implemented by class and its super\n-     * classes and the interfaces that those interfaces extend, and so on.\n-     * (Some people call this a transitive hull).\n-     * @throws ClassNotFoundException if any of the class's\n-     *  superclasses or superinterfaces can't be found\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if clazz, inter, or any superclasses or superinterfaces of clazz can't be found\n@@ -149,2 +127,2 @@\n-    public static JavaClass[] getInterfaces( final JavaClass clazz ) throws ClassNotFoundException {\n-        return clazz.getAllInterfaces();\n+    public static boolean implementationOf(final String clazz, final String inter) throws ClassNotFoundException {\n+        return implementationOf(lookupClass(clazz), lookupClass(inter));\n@@ -153,1 +131,0 @@\n-\n@@ -155,4 +132,4 @@\n-     * @return all interfaces implemented by class and its super\n-     * classes and the interfaces that extend those interfaces, and so on\n-     * @throws ClassNotFoundException if the named class can't be found,\n-     *   or if any of its superclasses or superinterfaces can't be found\n+     * Equivalent to runtime \"instanceof\" operator.\n+     *\n+     * @return true, if clazz is an instance of superclass\n+     * @throws ClassNotFoundException if any superclasses or superinterfaces of clazz can't be found\n@@ -160,2 +137,2 @@\n-    public static JavaClass[] getInterfaces( final String class_name ) throws ClassNotFoundException {\n-        return getInterfaces(lookupClass(class_name));\n+    public static boolean instanceOf(final JavaClass clazz, final JavaClass superclass) throws ClassNotFoundException {\n+        return clazz.instanceOf(superclass);\n@@ -164,1 +141,0 @@\n-\n@@ -166,4 +142,2 @@\n-     * Equivalent to runtime \"instanceof\" operator.\n-     * @return true, if clazz is an instance of super_class\n-     * @throws ClassNotFoundException if any superclasses or superinterfaces\n-     *   of clazz can't be found\n+     * @return true, if clazz is an instance of superclass\n+     * @throws ClassNotFoundException if superclass can't be found\n@@ -171,3 +145,2 @@\n-    public static boolean instanceOf( final JavaClass clazz, final JavaClass super_class )\n-            throws ClassNotFoundException {\n-        return clazz.instanceOf(super_class);\n+    public static boolean instanceOf(final JavaClass clazz, final String superclass) throws ClassNotFoundException {\n+        return instanceOf(clazz, lookupClass(superclass));\n@@ -176,1 +149,0 @@\n-\n@@ -178,3 +150,2 @@\n-     * @return true, if clazz is an instance of super_class\n-     * @throws ClassNotFoundException if either clazz or super_class\n-     *   can't be found\n+     * @return true, if clazz is an instance of superclass\n+     * @throws ClassNotFoundException if clazz can't be found\n@@ -182,3 +153,2 @@\n-    public static boolean instanceOf( final String clazz, final String super_class )\n-            throws ClassNotFoundException {\n-        return instanceOf(lookupClass(clazz), lookupClass(super_class));\n+    public static boolean instanceOf(final String clazz, final JavaClass superclass) throws ClassNotFoundException {\n+        return instanceOf(lookupClass(clazz), superclass);\n@@ -187,1 +157,0 @@\n-\n@@ -189,2 +158,2 @@\n-     * @return true, if clazz is an instance of super_class\n-     * @throws ClassNotFoundException if super_class can't be found\n+     * @return true, if clazz is an instance of superclass\n+     * @throws ClassNotFoundException if either clazz or superclass can't be found\n@@ -192,3 +161,2 @@\n-    public static boolean instanceOf( final JavaClass clazz, final String super_class )\n-            throws ClassNotFoundException {\n-        return instanceOf(clazz, lookupClass(super_class));\n+    public static boolean instanceOf(final String clazz, final String superclass) throws ClassNotFoundException {\n+        return instanceOf(lookupClass(clazz), lookupClass(superclass));\n@@ -197,1 +165,0 @@\n-\n@@ -199,2 +166,5 @@\n-     * @return true, if clazz is an instance of super_class\n-     * @throws ClassNotFoundException if clazz can't be found\n+     * Tries to find class source using the internal repository instance.\n+     *\n+     * @see Class\n+     * @return JavaClass object for given runtime class\n+     * @throws ClassNotFoundException if the class could not be found or parsed correctly\n@@ -202,3 +172,2 @@\n-    public static boolean instanceOf( final String clazz, final JavaClass super_class )\n-            throws ClassNotFoundException {\n-        return instanceOf(lookupClass(clazz), super_class);\n+    public static JavaClass lookupClass(final Class<?> clazz) throws ClassNotFoundException {\n+        return repository.loadClass(clazz);\n@@ -207,1 +176,0 @@\n-\n@@ -209,3 +177,4 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if any superclasses or superinterfaces\n-     *   of clazz can't be found\n+     * Lookups class somewhere found on your CLASSPATH, or wherever the repository instance looks for it.\n+     *\n+     * @return class object for given fully qualified class name\n+     * @throws ClassNotFoundException if the class could not be found or parsed correctly\n@@ -213,3 +182,2 @@\n-    public static boolean implementationOf( final JavaClass clazz, final JavaClass inter )\n-            throws ClassNotFoundException {\n-        return clazz.implementationOf(inter);\n+    public static JavaClass lookupClass(final String className) throws ClassNotFoundException {\n+        return repository.loadClass(className);\n@@ -218,1 +186,0 @@\n-\n@@ -220,3 +187,1 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if clazz, inter, or any superclasses\n-     *   or superinterfaces of clazz can't be found\n+     * Removes given class from repository.\n@@ -224,3 +189,2 @@\n-    public static boolean implementationOf( final String clazz, final String inter )\n-            throws ClassNotFoundException {\n-        return implementationOf(lookupClass(clazz), lookupClass(inter));\n+    public static void removeClass(final JavaClass clazz) {\n+        repository.removeClass(clazz);\n@@ -229,1 +193,0 @@\n-\n@@ -231,3 +194,1 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if inter or any superclasses\n-     *   or superinterfaces of clazz can't be found\n+     * Removes class with given (fully qualified) name from repository.\n@@ -235,3 +196,2 @@\n-    public static boolean implementationOf( final JavaClass clazz, final String inter )\n-            throws ClassNotFoundException {\n-        return implementationOf(clazz, lookupClass(inter));\n+    public static void removeClass(final String clazz) {\n+        repository.removeClass(repository.findClass(clazz));\n@@ -240,1 +200,0 @@\n-\n@@ -242,3 +201,1 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if clazz or any superclasses or\n-     *   superinterfaces of clazz can't be found\n+     * Sets repository instance to be used for class loading\n@@ -246,3 +203,2 @@\n-    public static boolean implementationOf( final String clazz, final JavaClass inter )\n-            throws ClassNotFoundException {\n-        return implementationOf(lookupClass(clazz), inter);\n+    public static void setRepository(final com.sun.org.apache.bcel.internal.util.Repository rep) {\n+        repository = rep;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Repository.java","additions":93,"deletions":137,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -32,1 +32,5 @@\n-    private int access_flags;\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected int access_flags; \/\/ TODO not used externally at present\n@@ -38,2 +42,1 @@\n-     * @param a\n-     *            inital access flags\n+     * @param a initial access flags\n@@ -59,38 +62,2 @@\n-    \/**\n-     * Set access flags aka \"modifiers\".\n-     *\n-     * @param access_flags\n-     *            Access flags of the object.\n-     *\/\n-    public final void setAccessFlags(final int access_flags) {\n-        this.access_flags = access_flags;\n-    }\n-\n-    \/**\n-     * Set access flags aka \"modifiers\".\n-     *\n-     * @param access_flags\n-     *            Access flags of the object.\n-     *\/\n-    public final void setModifiers(final int access_flags) {\n-        setAccessFlags(access_flags);\n-    }\n-\n-    private void setFlag(final int flag, final boolean set) {\n-        if ((access_flags & flag) != 0) { \/\/ Flag is set already\n-            if (!set) {\n-                access_flags ^= flag;\n-            }\n-        } else { \/\/ Flag not set\n-            if (set) {\n-                access_flags |= flag;\n-            }\n-        }\n-    }\n-\n-    public final void isPublic(final boolean flag) {\n-        setFlag(Const.ACC_PUBLIC, flag);\n-    }\n-\n-    public final boolean isPublic() {\n-        return (access_flags & Const.ACC_PUBLIC) != 0;\n+    public final boolean isAbstract() {\n+        return (access_flags & Const.ACC_ABSTRACT) != 0;\n@@ -99,2 +66,2 @@\n-    public final void isPrivate(final boolean flag) {\n-        setFlag(Const.ACC_PRIVATE, flag);\n+    public final void isAbstract(final boolean flag) {\n+        setFlag(Const.ACC_ABSTRACT, flag);\n@@ -103,2 +70,2 @@\n-    public final boolean isPrivate() {\n-        return (access_flags & Const.ACC_PRIVATE) != 0;\n+    public final boolean isAnnotation() {\n+        return (access_flags & Const.ACC_ANNOTATION) != 0;\n@@ -107,2 +74,2 @@\n-    public final void isProtected(final boolean flag) {\n-        setFlag(Const.ACC_PROTECTED, flag);\n+    public final void isAnnotation(final boolean flag) {\n+        setFlag(Const.ACC_ANNOTATION, flag);\n@@ -111,2 +78,2 @@\n-    public final boolean isProtected() {\n-        return (access_flags & Const.ACC_PROTECTED) != 0;\n+    public final boolean isEnum() {\n+        return (access_flags & Const.ACC_ENUM) != 0;\n@@ -115,2 +82,2 @@\n-    public final void isStatic(final boolean flag) {\n-        setFlag(Const.ACC_STATIC, flag);\n+    public final void isEnum(final boolean flag) {\n+        setFlag(Const.ACC_ENUM, flag);\n@@ -119,2 +86,2 @@\n-    public final boolean isStatic() {\n-        return (access_flags & Const.ACC_STATIC) != 0;\n+    public final boolean isFinal() {\n+        return (access_flags & Const.ACC_FINAL) != 0;\n@@ -127,2 +94,2 @@\n-    public final boolean isFinal() {\n-        return (access_flags & Const.ACC_FINAL) != 0;\n+    public final boolean isInterface() {\n+        return (access_flags & Const.ACC_INTERFACE) != 0;\n@@ -131,2 +98,2 @@\n-    public final void isSynchronized(final boolean flag) {\n-        setFlag(Const.ACC_SYNCHRONIZED, flag);\n+    public final void isInterface(final boolean flag) {\n+        setFlag(Const.ACC_INTERFACE, flag);\n@@ -135,2 +102,2 @@\n-    public final boolean isSynchronized() {\n-        return (access_flags & Const.ACC_SYNCHRONIZED) != 0;\n+    public final boolean isNative() {\n+        return (access_flags & Const.ACC_NATIVE) != 0;\n@@ -139,2 +106,2 @@\n-    public final void isVolatile(final boolean flag) {\n-        setFlag(Const.ACC_VOLATILE, flag);\n+    public final void isNative(final boolean flag) {\n+        setFlag(Const.ACC_NATIVE, flag);\n@@ -143,2 +110,2 @@\n-    public final boolean isVolatile() {\n-        return (access_flags & Const.ACC_VOLATILE) != 0;\n+    public final boolean isPrivate() {\n+        return (access_flags & Const.ACC_PRIVATE) != 0;\n@@ -147,2 +114,2 @@\n-    public final void isTransient(final boolean flag) {\n-        setFlag(Const.ACC_TRANSIENT, flag);\n+    public final void isPrivate(final boolean flag) {\n+        setFlag(Const.ACC_PRIVATE, flag);\n@@ -151,2 +118,2 @@\n-    public final boolean isTransient() {\n-        return (access_flags & Const.ACC_TRANSIENT) != 0;\n+    public final boolean isProtected() {\n+        return (access_flags & Const.ACC_PROTECTED) != 0;\n@@ -155,2 +122,2 @@\n-    public final void isNative(final boolean flag) {\n-        setFlag(Const.ACC_NATIVE, flag);\n+    public final void isProtected(final boolean flag) {\n+        setFlag(Const.ACC_PROTECTED, flag);\n@@ -159,2 +126,2 @@\n-    public final boolean isNative() {\n-        return (access_flags & Const.ACC_NATIVE) != 0;\n+    public final boolean isPublic() {\n+        return (access_flags & Const.ACC_PUBLIC) != 0;\n@@ -163,2 +130,2 @@\n-    public final void isInterface(final boolean flag) {\n-        setFlag(Const.ACC_INTERFACE, flag);\n+    public final void isPublic(final boolean flag) {\n+        setFlag(Const.ACC_PUBLIC, flag);\n@@ -167,2 +134,2 @@\n-    public final boolean isInterface() {\n-        return (access_flags & Const.ACC_INTERFACE) != 0;\n+    public final boolean isStatic() {\n+        return (access_flags & Const.ACC_STATIC) != 0;\n@@ -171,2 +138,2 @@\n-    public final void isAbstract(final boolean flag) {\n-        setFlag(Const.ACC_ABSTRACT, flag);\n+    public final void isStatic(final boolean flag) {\n+        setFlag(Const.ACC_STATIC, flag);\n@@ -175,2 +142,2 @@\n-    public final boolean isAbstract() {\n-        return (access_flags & Const.ACC_ABSTRACT) != 0;\n+    public final boolean isStrictfp() {\n+        return (access_flags & Const.ACC_STRICT) != 0;\n@@ -183,2 +150,2 @@\n-    public final boolean isStrictfp() {\n-        return (access_flags & Const.ACC_STRICT) != 0;\n+    public final boolean isSynchronized() {\n+        return (access_flags & Const.ACC_SYNCHRONIZED) != 0;\n@@ -187,2 +154,2 @@\n-    public final void isSynthetic(final boolean flag) {\n-        setFlag(Const.ACC_SYNTHETIC, flag);\n+    public final void isSynchronized(final boolean flag) {\n+        setFlag(Const.ACC_SYNCHRONIZED, flag);\n@@ -195,2 +162,2 @@\n-    public final void isAnnotation(final boolean flag) {\n-        setFlag(Const.ACC_ANNOTATION, flag);\n+    public final void isSynthetic(final boolean flag) {\n+        setFlag(Const.ACC_SYNTHETIC, flag);\n@@ -199,2 +166,2 @@\n-    public final boolean isAnnotation() {\n-        return (access_flags & Const.ACC_ANNOTATION) != 0;\n+    public final boolean isTransient() {\n+        return (access_flags & Const.ACC_TRANSIENT) != 0;\n@@ -203,2 +170,2 @@\n-    public final void isEnum(final boolean flag) {\n-        setFlag(Const.ACC_ENUM, flag);\n+    public final void isTransient(final boolean flag) {\n+        setFlag(Const.ACC_TRANSIENT, flag);\n@@ -207,2 +174,2 @@\n-    public final boolean isEnum() {\n-        return (access_flags & Const.ACC_ENUM) != 0;\n+    public final boolean isVarArgs() {\n+        return (access_flags & Const.ACC_VARARGS) != 0;\n@@ -215,2 +182,34 @@\n-    public final boolean isVarArgs() {\n-        return (access_flags & Const.ACC_VARARGS) != 0;\n+    public final boolean isVolatile() {\n+        return (access_flags & Const.ACC_VOLATILE) != 0;\n+    }\n+\n+    public final void isVolatile(final boolean flag) {\n+        setFlag(Const.ACC_VOLATILE, flag);\n+    }\n+\n+    \/**\n+     * Set access flags aka \"modifiers\".\n+     *\n+     * @param accessFlags Access flags of the object.\n+     *\/\n+    public final void setAccessFlags(final int accessFlags) {\n+        this.access_flags = accessFlags;\n+    }\n+\n+    private void setFlag(final int flag, final boolean set) {\n+        if ((access_flags & flag) != 0) { \/\/ Flag is set already\n+            if (!set) {\n+                access_flags ^= flag;\n+            }\n+        } else if (set) {\n+            access_flags |= flag;\n+        }\n+    }\n+\n+    \/**\n+     * Set access flags aka \"modifiers\".\n+     *\n+     * @param accessFlags Access flags of the object.\n+     *\/\n+    public final void setModifiers(final int accessFlags) {\n+        setAccessFlags(accessFlags);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AccessFlags.java","additions":92,"deletions":93,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * Represents the default value of a annotation for a method info\n+ * Represents the default value of a annotation for a method info.\n@@ -40,4 +40,4 @@\n-     * @param name_index    Index pointing to the name <em>Code<\/em>\n-     * @param length        Content length in bytes\n-     * @param input         Input stream\n-     * @param constant_pool Array of constants\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n@@ -45,3 +45,3 @@\n-    AnnotationDefault(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        this(name_index, length, (ElementValue) null, constant_pool);\n-        defaultValue = ElementValue.readElementValue(input, constant_pool);\n+    AnnotationDefault(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (ElementValue) null, constantPool);\n+        defaultValue = ElementValue.readElementValue(input, constantPool);\n@@ -51,4 +51,4 @@\n-     * @param name_index    Index pointing to the name <em>Code<\/em>\n-     * @param length        Content length in bytes\n-     * @param defaultValue  the annotation's default value\n-     * @param constant_pool Array of constants\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param defaultValue the annotation's default value\n+     * @param constantPool Array of constants\n@@ -56,2 +56,2 @@\n-    public AnnotationDefault(final int name_index, final int length, final ElementValue defaultValue, final ConstantPool constant_pool) {\n-        super(Const.ATTR_ANNOTATION_DEFAULT, name_index, length, constant_pool);\n+    public AnnotationDefault(final int nameIndex, final int length, final ElementValue defaultValue, final ConstantPool constantPool) {\n+        super(Const.ATTR_ANNOTATION_DEFAULT, nameIndex, length, constantPool);\n@@ -62,3 +62,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -73,5 +72,9 @@\n-    \/**\n-     * @param defaultValue the default value of this methodinfo's annotation\n-     *\/\n-    public final void setDefaultValue(final ElementValue defaultValue) {\n-        this.defaultValue = defaultValue;\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        return (Attribute) clone();\n+    }\n+\n+    @Override\n+    public final void dump(final DataOutputStream dos) throws IOException {\n+        super.dump(dos);\n+        defaultValue.dump(dos);\n@@ -87,9 +90,5 @@\n-    @Override\n-    public Attribute copy(final ConstantPool _constant_pool) {\n-        return (Attribute) clone();\n-    }\n-\n-    @Override\n-    public final void dump(final DataOutputStream dos) throws IOException {\n-        super.dump(dos);\n-        defaultValue.dump(dos);\n+    \/**\n+     * @param defaultValue the default value of this methodinfo's annotation\n+     *\/\n+    public final void setDefaultValue(final ElementValue defaultValue) {\n+        this.defaultValue = defaultValue;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationDefault.java","additions":30,"deletions":31,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,38 +30,8 @@\n-public class AnnotationElementValue extends ElementValue\n-{\n-        \/\/ For annotation element values, this is the annotation\n-        private final AnnotationEntry annotationEntry;\n-\n-        public AnnotationElementValue(final int type, final AnnotationEntry annotationEntry,\n-                        final ConstantPool cpool)\n-        {\n-                super(type, cpool);\n-                if (type != ANNOTATION) {\n-                    throw new IllegalArgumentException(\n-                                    \"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n-                }\n-                this.annotationEntry = annotationEntry;\n-        }\n-\n-        @Override\n-        public void dump(final DataOutputStream dos) throws IOException\n-        {\n-                dos.writeByte(super.getType()); \/\/ u1 type of value (ANNOTATION == '@')\n-                annotationEntry.dump(dos);\n-        }\n-\n-        @Override\n-        public String stringifyValue()\n-        {\n-                return annotationEntry.toString();\n-        }\n-\n-        @Override\n-        public String toString()\n-        {\n-                return stringifyValue();\n-        }\n-\n-        public AnnotationEntry getAnnotationEntry()\n-        {\n-                return annotationEntry;\n+public class AnnotationElementValue extends ElementValue {\n+    \/\/ For annotation element values, this is the annotation\n+    private final AnnotationEntry annotationEntry;\n+\n+    public AnnotationElementValue(final int type, final AnnotationEntry annotationEntry, final ConstantPool cpool) {\n+        super(type, cpool);\n+        if (type != ANNOTATION) {\n+            throw new ClassFormatException(\"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n@@ -69,0 +39,22 @@\n+        this.annotationEntry = annotationEntry;\n+    }\n+\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeByte(super.getType()); \/\/ u1 type of value (ANNOTATION == '@')\n+        annotationEntry.dump(dos);\n+    }\n+\n+    public AnnotationEntry getAnnotationEntry() {\n+        return annotationEntry;\n+    }\n+\n+    @Override\n+    public String stringifyValue() {\n+        return annotationEntry.toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return stringifyValue();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationElementValue.java","additions":30,"deletions":38,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.Collections;\n@@ -30,2 +29,1 @@\n-\n-import com.sun.org.apache.bcel.internal.Const;\n+import java.util.stream.Stream;\n@@ -34,1 +32,1 @@\n- * represents one annotation in the annotation table\n+ * Represents one annotation in the annotation table\n@@ -40,3 +38,1 @@\n-    private final int typeIndex;\n-    private final ConstantPool constantPool;\n-    private final boolean isRuntimeVisible;\n+    public static final AnnotationEntry[] EMPTY_ARRAY = {};\n@@ -44,1 +40,5 @@\n-    private List<ElementValuePair> elementValuePairs;\n+    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {\n+        \/\/ Find attributes that contain annotation data\n+        return Stream.of(attrs).filter(Annotations.class::isInstance).flatMap(e -> Stream.of(((Annotations) e).getAnnotationEntries()))\n+            .toArray(AnnotationEntry[]::new);\n+    }\n@@ -46,1 +46,1 @@\n-    \/*\n+    \/**\n@@ -53,1 +53,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -55,4 +55,3 @@\n-    public static AnnotationEntry read(final DataInput input, final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {\n-\n-        final AnnotationEntry annotationEntry = new AnnotationEntry(input.readUnsignedShort(), constant_pool, isRuntimeVisible);\n-        final int num_element_value_pairs = input.readUnsignedShort();\n+    public static AnnotationEntry read(final DataInput input, final ConstantPool constantPool, final boolean isRuntimeVisible) throws IOException {\n+        final AnnotationEntry annotationEntry = new AnnotationEntry(input.readUnsignedShort(), constantPool, isRuntimeVisible);\n+        final int numElementValuePairs = input.readUnsignedShort();\n@@ -60,4 +59,3 @@\n-        for (int i = 0; i < num_element_value_pairs; i++) {\n-            annotationEntry.elementValuePairs.add(\n-                    new ElementValuePair(input.readUnsignedShort(), ElementValue.readElementValue(input, constant_pool),\n-                    constant_pool));\n+        for (int i = 0; i < numElementValuePairs; i++) {\n+            annotationEntry.elementValuePairs\n+                .add(new ElementValuePair(input.readUnsignedShort(), ElementValue.readElementValue(input, constantPool), constantPool));\n@@ -68,5 +66,1 @@\n-    public AnnotationEntry(final int type_index, final ConstantPool constant_pool, final boolean isRuntimeVisible) {\n-        this.typeIndex = type_index;\n-        this.constantPool = constant_pool;\n-        this.isRuntimeVisible = isRuntimeVisible;\n-    }\n+    private final int typeIndex;\n@@ -74,3 +68,1 @@\n-    public int getTypeIndex() {\n-        return typeIndex;\n-    }\n+    private final ConstantPool constantPool;\n@@ -78,3 +70,1 @@\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n-    }\n+    private final boolean isRuntimeVisible;\n@@ -82,2 +72,6 @@\n-    public boolean isRuntimeVisible() {\n-        return isRuntimeVisible;\n+    private List<ElementValuePair> elementValuePairs;\n+\n+    public AnnotationEntry(final int typeIndex, final ConstantPool constantPool, final boolean isRuntimeVisible) {\n+        this.typeIndex = typeIndex;\n+        this.constantPool = constantPool;\n+        this.isRuntimeVisible = isRuntimeVisible;\n@@ -87,1 +81,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n@@ -97,0 +91,13 @@\n+    public void addElementNameValuePair(final ElementValuePair elementNameValuePair) {\n+        elementValuePairs.add(elementNameValuePair);\n+    }\n+\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n+        dos.writeShort(elementValuePairs.size()); \/\/ u2 element_value pair\n+        \/\/ count\n+        for (final ElementValuePair envp : elementValuePairs) {\n+            envp.dump(dos);\n+        }\n+    }\n+\n@@ -101,2 +108,1 @@\n-        final ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(typeIndex, Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+        return constantPool.getConstantUtf8(typeIndex).getBytes();\n@@ -112,5 +118,2 @@\n-    \/**\n-     * @return the number of element value pairs in this annotation entry\n-     *\/\n-    public final int getNumElementValuePairs() {\n-        return elementValuePairs.size();\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n@@ -124,1 +127,1 @@\n-        return elementValuePairs.toArray(new ElementValuePair[elementValuePairs.size()]);\n+        return elementValuePairs.toArray(ElementValuePair.EMPTY_ARRAY);\n@@ -127,7 +130,5 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n-        dos.writeShort(elementValuePairs.size()); \/\/ u2 element_value pair\n-        \/\/ count\n-        for (final ElementValuePair envp : elementValuePairs) {\n-            envp.dump(dos);\n-        }\n+    \/**\n+     * @return the number of element value pairs in this annotation entry\n+     *\/\n+    public final int getNumElementValuePairs() {\n+        return elementValuePairs.size();\n@@ -136,2 +137,6 @@\n-    public void addElementNameValuePair(final ElementValuePair elementNameValuePair) {\n-        elementValuePairs.add(elementNameValuePair);\n+    public int getTypeIndex() {\n+        return typeIndex;\n+    }\n+\n+    public boolean isRuntimeVisible() {\n+        return isRuntimeVisible;\n@@ -149,0 +154,1 @@\n+                result.append(\", \");\n@@ -150,0 +156,2 @@\n+            \/\/ remove last \", \"\n+            result.setLength(result.length() - 2);\n@@ -159,12 +167,0 @@\n-\n-    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {\n-        \/\/ Find attributes that contain annotation data\n-        final List<AnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n-        for (final Attribute attribute : attrs) {\n-            if (attribute instanceof Annotations) {\n-                final Annotations runtimeAnnotations = (Annotations) attribute;\n-                Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getAnnotationEntries());\n-            }\n-        }\n-        return accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationEntry.java","additions":57,"deletions":61,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -27,0 +27,4 @@\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -33,1 +37,1 @@\n-public abstract class Annotations extends Attribute {\n+public abstract class Annotations extends Attribute implements Iterable<AnnotationEntry> {\n@@ -39,22 +43,8 @@\n-     * @param annotation_type the subclass type of the annotation\n-     * @param name_index Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     *\/\n-    Annotations(final byte annotation_type, final int name_index, final int length, final DataInput input,\n-            final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {\n-        this(annotation_type, name_index, length, (AnnotationEntry[]) null, constant_pool, isRuntimeVisible);\n-        final int annotation_table_length = input.readUnsignedShort();\n-        annotationTable = new AnnotationEntry[annotation_table_length];\n-        for (int i = 0; i < annotation_table_length; i++) {\n-            annotationTable[i] = AnnotationEntry.read(input, constant_pool, isRuntimeVisible);\n-        }\n-    }\n-\n-    \/**\n-     * @param annotationType the subclass type of the annotation\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param annotationTable the actual annotations\n-     * @param constantPool Array of constants\n+     * Constructs an instance.\n+     *\n+     * @param annotationType   the subclass type of the annotation\n+     * @param nameIndex        Index pointing to the name <em>Code<\/em>\n+     * @param length           Content length in bytes\n+     * @param annotationTable  the actual annotations\n+     * @param constantPool     Array of constants\n+     * @param isRuntimeVisible whether this Annotation visible at runtime\n@@ -70,2 +60,24 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Constructs an instance.\n+     *\n+     * @param annotationType   the subclass type of the annotation\n+     * @param nameIndex        Index pointing to the name <em>Code<\/em>\n+     * @param length           Content length in bytes\n+     * @param input            Input stream\n+     * @param constantPool     Array of constants\n+     * @param isRuntimeVisible whether this Annotation visible at runtime\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    Annotations(final byte annotationType, final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool,\n+            final boolean isRuntimeVisible) throws IOException {\n+        this(annotationType, nameIndex, length, (AnnotationEntry[]) null, constantPool, isRuntimeVisible);\n+        final int annotationTableLength = input.readUnsignedShort();\n+        annotationTable = new AnnotationEntry[annotationTableLength];\n+        for (int i = 0; i < annotationTableLength; i++) {\n+            annotationTable[i] = AnnotationEntry.read(input, constantPool, isRuntimeVisible);\n+        }\n+    }\n+\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -80,5 +92,4 @@\n-    \/**\n-     * @param annotationTable the entries to set in this annotation\n-     *\/\n-    public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {\n-        this.annotationTable = annotationTable;\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        \/\/ TODO Auto-generated method stub\n+        return null;\n@@ -88,1 +99,1 @@\n-     * returns the array of annotation entries in this annotation\n+     * Gets the array of annotation entries in this annotation\n@@ -95,0 +106,2 @@\n+     * Gets the number of annotation entries in this annotation.\n+     *\n@@ -108,0 +121,32 @@\n+    @Override\n+    public Iterator<AnnotationEntry> iterator() {\n+        return Stream.of(annotationTable).iterator();\n+    }\n+\n+    \/**\n+     * Sets the entries to set in this annotation.\n+     *\n+     * @param annotationTable the entries to set in this annotation\n+     *\/\n+    public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {\n+        this.annotationTable = annotationTable;\n+    }\n+\n+    \/**\n+     * Converts to a String representation.\n+     *\n+     * @return String representation\n+     *\/\n+    @Override\n+    public final String toString() {\n+        final StringBuilder buf = new StringBuilder(Const.getAttributeName(getTag()));\n+        buf.append(\":\\n\");\n+        for (int i = 0; i < annotationTable.length; i++) {\n+            buf.append(\"  \").append(annotationTable[i]);\n+            if (i < annotationTable.length - 1) {\n+                buf.append('\\n');\n+            }\n+        }\n+        return buf.toString();\n+    }\n+\n@@ -117,0 +162,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Annotations.java","additions":77,"deletions":31,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n-public class ArrayElementValue extends ElementValue\n-{\n+public class ArrayElementValue extends ElementValue {\n@@ -35,18 +34,1 @@\n-    @Override\n-    public String toString()\n-    {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"{\");\n-        for (int i = 0; i < elementValues.length; i++)\n-        {\n-            sb.append(elementValues[i]);\n-            if ((i + 1) < elementValues.length) {\n-                sb.append(\",\");\n-            }\n-        }\n-        sb.append(\"}\");\n-        return sb.toString();\n-    }\n-\n-    public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool)\n-    {\n+    public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {\n@@ -55,2 +37,1 @@\n-            throw new IllegalArgumentException(\n-                    \"Only element values of type array can be built with this ctor - type specified: \" + type);\n+            throw new ClassFormatException(\"Only element values of type array can be built with this ctor - type specified: \" + type);\n@@ -62,2 +43,1 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n+    public void dump(final DataOutputStream dos) throws IOException {\n@@ -71,0 +51,8 @@\n+    public ElementValue[] getElementValuesArray() {\n+        return elementValues;\n+    }\n+\n+    public int getElementValuesArraySize() {\n+        return elementValues.length;\n+    }\n+\n@@ -72,2 +60,1 @@\n-    public String stringifyValue()\n-    {\n+    public String stringifyValue() {\n@@ -76,2 +63,1 @@\n-        for (int i = 0; i < elementValues.length; i++)\n-        {\n+        for (int i = 0; i < elementValues.length; i++) {\n@@ -79,1 +65,1 @@\n-            if ((i + 1) < elementValues.length) {\n+            if (i + 1 < elementValues.length) {\n@@ -87,8 +73,12 @@\n-    public ElementValue[] getElementValuesArray()\n-    {\n-        return elementValues;\n-    }\n-\n-    public int getElementValuesArraySize()\n-    {\n-        return elementValues.length;\n+    @Override\n+    public String toString() {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"{\");\n+        for (int i = 0; i < elementValues.length; i++) {\n+            sb.append(elementValues[i]);\n+            if (i + 1 < elementValues.length) {\n+                sb.append(\",\");\n+            }\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ArrayElementValue.java","additions":27,"deletions":37,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,6 +33,11 @@\n- * Abstract super class for <em>Attribute<\/em> objects. Currently the\n- * <em>ConstantValue<\/em>, <em>SourceFile<\/em>, <em>Code<\/em>,\n- * <em>Exceptiontable<\/em>, <em>LineNumberTable<\/em>,\n- * <em>LocalVariableTable<\/em>, <em>InnerClasses<\/em> and\n- * <em>Synthetic<\/em> attributes are supported. The <em>Unknown<\/em>\n- * attribute stands for non-standard-attributes.\n+ * Abstract super class for <em>Attribute<\/em> objects. Currently the <em>ConstantValue<\/em>, <em>SourceFile<\/em>, <em>Code<\/em>, <em>Exceptiontable<\/em>,\n+ * <em>LineNumberTable<\/em>, <em>LocalVariableTable<\/em>, <em>InnerClasses<\/em> and <em>Synthetic<\/em> attributes are supported. The <em>Unknown<\/em> attribute\n+ * stands for non-standard-attributes.\n+ *\n+ * <pre>\n+ * attribute_info {\n+ *   u2 attribute_name_index;\n+ *   u4 attribute_length;\n+ *   u1 info[attribute_length];\n+ * }\n+ * <\/pre>\n@@ -50,1 +56,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -54,4 +60,0 @@\n-    private int name_index; \/\/ Points to attribute name in constant pool\n-    private int length; \/\/ Content length of attribute field\n-    private final byte tag; \/\/ Tag to distinguish subclasses\n-    private ConstantPool constant_pool;\n@@ -59,1 +61,8 @@\n-    private static final Map<String, Object> readers = new HashMap<>();\n+    private static final Map<String, Object> READERS = new HashMap<>();\n+\n+    \/**\n+     * Empty array.\n+     *\n+     * @since 6.6.0\n+     *\/\n+    public static final Attribute[] EMPTY_ARRAY = {};\n@@ -62,3 +71,2 @@\n-     * Add an Attribute reader capable of parsing (user-defined) attributes\n-     * named \"name\". You should not add readers for the standard attributes such\n-     * as \"LineNumberTable\", because those are handled internally.\n+     * Add an Attribute reader capable of parsing (user-defined) attributes named \"name\". You should not add readers for the\n+     * standard attributes such as \"LineNumberTable\", because those are handled internally.\n@@ -67,1 +75,1 @@\n-     * @param r    the reader object\n+     * @param unknownAttributeReader the reader object\n@@ -69,3 +77,2 @@\n-    public static void addAttributeReader(final String name, final UnknownAttributeReader r)\n-    {\n-        readers.put(name, r);\n+    public static void addAttributeReader(final String name, final UnknownAttributeReader unknownAttributeReader) {\n+        READERS.put(name, unknownAttributeReader);\n@@ -81,3 +88,2 @@\n-     * Class method reads one attribute from the input data stream. This method\n-     * must not be accessible from the outside. It is called by the Field and\n-     * Method constructor methods.\n+     * Class method reads one attribute from the input data stream. This method must not be accessible from the outside. It\n+     * is called by the Field and Method constructor methods.\n@@ -88,2 +94,2 @@\n-     * @param file Input stream\n-     * @param constant_pool Array of constants\n+     * @param dataInput Input stream\n+     * @param constantPool Array of constants\n@@ -91,2 +97,1 @@\n-     * @throws IOException\n-     * @throws ClassFormatException\n+     * @throws IOException if an I\/O error occurs.\n@@ -95,3 +100,1 @@\n-    public static Attribute readAttribute(final DataInput file, final ConstantPool constant_pool)\n-            throws IOException, ClassFormatException\n-    {\n+    public static Attribute readAttribute(final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n@@ -99,4 +102,3 @@\n-        \/\/ Get class name from constant pool via `name_index' indirection\n-        final int name_index = file.readUnsignedShort();\n-        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n-        final String name = c.getBytes();\n+        \/\/ Get class name from constant pool via 'name_index' indirection\n+        final int nameIndex = dataInput.readUnsignedShort();\n+        final String name = constantPool.getConstantUtf8(nameIndex).getBytes();\n@@ -105,1 +107,1 @@\n-        final int length = file.readInt();\n+        final int length = dataInput.readInt();\n@@ -108,4 +110,2 @@\n-        for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++)\n-        {\n-            if (name.equals(Const.getAttributeName(i)))\n-            {\n+        for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++) {\n+            if (name.equals(Const.getAttributeName(i))) {\n@@ -117,72 +117,70 @@\n-        \/\/ Call proper constructor, depending on `tag'\n-        switch (tag)\n-        {\n-            case Const.ATTR_UNKNOWN:\n-                final Object r = readers.get(name);\n-                if (r instanceof UnknownAttributeReader)\n-                {\n-                    return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);\n-                }\n-                return new Unknown(name_index, length, file, constant_pool);\n-            case Const.ATTR_CONSTANT_VALUE:\n-                return new ConstantValue(name_index, length, file, constant_pool);\n-            case Const.ATTR_SOURCE_FILE:\n-                return new SourceFile(name_index, length, file, constant_pool);\n-            case Const.ATTR_CODE:\n-                return new Code(name_index, length, file, constant_pool);\n-            case Const.ATTR_EXCEPTIONS:\n-                return new ExceptionTable(name_index, length, file, constant_pool);\n-            case Const.ATTR_LINE_NUMBER_TABLE:\n-                return new LineNumberTable(name_index, length, file, constant_pool);\n-            case Const.ATTR_LOCAL_VARIABLE_TABLE:\n-                return new LocalVariableTable(name_index, length, file, constant_pool);\n-            case Const.ATTR_INNER_CLASSES:\n-                return new InnerClasses(name_index, length, file, constant_pool);\n-            case Const.ATTR_SYNTHETIC:\n-                return new Synthetic(name_index, length, file, constant_pool);\n-            case Const.ATTR_DEPRECATED:\n-                return new Deprecated(name_index, length, file, constant_pool);\n-            case Const.ATTR_PMG:\n-                return new PMGClass(name_index, length, file, constant_pool);\n-            case Const.ATTR_SIGNATURE:\n-                return new Signature(name_index, length, file, constant_pool);\n-            case Const.ATTR_STACK_MAP:\n-                \/\/ old style stack map: unneeded for JDK5 and below;\n-                \/\/ illegal(?) for JDK6 and above.  So just delete with a warning.\n-                println(\"Warning: Obsolete StackMap attribute ignored.\");\n-                return new Unknown(name_index, length, file, constant_pool);\n-            case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:\n-                return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);\n-            case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:\n-                return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);\n-            case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:\n-                return new RuntimeVisibleParameterAnnotations(name_index, length, file, constant_pool);\n-            case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:\n-                return new RuntimeInvisibleParameterAnnotations(name_index, length, file, constant_pool);\n-            case Const.ATTR_ANNOTATION_DEFAULT:\n-                return new AnnotationDefault(name_index, length, file, constant_pool);\n-            case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:\n-                return new LocalVariableTypeTable(name_index, length, file, constant_pool);\n-            case Const.ATTR_ENCLOSING_METHOD:\n-                return new EnclosingMethod(name_index, length, file, constant_pool);\n-            case Const.ATTR_STACK_MAP_TABLE:\n-                \/\/ read new style stack map: StackMapTable.  The rest of the code\n-                \/\/ calls this a StackMap for historical reasons.\n-                return new StackMap(name_index, length, file, constant_pool);\n-            case Const.ATTR_BOOTSTRAP_METHODS:\n-                return new BootstrapMethods(name_index, length, file, constant_pool);\n-            case Const.ATTR_METHOD_PARAMETERS:\n-                return new MethodParameters(name_index, length, file, constant_pool);\n-            case Const.ATTR_MODULE:\n-                return new Module(name_index, length, file, constant_pool);\n-            case Const.ATTR_MODULE_PACKAGES:\n-                return new ModulePackages(name_index, length, file, constant_pool);\n-            case Const.ATTR_MODULE_MAIN_CLASS:\n-                return new ModuleMainClass(name_index, length, file, constant_pool);\n-            case Const.ATTR_NEST_HOST:\n-                return new NestHost(name_index, length, file, constant_pool);\n-            case Const.ATTR_NEST_MEMBERS:\n-                return new NestMembers(name_index, length, file, constant_pool);\n-            default:\n-                \/\/ Never reached\n-                throw new IllegalStateException(\"Unrecognized attribute type tag parsed: \" + tag);\n+        \/\/ Call proper constructor, depending on 'tag'\n+        switch (tag) {\n+        case Const.ATTR_UNKNOWN:\n+            final Object r = READERS.get(name);\n+            if (r instanceof UnknownAttributeReader) {\n+                return ((UnknownAttributeReader) r).createAttribute(nameIndex, length, dataInput, constantPool);\n+            }\n+            return new Unknown(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_CONSTANT_VALUE:\n+            return new ConstantValue(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_SOURCE_FILE:\n+            return new SourceFile(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_CODE:\n+            return new Code(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_EXCEPTIONS:\n+            return new ExceptionTable(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_LINE_NUMBER_TABLE:\n+            return new LineNumberTable(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_LOCAL_VARIABLE_TABLE:\n+            return new LocalVariableTable(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_INNER_CLASSES:\n+            return new InnerClasses(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_SYNTHETIC:\n+            return new Synthetic(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_DEPRECATED:\n+            return new Deprecated(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_PMG:\n+            return new PMGClass(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_SIGNATURE:\n+            return new Signature(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_STACK_MAP:\n+            \/\/ old style stack map: unneeded for JDK5 and below;\n+            \/\/ illegal(?) for JDK6 and above. So just delete with a warning.\n+            println(\"Warning: Obsolete StackMap attribute ignored.\");\n+            return new Unknown(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:\n+            return new RuntimeVisibleAnnotations(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:\n+            return new RuntimeInvisibleAnnotations(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:\n+            return new RuntimeVisibleParameterAnnotations(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:\n+            return new RuntimeInvisibleParameterAnnotations(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_ANNOTATION_DEFAULT:\n+            return new AnnotationDefault(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:\n+            return new LocalVariableTypeTable(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_ENCLOSING_METHOD:\n+            return new EnclosingMethod(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_STACK_MAP_TABLE:\n+            \/\/ read new style stack map: StackMapTable. The rest of the code\n+            \/\/ calls this a StackMap for historical reasons.\n+            return new StackMap(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_BOOTSTRAP_METHODS:\n+            return new BootstrapMethods(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_METHOD_PARAMETERS:\n+            return new MethodParameters(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_MODULE:\n+            return new Module(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_MODULE_PACKAGES:\n+            return new ModulePackages(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_MODULE_MAIN_CLASS:\n+            return new ModuleMainClass(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_NEST_HOST:\n+            return new NestHost(nameIndex, length, dataInput, constantPool);\n+        case Const.ATTR_NEST_MEMBERS:\n+            return new NestMembers(nameIndex, length, dataInput, constantPool);\n+        default:\n+            \/\/ Never reached\n+            throw new IllegalStateException(\"Unrecognized attribute type tag parsed: \" + tag);\n@@ -193,3 +191,2 @@\n-     * Class method reads one attribute from the input data stream. This method\n-     * must not be accessible from the outside. It is called by the Field and\n-     * Method constructor methods.\n+     * Class method reads one attribute from the input data stream. This method must not be accessible from the outside. It\n+     * is called by the Field and Method constructor methods.\n@@ -200,2 +197,2 @@\n-     * @param file Input stream\n-     * @param constant_pool Array of constants\n+     * @param dataInputStream Input stream\n+     * @param constantPool Array of constants\n@@ -203,2 +200,1 @@\n-     * @throws IOException\n-     * @throws ClassFormatException\n+     * @throws IOException if an I\/O error occurs.\n@@ -206,4 +202,2 @@\n-    public static Attribute readAttribute(final DataInputStream file, final ConstantPool constant_pool)\n-            throws IOException, ClassFormatException\n-    {\n-        return readAttribute((DataInput) file, constant_pool);\n+    public static Attribute readAttribute(final DataInputStream dataInputStream, final ConstantPool constantPool) throws IOException {\n+        return readAttribute((DataInput) dataInputStream, constantPool);\n@@ -217,3 +211,2 @@\n-    public static void removeAttributeReader(final String name)\n-    {\n-        readers.remove(name);\n+    public static void removeAttributeReader(final String name) {\n+        READERS.remove(name);\n@@ -222,2 +215,41 @@\n-    protected Attribute(final byte tag, final int name_index, final int length, final ConstantPool constant_pool)\n-    {\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected int name_index; \/\/ Points to attribute name in constant pool TODO make private (has getter & setter)\n+\n+    \/**\n+     * @deprecated (since 6.0) (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected int length; \/\/ Content length of attribute field TODO make private (has getter & setter)\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected byte tag; \/\/ Tag to distinguish subclasses TODO make private & final; supposed to be immutable\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected ConstantPool constant_pool; \/\/ TODO make private (has getter & setter)\n+\n+    \/**\n+     * Constructs an instance.\n+     *\n+     * <pre>\n+     * attribute_info {\n+     *   u2 attribute_name_index;\n+     *   u4 attribute_length;\n+     *   u1 info[attribute_length];\n+     * }\n+     * <\/pre>\n+     *\n+     * @param tag tag.\n+     * @param nameIndex u2 name index.\n+     * @param length u4 length.\n+     * @param constantPool constant pool.\n+     *\/\n+    protected Attribute(final byte tag, final int nameIndex, final int length, final ConstantPool constantPool) {\n@@ -225,3 +257,3 @@\n-        this.name_index = name_index;\n-        this.length = length;\n-        this.constant_pool = constant_pool;\n+        this.name_index = Args.requireU2(nameIndex, 0, constantPool.getLength(), getClass().getSimpleName() + \" name index\");\n+        this.length = Args.requireU4(length, getClass().getSimpleName() + \" attribute length\");\n+        this.constant_pool = constantPool;\n@@ -231,3 +263,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -235,2 +266,1 @@\n-     * @param v\n-     *            Visitor object\n+     * @param v Visitor object\n@@ -242,2 +272,1 @@\n-     * Use copy() if you want to have a deep copy(), i.e., with all references\n-     * copied correctly.\n+     * Use copy() if you want to have a deep copy(), i.e., with all references copied correctly.\n@@ -248,2 +277,1 @@\n-    public Object clone()\n-    {\n+    public Object clone() {\n@@ -251,2 +279,1 @@\n-        try\n-        {\n+        try {\n@@ -254,3 +281,1 @@\n-        }\n-        catch (final CloneNotSupportedException e)\n-        {\n+        } catch (final CloneNotSupportedException e) {\n@@ -263,1 +288,2 @@\n-     * @return deep copy of this attribute\n+     * @param constantPool constant pool to save.\n+     * @return deep copy of this attribute.\n@@ -265,1 +291,1 @@\n-    public abstract Attribute copy(ConstantPool _constant_pool);\n+    public abstract Attribute copy(ConstantPool constantPool);\n@@ -268,1 +294,1 @@\n-     * Dump attribute to file stream in binary format.\n+     * Dumps attribute to file stream in binary format.\n@@ -270,3 +296,2 @@\n-     * @param file\n-     *            Output file stream\n-     * @throws IOException\n+     * @param file Output file stream\n+     * @throws IOException if an I\/O error occurs.\n@@ -274,2 +299,1 @@\n-    public void dump(final DataOutputStream file) throws IOException\n-    {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -284,2 +308,1 @@\n-    public final ConstantPool getConstantPool()\n-    {\n+    public final ConstantPool getConstantPool() {\n@@ -292,2 +315,1 @@\n-    public final int getLength()\n-    {\n+    public final int getLength() {\n@@ -301,4 +323,2 @@\n-    public String getName()\n-    {\n-        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+    public String getName() {\n+        return constant_pool.getConstantUtf8(name_index).getBytes();\n@@ -310,2 +330,1 @@\n-    public final int getNameIndex()\n-    {\n+    public final int getNameIndex() {\n@@ -318,2 +337,1 @@\n-    public final byte getTag()\n-    {\n+    public final byte getTag() {\n@@ -324,1 +342,1 @@\n-     * @param constant_pool Constant pool to be used for this object.\n+     * @param constantPool Constant pool to be used for this object.\n@@ -327,3 +345,2 @@\n-    public final void setConstantPool(final ConstantPool constant_pool)\n-    {\n-        this.constant_pool = constant_pool;\n+    public final void setConstantPool(final ConstantPool constantPool) {\n+        this.constant_pool = constantPool;\n@@ -335,2 +352,1 @@\n-    public final void setLength(final int length)\n-    {\n+    public final void setLength(final int length) {\n@@ -341,1 +357,1 @@\n-     * @param name_index of attribute.\n+     * @param nameIndex of attribute.\n@@ -343,3 +359,2 @@\n-    public final void setNameIndex(final int name_index)\n-    {\n-        this.name_index = name_index;\n+    public final void setNameIndex(final int nameIndex) {\n+        this.name_index = nameIndex;\n@@ -352,2 +367,1 @@\n-    public String toString()\n-    {\n+    public String toString() {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Attribute.java","additions":190,"deletions":176,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -25,4 +25,3 @@\n- * Unknown (non-standard) attributes may be read via user-defined factory\n- * objects that can be registered with the Attribute.addAttributeReader\n- * method. These factory objects should implement this interface.\n-\n+ * Unknown (non-standard) attributes may be read via user-defined factory objects that can be registered with the\n+ * Attribute.addAttributeReader method. These factory objects should implement this interface.\n+ *\n@@ -37,24 +36,17 @@\n-     When this attribute reader is added via the static method\n-     Attribute.addAttributeReader, an attribute name is associated with it.\n-     As the class file parser parses attributes, it will call various\n-     AttributeReaders based on the name of the attributes it is\n-     constructing.\n-\n-     @param name_index An index into the constant pool, indexing a\n-     ConstantUtf8 that represents the name of the attribute.\n-\n-     @param length The length of the data contained in the attribute.  This\n-     is written into the constant pool and should agree with what the\n-     factory expects the length to be.\n-\n-     @param file This is the data input stream that the factory needs to read\n-     its data from.\n-\n-     @param constant_pool This is the constant pool associated with the\n-     Attribute that we are constructing.\n-\n-     @return The user-defined AttributeReader should take this data and use\n-     it to construct an attribute.  In the case of errors, a null can be\n-     returned which will cause the parsing of the class file to fail.\n-\n-     @see Attribute#addAttributeReader( String, AttributeReader )\n+     * When this attribute reader is added via the static method Attribute.addAttributeReader, an attribute name is\n+     * associated with it. As the class file parser parses attributes, it will call various AttributeReaders based on the\n+     * name of the attributes it is constructing.\n+     *\n+     * @param nameIndex An index into the constant pool, indexing a ConstantUtf8 that represents the name of the attribute.\n+     *\n+     * @param length The length of the data contained in the attribute. This is written into the constant pool and should\n+     *        agree with what the factory expects the length to be.\n+     *\n+     * @param file This is the data input stream that the factory needs to read its data from.\n+     *\n+     * @param constantPool This is the constant pool associated with the Attribute that we are constructing.\n+     *\n+     * @return The user-defined AttributeReader should take this data and use it to construct an attribute. In the case of\n+     *         errors, a null can be returned which will cause the parsing of the class file to fail.\n+     *\n+     * @see Attribute#addAttributeReader( String, AttributeReader )\n@@ -62,1 +54,1 @@\n-    Attribute createAttribute( int name_index, int length, java.io.DataInputStream file, ConstantPool constant_pool );\n+    Attribute createAttribute(int nameIndex, int length, java.io.DataInputStream file, ConstantPool constantPool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AttributeReader.java","additions":21,"deletions":29,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -32,3 +32,2 @@\n- * This class represents a bootstrap method attribute, i.e., the bootstrap\n- * method ref, the number of bootstrap arguments and an array of the\n- * bootstrap arguments.\n+ * This class represents a bootstrap method attribute, i.e., the bootstrap method ref, the number of bootstrap arguments\n+ * and an array of the bootstrap arguments.\n@@ -36,2 +35,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\">\n- * The class File Format : The BootstrapMethods Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\"> The class File Format :\n+ *      The BootstrapMethods Attribute<\/a>\n@@ -48,1 +47,0 @@\n-\n@@ -51,0 +49,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -60,1 +60,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -71,2 +71,2 @@\n-    private BootstrapMethod(final int bootstrap_method_ref, final int num_bootstrap_arguments) {\n-        this(bootstrap_method_ref, new int[num_bootstrap_arguments]);\n+    private BootstrapMethod(final int bootstrapMethodRef, final int numBootstrapArguments) {\n+        this(bootstrapMethodRef, new int[numBootstrapArguments]);\n@@ -85,1 +85,1 @@\n-     * @return index into constant_pool of bootstrap_method\n+     * @return deep copy of this object\n@@ -87,2 +87,7 @@\n-    public int getBootstrapMethodRef() {\n-        return bootstrapMethodRef;\n+    public BootstrapMethod copy() {\n+        try {\n+            return (BootstrapMethod) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n@@ -92,1 +97,4 @@\n-     * @param bootstrapMethodRef int index into constant_pool of CONSTANT_MethodHandle\n+     * Dump object to file stream in binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException if an I\/O error occurs.\n@@ -94,2 +102,6 @@\n-    public void setBootstrapMethodRef(final int bootstrapMethodRef) {\n-        this.bootstrapMethodRef = bootstrapMethodRef;\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        file.writeShort(bootstrapMethodRef);\n+        file.writeShort(bootstrapArguments.length);\n+        for (final int bootstrapArgument : bootstrapArguments) {\n+            file.writeShort(bootstrapArgument);\n+        }\n@@ -105,0 +117,7 @@\n+    \/**\n+     * @return index into constant_pool of bootstrap_method\n+     *\/\n+    public int getBootstrapMethodRef() {\n+        return bootstrapMethodRef;\n+    }\n+\n@@ -119,0 +138,7 @@\n+    \/**\n+     * @param bootstrapMethodRef int index into constant_pool of CONSTANT_MethodHandle\n+     *\/\n+    public void setBootstrapMethodRef(final int bootstrapMethodRef) {\n+        this.bootstrapMethodRef = bootstrapMethodRef;\n+    }\n+\n@@ -124,2 +150,1 @@\n-        return \"BootstrapMethod(\" + bootstrapMethodRef + \", \" + bootstrapArguments.length + \", \"\n-               + Arrays.toString(bootstrapArguments) + \")\";\n+        return \"BootstrapMethod(\" + bootstrapMethodRef + \", \" + bootstrapArguments.length + \", \" + Arrays.toString(bootstrapArguments) + \")\";\n@@ -131,1 +156,1 @@\n-    public final String toString( final ConstantPool constantPool ) {\n+    public final String toString(final ConstantPool constantPool) {\n@@ -133,6 +158,4 @@\n-        String bootstrap_method_name;\n-        bootstrap_method_name = constantPool.constantToString(bootstrapMethodRef,\n-                Const.CONSTANT_MethodHandle);\n-        buf.append(Utility.compactClassName(bootstrap_method_name, false));\n-        final int num_bootstrap_arguments = bootstrapArguments.length;\n-        if (num_bootstrap_arguments > 0) {\n+        final String bootstrapMethodName = constantPool.constantToString(bootstrapMethodRef, Const.CONSTANT_MethodHandle);\n+        buf.append(Utility.compactClassName(bootstrapMethodName, false));\n+        final int bootstrapArgumentsLen = bootstrapArguments.length;\n+        if (bootstrapArgumentsLen > 0) {\n@@ -140,1 +163,1 @@\n-            for (int i = 0; i < num_bootstrap_arguments; i++) {\n+            for (int i = 0; i < bootstrapArgumentsLen; i++) {\n@@ -147,26 +170,0 @@\n-\n-    \/**\n-     * Dump object to file stream in binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException\n-     *\/\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        file.writeShort(bootstrapMethodRef);\n-        file.writeShort(bootstrapArguments.length);\n-        for (final int bootstrap_argument : bootstrapArguments) {\n-            file.writeShort(bootstrap_argument);\n-        }\n-    }\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public BootstrapMethod copy() {\n-        try {\n-            return (BootstrapMethod) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethod.java","additions":48,"deletions":51,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n@@ -33,2 +35,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\">\n- * The class File Format : The BootstrapMethods Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\"> The class File Format :\n+ *      The BootstrapMethods Attribute<\/a>\n@@ -37,1 +39,1 @@\n-public class BootstrapMethods extends Attribute {\n+public class BootstrapMethods extends Attribute implements Iterable<BootstrapMethod> {\n@@ -39,1 +41,1 @@\n-    private BootstrapMethod[] bootstrapMethods;  \/\/ TODO this could be made final (setter is not used)\n+    private BootstrapMethod[] bootstrapMethods; \/\/ TODO this could be made final (setter is not used)\n@@ -42,2 +44,4 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -49,1 +53,0 @@\n-\n@@ -51,1 +54,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -54,1 +57,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -56,2 +59,2 @@\n-    public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constant_pool) {\n-        super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);\n+    public BootstrapMethods(final int nameIndex, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constantPool) {\n+        super(Const.ATTR_BOOTSTRAP_METHODS, nameIndex, length, constantPool);\n@@ -64,1 +67,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -67,2 +70,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -70,2 +73,2 @@\n-    BootstrapMethods(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        this(name_index, length, (BootstrapMethod[]) null, constant_pool);\n+    BootstrapMethods(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (BootstrapMethod[]) null, constantPool);\n@@ -73,3 +76,3 @@\n-        final int num_bootstrap_methods = input.readUnsignedShort();\n-        bootstrapMethods = new BootstrapMethod[num_bootstrap_methods];\n-        for (int i = 0; i < num_bootstrap_methods; i++) {\n+        final int numBootstrapMethods = input.readUnsignedShort();\n+        bootstrapMethods = new BootstrapMethod[numBootstrapMethods];\n+        for (int i = 0; i < numBootstrapMethods; i++) {\n@@ -80,14 +83,0 @@\n-    \/**\n-     * @return array of bootstrap method \"records\"\n-     *\/\n-    public final BootstrapMethod[] getBootstrapMethods() {\n-        return bootstrapMethods;\n-    }\n-\n-    \/**\n-     * @param bootstrapMethods the array of bootstrap methods\n-     *\/\n-    public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {\n-        this.bootstrapMethods = bootstrapMethods;\n-    }\n-\n@@ -106,1 +95,1 @@\n-    public BootstrapMethods copy(final ConstantPool _constant_pool) {\n+    public BootstrapMethods copy(final ConstantPool constantPool) {\n@@ -113,1 +102,1 @@\n-        c.setConstantPool(_constant_pool);\n+        c.setConstantPool(constantPool);\n@@ -121,1 +110,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -128,2 +117,2 @@\n-        for (final BootstrapMethod bootstrap_method : bootstrapMethods) {\n-            bootstrap_method.dump(file);\n+        for (final BootstrapMethod bootstrapMethod : bootstrapMethods) {\n+            bootstrapMethod.dump(file);\n@@ -133,0 +122,19 @@\n+    \/**\n+     * @return array of bootstrap method \"records\"\n+     *\/\n+    public final BootstrapMethod[] getBootstrapMethods() {\n+        return bootstrapMethods;\n+    }\n+\n+    @Override\n+    public Iterator<BootstrapMethod> iterator() {\n+        return Stream.of(bootstrapMethods).iterator();\n+    }\n+\n+    \/**\n+     * @param bootstrapMethods the array of bootstrap methods\n+     *\/\n+    public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {\n+        this.bootstrapMethods = bootstrapMethods;\n+    }\n+\n@@ -146,2 +154,2 @@\n-            final int indent_count = buf.length() - start;\n-            final String[] lines = (bootstrapMethods[i].toString(super.getConstantPool())).split(\"\\\\r?\\\\n\");\n+            final int indentCount = buf.length() - start;\n+            final String[] lines = bootstrapMethods[i].toString(super.getConstantPool()).split(\"\\\\r?\\\\n\");\n@@ -150,1 +158,1 @@\n-                buf.append(\"\\n\").append(\"          \".substring(0,indent_count)).append(lines[j]);\n+                buf.append(\"\\n\").append(\"          \", 0, indentCount).append(lines[j]);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethods.java","additions":49,"deletions":41,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-\n@@ -32,2 +30,1 @@\n-public class ClassElementValue extends ElementValue\n-{\n+public class ClassElementValue extends ElementValue {\n@@ -39,2 +36,1 @@\n-    public ClassElementValue(final int type, final int idx, final ConstantPool cpool)\n-    {\n+    public ClassElementValue(final int type, final int idx, final ConstantPool cpool) {\n@@ -45,3 +41,4 @@\n-    public int getIndex()\n-    {\n-        return idx;\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeByte(super.getType()); \/\/ u1 kind of value\n+        dos.writeShort(idx);\n@@ -50,5 +47,2 @@\n-    public String getClassString()\n-    {\n-        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(idx,\n-                Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+    public String getClassString() {\n+        return super.getConstantPool().getConstantUtf8(idx).getBytes();\n@@ -57,6 +51,2 @@\n-    @Override\n-    public String stringifyValue()\n-    {\n-        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(idx,\n-                Const.CONSTANT_Utf8);\n-        return cu8.getBytes();\n+    public int getIndex() {\n+        return idx;\n@@ -66,4 +56,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n-        dos.writeByte(super.getType()); \/\/ u1 kind of value\n-        dos.writeShort(idx);\n+    public String stringifyValue() {\n+        return super.getConstantPool().getConstantUtf8(idx).getBytes();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassElementValue.java","additions":12,"deletions":24,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -25,4 +25,1 @@\n- * Thrown when the BCEL attempts to read a class file and determines\n- * that the file is malformed or otherwise cannot be interpreted as a\n- * class file.\n- *\n+ * Thrown when the BCEL attempts to read a class file and determines that a class is malformed or otherwise cannot be interpreted as a class file.\n@@ -34,0 +31,4 @@\n+    \/**\n+     * Constructs a new instance with {@code null} as its detail message. The cause is not initialized, and may subsequently be initialized by a call to\n+     * {@link #initCause}.\n+     *\/\n@@ -35,1 +36,0 @@\n-        super();\n@@ -38,3 +38,8 @@\n-\n-    public ClassFormatException(final String s) {\n-        super(s);\n+    \/**\n+     * Constructs a new instance with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to\n+     * {@link #initCause}.\n+     *\n+     * @param message the detail message. The detail message is saved for later retrieval by the {@link #getMessage()} method.\n+     *\/\n+    public ClassFormatException(final String message) {\n+        super(message);\n@@ -44,0 +49,7 @@\n+     * Constructs a new instance with the specified detail message and cause.\n+     * <p>\n+     * Note that the detail message associated with {@code cause} is <i>not<\/i> automatically incorporated in this runtime exception's detail message.\n+     *\n+     * @param message the detail message (which is saved for later retrieval by the {@link #getMessage()} method).\n+     * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that\n+     *                the cause is nonexistent or unknown.)\n@@ -49,0 +61,12 @@\n+\n+    \/**\n+     * Constructs a new instance with the specified cause and a detail message of {@code (cause==null ? null : cause.toString())} (which typically contains the\n+     * class and detail message of {@code cause}). This constructor is useful for runtime exceptions that are little more than wrappers for other throwables.\n+     *\n+     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that the\n+     *              cause is nonexistent or unknown.)\n+     * @since 6.7.0\n+     *\/\n+    public ClassFormatException(final Throwable cause) {\n+        super(cause);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassFormatException.java","additions":32,"deletions":8,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,10 +35,3 @@\n- * Wrapper class that parses a given Java .class file. The method <A\n- * href =\"#parse\">parse<\/A> returns a <A href =\"JavaClass.html\">\n- * JavaClass<\/A> object on success. When an I\/O error or an\n- * inconsistency occurs an appropiate exception is propagated back to\n- * the caller.\n- *\n- * The structure and the names comply, except for a few conveniences,\n- * exactly with the <A href=\"http:\/\/docs.oracle.com\/javase\/specs\/\">\n- * JVM specification 1.0<\/a>. See this paper for\n- * further details about the structure of a bytecode file.\n+ * Wrapper class that parses a given Java .class file. The method <a href =\"#parse\">parse<\/a> returns a\n+ * <a href =\"JavaClass.html\"> JavaClass<\/a> object on success. When an I\/O error or an inconsistency occurs an\n+ * appropriate exception is propagated back to the caller.\n@@ -46,0 +39,3 @@\n+ * The structure and the names comply, except for a few conveniences, exactly with the\n+ * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/\"> JVM specification 1.0<\/a>. See this paper for further details about\n+ * the structure of a bytecode file.\n@@ -49,0 +45,1 @@\n+    private static final int BUFSIZE = 8192;\n@@ -64,2 +61,0 @@\n-    private static final int BUFSIZE = 8192;\n-\n@@ -75,1 +70,1 @@\n-        fileOwned = false;\n+        this.fileOwned = false;\n@@ -77,1 +72,1 @@\n-        isZip = clazz.startsWith(\"java.util.zip.\") || clazz.startsWith(\"java.util.jar.\");\n+        this.isZip = clazz.startsWith(\"java.util.zip.\") || clazz.startsWith(\"java.util.jar.\");\n@@ -85,2 +80,2 @@\n-\n-    \/** Parses class from given .class file.\n+    \/**\n+     * Parses class from given .class file.\n@@ -91,1 +86,1 @@\n-        isZip = false;\n+        this.isZip = false;\n@@ -93,1 +88,1 @@\n-        fileOwned = true;\n+        this.fileOwned = true;\n@@ -96,2 +91,2 @@\n-\n-    \/** Parses class from given .class file in a ZIP-archive\n+    \/**\n+     * Parses class from given .class file in a ZIP-archive\n@@ -103,2 +98,2 @@\n-        isZip = true;\n-        fileOwned = true;\n+        this.isZip = true;\n+        this.fileOwned = true;\n@@ -109,1 +104,0 @@\n-\n@@ -111,5 +105,3 @@\n-     * Parses the given Java class file and return an object that represents\n-     * the contained data, i.e., constants, methods, fields and commands.\n-     * A <em>ClassFormatException<\/em> is raised, if the file is not a valid\n-     * .class file. (This does not include verification of the byte code as it\n-     * is performed by the java interpreter).\n+     * Parses the given Java class file and return an object that represents the contained data, i.e., constants, methods,\n+     * fields and commands. A <em>ClassFormatException<\/em> is raised, if the file is not a valid .class file. (This does\n+     * not include verification of the byte code as it is performed by the java interpreter).\n@@ -118,2 +110,2 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -133,2 +125,1 @@\n-                    dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry),\n-                            BUFSIZE));\n+                    dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE));\n@@ -136,2 +127,1 @@\n-                    dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(\n-                            fileName), BUFSIZE));\n+                    dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName), BUFSIZE));\n@@ -160,3 +150,3 @@\n-            \/\/Unknown[] u = Unknown.getUnknownAttributes();\n-            \/\/for (int i=0; i < u.length; i++)\n-            \/\/  System.err.println(\"WARNING: \" + u[i]);\n+            \/\/ Unknown[] u = Unknown.getUnknownAttributes();\n+            \/\/ for (int i=0; i < u.length; i++)\n+            \/\/ System.err.println(\"WARNING: \" + u[i]);\n@@ -164,9 +154,9 @@\n-            \/\/      if(file.available() > 0) {\n-            \/\/        int bytes = file.available();\n-            \/\/        byte[] buf = new byte[bytes];\n-            \/\/        file.read(buf);\n-            \/\/        if(!(isZip && (buf.length == 1))) {\n-            \/\/      System.err.println(\"WARNING: Trailing garbage at end of \" + fileName);\n-            \/\/      System.err.println(bytes + \" extra bytes: \" + Utility.toHexString(buf));\n-            \/\/        }\n-            \/\/      }\n+            \/\/ if(file.available() > 0) {\n+            \/\/ int bytes = file.available();\n+            \/\/ byte[] buf = new byte[bytes];\n+            \/\/ file.read(buf);\n+            \/\/ if(!(isZip && (buf.length == 1))) {\n+            \/\/ System.err.println(\"WARNING: Trailing garbage at end of \" + fileName);\n+            \/\/ System.err.println(bytes + \" extra bytes: \" + Utility.toHexString(buf));\n+            \/\/ }\n+            \/\/ }\n@@ -180,2 +170,2 @@\n-                } catch (final IOException ioe) {\n-                    \/\/ignore close exceptions\n+                } catch (final IOException ignored) {\n+                    \/\/ ignore close exceptions\n@@ -188,2 +178,2 @@\n-            } catch (final IOException ioe) {\n-                \/\/ignore close exceptions\n+            } catch (final IOException ignored) {\n+                \/\/ ignore close exceptions\n@@ -193,4 +183,2 @@\n-        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor,\n-                accessFlags, constantPool, interfaces, fields, methods, attributes, isZip\n-                        ? JavaClass.ZIP\n-                        : JavaClass.FILE);\n+        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor, accessFlags, constantPool, interfaces, fields, methods, attributes,\n+            isZip ? JavaClass.ZIP : JavaClass.FILE);\n@@ -199,1 +187,0 @@\n-\n@@ -202,2 +189,3 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -206,3 +194,3 @@\n-        final int attributes_count = dataInputStream.readUnsignedShort();\n-        attributes = new Attribute[attributes_count];\n-        for (int i = 0; i < attributes_count; i++) {\n+        final int attributesCount = dataInputStream.readUnsignedShort();\n+        attributes = new Attribute[attributesCount];\n+        for (int i = 0; i < attributesCount; i++) {\n@@ -213,1 +201,0 @@\n-\n@@ -216,2 +203,3 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -221,2 +209,2 @@\n-        \/* Interfaces are implicitely abstract, the flag should be set\n-         * according to the JVM specification.\n+        \/*\n+         * Interfaces are implicitly abstract, the flag should be set according to the JVM specification.\n@@ -227,2 +215,1 @@\n-        if (((accessFlags & Const.ACC_ABSTRACT) != 0)\n-                && ((accessFlags & Const.ACC_FINAL) != 0)) {\n+        if ((accessFlags & Const.ACC_ABSTRACT) != 0 && (accessFlags & Const.ACC_FINAL) != 0) {\n@@ -235,1 +222,0 @@\n-\n@@ -238,2 +224,3 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -245,1 +232,0 @@\n-\n@@ -248,2 +234,3 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -252,3 +239,3 @@\n-        final int fields_count = dataInputStream.readUnsignedShort();\n-        fields = new Field[fields_count];\n-        for (int i = 0; i < fields_count; i++) {\n+        final int fieldsCount = dataInputStream.readUnsignedShort();\n+        fields = new Field[fieldsCount];\n+        for (int i = 0; i < fieldsCount; i++) {\n@@ -259,1 +246,0 @@\n-\n@@ -262,4 +248,4 @@\n-     * Checks whether the header of the file is ok.\n-     * Of course, this has to be the first action on successive file reads.\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     * Checks whether the header of the file is ok. Of course, this has to be the first action on successive file reads.\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -273,1 +259,0 @@\n-\n@@ -276,2 +261,3 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -280,3 +266,3 @@\n-        final int interfaces_count = dataInputStream.readUnsignedShort();\n-        interfaces = new int[interfaces_count];\n-        for (int i = 0; i < interfaces_count; i++) {\n+        final int interfacesCount = dataInputStream.readUnsignedShort();\n+        interfaces = new int[interfacesCount];\n+        for (int i = 0; i < interfacesCount; i++) {\n@@ -287,1 +273,0 @@\n-\n@@ -290,2 +275,3 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -293,4 +279,4 @@\n-    private void readMethods() throws IOException, ClassFormatException {\n-        final int methods_count = dataInputStream.readUnsignedShort();\n-        methods = new Method[methods_count];\n-        for (int i = 0; i < methods_count; i++) {\n+    private void readMethods() throws IOException {\n+        final int methodsCount = dataInputStream.readUnsignedShort();\n+        methods = new Method[methodsCount];\n+        for (int i = 0; i < methodsCount; i++) {\n@@ -301,1 +287,0 @@\n-\n@@ -304,2 +289,3 @@\n-     * @throws  IOException\n-     * @throws  ClassFormatException\n+     *\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassParser.java","additions":83,"deletions":97,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +26,1 @@\n+import java.util.Arrays;\n@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,6 +32,3 @@\n- * This class represents a chunk of Java byte code contained in a\n- * method. It is instantiated by the\n- * <em>Attribute.readAttribute()<\/em> method. A <em>Code<\/em>\n- * attribute contains informations about operand stack, local\n- * variables, byte code and the exceptions handled within this\n- * method.\n+ * This class represents a chunk of Java byte code contained in a method. It is instantiated by the\n+ * <em>Attribute.readAttribute()<\/em> method. A <em>Code<\/em> attribute contains informations about operand stack, local\n+ * variables, byte code and the exceptions handled within this method.\n@@ -38,3 +36,2 @@\n- * This attribute has attributes itself, namely <em>LineNumberTable<\/em> which\n- * is used for debugging purposes and <em>LocalVariableTable<\/em> which\n- * contains information about the local variables.\n+ * This attribute has attributes itself, namely <em>LineNumberTable<\/em> which is used for debugging purposes and\n+ * <em>LocalVariableTable<\/em> which contains information about the local variables.\n@@ -42,3 +39,22 @@\n- * @see     Attribute\n- * @see     CodeException\n- * @see     LineNumberTable\n+ * <pre>\n+ * Code_attribute {\n+ *   u2 attribute_name_index;\n+ *   u4 attribute_length;\n+ *   u2 max_stack;\n+ *   u2 max_locals;\n+ *   u4 code_length;\n+ *   u1 code[code_length];\n+ *   u2 exception_table_length;\n+ *   {\n+ *     u2 start_pc;\n+ *     u2 end_pc;\n+ *     u2 handler_pc;\n+ *     u2 catch_type;\n+ *   } exception_table[exception_table_length];\n+ *   u2 attributes_count;\n+ *   attribute_info attributes[attributes_count];\n+ * }\n+ * <\/pre>\n+ * @see Attribute\n+ * @see CodeException\n+ * @see LineNumberTable\n@@ -46,0 +62,1 @@\n+ * @LastModified: Feb 2023\n@@ -49,2 +66,2 @@\n-    private int maxStack; \/\/ Maximum size of stack used by this method  \/\/ TODO this could be made final (setter is not used)\n-    private int maxLocals; \/\/ Number of local variables  \/\/ TODO this could be made final (setter is not used)\n+    private int maxStack; \/\/ Maximum size of stack used by this method \/\/ TODO this could be made final (setter is not used)\n+    private int maxLocals; \/\/ Number of local variables \/\/ TODO this could be made final (setter is not used)\n@@ -55,1 +72,0 @@\n-\n@@ -57,2 +73,4 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param code The source Code.\n@@ -60,3 +78,3 @@\n-    public Code(final Code c) {\n-        this(c.getNameIndex(), c.getLength(), c.getMaxStack(), c.getMaxLocals(), c.getCode(), c\n-                .getExceptionTable(), c.getAttributes(), c.getConstantPool());\n+    public Code(final Code code) {\n+        this(code.getNameIndex(), code.getLength(), code.getMaxStack(), code.getMaxLocals(), code.getCode(), code.getExceptionTable(), code.getAttributes(),\n+                code.getConstantPool());\n@@ -65,1 +83,0 @@\n-\n@@ -67,1 +84,1 @@\n-     * @param name_index Index pointing to the name <em>Code<\/em>\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n@@ -70,1 +87,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -72,2 +89,1 @@\n-    Code(final int name_index, final int length, final DataInput file, final ConstantPool constant_pool)\n-            throws IOException {\n+    Code(final int nameIndex, final int length, final DataInput file, final ConstantPool constantPool) throws IOException {\n@@ -75,4 +91,3 @@\n-        this(name_index, length, file.readUnsignedShort(), file.readUnsignedShort(), (byte[]) null,\n-                (CodeException[]) null, (Attribute[]) null, constant_pool);\n-        final int code_length = file.readInt();\n-        code = new byte[code_length]; \/\/ Read byte code\n+        this(nameIndex, length, file.readUnsignedShort(), file.readUnsignedShort(), (byte[]) null, (CodeException[]) null, (Attribute[]) null, constantPool);\n+        final int codeLength = Args.requireU4(file.readInt(), 1, \"Code length attribute\");\n+        code = new byte[codeLength]; \/\/ Read byte code\n@@ -80,2 +95,3 @@\n-        \/* Read exception table that contains all regions where an exception\n-         * handler is active, i.e., a try { ... } catch() block.\n+        \/*\n+         * Read exception table that contains all regions where an exception handler is active, i.e., a try { ... } catch()\n+         * block.\n@@ -83,3 +99,3 @@\n-        final int exception_table_length = file.readUnsignedShort();\n-        exceptionTable = new CodeException[exception_table_length];\n-        for (int i = 0; i < exception_table_length; i++) {\n+        final int exceptionTableLength = file.readUnsignedShort();\n+        exceptionTable = new CodeException[exceptionTableLength];\n+        for (int i = 0; i < exceptionTableLength; i++) {\n@@ -88,2 +104,2 @@\n-        \/* Read all attributes, currently `LineNumberTable' and\n-         * `LocalVariableTable'\n+        \/*\n+         * Read all attributes, currently 'LineNumberTable' and 'LocalVariableTable'\n@@ -91,4 +107,4 @@\n-        final int attributes_count = file.readUnsignedShort();\n-        attributes = new Attribute[attributes_count];\n-        for (int i = 0; i < attributes_count; i++) {\n-            attributes[i] = Attribute.readAttribute(file, constant_pool);\n+        final int attributesCount = file.readUnsignedShort();\n+        attributes = new Attribute[attributesCount];\n+        for (int i = 0; i < attributesCount; i++) {\n+            attributes[i] = Attribute.readAttribute(file, constantPool);\n@@ -96,3 +112,3 @@\n-        \/* Adjust length, because of setAttributes in this(), s.b.  length\n-         * is incorrect, because it didn't take the internal attributes\n-         * into account yet! Very subtle bug, fixed in 3.1.1.\n+        \/*\n+         * Adjust length, because of setAttributes in this(), s.b. length is incorrect, because it didn't take the internal\n+         * attributes into account yet! Very subtle bug, fixed in 3.1.1.\n@@ -103,1 +119,0 @@\n-\n@@ -105,1 +120,1 @@\n-     * @param name_index Index pointing to the name <em>Code<\/em>\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n@@ -112,1 +127,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -114,8 +129,9 @@\n-    public Code(final int name_index, final int length, final int maxStack, final int maxLocals, final byte[] code,\n-            final CodeException[] exceptionTable, final Attribute[] attributes, final ConstantPool constant_pool) {\n-        super(Const.ATTR_CODE, name_index, length, constant_pool);\n-        this.maxStack = maxStack;\n-        this.maxLocals = maxLocals;\n-        this.code = code != null ? code : new byte[0];\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : new CodeException[0];\n-        this.attributes = attributes != null ? attributes : new Attribute[0];\n+    public Code(final int nameIndex, final int length, final int maxStack, final int maxLocals, final byte[] code, final CodeException[] exceptionTable,\n+        final Attribute[] attributes, final ConstantPool constantPool) {\n+        super(Const.ATTR_CODE, nameIndex, length, constantPool);\n+        this.maxStack = Args.requireU2(maxStack, \"maxStack\");\n+        this.maxLocals = Args.requireU2(maxLocals, \"maxLocals\");\n+        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n+        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n+        Args.requireU2(this.exceptionTable.length, \"exceptionTable.length\");\n+        this.attributes = attributes != null ? attributes : EMPTY_ARRAY;\n@@ -125,1 +141,0 @@\n-\n@@ -127,3 +142,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -134,1 +148,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -138,0 +152,32 @@\n+    \/**\n+     * @return the full size of this code attribute, minus its first 6 bytes, including the size of all its contained\n+     *         attributes\n+     *\/\n+    private int calculateLength() {\n+        int len = 0;\n+        if (attributes != null) {\n+            for (final Attribute attribute : attributes) {\n+                len += attribute.getLength() + 6 \/* attribute header size *\/;\n+            }\n+        }\n+        return len + getInternalLength();\n+    }\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\n+     * @param constantPool the constant pool to duplicate\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final Code c = (Code) clone();\n+        if (code != null) {\n+            c.code = code.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        c.exceptionTable = new CodeException[exceptionTable.length];\n+        Arrays.setAll(c.exceptionTable, i -> exceptionTable[i].copy());\n+        c.attributes = new Attribute[attributes.length];\n+        Arrays.setAll(c.attributes, i -> attributes[i].copy(constantPool));\n+        return c;\n+    }\n@@ -143,1 +189,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -146,1 +192,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -162,1 +208,0 @@\n-\n@@ -171,0 +216,25 @@\n+    \/**\n+     * @return Actual byte code of the method.\n+     *\/\n+    public byte[] getCode() {\n+        return code;\n+    }\n+\n+    \/**\n+     * @return Table of handled exceptions.\n+     * @see CodeException\n+     *\/\n+    public CodeException[] getExceptionTable() {\n+        return exceptionTable;\n+    }\n+\n+    \/**\n+     * @return the internal length of this code attribute (minus the first 6 bytes) and excluding all its attributes\n+     *\/\n+    private int getInternalLength() {\n+        return 2 \/* maxStack *\/ + 2 \/* maxLocals *\/ + 4 \/* code length *\/\n+            + code.length \/* byte-code *\/\n+            + 2 \/* exception-table length *\/\n+            + 8 * (exceptionTable == null ? 0 : exceptionTable.length) \/* exception table *\/\n+            + 2 \/* attributes count *\/;\n+    }\n@@ -184,1 +254,0 @@\n-\n@@ -197,18 +266,0 @@\n-\n-    \/**\n-     * @return Actual byte code of the method.\n-     *\/\n-    public byte[] getCode() {\n-        return code;\n-    }\n-\n-\n-    \/**\n-     * @return Table of handled exceptions.\n-     * @see CodeException\n-     *\/\n-    public CodeException[] getExceptionTable() {\n-        return exceptionTable;\n-    }\n-\n-\n@@ -222,1 +273,0 @@\n-\n@@ -230,29 +280,0 @@\n-\n-    \/**\n-     * @return the internal length of this code attribute (minus the first 6 bytes)\n-     * and excluding all its attributes\n-     *\/\n-    private int getInternalLength() {\n-        return 2 \/*maxStack*\/+ 2 \/*maxLocals*\/+ 4 \/*code length*\/\n-                + code.length \/*byte-code*\/\n-                + 2 \/*exception-table length*\/\n-                + 8 * (exceptionTable == null ? 0 : exceptionTable.length) \/* exception table *\/\n-                + 2 \/* attributes count *\/;\n-    }\n-\n-\n-    \/**\n-     * @return the full size of this code attribute, minus its first 6 bytes,\n-     * including the size of all its contained attributes\n-     *\/\n-    private int calculateLength() {\n-        int len = 0;\n-        if (attributes != null) {\n-            for (final Attribute attribute : attributes) {\n-                len += attribute.getLength() + 6 \/*attribute header size*\/;\n-            }\n-        }\n-        return len + getInternalLength();\n-    }\n-\n-\n@@ -262,2 +283,2 @@\n-    public void setAttributes( final Attribute[] attributes ) {\n-        this.attributes = attributes != null ? attributes : new Attribute[0];\n+    public void setAttributes(final Attribute[] attributes) {\n+        this.attributes = attributes != null ? attributes : EMPTY_ARRAY;\n@@ -267,1 +288,0 @@\n-\n@@ -271,2 +291,2 @@\n-    public void setCode( final byte[] code ) {\n-        this.code = code != null ? code : new byte[0];\n+    public void setCode(final byte[] code) {\n+        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n@@ -276,1 +296,0 @@\n-\n@@ -280,2 +299,2 @@\n-    public void setExceptionTable( final CodeException[] exceptionTable ) {\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : new CodeException[0];\n+    public void setExceptionTable(final CodeException[] exceptionTable) {\n+        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n@@ -285,1 +304,0 @@\n-\n@@ -289,1 +307,1 @@\n-    public void setMaxLocals( final int maxLocals ) {\n+    public void setMaxLocals(final int maxLocals) {\n@@ -293,1 +311,0 @@\n-\n@@ -297,1 +314,1 @@\n-    public void setMaxStack( final int maxStack ) {\n+    public void setMaxStack(final int maxStack) {\n@@ -301,0 +318,7 @@\n+    \/**\n+     * @return String representation of code chunk.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return toString(true);\n+    }\n@@ -303,0 +327,3 @@\n+     * Converts this object to a String.\n+     *\n+     * @param verbose Provides verbose output when true.\n@@ -305,1 +332,1 @@\n-    public String toString( final boolean verbose ) {\n+    public String toString(final boolean verbose) {\n@@ -307,3 +334,2 @@\n-        buf.append(\"Code(maxStack = \").append(maxStack).append(\", maxLocals = \").append(\n-                maxLocals).append(\", code_length = \").append(code.length).append(\")\\n\").append(\n-                Utility.codeToString(code, super.getConstantPool(), 0, -1, verbose));\n+        buf.append(\"Code(maxStack = \").append(maxStack).append(\", maxLocals = \").append(maxLocals).append(\", code_length = \").append(code.length).append(\")\\n\")\n+            .append(Utility.codeToString(code, super.getConstantPool(), 0, -1, verbose));\n@@ -325,34 +351,0 @@\n-\n-\n-    \/**\n-     * @return String representation of code chunk.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return toString(true);\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\n-     * @param _constant_pool the constant pool to duplicate\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final Code c = (Code) clone();\n-        if (code != null) {\n-            c.code = new byte[code.length];\n-            System.arraycopy(code, 0, c.code, 0, code.length);\n-        }\n-        c.setConstantPool(_constant_pool);\n-        c.exceptionTable = new CodeException[exceptionTable.length];\n-        for (int i = 0; i < exceptionTable.length; i++) {\n-            c.exceptionTable[i] = exceptionTable[i].copy();\n-        }\n-        c.attributes = new Attribute[attributes.length];\n-        for (int i = 0; i < attributes.length; i++) {\n-            c.attributes[i] = attributes[i].copy(_constant_pool);\n-        }\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Code.java","additions":155,"deletions":163,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -30,3 +31,2 @@\n- * This class represents an entry in the exception table of the <em>Code<\/em>\n- * attribute and is used only there. It contains a range in which a\n- * particular exception handler is active.\n+ * This class represents an entry in the exception table of the <em>Code<\/em> attribute and is used only there. It\n+ * contains a range in which a particular exception handler is active.\n@@ -34,2 +34,22 @@\n- * @see     Code\n- * @LastModified: May 2021\n+ * <pre>\n+ * Code_attribute {\n+ *   u2 attribute_name_index;\n+ *   u4 attribute_length;\n+ *   u2 max_stack;\n+ *   u2 max_locals;\n+ *   u4 code_length;\n+ *   u1 code[code_length];\n+ *   u2 exception_table_length;\n+ *   {\n+ *     u2 start_pc;\n+ *     u2 end_pc;\n+ *     u2 handler_pc;\n+ *     u2 catch_type;\n+ *   } exception_table[exception_table_length];\n+ *   u2 attributes_count;\n+ *   attribute_info attributes[attributes_count];\n+ * }\n+ * <\/pre>\n+ *\n+ * @see Code\n+ * @LastModified: Feb 2023\n@@ -39,4 +59,2 @@\n-    private int startPc; \/\/ Range in the code the exception handler is\n-    private int endPc; \/\/ active. startPc is inclusive, endPc exclusive\n-    private int handlerPc; \/* Starting address of exception handler, i.e.,\n-     * an offset from start of code.\n+    \/**\n+     * Empty array.\n@@ -44,3 +62,10 @@\n-    private int catchType; \/* If this is zero the handler catches any\n-     * exception, otherwise it points to the\n-     * exception class which is to be caught.\n+    static final CodeException[] EMPTY_CODE_EXCEPTION_ARRAY = {};\n+\n+    \/** Range in the code the exception handler. *\/\n+    private int startPc;\n+\n+    \/** active. startPc is inclusive, endPc exclusive. *\/\n+    private int endPc;\n+\n+    \/**\n+     * Starting address of exception handler, i.e., an offset from start of code.\n@@ -48,0 +73,1 @@\n+    private int handlerPc;\n@@ -49,0 +75,4 @@\n+    \/*\n+     * If this is zero the handler catches any exception, otherwise it points to the exception class which is to be caught.\n+     *\/\n+    private int catchType;\n@@ -51,1 +81,3 @@\n-     * Initialize from another object.\n+     * Constructs a new instance from another instance.\n+     *\n+     * @param c Source for copying.\n@@ -57,1 +89,0 @@\n-\n@@ -59,1 +90,2 @@\n-     * Construct object from file stream.\n+     * Constructs a new instance from a DataInput.\n+     *\n@@ -61,1 +93,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -64,2 +96,1 @@\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n-                .readUnsignedShort());\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort());\n@@ -68,1 +99,0 @@\n-\n@@ -70,2 +100,3 @@\n-     * @param startPc Range in the code the exception handler is active,\n-     * startPc is inclusive while\n+     * Constructs a new instance.\n+     *\n+     * @param startPc Range in the code the exception handler is active, startPc is inclusive while\n@@ -73,5 +104,3 @@\n-     * @param handlerPc Starting address of exception handler, i.e.,\n-     * an offset from start of code.\n-     * @param catchType If zero the handler catches any\n-     * exception, otherwise it points to the exception class which is\n-     * to be caught.\n+     * @param handlerPc Starting address of exception handler, i.e., an offset from start of code.\n+     * @param catchType If zero the handler catches any exception, otherwise it points to the exception class which is to be\n+     *        caught.\n@@ -80,4 +109,4 @@\n-        this.startPc = startPc;\n-        this.endPc = endPc;\n-        this.handlerPc = handlerPc;\n-        this.catchType = catchType;\n+        this.startPc = Args.requireU2(startPc, \"startPc\");\n+        this.endPc = Args.requireU2(endPc, \"endPc\");\n+        this.handlerPc = Args.requireU2(handlerPc, \"handlerPc\");\n+        this.catchType = Args.requireU2(catchType, \"catchType\");\n@@ -86,1 +115,0 @@\n-\n@@ -88,3 +116,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -95,1 +122,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -99,0 +126,11 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public CodeException copy() {\n+        try {\n+            return (CodeException) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n@@ -101,1 +139,1 @@\n-     * Dump code exception to file stream in binary format.\n+     * Dumps code exception to file stream in binary format.\n@@ -104,1 +142,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -106,1 +144,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -113,1 +151,0 @@\n-\n@@ -115,2 +152,1 @@\n-     * @return 0, if the handler catches any exception, otherwise it points to\n-     * the exception class which is to be caught.\n+     * @return 0, if the handler catches any exception, otherwise it points to the exception class which is to be caught.\n@@ -122,1 +158,0 @@\n-\n@@ -130,1 +165,0 @@\n-\n@@ -138,1 +172,0 @@\n-\n@@ -146,1 +179,0 @@\n-\n@@ -150,1 +182,1 @@\n-    public void setCatchType( final int catchType ) {\n+    public void setCatchType(final int catchType) {\n@@ -154,1 +186,0 @@\n-\n@@ -158,1 +189,1 @@\n-    public void setEndPC( final int endPc ) {\n+    public void setEndPC(final int endPc) {\n@@ -162,1 +193,0 @@\n-\n@@ -166,1 +196,1 @@\n-    public void setHandlerPC( final int handlerPc ) { \/\/ TODO unused\n+    public void setHandlerPC(final int handlerPc) { \/\/ TODO unused\n@@ -170,1 +200,0 @@\n-\n@@ -174,1 +203,1 @@\n-    public void setStartPC( final int startPc ) { \/\/ TODO unused\n+    public void setStartPC(final int startPc) { \/\/ TODO unused\n@@ -178,1 +207,0 @@\n-\n@@ -184,2 +212,1 @@\n-        return \"CodeException(startPc = \" + startPc + \", endPc = \" + endPc + \", handlerPc = \"\n-                + handlerPc + \", catchType = \" + catchType + \")\";\n+        return \"CodeException(startPc = \" + startPc + \", endPc = \" + endPc + \", handlerPc = \" + handlerPc + \", catchType = \" + catchType + \")\";\n@@ -188,0 +215,3 @@\n+    public String toString(final ConstantPool cp) {\n+        return toString(cp, true);\n+    }\n@@ -190,0 +220,2 @@\n+     * @param cp constant pool source.\n+     * @param verbose Output more if true.\n@@ -192,1 +224,1 @@\n-    public String toString( final ConstantPool cp, final boolean verbose ) {\n+    public String toString(final ConstantPool cp, final boolean verbose) {\n@@ -197,2 +229,1 @@\n-            str = Utility.compactClassName(cp.getConstantString(catchType, Const.CONSTANT_Class), false)\n-                    + (verbose ? \"(\" + catchType + \")\" : \"\");\n+            str = Utility.compactClassName(cp.getConstantString(catchType, Const.CONSTANT_Class), false) + (verbose ? \"(\" + catchType + \")\" : \"\");\n@@ -202,18 +233,0 @@\n-\n-\n-    public String toString( final ConstantPool cp ) {\n-        return toString(cp, true);\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public CodeException copy() {\n-        try {\n-            return (CodeException) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/CodeException.java","additions":90,"deletions":77,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        public boolean equals( final Object o1, final Object o2 ) {\n+        public boolean equals(final Object o1, final Object o2) {\n@@ -48,1 +48,0 @@\n-\n@@ -50,1 +49,1 @@\n-        public int hashCode( final Object o ) {\n+        public int hashCode(final Object o) {\n@@ -56,42 +55,0 @@\n-    \/* In fact this tag is redundant since we can distinguish different\n-     * `Constant' objects by their type, i.e., via `instanceof'. In some\n-     * places we will use the tag for switch()es anyway.\n-     *\n-     * First, we want match the specification as closely as possible. Second we\n-     * need the tag as an index to select the corresponding class name from the\n-     * `CONSTANT_NAMES' array.\n-     *\/\n-    private byte tag;\n-\n-    Constant(final byte tag) {\n-        this.tag = tag;\n-    }\n-\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public abstract void accept( Visitor v );\n-\n-    public abstract void dump( DataOutputStream file ) throws IOException;\n-\n-    \/**\n-     * @return Tag of constant, i.e., its type. No setTag() method to avoid\n-     * confusion.\n-     *\/\n-    public final byte getTag() {\n-        return tag;\n-    }\n-\n-    \/**\n-     * @return String representation.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return Const.getConstantName(tag) + \"[\" + tag + \"]\";\n-    }\n-\n@@ -99,1 +56,1 @@\n-     * @return deep copy of this constant\n+     * @return Comparison strategy object\n@@ -101,16 +58,2 @@\n-    public Constant copy() {\n-        try {\n-            return (Constant) super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -171,1 +114,1 @@\n-     * @return Comparison strategy object\n+     * @param comparator Comparison strategy object\n@@ -173,2 +116,2 @@\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n+    public static void setComparator(final BCELComparator comparator) {\n+        bcelComparator = comparator;\n@@ -177,0 +120,7 @@\n+    \/*\n+     * In fact this tag is redundant since we can distinguish different 'Constant' objects by their type, i.e., via\n+     * 'instanceof'. In some places we will use the tag for switch()es anyway.\n+     *\n+     * First, we want match the specification as closely as possible. Second we need the tag as an index to select the\n+     * corresponding class name from the 'CONSTANT_NAMES' array.\n+     *\/\n@@ -178,1 +128,1 @@\n-     * @param comparator Comparison strategy object\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -180,2 +130,23 @@\n-    public static void setComparator( final BCELComparator comparator ) {\n-        bcelComparator = comparator;\n+    @java.lang.Deprecated\n+    protected byte tag; \/\/ TODO should be private & final\n+\n+    Constant(final byte tag) {\n+        this.tag = tag;\n+    }\n+\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public abstract void accept(Visitor v);\n+\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n@@ -185,2 +156,15 @@\n-     * Returns value as defined by given BCELComparator strategy.\n-     * By default two Constant objects are said to be equal when\n+     * @return deep copy of this constant\n+     *\/\n+    public Constant copy() {\n+        try {\n+            return (Constant) super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n+\n+    public abstract void dump(DataOutputStream file) throws IOException;\n+\n+    \/**\n+     * Returns value as defined by given BCELComparator strategy. By default two Constant objects are said to be equal when\n@@ -189,1 +173,1 @@\n-     * @see java.lang.Object#equals(java.lang.Object)\n+     * @see Object#equals(Object)\n@@ -192,1 +176,1 @@\n-    public boolean equals( final Object obj ) {\n+    public boolean equals(final Object obj) {\n@@ -197,2 +181,9 @@\n-     * Returns value as defined by given BCELComparator strategy.\n-     * By default return the hashcode of the result of toString().\n+     * @return Tag of constant, i.e., its type. No setTag() method to avoid confusion.\n+     *\/\n+    public final byte getTag() {\n+        return tag;\n+    }\n+\n+    \/**\n+     * Returns value as defined by given BCELComparator strategy. By default return the hashcode of the result of\n+     * toString().\n@@ -200,1 +191,1 @@\n-     * @see java.lang.Object#hashCode()\n+     * @see Object#hashCode()\n@@ -206,0 +197,8 @@\n+\n+    \/**\n+     * @return String representation.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return Const.getConstantName(tag) + \"[\" + tag + \"]\";\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Constant.java","additions":74,"deletions":75,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -29,2 +29,1 @@\n- * Abstract super class for Fieldref, Methodref, InterfaceMethodref and\n- *                          InvokeDynamic constants.\n+ * Abstract super class for Fieldref, Methodref, InterfaceMethodref and InvokeDynamic constants.\n@@ -45,1 +44,5 @@\n-    private int class_index;\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected int class_index; \/\/ TODO make private (has getter & setter)\n@@ -47,1 +50,0 @@\n-    private int name_and_type_index;\n@@ -50,1 +52,1 @@\n-     * Initialize from another object.\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -52,4 +54,2 @@\n-    public ConstantCP(final ConstantCP c) {\n-        this(c.getTag(), c.getClassIndex(), c.getNameAndTypeIndex());\n-    }\n-\n+    @java.lang.Deprecated\n+    protected int name_and_type_index; \/\/ TODO make private (has getter & setter)\n@@ -60,1 +60,1 @@\n-     * @param tag  Constant type tag\n+     * @param tag Constant type tag\n@@ -62,1 +62,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -68,1 +68,0 @@\n-\n@@ -70,2 +69,2 @@\n-     * @param class_index Reference to the class containing the field\n-     * @param name_and_type_index and the field signature\n+     * @param classIndex Reference to the class containing the field\n+     * @param nameAndTypeIndex and the field signature\n@@ -73,1 +72,1 @@\n-    protected ConstantCP(final byte tag, final int class_index, final int name_and_type_index) {\n+    protected ConstantCP(final byte tag, final int classIndex, final int nameAndTypeIndex) {\n@@ -75,2 +74,2 @@\n-        this.class_index = class_index;\n-        this.name_and_type_index = name_and_type_index;\n+        this.class_index = classIndex;\n+        this.name_and_type_index = nameAndTypeIndex;\n@@ -79,0 +78,8 @@\n+    \/**\n+     * Initialize from another object.\n+     *\n+     * @param c Source to copy.\n+     *\/\n+    public ConstantCP(final ConstantCP c) {\n+        this(c.getTag(), c.getClassIndex(), c.getNameAndTypeIndex());\n+    }\n@@ -84,1 +91,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -87,1 +94,1 @@\n-    public final void dump( final DataOutputStream file ) throws IOException {\n+    public final void dump(final DataOutputStream file) throws IOException {\n@@ -93,1 +100,0 @@\n-\n@@ -95,1 +101,1 @@\n-     * @return Reference (index) to class this constant refers to.\n+     * @return Class this field belongs to.\n@@ -97,2 +103,2 @@\n-    public final int getClassIndex() {\n-        return class_index;\n+    public String getClass(final ConstantPool cp) {\n+        return cp.constantToString(class_index, Const.CONSTANT_Class);\n@@ -101,1 +107,0 @@\n-\n@@ -103,1 +108,1 @@\n-     * @param class_index points to Constant_class\n+     * @return Reference (index) to class this constant refers to.\n@@ -105,2 +110,2 @@\n-    public final void setClassIndex( final int class_index ) {\n-        this.class_index = class_index;\n+    public final int getClassIndex() {\n+        return class_index;\n@@ -109,1 +114,0 @@\n-\n@@ -117,1 +121,0 @@\n-\n@@ -119,1 +122,1 @@\n-     * @param name_and_type_index points to Constant_NameAndType\n+     * @param classIndex points to Constant_class\n@@ -121,2 +124,2 @@\n-    public final void setNameAndTypeIndex( final int name_and_type_index ) {\n-        this.name_and_type_index = name_and_type_index;\n+    public final void setClassIndex(final int classIndex) {\n+        this.class_index = classIndex;\n@@ -125,1 +128,0 @@\n-\n@@ -127,1 +129,1 @@\n-     * @return Class this field belongs to.\n+     * @param nameAndTypeIndex points to Constant_NameAndType\n@@ -129,2 +131,2 @@\n-    public String getClass( final ConstantPool cp ) {\n-        return cp.constantToString(class_index, Const.CONSTANT_Class);\n+    public final void setNameAndTypeIndex(final int nameAndTypeIndex) {\n+        this.name_and_type_index = nameAndTypeIndex;\n@@ -133,1 +135,0 @@\n-\n@@ -137,1 +138,1 @@\n-     * not final as ConstantInvokeDynamic needs to modify\n+     *         not final as ConstantInvokeDynamic needs to modify\n@@ -141,2 +142,1 @@\n-        return super.toString() + \"(class_index = \" + class_index + \", name_and_type_index = \"\n-                + name_and_type_index + \")\";\n+        return super.toString() + \"(class_index = \" + class_index + \", name_and_type_index = \" + name_and_type_index + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantCP.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a (external) class.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a (external) class.\n@@ -34,1 +33,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -40,1 +39,0 @@\n-\n@@ -43,0 +41,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -48,1 +48,0 @@\n-\n@@ -59,1 +58,0 @@\n-\n@@ -61,2 +59,1 @@\n-     * @param nameIndex Name index in constant pool.  Should refer to a\n-     * ConstantUtf8.\n+     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n@@ -69,1 +66,0 @@\n-\n@@ -71,3 +67,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -78,1 +73,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -82,1 +77,0 @@\n-\n@@ -90,1 +84,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -95,1 +89,0 @@\n-\n@@ -97,1 +90,1 @@\n-     * @return Name index in constant pool of class name.\n+     * @return dereferenced string\n@@ -99,2 +92,2 @@\n-    public int getNameIndex() {\n-        return nameIndex;\n+    public String getBytes(final ConstantPool cp) {\n+        return (String) getConstantValue(cp);\n@@ -103,1 +96,0 @@\n-\n@@ -105,1 +97,1 @@\n-     * @param nameIndex the name index in the constant pool of this Constant Class\n+     * @return String object\n@@ -107,2 +99,3 @@\n-    public void setNameIndex( final int nameIndex ) {\n-        this.nameIndex = nameIndex;\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return cp.getConstantUtf8(nameIndex).getBytes();\n@@ -111,2 +104,2 @@\n-\n-    \/** @return String object\n+    \/**\n+     * @return Name index in constant pool of class name.\n@@ -114,4 +107,2 @@\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n-        return ((ConstantUtf8) c).getBytes();\n+    public int getNameIndex() {\n+        return nameIndex;\n@@ -120,2 +111,2 @@\n-\n-    \/** @return dereferenced string\n+    \/**\n+     * @param nameIndex the name index in the constant pool of this Constant Class\n@@ -123,2 +114,2 @@\n-    public String getBytes( final ConstantPool cp ) {\n-        return (String) getConstantValue(cp);\n+    public void setNameIndex(final int nameIndex) {\n+        this.nameIndex = nameIndex;\n@@ -127,1 +118,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantClass.java","additions":24,"deletions":34,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * This class is derived from the abstract  {@link Constant}\n- * and represents a reference to a Double object.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a Double object.\n@@ -40,10 +39,0 @@\n-\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantDouble(final double bytes) {\n-        super(Const.CONSTANT_Double);\n-        this.bytes = bytes;\n-    }\n-\n-\n@@ -52,0 +41,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -57,1 +48,0 @@\n-\n@@ -62,1 +52,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -68,0 +58,7 @@\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantDouble(final double bytes) {\n+        super(Const.CONSTANT_Double);\n+        this.bytes = bytes;\n+    }\n@@ -70,3 +67,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +73,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -81,1 +77,0 @@\n-\n@@ -86,1 +81,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -89,1 +84,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -94,1 +89,0 @@\n-\n@@ -102,0 +96,7 @@\n+    \/**\n+     * @return Double object\n+     *\/\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return Double.valueOf(bytes);\n+    }\n@@ -106,1 +107,1 @@\n-    public void setBytes( final double bytes ) {\n+    public void setBytes(final double bytes) {\n@@ -110,1 +111,0 @@\n-\n@@ -118,8 +118,0 @@\n-\n-\n-    \/** @return Double object\n-     *\/\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        return bytes;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantDouble.java","additions":24,"deletions":32,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a dynamically computed constant.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a dynamically computed\n+ * constant.\n@@ -33,3 +33,3 @@\n- * @see     Constant\n- * @see  <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\">\n- * Change request for JEP 309<\/a>\n+ * @see Constant\n+ * @see <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\"> Change request for JEP\n+ *      309<\/a>\n@@ -42,0 +42,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -52,1 +54,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -59,2 +61,2 @@\n-    public ConstantDynamic(final int bootstrap_method_attr_index, final int name_and_type_index) {\n-        super(Const.CONSTANT_Dynamic, bootstrap_method_attr_index, name_and_type_index);\n+    public ConstantDynamic(final int bootstrapMethodAttrIndex, final int nameAndTypeIndex) {\n+        super(Const.CONSTANT_Dynamic, bootstrapMethodAttrIndex, nameAndTypeIndex);\n@@ -65,3 +67,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n+     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -72,1 +73,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -79,2 +80,1 @@\n-     * Note that this method is a functional duplicate of getClassIndex\n-     * for use by ConstantInvokeDynamic.\n+     *         Note that this method is a functional duplicate of getClassIndex for use by ConstantInvokeDynamic.\n@@ -84,1 +84,1 @@\n-        return super.getClassIndex();  \/\/ AKA bootstrap_method_attr_index\n+        return super.getClassIndex(); \/\/ AKA bootstrap_method_attr_index\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantDynamic.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- *\n@@ -37,0 +36,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -42,1 +43,0 @@\n-\n@@ -47,1 +47,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -53,1 +53,0 @@\n-\n@@ -55,2 +54,2 @@\n-     * @param class_index Reference to the class containing the Field\n-     * @param name_and_type_index and the Field signature\n+     * @param classIndex Reference to the class containing the Field\n+     * @param nameAndTypeIndex and the Field signature\n@@ -58,2 +57,2 @@\n-    public ConstantFieldref(final int class_index, final int name_and_type_index) {\n-        super(Const.CONSTANT_Fieldref, class_index, name_and_type_index);\n+    public ConstantFieldref(final int classIndex, final int nameAndTypeIndex) {\n+        super(Const.CONSTANT_Fieldref, classIndex, nameAndTypeIndex);\n@@ -62,1 +61,0 @@\n-\n@@ -64,3 +62,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of Fields,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of Fields, fields, attributes, etc. spawns a tree of objects.\n@@ -71,1 +68,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantFieldref.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a float object.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a float object.\n@@ -40,10 +39,0 @@\n-\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantFloat(final float bytes) {\n-        super(Const.CONSTANT_Float);\n-        this.bytes = bytes;\n-    }\n-\n-\n@@ -51,2 +40,4 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -58,1 +49,0 @@\n-\n@@ -63,1 +53,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -69,0 +59,7 @@\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantFloat(final float bytes) {\n+        super(Const.CONSTANT_Float);\n+        this.bytes = bytes;\n+    }\n@@ -71,3 +68,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -78,1 +74,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -82,1 +78,0 @@\n-\n@@ -87,1 +82,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -90,1 +85,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -95,1 +90,0 @@\n-\n@@ -103,0 +97,7 @@\n+    \/**\n+     * @return Float object\n+     *\/\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return Float.valueOf(bytes);\n+    }\n@@ -107,1 +108,1 @@\n-    public void setBytes( final float bytes ) {\n+    public void setBytes(final float bytes) {\n@@ -111,1 +112,0 @@\n-\n@@ -119,8 +119,0 @@\n-\n-\n-    \/** @return Float object\n-     *\/\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        return bytes;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantFloat.java","additions":26,"deletions":34,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to an int object.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to an int object.\n@@ -40,10 +39,0 @@\n-\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantInteger(final int bytes) {\n-        super(Const.CONSTANT_Integer);\n-        this.bytes = bytes;\n-    }\n-\n-\n@@ -52,0 +41,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -57,1 +48,0 @@\n-\n@@ -62,1 +52,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -68,0 +58,7 @@\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantInteger(final int bytes) {\n+        super(Const.CONSTANT_Integer);\n+        this.bytes = bytes;\n+    }\n@@ -70,3 +67,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +73,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -81,1 +77,0 @@\n-\n@@ -86,1 +81,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -89,1 +84,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -94,1 +89,0 @@\n-\n@@ -102,0 +96,7 @@\n+    \/**\n+     * @return Integer object\n+     *\/\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return Integer.valueOf(bytes);\n+    }\n@@ -106,1 +107,1 @@\n-    public void setBytes( final int bytes ) {\n+    public void setBytes(final int bytes) {\n@@ -110,1 +111,0 @@\n-\n@@ -118,8 +118,0 @@\n-\n-\n-    \/** @return Integer object\n-     *\/\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        return Integer.valueOf(bytes);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInteger.java","additions":24,"deletions":32,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- *\n@@ -37,0 +36,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -42,1 +43,0 @@\n-\n@@ -47,1 +47,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -53,1 +53,0 @@\n-\n@@ -55,2 +54,2 @@\n-     * @param class_index Reference to the class containing the method\n-     * @param name_and_type_index and the method signature\n+     * @param classIndex Reference to the class containing the method\n+     * @param nameAndTypeIndex and the method signature\n@@ -58,2 +57,2 @@\n-    public ConstantInterfaceMethodref(final int class_index, final int name_and_type_index) {\n-        super(Const.CONSTANT_InterfaceMethodref, class_index, name_and_type_index);\n+    public ConstantInterfaceMethodref(final int classIndex, final int nameAndTypeIndex) {\n+        super(Const.CONSTANT_InterfaceMethodref, classIndex, nameAndTypeIndex);\n@@ -62,1 +61,0 @@\n-\n@@ -64,3 +62,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -71,1 +68,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInterfaceMethodref.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a invoke dynamic.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a invoke dynamic.\n@@ -33,3 +32,3 @@\n- * @see     Constant\n- * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\">\n- * The CONSTANT_InvokeDynamic_info Structure in The Java Virtual Machine Specification<\/a>\n+ * @see Constant\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\"> The\n+ *      CONSTANT_InvokeDynamic_info Structure in The Java Virtual Machine Specification<\/a>\n@@ -42,0 +41,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -47,1 +48,0 @@\n-\n@@ -52,1 +52,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -55,1 +55,1 @@\n-        this(file.readShort(), file.readShort());\n+        this(file.readUnsignedShort(), file.readUnsignedShort());\n@@ -58,3 +58,2 @@\n-\n-    public ConstantInvokeDynamic(final int bootstrap_method_attr_index, final int name_and_type_index) {\n-        super(Const.CONSTANT_InvokeDynamic, bootstrap_method_attr_index, name_and_type_index);\n+    public ConstantInvokeDynamic(final int bootstrapMethodAttrIndex, final int nameAndTypeIndex) {\n+        super(Const.CONSTANT_InvokeDynamic, bootstrapMethodAttrIndex, nameAndTypeIndex);\n@@ -63,1 +62,0 @@\n-\n@@ -65,3 +63,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n+     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -72,1 +69,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -79,2 +76,1 @@\n-     * Note that this method is a functional duplicate of getClassIndex\n-     * for use by ConstantInvokeDynamic.\n+     *         Note that this method is a functional duplicate of getClassIndex for use by ConstantInvokeDynamic.\n@@ -84,1 +80,1 @@\n-        return super.getClassIndex();  \/\/ AKA bootstrap_method_attr_index\n+        return super.getClassIndex(); \/\/ AKA bootstrap_method_attr_index\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInvokeDynamic.java","additions":15,"deletions":19,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a long object.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a long object.\n@@ -40,10 +39,0 @@\n-\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantLong(final long bytes) {\n-        super(Const.CONSTANT_Long);\n-        this.bytes = bytes;\n-    }\n-\n-\n@@ -52,0 +41,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -57,1 +48,0 @@\n-\n@@ -62,1 +52,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -68,0 +58,7 @@\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantLong(final long bytes) {\n+        super(Const.CONSTANT_Long);\n+        this.bytes = bytes;\n+    }\n@@ -70,3 +67,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +73,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -81,1 +77,0 @@\n-\n@@ -86,1 +81,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -89,1 +84,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -94,1 +89,0 @@\n-\n@@ -102,0 +96,7 @@\n+    \/**\n+     * @return Long object\n+     *\/\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return Long.valueOf(bytes);\n+    }\n@@ -106,1 +107,1 @@\n-    public void setBytes( final long bytes ) {\n+    public void setBytes(final long bytes) {\n@@ -110,1 +111,0 @@\n-\n@@ -118,8 +118,0 @@\n-\n-\n-    \/** @return Long object\n-     *\/\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        return bytes;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantLong.java","additions":24,"deletions":32,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a method handle.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a method handle.\n@@ -34,1 +33,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -42,1 +41,0 @@\n-\n@@ -45,0 +43,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -50,1 +50,0 @@\n-\n@@ -55,1 +54,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -61,2 +60,1 @@\n-\n-    public ConstantMethodHandle(final int reference_kind, final int reference_index) {\n+    public ConstantMethodHandle(final int referenceKind, final int referenceIndex) {\n@@ -64,2 +62,2 @@\n-        this.referenceKind = reference_kind;\n-        this.referenceIndex = reference_index;\n+        this.referenceKind = referenceKind;\n+        this.referenceIndex = referenceIndex;\n@@ -68,1 +66,0 @@\n-\n@@ -70,3 +67,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n+     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +73,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -81,1 +77,0 @@\n-\n@@ -86,1 +81,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -89,1 +84,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -95,0 +90,3 @@\n+    public int getReferenceIndex() {\n+        return referenceIndex;\n+    }\n@@ -100,8 +98,2 @@\n-\n-    public void setReferenceKind(final int reference_kind) {\n-        this.referenceKind = reference_kind;\n-    }\n-\n-\n-    public int getReferenceIndex() {\n-        return referenceIndex;\n+    public void setReferenceIndex(final int referenceIndex) {\n+        this.referenceIndex = referenceIndex;\n@@ -110,3 +102,2 @@\n-\n-    public void setReferenceIndex(final int reference_index) {\n-        this.referenceIndex = reference_index;\n+    public void setReferenceKind(final int referenceKind) {\n+        this.referenceKind = referenceKind;\n@@ -115,1 +106,0 @@\n-\n@@ -121,2 +111,1 @@\n-        return super.toString() + \"(referenceKind = \" + referenceKind +\n-                \", referenceIndex = \" + referenceIndex + \")\";\n+        return super.toString() + \"(referenceKind = \" + referenceKind + \", referenceIndex = \" + referenceIndex + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodHandle.java","additions":21,"deletions":32,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a method type.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a method type.\n@@ -34,1 +33,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -41,1 +40,0 @@\n-\n@@ -44,0 +42,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -49,1 +49,0 @@\n-\n@@ -54,1 +53,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -60,2 +59,1 @@\n-\n-    public ConstantMethodType(final int descriptor_index) {\n+    public ConstantMethodType(final int descriptorIndex) {\n@@ -63,1 +61,1 @@\n-        this.descriptorIndex = descriptor_index;\n+        this.descriptorIndex = descriptorIndex;\n@@ -66,1 +64,0 @@\n-\n@@ -68,3 +65,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n+     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -75,1 +71,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -79,1 +75,0 @@\n-\n@@ -84,1 +79,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -87,1 +82,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -92,1 +87,0 @@\n-\n@@ -97,3 +91,2 @@\n-\n-    public void setDescriptorIndex(final int descriptor_index) {\n-        this.descriptorIndex = descriptor_index;\n+    public void setDescriptorIndex(final int descriptorIndex) {\n+        this.descriptorIndex = descriptorIndex;\n@@ -102,1 +95,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodType.java","additions":14,"deletions":22,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- *\n@@ -37,0 +36,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -42,1 +43,0 @@\n-\n@@ -47,1 +47,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -53,1 +53,0 @@\n-\n@@ -55,2 +54,2 @@\n-     * @param class_index Reference to the class containing the method\n-     * @param name_and_type_index and the method signature\n+     * @param classIndex Reference to the class containing the method\n+     * @param nameAndTypeIndex and the method signature\n@@ -58,2 +57,2 @@\n-    public ConstantMethodref(final int class_index, final int name_and_type_index) {\n-        super(Const.CONSTANT_Methodref, class_index, name_and_type_index);\n+    public ConstantMethodref(final int classIndex, final int nameAndTypeIndex) {\n+        super(Const.CONSTANT_Methodref, classIndex, nameAndTypeIndex);\n@@ -62,1 +61,0 @@\n-\n@@ -64,3 +62,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -71,1 +68,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodref.java","additions":10,"deletions":13,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a module.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a module.\n@@ -34,1 +33,3 @@\n- * <p>Note: Early access Java 9 support- currently subject to change<\/p>\n+ * <p>\n+ * Note: Early access Java 9 support- currently subject to change\n+ * <\/p>\n@@ -36,1 +37,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -43,1 +44,0 @@\n-\n@@ -46,0 +46,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -51,1 +53,0 @@\n-\n@@ -56,1 +57,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -62,1 +63,0 @@\n-\n@@ -64,2 +64,1 @@\n-     * @param nameIndex Name index in constant pool.  Should refer to a\n-     * ConstantUtf8.\n+     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n@@ -72,1 +71,0 @@\n-\n@@ -74,3 +72,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n+     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -81,1 +78,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -85,1 +82,0 @@\n-\n@@ -90,1 +86,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -93,1 +89,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -98,1 +94,0 @@\n-\n@@ -100,1 +95,1 @@\n-     * @return Name index in constant pool of module name.\n+     * @return dereferenced string\n@@ -102,2 +97,2 @@\n-    public int getNameIndex() {\n-        return nameIndex;\n+    public String getBytes(final ConstantPool cp) {\n+        return (String) getConstantValue(cp);\n@@ -106,1 +101,0 @@\n-\n@@ -108,1 +102,1 @@\n-     * @param nameIndex the name index in the constant pool of this Constant Module\n+     * @return String object\n@@ -110,2 +104,3 @@\n-    public void setNameIndex( final int nameIndex ) {\n-        this.nameIndex = nameIndex;\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return cp.getConstantUtf8(nameIndex).getBytes();\n@@ -114,2 +109,2 @@\n-\n-    \/** @return String object\n+    \/**\n+     * @return Name index in constant pool of module name.\n@@ -117,4 +112,2 @@\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n-        return ((ConstantUtf8) c).getBytes();\n+    public int getNameIndex() {\n+        return nameIndex;\n@@ -123,2 +116,2 @@\n-\n-    \/** @return dereferenced string\n+    \/**\n+     * @param nameIndex the name index in the constant pool of this Constant Module\n@@ -126,2 +119,2 @@\n-    public String getBytes( final ConstantPool cp ) {\n-        return (String) getConstantValue(cp);\n+    public void setNameIndex(final int nameIndex) {\n+        this.nameIndex = nameIndex;\n@@ -130,1 +123,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantModule.java","additions":29,"deletions":37,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to the name and signature\n- * of a field or method.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to the name and signature of a\n+ * field or method.\n@@ -35,1 +34,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -42,1 +41,0 @@\n-\n@@ -45,0 +43,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -50,1 +50,0 @@\n-\n@@ -55,1 +54,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -61,1 +60,0 @@\n-\n@@ -72,1 +70,0 @@\n-\n@@ -74,3 +71,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -81,1 +77,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -85,1 +81,0 @@\n-\n@@ -90,1 +85,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -93,1 +88,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -99,0 +94,6 @@\n+    \/**\n+     * @return name\n+     *\/\n+    public String getName(final ConstantPool cp) {\n+        return cp.constantToString(getNameIndex(), Const.CONSTANT_Utf8);\n+    }\n@@ -107,2 +108,2 @@\n-\n-    \/** @return name\n+    \/**\n+     * @return signature\n@@ -110,2 +111,2 @@\n-    public String getName( final ConstantPool cp ) {\n-        return cp.constantToString(getNameIndex(), Const.CONSTANT_Utf8);\n+    public String getSignature(final ConstantPool cp) {\n+        return cp.constantToString(getSignatureIndex(), Const.CONSTANT_Utf8);\n@@ -114,1 +115,0 @@\n-\n@@ -122,8 +122,0 @@\n-\n-    \/** @return signature\n-     *\/\n-    public String getSignature( final ConstantPool cp ) {\n-        return cp.constantToString(getSignatureIndex(), Const.CONSTANT_Utf8);\n-    }\n-\n-\n@@ -133,1 +125,1 @@\n-    public void setNameIndex( final int nameIndex ) {\n+    public void setNameIndex(final int nameIndex) {\n@@ -137,1 +129,0 @@\n-\n@@ -141,1 +132,1 @@\n-    public void setSignatureIndex( final int signatureIndex ) {\n+    public void setSignatureIndex(final int signatureIndex) {\n@@ -145,1 +136,0 @@\n-\n@@ -151,2 +141,1 @@\n-        return super.toString() + \"(nameIndex = \" + nameIndex + \", signatureIndex = \"\n-                + signatureIndex + \")\";\n+        return super.toString() + \"(nameIndex = \" + nameIndex + \", signatureIndex = \" + signatureIndex + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantNameAndType.java","additions":24,"deletions":35,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * This interface denotes those constants that have a \"natural\" value,\n- * such as ConstantLong, ConstantString, etc..\n+ * This interface denotes those constants that have a \"natural\" value, such as ConstantLong, ConstantString, etc..\n@@ -28,1 +27,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -32,1 +31,2 @@\n-    \/** @return object representing the constant, e.g., Long for ConstantLong\n+    \/**\n+     * @return object representing the constant, e.g., Long for ConstantLong\n@@ -34,1 +34,1 @@\n-    Object getConstantValue( ConstantPool cp );\n+    Object getConstantValue(ConstantPool cp);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantObject.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a package.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a package.\n@@ -34,1 +33,3 @@\n- * <p>Note: Early access Java 9 support- currently subject to change<\/p>\n+ * <p>\n+ * Note: Early access Java 9 support- currently subject to change\n+ * <\/p>\n@@ -36,1 +37,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -43,1 +44,0 @@\n-\n@@ -46,0 +46,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -51,1 +53,0 @@\n-\n@@ -56,1 +57,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -62,1 +63,0 @@\n-\n@@ -64,2 +64,1 @@\n-     * @param nameIndex Name index in constant pool.  Should refer to a\n-     * ConstantUtf8.\n+     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n@@ -72,1 +71,0 @@\n-\n@@ -74,3 +72,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n+     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -81,1 +78,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -85,1 +82,0 @@\n-\n@@ -90,1 +86,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -93,1 +89,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -98,1 +94,0 @@\n-\n@@ -100,1 +95,1 @@\n-     * @return Name index in constant pool of package name.\n+     * @return dereferenced string\n@@ -102,2 +97,2 @@\n-    public int getNameIndex() {\n-        return nameIndex;\n+    public String getBytes(final ConstantPool cp) {\n+        return (String) getConstantValue(cp);\n@@ -106,1 +101,0 @@\n-\n@@ -108,1 +102,1 @@\n-     * @param nameIndex the name index in the constant pool of this Constant Package\n+     * @return String object\n@@ -110,2 +104,3 @@\n-    public void setNameIndex( final int nameIndex ) {\n-        this.nameIndex = nameIndex;\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return cp.getConstantUtf8(nameIndex).getBytes();\n@@ -114,2 +109,2 @@\n-\n-    \/** @return String object\n+    \/**\n+     * @return Name index in constant pool of package name.\n@@ -117,4 +112,2 @@\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n-        return ((ConstantUtf8) c).getBytes();\n+    public int getNameIndex() {\n+        return nameIndex;\n@@ -123,2 +116,2 @@\n-\n-    \/** @return dereferenced string\n+    \/**\n+     * @param nameIndex the name index in the constant pool of this Constant Package\n@@ -126,2 +119,2 @@\n-    public String getBytes( final ConstantPool cp ) {\n-        return (String) getConstantValue(cp);\n+    public void setNameIndex(final int nameIndex) {\n+        this.nameIndex = nameIndex;\n@@ -130,1 +123,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantPackage.java","additions":29,"deletions":37,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n@@ -28,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;\n@@ -31,10 +32,7 @@\n- * This class represents the constant pool, i.e., a table of constants, of\n- * a parsed classfile. It may contain null references, due to the JVM\n- * specification that skips an entry after an 8-byte constant (double,\n- * long) entry.  Those interested in generating constant pools\n- * programatically should see <a href=\"..\/generic\/ConstantPoolGen.html\">\n- * ConstantPoolGen<\/a>.\n-\n- * @see     Constant\n- * @see     com.sun.org.apache.bcel.internal.generic.ConstantPoolGen\n- * @LastModified: June 2022\n+ * This class represents the constant pool, i.e., a table of constants, of a parsed classfile. It may contain null references, due to the JVM specification that\n+ * skips an entry after an 8-byte constant (double, long) entry. Those interested in generating constant pools programmatically should see\n+ * <a href=\"..\/generic\/ConstantPoolGen.html\"> ConstantPoolGen<\/a>.\n+ *\n+ * @see Constant\n+ * @see com.sun.org.apache.bcel.internal.generic.ConstantPoolGen\n+ * @LastModified: Feb 2023\n@@ -42,1 +40,29 @@\n-public class ConstantPool implements Cloneable, Node {\n+public class ConstantPool implements Cloneable, Node, Iterable<Constant> {\n+\n+    private static String escape(final String str) {\n+        final int len = str.length();\n+        final StringBuilder buf = new StringBuilder(len + 5);\n+        final char[] ch = str.toCharArray();\n+        for (int i = 0; i < len; i++) {\n+            switch (ch[i]) {\n+            case '\\n':\n+                buf.append(\"\\\\n\");\n+                break;\n+            case '\\r':\n+                buf.append(\"\\\\r\");\n+                break;\n+            case '\\t':\n+                buf.append(\"\\\\t\");\n+                break;\n+            case '\\b':\n+                buf.append(\"\\\\b\");\n+                break;\n+            case '\"':\n+                buf.append(\"\\\\\\\"\");\n+                break;\n+            default:\n+                buf.append(ch[i]);\n+            }\n+        }\n+        return buf.toString();\n+    }\n@@ -57,2 +83,1 @@\n-     * @throws IOException\n-     * @throws ClassFormatException\n+     * @throws IOException if problem in readUnsignedShort or readConstant\n@@ -60,1 +85,1 @@\n-    public ConstantPool(final DataInput input) throws IOException, ClassFormatException {\n+    public ConstantPool(final DataInput input) throws IOException {\n@@ -62,4 +87,4 @@\n-        final int constant_pool_count = input.readUnsignedShort();\n-        constantPool = new Constant[constant_pool_count];\n-        \/* constantPool[0] is unused by the compiler and may be used freely\n-         * by the implementation.\n+        final int constantPoolCount = input.readUnsignedShort();\n+        constantPool = new Constant[constantPoolCount];\n+        \/*\n+         * constantPool[0] is unused by the compiler and may be used freely by the implementation.\n@@ -67,1 +92,1 @@\n-        for (int i = 1; i < constant_pool_count; i++) {\n+        for (int i = 1; i < constantPoolCount; i++) {\n@@ -69,4 +94,3 @@\n-            \/* Quote from the JVM specification:\n-             * \"All eight byte constants take up two spots in the constant pool.\n-             * If this is the n'th byte in the constant pool, then the next item\n-             * will be numbered n+2\"\n+            \/*\n+             * Quote from the JVM specification: \"All eight byte constants take up two spots in the constant pool. If this is the n'th byte in the constant\n+             * pool, then the next item will be numbered n+2\"\n@@ -77,1 +101,1 @@\n-            if ((tag == Const.CONSTANT_Double) || (tag == Const.CONSTANT_Long)) {\n+            if (tag == Const.CONSTANT_Double || tag == Const.CONSTANT_Long) {\n@@ -84,3 +108,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e., the hierarchy of methods, fields,\n+     * attributes, etc. spawns a tree of objects.\n@@ -91,1 +114,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -98,1 +121,1 @@\n-     * @param  c Constant to be printed\n+     * @param c Constant to be printed\n@@ -100,0 +123,1 @@\n+     * @throws IllegalArgumentException if c is unknown constant type\n@@ -101,1 +125,1 @@\n-    public String constantToString( Constant c ) throws ClassFormatException {\n+    public String constantToString(Constant c) throws IllegalArgumentException {\n@@ -106,68 +130,66 @@\n-            case Const.CONSTANT_Class:\n-                i = ((ConstantClass) c).getNameIndex();\n-                c = getConstant(i, Const.CONSTANT_Utf8);\n-                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-                break;\n-            case Const.CONSTANT_String:\n-                i = ((ConstantString) c).getStringIndex();\n-                c = getConstant(i, Const.CONSTANT_Utf8);\n-                str = \"\\\"\" + escape(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n-                break;\n-            case Const.CONSTANT_Utf8:\n-                str = ((ConstantUtf8) c).getBytes();\n-                break;\n-            case Const.CONSTANT_Double:\n-                str = String.valueOf(((ConstantDouble) c).getBytes());\n-                break;\n-            case Const.CONSTANT_Float:\n-                str = String.valueOf(((ConstantFloat) c).getBytes());\n-                break;\n-            case Const.CONSTANT_Long:\n-                str = String.valueOf(((ConstantLong) c).getBytes());\n-                break;\n-            case Const.CONSTANT_Integer:\n-                str = String.valueOf(((ConstantInteger) c).getBytes());\n-                break;\n-            case Const.CONSTANT_NameAndType:\n-                str = constantToString(((ConstantNameAndType) c).getNameIndex(),\n-                        Const.CONSTANT_Utf8)\n-                        + \" \" + constantToString(((ConstantNameAndType) c).getSignatureIndex(),\n-                        Const.CONSTANT_Utf8);\n-                break;\n-            case Const.CONSTANT_InterfaceMethodref:\n-            case Const.CONSTANT_Methodref:\n-            case Const.CONSTANT_Fieldref:\n-                str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)\n-                        + \".\" + constantToString(((ConstantCP) c).getNameAndTypeIndex(),\n-                        Const.CONSTANT_NameAndType);\n-                break;\n-            case Const.CONSTANT_MethodHandle:\n-                \/\/ Note that the ReferenceIndex may point to a Fieldref, Methodref or\n-                \/\/ InterfaceMethodref - so we need to peek ahead to get the actual type.\n-                final ConstantMethodHandle cmh = (ConstantMethodHandle) c;\n-                str = Const.getMethodHandleName(cmh.getReferenceKind())\n-                        + \" \" + constantToString(cmh.getReferenceIndex(),\n-                        getConstant(cmh.getReferenceIndex()).getTag());\n-                break;\n-            case Const.CONSTANT_MethodType:\n-                final ConstantMethodType cmt = (ConstantMethodType) c;\n-                str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);\n-                break;\n-            case Const.CONSTANT_InvokeDynamic:\n-                final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;\n-                str = cid.getBootstrapMethodAttrIndex()\n-                        + \":\" + constantToString(cid.getNameAndTypeIndex(),\n-                        Const.CONSTANT_NameAndType);\n-                break;\n-            case Const.CONSTANT_Module:\n-                i = ((ConstantModule) c).getNameIndex();\n-                c = getConstant(i, Const.CONSTANT_Utf8);\n-                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-                break;\n-            case Const.CONSTANT_Package:\n-                i = ((ConstantPackage) c).getNameIndex();\n-                c = getConstant(i, Const.CONSTANT_Utf8);\n-                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-                break;\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown constant type \" + tag);\n+        case Const.CONSTANT_Class:\n+            i = ((ConstantClass) c).getNameIndex();\n+            c = getConstantUtf8(i);\n+            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+            break;\n+        case Const.CONSTANT_String:\n+            i = ((ConstantString) c).getStringIndex();\n+            c = getConstantUtf8(i);\n+            str = \"\\\"\" + escape(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n+            break;\n+        case Const.CONSTANT_Utf8:\n+            str = ((ConstantUtf8) c).getBytes();\n+            break;\n+        case Const.CONSTANT_Double:\n+            str = String.valueOf(((ConstantDouble) c).getBytes());\n+            break;\n+        case Const.CONSTANT_Float:\n+            str = String.valueOf(((ConstantFloat) c).getBytes());\n+            break;\n+        case Const.CONSTANT_Long:\n+            str = String.valueOf(((ConstantLong) c).getBytes());\n+            break;\n+        case Const.CONSTANT_Integer:\n+            str = String.valueOf(((ConstantInteger) c).getBytes());\n+            break;\n+        case Const.CONSTANT_NameAndType:\n+            str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + \" \"\n+                    + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);\n+            break;\n+        case Const.CONSTANT_InterfaceMethodref:\n+        case Const.CONSTANT_Methodref:\n+        case Const.CONSTANT_Fieldref:\n+            str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + \".\"\n+                    + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n+            break;\n+        case Const.CONSTANT_MethodHandle:\n+            \/\/ Note that the ReferenceIndex may point to a Fieldref, Methodref or\n+            \/\/ InterfaceMethodref - so we need to peek ahead to get the actual type.\n+            final ConstantMethodHandle cmh = (ConstantMethodHandle) c;\n+            str = Const.getMethodHandleName(cmh.getReferenceKind()) + \" \"\n+                    + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());\n+            break;\n+        case Const.CONSTANT_MethodType:\n+            final ConstantMethodType cmt = (ConstantMethodType) c;\n+            str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);\n+            break;\n+        case Const.CONSTANT_InvokeDynamic:\n+            final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;\n+            str = cid.getBootstrapMethodAttrIndex() + \":\" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n+            break;\n+        case Const.CONSTANT_Dynamic:\n+            final ConstantDynamic cd = (ConstantDynamic) c;\n+            str = cd.getBootstrapMethodAttrIndex() + \":\" + constantToString(cd.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n+            break;\n+        case Const.CONSTANT_Module:\n+            i = ((ConstantModule) c).getNameIndex();\n+            c = getConstantUtf8(i);\n+            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+            break;\n+        case Const.CONSTANT_Package:\n+            i = ((ConstantPackage) c).getNameIndex();\n+            c = getConstantUtf8(i);\n+            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+            break;\n+        default: \/\/ Never reached\n+            throw new IllegalArgumentException(\"Unknown constant type \" + tag);\n@@ -178,28 +200,0 @@\n-    private static String escape( final String str ) {\n-        final int len = str.length();\n-        final StringBuilder buf = new StringBuilder(len + 5);\n-        final char[] ch = str.toCharArray();\n-        for (int i = 0; i < len; i++) {\n-            switch (ch[i]) {\n-                case '\\n':\n-                    buf.append(\"\\\\n\");\n-                    break;\n-                case '\\r':\n-                    buf.append(\"\\\\r\");\n-                    break;\n-                case '\\t':\n-                    buf.append(\"\\\\t\");\n-                    break;\n-                case '\\b':\n-                    buf.append(\"\\\\b\");\n-                    break;\n-                case '\"':\n-                    buf.append(\"\\\\\\\"\");\n-                    break;\n-                default:\n-                    buf.append(ch[i]);\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n@@ -207,2 +201,1 @@\n-     * Retrieves constant at `index' from constant pool and resolve it to\n-     * a string representation.\n+     * Retrieves constant at 'index' from constant pool and resolve it to a string representation.\n@@ -210,2 +203,2 @@\n-     * @param  index of constant in constant pool\n-     * @param  tag expected type\n+     * @param index of constant in constant pool\n+     * @param tag   expected type\n@@ -214,3 +207,21 @@\n-    public String constantToString( final int index, final byte tag ) throws ClassFormatException {\n-        final Constant c = getConstant(index, tag);\n-        return constantToString(c);\n+    public String constantToString(final int index, final byte tag) {\n+        return constantToString(getConstant(index, tag));\n+    }\n+\n+    \/**\n+     * @return deep copy of this constant pool\n+     *\/\n+    public ConstantPool copy() {\n+        ConstantPool c = null;\n+        try {\n+            c = (ConstantPool) clone();\n+            c.constantPool = new Constant[constantPool.length];\n+            for (int i = 1; i < constantPool.length; i++) {\n+                if (constantPool[i] != null) {\n+                    c.constantPool[i] = constantPool[i].copy();\n+                }\n+            }\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return c;\n@@ -223,1 +234,1 @@\n-     * @throws IOException\n+     * @throws IOException if problem in writeShort or dump\n@@ -225,1 +236,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -230,3 +241,2 @@\n-        *\/\n-        int size = constantPool.length < ConstantPoolGen.CONSTANT_POOL_SIZE ?\n-                constantPool.length : ConstantPoolGen.CONSTANT_POOL_SIZE;\n+         *\/\n+        final int size = Math.min(constantPool.length, Const.MAX_CP_ENTRIES);\n@@ -245,1 +255,1 @@\n-     * @param  index Index in constant pool\n+     * @param index Index in constant pool\n@@ -247,1 +257,2 @@\n-     * @see    Constant\n+     * @see Constant\n+     * @throws ClassFormatException if index is invalid\n@@ -249,4 +260,33 @@\n-    public Constant getConstant( final int index ) {\n-        if (index >= constantPool.length || index < 0) {\n-            throw new ClassFormatException(\"Invalid constant pool reference: \" + index\n-                    + \". Constant pool size is: \" + constantPool.length);\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Constant> T getConstant(final int index) throws ClassFormatException {\n+        return (T) getConstant(index, Constant.class);\n+    }\n+\n+    \/**\n+     * Gets constant from constant pool and check whether it has the expected type.\n+     *\n+     * @param index Index in constant pool\n+     * @param tag   Tag of expected constant, i.e., its type\n+     * @return Constant value\n+     * @see Constant\n+     * @throws ClassFormatException if constant type does not match tag\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public <T extends Constant> T getConstant(final int index, final byte tag) throws ClassFormatException {\n+        return (T) getConstant(index, tag, Constant.class);\n+    }\n+\n+    \/**\n+     * Gets constant from constant pool and check whether it has the expected type.\n+     *\n+     * @param index Index in constant pool\n+     * @param tag   Tag of expected constant, i.e., its type\n+     * @return Constant value\n+     * @see Constant\n+     * @throws ClassFormatException if constant type does not match tag\n+     * @since 6.6.0\n+     *\/\n+    public <T extends Constant> T getConstant(final int index, final byte tag, final Class<T> castTo) throws ClassFormatException {\n+        final T c = getConstant(index);\n+        if (c.getTag() != tag) {\n+            throw new ClassFormatException(\"Expected class '\" + Const.getConstantName(tag) + \"' at index \" + index + \" and got \" + c);\n@@ -254,1 +294,1 @@\n-        return constantPool[index];\n+        return c;\n@@ -258,2 +298,1 @@\n-     * Gets constant from constant pool and check whether it has the\n-     * expected type.\n+     * Gets constant from constant pool.\n@@ -261,2 +300,3 @@\n-     * @param  index Index in constant pool\n-     * @param  tag Tag of expected constant, i.e., its type\n+     * @param <T> A {@link Constant} subclass\n+     * @param index Index in constant pool\n+     * @param castTo The {@link Constant} subclass to cast to.\n@@ -264,2 +304,3 @@\n-     * @see    Constant\n-     * @throws  ClassFormatException\n+     * @see Constant\n+     * @throws ClassFormatException if index is invalid\n+     * @since 6.6.0\n@@ -267,5 +308,3 @@\n-    public Constant getConstant( final int index, final byte tag ) throws ClassFormatException {\n-        Constant c;\n-        c = getConstant(index);\n-        if (c == null) {\n-            throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n+    public <T extends Constant> T getConstant(final int index, final Class<T> castTo) throws ClassFormatException {\n+        if (index >= constantPool.length || index < 0) {\n+            throw new ClassFormatException(\"Invalid constant pool reference using index: \" + index + \". Constant pool size is: \" + constantPool.length);\n@@ -273,3 +312,13 @@\n-        if (c.getTag() != tag) {\n-            throw new ClassFormatException(\"Expected class `\" + Const.getConstantName(tag)\n-                    + \"' at index \" + index + \" and got \" + c);\n+        if (constantPool[index] != null && !castTo.isAssignableFrom(constantPool[index].getClass())) {\n+            throw new ClassFormatException(\"Invalid constant pool reference at index: \" + index +\n+                    \". Expected \" + castTo + \" but was \" + constantPool[index].getClass());\n+        }\n+        \/\/ Previous check ensures this won't throw a ClassCastException\n+        final T c = castTo.cast(constantPool[index]);\n+        if (c == null\n+            \/\/ the 0th element is always null\n+            && index != 0) {\n+            final Constant prev = constantPool[index - 1];\n+            if (prev == null || prev.getTag() != Const.CONSTANT_Double && prev.getTag() != Const.CONSTANT_Long) {\n+                throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n+            }\n@@ -280,0 +329,12 @@\n+    \/**\n+     * Gets constant from constant pool and check whether it has the expected type.\n+     *\n+     * @param index Index in constant pool\n+     * @return ConstantInteger value\n+     * @see ConstantInteger\n+     * @throws ClassFormatException if constant type does not match tag\n+     *\/\n+    public ConstantInteger getConstantInteger(final int index) {\n+        return getConstant(index, Const.CONSTANT_Integer, ConstantInteger.class);\n+    }\n+\n@@ -282,1 +343,1 @@\n-     * @see    Constant\n+     * @see Constant\n@@ -289,4 +350,2 @@\n-     * Gets string from constant pool and bypass the indirection of\n-     * `ConstantClass' and `ConstantString' objects. I.e. these classes have\n-     * an index field that points to another entry of the constant pool of\n-     * type `ConstantUtf8' which contains the real data.\n+     * Gets string from constant pool and bypass the indirection of 'ConstantClass' and 'ConstantString' objects. I.e. these classes have an index field that\n+     * points to another entry of the constant pool of type 'ConstantUtf8' which contains the real data.\n@@ -294,2 +353,2 @@\n-     * @param  index Index in constant pool\n-     * @param  tag Tag of expected constant, either ConstantClass or ConstantString\n+     * @param index Index in constant pool\n+     * @param tag   Tag of expected constant, either ConstantClass or ConstantString\n@@ -297,3 +356,3 @@\n-     * @see    ConstantClass\n-     * @see    ConstantString\n-     * @throws  ClassFormatException\n+     * @see ConstantClass\n+     * @see ConstantString\n+     * @throws IllegalArgumentException if tag is invalid\n@@ -301,2 +360,1 @@\n-    public String getConstantString( final int index, final byte tag ) throws ClassFormatException {\n-        Constant c;\n+    public String getConstantString(final int index, final byte tag) throws IllegalArgumentException {\n@@ -304,7 +362,4 @@\n-        c = getConstant(index, tag);\n-        \/* This switch() is not that elegant, since the four classes have the\n-         * same contents, they just differ in the name of the index\n-         * field variable.\n-         * But we want to stick to the JVM naming conventions closely though\n-         * we could have solved these more elegantly by using the same\n-         * variable name or by subclassing.\n+        \/*\n+         * This switch() is not that elegant, since the four classes have the same contents, they just differ in the name of the index field variable. But we\n+         * want to stick to the JVM naming conventions closely though we could have solved these more elegantly by using the same variable name or by\n+         * subclassing.\n@@ -313,14 +368,16 @@\n-            case Const.CONSTANT_Class:\n-                i = ((ConstantClass) c).getNameIndex();\n-                break;\n-            case Const.CONSTANT_String:\n-                i = ((ConstantString) c).getStringIndex();\n-                break;\n-            case Const.CONSTANT_Module:\n-                i = ((ConstantModule) c).getNameIndex();\n-                break;\n-            case Const.CONSTANT_Package:\n-                i = ((ConstantPackage) c).getNameIndex();\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"getConstantString called with illegal tag \" + tag);\n+        case Const.CONSTANT_Class:\n+            i = getConstant(index, ConstantClass.class).getNameIndex();\n+            break;\n+        case Const.CONSTANT_String:\n+            i = getConstant(index, ConstantString.class).getStringIndex();\n+            break;\n+        case Const.CONSTANT_Module:\n+            i = getConstant(index, ConstantModule.class).getNameIndex();\n+            break;\n+        case Const.CONSTANT_Package:\n+            i = getConstant(index, ConstantPackage.class).getNameIndex();\n+            break;\n+        case Const.CONSTANT_Utf8:\n+            return getConstantUtf8(index).getBytes();\n+        default:\n+            throw new IllegalArgumentException(\"getConstantString called with illegal tag \" + tag);\n@@ -329,2 +386,1 @@\n-        c = getConstant(i, Const.CONSTANT_Utf8);\n-        return ((ConstantUtf8) c).getBytes();\n+        return getConstantUtf8(i).getBytes();\n@@ -333,0 +389,11 @@\n+    \/**\n+     * Gets constant from constant pool and check whether it has the expected type.\n+     *\n+     * @param index Index in constant pool\n+     * @return ConstantUtf8 value\n+     * @see ConstantUtf8\n+     * @throws ClassFormatException if constant type does not match tag\n+     *\/\n+    public ConstantUtf8 getConstantUtf8(final int index) throws ClassFormatException {\n+        return getConstant(index, Const.CONSTANT_Utf8, ConstantUtf8.class);\n+    }\n@@ -341,0 +408,4 @@\n+    @Override\n+    public Iterator<Constant> iterator() {\n+        return Arrays.stream(constantPool).iterator();\n+    }\n@@ -345,1 +416,1 @@\n-    public void setConstant( final int index, final Constant constant ) {\n+    public void setConstant(final int index, final Constant constant) {\n@@ -349,1 +420,0 @@\n-\n@@ -353,1 +423,1 @@\n-    public void setConstantPool( final Constant[] constantPool ) {\n+    public void setConstantPool(final Constant[] constantPool) {\n@@ -357,1 +427,0 @@\n-\n@@ -369,20 +438,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this constant pool\n-     *\/\n-    public ConstantPool copy() {\n-        ConstantPool c = null;\n-        try {\n-            c = (ConstantPool) clone();\n-            c.constantPool = new Constant[constantPool.length];\n-            for (int i = 1; i < constantPool.length; i++) {\n-                if (constantPool[i] != null) {\n-                    c.constantPool[i] = constantPool[i].copy();\n-                }\n-            }\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantPool.java","additions":269,"deletions":220,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class is derived from the abstract {@link Constant}\n- * and represents a reference to a String object.\n+ * This class is derived from the abstract {@link Constant} and represents a reference to a String object.\n@@ -34,1 +33,1 @@\n- * @see     Constant\n+ * @see Constant\n@@ -40,1 +39,0 @@\n-\n@@ -43,0 +41,2 @@\n+     *\n+     * @param c Source to copy.\n@@ -48,1 +48,0 @@\n-\n@@ -53,1 +52,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -59,1 +58,0 @@\n-\n@@ -68,1 +66,0 @@\n-\n@@ -70,3 +67,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +73,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -81,1 +77,0 @@\n-\n@@ -86,1 +81,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -89,1 +84,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -94,0 +89,14 @@\n+    \/**\n+     * @return dereferenced string\n+     *\/\n+    public String getBytes(final ConstantPool cp) {\n+        return (String) getConstantValue(cp);\n+    }\n+\n+    \/**\n+     * @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue(final ConstantPool cp) {\n+        return cp.getConstantUtf8(stringIndex).getBytes();\n+    }\n@@ -102,1 +111,0 @@\n-\n@@ -106,1 +114,1 @@\n-    public void setStringIndex( final int stringIndex ) {\n+    public void setStringIndex(final int stringIndex) {\n@@ -110,1 +118,0 @@\n-\n@@ -118,16 +125,0 @@\n-\n-\n-    \/** @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue( final ConstantPool cp ) {\n-        final Constant c = cp.getConstant(stringIndex, Const.CONSTANT_Utf8);\n-        return ((ConstantUtf8) c).getBytes();\n-    }\n-\n-\n-    \/** @return dereferenced string\n-     *\/\n-    public String getBytes( final ConstantPool cp ) {\n-        return (String) getConstantValue(cp);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantString.java","additions":25,"deletions":34,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -30,0 +29,3 @@\n+import java.util.Objects;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -33,0 +35,24 @@\n+ * <p>\n+ * The following system properties govern caching this class performs.\n+ * <\/p>\n+ * <ul>\n+ * <li>{@value #SYS_PROP_CACHE_MAX_ENTRIES} (since 6.4): The size of the cache, by default 0, meaning caching is\n+ * disabled.<\/li>\n+ * <li>{@value #SYS_PROP_CACHE_MAX_ENTRY_SIZE} (since 6.0): The maximum size of the values to cache, by default 200, 0\n+ * disables caching. Values larger than this are <em>not<\/em> cached.<\/li>\n+ * <li>{@value #SYS_PROP_STATISTICS} (since 6.0): Prints statistics on the console when the JVM exits.<\/li>\n+ * <\/ul>\n+ * <p>\n+ * Here is a sample Maven invocation with caching disabled:\n+ * <\/p>\n+ *\n+ * <pre>\n+ * mvn test -Dbcel.statistics=true -Dbcel.maxcached.size=0 -Dbcel.maxcached=0\n+ * <\/pre>\n+ * <p>\n+ * Here is a sample Maven invocation with caching enabled:\n+ * <\/p>\n+ *\n+ * <pre>\n+ * mvn test -Dbcel.statistics=true -Dbcel.maxcached.size=100000 -Dbcel.maxcached=5000000\n+ * <\/pre>\n@@ -35,1 +61,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Feb 2023\n@@ -45,2 +71,1 @@\n-        private static final HashMap<String, ConstantUtf8> CACHE = new LinkedHashMap<String, ConstantUtf8>(\n-            INITIAL_CAPACITY, 0.75f, true) {\n+        private static final HashMap<String, ConstantUtf8> CACHE = new LinkedHashMap<String, ConstantUtf8>(INITIAL_CAPACITY, 0.75f, true) {\n@@ -65,0 +90,16 @@\n+    \/\/ TODO these should perhaps be AtomicInt?\n+    private static volatile int considered;\n+    private static volatile int created;\n+    private static volatile int hits;\n+    private static volatile int skipped;\n+\n+    private static final String SYS_PROP_CACHE_MAX_ENTRIES = \"bcel.maxcached\";\n+    private static final String SYS_PROP_CACHE_MAX_ENTRY_SIZE = \"bcel.maxcached.size\";\n+    private static final String SYS_PROP_STATISTICS = \"bcel.statistics\";\n+\n+    static {\n+        if (Cache.BCEL_STATISTICS) {\n+            Runtime.getRuntime().addShutdownHook(new Thread(ConstantUtf8::printStats));\n+        }\n+    }\n+\n@@ -74,0 +115,5 @@\n+    \/\/ for access by test code\n+    static synchronized void clearStats() {\n+        hits = considered = skipped = created = 0;\n+    }\n+\n@@ -86,0 +132,1 @@\n+            skipped++;\n@@ -88,1 +135,1 @@\n-\n+        considered++;\n@@ -92,0 +139,1 @@\n+                hits++;\n@@ -129,0 +177,9 @@\n+    \/\/ for access by test code\n+    static void printStats() {\n+        final String prefix = \"[Apache Commons BCEL]\";\n+        System.err.printf(\"%s Cache hit %,d\/%,d, %d skipped.%n\", prefix, hits, considered, skipped);\n+        System.err.printf(\"%s Total of %,d ConstantUtf8 objects created.%n\", prefix, created);\n+        System.err.printf(\"%s Configuration: %s=%,d, %s=%,d.%n\", prefix, SYS_PROP_CACHE_MAX_ENTRIES, Cache.MAX_ENTRIES, SYS_PROP_CACHE_MAX_ENTRY_SIZE,\n+            Cache.MAX_ENTRY_SIZE);\n+    }\n+\n@@ -144,1 +201,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -149,0 +206,1 @@\n+        created++;\n@@ -156,4 +214,2 @@\n-        if (value == null) {\n-            throw new IllegalArgumentException(\"Value must not be null.\");\n-        }\n-        this.value = value;\n+        this.value = Objects.requireNonNull(value, \"value\");\n+        created++;\n@@ -163,1 +219,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n@@ -177,1 +233,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantUtf8.java","additions":69,"deletions":13,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,3 +32,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents a constant\n- * value, i.e., a default value for initializing a class field.\n- * This class is instantiated by the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and represents a constant value, i.e., a default value for initializing\n+ * a class field. This class is instantiated by the <em>Attribute.readAttribute()<\/em> method.\n@@ -35,1 +35,8 @@\n- * @see     Attribute\n+ * <pre>\n+ * ConstantValue_attribute {\n+ *   u2 attribute_name_index;\n+ *   u4 attribute_length;\n+ *   u2 constantvalue_index;\n+ * }\n+ * <\/pre>\n+ * @see Attribute\n@@ -41,1 +48,0 @@\n-\n@@ -43,2 +49,4 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -50,1 +58,0 @@\n-\n@@ -53,1 +60,2 @@\n-     * @param name_index Name index in constant pool\n+     *\n+     * @param nameIndex Name index in constant pool\n@@ -56,2 +64,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -59,3 +67,2 @@\n-    ConstantValue(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, input.readUnsignedShort(), constant_pool);\n+    ConstantValue(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n@@ -64,1 +71,0 @@\n-\n@@ -66,1 +72,1 @@\n-     * @param name_index Name index in constant pool\n+     * @param nameIndex Name index in constant pool\n@@ -69,1 +75,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -71,3 +77,2 @@\n-    public ConstantValue(final int name_index, final int length, final int constantValueIndex,\n-            final ConstantPool constant_pool) {\n-        super(Const.ATTR_CONSTANT_VALUE, name_index, length, constant_pool);\n+    public ConstantValue(final int nameIndex, final int length, final int constantValueIndex, final ConstantPool constantPool) {\n+        super(Const.ATTR_CONSTANT_VALUE, nameIndex, Args.require(length, 2, \"ConstantValue attribute length\"), constantPool);\n@@ -77,1 +82,0 @@\n-\n@@ -79,3 +83,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -86,1 +89,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -90,0 +93,9 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final ConstantValue c = (ConstantValue) clone();\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -95,1 +107,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -98,1 +110,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -103,1 +115,0 @@\n-\n@@ -111,1 +122,0 @@\n-\n@@ -115,1 +125,1 @@\n-    public void setConstantValueIndex( final int constantValueIndex ) {\n+    public void setConstantValueIndex(final int constantValueIndex) {\n@@ -119,1 +129,0 @@\n-\n@@ -130,19 +139,19 @@\n-            case Const.CONSTANT_Long:\n-                buf = String.valueOf(((ConstantLong) c).getBytes());\n-                break;\n-            case Const.CONSTANT_Float:\n-                buf = String.valueOf(((ConstantFloat) c).getBytes());\n-                break;\n-            case Const.CONSTANT_Double:\n-                buf = String.valueOf(((ConstantDouble) c).getBytes());\n-                break;\n-            case Const.CONSTANT_Integer:\n-                buf = String.valueOf(((ConstantInteger) c).getBytes());\n-                break;\n-            case Const.CONSTANT_String:\n-                i = ((ConstantString) c).getStringIndex();\n-                c = super.getConstantPool().getConstant(i, Const.CONSTANT_Utf8);\n-                buf = \"\\\"\" + Utility.convertString(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n-                break;\n-            default:\n-                throw new IllegalStateException(\"Type of ConstValue invalid: \" + c);\n+        case Const.CONSTANT_Long:\n+            buf = String.valueOf(((ConstantLong) c).getBytes());\n+            break;\n+        case Const.CONSTANT_Float:\n+            buf = String.valueOf(((ConstantFloat) c).getBytes());\n+            break;\n+        case Const.CONSTANT_Double:\n+            buf = String.valueOf(((ConstantDouble) c).getBytes());\n+            break;\n+        case Const.CONSTANT_Integer:\n+            buf = String.valueOf(((ConstantInteger) c).getBytes());\n+            break;\n+        case Const.CONSTANT_String:\n+            i = ((ConstantString) c).getStringIndex();\n+            c = super.getConstantPool().getConstantUtf8(i);\n+            buf = \"\\\"\" + Utility.convertString(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n+            break;\n+        default:\n+            throw new IllegalStateException(\"Type of ConstValue invalid: \" + c);\n@@ -152,11 +161,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final ConstantValue c = (ConstantValue) clone();\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantValue.java","additions":59,"deletions":61,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -30,3 +31,2 @@\n- * This class is derived from <em>Attribute<\/em> and denotes that this is a\n- * deprecated method.\n- * It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and denotes that this is a deprecated method. It is instantiated from\n+ * the <em>Attribute.readAttribute()<\/em> method.\n@@ -34,1 +34,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -40,1 +40,0 @@\n-\n@@ -42,2 +41,4 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -49,1 +50,0 @@\n-\n@@ -51,1 +51,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -54,1 +54,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -56,2 +56,2 @@\n-    public Deprecated(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n-        super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);\n+    public Deprecated(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n+        super(Const.ATTR_DEPRECATED, nameIndex, Args.require0(length, \"Deprecated attribute length\"), constantPool);\n@@ -61,1 +61,0 @@\n-\n@@ -65,1 +64,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -68,2 +67,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -71,3 +70,2 @@\n-    Deprecated(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, (byte[]) null, constant_pool);\n+    Deprecated(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (byte[]) null, constantPool);\n@@ -81,1 +79,0 @@\n-\n@@ -83,3 +80,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -90,1 +86,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -94,0 +90,12 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final Deprecated c = (Deprecated) clone();\n+        if (bytes != null) {\n+            c.bytes = bytes.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -99,1 +107,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -102,1 +110,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -109,1 +117,0 @@\n-\n@@ -117,1 +124,0 @@\n-\n@@ -121,1 +127,1 @@\n-    public void setBytes( final byte[] bytes ) {\n+    public void setBytes(final byte[] bytes) {\n@@ -125,1 +131,0 @@\n-\n@@ -131,16 +136,1 @@\n-        return Const.getAttributeName(Const.ATTR_DEPRECATED);\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final Deprecated c = (Deprecated) clone();\n-        if (bytes != null) {\n-            c.bytes = new byte[bytes.length];\n-            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n+        return Const.getAttributeName(Const.ATTR_DEPRECATED) + \": true\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Deprecated.java","additions":36,"deletions":46,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+import java.util.Objects;\n@@ -23,0 +24,1 @@\n+import java.util.stream.Stream;\n@@ -30,2 +32,1 @@\n-public class DescendingVisitor implements Visitor\n-{\n+public class DescendingVisitor implements Visitor {\n@@ -39,1 +40,2 @@\n-     * @return container of current entitity, i.e., predecessor during traversal\n+     * @param clazz Class to traverse\n+     * @param visitor visitor object to apply to all components\n@@ -41,3 +43,3 @@\n-    public Object predecessor()\n-    {\n-        return predecessor(0);\n+    public DescendingVisitor(final JavaClass clazz, final Visitor visitor) {\n+        this.clazz = clazz;\n+        this.visitor = visitor;\n@@ -46,13 +48,2 @@\n-    \/**\n-     * @param level\n-     *            nesting level, i.e., 0 returns the direct predecessor\n-     * @return container of current entitity, i.e., predecessor during traversal\n-     *\/\n-    public Object predecessor(final int level)\n-    {\n-        final int size = stack.size();\n-        if ((size < 2) || (level < 0))\n-        {\n-            return null;\n-        }\n-        return stack.elementAt(size - (level + 2)); \/\/ size - 1 == current\n+    private <E extends Node> void accept(final E[] node) {\n+        Stream.of(node).forEach(e -> e.accept(this));\n@@ -64,2 +55,1 @@\n-    public Object current()\n-    {\n+    public Object current() {\n@@ -70,4 +60,1 @@\n-     * @param clazz\n-     *            Class to traverse\n-     * @param visitor\n-     *            visitor object to apply to all components\n+     * @return container of current entitity, i.e., predecessor during traversal\n@@ -75,4 +62,14 @@\n-    public DescendingVisitor(final JavaClass clazz, final Visitor visitor)\n-    {\n-        this.clazz = clazz;\n-        this.visitor = visitor;\n+    public Object predecessor() {\n+        return predecessor(0);\n+    }\n+\n+    \/**\n+     * @param level nesting level, i.e., 0 returns the direct predecessor\n+     * @return container of current entitity, i.e., predecessor during traversal\n+     *\/\n+    public Object predecessor(final int level) {\n+        final int size = stack.size();\n+        if (size < 2 || level < 0) {\n+            return null;\n+        }\n+        return stack.elementAt(size - (level + 2)); \/\/ size - 1 == current\n@@ -84,2 +81,1 @@\n-    public void visit()\n-    {\n+    public void visit() {\n@@ -89,0 +85,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -90,17 +89,4 @@\n-    public void visitJavaClass(final JavaClass _clazz)\n-    {\n-        stack.push(_clazz);\n-        _clazz.accept(visitor);\n-        final Field[] fields = _clazz.getFields();\n-        for (final Field field : fields) {\n-            field.accept(this);\n-        }\n-        final Method[] methods = _clazz.getMethods();\n-        for (final Method method : methods) {\n-            method.accept(this);\n-        }\n-        final Attribute[] attributes = _clazz.getAttributes();\n-        for (final Attribute attribute : attributes) {\n-            attribute.accept(this);\n-        }\n-        _clazz.getConstantPool().accept(this);\n+    public void visitAnnotation(final Annotations annotation) {\n+        stack.push(annotation);\n+        annotation.accept(visitor);\n+        accept(annotation.getAnnotationEntries());\n@@ -114,8 +100,3 @@\n-    public void visitAnnotation(final Annotations annotation)\n-    {\n-        stack.push(annotation);\n-        annotation.accept(visitor);\n-        final AnnotationEntry[] entries = annotation.getAnnotationEntries();\n-        for (final AnnotationEntry entrie : entries) {\n-            entrie.accept(this);\n-        }\n+    public void visitAnnotationDefault(final AnnotationDefault obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -129,2 +110,1 @@\n-    public void visitAnnotationEntry(final AnnotationEntry annotationEntry)\n-    {\n+    public void visitAnnotationEntry(final AnnotationEntry annotationEntry) {\n@@ -136,0 +116,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -137,8 +120,8 @@\n-    public void visitField(final Field field)\n-    {\n-        stack.push(field);\n-        field.accept(visitor);\n-        final Attribute[] attributes = field.getAttributes();\n-        for (final Attribute attribute : attributes) {\n-            attribute.accept(this);\n-        }\n+    public void visitBootstrapMethods(final BootstrapMethods bm) {\n+        stack.push(bm);\n+        bm.accept(visitor);\n+        \/\/ BootstrapMethod[] bms = bm.getBootstrapMethods();\n+        \/\/ for (int i = 0; i < bms.length; i++)\n+        \/\/ {\n+        \/\/ bms[i].accept(this);\n+        \/\/ }\n@@ -149,4 +132,5 @@\n-    public void visitConstantValue(final ConstantValue cv)\n-    {\n-        stack.push(cv);\n-        cv.accept(visitor);\n+    public void visitCode(final Code code) {\n+        stack.push(code);\n+        code.accept(visitor);\n+        accept(code.getExceptionTable());\n+        accept(code.getAttributes());\n@@ -157,8 +141,3 @@\n-    public void visitMethod(final Method method)\n-    {\n-        stack.push(method);\n-        method.accept(visitor);\n-        final Attribute[] attributes = method.getAttributes();\n-        for (final Attribute attribute : attributes) {\n-            attribute.accept(this);\n-        }\n+    public void visitCodeException(final CodeException ce) {\n+        stack.push(ce);\n+        ce.accept(visitor);\n@@ -169,4 +148,3 @@\n-    public void visitExceptionTable(final ExceptionTable table)\n-    {\n-        stack.push(table);\n-        table.accept(visitor);\n+    public void visitConstantClass(final ConstantClass constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -177,12 +155,3 @@\n-    public void visitCode(final Code code)\n-    {\n-        stack.push(code);\n-        code.accept(visitor);\n-        final CodeException[] table = code.getExceptionTable();\n-        for (final CodeException element : table) {\n-            element.accept(this);\n-        }\n-        final Attribute[] attributes = code.getAttributes();\n-        for (final Attribute attribute : attributes) {\n-            attribute.accept(this);\n-        }\n+    public void visitConstantDouble(final ConstantDouble constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -192,0 +161,1 @@\n+    \/** @since 6.3 *\/\n@@ -193,4 +163,3 @@\n-    public void visitCodeException(final CodeException ce)\n-    {\n-        stack.push(ce);\n-        ce.accept(visitor);\n+    public void visitConstantDynamic(final ConstantDynamic obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -201,8 +170,3 @@\n-    public void visitLineNumberTable(final LineNumberTable table)\n-    {\n-        stack.push(table);\n-        table.accept(visitor);\n-        final LineNumber[] numbers = table.getLineNumberTable();\n-        for (final LineNumber number : numbers) {\n-            number.accept(this);\n-        }\n+    public void visitConstantFieldref(final ConstantFieldref constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -213,4 +177,3 @@\n-    public void visitLineNumber(final LineNumber number)\n-    {\n-        stack.push(number);\n-        number.accept(visitor);\n+    public void visitConstantFloat(final ConstantFloat constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -221,8 +184,3 @@\n-    public void visitLocalVariableTable(final LocalVariableTable table)\n-    {\n-        stack.push(table);\n-        table.accept(visitor);\n-        final LocalVariable[] vars = table.getLocalVariableTable();\n-        for (final LocalVariable var : vars) {\n-            var.accept(this);\n-        }\n+    public void visitConstantInteger(final ConstantInteger constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -233,8 +191,3 @@\n-    public void visitStackMap(final StackMap table)\n-    {\n-        stack.push(table);\n-        table.accept(visitor);\n-        final StackMapEntry[] vars = table.getStackMap();\n-        for (final StackMapEntry var : vars) {\n-            var.accept(this);\n-        }\n+    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -244,0 +197,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -245,4 +201,3 @@\n-    public void visitStackMapEntry(final StackMapEntry var)\n-    {\n-        stack.push(var);\n-        var.accept(visitor);\n+    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -253,4 +208,3 @@\n-    public void visitLocalVariable(final LocalVariable var)\n-    {\n-        stack.push(var);\n-        var.accept(visitor);\n+    public void visitConstantLong(final ConstantLong constant) {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -260,0 +214,1 @@\n+    \/** @since 6.0 *\/\n@@ -261,12 +216,3 @@\n-    public void visitConstantPool(final ConstantPool cp)\n-    {\n-        stack.push(cp);\n-        cp.accept(visitor);\n-        final Constant[] constants = cp.getConstantPool();\n-        for (int i = 1; i < constants.length; i++)\n-        {\n-            if (constants[i] != null)\n-            {\n-                constants[i].accept(this);\n-            }\n-        }\n+    public void visitConstantMethodHandle(final ConstantMethodHandle obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -277,2 +223,1 @@\n-    public void visitConstantClass(final ConstantClass constant)\n-    {\n+    public void visitConstantMethodref(final ConstantMethodref constant) {\n@@ -284,0 +229,1 @@\n+    \/** @since 6.0 *\/\n@@ -285,4 +231,3 @@\n-    public void visitConstantDouble(final ConstantDouble constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitConstantMethodType(final ConstantMethodType obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -292,0 +237,1 @@\n+    \/** @since 6.1 *\/\n@@ -293,4 +239,3 @@\n-    public void visitConstantFieldref(final ConstantFieldref constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitConstantModule(final ConstantModule obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -301,2 +246,1 @@\n-    public void visitConstantFloat(final ConstantFloat constant)\n-    {\n+    public void visitConstantNameAndType(final ConstantNameAndType constant) {\n@@ -308,0 +252,1 @@\n+    \/** @since 6.1 *\/\n@@ -309,4 +254,3 @@\n-    public void visitConstantInteger(final ConstantInteger constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitConstantPackage(final ConstantPackage obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -317,5 +261,4 @@\n-    public void visitConstantInterfaceMethodref(\n-            final ConstantInterfaceMethodref constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitConstantPool(final ConstantPool cp) {\n+        stack.push(cp);\n+        cp.accept(visitor);\n+        Stream.of(cp.getConstantPool()).filter(Objects::nonNull).forEach(e -> e.accept(this));\n@@ -325,3 +268,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -329,3 +269,1 @@\n-    public void visitConstantInvokeDynamic(\n-            final ConstantInvokeDynamic constant)\n-    {\n+    public void visitConstantString(final ConstantString constant) {\n@@ -338,2 +276,1 @@\n-    public void visitConstantLong(final ConstantLong constant)\n-    {\n+    public void visitConstantUtf8(final ConstantUtf8 constant) {\n@@ -346,4 +283,3 @@\n-    public void visitConstantMethodref(final ConstantMethodref constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitConstantValue(final ConstantValue cv) {\n+        stack.push(cv);\n+        cv.accept(visitor);\n@@ -354,4 +290,3 @@\n-    public void visitConstantNameAndType(final ConstantNameAndType constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitDeprecated(final Deprecated attribute) {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -361,0 +296,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -362,4 +300,3 @@\n-    public void visitConstantString(final ConstantString constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitEnclosingMethod(final EnclosingMethod obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -370,4 +307,3 @@\n-    public void visitConstantUtf8(final ConstantUtf8 constant)\n-    {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitExceptionTable(final ExceptionTable table) {\n+        stack.push(table);\n+        table.accept(visitor);\n@@ -378,8 +314,4 @@\n-    public void visitInnerClasses(final InnerClasses ic)\n-    {\n-        stack.push(ic);\n-        ic.accept(visitor);\n-        final InnerClass[] ics = ic.getInnerClasses();\n-        for (final InnerClass ic2 : ics) {\n-            ic2.accept(this);\n-        }\n+    public void visitField(final Field field) {\n+        stack.push(field);\n+        field.accept(visitor);\n+        accept(field.getAttributes());\n@@ -390,2 +322,1 @@\n-    public void visitInnerClass(final InnerClass inner)\n-    {\n+    public void visitInnerClass(final InnerClass inner) {\n@@ -397,3 +328,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -401,9 +329,4 @@\n-    public void visitBootstrapMethods(final BootstrapMethods bm)\n-    {\n-        stack.push(bm);\n-        bm.accept(visitor);\n-        \/\/ BootstrapMethod[] bms = bm.getBootstrapMethods();\n-        \/\/ for (int i = 0; i < bms.length; i++)\n-        \/\/ {\n-        \/\/     bms[i].accept(this);\n-        \/\/ }\n+    public void visitInnerClasses(final InnerClasses ic) {\n+        stack.push(ic);\n+        ic.accept(visitor);\n+        accept(ic.getInnerClasses());\n@@ -414,4 +337,7 @@\n-    public void visitDeprecated(final Deprecated attribute)\n-    {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitJavaClass(final JavaClass clazz) {\n+        stack.push(clazz);\n+        clazz.accept(visitor);\n+        accept(clazz.getFields());\n+        accept(clazz.getMethods());\n+        accept(clazz.getAttributes());\n+        clazz.getConstantPool().accept(this);\n@@ -422,4 +348,3 @@\n-    public void visitSignature(final Signature attribute)\n-    {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitLineNumber(final LineNumber number) {\n+        stack.push(number);\n+        number.accept(visitor);\n@@ -430,4 +355,4 @@\n-    public void visitSourceFile(final SourceFile attribute)\n-    {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitLineNumberTable(final LineNumberTable table) {\n+        stack.push(table);\n+        table.accept(visitor);\n+        accept(table.getLineNumberTable());\n@@ -438,4 +363,3 @@\n-    public void visitSynthetic(final Synthetic attribute)\n-    {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitLocalVariable(final LocalVariable var) {\n+        stack.push(var);\n+        var.accept(visitor);\n@@ -446,4 +370,4 @@\n-    public void visitUnknown(final Unknown attribute)\n-    {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitLocalVariableTable(final LocalVariableTable table) {\n+        stack.push(table);\n+        table.accept(visitor);\n+        accept(table.getLocalVariableTable());\n@@ -457,2 +381,1 @@\n-    public void visitAnnotationDefault(final AnnotationDefault obj)\n-    {\n+    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj) {\n@@ -464,3 +387,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -468,4 +388,4 @@\n-    public void visitEnclosingMethod(final EnclosingMethod obj)\n-    {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitMethod(final Method method) {\n+        stack.push(method);\n+        method.accept(visitor);\n+        accept(method.getAttributes());\n@@ -476,1 +396,1 @@\n-     * @since 6.0\n+     * @since 6.4.0\n@@ -479,2 +399,1 @@\n-    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj)\n-    {\n+    public void visitMethodParameter(final MethodParameter obj) {\n@@ -490,2 +409,1 @@\n-    public void visitParameterAnnotation(final ParameterAnnotations obj)\n-    {\n+    public void visitMethodParameters(final MethodParameters obj) {\n@@ -494,0 +412,1 @@\n+        Stream.of(obj.getParameters()).forEach(e -> e.accept(this));\n@@ -497,3 +416,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -501,2 +418,1 @@\n-    public void visitMethodParameters(final MethodParameters obj)\n-    {\n+    public void visitModule(final Module obj) {\n@@ -505,4 +421,4 @@\n-        final MethodParameter[] table = obj.getParameters();\n-        for (final MethodParameter element : table) {\n-            element.accept(this);\n-        }\n+        accept(obj.getRequiresTable());\n+        accept(obj.getExportsTable());\n+        accept(obj.getOpensTable());\n+        accept(obj.getProvidesTable());\n@@ -512,3 +428,1 @@\n-    \/**\n-     * @since 6.4.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -516,2 +430,1 @@\n-    public void visitMethodParameter(final MethodParameter obj)\n-    {\n+    public void visitModuleExports(final ModuleExports obj) {\n@@ -523,1 +436,1 @@\n-    \/** @since 6.0 *\/\n+    \/** @since 6.4.0 *\/\n@@ -525,1 +438,1 @@\n-    public void visitConstantMethodType(final ConstantMethodType obj) {\n+    public void visitModuleMainClass(final ModuleMainClass obj) {\n@@ -531,1 +444,1 @@\n-    \/** @since 6.0 *\/\n+    \/** @since 6.4.0 *\/\n@@ -533,1 +446,1 @@\n-    public void visitConstantMethodHandle(final ConstantMethodHandle obj) {\n+    public void visitModuleOpens(final ModuleOpens obj) {\n@@ -539,1 +452,1 @@\n-    \/** @since 6.0 *\/\n+    \/** @since 6.4.0 *\/\n@@ -541,1 +454,1 @@\n-    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry obj) {\n+    public void visitModulePackages(final ModulePackages obj) {\n@@ -547,1 +460,1 @@\n-    \/** @since 6.1 *\/\n+    \/** @since 6.4.0 *\/\n@@ -549,1 +462,1 @@\n-    public void visitConstantPackage(final ConstantPackage obj) {\n+    public void visitModuleProvides(final ModuleProvides obj) {\n@@ -555,1 +468,1 @@\n-    \/** @since 6.1 *\/\n+    \/** @since 6.4.0 *\/\n@@ -557,1 +470,1 @@\n-    public void visitConstantModule(final ConstantModule obj) {\n+    public void visitModuleRequires(final ModuleRequires obj) {\n@@ -563,1 +476,1 @@\n-    \/** @since 6.3 *\/\n+    \/** @since 6.4.0 *\/\n@@ -565,1 +478,1 @@\n-    public void visitConstantDynamic(final ConstantDynamic obj) {\n+    public void visitNestHost(final NestHost obj) {\n@@ -573,1 +486,1 @@\n-    public void visitModule(final Module obj) {\n+    public void visitNestMembers(final NestMembers obj) {\n@@ -576,16 +489,0 @@\n-        final ModuleRequires[] rtable = obj.getRequiresTable();\n-        for (final ModuleRequires element : rtable) {\n-            element.accept(this);\n-        }\n-        final ModuleExports[] etable = obj.getExportsTable();\n-        for (final ModuleExports element : etable) {\n-            element.accept(this);\n-        }\n-        final ModuleOpens[] otable = obj.getOpensTable();\n-        for (final ModuleOpens element : otable) {\n-            element.accept(this);\n-        }\n-        final ModuleProvides[] ptable = obj.getProvidesTable();\n-        for (final ModuleProvides element : ptable) {\n-            element.accept(this);\n-        }\n@@ -595,1 +492,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -597,1 +496,1 @@\n-    public void visitModuleRequires(final ModuleRequires obj) {\n+    public void visitParameterAnnotation(final ParameterAnnotations obj) {\n@@ -603,1 +502,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.0 *\/\n@@ -605,1 +504,1 @@\n-    public void visitModuleExports(final ModuleExports obj) {\n+    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry obj) {\n@@ -611,1 +510,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -613,3 +511,3 @@\n-    public void visitModuleOpens(final ModuleOpens obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitSignature(final Signature attribute) {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -619,1 +517,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -621,3 +518,3 @@\n-    public void visitModuleProvides(final ModuleProvides obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitSourceFile(final SourceFile attribute) {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -627,1 +524,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -629,3 +525,4 @@\n-    public void visitModulePackages(final ModulePackages obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitStackMap(final StackMap table) {\n+        stack.push(table);\n+        table.accept(visitor);\n+        accept(table.getStackMap());\n@@ -635,1 +532,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -637,3 +533,3 @@\n-    public void visitModuleMainClass(final ModuleMainClass obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitStackMapEntry(final StackMapEntry var) {\n+        stack.push(var);\n+        var.accept(visitor);\n@@ -643,1 +539,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -645,3 +540,3 @@\n-    public void visitNestHost(final NestHost obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitSynthetic(final Synthetic attribute) {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -651,1 +546,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -653,3 +547,3 @@\n-    public void visitNestMembers(final NestMembers obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitUnknown(final Unknown attribute) {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/DescendingVisitor.java","additions":212,"deletions":318,"binary":false,"changes":530,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -28,0 +30,22 @@\n+ * The element_value structure is documented at https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/jvms-4.html#jvms-4.7.16.1\n+ *\n+ * <pre>\n+ * element_value {\n+ *    u1 tag;\n+ *    union {\n+ *        u2 const_value_index;\n+ *\n+ *        {   u2 type_name_index;\n+ *            u2 const_name_index;\n+ *        } enum_const_value;\n+ *\n+ *        u2 class_info_index;\n+ *\n+ *        annotation annotation_value;\n+ *\n+ *        {   u2            num_values;\n+ *            element_value values[num_values];\n+ *        } array_value;\n+ *    } value;\n+ *}\n+ *<\/pre>\n@@ -31,3 +55,15 @@\n-public abstract class ElementValue\n-{\n-    private final int type;\n+public abstract class ElementValue {\n+\n+    public static final byte STRING = 's';\n+    public static final byte ENUM_CONSTANT = 'e';\n+    public static final byte CLASS = 'c';\n+    public static final byte ANNOTATION = '@';\n+    public static final byte ARRAY = '[';\n+    public static final byte PRIMITIVE_INT = 'I';\n+    public static final byte PRIMITIVE_BYTE = 'B';\n+    public static final byte PRIMITIVE_CHAR = 'C';\n+    public static final byte PRIMITIVE_DOUBLE = 'D';\n+    public static final byte PRIMITIVE_FLOAT = 'F';\n+    public static final byte PRIMITIVE_LONG = 'J';\n+    public static final byte PRIMITIVE_SHORT = 'S';\n+    public static final byte PRIMITIVE_BOOLEAN = 'Z';\n@@ -35,1 +71,11 @@\n-    private final ConstantPool cpool;\n+    \/**\n+     * Reads an {@code element_value} as an {@code ElementValue}.\n+     *\n+     * @param input Raw data input.\n+     * @param cpool Constant pool.\n+     * @return a new ElementValue.\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool) throws IOException {\n+        return readElementValue(input, cpool, 0);\n+    }\n@@ -37,4 +83,51 @@\n-    @Override\n-    public String toString()\n-    {\n-        return stringifyValue();\n+    \/**\n+     * Reads an {@code element_value} as an {@code ElementValue}.\n+     *\n+     * @param input Raw data input.\n+     * @param cpool Constant pool.\n+     * @param arrayNesting level of current array nesting.\n+     * @return a new ElementValue.\n+     * @throws IOException if an I\/O error occurs.\n+     * @since 6.7.0\n+     *\/\n+    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool, int arrayNesting)\n+            throws IOException {\n+        final byte tag = input.readByte();\n+        switch (tag) {\n+        case PRIMITIVE_BYTE:\n+        case PRIMITIVE_CHAR:\n+        case PRIMITIVE_DOUBLE:\n+        case PRIMITIVE_FLOAT:\n+        case PRIMITIVE_INT:\n+        case PRIMITIVE_LONG:\n+        case PRIMITIVE_SHORT:\n+        case PRIMITIVE_BOOLEAN:\n+        case STRING:\n+            return new SimpleElementValue(tag, input.readUnsignedShort(), cpool);\n+\n+        case ENUM_CONSTANT:\n+            return new EnumElementValue(ENUM_CONSTANT, input.readUnsignedShort(), input.readUnsignedShort(), cpool);\n+\n+        case CLASS:\n+            return new ClassElementValue(CLASS, input.readUnsignedShort(), cpool);\n+\n+        case ANNOTATION:\n+            \/\/ TODO isRuntimeVisible\n+            return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(input, cpool, false), cpool);\n+\n+        case ARRAY:\n+            arrayNesting++;\n+            if (arrayNesting > Const.MAX_ARRAY_DIMENSIONS) {\n+                \/\/ JVM spec 4.4.1\n+                throw new ClassFormatException(String.format(\"Arrays are only valid if they represent %,d or fewer dimensions.\", Const.MAX_ARRAY_DIMENSIONS));\n+            }\n+            final int numArrayVals = input.readUnsignedShort();\n+            final ElementValue[] evalues = new ElementValue[numArrayVals];\n+            for (int j = 0; j < numArrayVals; j++) {\n+                evalues[j] = ElementValue.readElementValue(input, cpool, arrayNesting);\n+            }\n+            return new ArrayElementValue(ARRAY, evalues, cpool);\n+\n+        default:\n+            throw new ClassFormatException(\"Unexpected element value tag in annotation: \" + tag);\n+        }\n@@ -43,2 +136,12 @@\n-    protected ElementValue(final int type, final ConstantPool cpool)\n-    {\n+    \/**\n+     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n+     *\/\n+    @java.lang.Deprecated\n+    protected int type; \/\/ TODO should be final\n+    \/**\n+     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n+     *\/\n+    @java.lang.Deprecated\n+    protected ConstantPool cpool; \/\/ TODO should be final\n+\n+    protected ElementValue(final int type, final ConstantPool cpool) {\n@@ -49,7 +152,0 @@\n-    public int getElementValueType()\n-    {\n-        return type;\n-    }\n-\n-    public abstract String stringifyValue();\n-\n@@ -58,54 +154,0 @@\n-    public static final byte STRING            = 's';\n-    public static final byte ENUM_CONSTANT     = 'e';\n-    public static final byte CLASS             = 'c';\n-    public static final byte ANNOTATION        = '@';\n-    public static final byte ARRAY             = '[';\n-    public static final byte PRIMITIVE_INT     = 'I';\n-    public static final byte PRIMITIVE_BYTE    = 'B';\n-    public static final byte PRIMITIVE_CHAR    = 'C';\n-    public static final byte PRIMITIVE_DOUBLE  = 'D';\n-    public static final byte PRIMITIVE_FLOAT   = 'F';\n-    public static final byte PRIMITIVE_LONG    = 'J';\n-    public static final byte PRIMITIVE_SHORT   = 'S';\n-    public static final byte PRIMITIVE_BOOLEAN = 'Z';\n-\n-    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool) throws IOException\n-    {\n-        final byte type = input.readByte();\n-        switch (type)\n-        {\n-            case PRIMITIVE_BYTE:\n-            case PRIMITIVE_CHAR:\n-            case PRIMITIVE_DOUBLE:\n-            case PRIMITIVE_FLOAT:\n-            case PRIMITIVE_INT:\n-            case PRIMITIVE_LONG:\n-            case PRIMITIVE_SHORT:\n-            case PRIMITIVE_BOOLEAN:\n-            case STRING:\n-                return new SimpleElementValue(type, input.readUnsignedShort(), cpool);\n-\n-            case ENUM_CONSTANT:\n-                return new EnumElementValue(ENUM_CONSTANT, input.readUnsignedShort(), input.readUnsignedShort(), cpool);\n-\n-            case CLASS:\n-                return new ClassElementValue(CLASS, input.readUnsignedShort(), cpool);\n-\n-            case ANNOTATION:\n-                \/\/ TODO isRuntimeVisible\n-                return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(input, cpool, false), cpool);\n-\n-            case ARRAY:\n-                final int numArrayVals = input.readUnsignedShort();\n-                final ElementValue[] evalues = new ElementValue[numArrayVals];\n-                for (int j = 0; j < numArrayVals; j++)\n-                {\n-                    evalues[j] = ElementValue.readElementValue(input, cpool);\n-                }\n-                return new ArrayElementValue(ARRAY, evalues, cpool);\n-\n-            default:\n-                throw new IllegalArgumentException(\"Unexpected element value kind in annotation: \" + type);\n-        }\n-    }\n-\n@@ -117,0 +159,4 @@\n+    public int getElementValueType() {\n+        return type;\n+    }\n+\n@@ -122,2 +168,8 @@\n-    public String toShortString()\n-    {\n+    public abstract String stringifyValue();\n+\n+    public String toShortString() {\n+        return stringifyValue();\n+    }\n+\n+    @Override\n+    public String toString() {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ElementValue.java","additions":125,"deletions":73,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-\n@@ -30,1 +28,1 @@\n- * an annotation's element value pair\n+ * An annotation's element value pair.\n@@ -34,2 +32,4 @@\n-public class ElementValuePair\n-{\n+public class ElementValuePair {\n+\n+    static final ElementValuePair[] EMPTY_ARRAY = {};\n+\n@@ -42,3 +42,1 @@\n-    public ElementValuePair(final int elementNameIndex, final ElementValue elementValue,\n-            final ConstantPool constantPool)\n-    {\n+    public ElementValuePair(final int elementNameIndex, final ElementValue elementValue, final ConstantPool constantPool) {\n@@ -50,5 +48,3 @@\n-    public String getNameString()\n-    {\n-        final ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(\n-                elementNameIndex, Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+    protected void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(elementNameIndex); \/\/ u2 name of the element\n+        elementValue.dump(dos);\n@@ -57,3 +53,2 @@\n-    public final ElementValue getValue()\n-    {\n-        return elementValue;\n+    public int getNameIndex() {\n+        return elementNameIndex;\n@@ -62,3 +57,2 @@\n-    public int getNameIndex()\n-    {\n-        return elementNameIndex;\n+    public String getNameString() {\n+        return constantPool.getConstantUtf8(elementNameIndex).getBytes();\n@@ -67,6 +61,2 @@\n-    public String toShortString()\n-    {\n-        final StringBuilder result = new StringBuilder();\n-        result.append(getNameString()).append(\"=\").append(\n-                getValue().toShortString());\n-        return result.toString();\n+    public final ElementValue getValue() {\n+        return elementValue;\n@@ -75,3 +65,4 @@\n-    protected void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(elementNameIndex); \/\/ u2 name of the element\n-        elementValue.dump(dos);\n+    public String toShortString() {\n+        final StringBuilder result = new StringBuilder();\n+        result.append(getNameString()).append(\"=\").append(getValue().toShortString());\n+        return result.toString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ElementValuePair.java","additions":19,"deletions":28,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Visitor with empty method bodies, can be extended and used in conjunction\n- * with the DescendingVisitor class, e.g. By courtesy of David Spencer.\n+ * Visitor with empty method bodies, can be extended and used in conjunction with the DescendingVisitor class, e.g. By\n+ * courtesy of David Spencer.\n@@ -30,4 +30,2 @@\n-public class EmptyVisitor implements Visitor\n-{\n-    protected EmptyVisitor()\n-    {\n+public class EmptyVisitor implements Visitor {\n+    protected EmptyVisitor() {\n@@ -40,2 +38,1 @@\n-    public void visitAnnotation(final Annotations obj)\n-    {\n+    public void visitAnnotation(final Annotations obj) {\n@@ -48,2 +45,1 @@\n-    public void visitParameterAnnotation(final ParameterAnnotations obj)\n-    {\n+    public void visitAnnotationDefault(final AnnotationDefault obj) {\n@@ -56,2 +52,1 @@\n-    public void visitAnnotationEntry(final AnnotationEntry obj)\n-    {\n+    public void visitAnnotationEntry(final AnnotationEntry obj) {\n@@ -64,2 +59,1 @@\n-    public void visitAnnotationDefault(final AnnotationDefault obj)\n-    {\n+    public void visitBootstrapMethods(final BootstrapMethods obj) {\n@@ -69,2 +63,1 @@\n-    public void visitCode(final Code obj)\n-    {\n+    public void visitCode(final Code obj) {\n@@ -74,2 +67,1 @@\n-    public void visitCodeException(final CodeException obj)\n-    {\n+    public void visitCodeException(final CodeException obj) {\n@@ -79,2 +71,1 @@\n-    public void visitConstantClass(final ConstantClass obj)\n-    {\n+    public void visitConstantClass(final ConstantClass obj) {\n@@ -84,2 +75,1 @@\n-    public void visitConstantDouble(final ConstantDouble obj)\n-    {\n+    public void visitConstantDouble(final ConstantDouble obj) {\n@@ -88,0 +78,3 @@\n+    \/**\n+     * @since 6.3\n+     *\/\n@@ -89,2 +82,1 @@\n-    public void visitConstantFieldref(final ConstantFieldref obj)\n-    {\n+    public void visitConstantDynamic(final ConstantDynamic obj) {\n@@ -94,2 +86,1 @@\n-    public void visitConstantFloat(final ConstantFloat obj)\n-    {\n+    public void visitConstantFieldref(final ConstantFieldref obj) {\n@@ -99,2 +90,1 @@\n-    public void visitConstantInteger(final ConstantInteger obj)\n-    {\n+    public void visitConstantFloat(final ConstantFloat obj) {\n@@ -104,2 +94,1 @@\n-    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj)\n-    {\n+    public void visitConstantInteger(final ConstantInteger obj) {\n@@ -109,2 +98,1 @@\n-    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic obj)\n-    {\n+    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj) {\n@@ -114,2 +102,1 @@\n-    public void visitConstantLong(final ConstantLong obj)\n-    {\n+    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic obj) {\n@@ -119,2 +106,1 @@\n-    public void visitConstantMethodref(final ConstantMethodref obj)\n-    {\n+    public void visitConstantLong(final ConstantLong obj) {\n@@ -123,0 +109,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -124,2 +113,5 @@\n-    public void visitConstantNameAndType(final ConstantNameAndType obj)\n-    {\n+    public void visitConstantMethodHandle(final ConstantMethodHandle constantMethodHandle) {\n+    }\n+\n+    @Override\n+    public void visitConstantMethodref(final ConstantMethodref obj) {\n@@ -128,0 +120,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -129,2 +124,1 @@\n-    public void visitConstantPool(final ConstantPool obj)\n-    {\n+    public void visitConstantMethodType(final ConstantMethodType obj) {\n@@ -133,0 +127,3 @@\n+    \/**\n+     * @since 6.1\n+     *\/\n@@ -134,2 +131,1 @@\n-    public void visitConstantString(final ConstantString obj)\n-    {\n+    public void visitConstantModule(final ConstantModule constantModule) {\n@@ -139,2 +135,1 @@\n-    public void visitConstantUtf8(final ConstantUtf8 obj)\n-    {\n+    public void visitConstantNameAndType(final ConstantNameAndType obj) {\n@@ -143,0 +138,3 @@\n+    \/**\n+     * @since 6.1\n+     *\/\n@@ -144,2 +142,1 @@\n-    public void visitConstantValue(final ConstantValue obj)\n-    {\n+    public void visitConstantPackage(final ConstantPackage constantPackage) {\n@@ -149,2 +146,1 @@\n-    public void visitDeprecated(final Deprecated obj)\n-    {\n+    public void visitConstantPool(final ConstantPool obj) {\n@@ -154,2 +150,1 @@\n-    public void visitExceptionTable(final ExceptionTable obj)\n-    {\n+    public void visitConstantString(final ConstantString obj) {\n@@ -159,2 +154,1 @@\n-    public void visitField(final Field obj)\n-    {\n+    public void visitConstantUtf8(final ConstantUtf8 obj) {\n@@ -164,2 +158,1 @@\n-    public void visitInnerClass(final InnerClass obj)\n-    {\n+    public void visitConstantValue(final ConstantValue obj) {\n@@ -169,2 +162,1 @@\n-    public void visitInnerClasses(final InnerClasses obj)\n-    {\n+    public void visitDeprecated(final Deprecated obj) {\n@@ -177,7 +169,1 @@\n-    public void visitBootstrapMethods(final BootstrapMethods obj)\n-    {\n-    }\n-\n-    @Override\n-    public void visitJavaClass(final JavaClass obj)\n-    {\n+    public void visitEnclosingMethod(final EnclosingMethod obj) {\n@@ -187,2 +173,1 @@\n-    public void visitLineNumber(final LineNumber obj)\n-    {\n+    public void visitExceptionTable(final ExceptionTable obj) {\n@@ -192,2 +177,1 @@\n-    public void visitLineNumberTable(final LineNumberTable obj)\n-    {\n+    public void visitField(final Field obj) {\n@@ -197,2 +181,1 @@\n-    public void visitLocalVariable(final LocalVariable obj)\n-    {\n+    public void visitInnerClass(final InnerClass obj) {\n@@ -202,2 +185,1 @@\n-    public void visitLocalVariableTable(final LocalVariableTable obj)\n-    {\n+    public void visitInnerClasses(final InnerClasses obj) {\n@@ -207,2 +189,1 @@\n-    public void visitMethod(final Method obj)\n-    {\n+    public void visitJavaClass(final JavaClass obj) {\n@@ -212,2 +193,1 @@\n-    public void visitSignature(final Signature obj)\n-    {\n+    public void visitLineNumber(final LineNumber obj) {\n@@ -217,2 +197,1 @@\n-    public void visitSourceFile(final SourceFile obj)\n-    {\n+    public void visitLineNumberTable(final LineNumberTable obj) {\n@@ -222,2 +201,1 @@\n-    public void visitSynthetic(final Synthetic obj)\n-    {\n+    public void visitLocalVariable(final LocalVariable obj) {\n@@ -227,2 +205,1 @@\n-    public void visitUnknown(final Unknown obj)\n-    {\n+    public void visitLocalVariableTable(final LocalVariableTable obj) {\n@@ -231,0 +208,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -232,2 +212,1 @@\n-    public void visitStackMap(final StackMap obj)\n-    {\n+    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj) {\n@@ -237,2 +216,1 @@\n-    public void visitStackMapEntry(final StackMapEntry obj)\n-    {\n+    public void visitMethod(final Method obj) {\n@@ -243,4 +221,1 @@\n-    @Override\n-    public void visitStackMapTable(StackMapTable obj)\n-    {\n-    }\n+     * @Override public void visitStackMapTable(StackMapTable obj) { }\n@@ -251,4 +226,1 @@\n-    @Override\n-    public void visitStackMapTableEntry(StackMapTableEntry obj)\n-    {\n-    }\n+     * @Override public void visitStackMapTableEntry(StackMapTableEntry obj) { }\n@@ -258,1 +230,1 @@\n-     * @since 6.0\n+     * @since 6.4.0\n@@ -261,2 +233,1 @@\n-    public void visitEnclosingMethod(final EnclosingMethod obj)\n-    {\n+    public void visitMethodParameter(final MethodParameter obj) {\n@@ -269,2 +240,1 @@\n-    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj)\n-    {\n+    public void visitMethodParameters(final MethodParameters obj) {\n@@ -273,3 +243,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -277,2 +245,1 @@\n-    public void visitMethodParameters(final MethodParameters obj)\n-    {\n+    public void visitModule(final Module obj) {\n@@ -281,3 +248,1 @@\n-    \/**\n-     * @since 6.4.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -285,2 +250,1 @@\n-    public void visitMethodParameter(final MethodParameter obj)\n-    {\n+    public void visitModuleExports(final ModuleExports obj) {\n@@ -289,3 +253,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -293,2 +255,1 @@\n-    public void visitConstantMethodType(final ConstantMethodType obj)\n-    {\n+    public void visitModuleMainClass(final ModuleMainClass obj) {\n@@ -297,3 +258,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -301,1 +260,1 @@\n-    public void visitConstantMethodHandle(final ConstantMethodHandle constantMethodHandle) {\n+    public void visitModuleOpens(final ModuleOpens obj) {\n@@ -304,3 +263,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -308,1 +265,1 @@\n-    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry parameterAnnotationEntry) {\n+    public void visitModulePackages(final ModulePackages obj) {\n@@ -311,3 +268,1 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -315,1 +270,1 @@\n-    public void visitConstantPackage(final ConstantPackage constantPackage) {\n+    public void visitModuleProvides(final ModuleProvides obj) {\n@@ -318,3 +273,1 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -322,1 +275,1 @@\n-    public void visitConstantModule(final ConstantModule constantModule) {\n+    public void visitModuleRequires(final ModuleRequires obj) {\n@@ -325,3 +278,1 @@\n-    \/**\n-     * @since 6.3\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -329,1 +280,1 @@\n-    public void visitConstantDynamic(final ConstantDynamic obj) {\n+    public void visitNestHost(final NestHost obj) {\n@@ -334,1 +285,1 @@\n-    public void visitModule(final Module obj) {\n+    public void visitNestMembers(final NestMembers obj) {\n@@ -337,1 +288,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -339,1 +292,1 @@\n-    public void visitModuleRequires(final ModuleRequires obj) {\n+    public void visitParameterAnnotation(final ParameterAnnotations obj) {\n@@ -342,1 +295,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -344,1 +299,1 @@\n-    public void visitModuleExports(final ModuleExports obj) {\n+    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry parameterAnnotationEntry) {\n@@ -347,1 +302,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -349,1 +303,1 @@\n-    public void visitModuleOpens(final ModuleOpens obj) {\n+    public void visitSignature(final Signature obj) {\n@@ -352,1 +306,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -354,1 +307,1 @@\n-    public void visitModuleProvides(final ModuleProvides obj) {\n+    public void visitSourceFile(final SourceFile obj) {\n@@ -357,1 +310,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -359,1 +311,1 @@\n-    public void visitModulePackages(final ModulePackages obj) {\n+    public void visitStackMap(final StackMap obj) {\n@@ -362,1 +314,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -364,1 +315,1 @@\n-    public void visitModuleMainClass(final ModuleMainClass obj) {\n+    public void visitStackMapEntry(final StackMapEntry obj) {\n@@ -367,1 +318,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -369,1 +319,1 @@\n-    public void visitNestHost(final NestHost obj) {\n+    public void visitSynthetic(final Synthetic obj) {\n@@ -372,1 +322,0 @@\n-    \/** @since 6.4.0 *\/\n@@ -374,1 +323,1 @@\n-    public void visitNestMembers(final NestMembers obj) {\n+    public void visitUnknown(final Unknown obj) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EmptyVisitor.java","additions":99,"deletions":150,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +32,1 @@\n- * This attribute exists for local or\n- * anonymous classes and ... there can be only one.\n+ * This attribute exists for local or anonymous classes and ... there can be only one.\n@@ -44,1 +44,1 @@\n-    \/\/ Otherwise, the value of the  method_index item must point to a\n+    \/\/ Otherwise, the value of the method_index item must point to a\n@@ -47,1 +47,1 @@\n-    \/\/ to in the class_index.  *It is the compiler responsibility* to\n+    \/\/ to in the class_index. *It is the compiler responsibility* to\n@@ -57,4 +57,4 @@\n-    private EnclosingMethod(final int nameIndex, final int len, final int classIdx,final int methodIdx, final ConstantPool cpool) {\n-        super(Const.ATTR_ENCLOSING_METHOD, nameIndex, len, cpool);\n-        classIndex  = classIdx;\n-        methodIndex = methodIdx;\n+    private EnclosingMethod(final int nameIndex, final int len, final int classIndex, final int methodIndex, final ConstantPool cpool) {\n+        super(Const.ATTR_ENCLOSING_METHOD, nameIndex, Args.require(len, 4, \"EnclosingMethod attribute length\"), cpool);\n+        this.classIndex = Args.requireU2(classIndex, 0, cpool.getLength(), \"EnclosingMethod class index\");\n+        this.methodIndex = Args.requireU2(methodIndex, \"EnclosingMethod method index\");\n@@ -65,1 +65,1 @@\n-      v.visitEnclosingMethod(this);\n+        v.visitEnclosingMethod(this);\n@@ -69,1 +69,1 @@\n-    public Attribute copy(final ConstantPool constant_pool) {\n+    public Attribute copy(final ConstantPool constantPool) {\n@@ -73,0 +73,11 @@\n+    @Override\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        super.dump(file);\n+        file.writeShort(classIndex);\n+        file.writeShort(methodIndex);\n+    }\n+\n+    public final ConstantClass getEnclosingClass() {\n+        return super.getConstantPool().getConstant(classIndex, Const.CONSTANT_Class, ConstantClass.class);\n+    }\n+\n@@ -78,0 +89,7 @@\n+    public final ConstantNameAndType getEnclosingMethod() {\n+        if (methodIndex == 0) {\n+            return null;\n+        }\n+        return super.getConstantPool().getConstant(methodIndex, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n+    }\n+\n@@ -89,22 +107,0 @@\n-\n-    public final ConstantClass getEnclosingClass() {\n-        final ConstantClass c =\n-            (ConstantClass)super.getConstantPool().getConstant(classIndex,Const.CONSTANT_Class);\n-        return c;\n-    }\n-\n-    public final ConstantNameAndType getEnclosingMethod() {\n-        if (methodIndex == 0) {\n-            return null;\n-        }\n-        final ConstantNameAndType nat =\n-            (ConstantNameAndType)super.getConstantPool().getConstant(methodIndex,Const.CONSTANT_NameAndType);\n-        return nat;\n-    }\n-\n-    @Override\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        super.dump(file);\n-        file.writeShort(classIndex);\n-        file.writeShort(methodIndex);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EnclosingMethod.java","additions":28,"deletions":32,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-\n@@ -32,2 +30,1 @@\n-public class EnumElementValue extends ElementValue\n-{\n+public class EnumElementValue extends ElementValue {\n@@ -39,3 +36,1 @@\n-    public EnumElementValue(final int type, final int typeIdx, final int valueIdx,\n-            final ConstantPool cpool)\n-    {\n+    public EnumElementValue(final int type, final int typeIdx, final int valueIdx, final ConstantPool cpool) {\n@@ -44,2 +39,1 @@\n-            throw new IllegalArgumentException(\n-                    \"Only element values of type enum can be built with this ctor - type specified: \" + type);\n+            throw new ClassFormatException(\"Only element values of type enum can be built with this ctor - type specified: \" + type);\n@@ -52,2 +46,1 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n+    public void dump(final DataOutputStream dos) throws IOException {\n@@ -59,6 +52,2 @@\n-    @Override\n-    public String stringifyValue()\n-    {\n-        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(valueIdx,\n-                Const.CONSTANT_Utf8);\n-        return cu8.getBytes();\n+    public String getEnumTypeString() {\n+        return super.getConstantPool().getConstantUtf8(typeIdx).getBytes();\n@@ -67,5 +56,2 @@\n-    public String getEnumTypeString()\n-    {\n-        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(typeIdx,\n-                Const.CONSTANT_Utf8);\n-        return cu8.getBytes();\/\/ Utility.signatureToString(cu8.getBytes());\n+    public String getEnumValueString() {\n+        return super.getConstantPool().getConstantUtf8(valueIdx).getBytes();\n@@ -74,5 +60,2 @@\n-    public String getEnumValueString()\n-    {\n-        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(valueIdx,\n-                Const.CONSTANT_Utf8);\n-        return cu8.getBytes();\n+    public int getTypeIndex() {\n+        return typeIdx;\n@@ -81,2 +64,1 @@\n-    public int getValueIndex()\n-    {\n+    public int getValueIndex() {\n@@ -86,3 +68,3 @@\n-    public int getTypeIndex()\n-    {\n-        return typeIdx;\n+    @Override\n+    public String stringifyValue() {\n+        return super.getConstantPool().getConstantUtf8(valueIdx).getBytes();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EnumElementValue.java","additions":14,"deletions":32,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +26,1 @@\n+import java.util.Arrays;\n@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,6 +32,4 @@\n- * This class represents the table of exceptions that are thrown by a\n- * method. This attribute may be used once per method.  The name of\n- * this class is <em>ExceptionTable<\/em> for historical reasons; The\n- * Java Virtual Machine Specification, Second Edition defines this\n- * attribute using the name <em>Exceptions<\/em> (which is inconsistent\n- * with the other classes).\n+ * This class represents the table of exceptions that are thrown by a method. This attribute may be used once per\n+ * method. The name of this class is <em>ExceptionTable<\/em> for historical reasons; The Java Virtual Machine\n+ * Specification, Second Edition defines this attribute using the name <em>Exceptions<\/em> (which is inconsistent with\n+ * the other classes).\n@@ -38,1 +37,10 @@\n- * @see     Code\n+ * <pre>\n+ * Exceptions_attribute {\n+ *   u2 attribute_name_index;\n+ *   u4 attribute_length;\n+ *   u2 number_of_exceptions;\n+ *   u2 exception_index_table[number_of_exceptions];\n+ * }\n+ * <\/pre>\n+ * @see Code\n+ * @LastModified: Feb 2023\n@@ -44,1 +52,0 @@\n-\n@@ -46,2 +53,4 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -53,14 +62,0 @@\n-\n-    \/**\n-     * @param name_index Index in constant pool\n-     * @param length Content length in bytes\n-     * @param exceptionIndexTable Table of indices in constant pool\n-     * @param constant_pool Array of constants\n-     *\/\n-    public ExceptionTable(final int name_index, final int length, final int[] exceptionIndexTable,\n-            final ConstantPool constant_pool) {\n-        super(Const.ATTR_EXCEPTIONS, name_index, length, constant_pool);\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : new int[0];\n-    }\n-\n-\n@@ -69,0 +64,1 @@\n+     *\n@@ -73,1 +69,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -77,3 +73,3 @@\n-        final int number_of_exceptions = input.readUnsignedShort();\n-        exceptionIndexTable = new int[number_of_exceptions];\n-        for (int i = 0; i < number_of_exceptions; i++) {\n+        final int exceptionCount = input.readUnsignedShort();\n+        exceptionIndexTable = new int[exceptionCount];\n+        for (int i = 0; i < exceptionCount; i++) {\n@@ -84,0 +80,11 @@\n+    \/**\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param exceptionIndexTable Table of indices in constant pool\n+     * @param constantPool Array of constants\n+     *\/\n+    public ExceptionTable(final int nameIndex, final int length, final int[] exceptionIndexTable, final ConstantPool constantPool) {\n+        super(Const.ATTR_EXCEPTIONS, nameIndex, length, constantPool);\n+        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n+        Args.requireU2(this.exceptionIndexTable.length, \"exceptionIndexTable.length\");\n+    }\n@@ -86,3 +93,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -93,1 +99,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -97,0 +103,12 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final ExceptionTable c = (ExceptionTable) clone();\n+        if (exceptionIndexTable != null) {\n+            c.exceptionIndexTable = exceptionIndexTable.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -102,1 +120,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -105,1 +123,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -113,1 +131,0 @@\n-\n@@ -121,9 +138,0 @@\n-\n-    \/**\n-     * @return Length of exception table.\n-     *\/\n-    public int getNumberOfExceptions() {\n-        return exceptionIndexTable == null ? 0 : exceptionIndexTable.length;\n-    }\n-\n-\n@@ -135,4 +143,1 @@\n-        for (int i = 0; i < exceptionIndexTable.length; i++) {\n-            names[i] = super.getConstantPool().getConstantString(exceptionIndexTable[i],\n-                    Const.CONSTANT_Class).replace('\/', '.');\n-        }\n+        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(exceptionIndexTable[i], Const.CONSTANT_Class)));\n@@ -142,1 +147,0 @@\n-\n@@ -144,2 +148,1 @@\n-     * @param exceptionIndexTable the list of exception indexes\n-     * Also redefines number_of_exceptions according to table length.\n+     * @return Length of exception table.\n@@ -147,2 +150,2 @@\n-    public void setExceptionIndexTable( final int[] exceptionIndexTable ) {\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : new int[0];\n+    public int getNumberOfExceptions() {\n+        return exceptionIndexTable == null ? 0 : exceptionIndexTable.length;\n@@ -151,0 +154,7 @@\n+    \/**\n+     * @param exceptionIndexTable the list of exception indexes Also redefines number_of_exceptions according to table\n+     *        length.\n+     *\/\n+    public void setExceptionIndexTable(final int[] exceptionIndexTable) {\n+        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n+    }\n@@ -169,16 +179,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final ExceptionTable c = (ExceptionTable) clone();\n-        if (exceptionIndexTable != null) {\n-            c.exceptionIndexTable = new int[exceptionIndexTable.length];\n-            System.arraycopy(exceptionIndexTable, 0, c.exceptionIndexTable, 0,\n-                    exceptionIndexTable.length);\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ExceptionTable.java","additions":65,"deletions":71,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -33,3 +33,2 @@\n- * This class represents the field info structure, i.e., the representation\n- * for a variable in the class. See JVM specification for details.\n- *\n+ * This class represents the field info structure, i.e., the representation for a variable in the class. See JVM\n+ * specification for details.\n@@ -39,0 +38,7 @@\n+    \/**\n+     * Empty array constant.\n+     *\n+     * @since 6.6.0\n+     *\/\n+    public static final Field[] EMPTY_ARRAY = {};\n+\n@@ -42,1 +48,1 @@\n-        public boolean equals( final Object o1, final Object o2 ) {\n+        public boolean equals(final Object o1, final Object o2) {\n@@ -45,2 +51,1 @@\n-            return Objects.equals(THIS.getName(), THAT.getName())\n-                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -49,1 +54,0 @@\n-\n@@ -51,1 +55,1 @@\n-        public int hashCode( final Object o ) {\n+        public int hashCode(final Object o) {\n@@ -57,0 +61,4 @@\n+    \/**\n+     * Empty array.\n+     *\/\n+    static final Field[] EMPTY_FIELD_ARRAY = {};\n@@ -59,2 +67,1 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * @return Comparison strategy object\n@@ -62,2 +69,2 @@\n-    public Field(final Field c) {\n-        super(c);\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -66,0 +73,6 @@\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator(final BCELComparator comparator) {\n+        bcelComparator = comparator;\n+    }\n@@ -69,0 +82,1 @@\n+     *\n@@ -71,3 +85,2 @@\n-    Field(final DataInput file, final ConstantPool constant_pool) throws IOException,\n-            ClassFormatException {\n-        super(file, constant_pool);\n+    Field(final DataInput file, final ConstantPool constantPool) throws IOException, ClassFormatException {\n+        super(file, constantPool);\n@@ -76,0 +89,9 @@\n+    \/**\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n+     *\/\n+    public Field(final Field c) {\n+        super(c);\n+    }\n@@ -78,3 +100,3 @@\n-     * @param access_flags Access rights of field\n-     * @param name_index Points to field name in constant pool\n-     * @param signature_index Points to encoded signature\n+     * @param accessFlags Access rights of field\n+     * @param nameIndex Points to field name in constant pool\n+     * @param signatureIndex Points to encoded signature\n@@ -82,1 +104,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -84,3 +106,2 @@\n-    public Field(final int access_flags, final int name_index, final int signature_index, final Attribute[] attributes,\n-            final ConstantPool constant_pool) {\n-        super(access_flags, name_index, signature_index, attributes, constant_pool);\n+    public Field(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes, final ConstantPool constantPool) {\n+        super(accessFlags, nameIndex, signatureIndex, attributes, constantPool);\n@@ -89,1 +110,0 @@\n-\n@@ -91,3 +111,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -98,1 +117,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -102,0 +121,17 @@\n+    \/**\n+     * @return deep copy of this field\n+     *\/\n+    public Field copy(final ConstantPool constantPool) {\n+        return (Field) copy_(constantPool);\n+    }\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy. By default two Field objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see Object#equals(Object)\n+     *\/\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return bcelComparator.equals(this, obj);\n+    }\n@@ -115,0 +151,6 @@\n+    \/**\n+     * @return type of field\n+     *\/\n+    public Type getType() {\n+        return Type.getReturnType(getSignature());\n+    }\n@@ -117,2 +159,12 @@\n-     * Return string representation close to declaration format,\n-     * `public static final short MAX = 100', e.g..\n+     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n+     * signature.\n+     *\n+     * @see Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n+\n+    \/**\n+     * Return string representation close to declaration format, 'public static final short MAX = 100', e.g..\n@@ -130,1 +182,1 @@\n-        access = access.isEmpty() ? \"\" : (access + \" \");\n+        access = access.isEmpty() ? \"\" : access + \" \";\n@@ -146,57 +198,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this field\n-     *\/\n-    public Field copy( final ConstantPool _constant_pool ) {\n-        return (Field) copy_(_constant_pool);\n-    }\n-\n-\n-    \/**\n-     * @return type of field\n-     *\/\n-    public Type getType() {\n-        return Type.getReturnType(getSignature());\n-    }\n-\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator( final BCELComparator comparator ) {\n-        bcelComparator = comparator;\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default two Field objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see java.lang.Object#equals(java.lang.Object)\n-     *\/\n-    @Override\n-    public boolean equals( final Object obj ) {\n-        return bcelComparator.equals(this, obj);\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default return the hashcode of the field's name XOR signature.\n-     *\n-     * @see java.lang.Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Field.java","additions":82,"deletions":87,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n-\n-import com.sun.org.apache.bcel.internal.Const;\n+import java.util.Arrays;\n@@ -35,4 +34,24 @@\n-    private int name_index; \/\/ Points to field name in constant pool\n-    private int signature_index; \/\/ Points to encoded signature\n-    private Attribute[] attributes; \/\/ Collection of attributes\n-    private int attributes_count; \/\/ No. of attributes\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected int name_index; \/\/ Points to field name in constant pool\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected int signature_index; \/\/ Points to encoded signature\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected Attribute[] attributes; \/\/ Collection of attributes\n+\n+    \/**\n+     * @deprecated (since 6.0) will be removed (not needed)\n+     *\/\n+    @java.lang.Deprecated\n+    protected int attributes_count; \/\/ No. of attributes\n@@ -43,1 +62,5 @@\n-    private ConstantPool constant_pool;\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @java.lang.Deprecated\n+    protected ConstantPool constant_pool;\n@@ -45,2 +68,2 @@\n-    private String signatureAttributeString = null;\n-    private boolean searchedForSignatureAttribute = false;\n+    private String signatureAttributeString;\n+    private boolean searchedForSignatureAttribute;\n@@ -51,1 +74,0 @@\n-\n@@ -53,2 +75,4 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * Construct object from file stream.\n+     *\n+     * @param file Input stream\n+     * @throws IOException if an I\/O error occurs.\n@@ -56,3 +80,8 @@\n-    protected FieldOrMethod(final FieldOrMethod c) {\n-        this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(),\n-                c.getAttributes(), c.getConstantPool());\n+    protected FieldOrMethod(final DataInput file, final ConstantPool constantPool) throws IOException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null, constantPool);\n+        final int attributesCount = file.readUnsignedShort();\n+        attributes = new Attribute[attributesCount];\n+        for (int i = 0; i < attributesCount; i++) {\n+            attributes[i] = Attribute.readAttribute(file, constantPool);\n+        }\n+        this.attributes_count = attributesCount; \/\/ init deprecated field\n@@ -61,1 +90,0 @@\n-\n@@ -66,2 +94,1 @@\n-     * @throws IOException\n-     * @throws ClassFormatException\n+     * @throws IOException if an I\/O error occurs.\n@@ -71,4 +98,2 @@\n-    protected FieldOrMethod(final DataInputStream file, final ConstantPool constant_pool)\n-            throws IOException,\n-            ClassFormatException {\n-        this((DataInput) file, constant_pool);\n+    protected FieldOrMethod(final DataInputStream file, final ConstantPool constantPool) throws IOException {\n+        this((DataInput) file, constantPool);\n@@ -78,4 +103,4 @@\n-     * Construct object from file stream.\n-     * @param file Input stream\n-     * @throws IOException\n-     * @throws ClassFormatException\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -83,10 +108,2 @@\n-    protected FieldOrMethod(final DataInput file, final ConstantPool constant_pool)\n-            throws IOException, ClassFormatException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null,\n-                constant_pool);\n-        final int attributes_count = file.readUnsignedShort();\n-        attributes = new Attribute[attributes_count];\n-        for (int i = 0; i < attributes_count; i++) {\n-            attributes[i] = Attribute.readAttribute(file, constant_pool);\n-        }\n-        this.attributes_count = attributes_count; \/\/ init deprecated field\n+    protected FieldOrMethod(final FieldOrMethod c) {\n+        this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(), c.getAttributes(), c.getConstantPool());\n@@ -95,1 +112,0 @@\n-\n@@ -97,3 +113,3 @@\n-     * @param access_flags Access rights of method\n-     * @param name_index Points to field name in constant pool\n-     * @param signature_index Points to encoded signature\n+     * @param accessFlags Access rights of method\n+     * @param nameIndex Points to field name in constant pool\n+     * @param signatureIndex Points to encoded signature\n@@ -101,1 +117,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -103,6 +119,6 @@\n-    protected FieldOrMethod(final int access_flags, final int name_index, final int signature_index,\n-            final Attribute[] attributes, final ConstantPool constant_pool) {\n-        super(access_flags);\n-        this.name_index = name_index;\n-        this.signature_index = signature_index;\n-        this.constant_pool = constant_pool;\n+    protected FieldOrMethod(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes,\n+        final ConstantPool constantPool) {\n+        super(accessFlags);\n+        this.name_index = nameIndex;\n+        this.signature_index = signatureIndex;\n+        this.constant_pool = constantPool;\n@@ -112,0 +128,15 @@\n+    \/**\n+     * @return deep copy of this field\n+     *\/\n+    protected FieldOrMethod copy_(final ConstantPool constantPool) {\n+        try {\n+            final FieldOrMethod c = (FieldOrMethod) clone();\n+            c.constant_pool = constantPool;\n+            c.attributes = new Attribute[attributes.length];\n+            c.attributes_count = attributes_count; \/\/ init deprecated field\n+            Arrays.setAll(c.attributes, i -> attributes[i].copy(constantPool));\n+            return c;\n+        } catch (final CloneNotSupportedException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n@@ -117,1 +148,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -131,1 +162,0 @@\n-\n@@ -133,1 +163,2 @@\n-     * @return Collection of object attributes.\n+     * @return Annotations on the field or method\n+     * @since 6.0\n@@ -135,3 +166,4 @@\n-    public final Attribute[] getAttributes() {\n-        return attributes;\n-    }\n+    public AnnotationEntry[] getAnnotationEntries() {\n+        if (annotationEntries == null) {\n+            annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());\n+        }\n@@ -139,0 +171,2 @@\n+        return annotationEntries;\n+    }\n@@ -141,1 +175,1 @@\n-     * @param attributes Collection of object attributes.\n+     * @return Collection of object attributes.\n@@ -143,3 +177,2 @@\n-    public final void setAttributes( final Attribute[] attributes ) {\n-        this.attributes = attributes;\n-        this.attributes_count = attributes != null ? attributes.length : 0; \/\/ init deprecated field\n+    public final Attribute[] getAttributes() {\n+        return attributes;\n@@ -148,1 +181,0 @@\n-\n@@ -156,1 +188,0 @@\n-\n@@ -158,1 +189,5 @@\n-     * @param constant_pool Constant pool to be used for this object.\n+     * Hunts for a signature attribute on the member and returns its contents. So where the 'regular' signature may be\n+     * (Ljava\/util\/Vector;)V the signature attribute may in fact say 'Ljava\/lang\/Vector&lt;Ljava\/lang\/String&gt;;' Coded for\n+     * performance - searches for the attribute only when requested - only searches for it once.\n+     *\n+     * @since 6.0\n@@ -160,2 +195,12 @@\n-    public final void setConstantPool( final ConstantPool constant_pool ) {\n-        this.constant_pool = constant_pool;\n+    public final String getGenericSignature() {\n+        if (!searchedForSignatureAttribute) {\n+            boolean found = false;\n+            for (int i = 0; !found && i < attributes.length; i++) {\n+                if (attributes[i] instanceof Signature) {\n+                    signatureAttributeString = ((Signature) attributes[i]).getSignature();\n+                    found = true;\n+                }\n+            }\n+            searchedForSignatureAttribute = true;\n+        }\n+        return signatureAttributeString;\n@@ -164,0 +209,6 @@\n+    \/**\n+     * @return Name of object, i.e., method name or field name\n+     *\/\n+    public final String getName() {\n+        return constant_pool.getConstantUtf8(name_index).getBytes();\n+    }\n@@ -172,1 +223,0 @@\n-\n@@ -174,1 +224,1 @@\n-     * @param name_index Index in constant pool of object's name.\n+     * @return String representation of object's type signature (java style)\n@@ -176,2 +226,2 @@\n-    public final void setNameIndex( final int name_index ) {\n-        this.name_index = name_index;\n+    public final String getSignature() {\n+        return constant_pool.getConstantUtf8(signature_index).getBytes();\n@@ -180,1 +230,0 @@\n-\n@@ -188,9 +237,0 @@\n-\n-    \/**\n-     * @param signature_index Index in constant pool of field signature.\n-     *\/\n-    public final void setSignatureIndex( final int signature_index ) {\n-        this.signature_index = signature_index;\n-    }\n-\n-\n@@ -198,11 +238,1 @@\n-     * @return Name of object, i.e., method name or field name\n-     *\/\n-    public final String getName() {\n-        ConstantUtf8 c;\n-        c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n-        return c.getBytes();\n-    }\n-\n-\n-    \/**\n-     * @return String representation of object's type signature (java style)\n+     * @param attributes Collection of object attributes.\n@@ -210,4 +240,3 @@\n-    public final String getSignature() {\n-        ConstantUtf8 c;\n-        c = (ConstantUtf8) constant_pool.getConstant(signature_index, Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+    public final void setAttributes(final Attribute[] attributes) {\n+        this.attributes = attributes;\n+        this.attributes_count = attributes != null ? attributes.length : 0; \/\/ init deprecated field\n@@ -216,1 +245,0 @@\n-\n@@ -218,1 +246,1 @@\n-     * @return deep copy of this field\n+     * @param constantPool Constant pool to be used for this object.\n@@ -220,18 +248,2 @@\n-    protected FieldOrMethod copy_( final ConstantPool _constant_pool ) {\n-        FieldOrMethod c = null;\n-\n-        try {\n-          c = (FieldOrMethod)clone();\n-        } catch(final CloneNotSupportedException e) {\n-            \/\/ ignored, but will cause NPE ...\n-        }\n-\n-        c.constant_pool    = constant_pool;\n-        c.attributes       = new Attribute[attributes.length];\n-        c.attributes_count = attributes_count; \/\/ init deprecated field\n-\n-        for (int i = 0; i < attributes.length; i++) {\n-            c.attributes[i] = attributes[i].copy(constant_pool);\n-        }\n-\n-        return c;\n+    public final void setConstantPool(final ConstantPool constantPool) {\n+        this.constant_pool = constantPool;\n@@ -241,2 +253,1 @@\n-     * @return Annotations on the field or method\n-     * @since 6.0\n+     * @param nameIndex Index in constant pool of object's name.\n@@ -244,6 +255,2 @@\n-    public AnnotationEntry[] getAnnotationEntries() {\n-        if (annotationEntries == null) {\n-            annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());\n-        }\n-\n-        return annotationEntries;\n+    public final void setNameIndex(final int nameIndex) {\n+        this.name_index = nameIndex;\n@@ -253,8 +260,1 @@\n-     * Hunts for a signature attribute on the member and returns its contents.\n-     * So where the 'regular' signature may be (Ljava\/util\/Vector;)V the\n-     * signature attribute may in fact say\n-     * 'Ljava\/lang\/Vector&lt;Ljava\/lang\/String&gt;;' Coded for performance -\n-     * searches for the attribute only when requested - only searches for it\n-     * once.\n-     *\n-     * @since 6.0\n+     * @param signatureIndex Index in constant pool of field signature.\n@@ -262,17 +262,2 @@\n-    public final String getGenericSignature()\n-    {\n-        if (!searchedForSignatureAttribute)\n-        {\n-            boolean found = false;\n-            for (int i = 0; !found && i < attributes.length; i++)\n-            {\n-                if (attributes[i] instanceof Signature)\n-                {\n-                    signatureAttributeString = ((Signature) attributes[i])\n-                            .getSignature();\n-                    found = true;\n-                }\n-            }\n-            searchedForSignatureAttribute = true;\n-        }\n-        return signatureAttributeString;\n+    public final void setSignatureIndex(final int signatureIndex) {\n+        this.signature_index = signatureIndex;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/FieldOrMethod.java","additions":129,"deletions":144,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * This class represents a inner class attribute, i.e., the class\n- * indices of the inner and outer classes, the name and the attributes\n- * of the inner class.\n+ * This class represents a inner class attribute, i.e., the class indices of the inner and outer classes, the name and\n+ * the attributes of the inner class.\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * Initialize from another object.\n-     *\/\n-    public InnerClass(final InnerClass c) {\n-        this(c.getInnerClassIndex(), c.getOuterClassIndex(), c.getInnerNameIndex(), c\n-                .getInnerAccessFlags());\n-    }\n-\n-\n@@ -56,0 +45,1 @@\n+     *\n@@ -57,1 +47,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -60,2 +50,1 @@\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n-                .readUnsignedShort());\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort());\n@@ -64,0 +53,8 @@\n+    \/**\n+     * Initialize from another object.\n+     *\n+     * @param c Source to copy.\n+     *\/\n+    public InnerClass(final InnerClass c) {\n+        this(c.getInnerClassIndex(), c.getOuterClassIndex(), c.getInnerNameIndex(), c.getInnerAccessFlags());\n+    }\n@@ -68,1 +65,1 @@\n-     * @param innerNameIndex  Name index in constant pool of inner class\n+     * @param innerNameIndex Name index in constant pool of inner class\n@@ -71,2 +68,1 @@\n-    public InnerClass(final int innerClassIndex, final int outerClassIndex, final int innerNameIndex,\n-            final int innerAccessFlags) {\n+    public InnerClass(final int innerClassIndex, final int outerClassIndex, final int innerNameIndex, final int innerAccessFlags) {\n@@ -79,1 +75,0 @@\n-\n@@ -81,3 +76,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -88,1 +82,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -92,0 +86,11 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public InnerClass copy() {\n+        try {\n+            return (InnerClass) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n@@ -97,1 +102,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -99,1 +104,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -106,1 +111,0 @@\n-\n@@ -114,1 +118,0 @@\n-\n@@ -122,1 +125,0 @@\n-\n@@ -130,1 +132,0 @@\n-\n@@ -138,1 +139,0 @@\n-\n@@ -142,1 +142,1 @@\n-    public void setInnerAccessFlags( final int innerAccessFlags ) {\n+    public void setInnerAccessFlags(final int innerAccessFlags) {\n@@ -146,1 +146,0 @@\n-\n@@ -150,1 +149,1 @@\n-    public void setInnerClassIndex( final int innerClassIndex ) {\n+    public void setInnerClassIndex(final int innerClassIndex) {\n@@ -154,1 +153,0 @@\n-\n@@ -158,1 +156,1 @@\n-    public void setInnerNameIndex( final int innerNameIndex ) { \/\/ TODO unused\n+    public void setInnerNameIndex(final int innerNameIndex) { \/\/ TODO unused\n@@ -162,1 +160,0 @@\n-\n@@ -166,1 +163,1 @@\n-    public void setOuterClassIndex( final int outerClassIndex ) { \/\/ TODO unused\n+    public void setOuterClassIndex(final int outerClassIndex) { \/\/ TODO unused\n@@ -170,1 +167,0 @@\n-\n@@ -176,2 +172,1 @@\n-        return \"InnerClass(\" + innerClassIndex + \", \" + outerClassIndex + \", \"\n-                + innerNameIndex + \", \" + innerAccessFlags + \")\";\n+        return \"InnerClass(\" + innerClassIndex + \", \" + outerClassIndex + \", \" + innerNameIndex + \", \" + innerAccessFlags + \")\";\n@@ -180,1 +175,0 @@\n-\n@@ -184,6 +178,5 @@\n-    public String toString( final ConstantPool constantPool ) {\n-        String outer_class_name;\n-        String inner_name;\n-        String inner_class_name = constantPool.getConstantString(innerClassIndex,\n-                Const.CONSTANT_Class);\n-        inner_class_name = Utility.compactClassName(inner_class_name, false);\n+    public String toString(final ConstantPool constantPool) {\n+        String outerClassName;\n+        String innerName;\n+        String innerClassName = constantPool.getConstantString(innerClassIndex, Const.CONSTANT_Class);\n+        innerClassName = Utility.compactClassName(innerClassName, false);\n@@ -191,3 +184,2 @@\n-            outer_class_name = constantPool.getConstantString(outerClassIndex,\n-                    Const.CONSTANT_Class);\n-            outer_class_name = \" of class \" + Utility.compactClassName(outer_class_name, false);\n+            outerClassName = constantPool.getConstantString(outerClassIndex, Const.CONSTANT_Class);\n+            outerClassName = \" of class \" + Utility.compactClassName(outerClassName, false);\n@@ -195,1 +187,1 @@\n-            outer_class_name = \"\";\n+            outerClassName = \"\";\n@@ -198,2 +190,1 @@\n-            inner_name = ((ConstantUtf8) constantPool.getConstant(innerNameIndex,\n-                    Const.CONSTANT_Utf8)).getBytes();\n+            innerName = constantPool.getConstantUtf8(innerNameIndex).getBytes();\n@@ -201,1 +192,1 @@\n-            inner_name = \"(anonymous)\";\n+            innerName = \"(anonymous)\";\n@@ -204,15 +195,2 @@\n-        access = access.isEmpty() ? \"\" : (access + \" \");\n-        return \"  \" + access + inner_name + \"=class \" + inner_class_name + outer_class_name;\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public InnerClass copy() {\n-        try {\n-            return (InnerClass) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+        access = access.isEmpty() ? \"\" : access + \" \";\n+        return \"  \" + access + innerName + \"=class \" + innerClassName + outerClassName;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClass.java","additions":48,"deletions":70,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n@@ -29,0 +32,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,4 +35,2 @@\n- * This class is derived from <em>Attribute<\/em> and denotes that this class\n- * is an Inner class of another.\n- * to the source file of this class.\n- * It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and denotes that this class is an Inner class of another. to the source\n+ * file of this class. It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -36,1 +38,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -38,4 +40,1 @@\n-public final class InnerClasses extends Attribute {\n-\n-    private InnerClass[] innerClasses;\n-\n+public final class InnerClasses extends Attribute implements Iterable<InnerClass> {\n@@ -44,2 +43,1 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * Empty array.\n@@ -47,3 +45,1 @@\n-    public InnerClasses(final InnerClasses c) {\n-        this(c.getNameIndex(), c.getLength(), c.getInnerClasses(), c.getConstantPool());\n-    }\n+    private static final InnerClass[] EMPTY_INNER_CLASSE_ARRAY = {};\n@@ -51,0 +47,1 @@\n+    private InnerClass[] innerClasses;\n@@ -53,4 +50,4 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param innerClasses array of inner classes attributes\n-     * @param constant_pool Array of constants\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -58,4 +55,2 @@\n-    public InnerClasses(final int name_index, final int length, final InnerClass[] innerClasses,\n-            final ConstantPool constant_pool) {\n-        super(Const.ATTR_INNER_CLASSES, name_index, length, constant_pool);\n-        this.innerClasses = innerClasses != null ? innerClasses : new InnerClass[0];\n+    public InnerClasses(final InnerClasses c) {\n+        this(c.getNameIndex(), c.getLength(), c.getInnerClasses(), c.getConstantPool());\n@@ -64,1 +59,0 @@\n-\n@@ -68,1 +62,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -71,2 +65,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -74,6 +68,5 @@\n-    InnerClasses(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, (InnerClass[]) null, constant_pool);\n-        final int number_of_classes = input.readUnsignedShort();\n-        innerClasses = new InnerClass[number_of_classes];\n-        for (int i = 0; i < number_of_classes; i++) {\n+    InnerClasses(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (InnerClass[]) null, constantPool);\n+        final int classCount = input.readUnsignedShort();\n+        innerClasses = new InnerClass[classCount];\n+        for (int i = 0; i < classCount; i++) {\n@@ -84,0 +77,11 @@\n+    \/**\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param innerClasses array of inner classes attributes\n+     * @param constantPool Array of constants\n+     *\/\n+    public InnerClasses(final int nameIndex, final int length, final InnerClass[] innerClasses, final ConstantPool constantPool) {\n+        super(Const.ATTR_INNER_CLASSES, nameIndex, length, constantPool);\n+        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n+        Args.requireU2(this.innerClasses.length, \"innerClasses.length\");\n+    }\n@@ -86,3 +90,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -93,1 +96,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -97,0 +100,12 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        \/\/ TODO this could be recoded to use a lower level constructor after creating a copy of the inner classes\n+        final InnerClasses c = (InnerClasses) clone();\n+        c.innerClasses = new InnerClass[innerClasses.length];\n+        Arrays.setAll(c.innerClasses, i -> innerClasses[i].copy());\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -102,1 +117,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -105,1 +120,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -108,2 +123,2 @@\n-        for (final InnerClass inner_class : innerClasses) {\n-            inner_class.dump(file);\n+        for (final InnerClass innerClass : innerClasses) {\n+            innerClass.dump(file);\n@@ -113,1 +128,0 @@\n-\n@@ -121,0 +135,4 @@\n+    @Override\n+    public Iterator<InnerClass> iterator() {\n+        return Stream.of(innerClasses).iterator();\n+    }\n@@ -125,2 +143,2 @@\n-    public void setInnerClasses( final InnerClass[] innerClasses ) {\n-        this.innerClasses = innerClasses != null ? innerClasses : new InnerClass[0];\n+    public void setInnerClasses(final InnerClass[] innerClasses) {\n+        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n@@ -129,1 +147,0 @@\n-\n@@ -139,2 +156,2 @@\n-        for (final InnerClass inner_class : innerClasses) {\n-            buf.append(inner_class.toString(super.getConstantPool())).append(\"\\n\");\n+        for (final InnerClass innerClass : innerClasses) {\n+            buf.append(innerClass.toString(super.getConstantPool())).append(\"\\n\");\n@@ -142,17 +159,1 @@\n-        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        \/\/ TODO this could be recoded to use a lower level constructor after creating a copy of the inner classes\n-        final InnerClasses c = (InnerClasses) clone();\n-        c.innerClasses = new InnerClass[innerClasses.length];\n-        for (int i = 0; i < innerClasses.length; i++) {\n-            c.innerClasses[i] = innerClasses[i].copy();\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClasses.java","additions":64,"deletions":63,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,1 @@\n-import java.util.Objects;\n-import java.util.StringTokenizer;\n+import java.util.Arrays;\n@@ -32,0 +31,1 @@\n+import java.util.Objects;\n@@ -33,0 +33,1 @@\n+import java.util.StringTokenizer;\n@@ -42,7 +43,5 @@\n- * Represents a Java class, i.e., the data structures, constant pool,\n- * fields, methods and commands contained in a Java .class file.\n- * See <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\">JVM specification<\/a> for details.\n- * The intent of this class is to represent a parsed or otherwise existing\n- * class file.  Those interested in programatically generating classes\n- * should see the <a href=\"..\/generic\/ClassGen.html\">ClassGen<\/a> class.\n-\n+ * Represents a Java class, i.e., the data structures, constant pool, fields, methods and commands contained in a Java\n+ * .class file. See <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\">JVM specification<\/a> for details. The intent of\n+ * this class is to represent a parsed or otherwise existing class file. Those interested in programmatically generating\n+ * classes should see the <a href=\"..\/generic\/ClassGen.html\">ClassGen<\/a> class.\n+ *\n@@ -50,1 +49,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -54,0 +53,56 @@\n+    \/**\n+     * The standard class file extension.\n+     *\n+     * @since 6.7.0\n+     *\/\n+    public static final String EXTENSION = \".class\";\n+\n+    \/**\n+     * Empty array.\n+     *\n+     * @since 6.6.0\n+     *\/\n+    public static final JavaClass[] EMPTY_ARRAY = {};\n+\n+    public static final byte HEAP = 1;\n+    public static final byte FILE = 2;\n+    public static final byte ZIP = 3;\n+    private static BCELComparator bcelComparator = new BCELComparator() {\n+\n+        @Override\n+        public boolean equals(final Object o1, final Object o2) {\n+            final JavaClass THIS = (JavaClass) o1;\n+            final JavaClass THAT = (JavaClass) o2;\n+            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n+        }\n+\n+        @Override\n+        public int hashCode(final Object o) {\n+            final JavaClass THIS = (JavaClass) o;\n+            return THIS.getClassName().hashCode();\n+        }\n+    };\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+    private static String indent(final Object obj) {\n+        final StringTokenizer tokenizer = new StringTokenizer(obj.toString(), \"\\n\");\n+        final StringBuilder buf = new StringBuilder();\n+        while (tokenizer.hasMoreTokens()) {\n+            buf.append(\"\\t\").append(tokenizer.nextToken()).append(\"\\n\");\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator(final BCELComparator comparator) {\n+        bcelComparator = comparator;\n+    }\n+\n@@ -55,1 +110,1 @@\n-    private String packageName;\n+    private final String packageName;\n@@ -69,1 +124,2 @@\n-    private AnnotationEntry[] annotations;   \/\/ annotations defined on the class\n+\n+    private AnnotationEntry[] annotations; \/\/ annotations defined on the class\n@@ -71,7 +127,0 @@\n-    private boolean isAnonymous = false;\n-    private boolean isNested = false;\n-    private boolean computedNestedTypeStatus = false;\n-    public static final byte HEAP = 1;\n-    public static final byte FILE = 2;\n-    public static final byte ZIP = 3;\n-    private static final boolean debug = false;\n@@ -79,1 +128,1 @@\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n+    private boolean isAnonymous;\n@@ -81,6 +130,1 @@\n-        @Override\n-        public boolean equals( final Object o1, final Object o2 ) {\n-            final JavaClass THIS = (JavaClass) o1;\n-            final JavaClass THAT = (JavaClass) o2;\n-            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n-        }\n+    private boolean isNested;\n@@ -88,0 +132,1 @@\n+    private boolean computedNestedTypeStatus;\n@@ -89,6 +134,0 @@\n-        @Override\n-        public int hashCode( final Object o ) {\n-            final JavaClass THIS = (JavaClass) o;\n-            return THIS.getClassName().hashCode();\n-        }\n-    };\n@@ -96,3 +135,2 @@\n-     * In cases where we go ahead and create something,\n-     * use the default SyntheticRepository, because we\n-     * don't know any better.\n+     * In cases where we go ahead and create something, use the default SyntheticRepository, because we don't know any\n+     * better.\n@@ -100,2 +138,1 @@\n-    private transient com.sun.org.apache.bcel.internal.util.Repository repository\n-            = SyntheticRepository.getInstance();\n+    private transient com.sun.org.apache.bcel.internal.util.Repository repository = SyntheticRepository.getInstance();\n@@ -103,0 +140,19 @@\n+    \/**\n+     * Constructor gets all contents as arguments.\n+     *\n+     * @param classNameIndex Class name\n+     * @param superclassNameIndex Superclass name\n+     * @param fileName File name\n+     * @param major Major compiler version\n+     * @param minor Minor compiler version\n+     * @param accessFlags Access rights defined by bit flags\n+     * @param constantPool Array of constants\n+     * @param interfaces Implemented interfaces\n+     * @param fields Class fields\n+     * @param methods Class methods\n+     * @param attributes Class attributes\n+     *\/\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags,\n+        final ConstantPool constantPool, final int[] interfaces, final Field[] fields, final Method[] methods, final Attribute[] attributes) {\n+        this(classNameIndex, superclassNameIndex, fileName, major, minor, accessFlags, constantPool, interfaces, fields, methods, attributes, HEAP);\n+    }\n@@ -107,4 +163,3 @@\n-     * @param classNameIndex Index into constant pool referencing a\n-     * ConstantClass that represents this class.\n-     * @param superclassNameIndex Index into constant pool referencing a\n-     * ConstantClass that represents this class's superclass.\n+     * @param classNameIndex Index into constant pool referencing a ConstantClass that represents this class.\n+     * @param superclassNameIndex Index into constant pool referencing a ConstantClass that represents this class's\n+     *        superclass.\n@@ -114,1 +169,1 @@\n-     * @param access_flags Access rights defined by bit flags\n+     * @param accessFlags Access rights defined by bit flags\n@@ -122,5 +177,3 @@\n-    public JavaClass(final int classNameIndex, final int superclassNameIndex,\n-            final String fileName, final int major, final int minor, final int access_flags,\n-            final ConstantPool constantPool, int[] interfaces, Field[] fields,\n-            Method[] methods, Attribute[] attributes, final byte source) {\n-        super(access_flags);\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags,\n+        final ConstantPool constantPool, int[] interfaces, Field[] fields, Method[] methods, Attribute[] attributes, final byte source) {\n+        super(accessFlags);\n@@ -128,1 +181,1 @@\n-            interfaces = new int[0];\n+            interfaces = Const.EMPTY_INT_ARRAY;\n@@ -131,1 +184,1 @@\n-            attributes = new Attribute[0];\n+            attributes = Attribute.EMPTY_ARRAY;\n@@ -134,1 +187,1 @@\n-            fields = new Field[0];\n+            fields = Field.EMPTY_FIELD_ARRAY;\n@@ -137,1 +190,1 @@\n-            methods = new Method[0];\n+            methods = Method.EMPTY_METHOD_ARRAY;\n@@ -157,3 +210,3 @@\n-        \/* According to the specification the following entries must be of type\n-         * `ConstantClass' but we check that anyway via the\n-         * `ConstPool.getConstant' method.\n+        \/*\n+         * According to the specification the following entries must be of type 'ConstantClass' but we check that anyway via the\n+         * 'ConstPool.getConstant' method.\n@@ -171,2 +224,1 @@\n-            superclassName = constantPool.getConstantString(superclassNameIndex,\n-                    Const.CONSTANT_Class);\n+            superclassName = constantPool.getConstantString(superclassNameIndex, Const.CONSTANT_Class);\n@@ -184,1 +236,0 @@\n-\n@@ -186,1 +237,2 @@\n-     * Constructor gets all contents as arguments.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -188,11 +240,1 @@\n-     * @param classNameIndex Class name\n-     * @param superclassNameIndex Superclass name\n-     * @param fileName File name\n-     * @param major Major compiler version\n-     * @param minor Minor compiler version\n-     * @param access_flags Access rights defined by bit flags\n-     * @param constantPool Array of constants\n-     * @param interfaces Implemented interfaces\n-     * @param fields Class fields\n-     * @param methods Class methods\n-     * @param attributes Class attributes\n+     * @param v Visitor object\n@@ -200,6 +242,3 @@\n-    public JavaClass(final int classNameIndex, final int superclassNameIndex,\n-            final String fileName, final int major, final int minor, final int access_flags,\n-            final ConstantPool constantPool, final int[] interfaces, final Field[] fields,\n-            final Method[] methods, final Attribute[] attributes) {\n-        this(classNameIndex, superclassNameIndex, fileName, major, minor, access_flags,\n-                constantPool, interfaces, fields, methods, attributes, HEAP);\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitJavaClass(this);\n@@ -208,1 +247,0 @@\n-\n@@ -210,3 +248,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Return the natural ordering of two JavaClasses. This ordering is based on the class name\n@@ -214,1 +250,1 @@\n-     * @param v Visitor object\n+     * @since 6.0\n@@ -217,2 +253,2 @@\n-    public void accept( final Visitor v ) {\n-        v.visitJavaClass(this);\n+    public int compareTo(final JavaClass obj) {\n+        return getClassName().compareTo(obj.getClassName());\n@@ -221,6 +257,3 @@\n-\n-    \/* Print debug information depending on `JavaClass.debug'\n-     *\/\n-    static void Debug( final String str ) {\n-        if (debug) {\n-            System.out.println(str);\n+    private void computeNestedTypeStatus() {\n+        if (computedNestedTypeStatus) {\n+            return;\n@@ -228,17 +261,16 @@\n-    }\n-\n-\n-    \/**\n-     * Dump class to a file.\n-     *\n-     * @param file Output file\n-     * @throws IOException\n-     *\/\n-    public void dump(final File file) throws IOException {\n-        final String parent = file.getParent();\n-        if (parent != null) {\n-            final File dir = new File(parent);\n-            if (!dir.mkdirs()) { \/\/ either was not created or already existed\n-                if (!dir.isDirectory()) {\n-                    throw new IOException(\"Could not create the directory \" + dir);\n-                }\n+        for (final Attribute attribute : this.attributes) {\n+            if (attribute instanceof InnerClasses) {\n+                ((InnerClasses) attribute).forEach(innerClass ->  {\n+                    boolean innerClassAttributeRefersToMe = false;\n+                    String innerClassName = constantPool.getConstantString(innerClass.getInnerClassIndex(), Const.CONSTANT_Class);\n+                    innerClassName = Utility.compactClassName(innerClassName, false);\n+                    if (innerClassName.equals(getClassName())) {\n+                        innerClassAttributeRefersToMe = true;\n+                    }\n+                    if (innerClassAttributeRefersToMe) {\n+                        this.isNested = true;\n+                        if (innerClass.getInnerNameIndex() == 0) {\n+                            this.isAnonymous = true;\n+                        }\n+                    }\n+                });\n@@ -247,14 +279,1 @@\n-        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n-            dump(dos);\n-        }\n-    }\n-\n-\n-    \/**\n-     * Dump class to a file named fileName.\n-     *\n-     * @param _file_name Output file name\n-     * @throws IOException\n-     *\/\n-    public void dump( final String _file_name ) throws IOException {\n-        dump(new File(_file_name));\n+        this.computedNestedTypeStatus = true;\n@@ -263,1 +282,0 @@\n-\n@@ -265,1 +283,1 @@\n-     * @return class in binary format\n+     * @return deep copy of this class\n@@ -267,3 +285,1 @@\n-    public byte[] getBytes() {\n-        final ByteArrayOutputStream s = new ByteArrayOutputStream();\n-        final DataOutputStream ds = new DataOutputStream(s);\n+    public JavaClass copy() {\n@@ -271,9 +287,13 @@\n-            dump(ds);\n-        } catch (final IOException e) {\n-            System.err.println(\"Error dumping class: \" + e.getMessage());\n-        } finally {\n-            try {\n-                ds.close();\n-            } catch (final IOException e2) {\n-                System.err.println(\"Error dumping class: \" + e2.getMessage());\n-            }\n+            final JavaClass c = (JavaClass) clone();\n+            c.constantPool = constantPool.copy();\n+            c.interfaces = interfaces.clone();\n+            c.interfaceNames = interfaceNames.clone();\n+            c.fields = new Field[fields.length];\n+            Arrays.setAll(c.fields, i -> fields[i].copy(c.constantPool));\n+            c.methods = new Method[methods.length];\n+            Arrays.setAll(c.methods, i -> methods[i].copy(c.constantPool));\n+            c.attributes = new Attribute[attributes.length];\n+            Arrays.setAll(c.attributes, i -> attributes[i].copy(c.constantPool));\n+            return c;\n+        } catch (final CloneNotSupportedException e) {\n+            return null;\n@@ -281,1 +301,0 @@\n-        return s.toByteArray();\n@@ -284,12 +303,0 @@\n-\n-    \/**\n-     * Dump Java class to output stream in binary format.\n-     *\n-     * @param file Output stream\n-     * @throws IOException\n-     *\/\n-    public void dump( final OutputStream file ) throws IOException {\n-        dump(new DataOutputStream(file));\n-    }\n-\n-\n@@ -300,1 +307,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -302,1 +309,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -333,0 +340,38 @@\n+    \/**\n+     * Dump class to a file.\n+     *\n+     * @param file Output file\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    public void dump(final File file) throws IOException {\n+        final String parent = file.getParent();\n+        if (parent != null) {\n+            final File dir = new File(parent);\n+            if (!dir.mkdirs() && !dir.isDirectory()) {\n+                throw new IOException(\"Could not create the directory \" + dir);\n+            }\n+        }\n+        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n+            dump(dos);\n+        }\n+    }\n+\n+    \/**\n+     * Dump Java class to output stream in binary format.\n+     *\n+     * @param file Output stream\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    public void dump(final OutputStream file) throws IOException {\n+        dump(new DataOutputStream(file));\n+    }\n+\n+    \/**\n+     * Dump class to a file named fileName.\n+     *\n+     * @param fileName Output file name\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    public void dump(final String fileName) throws IOException {\n+        dump(new File(fileName));\n+    }\n@@ -335,1 +380,4 @@\n-     * @return Attributes of the class.\n+     * Return value as defined by given BCELComparator strategy. By default two JavaClass objects are said to be equal when\n+     * their class names are equal.\n+     *\n+     * @see Object#equals(Object)\n@@ -337,2 +385,28 @@\n-    public Attribute[] getAttributes() {\n-        return attributes;\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+    \/**\n+     * Get all interfaces implemented by this JavaClass (transitively).\n+     *\n+     * @throws ClassNotFoundException if any of the class's superclasses or interfaces can't be found.\n+     *\/\n+    public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n+        final ClassQueue queue = new ClassQueue();\n+        final Set<JavaClass> allInterfaces = new TreeSet<>();\n+        queue.enqueue(this);\n+        while (!queue.empty()) {\n+            final JavaClass clazz = queue.dequeue();\n+            final JavaClass souper = clazz.getSuperClass();\n+            final JavaClass[] interfaces = clazz.getInterfaces();\n+            if (clazz.isInterface()) {\n+                allInterfaces.add(clazz);\n+            } else if (souper != null) {\n+                queue.enqueue(souper);\n+            }\n+            for (final JavaClass iface : interfaces) {\n+                queue.enqueue(iface);\n+            }\n+        }\n+        return allInterfaces.toArray(JavaClass.EMPTY_ARRAY);\n@@ -354,1 +428,1 @@\n-     * @return Class name.\n+     * @return Attributes of the class.\n@@ -356,2 +430,2 @@\n-    public String getClassName() {\n-        return className;\n+    public Attribute[] getAttributes() {\n+        return attributes;\n@@ -360,1 +434,0 @@\n-\n@@ -362,1 +435,1 @@\n-     * @return Package name.\n+     * @return class in binary format\n@@ -364,2 +437,8 @@\n-    public String getPackageName() {\n-        return packageName;\n+    public byte[] getBytes() {\n+        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        try (DataOutputStream dos = new DataOutputStream(baos)) {\n+            dump(dos);\n+        } catch (final IOException e) {\n+            e.printStackTrace();\n+        }\n+        return baos.toByteArray();\n@@ -368,0 +447,6 @@\n+    \/**\n+     * @return Class name.\n+     *\/\n+    public String getClassName() {\n+        return className;\n+    }\n@@ -376,1 +461,0 @@\n-\n@@ -384,1 +468,0 @@\n-\n@@ -386,3 +469,2 @@\n-     * @return Fields, i.e., variables of the class. Like the JVM spec\n-     * mandates for the classfile format, these fields are those specific to\n-     * this class, and not those of the superclass or superinterfaces.\n+     * @return Fields, i.e., variables of the class. Like the JVM spec mandates for the classfile format, these fields are\n+     *         those specific to this class, and not those of the superclass or superinterfaces.\n@@ -394,1 +476,0 @@\n-\n@@ -402,0 +483,6 @@\n+    \/**\n+     * @return Indices in constant pool of implemented interfaces.\n+     *\/\n+    public int[] getInterfaceIndices() {\n+        return interfaces;\n+    }\n@@ -410,1 +497,0 @@\n-\n@@ -412,1 +498,3 @@\n-     * @return Indices in constant pool of implemented interfaces.\n+     * Get interfaces directly implemented by this JavaClass.\n+     *\n+     * @throws ClassNotFoundException if any of the class's interfaces can't be found.\n@@ -414,2 +502,7 @@\n-    public int[] getInterfaceIndices() {\n-        return interfaces;\n+    public JavaClass[] getInterfaces() throws ClassNotFoundException {\n+        final String[] interfaces = getInterfaceNames();\n+        final JavaClass[] classes = new JavaClass[interfaces.length];\n+        for (int i = 0; i < interfaces.length; i++) {\n+            classes[i] = repository.loadClass(interfaces[i]);\n+        }\n+        return classes;\n@@ -418,1 +511,0 @@\n-\n@@ -426,1 +518,0 @@\n-\n@@ -428,1 +519,1 @@\n-     * @return Methods of the class.\n+     * @return A {@link Method} corresponding to java.lang.reflect.Method if any\n@@ -430,10 +521,1 @@\n-    public Method[] getMethods() {\n-        return methods;\n-    }\n-\n-\n-    \/**\n-     * @return A {@link Method} corresponding to\n-     * java.lang.reflect.Method if any\n-     *\/\n-    public Method getMethod( final java.lang.reflect.Method m ) {\n+    public Method getMethod(final java.lang.reflect.Method m) {\n@@ -441,2 +523,1 @@\n-            if (m.getName().equals(method.getName()) && (m.getModifiers() == method.getModifiers())\n-                    && Type.getSignature(m).equals(method.getSignature())) {\n+            if (m.getName().equals(method.getName()) && m.getModifiers() == method.getModifiers() && Type.getSignature(m).equals(method.getSignature())) {\n@@ -449,0 +530,6 @@\n+    \/**\n+     * @return Methods of the class.\n+     *\/\n+    public Method[] getMethods() {\n+        return methods;\n+    }\n@@ -457,0 +544,21 @@\n+    \/**\n+     * @return Package name.\n+     *\/\n+    public String getPackageName() {\n+        return packageName;\n+    }\n+\n+    \/**\n+     * Gets the ClassRepository which holds its definition. By default this is the same as\n+     * SyntheticRepository.getInstance();\n+     *\/\n+    public com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n+        return repository;\n+    }\n+\n+    \/**\n+     * @return returns either HEAP (generated), FILE, or ZIP\n+     *\/\n+    public final byte getSource() {\n+        return source;\n+    }\n@@ -459,1 +567,1 @@\n-     * @return sbsolute path to file where this class was read from\n+     * @return file name where this class was read from\n@@ -465,0 +573,15 @@\n+    \/**\n+     * Gets the source file path including the package path.\n+     *\n+     * @return path to original source file of parsed class, relative to original source directory.\n+     * @since 6.7.0\n+     *\/\n+    public String getSourceFilePath() {\n+        final StringBuilder outFileName = new StringBuilder();\n+        if (!packageName.isEmpty()) {\n+            outFileName.append(Utility.packageToPath(packageName));\n+            outFileName.append('\/');\n+        }\n+        outFileName.append(sourceFileName);\n+        return outFileName.toString();\n+    }\n@@ -467,3 +590,26 @@\n-     * returns the super class name of this class. In the case that this class is\n-     * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect\n-     * but isn't fixed at this time to not break existing clients.\n+     * @return the superclass for this JavaClass object, or null if this is java.lang.Object\n+     * @throws ClassNotFoundException if the superclass can't be found\n+     *\/\n+    public JavaClass getSuperClass() throws ClassNotFoundException {\n+        if (\"java.lang.Object\".equals(getClassName())) {\n+            return null;\n+        }\n+        return repository.loadClass(getSuperclassName());\n+    }\n+\n+    \/**\n+     * @return list of super classes of this class in ascending order, i.e., java.lang.Object is always the last element\n+     * @throws ClassNotFoundException if any of the superclasses can't be found\n+     *\/\n+    public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n+        JavaClass clazz = this;\n+        final List<JavaClass> allSuperClasses = new ArrayList<>();\n+        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n+            allSuperClasses.add(clazz);\n+        }\n+        return allSuperClasses.toArray(JavaClass.EMPTY_ARRAY);\n+    }\n+\n+    \/**\n+     * returns the super class name of this class. In the case that this class is java.lang.Object, it will return itself\n+     * (java.lang.Object). This is probably incorrect but isn't fixed at this time to not break existing clients.\n@@ -477,1 +623,0 @@\n-\n@@ -485,0 +630,75 @@\n+    \/**\n+     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n+     *\n+     * @see Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n+\n+    \/**\n+     * @return true, if this class is an implementation of interface inter\n+     * @throws ClassNotFoundException if superclasses or superinterfaces of this class can't be found\n+     *\/\n+    public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {\n+        if (!inter.isInterface()) {\n+            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n+        }\n+        if (this.equals(inter)) {\n+            return true;\n+        }\n+        final JavaClass[] superInterfaces = getAllInterfaces();\n+        for (final JavaClass superInterface : superInterfaces) {\n+            if (superInterface.equals(inter)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Equivalent to runtime \"instanceof\" operator.\n+     *\n+     * @return true if this JavaClass is derived from the super class\n+     * @throws ClassNotFoundException if superclasses or superinterfaces of this object can't be found\n+     *\/\n+    public final boolean instanceOf(final JavaClass superclass) throws ClassNotFoundException {\n+        if (this.equals(superclass)) {\n+            return true;\n+        }\n+        for (final JavaClass clazz : getSuperClasses()) {\n+            if (clazz.equals(superclass)) {\n+                return true;\n+            }\n+        }\n+        if (superclass.isInterface()) {\n+            return implementationOf(superclass);\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public final boolean isAnonymous() {\n+        computeNestedTypeStatus();\n+        return this.isAnonymous;\n+    }\n+\n+    public final boolean isClass() {\n+        return (super.getAccessFlags() & Const.ACC_INTERFACE) == 0;\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public final boolean isNested() {\n+        computeNestedTypeStatus();\n+        return this.isNested;\n+    }\n+\n+    public final boolean isSuper() {\n+        return (super.getAccessFlags() & Const.ACC_SUPER) != 0;\n+    }\n+\n@@ -488,1 +708,1 @@\n-    public void setAttributes( final Attribute[] attributes ) {\n+    public void setAttributes(final Attribute[] attributes) {\n@@ -492,1 +712,0 @@\n-\n@@ -496,1 +715,1 @@\n-    public void setClassName( final String className ) {\n+    public void setClassName(final String className) {\n@@ -500,1 +719,0 @@\n-\n@@ -504,1 +722,1 @@\n-    public void setClassNameIndex( final int classNameIndex ) {\n+    public void setClassNameIndex(final int classNameIndex) {\n@@ -508,1 +726,0 @@\n-\n@@ -512,1 +729,1 @@\n-    public void setConstantPool( final ConstantPool constantPool ) {\n+    public void setConstantPool(final ConstantPool constantPool) {\n@@ -516,1 +733,0 @@\n-\n@@ -520,1 +736,1 @@\n-    public void setFields( final Field[] fields ) {\n+    public void setFields(final Field[] fields) {\n@@ -524,1 +740,0 @@\n-\n@@ -528,1 +743,1 @@\n-    public void setFileName( final String fileName ) {\n+    public void setFileName(final String fileName) {\n@@ -532,1 +747,0 @@\n-\n@@ -536,1 +750,1 @@\n-    public void setInterfaceNames( final String[] interfaceNames ) {\n+    public void setInterfaceNames(final String[] interfaceNames) {\n@@ -540,1 +754,0 @@\n-\n@@ -544,1 +757,1 @@\n-    public void setInterfaces( final int[] interfaces ) {\n+    public void setInterfaces(final int[] interfaces) {\n@@ -548,1 +761,0 @@\n-\n@@ -552,1 +764,1 @@\n-    public void setMajor( final int major ) {\n+    public void setMajor(final int major) {\n@@ -556,1 +768,0 @@\n-\n@@ -560,1 +771,1 @@\n-    public void setMethods( final Method[] methods ) {\n+    public void setMethods(final Method[] methods) {\n@@ -564,1 +775,0 @@\n-\n@@ -568,1 +778,1 @@\n-    public void setMinor( final int minor ) {\n+    public void setMinor(final int minor) {\n@@ -572,0 +782,6 @@\n+    \/**\n+     * Sets the ClassRepository which loaded the JavaClass. Should be called immediately after parsing is done.\n+     *\/\n+    public void setRepository(final com.sun.org.apache.bcel.internal.util.Repository repository) { \/\/ TODO make protected?\n+        this.repository = repository;\n+    }\n@@ -576,1 +792,1 @@\n-    public void setSourceFileName( final String sourceFileName ) {\n+    public void setSourceFileName(final String sourceFileName) {\n@@ -580,1 +796,0 @@\n-\n@@ -584,1 +799,1 @@\n-    public void setSuperclassName( final String superclassName ) {\n+    public void setSuperclassName(final String superclassName) {\n@@ -588,1 +803,0 @@\n-\n@@ -592,1 +806,1 @@\n-    public void setSuperclassNameIndex( final int superclassNameIndex ) {\n+    public void setSuperclassNameIndex(final int superclassNameIndex) {\n@@ -596,1 +810,0 @@\n-\n@@ -603,1 +816,1 @@\n-        access = access.isEmpty() ? \"\" : (access + \" \");\n+        access = access.isEmpty() ? \"\" : access + \" \";\n@@ -605,3 +818,2 @@\n-        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(\n-                className).append(\" extends \").append(\n-                Utility.compactClassName(superclassName, false)).append('\\n');\n+        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(className).append(\" extends \")\n+            .append(Utility.compactClassName(superclassName, false)).append('\\n');\n@@ -632,1 +844,1 @@\n-        if (annotations!=null && annotations.length>0) {\n+        if (annotations != null && annotations.length > 0) {\n@@ -652,282 +864,0 @@\n-\n-\n-    private static String indent( final Object obj ) {\n-        final StringTokenizer tok = new StringTokenizer(obj.toString(), \"\\n\");\n-        final StringBuilder buf = new StringBuilder();\n-        while (tok.hasMoreTokens()) {\n-            buf.append(\"\\t\").append(tok.nextToken()).append(\"\\n\");\n-        }\n-        return buf.toString();\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this class\n-     *\/\n-    public JavaClass copy() {\n-        JavaClass c = null;\n-        try {\n-            c = (JavaClass) clone();\n-            c.constantPool = constantPool.copy();\n-            c.interfaces = interfaces.clone();\n-            c.interfaceNames = interfaceNames.clone();\n-            c.fields = new Field[fields.length];\n-            for (int i = 0; i < fields.length; i++) {\n-                c.fields[i] = fields[i].copy(c.constantPool);\n-            }\n-            c.methods = new Method[methods.length];\n-            for (int i = 0; i < methods.length; i++) {\n-                c.methods[i] = methods[i].copy(c.constantPool);\n-            }\n-            c.attributes = new Attribute[attributes.length];\n-            for (int i = 0; i < attributes.length; i++) {\n-                c.attributes[i] = attributes[i].copy(c.constantPool);\n-            }\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return c;\n-    }\n-\n-\n-    public final boolean isSuper() {\n-        return (super.getAccessFlags() & Const.ACC_SUPER) != 0;\n-    }\n-\n-\n-    public final boolean isClass() {\n-        return (super.getAccessFlags() & Const.ACC_INTERFACE) == 0;\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public final boolean isAnonymous() {\n-        computeNestedTypeStatus();\n-        return this.isAnonymous;\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public final boolean isNested() {\n-        computeNestedTypeStatus();\n-        return this.isNested;\n-    }\n-\n-    private void computeNestedTypeStatus() {\n-        if (computedNestedTypeStatus) {\n-            return;\n-        }\n-        for (final Attribute attribute : this.attributes) {\n-              if (attribute instanceof InnerClasses) {\n-                  final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();\n-                  for (final InnerClass innerClasse : innerClasses) {\n-                      boolean innerClassAttributeRefersToMe = false;\n-                      String inner_class_name = constantPool.getConstantString(innerClasse.getInnerClassIndex(),\n-                                 Const.CONSTANT_Class);\n-                      inner_class_name = Utility.compactClassName(inner_class_name, false);\n-                      if (inner_class_name.equals(getClassName())) {\n-                          innerClassAttributeRefersToMe = true;\n-                      }\n-                      if (innerClassAttributeRefersToMe) {\n-                          this.isNested = true;\n-                          if (innerClasse.getInnerNameIndex() == 0) {\n-                              this.isAnonymous = true;\n-                          }\n-                      }\n-                  }\n-              }\n-        }\n-        this.computedNestedTypeStatus = true;\n-    }\n-\n-\n-    \/** @return returns either HEAP (generated), FILE, or ZIP\n-     *\/\n-    public final byte getSource() {\n-        return source;\n-    }\n-\n-\n-    \/********************* New repository functionality *********************\/\n-    \/**\n-     * Gets the ClassRepository which holds its definition. By default\n-     * this is the same as SyntheticRepository.getInstance();\n-     *\/\n-    public com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n-        return repository;\n-    }\n-\n-\n-    \/**\n-     * Sets the ClassRepository which loaded the JavaClass.\n-     * Should be called immediately after parsing is done.\n-     *\/\n-    public void setRepository( final com.sun.org.apache.bcel.internal.util.Repository repository ) { \/\/ TODO make protected?\n-        this.repository = repository;\n-    }\n-\n-\n-    \/** Equivalent to runtime \"instanceof\" operator.\n-     *\n-     * @return true if this JavaClass is derived from the super class\n-     * @throws ClassNotFoundException if superclasses or superinterfaces\n-     *   of this object can't be found\n-     *\/\n-    public final boolean instanceOf( final JavaClass super_class ) throws ClassNotFoundException {\n-        if (this.equals(super_class)) {\n-            return true;\n-        }\n-        final JavaClass[] super_classes = getSuperClasses();\n-        for (final JavaClass super_classe : super_classes) {\n-            if (super_classe.equals(super_class)) {\n-                return true;\n-            }\n-        }\n-        if (super_class.isInterface()) {\n-            return implementationOf(super_class);\n-        }\n-        return false;\n-    }\n-\n-\n-    \/**\n-     * @return true, if this class is an implementation of interface inter\n-     * @throws ClassNotFoundException if superclasses or superinterfaces\n-     *   of this class can't be found\n-     *\/\n-    public boolean implementationOf( final JavaClass inter ) throws ClassNotFoundException {\n-        if (!inter.isInterface()) {\n-            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n-        }\n-        if (this.equals(inter)) {\n-            return true;\n-        }\n-        final JavaClass[] super_interfaces = getAllInterfaces();\n-        for (final JavaClass super_interface : super_interfaces) {\n-            if (super_interface.equals(inter)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-\n-    \/**\n-     * @return the superclass for this JavaClass object, or null if this\n-     * is java.lang.Object\n-     * @throws ClassNotFoundException if the superclass can't be found\n-     *\/\n-    public JavaClass getSuperClass() throws ClassNotFoundException {\n-        if (\"java.lang.Object\".equals(getClassName())) {\n-            return null;\n-        }\n-        return repository.loadClass(getSuperclassName());\n-    }\n-\n-\n-    \/**\n-     * @return list of super classes of this class in ascending order, i.e.,\n-     * java.lang.Object is always the last element\n-     * @throws ClassNotFoundException if any of the superclasses can't be found\n-     *\/\n-    public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n-        JavaClass clazz = this;\n-        final List<JavaClass> allSuperClasses = new ArrayList<>();\n-        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n-            allSuperClasses.add(clazz);\n-        }\n-        return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);\n-    }\n-\n-\n-    \/**\n-     * Get interfaces directly implemented by this JavaClass.\n-     *\/\n-    public JavaClass[] getInterfaces() throws ClassNotFoundException {\n-        final String[] _interfaces = getInterfaceNames();\n-        final JavaClass[] classes = new JavaClass[_interfaces.length];\n-        for (int i = 0; i < _interfaces.length; i++) {\n-            classes[i] = repository.loadClass(_interfaces[i]);\n-        }\n-        return classes;\n-    }\n-\n-\n-    \/**\n-     * Get all interfaces implemented by this JavaClass (transitively).\n-     *\/\n-    public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n-        final ClassQueue queue = new ClassQueue();\n-        final Set<JavaClass> allInterfaces = new TreeSet<>();\n-        queue.enqueue(this);\n-        while (!queue.empty()) {\n-            final JavaClass clazz = queue.dequeue();\n-            final JavaClass souper = clazz.getSuperClass();\n-            final JavaClass[] _interfaces = clazz.getInterfaces();\n-            if (clazz.isInterface()) {\n-                allInterfaces.add(clazz);\n-            } else {\n-                if (souper != null) {\n-                    queue.enqueue(souper);\n-                }\n-            }\n-            for (final JavaClass _interface : _interfaces) {\n-                queue.enqueue(_interface);\n-            }\n-        }\n-        return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);\n-    }\n-\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator( final BCELComparator comparator ) {\n-        bcelComparator = comparator;\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default two JavaClass objects are said to be equal when\n-     * their class names are equal.\n-     *\n-     * @see java.lang.Object#equals(java.lang.Object)\n-     *\/\n-    @Override\n-    public boolean equals( final Object obj ) {\n-        return bcelComparator.equals(this, obj);\n-    }\n-\n-\n-    \/**\n-     * Return the natural ordering of two JavaClasses.\n-     * This ordering is based on the class name\n-     * @since 6.0\n-     *\/\n-    @Override\n-    public int compareTo( final JavaClass obj ) {\n-        return getClassName().compareTo(obj.getClassName());\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default return the hashcode of the class name.\n-     *\n-     * @see java.lang.Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/JavaClass.java","additions":433,"deletions":503,"binary":false,"changes":936,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n+\n@@ -29,3 +31,2 @@\n- * This class represents a (PC offset, line number) pair, i.e., a line number in\n- * the source that corresponds to a relative address in the byte code. This\n- * is used for debugging purposes.\n+ * This class represents a (PC offset, line number) pair, i.e., a line number in the source that corresponds to a\n+ * relative address in the byte code. This is used for debugging purposes.\n@@ -33,1 +34,1 @@\n- * @see     LineNumberTable\n+ * @see LineNumberTable\n@@ -37,0 +38,2 @@\n+    static final LineNumber[] EMPTY_ARRAY = {};\n+\n@@ -38,1 +41,1 @@\n-    private short startPc;\n+    private int startPc;\n@@ -41,11 +44,1 @@\n-    private short lineNumber;\n-\n-    \/**\n-     * Initialize from another object.\n-     *\n-     * @param c the object to copy\n-     *\/\n-    public LineNumber(final LineNumber c) {\n-        this(c.getStartPC(), c.getLineNumber());\n-    }\n-\n+    private int lineNumber;\n@@ -63,1 +56,0 @@\n-\n@@ -69,2 +61,2 @@\n-        this.startPc = (short) startPc;\n-        this.lineNumber = (short)lineNumber;\n+        this.startPc = Args.requireU2(startPc, \"startPc\");\n+        this.lineNumber = Args.requireU2(lineNumber, \"lineNumber\");\n@@ -73,0 +65,8 @@\n+    \/**\n+     * Initialize from another object.\n+     *\n+     * @param c the object to copy\n+     *\/\n+    public LineNumber(final LineNumber c) {\n+        this(c.getStartPC(), c.getLineNumber());\n+    }\n@@ -75,3 +75,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -82,1 +81,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -86,0 +85,11 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public LineNumber copy() {\n+        try {\n+            return (LineNumber) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n@@ -93,1 +103,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -98,1 +108,0 @@\n-\n@@ -103,1 +112,1 @@\n-        return 0xffff & lineNumber;\n+        return lineNumber & 0xffff;\n@@ -106,1 +115,0 @@\n-\n@@ -111,1 +119,1 @@\n-        return  0xffff & startPc;\n+        return startPc & 0xffff;\n@@ -114,1 +122,0 @@\n-\n@@ -118,1 +125,1 @@\n-    public void setLineNumber( final int lineNumber ) {\n+    public void setLineNumber(final int lineNumber) {\n@@ -122,1 +129,0 @@\n-\n@@ -126,1 +132,1 @@\n-    public void setStartPC( final int startPc ) {\n+    public void setStartPC(final int startPc) {\n@@ -130,1 +136,0 @@\n-\n@@ -136,14 +141,1 @@\n-        return \"LineNumber(\" + startPc + \", \" + lineNumber + \")\";\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public LineNumber copy() {\n-        try {\n-            return (LineNumber) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+        return \"LineNumber(\" + getStartPC() + \", \" + getLineNumber() + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumber.java","additions":39,"deletions":47,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -22,1 +22,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -26,0 +25,6 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -29,3 +34,2 @@\n- * This class represents a table of line numbers for debugging\n- * purposes. This attribute is used by the <em>Code<\/em> attribute. It\n- * contains pairs of PCs and line numbers.\n+ * This class represents a table of line numbers for debugging purposes. This attribute is used by the <em>Code<\/em>\n+ * attribute. It contains pairs of PCs and line numbers.\n@@ -33,1 +37,1 @@\n- * @see     Code\n+ * @see Code\n@@ -37,1 +41,1 @@\n-public final class LineNumberTable extends Attribute {\n+public final class LineNumberTable extends Attribute implements Iterable<LineNumber> {\n@@ -42,4 +46,8 @@\n-\n-    \/*\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+    \/**\n+     * Construct object from input stream.\n+     *\n+     * @param nameIndex Index of name\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O Exception occurs in readUnsignedShort\n@@ -47,2 +55,7 @@\n-    public LineNumberTable(final LineNumberTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLineNumberTable(), c.getConstantPool());\n+    LineNumberTable(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (LineNumber[]) null, constantPool);\n+        final int lineNumberTableLength = input.readUnsignedShort();\n+        lineNumberTable = new LineNumber[lineNumberTableLength];\n+        for (int i = 0; i < lineNumberTableLength; i++) {\n+            lineNumberTable[i] = new LineNumber(input);\n+        }\n@@ -51,1 +64,0 @@\n-\n@@ -53,1 +65,2 @@\n-     * @param name_index Index of name\n+     * @param nameIndex Index of name\n+     *\n@@ -55,0 +68,1 @@\n+     *\n@@ -56,1 +70,2 @@\n-     * @param constant_pool Array of constants\n+     *\n+     * @param constantPool Array of constants\n@@ -58,4 +73,4 @@\n-    public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table,\n-            final ConstantPool constant_pool) {\n-        super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);\n-        this.lineNumberTable = line_number_table;\n+    public LineNumberTable(final int nameIndex, final int length, final LineNumber[] lineNumberTable, final ConstantPool constantPool) {\n+        super(Const.ATTR_LINE_NUMBER_TABLE, nameIndex, length, constantPool);\n+        this.lineNumberTable = lineNumberTable != null ? lineNumberTable : LineNumber.EMPTY_ARRAY;\n+        Args.requireU2(this.lineNumberTable.length, \"lineNumberTable.length\");\n@@ -64,7 +79,3 @@\n-    \/**\n-     * Construct object from input stream.\n-     * @param name_index Index of name\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     * @throws IOException if an I\/O Exception occurs in readUnsignedShort\n+    \/*\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n@@ -72,8 +83,2 @@\n-    LineNumberTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, (LineNumber[]) null, constant_pool);\n-        final int line_number_table_length = input.readUnsignedShort();\n-        lineNumberTable = new LineNumber[line_number_table_length];\n-        for (int i = 0; i < line_number_table_length; i++) {\n-            lineNumberTable[i] = new LineNumber(input);\n-        }\n+    public LineNumberTable(final LineNumberTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLineNumberTable(), c.getConstantPool());\n@@ -83,3 +88,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -90,1 +94,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -94,0 +98,14 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        \/\/ TODO could use the lower level constructor and thereby allow\n+        \/\/ lineNumberTable to be made final\n+        final LineNumberTable c = (LineNumberTable) clone();\n+        c.lineNumberTable = new LineNumber[lineNumberTable.length];\n+        Arrays.setAll(c.lineNumberTable, i -> lineNumberTable[i].copy());\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n+\n@@ -101,1 +119,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -116,30 +134,0 @@\n-    \/**\n-     * @param lineNumberTable the line number entries for this table\n-     *\/\n-    public void setLineNumberTable( final LineNumber[] lineNumberTable ) {\n-        this.lineNumberTable = lineNumberTable;\n-    }\n-\n-    \/**\n-     * @return String representation.\n-     *\/\n-    @Override\n-    public String toString() {\n-        final StringBuilder buf = new StringBuilder();\n-        final StringBuilder line = new StringBuilder();\n-\n-        for (int i = 0; i < lineNumberTable.length; i++) {\n-            line.append(lineNumberTable[i].toString());\n-            if (i < lineNumberTable.length - 1) {\n-                line.append(\", \");\n-            }\n-            if ((line.length() > MAX_LINE_LENGTH) && (i < lineNumberTable.length - 1)) {\n-                line.append(SecuritySupport.NEWLINE);\n-                buf.append(line);\n-                line.setLength(0);\n-            }\n-        }\n-        buf.append(line);\n-        return buf.toString();\n-    }\n-\n@@ -152,1 +140,1 @@\n-    public int getSourceLine( final int pos ) {\n+    public int getSourceLine(final int pos) {\n@@ -158,1 +146,1 @@\n-        int min_index = -1;\n+        int minIndex = -1;\n@@ -160,1 +148,2 @@\n-        \/* Do a binary search since the array is ordered.\n+        \/*\n+         * Do a binary search since the array is ordered.\n@@ -163,1 +152,1 @@\n-            final int i = (l + r) >>> 1;\n+            final int i = l + r >>> 1;\n@@ -167,1 +156,2 @@\n-            } else if (pos < j) {\n+            }\n+            if (pos < j) {\n@@ -172,3 +162,3 @@\n-            \/* If exact match can't be found (which is the most common case)\n-             * return the line number that corresponds to the greatest index less\n-             * than pos.\n+            \/*\n+             * If exact match can't be found (which is the most common case) return the line number that corresponds to the greatest\n+             * index less than pos.\n@@ -178,1 +168,1 @@\n-                min_index = i;\n+                minIndex = i;\n@@ -181,2 +171,2 @@\n-        \/* It's possible that we did not find any valid entry for the bytecode\n-         * offset we were looking for.\n+        \/*\n+         * It's possible that we did not find any valid entry for the bytecode offset we were looking for.\n@@ -184,1 +174,1 @@\n-        if (min_index < 0) {\n+        if (minIndex < 0) {\n@@ -187,1 +177,10 @@\n-        return lineNumberTable[min_index].getLineNumber();\n+        return lineNumberTable[minIndex].getLineNumber();\n+    }\n+\n+    public int getTableLength() {\n+        return lineNumberTable == null ? 0 : lineNumberTable.length;\n+    }\n+\n+    @Override\n+    public Iterator<LineNumber> iterator() {\n+        return Stream.of(lineNumberTable).iterator();\n@@ -191,1 +190,8 @@\n-     * @return deep copy of this attribute\n+     * @param lineNumberTable the line number entries for this table\n+     *\/\n+    public void setLineNumberTable(final LineNumber[] lineNumberTable) {\n+        this.lineNumberTable = lineNumberTable;\n+    }\n+\n+    \/**\n+     * @return String representation.\n@@ -194,5 +200,3 @@\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        \/\/ TODO could use the lower level constructor and thereby allow\n-        \/\/ lineNumberTable to be made final\n-        final LineNumberTable c = (LineNumberTable) clone();\n-        c.lineNumberTable = new LineNumber[lineNumberTable.length];\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder();\n+        final StringBuilder line = new StringBuilder();\n@@ -200,1 +204,9 @@\n-            c.lineNumberTable[i] = lineNumberTable[i].copy();\n+            line.append(lineNumberTable[i].toString());\n+            if (i < lineNumberTable.length - 1) {\n+                line.append(\", \");\n+            }\n+            if (line.length() > MAX_LINE_LENGTH && i < lineNumberTable.length - 1) {\n+                line.append(SecuritySupport.NEWLINE);\n+                buf.append(line);\n+                line.setLength(0);\n+            }\n@@ -202,7 +214,2 @@\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n-\n-\n-    public int getTableLength() {\n-        return lineNumberTable == null ? 0 : lineNumberTable.length;\n+        buf.append(line);\n+        return buf.toString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumberTable.java","additions":103,"deletions":96,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -30,6 +30,4 @@\n- * This class represents a local variable within a method. It contains its\n- * scope, name, signature and index on the method's frame.  It is used both\n- * to represent an element of the LocalVariableTable as well as an element\n- * of the LocalVariableTypeTable.  The nomenclature used here may be a bit confusing;\n- * while the two items have the same layout in a class file, a LocalVariableTable\n- * attribute contains a descriptor_index, not a signatureIndex.  The\n+ * This class represents a local variable within a method. It contains its scope, name, signature and index on the\n+ * method's frame. It is used both to represent an element of the LocalVariableTable as well as an element of the\n+ * LocalVariableTypeTable. The nomenclature used here may be a bit confusing; while the two items have the same layout\n+ * in a class file, a LocalVariableTable attribute contains a descriptor_index, not a signatureIndex. The\n@@ -37,0 +35,1 @@\n+ *\n@@ -39,3 +38,3 @@\n- * @see     LocalVariableTable\n- * @see     LocalVariableTypeTable\n- * @LastModified: May 2021\n+ * @see LocalVariableTable\n+ * @see LocalVariableTypeTable\n+ * @LastModified: Feb 2023\n@@ -45,1 +44,5 @@\n-    private int startPc; \/\/ Range in which the variable is valid\n+    static final LocalVariable[] EMPTY_ARRAY = {};\n+\n+    \/** Range in which the variable is valid. *\/\n+    private int startPc;\n+\n@@ -47,9 +50,0 @@\n-    private int nameIndex; \/\/ Index in constant pool of variable name\n-    \/\/ Technically, a decscriptor_index for a local variable table entry\n-    \/\/ and a signatureIndex for a local variable type table entry.\n-    private int signatureIndex; \/\/ Index of variable signature\n-    private int index; \/* Variable is index'th local variable on\n-     * this method's frame.\n-     *\/\n-    private ConstantPool constantPool;\n-    private int origIndex; \/\/ never changes; used to match up with LocalVariableTypeTable entries\n@@ -57,0 +51,2 @@\n+    \/** Index in constant pool of variable name. *\/\n+    private int nameIndex;\n@@ -59,4 +55,1 @@\n-     * Initializes from another LocalVariable. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n-     *\n-     * @param localVariable Another LocalVariable.\n+     * Technically, a decscriptor_index for a local variable table entry and a signatureIndex for a local variable type table entry. Index of variable signature\n@@ -64,5 +57,11 @@\n-    public LocalVariable(final LocalVariable localVariable) {\n-        this(localVariable.getStartPC(), localVariable.getLength(), localVariable.getNameIndex(),\n-                localVariable.getSignatureIndex(), localVariable.getIndex(), localVariable.getConstantPool());\n-        this.origIndex = localVariable.getOrigIndex();\n-    }\n+    private int signatureIndex;\n+\n+    \/*\n+     * Variable is index'th local variable on this method's frame.\n+     *\/\n+    private int index;\n+\n+    private ConstantPool constantPool;\n+\n+    \/** Never changes; used to match up with LocalVariableTypeTable entries. *\/\n+    private final int origIndex;\n@@ -72,0 +71,1 @@\n+     *\n@@ -73,1 +73,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -75,3 +75,2 @@\n-    LocalVariable(final DataInput file, final ConstantPool constant_pool) throws IOException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n-                .readUnsignedShort(), file.readUnsignedShort(), constant_pool);\n+    LocalVariable(final DataInput file, final ConstantPool constantPool) throws IOException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), constantPool);\n@@ -80,1 +79,0 @@\n-\n@@ -86,1 +84,1 @@\n-     * @param index Variable is `index'th local variable on the method's frame\n+     * @param index Variable is 'index'th local variable on the method's frame\n@@ -89,9 +87,2 @@\n-    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index,\n-            final ConstantPool constantPool) {\n-        this.startPc = startPc;\n-        this.length = length;\n-        this.nameIndex = nameIndex;\n-        this.signatureIndex = signatureIndex;\n-        this.index = index;\n-        this.constantPool = constantPool;\n-        this.origIndex = index;\n+    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index, final ConstantPool constantPool) {\n+        this(startPc, length, nameIndex, signatureIndex, index, constantPool, index);\n@@ -100,1 +91,0 @@\n-\n@@ -106,1 +96,1 @@\n-     * @param index Variable is `index'th local variable on the method's frame\n+     * @param index Variable is 'index'th local variable on the method's frame\n@@ -108,1 +98,1 @@\n-     * @param origIndex Variable is `index'th local variable on the method's frame prior to any changes\n+     * @param origIndex Variable is 'index'th local variable on the method's frame prior to any changes\n@@ -110,7 +100,8 @@\n-    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index,\n-            final ConstantPool constantPool, final int origIndex) {\n-        this.startPc = startPc;\n-        this.length = length;\n-        this.nameIndex = nameIndex;\n-        this.signatureIndex = signatureIndex;\n-        this.index = index;\n+    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index, final ConstantPool constantPool,\n+        final int origIndex) {\n+        this.startPc = Args.requireU2(startPc, \"startPc\");\n+        this.length = Args.requireU2(length, \"length\");\n+        this.nameIndex = Args.requireU2(nameIndex, \"nameIndex\");\n+        this.signatureIndex = Args.requireU2(signatureIndex, \"signatureIndex\");\n+        this.index = Args.requireU2(index, \"index\");\n+        this.origIndex = Args.requireU2(origIndex, \"origIndex\");\n@@ -118,1 +109,0 @@\n-        this.origIndex = origIndex;\n@@ -121,0 +111,10 @@\n+    \/**\n+     * Initializes from another LocalVariable. Note that both objects use the same references (shallow copy). Use copy() for\n+     * a physical copy.\n+     *\n+     * @param localVariable Another LocalVariable.\n+     *\/\n+    public LocalVariable(final LocalVariable localVariable) {\n+        this(localVariable.getStartPC(), localVariable.getLength(), localVariable.getNameIndex(), localVariable.getSignatureIndex(), localVariable.getIndex(),\n+            localVariable.getConstantPool());\n+    }\n@@ -123,3 +123,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -130,1 +129,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -134,0 +133,11 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public LocalVariable copy() {\n+        try {\n+            return (LocalVariable) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n@@ -139,1 +149,1 @@\n-     * @exception IOException if an I\/O error occurs.\n+     * @throws IOException if an I\/O error occurs.\n@@ -157,0 +167,6 @@\n+    \/**\n+     * @return index of register where variable is stored\n+     *\/\n+    public int getIndex() {\n+        return index;\n+    }\n@@ -165,1 +181,0 @@\n-\n@@ -170,3 +185,1 @@\n-        ConstantUtf8 c;\n-        c = (ConstantUtf8) constantPool.getConstant(nameIndex, Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+        return constantPool.getConstantUtf8(nameIndex).getBytes();\n@@ -175,1 +188,0 @@\n-\n@@ -183,0 +195,6 @@\n+    \/**\n+     * @return index of register where variable was originally stored\n+     *\/\n+    public int getOrigIndex() {\n+        return origIndex;\n+    }\n@@ -188,3 +206,1 @@\n-        ConstantUtf8 c;\n-        c = (ConstantUtf8) constantPool.getConstant(signatureIndex, Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+        return constantPool.getConstantUtf8(signatureIndex).getBytes();\n@@ -193,1 +209,0 @@\n-\n@@ -201,17 +216,0 @@\n-\n-    \/**\n-     * @return index of register where variable is stored\n-     *\/\n-    public int getIndex() {\n-        return index;\n-    }\n-\n-\n-    \/**\n-     * @return index of register where variable was originally stored\n-     *\/\n-    public int getOrigIndex() {\n-        return origIndex;\n-    }\n-\n-\n@@ -225,13 +223,0 @@\n-\n-    \/*\n-     * Helper method shared with LocalVariableTypeTable\n-     *\/\n-    String toStringShared( final boolean typeTable ) {\n-        final String name = getName();\n-        final String signature = Utility.signatureToString(getSignature(), false);\n-        final String label = \"LocalVariable\" + (typeTable ? \"Types\" : \"\" );\n-        return label + \"(startPc = \" + startPc + \", length = \" + length + \", index = \"\n-                + index + \":\" + signature + \" \" + name + \")\";\n-    }\n-\n-\n@@ -241,1 +226,1 @@\n-    public void setConstantPool( final ConstantPool constantPool ) {\n+    public void setConstantPool(final ConstantPool constantPool) {\n@@ -245,0 +230,6 @@\n+    \/**\n+     * @param index the index in the local variable table of this variable\n+     *\/\n+    public void setIndex(final int index) { \/\/ TODO unused\n+        this.index = index;\n+    }\n@@ -249,1 +240,1 @@\n-    public void setLength( final int length ) {\n+    public void setLength(final int length) {\n@@ -253,1 +244,0 @@\n-\n@@ -257,1 +247,1 @@\n-    public void setNameIndex( final int nameIndex ) { \/\/ TODO unused\n+    public void setNameIndex(final int nameIndex) { \/\/ TODO unused\n@@ -261,1 +251,0 @@\n-\n@@ -265,1 +254,1 @@\n-    public void setSignatureIndex( final int signatureIndex ) { \/\/ TODO unused\n+    public void setSignatureIndex(final int signatureIndex) { \/\/ TODO unused\n@@ -269,9 +258,0 @@\n-\n-    \/**\n-     * @param index the index in the local variable table of this variable\n-     *\/\n-    public void setIndex( final int index ) { \/\/ TODO unused\n-        this.index = index;\n-    }\n-\n-\n@@ -281,1 +261,1 @@\n-    public void setStartPC( final int startPc ) { \/\/ TODO unused\n+    public void setStartPC(final int startPc) { \/\/ TODO unused\n@@ -285,1 +265,0 @@\n-\n@@ -294,3 +273,2 @@\n-\n-    \/**\n-     * @return deep copy of this object\n+    \/*\n+     * Helper method shared with LocalVariableTypeTable\n@@ -298,7 +276,5 @@\n-    public LocalVariable copy() {\n-        try {\n-            return (LocalVariable) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    String toStringShared(final boolean typeTable) {\n+        final String name = getName();\n+        final String signature = Utility.signatureToString(getSignature(), false);\n+        final String label = \"LocalVariable\" + (typeTable ? \"Types\" : \"\");\n+        return label + \"(startPc = \" + startPc + \", length = \" + length + \", index = \" + index + \":\" + signature + \" \" + name + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariable.java","additions":103,"deletions":127,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n@@ -29,0 +32,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +35,2 @@\n- * This class represents colection of local variables in a\n- * method. This attribute is contained in the <em>Code<\/em> attribute.\n+ * This class represents colection of local variables in a method. This attribute is contained in the <em>Code<\/em>\n+ * attribute.\n@@ -34,1 +38,1 @@\n- * @see     Code\n+ * @see Code\n@@ -37,1 +41,1 @@\n-public class LocalVariableTable extends Attribute {\n+public class LocalVariableTable extends Attribute implements Iterable<LocalVariable> {\n@@ -41,1 +45,0 @@\n-\n@@ -43,2 +46,7 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+     * Construct object from input stream.\n+     *\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -46,2 +54,7 @@\n-    public LocalVariableTable(final LocalVariableTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTable(), c.getConstantPool());\n+    LocalVariableTable(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (LocalVariable[]) null, constantPool);\n+        final int localVariableTableLength = input.readUnsignedShort();\n+        localVariableTable = new LocalVariable[localVariableTableLength];\n+        for (int i = 0; i < localVariableTableLength; i++) {\n+            localVariableTable[i] = new LocalVariable(input, constantPool);\n+        }\n@@ -50,1 +63,0 @@\n-\n@@ -52,1 +64,1 @@\n-     * @param nameIndex Index in constant pool to `LocalVariableTable'\n+     * @param nameIndex Index in constant pool to 'LocalVariableTable'\n@@ -57,2 +69,1 @@\n-    public LocalVariableTable(final int nameIndex, final int length, final LocalVariable[] localVariableTable,\n-            final ConstantPool constantPool) {\n+    public LocalVariableTable(final int nameIndex, final int length, final LocalVariable[] localVariableTable, final ConstantPool constantPool) {\n@@ -60,1 +71,2 @@\n-        this.localVariableTable = localVariableTable;\n+        this.localVariableTable = localVariableTable != null ? localVariableTable : LocalVariable.EMPTY_ARRAY;\n+        Args.requireU2(this.localVariableTable.length, \"localVariableTable.length\");\n@@ -63,1 +75,0 @@\n-\n@@ -65,6 +76,4 @@\n-     * Construct object from input stream.\n-     * @param name_index Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -72,8 +81,2 @@\n-    LocalVariableTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, (LocalVariable[]) null, constant_pool);\n-        final int local_variable_table_length = input.readUnsignedShort();\n-        localVariableTable = new LocalVariable[local_variable_table_length];\n-        for (int i = 0; i < local_variable_table_length; i++) {\n-            localVariableTable[i] = new LocalVariable(input, constant_pool);\n-        }\n+    public LocalVariableTable(final LocalVariableTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTable(), c.getConstantPool());\n@@ -82,1 +85,0 @@\n-\n@@ -84,3 +86,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -91,1 +92,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -95,0 +96,11 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final LocalVariableTable c = (LocalVariableTable) clone();\n+        c.localVariableTable = new LocalVariable[localVariableTable.length];\n+        Arrays.setAll(c.localVariableTable, i -> localVariableTable[i].copy());\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -100,1 +112,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -103,1 +115,1 @@\n-    public final void dump( final DataOutputStream file ) throws IOException {\n+    public final void dump(final DataOutputStream file) throws IOException {\n@@ -111,9 +123,0 @@\n-\n-    \/**\n-     * @return Array of local variables of method.\n-     *\/\n-    public final LocalVariable[] getLocalVariableTable() {\n-        return localVariableTable;\n-    }\n-\n-\n@@ -126,2 +129,2 @@\n-     * @deprecated since 5.2 because multiple variables can share the\n-     *             same slot, use getLocalVariable(int index, int pc) instead.\n+     * @deprecated since 5.2 because multiple variables can share the same slot, use getLocalVariable(int index, int pc)\n+     *             instead.\n@@ -130,1 +133,1 @@\n-    public final LocalVariable getLocalVariable( final int index ) {\n+    public final LocalVariable getLocalVariable(final int index) {\n@@ -139,1 +142,0 @@\n-\n@@ -147,1 +149,1 @@\n-    public final LocalVariable getLocalVariable( final int index, final int pc ) {\n+    public final LocalVariable getLocalVariable(final int index, final int pc) {\n@@ -150,3 +152,3 @@\n-                final int start_pc = variable.getStartPC();\n-                final int end_pc = start_pc + variable.getLength();\n-                if ((pc >= start_pc) && (pc <= end_pc)) {\n+                final int startPc = variable.getStartPC();\n+                final int endPc = startPc + variable.getLength();\n+                if (pc >= startPc && pc <= endPc) {\n@@ -160,0 +162,10 @@\n+    \/**\n+     * @return Array of local variables of method.\n+     *\/\n+    public final LocalVariable[] getLocalVariableTable() {\n+        return localVariableTable;\n+    }\n+\n+    public final int getTableLength() {\n+        return localVariableTable == null ? 0 : localVariableTable.length;\n+    }\n@@ -161,2 +173,3 @@\n-    public final void setLocalVariableTable( final LocalVariable[] local_variable_table ) {\n-        this.localVariableTable = local_variable_table;\n+    @Override\n+    public Iterator<LocalVariable> iterator() {\n+        return Stream.of(localVariableTable).iterator();\n@@ -165,0 +178,3 @@\n+    public final void setLocalVariableTable(final LocalVariable[] localVariableTable) {\n+        this.localVariableTable = localVariableTable;\n+    }\n@@ -180,20 +196,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final LocalVariableTable c = (LocalVariableTable) clone();\n-        c.localVariableTable = new LocalVariable[localVariableTable.length];\n-        for (int i = 0; i < localVariableTable.length; i++) {\n-            c.localVariableTable[i] = localVariableTable[i].copy();\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n-\n-\n-    public final int getTableLength() {\n-        return localVariableTable == null ? 0 : localVariableTable.length;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTable.java","additions":71,"deletions":75,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -26,0 +26,3 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n@@ -28,0 +31,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -60,1 +64,1 @@\n-public class LocalVariableTypeTable extends Attribute {\n+public class LocalVariableTypeTable extends Attribute implements Iterable<LocalVariable> {\n@@ -62,10 +66,1 @@\n-    private LocalVariable[] localVariableTypeTable;        \/\/ variables\n-\n-    public LocalVariableTypeTable(final LocalVariableTypeTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTypeTable(), c.getConstantPool());\n-    }\n-\n-    public LocalVariableTypeTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {\n-        super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);\n-        this.localVariableTypeTable = local_variable_table;\n-    }\n+    private LocalVariable[] localVariableTypeTable; \/\/ variables\n@@ -76,2 +71,2 @@\n-        final int local_variable_type_table_length = input.readUnsignedShort();\n-        localVariableTypeTable = new LocalVariable[local_variable_type_table_length];\n+        final int localVariableTypeTableLength = input.readUnsignedShort();\n+        localVariableTypeTable = new LocalVariable[localVariableTypeTableLength];\n@@ -79,1 +74,1 @@\n-        for (int i = 0; i < local_variable_type_table_length; i++) {\n+        for (int i = 0; i < localVariableTypeTableLength; i++) {\n@@ -84,0 +79,10 @@\n+    public LocalVariableTypeTable(final int nameIndex, final int length, final LocalVariable[] localVariableTypeTable, final ConstantPool constantPool) {\n+        super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, nameIndex, length, constantPool);\n+        this.localVariableTypeTable = localVariableTypeTable != null ? localVariableTypeTable : LocalVariable.EMPTY_ARRAY;\n+        Args.requireU2(this.localVariableTypeTable.length, \"localVariableTypeTable.length\");\n+    }\n+\n+    public LocalVariableTypeTable(final LocalVariableTypeTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTypeTable(), c.getConstantPool());\n+    }\n+\n@@ -89,0 +94,13 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final LocalVariableTypeTable c = (LocalVariableTypeTable) clone();\n+\n+        c.localVariableTypeTable = new LocalVariable[localVariableTypeTable.length];\n+        Arrays.setAll(c.localVariableTypeTable, i -> localVariableTypeTable[i].copy());\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n+\n@@ -98,4 +116,0 @@\n-    public final LocalVariable[] getLocalVariableTypeTable() {\n-        return localVariableTypeTable;\n-    }\n-\n@@ -112,2 +126,15 @@\n-    public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {\n-        this.localVariableTypeTable = local_variable_table;\n+    public final LocalVariable[] getLocalVariableTypeTable() {\n+        return localVariableTypeTable;\n+    }\n+\n+    public final int getTableLength() {\n+        return localVariableTypeTable == null ? 0 : localVariableTypeTable.length;\n+    }\n+\n+    @Override\n+    public Iterator<LocalVariable> iterator() {\n+        return Stream.of(localVariableTypeTable).iterator();\n+    }\n+\n+    public final void setLocalVariableTable(final LocalVariable[] localVariableTable) {\n+        this.localVariableTypeTable = localVariableTable;\n@@ -133,20 +160,0 @@\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constant_pool) {\n-        final LocalVariableTypeTable c = (LocalVariableTypeTable) clone();\n-\n-        c.localVariableTypeTable = new LocalVariable[localVariableTypeTable.length];\n-        for (int i = 0; i < localVariableTypeTable.length; i++) {\n-            c.localVariableTypeTable[i] = localVariableTypeTable[i].copy();\n-        }\n-\n-        c.setConstantPool(constant_pool);\n-        return c;\n-    }\n-\n-    public final int getTableLength() {\n-        return localVariableTypeTable == null ? 0 : localVariableTypeTable.length;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTypeTable.java","additions":47,"deletions":40,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -32,4 +31,2 @@\n- * This class represents the method info structure, i.e., the representation\n- * for a method in the class. See JVM specification for details.\n- * A method has access flags, a name, a signature and a number of attributes.\n- *\n+ * This class represents the method info structure, i.e., the representation for a method in the class. See JVM\n+ * specification for details. A method has access flags, a name, a signature and a number of attributes.\n@@ -39,0 +36,7 @@\n+    \/**\n+     * Empty array constant.\n+     *\n+     * @since 6.6.0\n+     *\/\n+    public static final Method[] EMPTY_ARRAY = {};\n+\n@@ -42,1 +46,1 @@\n-        public boolean equals( final Object o1, final Object o2 ) {\n+        public boolean equals(final Object o1, final Object o2) {\n@@ -45,2 +49,1 @@\n-            return Objects.equals(THIS.getName(), THAT.getName())\n-                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -49,1 +52,0 @@\n-\n@@ -51,1 +53,1 @@\n-        public int hashCode( final Object o ) {\n+        public int hashCode(final Object o) {\n@@ -57,2 +59,4 @@\n-    \/\/ annotations defined on the parameters of a method\n-    private ParameterAnnotationEntry[] parameterAnnotationEntries;\n+    \/**\n+     * Empty array.\n+     *\/\n+    static final Method[] EMPTY_METHOD_ARRAY = {};\n@@ -61,2 +65,1 @@\n-     * Empty constructor, all attributes have to be defined via `setXXX'\n-     * methods. Use at your own risk.\n+     * @return Comparison strategy object\n@@ -64,1 +67,2 @@\n-    public Method() {\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -67,1 +71,0 @@\n-\n@@ -69,2 +72,1 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n+     * @param comparator Comparison strategy object\n@@ -72,2 +74,2 @@\n-    public Method(final Method c) {\n-        super(c);\n+    public static void setComparator(final BCELComparator comparator) {\n+        bcelComparator = comparator;\n@@ -76,0 +78,8 @@\n+    \/\/ annotations defined on the parameters of a method\n+    private ParameterAnnotationEntry[] parameterAnnotationEntries;\n+\n+    \/**\n+     * Empty constructor, all attributes have to be defined via 'setXXX' methods. Use at your own risk.\n+     *\/\n+    public Method() {\n+    }\n@@ -79,0 +89,1 @@\n+     *\n@@ -80,2 +91,2 @@\n-     * @throws IOException\n-     * @throws ClassFormatException\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -83,3 +94,2 @@\n-    Method(final DataInput file, final ConstantPool constant_pool) throws IOException,\n-            ClassFormatException {\n-        super(file, constant_pool);\n+    Method(final DataInput file, final ConstantPool constantPool) throws IOException, ClassFormatException {\n+        super(file, constantPool);\n@@ -88,1 +98,0 @@\n-\n@@ -90,3 +99,3 @@\n-     * @param access_flags Access rights of method\n-     * @param name_index Points to field name in constant pool\n-     * @param signature_index Points to encoded signature\n+     * @param accessFlags Access rights of method\n+     * @param nameIndex Points to field name in constant pool\n+     * @param signatureIndex Points to encoded signature\n@@ -94,1 +103,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -96,3 +105,2 @@\n-    public Method(final int access_flags, final int name_index, final int signature_index, final Attribute[] attributes,\n-            final ConstantPool constant_pool) {\n-        super(access_flags, name_index, signature_index, attributes, constant_pool);\n+    public Method(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes, final ConstantPool constantPool) {\n+        super(accessFlags, nameIndex, signatureIndex, attributes, constantPool);\n@@ -101,0 +109,9 @@\n+    \/**\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n+     *\/\n+    public Method(final Method c) {\n+        super(c);\n+    }\n@@ -103,3 +120,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -110,1 +126,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -114,0 +130,24 @@\n+    \/**\n+     * @return deep copy of this method\n+     *\/\n+    public Method copy(final ConstantPool constantPool) {\n+        return (Method) copy_(constantPool);\n+    }\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy. By default two method objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see Object#equals(Object)\n+     *\/\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+    \/**\n+     * @return array of method argument types\n+     *\/\n+    public Type[] getArgumentTypes() {\n+        return Type.getArgumentTypes(getSignature());\n+    }\n@@ -127,1 +167,0 @@\n-\n@@ -129,2 +168,2 @@\n-     * @return ExceptionTable attribute of method, if any, i.e., list all\n-     * exceptions the method may throw not exception handlers!\n+     * @return ExceptionTable attribute of method, if any, i.e., list all exceptions the method may throw not exception\n+     *         handlers!\n@@ -141,3 +180,2 @@\n-\n-    \/** @return LocalVariableTable of code attribute if any, i.e. the call is forwarded\n-     * to the Code atribute.\n+    \/**\n+     * @return LineNumberTable of code attribute if any, i.e. the call is forwarded to the Code atribute.\n@@ -145,1 +183,1 @@\n-    public LocalVariableTable getLocalVariableTable() {\n+    public LineNumberTable getLineNumberTable() {\n@@ -150,1 +188,1 @@\n-        return code.getLocalVariableTable();\n+        return code.getLineNumberTable();\n@@ -153,3 +191,2 @@\n-\n-    \/** @return LineNumberTable of code attribute if any, i.e. the call is forwarded\n-     * to the Code atribute.\n+    \/**\n+     * @return LocalVariableTable of code attribute if any, i.e. the call is forwarded to the Code atribute.\n@@ -157,1 +194,1 @@\n-    public LineNumberTable getLineNumberTable() {\n+    public LocalVariableTable getLocalVariableTable() {\n@@ -162,1 +199,1 @@\n-        return code.getLineNumberTable();\n+        return code.getLocalVariableTable();\n@@ -165,0 +202,10 @@\n+    \/**\n+     * @return Annotations on the parameters of a method\n+     * @since 6.0\n+     *\/\n+    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n+        if (parameterAnnotationEntries == null) {\n+            parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());\n+        }\n+        return parameterAnnotationEntries;\n+    }\n@@ -167,2 +214,20 @@\n-     * Return string representation close to declaration format,\n-     * `public static void main(String[] args) throws IOException', e.g.\n+     * @return return type of method\n+     *\/\n+    public Type getReturnType() {\n+        return Type.getReturnType(getSignature());\n+    }\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n+     * signature.\n+     *\n+     * @see Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n+\n+    \/**\n+     * Return string representation close to declaration format, 'public static void main(String[] args) throws\n+     * IOException', e.g.\n@@ -176,1 +241,1 @@\n-        ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(super.getSignatureIndex(), Const.CONSTANT_Utf8);\n+        ConstantUtf8 c = super.getConstantPool().getConstantUtf8(super.getSignatureIndex());\n@@ -178,1 +243,1 @@\n-        c = (ConstantUtf8) super.getConstantPool().getConstant(super.getNameIndex(), Const.CONSTANT_Utf8);\n+        c = super.getConstantPool().getConstantUtf8(super.getNameIndex());\n@@ -180,2 +245,1 @@\n-        signature = Utility.methodSignatureToString(signature, name, access, true,\n-                getLocalVariableTable());\n+        signature = Utility.methodSignatureToString(signature, name, access, true, getLocalVariableTable());\n@@ -184,1 +248,1 @@\n-            if (!((attribute instanceof Code) || (attribute instanceof ExceptionTable))) {\n+            if (!(attribute instanceof Code || attribute instanceof ExceptionTable)) {\n@@ -197,76 +261,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this method\n-     *\/\n-    public Method copy( final ConstantPool _constant_pool ) {\n-        return (Method) copy_(_constant_pool);\n-    }\n-\n-\n-    \/**\n-     * @return return type of method\n-     *\/\n-    public Type getReturnType() {\n-        return Type.getReturnType(getSignature());\n-    }\n-\n-\n-    \/**\n-     * @return array of method argument types\n-     *\/\n-    public Type[] getArgumentTypes() {\n-        return Type.getArgumentTypes(getSignature());\n-    }\n-\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator( final BCELComparator comparator ) {\n-        bcelComparator = comparator;\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default two method objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see java.lang.Object#equals(java.lang.Object)\n-     *\/\n-    @Override\n-    public boolean equals( final Object obj ) {\n-        return bcelComparator.equals(this, obj);\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default return the hashcode of the method's name XOR signature.\n-     *\n-     * @see java.lang.Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    \/**\n-     * @return Annotations on the parameters of a method\n-     * @since 6.0\n-     *\/\n-    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n-        if (parameterAnnotationEntries == null) {\n-            parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());\n-        }\n-        return parameterAnnotationEntries;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Method.java","additions":121,"deletions":133,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\">\n- * The class File Format : The MethodParameters Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\"> The class File Format :\n+ *      The MethodParameters Attribute<\/a>\n@@ -37,1 +37,1 @@\n-public class MethodParameter implements Cloneable {\n+public class MethodParameter implements Cloneable, Node {\n@@ -52,2 +52,2 @@\n-     * @throws java.io.IOException\n-     * @throws ClassFormatException\n+     * @throws IOException if an I\/O error occurs.\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -60,2 +60,3 @@\n-    public int getNameIndex() {\n-        return nameIndex;\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitMethodParameter(this);\n@@ -64,2 +65,10 @@\n-    public void setNameIndex(final int name_index) {\n-        this.nameIndex = name_index;\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public MethodParameter copy() {\n+        try {\n+            return (MethodParameter) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n@@ -69,1 +78,4 @@\n-     * Returns the name of the parameter.\n+     * Dump object to file stream on binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException if an I\/O error occurs.\n@@ -71,6 +83,4 @@\n-    public String getParameterName(final ConstantPool constant_pool) {\n-        if (nameIndex == 0) {\n-            return null;\n-        }\n-        return ((ConstantUtf8) constant_pool.getConstant(nameIndex, Const.CONSTANT_Utf8)).getBytes();\n-       }\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        file.writeShort(nameIndex);\n+        file.writeShort(accessFlags);\n+    }\n@@ -82,2 +92,2 @@\n-    public void setAccessFlags(final int access_flags) {\n-        this.accessFlags = access_flags;\n+    public int getNameIndex() {\n+        return nameIndex;\n@@ -86,2 +96,8 @@\n-    public boolean isFinal() {\n-        return (accessFlags & Const.ACC_FINAL) != 0;\n+    \/**\n+     * Returns the name of the parameter.\n+     *\/\n+    public String getParameterName(final ConstantPool constantPool) {\n+        if (nameIndex == 0) {\n+            return null;\n+        }\n+        return constantPool.getConstantUtf8(nameIndex).getBytes();\n@@ -90,2 +106,2 @@\n-    public boolean isSynthetic() {\n-        return (accessFlags & Const.ACC_SYNTHETIC) != 0;\n+    public boolean isFinal() {\n+        return (accessFlags & Const.ACC_FINAL) != 0;\n@@ -98,2 +114,2 @@\n-    public void accept(final Visitor v) {\n-        v.visitMethodParameter(this);\n+    public boolean isSynthetic() {\n+        return (accessFlags & Const.ACC_SYNTHETIC) != 0;\n@@ -102,9 +118,2 @@\n-    \/**\n-     * Dump object to file stream on binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException\n-     *\/\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        file.writeShort(nameIndex);\n-        file.writeShort(accessFlags);\n+    public void setAccessFlags(final int accessFlags) {\n+        this.accessFlags = accessFlags;\n@@ -113,10 +122,2 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public MethodParameter copy() {\n-        try {\n-            return (MethodParameter) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public void setNameIndex(final int nameIndex) {\n+        this.nameIndex = nameIndex;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameter.java","additions":44,"deletions":43,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n@@ -33,2 +36,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\">\n- * The class File Format : The MethodParameters Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\"> The class File Format :\n+ *      The MethodParameters Attribute<\/a>\n@@ -37,1 +40,1 @@\n-public class MethodParameters extends Attribute {\n+public class MethodParameters extends Attribute implements Iterable<MethodParameter> {\n@@ -39,1 +42,6 @@\n-    private MethodParameter[] parameters = new MethodParameter[0];\n+    \/**\n+     * Empty array.\n+     *\/\n+    private static final MethodParameter[] EMPTY_METHOD_PARAMETER_ARRAY = {};\n+\n+    private MethodParameter[] parameters = EMPTY_METHOD_PARAMETER_ARRAY;\n@@ -41,2 +49,2 @@\n-    MethodParameters(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        super(Const.ATTR_METHOD_PARAMETERS, name_index, length, constant_pool);\n+    MethodParameters(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        super(Const.ATTR_METHOD_PARAMETERS, nameIndex, length, constantPool);\n@@ -44,3 +52,3 @@\n-        final int parameters_count = input.readUnsignedByte();\n-        parameters = new MethodParameter[parameters_count];\n-        for (int i = 0; i < parameters_count; i++) {\n+        final int parameterCount = input.readUnsignedByte();\n+        parameters = new MethodParameter[parameterCount];\n+        for (int i = 0; i < parameterCount; i++) {\n@@ -51,8 +59,0 @@\n-    public MethodParameter[] getParameters() {\n-        return parameters;\n-    }\n-\n-    public void setParameters(final MethodParameter[] parameters) {\n-        this.parameters = parameters;\n-    }\n-\n@@ -65,1 +65,1 @@\n-    public Attribute copy(final ConstantPool _constant_pool) {\n+    public Attribute copy(final ConstantPool constantPool) {\n@@ -69,4 +69,2 @@\n-        for (int i = 0; i < parameters.length; i++) {\n-            c.parameters[i] = parameters[i].copy();\n-        }\n-        c.setConstantPool(_constant_pool);\n+        Arrays.setAll(c.parameters, i -> parameters[i].copy());\n+        c.setConstantPool(constantPool);\n@@ -80,1 +78,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -83,3 +81,3 @@\n-       public void dump(final DataOutputStream file) throws IOException {\n-           super.dump(file);\n-           file.writeByte(parameters.length);\n+    public void dump(final DataOutputStream file) throws IOException {\n+        super.dump(file);\n+        file.writeByte(parameters.length);\n@@ -90,0 +88,13 @@\n+\n+    public MethodParameter[] getParameters() {\n+        return parameters;\n+    }\n+\n+    @Override\n+    public Iterator<MethodParameter> iterator() {\n+        return Stream.of(parameters).iterator();\n+    }\n+\n+    public void setParameters(final MethodParameter[] parameters) {\n+        this.parameters = parameters;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameters.java","additions":37,"deletions":26,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.Arrays;\n@@ -31,3 +32,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents the list of\n- * modules required, exported, opened or provided by a module.\n- * There may be at most one Module attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and represents the list of modules required, exported, opened or\n+ * provided by a module. There may be at most one Module attribute in a ClassFile structure.\n@@ -35,1 +35,1 @@\n- * @see   Attribute\n+ * @see Attribute\n@@ -40,0 +40,7 @@\n+    \/**\n+     * The module file name extension.\n+     *\n+     * @since 6.7.0\n+     *\/\n+    public static final String EXTENSION = \".jmod\";\n+\n@@ -53,1 +60,2 @@\n-     * @param name_index Index in constant pool\n+     *\n+     * @param nameIndex Index in constant pool\n@@ -56,2 +64,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -59,2 +67,2 @@\n-    Module(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        super(Const.ATTR_MODULE, name_index, length, constant_pool);\n+    Module(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        super(Const.ATTR_MODULE, nameIndex, length, constantPool);\n@@ -66,3 +74,3 @@\n-        final int requires_count = input.readUnsignedShort();\n-        requiresTable = new ModuleRequires[requires_count];\n-        for (int i = 0; i < requires_count; i++) {\n+        final int requiresCount = input.readUnsignedShort();\n+        requiresTable = new ModuleRequires[requiresCount];\n+        for (int i = 0; i < requiresCount; i++) {\n@@ -72,3 +80,3 @@\n-        final int exports_count = input.readUnsignedShort();\n-        exportsTable = new ModuleExports[exports_count];\n-        for (int i = 0; i < exports_count; i++) {\n+        final int exportsCount = input.readUnsignedShort();\n+        exportsTable = new ModuleExports[exportsCount];\n+        for (int i = 0; i < exportsCount; i++) {\n@@ -78,3 +86,3 @@\n-        final int opens_count = input.readUnsignedShort();\n-        opensTable = new ModuleOpens[opens_count];\n-        for (int i = 0; i < opens_count; i++) {\n+        final int opensCount = input.readUnsignedShort();\n+        opensTable = new ModuleOpens[opensCount];\n+        for (int i = 0; i < opensCount; i++) {\n@@ -90,3 +98,3 @@\n-        final int provides_count = input.readUnsignedShort();\n-        providesTable = new ModuleProvides[provides_count];\n-        for (int i = 0; i < provides_count; i++) {\n+        final int providesCount = input.readUnsignedShort();\n+        providesTable = new ModuleProvides[providesCount];\n+        for (int i = 0; i < providesCount; i++) {\n@@ -97,1 +105,0 @@\n-\n@@ -99,3 +106,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -106,1 +112,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -113,2 +119,1 @@\n-     * @return table of required modules\n-     * @see ModuleRequires\n+     * @return deep copy of this attribute\n@@ -116,4 +121,3 @@\n-    public ModuleRequires[] getRequiresTable() {\n-        return requiresTable;\n-    }\n-\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final Module c = (Module) clone();\n@@ -121,7 +125,2 @@\n-    \/**\n-     * @return table of exported interfaces\n-     * @see ModuleExports\n-     *\/\n-    public ModuleExports[] getExportsTable() {\n-        return exportsTable;\n-    }\n+        c.requiresTable = new ModuleRequires[requiresTable.length];\n+        Arrays.setAll(c.requiresTable, i -> requiresTable[i].copy());\n@@ -129,0 +128,2 @@\n+        c.exportsTable = new ModuleExports[exportsTable.length];\n+        Arrays.setAll(c.exportsTable, i -> exportsTable[i].copy());\n@@ -130,7 +131,2 @@\n-    \/**\n-     * @return table of provided interfaces\n-     * @see ModuleOpens\n-     *\/\n-    public ModuleOpens[] getOpensTable() {\n-        return opensTable;\n-    }\n+        c.opensTable = new ModuleOpens[opensTable.length];\n+        Arrays.setAll(c.opensTable, i -> opensTable[i].copy());\n@@ -138,0 +134,2 @@\n+        c.providesTable = new ModuleProvides[providesTable.length];\n+        Arrays.setAll(c.providesTable, i -> providesTable[i].copy());\n@@ -139,6 +137,2 @@\n-    \/**\n-     * @return table of provided interfaces\n-     * @see ModuleProvides\n-     *\/\n-    public ModuleProvides[] getProvidesTable() {\n-        return providesTable;\n+        c.setConstantPool(constantPool);\n+        return c;\n@@ -147,1 +141,0 @@\n-\n@@ -152,1 +145,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -155,1 +148,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -188,0 +181,31 @@\n+    \/**\n+     * @return table of exported interfaces\n+     * @see ModuleExports\n+     *\/\n+    public ModuleExports[] getExportsTable() {\n+        return exportsTable;\n+    }\n+\n+    \/**\n+     * @return table of provided interfaces\n+     * @see ModuleOpens\n+     *\/\n+    public ModuleOpens[] getOpensTable() {\n+        return opensTable;\n+    }\n+\n+    \/**\n+     * @return table of provided interfaces\n+     * @see ModuleProvides\n+     *\/\n+    public ModuleProvides[] getProvidesTable() {\n+        return providesTable;\n+    }\n+\n+    \/**\n+     * @return table of required modules\n+     * @see ModuleRequires\n+     *\/\n+    public ModuleRequires[] getRequiresTable() {\n+        return requiresTable;\n+    }\n@@ -197,2 +221,2 @@\n-        buf.append(\"  name:    \") .append(cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module).replace('\/', '.')).append(\"\\n\");\n-        buf.append(\"  flags:   \") .append(String.format(\"%04x\", moduleFlags)).append(\"\\n\");\n+        buf.append(\"  name:    \").append(Utility.pathToPackage(cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module))).append(\"\\n\");\n+        buf.append(\"  flags:   \").append(String.format(\"%04x\", moduleFlags)).append(\"\\n\");\n@@ -200,1 +224,1 @@\n-        buf.append(\"  version: \") .append(version).append(\"\\n\");\n+        buf.append(\"  version: \").append(version).append(\"\\n\");\n@@ -219,2 +243,2 @@\n-            final String class_name = cp.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"    \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n+            final String className = cp.getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"    \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n@@ -228,33 +252,1 @@\n-        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final Module c = (Module) clone();\n-\n-        c.requiresTable = new ModuleRequires[requiresTable.length];\n-        for (int i = 0; i < requiresTable.length; i++) {\n-            c.requiresTable[i] = requiresTable[i].copy();\n-        }\n-\n-        c.exportsTable = new ModuleExports[exportsTable.length];\n-        for (int i = 0; i < exportsTable.length; i++) {\n-            c.exportsTable[i] = exportsTable[i].copy();\n-        }\n-\n-        c.opensTable = new ModuleOpens[opensTable.length];\n-        for (int i = 0; i < opensTable.length; i++) {\n-            c.opensTable[i] = opensTable[i].copy();\n-        }\n-\n-        c.providesTable = new ModuleProvides[providesTable.length];\n-        for (int i = 0; i < providesTable.length; i++) {\n-            c.providesTable[i] = providesTable[i].copy();\n-        }\n-\n-        c.setConstantPool(_constant_pool);\n-        return c;\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Module.java","additions":85,"deletions":93,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the exports table of the Module attribute.\n- * Each entry describes a package which may open the parent module.\n+ * This class represents an entry in the exports table of the Module attribute. Each entry describes a package which may\n+ * open the parent module.\n@@ -34,1 +34,1 @@\n- * @see   Module\n+ * @see Module\n@@ -39,1 +39,1 @@\n-    private final int exportsIndex;  \/\/ points to CONSTANT_Package_info\n+    private final int exportsIndex; \/\/ points to CONSTANT_Package_info\n@@ -42,2 +42,1 @@\n-    private final int[] exportsToIndex;  \/\/ points to CONSTANT_Module_info\n-\n+    private final int[] exportsToIndex; \/\/ points to CONSTANT_Module_info\n@@ -61,1 +60,0 @@\n-\n@@ -63,3 +61,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -70,1 +67,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -76,0 +73,12 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleExports copy() {\n+        try {\n+            return (ModuleExports) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n+\n@@ -82,1 +91,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -91,1 +100,0 @@\n-\n@@ -100,1 +108,0 @@\n-\n@@ -104,1 +111,1 @@\n-    public String toString( final ConstantPool constant_pool ) {\n+    public String toString(final ConstantPool constantPool) {\n@@ -106,2 +113,2 @@\n-        final String package_name = constant_pool.constantToString(exportsIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(package_name, false));\n+        final String packageName = constantPool.constantToString(exportsIndex, Const.CONSTANT_Package);\n+        buf.append(Utility.compactClassName(packageName, false));\n@@ -111,15 +118,2 @@\n-            final String module_name = constant_pool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(module_name, false)).append(\"\\n\");\n-        }\n-        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleExports copy() {\n-        try {\n-            return (ModuleExports) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n+            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n+            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n@@ -127,1 +121,1 @@\n-        return null;\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleExports.java","additions":27,"deletions":33,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +32,2 @@\n- * This class is derived from <em>Attribute<\/em> and indicates the main class of a module.\n- * There may be at most one ModuleMainClass attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and indicates the main class of a module. There may be at most one\n+ * ModuleMainClass attribute in a ClassFile structure.\n@@ -34,1 +35,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -40,1 +41,0 @@\n-\n@@ -42,2 +42,7 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+     * Construct object from input stream.\n+     *\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -45,2 +50,3 @@\n-    public ModuleMainClass(final ModuleMainClass c) {\n-        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n+    ModuleMainClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, 0, constantPool);\n+        mainClassIndex = input.readUnsignedShort();\n@@ -49,1 +55,0 @@\n-\n@@ -51,1 +56,1 @@\n-     * @param name_index Index in constant pool\n+     * @param nameIndex Index in constant pool\n@@ -56,4 +61,3 @@\n-    public ModuleMainClass(final int name_index, final int length, final int mainClassIndex,\n-            final ConstantPool constantPool) {\n-        super(Const.ATTR_NEST_MEMBERS, name_index, length, constantPool);\n-        this.mainClassIndex = mainClassIndex;\n+    public ModuleMainClass(final int nameIndex, final int length, final int mainClassIndex, final ConstantPool constantPool) {\n+        super(Const.ATTR_NEST_MEMBERS, nameIndex, length, constantPool);\n+        this.mainClassIndex = Args.requireU2(mainClassIndex, \"mainClassIndex\");\n@@ -62,1 +66,0 @@\n-\n@@ -64,6 +67,4 @@\n-     * Construct object from input stream.\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -71,3 +72,2 @@\n-    ModuleMainClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, 0, constantPool);\n-        mainClassIndex = input.readUnsignedShort();\n+    public ModuleMainClass(final ModuleMainClass c) {\n+        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n@@ -76,1 +76,0 @@\n-\n@@ -78,3 +77,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n+     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -85,1 +83,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -89,0 +87,9 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final ModuleMainClass c = (ModuleMainClass) clone();\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -97,1 +104,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -102,1 +109,0 @@\n-\n@@ -110,1 +116,0 @@\n-\n@@ -114,1 +119,1 @@\n-    public void setHostClassIndex( final int mainClassIndex ) {\n+    public void setHostClassIndex(final int mainClassIndex) {\n@@ -118,1 +123,0 @@\n-\n@@ -126,2 +130,2 @@\n-        final String class_name = super.getConstantPool().getConstantString(mainClassIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(class_name, false));\n+        final String className = super.getConstantPool().getConstantString(mainClassIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(className, false));\n@@ -130,11 +134,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final ModuleMainClass c = (ModuleMainClass) clone();\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleMainClass.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the opens table of the Module attribute.\n- * Each entry describes a package which the parent module opens.\n+ * This class represents an entry in the opens table of the Module attribute. Each entry describes a package which the\n+ * parent module opens.\n@@ -34,1 +34,1 @@\n- * @see   Module\n+ * @see Module\n@@ -39,1 +39,1 @@\n-    private final int opensIndex;  \/\/ points to CONSTANT_Package_info\n+    private final int opensIndex; \/\/ points to CONSTANT_Package_info\n@@ -42,2 +42,1 @@\n-    private final int[] opensToIndex;  \/\/ points to CONSTANT_Module_info\n-\n+    private final int[] opensToIndex; \/\/ points to CONSTANT_Module_info\n@@ -61,1 +60,0 @@\n-\n@@ -63,3 +61,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -70,1 +67,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -76,0 +73,12 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleOpens copy() {\n+        try {\n+            return (ModuleOpens) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n+\n@@ -82,1 +91,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -91,1 +100,0 @@\n-\n@@ -100,1 +108,0 @@\n-\n@@ -104,1 +111,1 @@\n-    public String toString( final ConstantPool constant_pool ) {\n+    public String toString(final ConstantPool constantPool) {\n@@ -106,2 +113,2 @@\n-        final String package_name = constant_pool.constantToString(opensIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(package_name, false));\n+        final String packageName = constantPool.constantToString(opensIndex, Const.CONSTANT_Package);\n+        buf.append(Utility.compactClassName(packageName, false));\n@@ -111,15 +118,2 @@\n-            final String module_name = constant_pool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(module_name, false)).append(\"\\n\");\n-        }\n-        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleOpens copy() {\n-        try {\n-            return (ModuleOpens) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n+            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n+            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n@@ -127,1 +121,1 @@\n-        return null;\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleOpens.java","additions":27,"deletions":33,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +26,1 @@\n+import java.util.Arrays;\n@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +32,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents the list of packages that are exported or opened by the Module attribute.\n- * There may be at most one ModulePackages attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and represents the list of packages that are exported or opened by the\n+ * Module attribute. There may be at most one ModulePackages attribute in a ClassFile structure.\n@@ -34,1 +35,2 @@\n- * @see     Attribute\n+ * @see Attribute\n+ * @LastModified: Feb 2023\n@@ -40,1 +42,0 @@\n-\n@@ -42,2 +43,7 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+     * Construct object from input stream.\n+     *\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -45,2 +51,7 @@\n-    public ModulePackages(final ModulePackages c) {\n-        this(c.getNameIndex(), c.getLength(), c.getPackageIndexTable(), c.getConstantPool());\n+    ModulePackages(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (int[]) null, constantPool);\n+        final int packageCount = input.readUnsignedShort();\n+        packageIndexTable = new int[packageCount];\n+        for (int i = 0; i < packageCount; i++) {\n+            packageIndexTable[i] = input.readUnsignedShort();\n+        }\n@@ -49,1 +60,0 @@\n-\n@@ -56,2 +66,1 @@\n-    public ModulePackages(final int nameIndex, final int length, final int[] packageIndexTable,\n-            final ConstantPool constantPool) {\n+    public ModulePackages(final int nameIndex, final int length, final int[] packageIndexTable, final ConstantPool constantPool) {\n@@ -59,1 +68,2 @@\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : new int[0];\n+        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n+        Args.requireU2(this.packageIndexTable.length, \"packageIndexTable.length\");\n@@ -62,1 +72,0 @@\n-\n@@ -64,6 +73,4 @@\n-     * Construct object from input stream.\n-     * @param name_index Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -71,7 +78,2 @@\n-    ModulePackages(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        this(name_index, length, (int[]) null, constant_pool);\n-        final int number_of_packages = input.readUnsignedShort();\n-        packageIndexTable = new int[number_of_packages];\n-        for (int i = 0; i < number_of_packages; i++) {\n-            packageIndexTable[i] = input.readUnsignedShort();\n-        }\n+    public ModulePackages(final ModulePackages c) {\n+        this(c.getNameIndex(), c.getLength(), c.getPackageIndexTable(), c.getConstantPool());\n@@ -80,1 +82,0 @@\n-\n@@ -82,3 +83,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +89,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -93,0 +93,12 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final ModulePackages c = (ModulePackages) clone();\n+        if (packageIndexTable != null) {\n+            c.packageIndexTable = packageIndexTable.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -98,1 +110,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -101,1 +113,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -109,9 +121,0 @@\n-\n-    \/**\n-     * @return array of indices into constant pool of package names.\n-     *\/\n-    public int[] getPackageIndexTable() {\n-        return packageIndexTable;\n-    }\n-\n-\n@@ -125,0 +128,6 @@\n+    \/**\n+     * @return array of indices into constant pool of package names.\n+     *\/\n+    public int[] getPackageIndexTable() {\n+        return packageIndexTable;\n+    }\n@@ -131,4 +140,1 @@\n-        for (int i = 0; i < packageIndexTable.length; i++) {\n-            names[i] = super.getConstantPool().getConstantString(packageIndexTable[i],\n-                    Const.CONSTANT_Package).replace('\/', '.');\n-        }\n+        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(packageIndexTable[i], Const.CONSTANT_Package)));\n@@ -138,1 +144,0 @@\n-\n@@ -140,2 +145,1 @@\n-     * @param packageIndexTable the list of package indexes\n-     * Also redefines number_of_packages according to table length.\n+     * @param packageIndexTable the list of package indexes Also redefines number_of_packages according to table length.\n@@ -143,2 +147,2 @@\n-    public void setPackageIndexTable( final int[] packageIndexTable ) {\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : new int[0];\n+    public void setPackageIndexTable(final int[] packageIndexTable) {\n+        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n@@ -147,1 +151,0 @@\n-\n@@ -158,2 +161,2 @@\n-            final String package_name = super.getConstantPool().getConstantString(index, Const.CONSTANT_Package);\n-            buf.append(\"  \").append(Utility.compactClassName(package_name, false)).append(\"\\n\");\n+            final String packageName = super.getConstantPool().getConstantString(index, Const.CONSTANT_Package);\n+            buf.append(\"  \").append(Utility.compactClassName(packageName, false)).append(\"\\n\");\n@@ -161,17 +164,1 @@\n-        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final ModulePackages c = (ModulePackages) clone();\n-        if (packageIndexTable != null) {\n-            c.packageIndexTable = new int[packageIndexTable.length];\n-            System.arraycopy(packageIndexTable, 0, c.packageIndexTable, 0,\n-                    packageIndexTable.length);\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModulePackages.java","additions":60,"deletions":73,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the provides table of the Module attribute.\n- * Each entry describes a service implementation that the parent module provides.\n+ * This class represents an entry in the provides table of the Module attribute. Each entry describes a service\n+ * implementation that the parent module provides.\n@@ -34,1 +34,1 @@\n- * @see   Module\n+ * @see Module\n@@ -39,1 +39,1 @@\n-    private final int providesIndex;  \/\/ points to CONSTANT_Class_info\n+    private final int providesIndex; \/\/ points to CONSTANT_Class_info\n@@ -41,2 +41,1 @@\n-    private final int[] providesWithIndex;  \/\/ points to CONSTANT_Class_info\n-\n+    private final int[] providesWithIndex; \/\/ points to CONSTANT_Class_info\n@@ -59,1 +58,0 @@\n-\n@@ -61,3 +59,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -68,1 +65,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -74,0 +71,12 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleProvides copy() {\n+        try {\n+            return (ModuleProvides) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n+\n@@ -80,1 +89,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -88,1 +97,0 @@\n-\n@@ -97,1 +105,0 @@\n-\n@@ -101,1 +108,1 @@\n-    public String toString( final ConstantPool constant_pool ) {\n+    public String toString(final ConstantPool constantPool) {\n@@ -103,2 +110,2 @@\n-        final String interface_name = constant_pool.constantToString(providesIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(interface_name, false));\n+        final String interfaceName = constantPool.constantToString(providesIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(interfaceName, false));\n@@ -107,15 +114,2 @@\n-            final String class_name = constant_pool.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"      \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n-        }\n-        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleProvides copy() {\n-        try {\n-            return (ModuleProvides) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n+            final String className = constantPool.getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"      \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n@@ -123,1 +117,1 @@\n-        return null;\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleProvides.java","additions":27,"deletions":33,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the requires table of the Module attribute.\n- * Each entry describes a module on which the parent module depends.\n+ * This class represents an entry in the requires table of the Module attribute. Each entry describes a module on which\n+ * the parent module depends.\n@@ -34,1 +34,1 @@\n- * @see   Module\n+ * @see Module\n@@ -39,1 +39,1 @@\n-    private final int requiresIndex;  \/\/ points to CONSTANT_Module_info\n+    private final int requiresIndex; \/\/ points to CONSTANT_Module_info\n@@ -41,2 +41,1 @@\n-    private final int requiresVersionIndex;  \/\/ either 0 or points to CONSTANT_Utf8_info\n-\n+    private final int requiresVersionIndex; \/\/ either 0 or points to CONSTANT_Utf8_info\n@@ -56,1 +55,0 @@\n-\n@@ -58,3 +56,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -65,1 +62,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -71,0 +68,12 @@\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleRequires copy() {\n+        try {\n+            return (ModuleRequires) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n+\n@@ -77,1 +86,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -83,1 +92,0 @@\n-\n@@ -92,1 +100,0 @@\n-\n@@ -96,1 +103,1 @@\n-    public String toString( final ConstantPool constant_pool ) {\n+    public String toString(final ConstantPool constantPool) {\n@@ -98,2 +105,2 @@\n-        final String module_name = constant_pool.constantToString(requiresIndex, Const.CONSTANT_Module);\n-        buf.append(Utility.compactClassName(module_name, false));\n+        final String moduleName = constantPool.constantToString(requiresIndex, Const.CONSTANT_Module);\n+        buf.append(Utility.compactClassName(moduleName, false));\n@@ -101,1 +108,1 @@\n-        final String version = requiresVersionIndex == 0 ? \"0\" : constant_pool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n+        final String version = requiresVersionIndex == 0 ? \"0\" : constantPool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n@@ -105,13 +112,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleRequires copy() {\n-        try {\n-            return (ModuleRequires) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleRequires.java","additions":25,"deletions":31,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,3 +32,2 @@\n- * This class is derived from <em>Attribute<\/em> and records the nest host of the nest\n- * to which the current class or interface claims to belong.\n- * There may be at most one NestHost attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and records the nest host of the nest to which the current class or\n+ * interface claims to belong. There may be at most one NestHost attribute in a ClassFile structure.\n@@ -35,1 +35,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -41,1 +41,0 @@\n-\n@@ -43,2 +42,7 @@\n-     * Initializes from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+     * Constructs object from input stream.\n+     *\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -46,2 +50,3 @@\n-    public NestHost(final NestHost c) {\n-        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n+    NestHost(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, 0, constantPool);\n+        hostClassIndex = input.readUnsignedShort();\n@@ -50,1 +55,0 @@\n-\n@@ -57,2 +61,1 @@\n-    public NestHost(final int nameIndex, final int length, final int hostClassIndex,\n-            final ConstantPool constantPool) {\n+    public NestHost(final int nameIndex, final int length, final int hostClassIndex, final ConstantPool constantPool) {\n@@ -60,1 +63,1 @@\n-        this.hostClassIndex = hostClassIndex;\n+        this.hostClassIndex = Args.requireU2(hostClassIndex, \"hostClassIndex\");\n@@ -63,1 +66,0 @@\n-\n@@ -65,6 +67,4 @@\n-     * Constructs object from input stream.\n-     * @param name_index Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * Initializes from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -72,3 +72,2 @@\n-    NestHost(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        this(name_index, length, 0, constant_pool);\n-        hostClassIndex = input.readUnsignedShort();\n+    public NestHost(final NestHost c) {\n+        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n@@ -77,1 +76,0 @@\n-\n@@ -79,3 +77,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -86,1 +83,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -90,0 +87,9 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final NestHost c = (NestHost) clone();\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -98,1 +104,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -103,1 +109,0 @@\n-\n@@ -111,1 +116,0 @@\n-\n@@ -115,1 +119,1 @@\n-    public void setHostClassIndex( final int hostClassIndex ) {\n+    public void setHostClassIndex(final int hostClassIndex) {\n@@ -119,1 +123,0 @@\n-\n@@ -127,2 +130,2 @@\n-        final String class_name = super.getConstantPool().getConstantString(hostClassIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(class_name, false));\n+        final String className = super.getConstantPool().getConstantString(hostClassIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(className, false));\n@@ -131,11 +134,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final NestHost c = (NestHost) clone();\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/NestHost.java","additions":38,"deletions":46,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +26,1 @@\n+import java.util.Arrays;\n@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,3 +32,3 @@\n- * This class is derived from <em>Attribute<\/em> and records the classes and interfaces that\n- * are authorized to claim membership in the nest hosted by the current class or interface.\n- * There may be at most one NestMembers attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and records the classes and interfaces that are authorized to claim\n+ * membership in the nest hosted by the current class or interface. There may be at most one NestMembers attribute in a\n+ * ClassFile structure.\n@@ -35,1 +36,2 @@\n- * @see     Attribute\n+ * @see Attribute\n+ * @LastModified: Feb 2023\n@@ -41,1 +43,0 @@\n-\n@@ -43,2 +44,7 @@\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n+     * Construct object from input stream.\n+     *\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -46,2 +52,7 @@\n-    public NestMembers(final NestMembers c) {\n-        this(c.getNameIndex(), c.getLength(), c.getClasses(), c.getConstantPool());\n+    NestMembers(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (int[]) null, constantPool);\n+        final int classCount = input.readUnsignedShort();\n+        classes = new int[classCount];\n+        for (int i = 0; i < classCount; i++) {\n+            classes[i] = input.readUnsignedShort();\n+        }\n@@ -50,1 +61,0 @@\n-\n@@ -52,1 +62,1 @@\n-     * @param name_index Index in constant pool\n+     * @param nameIndex Index in constant pool\n@@ -55,1 +65,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -57,4 +67,4 @@\n-    public NestMembers(final int name_index, final int length, final int[] classes,\n-            final ConstantPool constant_pool) {\n-        super(Const.ATTR_NEST_MEMBERS, name_index, length, constant_pool);\n-        this.classes = classes != null ? classes : new int[0];\n+    public NestMembers(final int nameIndex, final int length, final int[] classes, final ConstantPool constantPool) {\n+        super(Const.ATTR_NEST_MEMBERS, nameIndex, length, constantPool);\n+        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n+        Args.requireU2(this.classes.length, \"classes.length\");\n@@ -63,1 +73,0 @@\n-\n@@ -65,6 +74,4 @@\n-     * Construct object from input stream.\n-     * @param name_index Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n@@ -72,7 +79,2 @@\n-    NestMembers(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        this(name_index, length, (int[]) null, constant_pool);\n-        final int number_of_classes = input.readUnsignedShort();\n-        classes = new int[number_of_classes];\n-        for (int i = 0; i < number_of_classes; i++) {\n-            classes[i] = input.readUnsignedShort();\n-        }\n+    public NestMembers(final NestMembers c) {\n+        this(c.getNameIndex(), c.getLength(), c.getClasses(), c.getConstantPool());\n@@ -81,1 +83,0 @@\n-\n@@ -83,3 +84,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -90,1 +90,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -94,0 +94,12 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final NestMembers c = (NestMembers) clone();\n+        if (classes.length > 0) {\n+            c.classes = classes.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -99,1 +111,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -102,1 +114,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -110,1 +122,0 @@\n-\n@@ -118,9 +129,0 @@\n-\n-    \/**\n-     * @return Length of classes table.\n-     *\/\n-    public int getNumberClasses() {\n-        return classes == null ? 0 : classes.length;\n-    }\n-\n-\n@@ -132,4 +134,1 @@\n-        for (int i = 0; i < classes.length; i++) {\n-            names[i] = super.getConstantPool().getConstantString(classes[i],\n-                    Const.CONSTANT_Class).replace('\/', '.');\n-        }\n+        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(classes[i], Const.CONSTANT_Class)));\n@@ -139,1 +138,0 @@\n-\n@@ -141,2 +139,1 @@\n-     * @param classes the list of class indexes\n-     * Also redefines number_of_classes according to table length.\n+     * @return Length of classes table.\n@@ -144,2 +141,2 @@\n-    public void setClasses( final int[] classes ) {\n-        this.classes = classes != null ? classes : new int[0];\n+    public int getNumberClasses() {\n+        return classes.length;\n@@ -148,0 +145,6 @@\n+    \/**\n+     * @param classes the list of class indexes Also redefines number_of_classes according to table length.\n+     *\/\n+    public void setClasses(final int[] classes) {\n+        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n+    }\n@@ -159,2 +162,2 @@\n-            final String class_name = super.getConstantPool().getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"  \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n+            final String className = super.getConstantPool().getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"  \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n@@ -162,17 +165,1 @@\n-        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n-    }\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final NestMembers c = (NestMembers) clone();\n-        if (classes != null) {\n-            c.classes = new int[classes.length];\n-            System.arraycopy(classes, 0, c.classes, 0,\n-                    classes.length);\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n+        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/NestMembers.java","additions":64,"deletions":77,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -30,1 +29,1 @@\n-    void accept( Visitor obj );\n+    void accept(Visitor obj);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Node.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference\n- * to a PMG attribute.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference to a PMG attribute.\n@@ -34,1 +33,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -41,11 +40,0 @@\n-\n-    \/**\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n-     *\/\n-    public PMGClass(final PMGClass pgmClass) {\n-        this(pgmClass.getNameIndex(), pgmClass.getLength(), pgmClass.getPMGIndex(), pgmClass.getPMGClassIndex(),\n-            pgmClass.getConstantPool());\n-    }\n-\n-\n@@ -54,1 +42,2 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     *\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -57,2 +46,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -60,3 +49,2 @@\n-    PMGClass(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, input.readUnsignedShort(), input.readUnsignedShort(), constant_pool);\n+    PMGClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, input.readUnsignedShort(), input.readUnsignedShort(), constantPool);\n@@ -65,1 +53,0 @@\n-\n@@ -67,1 +54,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -73,3 +60,2 @@\n-    public PMGClass(final int name_index, final int length, final int pmgIndex, final int pmgClassIndex,\n-            final ConstantPool constantPool) {\n-        super(Const.ATTR_PMG, name_index, length, constantPool);\n+    public PMGClass(final int nameIndex, final int length, final int pmgIndex, final int pmgClassIndex, final ConstantPool constantPool) {\n+        super(Const.ATTR_PMG, nameIndex, length, constantPool);\n@@ -80,0 +66,9 @@\n+    \/**\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param pgmClass Source to copy.\n+     *\/\n+    public PMGClass(final PMGClass pgmClass) {\n+        this(pgmClass.getNameIndex(), pgmClass.getLength(), pgmClass.getPMGIndex(), pgmClass.getPMGClassIndex(), pgmClass.getConstantPool());\n+    }\n@@ -82,3 +77,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +83,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -93,0 +87,7 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        return (Attribute) clone();\n+    }\n@@ -98,1 +99,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -101,1 +102,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -107,1 +108,0 @@\n-\n@@ -115,1 +115,0 @@\n-\n@@ -117,1 +116,1 @@\n-     * @param pmgClassIndex\n+     * @return PMG class name.\n@@ -119,2 +118,2 @@\n-    public void setPMGClassIndex( final int pmgClassIndex ) {\n-        this.pmgClassIndex = pmgClassIndex;\n+    public String getPMGClassName() {\n+        return super.getConstantPool().getConstantUtf8(pmgClassIndex).getBytes();\n@@ -123,1 +122,0 @@\n-\n@@ -131,1 +129,0 @@\n-\n@@ -133,1 +130,1 @@\n-     * @param pmgIndex\n+     * @return PMG name.\n@@ -135,2 +132,2 @@\n-    public void setPMGIndex( final int pmgIndex ) {\n-        this.pmgIndex = pmgIndex;\n+    public String getPMGName() {\n+        return super.getConstantPool().getConstantUtf8(pmgIndex).getBytes();\n@@ -139,1 +136,0 @@\n-\n@@ -141,1 +137,1 @@\n-     * @return PMG name.\n+     * @param pmgClassIndex\n@@ -143,4 +139,2 @@\n-    public String getPMGName() {\n-        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(pmgIndex,\n-                Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+    public void setPMGClassIndex(final int pmgClassIndex) {\n+        this.pmgClassIndex = pmgClassIndex;\n@@ -149,1 +143,0 @@\n-\n@@ -151,1 +144,1 @@\n-     * @return PMG class name.\n+     * @param pmgIndex\n@@ -153,4 +146,2 @@\n-    public String getPMGClassName() {\n-        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(pmgClassIndex,\n-                Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+    public void setPMGIndex(final int pmgIndex) {\n+        this.pmgIndex = pmgIndex;\n@@ -159,1 +150,0 @@\n-\n@@ -167,9 +157,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        return (Attribute) clone();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/PMGClass.java","additions":44,"deletions":63,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-    private final AnnotationEntry[] annotationTable;\n+    static final ParameterAnnotationEntry[] EMPTY_ARRAY = {};\n@@ -40,0 +40,13 @@\n+    public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attrs) {\n+        \/\/ Find attributes that contain parameter annotation data\n+        final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n+        for (final Attribute attribute : attrs) {\n+            if (attribute instanceof ParameterAnnotations) {\n+                final ParameterAnnotations runtimeAnnotations = (ParameterAnnotations) attribute;\n+                Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getParameterAnnotationEntries());\n+            }\n+        }\n+        return accumulatedAnnotations.toArray(ParameterAnnotationEntry.EMPTY_ARRAY);\n+    }\n+\n+    private final AnnotationEntry[] annotationTable;\n@@ -45,1 +58,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -47,4 +60,4 @@\n-    ParameterAnnotationEntry(final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        final int annotation_table_length = input.readUnsignedShort();\n-        annotationTable = new AnnotationEntry[annotation_table_length];\n-        for (int i = 0; i < annotation_table_length; i++) {\n+    ParameterAnnotationEntry(final DataInput input, final ConstantPool constantPool) throws IOException {\n+        final int annotationTableLength = input.readUnsignedShort();\n+        annotationTable = new AnnotationEntry[annotationTableLength];\n+        for (int i = 0; i < annotationTableLength; i++) {\n@@ -52,1 +65,1 @@\n-            annotationTable[i] = AnnotationEntry.read(input, constant_pool, false);\n+            annotationTable[i] = AnnotationEntry.read(input, constantPool, false);\n@@ -56,1 +69,0 @@\n-\n@@ -58,3 +70,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -65,1 +76,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,7 +80,0 @@\n-    \/**\n-     * returns the array of annotation entries in this annotation\n-     *\/\n-    public AnnotationEntry[] getAnnotationEntries() {\n-        return annotationTable;\n-    }\n-\n@@ -83,11 +87,6 @@\n-  public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attrs) {\n-      \/\/ Find attributes that contain parameter annotation data\n-      final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n-      for (final Attribute attribute : attrs) {\n-          if (attribute instanceof ParameterAnnotations) {\n-              final ParameterAnnotations runtimeAnnotations = (ParameterAnnotations)attribute;\n-              Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getParameterAnnotationEntries());\n-          }\n-      }\n-      return accumulatedAnnotations.toArray(new ParameterAnnotationEntry[accumulatedAnnotations.size()]);\n-  }\n+    \/**\n+     * returns the array of annotation entries in this annotation\n+     *\/\n+    public AnnotationEntry[] getAnnotationEntries() {\n+        return annotationTable;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotationEntry.java","additions":29,"deletions":30,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Iterator;\n+import java.util.stream.Stream;\n@@ -33,1 +35,1 @@\n-public abstract class ParameterAnnotations extends Attribute {\n+public abstract class ParameterAnnotations extends Attribute implements Iterable<ParameterAnnotationEntry> {\n@@ -39,2 +41,2 @@\n-     * @param parameter_annotation_type the subclass type of the parameter annotation\n-     * @param name_index Index pointing to the name <em>Code<\/em>\n+     * @param parameterAnnotationType the subclass type of the parameter annotation\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n@@ -43,1 +45,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -45,8 +47,7 @@\n-    ParameterAnnotations(final byte parameter_annotation_type, final int name_index, final int length,\n-            final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        this(parameter_annotation_type, name_index, length, (ParameterAnnotationEntry[]) null,\n-                constant_pool);\n-        final int num_parameters = input.readUnsignedByte();\n-        parameterAnnotationTable = new ParameterAnnotationEntry[num_parameters];\n-        for (int i = 0; i < num_parameters; i++) {\n-            parameterAnnotationTable[i] = new ParameterAnnotationEntry(input, constant_pool);\n+    ParameterAnnotations(final byte parameterAnnotationType, final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n+        throws IOException {\n+        this(parameterAnnotationType, nameIndex, length, (ParameterAnnotationEntry[]) null, constantPool);\n+        final int numParameters = input.readUnsignedByte();\n+        parameterAnnotationTable = new ParameterAnnotationEntry[numParameters];\n+        for (int i = 0; i < numParameters; i++) {\n+            parameterAnnotationTable[i] = new ParameterAnnotationEntry(input, constantPool);\n@@ -56,1 +57,0 @@\n-\n@@ -65,1 +65,1 @@\n-            final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {\n+        final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {\n@@ -70,1 +70,0 @@\n-\n@@ -72,3 +71,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -79,1 +77,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -83,1 +81,0 @@\n-\n@@ -85,1 +82,1 @@\n-     * @param parameterAnnotationTable the entries to set in this parameter annotation\n+     * @return deep copy of this attribute\n@@ -87,2 +84,3 @@\n-    public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable ) {\n-        this.parameterAnnotationTable = parameterAnnotationTable;\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        return (Attribute) clone();\n@@ -91,0 +89,10 @@\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        super.dump(dos);\n+        dos.writeByte(parameterAnnotationTable.length);\n+\n+        for (final ParameterAnnotationEntry element : parameterAnnotationTable) {\n+            element.dump(dos);\n+        }\n+\n+    }\n@@ -93,1 +101,1 @@\n-     * @return the parameter annotation entry table\n+     * returns the array of parameter annotation entries in this parameter annotation\n@@ -95,1 +103,1 @@\n-    public final ParameterAnnotationEntry[] getParameterAnnotationTable() {\n+    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n@@ -99,1 +107,0 @@\n-\n@@ -101,1 +108,1 @@\n-     * returns the array of parameter annotation entries in this parameter annotation\n+     * @return the parameter annotation entry table\n@@ -103,1 +110,1 @@\n-    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n+    public final ParameterAnnotationEntry[] getParameterAnnotationTable() {\n@@ -108,9 +115,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n-        super.dump(dos);\n-        dos.writeByte(parameterAnnotationTable.length);\n-\n-        for (final ParameterAnnotationEntry element : parameterAnnotationTable) {\n-            element.dump(dos);\n-        }\n-\n+    public Iterator<ParameterAnnotationEntry> iterator() {\n+        return Stream.of(parameterAnnotationTable).iterator();\n@@ -120,1 +120,1 @@\n-     * @return deep copy of this attribute\n+     * @param parameterAnnotationTable the entries to set in this parameter annotation\n@@ -122,3 +122,2 @@\n-    @Override\n-    public Attribute copy( final ConstantPool constant_pool ) {\n-        return (Attribute) clone();\n+    public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable) {\n+        this.parameterAnnotationTable = parameterAnnotationTable;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotations.java","additions":40,"deletions":41,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * represents an annotation that is represented in the class file but is not\n- * provided to the JVM.\n+ * represents an annotation that is represented in the class file but is not provided to the JVM.\n@@ -36,2 +35,2 @@\n-public class RuntimeInvisibleAnnotations extends Annotations\n-{\n+public class RuntimeInvisibleAnnotations extends Annotations {\n+\n@@ -39,8 +38,5 @@\n-     * @param name_index\n-     *            Index pointing to the name <em>Code<\/em>\n-     * @param length\n-     *            Content length in bytes\n-     * @param input\n-     *            Input stream\n-     * @param constant_pool\n-     *            Array of constants\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n@@ -48,4 +44,2 @@\n-    public RuntimeInvisibleAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException\n-    {\n-        super(Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS, name_index, length, input, constant_pool, false);\n+    public RuntimeInvisibleAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        super(Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS, nameIndex, length, input, constantPool, false);\n@@ -58,2 +52,1 @@\n-    public Attribute copy(final ConstantPool constant_pool)\n-    {\n+    public Attribute copy(final ConstantPool constantPool) {\n@@ -64,2 +57,1 @@\n-    public final void dump(final DataOutputStream dos) throws IOException\n-    {\n+    public final void dump(final DataOutputStream dos) throws IOException {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleAnnotations.java","additions":12,"deletions":20,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * Represents a parameter annotation that is represented in the class file\n- * but is not provided to the JVM.\n+ * Represents a parameter annotation that is represented in the class file but is not provided to the JVM.\n@@ -38,1 +37,1 @@\n-     * @param name_index Index pointing to the name <em>Code<\/em>\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n@@ -41,1 +40,2 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n+     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n@@ -43,3 +43,3 @@\n-    public RuntimeInvisibleParameterAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        super(Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, name_index, length, input, constant_pool);\n+    public RuntimeInvisibleParameterAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n+        throws IOException {\n+        super(Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, nameIndex, length, input, constantPool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleParameterAnnotations.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * represents an annotation that is represented in the class file and is\n- * provided to the JVM.\n+ * represents an annotation that is represented in the class file and is provided to the JVM.\n@@ -36,2 +35,2 @@\n-public class RuntimeVisibleAnnotations extends Annotations\n-{\n+public class RuntimeVisibleAnnotations extends Annotations {\n+\n@@ -39,8 +38,5 @@\n-     * @param name_index\n-     *            Index pointing to the name <em>Code<\/em>\n-     * @param length\n-     *            Content length in bytes\n-     * @param input\n-     *            Input stream\n-     * @param constant_pool\n-     *            Array of constants\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n@@ -48,3 +44,2 @@\n-    public RuntimeVisibleAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException\n-    {\n-        super(Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, name_index, length, input, constant_pool, true);\n+    public RuntimeVisibleAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        super(Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, nameIndex, length, input, constantPool, true);\n@@ -57,2 +52,1 @@\n-    public Attribute copy(final ConstantPool constant_pool)\n-    {\n+    public Attribute copy(final ConstantPool constantPool) {\n@@ -63,2 +57,1 @@\n-    public final void dump(final DataOutputStream dos) throws IOException\n-    {\n+    public final void dump(final DataOutputStream dos) throws IOException {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleAnnotations.java","additions":12,"deletions":19,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * Represents a parameter annotation that is represented in the class file\n- * and is provided to the JVM.\n+ * Represents a parameter annotation that is represented in the class file and is provided to the JVM.\n@@ -38,1 +37,1 @@\n-     * @param name_index Index pointing to the name <em>Code<\/em>\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n@@ -41,1 +40,2 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n+     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n@@ -43,3 +43,3 @@\n-    public RuntimeVisibleParameterAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        super(Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, name_index, length, input, constant_pool);\n+    public RuntimeVisibleParameterAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n+        throws IOException {\n+        super(Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, nameIndex, length, input, constantPool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleParameterAnnotations.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.nio.charset.StandardCharsets;\n+import java.util.Objects;\n@@ -30,0 +32,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +35,1 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference\n- * to a GJ attribute.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference to a GJ attribute.\n@@ -35,1 +37,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -39,90 +41,0 @@\n-    private int signatureIndex;\n-\n-\n-    \/**\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n-     *\/\n-    public Signature(final Signature c) {\n-        this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());\n-    }\n-\n-\n-    \/**\n-     * Construct object from file stream.\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n-     *\/\n-    Signature(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, input.readUnsignedShort(), constant_pool);\n-    }\n-\n-\n-    \/**\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param signatureIndex Index in constant pool to CONSTANT_Utf8\n-     * @param constant_pool Array of constants\n-     *\/\n-    public Signature(final int name_index, final int length, final int signatureIndex, final ConstantPool constant_pool) {\n-        super(Const.ATTR_SIGNATURE, name_index, length, constant_pool);\n-        this.signatureIndex = signatureIndex;\n-    }\n-\n-\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        \/\/System.err.println(\"Visiting non-standard Signature object\");\n-        v.visitSignature(this);\n-    }\n-\n-\n-    \/**\n-     * Dump source file attribute to file stream in binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException\n-     *\/\n-    @Override\n-    public void dump( final DataOutputStream file ) throws IOException {\n-        super.dump(file);\n-        file.writeShort(signatureIndex);\n-    }\n-\n-\n-    \/**\n-     * @return Index in constant pool of source file name.\n-     *\/\n-    public int getSignatureIndex() {\n-        return signatureIndex;\n-    }\n-\n-\n-    \/**\n-     * @param signatureIndex the index info the constant pool of this signature\n-     *\/\n-    public void setSignatureIndex( final int signatureIndex ) {\n-        this.signatureIndex = signatureIndex;\n-    }\n-\n-\n-    \/**\n-     * @return GJ signature.\n-     *\/\n-    public String getSignature() {\n-        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(signatureIndex,\n-                Const.CONSTANT_Utf8);\n-        return c.getBytes();\n-    }\n-\n@@ -135,1 +47,1 @@\n-            super(data.getBytes());\n+            super(data.getBytes(StandardCharsets.UTF_8));\n@@ -138,1 +50,0 @@\n-\n@@ -140,1 +51,1 @@\n-            return new String(buf);\n+            return new String(buf, StandardCharsets.UTF_8);\n@@ -143,1 +54,0 @@\n-\n@@ -151,2 +61,1 @@\n-\n-    private static boolean identStart( final int ch ) {\n+    private static boolean identStart(final int ch) {\n@@ -156,0 +65,42 @@\n+    \/\/ @since 6.0 is no longer final\n+    public static boolean isActualParameterList(final String s) {\n+        return s.startsWith(\"L\") && s.endsWith(\">;\");\n+    }\n+\n+    \/\/ @since 6.0 is no longer final\n+    public static boolean isFormalParameterList(final String s) {\n+        return s.startsWith(\"<\") && s.indexOf(':') > 0;\n+    }\n+\n+    private static void matchGJIdent(final MyByteArrayInputStream in, final StringBuilder buf) {\n+        int ch;\n+        matchIdent(in, buf);\n+        ch = in.read();\n+        if (ch == '<' || ch == '(') { \/\/ Parameterized or method\n+            \/\/ System.out.println(\"Enter <\");\n+            buf.append((char) ch);\n+            matchGJIdent(in, buf);\n+            while ((ch = in.read()) != '>' && ch != ')') { \/\/ List of parameters\n+                if (ch == -1) {\n+                    throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" reaching EOF\");\n+                }\n+                \/\/ System.out.println(\"Still no >\");\n+                buf.append(\", \");\n+                in.unread();\n+                matchGJIdent(in, buf); \/\/ Recursive call\n+            }\n+            \/\/ System.out.println(\"Exit >\");\n+            buf.append((char) ch);\n+        } else {\n+            in.unread();\n+        }\n+        ch = in.read();\n+        if (identStart(ch)) {\n+            in.unread();\n+            matchGJIdent(in, buf);\n+        } else if (ch == ')') {\n+            in.unread();\n+        } else if (ch != ';') {\n+            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" read \" + (char) ch);\n+        }\n+    }\n@@ -157,1 +108,1 @@\n-    private static void matchIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {\n+    private static void matchIdent(final MyByteArrayInputStream in, final StringBuilder buf) {\n@@ -160,2 +111,1 @@\n-            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData()\n-                    + \" no ident, reaching EOF\");\n+            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" no ident, reaching EOF\");\n@@ -163,1 +113,1 @@\n-        \/\/System.out.println(\"return from ident:\" + (char)ch);\n+        \/\/ System.out.println(\"return from ident:\" + (char)ch);\n@@ -173,1 +123,5 @@\n-                in.skip(\"Ljava\/lang\/Object\".length());\n+                final int skipExpected = \"Ljava\/lang\/Object\".length();\n+                final long skipActual = in.skip(skipExpected);\n+                if (skipActual != skipExpected) {\n+                    throw new IllegalStateException(String.format(\"Unexpected skip: expected=%,d, actual=%,d\", skipExpected, skipActual));\n+                }\n@@ -177,1 +131,1 @@\n-                \/\/System.out.println(\"so far:\" + buf2 + \":next:\" +(char)ch);\n+                \/\/ System.out.println(\"so far:\" + buf2 + \":next:\" +(char)ch);\n@@ -190,4 +144,4 @@\n-            \/\/System.out.println(\"within ident:\"+ (char)ch);\n-        } while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '\/')));\n-        buf.append(buf2.toString().replace('\/', '.'));\n-        \/\/System.out.println(\"regular return ident:\"+ (char)ch + \":\" + buf2);\n+            \/\/ System.out.println(\"within ident:\"+ (char)ch);\n+        } while (ch != -1 && (Character.isJavaIdentifierPart((char) ch) || ch == '\/'));\n+        buf.append(Utility.pathToPackage(buf2.toString()));\n+        \/\/ System.out.println(\"regular return ident:\"+ (char)ch + \":\" + buf2);\n@@ -199,39 +153,2 @@\n-\n-    private static void matchGJIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {\n-        int ch;\n-        matchIdent(in, buf);\n-        ch = in.read();\n-        if ((ch == '<') || ch == '(') { \/\/ Parameterized or method\n-            \/\/System.out.println(\"Enter <\");\n-            buf.append((char) ch);\n-            matchGJIdent(in, buf);\n-            while (((ch = in.read()) != '>') && (ch != ')')) { \/\/ List of parameters\n-                if (ch == -1) {\n-                    throw new IllegalArgumentException(\"Illegal signature: \" + in.getData()\n-                            + \" reaching EOF\");\n-                }\n-                \/\/System.out.println(\"Still no >\");\n-                buf.append(\", \");\n-                in.unread();\n-                matchGJIdent(in, buf); \/\/ Recursive call\n-            }\n-            \/\/System.out.println(\"Exit >\");\n-            buf.append((char) ch);\n-        } else {\n-            in.unread();\n-        }\n-        ch = in.read();\n-        if (identStart(ch)) {\n-            in.unread();\n-            matchGJIdent(in, buf);\n-        } else if (ch == ')') {\n-            in.unread();\n-            return;\n-        } else if (ch != ';') {\n-            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" read \" + (char) ch);\n-        }\n-    }\n-\n-\n-    public static String translate( final String s ) {\n-        \/\/System.out.println(\"Sig:\" + s);\n+    public static String translate(final String s) {\n+        \/\/ System.out.println(\"Sig:\" + s);\n@@ -243,0 +160,1 @@\n+    private int signatureIndex;\n@@ -244,3 +162,11 @@\n-    \/\/ @since 6.0 is no longer final\n-    public static boolean isFormalParameterList( final String s ) {\n-        return s.startsWith(\"<\") && (s.indexOf(':') > 0);\n+    \/**\n+     * Construct object from file stream.\n+     *\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    Signature(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n@@ -249,4 +175,11 @@\n-\n-    \/\/ @since 6.0 is no longer final\n-    public static boolean isActualParameterList( final String s ) {\n-        return s.startsWith(\"L\") && s.endsWith(\">;\");\n+    \/**\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param signatureIndex Index in constant pool to CONSTANT_Utf8\n+     * @param constantPool Array of constants\n+     *\/\n+    public Signature(final int nameIndex, final int length, final int signatureIndex, final ConstantPool constantPool) {\n+        super(Const.ATTR_SIGNATURE, nameIndex, Args.require(length, 2, \"Signature length attribute\"), constantPool);\n+        this.signatureIndex = signatureIndex;\n+        \/\/ validate:\n+        Objects.requireNonNull(constantPool.getConstantUtf8(signatureIndex), \"constantPool.getConstantUtf8(signatureIndex)\");\n@@ -255,0 +188,9 @@\n+    \/**\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n+     *\/\n+    public Signature(final Signature c) {\n+        this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());\n+    }\n@@ -257,1 +199,4 @@\n-     * @return String representation\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n@@ -260,3 +205,3 @@\n-    public String toString() {\n-        final String s = getSignature();\n-        return \"Signature: \" + s;\n+    public void accept(final Visitor v) {\n+        \/\/ System.err.println(\"Visiting non-standard Signature object\");\n+        v.visitSignature(this);\n@@ -265,1 +210,0 @@\n-\n@@ -270,1 +214,1 @@\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n+    public Attribute copy(final ConstantPool constantPool) {\n@@ -273,0 +217,41 @@\n+\n+    \/**\n+     * Dump source file attribute to file stream in binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    @Override\n+    public void dump(final DataOutputStream file) throws IOException {\n+        super.dump(file);\n+        file.writeShort(signatureIndex);\n+    }\n+\n+    \/**\n+     * @return GJ signature.\n+     *\/\n+    public String getSignature() {\n+        return super.getConstantPool().getConstantUtf8(signatureIndex).getBytes();\n+    }\n+\n+    \/**\n+     * @return Index in constant pool of source file name.\n+     *\/\n+    public int getSignatureIndex() {\n+        return signatureIndex;\n+    }\n+\n+    \/**\n+     * @param signatureIndex the index info the constant pool of this signature\n+     *\/\n+    public void setSignatureIndex(final int signatureIndex) {\n+        this.signatureIndex = signatureIndex;\n+    }\n+\n+    \/**\n+     * @return String representation\n+     *\/\n+    @Override\n+    public String toString() {\n+        return \"Signature: \" + getSignature();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Signature.java","additions":146,"deletions":161,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-public class SimpleElementValue extends ElementValue\n-{\n+public class SimpleElementValue extends ElementValue {\n@@ -36,2 +35,1 @@\n-    public SimpleElementValue(final int type, final int index, final ConstantPool cpool)\n-    {\n+    public SimpleElementValue(final int type, final int index, final ConstantPool cpool) {\n@@ -42,0 +40,21 @@\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        final int type = super.getType();\n+        dos.writeByte(type); \/\/ u1 kind of value\n+        switch (type) {\n+        case PRIMITIVE_INT:\n+        case PRIMITIVE_BYTE:\n+        case PRIMITIVE_CHAR:\n+        case PRIMITIVE_FLOAT:\n+        case PRIMITIVE_LONG:\n+        case PRIMITIVE_BOOLEAN:\n+        case PRIMITIVE_SHORT:\n+        case PRIMITIVE_DOUBLE:\n+        case STRING:\n+            dos.writeShort(getIndex());\n+            break;\n+        default:\n+            throw new ClassFormatException(\"SimpleElementValue doesnt know how to write out type \" + type);\n+        }\n+    }\n+\n@@ -45,2 +64,1 @@\n-    public int getIndex()\n-    {\n+    public int getIndex() {\n@@ -50,21 +68,3 @@\n-    public void setIndex(final int index)\n-    {\n-        this.index = index;\n-    }\n-\n-    public String getValueString()\n-    {\n-        if (super.getType() != STRING) {\n-            throw new IllegalStateException(\n-                    \"Dont call getValueString() on a non STRING ElementValue\");\n-        }\n-        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(getIndex(),\n-                Const.CONSTANT_Utf8);\n-        return c.getBytes();\n-    }\n-\n-    public int getValueInt()\n-    {\n-        if (super.getType() != PRIMITIVE_INT) {\n-            throw new IllegalStateException(\n-                    \"Dont call getValueString() on a non STRING ElementValue\");\n+    public boolean getValueBoolean() {\n+        if (super.getType() != PRIMITIVE_BOOLEAN) {\n+            throw new IllegalStateException(\"Dont call getValueBoolean() on a non BOOLEAN ElementValue\");\n@@ -72,3 +72,2 @@\n-        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n-                Const.CONSTANT_Integer);\n-        return c.getBytes();\n+        final ConstantInteger bo = (ConstantInteger) super.getConstantPool().getConstant(getIndex());\n+        return bo.getBytes() != 0;\n@@ -77,2 +76,1 @@\n-    public byte getValueByte()\n-    {\n+    public byte getValueByte() {\n@@ -80,2 +78,1 @@\n-            throw new IllegalStateException(\n-                    \"Dont call getValueByte() on a non BYTE ElementValue\");\n+            throw new IllegalStateException(\"Dont call getValueByte() on a non BYTE ElementValue\");\n@@ -83,3 +80,1 @@\n-        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n-                Const.CONSTANT_Integer);\n-        return (byte) c.getBytes();\n+        return (byte) super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n@@ -88,2 +83,1 @@\n-    public char getValueChar()\n-    {\n+    public char getValueChar() {\n@@ -91,2 +85,1 @@\n-            throw new IllegalStateException(\n-                    \"Dont call getValueChar() on a non CHAR ElementValue\");\n+            throw new IllegalStateException(\"Dont call getValueChar() on a non CHAR ElementValue\");\n@@ -94,3 +87,1 @@\n-        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n-                Const.CONSTANT_Integer);\n-        return (char) c.getBytes();\n+        return (char) super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n@@ -99,5 +90,3 @@\n-    public long getValueLong()\n-    {\n-        if (super.getType() != PRIMITIVE_LONG) {\n-            throw new IllegalStateException(\n-                    \"Dont call getValueLong() on a non LONG ElementValue\");\n+    public double getValueDouble() {\n+        if (super.getType() != PRIMITIVE_DOUBLE) {\n+            throw new IllegalStateException(\"Dont call getValueDouble() on a non DOUBLE ElementValue\");\n@@ -105,2 +94,2 @@\n-        final ConstantLong j = (ConstantLong) super.getConstantPool().getConstant(getIndex());\n-        return j.getBytes();\n+        final ConstantDouble d = (ConstantDouble) super.getConstantPool().getConstant(getIndex());\n+        return d.getBytes();\n@@ -109,2 +98,1 @@\n-    public float getValueFloat()\n-    {\n+    public float getValueFloat() {\n@@ -112,2 +100,1 @@\n-            throw new IllegalStateException(\n-                    \"Dont call getValueFloat() on a non FLOAT ElementValue\");\n+            throw new IllegalStateException(\"Dont call getValueFloat() on a non FLOAT ElementValue\");\n@@ -119,5 +106,3 @@\n-    public double getValueDouble()\n-    {\n-        if (super.getType() != PRIMITIVE_DOUBLE) {\n-            throw new IllegalStateException(\n-                    \"Dont call getValueDouble() on a non DOUBLE ElementValue\");\n+    public int getValueInt() {\n+        if (super.getType() != PRIMITIVE_INT) {\n+            throw new IllegalStateException(\"Dont call getValueInt() on a non INT ElementValue\");\n@@ -125,2 +110,1 @@\n-        final ConstantDouble d = (ConstantDouble) super.getConstantPool().getConstant(getIndex());\n-        return d.getBytes();\n+        return super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n@@ -129,5 +113,3 @@\n-    public boolean getValueBoolean()\n-    {\n-        if (super.getType() != PRIMITIVE_BOOLEAN) {\n-            throw new IllegalStateException(\n-                    \"Dont call getValueBoolean() on a non BOOLEAN ElementValue\");\n+    public long getValueLong() {\n+        if (super.getType() != PRIMITIVE_LONG) {\n+            throw new IllegalStateException(\"Dont call getValueLong() on a non LONG ElementValue\");\n@@ -135,2 +117,2 @@\n-        final ConstantInteger bo = (ConstantInteger) super.getConstantPool().getConstant(getIndex());\n-        return bo.getBytes() != 0;\n+        final ConstantLong j = (ConstantLong) super.getConstantPool().getConstant(getIndex());\n+        return j.getBytes();\n@@ -139,2 +121,1 @@\n-    public short getValueShort()\n-    {\n+    public short getValueShort() {\n@@ -142,2 +123,1 @@\n-            throw new IllegalStateException(\n-                    \"Dont call getValueShort() on a non SHORT ElementValue\");\n+            throw new IllegalStateException(\"Dont call getValueShort() on a non SHORT ElementValue\");\n@@ -149,4 +129,9 @@\n-    @Override\n-    public String toString()\n-    {\n-        return stringifyValue();\n+    public String getValueString() {\n+        if (super.getType() != STRING) {\n+            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+        }\n+        return super.getConstantPool().getConstantUtf8(getIndex()).getBytes();\n+    }\n+\n+    public void setIndex(final int index) {\n+        this.index = index;\n@@ -157,2 +142,1 @@\n-    public String stringifyValue()\n-    {\n+    public String stringifyValue() {\n@@ -160,3 +144,2 @@\n-        final int _type = super.getType();\n-        switch (_type)\n-        {\n+        final int type = super.getType();\n+        switch (type) {\n@@ -164,3 +147,1 @@\n-            final ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),\n-                    Const.CONSTANT_Integer);\n-            return Integer.toString(c.getBytes());\n+            return Integer.toString(cpool.getConstantInteger(getIndex()).getBytes());\n@@ -168,2 +149,1 @@\n-            final ConstantLong j = (ConstantLong) cpool.getConstant(getIndex(),\n-                    Const.CONSTANT_Long);\n+            final ConstantLong j = cpool.getConstant(getIndex(), Const.CONSTANT_Long, ConstantLong.class);\n@@ -172,2 +152,1 @@\n-            final ConstantDouble d = (ConstantDouble) cpool.getConstant(getIndex(),\n-                    Const.CONSTANT_Double);\n+            final ConstantDouble d = cpool.getConstant(getIndex(), Const.CONSTANT_Double, ConstantDouble.class);\n@@ -176,2 +155,1 @@\n-            final ConstantFloat f = (ConstantFloat) cpool.getConstant(getIndex(),\n-                    Const.CONSTANT_Float);\n+            final ConstantFloat f = cpool.getConstant(getIndex(), Const.CONSTANT_Float, ConstantFloat.class);\n@@ -180,2 +158,1 @@\n-            final ConstantInteger s = (ConstantInteger) cpool.getConstant(getIndex(),\n-                    Const.CONSTANT_Integer);\n+            final ConstantInteger s = cpool.getConstantInteger(getIndex());\n@@ -184,2 +161,1 @@\n-            final ConstantInteger b = (ConstantInteger) cpool.getConstant(getIndex(),\n-                    Const.CONSTANT_Integer);\n+            final ConstantInteger b = cpool.getConstantInteger(getIndex());\n@@ -188,3 +164,2 @@\n-            final ConstantInteger ch = (ConstantInteger) cpool.getConstant(\n-                    getIndex(), Const.CONSTANT_Integer);\n-            return String.valueOf((char)ch.getBytes());\n+            final ConstantInteger ch = cpool.getConstantInteger(getIndex());\n+            return String.valueOf((char) ch.getBytes());\n@@ -192,2 +167,1 @@\n-            final ConstantInteger bo = (ConstantInteger) cpool.getConstant(\n-                    getIndex(), Const.CONSTANT_Integer);\n+            final ConstantInteger bo = cpool.getConstantInteger(getIndex());\n@@ -199,3 +173,1 @@\n-            final ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(getIndex(),\n-                    Const.CONSTANT_Utf8);\n-            return cu8.getBytes();\n+            return cpool.getConstantUtf8(getIndex()).getBytes();\n@@ -203,1 +175,1 @@\n-            throw new IllegalStateException(\"SimpleElementValue class does not know how to stringify type \" + _type);\n+            throw new IllegalStateException(\"SimpleElementValue class does not know how to stringify type \" + type);\n@@ -208,20 +180,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n-        final int _type = super.getType();\n-        dos.writeByte(_type); \/\/ u1 kind of value\n-        switch (_type)\n-        {\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_BOOLEAN:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_DOUBLE:\n-        case STRING:\n-            dos.writeShort(getIndex());\n-            break;\n-        default:\n-            throw new IllegalStateException(\"SimpleElementValue doesnt know how to write out type \" + _type);\n-        }\n+    public String toString() {\n+        return stringifyValue();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SimpleElementValue.java","additions":78,"deletions":124,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,4 +32,3 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference\n- * to the source file of this class.  At most one SourceFile attribute\n- * should appear per classfile.  The intention of this class is that it is\n- * instantiated from the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference to the source file of this class. At most\n+ * one SourceFile attribute should appear per classfile. The intention of this class is that it is instantiated from the\n+ * <em>Attribute.readAttribute()<\/em> method.\n@@ -36,1 +36,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -42,10 +42,0 @@\n-\n-    \/**\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n-     *\/\n-    public SourceFile(final SourceFile c) {\n-        this(c.getNameIndex(), c.getLength(), c.getSourceFileIndex(), c.getConstantPool());\n-    }\n-\n-\n@@ -54,1 +44,2 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     *\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -57,2 +48,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -60,3 +51,2 @@\n-    SourceFile(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, input.readUnsignedShort(), constant_pool);\n+    SourceFile(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n@@ -65,1 +55,0 @@\n-\n@@ -67,2 +56,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n-     * should represent the string \"SourceFile\".\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8, which should represent the string \"SourceFile\".\n@@ -70,8 +58,5 @@\n-     * @param constantPool The constant pool that this attribute is\n-     * associated with.\n-     * @param sourceFileIndex Index in constant pool to CONSTANT_Utf8.  This\n-     * string will be interpreted as the name of the file from which this\n-     * class was compiled.  It will not be interpreted as indicating the name\n-     * of the directory contqining the file or an absolute path; this\n-     * information has to be supplied the consumer of this attribute - in\n-     * many cases, the JVM.\n+     * @param constantPool The constant pool that this attribute is associated with.\n+     * @param sourceFileIndex Index in constant pool to CONSTANT_Utf8. This string will be interpreted as the name of the\n+     *        file from which this class was compiled. It will not be interpreted as indicating the name of the directory\n+     *        contqining the file or an absolute path; this information has to be supplied the consumer of this attribute -\n+     *        in many cases, the JVM.\n@@ -79,3 +64,3 @@\n-    public SourceFile(final int name_index, final int length, final int sourceFileIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_SOURCE_FILE, name_index, length, constantPool);\n-        this.sourceFileIndex = sourceFileIndex;\n+    public SourceFile(final int nameIndex, final int length, final int sourceFileIndex, final ConstantPool constantPool) {\n+        super(Const.ATTR_SOURCE_FILE, nameIndex, Args.require(length, 2, \"SourceFile length attribute\"), constantPool);\n+        this.sourceFileIndex = Args.requireU2(sourceFileIndex, 0, constantPool.getLength(), \"SourceFile source file index\");\n@@ -84,0 +69,9 @@\n+    \/**\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n+     *\/\n+    public SourceFile(final SourceFile c) {\n+        this(c.getNameIndex(), c.getLength(), c.getSourceFileIndex(), c.getConstantPool());\n+    }\n@@ -86,3 +80,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -93,1 +86,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -97,0 +90,7 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        return (Attribute) clone();\n+    }\n@@ -102,1 +102,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -105,1 +105,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -110,1 +110,0 @@\n-\n@@ -118,1 +117,0 @@\n-\n@@ -120,1 +118,1 @@\n-     * @param sourceFileIndex\n+     * @return Source file name.\n@@ -122,2 +120,2 @@\n-    public void setSourceFileIndex( final int sourceFileIndex ) {\n-        this.sourceFileIndex = sourceFileIndex;\n+    public String getSourceFileName() {\n+        return super.getConstantPool().getConstantUtf8(sourceFileIndex).getBytes();\n@@ -126,1 +124,0 @@\n-\n@@ -128,1 +125,1 @@\n-     * @return Source file name.\n+     * @param sourceFileIndex\n@@ -130,4 +127,2 @@\n-    public String getSourceFileName() {\n-        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(sourceFileIndex,\n-                Const.CONSTANT_Utf8);\n-        return c.getBytes();\n+    public void setSourceFileIndex(final int sourceFileIndex) {\n+        this.sourceFileIndex = sourceFileIndex;\n@@ -136,1 +131,0 @@\n-\n@@ -144,9 +138,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        return (Attribute) clone();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SourceFile.java","additions":47,"deletions":62,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.Arrays;\n@@ -28,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -30,7 +32,4 @@\n- * This class represents a stack map attribute used for\n- * preverification of Java classes for the <a\n- * href=\"https:\/\/www.oracle.com\/java\/technologies\/javameoverview.html\">Java Platform, Micro Edition<\/a>\n- * (Java ME). This attribute is used by the <a\n- * href=\"https:\/\/www.oracle.com\/technetwork\/java\/embedded\/javame\/java-mobile\/kvmwp-150240.pdf\">KVM<\/a>\n- * and contained within the Code attribute of a method. See CLDC specification\n- * 5.3.1.2\n+ * This class represents a stack map attribute used for preverification of Java classes for the\n+ * <a href=\"http:\/\/java.sun.com\/j2me\/\"> Java 2 Micro Edition<\/a> (J2ME). This attribute is used by the\n+ * <a href=\"http:\/\/java.sun.com\/products\/cldc\/\">KVM<\/a> and contained within the Code attribute of a method. See CLDC\n+ * specification 5.3.1.2\n@@ -38,3 +37,12 @@\n- * @see     Code\n- * @see     StackMapEntry\n- * @see     StackMapType\n+ * <pre>\n+ * StackMapTable_attribute {\n+ *   u2              attribute_name_index;\n+ *   u4              attribute_length;\n+ *   u2              number_of_entries;\n+ *   stack_map_frame entries[number_of_entries];\n+ * }\n+ * <\/pre>\n+ *\n+ * @see Code\n+ * @see StackMapEntry\n+ * @see StackMapType\n@@ -45,1 +53,1 @@\n-    private StackMapEntry[] map; \/\/ Table of stack map entries\n+    private StackMapEntry[] table; \/\/ Table of stack map entries\n@@ -47,0 +55,17 @@\n+    \/**\n+     * Construct object from input stream.\n+     *\n+     * @param nameIndex Index of name\n+     * @param length Content length in bytes\n+     * @param dataInput Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    StackMap(final int nameIndex, final int length, final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (StackMapEntry[]) null, constantPool);\n+        final int mapLength = dataInput.readUnsignedShort();\n+        table = new StackMapEntry[mapLength];\n+        for (int i = 0; i < mapLength; i++) {\n+            table[i] = new StackMapEntry(dataInput, constantPool);\n+        }\n+    }\n@@ -49,1 +74,2 @@\n-     * @param name_index Index of name\n+     * @param nameIndex Index of name\n+     *\n@@ -51,0 +77,1 @@\n+     *\n@@ -52,1 +79,2 @@\n-     * @param constant_pool Array of constants\n+     *\n+     * @param constantPool Array of constants\n@@ -54,3 +82,4 @@\n-    public StackMap(final int name_index, final int length, final StackMapEntry[] map, final ConstantPool constant_pool) {\n-        super(Const.ATTR_STACK_MAP, name_index, length, constant_pool);\n-        this.map = map;\n+    public StackMap(final int nameIndex, final int length, final StackMapEntry[] table, final ConstantPool constantPool) {\n+        super(Const.ATTR_STACK_MAP, nameIndex, length, constantPool);\n+        this.table = table != null ? table : StackMapEntry.EMPTY_ARRAY;\n+        Args.requireU2(this.table.length, \"table.length\");\n@@ -59,1 +88,0 @@\n-\n@@ -61,1 +89,2 @@\n-     * Construct object from input stream.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -63,5 +92,1 @@\n-     * @param name_index Index of name\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param v Visitor object\n@@ -69,7 +94,3 @@\n-    StackMap(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n-        this(name_index, length, (StackMapEntry[]) null, constant_pool);\n-        final int map_length = input.readUnsignedShort();\n-        map = new StackMapEntry[map_length];\n-        for (int i = 0; i < map_length; i++) {\n-            map[i] = new StackMapEntry(input, constant_pool);\n-        }\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitStackMap(this);\n@@ -78,0 +99,11 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final StackMap c = (StackMap) clone();\n+        c.table = new StackMapEntry[table.length];\n+        Arrays.setAll(c.table, i -> table[i].copy());\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -83,1 +115,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -86,1 +118,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -88,2 +120,2 @@\n-        file.writeShort(map.length);\n-        for (final StackMapEntry entry : map) {\n+        file.writeShort(table.length);\n+        for (final StackMapEntry entry : table) {\n@@ -94,0 +126,3 @@\n+    public int getMapLength() {\n+        return table.length;\n+    }\n@@ -99,1 +134,1 @@\n-        return map;\n+        return table;\n@@ -102,1 +137,0 @@\n-\n@@ -104,1 +138,1 @@\n-     * @param map Array of stack map entries\n+     * @param table Array of stack map entries\n@@ -106,2 +140,2 @@\n-    public void setStackMap( final StackMapEntry[] map ) {\n-        this.map = map;\n+    public void setStackMap(final StackMapEntry[] table) {\n+        this.table = table != null ? table : StackMapEntry.EMPTY_ARRAY;\n@@ -109,1 +143,1 @@\n-        for (final StackMapEntry element : map) {\n+        for (final StackMapEntry element : this.table) {\n@@ -115,1 +149,0 @@\n-\n@@ -122,3 +155,5 @@\n-        for (int i = 0; i < map.length; i++) {\n-            buf.append(map[i]);\n-            if (i < map.length - 1) {\n+        int runningOffset = -1; \/\/ no +1 on first entry\n+        for (int i = 0; i < table.length; i++) {\n+            runningOffset = table[i].getByteCodeOffset() + runningOffset + 1;\n+            buf.append(String.format(\"%n@%03d %s\", runningOffset, table[i]));\n+            if (i < table.length - 1) {\n@@ -131,33 +166,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final StackMap c = (StackMap) clone();\n-        c.map = new StackMapEntry[map.length];\n-        for (int i = 0; i < map.length; i++) {\n-            c.map[i] = map[i].copy();\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n-\n-\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitStackMap(this);\n-    }\n-\n-\n-    public int getMapLength() {\n-        return map == null ? 0 : map.length;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMap.java","additions":79,"deletions":77,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import java.util.Arrays;\n+\n@@ -30,3 +32,4 @@\n- * This class represents a stack map entry recording the types of\n- * local variables and the the of stack items at a given byte code offset.\n- * See CLDC specification 5.3.1.2\n+ * This class represents a stack map entry recording the types of local variables and the of stack items at a given\n+ * byte code offset. See CLDC specification 5.3.1.2.\n+ *\n+ * See also https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.4\n@@ -34,2 +37,13 @@\n- * @see     StackMap\n- * @see     StackMapType\n+ * <pre>\n+ * union stack_map_frame {\n+ *   same_frame;\n+ *   same_locals_1_stack_item_frame;\n+ *   same_locals_1_stack_item_frame_extended;\n+ *   chop_frame;\n+ *   same_frame_extended;\n+ *   append_frame;\n+ *   full_frame;\n+ * }\n+ * <\/pre>\n+ * @see StackMap\n+ * @see StackMapType\n@@ -37,2 +51,3 @@\n-public final class StackMapEntry implements Node, Cloneable\n-{\n+public final class StackMapEntry implements Node, Cloneable {\n+\n+    static final StackMapEntry[] EMPTY_ARRAY = {};\n@@ -46,1 +61,0 @@\n-\n@@ -50,2 +64,2 @@\n-     * @param input Input stream\n-     * @throws IOException\n+     * @param dataInput Input stream\n+     * @throws IOException if an I\/O error occurs.\n@@ -53,2 +67,2 @@\n-    StackMapEntry(final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(input.readByte() & 0xFF, -1, null, null, constantPool);\n+    StackMapEntry(final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n+        this(dataInput.readByte() & 0xFF, -1, null, null, constantPool);\n@@ -58,2 +72,1 @@\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n-                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -61,2 +74,1 @@\n-            typesOfStackItems = new StackMapType[1];\n-            typesOfStackItems[0] = new StackMapType(input, constantPool);\n+            typesOfStackItems = new StackMapType[] { new StackMapType(dataInput, constantPool) };\n@@ -64,3 +76,2 @@\n-            byteCodeOffset = input.readShort();\n-            typesOfStackItems = new StackMapType[1];\n-            typesOfStackItems[0] = new StackMapType(input, constantPool);\n+            byteCodeOffset = dataInput.readUnsignedShort();\n+            typesOfStackItems = new StackMapType[] { new StackMapType(dataInput, constantPool) };\n@@ -68,1 +79,1 @@\n-            byteCodeOffset = input.readShort();\n+            byteCodeOffset = dataInput.readUnsignedShort();\n@@ -70,1 +81,1 @@\n-            byteCodeOffset = input.readShort();\n+            byteCodeOffset = dataInput.readUnsignedShort();\n@@ -72,5 +83,5 @@\n-            byteCodeOffset = input.readShort();\n-            final int number_of_locals = frameType - 251;\n-            typesOfLocals = new StackMapType[number_of_locals];\n-            for (int i = 0; i < number_of_locals; i++) {\n-                typesOfLocals[i] = new StackMapType(input, constantPool);\n+            byteCodeOffset = dataInput.readUnsignedShort();\n+            final int numberOfLocals = frameType - 251;\n+            typesOfLocals = new StackMapType[numberOfLocals];\n+            for (int i = 0; i < numberOfLocals; i++) {\n+                typesOfLocals[i] = new StackMapType(dataInput, constantPool);\n@@ -79,5 +90,5 @@\n-            byteCodeOffset = input.readShort();\n-            final int number_of_locals = input.readShort();\n-            typesOfLocals = new StackMapType[number_of_locals];\n-            for (int i = 0; i < number_of_locals; i++) {\n-                typesOfLocals[i] = new StackMapType(input, constantPool);\n+            byteCodeOffset = dataInput.readUnsignedShort();\n+            final int numberOfLocals = dataInput.readUnsignedShort();\n+            typesOfLocals = new StackMapType[numberOfLocals];\n+            for (int i = 0; i < numberOfLocals; i++) {\n+                typesOfLocals[i] = new StackMapType(dataInput, constantPool);\n@@ -85,4 +96,4 @@\n-            final int number_of_stack_items = input.readShort();\n-            typesOfStackItems = new StackMapType[number_of_stack_items];\n-            for (int i = 0; i < number_of_stack_items; i++) {\n-                typesOfStackItems[i] = new StackMapType(input, constantPool);\n+            final int numberOfStackItems = dataInput.readUnsignedShort();\n+            typesOfStackItems = new StackMapType[numberOfStackItems];\n+            for (int i = 0; i < numberOfStackItems; i++) {\n+                typesOfStackItems[i] = new StackMapType(dataInput, constantPool);\n@@ -92,1 +103,1 @@\n-            throw new ClassFormatException (\"Invalid frame type found while parsing stack map table: \" + frameType);\n+            throw new ClassFormatException(\"Invalid frame type found while parsing stack map table: \" + frameType);\n@@ -105,2 +116,1 @@\n-     * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)}\n-     * instead\n+     * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)} instead\n@@ -109,3 +119,2 @@\n-    public StackMapEntry(final int byteCodeOffset, final int numberOfLocals,\n-            final StackMapType[] typesOfLocals, final int numberOfStackItems,\n-            final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n+    public StackMapEntry(final int byteCodeOffset, final int numberOfLocals, final StackMapType[] typesOfLocals, final int numberOfStackItems,\n+        final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n@@ -113,2 +122,2 @@\n-        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];\n-        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];\n+        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : StackMapType.EMPTY_ARRAY;\n+        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : StackMapType.EMPTY_ARRAY;\n@@ -116,0 +125,6 @@\n+        if (numberOfLocals < 0) {\n+            throw new IllegalArgumentException(\"numberOfLocals < 0\");\n+        }\n+        if (numberOfStackItems < 0) {\n+            throw new IllegalArgumentException(\"numberOfStackItems < 0\");\n+        }\n@@ -127,3 +142,2 @@\n-    public StackMapEntry(final int tag, final int byteCodeOffset,\n-            final StackMapType[] typesOfLocals,\n-            final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n+    public StackMapEntry(final int tag, final int byteCodeOffset, final StackMapType[] typesOfLocals, final StackMapType[] typesOfStackItems,\n+        final ConstantPool constantPool) {\n@@ -132,2 +146,2 @@\n-        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];\n-        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];\n+        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : StackMapType.EMPTY_ARRAY;\n+        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : StackMapType.EMPTY_ARRAY;\n@@ -137,0 +151,28 @@\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitStackMapEntry(this);\n+    }\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public StackMapEntry copy() {\n+        StackMapEntry e;\n+        try {\n+            e = (StackMapEntry) clone();\n+        } catch (final CloneNotSupportedException ex) {\n+            throw new Error(\"Clone Not Supported\");\n+        }\n+\n+        e.typesOfLocals = new StackMapType[typesOfLocals.length];\n+        Arrays.setAll(e.typesOfLocals, i -> typesOfLocals[i].copy());\n+        e.typesOfStackItems = new StackMapType[typesOfStackItems.length];\n+        Arrays.setAll(e.typesOfStackItems, i -> typesOfStackItems[i].copy());\n+        return e;\n+    }\n@@ -142,1 +184,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -144,1 +186,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -146,4 +188,1 @@\n-        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n-            \/\/ nothing to be done\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n-                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -173,1 +212,1 @@\n-        } else {\n+        } else if (!(frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX)) {\n@@ -175,1 +214,1 @@\n-            throw new ClassFormatException (\"Invalid Stack map table tag: \" + frameType);\n+            throw new ClassFormatException(\"Invalid Stack map table tag: \" + frameType);\n@@ -179,0 +218,3 @@\n+    public int getByteCodeOffset() {\n+        return byteCodeOffset;\n+    }\n@@ -181,1 +223,1 @@\n-     * @return String representation.\n+     * @return Constant pool used by this object.\n@@ -183,45 +225,2 @@\n-    @Override\n-    public String toString() {\n-        final StringBuilder buf = new StringBuilder(64);\n-        buf.append(\"(\");\n-        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n-            buf.append(\"SAME\");\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n-                  frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            buf.append(\"SAME_LOCALS_1_STACK\");\n-        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n-            buf.append(\"SAME_LOCALS_1_STACK_EXTENDED\");\n-        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n-            buf.append(\"CHOP \").append(String.valueOf(251-frameType));\n-        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n-            buf.append(\"SAME_EXTENDED\");\n-        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n-            buf.append(\"APPEND \").append(String.valueOf(frameType-251));\n-        } else if (frameType == Const.FULL_FRAME) {\n-            buf.append(\"FULL\");\n-        } else {\n-            buf.append(\"UNKNOWN (\").append(frameType).append(\")\");\n-        }\n-        buf.append(\", offset delta=\").append(byteCodeOffset);\n-        if (typesOfLocals.length > 0) {\n-            buf.append(\", locals={\");\n-            for (int i = 0; i < typesOfLocals.length; i++) {\n-                buf.append(typesOfLocals[i]);\n-                if (i < typesOfLocals.length - 1) {\n-                    buf.append(\", \");\n-                }\n-            }\n-            buf.append(\"}\");\n-        }\n-        if (typesOfStackItems.length > 0) {\n-            buf.append(\", stack items={\");\n-            for (int i = 0; i < typesOfStackItems.length; i++) {\n-                buf.append(typesOfStackItems[i]);\n-                if (i < typesOfStackItems.length - 1) {\n-                    buf.append(\", \");\n-                }\n-            }\n-            buf.append(\"}\");\n-        }\n-        buf.append(\")\");\n-        return buf.toString();\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n@@ -230,0 +229,3 @@\n+    public int getFrameType() {\n+        return frameType;\n+    }\n@@ -238,2 +240,2 @@\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n-                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        }\n+        if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -241,1 +243,2 @@\n-        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n+        }\n+        if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n@@ -243,3 +246,2 @@\n-        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n-            return 3;\n-        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+        }\n+        if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX || frameType == Const.SAME_FRAME_EXTENDED) {\n@@ -247,1 +249,2 @@\n-        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n+        }\n+        if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n@@ -249,11 +252,2 @@\n-            for (final StackMapType types_of_local : typesOfLocals) {\n-                len += types_of_local.hasIndex() ? 3 : 1;\n-            }\n-            return len;\n-        } else if (frameType == Const.FULL_FRAME) {\n-            int len = 7;\n-            for (final StackMapType types_of_local : typesOfLocals) {\n-                len += types_of_local.hasIndex() ? 3 : 1;\n-            }\n-            for (final StackMapType types_of_stack_item : typesOfStackItems) {\n-                len += types_of_stack_item.hasIndex() ? 3 : 1;\n+            for (final StackMapType typesOfLocal : typesOfLocals) {\n+                len += typesOfLocal.hasIndex() ? 3 : 1;\n@@ -262,1 +256,2 @@\n-        } else {\n+        }\n+        if (frameType != Const.FULL_FRAME) {\n@@ -265,0 +260,8 @@\n+        int len = 7;\n+        for (final StackMapType typesOfLocal : typesOfLocals) {\n+            len += typesOfLocal.hasIndex() ? 3 : 1;\n+        }\n+        for (final StackMapType typesOfStackItem : typesOfStackItems) {\n+            len += typesOfStackItem.hasIndex() ? 3 : 1;\n+        }\n+        return len;\n@@ -267,0 +270,3 @@\n+    public int getNumberOfLocals() {\n+        return typesOfLocals.length;\n+    }\n@@ -268,15 +274,2 @@\n-    public void setFrameType( final int f ) {\n-        if (f >= Const.SAME_FRAME && f <= Const.SAME_FRAME_MAX) {\n-            byteCodeOffset = f - Const.SAME_FRAME;\n-        } else if (f >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n-                   f <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            byteCodeOffset = f - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;\n-        } else if (f == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (f >= Const.CHOP_FRAME && f <= Const.CHOP_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (f == Const.SAME_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (f >= Const.APPEND_FRAME && f <= Const.APPEND_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (f == Const.FULL_FRAME) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else {\n-            throw new IllegalArgumentException(\"Invalid StackMap frameType\");\n-        }\n-        frameType = f;\n+    public int getNumberOfStackItems() {\n+        return typesOfStackItems.length;\n@@ -285,0 +278,3 @@\n+    public StackMapType[] getTypesOfLocals() {\n+        return typesOfLocals;\n+    }\n@@ -286,2 +282,2 @@\n-    public int getFrameType() {\n-        return frameType;\n+    public StackMapType[] getTypesOfStackItems() {\n+        return typesOfStackItems;\n@@ -290,0 +286,9 @@\n+    private boolean invalidFrameType(final int f) {\n+        \/\/ @formatter:off\n+        return f != Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\n+            && !(f >= Const.CHOP_FRAME && f <= Const.CHOP_FRAME_MAX)\n+            && f != Const.SAME_FRAME_EXTENDED\n+            && !(f >= Const.APPEND_FRAME && f <= Const.APPEND_FRAME_MAX)\n+            && f != Const.FULL_FRAME;\n+        \/\/ @formatter:on\n+    }\n@@ -291,3 +296,3 @@\n-    public void setByteCodeOffset( final int new_offset ) {\n-        if (new_offset < 0 || new_offset > 32767) {\n-            throw new IllegalArgumentException(\"Invalid StackMap offset: \" + new_offset);\n+    public void setByteCodeOffset(final int newOffset) {\n+        if (newOffset < 0 || newOffset > 32767) {\n+            throw new IllegalArgumentException(\"Invalid StackMap offset: \" + newOffset);\n@@ -296,3 +301,2 @@\n-        if (frameType >= Const.SAME_FRAME &&\n-            frameType <= Const.SAME_FRAME_MAX) {\n-            if (new_offset > Const.SAME_FRAME_MAX) {\n+        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n+            if (newOffset > Const.SAME_FRAME_MAX) {\n@@ -301,1 +305,1 @@\n-                frameType = new_offset;\n+                frameType = newOffset;\n@@ -303,3 +307,2 @@\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n-                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            if (new_offset > Const.SAME_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            if (newOffset > Const.SAME_FRAME_MAX) {\n@@ -308,1 +311,1 @@\n-                frameType = Const.SAME_LOCALS_1_STACK_ITEM_FRAME + new_offset;\n+                frameType = Const.SAME_LOCALS_1_STACK_ITEM_FRAME + newOffset;\n@@ -310,8 +313,1 @@\n-        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (frameType >= Const.CHOP_FRAME &&\n-                   frameType <= Const.CHOP_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (frameType == Const.SAME_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (frameType >= Const.APPEND_FRAME &&\n-                   frameType <= Const.APPEND_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else if (frameType == Const.FULL_FRAME) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n-        } else {\n+        } else if (invalidFrameType(frameType)) {\n@@ -320,1 +316,1 @@\n-        byteCodeOffset = new_offset;\n+        byteCodeOffset = newOffset;\n@@ -323,1 +319,0 @@\n-\n@@ -325,5 +320,1 @@\n-     * Update the distance (as an offset delta) from this StackMap\n-     * entry to the next.  Note that this might cause the the\n-     * frame type to change.  Note also that delta may be negative.\n-     *\n-     * @param delta offset delta\n+     * @param constantPool Constant pool to be used for this object.\n@@ -331,2 +322,2 @@\n-    public void updateByteCodeOffset(final int delta) {\n-        setByteCodeOffset(byteCodeOffset + delta);\n+    public void setConstantPool(final ConstantPool constantPool) {\n+        this.constantPool = constantPool;\n@@ -335,3 +326,9 @@\n-\n-    public int getByteCodeOffset() {\n-        return byteCodeOffset;\n+    public void setFrameType(final int ft) {\n+        if (ft >= Const.SAME_FRAME && ft <= Const.SAME_FRAME_MAX) {\n+            byteCodeOffset = ft - Const.SAME_FRAME;\n+        } else if (ft >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && ft <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            byteCodeOffset = ft - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;\n+        } else if (invalidFrameType(ft)) {\n+            throw new IllegalArgumentException(\"Invalid StackMap frameType\");\n+        }\n+        frameType = ft;\n@@ -340,1 +337,0 @@\n-\n@@ -346,6 +342,1 @@\n-    public void setNumberOfLocals( final int n ) { \/\/ TODO unused\n-    }\n-\n-\n-    public int getNumberOfLocals() {\n-        return typesOfLocals.length;\n+    public void setNumberOfLocals(final int n) { \/\/ TODO unused\n@@ -354,11 +345,0 @@\n-\n-    public void setTypesOfLocals( final StackMapType[] types ) {\n-        typesOfLocals = types != null ? types : new StackMapType[0];\n-    }\n-\n-\n-    public StackMapType[] getTypesOfLocals() {\n-        return typesOfLocals;\n-    }\n-\n-\n@@ -370,6 +350,1 @@\n-    public void setNumberOfStackItems( final int n ) { \/\/ TODO unused\n-    }\n-\n-\n-    public int getNumberOfStackItems() {\n-        return typesOfStackItems.length;\n+    public void setNumberOfStackItems(final int n) { \/\/ TODO unused\n@@ -378,3 +353,2 @@\n-\n-    public void setTypesOfStackItems( final StackMapType[] types ) {\n-        typesOfStackItems = types != null ? types : new StackMapType[0];\n+    public void setTypesOfLocals(final StackMapType[] types) {\n+        typesOfLocals = types != null ? types : StackMapType.EMPTY_ARRAY;\n@@ -383,3 +357,2 @@\n-\n-    public StackMapType[] getTypesOfStackItems() {\n-        return typesOfStackItems;\n+    public void setTypesOfStackItems(final StackMapType[] types) {\n+        typesOfStackItems = types != null ? types : StackMapType.EMPTY_ARRAY;\n@@ -388,1 +361,0 @@\n-\n@@ -390,1 +362,1 @@\n-     * @return deep copy of this object\n+     * @return String representation.\n@@ -392,6 +364,20 @@\n-    public StackMapEntry copy() {\n-        StackMapEntry e;\n-        try {\n-            e = (StackMapEntry) clone();\n-        } catch (final CloneNotSupportedException ex) {\n-            throw new Error(\"Clone Not Supported\");\n+    @Override\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder(64);\n+        buf.append(\"(\");\n+        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n+            buf.append(\"SAME\");\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            buf.append(\"SAME_LOCALS_1_STACK\");\n+        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n+            buf.append(\"SAME_LOCALS_1_STACK_EXTENDED\");\n+        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n+            buf.append(\"CHOP \").append(String.valueOf(251 - frameType));\n+        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+            buf.append(\"SAME_EXTENDED\");\n+        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n+            buf.append(\"APPEND \").append(String.valueOf(frameType - 251));\n+        } else if (frameType == Const.FULL_FRAME) {\n+            buf.append(\"FULL\");\n+        } else {\n+            buf.append(\"UNKNOWN (\").append(frameType).append(\")\");\n@@ -399,4 +385,10 @@\n-\n-        e.typesOfLocals = new StackMapType[typesOfLocals.length];\n-        for (int i = 0; i < typesOfLocals.length; i++) {\n-            e.typesOfLocals[i] = typesOfLocals[i].copy();\n+        buf.append(\", offset delta=\").append(byteCodeOffset);\n+        if (typesOfLocals.length > 0) {\n+            buf.append(\", locals={\");\n+            for (int i = 0; i < typesOfLocals.length; i++) {\n+                buf.append(typesOfLocals[i]);\n+                if (i < typesOfLocals.length - 1) {\n+                    buf.append(\", \");\n+                }\n+            }\n+            buf.append(\"}\");\n@@ -404,3 +396,9 @@\n-        e.typesOfStackItems = new StackMapType[typesOfStackItems.length];\n-        for (int i = 0; i < typesOfStackItems.length; i++) {\n-            e.typesOfStackItems[i] = typesOfStackItems[i].copy();\n+        if (typesOfStackItems.length > 0) {\n+            buf.append(\", stack items={\");\n+            for (int i = 0; i < typesOfStackItems.length; i++) {\n+                buf.append(typesOfStackItems[i]);\n+                if (i < typesOfStackItems.length - 1) {\n+                    buf.append(\", \");\n+                }\n+            }\n+            buf.append(\"}\");\n@@ -408,1 +406,2 @@\n-        return e;\n+        buf.append(\")\");\n+        return buf.toString();\n@@ -411,1 +410,0 @@\n-\n@@ -413,3 +411,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Update the distance (as an offset delta) from this StackMap entry to the next. Note that this might cause the\n+     * frame type to change. Note also that delta may be negative.\n@@ -417,18 +414,1 @@\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitStackMapEntry(this);\n-    }\n-\n-\n-    \/**\n-     * @return Constant pool used by this object.\n-     *\/\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n-    }\n-\n-\n-    \/**\n-     * @param constantPool Constant pool to be used for this object.\n+     * @param delta offset delta\n@@ -436,2 +416,2 @@\n-    public void setConstantPool( final ConstantPool constantPool ) {\n-        this.constantPool = constantPool;\n+    public void updateByteCodeOffset(final int delta) {\n+        setByteCodeOffset(byteCodeOffset + delta);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapEntry.java","additions":219,"deletions":239,"binary":false,"changes":458,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n- * This class represents the type of a local variable or item on stack\n- * used in the StackMap entries.\n+ * This class represents the type of a local variable or item on stack used in the StackMap entries.\n@@ -34,3 +33,3 @@\n- * @see     StackMapEntry\n- * @see     StackMap\n- * @see     Const\n+ * @see StackMapEntry\n+ * @see StackMap\n+ * @see Const\n@@ -40,0 +39,2 @@\n+    public static final StackMapType[] EMPTY_ARRAY = {}; \/\/ must be public because BCELifier code generator writes calls to it\n+\n@@ -44,15 +45,0 @@\n-\n-    \/**\n-     * Construct object from file stream.\n-     * @param file Input stream\n-     * @throws IOException\n-     *\/\n-    StackMapType(final DataInput file, final ConstantPool constant_pool) throws IOException {\n-        this(file.readByte(), -1, constant_pool);\n-        if (hasIndex()) {\n-            this.index = file.readShort();\n-        }\n-        this.constantPool = constant_pool;\n-    }\n-\n-\n@@ -63,5 +49,2 @@\n-    public StackMapType(final byte type, final int index, final ConstantPool constant_pool) {\n-        if ((type < Const.ITEM_Bogus) || (type > Const.ITEM_NewObject)) {\n-            throw new IllegalArgumentException(\"Illegal type for StackMapType: \" + type);\n-        }\n-        this.type = type;\n+    public StackMapType(final byte type, final int index, final ConstantPool constantPool) {\n+        this.type = checkType(type);\n@@ -69,1 +52,1 @@\n-        this.constantPool = constant_pool;\n+        this.constantPool = constantPool;\n@@ -72,4 +55,10 @@\n-\n-    public void setType( final byte t ) {\n-        if ((t < Const.ITEM_Bogus) || (t > Const.ITEM_NewObject)) {\n-            throw new IllegalArgumentException(\"Illegal type for StackMapType: \" + t);\n+    \/**\n+     * Construct object from file stream.\n+     *\n+     * @param file Input stream\n+     * @throws IOException if an I\/O error occurs.\n+     *\/\n+    StackMapType(final DataInput file, final ConstantPool constantPool) throws IOException {\n+        this(file.readByte(), -1, constantPool);\n+        if (hasIndex()) {\n+            this.index = file.readUnsignedShort();\n@@ -77,1 +66,1 @@\n-        type = t;\n+        this.constantPool = constantPool;\n@@ -80,2 +69,4 @@\n-\n-    public byte getType() {\n+    private byte checkType(final byte type) {\n+        if (type < Const.ITEM_Bogus || type > Const.ITEM_NewObject) {\n+            throw new ClassFormatException(\"Illegal type for StackMapType: \" + type);\n+        }\n@@ -85,8 +76,2 @@\n-\n-    public void setIndex( final int t ) {\n-        index = t;\n-    }\n-\n-\n-    \/** @return index to constant pool if type == ITEM_Object, or offset\n-     * in byte code, if type == ITEM_NewObject, and -1 otherwise\n+    \/**\n+     * @return deep copy of this object\n@@ -94,2 +79,7 @@\n-    public int getIndex() {\n-        return index;\n+    public StackMapType copy() {\n+        try {\n+            return (StackMapType) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n@@ -98,1 +88,0 @@\n-\n@@ -103,1 +92,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -105,1 +94,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -112,0 +101,6 @@\n+    \/**\n+     * @return Constant pool used by this object.\n+     *\/\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n+    }\n@@ -113,1 +108,14 @@\n-    \/** @return true, if type is either ITEM_Object or ITEM_NewObject\n+    \/**\n+     * @return index to constant pool if type == ITEM_Object, or offset in byte code, if type == ITEM_NewObject, and -1\n+     *         otherwise\n+     *\/\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+    public byte getType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * @return true, if type is either ITEM_Object or ITEM_NewObject\n@@ -119,1 +127,0 @@\n-\n@@ -126,1 +133,2 @@\n-        } else if (type == Const.ITEM_NewObject) {\n+        }\n+        if (type == Const.ITEM_NewObject) {\n@@ -128,2 +136,0 @@\n-        } else {\n-            return \"\";\n@@ -131,0 +137,1 @@\n+        return \"\";\n@@ -133,1 +140,0 @@\n-\n@@ -135,1 +141,1 @@\n-     * @return String representation\n+     * @param constantPool Constant pool to be used for this object.\n@@ -137,3 +143,2 @@\n-    @Override\n-    public String toString() {\n-        return \"(type=\" + Const.getItemName(type) + printIndex() + \")\";\n+    public void setConstantPool(final ConstantPool constantPool) {\n+        this.constantPool = constantPool;\n@@ -142,11 +147,2 @@\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public StackMapType copy() {\n-        try {\n-            return (StackMapType) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public void setIndex(final int index) {\n+        this.index = index;\n@@ -155,6 +151,2 @@\n-\n-    \/**\n-     * @return Constant pool used by this object.\n-     *\/\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n+    public void setType(final byte type) {\n+        this.type = checkType(type);\n@@ -163,1 +155,0 @@\n-\n@@ -165,1 +156,1 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * @return String representation\n@@ -167,2 +158,3 @@\n-    public void setConstantPool( final ConstantPool constantPool ) {\n-        this.constantPool = constantPool;\n+    @Override\n+    public String toString() {\n+        return \"(type=\" + Const.getItemName(type) + printIndex() + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapType.java","additions":69,"deletions":77,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,7 +32,4 @@\n- * This class is derived from <em>Attribute<\/em> and declares this class as\n- * `synthetic', i.e., it needs special handling.  The JVM specification\n- * states \"A class member that does not appear in the source code must be\n- * marked using a Synthetic attribute.\"  It may appear in the ClassFile\n- * attribute table, a field_info table or a method_info table.  This class\n- * is intended to be instantiated from the\n- * <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and declares this class as 'synthetic', i.e., it needs special\n+ * handling. The JVM specification states \"A class member that does not appear in the source code must be marked using a\n+ * Synthetic attribute.\" It may appear in the ClassFile attribute table, a field_info table or a method_info table. This\n+ * class is intended to be instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -39,1 +37,1 @@\n- * @see     Attribute\n+ * @see Attribute\n@@ -45,10 +43,0 @@\n-\n-    \/**\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use copy() for a physical copy.\n-     *\/\n-    public Synthetic(final Synthetic c) {\n-        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n-    }\n-\n-\n@@ -56,2 +44,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n-     * should represent the string \"Synthetic\".\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8, which should represent the string \"Synthetic\".\n@@ -60,2 +47,1 @@\n-     * @param constant_pool The constant pool this attribute is associated\n-     * with.\n+     * @param constantPool The constant pool this attribute is associated with.\n@@ -63,2 +49,2 @@\n-    public Synthetic(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n-        super(Const.ATTR_SYNTHETIC, name_index, length, constant_pool);\n+    public Synthetic(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n+        super(Const.ATTR_SYNTHETIC, nameIndex, Args.require0(length, \"Synthetic attribute length\"), constantPool);\n@@ -68,1 +54,0 @@\n-\n@@ -72,1 +57,1 @@\n-     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n@@ -75,2 +60,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -78,3 +63,2 @@\n-    Synthetic(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, (byte[]) null, constant_pool);\n+    Synthetic(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (byte[]) null, constantPool);\n@@ -88,0 +72,9 @@\n+    \/**\n+     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n+     * physical copy.\n+     *\n+     * @param c Source to copy.\n+     *\/\n+    public Synthetic(final Synthetic c) {\n+        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n+    }\n@@ -90,3 +83,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -97,1 +89,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -101,0 +93,12 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final Synthetic c = (Synthetic) clone();\n+        if (bytes != null) {\n+            c.bytes = bytes.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -106,1 +110,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -109,1 +113,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -116,1 +120,0 @@\n-\n@@ -124,1 +127,0 @@\n-\n@@ -128,1 +130,1 @@\n-    public void setBytes( final byte[] bytes ) {\n+    public void setBytes(final byte[] bytes) {\n@@ -132,1 +134,0 @@\n-\n@@ -144,15 +145,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final Synthetic c = (Synthetic) clone();\n-        if (bytes != null) {\n-            c.bytes = new byte[bytes.length];\n-            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Synthetic.java","additions":42,"deletions":56,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n-import java.util.HashMap;\n-import java.util.Map;\n+import java.util.Arrays;\n@@ -33,5 +32,3 @@\n- * This class represents a reference to an unknown (i.e.,\n- * application-specific) attribute of a class.  It is instantiated from the\n- * {@link Attribute#readAttribute(java.io.DataInput, ConstantPool)} method.\n- * Applications that need to read in application-specific attributes should create an\n- * {@link UnknownAttributeReader} implementation and attach it via\n+ * This class represents a reference to an unknown (i.e., application-specific) attribute of a class. It is instantiated\n+ * from the {@link Attribute#readAttribute(java.io.DataInput, ConstantPool)} method. Applications that need to read in\n+ * application-specific attributes should create an {@link UnknownAttributeReader} implementation and attach it via\n@@ -39,1 +36,0 @@\n-\n@@ -47,21 +43,0 @@\n-    private final String name;\n-    private static final Map<String, Unknown> unknownAttributes = new HashMap<>();\n-\n-\n-    \/** @return array of unknown attributes, but just one for each kind.\n-     *\/\n-    static Unknown[] getUnknownAttributes() {\n-        final Unknown[] unknowns = new Unknown[unknownAttributes.size()];\n-        unknownAttributes.values().toArray(unknowns);\n-        unknownAttributes.clear();\n-        return unknowns;\n-    }\n-\n-\n-    \/**\n-     * Initialize from another object. Note that both objects use the same\n-     * references (shallow copy). Use clone() for a physical copy.\n-     *\/\n-    public Unknown(final Unknown c) {\n-        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n-    }\n@@ -69,0 +44,1 @@\n+    private final String name;\n@@ -71,1 +47,1 @@\n-     * Create a non-standard attribute.\n+     * Constructs a new instance for a non-standard attribute.\n@@ -73,1 +49,1 @@\n-     * @param name_index Index in constant pool\n+     * @param nameIndex Index in constant pool\n@@ -76,1 +52,1 @@\n-     * @param constant_pool Array of constants\n+     * @param constantPool Array of constants\n@@ -78,2 +54,2 @@\n-    public Unknown(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n-        super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);\n+    public Unknown(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n+        super(Const.ATTR_UNKNOWN, nameIndex, length, constantPool);\n@@ -81,3 +57,1 @@\n-        name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8))\n-                .getBytes();\n-        unknownAttributes.put(name, this);\n+        this.name = constantPool.getConstantUtf8(nameIndex).getBytes();\n@@ -86,1 +60,0 @@\n-\n@@ -88,1 +61,1 @@\n-     * Construct object from input stream.\n+     * Constructs a new instance from an input stream.\n@@ -90,1 +63,1 @@\n-     * @param name_index Index in constant pool\n+     * @param nameIndex Index in constant pool\n@@ -93,2 +66,2 @@\n-     * @param constant_pool Array of constants\n-     * @throws IOException\n+     * @param constantPool Array of constants\n+     * @throws IOException if an I\/O error occurs.\n@@ -96,3 +69,2 @@\n-    Unknown(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n-            throws IOException {\n-        this(name_index, length, (byte[]) null, constant_pool);\n+    Unknown(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, (byte[]) null, constantPool);\n@@ -105,0 +77,8 @@\n+    \/**\n+     * Constructs a new instance from another instance. Note that both objects use the same references (shallow copy). Use clone() for a physical copy.\n+     *\n+     * @param unknown Source.\n+     *\/\n+    public Unknown(final Unknown unknown) {\n+        this(unknown.getNameIndex(), unknown.getLength(), unknown.getBytes(), unknown.getConstantPool());\n+    }\n@@ -107,3 +87,2 @@\n-     * Called by objects that are traversing the nodes of the tree implicitely\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -114,1 +93,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -118,0 +97,12 @@\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constantPool) {\n+        final Unknown c = (Unknown) clone();\n+        if (bytes != null) {\n+            c.bytes = bytes.clone();\n+        }\n+        c.setConstantPool(constantPool);\n+        return c;\n+    }\n@@ -120,1 +111,1 @@\n-     * Dump unknown bytes to file stream.\n+     * Dumps unknown bytes to file stream.\n@@ -123,1 +114,1 @@\n-     * @throws IOException\n+     * @throws IOException if an I\/O error occurs.\n@@ -126,1 +117,1 @@\n-    public void dump( final DataOutputStream file ) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException {\n@@ -133,1 +124,0 @@\n-\n@@ -141,1 +131,0 @@\n-\n@@ -150,1 +139,0 @@\n-\n@@ -154,1 +142,1 @@\n-    public void setBytes( final byte[] bytes ) {\n+    public void setBytes(final byte[] bytes) {\n@@ -158,1 +146,0 @@\n-\n@@ -168,3 +155,3 @@\n-        if (super.getLength() > 10) {\n-            final byte[] tmp = new byte[10];\n-            System.arraycopy(bytes, 0, tmp, 0, 10);\n+        final int limit = 10;\n+        if (super.getLength() > limit) {\n+            final byte[] tmp = Arrays.copyOf(bytes, limit);\n@@ -177,15 +164,0 @@\n-\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy( final ConstantPool _constant_pool ) {\n-        final Unknown c = (Unknown) clone();\n-        if (bytes != null) {\n-            c.bytes = new byte[bytes.length];\n-            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n-        }\n-        c.setConstantPool(_constant_pool);\n-        return c;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Unknown.java","additions":47,"deletions":75,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -25,3 +25,2 @@\n- * Unknown (non-standard) attributes may be read via user-defined factory\n- * objects that can be registered with the Attribute.addAttributeReader\n- * method. These factory objects should implement this interface.\n+ * Unknown (non-standard) attributes may be read via user-defined factory objects that can be registered with the\n+ * Attribute.addAttributeReader method. These factory objects should implement this interface.\n@@ -35,3 +34,3 @@\n-     * When this attribute reader is added via the static method Attribute.addAttributeReader,\n-     * an attribute name is associated with it. As the class file parser parses attributes,\n-     * it will call various AttributeReaders based on the name of the attributes it is constructing.\n+     * When this attribute reader is added via the static method Attribute.addAttributeReader, an attribute name is\n+     * associated with it. As the class file parser parses attributes, it will call various AttributeReaders based on the\n+     * name of the attributes it is constructing.\n@@ -39,6 +38,5 @@\n-     * @param name_index    An index into the constant pool, indexing a ConstantUtf8\n-     *                      that represents the name of the attribute.\n-     * @param length        The length of the data contained in the attribute. This is written\n-     *                      into the constant pool and should agree with what the factory expects the length to be.\n-     * @param file          This is the data input that the factory needs to read its data from.\n-     * @param constant_pool This is the constant pool associated with the Attribute that we are constructing.\n+     * @param nameIndex An index into the constant pool, indexing a ConstantUtf8 that represents the name of the attribute.\n+     * @param length The length of the data contained in the attribute. This is written into the constant pool and should\n+     *        agree with what the factory expects the length to be.\n+     * @param file This is the data input that the factory needs to read its data from.\n+     * @param constantPool This is the constant pool associated with the Attribute that we are constructing.\n@@ -46,3 +44,2 @@\n-     * @return The user-defined AttributeReader should take this data and use\n-     * it to construct an attribute.  In the case of errors, a null can be\n-     * returned which will cause the parsing of the class file to fail.\n+     * @return The user-defined AttributeReader should take this data and use it to construct an attribute. In the case of\n+     *         errors, a null can be returned which will cause the parsing of the class file to fail.\n@@ -52,1 +49,1 @@\n-    Attribute createAttribute( int name_index, int length, java.io.DataInput file, ConstantPool constant_pool );\n+    Attribute createAttribute(int nameIndex, int length, java.io.DataInput file, ConstantPool constantPool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/UnknownAttributeReader.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Arrays;\n@@ -45,1 +46,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -50,3 +51,4 @@\n-    private static int unwrap( final ThreadLocal<Integer> tl ) {\n-        return tl.get();\n-    }\n+    \/**\n+     * Decode characters into bytes. Used by <a href=\"Utility.html#decode(java.lang.String, boolean)\">decode()<\/a>\n+     *\/\n+    private static class JavaReader extends FilterReader {\n@@ -54,2 +56,32 @@\n-    private static void wrap( final ThreadLocal<Integer> tl, final int value ) {\n-        tl.set(value);\n+        public JavaReader(final Reader in) {\n+            super(in);\n+        }\n+\n+        @Override\n+        public int read() throws IOException {\n+            final int b = in.read();\n+            if (b != ESCAPE_CHAR) {\n+                return b;\n+            }\n+            final int i = in.read();\n+            if (i < 0) {\n+                return -1;\n+            }\n+            if (i >= '0' && i <= '9' || i >= 'a' && i <= 'f') { \/\/ Normal escape\n+                final int j = in.read();\n+                if (j < 0) {\n+                    return -1;\n+                }\n+                final char[] tmp = {(char) i, (char) j};\n+                return Integer.parseInt(new String(tmp), 16);\n+            }\n+            return MAP_CHAR[i];\n+        }\n+\n+        @Override\n+        public int read(final char[] cbuf, final int off, final int len) throws IOException {\n+            for (int i = 0; i < len; i++) {\n+                cbuf[off + i] = (char) read();\n+            }\n+            return len;\n+        }\n@@ -58,4 +90,3 @@\n-    \/* How many chars have been consumed\n-     * during parsing in typeSignatureToString().\n-     * Read by methodSignatureToString().\n-     * Set by side effect, but only internally.\n+    \/**\n+     * Encode bytes into valid java identifier characters. Used by\n+     * <a href=\"Utility.html#encode(byte[], boolean)\">encode()<\/a>\n@@ -63,1 +94,35 @@\n-    private static ThreadLocal<Integer> consumed_chars = new ThreadLocal<Integer>() {\n+    private static class JavaWriter extends FilterWriter {\n+\n+        public JavaWriter(final Writer out) {\n+            super(out);\n+        }\n+\n+        @Override\n+        public void write(final char[] cbuf, final int off, final int len) throws IOException {\n+            for (int i = 0; i < len; i++) {\n+                write(cbuf[off + i]);\n+            }\n+        }\n+\n+        @Override\n+        public void write(final int b) throws IOException {\n+            if (isJavaIdentifierPart((char) b) && b != ESCAPE_CHAR) {\n+                out.write(b);\n+            } else {\n+                out.write(ESCAPE_CHAR); \/\/ Escape character\n+                \/\/ Special escape\n+                if (b >= 0 && b < FREE_CHARS) {\n+                    out.write(CHAR_MAP[b]);\n+                } else { \/\/ Normal escape\n+                    final char[] tmp = Integer.toHexString(b).toCharArray();\n+                    if (tmp.length == 1) {\n+                        out.write('0');\n+                        out.write(tmp[0]);\n+                    } else {\n+                        out.write(tmp[0]);\n+                        out.write(tmp[1]);\n+                    }\n+                }\n+            }\n+        }\n+\n@@ -65,2 +130,2 @@\n-        protected Integer initialValue() {\n-            return 0;\n+        public void write(final String str, final int off, final int len) throws IOException {\n+            write(str.toCharArray(), off, len);\n@@ -68,10 +133,12 @@\n-    };\n-\n-    \/* The `WIDE' instruction is used in the\n-     * byte code to allow 16-bit wide indices\n-     * for local variables. This opcode\n-     * precedes an `ILOAD', e.g.. The opcode\n-     * immediately following takes an extra\n-     * byte which is combined with the\n-     * following byte to form a\n-     * 16-bit value.\n+    }\n+\n+    \/*\n+     * How many chars have been consumed during parsing in typeSignatureToString(). Read by methodSignatureToString(). Set\n+     * by side effect, but only internally.\n+     *\/\n+    private static final ThreadLocal<Integer> CONSUMER_CHARS = ThreadLocal.withInitial(() -> Integer.valueOf(0));\n+\n+    \/*\n+     * The 'WIDE' instruction is used in the byte code to allow 16-bit wide indices for local variables. This opcode\n+     * precedes an 'ILOAD', e.g.. The opcode immediately following takes an extra byte which is combined with the following\n+     * byte to form a 16-bit value.\n@@ -79,1 +146,1 @@\n-    private static boolean wide = false;\n+    private static boolean wide;\n@@ -81,0 +148,27 @@\n+    \/\/ A-Z, g-z, _, $\n+    private static final int FREE_CHARS = 48;\n+\n+    private static final int[] CHAR_MAP = new int[FREE_CHARS];\n+\n+    private static final int[] MAP_CHAR = new int[256]; \/\/ Reverse map\n+\n+    private static final char ESCAPE_CHAR = '$';\n+\n+    static {\n+        int j = 0;\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            CHAR_MAP[j] = i;\n+            MAP_CHAR[i] = j;\n+            j++;\n+        }\n+        for (int i = 'g'; i <= 'z'; i++) {\n+            CHAR_MAP[j] = i;\n+            MAP_CHAR[i] = j;\n+            j++;\n+        }\n+        CHAR_MAP[j] = '$';\n+        MAP_CHAR['$'] = j;\n+        j++;\n+        CHAR_MAP[j] = '_';\n+        MAP_CHAR['_'] = j;\n+    }\n@@ -83,1 +177,1 @@\n-     * Convert bit field of flags into string such as `static final'.\n+     * Convert bit field of flags into string such as 'static final'.\n@@ -85,1 +179,1 @@\n-     * @param  access_flags Access flags\n+     * @param accessFlags Access flags\n@@ -88,2 +182,2 @@\n-    public static String accessToString( final int access_flags ) {\n-        return accessToString(access_flags, false);\n+    public static String accessToString(final int accessFlags) {\n+        return accessToString(accessFlags, false);\n@@ -92,1 +186,0 @@\n-\n@@ -94,1 +187,1 @@\n-     * Convert bit field of flags into string such as `static final'.\n+     * Convert bit field of flags into string such as 'static final'.\n@@ -96,4 +189,2 @@\n-     * Special case: Classes compiled with new compilers and with the\n-     * `ACC_SUPER' flag would be said to be \"synchronized\". This is\n-     * because SUN used the same value for the flags `ACC_SUPER' and\n-     * `ACC_SYNCHRONIZED'.\n+     * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be \"synchronized\".\n+     * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.\n@@ -101,2 +192,2 @@\n-     * @param  access_flags Access flags\n-     * @param  for_class access flags are for class qualifiers ?\n+     * @param accessFlags Access flags\n+     * @param forClass access flags are for class qualifiers ?\n@@ -105,1 +196,1 @@\n-    public static String accessToString( final int access_flags, final boolean for_class ) {\n+    public static String accessToString(final int accessFlags, final boolean forClass) {\n@@ -110,5 +201,4 @@\n-            if ((access_flags & p) != 0) {\n-                \/* Special case: Classes compiled with new compilers and with the\n-                 * `ACC_SUPER' flag would be said to be \"synchronized\". This is\n-                 * because SUN used the same value for the flags `ACC_SUPER' and\n-                 * `ACC_SYNCHRONIZED'.\n+            if ((accessFlags & p) != 0) {\n+                \/*\n+                 * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be \"synchronized\".\n+                 * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.\n@@ -116,1 +206,1 @@\n-                if (for_class && ((p == Const.ACC_SUPER) || (p == Const.ACC_INTERFACE))) {\n+                if (forClass && (p == Const.ACC_SUPER || p == Const.ACC_INTERFACE)) {\n@@ -125,0 +215,6 @@\n+    \/**\n+     * Convert (signed) byte to (unsigned) short value, i.e., all negative values become positive.\n+     *\/\n+    private static short byteToShort(final byte b) {\n+        return b < 0 ? (short) (256 + b) : (short) b;\n+    }\n@@ -127,1 +223,1 @@\n-     * @param access_flags the class flags\n+     * @param accessFlags the class flags\n@@ -131,2 +227,10 @@\n-    public static String classOrInterface( final int access_flags ) {\n-        return ((access_flags & Const.ACC_INTERFACE) != 0) ? \"interface\" : \"class\";\n+    public static String classOrInterface(final int accessFlags) {\n+        return (accessFlags & Const.ACC_INTERFACE) != 0 ? \"interface\" : \"class\";\n+    }\n+\n+    \/**\n+     * @return 'flag' with bit 'i' set to 0\n+     *\/\n+    public static int clearBit(final int flag, final int i) {\n+        final int bit = pow2(i);\n+        return (flag & bit) == 0 ? flag : flag ^ bit;\n@@ -135,0 +239,3 @@\n+    public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length) {\n+        return codeToString(code, constantPool, index, length, true);\n+    }\n@@ -137,4 +244,2 @@\n-     * Disassemble a byte array of JVM byte codes starting from code line\n-     * `index' and return the disassembled string representation. Decode only\n-     * `num' opcodes (including their operands), use -1 if you want to\n-     * decompile everything.\n+     * Disassemble a byte array of JVM byte codes starting from code line 'index' and return the disassembled string\n+     * representation. Decode only 'num' opcodes (including their operands), use -1 if you want to decompile everything.\n@@ -142,6 +247,5 @@\n-     * @param  code byte code array\n-     * @param  constant_pool Array of constants\n-     * @param  index offset in `code' array\n-     * <EM>(number of opcodes, not bytes!)<\/EM>\n-     * @param  length number of opcodes to decompile, -1 for all\n-     * @param  verbose be verbose, e.g. print constant pool index\n+     * @param code byte code array\n+     * @param constantPool Array of constants\n+     * @param index offset in 'code' array <EM>(number of opcodes, not bytes!)<\/EM>\n+     * @param length number of opcodes to decompile, -1 for all\n+     * @param verbose be verbose, e.g. print constant pool index\n@@ -150,2 +254,1 @@\n-    public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index,\n-            final int length, final boolean verbose ) {\n+    public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length, final boolean verbose) {\n@@ -155,1 +258,1 @@\n-                codeToString(stream, constant_pool, verbose);\n+                codeToString(stream, constantPool, verbose);\n@@ -158,1 +261,1 @@\n-                if ((length < 0) || (i < length)) {\n+                if (length < 0 || i < length) {\n@@ -160,1 +263,1 @@\n-                    buf.append(indices).append(codeToString(stream, constant_pool, verbose)).append('\\n');\n+                    buf.append(indices).append(codeToString(stream, constantPool, verbose)).append('\\n');\n@@ -169,3 +272,2 @@\n-\n-    public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index, final int length ) {\n-        return codeToString(code, constant_pool, index, length, true);\n+    public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool) throws IOException {\n+        return codeToString(bytes, constantPool, true);\n@@ -174,1 +276,0 @@\n-\n@@ -176,2 +277,1 @@\n-     * Disassemble a stream of byte codes and return the\n-     * string representation.\n+     * Disassemble a stream of byte codes and return the string representation.\n@@ -179,3 +279,3 @@\n-     * @param  bytes stream of bytes\n-     * @param  constant_pool Array of constants\n-     * @param  verbose be verbose, e.g. print constant pool index\n+     * @param bytes stream of bytes\n+     * @param constantPool Array of constants\n+     * @param verbose be verbose, e.g. print constant pool index\n@@ -187,1 +287,1 @@\n-    public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool,\n+    public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool,\n@@ -190,1 +290,1 @@\n-        int default_offset = 0;\n+        int defaultOffset = 0;\n@@ -198,2 +298,2 @@\n-        int[] jump_table;\n-        int no_pad_bytes = 0;\n+        int[] jumpTable;\n+        int noPadBytes = 0;\n@@ -202,2 +302,2 @@\n-        \/* Special case: Skip (0-3) padding bytes, i.e., the\n-         * following bytes are 4-byte-aligned\n+        \/*\n+         * Special case: Skip (0-3) padding bytes, i.e., the following bytes are 4-byte-aligned\n@@ -205,1 +305,1 @@\n-        if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\n+        if (opcode == Const.TABLESWITCH || opcode == Const.LOOKUPSWITCH) {\n@@ -207,2 +307,2 @@\n-            no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n-            for (int i = 0; i < no_pad_bytes; i++) {\n+            noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n+            for (int i = 0; i < noPadBytes; i++) {\n@@ -211,2 +311,1 @@\n-                    System.err.println(\"Warning: Padding byte != 0 in \"\n-                            + Const.getOpcodeName(opcode) + \":\" + b);\n+                    System.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName(opcode) + \":\" + b);\n@@ -216,1 +315,1 @@\n-            default_offset = bytes.readInt();\n+            defaultOffset = bytes.readInt();\n@@ -219,36 +318,15 @@\n-            \/* Table switch has variable length arguments.\n-             *\/\n-            case Const.TABLESWITCH:\n-                low = bytes.readInt();\n-                high = bytes.readInt();\n-                offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n-                default_offset += offset;\n-                buf.append(\"\\tdefault = \").append(default_offset).append(\", low = \").append(low)\n-                        .append(\", high = \").append(high).append(\"(\");\n-                jump_table = new int[high - low + 1];\n-                for (int i = 0; i < jump_table.length; i++) {\n-                    jump_table[i] = offset + bytes.readInt();\n-                    buf.append(jump_table[i]);\n-                    if (i < jump_table.length - 1) {\n-                        buf.append(\", \");\n-                    }\n-                }\n-                buf.append(\")\");\n-                break;\n-            \/* Lookup switch has variable length arguments.\n-             *\/\n-            case Const.LOOKUPSWITCH: {\n-                npairs = bytes.readInt();\n-                offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n-                match = new int[npairs];\n-                jump_table = new int[npairs];\n-                default_offset += offset;\n-                buf.append(\"\\tdefault = \").append(default_offset).append(\", npairs = \").append(\n-                        npairs).append(\" (\");\n-                for (int i = 0; i < npairs; i++) {\n-                    match[i] = bytes.readInt();\n-                    jump_table[i] = offset + bytes.readInt();\n-                    buf.append(\"(\").append(match[i]).append(\", \").append(jump_table[i]).append(\")\");\n-                    if (i < npairs - 1) {\n-                        buf.append(\", \");\n-                    }\n+        \/*\n+         * Table switch has variable length arguments.\n+         *\/\n+        case Const.TABLESWITCH:\n+            low = bytes.readInt();\n+            high = bytes.readInt();\n+            offset = bytes.getIndex() - 12 - noPadBytes - 1;\n+            defaultOffset += offset;\n+            buf.append(\"\\tdefault = \").append(defaultOffset).append(\", low = \").append(low).append(\", high = \").append(high).append(\"(\");\n+            jumpTable = new int[high - low + 1];\n+            for (int i = 0; i < jumpTable.length; i++) {\n+                jumpTable[i] = offset + bytes.readInt();\n+                buf.append(jumpTable[i]);\n+                if (i < jumpTable.length - 1) {\n+                    buf.append(\", \");\n@@ -256,1 +334,0 @@\n-                buf.append(\")\");\n@@ -258,48 +335,18 @@\n-                break;\n-            \/* Two address bytes + offset from start of byte stream form the\n-             * jump target\n-             *\/\n-            case Const.GOTO:\n-            case Const.IFEQ:\n-            case Const.IFGE:\n-            case Const.IFGT:\n-            case Const.IFLE:\n-            case Const.IFLT:\n-            case Const.JSR:\n-            case Const.IFNE:\n-            case Const.IFNONNULL:\n-            case Const.IFNULL:\n-            case Const.IF_ACMPEQ:\n-            case Const.IF_ACMPNE:\n-            case Const.IF_ICMPEQ:\n-            case Const.IF_ICMPGE:\n-            case Const.IF_ICMPGT:\n-            case Const.IF_ICMPLE:\n-            case Const.IF_ICMPLT:\n-            case Const.IF_ICMPNE:\n-                buf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readShort());\n-                break;\n-            \/* 32-bit wide jumps\n-             *\/\n-            case Const.GOTO_W:\n-            case Const.JSR_W:\n-                buf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readInt());\n-                break;\n-            \/* Index byte references local variable (register)\n-             *\/\n-            case Const.ALOAD:\n-            case Const.ASTORE:\n-            case Const.DLOAD:\n-            case Const.DSTORE:\n-            case Const.FLOAD:\n-            case Const.FSTORE:\n-            case Const.ILOAD:\n-            case Const.ISTORE:\n-            case Const.LLOAD:\n-            case Const.LSTORE:\n-            case Const.RET:\n-                if (wide) {\n-                    vindex = bytes.readUnsignedShort();\n-                    wide = false; \/\/ Clear flag\n-                } else {\n-                    vindex = bytes.readUnsignedByte();\n+            buf.append(\")\");\n+            break;\n+        \/*\n+         * Lookup switch has variable length arguments.\n+         *\/\n+        case Const.LOOKUPSWITCH: {\n+            npairs = bytes.readInt();\n+            offset = bytes.getIndex() - 8 - noPadBytes - 1;\n+            match = new int[npairs];\n+            jumpTable = new int[npairs];\n+            defaultOffset += offset;\n+            buf.append(\"\\tdefault = \").append(defaultOffset).append(\", npairs = \").append(npairs).append(\" (\");\n+            for (int i = 0; i < npairs; i++) {\n+                match[i] = bytes.readInt();\n+                jumpTable[i] = offset + bytes.readInt();\n+                buf.append(\"(\").append(match[i]).append(\", \").append(jumpTable[i]).append(\")\");\n+                if (i < npairs - 1) {\n+                    buf.append(\", \");\n@@ -307,108 +354,0 @@\n-                buf.append(\"\\t\\t%\").append(vindex);\n-                break;\n-            \/*\n-             * Remember wide byte which is used to form a 16-bit address in the\n-             * following instruction. Relies on that the method is called again with\n-             * the following opcode.\n-             *\/\n-            case Const.WIDE:\n-                wide = true;\n-                buf.append(\"\\t(wide)\");\n-                break;\n-            \/* Array of basic type.\n-             *\/\n-            case Const.NEWARRAY:\n-                buf.append(\"\\t\\t<\").append(Const.getTypeName(bytes.readByte())).append(\">\");\n-                break;\n-            \/* Access object\/class fields.\n-             *\/\n-            case Const.GETFIELD:\n-            case Const.GETSTATIC:\n-            case Const.PUTFIELD:\n-            case Const.PUTSTATIC:\n-                index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t\").append(\n-                        constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(\n-                        verbose ? \" (\" + index + \")\" : \"\");\n-                break;\n-            \/* Operands are references to classes in constant pool\n-             *\/\n-            case Const.NEW:\n-            case Const.CHECKCAST:\n-                buf.append(\"\\t\");\n-                \/\/$FALL-THROUGH$\n-            case Const.INSTANCEOF:\n-                index = bytes.readUnsignedShort();\n-                buf.append(\"\\t<\").append(\n-                        constant_pool.constantToString(index, Const.CONSTANT_Class))\n-                        .append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\n-                break;\n-            \/* Operands are references to methods in constant pool\n-             *\/\n-            case Const.INVOKESPECIAL:\n-            case Const.INVOKESTATIC:\n-                index = bytes.readUnsignedShort();\n-                final Constant c = constant_pool.getConstant(index);\n-                \/\/ With Java8 operand may be either a CONSTANT_Methodref\n-                \/\/ or a CONSTANT_InterfaceMethodref.   (markro)\n-                buf.append(\"\\t\").append(\n-                        constant_pool.constantToString(index, c.getTag()))\n-                        .append(verbose ? \" (\" + index + \")\" : \"\");\n-                break;\n-            case Const.INVOKEVIRTUAL:\n-                index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\").append(\n-                        constant_pool.constantToString(index, Const.CONSTANT_Methodref))\n-                        .append(verbose ? \" (\" + index + \")\" : \"\");\n-                break;\n-            case Const.INVOKEINTERFACE:\n-                index = bytes.readUnsignedShort();\n-                final int nargs = bytes.readUnsignedByte(); \/\/ historical, redundant\n-                buf.append(\"\\t\").append(\n-                        constant_pool\n-                                .constantToString(index, Const.CONSTANT_InterfaceMethodref))\n-                        .append(verbose ? \" (\" + index + \")\\t\" : \"\").append(nargs).append(\"\\t\")\n-                        .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n-                break;\n-            case Const.INVOKEDYNAMIC:\n-                index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\").append(\n-                        constant_pool\n-                                .constantToString(index, Const.CONSTANT_InvokeDynamic))\n-                        .append(verbose ? \" (\" + index + \")\\t\" : \"\")\n-                        .append(bytes.readUnsignedByte())  \/\/ Thrid byte is a reserved space\n-                        .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n-                break;\n-            \/* Operands are references to items in constant pool\n-             *\/\n-            case Const.LDC_W:\n-            case Const.LDC2_W:\n-                index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t\").append(\n-                        constant_pool.constantToString(index, constant_pool.getConstant(index)\n-                                .getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n-                break;\n-            case Const.LDC:\n-                index = bytes.readUnsignedByte();\n-                buf.append(\"\\t\\t\").append(\n-                        constant_pool.constantToString(index, constant_pool.getConstant(index)\n-                                .getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n-                break;\n-            \/* Array of references.\n-             *\/\n-            case Const.ANEWARRAY:\n-                index = bytes.readUnsignedShort();\n-                buf.append(\"\\t\\t<\").append(\n-                        compactClassName(constant_pool.getConstantString(index,\n-                                Const.CONSTANT_Class), false)).append(\">\").append(\n-                        verbose ? \" (\" + index + \")\" : \"\");\n-                break;\n-            \/* Multidimensional array of references.\n-             *\/\n-            case Const.MULTIANEWARRAY: {\n-                index = bytes.readUnsignedShort();\n-                final int dimensions = bytes.readUnsignedByte();\n-                buf.append(\"\\t<\").append(\n-                        compactClassName(constant_pool.getConstantString(index,\n-                                Const.CONSTANT_Class), false)).append(\">\\t\").append(dimensions)\n-                        .append(verbose ? \" (\" + index + \")\" : \"\");\n@@ -416,31 +355,179 @@\n-                break;\n-            \/* Increment local variable.\n-             *\/\n-            case Const.IINC:\n-                if (wide) {\n-                    vindex = bytes.readUnsignedShort();\n-                    constant = bytes.readShort();\n-                    wide = false;\n-                } else {\n-                    vindex = bytes.readUnsignedByte();\n-                    constant = bytes.readByte();\n-                }\n-                buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n-                break;\n-            default:\n-                if (Const.getNoOfOperands(opcode) > 0) {\n-                    for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n-                        buf.append(\"\\t\\t\");\n-                        switch (Const.getOperandType(opcode, i)) {\n-                            case Const.T_BYTE:\n-                                buf.append(bytes.readByte());\n-                                break;\n-                            case Const.T_SHORT:\n-                                buf.append(bytes.readShort());\n-                                break;\n-                            case Const.T_INT:\n-                                buf.append(bytes.readInt());\n-                                break;\n-                            default: \/\/ Never reached\n-                                throw new IllegalStateException(\"Unreachable default case reached!\");\n-                        }\n+            buf.append(\")\");\n+        }\n+            break;\n+        \/*\n+         * Two address bytes + offset from start of byte stream form the jump target\n+         *\/\n+        case Const.GOTO:\n+        case Const.IFEQ:\n+        case Const.IFGE:\n+        case Const.IFGT:\n+        case Const.IFLE:\n+        case Const.IFLT:\n+        case Const.JSR:\n+        case Const.IFNE:\n+        case Const.IFNONNULL:\n+        case Const.IFNULL:\n+        case Const.IF_ACMPEQ:\n+        case Const.IF_ACMPNE:\n+        case Const.IF_ICMPEQ:\n+        case Const.IF_ICMPGE:\n+        case Const.IF_ICMPGT:\n+        case Const.IF_ICMPLE:\n+        case Const.IF_ICMPLT:\n+        case Const.IF_ICMPNE:\n+            buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readShort());\n+            break;\n+        \/*\n+         * 32-bit wide jumps\n+         *\/\n+        case Const.GOTO_W:\n+        case Const.JSR_W:\n+            buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readInt());\n+            break;\n+        \/*\n+         * Index byte references local variable (register)\n+         *\/\n+        case Const.ALOAD:\n+        case Const.ASTORE:\n+        case Const.DLOAD:\n+        case Const.DSTORE:\n+        case Const.FLOAD:\n+        case Const.FSTORE:\n+        case Const.ILOAD:\n+        case Const.ISTORE:\n+        case Const.LLOAD:\n+        case Const.LSTORE:\n+        case Const.RET:\n+            if (wide) {\n+                vindex = bytes.readUnsignedShort();\n+                wide = false; \/\/ Clear flag\n+            } else {\n+                vindex = bytes.readUnsignedByte();\n+            }\n+            buf.append(\"\\t\\t%\").append(vindex);\n+            break;\n+        \/*\n+         * Remember wide byte which is used to form a 16-bit address in the following instruction. Relies on that the method is\n+         * called again with the following opcode.\n+         *\/\n+        case Const.WIDE:\n+            wide = true;\n+            buf.append(\"\\t(wide)\");\n+            break;\n+        \/*\n+         * Array of basic type.\n+         *\/\n+        case Const.NEWARRAY:\n+            buf.append(\"\\t\\t<\").append(Const.getTypeName(bytes.readByte())).append(\">\");\n+            break;\n+        \/*\n+         * Access object\/class fields.\n+         *\/\n+        case Const.GETFIELD:\n+        case Const.GETSTATIC:\n+        case Const.PUTFIELD:\n+        case Const.PUTSTATIC:\n+            index = bytes.readUnsignedShort();\n+            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n+        \/*\n+         * Operands are references to classes in constant pool\n+         *\/\n+        case Const.NEW:\n+        case Const.CHECKCAST:\n+            buf.append(\"\\t\");\n+            \/\/$FALL-THROUGH$\n+        case Const.INSTANCEOF:\n+            index = bytes.readUnsignedShort();\n+            buf.append(\"\\t<\").append(constantPool.constantToString(index, Const.CONSTANT_Class)).append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n+        \/*\n+         * Operands are references to methods in constant pool\n+         *\/\n+        case Const.INVOKESPECIAL:\n+        case Const.INVOKESTATIC:\n+            index = bytes.readUnsignedShort();\n+            final Constant c = constantPool.getConstant(index);\n+            \/\/ With Java8 operand may be either a CONSTANT_Methodref\n+            \/\/ or a CONSTANT_InterfaceMethodref. (markro)\n+            buf.append(\"\\t\").append(constantPool.constantToString(index, c.getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n+        case Const.INVOKEVIRTUAL:\n+            index = bytes.readUnsignedShort();\n+            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n+        case Const.INVOKEINTERFACE:\n+            index = bytes.readUnsignedShort();\n+            final int nargs = bytes.readUnsignedByte(); \/\/ historical, redundant\n+            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? \" (\" + index + \")\\t\" : \"\")\n+                .append(nargs).append(\"\\t\").append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n+            break;\n+        case Const.INVOKEDYNAMIC:\n+            index = bytes.readUnsignedShort();\n+            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? \" (\" + index + \")\\t\" : \"\")\n+                .append(bytes.readUnsignedByte()) \/\/ Thrid byte is a reserved space\n+                .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n+            break;\n+        \/*\n+         * Operands are references to items in constant pool\n+         *\/\n+        case Const.LDC_W:\n+        case Const.LDC2_W:\n+            index = bytes.readUnsignedShort();\n+            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))\n+                .append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n+        case Const.LDC:\n+            index = bytes.readUnsignedByte();\n+            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))\n+                .append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n+        \/*\n+         * Array of references.\n+         *\/\n+        case Const.ANEWARRAY:\n+            index = bytes.readUnsignedShort();\n+            buf.append(\"\\t\\t<\").append(compactClassName(constantPool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\")\n+                .append(verbose ? \" (\" + index + \")\" : \"\");\n+            break;\n+        \/*\n+         * Multidimensional array of references.\n+         *\/\n+        case Const.MULTIANEWARRAY: {\n+            index = bytes.readUnsignedShort();\n+            final int dimensions = bytes.readUnsignedByte();\n+            buf.append(\"\\t<\").append(compactClassName(constantPool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\\t\").append(dimensions)\n+                .append(verbose ? \" (\" + index + \")\" : \"\");\n+        }\n+            break;\n+        \/*\n+         * Increment local variable.\n+         *\/\n+        case Const.IINC:\n+            if (wide) {\n+                vindex = bytes.readUnsignedShort();\n+                constant = bytes.readShort();\n+                wide = false;\n+            } else {\n+                vindex = bytes.readUnsignedByte();\n+                constant = bytes.readByte();\n+            }\n+            buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n+            break;\n+        default:\n+            if (Const.getNoOfOperands(opcode) > 0) {\n+                for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n+                    buf.append(\"\\t\\t\");\n+                    switch (Const.getOperandType(opcode, i)) {\n+                    case Const.T_BYTE:\n+                        buf.append(bytes.readByte());\n+                        break;\n+                    case Const.T_SHORT:\n+                        buf.append(bytes.readShort());\n+                        break;\n+                    case Const.T_INT:\n+                        buf.append(bytes.readInt());\n+                        break;\n+                    default: \/\/ Never reached\n+                        throw new IllegalStateException(\"Unreachable default case reached!\");\n@@ -449,0 +536,1 @@\n+            }\n@@ -453,7 +541,0 @@\n-\n-    public static String codeToString( final ByteSequence bytes, final ConstantPool constant_pool )\n-            throws IOException {\n-        return codeToString(bytes, constant_pool, true);\n-    }\n-\n-\n@@ -461,2 +542,1 @@\n-     * Shorten long class names, <em>java\/lang\/String<\/em> becomes\n-     * <em>String<\/em>.\n+     * Shorten long class names, <em>java\/lang\/String<\/em> becomes <em>String<\/em>.\n@@ -467,1 +547,1 @@\n-    public static String compactClassName( final String str ) {\n+    public static String compactClassName(final String str) {\n@@ -471,1 +551,0 @@\n-\n@@ -473,4 +552,2 @@\n-     * Shorten long class names, <em>java\/lang\/String<\/em> becomes\n-     * <em>java.lang.String<\/em>,\n-     * e.g.. If <em>chopit<\/em> is <em>true<\/em> the prefix <em>java.lang<\/em>\n-     * is also removed.\n+     * Shorten long class names, <em>java\/lang\/String<\/em> becomes <em>java.lang.String<\/em>, e.g.. If <em>chopit<\/em> is\n+     * <em>true<\/em> the prefix <em>java.lang<\/em> is also removed.\n@@ -482,1 +559,1 @@\n-    public static String compactClassName( final String str, final boolean chopit ) {\n+    public static String compactClassName(final String str, final boolean chopit) {\n@@ -486,1 +563,0 @@\n-\n@@ -488,4 +564,2 @@\n-     * Shorten long class name <em>str<\/em>, i.e., chop off the <em>prefix<\/em>,\n-     * if the\n-     * class name starts with this string and the flag <em>chopit<\/em> is true.\n-     * Slashes <em>\/<\/em> are converted to dots <em>.<\/em>.\n+     * Shorten long class name <em>str<\/em>, i.e., chop off the <em>prefix<\/em>, if the class name starts with this string\n+     * and the flag <em>chopit<\/em> is true. Slashes <em>\/<\/em> are converted to dots <em>.<\/em>.\n@@ -498,1 +572,1 @@\n-    public static String compactClassName( String str, final String prefix, final boolean chopit ) {\n+    public static String compactClassName(String str, final String prefix, final boolean chopit) {\n@@ -500,6 +574,4 @@\n-        str = str.replace('\/', '.'); \/\/ Is `\/' on all systems, even DOS\n-        if (chopit) {\n-            \/\/ If string starts with `prefix' and contains no further dots\n-            if (str.startsWith(prefix) && (str.substring(len).indexOf('.') == -1)) {\n-                str = str.substring(len);\n-            }\n+        str = pathToPackage(str); \/\/ Is '\/' on all systems, even DOS\n+        \/\/ If string starts with 'prefix' and contains no further dots\n+        if (chopit && str.startsWith(prefix) && str.substring(len).indexOf('.') == -1) {\n+            str = str.substring(len);\n@@ -510,9 +582,0 @@\n-\n-    \/**\n-     * @return `flag' with bit `i' set to 1\n-     *\/\n-    public static int setBit( final int flag, final int i ) {\n-        return flag | pow2(i);\n-    }\n-\n-\n@@ -520,1 +583,1 @@\n-     * @return `flag' with bit `i' set to 0\n+     * Escape all occurrences of newline chars '\\n', quotes \\\", etc.\n@@ -522,3 +585,26 @@\n-    public static int clearBit( final int flag, final int i ) {\n-        final int bit = pow2(i);\n-        return (flag & bit) == 0 ? flag : flag ^ bit;\n+    public static String convertString(final String label) {\n+        final char[] ch = label.toCharArray();\n+        final StringBuilder buf = new StringBuilder();\n+        for (final char element : ch) {\n+            switch (element) {\n+            case '\\n':\n+                buf.append(\"\\\\n\");\n+                break;\n+            case '\\r':\n+                buf.append(\"\\\\r\");\n+                break;\n+            case '\\\"':\n+                buf.append(\"\\\\\\\"\");\n+                break;\n+            case '\\'':\n+                buf.append(\"\\\\'\");\n+                break;\n+            case '\\\\':\n+                buf.append(\"\\\\\\\\\");\n+                break;\n+            default:\n+                buf.append(element);\n+                break;\n+            }\n+        }\n+        return buf.toString();\n@@ -527,6 +613,28 @@\n-\n-    \/**\n-     * @return true, if bit `i' in `flag' is set\n-     *\/\n-    public static boolean isSet( final int flag, final int i ) {\n-        return (flag & pow2(i)) != 0;\n+    private static int countBrackets(final String brackets) {\n+        final char[] chars = brackets.toCharArray();\n+        int count = 0;\n+        boolean open = false;\n+        for (final char c : chars) {\n+            switch (c) {\n+            case '[':\n+                if (open) {\n+                    throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                }\n+                open = true;\n+                break;\n+            case ']':\n+                if (!open) {\n+                    throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                }\n+                open = false;\n+                count++;\n+                break;\n+            default:\n+                \/\/ Don't care\n+                break;\n+            }\n+        }\n+        if (open) {\n+            throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+        }\n+        return count;\n@@ -535,1 +643,0 @@\n-\n@@ -537,2 +644,1 @@\n-     * Converts string containing the method return and argument types\n-     * to a byte code method signature.\n+     * Decode a string back to a byte array.\n@@ -540,3 +646,2 @@\n-     * @param  ret Return type of method\n-     * @param  argv Types of method arguments\n-     * @return Byte code representation of method signature\n+     * @param s the string to convert\n+     * @param uncompress use gzip to uncompress the stream of bytes\n@@ -544,1 +649,1 @@\n-     * @throws ClassFormatException if the signature is for Void\n+     * @throws IOException if there's a gzip exception\n@@ -546,11 +651,6 @@\n-    public static String methodTypeToSignature( final String ret, final String[] argv )\n-            throws ClassFormatException {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        String str;\n-        if (argv != null) {\n-            for (final String element : argv) {\n-                str = getSignature(element);\n-                if (str.endsWith(\"V\")) {\n-                    throw new ClassFormatException(\"Invalid type: \" + element);\n-                }\n-                buf.append(str);\n+    public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n+        byte[] bytes;\n+        try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray())); ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n+            int ch;\n+            while ((ch = jr.read()) >= 0) {\n+                bos.write(ch);\n@@ -558,0 +658,1 @@\n+            bytes = bos.toByteArray();\n@@ -559,3 +660,11 @@\n-        str = getSignature(ret);\n-        buf.append(\")\").append(str);\n-        return buf.toString();\n+        if (uncompress) {\n+            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n+            final byte[] tmp = new byte[bytes.length * 3]; \/\/ Rough estimate\n+            int count = 0;\n+            int b;\n+            while ((b = gis.read()) >= 0) {\n+                tmp[count++] = (byte) b;\n+            }\n+            bytes = Arrays.copyOf(tmp, count);\n+        }\n+        return bytes;\n@@ -564,1 +673,0 @@\n-\n@@ -566,1 +674,3 @@\n-     * Converts argument list portion of method signature to string with all class names compacted.\n+     * Encode byte array it into Java identifier string, i.e., a string that only contains the following characters: (a, ...\n+     * z, A, ... Z, 0, ... 9, _, $). The encoding algorithm itself is not too clever: if the current byte's ASCII value\n+     * already is a valid Java identifier part, leave it as it is. Otherwise it writes the escape character($) followed by:\n@@ -568,12 +678,4 @@\n-     * @param  signature    Method signature\n-     * @return String Array of argument types\n-     * @throws ClassFormatException\n-     *\/\n-    public static String[] methodSignatureArgumentTypes( final String signature )\n-            throws ClassFormatException {\n-        return methodSignatureArgumentTypes(signature, true);\n-    }\n-\n-\n-    \/**\n-     * Converts argument list portion of method signature to string.\n+     * <ul>\n+     * <li>the ASCII value as a hexadecimal string, if the value is not in the range 200..247<\/li>\n+     * <li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247<\/li>\n+     * <\/ul>\n@@ -581,7 +683,178 @@\n-     * @param  signature    Method signature\n-     * @param  chopit flag that determines whether chopping is executed or not\n-     * @return String Array of argument types\n-     * @throws ClassFormatException\n-     *\/\n-    public static String[] methodSignatureArgumentTypes( final String signature, final boolean chopit )\n-            throws ClassFormatException {\n+     * <p>\n+     * This operation inflates the original byte array by roughly 40-50%\n+     * <\/p>\n+     *\n+     * @param bytes the byte array to convert\n+     * @param compress use gzip to minimize string\n+     *\n+     * @throws IOException if there's a gzip exception\n+     *\/\n+    public static String encode(byte[] bytes, final boolean compress) throws IOException {\n+        if (compress) {\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n+                gos.write(bytes, 0, bytes.length);\n+                gos.finish();\n+                bytes = baos.toByteArray();\n+            }\n+        }\n+        final CharArrayWriter caw = new CharArrayWriter();\n+        try (JavaWriter jw = new JavaWriter(caw)) {\n+            for (final byte b : bytes) {\n+                final int in = b & 0x000000ff; \/\/ Normalize to unsigned\n+                jw.write(in);\n+            }\n+        }\n+        return caw.toString();\n+    }\n+\n+    \/**\n+     * Fillup char with up to length characters with char 'fill' and justify it left or right.\n+     *\n+     * @param str string to format\n+     * @param length length of desired string\n+     * @param leftJustify format left or right\n+     * @param fill fill character\n+     * @return formatted string\n+     *\/\n+    public static String fillup(final String str, final int length, final boolean leftJustify, final char fill) {\n+        final int len = length - str.length();\n+        final char[] buf = new char[Math.max(len, 0)];\n+        Arrays.fill(buf, fill);\n+        if (leftJustify) {\n+            return str + new String(buf);\n+        }\n+        return new String(buf) + str;\n+    }\n+\n+    \/**\n+     * Return a string for an integer justified left or right and filled up with 'fill' characters if necessary.\n+     *\n+     * @param i integer to format\n+     * @param length length of desired string\n+     * @param leftJustify format left or right\n+     * @param fill fill character\n+     * @return formatted int\n+     *\/\n+    public static String format(final int i, final int length, final boolean leftJustify, final char fill) {\n+        return fillup(Integer.toString(i), length, leftJustify, fill);\n+    }\n+\n+    \/**\n+     * WARNING:\n+     *\n+     * There is some nomenclature confusion through much of the BCEL code base with respect to the terms Descriptor and\n+     * Signature. For the offical definitions see:\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3\"> Descriptors in The Java\n+     *      Virtual Machine Specification<\/a>\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.9.1\"> Signatures in The Java\n+     *      Virtual Machine Specification<\/a>\n+     *\n+     *      In brief, a descriptor is a string representing the type of a field or method. Signatures are similar, but more\n+     *      complex. Signatures are used to encode declarations written in the Java programming language that use types\n+     *      outside the type system of the Java Virtual Machine. They are used to describe the type of any class, interface,\n+     *      constructor, method or field whose declaration uses type variables or parameterized types.\n+     *\n+     *      To parse a descriptor, call typeSignatureToString. To parse a signature, call signatureToString.\n+     *\n+     *      Note that if the signature string is a single, non-generic item, the call to signatureToString reduces to a call\n+     *      to typeSignatureToString. Also note, that if you only wish to parse the first item in a longer signature string,\n+     *      you should call typeSignatureToString directly.\n+     *\/\n+\n+    \/**\n+     * Parse Java type such as \"char\", or \"java.lang.String[]\" and return the signature in byte code format, e.g. \"C\" or\n+     * \"[Ljava\/lang\/String;\" respectively.\n+     *\n+     * @param type Java type\n+     * @return byte code signature\n+     *\/\n+    public static String getSignature(String type) {\n+        final StringBuilder buf = new StringBuilder();\n+        final char[] chars = type.toCharArray();\n+        boolean charFound = false;\n+        boolean delim = false;\n+        int index = -1;\n+        loop: for (int i = 0; i < chars.length; i++) {\n+            switch (chars[i]) {\n+            case ' ':\n+            case '\\t':\n+            case '\\n':\n+            case '\\r':\n+            case '\\f':\n+                if (charFound) {\n+                    delim = true;\n+                }\n+                break;\n+            case '[':\n+                if (!charFound) {\n+                    throw new IllegalArgumentException(\"Illegal type: \" + type);\n+                }\n+                index = i;\n+                break loop;\n+            default:\n+                charFound = true;\n+                if (!delim) {\n+                    buf.append(chars[i]);\n+                }\n+            }\n+        }\n+        int brackets = 0;\n+        if (index > 0) {\n+            brackets = countBrackets(type.substring(index));\n+        }\n+        type = buf.toString();\n+        buf.setLength(0);\n+        for (int i = 0; i < brackets; i++) {\n+            buf.append('[');\n+        }\n+        boolean found = false;\n+        for (int i = Const.T_BOOLEAN; i <= Const.T_VOID && !found; i++) {\n+            if (Const.getTypeName(i).equals(type)) {\n+                found = true;\n+                buf.append(Const.getShortTypeName(i));\n+            }\n+        }\n+        if (!found) {\n+            buf.append('L').append(packageToPath(type)).append(';');\n+        }\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * @param ch the character to test if it's part of an identifier\n+     *\n+     * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)\n+     *\/\n+    public static boolean isJavaIdentifierPart(final char ch) {\n+        return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch == '_';\n+    }\n+\n+    \/**\n+     * @return true, if bit 'i' in 'flag' is set\n+     *\/\n+    public static boolean isSet(final int flag, final int i) {\n+        return (flag & pow2(i)) != 0;\n+    }\n+\n+    \/**\n+     * Converts argument list portion of method signature to string with all class names compacted.\n+     *\n+     * @param signature Method signature\n+     * @return String Array of argument types\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     *\/\n+    public static String[] methodSignatureArgumentTypes(final String signature) throws ClassFormatException {\n+        return methodSignatureArgumentTypes(signature, true);\n+    }\n+\n+    \/**\n+     * Converts argument list portion of method signature to string.\n+     *\n+     * @param signature Method signature\n+     * @param chopit flag that determines whether chopping is executed or not\n+     * @return String Array of argument types\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     *\/\n+    public static String[] methodSignatureArgumentTypes(final String signature, final boolean chopit) throws ClassFormatException {\n@@ -591,1 +864,1 @@\n-            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n+            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n@@ -598,2 +871,2 @@\n-                \/\/corrected concurrent private static field acess\n-                index += unwrap(consumed_chars); \/\/ update position\n+                \/\/ corrected concurrent private static field acess\n+                index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -604,1 +877,1 @@\n-        return vec.toArray(new String[vec.size()]);\n+        return vec.toArray(Const.EMPTY_STRING_ARRAY);\n@@ -607,1 +880,0 @@\n-\n@@ -611,1 +883,1 @@\n-     * @param  signature    Method signature\n+     * @param signature Method signature\n@@ -613,1 +885,1 @@\n-     * @throws ClassFormatException\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -615,1 +887,1 @@\n-    public static String methodSignatureReturnType( final String signature ) throws ClassFormatException {\n+    public static String methodSignatureReturnType(final String signature) throws ClassFormatException {\n@@ -619,1 +891,0 @@\n-\n@@ -623,2 +894,2 @@\n-     * @param  signature    Method signature\n-     * @param  chopit flag that determines whether chopping is executed or not\n+     * @param signature Method signature\n+     * @param chopit flag that determines whether chopping is executed or not\n@@ -626,1 +897,1 @@\n-     * @throws ClassFormatException\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -628,1 +899,1 @@\n-    public static String methodSignatureReturnType( final String signature, final boolean chopit ) throws ClassFormatException {\n+    public static String methodSignatureReturnType(final String signature, final boolean chopit) throws ClassFormatException {\n@@ -632,1 +903,1 @@\n-            \/\/ Read return type after `)'\n+            \/\/ Read return type after ')'\n@@ -644,1 +915,0 @@\n-\n@@ -648,3 +918,3 @@\n-     * @param  signature to convert\n-     * @param  name of method\n-     * @param  access flags of method\n+     * @param signature to convert\n+     * @param name of method\n+     * @param access flags of method\n@@ -653,1 +923,1 @@\n-    public static String methodSignatureToString( final String signature, final String name, final String access ) {\n+    public static String methodSignatureToString(final String signature, final String name, final String access) {\n@@ -657,1 +927,0 @@\n-\n@@ -661,4 +930,4 @@\n-     * @param  signature to convert\n-     * @param  name of method\n-     * @param  access flags of method\n-     * @param  chopit flag that determines whether chopping is executed or not\n+     * @param signature to convert\n+     * @param name of method\n+     * @param access flags of method\n+     * @param chopit flag that determines whether chopping is executed or not\n@@ -667,1 +936,1 @@\n-    public static String methodSignatureToString( final String signature, final String name, final String access, final boolean chopit ) {\n+    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit) {\n@@ -671,1 +940,0 @@\n-\n@@ -673,3 +941,2 @@\n-     * This method converts a method signature string into a Java type declaration like\n-     * `void main(String[])' and throws a `ClassFormatException' when the parsed\n-     * type is invalid.\n+     * This method converts a method signature string into a Java type declaration like 'void main(String[])' and throws a\n+     * 'ClassFormatException' when the parsed type is invalid.\n@@ -677,5 +944,5 @@\n-     * @param  signature    Method signature\n-     * @param  name         Method name\n-     * @param  access       Method access rights\n-     * @param  chopit flag that determines whether chopping is executed or not\n-     * @param  vars the LocalVariableTable for the method\n+     * @param signature Method signature\n+     * @param name Method name\n+     * @param access Method access rights\n+     * @param chopit flag that determines whether chopping is executed or not\n+     * @param vars the LocalVariableTable for the method\n@@ -683,1 +950,1 @@\n-     * @throws ClassFormatException\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n@@ -685,2 +952,2 @@\n-    public static String methodSignatureToString( final String signature, final String name,\n-            final String access, final boolean chopit, final LocalVariableTable vars ) throws ClassFormatException {\n+    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit,\n+        final LocalVariableTable vars) throws ClassFormatException {\n@@ -690,1 +957,1 @@\n-        int var_index = access.contains(\"static\") ? 0 : 1;\n+        int varIndex = access.contains(\"static\") ? 0 : 1;\n@@ -692,1 +959,1 @@\n-            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n+            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n@@ -698,2 +965,2 @@\n-                final String param_type = typeSignatureToString(signature.substring(index), chopit);\n-                buf.append(param_type);\n+                final String paramType = typeSignatureToString(signature.substring(index), chopit);\n+                buf.append(paramType);\n@@ -701,1 +968,1 @@\n-                    final LocalVariable l = vars.getLocalVariable(var_index, 0);\n+                    final LocalVariable l = vars.getLocalVariable(varIndex, 0);\n@@ -706,1 +973,1 @@\n-                    buf.append(\" arg\").append(var_index);\n+                    buf.append(\" arg\").append(varIndex);\n@@ -708,2 +975,2 @@\n-                if (\"double\".equals(param_type) || \"long\".equals(param_type)) {\n-                    var_index += 2;\n+                if (\"double\".equals(paramType) || \"long\".equals(paramType)) {\n+                    varIndex += 2;\n@@ -711,1 +978,1 @@\n-                    var_index++;\n+                    varIndex++;\n@@ -714,2 +981,2 @@\n-                \/\/corrected concurrent private static field acess\n-                index += unwrap(consumed_chars); \/\/ update position\n+                \/\/ corrected concurrent private static field acess\n+                index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -718,1 +985,1 @@\n-            \/\/ Read return type after `)'\n+            \/\/ Read return type after ')'\n@@ -728,2 +995,39 @@\n-        return access + ((access.length() > 0) ? \" \" : \"\") + \/\/ May be an empty string\n-                type + \" \" + name + buf.toString();\n+        return access + (!access.isEmpty() ? \" \" : \"\") + \/\/ May be an empty string\n+            type + \" \" + name + buf.toString();\n+    }\n+\n+    \/**\n+     * Converts string containing the method return and argument types to a byte code method signature.\n+     *\n+     * @param ret Return type of method\n+     * @param argv Types of method arguments\n+     * @return Byte code representation of method signature\n+     *\n+     * @throws ClassFormatException if the signature is for Void\n+     *\/\n+    public static String methodTypeToSignature(final String ret, final String[] argv) throws ClassFormatException {\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        String str;\n+        if (argv != null) {\n+            for (final String element : argv) {\n+                str = getSignature(element);\n+                if (str.endsWith(\"V\")) {\n+                    throw new ClassFormatException(\"Invalid type: \" + element);\n+                }\n+                buf.append(str);\n+            }\n+        }\n+        str = getSignature(ret);\n+        buf.append(\")\").append(str);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Converts '.'s to '\/'s.\n+     *\n+     * @param name Source\n+     * @return converted value\n+     * @since 6.7.0\n+     *\/\n+    public static String packageToPath(final String name) {\n+        return name.replace('.', '\/');\n@@ -732,0 +1036,10 @@\n+    \/**\n+     * Converts a path to a package name.\n+     *\n+     * @param str the source path.\n+     * @return a package name.\n+     * @since 6.6.0\n+     *\/\n+    public static String pathToPackage(final String str) {\n+        return str.replace('\/', '.');\n+    }\n@@ -733,1 +1047,1 @@\n-    private static int pow2( final int n ) {\n+    private static int pow2(final int n) {\n@@ -737,0 +1051,39 @@\n+    public static String printArray(final Object[] obj) {\n+        return printArray(obj, true);\n+    }\n+\n+    public static String printArray(final Object[] obj, final boolean braces) {\n+        return printArray(obj, braces, false);\n+    }\n+\n+    public static String printArray(final Object[] obj, final boolean braces, final boolean quote) {\n+        if (obj == null) {\n+            return null;\n+        }\n+        final StringBuilder buf = new StringBuilder();\n+        if (braces) {\n+            buf.append('{');\n+        }\n+        for (int i = 0; i < obj.length; i++) {\n+            if (obj[i] != null) {\n+                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n+            } else {\n+                buf.append(\"null\");\n+            }\n+            if (i < obj.length - 1) {\n+                buf.append(\", \");\n+            }\n+        }\n+        if (braces) {\n+            buf.append('}');\n+        }\n+        return buf.toString();\n+    }\n+\n+    public static void printArray(final PrintStream out, final Object[] obj) {\n+        out.println(printArray(obj, true));\n+    }\n+\n+    public static void printArray(final PrintWriter out, final Object[] obj) {\n+        out.println(printArray(obj, true));\n+    }\n@@ -746,1 +1099,1 @@\n-    public static String replace( String str, final String old, final String new_ ) {\n+    public static String replace(String str, final String old, final String new_) {\n@@ -748,1 +1101,1 @@\n-        int old_index;\n+        int oldIndex;\n@@ -750,1 +1103,1 @@\n-            if (str.contains(old)) { \/\/ `old' found in str\n+            if (str.contains(old)) { \/\/ 'old' found in str\n@@ -752,1 +1105,1 @@\n-                old_index = 0; \/\/ String start offset\n+                oldIndex = 0; \/\/ String start offset\n@@ -754,2 +1107,2 @@\n-                while ((index = str.indexOf(old, old_index)) != -1) {\n-                    buf.append(str.substring(old_index, index)); \/\/ append prefix\n+                while ((index = str.indexOf(old, oldIndex)) != -1) {\n+                    buf.append(str, oldIndex, index); \/\/ append prefix\n@@ -757,1 +1110,1 @@\n-                    old_index = index + old.length(); \/\/ Skip `old'.length chars\n+                    oldIndex = index + old.length(); \/\/ Skip 'old'.length chars\n@@ -759,1 +1112,1 @@\n-                buf.append(str.substring(old_index)); \/\/ append rest of string\n+                buf.append(str.substring(oldIndex)); \/\/ append rest of string\n@@ -768,1 +1121,0 @@\n-\n@@ -770,24 +1122,1 @@\n-     * WARNING:\n-     *\n-     * There is some nomenclature confusion through much of the BCEL code base with\n-     * respect to the terms Descriptor and Signature.  For the offical definitions see:\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3\">\n-     * Descriptors in The Java Virtual Machine Specification<\/a>\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.9.1\">\n-     * Signatures in The Java Virtual Machine Specification<\/a>\n-     *\n-     * In brief, a descriptor is a string representing the type of a field or method.\n-     * Signatures are similar, but more complex.  Signatures are used to encode declarations\n-     * written in the Java programming language that use types outside the type system of the\n-     * Java Virtual Machine.  They are used to describe the type of any class, interface,\n-     * constructor, method or field whose declaration uses type variables or parameterized types.\n-     *\n-     * To parse a descriptor, call typeSignatureToString.\n-     * To parse a signature, call signatureToString.\n-     *\n-     * Note that if the signature string is a single, non-generic item, the call to\n-     * signatureToString reduces to a call to typeSignatureToString.\n-     * Also note, that if you only wish to parse the first item in a longer signature\n-     * string, you should call typeSignatureToString directly.\n+     * Map opcode names to opcode numbers. E.g., return Constants.ALOAD for \"aload\"\n@@ -795,0 +1124,9 @@\n+    public static short searchOpcode(String name) {\n+        name = name.toLowerCase(Locale.ENGLISH);\n+        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; i++) {\n+            if (Const.getOpcodeName(i).equals(name)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n@@ -796,0 +1134,6 @@\n+    \/**\n+     * @return 'flag' with bit 'i' set to 1\n+     *\/\n+    public static int setBit(final int flag, final int i) {\n+        return flag | pow2(i);\n+    }\n@@ -798,2 +1142,1 @@\n-     * Converts a signature to a string with all class names compacted.\n-     * Class, Method and Type signatures are supported.\n+     * Converts a signature to a string with all class names compacted. Class, Method and Type signatures are supported.\n@@ -802,1 +1145,1 @@\n-     * @param  signature signature to convert\n+     * @param signature signature to convert\n@@ -805,1 +1148,1 @@\n-    public static String signatureToString( final String signature ) {\n+    public static String signatureToString(final String signature) {\n@@ -809,1 +1152,0 @@\n-\n@@ -811,3 +1153,2 @@\n-     * Converts a signature to a string.\n-     * Class, Method and Type signatures are supported.\n-     * Enum and Interface signatures are not supported.\n+     * Converts a signature to a string. Class, Method and Type signatures are supported. Enum and Interface signatures are\n+     * not supported.\n@@ -815,2 +1156,2 @@\n-     * @param  signature signature to convert\n-     * @param  chopit flag that determines whether chopping is executed or not\n+     * @param signature signature to convert\n+     * @param chopit flag that determines whether chopping is executed or not\n@@ -819,1 +1160,1 @@\n-    public static String signatureToString( final String signature, final boolean chopit ) {\n+    public static String signatureToString(final String signature, final boolean chopit) {\n@@ -826,1 +1167,1 @@\n-            index += unwrap(consumed_chars); \/\/ update position\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -832,1 +1173,1 @@\n-            index += unwrap(consumed_chars); \/\/ update position\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -835,1 +1176,1 @@\n-            index += unwrap(consumed_chars); \/\/ update position\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -841,2 +1182,2 @@\n-        index += unwrap(consumed_chars); \/\/ update position\n-        if ((typeParams.length() == 0) && (index == signature.length())) {\n+        index += unwrap(CONSUMER_CHARS); \/\/ update position\n+        if (typeParams.isEmpty() && index == signature.length()) {\n@@ -853,1 +1194,1 @@\n-            index += unwrap(consumed_chars); \/\/ update position\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -858,1 +1199,1 @@\n-            index += unwrap(consumed_chars); \/\/ update position\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -863,1 +1204,0 @@\n-\n@@ -865,1 +1205,1 @@\n-     * Converts a type parameter list signature to a string.\n+     * Convert bytes into hexadecimal string\n@@ -867,3 +1207,3 @@\n-     * @param  signature signature to convert\n-     * @param  chopit flag that determines whether chopping is executed or not\n-     * @return String containg human readable signature\n+     * @param bytes an array of bytes to convert to hexadecimal\n+     *\n+     * @return bytes as hexadecimal string, e.g. 00 fa 12 ...\n@@ -871,12 +1211,12 @@\n-    private static String typeParamTypesToString( final String signature, final boolean chopit ) {\n-        \/\/ The first character is guranteed to be '<'\n-        final StringBuilder typeParams = new StringBuilder(\"<\");\n-        int index = 1;  \/\/ skip the '<'\n-        \/\/ get the first TypeParameter\n-        typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n-        index += unwrap(consumed_chars); \/\/ update position\n-        \/\/ are there more TypeParameters?\n-        while (signature.charAt(index) != '>') {\n-            typeParams.append(\", \");\n-            typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n-            index += unwrap(consumed_chars); \/\/ update position\n+    public static String toHexString(final byte[] bytes) {\n+        final StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < bytes.length; i++) {\n+            final short b = byteToShort(bytes[i]);\n+            final String hex = Integer.toHexString(b);\n+            if (b < 0x10) {\n+                buf.append('0');\n+            }\n+            buf.append(hex);\n+            if (i < bytes.length - 1) {\n+                buf.append(' ');\n+            }\n@@ -884,2 +1224,1 @@\n-        wrap(consumed_chars, index + 1); \/\/ account for the '>' char\n-        return typeParams.append(\">\").toString();\n+        return buf.toString();\n@@ -888,1 +1227,0 @@\n-\n@@ -890,1 +1228,1 @@\n-     * Converts a type parameter signature to a string.\n+     * Return type of method signature as a byte value as defined in <em>Constants<\/em>\n@@ -892,3 +1230,5 @@\n-     * @param  signature signature to convert\n-     * @param  chopit flag that determines whether chopping is executed or not\n-     * @return String containg human readable signature\n+     * @param signature in format described above\n+     * @return type of method signature\n+     * @see Const\n+     *\n+     * @throws ClassFormatException if signature is not a method signature\n@@ -896,330 +1236,1 @@\n-    private static String typeParamTypeToString( final String signature, final boolean chopit ) {\n-        int index = signature.indexOf(':');\n-        if (index <= 0) {\n-            throw new ClassFormatException(\"Invalid type parameter signature: \" + signature);\n-        }\n-        \/\/ get the TypeParameter identifier\n-        final StringBuilder typeParam = new StringBuilder(signature.substring(0, index));\n-        index++;  \/\/ account for the ':'\n-        if (signature.charAt(index) != ':') {\n-            \/\/ we have a class bound\n-            typeParam.append(\" extends \");\n-            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(consumed_chars); \/\/ update position\n-        }\n-        \/\/ look for interface bounds\n-        while (signature.charAt(index) == ':') {\n-            index++;  \/\/ skip over the ':'\n-            typeParam.append(\" & \");\n-            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(consumed_chars); \/\/ update position\n-        }\n-        wrap(consumed_chars, index);\n-        return typeParam.toString();\n-    }\n-\n-\n-    \/**\n-     * Converts a list of type signatures to a string.\n-     *\n-     * @param  signature signature to convert\n-     * @param  chopit flag that determines whether chopping is executed or not\n-     * @param  term character indicating the end of the list\n-     * @return String containg human readable signature\n-     *\/\n-    private static String typeSignaturesToString( final String signature, final boolean chopit, final char term ) {\n-        \/\/ The first character will be an 'open' that matches the 'close' contained in term.\n-        final StringBuilder typeList = new StringBuilder(signature.substring(0, 1));\n-        int index = 1;  \/\/ skip the 'open' character\n-        \/\/ get the first Type in the list\n-        if (signature.charAt(index) != term) {\n-            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(consumed_chars); \/\/ update position\n-        }\n-        \/\/ are there more types in the list?\n-        while (signature.charAt(index) != term) {\n-            typeList.append(\", \");\n-            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n-            index += unwrap(consumed_chars); \/\/ update position\n-        }\n-        wrap(consumed_chars, index + 1); \/\/ account for the term char\n-        return typeList.append(term).toString();\n-    }\n-\n-\n-    \/**\n-     *\n-     * This method converts a type signature string into a Java type declaration such as\n-     * `String[]' and throws a `ClassFormatException' when the parsed type is invalid.\n-     *\n-     * @param  signature type signature\n-     * @param  chopit flag that determines whether chopping is executed or not\n-     * @return string containing human readable type signature\n-     * @throws ClassFormatException\n-     * @since 6.4.0\n-     *\/\n-    public static String typeSignatureToString( final String signature, final boolean chopit ) throws ClassFormatException {\n-        \/\/corrected concurrent private static field acess\n-        wrap(consumed_chars, 1); \/\/ This is the default, read just one char like `B'\n-        try {\n-            switch (signature.charAt(0)) {\n-                case 'B':\n-                    return \"byte\";\n-                case 'C':\n-                    return \"char\";\n-                case 'D':\n-                    return \"double\";\n-                case 'F':\n-                    return \"float\";\n-                case 'I':\n-                    return \"int\";\n-                case 'J':\n-                    return \"long\";\n-                case 'T': { \/\/ TypeVariableSignature\n-                    final int index = signature.indexOf(';'); \/\/ Look for closing `;'\n-                    if (index < 0) {\n-                        throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n-                    }\n-                    \/\/corrected concurrent private static field acess\n-                    wrap(consumed_chars, index + 1); \/\/ \"Tblabla;\" `T' and `;' are removed\n-                    return compactClassName(signature.substring(1, index), chopit);\n-                }\n-                case 'L': { \/\/ Full class name\n-                    \/\/ should this be a while loop? can there be more than\n-                    \/\/ one generic clause?  (markro)\n-                    int fromIndex = signature.indexOf('<'); \/\/ generic type?\n-                    if (fromIndex < 0) {\n-                        fromIndex = 0;\n-                    } else {\n-                        fromIndex = signature.indexOf('>', fromIndex);\n-                        if (fromIndex < 0) {\n-                            throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                        }\n-                    }\n-                    final int index = signature.indexOf(';', fromIndex); \/\/ Look for closing `;'\n-                    if (index < 0) {\n-                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                    }\n-\n-                    \/\/ check to see if there are any TypeArguments\n-                    final int bracketIndex = signature.substring(0, index).indexOf('<');\n-                    if (bracketIndex < 0) {\n-                        \/\/ just a class identifier\n-                        wrap(consumed_chars, index + 1); \/\/ \"Lblabla;\" `L' and `;' are removed\n-                        return compactClassName(signature.substring(1, index), chopit);\n-                    }\n-                    \/\/ but make sure we are not looking past the end of the current item\n-                    fromIndex = signature.indexOf(';');\n-                    if (fromIndex < 0) {\n-                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                    }\n-                    if (fromIndex < bracketIndex) {\n-                        \/\/ just a class identifier\n-                        wrap(consumed_chars, fromIndex + 1); \/\/ \"Lblabla;\" `L' and `;' are removed\n-                        return compactClassName(signature.substring(1, fromIndex), chopit);\n-                    }\n-\n-                    \/\/ we have TypeArguments; build up partial result\n-                    \/\/ as we recurse for each TypeArgument\n-                    final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n-                    int consumed_chars = bracketIndex + 1; \/\/ Shadows global var\n-\n-                    \/\/ check for wildcards\n-                    if (signature.charAt(consumed_chars) == '+') {\n-                        type.append(\"? extends \");\n-                        consumed_chars++;\n-                    } else if (signature.charAt(consumed_chars) == '-') {\n-                        type.append(\"? super \");\n-                        consumed_chars++;\n-                    }\n-\n-                    \/\/ get the first TypeArgument\n-                    if (signature.charAt(consumed_chars) == '*') {\n-                        type.append(\"?\");\n-                        consumed_chars++;\n-                    } else {\n-                        type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n-                        \/\/ update our consumed count by the number of characters the for type argument\n-                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n-                        wrap(Utility.consumed_chars, consumed_chars);\n-                    }\n-\n-                    \/\/ are there more TypeArguments?\n-                    while (signature.charAt(consumed_chars) != '>') {\n-                        type.append(\", \");\n-                        \/\/ check for wildcards\n-                        if (signature.charAt(consumed_chars) == '+') {\n-                            type.append(\"? extends \");\n-                            consumed_chars++;\n-                        } else if (signature.charAt(consumed_chars) == '-') {\n-                            type.append(\"? super \");\n-                            consumed_chars++;\n-                        }\n-                        if (signature.charAt(consumed_chars) == '*') {\n-                            type.append(\"?\");\n-                            consumed_chars++;\n-                        } else {\n-                            type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n-                            \/\/ update our consumed count by the number of characters the for type argument\n-                            consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n-                            wrap(Utility.consumed_chars, consumed_chars);\n-                        }\n-                    }\n-\n-                    \/\/ process the closing \">\"\n-                    consumed_chars++;\n-                    type.append(\">\");\n-\n-                    if (signature.charAt(consumed_chars) == '.') {\n-                        \/\/ we have a ClassTypeSignatureSuffix\n-                        type.append(\".\");\n-                        \/\/ convert SimpleClassTypeSignature to fake ClassTypeSignature\n-                        \/\/ and then recurse to parse it\n-                        type.append(typeSignatureToString(\"L\" + signature.substring(consumed_chars+1), chopit));\n-                        \/\/ update our consumed count by the number of characters the for type argument\n-                        \/\/ note that this count includes the \"L\" we added, but that is ok\n-                        \/\/ as it accounts for the \".\" we didn't consume\n-                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n-                        wrap(Utility.consumed_chars, consumed_chars);\n-                        return type.toString();\n-                    }\n-                    if (signature.charAt(consumed_chars) != ';') {\n-                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                    }\n-                    wrap(Utility.consumed_chars, consumed_chars + 1); \/\/ remove final \";\"\n-                    return type.toString();\n-                }\n-                case 'S':\n-                    return \"short\";\n-                case 'Z':\n-                    return \"boolean\";\n-                case '[': { \/\/ Array declaration\n-                    int n;\n-                    StringBuilder brackets;\n-                    String type;\n-                    int consumed_chars; \/\/ Shadows global var\n-                    brackets = new StringBuilder(); \/\/ Accumulate []'s\n-                    \/\/ Count opening brackets and look for optional size argument\n-                    for (n = 0; signature.charAt(n) == '['; n++) {\n-                        brackets.append(\"[]\");\n-                    }\n-                    consumed_chars = n; \/\/ Remember value\n-                    \/\/ The rest of the string denotes a `<field_type>'\n-                    type = typeSignatureToString(signature.substring(n), chopit);\n-                    \/\/corrected concurrent private static field acess\n-                    \/\/Utility.consumed_chars += consumed_chars; is replaced by:\n-                    final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;\n-                    wrap(Utility.consumed_chars, _temp);\n-                    return type + brackets.toString();\n-                }\n-                case 'V':\n-                    return \"void\";\n-                default:\n-                    throw new ClassFormatException(\"Invalid signature: `\" + signature + \"'\");\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid signature: \" + signature, e);\n-        }\n-    }\n-\n-\n-    \/** Parse Java type such as \"char\", or \"java.lang.String[]\" and return the\n-     * signature in byte code format, e.g. \"C\" or \"[Ljava\/lang\/String;\" respectively.\n-     *\n-     * @param  type Java type\n-     * @return byte code signature\n-     *\/\n-    public static String getSignature( String type ) {\n-        final StringBuilder buf = new StringBuilder();\n-        final char[] chars = type.toCharArray();\n-        boolean char_found = false;\n-        boolean delim = false;\n-        int index = -1;\n-        loop: for (int i = 0; i < chars.length; i++) {\n-            switch (chars[i]) {\n-                case ' ':\n-                case '\\t':\n-                case '\\n':\n-                case '\\r':\n-                case '\\f':\n-                    if (char_found) {\n-                        delim = true;\n-                    }\n-                    break;\n-                case '[':\n-                    if (!char_found) {\n-                        throw new IllegalArgumentException(\"Illegal type: \" + type);\n-                    }\n-                    index = i;\n-                    break loop;\n-                default:\n-                    char_found = true;\n-                    if (!delim) {\n-                        buf.append(chars[i]);\n-                    }\n-            }\n-        }\n-        int brackets = 0;\n-        if (index > 0) {\n-            brackets = countBrackets(type.substring(index));\n-        }\n-        type = buf.toString();\n-        buf.setLength(0);\n-        for (int i = 0; i < brackets; i++) {\n-            buf.append('[');\n-        }\n-        boolean found = false;\n-        for (int i = Const.T_BOOLEAN; (i <= Const.T_VOID) && !found; i++) {\n-            if (Const.getTypeName(i).equals(type)) {\n-                found = true;\n-                buf.append(Const.getShortTypeName(i));\n-            }\n-        }\n-        if (!found) {\n-            buf.append('L').append(type.replace('.', '\/')).append(';');\n-        }\n-        return buf.toString();\n-    }\n-\n-\n-    private static int countBrackets( final String brackets ) {\n-        final char[] chars = brackets.toCharArray();\n-        int count = 0;\n-        boolean open = false;\n-        for (final char c : chars) {\n-            switch (c) {\n-                case '[':\n-                    if (open) {\n-                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-                    }\n-                    open = true;\n-                    break;\n-                case ']':\n-                    if (!open) {\n-                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-                    }\n-                    open = false;\n-                    count++;\n-                    break;\n-                default:\n-                    \/\/ Don't care\n-                    break;\n-            }\n-        }\n-        if (open) {\n-            throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-        }\n-        return count;\n-    }\n-\n-\n-    \/**\n-     * Return type of method signature as a byte value as defined in <em>Constants<\/em>\n-     *\n-     * @param  signature in format described above\n-     * @return type of method signature\n-     * @see    Const\n-     *\n-     * @throws ClassFormatException if signature is not a method signature\n-     *\/\n-    public static byte typeOfMethodSignature( final String signature ) throws ClassFormatException {\n+    public static byte typeOfMethodSignature(final String signature) throws ClassFormatException {\n@@ -1238,1 +1249,0 @@\n-\n@@ -1242,1 +1252,1 @@\n-     * @param  signature in format described above\n+     * @param signature in format described above\n@@ -1244,1 +1254,1 @@\n-     * @see    Const\n+     * @see Const\n@@ -1248,1 +1258,1 @@\n-    public static byte typeOfSignature( final String signature ) throws ClassFormatException {\n+    public static byte typeOfSignature(final String signature) throws ClassFormatException {\n@@ -1251,29 +1261,29 @@\n-                case 'B':\n-                    return Const.T_BYTE;\n-                case 'C':\n-                    return Const.T_CHAR;\n-                case 'D':\n-                    return Const.T_DOUBLE;\n-                case 'F':\n-                    return Const.T_FLOAT;\n-                case 'I':\n-                    return Const.T_INT;\n-                case 'J':\n-                    return Const.T_LONG;\n-                case 'L':\n-                case 'T':\n-                    return Const.T_REFERENCE;\n-                case '[':\n-                    return Const.T_ARRAY;\n-                case 'V':\n-                    return Const.T_VOID;\n-                case 'Z':\n-                    return Const.T_BOOLEAN;\n-                case 'S':\n-                    return Const.T_SHORT;\n-                case '!':\n-                case '+':\n-                case '*':\n-                    return typeOfSignature(signature.substring(1));\n-                default:\n-                    throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            case 'B':\n+                return Const.T_BYTE;\n+            case 'C':\n+                return Const.T_CHAR;\n+            case 'D':\n+                return Const.T_DOUBLE;\n+            case 'F':\n+                return Const.T_FLOAT;\n+            case 'I':\n+                return Const.T_INT;\n+            case 'J':\n+                return Const.T_LONG;\n+            case 'L':\n+            case 'T':\n+                return Const.T_REFERENCE;\n+            case '[':\n+                return Const.T_ARRAY;\n+            case 'V':\n+                return Const.T_VOID;\n+            case 'Z':\n+                return Const.T_BOOLEAN;\n+            case 'S':\n+                return Const.T_SHORT;\n+            case '!':\n+            case '+':\n+            case '*':\n+                return typeOfSignature(signature.substring(1));\n+            default:\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n@@ -1286,14 +1296,0 @@\n-\n-    \/** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for \"aload\"\n-     *\/\n-    public static short searchOpcode( String name ) {\n-        name = name.toLowerCase(Locale.ENGLISH);\n-        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; i++) {\n-            if (Const.getOpcodeName(i).equals(name)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n-\n-\n@@ -1301,11 +1297,1 @@\n-     * Convert (signed) byte to (unsigned) short value, i.e., all negative\n-     * values become positive.\n-     *\/\n-    private static short byteToShort( final byte b ) {\n-        return (b < 0) ? (short) (256 + b) : (short) b;\n-    }\n-\n-\n-    \/** Convert bytes into hexadecimal string\n-     *\n-     * @param bytes an array of bytes to convert to hexadecimal\n+     * Converts a type parameter list signature to a string.\n@@ -1313,1 +1299,3 @@\n-     * @return bytes as hexadecimal string, e.g. 00 fa 12 ...\n+     * @param signature signature to convert\n+     * @param chopit flag that determines whether chopping is executed or not\n+     * @return String containg human readable signature\n@@ -1315,12 +1303,12 @@\n-    public static String toHexString( final byte[] bytes ) {\n-        final StringBuilder buf = new StringBuilder();\n-        for (int i = 0; i < bytes.length; i++) {\n-            final short b = byteToShort(bytes[i]);\n-            final String hex = Integer.toHexString(b);\n-            if (b < 0x10) {\n-                buf.append('0');\n-            }\n-            buf.append(hex);\n-            if (i < bytes.length - 1) {\n-                buf.append(' ');\n-            }\n+    private static String typeParamTypesToString(final String signature, final boolean chopit) {\n+        \/\/ The first character is guranteed to be '<'\n+        final StringBuilder typeParams = new StringBuilder(\"<\");\n+        int index = 1; \/\/ skip the '<'\n+        \/\/ get the first TypeParameter\n+        typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n+        index += unwrap(CONSUMER_CHARS); \/\/ update position\n+        \/\/ are there more TypeParameters?\n+        while (signature.charAt(index) != '>') {\n+            typeParams.append(\", \");\n+            typeParams.append(typeParamTypeToString(signature.substring(index), chopit));\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -1328,16 +1316,2 @@\n-        return buf.toString();\n-    }\n-\n-\n-    \/**\n-     * Return a string for an integer justified left or right and filled up with\n-     * `fill' characters if necessary.\n-     *\n-     * @param i integer to format\n-     * @param length length of desired string\n-     * @param left_justify format left or right\n-     * @param fill fill character\n-     * @return formatted int\n-     *\/\n-    public static String format( final int i, final int length, final boolean left_justify, final char fill ) {\n-        return fillup(Integer.toString(i), length, left_justify, fill);\n+        wrap(CONSUMER_CHARS, index + 1); \/\/ account for the '>' char\n+        return typeParams.append(\">\").toString();\n@@ -1346,1 +1320,0 @@\n-\n@@ -1348,1 +1321,1 @@\n-     * Fillup char with up to length characters with char `fill' and justify it left or right.\n+     * Converts a type parameter signature to a string.\n@@ -1350,5 +1323,3 @@\n-     * @param str string to format\n-     * @param length length of desired string\n-     * @param left_justify format left or right\n-     * @param fill fill character\n-     * @return formatted string\n+     * @param signature signature to convert\n+     * @param chopit flag that determines whether chopping is executed or not\n+     * @return String containg human readable signature\n@@ -1356,54 +1327,4 @@\n-    public static String fillup( final String str, final int length, final boolean left_justify, final char fill ) {\n-        final int len = length - str.length();\n-        final char[] buf = new char[(len < 0) ? 0 : len];\n-        for (int j = 0; j < buf.length; j++) {\n-            buf[j] = fill;\n-        }\n-        if (left_justify) {\n-            return str + new String(buf);\n-        }\n-        return new String(buf) + str;\n-    }\n-\n-\n-    static boolean equals( final byte[] a, final byte[] b ) {\n-        int size;\n-        if ((size = a.length) != b.length) {\n-            return false;\n-        }\n-        for (int i = 0; i < size; i++) {\n-            if (a[i] != b[i]) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-\n-\n-    public static void printArray( final PrintStream out, final Object[] obj ) {\n-        out.println(printArray(obj, true));\n-    }\n-\n-\n-    public static void printArray( final PrintWriter out, final Object[] obj ) {\n-        out.println(printArray(obj, true));\n-    }\n-\n-\n-    public static String printArray( final Object[] obj ) {\n-        return printArray(obj, true);\n-    }\n-\n-\n-    public static String printArray( final Object[] obj, final boolean braces ) {\n-        return printArray(obj, braces, false);\n-    }\n-\n-\n-    public static String printArray( final Object[] obj, final boolean braces, final boolean quote ) {\n-        if (obj == null) {\n-            return null;\n-        }\n-        final StringBuilder buf = new StringBuilder();\n-        if (braces) {\n-            buf.append('{');\n+    private static String typeParamTypeToString(final String signature, final boolean chopit) {\n+        int index = signature.indexOf(':');\n+        if (index <= 0) {\n+            throw new ClassFormatException(\"Invalid type parameter signature: \" + signature);\n@@ -1411,9 +1332,8 @@\n-        for (int i = 0; i < obj.length; i++) {\n-            if (obj[i] != null) {\n-                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n-            } else {\n-                buf.append(\"null\");\n-            }\n-            if (i < obj.length - 1) {\n-                buf.append(\", \");\n-            }\n+        \/\/ get the TypeParameter identifier\n+        final StringBuilder typeParam = new StringBuilder(signature.substring(0, index));\n+        index++; \/\/ account for the ':'\n+        if (signature.charAt(index) != ':') {\n+            \/\/ we have a class bound\n+            typeParam.append(\" extends \");\n+            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -1421,2 +1341,6 @@\n-        if (braces) {\n-            buf.append('}');\n+        \/\/ look for interface bounds\n+        while (signature.charAt(index) == ':') {\n+            index++; \/\/ skip over the ':'\n+            typeParam.append(\" & \");\n+            typeParam.append(typeSignatureToString(signature.substring(index), chopit));\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -1424,12 +1348,2 @@\n-        return buf.toString();\n-    }\n-\n-\n-    \/**\n-     * @param ch the character to test if it's part of an identifier\n-     *\n-     * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)\n-     *\/\n-    public static boolean isJavaIdentifierPart( final char ch ) {\n-        return ((ch >= 'a') && (ch <= 'z')) || ((ch >= 'A') && (ch <= 'Z'))\n-                || ((ch >= '0') && (ch <= '9')) || (ch == '_');\n+        wrap(CONSUMER_CHARS, index);\n+        return typeParam.toString();\n@@ -1438,1 +1352,0 @@\n-\n@@ -1440,16 +1353,1 @@\n-     * Encode byte array it into Java identifier string, i.e., a string\n-     * that only contains the following characters: (a, ... z, A, ... Z,\n-     * 0, ... 9, _, $).  The encoding algorithm itself is not too\n-     * clever: if the current byte's ASCII value already is a valid Java\n-     * identifier part, leave it as it is. Otherwise it writes the\n-     * escape character($) followed by:\n-     *\n-     * <ul>\n-     *   <li> the ASCII value as a hexadecimal string, if the value is not in the range 200..247<\/li>\n-     *   <li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247<\/li>\n-     * <\/ul>\n-     *\n-     * <p>This operation inflates the original byte array by roughly 40-50%<\/p>\n-     *\n-     * @param bytes the byte array to convert\n-     * @param compress use gzip to minimize string\n+     * Converts a list of type signatures to a string.\n@@ -1457,1 +1355,4 @@\n-     * @throws IOException if there's a gzip exception\n+     * @param signature signature to convert\n+     * @param chopit flag that determines whether chopping is executed or not\n+     * @param term character indicating the end of the list\n+     * @return String containg human readable signature\n@@ -1459,7 +1360,8 @@\n-    public static String encode(byte[] bytes, final boolean compress) throws IOException {\n-        if (compress) {\n-            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-                    GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n-                gos.write(bytes, 0, bytes.length);\n-                bytes = baos.toByteArray();\n-            }\n+    private static String typeSignaturesToString(final String signature, final boolean chopit, final char term) {\n+        \/\/ The first character will be an 'open' that matches the 'close' contained in term.\n+        final StringBuilder typeList = new StringBuilder(signature.substring(0, 1));\n+        int index = 1; \/\/ skip the 'open' character\n+        \/\/ get the first Type in the list\n+        if (signature.charAt(index) != term) {\n+            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -1467,6 +1369,5 @@\n-        final CharArrayWriter caw = new CharArrayWriter();\n-        try (JavaWriter jw = new JavaWriter(caw)) {\n-            for (final byte b : bytes) {\n-                final int in = b & 0x000000ff; \/\/ Normalize to unsigned\n-                jw.write(in);\n-            }\n+        \/\/ are there more types in the list?\n+        while (signature.charAt(index) != term) {\n+            typeList.append(\", \");\n+            typeList.append(typeSignatureToString(signature.substring(index), chopit));\n+            index += unwrap(CONSUMER_CHARS); \/\/ update position\n@@ -1474,1 +1375,2 @@\n-        return caw.toString();\n+        wrap(CONSUMER_CHARS, index + 1); \/\/ account for the term char\n+        return typeList.append(term).toString();\n@@ -1477,1 +1379,0 @@\n-\n@@ -1479,1 +1380,0 @@\n-     * Decode a string back to a byte array.\n@@ -1481,2 +1381,2 @@\n-     * @param s the string to convert\n-     * @param uncompress use gzip to uncompress the stream of bytes\n+     * This method converts a type signature string into a Java type declaration such as 'String[]' and throws a\n+     * 'ClassFormatException' when the parsed type is invalid.\n@@ -1484,53 +1384,5 @@\n-     * @throws IOException if there's a gzip exception\n-     *\/\n-    public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n-        byte[] bytes;\n-        try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray()));\n-                ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n-            int ch;\n-            while ((ch = jr.read()) >= 0) {\n-                bos.write(ch);\n-            }\n-            bytes = bos.toByteArray();\n-        }\n-        if (uncompress) {\n-            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n-            final byte[] tmp = new byte[bytes.length * 3]; \/\/ Rough estimate\n-            int count = 0;\n-            int b;\n-            while ((b = gis.read()) >= 0) {\n-                tmp[count++] = (byte) b;\n-            }\n-            bytes = new byte[count];\n-            System.arraycopy(tmp, 0, bytes, 0, count);\n-        }\n-        return bytes;\n-    }\n-\n-    \/\/ A-Z, g-z, _, $\n-    private static final int FREE_CHARS = 48;\n-    private static int[] CHAR_MAP = new int[FREE_CHARS];\n-    private static int[] MAP_CHAR = new int[256]; \/\/ Reverse map\n-    private static final char ESCAPE_CHAR = '$';\n-    static {\n-        int j = 0;\n-        for (int i = 'A'; i <= 'Z'; i++) {\n-            CHAR_MAP[j] = i;\n-            MAP_CHAR[i] = j;\n-            j++;\n-        }\n-        for (int i = 'g'; i <= 'z'; i++) {\n-            CHAR_MAP[j] = i;\n-            MAP_CHAR[i] = j;\n-            j++;\n-        }\n-        CHAR_MAP[j] = '$';\n-        MAP_CHAR['$'] = j;\n-        j++;\n-        CHAR_MAP[j] = '_';\n-        MAP_CHAR['_'] = j;\n-    }\n-\n-    \/**\n-     * Decode characters into bytes.\n-     * Used by <a href=\"Utility.html#decode(java.lang.String, boolean)\">decode()<\/a>\n+     * @param signature type signature\n+     * @param chopit flag that determines whether chopping is executed or not\n+     * @return string containing human readable type signature\n+     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @since 6.4.0\n@@ -1538,21 +1390,21 @@\n-    private static class JavaReader extends FilterReader {\n-\n-        public JavaReader(final Reader in) {\n-            super(in);\n-        }\n-\n-\n-        @Override\n-        public int read() throws IOException {\n-            final int b = in.read();\n-            if (b != ESCAPE_CHAR) {\n-                return b;\n-            }\n-            final int i = in.read();\n-            if (i < 0) {\n-                return -1;\n-            }\n-            if (((i >= '0') && (i <= '9')) || ((i >= 'a') && (i <= 'f'))) { \/\/ Normal escape\n-                final int j = in.read();\n-                if (j < 0) {\n-                    return -1;\n+    public static String typeSignatureToString(final String signature, final boolean chopit) throws ClassFormatException {\n+        \/\/ corrected concurrent private static field acess\n+        wrap(CONSUMER_CHARS, 1); \/\/ This is the default, read just one char like 'B'\n+        try {\n+            switch (signature.charAt(0)) {\n+            case 'B':\n+                return \"byte\";\n+            case 'C':\n+                return \"char\";\n+            case 'D':\n+                return \"double\";\n+            case 'F':\n+                return \"float\";\n+            case 'I':\n+                return \"int\";\n+            case 'J':\n+                return \"long\";\n+            case 'T': { \/\/ TypeVariableSignature\n+                final int index = signature.indexOf(';'); \/\/ Look for closing ';'\n+                if (index < 0) {\n+                    throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n@@ -1560,5 +1412,3 @@\n-                final char[] tmp = {\n-                        (char) i, (char) j\n-                };\n-                final int s = Integer.parseInt(new String(tmp), 16);\n-                return s;\n+                \/\/ corrected concurrent private static field acess\n+                wrap(CONSUMER_CHARS, index + 1); \/\/ \"Tblabla;\" 'T' and ';' are removed\n+                return compactClassName(signature.substring(1, index), chopit);\n@@ -1566,12 +1416,16 @@\n-            return MAP_CHAR[i];\n-        }\n-\n-\n-        @Override\n-        public int read( final char[] cbuf, final int off, final int len ) throws IOException {\n-            for (int i = 0; i < len; i++) {\n-                cbuf[off + i] = (char) read();\n-            }\n-            return len;\n-        }\n-    }\n+            case 'L': { \/\/ Full class name\n+                \/\/ should this be a while loop? can there be more than\n+                \/\/ one generic clause? (markro)\n+                int fromIndex = signature.indexOf('<'); \/\/ generic type?\n+                if (fromIndex < 0) {\n+                    fromIndex = 0;\n+                } else {\n+                    fromIndex = signature.indexOf('>', fromIndex);\n+                    if (fromIndex < 0) {\n+                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                    }\n+                }\n+                final int index = signature.indexOf(';', fromIndex); \/\/ Look for closing ';'\n+                if (index < 0) {\n+                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                }\n@@ -1579,5 +1433,17 @@\n-    \/**\n-     * Encode bytes into valid java identifier characters.\n-     * Used by <a href=\"Utility.html#encode(byte[], boolean)\">encode()<\/a>\n-     *\/\n-    private static class JavaWriter extends FilterWriter {\n+                \/\/ check to see if there are any TypeArguments\n+                final int bracketIndex = signature.substring(0, index).indexOf('<');\n+                if (bracketIndex < 0) {\n+                    \/\/ just a class identifier\n+                    wrap(CONSUMER_CHARS, index + 1); \/\/ \"Lblabla;\" 'L' and ';' are removed\n+                    return compactClassName(signature.substring(1, index), chopit);\n+                }\n+                \/\/ but make sure we are not looking past the end of the current item\n+                fromIndex = signature.indexOf(';');\n+                if (fromIndex < 0) {\n+                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                }\n+                if (fromIndex < bracketIndex) {\n+                    \/\/ just a class identifier\n+                    wrap(CONSUMER_CHARS, fromIndex + 1); \/\/ \"Lblabla;\" 'L' and ';' are removed\n+                    return compactClassName(signature.substring(1, fromIndex), chopit);\n+                }\n@@ -1585,3 +1451,13 @@\n-        public JavaWriter(final Writer out) {\n-            super(out);\n-        }\n+                \/\/ we have TypeArguments; build up partial result\n+                \/\/ as we recurse for each TypeArgument\n+                final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n+                int consumedChars = bracketIndex + 1; \/\/ Shadows global var\n+\n+                \/\/ check for wildcards\n+                if (signature.charAt(consumedChars) == '+') {\n+                    type.append(\"? extends \");\n+                    consumedChars++;\n+                } else if (signature.charAt(consumedChars) == '-') {\n+                    type.append(\"? super \");\n+                    consumedChars++;\n+                }\n@@ -1589,0 +1465,10 @@\n+                \/\/ get the first TypeArgument\n+                if (signature.charAt(consumedChars) == '*') {\n+                    type.append(\"?\");\n+                    consumedChars++;\n+                } else {\n+                    type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n+                    \/\/ update our consumed count by the number of characters the for type argument\n+                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n+                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                }\n@@ -1590,14 +1476,14 @@\n-        @Override\n-        public void write( final int b ) throws IOException {\n-            if (isJavaIdentifierPart((char) b) && (b != ESCAPE_CHAR)) {\n-                out.write(b);\n-            } else {\n-                out.write(ESCAPE_CHAR); \/\/ Escape character\n-                \/\/ Special escape\n-                if (b >= 0 && b < FREE_CHARS) {\n-                    out.write(CHAR_MAP[b]);\n-                } else { \/\/ Normal escape\n-                    final char[] tmp = Integer.toHexString(b).toCharArray();\n-                    if (tmp.length == 1) {\n-                        out.write('0');\n-                        out.write(tmp[0]);\n+                \/\/ are there more TypeArguments?\n+                while (signature.charAt(consumedChars) != '>') {\n+                    type.append(\", \");\n+                    \/\/ check for wildcards\n+                    if (signature.charAt(consumedChars) == '+') {\n+                        type.append(\"? extends \");\n+                        consumedChars++;\n+                    } else if (signature.charAt(consumedChars) == '-') {\n+                        type.append(\"? super \");\n+                        consumedChars++;\n+                    }\n+                    if (signature.charAt(consumedChars) == '*') {\n+                        type.append(\"?\");\n+                        consumedChars++;\n@@ -1605,2 +1491,4 @@\n-                        out.write(tmp[0]);\n-                        out.write(tmp[1]);\n+                        type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n+                        \/\/ update our consumed count by the number of characters the for type argument\n+                        consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n+                        wrap(Utility.CONSUMER_CHARS, consumedChars);\n@@ -1609,3 +1497,0 @@\n-            }\n-        }\n-\n@@ -1613,4 +1498,22 @@\n-        @Override\n-        public void write( final char[] cbuf, final int off, final int len ) throws IOException {\n-            for (int i = 0; i < len; i++) {\n-                write(cbuf[off + i]);\n+                \/\/ process the closing \">\"\n+                consumedChars++;\n+                type.append(\">\");\n+\n+                if (signature.charAt(consumedChars) == '.') {\n+                    \/\/ we have a ClassTypeSignatureSuffix\n+                    type.append(\".\");\n+                    \/\/ convert SimpleClassTypeSignature to fake ClassTypeSignature\n+                    \/\/ and then recurse to parse it\n+                    type.append(typeSignatureToString(\"L\" + signature.substring(consumedChars + 1), chopit));\n+                    \/\/ update our consumed count by the number of characters the for type argument\n+                    \/\/ note that this count includes the \"L\" we added, but that is ok\n+                    \/\/ as it accounts for the \".\" we didn't consume\n+                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n+                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                    return type.toString();\n+                }\n+                if (signature.charAt(consumedChars) != ';') {\n+                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                }\n+                wrap(Utility.CONSUMER_CHARS, consumedChars + 1); \/\/ remove final \";\"\n+                return type.toString();\n@@ -1618,6 +1521,30 @@\n-        }\n-\n-\n-        @Override\n-        public void write( final String str, final int off, final int len ) throws IOException {\n-            write(str.toCharArray(), off, len);\n+            case 'S':\n+                return \"short\";\n+            case 'Z':\n+                return \"boolean\";\n+            case '[': { \/\/ Array declaration\n+                int n;\n+                StringBuilder brackets;\n+                String type;\n+                int consumedChars; \/\/ Shadows global var\n+                brackets = new StringBuilder(); \/\/ Accumulate []'s\n+                \/\/ Count opening brackets and look for optional size argument\n+                for (n = 0; signature.charAt(n) == '['; n++) {\n+                    brackets.append(\"[]\");\n+                }\n+                consumedChars = n; \/\/ Remember value\n+                \/\/ The rest of the string denotes a '<field_type>'\n+                type = typeSignatureToString(signature.substring(n), chopit);\n+                \/\/ corrected concurrent private static field acess\n+                \/\/ Utility.consumed_chars += consumed_chars; is replaced by:\n+                final int temp = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n+                wrap(Utility.CONSUMER_CHARS, temp);\n+                return type + brackets.toString();\n+            }\n+            case 'V':\n+                return \"void\";\n+            default:\n+                throw new ClassFormatException(\"Invalid signature: '\" + signature + \"'\");\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid signature: \" + signature, e);\n@@ -1627,0 +1554,3 @@\n+    private static int unwrap(final ThreadLocal<Integer> tl) {\n+        return tl.get();\n+    }\n@@ -1628,29 +1558,2 @@\n-    \/**\n-     * Escape all occurences of newline chars '\\n', quotes \\\", etc.\n-     *\/\n-    public static String convertString( final String label ) {\n-        final char[] ch = label.toCharArray();\n-        final StringBuilder buf = new StringBuilder();\n-        for (final char element : ch) {\n-            switch (element) {\n-                case '\\n':\n-                    buf.append(\"\\\\n\");\n-                    break;\n-                case '\\r':\n-                    buf.append(\"\\\\r\");\n-                    break;\n-                case '\\\"':\n-                    buf.append(\"\\\\\\\"\");\n-                    break;\n-                case '\\'':\n-                    buf.append(\"\\\\'\");\n-                    break;\n-                case '\\\\':\n-                    buf.append(\"\\\\\\\\\");\n-                    break;\n-                default:\n-                    buf.append(element);\n-                    break;\n-            }\n-        }\n-        return buf.toString();\n+    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n+        tl.set(value);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Utility.java","additions":1120,"deletions":1217,"binary":false,"changes":2337,"status":"modified"},{"patch":"@@ -25,4 +25,2 @@\n- * Interface to make use of the Visitor pattern programming style. I.e. a class\n- * that implements this interface can traverse the contents of a Java class just\n- * by calling the `accept' method which all classes have.\n- *\n+ * Interface to make use of the Visitor pattern programming style. I.e. a class that implements this interface can\n+ * traverse the contents of a Java class just by calling the 'accept' method which all classes have.\n@@ -30,2 +28,21 @@\n-public interface Visitor\n-{\n+public interface Visitor {\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotation(Annotations obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotationDefault(AnnotationDefault obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotationEntry(AnnotationEntry obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitBootstrapMethods(BootstrapMethods obj);\n+\n@@ -40,0 +57,7 @@\n+    \/**\n+     * @since 6.3\n+     *\/\n+    default void visitConstantDynamic(final ConstantDynamic constantDynamic) {\n+        \/\/ empty\n+    }\n+\n@@ -52,0 +76,5 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitConstantMethodHandle(ConstantMethodHandle obj);\n+\n@@ -54,0 +83,10 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitConstantMethodType(ConstantMethodType obj);\n+\n+    \/**\n+     * @since 6.1\n+     *\/\n+    void visitConstantModule(ConstantModule constantModule);\n+\n@@ -56,0 +95,5 @@\n+    \/**\n+     * @since 6.1\n+     *\/\n+    void visitConstantPackage(ConstantPackage constantPackage);\n+\n@@ -66,0 +110,5 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitEnclosingMethod(EnclosingMethod obj);\n+\n@@ -84,34 +133,0 @@\n-    void visitMethod(Method obj);\n-\n-    void visitSignature(Signature obj);\n-\n-    void visitSourceFile(SourceFile obj);\n-\n-    void visitSynthetic(Synthetic obj);\n-\n-    void visitUnknown(Unknown obj);\n-\n-    void visitStackMap(StackMap obj);\n-\n-    void visitStackMapEntry(StackMapEntry obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotation(Annotations obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitParameterAnnotation(ParameterAnnotations obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotationEntry(AnnotationEntry obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotationDefault(AnnotationDefault obj);\n-\n@@ -123,14 +138,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitEnclosingMethod(EnclosingMethod obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitBootstrapMethods(BootstrapMethods obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitMethodParameters(MethodParameters obj);\n+    void visitMethod(Method obj);\n@@ -148,28 +150,1 @@\n-    void visitConstantMethodType(ConstantMethodType obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitConstantMethodHandle(ConstantMethodHandle obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitParameterAnnotationEntry(ParameterAnnotationEntry obj);\n-\n-    \/**\n-     * @since 6.1\n-     *\/\n-    void visitConstantPackage(ConstantPackage constantPackage);\n-\n-    \/**\n-     * @since 6.1\n-     *\/\n-    void visitConstantModule(ConstantModule constantModule);\n-\n-    \/**\n-     * @since 6.3\n-     *\/\n-    default void visitConstantDynamic(final ConstantDynamic constantDynamic) {\n-        \/\/ empty\n-    }\n+    void visitMethodParameters(MethodParameters obj);\n@@ -187,1 +162,1 @@\n-    default void visitModuleRequires(final ModuleRequires constantModule) {\n+    default void visitModuleExports(final ModuleExports constantModule) {\n@@ -194,1 +169,1 @@\n-    default void visitModuleExports(final ModuleExports constantModule) {\n+    default void visitModuleMainClass(final ModuleMainClass obj) {\n@@ -208,1 +183,1 @@\n-    default void visitModuleProvides(final ModuleProvides constantModule) {\n+    default void visitModulePackages(final ModulePackages constantModule) {\n@@ -215,1 +190,1 @@\n-    default void visitModulePackages(final ModulePackages constantModule) {\n+    default void visitModuleProvides(final ModuleProvides constantModule) {\n@@ -222,1 +197,1 @@\n-    default void visitModuleMainClass(final ModuleMainClass obj) {\n+    default void visitModuleRequires(final ModuleRequires constantModule) {\n@@ -239,0 +214,22 @@\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitParameterAnnotation(ParameterAnnotations obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitParameterAnnotationEntry(ParameterAnnotationEntry obj);\n+\n+    void visitSignature(Signature obj);\n+\n+    void visitSourceFile(SourceFile obj);\n+\n+    void visitStackMap(StackMap obj);\n+\n+    void visitStackMapEntry(StackMapEntry obj);\n+\n+    void visitSynthetic(Synthetic obj);\n+\n+    void visitUnknown(Unknown obj);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Visitor.java","additions":84,"deletions":87,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; value<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; value\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Load reference from array\n+    \/**\n+     * Load reference from array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * AASTORE -  Store into reference array\n- * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n+ * AASTORE - Store into reference array\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value -&gt; ...\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Store into reference array\n+    \/**\n+     * Store into reference array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ... -&gt; ..., null<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ... -&gt; ..., null\n+ * <\/PRE>\n@@ -38,9 +40,0 @@\n-\n-    \/** @return Type.NULL\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.NULL;\n-    }\n-\n-\n@@ -48,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -62,0 +53,8 @@\n+\n+    \/**\n+     * @return Type.NULL\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.NULL;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ACONST_NULL.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -23,2 +23,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-\n@@ -27,1 +25,0 @@\n- * <PRE>Stack: ... -&gt; ..., objectref<\/PRE>\n@@ -29,0 +26,3 @@\n+ * <PRE>\n+ * Stack: ... -&gt; ..., objectref\n+ * <\/PRE>\n@@ -34,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -38,1 +37,1 @@\n-        super(Const.ALOAD, Const.ALOAD_0);\n+        super(com.sun.org.apache.bcel.internal.Const.ALOAD, com.sun.org.apache.bcel.internal.Const.ALOAD_0);\n@@ -41,2 +40,3 @@\n-\n-    \/** Load reference from local variable\n+    \/**\n+     * Load reference from local variable\n+     *\n@@ -46,1 +46,1 @@\n-        super(Const.ALOAD, Const.ALOAD_0, n);\n+        super(com.sun.org.apache.bcel.internal.Const.ALOAD, com.sun.org.apache.bcel.internal.Const.ALOAD_0, n);\n@@ -49,1 +49,0 @@\n-\n@@ -51,4 +50,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +56,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ALOAD.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,2 +27,1 @@\n- * ANEWARRAY -  Create new array of references\n- * <PRE>Stack: ..., count -&gt; ..., arrayref<\/PRE>\n+ * ANEWARRAY - Create new array of references\n@@ -30,0 +29,3 @@\n+ * <PRE>\n+ * Stack: ..., count -&gt; ..., arrayref\n+ * <\/PRE>\n@@ -31,2 +33,1 @@\n-public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction,\n-        ExceptionThrower, StackConsumer, StackProducer {\n+public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower, StackConsumer, StackProducer {\n@@ -35,2 +36,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -41,1 +41,0 @@\n-\n@@ -46,8 +45,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n-            ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION);\n-    }\n-\n-\n@@ -55,4 +46,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +52,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -73,0 +62,4 @@\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION);\n+    }\n@@ -75,1 +68,1 @@\n-    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n@@ -80,1 +73,1 @@\n-        return (t instanceof ObjectType) ? (ObjectType) t : null;\n+        return t instanceof ObjectType ? (ObjectType) t : null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ANEWARRAY.java","additions":15,"deletions":22,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * ARETURN -  Return reference from method\n- * <PRE>Stack: ..., objectref -&gt; &lt;empty&gt;<\/PRE>\n+ * ARETURN - Return reference from method\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; &lt;empty&gt;\n+ * <\/PRE>\n@@ -38,1 +40,0 @@\n-\n@@ -40,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ARETURN.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,1 @@\n- * ARRAYLENGTH -  Get length of array\n- * <PRE>Stack: ..., arrayref -&gt; ..., length<\/PRE>\n+ * ARRAYLENGTH - Get length of array\n@@ -29,1 +28,4 @@\n- * @LastModified: Jun 2019\n+ * <PRE>\n+ * Stack: ..., arrayref -&gt; ..., length\n+ * <\/PRE>\n+ * @LastModified: Feb 2023\n@@ -31,2 +33,1 @@\n-public class ARRAYLENGTH extends Instruction\n-    implements ExceptionThrower, StackProducer, StackConsumer \/* since 6.0 *\/ {\n+public class ARRAYLENGTH extends Instruction implements ExceptionThrower, StackProducer, StackConsumer \/* since 6.0 *\/ {\n@@ -34,1 +35,2 @@\n-    \/** Get length of array\n+    \/**\n+     * Get length of array\n@@ -40,11 +42,0 @@\n-\n-    \/** @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.NULL_POINTER_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -52,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -65,0 +54,8 @@\n+\n+    \/**\n+     * @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ARRAYLENGTH.java","additions":20,"deletions":23,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -22,2 +22,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-\n@@ -26,1 +24,0 @@\n- * <PRE>Stack ..., objectref -&gt; ... <\/PRE>\n@@ -28,0 +25,3 @@\n+ * <PRE>\n+ * Stack ..., objectref -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +33,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -37,1 +36,1 @@\n-        super(Const.ASTORE, Const.ASTORE_0);\n+        super(com.sun.org.apache.bcel.internal.Const.ASTORE, com.sun.org.apache.bcel.internal.Const.ASTORE_0);\n@@ -40,2 +39,3 @@\n-\n-    \/** Store reference into local variable\n+    \/**\n+     * Store reference into local variable\n+     *\n@@ -45,1 +45,1 @@\n-        super(Const.ASTORE, Const.ASTORE_0, n);\n+        super(com.sun.org.apache.bcel.internal.Const.ASTORE, com.sun.org.apache.bcel.internal.Const.ASTORE_0, n);\n@@ -48,1 +48,0 @@\n-\n@@ -50,4 +49,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -58,1 +55,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ASTORE.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,2 +26,1 @@\n- * ATHROW -  Throw exception\n- * <PRE>Stack: ..., objectref -&gt; objectref<\/PRE>\n+ * ATHROW - Throw exception\n@@ -29,1 +28,3 @@\n- * @LastModified: Jan 2020\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; objectref\n+ * <\/PRE>\n@@ -34,1 +35,1 @@\n-     *  Throw exception\n+     * Throw exception\n@@ -40,11 +41,0 @@\n-\n-    \/** @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.THROWABLE\n-        };\n-    }\n-\n-\n@@ -52,4 +42,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +48,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -65,0 +53,8 @@\n+\n+    \/**\n+     * @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.THROWABLE};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ATHROW.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AllocationInstruction.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,2 +33,1 @@\n-public class AnnotationElementValueGen extends ElementValueGen\n-{\n+public class AnnotationElementValueGen extends ElementValueGen {\n@@ -38,2 +37,6 @@\n-    public AnnotationElementValueGen(final AnnotationEntryGen a, final ConstantPoolGen cpool)\n-    {\n+    public AnnotationElementValueGen(final AnnotationElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+        super(ANNOTATION, cpool);\n+        a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);\n+    }\n+\n+    public AnnotationElementValueGen(final AnnotationEntryGen a, final ConstantPoolGen cpool) {\n@@ -44,3 +47,1 @@\n-    public AnnotationElementValueGen(final int type, final AnnotationEntryGen annotation,\n-            final ConstantPoolGen cpool)\n-    {\n+    public AnnotationElementValueGen(final int type, final AnnotationEntryGen annotation, final ConstantPoolGen cpool) {\n@@ -49,2 +50,1 @@\n-            throw new IllegalArgumentException(\n-                    \"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n@@ -55,7 +55,0 @@\n-    public AnnotationElementValueGen(final AnnotationElementValue value,\n-            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n-    {\n-        super(ANNOTATION, cpool);\n-        a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);\n-    }\n-\n@@ -63,2 +56,1 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n+    public void dump(final DataOutputStream dos) throws IOException {\n@@ -69,4 +61,2 @@\n-    @Override\n-    public String stringifyValue()\n-    {\n-        throw new UnsupportedOperationException(\"Not implemented yet\");\n+    public AnnotationEntryGen getAnnotation() {\n+        return a;\n@@ -79,5 +69,2 @@\n-    public ElementValue getElementValue()\n-    {\n-        return new AnnotationElementValue(super.getElementValueType(),\n-                a.getAnnotation(),\n-                getConstantPool().getConstantPool());\n+    public ElementValue getElementValue() {\n+        return new AnnotationElementValue(super.getElementValueType(), a.getAnnotation(), getConstantPool().getConstantPool());\n@@ -86,3 +73,3 @@\n-    public AnnotationEntryGen getAnnotation()\n-    {\n-        return a;\n+    @Override\n+    public String stringifyValue() {\n+        throw new UnsupportedOperationException(\"Not implemented yet\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AnnotationElementValueGen.java","additions":17,"deletions":30,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -46,90 +46,0 @@\n-    private int typeIndex;\n-\n-    private List<ElementValuePairGen> evs;\n-\n-    private final ConstantPoolGen cpool;\n-\n-    private boolean isRuntimeVisible = false;\n-\n-    \/**\n-     * Here we are taking a fixed annotation of type Annotation and building a\n-     * modifiable AnnotationGen object. If the pool passed in is for a different\n-     * class file, then copyPoolEntries should have been passed as true as that\n-     * will force us to do a deep copy of the annotation and move the cpool\n-     * entries across. We need to copy the type and the element name value pairs\n-     * and the visibility.\n-     *\/\n-    public AnnotationEntryGen(final AnnotationEntry a, final ConstantPoolGen cpool,\n-                              final boolean copyPoolEntries) {\n-        this.cpool = cpool;\n-        if (copyPoolEntries) {\n-            typeIndex = cpool.addUtf8(a.getAnnotationType());\n-        } else {\n-            typeIndex = a.getAnnotationTypeIndex();\n-        }\n-        isRuntimeVisible = a.isRuntimeVisible();\n-        evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);\n-    }\n-\n-    private List<ElementValuePairGen> copyValues(final ElementValuePair[] in, final ConstantPoolGen cpool,\n-                                                 final boolean copyPoolEntries) {\n-        final List<ElementValuePairGen> out = new ArrayList<>();\n-        for (final ElementValuePair nvp : in) {\n-            out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));\n-        }\n-        return out;\n-    }\n-\n-    private AnnotationEntryGen(final ConstantPoolGen cpool) {\n-        this.cpool = cpool;\n-    }\n-\n-    \/**\n-     * Retrieve an immutable version of this AnnotationGen\n-     *\/\n-    public AnnotationEntry getAnnotation() {\n-        final AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(),\n-                isRuntimeVisible);\n-        for (final ElementValuePairGen element : evs) {\n-            a.addElementNameValuePair(element.getElementNameValuePair());\n-        }\n-        return a;\n-    }\n-\n-    public AnnotationEntryGen(final ObjectType type,\n-                              final List<ElementValuePairGen> elements, final boolean vis,\n-                              final ConstantPoolGen cpool) {\n-        this.cpool = cpool;\n-        this.typeIndex = cpool.addUtf8(type.getSignature());\n-        evs = elements;\n-        isRuntimeVisible = vis;\n-    }\n-\n-    public static AnnotationEntryGen read(final DataInput dis,\n-                                          final ConstantPoolGen cpool, final boolean b) throws IOException {\n-        final AnnotationEntryGen a = new AnnotationEntryGen(cpool);\n-        a.typeIndex = dis.readUnsignedShort();\n-        final int elemValuePairCount = dis.readUnsignedShort();\n-        for (int i = 0; i < elemValuePairCount; i++) {\n-            final int nidx = dis.readUnsignedShort();\n-            a.addElementNameValuePair(new ElementValuePairGen(nidx,\n-                    ElementValueGen.readElementValue(dis, cpool), cpool));\n-        }\n-        a.isRuntimeVisible(b);\n-        return a;\n-    }\n-\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n-        dos.writeShort(evs.size()); \/\/ u2 element_value pair count\n-        for (final ElementValuePairGen envp : evs) {\n-            envp.dump(dos);\n-        }\n-    }\n-\n-    public void addElementNameValuePair(final ElementValuePairGen evp) {\n-        if (evs == null) {\n-            evs = new ArrayList<>();\n-        }\n-        evs.add(evp);\n-    }\n@@ -137,15 +47,1 @@\n-    public int getTypeIndex() {\n-        return typeIndex;\n-    }\n-\n-    public final String getTypeSignature() {\n-        \/\/ ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);\n-        final ConstantUtf8 utf8 = (ConstantUtf8) cpool\n-                .getConstant(typeIndex\/* c.getNameIndex() *\/);\n-        return utf8.getBytes();\n-    }\n-\n-    public final String getTypeName() {\n-        return getTypeSignature();\/\/ BCELBUG: Should I use this instead?\n-        \/\/ Utility.signatureToString(getTypeSignature());\n-    }\n+    static final AnnotationEntryGen[] EMPTY_ARRAY = {};\n@@ -154,45 +50,1 @@\n-     * Returns list of ElementNameValuePair objects\n-     *\/\n-    public List<ElementValuePairGen> getValues() {\n-        return evs;\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final StringBuilder s = new StringBuilder(32); \/\/ CHECKSTYLE IGNORE MagicNumber\n-        s.append(\"AnnotationGen:[\").append(getTypeName()).append(\" #\").append(evs.size()).append(\" {\");\n-        for (int i = 0; i < evs.size(); i++) {\n-            s.append(evs.get(i));\n-            if (i + 1 < evs.size()) {\n-                s.append(\",\");\n-            }\n-        }\n-        s.append(\"}]\");\n-        return s.toString();\n-    }\n-\n-    public String toShortString() {\n-        final StringBuilder s = new StringBuilder();\n-        s.append(\"@\").append(getTypeName()).append(\"(\");\n-        for (int i = 0; i < evs.size(); i++) {\n-            s.append(evs.get(i));\n-            if (i + 1 < evs.size()) {\n-                s.append(\",\");\n-            }\n-        }\n-        s.append(\")\");\n-        return s.toString();\n-    }\n-\n-    private void isRuntimeVisible(final boolean b) {\n-        isRuntimeVisible = b;\n-    }\n-\n-    public boolean isRuntimeVisible() {\n-        return isRuntimeVisible;\n-    }\n-\n-\n-    \/**\n-     * Converts a list of AnnotationGen objects into a set of attributes\n-     * that can be attached to the class file.\n+     * Converts a list of AnnotationGen objects into a set of attributes that can be attached to the class file.\n@@ -200,1 +52,1 @@\n-     * @param cp  The constant pool gen where we can create the necessary name refs\n+     * @param cp The constant pool gen where we can create the necessary name refs\n@@ -205,1 +57,1 @@\n-            return new Attribute[0];\n+            return Attribute.EMPTY_ARRAY;\n@@ -212,1 +64,1 @@\n-            \/\/  put the annotations in the right output stream\n+            \/\/ put the annotations in the right output stream\n@@ -223,2 +75,1 @@\n-            try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes);\n-                    DataOutputStream riaDos = new DataOutputStream(riaBytes)) {\n+            try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes); DataOutputStream riaDos = new DataOutputStream(riaBytes)) {\n@@ -254,3 +105,2 @@\n-                newAttributes.add(\n-                        new RuntimeVisibleAnnotations(rvaIndex, rvaData.length,\n-                            new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));\n+                newAttributes\n+                    .add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));\n@@ -260,2 +110,1 @@\n-                        new RuntimeInvisibleAnnotations(riaIndex, riaData.length,\n-                            new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));\n+                    new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));\n@@ -264,1 +113,1 @@\n-            return newAttributes.toArray(new Attribute[newAttributes.size()]);\n+            return newAttributes.toArray(Attribute.EMPTY_ARRAY);\n@@ -272,1 +121,0 @@\n-\n@@ -274,3 +122,2 @@\n-     * Annotations against a class are stored in one of four attribute kinds:\n-     * - RuntimeVisibleParameterAnnotations\n-     * - RuntimeInvisibleParameterAnnotations\n+     * Annotations against a class are stored in one of four attribute kinds: - RuntimeVisibleParameterAnnotations -\n+     * RuntimeInvisibleParameterAnnotations\n@@ -278,3 +125,2 @@\n-    static Attribute[] getParameterAnnotationAttributes(\n-            final ConstantPoolGen cp,\n-            final List<AnnotationEntryGen>[] \/*Array of lists, array size depends on #params *\/vec) {\n+    static Attribute[] getParameterAnnotationAttributes(final ConstantPoolGen cp,\n+        final List<AnnotationEntryGen>[] \/* Array of lists, array size depends on #params *\/ vec) {\n@@ -341,5 +187,2 @@\n-                newAttributes\n-                        .add(new RuntimeVisibleParameterAnnotations(rvaIndex,\n-                                rvaData.length,\n-                                new DataInputStream(new ByteArrayInputStream(rvaData)),\n-                                    cp.getConstantPool()));\n+                newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)),\n+                    cp.getConstantPool()));\n@@ -348,5 +191,2 @@\n-                newAttributes\n-                        .add(new RuntimeInvisibleParameterAnnotations(riaIndex,\n-                                riaData.length,\n-                                new DataInputStream(new ByteArrayInputStream(riaData)),\n-                                    cp.getConstantPool()));\n+                newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)),\n+                    cp.getConstantPool()));\n@@ -354,1 +194,1 @@\n-            return newAttributes.toArray(new Attribute[newAttributes.size()]);\n+            return newAttributes.toArray(Attribute.EMPTY_ARRAY);\n@@ -356,2 +196,2 @@\n-            System.err.println(\"IOException whilst processing parameter annotations.\" +\n-                    e.getMessage());\n+            System.err.println(\"IOException whilst processing parameter annotations\");\n+            e.printStackTrace();\n@@ -362,0 +202,139 @@\n+    public static AnnotationEntryGen read(final DataInput dis, final ConstantPoolGen cpool, final boolean b) throws IOException {\n+        final AnnotationEntryGen a = new AnnotationEntryGen(cpool);\n+        a.typeIndex = dis.readUnsignedShort();\n+        final int elemValuePairCount = dis.readUnsignedShort();\n+        for (int i = 0; i < elemValuePairCount; i++) {\n+            final int nidx = dis.readUnsignedShort();\n+            a.addElementNameValuePair(new ElementValuePairGen(nidx, ElementValueGen.readElementValue(dis, cpool), cpool));\n+        }\n+        a.isRuntimeVisible(b);\n+        return a;\n+    }\n+\n+    private int typeIndex;\n+\n+    private List<ElementValuePairGen> evs;\n+\n+    private final ConstantPoolGen cpool;\n+\n+    private boolean isRuntimeVisible;\n+\n+    \/**\n+     * Here we are taking a fixed annotation of type Annotation and building a modifiable AnnotationGen object. If the pool\n+     * passed in is for a different class file, then copyPoolEntries should have been passed as true as that will force us\n+     * to do a deep copy of the annotation and move the cpool entries across. We need to copy the type and the element name\n+     * value pairs and the visibility.\n+     *\/\n+    public AnnotationEntryGen(final AnnotationEntry a, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+        this.cpool = cpool;\n+        if (copyPoolEntries) {\n+            typeIndex = cpool.addUtf8(a.getAnnotationType());\n+        } else {\n+            typeIndex = a.getAnnotationTypeIndex();\n+        }\n+        isRuntimeVisible = a.isRuntimeVisible();\n+        evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);\n+    }\n+\n+    private AnnotationEntryGen(final ConstantPoolGen cpool) {\n+        this.cpool = cpool;\n+    }\n+\n+    public AnnotationEntryGen(final ObjectType type, final List<ElementValuePairGen> elements, final boolean vis, final ConstantPoolGen cpool) {\n+        this.cpool = cpool;\n+        this.typeIndex = cpool.addUtf8(type.getSignature());\n+        evs = elements;\n+        isRuntimeVisible = vis;\n+    }\n+\n+    public void addElementNameValuePair(final ElementValuePairGen evp) {\n+        if (evs == null) {\n+            evs = new ArrayList<>();\n+        }\n+        evs.add(evp);\n+    }\n+\n+    private List<ElementValuePairGen> copyValues(final ElementValuePair[] in, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+        final List<ElementValuePairGen> out = new ArrayList<>();\n+        for (final ElementValuePair nvp : in) {\n+            out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));\n+        }\n+        return out;\n+    }\n+\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n+        dos.writeShort(evs.size()); \/\/ u2 element_value pair count\n+        for (final ElementValuePairGen envp : evs) {\n+            envp.dump(dos);\n+        }\n+    }\n+\n+    \/**\n+     * Retrieve an immutable version of this AnnotationGen\n+     *\/\n+    public AnnotationEntry getAnnotation() {\n+        final AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(), isRuntimeVisible);\n+        for (final ElementValuePairGen element : evs) {\n+            a.addElementNameValuePair(element.getElementNameValuePair());\n+        }\n+        return a;\n+    }\n+\n+    public int getTypeIndex() {\n+        return typeIndex;\n+    }\n+\n+    public final String getTypeName() {\n+        return getTypeSignature();\/\/ BCELBUG: Should I use this instead?\n+        \/\/ Utility.signatureToString(getTypeSignature());\n+    }\n+\n+    public final String getTypeSignature() {\n+        \/\/ ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);\n+        final ConstantUtf8 utf8 = (ConstantUtf8) cpool.getConstant(typeIndex\/* c.getNameIndex() *\/);\n+        return utf8.getBytes();\n+    }\n+\n+    \/**\n+     * Returns list of ElementNameValuePair objects\n+     *\/\n+    public List<ElementValuePairGen> getValues() {\n+        return evs;\n+    }\n+\n+    public boolean isRuntimeVisible() {\n+        return isRuntimeVisible;\n+    }\n+\n+    private void isRuntimeVisible(final boolean b) {\n+        isRuntimeVisible = b;\n+    }\n+\n+    public String toShortString() {\n+        final StringBuilder s = new StringBuilder();\n+        s.append(\"@\").append(getTypeName()).append(\"(\");\n+        for (int i = 0; i < evs.size(); i++) {\n+            s.append(evs.get(i));\n+            if (i + 1 < evs.size()) {\n+                s.append(\",\");\n+            }\n+        }\n+        s.append(\")\");\n+        return s.toString();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder s = new StringBuilder(32); \/\/ CHECKSTYLE IGNORE MagicNumber\n+        s.append(\"AnnotationGen:[\").append(getTypeName()).append(\" #\").append(evs.size()).append(\" {\");\n+        for (int i = 0; i < evs.size(); i++) {\n+            s.append(evs.get(i));\n+            if (i + 1 < evs.size()) {\n+                s.append(\",\");\n+            }\n+        }\n+        s.append(\"}]\");\n+        return s.toString();\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AnnotationEntryGen.java","additions":160,"deletions":181,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- *\n@@ -30,2 +29,1 @@\n-public abstract class ArithmeticInstruction extends Instruction implements TypedInstruction,\n-        StackProducer, StackConsumer {\n+public abstract class ArithmeticInstruction extends Instruction implements TypedInstruction, StackProducer, StackConsumer {\n@@ -34,2 +32,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -40,1 +37,0 @@\n-\n@@ -48,2 +44,2 @@\n-\n-    \/** @return type associated with the instruction\n+    \/**\n+     * @return type associated with the instruction\n@@ -52,45 +48,45 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n-        final short _opcode = super.getOpcode();\n-        switch (_opcode) {\n-            case Const.DADD:\n-            case Const.DDIV:\n-            case Const.DMUL:\n-            case Const.DNEG:\n-            case Const.DREM:\n-            case Const.DSUB:\n-                return Type.DOUBLE;\n-            case Const.FADD:\n-            case Const.FDIV:\n-            case Const.FMUL:\n-            case Const.FNEG:\n-            case Const.FREM:\n-            case Const.FSUB:\n-                return Type.FLOAT;\n-            case Const.IADD:\n-            case Const.IAND:\n-            case Const.IDIV:\n-            case Const.IMUL:\n-            case Const.INEG:\n-            case Const.IOR:\n-            case Const.IREM:\n-            case Const.ISHL:\n-            case Const.ISHR:\n-            case Const.ISUB:\n-            case Const.IUSHR:\n-            case Const.IXOR:\n-                return Type.INT;\n-            case Const.LADD:\n-            case Const.LAND:\n-            case Const.LDIV:\n-            case Const.LMUL:\n-            case Const.LNEG:\n-            case Const.LOR:\n-            case Const.LREM:\n-            case Const.LSHL:\n-            case Const.LSHR:\n-            case Const.LSUB:\n-            case Const.LUSHR:\n-            case Const.LXOR:\n-                return Type.LONG;\n-            default: \/\/ Never reached\n-                throw new ClassGenException(\"Unknown type \" + _opcode);\n+    public Type getType(final ConstantPoolGen cp) {\n+        final short opcode = super.getOpcode();\n+        switch (opcode) {\n+        case Const.DADD:\n+        case Const.DDIV:\n+        case Const.DMUL:\n+        case Const.DNEG:\n+        case Const.DREM:\n+        case Const.DSUB:\n+            return Type.DOUBLE;\n+        case Const.FADD:\n+        case Const.FDIV:\n+        case Const.FMUL:\n+        case Const.FNEG:\n+        case Const.FREM:\n+        case Const.FSUB:\n+            return Type.FLOAT;\n+        case Const.IADD:\n+        case Const.IAND:\n+        case Const.IDIV:\n+        case Const.IMUL:\n+        case Const.INEG:\n+        case Const.IOR:\n+        case Const.IREM:\n+        case Const.ISHL:\n+        case Const.ISHR:\n+        case Const.ISUB:\n+        case Const.IUSHR:\n+        case Const.IXOR:\n+            return Type.INT;\n+        case Const.LADD:\n+        case Const.LAND:\n+        case Const.LDIV:\n+        case Const.LMUL:\n+        case Const.LNEG:\n+        case Const.LOR:\n+        case Const.LREM:\n+        case Const.LSHL:\n+        case Const.LSHR:\n+        case Const.LSUB:\n+        case Const.LUSHR:\n+        case Const.LXOR:\n+            return Type.LONG;\n+        default: \/\/ Never reached\n+            throw new ClassGenException(\"Unknown type \" + opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArithmeticInstruction.java","additions":49,"deletions":53,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -35,2 +35,1 @@\n-public class ArrayElementValueGen extends ElementValueGen\n-{\n+public class ArrayElementValueGen extends ElementValueGen {\n@@ -41,2 +40,14 @@\n-    public ArrayElementValueGen(final ConstantPoolGen cp)\n-    {\n+    \/**\n+     * @param value\n+     * @param cpool\n+     *\/\n+    public ArrayElementValueGen(final ArrayElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+        super(ARRAY, cpool);\n+        evalues = new ArrayList<>();\n+        final ElementValue[] in = value.getElementValuesArray();\n+        for (final ElementValue element : in) {\n+            evalues.add(ElementValueGen.copy(element, cpool, copyPoolEntries));\n+        }\n+    }\n+\n+    public ArrayElementValueGen(final ConstantPoolGen cp) {\n@@ -47,3 +58,1 @@\n-    public ArrayElementValueGen(final int type, final ElementValue[] datums,\n-            final ConstantPoolGen cpool)\n-    {\n+    public ArrayElementValueGen(final int type, final ElementValue[] datums, final ConstantPoolGen cpool) {\n@@ -52,2 +61,1 @@\n-            throw new IllegalArgumentException(\n-                    \"Only element values of type array can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\"Only element values of type array can be built with this ctor - type specified: \" + type);\n@@ -61,0 +69,13 @@\n+    public void addElement(final ElementValueGen gen) {\n+        evalues.add(gen);\n+    }\n+\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 type of value (ARRAY == '[')\n+        dos.writeShort(evalues.size());\n+        for (final ElementValueGen element : evalues) {\n+            element.dump(dos);\n+        }\n+    }\n+\n@@ -65,2 +86,1 @@\n-    public ElementValue getElementValue()\n-    {\n+    public ElementValue getElementValue() {\n@@ -72,3 +92,1 @@\n-        return new ArrayElementValue(super.getElementValueType(),\n-                immutableData,\n-                getConstantPool().getConstantPool());\n+        return new ArrayElementValue(super.getElementValueType(), immutableData, getConstantPool().getConstantPool());\n@@ -77,13 +95,2 @@\n-    \/**\n-     * @param value\n-     * @param cpool\n-     *\/\n-    public ArrayElementValueGen(final ArrayElementValue value, final ConstantPoolGen cpool,\n-            final boolean copyPoolEntries)\n-    {\n-        super(ARRAY, cpool);\n-        evalues = new ArrayList<>();\n-        final ElementValue[] in = value.getElementValuesArray();\n-        for (final ElementValue element : in) {\n-            evalues.add(ElementValueGen.copy(element, cpool, copyPoolEntries));\n-        }\n+    public List<ElementValueGen> getElementValues() {\n+        return evalues;\n@@ -92,8 +99,2 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 type of value (ARRAY == '[')\n-        dos.writeShort(evalues.size());\n-        for (final ElementValueGen element : evalues) {\n-            element.dump(dos);\n-        }\n+    public int getElementValuesSize() {\n+        return evalues.size();\n@@ -103,2 +104,1 @@\n-    public String stringifyValue()\n-    {\n+    public String stringifyValue() {\n@@ -116,15 +116,0 @@\n-\n-    public List<ElementValueGen> getElementValues()\n-    {\n-        return evalues;\n-    }\n-\n-    public int getElementValuesSize()\n-    {\n-        return evalues.size();\n-    }\n-\n-    public void addElement(final ElementValueGen gen)\n-    {\n-        evalues.add(gen);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayElementValueGen.java","additions":37,"deletions":52,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- *\n@@ -30,2 +29,1 @@\n-public abstract class ArrayInstruction extends Instruction implements ExceptionThrower,\n-        TypedInstruction {\n+public abstract class ArrayInstruction extends Instruction implements ExceptionThrower, TypedInstruction {\n@@ -34,2 +32,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -40,1 +37,0 @@\n-\n@@ -48,1 +44,0 @@\n-\n@@ -54,2 +49,2 @@\n-\n-    \/** @return type associated with the instruction\n+    \/**\n+     * @return type associated with the instruction\n@@ -58,29 +53,29 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n-        final short _opcode = super.getOpcode();\n-        switch (_opcode) {\n-            case com.sun.org.apache.bcel.internal.Const.IALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.IASTORE:\n-                return Type.INT;\n-            case com.sun.org.apache.bcel.internal.Const.CALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.CASTORE:\n-                return Type.CHAR;\n-            case com.sun.org.apache.bcel.internal.Const.BALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.BASTORE:\n-                return Type.BYTE;\n-            case com.sun.org.apache.bcel.internal.Const.SALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.SASTORE:\n-                return Type.SHORT;\n-            case com.sun.org.apache.bcel.internal.Const.LALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.LASTORE:\n-                return Type.LONG;\n-            case com.sun.org.apache.bcel.internal.Const.DALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.DASTORE:\n-                return Type.DOUBLE;\n-            case com.sun.org.apache.bcel.internal.Const.FALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.FASTORE:\n-                return Type.FLOAT;\n-            case com.sun.org.apache.bcel.internal.Const.AALOAD:\n-            case com.sun.org.apache.bcel.internal.Const.AASTORE:\n-                return Type.OBJECT;\n-            default:\n-                throw new ClassGenException(\"Unknown case in switch\" + _opcode);\n+    public Type getType(final ConstantPoolGen cp) {\n+        final short opcode = super.getOpcode();\n+        switch (opcode) {\n+        case com.sun.org.apache.bcel.internal.Const.IALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.IASTORE:\n+            return Type.INT;\n+        case com.sun.org.apache.bcel.internal.Const.CALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.CASTORE:\n+            return Type.CHAR;\n+        case com.sun.org.apache.bcel.internal.Const.BALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.BASTORE:\n+            return Type.BYTE;\n+        case com.sun.org.apache.bcel.internal.Const.SALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.SASTORE:\n+            return Type.SHORT;\n+        case com.sun.org.apache.bcel.internal.Const.LALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.LASTORE:\n+            return Type.LONG;\n+        case com.sun.org.apache.bcel.internal.Const.DALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.DASTORE:\n+            return Type.DOUBLE;\n+        case com.sun.org.apache.bcel.internal.Const.FALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.FASTORE:\n+            return Type.FLOAT;\n+        case com.sun.org.apache.bcel.internal.Const.AALOAD:\n+        case com.sun.org.apache.bcel.internal.Const.AASTORE:\n+            return Type.OBJECT;\n+        default:\n+            throw new ClassGenException(\"Unknown case in switch\" + opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayInstruction.java","additions":33,"deletions":38,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- *\n@@ -31,3 +30,2 @@\n-    private int dimensions;\n-    private Type basicType;\n-\n+    private final int dimensions;\n+    private final Type basicType;\n@@ -39,0 +37,1 @@\n+     * @param dimensions array dimensions\n@@ -44,1 +43,0 @@\n-\n@@ -48,1 +46,2 @@\n-     * @param class_name complete name of class (java.lang.String, e.g.)\n+     * @param className complete name of class (java.lang.String, e.g.)\n+     * @param dimensions array dimensions\n@@ -50,2 +49,2 @@\n-    public ArrayType(final String class_name, final int dimensions) {\n-        this(ObjectType.getInstance(class_name), dimensions);\n+    public ArrayType(final String className, final int dimensions) {\n+        this(ObjectType.getInstance(className), dimensions);\n@@ -54,1 +53,0 @@\n-\n@@ -59,0 +57,1 @@\n+     * @param dimensions array dimensions\n@@ -62,1 +61,1 @@\n-        if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {\n+        if (dimensions < 1 || dimensions > Const.MAX_BYTE) {\n@@ -66,11 +65,11 @@\n-            case Const.T_ARRAY:\n-                final ArrayType array = (ArrayType) type;\n-                this.dimensions = dimensions + array.dimensions;\n-                basicType = array.basicType;\n-                break;\n-            case Const.T_VOID:\n-                throw new ClassGenException(\"Invalid type: void[]\");\n-            default: \/\/ Basic type or reference\n-                this.dimensions = dimensions;\n-                basicType = type;\n-                break;\n+        case Const.T_ARRAY:\n+            final ArrayType array = (ArrayType) type;\n+            this.dimensions = dimensions + array.dimensions;\n+            basicType = array.basicType;\n+            break;\n+        case Const.T_VOID:\n+            throw new ClassGenException(\"Invalid type: void[]\");\n+        default: \/\/ Basic type or reference\n+            this.dimensions = dimensions;\n+            basicType = type;\n+            break;\n@@ -86,0 +85,11 @@\n+    \/**\n+     * @return true if both type objects refer to the same array type.\n+     *\/\n+    @Override\n+    public boolean equals(final Object type) {\n+        if (type instanceof ArrayType) {\n+            final ArrayType array = (ArrayType) type;\n+            return array.dimensions == dimensions && array.basicType.equals(basicType);\n+        }\n+        return false;\n+    }\n@@ -94,0 +104,18 @@\n+    \/**\n+     * Gets the name of referenced class.\n+     *\n+     * @return name of referenced class.\n+     * @since 6.7.0\n+     *\/\n+    @Override\n+    @Deprecated\n+    public String getClassName() {\n+        return signature;\n+    }\n+\n+    \/**\n+     * @return number of dimensions of array\n+     *\/\n+    public int getDimensions() {\n+        return dimensions;\n+    }\n@@ -105,9 +133,2 @@\n-\n-    \/** @return number of dimensions of array\n-     *\/\n-    public int getDimensions() {\n-        return dimensions;\n-    }\n-\n-\n-    \/** @return a hash code value for the object.\n+    \/**\n+     * @return a hash code value for the object.\n@@ -119,12 +140,0 @@\n-\n-\n-    \/** @return true if both type objects refer to the same array type.\n-     *\/\n-    @Override\n-    public boolean equals( final Object _type ) {\n-        if (_type instanceof ArrayType) {\n-            final ArrayType array = (ArrayType) _type;\n-            return (array.dimensions == dimensions) && array.basicType.equals(basicType);\n-        }\n-        return false;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayType.java","additions":51,"deletions":42,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,0 +26,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; ..., value\n+ * <\/PRE>\n@@ -30,1 +32,2 @@\n-    \/** Load byte or boolean from array\n+    \/**\n+     * Load byte or boolean from array\n@@ -36,1 +39,0 @@\n-\n@@ -38,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -24,2 +24,1 @@\n- * BASTORE -  Store into byte or boolean array\n- * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n+ * BASTORE - Store into byte or boolean array\n@@ -27,0 +26,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value -&gt; ...\n+ * <\/PRE>\n@@ -30,1 +32,2 @@\n-    \/** Store byte or boolean into array\n+    \/**\n+     * Store byte or boolean into array\n@@ -36,1 +39,0 @@\n-\n@@ -38,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,2 +30,3 @@\n- * <PRE>Stack: ... -&gt; ..., value<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ..., value\n+ * <\/PRE>\n@@ -37,1 +38,0 @@\n-\n@@ -39,2 +39,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -45,2 +44,2 @@\n-\n-    \/** Push byte on stack\n+    \/**\n+     * Push byte on stack\n@@ -53,1 +52,0 @@\n-\n@@ -55,1 +53,4 @@\n-     * Dump instruction as byte code to stream out.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -58,3 +59,6 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        super.dump(out);\n-        out.writeByte(b);\n+    public void accept(final Visitor v) {\n+        v.visitPushInstruction(this);\n+        v.visitStackProducer(this);\n+        v.visitTypedInstruction(this);\n+        v.visitConstantPushInstruction(this);\n+        v.visitBIPUSH(this);\n@@ -63,1 +67,0 @@\n-\n@@ -65,1 +68,1 @@\n-     * @return mnemonic for instruction\n+     * Dump instruction as byte code to stream out.\n@@ -68,2 +71,3 @@\n-    public String toString( final boolean verbose ) {\n-        return super.toString(verbose) + \" \" + b;\n+    public void dump(final DataOutputStream out) throws IOException {\n+        super.dump(out);\n+        out.writeByte(b);\n@@ -72,1 +76,0 @@\n-\n@@ -74,1 +77,1 @@\n-     * Read needed data (e.g. index) from file.\n+     * @return Type.BYTE\n@@ -77,3 +80,2 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n-        super.setLength(2);\n-        b = bytes.readByte();\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.BYTE;\n@@ -82,1 +84,0 @@\n-\n@@ -88,2 +89,2 @@\n-\n-    \/** @return Type.BYTE\n+    \/**\n+     * Read needed data (e.g. index) from file.\n@@ -92,2 +93,3 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.BYTE;\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+        super.setLength(2);\n+        b = bytes.readByte();\n@@ -96,1 +98,0 @@\n-\n@@ -98,6 +99,1 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * @return mnemonic for instruction\n@@ -106,6 +102,2 @@\n-    public void accept( final Visitor v ) {\n-        v.visitPushInstruction(this);\n-        v.visitStackProducer(this);\n-        v.visitTypedInstruction(this);\n-        v.visitConstantPushInstruction(this);\n-        v.visitBIPUSH(this);\n+    public String toString(final boolean verbose) {\n+        return super.toString(verbose) + \" \" + b;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BIPUSH.java","additions":31,"deletions":39,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n- *\n@@ -33,1 +32,0 @@\n-\n@@ -35,4 +33,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -43,1 +39,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BREAKPOINT.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- *\n@@ -31,0 +30,26 @@\n+    \/\/ @since 6.0 no longer final\n+    public static BasicType getType(final byte type) {\n+        switch (type) {\n+        case Const.T_VOID:\n+            return VOID;\n+        case Const.T_BOOLEAN:\n+            return BOOLEAN;\n+        case Const.T_BYTE:\n+            return BYTE;\n+        case Const.T_SHORT:\n+            return SHORT;\n+        case Const.T_CHAR:\n+            return CHAR;\n+        case Const.T_INT:\n+            return INT;\n+        case Const.T_LONG:\n+            return LONG;\n+        case Const.T_DOUBLE:\n+            return DOUBLE;\n+        case Const.T_FLOAT:\n+            return FLOAT;\n+        default:\n+            throw new ClassGenException(\"Invalid type: \" + type);\n+        }\n+    }\n+\n@@ -32,1 +57,1 @@\n-     * Constructor for basic types such as int, long, `void'\n+     * Constructor for basic types such as int, long, 'void'\n@@ -39,1 +64,1 @@\n-        if ((type < Const.T_BOOLEAN) || (type > Const.T_VOID)) {\n+        if (type < Const.T_BOOLEAN || type > Const.T_VOID) {\n@@ -44,29 +69,2 @@\n-\n-    \/\/ @since 6.0 no longer final\n-    public static BasicType getType( final byte type ) {\n-        switch (type) {\n-            case Const.T_VOID:\n-                return VOID;\n-            case Const.T_BOOLEAN:\n-                return BOOLEAN;\n-            case Const.T_BYTE:\n-                return BYTE;\n-            case Const.T_SHORT:\n-                return SHORT;\n-            case Const.T_CHAR:\n-                return CHAR;\n-            case Const.T_INT:\n-                return INT;\n-            case Const.T_LONG:\n-                return LONG;\n-            case Const.T_DOUBLE:\n-                return DOUBLE;\n-            case Const.T_FLOAT:\n-                return FLOAT;\n-            default:\n-                throw new ClassGenException(\"Invalid type: \" + type);\n-        }\n-    }\n-\n-\n-    \/** @return a hash code value for the object.\n+    \/**\n+     * @return true if both type objects refer to the same type\n@@ -75,2 +73,2 @@\n-    public int hashCode() {\n-        return super.getType();\n+    public boolean equals(final Object type) {\n+        return type instanceof BasicType && ((BasicType) type).getType() == this.getType();\n@@ -79,2 +77,2 @@\n-\n-    \/** @return true if both type objects refer to the same type\n+    \/**\n+     * @return a hash code value for the object.\n@@ -83,2 +81,2 @@\n-    public boolean equals( final Object _type ) {\n-        return (_type instanceof BasicType) ? ((BasicType) _type).getType() == this.getType() : false;\n+    public int hashCode() {\n+        return super.getType();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BasicType.java","additions":36,"deletions":38,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -24,4 +24,2 @@\n- * BranchHandle is returned by specialized InstructionList.append() whenever a\n- * BranchInstruction is appended. This is useful when the target of this\n- * instruction is not known at time of creation and must be set later\n- * via setTarget().\n+ * BranchHandle is returned by specialized InstructionList.append() whenever a BranchInstruction is appended. This is\n+ * useful when the target of this instruction is not known at time of creation and must be set later via setTarget().\n@@ -35,0 +33,7 @@\n+    \/**\n+     * Factory method.\n+     *\/\n+    static BranchHandle getBranchHandle(final BranchInstruction i) {\n+        return new BranchHandle(i);\n+    }\n+\n@@ -39,1 +44,0 @@\n-\n@@ -45,10 +49,3 @@\n-    \/** Factory method.\n-     *\/\n-    static BranchHandle getBranchHandle( final BranchInstruction i ) {\n-        return new BranchHandle(i);\n-    }\n-\n-\n-    \/* Override InstructionHandle methods: delegate to branch instruction.\n-     * Through this overriding all access to the private i_position field should\n-     * be prevented.\n+    \/*\n+     * Override InstructionHandle methods: delegate to branch instruction. Through this overriding all access to the private\n+     * i_position field should be prevented.\n@@ -61,0 +58,18 @@\n+    \/**\n+     * @return target of instruction.\n+     *\/\n+    public InstructionHandle getTarget() {\n+        return bi.getTarget();\n+    }\n+\n+    \/**\n+     * Set new contents. Old instruction is disposed and may not be used anymore.\n+     *\/\n+    @Override \/\/ This is only done in order to apply the additional type check; could be merged with super impl.\n+    public void setInstruction(final Instruction i) { \/\/ TODO could be package-protected?\n+        super.setInstruction(i);\n+        if (!(i instanceof BranchInstruction)) {\n+            throw new ClassGenException(\"Assigning \" + i + \" to branch handle which is not a branch instruction\");\n+        }\n+        bi = (BranchInstruction) i;\n+    }\n@@ -63,1 +78,1 @@\n-    void setPosition( final int pos ) {\n+    void setPosition(final int pos) {\n@@ -69,9 +84,0 @@\n-\n-    @Override\n-    protected int updatePosition( final int offset, final int max_offset ) {\n-        final int x = bi.updatePosition(offset, max_offset);\n-        super.setPosition(bi.getPosition());\n-        return x;\n-    }\n-\n-\n@@ -81,1 +87,1 @@\n-    public void setTarget( final InstructionHandle ih ) {\n+    public void setTarget(final InstructionHandle ih) {\n@@ -85,14 +91,5 @@\n-\n-    \/**\n-     * Update target of instruction.\n-     *\/\n-    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n-        bi.updateTarget(old_ih, new_ih);\n-    }\n-\n-\n-    \/**\n-     * @return target of instruction.\n-     *\/\n-    public InstructionHandle getTarget() {\n-        return bi.getTarget();\n+    @Override\n+    protected int updatePosition(final int offset, final int maxOffset) {\n+        final int x = bi.updatePosition(offset, maxOffset);\n+        super.setPosition(bi.getPosition());\n+        return x;\n@@ -101,1 +98,0 @@\n-\n@@ -103,1 +99,1 @@\n-     * Set new contents. Old instruction is disposed and may not be used anymore.\n+     * Update target of instruction.\n@@ -105,8 +101,2 @@\n-    @Override \/\/ This is only done in order to apply the additional type check; could be merged with super impl.\n-    public void setInstruction( final Instruction i ) { \/\/ TODO could be package-protected?\n-        super.setInstruction(i);\n-        if (!(i instanceof BranchInstruction)) {\n-            throw new ClassGenException(\"Assigning \" + i\n-                    + \" to branch handle which is not a branch instruction\");\n-        }\n-        bi = (BranchInstruction) i;\n+    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n+        bi.updateTarget(oldIh, newIh);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BranchHandle.java","additions":40,"deletions":50,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,3 +28,2 @@\n- * Abstract super class for branching instructions like GOTO, IFEQ, etc..\n- * Branch instructions may have a variable length, namely GOTO, JSR,\n- * LOOKUPSWITCH and TABLESWITCH.\n+ * Abstract super class for branching instructions like GOTO, IFEQ, etc.. Branch instructions may have a variable\n+ * length, namely GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n@@ -33,1 +32,1 @@\n- * @LastModified: July 2020\n+ * @LastModified: Feb 2023\n@@ -37,4 +36,0 @@\n-    private int index; \/\/ Branch target relative to this instruction\n-    private InstructionHandle target; \/\/ Target object in instruction list\n-    private int position; \/\/ Byte code offset\n-\n@@ -42,2 +37,1 @@\n-     * Empty constructor needed for the Class.newInstance() statement in\n-     * Instruction.readInstruction(). Not to be used otherwise.\n+     * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen\n@@ -45,1 +39,7 @@\n-    BranchInstruction() {\n+    static void notifyTarget(final InstructionHandle oldIh, final InstructionHandle newIh, final InstructionTargeter t) {\n+        if (oldIh != null) {\n+            oldIh.removeTargeter(t);\n+        }\n+        if (newIh != null) {\n+            newIh.addTargeter(t);\n+        }\n@@ -48,4 +48,2 @@\n-\n-    \/** Common super constructor\n-     * @param opcode Instruction opcode\n-     * @param target instruction to branch to\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -53,5 +51,2 @@\n-    protected BranchInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, (short) 3);\n-        setTarget(target);\n-    }\n-\n+    @Deprecated\n+    protected int index; \/\/ Branch target relative to this instruction\n@@ -60,2 +55,1 @@\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -63,10 +57,2 @@\n-    @Override\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        index = getTargetOffset();\n-        if (!isValidShort(index)) {\n-            throw new ClassGenException(\"Branch target offset too large for short: \" + index);\n-        }\n-        out.writeShort(index); \/\/ May be negative, i.e., point backwards\n-    }\n-\n+    @Deprecated\n+    protected InstructionHandle target; \/\/ Target object in instruction list\n@@ -75,2 +61,1 @@\n-     * @param _target branch target\n-     * @return the offset to  `target' relative to this instruction\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -78,13 +63,2 @@\n-    protected int getTargetOffset( final InstructionHandle _target ) {\n-        if (_target == null) {\n-            throw new ClassGenException(\"Target of \" + super.toString(true)\n-                    + \" is invalid null handle\");\n-        }\n-        final int t = _target.getPosition();\n-        if (t < 0) {\n-            throw new ClassGenException(\"Invalid branch target position offset for \"\n-                    + super.toString(true) + \":\" + t + \":\" + _target);\n-        }\n-        return t - position;\n-    }\n-\n+    @Deprecated\n+    protected int position; \/\/ Byte code offset\n@@ -93,1 +67,1 @@\n-     * @return the offset to this instruction's target\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -95,2 +69,1 @@\n-    protected int getTargetOffset() {\n-        return getTargetOffset(target);\n+    BranchInstruction() {\n@@ -99,1 +72,0 @@\n-\n@@ -101,4 +73,1 @@\n-     * Called by InstructionList.setPositions when setting the position for every\n-     * instruction. In the presence of variable length instructions `setPositions'\n-     * performs multiple passes over the instruction list to calculate the\n-     * correct (byte) positions and offsets by calling this function.\n+     * Common super constructor\n@@ -106,3 +75,2 @@\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param max_offset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n+     * @param opcode Instruction opcode\n+     * @param target instruction to branch to\n@@ -110,3 +78,3 @@\n-    protected int updatePosition( final int offset, final int max_offset ) {\n-        position += offset;\n-        return 0;\n+    protected BranchInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, (short) 3);\n+        setTarget(target);\n@@ -115,1 +83,0 @@\n-\n@@ -117,9 +84,1 @@\n-     * Long output format:\n-     *\n-     * &lt;position in byte code&gt;\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n-     * \"(\"&lt;length of instruction&gt;\")\"\n-     * \"&lt;\"&lt;target instruction&gt;\"&gt;\" \"@\"&lt;branch target offset&gt;\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * @return true, if ih is target of this instruction\n@@ -128,25 +87,2 @@\n-    public String toString( final boolean verbose ) {\n-        final String s = super.toString(verbose);\n-        String t = \"null\";\n-        if (verbose) {\n-            if (target != null) {\n-                if (target.getInstruction() == this) {\n-                    t = \"<points to itself>\";\n-                } else if (target.getInstruction() == null) {\n-                    t = \"<null instruction!!!?>\";\n-                } else {\n-                    \/\/ I'm more interested in the address of the target then\n-                    \/\/ the instruction located there.\n-                    \/\/t = target.getInstruction().toString(false); \/\/ Avoid circles\n-                    t = \"\" + target.getPosition();\n-                }\n-            }\n-        } else {\n-            if (target != null) {\n-                index = target.getPosition();\n-                \/\/ index = getTargetOffset();  crashes if positions haven't been set\n-                \/\/ t = \"\" + (index + position);\n-                t = \"\" + index;\n-            }\n-        }\n-        return s + \" -> \" + t;\n+    public boolean containsTarget(final InstructionHandle ih) {\n+        return target == ih;\n@@ -155,0 +91,9 @@\n+    \/**\n+     * Inform target that it's not targeted anymore.\n+     *\/\n+    @Override\n+    void dispose() {\n+        setTarget(null);\n+        index = -1;\n+        position = -1;\n+    }\n@@ -157,2 +102,1 @@\n-     * Read needed data (e.g. index) from file. Conversion to a InstructionHandle\n-     * is done in InstructionList(byte[]).\n+     * Dump instruction as byte code to stream out.\n@@ -160,3 +104,1 @@\n-     * @param bytes input stream\n-     * @param wide wide prefix?\n-     * @see InstructionList\n+     * @param out Output stream\n@@ -165,3 +107,7 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n-        super.setLength(3);\n-        index = bytes.readShort();\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        index = getTargetOffset();\n+        if (!isValidShort(index)) {\n+            throw new ClassGenException(\"Branch target offset too large for short: \" + index);\n+        }\n+        out.writeShort(index); \/\/ May be negative, i.e., point backwards\n@@ -170,1 +116,0 @@\n-\n@@ -178,0 +123,7 @@\n+    \/**\n+     * @return the position\n+     * @since 6.0\n+     *\/\n+    protected int getPosition() {\n+        return position;\n+    }\n@@ -186,1 +138,0 @@\n-\n@@ -188,2 +139,1 @@\n-     * Set branch target\n-     * @param target branch target\n+     * @return the offset to this instruction's target\n@@ -191,3 +141,2 @@\n-    public void setTarget( final InstructionHandle target ) {\n-        notifyTarget(this.target, target, this);\n-        this.target = target;\n+    protected int getTargetOffset() {\n+        return getTargetOffset(target);\n@@ -196,1 +145,0 @@\n-\n@@ -198,1 +146,2 @@\n-     * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen\n+     * @param target branch target\n+     * @return the offset to 'target' relative to this instruction\n@@ -200,4 +149,3 @@\n-    static void notifyTarget( final InstructionHandle old_ih, final InstructionHandle new_ih,\n-            final InstructionTargeter t ) {\n-        if (old_ih != null) {\n-            old_ih.removeTargeter(t);\n+    protected int getTargetOffset(final InstructionHandle target) {\n+        if (target == null) {\n+            throw new ClassGenException(\"Target of \" + super.toString(true) + \" is invalid null handle\");\n@@ -205,2 +153,3 @@\n-        if (new_ih != null) {\n-            new_ih.addTargeter(t);\n+        final int t = target.getPosition();\n+        if (t < 0) {\n+            throw new ClassGenException(\"Invalid branch target position offset for \" + super.toString(true) + \":\" + t + \":\" + target);\n@@ -208,0 +157,1 @@\n+        return t - position;\n@@ -210,1 +160,0 @@\n-\n@@ -212,2 +161,5 @@\n-     * @param old_ih old target\n-     * @param new_ih new target\n+     * Read needed data (e.g. index) from file. Conversion to a InstructionHandle is done in InstructionList(byte[]).\n+     *\n+     * @param bytes input stream\n+     * @param wide wide prefix?\n+     * @see InstructionList\n@@ -216,6 +168,3 @@\n-    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n-        if (target == old_ih) {\n-            setTarget(new_ih);\n-        } else {\n-            throw new ClassGenException(\"Not targeting \" + old_ih + \", but \" + target);\n-        }\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+        super.setLength(3);\n+        index = bytes.readShort();\n@@ -224,0 +173,7 @@\n+    \/**\n+     * @param index the index to set\n+     * @since 6.0\n+     *\/\n+    protected void setIndex(final int index) {\n+        this.index = index;\n+    }\n@@ -226,1 +182,2 @@\n-     * @return true, if ih is target of this instruction\n+     * @param position the position to set\n+     * @since 6.0\n@@ -228,3 +185,2 @@\n-    @Override\n-    public boolean containsTarget( final InstructionHandle ih ) {\n-        return target == ih;\n+    protected void setPosition(final int position) {\n+        this.position = position;\n@@ -252,1 +208,3 @@\n-     * Inform target that it's not targeted anymore.\n+     * Set branch target\n+     *\n+     * @param target branch target\n@@ -254,5 +212,3 @@\n-    @Override\n-    void dispose() {\n-        setTarget(null);\n-        index = -1;\n-        position = -1;\n+    public void setTarget(final InstructionHandle target) {\n+        notifyTarget(this.target, target, this);\n+        this.target = target;\n@@ -261,1 +217,0 @@\n-\n@@ -263,2 +218,7 @@\n-     * @return the position\n-     * @since 6.0\n+     * Long output format:\n+     *\n+     * &lt;position in byte code&gt; &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\"\n+     * \"&lt;\"&lt;target instruction&gt;\"&gt;\" \"@\"&lt;branch target offset&gt;\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -266,2 +226,24 @@\n-    protected int getPosition() {\n-        return position;\n+    @Override\n+    public String toString(final boolean verbose) {\n+        final String s = super.toString(verbose);\n+        String t = \"null\";\n+        if (target != null) {\n+            if (verbose) {\n+                if (target.getInstruction() == this) {\n+                    t = \"<points to itself>\";\n+                } else if (target.getInstruction() == null) {\n+                    t = \"<null instruction!!!?>\";\n+                } else {\n+                    \/\/ I'm more interested in the address of the target then\n+                    \/\/ the instruction located there.\n+                    \/\/ t = target.getInstruction().toString(false); \/\/ Avoid circles\n+                    t = \"\" + target.getPosition();\n+                }\n+            } else {\n+                index = target.getPosition();\n+                \/\/ index = getTargetOffset(); crashes if positions haven't been set\n+                \/\/ t = \"\" + (index + position);\n+                t = \"\" + index;\n+            }\n+        }\n+        return s + \" -> \" + t;\n@@ -270,1 +252,0 @@\n-\n@@ -272,2 +253,7 @@\n-     * @param position the position to set\n-     * @since 6.0\n+     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n+     * length instructions 'setPositions' performs multiple passes over the instruction list to calculate the correct (byte)\n+     * positions and offsets by calling this function.\n+     *\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param maxOffset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n@@ -275,2 +261,3 @@\n-    protected void setPosition(final int position) {\n-        this.position = position;\n+    protected int updatePosition(final int offset, final int maxOffset) {\n+        position += offset;\n+        return 0;\n@@ -279,1 +266,0 @@\n-\n@@ -281,2 +267,2 @@\n-     * @param index the index to set\n-     * @since 6.0\n+     * @param oldIh old target\n+     * @param newIh new target\n@@ -284,2 +270,6 @@\n-    protected void setIndex(final int index) {\n-        this.index = index;\n+    @Override\n+    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n+        if (target != oldIh) {\n+            throw new ClassGenException(\"Not targeting \" + oldIh + \", but \" + target);\n+        }\n+        setTarget(newIh);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BranchInstruction.java","additions":144,"deletions":154,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; ..., value\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Load char from array\n+    \/**\n+     * Load char from array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * CASTORE -  Store into char array\n- * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n+ * CASTORE - Store into char array\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value -&gt; ...\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Store char into array\n+    \/**\n+     * Store char into array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * <PRE>Stack: ..., objectref -&gt; ..., objectref<\/PRE>\n@@ -30,0 +29,3 @@\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; ..., objectref\n+ * <\/PRE>\n@@ -31,2 +33,1 @@\n-public class CHECKCAST extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer,\n-        StackConsumer {\n+public class CHECKCAST extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer, StackConsumer {\n@@ -35,2 +36,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -41,2 +41,3 @@\n-\n-    \/** Check whether object is of given type\n+    \/**\n+     * Check whether object is of given type\n+     *\n@@ -49,20 +50,0 @@\n-\n-    \/** @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n-            ExceptionConst.CLASS_CAST_EXCEPTION);\n-    }\n-\n-\n-    @Override\n-    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n-        Type t = getType(cpg);\n-        if (t instanceof ArrayType) {\n-            t = ((ArrayType) t).getBasicType();\n-        }\n-        return (t instanceof ObjectType) ? (ObjectType) t : null;\n-    }\n-\n-\n@@ -70,4 +51,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -78,1 +57,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -87,0 +66,17 @@\n+\n+    \/**\n+     * @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.CLASS_CAST_EXCEPTION);\n+    }\n+\n+    @Override\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+        Type t = getType(cpg);\n+        if (t instanceof ArrayType) {\n+            t = ((ArrayType) t).getBasicType();\n+        }\n+        return t instanceof ObjectType ? (ObjectType) t : null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CHECKCAST.java","additions":28,"deletions":32,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -31,2 +32,1 @@\n- * Abstract super class for instructions that use an index into the\n- * constant pool such as LDC, INVOKEVIRTUAL, etc.\n+ * Abstract super class for instructions that use an index into the constant pool such as LDC, INVOKEVIRTUAL, etc.\n@@ -40,4 +40,1 @@\n-public abstract class CPInstruction extends Instruction implements TypedInstruction,\n-        IndexedInstruction {\n-\n-    private int index; \/\/ index to constant pool\n+public abstract class CPInstruction extends Instruction implements TypedInstruction, IndexedInstruction {\n@@ -45,0 +42,5 @@\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int index; \/\/ index to constant pool\n@@ -47,2 +49,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -53,1 +54,0 @@\n-\n@@ -62,1 +62,0 @@\n-\n@@ -65,0 +64,1 @@\n+     *\n@@ -68,1 +68,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -73,1 +73,0 @@\n-\n@@ -75,7 +74,1 @@\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n-     * \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; constant pool index&gt;\"&gt;\"\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * @return index in constant pool referred by this instruction.\n@@ -84,2 +77,2 @@\n-    public String toString( final boolean verbose ) {\n-        return super.toString(verbose) + \" \" + index;\n+    public final int getIndex() {\n+        return index;\n@@ -88,1 +81,0 @@\n-\n@@ -90,1 +82,1 @@\n-     * @return mnemonic for instruction with symbolic references resolved\n+     * @return type related with this instruction.\n@@ -93,5 +85,5 @@\n-    public String toString( final ConstantPool cp ) {\n-        final Constant c = cp.getConstant(index);\n-        String str = cp.constantToString(c);\n-        if (c instanceof ConstantClass) {\n-            str = str.replace('.', '\/');\n+    public Type getType(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        String name = cp.getConstantString(index, com.sun.org.apache.bcel.internal.Const.CONSTANT_Class);\n+        if (!name.startsWith(\"[\")) {\n+            name = \"L\" + name + \";\";\n@@ -99,1 +91,1 @@\n-        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + str;\n+        return Type.getType(name);\n@@ -102,1 +94,0 @@\n-\n@@ -105,0 +96,1 @@\n+     *\n@@ -109,1 +101,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -114,10 +106,0 @@\n-\n-    \/**\n-     * @return index in constant pool referred by this instruction.\n-     *\/\n-    @Override\n-    public final int getIndex() {\n-        return index;\n-    }\n-\n-\n@@ -126,1 +108,2 @@\n-     * @param index in  constant pool.\n+     *\n+     * @param index in constant pool.\n@@ -129,1 +112,1 @@\n-    public void setIndex( final int index ) { \/\/ TODO could be package-protected?\n+    public void setIndex(final int index) { \/\/ TODO could be package-protected?\n@@ -136,0 +119,13 @@\n+    \/**\n+     * Long output format:\n+     *\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; constant pool\n+     * index&gt;\"&gt;\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n+     *\/\n+    @Override\n+    public String toString(final boolean verbose) {\n+        return super.toString(verbose) + \" \" + index;\n+    }\n@@ -137,1 +133,2 @@\n-    \/** @return type related with this instruction.\n+    \/**\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -140,5 +137,5 @@\n-    public Type getType( final ConstantPoolGen cpg ) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        String name = cp.getConstantString(index, com.sun.org.apache.bcel.internal.Const.CONSTANT_Class);\n-        if (!name.startsWith(\"[\")) {\n-            name = \"L\" + name + \";\";\n+    public String toString(final ConstantPool cp) {\n+        final Constant c = cp.getConstant(index);\n+        String str = cp.constantToString(c);\n+        if (c instanceof ConstantClass) {\n+            str = Utility.packageToPath(str);\n@@ -146,1 +143,1 @@\n-        return Type.getType(name);\n+        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + str;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CPInstruction.java","additions":47,"deletions":50,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-public class ClassElementValueGen extends ElementValueGen\n-{\n+public class ClassElementValueGen extends ElementValueGen {\n@@ -39,1 +38,1 @@\n-    private int idx;\n+    private final int idx;\n@@ -41,2 +40,11 @@\n-    protected ClassElementValueGen(final int typeIdx, final ConstantPoolGen cpool)\n-    {\n+    public ClassElementValueGen(final ClassElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+        super(CLASS, cpool);\n+        if (copyPoolEntries) {\n+            \/\/ idx = cpool.addClass(value.getClassString());\n+            idx = cpool.addUtf8(value.getClassString());\n+        } else {\n+            idx = value.getIndex();\n+        }\n+    }\n+\n+    protected ClassElementValueGen(final int typeIdx, final ConstantPoolGen cpool) {\n@@ -47,2 +55,1 @@\n-    public ClassElementValueGen(final ObjectType t, final ConstantPoolGen cpool)\n-    {\n+    public ClassElementValueGen(final ObjectType t, final ConstantPoolGen cpool) {\n@@ -54,3 +61,0 @@\n-    \/**\n-     * Return immutable variant of this ClassElementValueGen\n-     *\/\n@@ -58,25 +62,3 @@\n-    public ElementValue getElementValue()\n-    {\n-        return new ClassElementValue(super.getElementValueType(),\n-                idx,\n-                getConstantPool().getConstantPool());\n-    }\n-\n-    public ClassElementValueGen(final ClassElementValue value, final ConstantPoolGen cpool,\n-            final boolean copyPoolEntries)\n-    {\n-        super(CLASS, cpool);\n-        if (copyPoolEntries)\n-        {\n-            \/\/ idx = cpool.addClass(value.getClassString());\n-            idx = cpool.addUtf8(value.getClassString());\n-        }\n-        else\n-        {\n-            idx = value.getIndex();\n-        }\n-    }\n-\n-    public int getIndex()\n-    {\n-        return idx;\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n+        dos.writeShort(idx);\n@@ -85,2 +67,1 @@\n-    public String getClassString()\n-    {\n+    public String getClassString() {\n@@ -95,0 +76,3 @@\n+    \/**\n+     * Return immutable variant of this ClassElementValueGen\n+     *\/\n@@ -96,3 +80,6 @@\n-    public String stringifyValue()\n-    {\n-        return getClassString();\n+    public ElementValue getElementValue() {\n+        return new ClassElementValue(super.getElementValueType(), idx, getConstantPool().getConstantPool());\n+    }\n+\n+    public int getIndex() {\n+        return idx;\n@@ -102,4 +89,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n-        dos.writeShort(idx);\n+    public String stringifyValue() {\n+        return getClassString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassElementValueGen.java","additions":29,"deletions":44,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,2 @@\n+import java.util.Arrays;\n+import java.util.Collections;\n@@ -28,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;\n@@ -38,0 +39,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -41,2 +43,1 @@\n- * Template class for building up a java class. May be initialized with an\n- * existing java class (file).\n+ * Template class for building up a java class. May be initialized with an existing java class (file).\n@@ -45,1 +46,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -49,17 +50,0 @@\n-    \/* Corresponds to the fields found in a JavaClass object.\n-     *\/\n-    private String className;\n-    private String superClassName;\n-    private final String fileName;\n-    private int classNameIndex = -1;\n-    private int superclass_name_index = -1;\n-    private int major = Const.MAJOR_1_1;\n-    private int minor = Const.MINOR_1_1;\n-    private ConstantPoolGen cp; \/\/ Template for building up constant pool\n-    \/\/ ArrayLists instead of arrays to gather fields, methods, etc.\n-    private final List<Field> fieldList = new ArrayList<>();\n-    private final List<Method> methodList = new ArrayList<>();\n-    private final List<Attribute> attributeList = new ArrayList<>();\n-    private final List<String> interfaceList = new ArrayList<>();\n-    private final List<AnnotationEntryGen> annotationList = new ArrayList<>();\n-\n@@ -69,1 +53,1 @@\n-        public boolean equals( final Object o1, final Object o2 ) {\n+        public boolean equals(final Object o1, final Object o2) {\n@@ -75,1 +59,0 @@\n-\n@@ -77,1 +60,1 @@\n-        public int hashCode( final Object o ) {\n+        public int hashCode(final Object o) {\n@@ -83,9 +66,2 @@\n-\n-    \/** Convenience constructor to set up some important values initially.\n-     *\n-     * @param className fully qualified class name\n-     * @param superClassName fully qualified superclass name\n-     * @param fileName source file name\n-     * @param accessFlags access qualifiers\n-     * @param interfaces implemented interfaces\n-     * @param cp constant pool to use\n+    \/**\n+     * @return Comparison strategy object\n@@ -93,19 +69,2 @@\n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags,\n-            final String[] interfaces, final ConstantPoolGen cp) {\n-        super(accessFlags);\n-        this.className = className;\n-        this.superClassName = superClassName;\n-        this.fileName = fileName;\n-        this.cp = cp;\n-        \/\/ Put everything needed by default into the constant pool and the vectors\n-        if (fileName != null) {\n-            addAttribute(new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp\n-                    .getConstantPool()));\n-        }\n-        classNameIndex = cp.addClass(className);\n-        superclass_name_index = cp.addClass(superClassName);\n-        if (interfaces != null) {\n-            for (final String interface1 : interfaces) {\n-                addInterface(interface1);\n-            }\n-        }\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -114,8 +73,2 @@\n-\n-    \/** Convenience constructor to set up some important values initially.\n-     *\n-     * @param className fully qualified class name\n-     * @param superClassName fully qualified superclass name\n-     * @param fileName source file name\n-     * @param accessFlags access qualifiers\n-     * @param interfaces implemented interfaces\n+    \/**\n+     * @param comparator Comparison strategy object\n@@ -123,4 +76,2 @@\n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags,\n-            final String[] interfaces) {\n-        this(className, superClassName, fileName, accessFlags, interfaces,\n-                new ConstantPoolGen());\n+    public static void setComparator(final BCELComparator comparator) {\n+        bcelComparator = comparator;\n@@ -129,0 +80,22 @@\n+    \/*\n+     * Corresponds to the fields found in a JavaClass object.\n+     *\/\n+    private String className;\n+    private String superClassName;\n+    private final String fileName;\n+    private int classNameIndex = -1;\n+    private int superclassNameIndex = -1;\n+    private int major = Const.MAJOR_1_1;\n+    private int minor = Const.MINOR_1_1;\n+    private ConstantPoolGen cp; \/\/ Template for building up constant pool\n+    \/\/ ArrayLists instead of arrays to gather fields, methods, etc.\n+    private final List<Field> fieldList = new ArrayList<>();\n+    private final List<Method> methodList = new ArrayList<>();\n+\n+    private final List<Attribute> attributeList = new ArrayList<>();\n+\n+    private final List<String> interfaceList = new ArrayList<>();\n+\n+    private final List<AnnotationEntryGen> annotationList = new ArrayList<>();\n+\n+    private List<ClassObserver> observers;\n@@ -132,0 +105,1 @@\n+     *\n@@ -137,1 +111,1 @@\n-        superclass_name_index = clazz.getSuperclassNameIndex();\n+        superclassNameIndex = clazz.getSuperclassNameIndex();\n@@ -147,6 +121,1 @@\n-        final Method[] methods = clazz.getMethods();\n-        final Field[] fields = clazz.getFields();\n-        final String[] interfaces = clazz.getInterfaceNames();\n-        for (final String interface1 : interfaces) {\n-            addInterface(interface1);\n-        }\n+        Collections.addAll(interfaceList, clazz.getInterfaceNames());\n@@ -158,9 +127,3 @@\n-        for (final AnnotationEntryGen annotation : annotations) {\n-            addAnnotationEntry(annotation);\n-        }\n-        for (final Method method : methods) {\n-            addMethod(method);\n-        }\n-        for (final Field field : fields) {\n-            addField(field);\n-        }\n+        Collections.addAll(annotationList, annotations);\n+        Collections.addAll(methodList, clazz.getMethods());\n+        Collections.addAll(fieldList, clazz.getFields());\n@@ -170,1 +133,7 @@\n-     * Look for attributes representing annotations and unpack them.\n+     * Convenience constructor to set up some important values initially.\n+     *\n+     * @param className fully qualified class name\n+     * @param superClassName fully qualified superclass name\n+     * @param fileName source file name\n+     * @param accessFlags access qualifiers\n+     * @param interfaces implemented interfaces\n@@ -172,25 +141,2 @@\n-    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs)\n-    {\n-        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<>();\n-        for (final Attribute attr : attrs) {\n-            if (attr instanceof RuntimeVisibleAnnotations)\n-            {\n-                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n-                final AnnotationEntry[] annos = rva.getAnnotationEntries();\n-                for (final AnnotationEntry a : annos) {\n-                    annotationGenObjs.add(new AnnotationEntryGen(a,\n-                            getConstantPool(), false));\n-                }\n-            }\n-            else\n-                if (attr instanceof RuntimeInvisibleAnnotations)\n-                {\n-                    final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n-                    final AnnotationEntry[] annos = ria.getAnnotationEntries();\n-                    for (final AnnotationEntry a : annos) {\n-                        annotationGenObjs.add(new AnnotationEntryGen(a,\n-                                getConstantPool(), false));\n-                    }\n-                }\n-        }\n-        return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces) {\n+        this(className, superClassName, fileName, accessFlags, interfaces, new ConstantPoolGen());\n@@ -199,1 +145,0 @@\n-\n@@ -201,1 +146,8 @@\n-     * @return the (finally) built up Java class object.\n+     * Convenience constructor to set up some important values initially.\n+     *\n+     * @param className fully qualified class name\n+     * @param superClassName fully qualified superclass name\n+     * @param fileName source file name\n+     * @param accessFlags access qualifiers\n+     * @param interfaces implemented interfaces\n+     * @param cp constant pool to use\n@@ -203,13 +155,15 @@\n-    public JavaClass getJavaClass() {\n-        final int[] interfaces = getInterfaces();\n-        final Field[] fields = getFields();\n-        final Method[] methods = getMethods();\n-        Attribute[] attributes = null;\n-        if (annotationList.isEmpty()) {\n-            attributes = getAttributes();\n-        } else {\n-            \/\/ TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'\n-            final Attribute[] annAttributes  = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());\n-            attributes = new Attribute[attributeList.size()+annAttributes.length];\n-            attributeList.toArray(attributes);\n-            System.arraycopy(annAttributes,0,attributes,attributeList.size(),annAttributes.length);\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces,\n+        final ConstantPoolGen cp) {\n+        super(accessFlags);\n+        this.className = className;\n+        this.superClassName = superClassName;\n+        this.fileName = fileName;\n+        this.cp = cp;\n+        \/\/ Put everything needed by default into the constant pool and the vectors\n+        if (fileName != null) {\n+            addAttribute(new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp.getConstantPool()));\n+        }\n+        classNameIndex = cp.addClass(className);\n+        superclassNameIndex = cp.addClass(superClassName);\n+        if (interfaces != null) {\n+            Collections.addAll(interfaceList, interfaces);\n@@ -217,4 +171,0 @@\n-        \/\/ Must be last since the above calls may still add something to it\n-        final ConstantPool _cp = this.cp.getFinalConstantPool();\n-        return new JavaClass(classNameIndex, superclass_name_index, fileName, major, minor,\n-                super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);\n@@ -223,7 +173,2 @@\n-\n-    \/**\n-     * Add an interface to this class, i.e., this class has to implement it.\n-     * @param name interface to implement (fully qualified class name)\n-     *\/\n-    public void addInterface( final String name ) {\n-        interfaceList.add(name);\n+    public void addAnnotationEntry(final AnnotationEntryGen a) {\n+        annotationList.add(a);\n@@ -232,1 +177,0 @@\n-\n@@ -234,2 +178,3 @@\n-     * Remove an interface from this class.\n-     * @param name interface to remove (fully qualified name)\n+     * Add an attribute to this class.\n+     *\n+     * @param a attribute to add\n@@ -237,2 +182,2 @@\n-    public void removeInterface( final String name ) {\n-        interfaceList.remove(name);\n+    public void addAttribute(final Attribute a) {\n+        attributeList.add(a);\n@@ -241,1 +186,0 @@\n-\n@@ -243,17 +187,5 @@\n-     * @return major version number of class file\n-     *\/\n-    public int getMajor() {\n-        return major;\n-    }\n-\n-\n-    \/** Set major version number of class file, default value is 45 (JDK 1.1)\n-     * @param major major version number\n-     *\/\n-    public void setMajor( final int major ) { \/\/ TODO could be package-protected - only called by test code\n-        this.major = major;\n-    }\n-\n-\n-    \/** Set minor version number of class file, default value is 3 (JDK 1.1)\n-     * @param minor minor version number\n+     * Convenience method.\n+     *\n+     * Add an empty constructor to this class that does nothing but calling super().\n+     *\n+     * @param accessFlags rights for constructor\n@@ -261,2 +193,8 @@\n-    public void setMinor( final int minor ) {  \/\/ TODO could be package-protected - only called by test code\n-        this.minor = minor;\n+    public void addEmptyConstructor(final int accessFlags) {\n+        final InstructionList il = new InstructionList();\n+        il.append(InstructionConst.THIS); \/\/ Push 'this'\n+        il.append(new INVOKESPECIAL(cp.addMethodref(superClassName, Const.CONSTRUCTOR_NAME, \"()V\")));\n+        il.append(InstructionConst.RETURN);\n+        final MethodGen mg = new MethodGen(accessFlags, Type.VOID, Type.NO_ARGS, null, Const.CONSTRUCTOR_NAME, className, il, cp);\n+        mg.setMaxStack(1);\n+        addMethod(mg.getMethod());\n@@ -266,1 +204,3 @@\n-     * @return minor version number of class file\n+     * Add a field to this class.\n+     *\n+     * @param f field to add\n@@ -268,2 +208,2 @@\n-    public int getMinor() {\n-        return minor;\n+    public void addField(final Field f) {\n+        fieldList.add(f);\n@@ -272,1 +212,0 @@\n-\n@@ -274,2 +213,3 @@\n-     * Add an attribute to this class.\n-     * @param a attribute to add\n+     * Add an interface to this class, i.e., this class has to implement it.\n+     *\n+     * @param name interface to implement (fully qualified class name)\n@@ -277,6 +217,2 @@\n-    public void addAttribute( final Attribute a ) {\n-        attributeList.add(a);\n-    }\n-\n-    public void addAnnotationEntry(final AnnotationEntryGen a) {\n-        annotationList.add(a);\n+    public void addInterface(final String name) {\n+        interfaceList.add(name);\n@@ -285,1 +221,0 @@\n-\n@@ -288,0 +223,1 @@\n+     *\n@@ -290,1 +226,1 @@\n-    public void addMethod( final Method m ) {\n+    public void addMethod(final Method m) {\n@@ -294,1 +230,0 @@\n-\n@@ -296,4 +231,1 @@\n-     * Convenience method.\n-     *\n-     * Add an empty constructor to this class that does nothing but calling super().\n-     * @param access_flags rights for constructor\n+     * Add observer for this object.\n@@ -301,9 +233,5 @@\n-    public void addEmptyConstructor( final int access_flags ) {\n-        final InstructionList il = new InstructionList();\n-        il.append(InstructionConst.THIS); \/\/ Push `this'\n-        il.append(new INVOKESPECIAL(cp.addMethodref(superClassName, \"<init>\", \"()V\")));\n-        il.append(InstructionConst.RETURN);\n-        final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, \"<init>\",\n-                className, il, cp);\n-        mg.setMaxStack(1);\n-        addMethod(mg.getMethod());\n+    public void addObserver(final ClassObserver o) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n@@ -312,7 +240,7 @@\n-\n-    \/**\n-     * Add a field to this class.\n-     * @param f field to add\n-     *\/\n-    public void addField( final Field f ) {\n-        fieldList.add(f);\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n@@ -321,2 +249,1 @@\n-\n-    public boolean containsField( final Field f ) {\n+    public boolean containsField(final Field f) {\n@@ -326,2 +253,2 @@\n-\n-    \/** @return field object with given name, or null\n+    \/**\n+     * @return field object with given name, or null\n@@ -329,1 +256,1 @@\n-    public Field containsField( final String name ) {\n+    public Field containsField(final String name) {\n@@ -338,2 +265,2 @@\n-\n-    \/** @return method object with given name and signature, or null\n+    \/**\n+     * @return method object with given name and signature, or null\n@@ -341,1 +268,1 @@\n-    public Method containsMethod( final String name, final String signature ) {\n+    public Method containsMethod(final String name, final String signature) {\n@@ -350,1 +277,0 @@\n-\n@@ -352,19 +278,4 @@\n-     * Remove an attribute from this class.\n-     * @param a attribute to remove\n-     *\/\n-    public void removeAttribute( final Attribute a ) {\n-        attributeList.remove(a);\n-    }\n-\n-\n-    \/**\n-     * Remove a method from this class.\n-     * @param m method to remove\n-     *\/\n-    public void removeMethod( final Method m ) {\n-        methodList.remove(m);\n-    }\n-\n-\n-    \/** Replace given method with new one. If the old one does not exist\n-     * add the new_ method to the class anyway.\n+     * Return value as defined by given BCELComparator strategy. By default two ClassGen objects are said to be equal when\n+     * their class names are equal.\n+     *\n+     * @see Object#equals(Object)\n@@ -372,10 +283,3 @@\n-    public void replaceMethod( final Method old, final Method new_ ) {\n-        if (new_ == null) {\n-            throw new ClassGenException(\"Replacement method must not be null\");\n-        }\n-        final int i = methodList.indexOf(old);\n-        if (i < 0) {\n-            methodList.add(new_);\n-        } else {\n-            methodList.set(i, new_);\n-        }\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return bcelComparator.equals(this, obj);\n@@ -384,14 +288,3 @@\n-\n-    \/** Replace given field with new one. If the old one does not exist\n-     * add the new_ field to the class anyway.\n-     *\/\n-    public void replaceField( final Field old, final Field new_ ) {\n-        if (new_ == null) {\n-            throw new ClassGenException(\"Replacement method must not be null\");\n-        }\n-        final int i = fieldList.indexOf(old);\n-        if (i < 0) {\n-            fieldList.add(new_);\n-        } else {\n-            fieldList.set(i, new_);\n-        }\n+    \/\/ J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?\n+    public AnnotationEntryGen[] getAnnotationEntries() {\n+        return annotationList.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n@@ -400,7 +293,2 @@\n-\n-    \/**\n-     * Remove a field to this class.\n-     * @param f field to remove\n-     *\/\n-    public void removeField( final Field f ) {\n-        fieldList.remove(f);\n+    public Attribute[] getAttributes() {\n+        return attributeList.toArray(Attribute.EMPTY_ARRAY);\n@@ -409,1 +297,0 @@\n-\n@@ -414,25 +301,2 @@\n-\n-    public String getSuperclassName() {\n-        return superClassName;\n-    }\n-\n-\n-    public String getFileName() {\n-        return fileName;\n-    }\n-\n-\n-    public void setClassName( final String name ) {\n-        className = name.replace('\/', '.');\n-        classNameIndex = cp.addClass(name);\n-    }\n-\n-\n-    public void setSuperclassName( final String name ) {\n-        superClassName = name.replace('\/', '.');\n-        superclass_name_index = cp.addClass(name);\n-    }\n-\n-\n-    public Method[] getMethods() {\n-        return methodList.toArray(new Method[methodList.size()]);\n+    public int getClassNameIndex() {\n+        return classNameIndex;\n@@ -441,6 +305,2 @@\n-\n-    public void setMethods( final Method[] methods ) {\n-        methodList.clear();\n-        for (final Method method : methods) {\n-            addMethod(method);\n-        }\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n@@ -449,3 +309,2 @@\n-\n-    public void setMethodAt( final Method method, final int pos ) {\n-        methodList.set(pos, method);\n+    public Field[] getFields() {\n+        return fieldList.toArray(Field.EMPTY_ARRAY);\n@@ -454,3 +313,2 @@\n-\n-    public Method getMethodAt( final int pos ) {\n-        return methodList.get(pos);\n+    public String getFileName() {\n+        return fileName;\n@@ -459,1 +317,0 @@\n-\n@@ -461,4 +318,1 @@\n-        final int size = interfaceList.size();\n-        final String[] interfaces = new String[size];\n-        interfaceList.toArray(interfaces);\n-        return interfaces;\n+        return interfaceList.toArray(Const.EMPTY_STRING_ARRAY);\n@@ -467,1 +321,0 @@\n-\n@@ -471,3 +324,1 @@\n-        for (int i = 0; i < size; i++) {\n-            interfaces[i] = cp.addClass(interfaceList.get(i));\n-        }\n+        Arrays.setAll(interfaces, i -> cp.addClass(interfaceList.get(i)));\n@@ -477,8 +328,21 @@\n-\n-    public Field[] getFields() {\n-        return fieldList.toArray(new Field[fieldList.size()]);\n-    }\n-\n-\n-    public Attribute[] getAttributes() {\n-        return attributeList.toArray(new Attribute[attributeList.size()]);\n+    \/**\n+     * @return the (finally) built up Java class object.\n+     *\/\n+    public JavaClass getJavaClass() {\n+        final int[] interfaces = getInterfaces();\n+        final Field[] fields = getFields();\n+        final Method[] methods = getMethods();\n+        Attribute[] attributes = null;\n+        if (annotationList.isEmpty()) {\n+            attributes = getAttributes();\n+        } else {\n+            \/\/ TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'\n+            final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());\n+            attributes = new Attribute[attributeList.size() + annAttributes.length];\n+            attributeList.toArray(attributes);\n+            System.arraycopy(annAttributes, 0, attributes, attributeList.size(), annAttributes.length);\n+        }\n+        \/\/ Must be last since the above calls may still add something to it\n+        final ConstantPool cp = this.cp.getFinalConstantPool();\n+        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor, super.getAccessFlags(), cp, interfaces, fields, methods,\n+            attributes);\n@@ -487,3 +351,5 @@\n-    \/\/  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?\n-    public AnnotationEntryGen[] getAnnotationEntries() {\n-        return annotationList.toArray(new AnnotationEntryGen[annotationList.size()]);\n+    \/**\n+     * @return major version number of class file\n+     *\/\n+    public int getMajor() {\n+        return major;\n@@ -492,3 +358,2 @@\n-\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n+    public Method getMethodAt(final int pos) {\n+        return methodList.get(pos);\n@@ -497,3 +362,2 @@\n-\n-    public void setConstantPool( final ConstantPoolGen constant_pool ) {\n-        cp = constant_pool;\n+    public Method[] getMethods() {\n+        return methodList.toArray(Method.EMPTY_ARRAY);\n@@ -502,5 +366,5 @@\n-\n-    public void setClassNameIndex( final int class_name_index ) {\n-        this.classNameIndex = class_name_index;\n-        className = cp.getConstantPool().getConstantString(class_name_index,\n-                Const.CONSTANT_Class).replace('\/', '.');\n+    \/**\n+     * @return minor version number of class file\n+     *\/\n+    public int getMinor() {\n+        return minor;\n@@ -509,5 +373,2 @@\n-\n-    public void setSuperclassNameIndex( final int superclass_name_index ) {\n-        this.superclass_name_index = superclass_name_index;\n-        superClassName = cp.getConstantPool().getConstantString(superclass_name_index,\n-                Const.CONSTANT_Class).replace('\/', '.');\n+    public String getSuperclassName() {\n+        return superClassName;\n@@ -516,1 +377,0 @@\n-\n@@ -518,1 +378,1 @@\n-        return superclass_name_index;\n+        return superclassNameIndex;\n@@ -521,3 +381,8 @@\n-\n-    public int getClassNameIndex() {\n-        return classNameIndex;\n+    \/**\n+     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n+     *\n+     * @see Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n@@ -526,1 +391,8 @@\n-    private List<ClassObserver> observers;\n+    \/**\n+     * Remove an attribute from this class.\n+     *\n+     * @param a attribute to remove\n+     *\/\n+    public void removeAttribute(final Attribute a) {\n+        attributeList.remove(a);\n+    }\n@@ -528,0 +400,8 @@\n+    \/**\n+     * Remove a field to this class.\n+     *\n+     * @param f field to remove\n+     *\/\n+    public void removeField(final Field f) {\n+        fieldList.remove(f);\n+    }\n@@ -529,1 +409,4 @@\n-    \/** Add observer for this object.\n+    \/**\n+     * Remove an interface from this class.\n+     *\n+     * @param name interface to remove (fully qualified name)\n@@ -531,5 +414,2 @@\n-    public void addObserver( final ClassObserver o ) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n+    public void removeInterface(final String name) {\n+        interfaceList.remove(name);\n@@ -538,0 +418,8 @@\n+    \/**\n+     * Remove a method from this class.\n+     *\n+     * @param m method to remove\n+     *\/\n+    public void removeMethod(final Method m) {\n+        methodList.remove(m);\n+    }\n@@ -539,1 +427,2 @@\n-    \/** Remove observer for this object.\n+    \/**\n+     * Remove observer for this object.\n@@ -541,1 +430,1 @@\n-    public void removeObserver( final ClassObserver o ) {\n+    public void removeObserver(final ClassObserver o) {\n@@ -547,0 +436,14 @@\n+    \/**\n+     * Replace given field with new one. If the old one does not exist add the new_ field to the class anyway.\n+     *\/\n+    public void replaceField(final Field old, final Field newField) {\n+        if (newField == null) {\n+            throw new ClassGenException(\"Replacement method must not be null\");\n+        }\n+        final int i = fieldList.indexOf(old);\n+        if (i < 0) {\n+            fieldList.add(newField);\n+        } else {\n+            fieldList.set(i, newField);\n+        }\n+    }\n@@ -548,3 +451,2 @@\n-    \/** Call notify() method on all observers. This method is not called\n-     * automatically whenever the state has changed, but has to be\n-     * called by the user after he has finished editing the object.\n+    \/**\n+     * Replace given method with new one. If the old one does not exist add the newMethod method to the class anyway.\n@@ -552,5 +454,9 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final ClassObserver observer : observers) {\n-                observer.notify(this);\n-            }\n+    public void replaceMethod(final Method old, final Method newMethod) {\n+        if (newMethod == null) {\n+            throw new ClassGenException(\"Replacement method must not be null\");\n+        }\n+        final int i = methodList.indexOf(old);\n+        if (i < 0) {\n+            methodList.add(newMethod);\n+        } else {\n+            methodList.set(i, newMethod);\n@@ -560,0 +466,4 @@\n+    public void setClassName(final String name) {\n+        className = Utility.pathToPackage(name);\n+        classNameIndex = cp.addClass(name);\n+    }\n@@ -561,7 +471,3 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n+    public void setClassNameIndex(final int classNameIndex) {\n+        this.classNameIndex = classNameIndex;\n+        this.className = Utility.pathToPackage(cp.getConstantPool().getConstantString(classNameIndex, Const.CONSTANT_Class));\n@@ -570,0 +476,3 @@\n+    public void setConstantPool(final ConstantPoolGen constantPool) {\n+        cp = constantPool;\n+    }\n@@ -572,1 +481,3 @@\n-     * @return Comparison strategy object\n+     * Set major version number of class file, default value is 45 (JDK 1.1)\n+     *\n+     * @param major major version number\n@@ -574,2 +485,2 @@\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n+    public void setMajor(final int major) { \/\/ TODO could be package-protected - only called by test code\n+        this.major = major;\n@@ -578,0 +489,8 @@\n+    public void setMethodAt(final Method method, final int pos) {\n+        methodList.set(pos, method);\n+    }\n+\n+    public void setMethods(final Method[] methods) {\n+        methodList.clear();\n+        Collections.addAll(methodList, methods);\n+    }\n@@ -580,1 +499,3 @@\n-     * @param comparator Comparison strategy object\n+     * Set minor version number of class file, default value is 3 (JDK 1.1)\n+     *\n+     * @param minor minor version number\n@@ -582,2 +503,2 @@\n-    public static void setComparator( final BCELComparator comparator ) {\n-        bcelComparator = comparator;\n+    public void setMinor(final int minor) { \/\/ TODO could be package-protected - only called by test code\n+        this.minor = minor;\n@@ -586,0 +507,9 @@\n+    public void setSuperclassName(final String name) {\n+        superClassName = Utility.pathToPackage(name);\n+        superclassNameIndex = cp.addClass(name);\n+    }\n+\n+    public void setSuperclassNameIndex(final int superclassNameIndex) {\n+        this.superclassNameIndex = superclassNameIndex;\n+        superClassName = Utility.pathToPackage(cp.getConstantPool().getConstantString(superclassNameIndex, Const.CONSTANT_Class));\n+    }\n@@ -588,5 +518,1 @@\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default two ClassGen objects are said to be equal when\n-     * their class names are equal.\n-     *\n-     * @see java.lang.Object#equals(java.lang.Object)\n+     * Look for attributes representing annotations and unpack them.\n@@ -594,3 +520,12 @@\n-    @Override\n-    public boolean equals( final Object obj ) {\n-        return bcelComparator.equals(this, obj);\n+    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {\n+        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<>();\n+        for (final Attribute attr : attrs) {\n+            if (attr instanceof RuntimeVisibleAnnotations) {\n+                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n+                rva.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n+            } else if (attr instanceof RuntimeInvisibleAnnotations) {\n+                final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n+                ria.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n+            }\n+        }\n+        return annotationGenObjs.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n@@ -599,1 +534,0 @@\n-\n@@ -601,4 +535,2 @@\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default return the hashcode of the class name.\n-     *\n-     * @see java.lang.Object#hashCode()\n+     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n+     * has to be called by the user after they have finished editing the object.\n@@ -606,3 +538,6 @@\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n+    public void update() {\n+        if (observers != null) {\n+            for (final ClassObserver observer : observers) {\n+                observer.notify(this);\n+            }\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassGen.java","additions":312,"deletions":377,"binary":false,"changes":689,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Thrown on internal errors. Extends RuntimeException so it hasn't to be declared\n- * in the throws clause every time.\n- *\n+ * Thrown on internal exceptions.\n@@ -34,1 +32,0 @@\n-        super();\n@@ -37,1 +34,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassGenException.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,3 +25,2 @@\n- * Implement this interface if you're interested in changes to a ClassGen object\n- * and register yourself with addObserver().\n- *\n+ * Implement this interface if you're interested in changes to a ClassGen object and register yourself with\n+ * addObserver().\n@@ -31,1 +30,1 @@\n-    void notify( ClassGen clazz );\n+    void notify(ClassGen clazz);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassObserver.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,6 +26,4 @@\n- * This class represents an exception handler, i.e., specifies the  region where\n- * a handler is active and an instruction where the actual handling is done.\n- * pool as parameters. Opposed to the JVM specification the end of the handled\n- * region is set to be inclusive, i.e. all instructions between start and end\n- * are protected including the start and end instructions (handles) themselves.\n- * The end of the region is automatically mapped to be exclusive when calling\n+ * This class represents an exception handler, i.e., specifies the region where a handler is active and an instruction\n+ * where the actual handling is done. pool as parameters. Opposed to the JVM specification the end of the handled region\n+ * is set to be inclusive, i.e. all instructions between start and end are protected including the start and end\n+ * instructions (handles) themselves. The end of the region is automatically mapped to be exclusive when calling\n@@ -34,3 +32,3 @@\n- * @see     MethodGen\n- * @see     CodeException\n- * @see     InstructionHandle\n+ * @see MethodGen\n+ * @see CodeException\n+ * @see InstructionHandle\n@@ -40,0 +38,2 @@\n+    static final CodeExceptionGen[] EMPTY_ARRAY = {};\n+\n@@ -45,1 +45,0 @@\n-\n@@ -47,2 +46,2 @@\n-     * Add an exception handler, i.e., specify region where a handler is active and an\n-     * instruction where the actual handling is done.\n+     * Add an exception handler, i.e., specify region where a handler is active and an instruction where the actual handling\n+     * is done.\n@@ -55,2 +54,1 @@\n-    public CodeExceptionGen(final InstructionHandle startPc, final InstructionHandle endPc,\n-            final InstructionHandle handlerPc, final ObjectType catchType) {\n+    public CodeExceptionGen(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc, final ObjectType catchType) {\n@@ -63,0 +61,8 @@\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n+    }\n@@ -65,7 +71,1 @@\n-     * Get CodeException object.<BR>\n-     *\n-     * This relies on that the instruction list has already been dumped\n-     * to byte code or or that the `setPositions' methods has been\n-     * called for the instruction list.\n-     *\n-     * @param cp constant pool\n+     * @return true, if ih is target of this handler\n@@ -73,4 +73,3 @@\n-    public CodeException getCodeException( final ConstantPoolGen cp ) {\n-        return new CodeException(startPc.getPosition(), endPc.getPosition()\n-                + endPc.getInstruction().getLength(), handlerPc.getPosition(),\n-                (catchType == null) ? 0 : cp.addClass(catchType));\n+    @Override\n+    public boolean containsTarget(final InstructionHandle ih) {\n+        return startPc == ih || endPc == ih || handlerPc == ih;\n@@ -79,7 +78,3 @@\n-\n-    \/* Set start of handler\n-     * @param startPc Start of handled region (inclusive)\n-     *\/\n-    public void setStartPC( final InstructionHandle start_pc ) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.startPc, start_pc, this);\n-        this.startPc = start_pc;\n+    \/** Gets the type of the Exception to catch, 'null' for ANY. *\/\n+    public ObjectType getCatchType() {\n+        return catchType;\n@@ -88,3 +83,7 @@\n-\n-    \/* Set end of handler\n-     * @param endPc End of handled region (inclusive)\n+    \/**\n+     * Get CodeException object.<BR>\n+     *\n+     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n+     * has been called for the instruction list.\n+     *\n+     * @param cp constant pool\n@@ -92,3 +91,3 @@\n-    public void setEndPC( final InstructionHandle end_pc ) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.endPc, end_pc, this);\n-        this.endPc = end_pc;\n+    public CodeException getCodeException(final ConstantPoolGen cp) {\n+        return new CodeException(startPc.getPosition(), endPc.getPosition() + endPc.getInstruction().getLength(), handlerPc.getPosition(),\n+            catchType == null ? 0 : cp.addClass(catchType));\n@@ -97,3 +96,2 @@\n-\n-    \/* Set handler code\n-     * @param handlerPc Start of handler\n+    \/**\n+     * @return end of handled region (inclusive)\n@@ -101,3 +99,2 @@\n-    public void setHandlerPC( final InstructionHandle handler_pc ) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.handlerPc, handler_pc, this);\n-        this.handlerPc = handler_pc;\n+    public InstructionHandle getEndPC() {\n+        return endPc;\n@@ -106,1 +103,0 @@\n-\n@@ -108,2 +104,1 @@\n-     * @param old_ih old target, either start or end\n-     * @param new_ih new target\n+     * @return start of handler\n@@ -111,19 +106,2 @@\n-    @Override\n-    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n-        boolean targeted = false;\n-        if (startPc == old_ih) {\n-            targeted = true;\n-            setStartPC(new_ih);\n-        }\n-        if (endPc == old_ih) {\n-            targeted = true;\n-            setEndPC(new_ih);\n-        }\n-        if (handlerPc == old_ih) {\n-            targeted = true;\n-            setHandlerPC(new_ih);\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + old_ih + \", but {\" + startPc + \", \"\n-                    + endPc + \", \" + handlerPc + \"}\");\n-        }\n+    public InstructionHandle getHandlerPC() {\n+        return handlerPc;\n@@ -132,1 +110,0 @@\n-\n@@ -134,1 +111,1 @@\n-     * @return true, if ih is target of this handler\n+     * @return start of handled region (inclusive)\n@@ -136,3 +113,2 @@\n-    @Override\n-    public boolean containsTarget( final InstructionHandle ih ) {\n-        return (startPc == ih) || (endPc == ih) || (handlerPc == ih);\n+    public InstructionHandle getStartPC() {\n+        return startPc;\n@@ -141,1 +117,0 @@\n-\n@@ -143,1 +118,1 @@\n-    public void setCatchType( final ObjectType catchType ) {\n+    public void setCatchType(final ObjectType catchType) {\n@@ -147,8 +122,4 @@\n-\n-    \/** Gets the type of the Exception to catch, 'null' for ANY. *\/\n-    public ObjectType getCatchType() {\n-        return catchType;\n-    }\n-\n-\n-    \/** @return start of handled region (inclusive)\n+    \/*\n+     * Set end of handler\n+     *\n+     * @param endPc End of handled region (inclusive)\n@@ -156,2 +127,3 @@\n-    public InstructionHandle getStartPC() {\n-        return startPc;\n+    public void setEndPC(final InstructionHandle endPc) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.endPc, endPc, this);\n+        this.endPc = endPc;\n@@ -160,2 +132,4 @@\n-\n-    \/** @return end of handled region (inclusive)\n+    \/*\n+     * Set handler code\n+     *\n+     * @param handlerPc Start of handler\n@@ -163,2 +137,3 @@\n-    public InstructionHandle getEndPC() {\n-        return endPc;\n+    public void setHandlerPC(final InstructionHandle handlerPc) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.handlerPc, handlerPc, this);\n+        this.handlerPc = handlerPc;\n@@ -167,2 +142,4 @@\n-\n-    \/** @return start of handler\n+    \/*\n+     * Set start of handler\n+     *\n+     * @param startPc Start of handled region (inclusive)\n@@ -170,2 +147,3 @@\n-    public InstructionHandle getHandlerPC() {\n-        return handlerPc;\n+    public void setStartPC(final InstructionHandle startPc) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.startPc, startPc, this);\n+        this.startPc = startPc;\n@@ -174,1 +152,0 @@\n-\n@@ -180,1 +157,4 @@\n-\n+    \/**\n+     * @param oldIh old target, either start or end\n+     * @param newIh new target\n+     *\/\n@@ -182,5 +162,16 @@\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n+        boolean targeted = false;\n+        if (startPc == oldIh) {\n+            targeted = true;\n+            setStartPC(newIh);\n+        }\n+        if (endPc == oldIh) {\n+            targeted = true;\n+            setEndPC(newIh);\n+        }\n+        if (handlerPc == oldIh) {\n+            targeted = true;\n+            setHandlerPC(newIh);\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + oldIh + \", but {\" + startPc + \", \" + endPc + \", \" + handlerPc + \"}\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CodeExceptionGen.java","additions":89,"deletions":98,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -25,6 +25,4 @@\n- * Wrapper class for `compound' operations, virtual instructions that\n- * don't exist as byte code, but give a useful meaning. For example,\n- * the (virtual) PUSH instruction takes an arbitray argument and produces the\n- * appropiate code at dump time (ICONST, LDC, BIPUSH, ...). Also you can use the\n- * SWITCH instruction as a useful template for either LOOKUPSWITCH or\n- * TABLESWITCH.\n+ * Wrapper class for 'compound' operations, virtual instructions that don't exist as byte code, but give a useful\n+ * meaning. For example, the (virtual) PUSH instruction takes an arbitrary argument and produces the appropriate code at\n+ * dump time (ICONST, LDC, BIPUSH, ...). Also you can use the SWITCH instruction as a useful template for either\n+ * LOOKUPSWITCH or TABLESWITCH.\n@@ -32,2 +30,1 @@\n- * The interface provides the possibilty for the user to write\n- * `templates' or `macros' for such reuseable code patterns.\n+ * The interface provides the possibility for the user to write 'templates' or 'macros' for such reusable code patterns.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CompoundInstruction.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,0 +22,1 @@\n+import java.util.Arrays;\n@@ -30,0 +31,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.ConstantDynamic;\n@@ -41,0 +43,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -43,8 +46,5 @@\n- * This class is used to build up a constant pool. The user adds\n- * constants via `addXXX' methods, `addString', `addClass',\n- * etc.. These methods return an index into the constant\n- * pool. Finally, `getFinalConstantPool()' returns the constant pool\n- * built up. Intermediate versions of the constant pool can be\n- * obtained with `getConstantPool()'. A constant pool has capacity for\n- * Constants.MAX_SHORT entries. Note that the first (0) is used by the\n- * JVM and that Double and Long constants need two slots.\n+ * This class is used to build up a constant pool. The user adds constants via 'addXXX' methods, 'addString',\n+ * 'addClass', etc.. These methods return an index into the constant pool. Finally, 'getFinalConstantPool()' returns the\n+ * constant pool built up. Intermediate versions of the constant pool can be obtained with 'getConstantPool()'. A\n+ * constant pool has capacity for Constants.MAX_SHORT entries. Note that the first (0) is used by the JVM and that\n+ * Double and Long constants need two slots.\n@@ -53,1 +53,1 @@\n- * @LastModified: June 2022\n+ * @LastModified: Feb 2023\n@@ -56,1 +56,1 @@\n-    public static final int CONSTANT_POOL_SIZE = 65535;\n+\n@@ -58,3 +58,0 @@\n-    private int size;\n-    private Constant[] constants;\n-    private int index = 1; \/\/ First entry (0) used by JVM\n@@ -63,0 +60,1 @@\n+\n@@ -64,0 +62,1 @@\n+\n@@ -65,0 +64,1 @@\n+\n@@ -67,1 +67,5 @@\n-    private static class Index {\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int size;\n@@ -69,1 +73,5 @@\n-        final int index;\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected Constant[] constants;\n@@ -71,0 +79,5 @@\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getSize()\n+     *\/\n+    @Deprecated\n+    protected int index = 1; \/\/ First entry (0) used by JVM\n@@ -72,4 +85,7 @@\n-        Index(final int i) {\n-            index = i;\n-        }\n-    }\n+    private final Map<String, Integer> stringTable = new HashMap<>();\n+\n+    private final Map<String, Integer> classTable = new HashMap<>();\n+\n+    private final Map<String, Integer> utf8Table = new HashMap<>();\n+\n+    private final Map<String, Integer> natTable = new HashMap<>();\n@@ -77,0 +93,1 @@\n+    private final Map<String, Integer> cpTable = new HashMap<>();\n@@ -79,1 +96,9 @@\n-     * Initialize with given array of constants.\n+     * Constructs a new empty constant pool.\n+     *\/\n+    public ConstantPoolGen() {\n+        size = DEFAULT_BUFFER_SIZE;\n+        constants = new Constant[size];\n+    }\n+\n+    \/**\n+     * Constructs a new instance with the given array of constants.\n@@ -91,2 +116,2 @@\n-        if (cs.length > CONSTANT_POOL_SIZE) {\n-            throw new RuntimeException(\"The number of constants \" + cs.length\n+        if (cs.length > Const.MAX_CP_ENTRIES) {\n+            throw new IllegalStateException(\"The number of constants \" + cs.length\n@@ -94,1 +119,1 @@\n-                    + CONSTANT_POOL_SIZE);\n+                    + Const.MAX_CP_ENTRIES);\n@@ -99,1 +124,1 @@\n-        size = Math.min(Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64), CONSTANT_POOL_SIZE);\n+        size = Math.min(Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64), Const.MAX_CP_ENTRIES);\n@@ -107,1 +132,0 @@\n-\n@@ -115,1 +139,1 @@\n-                    stringTable.put(key, new Index(i));\n+                    stringTable.put(key, Integer.valueOf(i));\n@@ -122,1 +146,1 @@\n-                    classTable.put(key, new Index(i));\n+                    classTable.put(key, Integer.valueOf(i));\n@@ -126,2 +150,2 @@\n-                final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n-                final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n+                final ConstantUtf8 u8NameIdx = (ConstantUtf8) constants[n.getNameIndex()];\n+                final ConstantUtf8 u8SigIdx = (ConstantUtf8) constants[n.getSignatureIndex()];\n@@ -129,1 +153,1 @@\n-                sb.append(u8.getBytes());\n+                sb.append(u8NameIdx.getBytes());\n@@ -131,1 +155,1 @@\n-                sb.append(u8_2.getBytes());\n+                sb.append(u8SigIdx.getBytes());\n@@ -136,1 +160,1 @@\n-                    natTable.put(key, new Index(i));\n+                    natTable.put(key, Integer.valueOf(i));\n@@ -142,1 +166,1 @@\n-                    utf8Table.put(key, new Index(i));\n+                    utf8Table.put(key, Integer.valueOf(i));\n@@ -146,1 +170,1 @@\n-                String class_name;\n+                String className;\n@@ -150,3 +174,3 @@\n-                    class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());\n-                    \/\/ since name can't begin with digit, can  use\n-                    \/\/ METHODREF_DELIM with out fear of duplicates.\n+                    className = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());\n+                } else if (c instanceof ConstantDynamic) {\n+                    className = Integer.toString(((ConstantDynamic) m).getBootstrapMethodAttrIndex());\n@@ -154,1 +178,1 @@\n-                final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n+                    final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n@@ -156,1 +180,1 @@\n-                    class_name = u8.getBytes().replace('\/', '.');\n+                    className = Utility.pathToPackage(u8.getBytes());\n@@ -161,1 +185,1 @@\n-                final String method_name = u8.getBytes();\n+                final String methodName = u8.getBytes();\n@@ -165,0 +189,1 @@\n+                \/\/ Since name cannot begin with digit, we can use METHODREF_DELIM without fear of duplicates\n@@ -172,1 +197,1 @@\n-                sb.append(class_name);\n+                sb.append(className);\n@@ -174,1 +199,1 @@\n-                sb.append(method_name);\n+                sb.append(methodName);\n@@ -181,1 +206,1 @@\n-                    cpTable.put(key, new Index(i));\n+                    cpTable.put(key, Integer.valueOf(i));\n@@ -183,20 +208,0 @@\n-            } else if (c == null) { \/\/ entries may be null\n-                \/\/ nothing to do\n-            } else if (c instanceof ConstantInteger) {\n-                \/\/ nothing to do\n-            } else if (c instanceof ConstantLong) {\n-                \/\/ nothing to do\n-            } else if (c instanceof ConstantFloat) {\n-                \/\/ nothing to do\n-            } else if (c instanceof ConstantDouble) {\n-                \/\/ nothing to do\n-            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {\n-                \/\/ TODO should this be handled somehow?\n-            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {\n-                \/\/ TODO should this be handled somehow?\n-            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {\n-                \/\/ TODO should this be handled somehow?\n-            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {\n-                \/\/ TODO should this be handled somehow?\n-            } else {\n-                assert false : \"Unexpected constant type: \" + c.getClass().getName();\n@@ -204,0 +209,22 @@\n+\/\/            else if (c == null) { \/\/ entries may be null\n+\/\/                \/\/ nothing to do\n+\/\/            } else if (c instanceof ConstantInteger) {\n+\/\/                \/\/ nothing to do\n+\/\/            } else if (c instanceof ConstantLong) {\n+\/\/                \/\/ nothing to do\n+\/\/            } else if (c instanceof ConstantFloat) {\n+\/\/                \/\/ nothing to do\n+\/\/            } else if (c instanceof ConstantDouble) {\n+\/\/                \/\/ nothing to do\n+\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {\n+\/\/                \/\/ TODO should this be handled somehow?\n+\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {\n+\/\/                \/\/ TODO should this be handled somehow?\n+\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {\n+\/\/                \/\/ TODO should this be handled somehow?\n+\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {\n+\/\/                \/\/ TODO should this be handled somehow?\n+\/\/            } else {\n+\/\/                \/\/ Not helpful, should throw an exception.\n+\/\/                assert false : \"Unexpected constant type: \" + c.getClass().getName();\n+\/\/            }\n@@ -207,1 +234,0 @@\n-\n@@ -209,1 +235,3 @@\n-     * Initialize with given constant pool.\n+     * Constructs a new instance with the given constant pool.\n+     *\n+     * @param cp the constant pool.\n@@ -215,1 +243,0 @@\n-\n@@ -217,33 +244,2 @@\n-     * Create empty constant pool.\n-     *\/\n-    public ConstantPoolGen() {\n-        size = DEFAULT_BUFFER_SIZE;\n-        constants = new Constant[size];\n-    }\n-\n-\n-    \/** Resize internal array of constants.\n-     *\/\n-    protected void adjustSize() {\n-        \/\/ 3 extra spaces are needed as some entries may take 3 slots\n-        if (index + 3 >= CONSTANT_POOL_SIZE) {\n-            throw new RuntimeException(\"The number of constants \" + (index + 3)\n-                    + \" is over the size limit of the constant pool: \"\n-                    + CONSTANT_POOL_SIZE);\n-        }\n-\n-        if (index + 3 >= size) {\n-            final Constant[] cs = constants;\n-            size *= 2;\n-            \/\/ the constant array shall not exceed the size of the constant pool\n-            size = Math.min(size, CONSTANT_POOL_SIZE);\n-            constants = new Constant[size];\n-            System.arraycopy(cs, 0, constants, 0, index);\n-        }\n-    }\n-\n-    private final Map<String, Index> stringTable = new HashMap<>();\n-\n-\n-    \/**\n-     * Look for ConstantString in ConstantPool containing String `str'.\n+     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY instruction, e.g. to the\n+     * ConstantPool.\n@@ -251,2 +247,2 @@\n-     * @param str String to search for\n-     * @return index on success, -1 otherwise\n+     * @param type type of array class\n+     * @return index of entry\n@@ -254,3 +250,2 @@\n-    public int lookupString( final String str ) {\n-        final Index index = stringTable.get(str);\n-        return (index != null) ? index.index : -1;\n+    public int addArrayClass(final ArrayType type) {\n+        return addClass_(type.getSignature());\n@@ -259,1 +254,0 @@\n-\n@@ -261,1 +255,1 @@\n-     * Add a new String constant to the ConstantPool, if it is not already in there.\n+     * Add a new Class reference to the ConstantPool for a given type.\n@@ -263,1 +257,1 @@\n-     * @param str String to add\n+     * @param type Class to add\n@@ -266,14 +260,2 @@\n-    public int addString( final String str ) {\n-        int ret;\n-        if ((ret = lookupString(str)) != -1) {\n-            return ret; \/\/ Already in CP\n-        }\n-        final int utf8 = addUtf8(str);\n-        adjustSize();\n-        final ConstantString s = new ConstantString(utf8);\n-        ret = index;\n-        constants[index++] = s;\n-        if (!stringTable.containsKey(str)) {\n-            stringTable.put(str, new Index(ret));\n-        }\n-        return ret;\n+    public int addClass(final ObjectType type) {\n+        return addClass(type.getClassName());\n@@ -282,3 +264,0 @@\n-    private final Map<String, Index> classTable = new HashMap<>();\n-\n-\n@@ -286,1 +265,1 @@\n-     * Look for ConstantClass in ConstantPool named `str'.\n+     * Add a new Class reference to the ConstantPool, if it is not already in there.\n@@ -288,2 +267,2 @@\n-     * @param str String to search for\n-     * @return index on success, -1 otherwise\n+     * @param str Class to add\n+     * @return index of entry\n@@ -291,3 +270,2 @@\n-    public int lookupClass( final String str ) {\n-        final Index index = classTable.get(str.replace('.', '\/'));\n-        return (index != null) ? index.index : -1;\n+    public int addClass(final String str) {\n+        return addClass_(Utility.packageToPath(str));\n@@ -296,5 +274,4 @@\n-\n-    private int addClass_( final String clazz ) {\n-        int ret;\n-        if ((ret = lookupClass(clazz)) != -1) {\n-            return ret; \/\/ Already in CP\n+    private int addClass_(final String clazz) {\n+        final int cpRet;\n+        if ((cpRet = lookupClass(clazz)) != -1) {\n+            return cpRet; \/\/ Already in CP\n@@ -304,1 +281,1 @@\n-        ret = index;\n+        final int ret = index;\n@@ -306,26 +283,1 @@\n-        if (!classTable.containsKey(clazz)) {\n-            classTable.put(clazz, new Index(ret));\n-        }\n-        return ret;\n-    }\n-\n-\n-    \/**\n-     * Add a new Class reference to the ConstantPool, if it is not already in there.\n-     *\n-     * @param str Class to add\n-     * @return index of entry\n-     *\/\n-    public int addClass( final String str ) {\n-        return addClass_(str.replace('.', '\/'));\n-    }\n-\n-\n-    \/**\n-     * Add a new Class reference to the ConstantPool for a given type.\n-     *\n-     * @param type Class to add\n-     * @return index of entry\n-     *\/\n-    public int addClass( final ObjectType type ) {\n-        return addClass(type.getClassName());\n+        return computeIfAbsent(classTable, clazz, ret);\n@@ -334,1 +286,0 @@\n-\n@@ -336,2 +287,1 @@\n-     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY\n-     * instruction, e.g. to the ConstantPool.\n+     * Adds a constant from another ConstantPool and returns the new index.\n@@ -339,1 +289,2 @@\n-     * @param type type of array class\n+     * @param constant The constant to add.\n+     * @param cpGen Source pool.\n@@ -342,18 +293,50 @@\n-    public int addArrayClass( final ArrayType type ) {\n-        return addClass_(type.getSignature());\n-    }\n-\n-\n-    \/**\n-     * Look for ConstantInteger in ConstantPool.\n-     *\n-     * @param n integer number to look for\n-     * @return index on success, -1 otherwise\n-     *\/\n-    public int lookupInteger( final int n ) {\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantInteger) {\n-                final ConstantInteger c = (ConstantInteger) constants[i];\n-                if (c.getBytes() == n) {\n-                    return i;\n-                }\n+    public int addConstant(final Constant constant, final ConstantPoolGen cpGen) {\n+        final Constant[] constants = cpGen.getConstantPool().getConstantPool();\n+        switch (constant.getTag()) {\n+        case Const.CONSTANT_String: {\n+            final ConstantString s = (ConstantString) constant;\n+            final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];\n+            return addString(u8.getBytes());\n+        }\n+        case Const.CONSTANT_Class: {\n+            final ConstantClass s = (ConstantClass) constant;\n+            final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];\n+            return addClass(u8.getBytes());\n+        }\n+        case Const.CONSTANT_NameAndType: {\n+            final ConstantNameAndType n = (ConstantNameAndType) constant;\n+            final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+            final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n+            return addNameAndType(u8.getBytes(), u8_2.getBytes());\n+        }\n+        case Const.CONSTANT_Utf8:\n+            return addUtf8(((ConstantUtf8) constant).getBytes());\n+        case Const.CONSTANT_Double:\n+            return addDouble(((ConstantDouble) constant).getBytes());\n+        case Const.CONSTANT_Float:\n+            return addFloat(((ConstantFloat) constant).getBytes());\n+        case Const.CONSTANT_Long:\n+            return addLong(((ConstantLong) constant).getBytes());\n+        case Const.CONSTANT_Integer:\n+            return addInteger(((ConstantInteger) constant).getBytes());\n+        case Const.CONSTANT_InterfaceMethodref:\n+        case Const.CONSTANT_Methodref:\n+        case Const.CONSTANT_Fieldref: {\n+            final ConstantCP m = (ConstantCP) constant;\n+            final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n+            final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];\n+            ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];\n+            final String className = Utility.pathToPackage(u8.getBytes());\n+            u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+            final String name = u8.getBytes();\n+            u8 = (ConstantUtf8) constants[n.getSignatureIndex()];\n+            final String signature = u8.getBytes();\n+            switch (constant.getTag()) {\n+            case Const.CONSTANT_InterfaceMethodref:\n+                return addInterfaceMethodref(className, name, signature);\n+            case Const.CONSTANT_Methodref:\n+                return addMethodref(className, name, signature);\n+            case Const.CONSTANT_Fieldref:\n+                return addFieldref(className, name, signature);\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown constant type \" + constant);\n@@ -362,1 +345,3 @@\n-        return -1;\n+        default: \/\/ Never reached\n+            throw new IllegalArgumentException(\"Unknown constant type \" + constant);\n+        }\n@@ -365,1 +350,0 @@\n-\n@@ -367,1 +351,1 @@\n-     * Add a new Integer constant to the ConstantPool, if it is not already in there.\n+     * Add a new double constant to the ConstantPool, if it is not already in there.\n@@ -369,1 +353,1 @@\n-     * @param n integer number to add\n+     * @param n Double number to add\n@@ -372,1 +356,1 @@\n-    public int addInteger( final int n ) {\n+    public int addDouble(final double n) {\n@@ -374,1 +358,1 @@\n-        if ((ret = lookupInteger(n)) != -1) {\n+        if ((ret = lookupDouble(n)) != -1) {\n@@ -379,1 +363,2 @@\n-        constants[index++] = new ConstantInteger(n);\n+        constants[index] = new ConstantDouble(n);\n+        index += 2; \/\/ Wastes one entry according to spec\n@@ -383,1 +368,0 @@\n-\n@@ -385,1 +369,1 @@\n-     * Look for ConstantFloat in ConstantPool.\n+     * Add a new Fieldref constant to the ConstantPool, if it is not already in there.\n@@ -387,2 +371,4 @@\n-     * @param n Float number to look for\n-     * @return index on success, -1 otherwise\n+     * @param className class name string to add\n+     * @param fieldName field name string to add\n+     * @param signature signature string to add\n+     * @return index of entry\n@@ -390,9 +376,4 @@\n-    public int lookupFloat( final float n ) {\n-        final int bits = Float.floatToIntBits(n);\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantFloat) {\n-                final ConstantFloat c = (ConstantFloat) constants[i];\n-                if (Float.floatToIntBits(c.getBytes()) == bits) {\n-                    return i;\n-                }\n-            }\n+    public int addFieldref(final String className, final String fieldName, final String signature) {\n+        final int cpRet;\n+        if ((cpRet = lookupFieldref(className, fieldName, signature)) != -1) {\n+            return cpRet; \/\/ Already in CP\n@@ -400,1 +381,6 @@\n-        return -1;\n+        adjustSize();\n+        final int classIndex = addClass(className);\n+        final int nameAndTypeIndex = addNameAndType(fieldName, signature);\n+        final int ret = index;\n+        constants[index++] = new ConstantFieldref(classIndex, nameAndTypeIndex);\n+        return computeIfAbsent(cpTable, className + FIELDREF_DELIM + fieldName + FIELDREF_DELIM + signature, ret);\n@@ -403,1 +389,0 @@\n-\n@@ -410,1 +395,1 @@\n-    public int addFloat( final float n ) {\n+    public int addFloat(final float n) {\n@@ -421,15 +406,0 @@\n-    private final Map<String, Index> utf8Table = new HashMap<>();\n-\n-\n-    \/**\n-     * Look for ConstantUtf8 in ConstantPool.\n-     *\n-     * @param n Utf8 string to look for\n-     * @return index on success, -1 otherwise\n-     *\/\n-    public int lookupUtf8( final String n ) {\n-        final Index index = utf8Table.get(n);\n-        return (index != null) ? index.index : -1;\n-    }\n-\n-\n@@ -437,1 +407,1 @@\n-     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.\n+     * Add a new Integer constant to the ConstantPool, if it is not already in there.\n@@ -439,1 +409,1 @@\n-     * @param n Utf8 string to add\n+     * @param n integer number to add\n@@ -442,1 +412,1 @@\n-    public int addUtf8( final String n ) {\n+    public int addInteger(final int n) {\n@@ -444,1 +414,1 @@\n-        if ((ret = lookupUtf8(n)) != -1) {\n+        if ((ret = lookupInteger(n)) != -1) {\n@@ -449,4 +419,1 @@\n-        constants[index++] = new ConstantUtf8(n);\n-        if (!utf8Table.containsKey(n)) {\n-            utf8Table.put(n, new Index(ret));\n-        }\n+        constants[index++] = new ConstantInteger(n);\n@@ -456,0 +423,3 @@\n+    public int addInterfaceMethodref(final MethodGen method) {\n+        return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n+    }\n@@ -458,1 +428,1 @@\n-     * Look for ConstantLong in ConstantPool.\n+     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already in there.\n@@ -460,2 +430,4 @@\n-     * @param n Long number to look for\n-     * @return index on success, -1 otherwise\n+     * @param className class name string to add\n+     * @param methodName method name string to add\n+     * @param signature signature string to add\n+     * @return index of entry\n@@ -463,8 +435,4 @@\n-    public int lookupLong( final long n ) {\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantLong) {\n-                final ConstantLong c = (ConstantLong) constants[i];\n-                if (c.getBytes() == n) {\n-                    return i;\n-                }\n-            }\n+    public int addInterfaceMethodref(final String className, final String methodName, final String signature) {\n+        final int cpRet;\n+        if ((cpRet = lookupInterfaceMethodref(className, methodName, signature)) != -1) {\n+            return cpRet; \/\/ Already in CP\n@@ -472,1 +440,6 @@\n-        return -1;\n+        adjustSize();\n+        final int classIndex = addClass(className);\n+        final int nameAndTypeIndex = addNameAndType(methodName, signature);\n+        final int ret = index;\n+        constants[index++] = new ConstantInterfaceMethodref(classIndex, nameAndTypeIndex);\n+        return computeIfAbsent(cpTable, className + IMETHODREF_DELIM + methodName + IMETHODREF_DELIM + signature, ret);\n@@ -475,1 +448,0 @@\n-\n@@ -482,1 +454,1 @@\n-    public int addLong( final long n ) {\n+    public int addLong(final long n) {\n@@ -493,1 +465,3 @@\n-\n+    public int addMethodref(final MethodGen method) {\n+        return addMethodref(method.getClassName(), method.getName(), method.getSignature());\n+    }\n@@ -496,1 +470,1 @@\n-     * Look for ConstantDouble in ConstantPool.\n+     * Add a new Methodref constant to the ConstantPool, if it is not already in there.\n@@ -498,2 +472,4 @@\n-     * @param n Double number to look for\n-     * @return index on success, -1 otherwise\n+     * @param className class name string to add\n+     * @param methodName method name string to add\n+     * @param signature method signature string to add\n+     * @return index of entry\n@@ -501,9 +477,4 @@\n-    public int lookupDouble( final double n ) {\n-        final long bits = Double.doubleToLongBits(n);\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantDouble) {\n-                final ConstantDouble c = (ConstantDouble) constants[i];\n-                if (Double.doubleToLongBits(c.getBytes()) == bits) {\n-                    return i;\n-                }\n-            }\n+    public int addMethodref(final String className, final String methodName, final String signature) {\n+        final int cpRet;\n+        if ((cpRet = lookupMethodref(className, methodName, signature)) != -1) {\n+            return cpRet; \/\/ Already in CP\n@@ -511,1 +482,6 @@\n-        return -1;\n+        adjustSize();\n+        final int nameAndTypeIndex = addNameAndType(methodName, signature);\n+        final int classIndex = addClass(className);\n+        final int ret = index;\n+        constants[index++] = new ConstantMethodref(classIndex, nameAndTypeIndex);\n+        return computeIfAbsent(cpTable, className + METHODREF_DELIM + methodName + METHODREF_DELIM + signature, ret);\n@@ -514,1 +490,0 @@\n-\n@@ -516,1 +491,1 @@\n-     * Add a new double constant to the ConstantPool, if it is not already in there.\n+     * Add a new NameAndType constant to the ConstantPool if it is not already in there.\n@@ -518,1 +493,2 @@\n-     * @param n Double number to add\n+     * @param name Name string to add\n+     * @param signature signature string to add\n@@ -521,1 +497,1 @@\n-    public int addDouble( final double n ) {\n+    public int addNameAndType(final String name, final String signature) {\n@@ -523,1 +499,1 @@\n-        if ((ret = lookupDouble(n)) != -1) {\n+        if ((ret = lookupNameAndType(name, signature)) != -1) {\n@@ -527,0 +503,2 @@\n+        final int nameIndex = addUtf8(name);\n+        final int signatureIndex = addUtf8(signature);\n@@ -528,3 +506,2 @@\n-        constants[index] = new ConstantDouble(n);\n-        index += 2; \/\/ Wastes one entry according to spec\n-        return ret;\n+        constants[index++] = new ConstantNameAndType(nameIndex, signatureIndex);\n+        return computeIfAbsent(natTable, name + NAT_DELIM + signature, ret);\n@@ -533,3 +510,0 @@\n-    private final Map<String, Index> natTable = new HashMap<>();\n-\n-\n@@ -537,1 +511,1 @@\n-     * Look for ConstantNameAndType in ConstantPool.\n+     * Add a new String constant to the ConstantPool, if it is not already in there.\n@@ -539,3 +513,2 @@\n-     * @param name of variable\/method\n-     * @param signature of variable\/method\n-     * @return index on success, -1 otherwise\n+     * @param str String to add\n+     * @return index of entry\n@@ -543,3 +516,11 @@\n-    public int lookupNameAndType( final String name, final String signature ) {\n-        final Index _index = natTable.get(name + NAT_DELIM + signature);\n-        return (_index != null) ? _index.index : -1;\n+    public int addString(final String str) {\n+        int ret;\n+        if ((ret = lookupString(str)) != -1) {\n+            return ret; \/\/ Already in CP\n+        }\n+        final int utf8 = addUtf8(str);\n+        adjustSize();\n+        final ConstantString s = new ConstantString(utf8);\n+        ret = index;\n+        constants[index++] = s;\n+        return computeIfAbsent(stringTable, str, ret);\n@@ -548,1 +529,0 @@\n-\n@@ -550,2 +530,1 @@\n-     * Add a new NameAndType constant to the ConstantPool if it is not already\n-     * in there.\n+     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.\n@@ -553,2 +532,1 @@\n-     * @param name Name string to add\n-     * @param signature signature string to add\n+     * @param n Utf8 string to add\n@@ -557,1 +535,1 @@\n-    public int addNameAndType( final String name, final String signature ) {\n+    public int addUtf8(final String n) {\n@@ -559,3 +537,1 @@\n-        int name_index;\n-        int signature_index;\n-        if ((ret = lookupNameAndType(name, signature)) != -1) {\n+        if ((ret = lookupUtf8(n)) != -1) {\n@@ -565,2 +541,0 @@\n-        name_index = addUtf8(name);\n-        signature_index = addUtf8(signature);\n@@ -568,4 +542,22 @@\n-        constants[index++] = new ConstantNameAndType(name_index, signature_index);\n-        final String key = name + NAT_DELIM + signature;\n-        if (!natTable.containsKey(key)) {\n-            natTable.put(key, new Index(ret));\n+        constants[index++] = new ConstantUtf8(n);\n+        return computeIfAbsent(utf8Table, n, ret);\n+    }\n+\n+    \/**\n+     * Resize internal array of constants.\n+     *\/\n+    protected void adjustSize() {\n+        \/\/ 3 extra spaces are needed as some entries may take 3 slots\n+        if (index + 3 >= Const.MAX_CP_ENTRIES) {\n+            throw new IllegalStateException(\"The number of constants \" + (index + 3)\n+                    + \" is over the size limit of the constant pool: \"\n+                    + Const.MAX_CP_ENTRIES);\n+        }\n+\n+        if (index + 3 >= size) {\n+            final Constant[] cs = constants;\n+            size *= 2;\n+            \/\/ the constant array shall not exceed the size of the constant pool\n+            size = Math.min(size, Const.MAX_CP_ENTRIES);\n+            constants = new Constant[size];\n+            System.arraycopy(cs, 0, constants, 0, index);\n@@ -573,1 +565,0 @@\n-        return ret;\n@@ -576,1 +567,3 @@\n-    private final Map<String, Index> cpTable = new HashMap<>();\n+    private int computeIfAbsent(final Map<String, Integer> map, final String key, final int value) {\n+        return map.computeIfAbsent(key, k -> Integer.valueOf(value));\n+    }\n@@ -578,0 +571,7 @@\n+    \/**\n+     * @param i index in constant pool\n+     * @return constant pool entry at index i\n+     *\/\n+    public Constant getConstant(final int i) {\n+        return constants[i];\n+    }\n@@ -580,6 +580,1 @@\n-     * Look for ConstantMethodref in ConstantPool.\n-     *\n-     * @param class_name Where to find method\n-     * @param method_name Guess what\n-     * @param signature return and argument types\n-     * @return index on success, -1 otherwise\n+     * @return intermediate constant pool\n@@ -587,4 +582,2 @@\n-    public int lookupMethodref( final String class_name, final String method_name, final String signature ) {\n-        final Index index = cpTable.get(class_name + METHODREF_DELIM + method_name\n-                + METHODREF_DELIM + signature);\n-        return (index != null) ? index.index : -1;\n+    public ConstantPool getConstantPool() {\n+        return new ConstantPool(constants);\n@@ -593,0 +586,6 @@\n+    \/**\n+     * @return constant pool with proper length\n+     *\/\n+    public ConstantPool getFinalConstantPool() {\n+        return new ConstantPool(Arrays.copyOf(constants, index));\n+    }\n@@ -594,2 +593,2 @@\n-    public int lookupMethodref( final MethodGen method ) {\n-        return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());\n+    private int getIndex(final Map<String, Integer> map, final String key) {\n+        return toIndex(map.get(key));\n@@ -598,0 +597,6 @@\n+    \/**\n+     * @return current size of constant pool\n+     *\/\n+    public int getSize() {\n+        return index;\n+    }\n@@ -600,2 +605,1 @@\n-     * Add a new Methodref constant to the ConstantPool, if it is not already\n-     * in there.\n+     * Look for ConstantClass in ConstantPool named 'str'.\n@@ -603,4 +607,2 @@\n-     * @param class_name class name string to add\n-     * @param method_name method name string to add\n-     * @param signature method signature string to add\n-     * @return index of entry\n+     * @param str String to search for\n+     * @return index on success, -1 otherwise\n@@ -608,17 +610,2 @@\n-    public int addMethodref( final String class_name, final String method_name, final String signature ) {\n-        int ret;\n-        int class_index;\n-        int name_and_type_index;\n-        if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {\n-            return ret; \/\/ Already in CP\n-        }\n-        adjustSize();\n-        name_and_type_index = addNameAndType(method_name, signature);\n-        class_index = addClass(class_name);\n-        ret = index;\n-        constants[index++] = new ConstantMethodref(class_index, name_and_type_index);\n-        final String key = class_name + METHODREF_DELIM + method_name + METHODREF_DELIM + signature;\n-        if (!cpTable.containsKey(key)) {\n-            cpTable.put(key, new Index(ret));\n-        }\n-        return ret;\n+    public int lookupClass(final String str) {\n+        return getIndex(classTable, Utility.packageToPath(str));\n@@ -627,3 +614,17 @@\n-\n-    public int addMethodref( final MethodGen method ) {\n-        return addMethodref(method.getClassName(), method.getName(), method.getSignature());\n+    \/**\n+     * Look for ConstantDouble in ConstantPool.\n+     *\n+     * @param n Double number to look for\n+     * @return index on success, -1 otherwise\n+     *\/\n+    public int lookupDouble(final double n) {\n+        final long bits = Double.doubleToLongBits(n);\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantDouble) {\n+                final ConstantDouble c = (ConstantDouble) constants[i];\n+                if (Double.doubleToLongBits(c.getBytes()) == bits) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n@@ -632,1 +633,0 @@\n-\n@@ -634,1 +634,1 @@\n-     * Look for ConstantInterfaceMethodref in ConstantPool.\n+     * Look for ConstantFieldref in ConstantPool.\n@@ -636,2 +636,2 @@\n-     * @param class_name Where to find method\n-     * @param method_name Guess what\n+     * @param className Where to find method\n+     * @param fieldName Guess what\n@@ -641,4 +641,2 @@\n-    public int lookupInterfaceMethodref( final String class_name, final String method_name, final String signature ) {\n-        final Index index = cpTable.get(class_name + IMETHODREF_DELIM + method_name\n-                + IMETHODREF_DELIM + signature);\n-        return (index != null) ? index.index : -1;\n+    public int lookupFieldref(final String className, final String fieldName, final String signature) {\n+        return getIndex(cpTable, className + FIELDREF_DELIM + fieldName + FIELDREF_DELIM + signature);\n@@ -647,4 +645,17 @@\n-\n-    public int lookupInterfaceMethodref( final MethodGen method ) {\n-        return lookupInterfaceMethodref(method.getClassName(), method.getName(), method\n-                .getSignature());\n+    \/**\n+     * Look for ConstantFloat in ConstantPool.\n+     *\n+     * @param n Float number to look for\n+     * @return index on success, -1 otherwise\n+     *\/\n+    public int lookupFloat(final float n) {\n+        final int bits = Float.floatToIntBits(n);\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantFloat) {\n+                final ConstantFloat c = (ConstantFloat) constants[i];\n+                if (Float.floatToIntBits(c.getBytes()) == bits) {\n+                    return i;\n+                }\n+            }\n+        }\n+        return -1;\n@@ -653,1 +664,0 @@\n-\n@@ -655,2 +665,1 @@\n-     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already\n-     * in there.\n+     * Look for ConstantInteger in ConstantPool.\n@@ -658,4 +667,2 @@\n-     * @param class_name class name string to add\n-     * @param method_name method name string to add\n-     * @param signature signature string to add\n-     * @return index of entry\n+     * @param n integer number to look for\n+     * @return index on success, -1 otherwise\n@@ -663,15 +670,8 @@\n-    public int addInterfaceMethodref( final String class_name, final String method_name, final String signature ) {\n-        int ret;\n-        int class_index;\n-        int name_and_type_index;\n-        if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {\n-            return ret; \/\/ Already in CP\n-        }\n-        adjustSize();\n-        class_index = addClass(class_name);\n-        name_and_type_index = addNameAndType(method_name, signature);\n-        ret = index;\n-        constants[index++] = new ConstantInterfaceMethodref(class_index, name_and_type_index);\n-        final String key = class_name + IMETHODREF_DELIM + method_name + IMETHODREF_DELIM + signature;\n-        if (!cpTable.containsKey(key)) {\n-            cpTable.put(key, new Index(ret));\n+    public int lookupInteger(final int n) {\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantInteger) {\n+                final ConstantInteger c = (ConstantInteger) constants[i];\n+                if (c.getBytes() == n) {\n+                    return i;\n+                }\n+            }\n@@ -679,1 +679,1 @@\n-        return ret;\n+        return -1;\n@@ -682,3 +682,2 @@\n-\n-    public int addInterfaceMethodref( final MethodGen method ) {\n-        return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n+    public int lookupInterfaceMethodref(final MethodGen method) {\n+        return lookupInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n@@ -687,1 +686,0 @@\n-\n@@ -689,1 +687,1 @@\n-     * Look for ConstantFieldref in ConstantPool.\n+     * Look for ConstantInterfaceMethodref in ConstantPool.\n@@ -691,2 +689,2 @@\n-     * @param class_name Where to find method\n-     * @param field_name Guess what\n+     * @param className Where to find method\n+     * @param methodName Guess what\n@@ -696,4 +694,2 @@\n-    public int lookupFieldref( final String class_name, final String field_name, final String signature ) {\n-        final Index index = cpTable.get(class_name + FIELDREF_DELIM + field_name\n-                + FIELDREF_DELIM + signature);\n-        return (index != null) ? index.index : -1;\n+    public int lookupInterfaceMethodref(final String className, final String methodName, final String signature) {\n+        return getIndex(cpTable, className + IMETHODREF_DELIM + methodName + IMETHODREF_DELIM + signature);\n@@ -702,1 +698,0 @@\n-\n@@ -704,2 +699,1 @@\n-     * Add a new Fieldref constant to the ConstantPool, if it is not already\n-     * in there.\n+     * Look for ConstantLong in ConstantPool.\n@@ -707,4 +701,2 @@\n-     * @param class_name class name string to add\n-     * @param field_name field name string to add\n-     * @param signature signature string to add\n-     * @return index of entry\n+     * @param n Long number to look for\n+     * @return index on success, -1 otherwise\n@@ -712,15 +704,8 @@\n-    public int addFieldref( final String class_name, final String field_name, final String signature ) {\n-        int ret;\n-        int class_index;\n-        int name_and_type_index;\n-        if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {\n-            return ret; \/\/ Already in CP\n-        }\n-        adjustSize();\n-        class_index = addClass(class_name);\n-        name_and_type_index = addNameAndType(field_name, signature);\n-        ret = index;\n-        constants[index++] = new ConstantFieldref(class_index, name_and_type_index);\n-        final String key = class_name + FIELDREF_DELIM + field_name + FIELDREF_DELIM + signature;\n-        if (!cpTable.containsKey(key)) {\n-            cpTable.put(key, new Index(ret));\n+    public int lookupLong(final long n) {\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantLong) {\n+                final ConstantLong c = (ConstantLong) constants[i];\n+                if (c.getBytes() == n) {\n+                    return i;\n+                }\n+            }\n@@ -728,1 +713,1 @@\n-        return ret;\n+        return -1;\n@@ -731,0 +716,3 @@\n+    public int lookupMethodref(final MethodGen method) {\n+        return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());\n+    }\n@@ -733,2 +721,6 @@\n-     * @param i index in constant pool\n-     * @return constant pool entry at index i\n+     * Look for ConstantMethodref in ConstantPool.\n+     *\n+     * @param className Where to find method\n+     * @param methodName Guess what\n+     * @param signature return and argument types\n+     * @return index on success, -1 otherwise\n@@ -736,2 +728,2 @@\n-    public Constant getConstant( final int i ) {\n-        return constants[i];\n+    public int lookupMethodref(final String className, final String methodName, final String signature) {\n+        return getIndex(cpTable, className + METHODREF_DELIM + methodName + METHODREF_DELIM + signature);\n@@ -740,1 +732,0 @@\n-\n@@ -742,1 +733,1 @@\n-     * Use with care!\n+     * Look for ConstantNameAndType in ConstantPool.\n@@ -744,2 +735,3 @@\n-     * @param i index in constant pool\n-     * @param c new constant pool entry at index i\n+     * @param name of variable\/method\n+     * @param signature of variable\/method\n+     * @return index on success, -1 otherwise\n@@ -747,2 +739,2 @@\n-    public void setConstant( final int i, final Constant c ) {\n-        constants[i] = c;\n+    public int lookupNameAndType(final String name, final String signature) {\n+        return getIndex(natTable, name + NAT_DELIM + signature);\n@@ -751,1 +743,0 @@\n-\n@@ -753,1 +744,4 @@\n-     * @return intermediate constant pool\n+     * Look for ConstantString in ConstantPool containing String 'str'.\n+     *\n+     * @param str String to search for\n+     * @return index on success, -1 otherwise\n@@ -755,2 +749,2 @@\n-    public ConstantPool getConstantPool() {\n-        return new ConstantPool(constants);\n+    public int lookupString(final String str) {\n+        return getIndex(stringTable, str);\n@@ -759,1 +753,0 @@\n-\n@@ -761,1 +754,4 @@\n-     * @return current size of constant pool\n+     * Look for ConstantUtf8 in ConstantPool.\n+     *\n+     * @param n Utf8 string to look for\n+     * @return index on success, -1 otherwise\n@@ -763,2 +759,2 @@\n-    public int getSize() {\n-        return index;\n+    public int lookupUtf8(final String n) {\n+        return getIndex(utf8Table, n);\n@@ -767,1 +763,0 @@\n-\n@@ -769,1 +764,4 @@\n-     * @return constant pool with proper length\n+     * Use with care!\n+     *\n+     * @param i index in constant pool\n+     * @param c new constant pool entry at index i\n@@ -771,4 +769,2 @@\n-    public ConstantPool getFinalConstantPool() {\n-        final Constant[] cs = new Constant[index];\n-        System.arraycopy(constants, 0, cs, 0, index);\n-        return new ConstantPool(cs);\n+    public void setConstant(final int i, final Constant c) {\n+        constants[i] = c;\n@@ -777,0 +773,3 @@\n+    private int toIndex(final Integer index) {\n+        return index != null ? index.intValue() : -1;\n+    }\n@@ -789,60 +788,0 @@\n-\n-\n-    \/** Import constant from another ConstantPool and return new index.\n-     *\/\n-    public int addConstant( final Constant c, final ConstantPoolGen cp ) {\n-        final Constant[] constants = cp.getConstantPool().getConstantPool();\n-        switch (c.getTag()) {\n-            case Const.CONSTANT_String: {\n-                final ConstantString s = (ConstantString) c;\n-                final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];\n-                return addString(u8.getBytes());\n-            }\n-            case Const.CONSTANT_Class: {\n-                final ConstantClass s = (ConstantClass) c;\n-                final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];\n-                return addClass(u8.getBytes());\n-            }\n-            case Const.CONSTANT_NameAndType: {\n-                final ConstantNameAndType n = (ConstantNameAndType) c;\n-                final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n-                final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n-                return addNameAndType(u8.getBytes(), u8_2.getBytes());\n-            }\n-            case Const.CONSTANT_Utf8:\n-                return addUtf8(((ConstantUtf8) c).getBytes());\n-            case Const.CONSTANT_Double:\n-                return addDouble(((ConstantDouble) c).getBytes());\n-            case Const.CONSTANT_Float:\n-                return addFloat(((ConstantFloat) c).getBytes());\n-            case Const.CONSTANT_Long:\n-                return addLong(((ConstantLong) c).getBytes());\n-            case Const.CONSTANT_Integer:\n-                return addInteger(((ConstantInteger) c).getBytes());\n-            case Const.CONSTANT_InterfaceMethodref:\n-            case Const.CONSTANT_Methodref:\n-            case Const.CONSTANT_Fieldref: {\n-                final ConstantCP m = (ConstantCP) c;\n-                final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n-                final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];\n-                ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];\n-                final String class_name = u8.getBytes().replace('\/', '.');\n-                u8 = (ConstantUtf8) constants[n.getNameIndex()];\n-                final String name = u8.getBytes();\n-                u8 = (ConstantUtf8) constants[n.getSignatureIndex()];\n-                final String signature = u8.getBytes();\n-                switch (c.getTag()) {\n-                    case Const.CONSTANT_InterfaceMethodref:\n-                        return addInterfaceMethodref(class_name, name, signature);\n-                    case Const.CONSTANT_Methodref:\n-                        return addMethodref(class_name, name, signature);\n-                    case Const.CONSTANT_Fieldref:\n-                        return addFieldref(class_name, name, signature);\n-                    default: \/\/ Never reached\n-                        throw new IllegalArgumentException(\"Unknown constant type \" + c);\n-                }\n-            }\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown constant type \" + c);\n-        }\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConstantPoolGen.java","additions":424,"deletions":485,"binary":false,"changes":909,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Denotes a push instruction that produces a literal on the stack\n- * such as  SIPUSH, BIPUSH, ICONST, etc.\n+ * Denotes a push instruction that produces a literal on the stack such as SIPUSH, BIPUSH, ICONST, etc.\n+ *\n@@ -28,1 +28,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConstantPushInstruction.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- *\n@@ -30,2 +29,1 @@\n-public abstract class ConversionInstruction extends Instruction implements TypedInstruction,\n-        StackProducer, StackConsumer {\n+public abstract class ConversionInstruction extends Instruction implements TypedInstruction, StackProducer, StackConsumer {\n@@ -34,2 +32,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -40,1 +37,0 @@\n-\n@@ -48,2 +44,2 @@\n-\n-    \/** @return type associated with the instruction\n+    \/**\n+     * @return type associated with the instruction\n@@ -52,27 +48,27 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n-        final short _opcode = super.getOpcode();\n-        switch (_opcode) {\n-            case Const.D2I:\n-            case Const.F2I:\n-            case Const.L2I:\n-                return Type.INT;\n-            case Const.D2F:\n-            case Const.I2F:\n-            case Const.L2F:\n-                return Type.FLOAT;\n-            case Const.D2L:\n-            case Const.F2L:\n-            case Const.I2L:\n-                return Type.LONG;\n-            case Const.F2D:\n-            case Const.I2D:\n-            case Const.L2D:\n-                return Type.DOUBLE;\n-            case Const.I2B:\n-                return Type.BYTE;\n-            case Const.I2C:\n-                return Type.CHAR;\n-            case Const.I2S:\n-                return Type.SHORT;\n-            default: \/\/ Never reached\n-                throw new ClassGenException(\"Unknown type \" + _opcode);\n+    public Type getType(final ConstantPoolGen cp) {\n+        final short opcode = super.getOpcode();\n+        switch (opcode) {\n+        case Const.D2I:\n+        case Const.F2I:\n+        case Const.L2I:\n+            return Type.INT;\n+        case Const.D2F:\n+        case Const.I2F:\n+        case Const.L2F:\n+            return Type.FLOAT;\n+        case Const.D2L:\n+        case Const.F2L:\n+        case Const.I2L:\n+            return Type.LONG;\n+        case Const.F2D:\n+        case Const.I2D:\n+        case Const.L2D:\n+            return Type.DOUBLE;\n+        case Const.I2B:\n+            return Type.BYTE;\n+        case Const.I2C:\n+            return Type.CHAR;\n+        case Const.I2S:\n+            return Type.SHORT;\n+        default: \/\/ Never reached\n+            throw new ClassGenException(\"Unknown type \" + opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConversionInstruction.java","additions":31,"deletions":35,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert double to float\n+    \/**\n+     * Convert double to float\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2F.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert double to int\n+    \/**\n+     * Convert double to int\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2I.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert double to long\n+    \/**\n+     * Convert double to long\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result1.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result1.word2\n@@ -32,1 +35,2 @@\n-    \/** Add doubles\n+    \/**\n+     * Add doubles\n@@ -38,1 +42,0 @@\n-\n@@ -40,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DADD.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Load double from array\n+    \/**\n+     * Load double from array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * DASTORE -  Store into double array\n- * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...<\/PRE>\n+ * DASTORE - Store into double array\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Store double into array\n+    \/**\n+     * Store double into array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,7 +37,0 @@\n-    \/** @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.DOUBLE;\n-    }\n-\n@@ -43,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -51,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -57,0 +50,8 @@\n+\n+    \/**\n+     * @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.DOUBLE;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCMPG.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,7 +37,0 @@\n-    \/** @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.DOUBLE;\n-    }\n-\n@@ -43,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -51,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -57,0 +50,8 @@\n+\n+    \/**\n+     * @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.DOUBLE;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCMPL.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,2 +26,3 @@\n- * <PRE>Stack: ... -&gt; ..., <\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ...,\n+ * <\/PRE>\n@@ -32,2 +33,1 @@\n-    private double value;\n-\n+    private final double value;\n@@ -36,2 +36,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -40,0 +39,1 @@\n+        this(0);\n@@ -42,1 +42,0 @@\n-\n@@ -55,15 +54,0 @@\n-\n-    @Override\n-    public Number getValue() {\n-        return value;\n-    }\n-\n-\n-    \/** @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.DOUBLE;\n-    }\n-\n-\n@@ -71,4 +55,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -79,1 +61,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -86,0 +68,13 @@\n+\n+    \/**\n+     * @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.DOUBLE;\n+    }\n+\n+    @Override\n+    public Number getValue() {\n+        return Double.valueOf(value);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCONST.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * DDIV -  Divide doubles\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n+ * DDIV - Divide doubles\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -32,1 +35,2 @@\n-    \/** Divide doubles\n+    \/**\n+     * Divide doubles\n@@ -38,1 +42,0 @@\n-\n@@ -40,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DDIV.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack ... -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack ... -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,2 +40,3 @@\n-\n-    \/** Load double from local variable\n+    \/**\n+     * Load double from local variable\n+     *\n@@ -47,1 +49,0 @@\n-\n@@ -49,4 +50,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +56,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DLOAD.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -32,1 +35,2 @@\n-    \/** Multiply doubles\n+    \/**\n+     * Multiply doubles\n@@ -38,1 +42,0 @@\n-\n@@ -40,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DMUL.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DNEG.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -32,1 +35,2 @@\n-    \/** Remainder of doubles\n+    \/**\n+     * Remainder of doubles\n@@ -38,1 +42,0 @@\n-\n@@ -40,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DREM.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * DRETURN -  Return double from method\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;<\/PRE>\n+ * DRETURN - Return double from method\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Return double from method\n+    \/**\n+     * Return double from method\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <pre>Stack: ..., value.word1, value.word2 -&gt; ... <\/PRE>\n@@ -28,0 +27,3 @@\n+ * <pre>\n+ * Stack: ..., value.word1, value.word2 -&gt; ...\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,2 +40,3 @@\n-\n-    \/** Store double into local variable\n+    \/**\n+     * Store double into local variable\n+     *\n@@ -47,1 +49,0 @@\n-\n@@ -49,4 +50,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +56,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DSTORE.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -32,1 +35,2 @@\n-    \/** Substract doubles\n+    \/**\n+     * Substract doubles\n@@ -38,1 +42,0 @@\n-\n@@ -40,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DSUB.java","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., word -&gt; ..., word, word<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., word -&gt; ..., word, word\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., word2, word1 -&gt; ..., word2, word1, word2, word1<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., word2, word1 -&gt; ..., word2, word1, word2, word1\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word2, word1, word3, word2, word1<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., word3, word2, word1 -&gt; ..., word2, word1, word3, word2, word1\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2_X1.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., word4, word3, word2, word1 -&gt; ..., word2, word1, word4, word3, word2, word1<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., word4, word3, word2, word1 -&gt; ..., word2, word1, word4, word3, word2, word1\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2_X2.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2, word1<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., word2, word1 -&gt; ..., word1, word2, word1\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP_X1.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word1, word3, word2, word1<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., word3, word2, word1 -&gt; ..., word1, word3, word2, word1\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP_X2.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,25 +39,1 @@\n-public abstract class ElementValueGen\n-{\n-    private final int type;\n-    private final ConstantPoolGen cpGen;\n-\n-    protected ElementValueGen(final int type, final ConstantPoolGen cpGen)\n-    {\n-        this.type = type;\n-        this.cpGen = cpGen;\n-    }\n-\n-    \/**\n-     * Subtypes return an immutable variant of the ElementValueGen\n-     *\/\n-    public abstract ElementValue getElementValue();\n-\n-    public int getElementValueType()\n-    {\n-        return type;\n-    }\n-\n-    public abstract String stringifyValue();\n-\n-    public abstract void dump(DataOutputStream dos) throws IOException;\n-\n+public abstract class ElementValueGen {\n@@ -90,3 +66,29 @@\n-    public static ElementValueGen readElementValue(final DataInput dis,\n-            final ConstantPoolGen cpGen) throws IOException\n-    {\n+    \/**\n+     * Creates an (modifiable) ElementValueGen copy of an (immutable) ElementValue - constant pool is assumed correct.\n+     *\/\n+    public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+        switch (value.getElementValueType()) {\n+        case 'B': \/\/ byte\n+        case 'C': \/\/ char\n+        case 'D': \/\/ double\n+        case 'F': \/\/ float\n+        case 'I': \/\/ int\n+        case 'J': \/\/ long\n+        case 'S': \/\/ short\n+        case 'Z': \/\/ boolean\n+        case 's': \/\/ String\n+            return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);\n+        case 'e': \/\/ Enum constant\n+            return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);\n+        case '@': \/\/ Annotation\n+            return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);\n+        case '[': \/\/ Array\n+            return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);\n+        case 'c': \/\/ Class\n+            return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);\n+        default:\n+            throw new UnsupportedOperationException(\"Not implemented yet! (\" + value.getElementValueType() + \")\");\n+        }\n+    }\n+\n+    public static ElementValueGen readElementValue(final DataInput dis, final ConstantPoolGen cpGen) throws IOException {\n@@ -94,2 +96,1 @@\n-        switch (type)\n-        {\n+        switch (type) {\n@@ -97,2 +98,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_BYTE, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_BYTE, dis.readUnsignedShort(), cpGen);\n@@ -100,2 +100,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_CHAR, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_CHAR, dis.readUnsignedShort(), cpGen);\n@@ -103,2 +102,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_DOUBLE, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_DOUBLE, dis.readUnsignedShort(), cpGen);\n@@ -106,2 +104,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_FLOAT, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_FLOAT, dis.readUnsignedShort(), cpGen);\n@@ -109,2 +106,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_INT, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_INT, dis.readUnsignedShort(), cpGen);\n@@ -112,2 +108,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_LONG, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_LONG, dis.readUnsignedShort(), cpGen);\n@@ -115,2 +110,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_SHORT, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_SHORT, dis.readUnsignedShort(), cpGen);\n@@ -118,2 +112,1 @@\n-            return new SimpleElementValueGen(PRIMITIVE_BOOLEAN, dis\n-                    .readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_BOOLEAN, dis.readUnsignedShort(), cpGen);\n@@ -121,2 +114,1 @@\n-            return new SimpleElementValueGen(STRING, dis.readUnsignedShort(),\n-                    cpGen);\n+            return new SimpleElementValueGen(STRING, dis.readUnsignedShort(), cpGen);\n@@ -124,2 +116,1 @@\n-            return new EnumElementValueGen(dis.readUnsignedShort(), dis\n-                    .readUnsignedShort(), cpGen);\n+            return new EnumElementValueGen(dis.readUnsignedShort(), dis.readUnsignedShort(), cpGen);\n@@ -131,3 +122,2 @@\n-            return new AnnotationElementValueGen(ANNOTATION,\n-                    new AnnotationEntryGen(AnnotationEntry.read(dis, cpGen\n-                            .getConstantPool(), true), cpGen, false), cpGen);\n+            return new AnnotationElementValueGen(ANNOTATION, new AnnotationEntryGen(AnnotationEntry.read(dis, cpGen.getConstantPool(), true), cpGen, false),\n+                cpGen);\n@@ -137,4 +127,2 @@\n-            for (int j = 0; j < numArrayVals; j++)\n-            {\n-                evalues[j] = ElementValue.readElementValue(dis, cpGen\n-                        .getConstantPool());\n+            for (int j = 0; j < numArrayVals; j++) {\n+                evalues[j] = ElementValue.readElementValue(dis, cpGen.getConstantPool());\n@@ -148,2 +136,20 @@\n-    protected ConstantPoolGen getConstantPool()\n-    {\n+    \/**\n+     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n+     *\/\n+    @Deprecated\n+    protected int type;\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n+     *\/\n+    @Deprecated\n+    protected ConstantPoolGen cpGen;\n+\n+    protected ElementValueGen(final int type, final ConstantPoolGen cpGen) {\n+        this.type = type;\n+        this.cpGen = cpGen;\n+    }\n+\n+    public abstract void dump(DataOutputStream dos) throws IOException;\n+\n+    protected ConstantPoolGen getConstantPool() {\n@@ -154,2 +160,1 @@\n-     * Creates an (modifiable) ElementValueGen copy of an (immutable)\n-     * ElementValue - constant pool is assumed correct.\n+     * Subtypes return an immutable variant of the ElementValueGen\n@@ -157,31 +162,4 @@\n-    public static ElementValueGen copy(final ElementValue value,\n-            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n-    {\n-        switch (value.getElementValueType())\n-        {\n-        case 'B': \/\/ byte\n-        case 'C': \/\/ char\n-        case 'D': \/\/ double\n-        case 'F': \/\/ float\n-        case 'I': \/\/ int\n-        case 'J': \/\/ long\n-        case 'S': \/\/ short\n-        case 'Z': \/\/ boolean\n-        case 's': \/\/ String\n-            return new SimpleElementValueGen((SimpleElementValue) value, cpool,\n-                    copyPoolEntries);\n-        case 'e': \/\/ Enum constant\n-            return new EnumElementValueGen((EnumElementValue) value, cpool,\n-                    copyPoolEntries);\n-        case '@': \/\/ Annotation\n-            return new AnnotationElementValueGen(\n-                    (AnnotationElementValue) value, cpool, copyPoolEntries);\n-        case '[': \/\/ Array\n-            return new ArrayElementValueGen((ArrayElementValue) value, cpool,\n-                    copyPoolEntries);\n-        case 'c': \/\/ Class\n-            return new ClassElementValueGen((ClassElementValue) value, cpool,\n-                    copyPoolEntries);\n-        default:\n-            throw new UnsupportedOperationException(\"Not implemented yet! (\" + value.getElementValueType() + \")\");\n-        }\n+    public abstract ElementValue getElementValue();\n+\n+    public int getElementValueType() {\n+        return type;\n@@ -189,0 +167,2 @@\n+\n+    public abstract String stringifyValue();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ElementValueGen.java","additions":72,"deletions":92,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -34,3 +34,2 @@\n-public class ElementValuePairGen\n-{\n-    private int nameIdx;\n+public class ElementValuePairGen {\n+    private final int nameIdx;\n@@ -42,3 +41,1 @@\n-    public ElementValuePairGen(final ElementValuePair nvp, final ConstantPoolGen cpool,\n-            final boolean copyPoolEntries)\n-    {\n+    public ElementValuePairGen(final ElementValuePair nvp, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n@@ -54,2 +51,1 @@\n-        if (copyPoolEntries)\n-        {\n+        if (copyPoolEntries) {\n@@ -57,3 +53,1 @@\n-        }\n-        else\n-        {\n+        } else {\n@@ -65,13 +59,1 @@\n-    \/**\n-     * Retrieve an immutable version of this ElementNameValuePairGen\n-     *\/\n-    public ElementValuePair getElementNameValuePair()\n-    {\n-        final ElementValue immutableValue = value.getElementValue();\n-        return new ElementValuePair(nameIdx, immutableValue, constantPoolGen\n-                .getConstantPool());\n-    }\n-\n-    protected ElementValuePairGen(final int idx, final ElementValueGen value,\n-            final ConstantPoolGen cpool)\n-    {\n+    protected ElementValuePairGen(final int idx, final ElementValueGen value, final ConstantPoolGen cpool) {\n@@ -83,3 +65,1 @@\n-    public ElementValuePairGen(final String name, final ElementValueGen value,\n-            final ConstantPoolGen cpool)\n-    {\n+    public ElementValuePairGen(final String name, final ElementValueGen value, final ConstantPoolGen cpool) {\n@@ -91,2 +71,1 @@\n-    protected void dump(final DataOutputStream dos) throws IOException\n-    {\n+    protected void dump(final DataOutputStream dos) throws IOException {\n@@ -97,2 +76,9 @@\n-    public int getNameIndex()\n-    {\n+    \/**\n+     * Retrieve an immutable version of this ElementNameValuePairGen\n+     *\/\n+    public ElementValuePair getElementNameValuePair() {\n+        final ElementValue immutableValue = value.getElementValue();\n+        return new ElementValuePair(nameIdx, immutableValue, constantPoolGen.getConstantPool());\n+    }\n+\n+    public int getNameIndex() {\n@@ -102,2 +88,1 @@\n-    public final String getNameString()\n-    {\n+    public final String getNameString() {\n@@ -108,2 +93,1 @@\n-    public final ElementValueGen getValue()\n-    {\n+    public final ElementValueGen getValue() {\n@@ -114,4 +98,2 @@\n-    public String toString()\n-    {\n-        return \"ElementValuePair:[\" + getNameString() + \"=\"\n-                + value.stringifyValue() + \"]\";\n+    public String toString() {\n+        return \"ElementValuePair:[\" + getNameString() + \"=\" + value.stringifyValue() + \"]\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ElementValuePairGen.java","additions":21,"deletions":39,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -31,1 +30,1 @@\n-    public void visitStackInstruction( final StackInstruction obj ) {\n+    public void visitAALOAD(final AALOAD obj) {\n@@ -34,1 +33,0 @@\n-\n@@ -36,1 +34,1 @@\n-    public void visitLocalVariableInstruction( final LocalVariableInstruction obj ) {\n+    public void visitAASTORE(final AASTORE obj) {\n@@ -39,1 +37,0 @@\n-\n@@ -41,1 +38,1 @@\n-    public void visitBranchInstruction( final BranchInstruction obj ) {\n+    public void visitACONST_NULL(final ACONST_NULL obj) {\n@@ -44,1 +41,0 @@\n-\n@@ -46,1 +42,1 @@\n-    public void visitLoadClass( final LoadClass obj ) {\n+    public void visitAllocationInstruction(final AllocationInstruction obj) {\n@@ -49,1 +45,0 @@\n-\n@@ -51,1 +46,1 @@\n-    public void visitFieldInstruction( final FieldInstruction obj ) {\n+    public void visitALOAD(final ALOAD obj) {\n@@ -54,1 +49,0 @@\n-\n@@ -56,1 +50,1 @@\n-    public void visitIfInstruction( final IfInstruction obj ) {\n+    public void visitANEWARRAY(final ANEWARRAY obj) {\n@@ -59,1 +53,0 @@\n-\n@@ -61,1 +54,1 @@\n-    public void visitConversionInstruction( final ConversionInstruction obj ) {\n+    public void visitARETURN(final ARETURN obj) {\n@@ -64,1 +57,0 @@\n-\n@@ -66,1 +58,1 @@\n-    public void visitPopInstruction( final PopInstruction obj ) {\n+    public void visitArithmeticInstruction(final ArithmeticInstruction obj) {\n@@ -69,1 +61,0 @@\n-\n@@ -71,1 +62,1 @@\n-    public void visitJsrInstruction( final JsrInstruction obj ) {\n+    public void visitArrayInstruction(final ArrayInstruction obj) {\n@@ -74,1 +65,0 @@\n-\n@@ -76,1 +66,1 @@\n-    public void visitGotoInstruction( final GotoInstruction obj ) {\n+    public void visitARRAYLENGTH(final ARRAYLENGTH obj) {\n@@ -79,1 +69,0 @@\n-\n@@ -81,1 +70,1 @@\n-    public void visitStoreInstruction( final StoreInstruction obj ) {\n+    public void visitASTORE(final ASTORE obj) {\n@@ -84,1 +73,0 @@\n-\n@@ -86,1 +74,1 @@\n-    public void visitTypedInstruction( final TypedInstruction obj ) {\n+    public void visitATHROW(final ATHROW obj) {\n@@ -89,1 +77,0 @@\n-\n@@ -91,1 +78,1 @@\n-    public void visitSelect( final Select obj ) {\n+    public void visitBALOAD(final BALOAD obj) {\n@@ -94,1 +81,0 @@\n-\n@@ -96,1 +82,1 @@\n-    public void visitUnconditionalBranch( final UnconditionalBranch obj ) {\n+    public void visitBASTORE(final BASTORE obj) {\n@@ -99,1 +85,0 @@\n-\n@@ -101,1 +86,1 @@\n-    public void visitPushInstruction( final PushInstruction obj ) {\n+    public void visitBIPUSH(final BIPUSH obj) {\n@@ -104,1 +89,0 @@\n-\n@@ -106,1 +90,1 @@\n-    public void visitArithmeticInstruction( final ArithmeticInstruction obj ) {\n+    public void visitBranchInstruction(final BranchInstruction obj) {\n@@ -109,1 +93,0 @@\n-\n@@ -111,1 +94,1 @@\n-    public void visitCPInstruction( final CPInstruction obj ) {\n+    public void visitBREAKPOINT(final BREAKPOINT obj) {\n@@ -114,1 +97,0 @@\n-\n@@ -116,1 +98,1 @@\n-    public void visitInvokeInstruction( final InvokeInstruction obj ) {\n+    public void visitCALOAD(final CALOAD obj) {\n@@ -119,1 +101,0 @@\n-\n@@ -121,1 +102,1 @@\n-    public void visitArrayInstruction( final ArrayInstruction obj ) {\n+    public void visitCASTORE(final CASTORE obj) {\n@@ -124,1 +105,0 @@\n-\n@@ -126,1 +106,1 @@\n-    public void visitAllocationInstruction( final AllocationInstruction obj ) {\n+    public void visitCHECKCAST(final CHECKCAST obj) {\n@@ -129,1 +109,0 @@\n-\n@@ -131,1 +110,1 @@\n-    public void visitReturnInstruction( final ReturnInstruction obj ) {\n+    public void visitConstantPushInstruction(final ConstantPushInstruction obj) {\n@@ -134,1 +113,0 @@\n-\n@@ -136,1 +114,1 @@\n-    public void visitFieldOrMethod( final FieldOrMethod obj ) {\n+    public void visitConversionInstruction(final ConversionInstruction obj) {\n@@ -139,1 +117,0 @@\n-\n@@ -141,1 +118,1 @@\n-    public void visitConstantPushInstruction( final ConstantPushInstruction obj ) {\n+    public void visitCPInstruction(final CPInstruction obj) {\n@@ -144,1 +121,0 @@\n-\n@@ -146,1 +122,1 @@\n-    public void visitExceptionThrower( final ExceptionThrower obj ) {\n+    public void visitD2F(final D2F obj) {\n@@ -149,1 +125,0 @@\n-\n@@ -151,1 +126,1 @@\n-    public void visitLoadInstruction( final LoadInstruction obj ) {\n+    public void visitD2I(final D2I obj) {\n@@ -154,1 +129,0 @@\n-\n@@ -156,1 +130,1 @@\n-    public void visitVariableLengthInstruction( final VariableLengthInstruction obj ) {\n+    public void visitD2L(final D2L obj) {\n@@ -159,1 +133,0 @@\n-\n@@ -161,1 +134,1 @@\n-    public void visitStackProducer( final StackProducer obj ) {\n+    public void visitDADD(final DADD obj) {\n@@ -164,1 +137,0 @@\n-\n@@ -166,1 +138,1 @@\n-    public void visitStackConsumer( final StackConsumer obj ) {\n+    public void visitDALOAD(final DALOAD obj) {\n@@ -169,1 +141,0 @@\n-\n@@ -171,1 +142,1 @@\n-    public void visitACONST_NULL( final ACONST_NULL obj ) {\n+    public void visitDASTORE(final DASTORE obj) {\n@@ -174,1 +145,0 @@\n-\n@@ -176,1 +146,1 @@\n-    public void visitGETSTATIC( final GETSTATIC obj ) {\n+    public void visitDCMPG(final DCMPG obj) {\n@@ -179,1 +149,0 @@\n-\n@@ -181,1 +150,1 @@\n-    public void visitIF_ICMPLT( final IF_ICMPLT obj ) {\n+    public void visitDCMPL(final DCMPL obj) {\n@@ -184,1 +153,0 @@\n-\n@@ -186,1 +154,1 @@\n-    public void visitMONITOREXIT( final MONITOREXIT obj ) {\n+    public void visitDCONST(final DCONST obj) {\n@@ -189,1 +157,0 @@\n-\n@@ -191,1 +158,1 @@\n-    public void visitIFLT( final IFLT obj ) {\n+    public void visitDDIV(final DDIV obj) {\n@@ -194,1 +161,0 @@\n-\n@@ -196,1 +162,1 @@\n-    public void visitLSTORE( final LSTORE obj ) {\n+    public void visitDLOAD(final DLOAD obj) {\n@@ -199,1 +165,0 @@\n-\n@@ -201,1 +166,1 @@\n-    public void visitPOP2( final POP2 obj ) {\n+    public void visitDMUL(final DMUL obj) {\n@@ -204,1 +169,0 @@\n-\n@@ -206,1 +170,1 @@\n-    public void visitBASTORE( final BASTORE obj ) {\n+    public void visitDNEG(final DNEG obj) {\n@@ -209,1 +173,0 @@\n-\n@@ -211,1 +174,1 @@\n-    public void visitISTORE( final ISTORE obj ) {\n+    public void visitDREM(final DREM obj) {\n@@ -214,1 +177,0 @@\n-\n@@ -216,1 +178,1 @@\n-    public void visitCHECKCAST( final CHECKCAST obj ) {\n+    public void visitDRETURN(final DRETURN obj) {\n@@ -219,1 +181,0 @@\n-\n@@ -221,1 +182,1 @@\n-    public void visitFCMPG( final FCMPG obj ) {\n+    public void visitDSTORE(final DSTORE obj) {\n@@ -224,1 +185,0 @@\n-\n@@ -226,1 +186,1 @@\n-    public void visitI2F( final I2F obj ) {\n+    public void visitDSUB(final DSUB obj) {\n@@ -229,1 +189,0 @@\n-\n@@ -231,1 +190,1 @@\n-    public void visitATHROW( final ATHROW obj ) {\n+    public void visitDUP(final DUP obj) {\n@@ -234,1 +193,0 @@\n-\n@@ -236,1 +194,1 @@\n-    public void visitDCMPL( final DCMPL obj ) {\n+    public void visitDUP_X1(final DUP_X1 obj) {\n@@ -239,1 +197,0 @@\n-\n@@ -241,1 +198,1 @@\n-    public void visitARRAYLENGTH( final ARRAYLENGTH obj ) {\n+    public void visitDUP_X2(final DUP_X2 obj) {\n@@ -244,1 +201,0 @@\n-\n@@ -246,1 +202,1 @@\n-    public void visitDUP( final DUP obj ) {\n+    public void visitDUP2(final DUP2 obj) {\n@@ -249,1 +205,0 @@\n-\n@@ -251,1 +206,1 @@\n-    public void visitINVOKESTATIC( final INVOKESTATIC obj ) {\n+    public void visitDUP2_X1(final DUP2_X1 obj) {\n@@ -254,1 +209,0 @@\n-\n@@ -256,1 +210,1 @@\n-    public void visitLCONST( final LCONST obj ) {\n+    public void visitDUP2_X2(final DUP2_X2 obj) {\n@@ -259,1 +213,0 @@\n-\n@@ -261,1 +214,1 @@\n-    public void visitDREM( final DREM obj ) {\n+    public void visitExceptionThrower(final ExceptionThrower obj) {\n@@ -264,1 +217,0 @@\n-\n@@ -266,1 +218,1 @@\n-    public void visitIFGE( final IFGE obj ) {\n+    public void visitF2D(final F2D obj) {\n@@ -269,1 +221,0 @@\n-\n@@ -271,1 +222,1 @@\n-    public void visitCALOAD( final CALOAD obj ) {\n+    public void visitF2I(final F2I obj) {\n@@ -274,1 +225,0 @@\n-\n@@ -276,1 +226,1 @@\n-    public void visitLASTORE( final LASTORE obj ) {\n+    public void visitF2L(final F2L obj) {\n@@ -279,1 +229,0 @@\n-\n@@ -281,1 +230,1 @@\n-    public void visitI2D( final I2D obj ) {\n+    public void visitFADD(final FADD obj) {\n@@ -284,1 +233,0 @@\n-\n@@ -286,1 +234,1 @@\n-    public void visitDADD( final DADD obj ) {\n+    public void visitFALOAD(final FALOAD obj) {\n@@ -289,1 +237,0 @@\n-\n@@ -291,1 +238,1 @@\n-    public void visitINVOKESPECIAL( final INVOKESPECIAL obj ) {\n+    public void visitFASTORE(final FASTORE obj) {\n@@ -294,1 +241,0 @@\n-\n@@ -296,1 +242,1 @@\n-    public void visitIAND( final IAND obj ) {\n+    public void visitFCMPG(final FCMPG obj) {\n@@ -299,1 +245,0 @@\n-\n@@ -301,1 +246,1 @@\n-    public void visitPUTFIELD( final PUTFIELD obj ) {\n+    public void visitFCMPL(final FCMPL obj) {\n@@ -304,1 +249,0 @@\n-\n@@ -306,1 +250,1 @@\n-    public void visitILOAD( final ILOAD obj ) {\n+    public void visitFCONST(final FCONST obj) {\n@@ -309,1 +253,0 @@\n-\n@@ -311,1 +254,1 @@\n-    public void visitDLOAD( final DLOAD obj ) {\n+    public void visitFDIV(final FDIV obj) {\n@@ -314,1 +257,0 @@\n-\n@@ -316,1 +258,1 @@\n-    public void visitDCONST( final DCONST obj ) {\n+    public void visitFieldInstruction(final FieldInstruction obj) {\n@@ -319,1 +261,0 @@\n-\n@@ -321,1 +262,1 @@\n-    public void visitNEW( final NEW obj ) {\n+    public void visitFieldOrMethod(final FieldOrMethod obj) {\n@@ -324,1 +265,0 @@\n-\n@@ -326,1 +266,1 @@\n-    public void visitIFNULL( final IFNULL obj ) {\n+    public void visitFLOAD(final FLOAD obj) {\n@@ -329,1 +269,0 @@\n-\n@@ -331,1 +270,1 @@\n-    public void visitLSUB( final LSUB obj ) {\n+    public void visitFMUL(final FMUL obj) {\n@@ -334,1 +273,0 @@\n-\n@@ -336,1 +274,1 @@\n-    public void visitL2I( final L2I obj ) {\n+    public void visitFNEG(final FNEG obj) {\n@@ -339,1 +277,0 @@\n-\n@@ -341,1 +278,1 @@\n-    public void visitISHR( final ISHR obj ) {\n+    public void visitFREM(final FREM obj) {\n@@ -344,1 +281,0 @@\n-\n@@ -346,1 +282,1 @@\n-    public void visitTABLESWITCH( final TABLESWITCH obj ) {\n+    public void visitFRETURN(final FRETURN obj) {\n@@ -349,1 +285,0 @@\n-\n@@ -351,1 +286,1 @@\n-    public void visitIINC( final IINC obj ) {\n+    public void visitFSTORE(final FSTORE obj) {\n@@ -354,1 +289,0 @@\n-\n@@ -356,1 +290,1 @@\n-    public void visitDRETURN( final DRETURN obj ) {\n+    public void visitFSUB(final FSUB obj) {\n@@ -359,1 +293,0 @@\n-\n@@ -361,1 +294,1 @@\n-    public void visitFSTORE( final FSTORE obj ) {\n+    public void visitGETFIELD(final GETFIELD obj) {\n@@ -364,1 +297,0 @@\n-\n@@ -366,1 +298,1 @@\n-    public void visitDASTORE( final DASTORE obj ) {\n+    public void visitGETSTATIC(final GETSTATIC obj) {\n@@ -369,1 +301,0 @@\n-\n@@ -371,1 +302,1 @@\n-    public void visitIALOAD( final IALOAD obj ) {\n+    public void visitGOTO(final GOTO obj) {\n@@ -374,1 +305,0 @@\n-\n@@ -376,1 +306,1 @@\n-    public void visitDDIV( final DDIV obj ) {\n+    public void visitGOTO_W(final GOTO_W obj) {\n@@ -379,1 +309,0 @@\n-\n@@ -381,1 +310,1 @@\n-    public void visitIF_ICMPGE( final IF_ICMPGE obj ) {\n+    public void visitGotoInstruction(final GotoInstruction obj) {\n@@ -384,1 +313,0 @@\n-\n@@ -386,1 +314,1 @@\n-    public void visitLAND( final LAND obj ) {\n+    public void visitI2B(final I2B obj) {\n@@ -389,1 +317,0 @@\n-\n@@ -391,1 +318,1 @@\n-    public void visitIDIV( final IDIV obj ) {\n+    public void visitI2C(final I2C obj) {\n@@ -394,1 +321,0 @@\n-\n@@ -396,1 +322,1 @@\n-    public void visitLOR( final LOR obj ) {\n+    public void visitI2D(final I2D obj) {\n@@ -399,1 +325,0 @@\n-\n@@ -401,1 +326,1 @@\n-    public void visitCASTORE( final CASTORE obj ) {\n+    public void visitI2F(final I2F obj) {\n@@ -404,1 +329,0 @@\n-\n@@ -406,1 +330,1 @@\n-    public void visitFREM( final FREM obj ) {\n+    public void visitI2L(final I2L obj) {\n@@ -409,1 +333,0 @@\n-\n@@ -411,1 +334,1 @@\n-    public void visitLDC( final LDC obj ) {\n+    public void visitI2S(final I2S obj) {\n@@ -414,1 +337,0 @@\n-\n@@ -416,1 +338,1 @@\n-    public void visitBIPUSH( final BIPUSH obj ) {\n+    public void visitIADD(final IADD obj) {\n@@ -419,1 +341,0 @@\n-\n@@ -421,1 +342,1 @@\n-    public void visitDSTORE( final DSTORE obj ) {\n+    public void visitIALOAD(final IALOAD obj) {\n@@ -424,1 +345,0 @@\n-\n@@ -426,1 +346,1 @@\n-    public void visitF2L( final F2L obj ) {\n+    public void visitIAND(final IAND obj) {\n@@ -429,1 +349,0 @@\n-\n@@ -431,1 +350,1 @@\n-    public void visitFMUL( final FMUL obj ) {\n+    public void visitIASTORE(final IASTORE obj) {\n@@ -434,1 +353,0 @@\n-\n@@ -436,1 +354,1 @@\n-    public void visitLLOAD( final LLOAD obj ) {\n+    public void visitICONST(final ICONST obj) {\n@@ -439,1 +357,0 @@\n-\n@@ -441,1 +358,1 @@\n-    public void visitJSR( final JSR obj ) {\n+    public void visitIDIV(final IDIV obj) {\n@@ -444,1 +361,0 @@\n-\n@@ -446,1 +362,1 @@\n-    public void visitFSUB( final FSUB obj ) {\n+    public void visitIF_ACMPEQ(final IF_ACMPEQ obj) {\n@@ -449,1 +365,0 @@\n-\n@@ -451,1 +366,1 @@\n-    public void visitSASTORE( final SASTORE obj ) {\n+    public void visitIF_ACMPNE(final IF_ACMPNE obj) {\n@@ -454,1 +369,0 @@\n-\n@@ -456,1 +370,1 @@\n-    public void visitALOAD( final ALOAD obj ) {\n+    public void visitIF_ICMPEQ(final IF_ICMPEQ obj) {\n@@ -459,1 +373,0 @@\n-\n@@ -461,1 +374,1 @@\n-    public void visitDUP2_X2( final DUP2_X2 obj ) {\n+    public void visitIF_ICMPGE(final IF_ICMPGE obj) {\n@@ -464,1 +377,0 @@\n-\n@@ -466,1 +378,1 @@\n-    public void visitRETURN( final RETURN obj ) {\n+    public void visitIF_ICMPGT(final IF_ICMPGT obj) {\n@@ -469,1 +381,0 @@\n-\n@@ -471,1 +382,1 @@\n-    public void visitDALOAD( final DALOAD obj ) {\n+    public void visitIF_ICMPLE(final IF_ICMPLE obj) {\n@@ -474,1 +385,0 @@\n-\n@@ -476,1 +386,1 @@\n-    public void visitSIPUSH( final SIPUSH obj ) {\n+    public void visitIF_ICMPLT(final IF_ICMPLT obj) {\n@@ -479,1 +389,0 @@\n-\n@@ -481,1 +390,1 @@\n-    public void visitDSUB( final DSUB obj ) {\n+    public void visitIF_ICMPNE(final IF_ICMPNE obj) {\n@@ -484,1 +393,0 @@\n-\n@@ -486,1 +394,1 @@\n-    public void visitL2F( final L2F obj ) {\n+    public void visitIFEQ(final IFEQ obj) {\n@@ -489,1 +397,0 @@\n-\n@@ -491,1 +398,1 @@\n-    public void visitIF_ICMPGT( final IF_ICMPGT obj ) {\n+    public void visitIFGE(final IFGE obj) {\n@@ -494,1 +401,0 @@\n-\n@@ -496,1 +402,1 @@\n-    public void visitF2D( final F2D obj ) {\n+    public void visitIFGT(final IFGT obj) {\n@@ -499,1 +405,0 @@\n-\n@@ -501,1 +406,1 @@\n-    public void visitI2L( final I2L obj ) {\n+    public void visitIfInstruction(final IfInstruction obj) {\n@@ -504,1 +409,0 @@\n-\n@@ -506,1 +410,1 @@\n-    public void visitIF_ACMPNE( final IF_ACMPNE obj ) {\n+    public void visitIFLE(final IFLE obj) {\n@@ -509,1 +413,0 @@\n-\n@@ -511,1 +414,1 @@\n-    public void visitPOP( final POP obj ) {\n+    public void visitIFLT(final IFLT obj) {\n@@ -514,1 +417,0 @@\n-\n@@ -516,1 +418,1 @@\n-    public void visitI2S( final I2S obj ) {\n+    public void visitIFNE(final IFNE obj) {\n@@ -519,1 +421,0 @@\n-\n@@ -521,1 +422,1 @@\n-    public void visitIFEQ( final IFEQ obj ) {\n+    public void visitIFNONNULL(final IFNONNULL obj) {\n@@ -524,1 +425,0 @@\n-\n@@ -526,1 +426,1 @@\n-    public void visitSWAP( final SWAP obj ) {\n+    public void visitIFNULL(final IFNULL obj) {\n@@ -529,1 +429,0 @@\n-\n@@ -531,1 +430,1 @@\n-    public void visitIOR( final IOR obj ) {\n+    public void visitIINC(final IINC obj) {\n@@ -534,1 +433,0 @@\n-\n@@ -536,1 +434,1 @@\n-    public void visitIREM( final IREM obj ) {\n+    public void visitILOAD(final ILOAD obj) {\n@@ -539,1 +437,0 @@\n-\n@@ -541,1 +438,1 @@\n-    public void visitIASTORE( final IASTORE obj ) {\n+    public void visitIMPDEP1(final IMPDEP1 obj) {\n@@ -544,1 +441,0 @@\n-\n@@ -546,1 +442,1 @@\n-    public void visitNEWARRAY( final NEWARRAY obj ) {\n+    public void visitIMPDEP2(final IMPDEP2 obj) {\n@@ -549,1 +445,0 @@\n-\n@@ -551,1 +446,1 @@\n-    public void visitINVOKEINTERFACE( final INVOKEINTERFACE obj ) {\n+    public void visitIMUL(final IMUL obj) {\n@@ -554,1 +449,0 @@\n-\n@@ -556,1 +450,1 @@\n-    public void visitINEG( final INEG obj ) {\n+    public void visitINEG(final INEG obj) {\n@@ -559,1 +453,0 @@\n-\n@@ -561,1 +454,1 @@\n-    public void visitLCMP( final LCMP obj ) {\n+    public void visitINSTANCEOF(final INSTANCEOF obj) {\n@@ -564,1 +457,3 @@\n-\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -566,1 +461,1 @@\n-    public void visitJSR_W( final JSR_W obj ) {\n+    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC obj) {\n@@ -569,1 +464,0 @@\n-\n@@ -571,1 +465,1 @@\n-    public void visitMULTIANEWARRAY( final MULTIANEWARRAY obj ) {\n+    public void visitInvokeInstruction(final InvokeInstruction obj) {\n@@ -574,1 +468,0 @@\n-\n@@ -576,1 +469,1 @@\n-    public void visitDUP_X2( final DUP_X2 obj ) {\n+    public void visitINVOKEINTERFACE(final INVOKEINTERFACE obj) {\n@@ -579,1 +472,0 @@\n-\n@@ -581,1 +473,1 @@\n-    public void visitSALOAD( final SALOAD obj ) {\n+    public void visitINVOKESPECIAL(final INVOKESPECIAL obj) {\n@@ -584,1 +476,0 @@\n-\n@@ -586,1 +477,1 @@\n-    public void visitIFNONNULL( final IFNONNULL obj ) {\n+    public void visitINVOKESTATIC(final INVOKESTATIC obj) {\n@@ -589,1 +480,0 @@\n-\n@@ -591,1 +481,1 @@\n-    public void visitDMUL( final DMUL obj ) {\n+    public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL obj) {\n@@ -594,1 +484,0 @@\n-\n@@ -596,1 +485,1 @@\n-    public void visitIFNE( final IFNE obj ) {\n+    public void visitIOR(final IOR obj) {\n@@ -599,1 +488,0 @@\n-\n@@ -601,1 +489,1 @@\n-    public void visitIF_ICMPLE( final IF_ICMPLE obj ) {\n+    public void visitIREM(final IREM obj) {\n@@ -604,1 +492,0 @@\n-\n@@ -606,1 +493,1 @@\n-    public void visitLDC2_W( final LDC2_W obj ) {\n+    public void visitIRETURN(final IRETURN obj) {\n@@ -609,1 +496,0 @@\n-\n@@ -611,1 +497,1 @@\n-    public void visitGETFIELD( final GETFIELD obj ) {\n+    public void visitISHL(final ISHL obj) {\n@@ -614,1 +500,0 @@\n-\n@@ -616,1 +501,1 @@\n-    public void visitLADD( final LADD obj ) {\n+    public void visitISHR(final ISHR obj) {\n@@ -619,1 +504,0 @@\n-\n@@ -621,1 +505,1 @@\n-    public void visitNOP( final NOP obj ) {\n+    public void visitISTORE(final ISTORE obj) {\n@@ -624,1 +508,0 @@\n-\n@@ -626,1 +509,1 @@\n-    public void visitFALOAD( final FALOAD obj ) {\n+    public void visitISUB(final ISUB obj) {\n@@ -629,1 +512,0 @@\n-\n@@ -631,1 +513,1 @@\n-    public void visitINSTANCEOF( final INSTANCEOF obj ) {\n+    public void visitIUSHR(final IUSHR obj) {\n@@ -634,1 +516,0 @@\n-\n@@ -636,1 +517,1 @@\n-    public void visitIFLE( final IFLE obj ) {\n+    public void visitIXOR(final IXOR obj) {\n@@ -639,1 +520,0 @@\n-\n@@ -641,1 +521,1 @@\n-    public void visitLXOR( final LXOR obj ) {\n+    public void visitJSR(final JSR obj) {\n@@ -644,1 +524,0 @@\n-\n@@ -646,1 +525,1 @@\n-    public void visitLRETURN( final LRETURN obj ) {\n+    public void visitJSR_W(final JSR_W obj) {\n@@ -649,1 +528,0 @@\n-\n@@ -651,1 +529,1 @@\n-    public void visitFCONST( final FCONST obj ) {\n+    public void visitJsrInstruction(final JsrInstruction obj) {\n@@ -654,1 +532,0 @@\n-\n@@ -656,1 +533,1 @@\n-    public void visitIUSHR( final IUSHR obj ) {\n+    public void visitL2D(final L2D obj) {\n@@ -659,1 +536,0 @@\n-\n@@ -661,1 +537,1 @@\n-    public void visitBALOAD( final BALOAD obj ) {\n+    public void visitL2F(final L2F obj) {\n@@ -664,1 +540,0 @@\n-\n@@ -666,1 +541,1 @@\n-    public void visitDUP2( final DUP2 obj ) {\n+    public void visitL2I(final L2I obj) {\n@@ -669,1 +544,0 @@\n-\n@@ -671,1 +545,1 @@\n-    public void visitIF_ACMPEQ( final IF_ACMPEQ obj ) {\n+    public void visitLADD(final LADD obj) {\n@@ -674,1 +548,0 @@\n-\n@@ -676,1 +549,1 @@\n-    public void visitIMPDEP1( final IMPDEP1 obj ) {\n+    public void visitLALOAD(final LALOAD obj) {\n@@ -679,1 +552,0 @@\n-\n@@ -681,1 +553,1 @@\n-    public void visitMONITORENTER( final MONITORENTER obj ) {\n+    public void visitLAND(final LAND obj) {\n@@ -684,1 +556,0 @@\n-\n@@ -686,1 +557,1 @@\n-    public void visitLSHL( final LSHL obj ) {\n+    public void visitLASTORE(final LASTORE obj) {\n@@ -689,1 +560,0 @@\n-\n@@ -691,1 +561,1 @@\n-    public void visitDCMPG( final DCMPG obj ) {\n+    public void visitLCMP(final LCMP obj) {\n@@ -694,1 +564,0 @@\n-\n@@ -696,1 +565,1 @@\n-    public void visitD2L( final D2L obj ) {\n+    public void visitLCONST(final LCONST obj) {\n@@ -699,1 +568,0 @@\n-\n@@ -701,1 +569,1 @@\n-    public void visitIMPDEP2( final IMPDEP2 obj ) {\n+    public void visitLDC(final LDC obj) {\n@@ -704,1 +572,0 @@\n-\n@@ -706,1 +573,1 @@\n-    public void visitL2D( final L2D obj ) {\n+    public void visitLDC2_W(final LDC2_W obj) {\n@@ -709,1 +576,0 @@\n-\n@@ -711,1 +577,1 @@\n-    public void visitRET( final RET obj ) {\n+    public void visitLDIV(final LDIV obj) {\n@@ -714,1 +580,0 @@\n-\n@@ -716,1 +581,1 @@\n-    public void visitIFGT( final IFGT obj ) {\n+    public void visitLLOAD(final LLOAD obj) {\n@@ -719,1 +584,0 @@\n-\n@@ -721,1 +585,1 @@\n-    public void visitIXOR( final IXOR obj ) {\n+    public void visitLMUL(final LMUL obj) {\n@@ -724,1 +588,0 @@\n-\n@@ -726,1 +589,1 @@\n-    public void visitINVOKEVIRTUAL( final INVOKEVIRTUAL obj ) {\n+    public void visitLNEG(final LNEG obj) {\n@@ -729,1 +592,0 @@\n-\n@@ -731,1 +593,1 @@\n-    public void visitFASTORE( final FASTORE obj ) {\n+    public void visitLoadClass(final LoadClass obj) {\n@@ -734,1 +596,0 @@\n-\n@@ -736,1 +597,1 @@\n-    public void visitIRETURN( final IRETURN obj ) {\n+    public void visitLoadInstruction(final LoadInstruction obj) {\n@@ -739,1 +600,0 @@\n-\n@@ -741,1 +601,1 @@\n-    public void visitIF_ICMPNE( final IF_ICMPNE obj ) {\n+    public void visitLocalVariableInstruction(final LocalVariableInstruction obj) {\n@@ -744,1 +604,0 @@\n-\n@@ -746,1 +605,1 @@\n-    public void visitFLOAD( final FLOAD obj ) {\n+    public void visitLOOKUPSWITCH(final LOOKUPSWITCH obj) {\n@@ -749,1 +608,0 @@\n-\n@@ -751,1 +609,1 @@\n-    public void visitLDIV( final LDIV obj ) {\n+    public void visitLOR(final LOR obj) {\n@@ -754,1 +612,0 @@\n-\n@@ -756,1 +613,1 @@\n-    public void visitPUTSTATIC( final PUTSTATIC obj ) {\n+    public void visitLREM(final LREM obj) {\n@@ -759,1 +616,0 @@\n-\n@@ -761,1 +617,1 @@\n-    public void visitAALOAD( final AALOAD obj ) {\n+    public void visitLRETURN(final LRETURN obj) {\n@@ -764,1 +620,0 @@\n-\n@@ -766,1 +621,1 @@\n-    public void visitD2I( final D2I obj ) {\n+    public void visitLSHL(final LSHL obj) {\n@@ -769,1 +624,0 @@\n-\n@@ -771,1 +625,1 @@\n-    public void visitIF_ICMPEQ( final IF_ICMPEQ obj ) {\n+    public void visitLSHR(final LSHR obj) {\n@@ -774,1 +628,0 @@\n-\n@@ -776,1 +629,1 @@\n-    public void visitAASTORE( final AASTORE obj ) {\n+    public void visitLSTORE(final LSTORE obj) {\n@@ -779,1 +632,0 @@\n-\n@@ -781,1 +633,1 @@\n-    public void visitARETURN( final ARETURN obj ) {\n+    public void visitLSUB(final LSUB obj) {\n@@ -784,1 +636,0 @@\n-\n@@ -786,1 +637,1 @@\n-    public void visitDUP2_X1( final DUP2_X1 obj ) {\n+    public void visitLUSHR(final LUSHR obj) {\n@@ -789,1 +640,0 @@\n-\n@@ -791,1 +641,1 @@\n-    public void visitFNEG( final FNEG obj ) {\n+    public void visitLXOR(final LXOR obj) {\n@@ -794,1 +644,0 @@\n-\n@@ -796,1 +645,1 @@\n-    public void visitGOTO_W( final GOTO_W obj ) {\n+    public void visitMONITORENTER(final MONITORENTER obj) {\n@@ -799,1 +648,0 @@\n-\n@@ -801,1 +649,1 @@\n-    public void visitD2F( final D2F obj ) {\n+    public void visitMONITOREXIT(final MONITOREXIT obj) {\n@@ -804,1 +652,0 @@\n-\n@@ -806,1 +653,1 @@\n-    public void visitGOTO( final GOTO obj ) {\n+    public void visitMULTIANEWARRAY(final MULTIANEWARRAY obj) {\n@@ -809,1 +656,0 @@\n-\n@@ -811,1 +657,1 @@\n-    public void visitISUB( final ISUB obj ) {\n+    public void visitNEW(final NEW obj) {\n@@ -814,1 +660,0 @@\n-\n@@ -816,1 +661,1 @@\n-    public void visitF2I( final F2I obj ) {\n+    public void visitNEWARRAY(final NEWARRAY obj) {\n@@ -819,1 +664,0 @@\n-\n@@ -821,1 +665,1 @@\n-    public void visitDNEG( final DNEG obj ) {\n+    public void visitNOP(final NOP obj) {\n@@ -824,1 +668,0 @@\n-\n@@ -826,1 +669,1 @@\n-    public void visitICONST( final ICONST obj ) {\n+    public void visitPOP(final POP obj) {\n@@ -829,1 +672,0 @@\n-\n@@ -831,1 +673,1 @@\n-    public void visitFDIV( final FDIV obj ) {\n+    public void visitPOP2(final POP2 obj) {\n@@ -834,1 +676,0 @@\n-\n@@ -836,1 +677,1 @@\n-    public void visitI2B( final I2B obj ) {\n+    public void visitPopInstruction(final PopInstruction obj) {\n@@ -839,1 +680,0 @@\n-\n@@ -841,1 +681,1 @@\n-    public void visitLNEG( final LNEG obj ) {\n+    public void visitPushInstruction(final PushInstruction obj) {\n@@ -844,1 +684,0 @@\n-\n@@ -846,1 +685,1 @@\n-    public void visitLREM( final LREM obj ) {\n+    public void visitPUTFIELD(final PUTFIELD obj) {\n@@ -849,1 +688,0 @@\n-\n@@ -851,1 +689,1 @@\n-    public void visitIMUL( final IMUL obj ) {\n+    public void visitPUTSTATIC(final PUTSTATIC obj) {\n@@ -854,1 +692,0 @@\n-\n@@ -856,1 +693,1 @@\n-    public void visitIADD( final IADD obj ) {\n+    public void visitRET(final RET obj) {\n@@ -859,1 +696,0 @@\n-\n@@ -861,1 +697,1 @@\n-    public void visitLSHR( final LSHR obj ) {\n+    public void visitRETURN(final RETURN obj) {\n@@ -864,1 +700,0 @@\n-\n@@ -866,1 +701,1 @@\n-    public void visitLOOKUPSWITCH( final LOOKUPSWITCH obj ) {\n+    public void visitReturnInstruction(final ReturnInstruction obj) {\n@@ -869,1 +704,0 @@\n-\n@@ -871,1 +705,1 @@\n-    public void visitDUP_X1( final DUP_X1 obj ) {\n+    public void visitSALOAD(final SALOAD obj) {\n@@ -874,1 +708,0 @@\n-\n@@ -876,1 +709,1 @@\n-    public void visitFCMPL( final FCMPL obj ) {\n+    public void visitSASTORE(final SASTORE obj) {\n@@ -879,1 +712,0 @@\n-\n@@ -881,1 +713,1 @@\n-    public void visitI2C( final I2C obj ) {\n+    public void visitSelect(final Select obj) {\n@@ -884,1 +716,0 @@\n-\n@@ -886,1 +717,1 @@\n-    public void visitLMUL( final LMUL obj ) {\n+    public void visitSIPUSH(final SIPUSH obj) {\n@@ -889,1 +720,0 @@\n-\n@@ -891,1 +721,1 @@\n-    public void visitLUSHR( final LUSHR obj ) {\n+    public void visitStackConsumer(final StackConsumer obj) {\n@@ -894,1 +724,0 @@\n-\n@@ -896,1 +725,1 @@\n-    public void visitISHL( final ISHL obj ) {\n+    public void visitStackInstruction(final StackInstruction obj) {\n@@ -899,1 +728,0 @@\n-\n@@ -901,1 +729,1 @@\n-    public void visitLALOAD( final LALOAD obj ) {\n+    public void visitStackProducer(final StackProducer obj) {\n@@ -904,1 +732,0 @@\n-\n@@ -906,1 +733,1 @@\n-    public void visitASTORE( final ASTORE obj ) {\n+    public void visitStoreInstruction(final StoreInstruction obj) {\n@@ -909,1 +736,0 @@\n-\n@@ -911,1 +737,1 @@\n-    public void visitANEWARRAY( final ANEWARRAY obj ) {\n+    public void visitSWAP(final SWAP obj) {\n@@ -914,1 +740,0 @@\n-\n@@ -916,1 +741,1 @@\n-    public void visitFRETURN( final FRETURN obj ) {\n+    public void visitTABLESWITCH(final TABLESWITCH obj) {\n@@ -919,1 +744,0 @@\n-\n@@ -921,1 +745,1 @@\n-    public void visitFADD( final FADD obj ) {\n+    public void visitTypedInstruction(final TypedInstruction obj) {\n@@ -924,1 +748,0 @@\n-\n@@ -926,1 +749,1 @@\n-    public void visitBREAKPOINT( final BREAKPOINT obj ) {\n+    public void visitUnconditionalBranch(final UnconditionalBranch obj) {\n@@ -929,3 +752,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -933,1 +753,1 @@\n-    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC obj) {\n+    public void visitVariableLengthInstruction(final VariableLengthInstruction obj) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/EmptyVisitor.java","additions":184,"deletions":364,"binary":false,"changes":548,"status":"modified"},{"patch":"@@ -34,2 +34,1 @@\n-public class EnumElementValueGen extends ElementValueGen\n-{\n+public class EnumElementValueGen extends ElementValueGen {\n@@ -37,1 +36,1 @@\n-    private int typeIdx;\n+    private final int typeIdx;\n@@ -39,1 +38,14 @@\n-    private int valueIdx;\n+    private final int valueIdx;\n+\n+    public EnumElementValueGen(final EnumElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+        super(ENUM_CONSTANT, cpool);\n+        if (copyPoolEntries) {\n+            typeIdx = cpool.addUtf8(value.getEnumTypeString());\/\/ was\n+                                                               \/\/ addClass(value.getEnumTypeString());\n+            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was\n+                                                                  \/\/ addString(value.getEnumValueString());\n+        } else {\n+            typeIdx = value.getTypeIndex();\n+            valueIdx = value.getValueIndex();\n+        }\n+    }\n@@ -42,3 +54,2 @@\n-     * This ctor assumes the constant pool already contains the right type and\n-     * value - as indicated by typeIdx and valueIdx. This ctor is used for\n-     * deserialization\n+     * This ctor assumes the constant pool already contains the right type and value - as indicated by typeIdx and valueIdx.\n+     * This ctor is used for deserialization\n@@ -46,3 +57,1 @@\n-    protected EnumElementValueGen(final int typeIdx, final int valueIdx,\n-            final ConstantPoolGen cpool)\n-    {\n+    protected EnumElementValueGen(final int typeIdx, final int valueIdx, final ConstantPoolGen cpool) {\n@@ -51,3 +60,1 @@\n-            throw new IllegalArgumentException(\n-                    \"Only element values of type enum can be built with this ctor - type specified: \"\n-                            + super.getElementValueType());\n+            throw new IllegalArgumentException(\"Only element values of type enum can be built with this ctor - type specified: \" + super.getElementValueType());\n@@ -59,14 +66,1 @@\n-    \/**\n-     * Return immutable variant of this EnumElementValue\n-     *\/\n-    @Override\n-    public ElementValue getElementValue()\n-    {\n-        System.err.println(\"Duplicating value: \" + getEnumTypeString() + \":\"\n-                + getEnumValueString());\n-        return new EnumElementValue(super.getElementValueType(), typeIdx, valueIdx,\n-                getConstantPool().getConstantPool());\n-    }\n-\n-    public EnumElementValueGen(final ObjectType t, final String value, final ConstantPoolGen cpool)\n-    {\n+    public EnumElementValueGen(final ObjectType t, final String value, final ConstantPoolGen cpool) {\n@@ -78,18 +72,0 @@\n-    public EnumElementValueGen(final EnumElementValue value, final ConstantPoolGen cpool,\n-            final boolean copyPoolEntries)\n-    {\n-        super(ENUM_CONSTANT, cpool);\n-        if (copyPoolEntries)\n-        {\n-            typeIdx = cpool.addUtf8(value.getEnumTypeString());\/\/ was\n-                                                                \/\/ addClass(value.getEnumTypeString());\n-            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was\n-                                                                    \/\/ addString(value.getEnumValueString());\n-        }\n-        else\n-        {\n-            typeIdx = value.getTypeIndex();\n-            valueIdx = value.getValueIndex();\n-        }\n-    }\n-\n@@ -97,2 +73,1 @@\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n+    public void dump(final DataOutputStream dos) throws IOException {\n@@ -104,0 +79,3 @@\n+    \/**\n+     * Return immutable variant of this EnumElementValue\n+     *\/\n@@ -105,8 +83,3 @@\n-    public String stringifyValue()\n-    {\n-        final ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(valueIdx);\n-        return cu8.getBytes();\n-        \/\/ ConstantString cu8 =\n-        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n-        \/\/ return\n-        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n+    public ElementValue getElementValue() {\n+        System.err.println(\"Duplicating value: \" + getEnumTypeString() + \":\" + getEnumValueString());\n+        return new EnumElementValue(super.getElementValueType(), typeIdx, valueIdx, getConstantPool().getConstantPool());\n@@ -117,2 +90,1 @@\n-    public String getEnumTypeString()\n-    {\n+    public String getEnumTypeString() {\n@@ -124,2 +96,1 @@\n-        return ((ConstantUtf8) getConstantPool().getConstant(typeIdx))\n-                .getBytes();\n+        return ((ConstantUtf8) getConstantPool().getConstant(typeIdx)).getBytes();\n@@ -129,2 +100,1 @@\n-    public String getEnumValueString()\n-    {\n+    public String getEnumValueString() {\n@@ -138,2 +108,5 @@\n-    public int getValueIndex()\n-    {\n+    public int getTypeIndex() {\n+        return typeIdx;\n+    }\n+\n+    public int getValueIndex() {\n@@ -143,3 +116,8 @@\n-    public int getTypeIndex()\n-    {\n-        return typeIdx;\n+    @Override\n+    public String stringifyValue() {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(valueIdx);\n+        return cu8.getBytes();\n+        \/\/ ConstantString cu8 =\n+        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n+        \/\/ return\n+        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/EnumElementValueGen.java","additions":44,"deletions":66,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -25,4 +25,2 @@\n- * Denote an instruction that may throw a run-time or a linking\n- * exception (or both) during execution.  This is not quite the truth\n- * as such; because all instructions may throw an\n- * java.lang.VirtualMachineError. These exceptions are omitted.\n+ * Denote an instruction that may throw a run-time or a linking exception (or both) during execution. This is not quite\n+ * the truth as such; because all instructions may throw an java.lang.VirtualMachineError. These exceptions are omitted.\n@@ -30,10 +28,3 @@\n- * The Lava Language Specification specifies exactly which\n- * <i>RUN-TIME<\/i> and which <i>LINKING<\/i> exceptions each\n- * instruction may throw which is reflected by the implementers.  Due\n- * to the structure of the JVM specification, it may be possible that\n- * an Instruction implementing this interface returns a Class[] of\n- * size 0.\n- *\n- * Please note that we speak of an \"exception\" here when we mean any\n- * \"Throwable\" object; so this term is equally used for \"Exception\"\n- * and \"Error\" objects.\n+ * The Lava Language Specification specifies exactly which <i>RUN-TIME<\/i> and which <i>LINKING<\/i> exceptions each\n+ * instruction may throw which is reflected by the implementers. Due to the structure of the JVM specification, it may\n+ * be possible that an Instruction implementing this interface returns a Class[] of size 0.\n@@ -41,0 +32,2 @@\n+ * Please note that we speak of an \"exception\" here when we mean any \"Throwable\" object; so this term is equally used\n+ * for \"Exception\" and \"Error\" objects.\n@@ -44,1 +37,1 @@\n-    java.lang.Class<?>[] getExceptions();\n+    Class<?>[] getExceptions();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ExceptionThrower.java","additions":8,"deletions":15,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert float to double\n+    \/**\n+     * Convert float to double\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2D.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert float to int\n+    \/**\n+     * Convert float to int\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2I.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert float to long\n+    \/**\n+     * Convert float to long\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Add floats\n+    \/**\n+     * Add floats\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; ..., value\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Load float from array\n+    \/**\n+     * Load float from array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * FASTORE -  Store into float array\n- * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n+ * FASTORE - Store into float array\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value -&gt; ...\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Store float into array\n+    \/**\n+     * Store float into array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,9 +37,0 @@\n-\n-    \/** @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.FLOAT;\n-    }\n-\n-\n@@ -45,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -53,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -59,0 +50,8 @@\n+\n+    \/**\n+     * @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.FLOAT;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCMPG.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,9 +37,0 @@\n-\n-    \/** @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.FLOAT;\n-    }\n-\n-\n@@ -45,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -53,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -59,0 +50,8 @@\n+\n+    \/**\n+     * @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.FLOAT;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCMPL.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,2 +26,3 @@\n- * <PRE>Stack: ... -&gt; ..., <\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ...,\n+ * <\/PRE>\n@@ -32,2 +33,1 @@\n-    private float value;\n-\n+    private final float value;\n@@ -36,2 +36,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -40,0 +39,1 @@\n+        this(0);\n@@ -42,1 +42,0 @@\n-\n@@ -57,15 +56,0 @@\n-\n-    @Override\n-    public Number getValue() {\n-        return value;\n-    }\n-\n-\n-    \/** @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.FLOAT;\n-    }\n-\n-\n@@ -73,4 +57,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -81,1 +63,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -88,0 +70,13 @@\n+\n+    \/**\n+     * @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.FLOAT;\n+    }\n+\n+    @Override\n+    public Number getValue() {\n+        return Float.valueOf(value);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCONST.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Divide floats\n+    \/**\n+     * Divide floats\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FDIV.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack ... -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack ... -&gt; ..., result\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,2 +40,3 @@\n-\n-    \/** Load float from local variable\n+    \/**\n+     * Load float from local variable\n+     *\n@@ -47,1 +49,0 @@\n-\n@@ -49,4 +50,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +56,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FLOAD.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Multiply floats\n+    \/**\n+     * Multiply floats\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FNEG.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Remainder of floats\n+    \/**\n+     * Remainder of floats\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FREM.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * FRETURN -  Return float from method\n- * <PRE>Stack: ..., value -&gt; &lt;empty&gt;<\/PRE>\n+ * FRETURN - Return float from method\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; &lt;empty&gt;\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Return float from method\n+    \/**\n+     * Return float from method\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ... <\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,2 +40,3 @@\n-\n-    \/** Store float into local variable\n+    \/**\n+     * Store float into local variable\n+     *\n@@ -47,1 +49,0 @@\n-\n@@ -49,4 +50,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +56,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FSTORE.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Substract floats\n+    \/**\n+     * Substract floats\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FSUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+import java.util.stream.Stream;\n@@ -27,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;\n@@ -39,3 +39,2 @@\n- * Template class for building up a field.  The only extraordinary thing\n- * one can do is to add a constant value attribute to a field (which must of\n- * course be compatible with to the declared type).\n+ * Template class for building up a field. The only extraordinary thing one can do is to add a constant value attribute\n+ * to a field (which must of course be compatible with to the declared type).\n@@ -48,1 +47,0 @@\n-    private Object value = null;\n@@ -52,1 +50,1 @@\n-        public boolean equals( final Object o1, final Object o2 ) {\n+        public boolean equals(final Object o1, final Object o2) {\n@@ -55,2 +53,1 @@\n-            return Objects.equals(THIS.getName(), THAT.getName())\n-                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -59,1 +56,0 @@\n-\n@@ -61,1 +57,1 @@\n-        public int hashCode( final Object o ) {\n+        public int hashCode(final Object o) {\n@@ -67,0 +63,6 @@\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n@@ -69,8 +71,1 @@\n-     * Declare a field. If it is static (isStatic() == true) and has a\n-     * basic type like int or String it may have an initial value\n-     * associated with it as defined by setInitValue().\n-     *\n-     * @param access_flags access qualifiers\n-     * @param type  field type\n-     * @param name field name\n-     * @param cp constant pool\n+     * @param comparator Comparison strategy object\n@@ -78,5 +73,2 @@\n-    public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {\n-        super(access_flags);\n-        setType(type);\n-        setName(name);\n-        setConstantPool(cp);\n+    public static void setComparator(final BCELComparator comparator) {\n+        bcelComparator = comparator;\n@@ -85,0 +77,3 @@\n+    private Object value;\n+\n+    private List<FieldObserver> observers;\n@@ -99,5 +94,2 @@\n-                final Annotations runtimeAnnotations = (Annotations)attr;\n-                final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();\n-                for (final AnnotationEntry element : annotationEntries) {\n-                    addAnnotationEntry(new AnnotationEntryGen(element,cp,false));\n-                }\n+                final Annotations runtimeAnnotations = (Annotations) attr;\n+                runtimeAnnotations.forEach(element -> addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n@@ -110,8 +102,0 @@\n-\n-    private void setValue( final int index ) {\n-        final ConstantPool cp = super.getConstantPool().getConstantPool();\n-        final Constant c = cp.getConstant(index);\n-        value = ((ConstantObject) c).getConstantValue(cp);\n-    }\n-\n-\n@@ -119,2 +103,7 @@\n-     * Set (optional) initial value of field, otherwise it will be set to null\/0\/false\n-     * by the JVM automatically.\n+     * Declare a field. If it is static (isStatic() == true) and has a basic type like int or String it may have an initial\n+     * value associated with it as defined by setInitValue().\n+     *\n+     * @param accessFlags access qualifiers\n+     * @param type field type\n+     * @param name field name\n+     * @param cp constant pool\n@@ -122,45 +111,5 @@\n-    public void setInitValue( final String str ) {\n-        checkType(  ObjectType.getInstance(\"java.lang.String\"));\n-        if (str != null) {\n-            value = str;\n-        }\n-    }\n-\n-\n-    public void setInitValue( final long l ) {\n-        checkType(Type.LONG);\n-        if (l != 0L) {\n-            value = Long.valueOf(l);\n-        }\n-    }\n-\n-\n-    public void setInitValue( final int i ) {\n-        checkType(Type.INT);\n-        if (i != 0) {\n-            value = Integer.valueOf(i);\n-        }\n-    }\n-\n-\n-    public void setInitValue( final short s ) {\n-        checkType(Type.SHORT);\n-        if (s != 0) {\n-            value = Integer.valueOf(s);\n-        }\n-    }\n-\n-\n-    public void setInitValue( final char c ) {\n-        checkType(Type.CHAR);\n-        if (c != 0) {\n-            value = Integer.valueOf(c);\n-        }\n-    }\n-\n-\n-    public void setInitValue( final byte b ) {\n-        checkType(Type.BYTE);\n-        if (b != 0) {\n-            value = Integer.valueOf(b);\n-        }\n+    public FieldGen(final int accessFlags, final Type type, final String name, final ConstantPoolGen cp) {\n+        super(accessFlags);\n+        setType(type);\n+        setName(name);\n+        setConstantPool(cp);\n@@ -169,6 +118,2 @@\n-\n-    public void setInitValue( final boolean b ) {\n-        checkType(Type.BOOLEAN);\n-        if (b) {\n-            value = Integer.valueOf(1);\n-        }\n+    private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        Stream.of(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries())).forEach(this::addAttribute);\n@@ -177,5 +122,18 @@\n-\n-    public void setInitValue( final float f ) {\n-        checkType(Type.FLOAT);\n-        if (f != 0.0) {\n-            value = f;\n+    private int addConstant() {\n+        switch (super.getType().getType()) { \/\/ sic\n+        case Const.T_INT:\n+        case Const.T_CHAR:\n+        case Const.T_BYTE:\n+        case Const.T_BOOLEAN:\n+        case Const.T_SHORT:\n+            return super.getConstantPool().addInteger(((Integer) value).intValue());\n+        case Const.T_FLOAT:\n+            return super.getConstantPool().addFloat(((Float) value).floatValue());\n+        case Const.T_DOUBLE:\n+            return super.getConstantPool().addDouble(((Double) value).doubleValue());\n+        case Const.T_LONG:\n+            return super.getConstantPool().addLong(((Long) value).longValue());\n+        case Const.T_REFERENCE:\n+            return super.getConstantPool().addString((String) value);\n+        default:\n+            throw new IllegalStateException(\"Unhandled : \" + super.getType().getType()); \/\/ sic\n@@ -185,5 +143,6 @@\n-\n-    public void setInitValue( final double d ) {\n-        checkType(Type.DOUBLE);\n-        if (d != 0.0) {\n-            value = d;\n+    \/**\n+     * Add observer for this object.\n+     *\/\n+    public void addObserver(final FieldObserver o) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n@@ -191,0 +150,1 @@\n+        observers.add(o);\n@@ -193,2 +153,2 @@\n-\n-    \/** Remove any initial value.\n+    \/**\n+     * Remove any initial value.\n@@ -200,2 +160,1 @@\n-\n-    private void checkType( final Type atype ) {\n+    private void checkType(final Type atype) {\n@@ -214,0 +173,19 @@\n+    \/**\n+     * @return deep copy of this field\n+     *\/\n+    public FieldGen copy(final ConstantPoolGen cp) {\n+        final FieldGen fg = (FieldGen) clone();\n+        fg.setConstantPool(cp);\n+        return fg;\n+    }\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy. By default two FieldGen objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see Object#equals(Object)\n+     *\/\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return bcelComparator.equals(this, obj);\n+    }\n@@ -220,2 +198,2 @@\n-        final int name_index = super.getConstantPool().addUtf8(super.getName());\n-        final int signature_index = super.getConstantPool().addUtf8(signature);\n+        final int nameIndex = super.getConstantPool().addUtf8(super.getName());\n+        final int signatureIndex = super.getConstantPool().addUtf8(signature);\n@@ -225,2 +203,1 @@\n-            addAttribute(new ConstantValue(super.getConstantPool().addUtf8(\"ConstantValue\"), 2, index,\n-                    super.getConstantPool().getConstantPool())); \/\/ sic\n+            addAttribute(new ConstantValue(super.getConstantPool().addUtf8(\"ConstantValue\"), 2, index, super.getConstantPool().getConstantPool())); \/\/ sic\n@@ -229,2 +206,1 @@\n-        return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),\n-                super.getConstantPool().getConstantPool()); \/\/ sic\n+        return new Field(super.getAccessFlags(), nameIndex, signatureIndex, getAttributes(), super.getConstantPool().getConstantPool()); \/\/ sic\n@@ -233,26 +209,3 @@\n-    private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-          final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n-        for (final Attribute attr : attrs) {\n-            addAttribute(attr);\n-        }\n-      }\n-\n-\n-    private int addConstant() {\n-        switch (super.getType().getType()) { \/\/ sic\n-            case Const.T_INT:\n-            case Const.T_CHAR:\n-            case Const.T_BYTE:\n-            case Const.T_BOOLEAN:\n-            case Const.T_SHORT:\n-                return super.getConstantPool().addInteger(((Integer) value));\n-            case Const.T_FLOAT:\n-                return super.getConstantPool().addFloat(((Float) value));\n-            case Const.T_DOUBLE:\n-                return super.getConstantPool().addDouble(((Double) value));\n-            case Const.T_LONG:\n-                return super.getConstantPool().addLong(((Long) value));\n-            case Const.T_REFERENCE:\n-                return super.getConstantPool().addString((String) value);\n-            default:\n-                throw new IllegalStateException(\"Unhandled : \" + super.getType().getType()); \/\/ sic\n+    public String getInitValue() {\n+        if (value != null) {\n+            return value.toString();\n@@ -260,0 +213,1 @@\n+        return null;\n@@ -262,1 +216,0 @@\n-\n@@ -268,4 +221,5 @@\n-    private List<FieldObserver> observers;\n-\n-\n-    \/** Add observer for this object.\n+    \/**\n+     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n+     * signature.\n+     *\n+     * @see Object#hashCode()\n@@ -273,5 +227,3 @@\n-    public void addObserver( final FieldObserver o ) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n@@ -280,2 +232,2 @@\n-\n-    \/** Remove observer for this object.\n+    \/**\n+     * Remove observer for this object.\n@@ -283,1 +235,1 @@\n-    public void removeObserver( final FieldObserver o ) {\n+    public void removeObserver(final FieldObserver o) {\n@@ -289,0 +241,6 @@\n+    public void setInitValue(final boolean b) {\n+        checkType(Type.BOOLEAN);\n+        if (b) {\n+            value = Integer.valueOf(1);\n+        }\n+    }\n@@ -290,9 +248,4 @@\n-    \/** Call notify() method on all observers. This method is not called\n-     * automatically whenever the state has changed, but has to be\n-     * called by the user after he has finished editing the object.\n-     *\/\n-    public void update() {\n-        if (observers != null) {\n-            for (final FieldObserver observer : observers ) {\n-                observer.notify(this);\n-            }\n+    public void setInitValue(final byte b) {\n+        checkType(Type.BYTE);\n+        if (b != 0) {\n+            value = Integer.valueOf(b);\n@@ -302,0 +255,6 @@\n+    public void setInitValue(final char c) {\n+        checkType(Type.CHAR);\n+        if (c != 0) {\n+            value = Integer.valueOf(c);\n+        }\n+    }\n@@ -303,3 +262,32 @@\n-    public String getInitValue() {\n-        if (value != null) {\n-            return value.toString();\n+    public void setInitValue(final double d) {\n+        checkType(Type.DOUBLE);\n+        if (d != 0.0) {\n+            value = Double.valueOf(d);\n+        }\n+    }\n+\n+    public void setInitValue(final float f) {\n+        checkType(Type.FLOAT);\n+        if (f != 0.0) {\n+            value = Float.valueOf(f);\n+        }\n+    }\n+\n+    public void setInitValue(final int i) {\n+        checkType(Type.INT);\n+        if (i != 0) {\n+            value = Integer.valueOf(i);\n+        }\n+    }\n+\n+    public void setInitValue(final long l) {\n+        checkType(Type.LONG);\n+        if (l != 0L) {\n+            value = Long.valueOf(l);\n+        }\n+    }\n+\n+    public void setInitValue(final short s) {\n+        checkType(Type.SHORT);\n+        if (s != 0) {\n+            value = Integer.valueOf(s);\n@@ -307,1 +295,0 @@\n-        return null;\n@@ -310,0 +297,15 @@\n+    \/**\n+     * Set (optional) initial value of field, otherwise it will be set to null\/0\/false by the JVM automatically.\n+     *\/\n+    public void setInitValue(final String str) {\n+        checkType(ObjectType.getInstance(\"java.lang.String\"));\n+        if (str != null) {\n+            value = str;\n+        }\n+    }\n+\n+    private void setValue(final int index) {\n+        final ConstantPool cp = super.getConstantPool().getConstantPool();\n+        final Constant c = cp.getConstant(index);\n+        value = ((ConstantObject) c).getConstantValue(cp);\n+    }\n@@ -312,2 +314,1 @@\n-     * Return string representation close to declaration format,\n-     * `public static final short MAX = 100', e.g..\n+     * Return string representation close to declaration format, 'public static final short MAX = 100', e.g..\n@@ -323,1 +324,1 @@\n-        access = access.isEmpty() ? \"\" : (access + \" \");\n+        access = access.isEmpty() ? \"\" : access + \" \";\n@@ -335,10 +336,0 @@\n-\n-    \/** @return deep copy of this field\n-     *\/\n-    public FieldGen copy( final ConstantPoolGen cp ) {\n-        final FieldGen fg = (FieldGen) clone();\n-        fg.setConstantPool(cp);\n-        return fg;\n-    }\n-\n-\n@@ -346,1 +337,2 @@\n-     * @return Comparison strategy object\n+     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n+     * has to be called by the user after they have finished editing the object.\n@@ -348,35 +340,6 @@\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator( final BCELComparator comparator ) {\n-        bcelComparator = comparator;\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default two FieldGen objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see java.lang.Object#equals(java.lang.Object)\n-     *\/\n-    @Override\n-    public boolean equals( final Object obj ) {\n-        return bcelComparator.equals(this, obj);\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default return the hashcode of the field's name XOR signature.\n-     *\n-     * @see java.lang.Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n+    public void update() {\n+        if (observers != null) {\n+            for (final FieldObserver observer : observers) {\n+                observer.notify(this);\n+            }\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGen.java","additions":173,"deletions":210,"binary":false,"changes":383,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import java.util.Collections;\n@@ -30,2 +31,1 @@\n- * Super class for FieldGen and MethodGen objects, since they have\n- * some methods in common!\n+ * Super class for FieldGen and MethodGen objects, since they have some methods in common!\n@@ -37,3 +37,17 @@\n-    private String name;\n-    private Type type;\n-    private ConstantPoolGen cp;\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected String name;\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected Type type;\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected ConstantPoolGen cp;\n@@ -46,1 +60,0 @@\n-\n@@ -50,1 +63,0 @@\n-\n@@ -54,2 +66,2 @@\n-    protected FieldGenOrMethodGen(final int access_flags) { \/\/ TODO could this be package protected?\n-        super(access_flags);\n+    protected FieldGenOrMethodGen(final int accessFlags) { \/\/ TODO could this be package protected?\n+        super(accessFlags);\n@@ -58,6 +70,2 @@\n-    @Override\n-    public void setType( final Type type ) { \/\/ TODO could be package-protected?\n-        if (type.getType() == Const.T_ADDRESS) {\n-            throw new IllegalArgumentException(\"Type can not be \" + type);\n-        }\n-        this.type = type;\n+    protected void addAll(final Attribute[] attrs) {\n+        Collections.addAll(attributeList, attrs);\n@@ -66,4 +74,5 @@\n-\n-    @Override\n-    public Type getType() {\n-        return type;\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void addAnnotationEntry(final AnnotationEntryGen ag) {\n+        annotationList.add(ag);\n@@ -72,2 +81,5 @@\n-\n-    \/** @return name of method\/field.\n+    \/**\n+     * Add an attribute to this method. Currently, the JVM knows about the 'Code', 'ConstantValue', 'Synthetic' and\n+     * 'Exceptions' attributes. Other attributes will be ignored by the JVM but do no harm.\n+     *\n+     * @param a attribute to be added\n@@ -75,3 +87,2 @@\n-    @Override\n-    public String getName() {\n-        return name;\n+    public void addAttribute(final Attribute a) {\n+        attributeList.add(a);\n@@ -80,1 +91,0 @@\n-\n@@ -82,2 +92,6 @@\n-    public void setName( final String name ) { \/\/ TODO could be package-protected?\n-        this.name = name;\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n@@ -86,3 +100,2 @@\n-\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n+    public AnnotationEntryGen[] getAnnotationEntries() {\n+        return annotationList.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n@@ -91,3 +104,5 @@\n-\n-    public void setConstantPool( final ConstantPoolGen cp ) { \/\/ TODO could be package-protected?\n-        this.cp = cp;\n+    \/**\n+     * @return all attributes of this method.\n+     *\/\n+    public Attribute[] getAttributes() {\n+        return attributeList.toArray(Attribute.EMPTY_ARRAY);\n@@ -96,0 +111,3 @@\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n+    }\n@@ -98,6 +116,1 @@\n-     * Add an attribute to this method. Currently, the JVM knows about\n-     * the `Code', `ConstantValue', `Synthetic' and `Exceptions'\n-     * attributes. Other attributes will be ignored by the JVM but do no\n-     * harm.\n-     *\n-     * @param a attribute to be added\n+     * @return name of method\/field.\n@@ -105,2 +118,3 @@\n-    public void addAttribute( final Attribute a ) {\n-        attributeList.add(a);\n+    @Override\n+    public String getName() {\n+        return name;\n@@ -110,1 +124,1 @@\n-     * @since 6.0\n+     * @return signature of method\/field.\n@@ -112,4 +126,1 @@\n-    public void addAnnotationEntry(final AnnotationEntryGen ag)\n-    {\n-        annotationList.add(ag);\n-    }\n+    public abstract String getSignature();\n@@ -117,0 +128,4 @@\n+    @Override\n+    public Type getType() {\n+        return type;\n+    }\n@@ -119,1 +134,1 @@\n-     * Remove an attribute.\n+     * @since 6.0\n@@ -121,2 +136,2 @@\n-    public void removeAttribute( final Attribute a ) {\n-        attributeList.remove(a);\n+    public void removeAnnotationEntries() {\n+        annotationList.clear();\n@@ -128,2 +143,1 @@\n-    public void removeAnnotationEntry(final AnnotationEntryGen ag)\n-    {\n+    public void removeAnnotationEntry(final AnnotationEntryGen ag) {\n@@ -133,0 +147,6 @@\n+    \/**\n+     * Remove an attribute.\n+     *\/\n+    public void removeAttribute(final Attribute a) {\n+        attributeList.remove(a);\n+    }\n@@ -141,6 +161,2 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public void removeAnnotationEntries()\n-    {\n-        annotationList.clear();\n+    public void setConstantPool(final ConstantPoolGen cp) { \/\/ TODO could be package-protected?\n+        this.cp = cp;\n@@ -149,6 +165,3 @@\n-\n-    \/**\n-     * @return all attributes of this method.\n-     *\/\n-    public Attribute[] getAttributes() {\n-        return attributeList.toArray(new Attribute[0]);\n+    @Override\n+    public void setName(final String name) { \/\/ TODO could be package-protected?\n+        this.name = name;\n@@ -157,10 +170,0 @@\n-    public AnnotationEntryGen[] getAnnotationEntries() {\n-        return annotationList.toArray(new AnnotationEntryGen[0]);\n-      }\n-\n-\n-    \/** @return signature of method\/field.\n-     *\/\n-    public abstract String getSignature();\n-\n-\n@@ -168,5 +171,3 @@\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+    public void setType(final Type type) { \/\/ TODO could be package-protected?\n+        if (type.getType() == Const.T_ADDRESS) {\n+            throw new IllegalArgumentException(\"Type can not be \" + type);\n@@ -174,0 +175,1 @@\n+        this.type = type;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGenOrMethodGen.java","additions":80,"deletions":78,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- *\n@@ -33,2 +32,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +37,0 @@\n-\n@@ -47,1 +44,0 @@\n-\n@@ -49,1 +45,1 @@\n-     * @return mnemonic for instruction with symbolic references resolved\n+     * @return name of referenced field.\n@@ -51,4 +47,2 @@\n-    @Override\n-    public String toString( final ConstantPool cp ) {\n-        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \"\n-                + cp.constantToString(super.getIndex(), com.sun.org.apache.bcel.internal.Const.CONSTANT_Fieldref);\n+    public String getFieldName(final ConstantPoolGen cpg) {\n+        return getName(cpg);\n@@ -57,2 +51,2 @@\n-\n-    \/** @return size of field (1 or 2)\n+    \/**\n+     * @return size of field (1 or 2)\n@@ -60,1 +54,1 @@\n-    protected int getFieldSize( final ConstantPoolGen cpg ) {\n+    protected int getFieldSize(final ConstantPoolGen cpg) {\n@@ -64,2 +58,2 @@\n-\n-    \/** @return return type of referenced field\n+    \/**\n+     * @return type of field\n@@ -67,3 +61,2 @@\n-    @Override\n-    public Type getType( final ConstantPoolGen cpg ) {\n-        return getFieldType(cpg);\n+    public Type getFieldType(final ConstantPoolGen cpg) {\n+        return Type.getType(getSignature(cpg));\n@@ -72,2 +65,2 @@\n-\n-    \/** @return type of field\n+    \/**\n+     * @return return type of referenced field\n@@ -75,2 +68,3 @@\n-    public Type getFieldType( final ConstantPoolGen cpg ) {\n-        return Type.getType(getSignature(cpg));\n+    @Override\n+    public Type getType(final ConstantPoolGen cpg) {\n+        return getFieldType(cpg);\n@@ -79,2 +73,2 @@\n-\n-    \/** @return name of referenced field.\n+    \/**\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -82,2 +76,3 @@\n-    public String getFieldName( final ConstantPoolGen cpg ) {\n-        return getName(cpg);\n+    @Override\n+    public String toString(final ConstantPool cp) {\n+        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + cp.constantToString(super.getIndex(), com.sun.org.apache.bcel.internal.Const.CONSTANT_Fieldref);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldInstruction.java","additions":21,"deletions":26,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,3 +25,2 @@\n- * Imnplement this interface if you're interested in changes to a FieldGen object\n- * and register yourself with addObserver().\n- *\n+ * Imnplement this interface if you're interested in changes to a FieldGen object and register yourself with\n+ * addObserver().\n@@ -31,1 +30,1 @@\n-    void notify( FieldGen field );\n+    void notify(FieldGen field);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldObserver.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -31,3 +32,1 @@\n- * Super class for InvokeInstruction and FieldInstruction, since they have\n- * some methods in common!\n- *\n+ * Super class for InvokeInstruction and FieldInstruction, since they have some methods in common!\n@@ -38,2 +37,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -45,1 +43,0 @@\n-\n@@ -53,21 +50,0 @@\n-\n-    \/** @return signature of referenced method\/field.\n-     *\/\n-    public String getSignature(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n-        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n-        return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();\n-    }\n-\n-\n-    \/** @return name of referenced method\/field.\n-     *\/\n-    public String getName(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n-        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n-        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n-    }\n-\n-\n@@ -76,7 +52,4 @@\n-     * @deprecated If the instruction references an array class,\n-     *    this method will return \"java.lang.Object\".\n-     *    For code generated by Java 1.5, this answer is\n-     *    sometimes wrong (e.g., if the \"clone()\" method is\n-     *    called on an array).  A better idea is to use\n-     *    the {@link #getReferenceType(ConstantPoolGen)} method, which correctly distinguishes\n-     *    between class types and array types.\n+     * @deprecated If the instruction references an array class, this method will return \"java.lang.Object\". For code\n+     *             generated by Java 1.5, this answer is sometimes wrong (e.g., if the \"clone()\" method is called on an\n+     *             array). A better idea is to use the {@link #getReferenceType(ConstantPoolGen)} method, which correctly\n+     *             distinguishes between class types and array types.\n@@ -94,1 +67,1 @@\n-        return className.replace('\/', '.');\n+        return Utility.pathToPackage(className);\n@@ -97,5 +70,4 @@\n-\n-    \/** @return type of the referenced class\/interface\n-     * @deprecated If the instruction references an array class,\n-     *    the ObjectType returned will be invalid.  Use\n-     *    getReferenceType() instead.\n+    \/**\n+     * @return type of the referenced class\/interface\n+     * @deprecated If the instruction references an array class, the ObjectType returned will be invalid. Use\n+     *             getReferenceType() instead.\n@@ -108,0 +80,24 @@\n+    \/**\n+     * Gets the ObjectType of the method return or field.\n+     *\n+     * @return type of the referenced class\/interface\n+     * @throws ClassGenException when the field is (or method returns) an array,\n+     *\/\n+    @Override\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+        final ReferenceType rt = getReferenceType(cpg);\n+        if (rt instanceof ObjectType) {\n+            return (ObjectType) rt;\n+        }\n+        throw new ClassGenException(rt.getClass().getCanonicalName() + \" \" + rt.getSignature() + \" does not represent an ObjectType\");\n+    }\n+\n+    \/**\n+     * @return name of referenced method\/field.\n+     *\/\n+    public String getName(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n+        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n+    }\n@@ -110,2 +106,2 @@\n-     * Gets the reference type representing the class, interface,\n-     * or array class referenced by the instruction.\n+     * Gets the reference type representing the class, interface, or array class referenced by the instruction.\n+     *\n@@ -113,3 +109,2 @@\n-     * @return an ObjectType (if the referenced class type is a class\n-     *   or interface), or an ArrayType (if the referenced class\n-     *   type is an array class)\n+     * @return an ObjectType (if the referenced class type is a class or interface), or an ArrayType (if the referenced\n+     *         class type is an array class)\n@@ -124,1 +119,1 @@\n-        className = className.replace('\/', '.');\n+        className = Utility.pathToPackage(className);\n@@ -128,1 +123,0 @@\n-\n@@ -130,4 +124,1 @@\n-     * Gets the ObjectType of the method return or field.\n-     *\n-     * @return type of the referenced class\/interface\n-     * @throws ClassGenException when the field is (or method returns) an array,\n+     * @return signature of referenced method\/field.\n@@ -135,8 +126,5 @@\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        final ReferenceType rt = getReferenceType(cpg);\n-        if (rt instanceof ObjectType) {\n-            return (ObjectType) rt;\n-        }\n-        throw new ClassGenException(rt.getClass().getCanonicalName() + \" \" +\n-                rt.getSignature() + \" does not represent an ObjectType\");\n+    public String getSignature(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n+        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldOrMethod.java","additions":47,"deletions":59,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -28,1 +28,5 @@\n- * <PRE>Stack: ..., objectref -&gt; ..., value<\/PRE>\n+ *\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; ..., value\n+ * <\/PRE>\n+ *\n@@ -30,1 +34,0 @@\n- * <PRE>Stack: ..., objectref -&gt; ..., value.word1, value.word2<\/PRE>\n@@ -32,0 +35,3 @@\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; ..., value.word1, value.word2\n+ * <\/PRE>\n@@ -33,2 +39,1 @@\n-public class GETFIELD extends FieldInstruction implements ExceptionThrower, StackConsumer,\n-        StackProducer {\n+public class GETFIELD extends FieldInstruction implements ExceptionThrower, StackConsumer, StackProducer {\n@@ -37,2 +42,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,1 +47,0 @@\n-\n@@ -48,15 +51,0 @@\n-\n-    @Override\n-    public int produceStack( final ConstantPoolGen cpg ) {\n-        return getFieldSize(cpg);\n-    }\n-\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n-            ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-\n@@ -64,4 +52,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -72,1 +58,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -83,0 +69,11 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+    @Override\n+    public int produceStack(final ConstantPoolGen cpg) {\n+        return getFieldSize(cpg);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GETFIELD.java","additions":24,"deletions":27,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -29,1 +29,5 @@\n- * <PRE>Stack: ..., -&gt; ..., value<\/PRE>\n+ *\n+ * <PRE>\n+ * Stack: ..., -&gt; ..., value\n+ * <\/PRE>\n+ *\n@@ -31,1 +35,0 @@\n- * <PRE>Stack: ..., -&gt; ..., value.word1, value.word2<\/PRE>\n@@ -33,0 +36,3 @@\n+ * <PRE>\n+ * Stack: ..., -&gt; ..., value.word1, value.word2\n+ * <\/PRE>\n@@ -37,2 +43,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,1 +48,0 @@\n-\n@@ -48,14 +52,0 @@\n-\n-    @Override\n-    public int produceStack( final ConstantPoolGen cpg ) {\n-        return getFieldSize(cpg);\n-    }\n-\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-\n@@ -63,4 +53,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -71,1 +59,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -82,0 +70,10 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+    @Override\n+    public int produceStack(final ConstantPoolGen cpg) {\n+        return getFieldSize(cpg);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GETSTATIC.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- *\n@@ -34,2 +33,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -40,1 +38,0 @@\n-\n@@ -45,0 +42,14 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitUnconditionalBranch(this);\n+        v.visitBranchInstruction(this);\n+        v.visitGotoInstruction(this);\n+        v.visitGOTO(this);\n+    }\n@@ -48,0 +59,1 @@\n+     *\n@@ -51,1 +63,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -53,2 +65,2 @@\n-        final short _opcode = getOpcode();\n-        if (_opcode == com.sun.org.apache.bcel.internal.Const.GOTO) {\n+        final short opcode = getOpcode();\n+        if (opcode == com.sun.org.apache.bcel.internal.Const.GOTO) {\n@@ -58,1 +70,1 @@\n-            out.writeByte(_opcode);\n+            out.writeByte(opcode);\n@@ -63,1 +75,0 @@\n-\n@@ -65,2 +76,2 @@\n-     * Called in pass 2 of InstructionList.setPositions() in order to update\n-     * the branch target, that may shift due to variable length instructions.\n+     * Called in pass 2 of InstructionList.setPositions() in order to update the branch target, that may shift due to\n+     * variable length instructions.\n@@ -69,1 +80,1 @@\n-     * @param max_offset the maximum offset that may be caused by these instructions\n+     * @param maxOffset the maximum offset that may be caused by these instructions\n@@ -73,1 +84,1 @@\n-    protected int updatePosition( final int offset, final int max_offset ) {\n+    protected int updatePosition(final int offset, final int maxOffset) {\n@@ -76,1 +87,1 @@\n-        if (Math.abs(i) >= (Short.MAX_VALUE - max_offset)) { \/\/ to large for short (estimate)\n+        if (Math.abs(i) >= Short.MAX_VALUE - maxOffset) { \/\/ to large for short (estimate)\n@@ -78,1 +89,1 @@\n-            final short old_length = (short) super.getLength();\n+            final short oldLength = (short) super.getLength();\n@@ -80,1 +91,1 @@\n-            return super.getLength() - old_length;\n+            return super.getLength() - oldLength;\n@@ -84,18 +95,0 @@\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitUnconditionalBranch(this);\n-        v.visitBranchInstruction(this);\n-        v.visitGotoInstruction(this);\n-        v.visitGOTO(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GOTO.java","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- *\n@@ -36,2 +35,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -42,1 +40,0 @@\n-\n@@ -48,0 +45,13 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitUnconditionalBranch(this);\n+        v.visitBranchInstruction(this);\n+        v.visitGotoInstruction(this);\n+        v.visitGOTO_W(this);\n+    }\n@@ -51,0 +61,1 @@\n+     *\n@@ -54,1 +65,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -60,1 +71,0 @@\n-\n@@ -65,1 +75,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -69,17 +79,0 @@\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitUnconditionalBranch(this);\n-        v.visitBranchInstruction(this);\n-        v.visitGotoInstruction(this);\n-        v.visitGOTO_W(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GOTO_W.java","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -30,5 +29,0 @@\n-    GotoInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, target);\n-    }\n-\n-\n@@ -36,2 +30,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -41,0 +34,4 @@\n+\n+    GotoInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, target);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GotoInstruction.java","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert int to byte\n+    \/**\n+     * Convert int to byte\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2B.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert int to char\n+    \/**\n+     * Convert int to char\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2C.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert int to double\n+    \/**\n+     * Convert int to double\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2D.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert int to float\n+    \/**\n+     * Convert int to float\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2F.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Convert int to long\n+    \/**\n+     * Convert int to long\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2S.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Add ints\n+    \/**\n+     * Add ints\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; ..., value\n+ * <\/PRE>\n@@ -38,1 +40,0 @@\n-\n@@ -40,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IALOAD.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IAND.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * IASTORE -  Store into int array\n- * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n+ * IASTORE - Store into int array\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value -&gt; ...\n+ * <\/PRE>\n@@ -38,1 +40,0 @@\n-\n@@ -40,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IASTORE.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * <PRE>Stack: ... -&gt; ..., <\/PRE>\n+ * <PRE>\n+ * Stack: ... -&gt; ...,\n+ * <\/PRE>\n@@ -30,2 +32,1 @@\n-    private int value;\n-\n+    private final int value;\n@@ -34,2 +35,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -38,0 +38,1 @@\n+        this(0);\n@@ -40,1 +41,0 @@\n-\n@@ -43,3 +43,1 @@\n-        if ((i >= -1) && (i <= 5)) {\n-            super.setOpcode((short) (com.sun.org.apache.bcel.internal.Const.ICONST_0 + i)); \/\/ Even works for i == -1\n-        } else {\n+        if (i < -1 || i > 5) {\n@@ -48,0 +46,1 @@\n+        super.setOpcode((short) (com.sun.org.apache.bcel.internal.Const.ICONST_0 + i)); \/\/ Even works for i == -1\n@@ -51,15 +50,0 @@\n-\n-    @Override\n-    public Number getValue() {\n-        return Integer.valueOf(value);\n-    }\n-\n-\n-    \/** @return Type.INT\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.INT;\n-    }\n-\n-\n@@ -67,4 +51,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -75,1 +57,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -82,0 +64,13 @@\n+\n+    \/**\n+     * @return Type.INT\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.INT;\n+    }\n+\n+    @Override\n+    public Number getValue() {\n+        return Integer.valueOf(value);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ICONST.java","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -29,0 +28,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -33,1 +35,2 @@\n-    \/** Divide ints\n+    \/**\n+     * Divide ints\n@@ -39,11 +42,0 @@\n-\n-    \/** @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.ARITHMETIC_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -51,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -67,0 +57,8 @@\n+\n+    \/**\n+     * @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IDIV.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction, e.g. IFEQ.negate() == IFNE\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNE(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction, e.g. IFEQ.negate() == IFNE\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNE(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFEQ.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFLT(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFLT(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFGE.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFLE(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFLE(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFGT.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFGT(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFGT(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFLE.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFGE(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFGE(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFLT.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFEQ(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFEQ(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNE.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., reference -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., reference -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNULL(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNULL(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNONNULL.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., reference -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., reference -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNONNULL(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNONNULL(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNULL.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ACMPNE(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ACMPNE(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ACMPEQ.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ACMPEQ(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ACMPEQ(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ACMPNE.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPNE(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPNE(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPEQ.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPLT(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPLT(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPGE.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPLE(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPLE(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPGT.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPGT(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPGT(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPLE.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPGE(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPGE(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPLT.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ...\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,10 +43,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPEQ(super.getTarget());\n-    }\n-\n-\n@@ -55,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -69,0 +56,8 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPEQ(super.getTarget());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPNE.java","additions":15,"deletions":20,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -31,1 +32,0 @@\n- *\n@@ -38,1 +38,0 @@\n-\n@@ -40,2 +39,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -46,1 +44,0 @@\n-\n@@ -52,2 +49,2 @@\n-        super(); \/\/ Default behavior of LocalVariableInstruction causes error\n-        super.setOpcode(com.sun.org.apache.bcel.internal.Const.IINC);\n+        \/\/ Default behavior of LocalVariableInstruction causes error\n+        super.setOpcode(Const.IINC);\n@@ -59,0 +56,11 @@\n+    \/**\n+     * Calls corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitLocalVariableInstruction(this);\n+        v.visitIINC(this);\n+    }\n@@ -61,1 +69,2 @@\n-     * Dump instruction as byte code to stream out.\n+     * Dumps instruction as byte code to stream out.\n+     *\n@@ -65,1 +74,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -67,1 +76,1 @@\n-            out.writeByte(com.sun.org.apache.bcel.internal.Const.WIDE);\n+            out.writeByte(Const.WIDE);\n@@ -79,13 +88,5 @@\n-\n-    private void setWide() {\n-        wide = super.getIndex() > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n-        if (c > 0) {\n-            wide = wide || (c > Byte.MAX_VALUE);\n-        } else {\n-            wide = wide || (c < Byte.MIN_VALUE);\n-        }\n-        if (wide) {\n-            super.setLength(6); \/\/ wide byte included\n-        } else {\n-            super.setLength(3);\n-        }\n+    \/**\n+     * @return increment factor\n+     *\/\n+    public final int getIncrement() {\n+        return c;\n@@ -94,0 +95,7 @@\n+    \/**\n+     * @return int type\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.INT;\n+    }\n@@ -96,1 +104,1 @@\n-     * Read needed data (e.g. index) from file.\n+     * Reads needed data (e.g. index) from file.\n@@ -99,1 +107,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -112,1 +120,0 @@\n-\n@@ -114,1 +121,1 @@\n-     * @return mnemonic for instruction\n+     * Sets increment factor.\n@@ -116,3 +123,3 @@\n-    @Override\n-    public String toString( final boolean verbose ) {\n-        return super.toString(verbose) + \" \" + c;\n+    public final void setIncrement(final int c) {\n+        this.c = c;\n+        setWide();\n@@ -121,1 +128,0 @@\n-\n@@ -123,1 +129,1 @@\n-     * Set index of local variable.\n+     * Sets index of local variable.\n@@ -126,1 +132,1 @@\n-    public final void setIndex( final int n ) {\n+    public final void setIndex(final int n) {\n@@ -134,23 +140,12 @@\n-\n-    \/**\n-     * @return increment factor\n-     *\/\n-    public final int getIncrement() {\n-        return c;\n-    }\n-\n-\n-    \/**\n-     * Set increment factor.\n-     *\/\n-    public final void setIncrement( final int c ) {\n-        this.c = c;\n-        setWide();\n-    }\n-\n-\n-    \/** @return int type\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.INT;\n+    private void setWide() {\n+        wide = super.getIndex() > Const.MAX_BYTE;\n+        if (c > 0) {\n+            wide = wide || c > Byte.MAX_VALUE;\n+        } else {\n+            wide = wide || c < Byte.MIN_VALUE;\n+        }\n+        if (wide) {\n+            super.setLength(6); \/\/ wide byte included\n+        } else {\n+            super.setLength(3);\n+        }\n@@ -159,1 +154,0 @@\n-\n@@ -161,4 +155,1 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Returns mnemonic for instruction.\n@@ -166,1 +157,1 @@\n-     * @param v Visitor object\n+     * @return mnemonic for instruction.\n@@ -169,3 +160,2 @@\n-    public void accept( final Visitor v ) {\n-        v.visitLocalVariableInstruction(this);\n-        v.visitIINC(this);\n+    public String toString(final boolean verbose) {\n+        return super.toString(verbose) + \" \" + c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IINC.java","additions":55,"deletions":65,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ... -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ... -&gt; ..., result\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,2 +40,3 @@\n-\n-    \/** Load int from local variable\n+    \/**\n+     * Load int from local variable\n+     *\n@@ -47,1 +49,0 @@\n-\n@@ -49,4 +50,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +56,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ILOAD.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -34,1 +33,0 @@\n-\n@@ -36,4 +34,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +40,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMPDEP1.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -34,1 +33,0 @@\n-\n@@ -36,4 +34,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +40,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMPDEP2.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Multiply ints\n+    \/**\n+     * Multiply ints\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INEG.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * <PRE>Stack: ..., objectref -&gt; ..., result<\/PRE>\n@@ -30,0 +29,3 @@\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; ..., result\n+ * <\/PRE>\n@@ -31,2 +33,1 @@\n-public class INSTANCEOF extends CPInstruction implements LoadClass, ExceptionThrower,\n-        StackProducer, StackConsumer {\n+public class INSTANCEOF extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer, StackConsumer {\n@@ -35,2 +36,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -41,1 +41,0 @@\n-\n@@ -46,17 +45,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION);\n-    }\n-\n-\n-    @Override\n-    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n-        Type t = getType(cpg);\n-        if (t instanceof ArrayType) {\n-            t = ((ArrayType) t).getBasicType();\n-        }\n-        return (t instanceof ObjectType) ? (ObjectType) t : null;\n-    }\n-\n-\n@@ -64,4 +46,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -72,1 +52,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -81,0 +61,14 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION);\n+    }\n+\n+    @Override\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+        Type t = getType(cpg);\n+        if (t instanceof ArrayType) {\n+            t = ((ArrayType) t).getBasicType();\n+        }\n+        return t instanceof ObjectType ? (ObjectType) t : null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INSTANCEOF.java","additions":22,"deletions":28,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,3 +34,2 @@\n- * Class for INVOKEDYNAMIC. Not an instance of InvokeInstruction, since that class\n- * expects to be able to get the class of the method. Ignores the bootstrap\n- * mechanism entirely.\n+ * Class for INVOKEDYNAMIC. Not an instance of InvokeInstruction, since that class expects to be able to get the class\n+ * of the method. Ignores the bootstrap mechanism entirely.\n@@ -38,3 +37,2 @@\n- * @see\n- * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\">\n- * The invokedynamic instruction in The Java Virtual Machine Specification<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\"> The\n+ *      invokedynamic instruction in The Java Virtual Machine Specification<\/a>\n@@ -42,1 +40,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -47,2 +45,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -53,1 +50,0 @@\n-\n@@ -58,45 +54,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-        out.writeByte(0);\n-        out.writeByte(0);\n-       }\n-\n-\n-    \/**\n-     * Read needed data (i.e., index) from file.\n-     *\/\n-    @Override\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n-        super.initFromFile(bytes, wide);\n-        super.setLength(5);\n-        bytes.readByte(); \/\/ Skip 0 byte\n-        bytes.readByte(); \/\/ Skip 0 byte\n-    }\n-\n-\n-    \/**\n-     * @return mnemonic for instruction with symbolic references resolved\n-     *\/\n-    @Override\n-    public String toString( final ConstantPool cp ) {\n-        return super.toString(cp);\n-    }\n-\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION,\n-            ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR,\n-            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-\n@@ -104,4 +55,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -112,1 +61,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -125,1 +74,1 @@\n-     * Override the parent method because our classname is held elsewhere.\n+     * Dump instruction as byte code to stream out.\n@@ -127,2 +76,12 @@\n-     * @param cpg the ConstantPool generator\n-     * @deprecated in FieldOrMethod\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+        out.writeByte(0);\n+        out.writeByte(0);\n+    }\n+\n+    \/**\n+     * Override the parent method because our class name is held elsewhere.\n@@ -130,1 +89,2 @@\n-     * @return name of the referenced class\/interface\n+     * Note: Contrary to this method's name it does not return the class name of the invoke target; rather it returns the\n+     * name of the method that will be used to invoke the Lambda method generated by this invoke dynamic instruction.\n@@ -136,2 +96,2 @@\n-        final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) cp.getConstant(super.getIndex(), Const.CONSTANT_InvokeDynamic);\n-        return ((ConstantNameAndType) cp.getConstant(cid.getNameAndTypeIndex())).getName(cp);\n+        final ConstantInvokeDynamic cid = cp.getConstant(super.getIndex(), Const.CONSTANT_InvokeDynamic, ConstantInvokeDynamic.class);\n+        return cp.getConstant(cid.getNameAndTypeIndex(), ConstantNameAndType.class).getName(cp);\n@@ -140,0 +100,5 @@\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.ILLEGAL_ACCESS_ERROR, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n@@ -142,2 +107,2 @@\n-     * Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object,\n-     * as that is the only type we can say for sure the reference will be.\n+     * Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object, as that is the only type we can\n+     * say for sure the reference will be.\n@@ -145,2 +110,1 @@\n-     * @param cpg\n-     *            the ConstantPoolGen used to create the instruction\n+     * @param cpg the ConstantPoolGen used to create the instruction\n@@ -154,0 +118,12 @@\n+\n+    \/**\n+     * Read needed data (i.e., index) from file.\n+     *\/\n+    @Override\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+        super.initFromFile(bytes, wide);\n+        super.setLength(5);\n+        bytes.readByte(); \/\/ Skip 0 byte\n+        bytes.readByte(); \/\/ Skip 0 byte\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEDYNAMIC.java","additions":47,"deletions":71,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -34,1 +34,0 @@\n- * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -36,3 +35,6 @@\n- * @see\n- * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\">\n- * The invokeinterface instruction in The Java Virtual Machine Specification<\/a>\n+ * <PRE>\n+ * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n+ * <\/PRE>\n+ *\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\"> The\n+ *      invokeinterface instruction in The Java Virtual Machine Specification<\/a>\n@@ -44,1 +46,0 @@\n-\n@@ -46,2 +47,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -52,1 +52,0 @@\n-\n@@ -62,0 +61,23 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitStackProducer(this);\n+        v.visitLoadClass(this);\n+        v.visitCPInstruction(this);\n+        v.visitFieldOrMethod(this);\n+        v.visitInvokeInstruction(this);\n+        v.visitINVOKEINTERFACE(this);\n+    }\n+\n+    @Override\n+    public int consumeStack(final ConstantPoolGen cpg) { \/\/ nargs is given in byte-code\n+        return nargs; \/\/ nargs includes this reference\n+    }\n@@ -65,0 +87,1 @@\n+     *\n@@ -68,1 +91,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -75,1 +98,0 @@\n-\n@@ -77,2 +99,1 @@\n-     * The <B>count<\/B> argument according to the Java Language Specification,\n-     * Second Edition.\n+     * The <B>count<\/B> argument according to the Java Language Specification, Second Edition.\n@@ -84,0 +105,5 @@\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.ILLEGAL_ACCESS_ERROR, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n@@ -89,1 +115,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -96,1 +122,0 @@\n-\n@@ -101,1 +126,1 @@\n-    public String toString( final ConstantPool cp ) {\n+    public String toString(final ConstantPool cp) {\n@@ -104,38 +129,0 @@\n-\n-\n-    @Override\n-    public int consumeStack( final ConstantPoolGen cpg ) { \/\/ nargs is given in byte-code\n-        return nargs; \/\/ nargs includes this reference\n-    }\n-\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION,\n-            ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR,\n-            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitStackProducer(this);\n-        v.visitLoadClass(this);\n-        v.visitCPInstruction(this);\n-        v.visitFieldOrMethod(this);\n-        v.visitInvokeInstruction(this);\n-        v.visitINVOKEINTERFACE(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEINTERFACE.java","additions":40,"deletions":53,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * INVOKESPECIAL - Invoke instance method; special handling for superclass, private\n- * and instance initialization method invocations\n+ * INVOKESPECIAL - Invoke instance method; special handling for superclass, private and instance initialization method\n+ * invocations\n@@ -34,1 +34,3 @@\n- * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n+ * <PRE>\n+ * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n+ * <\/PRE>\n@@ -36,3 +38,2 @@\n- * @see\n- * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\">\n- * The invokespecial instruction in The Java Virtual Machine Specification<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\"> The\n+ *      invokespecial instruction in The Java Virtual Machine Specification<\/a>\n@@ -43,2 +44,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -49,1 +49,0 @@\n-\n@@ -54,21 +53,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n-            ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR,\n-            ExceptionConst.UNSATISFIED_LINK_ERROR);\n-    }\n-\n-\n@@ -76,4 +54,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -84,1 +60,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -95,0 +71,17 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     *\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR, ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.UNSATISFIED_LINK_ERROR);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKESPECIAL.java","additions":28,"deletions":35,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n- * <PRE>Stack: ..., [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n+ * <PRE>\n+ * Stack: ..., [arg1, [arg2 ...]] -&gt; ...\n+ * <\/PRE>\n@@ -35,3 +37,2 @@\n- * @see\n- * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\">\n- * The invokestatic instruction in The Java Virtual Machine Specification<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\"> The invokestatic\n+ *      instruction in The Java Virtual Machine Specification<\/a>\n@@ -42,2 +43,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -48,1 +48,0 @@\n-\n@@ -53,19 +52,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump( final DataOutputStream out ) throws IOException {\n-      out.writeByte(super.getOpcode());\n-      out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n-            ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-\n@@ -73,4 +53,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -81,1 +59,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -92,0 +70,17 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     *\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKESTATIC.java","additions":26,"deletions":31,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,1 +33,3 @@\n- * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n+ * <PRE>\n+ * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n+ * <\/PRE>\n@@ -35,3 +37,2 @@\n- * @see\n- * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\">\n- * The invokevirtual instruction in The Java Virtual Machine Specification<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\"> The\n+ *      invokevirtual instruction in The Java Virtual Machine Specification<\/a>\n@@ -42,2 +43,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -48,1 +48,0 @@\n-\n@@ -53,21 +52,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n-            ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR,\n-            ExceptionConst.UNSATISFIED_LINK_ERROR);\n-    }\n-\n-\n@@ -75,4 +53,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -83,1 +59,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -94,0 +70,17 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     *\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR, ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.UNSATISFIED_LINK_ERROR);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEVIRTUAL.java","additions":26,"deletions":33,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IOR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -29,0 +28,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -33,1 +35,2 @@\n-    \/** Remainder of ints\n+    \/**\n+     * Remainder of ints\n@@ -39,11 +42,0 @@\n-\n-    \/** @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.ARITHMETIC_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -51,4 +43,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +49,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -67,0 +57,8 @@\n+\n+    \/**\n+     * @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IREM.java","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * IRETURN -  Return int from method\n- * <PRE>Stack: ..., value -&gt; &lt;empty&gt;<\/PRE>\n+ * IRETURN - Return int from method\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; &lt;empty&gt;\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Return int from method\n+    \/**\n+     * Return int from method\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISHL.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISHR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value -&gt; ... <\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,2 +40,3 @@\n-\n-    \/** Store int into local variable\n+    \/**\n+     * Store int into local variable\n+     *\n@@ -47,1 +49,0 @@\n-\n@@ -49,4 +50,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +56,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISTORE.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Substract ints\n+    \/**\n+     * Substract ints\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IUSHR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IXOR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -31,2 +30,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -37,1 +35,0 @@\n-\n@@ -46,1 +43,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IfInstruction.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Denote entity that refers to an index, e.g. local variable instructions,\n- * RET, CPInstruction, etc.\n- *\n+ * Denote entity that refers to an index, e.g. local variable instructions, RET, CPInstruction, etc.\n@@ -33,2 +31,1 @@\n-\n-    void setIndex( int index );\n+    void setIndex(int index);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IndexedInstruction.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @LastModified: July 2020\n+ * @LastModified: Feb 2023\n@@ -36,2 +36,1 @@\n-    private short length = 1; \/\/ Length of instruction in bytes\n-    private short opcode = -1; \/\/ Opcode number\n+    static final Instruction[] EMPTY_ARRAY = {};\n@@ -41,1 +40,0 @@\n-\n@@ -43,34 +41,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n-     *\/\n-    Instruction() {\n-    }\n-\n-\n-    public Instruction(final short opcode, final short length) {\n-        this.length = length;\n-        this.opcode = opcode;\n-    }\n-\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n-     *\/\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        out.writeByte(opcode); \/\/ Common for all instructions\n-    }\n-\n-\n-    \/** @return name of instruction, i.e., opcode name\n-     *\/\n-    public String getName() {\n-        return Const.getOpcodeName(opcode);\n-    }\n-\n-\n-    \/**\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n-     * \"(\"&lt;length of instruction&gt;\")\"\n+     * Gets Comparator object used in the equals() method to determine equality of instructions.\n@@ -78,22 +43,2 @@\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n-     *\/\n-    public String toString( final boolean verbose ) {\n-        if (verbose) {\n-            return getName() + \"[\" + opcode + \"](\" + length + \")\";\n-        }\n-        return getName();\n-    }\n-\n-\n-    \/**\n-     * @return mnemonic for instruction in verbose format\n-     *\/\n-    @Override\n-    public String toString() {\n-        return toString(true);\n-    }\n-\n-\n-    \/**\n-     * @return mnemonic for instruction with sumbolic references resolved\n+     * @return currently used comparator for equals()\n+     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n@@ -101,2 +46,3 @@\n-    public String toString( final ConstantPool cp ) {\n-        return toString(false);\n+    @Deprecated\n+    public static InstructionComparator getComparator() {\n+        return cmp;\n@@ -105,1 +51,0 @@\n-\n@@ -107,3 +52,1 @@\n-     * Use with caution, since `BranchInstruction's have a `target' reference which\n-     * is not copied correctly (only basic types are). This also applies for\n-     * `Select' instructions with their multiple branch targets.\n+     * Tests if the value can fit in a byte (signed)\n@@ -111,2 +54,3 @@\n-     * @see BranchInstruction\n-     * @return (shallow) copy of an instruction\n+     * @param value the value to check\n+     * @return true if the value is in range\n+     * @since 6.0\n@@ -114,13 +58,2 @@\n-    public Instruction copy() {\n-        Instruction i = null;\n-        \/\/ \"Constant\" instruction, no need to duplicate\n-        if (InstructionConst.getInstruction(this.getOpcode()) != null) {\n-            i = this;\n-        } else {\n-            try {\n-                i = (Instruction) clone();\n-            } catch (final CloneNotSupportedException e) {\n-                System.err.println(e);\n-            }\n-        }\n-        return i;\n+    public static boolean isValidByte(final int value) {\n+        return value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE;\n@@ -129,1 +62,0 @@\n-\n@@ -131,1 +63,1 @@\n-     * Read needed data (e.g. index) from file.\n+     * Tests if the value can fit in a short (signed)\n@@ -133,3 +65,3 @@\n-     * @param bytes byte sequence to read from\n-     * @param wide \"wide\" instruction flag\n-     * @throws IOException may be thrown if the implementation needs to read data from the file\n+     * @param value the value to check\n+     * @return true if the value is in range\n+     * @since 6.0\n@@ -137,1 +69,2 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    public static boolean isValidShort(final int value) {\n+        return value >= Short.MIN_VALUE && value <= Short.MAX_VALUE;\n@@ -140,1 +73,0 @@\n-\n@@ -142,2 +74,1 @@\n-     * Read an instruction from (byte code) input stream and return the\n-     * appropiate object.\n+     * Reads an instruction from (byte code) input stream and return the appropriate object.\n@@ -145,2 +76,2 @@\n-     * If the Instruction is defined in {@link InstructionConst}, then the\n-     * singleton instance is returned.\n+     * If the Instruction is defined in {@link InstructionConst}, then the singleton instance is returned.\n+     * <\/p>\n@@ -149,0 +80,1 @@\n+     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n@@ -152,1 +84,1 @@\n-    public static Instruction readInstruction( final ByteSequence bytes ) throws IOException {\n+    public static Instruction readInstruction(final ByteSequence bytes) throws IOException {\n@@ -166,293 +98,293 @@\n-            case Const.BIPUSH:\n-                obj = new BIPUSH();\n-                break;\n-            case Const.SIPUSH:\n-                obj = new SIPUSH();\n-                break;\n-            case Const.LDC:\n-                obj = new LDC();\n-                break;\n-            case Const.LDC_W:\n-                obj = new LDC_W();\n-                break;\n-            case Const.LDC2_W:\n-                obj = new LDC2_W();\n-                break;\n-            case Const.ILOAD:\n-                obj = new ILOAD();\n-                break;\n-            case Const.LLOAD:\n-                obj = new LLOAD();\n-                break;\n-            case Const.FLOAD:\n-                obj = new FLOAD();\n-                break;\n-            case Const.DLOAD:\n-                obj = new DLOAD();\n-                break;\n-            case Const.ALOAD:\n-                obj = new ALOAD();\n-                break;\n-            case Const.ILOAD_0:\n-                obj = new ILOAD(0);\n-                break;\n-            case Const.ILOAD_1:\n-                obj = new ILOAD(1);\n-                break;\n-            case Const.ILOAD_2:\n-                obj = new ILOAD(2);\n-                break;\n-            case Const.ILOAD_3:\n-                obj = new ILOAD(3);\n-                break;\n-            case Const.LLOAD_0:\n-                obj = new LLOAD(0);\n-                break;\n-            case Const.LLOAD_1:\n-                obj = new LLOAD(1);\n-                break;\n-            case Const.LLOAD_2:\n-                obj = new LLOAD(2);\n-                break;\n-            case Const.LLOAD_3:\n-                obj = new LLOAD(3);\n-                break;\n-            case Const.FLOAD_0:\n-                obj = new FLOAD(0);\n-                break;\n-            case Const.FLOAD_1:\n-                obj = new FLOAD(1);\n-                break;\n-            case Const.FLOAD_2:\n-                obj = new FLOAD(2);\n-                break;\n-            case Const.FLOAD_3:\n-                obj = new FLOAD(3);\n-                break;\n-            case Const.DLOAD_0:\n-                obj = new DLOAD(0);\n-                break;\n-            case Const.DLOAD_1:\n-                obj = new DLOAD(1);\n-                break;\n-            case Const.DLOAD_2:\n-                obj = new DLOAD(2);\n-                break;\n-            case Const.DLOAD_3:\n-                obj = new DLOAD(3);\n-                break;\n-            case Const.ALOAD_0:\n-                obj = new ALOAD(0);\n-                break;\n-            case Const.ALOAD_1:\n-                obj = new ALOAD(1);\n-                break;\n-            case Const.ALOAD_2:\n-                obj = new ALOAD(2);\n-                break;\n-            case Const.ALOAD_3:\n-                obj = new ALOAD(3);\n-                break;\n-            case Const.ISTORE:\n-                obj = new ISTORE();\n-                break;\n-            case Const.LSTORE:\n-                obj = new LSTORE();\n-                break;\n-            case Const.FSTORE:\n-                obj = new FSTORE();\n-                break;\n-            case Const.DSTORE:\n-                obj = new DSTORE();\n-                break;\n-            case Const.ASTORE:\n-                obj = new ASTORE();\n-                break;\n-            case Const.ISTORE_0:\n-                obj = new ISTORE(0);\n-                break;\n-            case Const.ISTORE_1:\n-                obj = new ISTORE(1);\n-                break;\n-            case Const.ISTORE_2:\n-                obj = new ISTORE(2);\n-                break;\n-            case Const.ISTORE_3:\n-                obj = new ISTORE(3);\n-                break;\n-            case Const.LSTORE_0:\n-                obj = new LSTORE(0);\n-                break;\n-            case Const.LSTORE_1:\n-                obj = new LSTORE(1);\n-                break;\n-            case Const.LSTORE_2:\n-                obj = new LSTORE(2);\n-                break;\n-            case Const.LSTORE_3:\n-                obj = new LSTORE(3);\n-                break;\n-            case Const.FSTORE_0:\n-                obj = new FSTORE(0);\n-                break;\n-            case Const.FSTORE_1:\n-                obj = new FSTORE(1);\n-                break;\n-            case Const.FSTORE_2:\n-                obj = new FSTORE(2);\n-                break;\n-            case Const.FSTORE_3:\n-                obj = new FSTORE(3);\n-                break;\n-            case Const.DSTORE_0:\n-                obj = new DSTORE(0);\n-                break;\n-            case Const.DSTORE_1:\n-                obj = new DSTORE(1);\n-                break;\n-            case Const.DSTORE_2:\n-                obj = new DSTORE(2);\n-                break;\n-            case Const.DSTORE_3:\n-                obj = new DSTORE(3);\n-                break;\n-            case Const.ASTORE_0:\n-                obj = new ASTORE(0);\n-                break;\n-            case Const.ASTORE_1:\n-                obj = new ASTORE(1);\n-                break;\n-            case Const.ASTORE_2:\n-                obj = new ASTORE(2);\n-                break;\n-            case Const.ASTORE_3:\n-                obj = new ASTORE(3);\n-                break;\n-            case Const.IINC:\n-                obj = new IINC();\n-                break;\n-            case Const.IFEQ:\n-                obj = new IFEQ();\n-                break;\n-            case Const.IFNE:\n-                obj = new IFNE();\n-                break;\n-            case Const.IFLT:\n-                obj = new IFLT();\n-                break;\n-            case Const.IFGE:\n-                obj = new IFGE();\n-                break;\n-            case Const.IFGT:\n-                obj = new IFGT();\n-                break;\n-            case Const.IFLE:\n-                obj = new IFLE();\n-                break;\n-            case Const.IF_ICMPEQ:\n-                obj = new IF_ICMPEQ();\n-                break;\n-            case Const.IF_ICMPNE:\n-                obj = new IF_ICMPNE();\n-                break;\n-            case Const.IF_ICMPLT:\n-                obj = new IF_ICMPLT();\n-                break;\n-            case Const.IF_ICMPGE:\n-                obj = new IF_ICMPGE();\n-                break;\n-            case Const.IF_ICMPGT:\n-                obj = new IF_ICMPGT();\n-                break;\n-            case Const.IF_ICMPLE:\n-                obj = new IF_ICMPLE();\n-                break;\n-            case Const.IF_ACMPEQ:\n-                obj = new IF_ACMPEQ();\n-                break;\n-            case Const.IF_ACMPNE:\n-                obj = new IF_ACMPNE();\n-                break;\n-            case Const.GOTO:\n-                obj = new GOTO();\n-                break;\n-            case Const.JSR:\n-                obj = new JSR();\n-                break;\n-            case Const.RET:\n-                obj = new RET();\n-                break;\n-            case Const.TABLESWITCH:\n-                obj = new TABLESWITCH();\n-                break;\n-            case Const.LOOKUPSWITCH:\n-                obj = new LOOKUPSWITCH();\n-                break;\n-            case Const.GETSTATIC:\n-                obj = new GETSTATIC();\n-                break;\n-            case Const.PUTSTATIC:\n-                obj = new PUTSTATIC();\n-                break;\n-            case Const.GETFIELD:\n-                obj = new GETFIELD();\n-                break;\n-            case Const.PUTFIELD:\n-                obj = new PUTFIELD();\n-                break;\n-            case Const.INVOKEVIRTUAL:\n-                obj = new INVOKEVIRTUAL();\n-                break;\n-            case Const.INVOKESPECIAL:\n-                obj = new INVOKESPECIAL();\n-                break;\n-            case Const.INVOKESTATIC:\n-                obj = new INVOKESTATIC();\n-                break;\n-            case Const.INVOKEINTERFACE:\n-                obj = new INVOKEINTERFACE();\n-                break;\n-            case Const.INVOKEDYNAMIC:\n-                obj = new INVOKEDYNAMIC();\n-                break;\n-            case Const.NEW:\n-                obj = new NEW();\n-                break;\n-            case Const.NEWARRAY:\n-                obj = new NEWARRAY();\n-                break;\n-            case Const.ANEWARRAY:\n-                obj = new ANEWARRAY();\n-                break;\n-            case Const.CHECKCAST:\n-                obj = new CHECKCAST();\n-                break;\n-            case Const.INSTANCEOF:\n-                obj = new INSTANCEOF();\n-                break;\n-            case Const.MULTIANEWARRAY:\n-                obj = new MULTIANEWARRAY();\n-                break;\n-            case Const.IFNULL:\n-                obj = new IFNULL();\n-                break;\n-            case Const.IFNONNULL:\n-                obj = new IFNONNULL();\n-                break;\n-            case Const.GOTO_W:\n-                obj = new GOTO_W();\n-                break;\n-            case Const.JSR_W:\n-                obj = new JSR_W();\n-                break;\n-            case Const.BREAKPOINT:\n-                obj = new BREAKPOINT();\n-                break;\n-            case Const.IMPDEP1:\n-                obj = new IMPDEP1();\n-                break;\n-            case Const.IMPDEP2:\n-                obj = new IMPDEP2();\n-                break;\n-            default:\n-                throw new ClassGenException(\"Illegal opcode detected: \" + opcode);\n+        case Const.BIPUSH:\n+            obj = new BIPUSH();\n+            break;\n+        case Const.SIPUSH:\n+            obj = new SIPUSH();\n+            break;\n+        case Const.LDC:\n+            obj = new LDC();\n+            break;\n+        case Const.LDC_W:\n+            obj = new LDC_W();\n+            break;\n+        case Const.LDC2_W:\n+            obj = new LDC2_W();\n+            break;\n+        case Const.ILOAD:\n+            obj = new ILOAD();\n+            break;\n+        case Const.LLOAD:\n+            obj = new LLOAD();\n+            break;\n+        case Const.FLOAD:\n+            obj = new FLOAD();\n+            break;\n+        case Const.DLOAD:\n+            obj = new DLOAD();\n+            break;\n+        case Const.ALOAD:\n+            obj = new ALOAD();\n+            break;\n+        case Const.ILOAD_0:\n+            obj = new ILOAD(0);\n+            break;\n+        case Const.ILOAD_1:\n+            obj = new ILOAD(1);\n+            break;\n+        case Const.ILOAD_2:\n+            obj = new ILOAD(2);\n+            break;\n+        case Const.ILOAD_3:\n+            obj = new ILOAD(3);\n+            break;\n+        case Const.LLOAD_0:\n+            obj = new LLOAD(0);\n+            break;\n+        case Const.LLOAD_1:\n+            obj = new LLOAD(1);\n+            break;\n+        case Const.LLOAD_2:\n+            obj = new LLOAD(2);\n+            break;\n+        case Const.LLOAD_3:\n+            obj = new LLOAD(3);\n+            break;\n+        case Const.FLOAD_0:\n+            obj = new FLOAD(0);\n+            break;\n+        case Const.FLOAD_1:\n+            obj = new FLOAD(1);\n+            break;\n+        case Const.FLOAD_2:\n+            obj = new FLOAD(2);\n+            break;\n+        case Const.FLOAD_3:\n+            obj = new FLOAD(3);\n+            break;\n+        case Const.DLOAD_0:\n+            obj = new DLOAD(0);\n+            break;\n+        case Const.DLOAD_1:\n+            obj = new DLOAD(1);\n+            break;\n+        case Const.DLOAD_2:\n+            obj = new DLOAD(2);\n+            break;\n+        case Const.DLOAD_3:\n+            obj = new DLOAD(3);\n+            break;\n+        case Const.ALOAD_0:\n+            obj = new ALOAD(0);\n+            break;\n+        case Const.ALOAD_1:\n+            obj = new ALOAD(1);\n+            break;\n+        case Const.ALOAD_2:\n+            obj = new ALOAD(2);\n+            break;\n+        case Const.ALOAD_3:\n+            obj = new ALOAD(3);\n+            break;\n+        case Const.ISTORE:\n+            obj = new ISTORE();\n+            break;\n+        case Const.LSTORE:\n+            obj = new LSTORE();\n+            break;\n+        case Const.FSTORE:\n+            obj = new FSTORE();\n+            break;\n+        case Const.DSTORE:\n+            obj = new DSTORE();\n+            break;\n+        case Const.ASTORE:\n+            obj = new ASTORE();\n+            break;\n+        case Const.ISTORE_0:\n+            obj = new ISTORE(0);\n+            break;\n+        case Const.ISTORE_1:\n+            obj = new ISTORE(1);\n+            break;\n+        case Const.ISTORE_2:\n+            obj = new ISTORE(2);\n+            break;\n+        case Const.ISTORE_3:\n+            obj = new ISTORE(3);\n+            break;\n+        case Const.LSTORE_0:\n+            obj = new LSTORE(0);\n+            break;\n+        case Const.LSTORE_1:\n+            obj = new LSTORE(1);\n+            break;\n+        case Const.LSTORE_2:\n+            obj = new LSTORE(2);\n+            break;\n+        case Const.LSTORE_3:\n+            obj = new LSTORE(3);\n+            break;\n+        case Const.FSTORE_0:\n+            obj = new FSTORE(0);\n+            break;\n+        case Const.FSTORE_1:\n+            obj = new FSTORE(1);\n+            break;\n+        case Const.FSTORE_2:\n+            obj = new FSTORE(2);\n+            break;\n+        case Const.FSTORE_3:\n+            obj = new FSTORE(3);\n+            break;\n+        case Const.DSTORE_0:\n+            obj = new DSTORE(0);\n+            break;\n+        case Const.DSTORE_1:\n+            obj = new DSTORE(1);\n+            break;\n+        case Const.DSTORE_2:\n+            obj = new DSTORE(2);\n+            break;\n+        case Const.DSTORE_3:\n+            obj = new DSTORE(3);\n+            break;\n+        case Const.ASTORE_0:\n+            obj = new ASTORE(0);\n+            break;\n+        case Const.ASTORE_1:\n+            obj = new ASTORE(1);\n+            break;\n+        case Const.ASTORE_2:\n+            obj = new ASTORE(2);\n+            break;\n+        case Const.ASTORE_3:\n+            obj = new ASTORE(3);\n+            break;\n+        case Const.IINC:\n+            obj = new IINC();\n+            break;\n+        case Const.IFEQ:\n+            obj = new IFEQ();\n+            break;\n+        case Const.IFNE:\n+            obj = new IFNE();\n+            break;\n+        case Const.IFLT:\n+            obj = new IFLT();\n+            break;\n+        case Const.IFGE:\n+            obj = new IFGE();\n+            break;\n+        case Const.IFGT:\n+            obj = new IFGT();\n+            break;\n+        case Const.IFLE:\n+            obj = new IFLE();\n+            break;\n+        case Const.IF_ICMPEQ:\n+            obj = new IF_ICMPEQ();\n+            break;\n+        case Const.IF_ICMPNE:\n+            obj = new IF_ICMPNE();\n+            break;\n+        case Const.IF_ICMPLT:\n+            obj = new IF_ICMPLT();\n+            break;\n+        case Const.IF_ICMPGE:\n+            obj = new IF_ICMPGE();\n+            break;\n+        case Const.IF_ICMPGT:\n+            obj = new IF_ICMPGT();\n+            break;\n+        case Const.IF_ICMPLE:\n+            obj = new IF_ICMPLE();\n+            break;\n+        case Const.IF_ACMPEQ:\n+            obj = new IF_ACMPEQ();\n+            break;\n+        case Const.IF_ACMPNE:\n+            obj = new IF_ACMPNE();\n+            break;\n+        case Const.GOTO:\n+            obj = new GOTO();\n+            break;\n+        case Const.JSR:\n+            obj = new JSR();\n+            break;\n+        case Const.RET:\n+            obj = new RET();\n+            break;\n+        case Const.TABLESWITCH:\n+            obj = new TABLESWITCH();\n+            break;\n+        case Const.LOOKUPSWITCH:\n+            obj = new LOOKUPSWITCH();\n+            break;\n+        case Const.GETSTATIC:\n+            obj = new GETSTATIC();\n+            break;\n+        case Const.PUTSTATIC:\n+            obj = new PUTSTATIC();\n+            break;\n+        case Const.GETFIELD:\n+            obj = new GETFIELD();\n+            break;\n+        case Const.PUTFIELD:\n+            obj = new PUTFIELD();\n+            break;\n+        case Const.INVOKEVIRTUAL:\n+            obj = new INVOKEVIRTUAL();\n+            break;\n+        case Const.INVOKESPECIAL:\n+            obj = new INVOKESPECIAL();\n+            break;\n+        case Const.INVOKESTATIC:\n+            obj = new INVOKESTATIC();\n+            break;\n+        case Const.INVOKEINTERFACE:\n+            obj = new INVOKEINTERFACE();\n+            break;\n+        case Const.INVOKEDYNAMIC:\n+            obj = new INVOKEDYNAMIC();\n+            break;\n+        case Const.NEW:\n+            obj = new NEW();\n+            break;\n+        case Const.NEWARRAY:\n+            obj = new NEWARRAY();\n+            break;\n+        case Const.ANEWARRAY:\n+            obj = new ANEWARRAY();\n+            break;\n+        case Const.CHECKCAST:\n+            obj = new CHECKCAST();\n+            break;\n+        case Const.INSTANCEOF:\n+            obj = new INSTANCEOF();\n+            break;\n+        case Const.MULTIANEWARRAY:\n+            obj = new MULTIANEWARRAY();\n+            break;\n+        case Const.IFNULL:\n+            obj = new IFNULL();\n+            break;\n+        case Const.IFNONNULL:\n+            obj = new IFNONNULL();\n+            break;\n+        case Const.GOTO_W:\n+            obj = new GOTO_W();\n+            break;\n+        case Const.JSR_W:\n+            obj = new JSR_W();\n+            break;\n+        case Const.BREAKPOINT:\n+            obj = new BREAKPOINT();\n+            break;\n+        case Const.IMPDEP1:\n+            obj = new IMPDEP1();\n+            break;\n+        case Const.IMPDEP2:\n+            obj = new IMPDEP2();\n+            break;\n+        default:\n+            throw new ClassGenException(\"Illegal opcode detected: \" + opcode);\n@@ -462,2 +394,1 @@\n-        if (wide\n-                && !((obj instanceof LocalVariableInstruction) || (obj instanceof IINC) || (obj instanceof RET))) {\n+        if (wide && !(obj instanceof LocalVariableInstruction || obj instanceof RET)) {\n@@ -472,5 +403,3 @@\n-     * This method also gives right results for instructions whose\n-     * effect on the stack depends on the constant pool entry they\n-     * reference.\n-     *  @return Number of words consumed from stack by this instruction,\n-     * or Constants.UNPREDICTABLE, if this can not be computed statically\n+     * Sets comparator to be used for equals().\n+     *\n+     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n@@ -478,2 +407,3 @@\n-    public int consumeStack( final ConstantPoolGen cpg ) {\n-        return Const.getConsumeStack(opcode);\n+    @Deprecated\n+    public static void setComparator(final InstructionComparator c) {\n+        cmp = c;\n@@ -482,1 +412,0 @@\n-\n@@ -484,5 +413,1 @@\n-     * This method also gives right results for instructions whose\n-     * effect on the stack depends on the constant pool entry they\n-     * reference.\n-     * @return Number of words produced onto stack by this instruction,\n-     * or Constants.UNPREDICTABLE, if this can not be computed statically\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -490,3 +415,2 @@\n-    public int produceStack( final ConstantPoolGen cpg ) {\n-        return Const.getProduceStack(opcode);\n-    }\n+    @Deprecated\n+    protected short length = 1; \/\/ Length of instruction in bytes\n@@ -494,0 +418,5 @@\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected short opcode = -1; \/\/ Opcode number\n@@ -496,1 +425,1 @@\n-     * @return this instructions opcode\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -498,2 +427,1 @@\n-    public short getOpcode() {\n-        return opcode;\n+    Instruction() {\n@@ -502,0 +430,4 @@\n+    public Instruction(final short opcode, final short length) {\n+        this.length = length;\n+        this.opcode = opcode;\n+    }\n@@ -504,1 +436,4 @@\n-     * @return length (in bytes) of instruction\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -506,4 +441,1 @@\n-    public int getLength() {\n-        return length;\n-    }\n-\n+    public abstract void accept(Visitor v);\n@@ -512,1 +444,5 @@\n-     * Needed in readInstruction and subclasses in this package\n+     * This method also gives right results for instructions whose effect on the stack depends on the constant pool entry\n+     * they reference.\n+     *\n+     * @return Number of words consumed from stack by this instruction, or Constants.UNPREDICTABLE, if this can not be\n+     *         computed statically\n@@ -514,2 +450,2 @@\n-    void setOpcode( final short opcode ) {\n-        this.opcode = opcode;\n+    public int consumeStack(final ConstantPoolGen cpg) {\n+        return Const.getConsumeStack(opcode);\n@@ -518,1 +454,0 @@\n-\n@@ -520,2 +455,5 @@\n-     * Needed in readInstruction and subclasses in this package\n-     * @since 6.0\n+     * Use with caution, since 'BranchInstruction's have a 'target' reference which is not copied correctly (only basic\n+     * types are). This also applies for 'Select' instructions with their multiple branch targets.\n+     *\n+     * @see BranchInstruction\n+     * @return (shallow) copy of an instruction\n@@ -523,2 +461,13 @@\n-    final void setLength( final int length ) {\n-        this.length = (short) length; \/\/ TODO check range?\n+    public Instruction copy() {\n+        Instruction i = null;\n+        \/\/ \"Constant\" instruction, no need to duplicate\n+        if (InstructionConst.getInstruction(this.getOpcode()) != null) {\n+            i = this;\n+        } else {\n+            try {\n+                i = (Instruction) clone();\n+            } catch (final CloneNotSupportedException e) {\n+                System.err.println(e);\n+            }\n+        }\n+        return i;\n@@ -527,2 +476,2 @@\n-\n-    \/** Some instructions may be reused, so don't do anything by default.\n+    \/**\n+     * Some instructions may be reused, so don't do anything by default.\n@@ -533,1 +482,0 @@\n-\n@@ -535,4 +483,1 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Dumps instruction as byte code to stream out.\n@@ -540,1 +485,2 @@\n-     * @param v Visitor object\n+     * @param out Output stream\n+     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n@@ -542,2 +488,3 @@\n-    public abstract void accept( Visitor v );\n-\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(opcode); \/\/ Common for all instructions\n+    }\n@@ -545,2 +492,2 @@\n-    \/** Get Comparator object used in the equals() method to determine\n-     * equality of instructions.\n+    \/**\n+     * Tests for equality, delegated to comparator\n@@ -548,2 +495,1 @@\n-     * @return currently used comparator for equals()\n-     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+     * @return true if that is an Instruction and has the same opcode\n@@ -551,3 +497,3 @@\n-    @Deprecated\n-    public static InstructionComparator getComparator() {\n-        return cmp;\n+    @Override\n+    public boolean equals(final Object that) {\n+        return that instanceof Instruction && cmp.equals(this, (Instruction) that);\n@@ -556,3 +502,2 @@\n-\n-    \/** Set comparator to be used for equals().\n-      * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+    \/**\n+     * @return length (in bytes) of instruction\n@@ -560,3 +505,2 @@\n-    @Deprecated\n-    public static void setComparator( final InstructionComparator c ) {\n-        cmp = c;\n+    public int getLength() {\n+        return length;\n@@ -565,0 +509,6 @@\n+    \/**\n+     * @return name of instruction, i.e., opcode name\n+     *\/\n+    public String getName() {\n+        return Const.getOpcodeName(opcode);\n+    }\n@@ -566,2 +516,2 @@\n-    \/** Check for equality, delegated to comparator\n-     * @return true if that is an Instruction and has the same opcode\n+    \/**\n+     * @return this instructions opcode\n@@ -569,3 +519,2 @@\n-    @Override\n-    public boolean equals( final Object that ) {\n-        return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;\n+    public short getOpcode() {\n+        return opcode;\n@@ -574,1 +523,3 @@\n-    \/** calculate the hashCode of this object\n+    \/**\n+     * Gets the hashCode of this object.\n+     *\n@@ -584,4 +535,5 @@\n-     * Check if the value can fit in a byte (signed)\n-     * @param value the value to check\n-     * @return true if the value is in range\n-     * @since 6.0\n+     * Reads needed data (e.g. index) from file.\n+     *\n+     * @param bytes byte sequence to read from\n+     * @param wide \"wide\" instruction flag\n+     * @throws IOException may be thrown if the implementation needs to read data from the file\n@@ -589,2 +541,2 @@\n-    public static boolean isValidByte(final int value) {\n-        return value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE;\n+    @SuppressWarnings(\"unused\") \/\/ thrown by subclasses\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -594,3 +546,13 @@\n-     * Check if the value can fit in a short (signed)\n-     * @param value the value to check\n-     * @return true if the value is in range\n+     * This method also gives right results for instructions whose effect on the stack depends on the constant pool entry\n+     * they reference.\n+     *\n+     * @return Number of words produced onto stack by this instruction, or Constants.UNPREDICTABLE, if this can not be\n+     *         computed statically\n+     *\/\n+    public int produceStack(final ConstantPoolGen cpg) {\n+        return Const.getProduceStack(opcode);\n+    }\n+\n+    \/**\n+     * Needed in readInstruction and subclasses in this package\n+     *\n@@ -599,2 +561,39 @@\n-    public static boolean isValidShort(final int value) {\n-        return value >= Short.MIN_VALUE && value <= Short.MAX_VALUE;\n+    final void setLength(final int length) {\n+        this.length = (short) length; \/\/ TODO check range?\n+    }\n+\n+    \/**\n+     * Needed in readInstruction and subclasses in this package\n+     *\/\n+    void setOpcode(final short opcode) {\n+        this.opcode = opcode;\n+    }\n+\n+    \/**\n+     * @return mnemonic for instruction in verbose format\n+     *\/\n+    @Override\n+    public String toString() {\n+        return toString(true);\n+    }\n+\n+    \/**\n+     * Long output format:\n+     *\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n+     *\/\n+    public String toString(final boolean verbose) {\n+        if (verbose) {\n+            return getName() + \"[\" + opcode + \"](\" + length + \")\";\n+        }\n+        return getName();\n+    }\n+\n+    \/**\n+     * @return mnemonic for instruction with sumbolic references resolved\n+     *\/\n+    public String toString(final ConstantPool cp) {\n+        return toString(false);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Instruction.java","additions":460,"deletions":461,"binary":false,"changes":921,"status":"modified"},{"patch":"@@ -25,4 +25,2 @@\n- * Equality of instructions isn't clearly to be defined. You might\n- * wish, for example, to compare whether instructions have the same\n- * meaning. E.g., whether two INVOKEVIRTUALs describe the same\n- * call.\n+ * Equality of instructions isn't clearly to be defined. You might wish, for example, to compare whether instructions\n+ * have the same meaning. E.g., whether two INVOKEVIRTUALs describe the same call.\n@@ -30,4 +28,3 @@\n- * The DEFAULT comparator however, considers two instructions\n- * to be equal if they have same opcode and point to the same indexes\n- * (if any) in the constant pool or the same local variable index. Branch\n- * instructions must have the same target.\n+ * The DEFAULT comparator however, considers two instructions to be equal if they have same opcode and point to the same\n+ * indexes (if any) in the constant pool or the same local variable index. Branch instructions must have the same\n+ * target.\n@@ -43,1 +40,1 @@\n-             \/\/ BIs are never equal to make targeters work correctly (BCEL-195)\n+                \/\/ BIs are never equal to make targeters work correctly (BCEL-195)\n@@ -47,7 +44,8 @@\n-            } else if (i1 instanceof ConstantPushInstruction) {\n-                return ((ConstantPushInstruction) i1).getValue().equals(\n-                        ((ConstantPushInstruction) i2).getValue());\n-            } else if (i1 instanceof IndexedInstruction) {\n-                return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2)\n-                        .getIndex();\n-            } else if (i1 instanceof NEWARRAY) {\n+            }\n+            if (i1 instanceof ConstantPushInstruction) {\n+                return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());\n+            }\n+            if (i1 instanceof IndexedInstruction) {\n+                return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();\n+            }\n+            if (i1 instanceof NEWARRAY) {\n@@ -55,2 +53,0 @@\n-            } else {\n-                return true;\n@@ -58,0 +54,1 @@\n+            return true;\n@@ -62,2 +59,1 @@\n-\n-    boolean equals( Instruction i1, Instruction i2 );\n+    boolean equals(Instruction i1, Instruction i2);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionComparator.java","additions":16,"deletions":20,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,13 +27,11 @@\n- * This interface contains shareable instruction objects.\n- *\n- * In order to save memory you can use some instructions multiply,\n- * since they have an immutable state and are directly derived from\n- * Instruction.  I.e. they have no instance fields that could be\n- * changed. Since some of these instructions like ICONST_0 occur\n- * very frequently this can save a lot of time and space. This\n- * feature is an adaptation of the FlyWeight design pattern, we\n- * just use an array instead of a factory.\n- *\n- * The Instructions can also accessed directly under their names, so\n- * it's possible to write il.append(Instruction.ICONST_0);\n- *\n+ * Contains shareable instruction objects.\n+ * <p>\n+ * In order to save memory you can use some instructions multiply, since they have an immutable state and are directly\n+ * derived from Instruction. I.e. they have no instance fields that could be changed. Since some of these instructions\n+ * like ICONST_0 occur very frequently this can save a lot of time and space. This feature is an adaptation of the\n+ * FlyWeight design pattern, we just use an array instead of a factory.\n+ * <\/p>\n+ * <p>\n+ * The Instructions can also accessed directly under their names, so it's possible to write\n+ * il.append(Instruction.ICONST_0);\n+ * <\/p>\n@@ -44,5 +42,3 @@\n-     * Predefined instruction objects\n-     *\/\n-    \/*\n-     * NOTE these are not currently immutable, because Instruction\n-     * has mutable protected fields opcode and length.\n+     * Predefined instruction objects.\n+     *\n+     * NOTE these are not currently immutable, because Instruction has mutable protected fields opcode and length.\n@@ -158,2 +154,3 @@\n-    \/** You can use these constants in multiple places safely, if you can guarantee\n-     * that you will never alter their internal values, e.g. call setIndex().\n+    \/**\n+     * You can use these constants in multiple places safely, if you can guarantee that you will never alter their internal\n+     * values, e.g. call setIndex().\n@@ -175,2 +172,2 @@\n-    \/** Get object via its opcode, for immutable instructions like\n-     * branch instructions entries are set to null.\n+    \/**\n+     * Get object via its opcode, for immutable instructions like branch instructions entries are set to null.\n@@ -178,1 +175,1 @@\n-    private static final Instruction[] INSTRUCTIONS = new Instruction[256];\n+    static final Instruction[] INSTRUCTIONS = new Instruction[256];\n@@ -290,2 +287,0 @@\n-    private InstructionConst() { } \/\/ non-instantiable\n-\n@@ -294,0 +289,1 @@\n+     *\n@@ -300,0 +296,3 @@\n+\n+    private InstructionConst() {\n+    } \/\/ non-instantiable\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionConst.java","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,2 @@\n- * Instances of this class may be used, e.g., to generate typed\n- * versions of instructions. Its main purpose is to be used as the\n- * byte code generating backend of a compiler. You can subclass it to\n- * add your own create methods.\n+ * Instances of this class may be used, e.g., to generate typed versions of instructions. Its main purpose is to be used\n+ * as the byte code generating backend of a compiler. You can subclass it to add your own create methods.\n@@ -30,2 +28,2 @@\n- * Note: The static createXXX methods return singleton instances\n- * from the {@link InstructionConst} class.\n+ * Note: The static createXXX methods return singleton instances from the {@link InstructionConst} class.\n+ * <\/p>\n@@ -35,1 +33,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -39,12 +37,1 @@\n-    \/\/ N.N. These must agree with the order of Constants.T_CHAR through T_LONG\n-    private static final String[] short_names = {\n-            \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"\n-    };\n-\n-    private ClassGen cg;\n-    private ConstantPoolGen cp;\n-\n-    public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {\n-        this.cg = cg;\n-        this.cp = cp;\n-    }\n+    private static class MethodObject {\n@@ -52,0 +39,4 @@\n+        final Type[] argTypes;\n+        final Type resultType;\n+        final String className;\n+        final String name;\n@@ -53,4 +44,6 @@\n-    \/** Initialize with ClassGen object\n-     *\/\n-    public InstructionFactory(final ClassGen cg) {\n-        this(cg, cg.getConstantPool());\n+        MethodObject(final String c, final String n, final Type r, final Type[] a) {\n+            this.className = c;\n+            this.name = n;\n+            this.resultType = r;\n+            this.argTypes = a;\n+        }\n@@ -59,0 +52,1 @@\n+    private static final String APPEND = \"append\";\n@@ -60,6 +54,1 @@\n-    \/** Initialize just with ConstantPoolGen object\n-     *\/\n-    public InstructionFactory(final ConstantPoolGen cp) {\n-        this(null, cp);\n-    }\n-\n+    private static final String FQCN_STRING_BUFFER = \"java.lang.StringBuffer\";\n@@ -67,14 +56,14 @@\n-    \/** Create an invoke instruction. (Except for invokedynamic.)\n-     *\n-     * @param class_name name of the called class\n-     * @param name name of the called method\n-     * @param ret_type return type of method\n-     * @param arg_types argument types of method\n-     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,\n-     * or INVOKESPECIAL\n-     * @see Const\n-     *\/\n-    public InvokeInstruction createInvoke( final String class_name, final String name,\n-            final Type ret_type, final Type[] arg_types, final short kind ) {\n-        return createInvoke(class_name, name, ret_type, arg_types, kind, kind == Const.INVOKEINTERFACE);\n-    }\n+    \/\/ N.N. These must agree with the order of Constants.T_CHAR through T_LONG\n+    private static final String[] shortNames = {\"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"};\n+\n+    private static final MethodObject[] appendMethodObjects = {\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.STRING }),\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.OBJECT }), null, null, \/\/ indices 2, 3\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.BOOLEAN }),\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.CHAR }),\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.FLOAT }),\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.DOUBLE }),\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }),\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }), \/\/ No append(byte)\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }), \/\/ No append(short)\n+            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.LONG })};\n@@ -83,10 +72,1 @@\n-     * Creates an invoke instruction. (Except for invokedynamic.)\n-     *\n-     * @param class_name name of the called class\n-     * @param name name of the called method\n-     * @param ret_type return type of method\n-     * @param arg_types argument types of method\n-     * @param kind how to invoke: INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n-     * @param use_interface force use of InterfaceMethodref\n-     * @return A new InvokeInstruction.\n-     * @since 6.5.0\n+     * @param type type of elements of array, i.e., array.getElementType()\n@@ -94,28 +74,20 @@\n-    public InvokeInstruction createInvoke( final String class_name, final String name, final Type ret_type,\n-        final Type[] arg_types, final short kind, final boolean use_interface) {\n-        if (kind != Const.INVOKESPECIAL && kind != Const.INVOKEVIRTUAL && kind != Const.INVOKESTATIC\n-            && kind != Const.INVOKEINTERFACE && kind != Const.INVOKEDYNAMIC) {\n-            throw new IllegalArgumentException(\"Unknown invoke kind: \" + kind);\n-        }\n-        int index;\n-        int nargs = 0;\n-        final String signature = Type.getMethodSignature(ret_type, arg_types);\n-        for (final Type arg_type : arg_types) {\n-            nargs += arg_type.getSize();\n-        }\n-        if (use_interface) {\n-            index = cp.addInterfaceMethodref(class_name, name, signature);\n-        } else {\n-            index = cp.addMethodref(class_name, name, signature);\n-        }\n-        switch (kind) {\n-        case Const.INVOKESPECIAL:\n-            return new INVOKESPECIAL(index);\n-        case Const.INVOKEVIRTUAL:\n-            return new INVOKEVIRTUAL(index);\n-        case Const.INVOKESTATIC:\n-            return new INVOKESTATIC(index);\n-        case Const.INVOKEINTERFACE:\n-            return new INVOKEINTERFACE(index, nargs + 1);\n-        case Const.INVOKEDYNAMIC:\n-            return new INVOKEDYNAMIC(index);\n+    public static ArrayInstruction createArrayLoad(final Type type) {\n+        switch (type.getType()) {\n+        case Const.T_BOOLEAN:\n+        case Const.T_BYTE:\n+            return InstructionConst.BALOAD;\n+        case Const.T_CHAR:\n+            return InstructionConst.CALOAD;\n+        case Const.T_SHORT:\n+            return InstructionConst.SALOAD;\n+        case Const.T_INT:\n+            return InstructionConst.IALOAD;\n+        case Const.T_FLOAT:\n+            return InstructionConst.FALOAD;\n+        case Const.T_DOUBLE:\n+            return InstructionConst.DALOAD;\n+        case Const.T_LONG:\n+            return InstructionConst.LALOAD;\n+        case Const.T_ARRAY:\n+        case Const.T_OBJECT:\n+            return InstructionConst.AALOAD;\n@@ -123,2 +95,1 @@\n-            \/\/ Can't happen\n-            throw new IllegalStateException(\"Unknown invoke kind: \" + kind);\n+            throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -128,7 +99,2 @@\n-    \/** Create an invokedynamic instruction.\n-     *\n-     * @param bootstrap_index index into the bootstrap_methods array\n-     * @param name name of the called method\n-     * @param ret_type return type of method\n-     * @param arg_types argument types of method\n-     * @see Constants\n+    \/**\n+     * @param type type of elements of array, i.e., array.getElementType()\n@@ -136,11 +102,22 @@\n-\/*\n- * createInvokeDynamic only needed if instrumention code wants to generate\n- * a new invokedynamic instruction.  I don't think we need.  (markro)\n- *\n-    public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,\n-            Type[] arg_types) {\n-        int index;\n-        int nargs = 0;\n-        String signature = Type.getMethodSignature(ret_type, arg_types);\n-        for (int i = 0; i < arg_types.length; i++) {\n-            nargs += arg_types[i].getSize();\n+    public static ArrayInstruction createArrayStore(final Type type) {\n+        switch (type.getType()) {\n+        case Const.T_BOOLEAN:\n+        case Const.T_BYTE:\n+            return InstructionConst.BASTORE;\n+        case Const.T_CHAR:\n+            return InstructionConst.CASTORE;\n+        case Const.T_SHORT:\n+            return InstructionConst.SASTORE;\n+        case Const.T_INT:\n+            return InstructionConst.IASTORE;\n+        case Const.T_FLOAT:\n+            return InstructionConst.FASTORE;\n+        case Const.T_DOUBLE:\n+            return InstructionConst.DASTORE;\n+        case Const.T_LONG:\n+            return InstructionConst.LASTORE;\n+        case Const.T_ARRAY:\n+        case Const.T_OBJECT:\n+            return InstructionConst.AASTORE;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -148,19 +125,0 @@\n-        \/\/ UNDONE - needs to be added to ConstantPoolGen\n-        \/\/index = cp.addInvokeDynamic(bootstrap_index, name, signature);\n-        index = 0;\n-        return new INVOKEDYNAMIC(index);\n-    }\n- *\/\n-\n-    \/** Create a call to the most popular System.out.println() method.\n-     *\n-     * @param s the string to print\n-     *\/\n-    public InstructionList createPrintln( final String s ) {\n-        final InstructionList il = new InstructionList();\n-        final int out = cp.addFieldref(\"java.lang.System\", \"out\", \"Ljava\/io\/PrintStream;\");\n-        final int println = cp.addMethodref(\"java.io.PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\");\n-        il.append(new GETSTATIC(out));\n-        il.append(new PUSH(cp, s));\n-        il.append(new INVOKEVIRTUAL(println));\n-        return il;\n@@ -169,16 +127,14 @@\n-\n-    \/** Uses PUSH to push a constant value onto the stack.\n-     * @param value must be of type Number, Boolean, Character or String\n-     *\/\n-    public Instruction createConstant( final Object value ) {\n-        PUSH push;\n-        if (value instanceof Number) {\n-            push = new PUSH(cp, (Number) value);\n-        } else if (value instanceof String) {\n-            push = new PUSH(cp, (String) value);\n-        } else if (value instanceof Boolean) {\n-            push = new PUSH(cp, (Boolean) value);\n-        } else if (value instanceof Character) {\n-            push = new PUSH(cp, (Character) value);\n-        } else {\n-            throw new ClassGenException(\"Illegal type: \" + value.getClass());\n+    private static ArithmeticInstruction createBinaryDoubleOp(final char op) {\n+        switch (op) {\n+        case '-':\n+            return InstructionConst.DSUB;\n+        case '+':\n+            return InstructionConst.DADD;\n+        case '*':\n+            return InstructionConst.DMUL;\n+        case '\/':\n+            return InstructionConst.DDIV;\n+        case '%':\n+            return InstructionConst.DREM;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid operand \" + op);\n@@ -186,1 +142,0 @@\n-        return push.getInstruction();\n@@ -189,13 +144,14 @@\n-    private static class MethodObject {\n-\n-        final Type[] arg_types;\n-        final Type result_type;\n-        final String class_name;\n-        final String name;\n-\n-\n-        MethodObject(final String c, final String n, final Type r, final Type[] a) {\n-            class_name = c;\n-            name = n;\n-            result_type = r;\n-            arg_types = a;\n+    private static ArithmeticInstruction createBinaryFloatOp(final char op) {\n+        switch (op) {\n+        case '-':\n+            return InstructionConst.FSUB;\n+        case '+':\n+            return InstructionConst.FADD;\n+        case '*':\n+            return InstructionConst.FMUL;\n+        case '\/':\n+            return InstructionConst.FDIV;\n+        case '%':\n+            return InstructionConst.FREM;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid operand \" + op);\n@@ -205,69 +161,24 @@\n-\n-    private InvokeInstruction createInvoke( final MethodObject m, final short kind ) {\n-        return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);\n-    }\n-\n-    private static final MethodObject[] append_mos = {\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.STRING\n-            }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.OBJECT\n-            }),\n-            null,\n-            null, \/\/ indices 2, 3\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.BOOLEAN\n-            }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.CHAR\n-            }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.FLOAT\n-            }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.DOUBLE\n-            }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.INT\n-            }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, \/\/ No append(byte)\n-                    new Type[] {\n-                        Type.INT\n-                    }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, \/\/ No append(short)\n-                    new Type[] {\n-                        Type.INT\n-                    }),\n-            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n-                Type.LONG\n-            })\n-    };\n-\n-\n-    private static boolean isString( final Type type ) {\n-        return (type instanceof ObjectType) &&\n-              ((ObjectType) type).getClassName().equals(\"java.lang.String\");\n-    }\n-\n-\n-    public Instruction createAppend( final Type type ) {\n-        final byte t = type.getType();\n-        if (isString(type)) {\n-            return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);\n-        }\n-        switch (t) {\n-            case Const.T_BOOLEAN:\n-            case Const.T_CHAR:\n-            case Const.T_FLOAT:\n-            case Const.T_DOUBLE:\n-            case Const.T_BYTE:\n-            case Const.T_SHORT:\n-            case Const.T_INT:\n-            case Const.T_LONG:\n-                return createInvoke(append_mos[t], Const.INVOKEVIRTUAL);\n-            case Const.T_ARRAY:\n-            case Const.T_OBJECT:\n-                return createInvoke(append_mos[1], Const.INVOKEVIRTUAL);\n-            default:\n-                throw new IllegalArgumentException(\"No append for this type? \" + type);\n+    private static ArithmeticInstruction createBinaryIntOp(final char first, final String op) {\n+        switch (first) {\n+        case '-':\n+            return InstructionConst.ISUB;\n+        case '+':\n+            return InstructionConst.IADD;\n+        case '%':\n+            return InstructionConst.IREM;\n+        case '*':\n+            return InstructionConst.IMUL;\n+        case '\/':\n+            return InstructionConst.IDIV;\n+        case '&':\n+            return InstructionConst.IAND;\n+        case '|':\n+            return InstructionConst.IOR;\n+        case '^':\n+            return InstructionConst.IXOR;\n+        case '<':\n+            return InstructionConst.ISHL;\n+        case '>':\n+            return op.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid operand \" + op);\n@@ -277,2 +188,2 @@\n-\n-    \/** Create a field instruction.\n+    \/**\n+     * Create an invokedynamic instruction.\n@@ -280,4 +191,4 @@\n-     * @param class_name name of the accessed class\n-     * @param name name of the referenced field\n-     * @param type  type of field\n-     * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC\n+     * @param bootstrap_index index into the bootstrap_methods array\n+     * @param name name of the called method\n+     * @param ret_type return type of method\n+     * @param argTypes argument types of method\n@@ -286,26 +197,0 @@\n-    public FieldInstruction createFieldAccess( final String class_name,\n-            final String name, final Type type, final short kind ) {\n-        int index;\n-        final String signature = type.getSignature();\n-        index = cp.addFieldref(class_name, name, signature);\n-        switch (kind) {\n-            case Const.GETFIELD:\n-                return new GETFIELD(index);\n-            case Const.PUTFIELD:\n-                return new PUTFIELD(index);\n-            case Const.GETSTATIC:\n-                return new GETSTATIC(index);\n-            case Const.PUTSTATIC:\n-                return new PUTSTATIC(index);\n-            default:\n-                throw new IllegalArgumentException(\"Unknown getfield kind:\" + kind);\n-        }\n-    }\n-\n-\n-    \/** Create reference to `this'\n-     *\/\n-    public static Instruction createThis() {\n-        return new ALOAD(0);\n-    }\n-\n@@ -313,1 +198,8 @@\n-    \/** Create typed return\n+    \/*\n+     * createInvokeDynamic only needed if instrumentation code wants to generate a new invokedynamic instruction. I don't\n+     * think we need.\n+     *\n+     * public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type, Type[] argTypes) {\n+     * int index; int nargs = 0; String signature = Type.getMethodSignature(ret_type, argTypes); for (int i = 0; i <\n+     * argTypes.length; i++) { nargs += argTypes[i].getSize(); } \/\/ UNDONE - needs to be added to ConstantPoolGen \/\/index\n+     * = cp.addInvokeDynamic(bootstrap_index, name, signature); index = 0; return new INVOKEDYNAMIC(index); }\n@@ -315,24 +207,0 @@\n-    public static ReturnInstruction createReturn( final Type type ) {\n-        switch (type.getType()) {\n-            case Const.T_ARRAY:\n-            case Const.T_OBJECT:\n-                return InstructionConst.ARETURN;\n-            case Const.T_INT:\n-            case Const.T_SHORT:\n-            case Const.T_BOOLEAN:\n-            case Const.T_CHAR:\n-            case Const.T_BYTE:\n-                return InstructionConst.IRETURN;\n-            case Const.T_FLOAT:\n-                return InstructionConst.FRETURN;\n-            case Const.T_DOUBLE:\n-                return InstructionConst.DRETURN;\n-            case Const.T_LONG:\n-                return InstructionConst.LRETURN;\n-            case Const.T_VOID:\n-                return InstructionConst.RETURN;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid type: \" + type);\n-        }\n-    }\n-\n@@ -340,1 +208,1 @@\n-    private static ArithmeticInstruction createBinaryIntOp( final char first, final String op ) {\n+    private static ArithmeticInstruction createBinaryLongOp(final char first, final String op) {\n@@ -342,86 +210,22 @@\n-            case '-':\n-                return InstructionConst.ISUB;\n-            case '+':\n-                return InstructionConst.IADD;\n-            case '%':\n-                return InstructionConst.IREM;\n-            case '*':\n-                return InstructionConst.IMUL;\n-            case '\/':\n-                return InstructionConst.IDIV;\n-            case '&':\n-                return InstructionConst.IAND;\n-            case '|':\n-                return InstructionConst.IOR;\n-            case '^':\n-                return InstructionConst.IXOR;\n-            case '<':\n-                return InstructionConst.ISHL;\n-            case '>':\n-                return op.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid operand \" + op);\n-        }\n-    }\n-\n-\n-    private static ArithmeticInstruction createBinaryLongOp( final char first, final String op ) {\n-        switch (first) {\n-            case '-':\n-                return InstructionConst.LSUB;\n-            case '+':\n-                return InstructionConst.LADD;\n-            case '%':\n-                return InstructionConst.LREM;\n-            case '*':\n-                return InstructionConst.LMUL;\n-            case '\/':\n-                return InstructionConst.LDIV;\n-            case '&':\n-                return InstructionConst.LAND;\n-            case '|':\n-                return InstructionConst.LOR;\n-            case '^':\n-                return InstructionConst.LXOR;\n-            case '<':\n-                return InstructionConst.LSHL;\n-            case '>':\n-                return op.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid operand \" + op);\n-        }\n-    }\n-\n-\n-    private static ArithmeticInstruction createBinaryFloatOp( final char op ) {\n-        switch (op) {\n-            case '-':\n-                return InstructionConst.FSUB;\n-            case '+':\n-                return InstructionConst.FADD;\n-            case '*':\n-                return InstructionConst.FMUL;\n-            case '\/':\n-                return InstructionConst.FDIV;\n-            case '%':\n-                return InstructionConst.FREM;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid operand \" + op);\n-        }\n-    }\n-\n-\n-    private static ArithmeticInstruction createBinaryDoubleOp( final char op ) {\n-        switch (op) {\n-            case '-':\n-                return InstructionConst.DSUB;\n-            case '+':\n-                return InstructionConst.DADD;\n-            case '*':\n-                return InstructionConst.DMUL;\n-            case '\/':\n-                return InstructionConst.DDIV;\n-            case '%':\n-                return InstructionConst.DREM;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid operand \" + op);\n+        case '-':\n+            return InstructionConst.LSUB;\n+        case '+':\n+            return InstructionConst.LADD;\n+        case '%':\n+            return InstructionConst.LREM;\n+        case '*':\n+            return InstructionConst.LMUL;\n+        case '\/':\n+            return InstructionConst.LDIV;\n+        case '&':\n+            return InstructionConst.LAND;\n+        case '|':\n+            return InstructionConst.LOR;\n+        case '^':\n+            return InstructionConst.LXOR;\n+        case '<':\n+            return InstructionConst.LSHL;\n+        case '>':\n+            return op.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid operand \" + op);\n@@ -431,1 +235,0 @@\n-\n@@ -437,1 +240,1 @@\n-    public static ArithmeticInstruction createBinaryOperation( final String op, final Type type ) {\n+    public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {\n@@ -440,13 +243,13 @@\n-            case Const.T_BYTE:\n-            case Const.T_SHORT:\n-            case Const.T_INT:\n-            case Const.T_CHAR:\n-                return createBinaryIntOp(first, op);\n-            case Const.T_LONG:\n-                return createBinaryLongOp(first, op);\n-            case Const.T_FLOAT:\n-                return createBinaryFloatOp(first);\n-            case Const.T_DOUBLE:\n-                return createBinaryDoubleOp(first);\n-            default:\n-                throw new IllegalArgumentException(\"Invalid type \" + type);\n+        case Const.T_BYTE:\n+        case Const.T_SHORT:\n+        case Const.T_INT:\n+        case Const.T_CHAR:\n+            return createBinaryIntOp(first, op);\n+        case Const.T_LONG:\n+            return createBinaryLongOp(first, op);\n+        case Const.T_FLOAT:\n+            return createBinaryFloatOp(first);\n+        case Const.T_DOUBLE:\n+            return createBinaryDoubleOp(first);\n+        default:\n+            throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -456,0 +259,50 @@\n+    \/**\n+     * Create branch instruction by given opcode, except LOOKUPSWITCH and TABLESWITCH. For those you should use the SWITCH\n+     * compound instruction.\n+     *\/\n+    public static BranchInstruction createBranchInstruction(final short opcode, final InstructionHandle target) {\n+        switch (opcode) {\n+        case Const.IFEQ:\n+            return new IFEQ(target);\n+        case Const.IFNE:\n+            return new IFNE(target);\n+        case Const.IFLT:\n+            return new IFLT(target);\n+        case Const.IFGE:\n+            return new IFGE(target);\n+        case Const.IFGT:\n+            return new IFGT(target);\n+        case Const.IFLE:\n+            return new IFLE(target);\n+        case Const.IF_ICMPEQ:\n+            return new IF_ICMPEQ(target);\n+        case Const.IF_ICMPNE:\n+            return new IF_ICMPNE(target);\n+        case Const.IF_ICMPLT:\n+            return new IF_ICMPLT(target);\n+        case Const.IF_ICMPGE:\n+            return new IF_ICMPGE(target);\n+        case Const.IF_ICMPGT:\n+            return new IF_ICMPGT(target);\n+        case Const.IF_ICMPLE:\n+            return new IF_ICMPLE(target);\n+        case Const.IF_ACMPEQ:\n+            return new IF_ACMPEQ(target);\n+        case Const.IF_ACMPNE:\n+            return new IF_ACMPNE(target);\n+        case Const.GOTO:\n+            return new GOTO(target);\n+        case Const.JSR:\n+            return new JSR(target);\n+        case Const.IFNULL:\n+            return new IFNULL(target);\n+        case Const.IFNONNULL:\n+            return new IFNONNULL(target);\n+        case Const.GOTO_W:\n+            return new GOTO_W(target);\n+        case Const.JSR_W:\n+            return new JSR_W(target);\n+        default:\n+            throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\n+        }\n+    }\n@@ -460,2 +313,2 @@\n-    public static StackInstruction createPop( final int size ) {\n-        return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;\n+    public static StackInstruction createDup(final int size) {\n+        return size == 2 ? InstructionConst.DUP2 : InstructionConst.DUP;\n@@ -464,1 +317,0 @@\n-\n@@ -468,2 +320,2 @@\n-    public static StackInstruction createDup( final int size ) {\n-        return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;\n+    public static StackInstruction createDup_1(final int size) {\n+        return size == 2 ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n@@ -472,1 +324,0 @@\n-\n@@ -476,2 +327,2 @@\n-    public static StackInstruction createDup_2( final int size ) {\n-        return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n+    public static StackInstruction createDup_2(final int size) {\n+        return size == 2 ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n@@ -480,0 +331,24 @@\n+    \/**\n+     * @param index index of local variable\n+     *\/\n+    public static LocalVariableInstruction createLoad(final Type type, final int index) {\n+        switch (type.getType()) {\n+        case Const.T_BOOLEAN:\n+        case Const.T_CHAR:\n+        case Const.T_BYTE:\n+        case Const.T_SHORT:\n+        case Const.T_INT:\n+            return new ILOAD(index);\n+        case Const.T_FLOAT:\n+            return new FLOAD(index);\n+        case Const.T_DOUBLE:\n+            return new DLOAD(index);\n+        case Const.T_LONG:\n+            return new LLOAD(index);\n+        case Const.T_ARRAY:\n+        case Const.T_OBJECT:\n+            return new ALOAD(index);\n+        default:\n+            throw new IllegalArgumentException(\"Invalid type \" + type);\n+        }\n+    }\n@@ -482,1 +357,1 @@\n-     * @param size size of operand, either 1 (int, e.g.) or 2 (double)\n+     * Create \"null\" value for reference types, 0 for basic types like int\n@@ -484,2 +359,22 @@\n-    public static StackInstruction createDup_1( final int size ) {\n-        return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n+    public static Instruction createNull(final Type type) {\n+        switch (type.getType()) {\n+        case Const.T_ARRAY:\n+        case Const.T_OBJECT:\n+            return InstructionConst.ACONST_NULL;\n+        case Const.T_INT:\n+        case Const.T_SHORT:\n+        case Const.T_BOOLEAN:\n+        case Const.T_CHAR:\n+        case Const.T_BYTE:\n+            return InstructionConst.ICONST_0;\n+        case Const.T_FLOAT:\n+            return InstructionConst.FCONST_0;\n+        case Const.T_DOUBLE:\n+            return InstructionConst.DCONST_0;\n+        case Const.T_LONG:\n+            return InstructionConst.LCONST_0;\n+        case Const.T_VOID:\n+            return InstructionConst.NOP;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid type: \" + type);\n+        }\n@@ -488,0 +383,6 @@\n+    \/**\n+     * @param size size of operand, either 1 (int, e.g.) or 2 (double)\n+     *\/\n+    public static StackInstruction createPop(final int size) {\n+        return size == 2 ? InstructionConst.POP2 : InstructionConst.POP;\n+    }\n@@ -490,1 +391,1 @@\n-     * @param index index of local variable\n+     * Create typed return\n@@ -492,1 +393,1 @@\n-    public static LocalVariableInstruction createStore( final Type type, final int index ) {\n+    public static ReturnInstruction createReturn(final Type type) {\n@@ -494,17 +395,19 @@\n-            case Const.T_BOOLEAN:\n-            case Const.T_CHAR:\n-            case Const.T_BYTE:\n-            case Const.T_SHORT:\n-            case Const.T_INT:\n-                return new ISTORE(index);\n-            case Const.T_FLOAT:\n-                return new FSTORE(index);\n-            case Const.T_DOUBLE:\n-                return new DSTORE(index);\n-            case Const.T_LONG:\n-                return new LSTORE(index);\n-            case Const.T_ARRAY:\n-            case Const.T_OBJECT:\n-                return new ASTORE(index);\n-            default:\n-                throw new IllegalArgumentException(\"Invalid type \" + type);\n+        case Const.T_ARRAY:\n+        case Const.T_OBJECT:\n+            return InstructionConst.ARETURN;\n+        case Const.T_INT:\n+        case Const.T_SHORT:\n+        case Const.T_BOOLEAN:\n+        case Const.T_CHAR:\n+        case Const.T_BYTE:\n+            return InstructionConst.IRETURN;\n+        case Const.T_FLOAT:\n+            return InstructionConst.FRETURN;\n+        case Const.T_DOUBLE:\n+            return InstructionConst.DRETURN;\n+        case Const.T_LONG:\n+            return InstructionConst.LRETURN;\n+        case Const.T_VOID:\n+            return InstructionConst.RETURN;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid type: \" + type);\n@@ -514,1 +417,0 @@\n-\n@@ -518,1 +420,1 @@\n-    public static LocalVariableInstruction createLoad( final Type type, final int index ) {\n+    public static LocalVariableInstruction createStore(final Type type, final int index) {\n@@ -520,17 +422,17 @@\n-            case Const.T_BOOLEAN:\n-            case Const.T_CHAR:\n-            case Const.T_BYTE:\n-            case Const.T_SHORT:\n-            case Const.T_INT:\n-                return new ILOAD(index);\n-            case Const.T_FLOAT:\n-                return new FLOAD(index);\n-            case Const.T_DOUBLE:\n-                return new DLOAD(index);\n-            case Const.T_LONG:\n-                return new LLOAD(index);\n-            case Const.T_ARRAY:\n-            case Const.T_OBJECT:\n-                return new ALOAD(index);\n-            default:\n-                throw new IllegalArgumentException(\"Invalid type \" + type);\n+        case Const.T_BOOLEAN:\n+        case Const.T_CHAR:\n+        case Const.T_BYTE:\n+        case Const.T_SHORT:\n+        case Const.T_INT:\n+            return new ISTORE(index);\n+        case Const.T_FLOAT:\n+            return new FSTORE(index);\n+        case Const.T_DOUBLE:\n+            return new DSTORE(index);\n+        case Const.T_LONG:\n+            return new LSTORE(index);\n+        case Const.T_ARRAY:\n+        case Const.T_OBJECT:\n+            return new ASTORE(index);\n+        default:\n+            throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -540,0 +442,10 @@\n+    \/**\n+     * Create reference to 'this'\n+     *\/\n+    public static Instruction createThis() {\n+        return new ALOAD(0);\n+    }\n+\n+    private static boolean isString(final Type type) {\n+        return type instanceof ObjectType && ((ObjectType) type).getClassName().equals(\"java.lang.String\");\n+    }\n@@ -542,1 +454,1 @@\n-     * @param type type of elements of array, i.e., array.getElementType()\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -544,23 +456,14 @@\n-    public static ArrayInstruction createArrayLoad( final Type type ) {\n-        switch (type.getType()) {\n-            case Const.T_BOOLEAN:\n-            case Const.T_BYTE:\n-                return InstructionConst.BALOAD;\n-            case Const.T_CHAR:\n-                return InstructionConst.CALOAD;\n-            case Const.T_SHORT:\n-                return InstructionConst.SALOAD;\n-            case Const.T_INT:\n-                return InstructionConst.IALOAD;\n-            case Const.T_FLOAT:\n-                return InstructionConst.FALOAD;\n-            case Const.T_DOUBLE:\n-                return InstructionConst.DALOAD;\n-            case Const.T_LONG:\n-                return InstructionConst.LALOAD;\n-            case Const.T_ARRAY:\n-            case Const.T_OBJECT:\n-                return InstructionConst.AALOAD;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid type \" + type);\n-        }\n+    @Deprecated\n+    protected ClassGen cg;\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected ConstantPoolGen cp;\n+\n+    \/**\n+     * Initialize with ClassGen object\n+     *\/\n+    public InstructionFactory(final ClassGen cg) {\n+        this(cg, cg.getConstantPool());\n@@ -569,0 +472,4 @@\n+    public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {\n+        this.cg = cg;\n+        this.cp = cp;\n+    }\n@@ -571,1 +478,1 @@\n-     * @param type type of elements of array, i.e., array.getElementType()\n+     * Initialize just with ConstantPoolGen object\n@@ -573,22 +480,24 @@\n-    public static ArrayInstruction createArrayStore( final Type type ) {\n-        switch (type.getType()) {\n-            case Const.T_BOOLEAN:\n-            case Const.T_BYTE:\n-                return InstructionConst.BASTORE;\n-            case Const.T_CHAR:\n-                return InstructionConst.CASTORE;\n-            case Const.T_SHORT:\n-                return InstructionConst.SASTORE;\n-            case Const.T_INT:\n-                return InstructionConst.IASTORE;\n-            case Const.T_FLOAT:\n-                return InstructionConst.FASTORE;\n-            case Const.T_DOUBLE:\n-                return InstructionConst.DASTORE;\n-            case Const.T_LONG:\n-                return InstructionConst.LASTORE;\n-            case Const.T_ARRAY:\n-            case Const.T_OBJECT:\n-                return InstructionConst.AASTORE;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid type \" + type);\n+    public InstructionFactory(final ConstantPoolGen cp) {\n+        this(null, cp);\n+    }\n+\n+    public Instruction createAppend(final Type type) {\n+        final byte t = type.getType();\n+        if (isString(type)) {\n+            return createInvoke(appendMethodObjects[0], Const.INVOKEVIRTUAL);\n+        }\n+        switch (t) {\n+        case Const.T_BOOLEAN:\n+        case Const.T_CHAR:\n+        case Const.T_FLOAT:\n+        case Const.T_DOUBLE:\n+        case Const.T_BYTE:\n+        case Const.T_SHORT:\n+        case Const.T_INT:\n+        case Const.T_LONG:\n+            return createInvoke(appendMethodObjects[t], Const.INVOKEVIRTUAL);\n+        case Const.T_ARRAY:\n+        case Const.T_OBJECT:\n+            return createInvoke(appendMethodObjects[1], Const.INVOKEVIRTUAL);\n+        default:\n+            throw new IllegalArgumentException(\"No append for this type? \" + type);\n@@ -599,3 +508,2 @@\n-     * Create conversion operation for two stack operands, this may be an I2C,\n-     * instruction, e.g., if the operands are basic types and CHECKCAST if they\n-     * are reference types.\n+     * Create conversion operation for two stack operands, this may be an I2C, instruction, e.g., if the operands are basic\n+     * types and CHECKCAST if they are reference types.\n@@ -603,6 +511,5 @@\n-    public Instruction createCast( final Type src_type, final Type dest_type ) {\n-        if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {\n-            final byte dest = dest_type.getType();\n-            byte src = src_type.getType();\n-            if (dest == Const.T_LONG\n-                    && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {\n+    public Instruction createCast(final Type srcType, final Type destType) {\n+        if (srcType instanceof BasicType && destType instanceof BasicType) {\n+            final byte dest = destType.getType();\n+            byte src = srcType.getType();\n+            if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {\n@@ -611,2 +518,1 @@\n-            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + short_names[src - Const.T_CHAR] + \"2\"\n-                    + short_names[dest - Const.T_CHAR];\n+            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + shortNames[src - Const.T_CHAR] + \"2\" + shortNames[dest - Const.T_CHAR];\n@@ -615,1 +521,1 @@\n-                i = (Instruction) java.lang.Class.forName(name).getDeclaredConstructor().newInstance();\n+                i = (Instruction) Class.forName(name).getDeclaredConstructor().newInstance();;\n@@ -620,7 +526,0 @@\n-        } else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {\n-            if (dest_type instanceof ArrayType) {\n-                return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));\n-            }\n-            return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));\n-        } else {\n-            throw new IllegalArgumentException(\"Cannot cast \" + src_type + \" to \" + dest_type);\n@@ -628,0 +527,7 @@\n+        if (!(srcType instanceof ReferenceType) || !(destType instanceof ReferenceType)) {\n+            throw new IllegalArgumentException(\"Cannot cast \" + srcType + \" to \" + destType);\n+        }\n+        if (destType instanceof ArrayType) {\n+            return new CHECKCAST(cp.addArrayClass((ArrayType) destType));\n+        }\n+        return new CHECKCAST(cp.addClass(((ObjectType) destType).getClassName()));\n@@ -630,3 +536,5 @@\n-\n-    public GETFIELD createGetField( final String class_name, final String name, final Type t ) {\n-        return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));\n+    public CHECKCAST createCheckCast(final ReferenceType t) {\n+        if (t instanceof ArrayType) {\n+            return new CHECKCAST(cp.addArrayClass((ArrayType) t));\n+        }\n+        return new CHECKCAST(cp.addClass((ObjectType) t));\n@@ -635,3 +543,19 @@\n-\n-    public GETSTATIC createGetStatic( final String class_name, final String name, final Type t ) {\n-        return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));\n+    \/**\n+     * Uses PUSH to push a constant value onto the stack.\n+     *\n+     * @param value must be of type Number, Boolean, Character or String\n+     *\/\n+    public Instruction createConstant(final Object value) {\n+        PUSH push;\n+        if (value instanceof Number) {\n+            push = new PUSH(cp, (Number) value);\n+        } else if (value instanceof String) {\n+            push = new PUSH(cp, (String) value);\n+        } else if (value instanceof Boolean) {\n+            push = new PUSH(cp, (Boolean) value);\n+        } else if (value instanceof Character) {\n+            push = new PUSH(cp, (Character) value);\n+        } else {\n+            throw new ClassGenException(\"Illegal type: \" + value.getClass());\n+        }\n+        return push.getInstruction();\n@@ -640,3 +564,25 @@\n-\n-    public PUTFIELD createPutField( final String class_name, final String name, final Type t ) {\n-        return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));\n+    \/**\n+     * Create a field instruction.\n+     *\n+     * @param className name of the accessed class\n+     * @param name name of the referenced field\n+     * @param type type of field\n+     * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC\n+     * @see Const\n+     *\/\n+    public FieldInstruction createFieldAccess(final String className, final String name, final Type type, final short kind) {\n+        int index;\n+        final String signature = type.getSignature();\n+        index = cp.addFieldref(className, name, signature);\n+        switch (kind) {\n+        case Const.GETFIELD:\n+            return new GETFIELD(index);\n+        case Const.PUTFIELD:\n+            return new PUTFIELD(index);\n+        case Const.GETSTATIC:\n+            return new GETSTATIC(index);\n+        case Const.PUTSTATIC:\n+            return new PUTSTATIC(index);\n+        default:\n+            throw new IllegalArgumentException(\"Unknown getfield kind:\" + kind);\n+        }\n@@ -645,3 +591,2 @@\n-\n-    public PUTSTATIC createPutStatic( final String class_name, final String name, final Type t ) {\n-        return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));\n+    public GETFIELD createGetField(final String className, final String name, final Type t) {\n+        return new GETFIELD(cp.addFieldref(className, name, t.getSignature()));\n@@ -650,6 +595,2 @@\n-\n-    public CHECKCAST createCheckCast( final ReferenceType t ) {\n-        if (t instanceof ArrayType) {\n-            return new CHECKCAST(cp.addArrayClass((ArrayType) t));\n-        }\n-        return new CHECKCAST(cp.addClass((ObjectType) t));\n+    public GETSTATIC createGetStatic(final String className, final String name, final Type t) {\n+        return new GETSTATIC(cp.addFieldref(className, name, t.getSignature()));\n@@ -658,2 +599,1 @@\n-\n-    public INSTANCEOF createInstanceOf( final ReferenceType t ) {\n+    public INSTANCEOF createInstanceOf(final ReferenceType t) {\n@@ -666,0 +606,3 @@\n+    private InvokeInstruction createInvoke(final MethodObject m, final short kind) {\n+        return createInvoke(m.className, m.name, m.resultType, m.argTypes, kind);\n+    }\n@@ -667,2 +610,58 @@\n-    public NEW createNew( final ObjectType t ) {\n-        return new NEW(cp.addClass(t));\n+    \/**\n+     * Create an invoke instruction. (Except for invokedynamic.)\n+     *\n+     * @param className name of the called class\n+     * @param name name of the called method\n+     * @param retType return type of method\n+     * @param argTypes argument types of method\n+     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n+     * @see Const\n+     *\/\n+    public InvokeInstruction createInvoke(final String className, final String name, final Type retType, final Type[] argTypes, final short kind) {\n+        return createInvoke(className, name, retType, argTypes, kind, kind == Const.INVOKEINTERFACE);\n+    }\n+\n+    \/**\n+     * Create an invoke instruction. (Except for invokedynamic.)\n+     *\n+     * @param className name of the called class\n+     * @param name name of the called method\n+     * @param retType return type of method\n+     * @param argTypes argument types of method\n+     * @param kind how to invoke: INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n+     * @param useInterface force use of InterfaceMethodref\n+     * @return A new InvokeInstruction.\n+     * @since 6.5.0\n+     *\/\n+    public InvokeInstruction createInvoke(final String className, final String name, final Type retType, final Type[] argTypes, final short kind,\n+        final boolean useInterface) {\n+        if (kind != Const.INVOKESPECIAL && kind != Const.INVOKEVIRTUAL && kind != Const.INVOKESTATIC && kind != Const.INVOKEINTERFACE\n+            && kind != Const.INVOKEDYNAMIC) {\n+            throw new IllegalArgumentException(\"Unknown invoke kind: \" + kind);\n+        }\n+        int index;\n+        int nargs = 0;\n+        final String signature = Type.getMethodSignature(retType, argTypes);\n+        for (final Type argType : argTypes) {\n+            nargs += argType.getSize();\n+        }\n+        if (useInterface) {\n+            index = cp.addInterfaceMethodref(className, name, signature);\n+        } else {\n+            index = cp.addMethodref(className, name, signature);\n+        }\n+        switch (kind) {\n+        case Const.INVOKESPECIAL:\n+            return new INVOKESPECIAL(index);\n+        case Const.INVOKEVIRTUAL:\n+            return new INVOKEVIRTUAL(index);\n+        case Const.INVOKESTATIC:\n+            return new INVOKESTATIC(index);\n+        case Const.INVOKEINTERFACE:\n+            return new INVOKEINTERFACE(index, nargs + 1);\n+        case Const.INVOKEDYNAMIC:\n+            return new INVOKEDYNAMIC(index);\n+        default:\n+            \/\/ Can't happen\n+            throw new IllegalStateException(\"Unknown invoke kind: \" + kind);\n+        }\n@@ -671,0 +670,3 @@\n+    public NEW createNew(final ObjectType t) {\n+        return new NEW(cp.addClass(t));\n+    }\n@@ -672,1 +674,1 @@\n-    public NEW createNew( final String s ) {\n+    public NEW createNew(final String s) {\n@@ -679,2 +681,1 @@\n-     * @return an instruction that creates the corresponding array at runtime,\n-     * i.e. is an AllocationInstruction\n+     * @return an instruction that creates the corresponding array at runtime, i.e. is an AllocationInstruction\n@@ -682,1 +683,1 @@\n-    public Instruction createNewArray( final Type t, final short dim ) {\n+    public Instruction createNewArray(final Type t, final short dim) {\n@@ -686,1 +687,2 @@\n-            } else if (t instanceof ArrayType) {\n+            }\n+            if (t instanceof ArrayType) {\n@@ -688,2 +690,0 @@\n-            } else {\n-                return new NEWARRAY(t.getType());\n@@ -691,0 +691,1 @@\n+            return new NEWARRAY(t.getType());\n@@ -702,1 +703,3 @@\n-     * Create \"null\" value for reference types, 0 for basic types like int\n+     * Create a call to the most popular System.out.println() method.\n+     *\n+     * @param s the string to print\n@@ -704,22 +707,7 @@\n-    public static Instruction createNull( final Type type ) {\n-        switch (type.getType()) {\n-            case Const.T_ARRAY:\n-            case Const.T_OBJECT:\n-                return InstructionConst.ACONST_NULL;\n-            case Const.T_INT:\n-            case Const.T_SHORT:\n-            case Const.T_BOOLEAN:\n-            case Const.T_CHAR:\n-            case Const.T_BYTE:\n-                return InstructionConst.ICONST_0;\n-            case Const.T_FLOAT:\n-                return InstructionConst.FCONST_0;\n-            case Const.T_DOUBLE:\n-                return InstructionConst.DCONST_0;\n-            case Const.T_LONG:\n-                return InstructionConst.LCONST_0;\n-            case Const.T_VOID:\n-                return InstructionConst.NOP;\n-            default:\n-                throw new IllegalArgumentException(\"Invalid type: \" + type);\n-        }\n+    public InstructionList createPrintln(final String s) {\n+        final InstructionList il = new InstructionList();\n+        il.append(createGetStatic(\"java.lang.System\", \"out\", Type.getType(\"Ljava\/io\/PrintStream;\")));\n+        il.append(new PUSH(cp, s));\n+        final MethodObject methodObject = new MethodObject(\"java.io.PrintStream\", \"println\", Type.VOID, new Type[] { Type.getType(\"Ljava\/lang\/String;\") });\n+        il.append(createInvoke(methodObject, Const.INVOKEVIRTUAL));\n+        return il;\n@@ -728,50 +716,2 @@\n-    \/**\n-     * Create branch instruction by given opcode, except LOOKUPSWITCH and\n-     * TABLESWITCH. For those you should use the SWITCH compound instruction.\n-     *\/\n-    public static BranchInstruction createBranchInstruction( final short opcode,\n-            final InstructionHandle target ) {\n-        switch (opcode) {\n-            case Const.IFEQ:\n-                return new IFEQ(target);\n-            case Const.IFNE:\n-                return new IFNE(target);\n-            case Const.IFLT:\n-                return new IFLT(target);\n-            case Const.IFGE:\n-                return new IFGE(target);\n-            case Const.IFGT:\n-                return new IFGT(target);\n-            case Const.IFLE:\n-                return new IFLE(target);\n-            case Const.IF_ICMPEQ:\n-                return new IF_ICMPEQ(target);\n-            case Const.IF_ICMPNE:\n-                return new IF_ICMPNE(target);\n-            case Const.IF_ICMPLT:\n-                return new IF_ICMPLT(target);\n-            case Const.IF_ICMPGE:\n-                return new IF_ICMPGE(target);\n-            case Const.IF_ICMPGT:\n-                return new IF_ICMPGT(target);\n-            case Const.IF_ICMPLE:\n-                return new IF_ICMPLE(target);\n-            case Const.IF_ACMPEQ:\n-                return new IF_ACMPEQ(target);\n-            case Const.IF_ACMPNE:\n-                return new IF_ACMPNE(target);\n-            case Const.GOTO:\n-                return new GOTO(target);\n-            case Const.JSR:\n-                return new JSR(target);\n-            case Const.IFNULL:\n-                return new IFNULL(target);\n-            case Const.IFNONNULL:\n-                return new IFNONNULL(target);\n-            case Const.GOTO_W:\n-                return new GOTO_W(target);\n-            case Const.JSR_W:\n-                return new JSR_W(target);\n-            default:\n-                throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\n-        }\n+    public PUTFIELD createPutField(final String className, final String name, final Type t) {\n+        return new PUTFIELD(cp.addFieldref(className, name, t.getSignature()));\n@@ -780,3 +720,2 @@\n-\n-    public void setClassGen( final ClassGen c ) {\n-        cg = c;\n+    public PUTSTATIC createPutStatic(final String className, final String name, final Type t) {\n+        return new PUTSTATIC(cp.addFieldref(className, name, t.getSignature()));\n@@ -785,1 +724,0 @@\n-\n@@ -790,3 +728,2 @@\n-\n-    public void setConstantPool( final ConstantPoolGen c ) {\n-        cp = c;\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n@@ -795,0 +732,3 @@\n+    public void setClassGen(final ClassGen c) {\n+        cg = c;\n+    }\n@@ -796,2 +736,2 @@\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n+    public void setConstantPool(final ConstantPoolGen c) {\n+        cp = c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionFactory.java","additions":545,"deletions":605,"binary":false,"changes":1150,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * Instances of this class give users a handle to the instructions contained in\n- * an InstructionList. Instruction objects may be used more than once within a\n- * list, this is useful because it saves memory and may be much faster.\n+ * Instances of this class give users a handle to the instructions contained in an InstructionList. Instruction objects\n+ * may be used more than once within a list, this is useful because it saves memory and may be much faster.\n@@ -35,6 +34,3 @@\n- * Within an InstructionList an InstructionHandle object is wrapped\n- * around all instructions, i.e., it implements a cell in a\n- * doubly-linked list. From the outside only the next and the\n- * previous instruction (handle) are accessible. One\n- * can traverse the list via an Enumeration returned by\n- * InstructionList.elements().\n+ * Within an InstructionList an InstructionHandle object is wrapped around all instructions, i.e., it implements a cell\n+ * in a doubly-linked list. From the outside only the next and the previous instruction (handle) are accessible. One can\n+ * traverse the list via an Enumeration returned by InstructionList.elements().\n@@ -49,10 +45,0 @@\n-    private InstructionHandle next;\n-    private InstructionHandle prev;\n-    private Instruction instruction;\n-\n-    private int i_position = -1; \/\/ byte code offset of instruction\n-\n-    private Set<InstructionTargeter> targeters;\n-    private Map<Object, Object> attributes;\n-\n-\n@@ -60,1 +46,1 @@\n-     * Does nothing.\n+     * Empty array.\n@@ -62,1 +48,1 @@\n-     * @deprecated Does nothing as of 6.3.1.\n+     * @since 6.6.0\n@@ -64,18 +50,1 @@\n-    @Deprecated\n-    protected void addHandle() {\n-        \/\/ noop\n-    }\n-\n-    public final InstructionHandle getNext() {\n-        return next;\n-    }\n-\n-\n-    public final InstructionHandle getPrev() {\n-        return prev;\n-    }\n-\n-\n-    public final Instruction getInstruction() {\n-        return instruction;\n-    }\n+    public static final InstructionHandle[] EMPTY_ARRAY = {};\n@@ -83,0 +52,4 @@\n+    \/**\n+     * Empty array.\n+     *\/\n+    static final InstructionTargeter[] EMPTY_INSTRUCTION_TARGETER_ARRAY = {};\n@@ -85,2 +58,1 @@\n-     * Replace current instruction contained in this handle.\n-     * Old instruction is disposed using Instruction.dispose().\n+     * Factory method.\n@@ -88,11 +60,2 @@\n-    public void setInstruction( final Instruction i ) { \/\/ Overridden in BranchHandle TODO could be package-protected?\n-        if (i == null) {\n-            throw new ClassGenException(\"Assigning null to handle\");\n-        }\n-        if ((this.getClass() != BranchHandle.class) && (i instanceof BranchInstruction)) {\n-            throw new ClassGenException(\"Assigning branch instruction \" + i + \" to plain handle\");\n-        }\n-        if (instruction != null) {\n-            instruction.dispose();\n-        }\n-        instruction = i;\n+    static InstructionHandle getInstructionHandle(final Instruction i) {\n+        return new InstructionHandle(i);\n@@ -101,0 +64,4 @@\n+    private InstructionHandle next;\n+    private InstructionHandle prev;\n+\n+    private Instruction instruction;\n@@ -103,7 +70,1 @@\n-     * Temporarily swap the current instruction, without disturbing\n-     * anything. Meant to be used by a debugger, implementing\n-     * breakpoints. Current instruction is returned.\n-     * <p>\n-     * Warning: if this is used on a BranchHandle then some methods such as\n-     * getPosition() will still refer to the original cached instruction, whereas\n-     * other BH methods may affect the cache and the replacement instruction.\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n@@ -111,7 +72,3 @@\n-    \/\/ See BCEL-273\n-    \/\/ TODO remove this method in any redesign of BCEL\n-    public Instruction swapInstruction( final Instruction i ) {\n-        final Instruction oldInstruction = instruction;\n-        instruction = i;\n-        return oldInstruction;\n-    }\n+    @Deprecated\n+    protected int i_position = -1; \/\/ byte code offset of instruction\n+    private Set<InstructionTargeter> targeters;\n@@ -119,0 +76,1 @@\n+    private Map<Object, Object> attributes;\n@@ -120,1 +78,1 @@\n-    \/*private*\/protected InstructionHandle(final Instruction i) {\n+    protected InstructionHandle(final Instruction i) {\n@@ -124,1 +82,4 @@\n-    \/** Factory method.\n+    \/**\n+     * Convenience method, simply calls accept() on the contained instruction.\n+     *\n+     * @param v Visitor object\n@@ -126,2 +87,2 @@\n-    static InstructionHandle getInstructionHandle( final Instruction i ) {\n-        return new InstructionHandle(i);\n+    public void accept(final Visitor v) {\n+        instruction.accept(v);\n@@ -130,1 +91,0 @@\n-\n@@ -132,4 +92,1 @@\n-     * Called by InstructionList.setPositions when setting the position for every\n-     * instruction. In the presence of variable length instructions `setPositions()'\n-     * performs multiple passes over the instruction list to calculate the\n-     * correct (byte) positions and offsets by calling this function.\n+     * Add an attribute to an instruction handle.\n@@ -137,3 +94,2 @@\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param max_offset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n+     * @param key the key object to store\/retrieve the attribute\n+     * @param attr the attribute to associate with this handle\n@@ -141,3 +97,5 @@\n-    protected int updatePosition( final int offset, final int max_offset ) {\n-        i_position += offset;\n-        return 0;\n+    public void addAttribute(final Object key, final Object attr) {\n+        if (attributes == null) {\n+            attributes = new HashMap<>(3);\n+        }\n+        attributes.put(key, attr);\n@@ -146,4 +104,4 @@\n-\n-    \/** @return the position, i.e., the byte code offset of the contained\n-     * instruction. This is accurate only after\n-     * InstructionList.setPositions() has been called.\n+    \/**\n+     * Does nothing.\n+     *\n+     * @deprecated Does nothing as of 6.3.1.\n@@ -151,2 +109,3 @@\n-    public int getPosition() {\n-        return i_position;\n+    @Deprecated\n+    protected void addHandle() {\n+        \/\/ noop\n@@ -155,3 +114,2 @@\n-\n-    \/** Set the position, i.e., the byte code offset of the contained\n-     * instruction.\n+    \/**\n+     * Denote this handle is being referenced by t.\n@@ -159,2 +117,6 @@\n-    void setPosition( final int pos ) {\n-        i_position = pos;\n+    public void addTargeter(final InstructionTargeter t) {\n+        if (targeters == null) {\n+            targeters = new HashSet<>();\n+        }\n+        \/\/ if(!targeters.contains(t))\n+        targeters.add(t);\n@@ -163,1 +125,0 @@\n-\n@@ -176,2 +137,4 @@\n-\n-    \/** Remove all targeters, if any.\n+    \/**\n+     * Get attribute of an instruction handle.\n+     *\n+     * @param key the key object to store\/retrieve the attribute\n@@ -179,3 +142,3 @@\n-    public void removeAllTargeters() {\n-        if (targeters != null) {\n-            targeters.clear();\n+    public Object getAttribute(final Object key) {\n+        if (attributes != null) {\n+            return attributes.get(key);\n@@ -183,0 +146,1 @@\n+        return null;\n@@ -185,1 +149,0 @@\n-\n@@ -187,1 +150,1 @@\n-     * Denote this handle isn't referenced anymore by t.\n+     * @return all attributes associated with this handle\n@@ -189,3 +152,3 @@\n-    public void removeTargeter( final InstructionTargeter t ) {\n-        if (targeters != null) {\n-            targeters.remove(t);\n+    public Collection<Object> getAttributes() {\n+        if (attributes == null) {\n+            attributes = new HashMap<>(3);\n@@ -193,0 +156,5 @@\n+        return attributes.values();\n+    }\n+\n+    public final Instruction getInstruction() {\n+        return instruction;\n@@ -195,0 +163,3 @@\n+    public final InstructionHandle getNext() {\n+        return next;\n+    }\n@@ -197,1 +168,2 @@\n-     * Denote this handle is being referenced by t.\n+     * @return the position, i.e., the byte code offset of the contained instruction. This is accurate only after\n+     *         InstructionList.setPositions() has been called.\n@@ -199,6 +171,2 @@\n-    public void addTargeter( final InstructionTargeter t ) {\n-        if (targeters == null) {\n-            targeters = new HashSet<>();\n-        }\n-        \/\/if(!targeters.contains(t))\n-        targeters.add(t);\n+    public int getPosition() {\n+        return i_position;\n@@ -207,3 +175,2 @@\n-\n-    public boolean hasTargeters() {\n-        return (targeters != null) && (targeters.size() > 0);\n+    public final InstructionHandle getPrev() {\n+        return prev;\n@@ -212,1 +179,0 @@\n-\n@@ -218,1 +184,1 @@\n-            return new InstructionTargeter[0];\n+            return EMPTY_INSTRUCTION_TARGETER_ARRAY;\n@@ -225,13 +191,2 @@\n-\n-    \/** @return a (verbose) string representation of the contained instruction.\n-     *\/\n-    public String toString( final boolean verbose ) {\n-        return Utility.format(i_position, 4, false, ' ') + \": \" + instruction.toString(verbose);\n-    }\n-\n-\n-    \/** @return a string representation of the contained instruction.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return toString(true);\n+    public boolean hasTargeters() {\n+        return targeters != null && !targeters.isEmpty();\n@@ -240,5 +195,2 @@\n-\n-    \/** Add an attribute to an instruction handle.\n-     *\n-     * @param key the key object to store\/retrieve the attribute\n-     * @param attr the attribute to associate with this handle\n+    \/**\n+     * Remove all targeters, if any.\n@@ -246,3 +198,3 @@\n-    public void addAttribute( final Object key, final Object attr ) {\n-        if (attributes == null) {\n-            attributes = new HashMap<>(3);\n+    public void removeAllTargeters() {\n+        if (targeters != null) {\n+            targeters.clear();\n@@ -250,1 +202,0 @@\n-        attributes.put(key, attr);\n@@ -253,2 +204,2 @@\n-\n-    \/** Delete an attribute of an instruction handle.\n+    \/**\n+     * Delete an attribute of an instruction handle.\n@@ -258,1 +209,1 @@\n-    public void removeAttribute( final Object key ) {\n+    public void removeAttribute(final Object key) {\n@@ -264,4 +215,2 @@\n-\n-    \/** Get attribute of an instruction handle.\n-     *\n-     * @param key the key object to store\/retrieve the attribute\n+    \/**\n+     * Denote this handle isn't referenced anymore by t.\n@@ -269,3 +218,3 @@\n-    public Object getAttribute( final Object key ) {\n-        if (attributes != null) {\n-            return attributes.get(key);\n+    public void removeTargeter(final InstructionTargeter t) {\n+        if (targeters != null) {\n+            targeters.remove(t);\n@@ -273,1 +222,0 @@\n-        return null;\n@@ -276,2 +224,2 @@\n-\n-    \/** @return all attributes associated with this handle\n+    \/**\n+     * Replace current instruction contained in this handle. Old instruction is disposed using Instruction.dispose().\n@@ -279,3 +227,3 @@\n-    public Collection<Object> getAttributes() {\n-        if (attributes == null) {\n-            attributes = new HashMap<>(3);\n+    public void setInstruction(final Instruction i) { \/\/ Overridden in BranchHandle TODO could be package-protected?\n+        if (i == null) {\n+            throw new ClassGenException(\"Assigning null to handle\");\n@@ -283,10 +231,7 @@\n-        return attributes.values();\n-    }\n-\n-\n-    \/** Convenience method, simply calls accept() on the contained instruction.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    public void accept( final Visitor v ) {\n-        instruction.accept(v);\n+        if (this.getClass() != BranchHandle.class && i instanceof BranchInstruction) {\n+            throw new ClassGenException(\"Assigning branch instruction \" + i + \" to plain handle\");\n+        }\n+        if (instruction != null) {\n+            instruction.dispose();\n+        }\n+        instruction = i;\n@@ -295,1 +240,0 @@\n-\n@@ -305,0 +249,6 @@\n+    \/**\n+     * Set the position, i.e., the byte code offset of the contained instruction.\n+     *\/\n+    void setPosition(final int pos) {\n+        i_position = pos;\n+    }\n@@ -314,0 +264,44 @@\n+\n+    \/**\n+     * Temporarily swap the current instruction, without disturbing anything. Meant to be used by a debugger, implementing\n+     * breakpoints. Current instruction is returned.\n+     * <p>\n+     * Warning: if this is used on a BranchHandle then some methods such as getPosition() will still refer to the original\n+     * cached instruction, whereas other BH methods may affect the cache and the replacement instruction.\n+     *\/\n+    \/\/ See BCEL-273\n+    \/\/ TODO remove this method in any redesign of BCEL\n+    public Instruction swapInstruction(final Instruction i) {\n+        final Instruction oldInstruction = instruction;\n+        instruction = i;\n+        return oldInstruction;\n+    }\n+\n+    \/**\n+     * @return a string representation of the contained instruction.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return toString(true);\n+    }\n+\n+    \/**\n+     * @return a (verbose) string representation of the contained instruction.\n+     *\/\n+    public String toString(final boolean verbose) {\n+        return Utility.format(i_position, 4, false, ' ') + \": \" + instruction.toString(verbose);\n+    }\n+\n+    \/**\n+     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n+     * length instructions 'setPositions()' performs multiple passes over the instruction list to calculate the correct\n+     * (byte) positions and offsets by calling this function.\n+     *\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param maxOffset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n+     *\/\n+    protected int updatePosition(final int offset, final int maxOffset) {\n+        i_position += offset;\n+        return 0;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionHandle.java","additions":158,"deletions":164,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,3 +22,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.classfile.Constant;\n-import com.sun.org.apache.bcel.internal.util.ByteSequence;\n@@ -29,0 +26,1 @@\n+import java.util.Arrays;\n@@ -35,0 +33,4 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.classfile.Constant;\n+import com.sun.org.apache.bcel.internal.util.ByteSequence;\n+\n@@ -36,2 +38,1 @@\n- * This class is a container for a list of <a\n- * href=\"Instruction.html\">Instruction<\/a> objects. Instructions can be\n+ * This class is a container for a list of <a href=\"Instruction.html\">Instruction<\/a> objects. Instructions can be\n@@ -39,4 +40,3 @@\n- * <a href=\"InstructionHandle.html\">InstructionHandles<\/a> objects that are\n- * returned upon append\/insert operations. They give the user (read only) access\n- * to the list structure, such that it can be traversed and manipulated in a\n- * controlled way.\n+ * <a href=\"InstructionHandle.html\">InstructionHandles<\/a> objects that are returned upon append\/insert operations. They\n+ * give the user (read only) access to the list structure, such that it can be traversed and manipulated in a controlled\n+ * way.\n@@ -44,2 +44,1 @@\n- * A list is finally dumped to a byte code array with <a\n- * href=\"#getByteCode()\">getByteCode<\/a>.\n+ * A list is finally dumped to a byte code array with <a href=\"#getByteCode()\">getByteCode<\/a>.\n@@ -50,1 +49,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -54,49 +53,0 @@\n-    private InstructionHandle start = null;\n-    private InstructionHandle end = null;\n-    private int length = 0; \/\/ number of elements in list\n-    private int[] bytePositions; \/\/ byte code offsets corresponding to instructions\n-\n-    \/**\n-     * Create (empty) instruction list.\n-     *\/\n-    public InstructionList() {\n-    }\n-\n-    \/**\n-     * Create instruction list containing one instruction.\n-     *\n-     * @param i\n-     *            initial instruction\n-     *\/\n-    public InstructionList(final Instruction i) {\n-        append(i);\n-    }\n-\n-    \/**\n-     * Create instruction list containing one instruction.\n-     *\n-     * @param i\n-     *            initial instruction\n-     *\/\n-    public InstructionList(final BranchInstruction i) {\n-        append(i);\n-    }\n-\n-    \/**\n-     * Initialize list with (nonnull) compound instruction. Consumes argument\n-     * list, i.e., it becomes empty.\n-     *\n-     * @param c\n-     *            compound instruction (list)\n-     *\/\n-    public InstructionList(final CompoundInstruction c) {\n-        append(c.getInstructionList());\n-    }\n-\n-    \/**\n-     * Test for empty list.\n-     *\/\n-    public boolean isEmpty() {\n-        return start == null;\n-    } \/\/ && end == null\n-\n@@ -104,2 +54,1 @@\n-     * Find the target instruction (handle) that corresponds to the given target\n-     * position (byte code offset).\n+     * Find the target instruction (handle) that corresponds to the given target position (byte code offset).\n@@ -107,8 +56,4 @@\n-     * @param ihs\n-     *            array of instruction handles, i.e. il.getInstructionHandles()\n-     * @param pos\n-     *            array of positions corresponding to ihs, i.e. il.getInstructionPositions()\n-     * @param count\n-     *            length of arrays\n-     * @param target\n-     *            target position to search for\n+     * @param ihs array of instruction handles, i.e. il.getInstructionHandles()\n+     * @param pos array of positions corresponding to ihs, i.e. il.getInstructionPositions()\n+     * @param count length of arrays\n+     * @param target target position to search for\n@@ -117,2 +62,1 @@\n-    public static InstructionHandle findHandle(final InstructionHandle[] ihs,\n-            final int[] pos, final int count, final int target) {\n+    public static InstructionHandle findHandle(final InstructionHandle[] ihs, final int[] pos, final int count, final int target) {\n@@ -125,1 +69,1 @@\n-            final int i = (l + r) >>> 1;\n+            final int i = l + r >>> 1;\n@@ -129,1 +73,2 @@\n-            } else if (target < j) {\n+            }\n+            if (target < j) {\n@@ -138,0 +83,14 @@\n+    private InstructionHandle start;\n+    private InstructionHandle end;\n+    private int length; \/\/ number of elements in list\n+\n+    private int[] bytePositions; \/\/ byte code offsets corresponding to instructions\n+\n+    private List<InstructionListObserver> observers;\n+\n+    \/**\n+     * Create (empty) instruction list.\n+     *\/\n+    public InstructionList() {\n+    }\n+\n@@ -139,3 +98,1 @@\n-     * Get instruction handle for instruction at byte code position pos. This\n-     * only works properly, if the list is freshly initialized from a byte array\n-     * or setPositions() has been called before this method.\n+     * Create instruction list containing one instruction.\n@@ -143,3 +100,1 @@\n-     * @param pos\n-     *            byte code position to search for\n-     * @return target position's instruction handle if available\n+     * @param i initial instruction\n@@ -147,10 +102,2 @@\n-    public InstructionHandle findHandle(final int pos) {\n-        final int[] positions = bytePositions;\n-        InstructionHandle ih = start;\n-        for (int i = 0; i < length; i++) {\n-            if (positions[i] == pos) {\n-                return ih;\n-            }\n-            ih = ih.getNext();\n-        }\n-        return null;\n+    public InstructionList(final BranchInstruction i) {\n+        append(i);\n@@ -162,2 +109,1 @@\n-     * @param code\n-     *            byte array containing the instructions\n+     * @param code byte array containing the instructions\n@@ -196,2 +142,1 @@\n-        bytePositions = new int[count]; \/\/ Trim to proper size\n-        System.arraycopy(pos, 0, bytePositions, 0, count);\n+        bytePositions = Arrays.copyOf(pos, count); \/\/ Trim to proper size\n@@ -204,4 +149,3 @@\n-                int target = bi.getPosition() + bi.getIndex();\n-                \/*\n-                 * Byte code position: relative -> absolute.\n-                 *\/\n+                int target = bi.getPosition() + bi.getIndex(); \/*\n+                                                                * Byte code position: relative -> absolute.\n+                                                                *\/\n@@ -232,2 +176,1 @@\n-     * Append another list after instruction (handle) ih contained in this list.\n-     * Consumes argument list, i.e., it becomes empty.\n+     * Initialize list with (nonnull) compound instruction. Consumes argument list, i.e., it becomes empty.\n@@ -235,5 +178,1 @@\n-     * @param ih\n-     *            where to append the instruction list\n-     * @param il\n-     *            Instruction list to append to this one\n-     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n+     * @param c compound instruction (list)\n@@ -241,20 +180,2 @@\n-    public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {\n-        if (il == null) {\n-            throw new ClassGenException(\"Appending null InstructionList\");\n-        }\n-        if (il.isEmpty()) {\n-            return ih;\n-        }\n-        final InstructionHandle next = ih.getNext();\n-        final InstructionHandle ret = il.start;\n-        ih.setNext(il.start);\n-        il.start.setPrev(ih);\n-        il.end.setNext(next);\n-        if (next != null) {\n-            next.setPrev(il.end);\n-        } else {\n-            end = il.end; \/\/ Update end ...\n-        }\n-        length += il.length; \/\/ Update length\n-        il.clear();\n-        return ret;\n+    public InstructionList(final CompoundInstruction c) {\n+        append(c.getInstructionList());\n@@ -264,2 +185,1 @@\n-     * Append another list after instruction i contained in this list. Consumes\n-     * argument list, i.e., it becomes empty.\n+     * Create instruction list containing one instruction.\n@@ -267,5 +187,1 @@\n-     * @param i\n-     *            where to append the instruction list\n-     * @param il\n-     *            Instruction list to append to this one\n-     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n+     * @param i initial instruction\n@@ -273,4 +189,10 @@\n-    public InstructionHandle append(final Instruction i, final InstructionList il) {\n-        InstructionHandle ih;\n-        if ((ih = findInstruction2(i)) == null) {\n-            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n+    public InstructionList(final Instruction i) {\n+        append(i);\n+    }\n+\n+    \/**\n+     * Add observer for this object.\n+     *\/\n+    public void addObserver(final InstructionListObserver o) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n@@ -278,1 +200,1 @@\n-        return append(ih, il);\n+        observers.add(o);\n@@ -282,2 +204,1 @@\n-     * Append another list to this one. Consumes argument list, i.e., it becomes\n-     * empty.\n+     * Append a branch instruction to the end of this list.\n@@ -285,3 +206,2 @@\n-     * @param il\n-     *            list to append to end of this list\n-     * @return instruction handle of the <B>first<\/B> appended instruction\n+     * @param i branch instruction to append\n+     * @return branch instruction handle of the appended instruction\n@@ -289,15 +209,4 @@\n-    public InstructionHandle append(final InstructionList il) {\n-        if (il == null) {\n-            throw new ClassGenException(\"Appending null InstructionList\");\n-        }\n-        if (il.isEmpty()) {\n-            return null;\n-        }\n-        if (isEmpty()) {\n-            start = il.start;\n-            end = il.end;\n-            length = il.length;\n-            il.clear();\n-            return start;\n-        }\n-        return append(end, il); \/\/ was end.instruction\n+    public BranchHandle append(final BranchInstruction i) {\n+        final BranchHandle ih = BranchHandle.getBranchHandle(i);\n+        append(ih);\n+        return ih;\n@@ -307,1 +216,1 @@\n-     * Append an instruction to the end of this list.\n+     * Append a compound instruction.\n@@ -309,2 +218,2 @@\n-     * @param ih\n-     *            instruction to append\n+     * @param c The composite instruction (containing an InstructionList)\n+     * @return instruction handle of the first appended instruction\n@@ -312,11 +221,2 @@\n-    private void append(final InstructionHandle ih) {\n-        if (isEmpty()) {\n-            start = end = ih;\n-            ih.setNext(ih.setPrev(null));\n-        } else {\n-            end.setNext(ih);\n-            ih.setPrev(end);\n-            ih.setNext(null);\n-            end = ih;\n-        }\n-        length++; \/\/ Update length\n+    public InstructionHandle append(final CompoundInstruction c) {\n+        return append(c.getInstructionList());\n@@ -328,2 +228,1 @@\n-     * @param i\n-     *            instruction to append\n+     * @param i instruction to append\n@@ -339,1 +238,1 @@\n-     * Append a branch instruction to the end of this list.\n+     * Append a compound instruction, after instruction i.\n@@ -341,3 +240,3 @@\n-     * @param i\n-     *            branch instruction to append\n-     * @return branch instruction handle of the appended instruction\n+     * @param i Instruction in list\n+     * @param c The composite instruction (containing an InstructionList)\n+     * @return instruction handle of the first appended instruction\n@@ -345,4 +244,2 @@\n-    public BranchHandle append(final BranchInstruction i) {\n-        final BranchHandle ih = BranchHandle.getBranchHandle(i);\n-        append(ih);\n-        return ih;\n+    public InstructionHandle append(final Instruction i, final CompoundInstruction c) {\n+        return append(i, c.getInstructionList());\n@@ -352,2 +249,1 @@\n-     * Append a single instruction j after another instruction i, which must be\n-     * in this list of course!\n+     * Append a single instruction j after another instruction i, which must be in this list of course!\n@@ -355,4 +251,2 @@\n-     * @param i\n-     *            Instruction in list\n-     * @param j\n-     *            Instruction to append after i in list\n+     * @param i Instruction in list\n+     * @param j Instruction to append after i in list\n@@ -366,1 +260,1 @@\n-     * Append a compound instruction, after instruction i.\n+     * Append another list after instruction i contained in this list. Consumes argument list, i.e., it becomes empty.\n@@ -368,5 +262,3 @@\n-     * @param i\n-     *            Instruction in list\n-     * @param c\n-     *            The composite instruction (containing an InstructionList)\n-     * @return instruction handle of the first appended instruction\n+     * @param i where to append the instruction list\n+     * @param il Instruction list to append to this one\n+     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n@@ -374,2 +266,6 @@\n-    public InstructionHandle append(final Instruction i, final CompoundInstruction c) {\n-        return append(i, c.getInstructionList());\n+    public InstructionHandle append(final Instruction i, final InstructionList il) {\n+        InstructionHandle ih;\n+        if ((ih = findInstruction2(i)) == null) {\n+            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n+        }\n+        return append(ih, il);\n@@ -379,1 +275,1 @@\n-     * Append a compound instruction.\n+     * Append an instruction to the end of this list.\n@@ -381,3 +277,1 @@\n-     * @param c\n-     *            The composite instruction (containing an InstructionList)\n-     * @return instruction handle of the first appended instruction\n+     * @param ih instruction to append\n@@ -385,2 +279,26 @@\n-    public InstructionHandle append(final CompoundInstruction c) {\n-        return append(c.getInstructionList());\n+    private void append(final InstructionHandle ih) {\n+        if (isEmpty()) {\n+            start = end = ih;\n+            ih.setNext(ih.setPrev(null));\n+        } else {\n+            end.setNext(ih);\n+            ih.setPrev(end);\n+            ih.setNext(null);\n+            end = ih;\n+        }\n+        length++; \/\/ Update length\n+    }\n+\n+    \/**\n+     * Append an instruction after instruction (handle) ih contained in this list.\n+     *\n+     * @param ih where to append the instruction list\n+     * @param i Instruction to append\n+     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n+     *\/\n+    public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {\n+        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n+        final InstructionList il = new InstructionList();\n+        il.append(bh);\n+        append(ih, il);\n+        return bh;\n@@ -392,4 +310,2 @@\n-     * @param ih\n-     *            where to append the instruction list\n-     * @param c\n-     *            The composite instruction (containing an InstructionList)\n+     * @param ih where to append the instruction list\n+     * @param c The composite instruction (containing an InstructionList)\n@@ -405,4 +321,2 @@\n-     * @param ih\n-     *            where to append the instruction list\n-     * @param i\n-     *            Instruction to append\n+     * @param ih where to append the instruction list\n+     * @param i Instruction to append\n@@ -416,1 +330,2 @@\n-     * Append an instruction after instruction (handle) ih contained in this list.\n+     * Append another list after instruction (handle) ih contained in this list. Consumes argument list, i.e., it becomes\n+     * empty.\n@@ -418,4 +333,2 @@\n-     * @param ih\n-     *            where to append the instruction list\n-     * @param i\n-     *            Instruction to append\n+     * @param ih where to append the instruction list\n+     * @param il Instruction list to append to this one\n@@ -424,19 +337,1 @@\n-    public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {\n-        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n-        final InstructionList il = new InstructionList();\n-        il.append(bh);\n-        append(ih, il);\n-        return bh;\n-    }\n-\n-    \/**\n-     * Insert another list before Instruction handle ih contained in this list.\n-     * Consumes argument list, i.e., it becomes empty.\n-     *\n-     * @param ih\n-     *            where to append the instruction list\n-     * @param il\n-     *            Instruction list to insert\n-     * @return instruction handle of the first inserted instruction\n-     *\/\n-    public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {\n+    public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {\n@@ -444,1 +339,1 @@\n-            throw new ClassGenException(\"Inserting null InstructionList\");\n+            throw new ClassGenException(\"Appending null InstructionList\");\n@@ -449,1 +344,1 @@\n-        final InstructionHandle prev = ih.getPrev();\n+        final InstructionHandle next = ih.getNext();\n@@ -451,5 +346,5 @@\n-        ih.setPrev(il.end);\n-        il.end.setNext(ih);\n-        il.start.setPrev(prev);\n-        if (prev != null) {\n-            prev.setNext(il.start);\n+        ih.setNext(il.start);\n+        il.start.setPrev(ih);\n+        il.end.setNext(next);\n+        if (next != null) {\n+            next.setPrev(il.end);\n@@ -457,1 +352,1 @@\n-            start = il.start; \/\/ Update start ...\n+            end = il.end; \/\/ Update end ...\n@@ -465,1 +360,1 @@\n-     * Insert another list.\n+     * Append another list to this one. Consumes argument list, i.e., it becomes empty.\n@@ -467,3 +362,2 @@\n-     * @param il\n-     *            list to insert before start of this list\n-     * @return instruction handle of the first inserted instruction\n+     * @param il list to append to end of this list\n+     * @return instruction handle of the <B>first<\/B> appended instruction\n@@ -471,1 +365,7 @@\n-    public InstructionHandle insert(final InstructionList il) {\n+    public InstructionHandle append(final InstructionList il) {\n+        if (il == null) {\n+            throw new ClassGenException(\"Appending null InstructionList\");\n+        }\n+        if (il.isEmpty()) {\n+            return null;\n+        }\n@@ -473,1 +373,4 @@\n-            append(il); \/\/ Code is identical for this case\n+            start = il.start;\n+            end = il.end;\n+            length = il.length;\n+            il.clear();\n@@ -476,1 +379,1 @@\n-        return insert(start, il);\n+        return append(end, il); \/\/ was end.instruction\n@@ -479,5 +382,23 @@\n-    \/**\n-     * Insert an instruction at start of this list.\n-     *\n-     * @param ih\n-     *            instruction to insert\n+    private void clear() {\n+        start = end = null;\n+        length = 0;\n+    }\n+\n+    public boolean contains(final Instruction i) {\n+        return findInstruction1(i) != null;\n+    }\n+\n+    public boolean contains(final InstructionHandle i) {\n+        if (i == null) {\n+            return false;\n+        }\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            if (ih == i) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * @return complete, i.e., deep copy of this list\n@@ -485,9 +406,15 @@\n-    private void insert(final InstructionHandle ih) {\n-        if (isEmpty()) {\n-            start = end = ih;\n-            ih.setNext(ih.setPrev(null));\n-        } else {\n-            start.setPrev(ih);\n-            ih.setNext(start);\n-            ih.setPrev(null);\n-            start = ih;\n+    public InstructionList copy() {\n+        final Map<InstructionHandle, InstructionHandle> map = new HashMap<>();\n+        final InstructionList il = new InstructionList();\n+        \/*\n+         * Pass 1: Make copies of all instructions, append them to the new list and associate old instruction references with\n+         * the new ones, i.e., a 1:1 mapping.\n+         *\/\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            final Instruction c = i.copy(); \/\/ Use clone for shallow copy\n+            if (c instanceof BranchInstruction) {\n+                map.put(ih, il.append((BranchInstruction) c));\n+            } else {\n+                map.put(ih, il.append(c));\n+            }\n@@ -495,1 +422,26 @@\n-        length++;\n+        \/*\n+         * Pass 2: Update branch targets.\n+         *\/\n+        InstructionHandle ih = start;\n+        InstructionHandle ch = il.start;\n+        while (ih != null) {\n+            final Instruction i = ih.getInstruction();\n+            final Instruction c = ch.getInstruction();\n+            if (i instanceof BranchInstruction) {\n+                final BranchInstruction bi = (BranchInstruction) i;\n+                final BranchInstruction bc = (BranchInstruction) c;\n+                final InstructionHandle itarget = bi.getTarget(); \/\/ old target\n+                \/\/ New target is in hash map\n+                bc.setTarget(map.get(itarget));\n+                if (bi instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n+                    final InstructionHandle[] itargets = ((Select) bi).getTargets();\n+                    final InstructionHandle[] ctargets = ((Select) bc).getTargets();\n+                    for (int j = 0; j < itargets.length; j++) { \/\/ Update all targets\n+                        ctargets[j] = map.get(itargets[j]);\n+                    }\n+                }\n+            }\n+            ih = ih.getNext();\n+            ch = ch.getNext();\n+        }\n+        return il;\n@@ -499,2 +451,1 @@\n-     * Insert another list before Instruction i contained in this list. Consumes\n-     * argument list, i.e., it becomes empty.\n+     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n@@ -502,5 +453,1 @@\n-     * @param i\n-     *            where to append the instruction list\n-     * @param il\n-     *            Instruction list to insert\n-     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()\n+     * @param i instruction to remove\n@@ -508,1 +455,1 @@\n-    public InstructionHandle insert(final Instruction i, final InstructionList il) {\n+    public void delete(final Instruction i) throws TargetLostException {\n@@ -513,1 +460,1 @@\n-        return insert(ih, il);\n+        delete(ih);\n@@ -517,1 +464,2 @@\n-     * Insert an instruction at start of this list.\n+     * Remove instructions from instruction 'from' to instruction 'to' contained in this list. The user must ensure that\n+     * 'from' is an instruction before 'to', or risk havoc. The corresponding Instruction handles must not be reused!\n@@ -519,3 +467,2 @@\n-     * @param i\n-     *            instruction to insert\n-     * @return instruction handle of the inserted instruction\n+     * @param from where to start deleting (inclusive)\n+     * @param to where to end deleting (inclusive)\n@@ -523,4 +470,174 @@\n-    public InstructionHandle insert(final Instruction i) {\n-        final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n-        insert(ih);\n-        return ih;\n+    public void delete(final Instruction from, final Instruction to) throws TargetLostException {\n+        InstructionHandle fromIh;\n+        InstructionHandle toIh;\n+        if ((fromIh = findInstruction1(from)) == null) {\n+            throw new ClassGenException(\"Instruction \" + from + \" is not contained in this list.\");\n+        }\n+        if ((toIh = findInstruction2(to)) == null) {\n+            throw new ClassGenException(\"Instruction \" + to + \" is not contained in this list.\");\n+        }\n+        delete(fromIh, toIh);\n+    }\n+\n+    \/**\n+     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n+     *\n+     * @param ih instruction (handle) to remove\n+     *\/\n+    public void delete(final InstructionHandle ih) throws TargetLostException {\n+        remove(ih.getPrev(), ih.getNext());\n+    }\n+\n+    \/**\n+     * Remove instructions from instruction 'from' to instruction 'to' contained in this list. The user must ensure that\n+     * 'from' is an instruction before 'to', or risk havoc. The corresponding Instruction handles must not be reused!\n+     *\n+     * @param from where to start deleting (inclusive)\n+     * @param to where to end deleting (inclusive)\n+     *\/\n+    public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {\n+        remove(from.getPrev(), to.getNext());\n+    }\n+\n+    \/**\n+     * Delete contents of list. Provides better memory utilization, because the system then may reuse the instruction\n+     * handles. This method is typically called right after {@link MethodGen#getMethod()}.\n+     *\/\n+    public void dispose() {\n+        \/\/ Traverse in reverse order, because ih.next is overwritten\n+        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n+            \/\/ Causes BranchInstructions to release target and targeters, because it calls dispose() on the contained instruction.\n+            ih.dispose();\n+        }\n+        clear();\n+    }\n+\n+    \/**\n+     * Get instruction handle for instruction at byte code position pos. This only works properly, if the list is freshly\n+     * initialized from a byte array or setPositions() has been called before this method.\n+     *\n+     * @param pos byte code position to search for\n+     * @return target position's instruction handle if available\n+     *\/\n+    public InstructionHandle findHandle(final int pos) {\n+        final int[] positions = bytePositions;\n+        InstructionHandle ih = start;\n+        for (int i = 0; i < length; i++) {\n+            if (positions[i] == pos) {\n+                return ih;\n+            }\n+            ih = ih.getNext();\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Search for given Instruction reference, start at beginning of list.\n+     *\n+     * @param i instruction to search for\n+     * @return instruction found on success, null otherwise\n+     *\/\n+    private InstructionHandle findInstruction1(final Instruction i) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            if (ih.getInstruction() == i) {\n+                return ih;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * Search for given Instruction reference, start at end of list\n+     *\n+     * @param i instruction to search for\n+     * @return instruction found on success, null otherwise\n+     *\/\n+    private InstructionHandle findInstruction2(final Instruction i) {\n+        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n+            if (ih.getInstruction() == i) {\n+                return ih;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    \/**\n+     * When everything is finished, use this method to convert the instruction list into an array of bytes.\n+     *\n+     * @return the byte code ready to be dumped\n+     *\/\n+    public byte[] getByteCode() {\n+        \/\/ Update position indices of instructions\n+        setPositions();\n+        final ByteArrayOutputStream b = new ByteArrayOutputStream();\n+        final DataOutputStream out = new DataOutputStream(b);\n+        try {\n+            for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+                final Instruction i = ih.getInstruction();\n+                i.dump(out); \/\/ Traverse list\n+            }\n+            out.flush();\n+        } catch (final IOException e) {\n+            System.err.println(e);\n+            return Const.EMPTY_BYTE_ARRAY;\n+        }\n+        return b.toByteArray();\n+    }\n+\n+    \/**\n+     * @return end of list\n+     *\/\n+    public InstructionHandle getEnd() {\n+        return end;\n+    }\n+\n+    \/**\n+     * @return array containing all instructions (handles)\n+     *\/\n+    public InstructionHandle[] getInstructionHandles() {\n+        final InstructionHandle[] ihs = new InstructionHandle[length];\n+        InstructionHandle ih = start;\n+        for (int i = 0; i < length; i++) {\n+            ihs[i] = ih;\n+            ih = ih.getNext();\n+        }\n+        return ihs;\n+    }\n+\n+    \/**\n+     * Get positions (offsets) of all instructions in the list. This relies on that the list has been freshly created from\n+     * an byte code array, or that setPositions() has been called. Otherwise this may be inaccurate.\n+     *\n+     * @return array containing all instruction's offset in byte code\n+     *\/\n+    public int[] getInstructionPositions() {\n+        return bytePositions;\n+    }\n+\n+    \/**\n+     * @return an array of instructions without target information for branch instructions.\n+     *\/\n+    public Instruction[] getInstructions() {\n+        final List<Instruction> instructions = new ArrayList<>();\n+        try (ByteSequence bytes = new ByteSequence(getByteCode())) {\n+            while (bytes.available() > 0) {\n+                instructions.add(Instruction.readInstruction(bytes));\n+            }\n+        } catch (final IOException e) {\n+            throw new ClassGenException(e.toString(), e);\n+        }\n+        return instructions.toArray(Instruction.EMPTY_ARRAY);\n+    }\n+\n+    \/**\n+     * @return length of list (Number of instructions, not bytes)\n+     *\/\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    \/**\n+     * @return start of list\n+     *\/\n+    public InstructionHandle getStart() {\n+        return start;\n@@ -532,2 +649,1 @@\n-     * @param i\n-     *            branch instruction to insert\n+     * @param i branch instruction to insert\n@@ -543,2 +659,1 @@\n-     * Insert a single instruction j before another instruction i, which must be\n-     * in this list of course!\n+     * Insert a compound instruction.\n@@ -546,4 +661,1 @@\n-     * @param i\n-     *            Instruction in list\n-     * @param j\n-     *            Instruction to insert before i in list\n+     * @param c The composite instruction (containing an InstructionList)\n@@ -552,2 +664,14 @@\n-    public InstructionHandle insert(final Instruction i, final Instruction j) {\n-        return insert(i, new InstructionList(j));\n+    public InstructionHandle insert(final CompoundInstruction c) {\n+        return insert(c.getInstructionList());\n+    }\n+\n+    \/**\n+     * Insert an instruction at start of this list.\n+     *\n+     * @param i instruction to insert\n+     * @return instruction handle of the inserted instruction\n+     *\/\n+    public InstructionHandle insert(final Instruction i) {\n+        final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n+        insert(ih);\n+        return ih;\n@@ -559,4 +683,2 @@\n-     * @param i\n-     *            Instruction in list\n-     * @param c\n-     *            The composite instruction (containing an InstructionList)\n+     * @param i Instruction in list\n+     * @param c The composite instruction (containing an InstructionList)\n@@ -570,1 +692,1 @@\n-     * Insert a compound instruction.\n+     * Insert a single instruction j before another instruction i, which must be in this list of course!\n@@ -572,2 +694,2 @@\n-     * @param c\n-     *            The composite instruction (containing an InstructionList)\n+     * @param i Instruction in list\n+     * @param j Instruction to insert before i in list\n@@ -576,2 +698,2 @@\n-    public InstructionHandle insert(final CompoundInstruction c) {\n-        return insert(c.getInstructionList());\n+    public InstructionHandle insert(final Instruction i, final Instruction j) {\n+        return insert(i, new InstructionList(j));\n@@ -581,1 +703,1 @@\n-     * Insert an instruction before instruction (handle) ih contained in this list.\n+     * Insert another list before Instruction i contained in this list. Consumes argument list, i.e., it becomes empty.\n@@ -583,5 +705,3 @@\n-     * @param ih\n-     *            where to insert to the instruction list\n-     * @param i\n-     *            Instruction to insert\n-     * @return instruction handle of the first inserted instruction\n+     * @param i where to append the instruction list\n+     * @param il Instruction list to insert\n+     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()\n@@ -589,2 +709,6 @@\n-    public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {\n-        return insert(ih, new InstructionList(i));\n+    public InstructionHandle insert(final Instruction i, final InstructionList il) {\n+        InstructionHandle ih;\n+        if ((ih = findInstruction1(i)) == null) {\n+            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n+        }\n+        return insert(ih, il);\n@@ -594,1 +718,1 @@\n-     * Insert a compound instruction.\n+     * Insert an instruction at start of this list.\n@@ -596,5 +720,1 @@\n-     * @param ih\n-     *            where to insert the instruction list\n-     * @param c\n-     *            The composite instruction (containing an InstructionList)\n-     * @return instruction handle of the first inserted instruction\n+     * @param ih instruction to insert\n@@ -602,2 +722,11 @@\n-    public InstructionHandle insert(final InstructionHandle ih, final CompoundInstruction c) {\n-        return insert(ih, c.getInstructionList());\n+    private void insert(final InstructionHandle ih) {\n+        if (isEmpty()) {\n+            start = end = ih;\n+            ih.setNext(ih.setPrev(null));\n+        } else {\n+            start.setPrev(ih);\n+            ih.setNext(start);\n+            ih.setPrev(null);\n+            start = ih;\n+        }\n+        length++;\n@@ -609,4 +738,2 @@\n-     * @param ih\n-     *            where to insert to the instruction list\n-     * @param i\n-     *            Instruction to insert\n+     * @param ih where to insert to the instruction list\n+     * @param i Instruction to insert\n@@ -624,4 +751,117 @@\n-     * Take all instructions (handles) from \"start\" to \"end\" and append them\n-     * after the new location \"target\". Of course, \"end\" must be after \"start\"\n-     * and target must not be located within this range. If you want to move\n-     * something to the start of the list use null as value for target.\n+     * Insert a compound instruction.\n+     *\n+     * @param ih where to insert the instruction list\n+     * @param c The composite instruction (containing an InstructionList)\n+     * @return instruction handle of the first inserted instruction\n+     *\/\n+    public InstructionHandle insert(final InstructionHandle ih, final CompoundInstruction c) {\n+        return insert(ih, c.getInstructionList());\n+    }\n+\n+    \/**\n+     * Insert an instruction before instruction (handle) ih contained in this list.\n+     *\n+     * @param ih where to insert to the instruction list\n+     * @param i Instruction to insert\n+     * @return instruction handle of the first inserted instruction\n+     *\/\n+    public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {\n+        return insert(ih, new InstructionList(i));\n+    }\n+\n+    \/**\n+     * Insert another list before Instruction handle ih contained in this list. Consumes argument list, i.e., it becomes\n+     * empty.\n+     *\n+     * @param ih where to append the instruction list\n+     * @param il Instruction list to insert\n+     * @return instruction handle of the first inserted instruction\n+     *\/\n+    public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {\n+        if (il == null) {\n+            throw new ClassGenException(\"Inserting null InstructionList\");\n+        }\n+        if (il.isEmpty()) {\n+            return ih;\n+        }\n+        final InstructionHandle prev = ih.getPrev();\n+        final InstructionHandle ret = il.start;\n+        ih.setPrev(il.end);\n+        il.end.setNext(ih);\n+        il.start.setPrev(prev);\n+        if (prev != null) {\n+            prev.setNext(il.start);\n+        } else {\n+            start = il.start; \/\/ Update start ...\n+        }\n+        length += il.length; \/\/ Update length\n+        il.clear();\n+        return ret;\n+    }\n+\n+    \/**\n+     * Insert another list.\n+     *\n+     * @param il list to insert before start of this list\n+     * @return instruction handle of the first inserted instruction\n+     *\/\n+    public InstructionHandle insert(final InstructionList il) {\n+        if (isEmpty()) {\n+            append(il); \/\/ Code is identical for this case\n+            return start;\n+        }\n+        return insert(start, il);\n+    }\n+\n+    \/**\n+     * Test for empty list.\n+     *\/\n+    public boolean isEmpty() {\n+        return start == null;\n+    } \/\/ && end == null\n+\n+    \/**\n+     * @return iterator that lists all instructions (handles)\n+     *\/\n+    @Override\n+    public Iterator<InstructionHandle> iterator() {\n+        return new Iterator<InstructionHandle>() {\n+\n+            private InstructionHandle ih = start;\n+\n+            @Override\n+            public boolean hasNext() {\n+                return ih != null;\n+            }\n+\n+            @Override\n+            public InstructionHandle next() throws NoSuchElementException {\n+                if (ih == null) {\n+                    throw new NoSuchElementException();\n+                }\n+                final InstructionHandle i = ih;\n+                ih = ih.getNext();\n+                return i;\n+            }\n+\n+            @Override\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * Move a single instruction (handle) to a new location.\n+     *\n+     * @param ih moved instruction\n+     * @param target new location of moved instruction\n+     *\/\n+    public void move(final InstructionHandle ih, final InstructionHandle target) {\n+        move(ih, ih, target);\n+    }\n+\n+    \/**\n+     * Take all instructions (handles) from \"start\" to \"end\" and append them after the new location \"target\". Of course,\n+     * \"end\" must be after \"start\" and target must not be located withing this range. If you want to move something to the\n+     * start of the list use null as value for target.\n@@ -629,2 +869,2 @@\n-     * Any instruction targeters pointing to handles within the block, keep\n-     * their targets.\n+     * Any instruction targeters pointing to handles within the block, keep their targets.\n+     * <\/p>\n@@ -632,6 +872,3 @@\n-     * @param start\n-     *            of moved block\n-     * @param end\n-     *            of moved block\n-     * @param target\n-     *            of moved block\n+     * @param start of moved block\n+     * @param end of moved block\n+     * @param target of moved block\n@@ -641,1 +878,1 @@\n-        if ((start == null) || (end == null)) {\n+        if (start == null || end == null) {\n@@ -644,1 +881,1 @@\n-        if ((target == start) || (target == end)) {\n+        if (target == start || target == end) {\n@@ -650,1 +887,2 @@\n-            } else if (ih == target) {\n+            }\n+            if (ih == target) {\n@@ -689,1 +927,1 @@\n-     * Move a single instruction (handle) to a new location.\n+     * Redirect all references from oldTarget to newTarget, i.e., update targets of branch instructions.\n@@ -691,4 +929,2 @@\n-     * @param ih\n-     *            moved instruction\n-     * @param target\n-     *            new location of moved instruction\n+     * @param oldTarget the old target instruction handle\n+     * @param newTarget the new target instruction handle\n@@ -696,2 +932,41 @@\n-    public void move(final InstructionHandle ih, final InstructionHandle target) {\n-        move(ih, ih, target);\n+    public void redirectBranches(final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            if (i instanceof BranchInstruction) {\n+                final BranchInstruction b = (BranchInstruction) i;\n+                final InstructionHandle target = b.getTarget();\n+                if (target == oldTarget) {\n+                    b.setTarget(newTarget);\n+                }\n+                if (b instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n+                    final InstructionHandle[] targets = ((Select) b).getTargets();\n+                    for (int j = 0; j < targets.length; j++) {\n+                        if (targets[j] == oldTarget) {\n+                            ((Select) b).setTarget(j, newTarget);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Redirect all references of exception handlers from oldTarget to newTarget.\n+     *\n+     * @param exceptions array of exception handlers\n+     * @param oldTarget the old target instruction handle\n+     * @param newTarget the new target instruction handle\n+     * @see MethodGen\n+     *\/\n+    public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions, final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n+        for (final CodeExceptionGen exception : exceptions) {\n+            if (exception.getStartPC() == oldTarget) {\n+                exception.setStartPC(newTarget);\n+            }\n+            if (exception.getEndPC() == oldTarget) {\n+                exception.setEndPC(newTarget);\n+            }\n+            if (exception.getHandlerPC() == oldTarget) {\n+                exception.setHandlerPC(newTarget);\n+            }\n+        }\n@@ -701,3 +976,1 @@\n-     * Remove from instruction `prev' to instruction `next' both contained in\n-     * this list. Throws TargetLostException when one of the removed instruction\n-     * handles is still being targeted.\n+     * Redirect all references of local variables from oldTarget to newTarget.\n@@ -705,4 +978,24 @@\n-     * @param prev\n-     *            where to start deleting (predecessor, exclusive)\n-     * @param next\n-     *            where to end deleting (successor, exclusive)\n+     * @param lg array of local variables\n+     * @param oldTarget the old target instruction handle\n+     * @param newTarget the new target instruction handle\n+     * @see MethodGen\n+     *\/\n+    public void redirectLocalVariables(final LocalVariableGen[] lg, final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n+        for (final LocalVariableGen element : lg) {\n+            final InstructionHandle start = element.getStart();\n+            final InstructionHandle end = element.getEnd();\n+            if (start == oldTarget) {\n+                element.setStart(newTarget);\n+            }\n+            if (end == oldTarget) {\n+                element.setEnd(newTarget);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Remove from instruction 'prev' to instruction 'next' both contained in this list. Throws TargetLostException when one\n+     * of the removed instruction handles is still being targeted.\n+     *\n+     * @param prev where to start deleting (predecessor, exclusive)\n+     * @param next where to end deleting (successor, exclusive)\n@@ -713,1 +1006,1 @@\n-        if ((prev == null) && (next == null)) {\n+        if (prev == null && next == null) {\n@@ -735,1 +1028,1 @@\n-        final List<InstructionHandle> target_vec = new ArrayList<>();\n+        final List<InstructionHandle> targetList = new ArrayList<>();\n@@ -744,1 +1037,1 @@\n-                target_vec.add(ih);\n+                targetList.add(ih);\n@@ -752,28 +1045,2 @@\n-        if (!target_vec.isEmpty()) {\n-            final InstructionHandle[] targeted = new InstructionHandle[target_vec.size()];\n-            target_vec.toArray(targeted);\n-            throw new TargetLostException(targeted, buf.toString());\n-        }\n-    }\n-\n-    \/**\n-     * Remove instruction from this list. The corresponding Instruction handles\n-     * must not be reused!\n-     *\n-     * @param ih\n-     *            instruction (handle) to remove\n-     *\/\n-    public void delete(final InstructionHandle ih) throws TargetLostException {\n-        remove(ih.getPrev(), ih.getNext());\n-    }\n-\n-    \/**\n-     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param i\n-     *            instruction to remove\n-     *\/\n-    public void delete(final Instruction i) throws TargetLostException {\n-        InstructionHandle ih;\n-        if ((ih = findInstruction1(i)) == null) {\n-            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n+        if (!targetList.isEmpty()) {\n+            throw new TargetLostException(targetList.toArray(InstructionHandle.EMPTY_ARRAY), buf.toString());\n@@ -781,1 +1048,0 @@\n-        delete(ih);\n@@ -785,41 +1051,1 @@\n-     * Remove instructions from instruction `from' to instruction `to' contained\n-     * in this list. The user must ensure that `from' is an instruction before\n-     * `to', or risk havoc. The corresponding Instruction handles must not be\n-     * reused!\n-     *\n-     * @param from\n-     *            where to start deleting (inclusive)\n-     * @param to\n-     *            where to end deleting (inclusive)\n-     *\/\n-    public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {\n-        remove(from.getPrev(), to.getNext());\n-    }\n-\n-    \/**\n-     * Remove instructions from instruction `from' to instruction `to' contained in this list. The user must ensure that `from' is an instruction before `to',\n-     * or risk havoc. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param from\n-     *            where to start deleting (inclusive)\n-     * @param to\n-     *            where to end deleting (inclusive)\n-     *\/\n-    public void delete(final Instruction from, final Instruction to) throws TargetLostException {\n-        InstructionHandle from_ih;\n-        InstructionHandle to_ih;\n-        if ((from_ih = findInstruction1(from)) == null) {\n-            throw new ClassGenException(\"Instruction \" + from + \" is not contained in this list.\");\n-        }\n-        if ((to_ih = findInstruction2(to)) == null) {\n-            throw new ClassGenException(\"Instruction \" + to + \" is not contained in this list.\");\n-        }\n-        delete(from_ih, to_ih);\n-    }\n-\n-    \/**\n-     * Search for given Instruction reference, start at beginning of list.\n-     *\n-     * @param i\n-     *            instruction to search for\n-     * @return instruction found on success, null otherwise\n+     * Remove observer for this object.\n@@ -827,5 +1053,3 @@\n-    private InstructionHandle findInstruction1(final Instruction i) {\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            if (ih.getInstruction() == i) {\n-                return ih;\n-            }\n+    public void removeObserver(final InstructionListObserver o) {\n+        if (observers != null) {\n+            observers.remove(o);\n@@ -833,1 +1057,0 @@\n-        return null;\n@@ -837,5 +1060,1 @@\n-     * Search for given Instruction reference, start at end of list\n-     *\n-     * @param i\n-     *            instruction to search for\n-     * @return instruction found on success, null otherwise\n+     * Replace all references to the old constant pool with references to the new constant pool\n@@ -843,13 +1062,1 @@\n-    private InstructionHandle findInstruction2(final Instruction i) {\n-        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n-            if (ih.getInstruction() == i) {\n-                return ih;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    public boolean contains(final InstructionHandle i) {\n-        if (i == null) {\n-            return false;\n-        }\n+    public void replaceConstantPool(final ConstantPoolGen oldCp, final ConstantPoolGen newCp) {\n@@ -857,2 +1064,5 @@\n-            if (ih == i) {\n-                return true;\n+            final Instruction i = ih.getInstruction();\n+            if (i instanceof CPInstruction) {\n+                final CPInstruction ci = (CPInstruction) i;\n+                final Constant c = oldCp.getConstant(ci.getIndex());\n+                ci.setIndex(newCp.addConstant(c, oldCp));\n@@ -861,5 +1071,0 @@\n-        return false;\n-    }\n-\n-    public boolean contains(final Instruction i) {\n-        return findInstruction1(i) != null;\n@@ -873,2 +1078,1 @@\n-     * Give all instructions their position number (offset in byte stream),\n-     * i.e., make the list ready to be dumped.\n+     * Give all instructions their position number (offset in byte stream), i.e., make the list ready to be dumped.\n@@ -876,2 +1080,1 @@\n-     * @param check\n-     *            Perform sanity checks, e.g. if all targeted instructions really belong to this list\n+     * @param check Perform sanity checks, e.g. if all targeted instructions really belong to this list\n@@ -880,2 +1083,2 @@\n-        int max_additional_bytes = 0;\n-        int additional_bytes = 0;\n+        int maxAdditionalBytes = 0;\n+        int additionalBytes = 0;\n@@ -894,3 +1097,1 @@\n-                        throw new ClassGenException(\"Branch target of \"\n-                                + Const.getOpcodeName(i.getOpcode()) + \":\"\n-                                + inst + \" not in instruction list\");\n+                        throw new ClassGenException(\"Branch target of \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not in instruction list\");\n@@ -903,3 +1104,1 @@\n-                                throw new ClassGenException(\"Branch target of \"\n-                                        + Const.getOpcodeName(i.getOpcode()) + \":\"\n-                                        + inst + \" not in instruction list\");\n+                                throw new ClassGenException(\"Branch target of \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not in instruction list\");\n@@ -911,3 +1110,1 @@\n-                                \"Branch instruction \"\n-                                + Const.getOpcodeName(i.getOpcode()) + \":\"\n-                                + inst + \" not contained in BranchHandle.\");\n+                            \"Branch instruction \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not contained in BranchHandle.\");\n@@ -926,3 +1123,2 @@\n-             * Get an estimate about how many additional bytes may be added,\n-             * because BranchInstructions may have variable length depending on the target offset\n-             * (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).\n+             * Get an estimate about how many additional bytes may be added, because BranchInstructions may have variable length\n+             * depending on the target offset (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).\n@@ -931,3 +1127,3 @@\n-                case Const.JSR:\n-                case Const.GOTO:\n-                    max_additional_bytes += 2;\n+            case Const.JSR:\n+            case Const.GOTO:\n+                maxAdditionalBytes += 2;\n@@ -935,3 +1131,3 @@\n-                case Const.TABLESWITCH:\n-                case Const.LOOKUPSWITCH:\n-                    max_additional_bytes += 3;\n+            case Const.TABLESWITCH:\n+            case Const.LOOKUPSWITCH:\n+                maxAdditionalBytes += 3;\n@@ -942,4 +1138,3 @@\n-\n-        \/* Pass 2: Expand the variable-length (Branch)Instructions depending on\n-         * the target offset (short or int) and ensure that branch targets are\n-         * within this list.\n+        \/*\n+         * Pass 2: Expand the variable-length (Branch)Instructions depending on the target offset (short or int) and ensure that\n+         * branch targets are within this list.\n@@ -948,1 +1143,1 @@\n-            additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);\n+            additionalBytes += ih.updatePosition(additionalBytes, maxAdditionalBytes);\n@@ -951,2 +1146,1 @@\n-         * Pass 3: Update position numbers (which may have changed due to the\n-         * preceding expansions), like pass 1.\n+         * Pass 3: Update position numbers (which may have changed due to the preceding expansions), like pass 1.\n@@ -966,26 +1160,1 @@\n-     * When everything is finished, use this method to convert the instruction\n-     * list into an array of bytes.\n-     *\n-     * @return the byte code ready to be dumped\n-     *\/\n-    public byte[] getByteCode() {\n-        \/\/ Update position indices of instructions\n-        setPositions();\n-        final ByteArrayOutputStream b = new ByteArrayOutputStream();\n-        final DataOutputStream out = new DataOutputStream(b);\n-        try {\n-            for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-                final Instruction i = ih.getInstruction();\n-                i.dump(out); \/\/ Traverse list\n-            }\n-            out.flush();\n-        } catch (final IOException e) {\n-            System.err.println(e);\n-            return new byte[0];\n-        }\n-        return b.toByteArray();\n-    }\n-\n-    \/**\n-     * @return an array of instructions without target information for branch\n-     * instructions.\n+     * @return length of list (Number of instructions, not bytes)\n@@ -993,10 +1162,2 @@\n-    public Instruction[] getInstructions() {\n-        final List<Instruction> instructions = new ArrayList<>();\n-        try (ByteSequence bytes = new ByteSequence(getByteCode())) {\n-            while (bytes.available() > 0) {\n-                instructions.add(Instruction.readInstruction(bytes));\n-            }\n-        } catch (final IOException e) {\n-            throw new ClassGenException(e.toString(), e);\n-        }\n-        return instructions.toArray(new Instruction[instructions.size()]);\n+    public int size() {\n+        return length;\n@@ -1011,2 +1172,1 @@\n-     * @param verbose\n-     *            toggle output format\n+     * @param verbose toggle output format\n@@ -1024,271 +1184,2 @@\n-     * @return iterator that lists all instructions (handles)\n-     *\/\n-    @Override\n-    public Iterator<InstructionHandle> iterator() {\n-        return new Iterator<InstructionHandle>() {\n-\n-            private InstructionHandle ih = start;\n-\n-            @Override\n-            public InstructionHandle next() throws NoSuchElementException {\n-                if (ih == null) {\n-                    throw new NoSuchElementException();\n-                }\n-                final InstructionHandle i = ih;\n-                ih = ih.getNext();\n-                return i;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public boolean hasNext() {\n-                return ih != null;\n-            }\n-        };\n-    }\n-\n-    \/**\n-     * @return array containing all instructions (handles)\n-     *\/\n-    public InstructionHandle[] getInstructionHandles() {\n-        final InstructionHandle[] ihs = new InstructionHandle[length];\n-        InstructionHandle ih = start;\n-        for (int i = 0; i < length; i++) {\n-            ihs[i] = ih;\n-            ih = ih.getNext();\n-        }\n-        return ihs;\n-    }\n-\n-    \/**\n-     * Get positions (offsets) of all instructions in the list. This relies on\n-     * that the list has been freshly created from an byte code array, or that\n-     * setPositions() has been called. Otherwise this may be inaccurate.\n-     *\n-     * @return array containing all instruction's offset in byte code\n-     *\/\n-    public int[] getInstructionPositions() {\n-        return bytePositions;\n-    }\n-\n-    \/**\n-     * @return complete, i.e., deep copy of this list\n-     *\/\n-    public InstructionList copy() {\n-        final Map<InstructionHandle, InstructionHandle> map = new HashMap<>();\n-        final InstructionList il = new InstructionList();\n-        \/*\n-         * Pass 1: Make copies of all instructions, append them to the new list\n-         * and associate old instruction references with the new ones, i.e., a 1:1 mapping.\n-         *\/\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            final Instruction c = i.copy(); \/\/ Use clone for shallow copy\n-            if (c instanceof BranchInstruction) {\n-                map.put(ih, il.append((BranchInstruction) c));\n-            } else {\n-                map.put(ih, il.append(c));\n-            }\n-        }\n-        \/*\n-         * Pass 2: Update branch targets.\n-         *\/\n-        InstructionHandle ih = start;\n-        InstructionHandle ch = il.start;\n-        while (ih != null) {\n-            final Instruction i = ih.getInstruction();\n-            final Instruction c = ch.getInstruction();\n-            if (i instanceof BranchInstruction) {\n-                final BranchInstruction bi = (BranchInstruction) i;\n-                final BranchInstruction bc = (BranchInstruction) c;\n-                final InstructionHandle itarget = bi.getTarget(); \/\/ old target\n-                \/\/ New target is in hash map\n-                bc.setTarget(map.get(itarget));\n-                if (bi instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n-                    final InstructionHandle[] itargets = ((Select) bi).getTargets();\n-                    final InstructionHandle[] ctargets = ((Select) bc).getTargets();\n-                    for (int j = 0; j < itargets.length; j++) { \/\/ Update all targets\n-                        ctargets[j] = map.get(itargets[j]);\n-                    }\n-                }\n-            }\n-            ih = ih.getNext();\n-            ch = ch.getNext();\n-        }\n-        return il;\n-    }\n-\n-    \/**\n-     * Replace all references to the old constant pool with references to the\n-     * new constant pool\n-     *\/\n-    public void replaceConstantPool(final ConstantPoolGen old_cp, final ConstantPoolGen new_cp) {\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            if (i instanceof CPInstruction) {\n-                final CPInstruction ci = (CPInstruction) i;\n-                final Constant c = old_cp.getConstant(ci.getIndex());\n-                ci.setIndex(new_cp.addConstant(c, old_cp));\n-            }\n-        }\n-    }\n-\n-    private void clear() {\n-        start = end = null;\n-        length = 0;\n-    }\n-\n-    \/**\n-     * Delete contents of list. Provides better memory utilization, because the\n-     * system then may reuse the instruction handles. This method is typically\n-     * called right after {@link MethodGen#getMethod()}.\n-     *\/\n-    public void dispose() {\n-        \/\/ Traverse in reverse order, because ih.next is overwritten\n-        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n-            \/*\n-             * Causes BranchInstructions to release target and targeters,\n-             * because it calls dispose() on the contained instruction.\n-             *\/\n-            ih.dispose();\n-        }\n-        clear();\n-    }\n-\n-    \/**\n-     * @return start of list\n-     *\/\n-    public InstructionHandle getStart() {\n-        return start;\n-    }\n-\n-    \/**\n-     * @return end of list\n-     *\/\n-    public InstructionHandle getEnd() {\n-        return end;\n-    }\n-\n-    \/**\n-     * @return length of list (Number of instructions, not bytes)\n-     *\/\n-    public int getLength() {\n-        return length;\n-    }\n-\n-    \/**\n-     * @return length of list (Number of instructions, not bytes)\n-     *\/\n-    public int size() {\n-        return length;\n-    }\n-\n-    \/**\n-     * Redirect all references from old_target to new_target, i.e., update\n-     * targets of branch instructions.\n-     *\n-     * @param old_target\n-     *            the old target instruction handle\n-     * @param new_target\n-     *            the new target instruction handle\n-     *\/\n-    public void redirectBranches(final InstructionHandle old_target, final InstructionHandle new_target) {\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            if (i instanceof BranchInstruction) {\n-                final BranchInstruction b = (BranchInstruction) i;\n-                final InstructionHandle target = b.getTarget();\n-                if (target == old_target) {\n-                    b.setTarget(new_target);\n-                }\n-                if (b instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n-                    final InstructionHandle[] targets = ((Select) b).getTargets();\n-                    for (int j = 0; j < targets.length; j++) {\n-                        if (targets[j] == old_target) {\n-                            ((Select) b).setTarget(j, new_target);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Redirect all references of local variables from old_target to new_target.\n-     *\n-     * @param lg\n-     *            array of local variables\n-     * @param old_target\n-     *            the old target instruction handle\n-     * @param new_target\n-     *            the new target instruction handle\n-     * @see MethodGen\n-     *\/\n-    public void redirectLocalVariables(final LocalVariableGen[] lg, final InstructionHandle old_target, final InstructionHandle new_target) {\n-        for (final LocalVariableGen element : lg) {\n-            final InstructionHandle start = element.getStart();\n-            final InstructionHandle end = element.getEnd();\n-            if (start == old_target) {\n-                element.setStart(new_target);\n-            }\n-            if (end == old_target) {\n-                element.setEnd(new_target);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Redirect all references of exception handlers from old_target to new_target.\n-     *\n-     * @param exceptions\n-     *            array of exception handlers\n-     * @param old_target\n-     *            the old target instruction handle\n-     * @param new_target\n-     *            the new target instruction handle\n-     * @see MethodGen\n-     *\/\n-    public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions,\n-            final InstructionHandle old_target, final InstructionHandle new_target) {\n-        for (final CodeExceptionGen exception : exceptions) {\n-            if (exception.getStartPC() == old_target) {\n-                exception.setStartPC(new_target);\n-            }\n-            if (exception.getEndPC() == old_target) {\n-                exception.setEndPC(new_target);\n-            }\n-            if (exception.getHandlerPC() == old_target) {\n-                exception.setHandlerPC(new_target);\n-            }\n-        }\n-    }\n-\n-    private List<InstructionListObserver> observers;\n-\n-    \/**\n-     * Add observer for this object.\n-     *\/\n-    public void addObserver(final InstructionListObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n-    }\n-\n-    \/**\n-     * Remove observer for this object.\n-     *\/\n-    public void removeObserver(final InstructionListObserver o) {\n-        if (observers != null) {\n-            observers.remove(o);\n-        }\n-    }\n-\n-    \/**\n-     * Call notify() method on all observers. This method is not called\n-     * automatically whenever the state has changed, but has to be called by the\n-     * user after he has finished editing the object.\n+     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n+     * has to be called by the user after he has finished editing the object.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionList.java","additions":685,"deletions":794,"binary":false,"changes":1479,"status":"modified"},{"patch":"@@ -25,3 +25,2 @@\n- * Implement this interface if you're interested in changes to an InstructionList object\n- * and register yourself with addObserver().\n- *\n+ * Implement this interface if you're interested in changes to an InstructionList object and register yourself with\n+ * addObserver().\n@@ -31,1 +30,1 @@\n-    void notify( InstructionList list );\n+    void notify(InstructionList list);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionListObserver.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * Denote that a class targets InstructionHandles within an InstructionList. Namely\n- * the following implementers:\n+ * Denote that a class targets InstructionHandles within an InstructionList. Namely the following implementers:\n@@ -34,0 +33,2 @@\n+    \/\/ static final InstructionTargeter[] EMPTY_ARRAY = new InstructionTargeter[0];\n+\n@@ -42,3 +43,3 @@\n-     * @param old_ih the old handle\n-     * @param new_ih the new handle\n-     * @throws ClassGenException if old_ih is not targeted by this object\n+     * @param oldIh the old handle\n+     * @param newIh the new handle\n+     * @throws ClassGenException if oldIh is not targeted by this object\n@@ -46,1 +47,1 @@\n-    void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) throws ClassGenException;\n+    void updateTarget(InstructionHandle oldIh, InstructionHandle newIh) throws ClassGenException;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionTargeter.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -33,1 +34,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Feb 2023\n@@ -35,2 +36,1 @@\n-public abstract class InvokeInstruction extends FieldOrMethod implements ExceptionThrower,\n-        StackConsumer, StackProducer {\n+public abstract class InvokeInstruction extends FieldOrMethod implements ExceptionThrower, StackConsumer, StackProducer {\n@@ -39,2 +39,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -45,1 +44,0 @@\n-\n@@ -53,1 +51,0 @@\n-\n@@ -55,25 +52,2 @@\n-     * @return mnemonic for instruction with symbolic references resolved\n-     *\/\n-    @Override\n-    public String toString( final ConstantPool cp ) {\n-        final Constant c = cp.getConstant(super.getIndex());\n-        final StringTokenizer tok = new StringTokenizer(cp.constantToString(c));\n-\n-        final String opcodeName = Const.getOpcodeName(super.getOpcode());\n-\n-        final StringBuilder sb = new StringBuilder(opcodeName);\n-        if (tok.hasMoreTokens()) {\n-            sb.append(\" \");\n-            sb.append(tok.nextToken().replace('.', '\/'));\n-            if (tok.hasMoreTokens()) {\n-                sb.append(tok.nextToken());\n-            }\n-        }\n-\n-        return sb.toString();\n-    }\n-\n-\n-    \/**\n-     * Also works for instructions whose stack effect depends on the\n-     * constant pool entry they reference.\n+     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n+     *\n@@ -83,1 +57,1 @@\n-    public int consumeStack( final ConstantPoolGen cpg ) {\n+    public int consumeStack(final ConstantPoolGen cpg) {\n@@ -85,1 +59,1 @@\n-        if ((super.getOpcode() == Const.INVOKESTATIC) || (super.getOpcode() == Const.INVOKEDYNAMIC)) {\n+        if (super.getOpcode() == Const.INVOKESTATIC || super.getOpcode() == Const.INVOKEDYNAMIC) {\n@@ -96,1 +70,0 @@\n-\n@@ -98,3 +71,1 @@\n-     * Also works for instructions whose stack effect depends on the\n-     * constant pool entry they reference.\n-     * @return Number of words produced onto stack by this instruction\n+     * @return argument types of referenced method.\n@@ -102,4 +73,2 @@\n-    @Override\n-    public int produceStack( final ConstantPoolGen cpg ) {\n-        final String signature = getSignature(cpg);\n-        return Type.getReturnTypeSize(signature);\n+    public Type[] getArgumentTypes(final ConstantPoolGen cpg) {\n+        return Type.getArgumentTypes(getSignature(cpg));\n@@ -109,4 +78,1 @@\n-     * This overrides the deprecated version as we know here that the referenced class\n-     * may legally be an array.\n-     *\n-     * @deprecated in FieldOrMethod\n+     * This overrides the deprecated version as we know here that the referenced class may legally be an array.\n@@ -123,1 +89,1 @@\n-        return className.replace('\/', '.');\n+        return Utility.pathToPackage(className);\n@@ -126,1 +92,2 @@\n-    \/** @return return type of referenced method.\n+    \/**\n+     * @return name of referenced method.\n@@ -128,3 +95,2 @@\n-    @Override\n-    public Type getType( final ConstantPoolGen cpg ) {\n-        return getReturnType(cpg);\n+    public String getMethodName(final ConstantPoolGen cpg) {\n+        return getName(cpg);\n@@ -133,2 +99,2 @@\n-\n-    \/** @return name of referenced method.\n+    \/**\n+     * @return return type of referenced method.\n@@ -136,2 +102,2 @@\n-    public String getMethodName( final ConstantPoolGen cpg ) {\n-        return getName(cpg);\n+    public Type getReturnType(final ConstantPoolGen cpg) {\n+        return Type.getReturnType(getSignature(cpg));\n@@ -140,2 +106,2 @@\n-\n-    \/** @return return type of referenced method.\n+    \/**\n+     * @return return type of referenced method.\n@@ -143,2 +109,3 @@\n-    public Type getReturnType( final ConstantPoolGen cpg ) {\n-        return Type.getReturnType(getSignature(cpg));\n+    @Override\n+    public Type getType(final ConstantPoolGen cpg) {\n+        return getReturnType(cpg);\n@@ -147,0 +114,10 @@\n+    \/**\n+     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n+     *\n+     * @return Number of words produced onto stack by this instruction\n+     *\/\n+    @Override\n+    public int produceStack(final ConstantPoolGen cpg) {\n+        final String signature = getSignature(cpg);\n+        return Type.getReturnTypeSize(signature);\n+    }\n@@ -148,1 +125,2 @@\n-    \/** @return argument types of referenced method.\n+    \/**\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -150,2 +128,17 @@\n-    public Type[] getArgumentTypes( final ConstantPoolGen cpg ) {\n-        return Type.getArgumentTypes(getSignature(cpg));\n+    @Override\n+    public String toString(final ConstantPool cp) {\n+        final Constant c = cp.getConstant(super.getIndex());\n+        final StringTokenizer tok = new StringTokenizer(cp.constantToString(c));\n+\n+        final String opcodeName = Const.getOpcodeName(super.getOpcode());\n+\n+        final StringBuilder sb = new StringBuilder(opcodeName);\n+        if (tok.hasMoreTokens()) {\n+            sb.append(\" \");\n+            sb.append(Utility.packageToPath(tok.nextToken()));\n+            if (tok.hasMoreTokens()) {\n+                sb.append(tok.nextToken());\n+            }\n+        }\n+\n+        return sb.toString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InvokeInstruction.java","additions":56,"deletions":63,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- *\n@@ -34,2 +33,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -40,1 +38,0 @@\n-\n@@ -45,0 +42,14 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitStackProducer(this);\n+        v.visitVariableLengthInstruction(this);\n+        v.visitBranchInstruction(this);\n+        v.visitJsrInstruction(this);\n+        v.visitJSR(this);\n+    }\n@@ -48,0 +59,1 @@\n+     *\n@@ -51,1 +63,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -62,1 +74,0 @@\n-\n@@ -64,1 +75,1 @@\n-    protected int updatePosition( final int offset, final int max_offset ) {\n+    protected int updatePosition(final int offset, final int maxOffset) {\n@@ -67,1 +78,1 @@\n-        if (Math.abs(i) >= (Short.MAX_VALUE - max_offset)) { \/\/ to large for short (estimate)\n+        if (Math.abs(i) >= Short.MAX_VALUE - maxOffset) { \/\/ to large for short (estimate)\n@@ -69,1 +80,1 @@\n-            final short old_length = (short) super.getLength();\n+            final short oldLength = (short) super.getLength();\n@@ -71,1 +82,1 @@\n-            return super.getLength() - old_length;\n+            return super.getLength() - oldLength;\n@@ -75,18 +86,0 @@\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitStackProducer(this);\n-        v.visitVariableLengthInstruction(this);\n-        v.visitBranchInstruction(this);\n-        v.visitJsrInstruction(this);\n-        v.visitJSR(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JSR.java","additions":21,"deletions":28,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n- *\n@@ -36,2 +35,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -42,1 +40,0 @@\n-\n@@ -48,0 +45,13 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitStackProducer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitJsrInstruction(this);\n+        v.visitJSR_W(this);\n+    }\n@@ -51,0 +61,1 @@\n+     *\n@@ -54,1 +65,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -60,1 +71,0 @@\n-\n@@ -65,1 +75,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -69,17 +79,0 @@\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitStackProducer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitJsrInstruction(this);\n-        v.visitJSR_W(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JSR_W.java","additions":17,"deletions":24,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -28,7 +27,1 @@\n-public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch,\n-        TypedInstruction, StackProducer {\n-\n-    JsrInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, target);\n-    }\n-\n+public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch, TypedInstruction, StackProducer {\n@@ -37,2 +30,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,0 +35,3 @@\n+    JsrInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, target);\n+    }\n@@ -44,1 +39,2 @@\n-    \/** @return return address type\n+    \/**\n+     * @return return address type\n@@ -47,1 +43,1 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n+    public Type getType(final ConstantPoolGen cp) {\n@@ -51,1 +47,0 @@\n-\n@@ -53,9 +48,5 @@\n-     * Returns an InstructionHandle to the physical successor\n-     * of this JsrInstruction. <B>For this method to work,\n-     * this JsrInstruction object must not be shared between\n-     * multiple InstructionHandle objects!<\/B>\n-     * Formally, there must not be InstructionHandle objects\n-     * i, j where i != j and i.getInstruction() == this ==\n-     * j.getInstruction().\n-     * @return an InstructionHandle to the \"next\" instruction that\n-     * will be executed when RETurned from a subroutine.\n+     * Returns an InstructionHandle to the physical successor of this JsrInstruction. <B>For this method to work, this\n+     * JsrInstruction object must not be shared between multiple InstructionHandle objects!<\/B> Formally, there must not be\n+     * InstructionHandle objects i, j where i != j and i.getInstruction() == this == j.getInstruction().\n+     *\n+     * @return an InstructionHandle to the \"next\" instruction that will be executed when RETurned from a subroutine.\n@@ -76,1 +67,1 @@\n-            if ((ih != null) && (ih.getInstruction() == this)) {\n+            if (ih != null && ih.getInstruction() == this) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JsrInstruction.java","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2D.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2F.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2I.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -36,1 +39,0 @@\n-\n@@ -38,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; ..., value1, value2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; ..., value1, value2\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Load long from array\n+    \/**\n+     * Load long from array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -36,1 +39,0 @@\n-\n@@ -38,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LAND.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * LASTORE -  Store into long array\n- * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...<\/PRE>\n+ * LASTORE - Store into long array\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...\n+ * <\/PRE>\n@@ -31,1 +33,2 @@\n-    \/** Store long into array\n+    \/**\n+     * Store long into array\n@@ -37,1 +40,0 @@\n-\n@@ -39,4 +41,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result &lt;= -1, 0, 1&gt;<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result &lt;= -1, 0, 1&gt;\n+ * <\/PRE>\n@@ -36,9 +38,0 @@\n-\n-    \/** @return Type.LONG\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.LONG;\n-    }\n-\n-\n@@ -46,4 +39,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -54,1 +45,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -60,0 +51,8 @@\n+\n+    \/**\n+     * @return Type.LONG\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.LONG;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LCMP.java","additions":14,"deletions":15,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,2 +26,3 @@\n- * <PRE>Stack: ... -&gt; ..., <\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ...,\n+ * <\/PRE>\n@@ -31,2 +32,1 @@\n-    private long value;\n-\n+    private final long value;\n@@ -35,2 +35,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,0 +38,1 @@\n+        this(0);\n@@ -41,1 +41,0 @@\n-\n@@ -54,15 +53,0 @@\n-\n-    @Override\n-    public Number getValue() {\n-        return Long.valueOf(value);\n-    }\n-\n-\n-    \/** @return Type.LONG\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.LONG;\n-    }\n-\n-\n@@ -70,4 +54,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -78,1 +60,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -85,0 +67,13 @@\n+\n+    \/**\n+     * @return Type.LONG\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.LONG;\n+    }\n+\n+    @Override\n+    public Number getValue() {\n+        return Long.valueOf(value);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LCONST.java","additions":22,"deletions":27,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * <PRE>Stack: ... -&gt; ..., item<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ..., item\n+ * <\/PRE>\n@@ -39,2 +40,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -45,1 +45,0 @@\n-\n@@ -51,10 +50,14 @@\n-\n-    \/\/ Adjust to proper size\n-    protected final void setSize() {\n-        if (super.getIndex() <= com.sun.org.apache.bcel.internal.Const.MAX_BYTE) { \/\/ Fits in one byte?\n-            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC);\n-            super.setLength(2);\n-        } else {\n-            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC_W);\n-            super.setLength(3);\n-        }\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitStackProducer(this);\n+        v.visitPushInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitCPInstruction(this);\n+        v.visitLDC(this);\n@@ -63,1 +66,0 @@\n-\n@@ -66,0 +68,1 @@\n+     *\n@@ -69,1 +72,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -78,4 +81,0 @@\n-\n-    \/**\n-     * Set the index to constant pool and adjust size.\n-     *\/\n@@ -83,3 +82,2 @@\n-    public final void setIndex( final int index ) {\n-        super.setIndex(index);\n-        setSize();\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_STRING_RESOLUTION);\n@@ -88,4 +86,0 @@\n-\n-    \/**\n-     * Read needed data (e.g. index) from file.\n-     *\/\n@@ -93,3 +87,13 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n-        super.setLength(2);\n-        super.setIndex(bytes.readUnsignedByte());\n+    public Type getType(final ConstantPoolGen cpg) {\n+        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n+            return Type.STRING;\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n+            return Type.FLOAT;\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n+            return Type.INT;\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n+            return Type.CLASS;\n+        default: \/\/ Never reached\n+            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+        }\n@@ -98,2 +102,1 @@\n-\n-    public Object getValue( final ConstantPoolGen cpg ) {\n+    public Object getValue(final ConstantPoolGen cpg) {\n@@ -102,31 +105,14 @@\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n-                final int i = ((com.sun.org.apache.bcel.internal.classfile.ConstantString) c).getStringIndex();\n-                c = cpg.getConstantPool().getConstant(i);\n-                return ((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes();\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n-                return ((com.sun.org.apache.bcel.internal.classfile.ConstantFloat) c).getBytes();\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n-                return ((com.sun.org.apache.bcel.internal.classfile.ConstantInteger) c).getBytes();\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n-                final int nameIndex = ((com.sun.org.apache.bcel.internal.classfile.ConstantClass) c).getNameIndex();\n-                c = cpg.getConstantPool().getConstant(nameIndex);\n-                return new ObjectType(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes());\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n-        }\n-    }\n-\n-\n-    @Override\n-    public Type getType( final ConstantPoolGen cpg ) {\n-        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n-                return Type.STRING;\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n-                return Type.FLOAT;\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n-                return Type.INT;\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n-                return Type.CLASS;\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n+            final int i = ((com.sun.org.apache.bcel.internal.classfile.ConstantString) c).getStringIndex();\n+            c = cpg.getConstantPool().getConstant(i);\n+            return ((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes();\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n+            return Float.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantFloat) c).getBytes());\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n+            return Integer.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantInteger) c).getBytes());\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n+            final int nameIndex = ((com.sun.org.apache.bcel.internal.classfile.ConstantClass) c).getNameIndex();\n+            c = cpg.getConstantPool().getConstant(nameIndex);\n+            return Type.getType(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes());\n+        default: \/\/ Never reached\n+            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n@@ -136,1 +122,3 @@\n-\n+    \/**\n+     * Read needed data (e.g. index) from file.\n+     *\/\n@@ -138,2 +126,3 @@\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_STRING_RESOLUTION);\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+        super.setLength(2);\n+        super.setIndex(bytes.readUnsignedByte());\n@@ -142,1 +131,0 @@\n-\n@@ -144,6 +132,1 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * Set the index to constant pool and adjust size.\n@@ -152,7 +135,14 @@\n-    public void accept( final Visitor v ) {\n-        v.visitStackProducer(this);\n-        v.visitPushInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitCPInstruction(this);\n-        v.visitLDC(this);\n+    public final void setIndex(final int index) {\n+        super.setIndex(index);\n+        setSize();\n+    }\n+\n+    \/\/ Adjust to proper size\n+    protected final void setSize() {\n+        if (super.getIndex() <= com.sun.org.apache.bcel.internal.Const.MAX_BYTE) { \/\/ Fits in one byte?\n+            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC);\n+            super.setLength(2);\n+        } else {\n+            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC_W);\n+            super.setLength(3);\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC.java","additions":71,"deletions":81,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -26,2 +26,3 @@\n- * <PRE>Stack: ... -&gt; ..., item.word1, item.word2<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ..., item.word1, item.word2\n+ * <\/PRE>\n@@ -33,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +39,0 @@\n-\n@@ -44,27 +43,0 @@\n-\n-    @Override\n-    public Type getType( final ConstantPoolGen cpg ) {\n-        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n-                return Type.LONG;\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n-                return Type.DOUBLE;\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown constant type \" + super.getOpcode());\n-        }\n-    }\n-\n-\n-    public Number getValue( final ConstantPoolGen cpg ) {\n-        final com.sun.org.apache.bcel.internal.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());\n-        switch (c.getTag()) {\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n-                return ((com.sun.org.apache.bcel.internal.classfile.ConstantLong) c).getBytes();\n-            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n-                return ((com.sun.org.apache.bcel.internal.classfile.ConstantDouble) c).getBytes();\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n-        }\n-    }\n-\n-\n@@ -72,4 +44,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -80,1 +50,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -87,0 +57,24 @@\n+\n+    @Override\n+    public Type getType(final ConstantPoolGen cpg) {\n+        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n+            return Type.LONG;\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n+            return Type.DOUBLE;\n+        default: \/\/ Never reached\n+            throw new IllegalArgumentException(\"Unknown constant type \" + super.getOpcode());\n+        }\n+    }\n+\n+    public Number getValue(final ConstantPoolGen cpg) {\n+        final com.sun.org.apache.bcel.internal.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());\n+        switch (c.getTag()) {\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n+            return Long.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantLong) c).getBytes());\n+        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n+            return Double.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantDouble) c).getBytes());\n+        default: \/\/ Never reached\n+            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+        }\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC2_W.java","additions":31,"deletions":37,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * <PRE>Stack: ... -&gt; ..., item.word1, item.word2<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ..., item.word1, item.word2\n+ * <\/PRE>\n@@ -37,2 +38,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,1 +43,0 @@\n-\n@@ -48,1 +47,0 @@\n-\n@@ -53,1 +51,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC_W.java","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -30,0 +28,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -38,9 +41,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.ARITHMETIC_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -48,4 +42,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +48,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -64,0 +56,5 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDIV.java","additions":13,"deletions":16,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *<PRE>Stack ... -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack ... -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +40,0 @@\n-\n@@ -44,1 +44,0 @@\n-\n@@ -46,4 +45,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -54,1 +51,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LLOAD.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -36,1 +39,0 @@\n-\n@@ -38,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LNEG.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,3 +42,1 @@\n-\n-    public LOOKUPSWITCH(final int[] match, final InstructionHandle[] targets,\n-            final InstructionHandle defaultTarget) {\n+    public LOOKUPSWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {\n@@ -48,3 +45,3 @@\n-        final short _length = (short) (9 + getMatch_length() * 8);\n-        super.setLength(_length);\n-        setFixed_length(_length);\n+        final short length = (short) (9 + getMatchLength() * 8);\n+        super.setLength(length);\n+        setFixedLength(length);\n@@ -53,0 +50,14 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitSelect(this);\n+        v.visitLOOKUPSWITCH(this);\n+    }\n@@ -56,0 +67,1 @@\n+     *\n@@ -59,1 +71,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -61,3 +73,3 @@\n-        final int _match_length = getMatch_length();\n-        out.writeInt(_match_length); \/\/ npairs\n-        for (int i = 0; i < _match_length; i++) {\n+        final int matchLength = getMatchLength();\n+        out.writeInt(matchLength); \/\/ npairs\n+        for (int i = 0; i < matchLength; i++) {\n@@ -69,1 +81,0 @@\n-\n@@ -74,1 +85,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -76,10 +87,10 @@\n-        final int _match_length = bytes.readInt();\n-        setMatch_length(_match_length);\n-        final short _fixed_length = (short) (9 + _match_length * 8);\n-        setFixed_length(_fixed_length);\n-        final short _length = (short) (_match_length + super.getPadding());\n-        super.setLength(_length);\n-        super.setMatches(new int[_match_length]);\n-        super.setIndices(new int[_match_length]);\n-        super.setTargets(new InstructionHandle[_match_length]);\n-        for (int i = 0; i < _match_length; i++) {\n+        final int matchLength = bytes.readInt();\n+        setMatchLength(matchLength);\n+        final short fixedLength = (short) (9 + matchLength * 8);\n+        setFixedLength(fixedLength);\n+        final short length = (short) (matchLength + super.getPadding());\n+        super.setLength(length);\n+        super.setMatches(new int[matchLength]);\n+        super.setIndices(new int[matchLength]);\n+        super.setTargets(new InstructionHandle[matchLength]);\n+        for (int i = 0; i < matchLength; i++) {\n@@ -90,18 +101,0 @@\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitSelect(this);\n-        v.visitLOOKUPSWITCH(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LOOKUPSWITCH.java","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LOR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -29,0 +28,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; result\n+ * <\/PRE>\n@@ -37,9 +39,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.ARITHMETIC_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -47,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -55,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -63,0 +54,5 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LREM.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * LRETURN -  Return long from method\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;<\/PRE>\n+ * LRETURN - Return long from method\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LRETURN.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSHL.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSHR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ... <\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ...\n+ * <\/PRE>\n@@ -32,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -39,1 +40,0 @@\n-\n@@ -44,1 +44,0 @@\n-\n@@ -46,4 +45,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -54,1 +51,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSTORE.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,2 +26,0 @@\n- * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n- *        ..., result.word1, result.word2\n@@ -29,0 +27,5 @@\n+ * <PRE>\n+ * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n+ * <\/PRE>\n+ *\n+ * ..., result.word1, result.word2\n@@ -36,1 +39,0 @@\n-\n@@ -38,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LUSHR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., value1, value2 -&gt; ..., result\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LXOR.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * This class represents a line number within a method, i.e., give an instruction\n- * a line number corresponding to the source code line.\n+ * This class represents a line number within a method, i.e., give an instruction a line number corresponding to the\n+ * source code line.\n@@ -32,2 +32,2 @@\n- * @see     LineNumber\n- * @see     MethodGen\n+ * @see LineNumber\n+ * @see MethodGen\n@@ -37,0 +37,2 @@\n+    static final LineNumberGen[] EMPTY_ARRAY = {};\n+\n@@ -45,1 +47,1 @@\n-    public LineNumberGen(final InstructionHandle ih, final int src_line) {\n+    public LineNumberGen(final InstructionHandle ih, final int srcLine) {\n@@ -47,1 +49,1 @@\n-        setSourceLine(src_line);\n+        setSourceLine(srcLine);\n@@ -50,0 +52,8 @@\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n+    }\n@@ -55,1 +65,1 @@\n-    public boolean containsTarget( final InstructionHandle ih ) {\n+    public boolean containsTarget(final InstructionHandle ih) {\n@@ -59,11 +69,2 @@\n-\n-    \/**\n-     * @param old_ih old target\n-     * @param new_ih new target\n-     *\/\n-    @Override\n-    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n-        if (old_ih != ih) {\n-            throw new ClassGenException(\"Not targeting \" + old_ih + \", but \" + ih + \"}\");\n-        }\n-        setInstruction(new_ih);\n+    public InstructionHandle getInstruction() {\n+        return ih;\n@@ -72,1 +73,0 @@\n-\n@@ -74,1 +74,1 @@\n-     * Get LineNumber attribute .\n+     * Get LineNumber attribute.\n@@ -76,2 +76,2 @@\n-     * This relies on that the instruction list has already been dumped to byte code or\n-     * or that the `setPositions' methods has been called for the instruction list.\n+     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n+     * has been called for the instruction list.\n@@ -83,0 +83,3 @@\n+    public int getSourceLine() {\n+        return srcLine;\n+    }\n@@ -84,1 +87,1 @@\n-    public void setInstruction( final InstructionHandle instructionHandle ) { \/\/ TODO could be package-protected?\n+    public void setInstruction(final InstructionHandle instructionHandle) { \/\/ TODO could be package-protected?\n@@ -90,0 +93,3 @@\n+    public void setSourceLine(final int srcLine) { \/\/ TODO could be package-protected?\n+        this.srcLine = srcLine;\n+    }\n@@ -91,0 +97,4 @@\n+    \/**\n+     * @param oldIh old target\n+     * @param newIh new target\n+     *\/\n@@ -92,5 +102,3 @@\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n+        if (oldIh != ih) {\n+            throw new ClassGenException(\"Not targeting \" + oldIh + \", but \" + ih + \"}\");\n@@ -98,15 +106,1 @@\n-    }\n-\n-\n-    public InstructionHandle getInstruction() {\n-        return ih;\n-    }\n-\n-\n-    public void setSourceLine( final int src_line ) { \/\/ TODO could be package-protected?\n-        this.srcLine = src_line;\n-    }\n-\n-\n-    public int getSourceLine() {\n-        return srcLine;\n+        setInstruction(newIh);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LineNumberGen.java","additions":37,"deletions":43,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Denotes that an instruction may start the process of loading and resolving\n- * the referenced class in the Virtual Machine.\n- *\n+ * Denotes that an instruction may start the process of loading and resolving the referenced class in the Virtual Machine.\n@@ -32,4 +30,4 @@\n-     * Returns the ObjectType of the referenced class or interface\n-     * that may be loaded and resolved.\n-     * @return object type that may be loaded or null if a primitive is\n-     * referenced\n+     * Returns the {@link ObjectType} of the referenced class or interface that may be loaded and resolved.\n+     *\n+     * @param cpg A ConstantPoolGen\n+     * @return object type that may be loaded or null if a primitive is referenced\n@@ -37,2 +35,1 @@\n-    ObjectType getLoadClassType( ConstantPoolGen cpg );\n-\n+    ObjectType getLoadClassType(ConstantPoolGen cpg);\n@@ -41,9 +38,7 @@\n-     * Returns the type associated with this instruction.\n-     * LoadClass instances are always typed, but this type\n-     * does not always refer to the type of the class or interface\n-     * that it possibly forces to load. For example, GETFIELD would\n-     * return the type of the field and not the type of the class\n-     * where the field is defined.\n-     * If no class is forced to be loaded, <B>null<\/B> is returned.\n-     * An example for this is an ANEWARRAY instruction that creates\n-     * an int[][].\n+     * Returns the type associated with this instruction. LoadClass instances are always typed, but this type does not always refer to the type of the class or\n+     * interface that it possibly forces to load. For example, {@link GETFIELD} would return the type of the field and not the type of the class where the field\n+     * is defined. If no class is forced to be loaded, {@code null} is returned. An example for this is an {@link NEWARRAY} instruction that creates an\n+     * {@code int[][]}.\n+     *\n+     * @param cpg A ConstantPoolGen\n+     * @return the type associated with this instruction.\n@@ -52,1 +47,1 @@\n-    Type getType( ConstantPoolGen cpg );\n+    Type getType(ConstantPoolGen cpg);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LoadClass.java","additions":14,"deletions":19,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Denotes an unparameterized instruction to load a value from a local\n- * variable, e.g. ILOAD.\n- *\n+ * Denotes an unparameterized instruction to load a value from a local variable, e.g. ILOAD.\n@@ -32,3 +30,2 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n-     * tag and length are defined in readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n+     * readInstruction and initFromFile, respectively.\n@@ -36,2 +33,2 @@\n-    LoadInstruction(final short canon_tag, final short c_tag) {\n-        super(canon_tag, c_tag);\n+    LoadInstruction(final short canonTag, final short cTag) {\n+        super(canonTag, cTag);\n@@ -40,1 +37,0 @@\n-\n@@ -43,1 +39,1 @@\n-     * @param c_tag Instruction number for compact version, ALOAD_0, e.g.\n+     * @param cTag Instruction number for compact version, ALOAD_0, e.g.\n@@ -46,2 +42,2 @@\n-    protected LoadInstruction(final short opcode, final short c_tag, final int n) {\n-        super(opcode, c_tag, n);\n+    protected LoadInstruction(final short opcode, final short cTag, final int n) {\n+        super(opcode, cTag, n);\n@@ -50,1 +46,0 @@\n-\n@@ -52,4 +47,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +53,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LoadInstruction.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,4 +27,2 @@\n- * Represents a local variable within a method. It contains its\n- * scope, name and type. The generated LocalVariable object can be obtained\n- * with getLocalVariable which needs the instruction list and the constant\n- * pool as parameters.\n+ * Represents a local variable within a method. It contains its scope, name and type. The generated LocalVariable object\n+ * can be obtained with getLocalVariable which needs the instruction list and the constant pool as parameters.\n@@ -32,2 +30,2 @@\n- * @see     LocalVariable\n- * @see     MethodGen\n+ * @see LocalVariable\n+ * @see MethodGen\n@@ -45,1 +43,0 @@\n-\n@@ -47,2 +44,2 @@\n-     * Generate a local variable that with index `index'. Note that double and long\n-     * variables need two indexs. Index indices have to be provided by the user.\n+     * Generate a local variable that with index 'index'. Note that double and long variables need two indexs. Index indices\n+     * have to be provided by the user.\n@@ -56,4 +53,3 @@\n-    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,\n-            final InstructionHandle end) {\n-        if ((index < 0) || (index > Const.MAX_SHORT)) {\n-            throw new ClassGenException(\"Invalid index index: \" + index);\n+    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n+        if (index < 0 || index > Const.MAX_SHORT) {\n+            throw new ClassGenException(\"Invalid index: \" + index);\n@@ -70,1 +66,0 @@\n-\n@@ -72,2 +67,2 @@\n-     * Generates a local variable that with index `index'. Note that double and long\n-     * variables need two indexs. Index indices have to be provided by the user.\n+     * Generates a local variable that with index 'index'. Note that double and long variables need two indexs. Index\n+     * indices have to be provided by the user.\n@@ -82,2 +77,2 @@\n-    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,\n-            final InstructionHandle end, final int origIndex) {\n+    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start, final InstructionHandle end,\n+        final int origIndex) {\n@@ -88,0 +83,8 @@\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n+    }\n@@ -90,12 +93,1 @@\n-     * Gets LocalVariable object.\n-     *\n-     * This relies on that the instruction list has already been dumped to byte code or\n-     * or that the `setPositions' methods has been called for the instruction list.\n-     *\n-     * Note that due to the conversion from byte code offset to InstructionHandle,\n-     * it is impossible to tell the difference between a live range that ends BEFORE\n-     * the last insturction of the method or a live range that ends AFTER the last\n-     * instruction of the method.  Hence the liveToEnd flag to differentiate\n-     * between these two cases.\n-     *\n-     * @param cp constant pool\n+     * @return true, if ih is target of this variable\n@@ -103,14 +95,3 @@\n-    public LocalVariable getLocalVariable( final ConstantPoolGen cp ) {\n-        int start_pc = 0;\n-        int length = 0;\n-        if ((start != null) && (end != null)) {\n-            start_pc = start.getPosition();\n-            length = end.getPosition() - start_pc;\n-            if ((end.getNext() == null) && liveToEnd) {\n-                length += end.getInstruction().getLength();\n-            }\n-        }\n-        final int name_index = cp.addUtf8(name);\n-        final int signature_index = cp.addUtf8(type.getSignature());\n-        return new LocalVariable(start_pc, length, name_index, signature_index, index, cp\n-                .getConstantPool(), origIndex);\n+    @Override\n+    public boolean containsTarget(final InstructionHandle ih) {\n+        return start == ih || end == ih;\n@@ -119,3 +100,6 @@\n-\n-    public void setIndex( final int index ) {\n-        this.index = index;\n+    \/**\n+     * Clear the references from and to this variable when it's removed.\n+     *\/\n+    void dispose() {\n+        setStart(null);\n+        setEnd(null);\n@@ -124,3 +108,10 @@\n-\n-    public int getIndex() {\n-        return index;\n+    \/**\n+     * We consider to local variables to be equal, if the use the same index and are valid in the same range.\n+     *\/\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (!(o instanceof LocalVariableGen)) {\n+            return false;\n+        }\n+        final LocalVariableGen l = (LocalVariableGen) o;\n+        return l.index == index && l.start == start && l.end == end;\n@@ -129,3 +120,2 @@\n-\n-    public int getOrigIndex() {\n-        return origIndex;\n+    public InstructionHandle getEnd() {\n+        return end;\n@@ -134,3 +124,2 @@\n-\n-    public void setLiveToEnd( final boolean live_to_end) {\n-        this.liveToEnd = live_to_end;\n+    public int getIndex() {\n+        return index;\n@@ -139,1 +128,0 @@\n-\n@@ -144,4 +132,25 @@\n-\n-    @Override\n-    public void setName( final String name ) {\n-        this.name = name;\n+    \/**\n+     * Gets LocalVariable object.\n+     *\n+     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n+     * has been called for the instruction list.\n+     *\n+     * Note that due to the conversion from byte code offset to InstructionHandle, it is impossible to tell the difference\n+     * between a live range that ends BEFORE the last insturction of the method or a live range that ends AFTER the last\n+     * instruction of the method. Hence the liveToEnd flag to differentiate between these two cases.\n+     *\n+     * @param cp constant pool\n+     *\/\n+    public LocalVariable getLocalVariable(final ConstantPoolGen cp) {\n+        int startPc = 0;\n+        int length = 0;\n+        if (start != null && end != null) {\n+            startPc = start.getPosition();\n+            length = end.getPosition() - startPc;\n+            if (end.getNext() == null && liveToEnd) {\n+                length += end.getInstruction().getLength();\n+            }\n+        }\n+        final int nameIndex = cp.addUtf8(name);\n+        final int signatureIndex = cp.addUtf8(type.getSignature());\n+        return new LocalVariable(startPc, length, nameIndex, signatureIndex, index, cp.getConstantPool(), origIndex);\n@@ -150,1 +159,0 @@\n-\n@@ -156,10 +164,2 @@\n-\n-    @Override\n-    public void setType( final Type type ) {\n-        this.type = type;\n-    }\n-\n-\n-    @Override\n-    public Type getType() {\n-        return type;\n+    public int getOrigIndex() {\n+        return origIndex;\n@@ -168,1 +168,0 @@\n-\n@@ -173,3 +172,3 @@\n-\n-    public InstructionHandle getEnd() {\n-        return end;\n+    @Override\n+    public Type getType() {\n+        return type;\n@@ -178,4 +177,5 @@\n-\n-    public void setStart( final InstructionHandle start ) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.start, start, this);\n-        this.start = start;\n+    @Override\n+    public int hashCode() {\n+        \/\/ If the user changes the name or type, problems with the targeter hashmap will occur.\n+        \/\/ Note: index cannot be part of hash as it may be changed by the user.\n+        return name.hashCode() ^ type.hashCode();\n@@ -184,2 +184,1 @@\n-\n-    public void setEnd( final InstructionHandle end ) { \/\/ TODO could be package-protected?\n+    public void setEnd(final InstructionHandle end) { \/\/ TODO could be package-protected?\n@@ -190,20 +189,2 @@\n-\n-    \/**\n-     * @param old_ih old target, either start or end\n-     * @param new_ih new target\n-     *\/\n-    @Override\n-    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n-        boolean targeted = false;\n-        if (start == old_ih) {\n-            targeted = true;\n-            setStart(new_ih);\n-        }\n-        if (end == old_ih) {\n-            targeted = true;\n-            setEnd(new_ih);\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + old_ih + \", but {\" + start + \", \" + end\n-                    + \"}\");\n-        }\n+    public void setIndex(final int index) {\n+        this.index = index;\n@@ -212,6 +193,2 @@\n-    \/**\n-     * Clear the references from and to this variable when it's removed.\n-     *\/\n-    void dispose() {\n-        setStart(null);\n-        setEnd(null);\n+    public void setLiveToEnd(final boolean liveToEnd) {\n+        this.liveToEnd = liveToEnd;\n@@ -220,3 +197,0 @@\n-    \/**\n-     * @return true, if ih is target of this variable\n-     *\/\n@@ -224,2 +198,2 @@\n-    public boolean containsTarget( final InstructionHandle ih ) {\n-        return (start == ih) || (end == ih);\n+    public void setName(final String name) {\n+        this.name = name;\n@@ -228,6 +202,3 @@\n-\n-    @Override\n-    public int hashCode() {\n-        \/\/ If the user changes the name or type, problems with the targeter hashmap will occur.\n-        \/\/ Note: index cannot be part of hash as it may be changed by the user.\n-        return name.hashCode() ^ type.hashCode();\n+    public void setStart(final InstructionHandle start) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.start, start, this);\n+        this.start = start;\n@@ -236,5 +207,0 @@\n-\n-    \/**\n-     * We consider to local variables to be equal, if the use the same index and\n-     * are valid in the same range.\n-     *\/\n@@ -242,6 +208,2 @@\n-    public boolean equals( final Object o ) {\n-        if (!(o instanceof LocalVariableGen)) {\n-            return false;\n-        }\n-        final LocalVariableGen l = (LocalVariableGen) o;\n-        return (l.index == index) && (l.start == start) && (l.end == end);\n+    public void setType(final Type type) {\n+        this.type = type;\n@@ -250,1 +212,0 @@\n-\n@@ -256,1 +217,4 @@\n-\n+    \/**\n+     * @param oldIh old target, either start or end\n+     * @param newIh new target\n+     *\/\n@@ -258,5 +222,12 @@\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n+        boolean targeted = false;\n+        if (start == oldIh) {\n+            targeted = true;\n+            setStart(newIh);\n+        }\n+        if (end == oldIh) {\n+            targeted = true;\n+            setEnd(newIh);\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + oldIh + \", but {\" + start + \", \" + end + \"}\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableGen.java","additions":108,"deletions":137,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -33,2 +33,7 @@\n-public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction,\n-        IndexedInstruction {\n+public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction, IndexedInstruction {\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int n = -1; \/\/ index of referenced variable\n@@ -36,1 +41,0 @@\n-    private int n = -1; \/\/ index of referenced variable\n@@ -40,6 +44,0 @@\n-\n-    private boolean wide() {\n-        return n > Const.MAX_BYTE;\n-    }\n-\n-\n@@ -47,3 +45,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n-     * tag and length are defined in readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction. Also used by IINC()!\n@@ -51,4 +47,1 @@\n-    LocalVariableInstruction(final short canon_tag, final short c_tag) {\n-        super();\n-        this.canonTag = canon_tag;\n-        this.cTag = c_tag;\n+    LocalVariableInstruction() {\n@@ -57,1 +50,0 @@\n-\n@@ -59,2 +51,2 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Also used by IINC()!\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n+     * readInstruction and initFromFile, respectively.\n@@ -62,1 +54,3 @@\n-    LocalVariableInstruction() {\n+    LocalVariableInstruction(final short canonTag, final short cTag) {\n+        this.canonTag = canonTag;\n+        this.cTag = cTag;\n@@ -65,1 +59,0 @@\n-\n@@ -78,1 +71,0 @@\n-\n@@ -81,0 +73,1 @@\n+     *\n@@ -84,1 +77,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -98,0 +91,6 @@\n+    \/**\n+     * @return canonical tag for instruction, e.g., ALOAD for ALOAD_0\n+     *\/\n+    public short getCanonicalTag() {\n+        return canonTag;\n+    }\n@@ -100,4 +99,11 @@\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n-     * \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; local variable index&gt;\"&gt;\"\n+     * @return local variable index (n) referred by this instruction.\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return n;\n+    }\n+\n+    \/**\n+     * Returns the type associated with the instruction - in case of ALOAD or ASTORE Type.OBJECT is returned. This is just a\n+     * bit incorrect, because ALOAD and ASTORE may work on every ReferenceType (including Type.NULL) and ASTORE may even\n+     * work on a ReturnaddressType .\n@@ -105,2 +111,1 @@\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * @return type associated with the instruction\n@@ -109,5 +114,19 @@\n-    public String toString( final boolean verbose ) {\n-        final short _opcode = super.getOpcode();\n-        if (((_opcode >= Const.ILOAD_0) && (_opcode <= Const.ALOAD_3))\n-         || ((_opcode >= Const.ISTORE_0) && (_opcode <= Const.ASTORE_3))) {\n-            return super.toString(verbose);\n+    public Type getType(final ConstantPoolGen cp) {\n+        switch (canonTag) {\n+        case Const.ILOAD:\n+        case Const.ISTORE:\n+            return Type.INT;\n+        case Const.LLOAD:\n+        case Const.LSTORE:\n+            return Type.LONG;\n+        case Const.DLOAD:\n+        case Const.DSTORE:\n+            return Type.DOUBLE;\n+        case Const.FLOAD:\n+        case Const.FSTORE:\n+            return Type.FLOAT;\n+        case Const.ALOAD:\n+        case Const.ASTORE:\n+            return Type.OBJECT;\n+        default:\n+            throw new ClassGenException(\"Unknown case in switch\" + canonTag);\n@@ -115,1 +134,0 @@\n-        return super.toString(verbose) + \" \" + n;\n@@ -118,1 +136,0 @@\n-\n@@ -121,0 +138,1 @@\n+     *\n@@ -126,1 +144,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -131,3 +149,2 @@\n-            final short _opcode = super.getOpcode();\n-            if (((_opcode >= Const.ILOAD) && (_opcode <= Const.ALOAD))\n-             || ((_opcode >= Const.ISTORE) && (_opcode <= Const.ASTORE))) {\n+            final short opcode = super.getOpcode();\n+            if (opcode >= Const.ILOAD && opcode <= Const.ALOAD || opcode >= Const.ISTORE && opcode <= Const.ASTORE) {\n@@ -136,5 +153,6 @@\n-            } else if (_opcode <= Const.ALOAD_3) { \/\/ compact load instruction such as ILOAD_2\n-                n = (_opcode - Const.ILOAD_0) % 4;\n-                super.setLength(1);\n-            } else { \/\/ Assert ISTORE_0 <= tag <= ASTORE_3\n-                n = (_opcode - Const.ISTORE_0) % 4;\n+            } else {\n+                if (opcode <= Const.ALOAD_3) { \/\/ compact load instruction such as ILOAD_2\n+                    n = (opcode - Const.ILOAD_0) % 4;\n+                } else { \/\/ Assert ISTORE_0 <= tag <= ASTORE_3\n+                    n = (opcode - Const.ISTORE_0) % 4;\n+                }\n@@ -146,10 +164,0 @@\n-\n-    \/**\n-     * @return local variable index (n) referred by this instruction.\n-     *\/\n-    @Override\n-    public final int getIndex() {\n-        return n;\n-    }\n-\n-\n@@ -157,3 +165,2 @@\n-     * Set the local variable index.\n-     * also updates opcode and length\n-     * TODO Why?\n+     * Set the local variable index. also updates opcode and length TODO Why?\n+     *\n@@ -163,2 +170,2 @@\n-    public void setIndex( final int n ) { \/\/ TODO could be package-protected?\n-        if ((n < 0) || (n > Const.MAX_SHORT)) {\n+    public void setIndex(final int n) { \/\/ TODO could be package-protected?\n+        if (n < 0 || n > Const.MAX_SHORT) {\n@@ -182,2 +189,5 @@\n-\n-    \/** @return canonical tag for instruction, e.g., ALOAD for ALOAD_0\n+    \/**\n+     * Sets the index of the referenced variable (n) only\n+     *\n+     * @since 6.0\n+     * @see #setIndex(int)\n@@ -185,2 +195,2 @@\n-    public short getCanonicalTag() {\n-        return canonTag;\n+    final void setIndexOnly(final int n) {\n+        this.n = n;\n@@ -189,1 +199,0 @@\n-\n@@ -191,6 +200,7 @@\n-     * Returns the type associated with the instruction -\n-     * in case of ALOAD or ASTORE Type.OBJECT is returned.\n-     * This is just a bit incorrect, because ALOAD and ASTORE\n-     * may work on every ReferenceType (including Type.NULL) and\n-     * ASTORE may even work on a ReturnaddressType .\n-     * @return type associated with the instruction\n+     * Long output format:\n+     *\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; local variable\n+     * index&gt;\"&gt;\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -199,19 +209,4 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n-        switch (canonTag) {\n-            case Const.ILOAD:\n-            case Const.ISTORE:\n-                return Type.INT;\n-            case Const.LLOAD:\n-            case Const.LSTORE:\n-                return Type.LONG;\n-            case Const.DLOAD:\n-            case Const.DSTORE:\n-                return Type.DOUBLE;\n-            case Const.FLOAD:\n-            case Const.FSTORE:\n-                return Type.FLOAT;\n-            case Const.ALOAD:\n-            case Const.ASTORE:\n-                return Type.OBJECT;\n-            default:\n-                throw new ClassGenException(\"Unknown case in switch\" + canonTag);\n+    public String toString(final boolean verbose) {\n+        final short opcode = super.getOpcode();\n+        if (opcode >= Const.ILOAD_0 && opcode <= Const.ALOAD_3 || opcode >= Const.ISTORE_0 && opcode <= Const.ASTORE_3) {\n+            return super.toString(verbose);\n@@ -219,0 +214,1 @@\n+        return super.toString(verbose) + \" \" + n;\n@@ -221,7 +217,2 @@\n-    \/**\n-     * Sets the index of the referenced variable (n) only\n-     * @since 6.0\n-     * @see #setIndex(int)\n-     *\/\n-    final void setIndexOnly(final int n) {\n-        this.n = n;\n+    private boolean wide() {\n+        return n > Const.MAX_BYTE;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableInstruction.java","additions":88,"deletions":97,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * <PRE>Stack: ..., objectref -&gt; ...<\/PRE>\n@@ -29,0 +28,3 @@\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; ...\n+ * <\/PRE>\n@@ -37,9 +39,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.NULL_POINTER_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -47,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -55,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -60,0 +51,5 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MONITORENTER.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n- * <PRE>Stack: ..., objectref -&gt; ...<\/PRE>\n@@ -29,0 +28,3 @@\n+ * <PRE>\n+ * Stack: ..., objectref -&gt; ...\n+ * <\/PRE>\n@@ -37,9 +39,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.NULL_POINTER_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -47,4 +40,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -55,1 +46,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -60,0 +51,5 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MONITOREXIT.java","additions":11,"deletions":15,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n- * <PRE>Stack: ..., count1, [count2, ...] -&gt; ..., arrayref<\/PRE>\n@@ -35,0 +34,3 @@\n+ * <PRE>\n+ * Stack: ..., count1, [count2, ...] -&gt; ..., arrayref\n+ * <\/PRE>\n@@ -36,2 +38,1 @@\n-public class MULTIANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction,\n-        ExceptionThrower {\n+public class MULTIANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower {\n@@ -41,1 +42,0 @@\n-\n@@ -43,2 +43,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -49,1 +48,0 @@\n-\n@@ -59,1 +57,0 @@\n-\n@@ -61,2 +58,4 @@\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -65,4 +64,7 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-        out.writeByte(dimensions);\n+    public void accept(final Visitor v) {\n+        v.visitLoadClass(this);\n+        v.visitAllocationInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitCPInstruction(this);\n+        v.visitMULTIANEWARRAY(this);\n@@ -71,1 +73,0 @@\n-\n@@ -73,1 +74,3 @@\n-     * Read needed data (i.e., no. dimension) from file.\n+     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n+     *\n+     * @return Number of words consumed from stack by this instruction\n@@ -76,11 +79,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n-        super.initFromFile(bytes, wide);\n-        dimensions = bytes.readByte();\n-        super.setLength(4);\n-    }\n-\n-\n-    \/**\n-     * @return number of dimensions to be created\n-     *\/\n-    public final short getDimensions() {\n+    public int consumeStack(final ConstantPoolGen cpg) {\n@@ -90,10 +83,0 @@\n-\n-    \/**\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString( final boolean verbose ) {\n-        return super.toString(verbose) + \" \" + super.getIndex() + \" \" + dimensions;\n-    }\n-\n-\n@@ -101,1 +84,3 @@\n-     * @return mnemonic for instruction with symbolic references resolved\n+     * Dump instruction as byte code to stream out.\n+     *\n+     * @param out Output stream\n@@ -104,2 +89,4 @@\n-    public String toString( final ConstantPool cp ) {\n-        return super.toString(cp) + \" \" + dimensions;\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+        out.writeByte(dimensions);\n@@ -108,1 +95,0 @@\n-\n@@ -110,3 +96,1 @@\n-     * Also works for instructions whose stack effect depends on the\n-     * constant pool entry they reference.\n-     * @return Number of words consumed from stack by this instruction\n+     * @return number of dimensions to be created\n@@ -114,2 +98,1 @@\n-    @Override\n-    public int consumeStack( final ConstantPoolGen cpg ) {\n+    public final short getDimensions() {\n@@ -119,1 +102,0 @@\n-\n@@ -122,2 +104,1 @@\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n-            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.ILLEGAL_ACCESS_ERROR,\n@@ -127,1 +108,0 @@\n-\n@@ -129,1 +109,1 @@\n-    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n@@ -134,1 +114,1 @@\n-        return (t instanceof ObjectType) ? (ObjectType) t : null;\n+        return t instanceof ObjectType ? (ObjectType) t : null;\n@@ -137,0 +117,9 @@\n+    \/**\n+     * Read needed data (i.e., no. dimension) from file.\n+     *\/\n+    @Override\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+        super.initFromFile(bytes, wide);\n+        dimensions = bytes.readByte();\n+        super.setLength(4);\n+    }\n@@ -139,6 +128,1 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * @return mnemonic for instruction\n@@ -147,7 +131,10 @@\n-    public void accept( final Visitor v ) {\n-        v.visitLoadClass(this);\n-        v.visitAllocationInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitCPInstruction(this);\n-        v.visitMULTIANEWARRAY(this);\n+    public String toString(final boolean verbose) {\n+        return super.toString(verbose) + \" \" + super.getIndex() + \" \" + dimensions;\n+    }\n+\n+    \/**\n+     * @return mnemonic for instruction with symbolic references resolved\n+     *\/\n+    @Override\n+    public String toString(final ConstantPool cp) {\n+        return super.toString(cp) + \" \" + dimensions;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MULTIANEWARRAY.java","additions":52,"deletions":65,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,0 +22,9 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Stack;\n+\n@@ -40,7 +49,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Stack;\n@@ -49,4 +51,3 @@\n- * Template class for building up a method. This is done by defining exception\n- * handlers, adding thrown exceptions, local variables and attributes, whereas\n- * the `LocalVariableTable' and `LineNumberTable' attributes will be set\n- * automatically for the code. Use stripAttributes() if you don't like this.\n+ * Template class for building up a method. This is done by defining exception handlers, adding thrown exceptions, local\n+ * variables and attributes, whereas the 'LocalVariableTable' and 'LineNumberTable' attributes will be set automatically\n+ * for the code. Use stripAttributes() if you don't like this.\n@@ -54,3 +55,2 @@\n- * While generating code it may be necessary to insert NOP operations. You can\n- * use the `removeNOPs' method to get rid off them.\n- * The resulting method object can be obtained via the `getMethod()' method.\n+ * While generating code it may be necessary to insert NOP operations. You can use the 'removeNOPs' method to get rid\n+ * off them. The resulting method object can be obtained via the 'getMethod()' method.\n@@ -58,3 +58,3 @@\n- * @see     InstructionList\n- * @see     Method\n- * @LastModified: May 2021\n+ * @see InstructionList\n+ * @see Method\n+ * @LastModified: Feb 2023\n@@ -64,0 +64,151 @@\n+    static final class BranchStack {\n+\n+        private final Stack<BranchTarget> branchTargets = new Stack<>();\n+        private final HashMap<InstructionHandle, BranchTarget> visitedTargets = new HashMap<>();\n+\n+        public BranchTarget pop() {\n+            if (!branchTargets.empty()) {\n+                return branchTargets.pop();\n+            }\n+            return null;\n+        }\n+\n+        public void push(final InstructionHandle target, final int stackDepth) {\n+            if (visited(target)) {\n+                return;\n+            }\n+            branchTargets.push(visit(target, stackDepth));\n+        }\n+\n+        private BranchTarget visit(final InstructionHandle target, final int stackDepth) {\n+            final BranchTarget bt = new BranchTarget(target, stackDepth);\n+            visitedTargets.put(target, bt);\n+            return bt;\n+        }\n+\n+        private boolean visited(final InstructionHandle target) {\n+            return visitedTargets.get(target) != null;\n+        }\n+    }\n+\n+    static final class BranchTarget {\n+\n+        final InstructionHandle target;\n+        final int stackDepth;\n+\n+        BranchTarget(final InstructionHandle target, final int stackDepth) {\n+            this.target = target;\n+            this.stackDepth = stackDepth;\n+        }\n+    }\n+\n+    private static BCELComparator bcelComparator = new BCELComparator() {\n+\n+        @Override\n+        public boolean equals(final Object o1, final Object o2) {\n+            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o1;\n+            final FieldGenOrMethodGen THAT = (FieldGenOrMethodGen) o2;\n+            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+        }\n+\n+        @Override\n+        public int hashCode(final Object o) {\n+            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o;\n+            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n+        }\n+    };\n+\n+    private static byte[] getByteCodes(final Method method) {\n+        final Code code = method.getCode();\n+        if (code == null) {\n+            throw new IllegalStateException(String.format(\"The method '%s' has no code.\", method));\n+        }\n+        return code.getCode();\n+    }\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+    \/**\n+     * Computes stack usage of an instruction list by performing control flow analysis.\n+     *\n+     * @return maximum stack depth used by method\n+     *\/\n+    public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et) {\n+        final BranchStack branchTargets = new BranchStack();\n+        \/*\n+         * Initially, populate the branch stack with the exception handlers, because these aren't (necessarily) branched to\n+         * explicitly. in each case, the stack will have depth 1, containing the exception object.\n+         *\/\n+        for (final CodeExceptionGen element : et) {\n+            final InstructionHandle handlerPc = element.getHandlerPC();\n+            if (handlerPc != null) {\n+                branchTargets.push(handlerPc, 1);\n+            }\n+        }\n+        int stackDepth = 0;\n+        int maxStackDepth = 0;\n+        InstructionHandle ih = il.getStart();\n+        while (ih != null) {\n+            final Instruction instruction = ih.getInstruction();\n+            final short opcode = instruction.getOpcode();\n+            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n+            stackDepth += delta;\n+            if (stackDepth > maxStackDepth) {\n+                maxStackDepth = stackDepth;\n+            }\n+            \/\/ choose the next instruction based on whether current is a branch.\n+            if (instruction instanceof BranchInstruction) {\n+                final BranchInstruction branch = (BranchInstruction) instruction;\n+                if (instruction instanceof Select) {\n+                    \/\/ explore all of the select's targets. the default target is handled below.\n+                    final Select select = (Select) branch;\n+                    final InstructionHandle[] targets = select.getTargets();\n+                    for (final InstructionHandle target : targets) {\n+                        branchTargets.push(target, stackDepth);\n+                    }\n+                    \/\/ nothing to fall through to.\n+                    ih = null;\n+                } else if (!(branch instanceof IfInstruction)) {\n+                    \/\/ if an instruction that comes back to following PC,\n+                    \/\/ push next instruction, with stack depth reduced by 1.\n+                    if (opcode == Const.JSR || opcode == Const.JSR_W) {\n+                        branchTargets.push(ih.getNext(), stackDepth - 1);\n+                    }\n+                    ih = null;\n+                }\n+                \/\/ for all branches, the target of the branch is pushed on the branch stack.\n+                \/\/ conditional branches have a fall through case, selects don't, and\n+                \/\/ jsr\/jsr_w return to the next instruction.\n+                branchTargets.push(branch.getTarget(), stackDepth);\n+            } else \/\/ check for instructions that terminate the method.\n+            if (opcode == Const.ATHROW || opcode == Const.RET || opcode >= Const.IRETURN && opcode <= Const.RETURN) {\n+                ih = null;\n+            }\n+            \/\/ normal case, go to the next instruction.\n+            if (ih != null) {\n+                ih = ih.getNext();\n+            }\n+            \/\/ if we have no more instructions, see if there are any deferred branches to explore.\n+            if (ih == null) {\n+                final BranchTarget bt = branchTargets.pop();\n+                if (bt != null) {\n+                    ih = bt.target;\n+                    stackDepth = bt.stackDepth;\n+                }\n+            }\n+        }\n+        return maxStackDepth;\n+    }\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator(final BCELComparator comparator) {\n+        bcelComparator = comparator;\n+    }\n+\n@@ -70,0 +221,1 @@\n+\n@@ -71,1 +223,1 @@\n-    private LocalVariableTypeTable localVariableTypeTable = null;\n+    private LocalVariableTypeTable localVariableTypeTable;\n@@ -73,0 +225,1 @@\n+\n@@ -74,0 +227,1 @@\n+\n@@ -75,0 +229,1 @@\n+\n@@ -76,0 +231,1 @@\n+\n@@ -79,12 +235,0 @@\n-    private boolean hasParameterAnnotations = false;\n-    private boolean haveUnpackedParameterAnnotations = false;\n-\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n-\n-        @Override\n-        public boolean equals( final Object o1, final Object o2 ) {\n-            final MethodGen THIS = (MethodGen) o1;\n-            final MethodGen THAT = (MethodGen) o2;\n-            return Objects.equals(THIS.getName(), THAT.getName())\n-                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n-        }\n@@ -92,0 +236,1 @@\n+    private boolean hasParameterAnnotations;\n@@ -93,6 +238,1 @@\n-        @Override\n-        public int hashCode( final Object o ) {\n-            final MethodGen THIS = (MethodGen) o;\n-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n-        }\n-    };\n+    private boolean haveUnpackedParameterAnnotations;\n@@ -100,0 +240,1 @@\n+    private List<MethodObserver> observers;\n@@ -102,5 +243,3 @@\n-     * Declare method. If the method is non-static the constructor\n-     * automatically declares a local variable `$this' in slot 0. The\n-     * actual code is contained in the `il' parameter, which may further\n-     * manipulated by the user. But he must take care not to remove any\n-     * instruction (handles) that are still referenced from this object.\n+     * Declare method. If the method is non-static the constructor automatically declares a local variable '$this' in slot\n+     * 0. The actual code is contained in the 'il' parameter, which may further manipulated by the user. But they must take\n+     * care not to remove any instruction (handles) that are still referenced from this object.\n@@ -108,3 +247,2 @@\n-     * For example one may not add a local variable and later remove the\n-     * instructions it refers to without causing havoc. It is safe\n-     * however if you remove that local variable, too.\n+     * For example one may not add a local variable and later remove the instructions it refers to without causing havoc. It\n+     * is safe however if you remove that local variable, too.\n@@ -112,2 +250,2 @@\n-     * @param access_flags access qualifiers\n-     * @param return_type  method type\n+     * @param accessFlags access qualifiers\n+     * @param returnType method type\n@@ -115,3 +253,2 @@\n-     * @param argNames argument names (if this is null, default names will be provided\n-     * for them)\n-     * @param method_name name of method\n+     * @param argNames argument names (if this is null, default names will be provided for them)\n+     * @param methodName name of method\n@@ -119,2 +256,1 @@\n-     * @param il instruction list associated with this method, may be null only for\n-     * abstract or native methods\n+     * @param il instruction list associated with this method, may be null only for abstract or native methods\n@@ -123,4 +259,4 @@\n-    public MethodGen(final int access_flags, final Type return_type, final Type[] argTypes, String[] argNames,\n-            final String method_name, final String className, final InstructionList il, final ConstantPoolGen cp) {\n-        super(access_flags);\n-        setType(return_type);\n+    public MethodGen(final int accessFlags, final Type returnType, final Type[] argTypes, String[] argNames, final String methodName, final String className,\n+        final InstructionList il, final ConstantPoolGen cp) {\n+        super(accessFlags);\n+        setType(returnType);\n@@ -129,1 +265,1 @@\n-        setName(method_name);\n+        setName(methodName);\n@@ -139,1 +275,2 @@\n-            \/* Add local variables, namely the implicit `this' and the arguments\n+            \/*\n+             * Add local variables, namely the implicit 'this' and the arguments\n@@ -141,2 +278,2 @@\n-            if (!isStatic() && (className != null)) { \/\/ Instance method -> `this' is local var 0\n-                addLocalVariable(\"this\",  ObjectType.getInstance(className), start, end);\n+            if (!isStatic() && className != null) { \/\/ Instance method -> 'this' is local var 0\n+                addLocalVariable(\"this\", ObjectType.getInstance(className), start, end);\n@@ -147,2 +284,2 @@\n-            for (final Type arg_type : argTypes) {\n-                if (Type.VOID == arg_type) {\n+            for (final Type argType : argTypes) {\n+                if (Type.VOID == argType) {\n@@ -154,2 +291,1 @@\n-                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size\n-                            + \" vs. \" + argNames.length);\n+                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size + \" vs. \" + argNames.length);\n@@ -172,1 +308,0 @@\n-\n@@ -181,2 +316,2 @@\n-        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()),\n-            Type.getArgumentTypes(method.getSignature()), null \/* may be overridden anyway *\/\n+        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()), Type.getArgumentTypes(method.getSignature()),\n+            null \/* may be overridden anyway *\/\n@@ -184,4 +319,1 @@\n-            ((method.getAccessFlags() & (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)\n-                ? new InstructionList(getByteCodes(method))\n-                : null,\n-            cp);\n+            (method.getAccessFlags() & (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0 ? new InstructionList(getByteCodes(method)) : null, cp);\n@@ -199,1 +331,1 @@\n-                        ObjectType c_type = null;\n+                        ObjectType cType = null;\n@@ -201,3 +333,2 @@\n-                            final String cen = method.getConstantPool().getConstantString(type,\n-                                    Const.CONSTANT_Class);\n-                            c_type =  ObjectType.getInstance(cen);\n+                            final String cen = method.getConstantPool().getConstantString(type, Const.CONSTANT_Class);\n+                            cType = ObjectType.getInstance(cen);\n@@ -205,1 +336,1 @@\n-                        final int end_pc = ce.getEndPC();\n+                        final int endPc = ce.getEndPC();\n@@ -208,1 +339,1 @@\n-                        if (length == end_pc) { \/\/ May happen, because end_pc is exclusive\n+                        if (length == endPc) { \/\/ May happen, because end_pc is exclusive\n@@ -211,1 +342,1 @@\n-                            end = il.findHandle(end_pc);\n+                            end = il.findHandle(endPc);\n@@ -214,2 +345,1 @@\n-                        addExceptionHandler(il.findHandle(ce.getStartPC()), end,\n-                                il.findHandle(ce.getHandlerPC()), c_type);\n+                        addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce.getHandlerPC()), cType);\n@@ -218,3 +348,3 @@\n-                final Attribute[] c_attributes = c.getAttributes();\n-                for (final Attribute c_attribute : c_attributes) {\n-                    a = c_attribute;\n+                final Attribute[] cAttributes = c.getAttributes();\n+                for (final Attribute cAttribute : cAttributes) {\n+                    a = cAttribute;\n@@ -222,2 +352,1 @@\n-                        final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();\n-                        for (final LineNumber l : ln) {\n+                        ((LineNumberTable) a).forEach(l -> {\n@@ -228,1 +357,1 @@\n-                        }\n+                        });\n@@ -238,4 +367,1 @@\n-                final String[] names = ((ExceptionTable) a).getExceptionNames();\n-                for (final String name2 : names) {\n-                    addException(name2);\n-                }\n+                Collections.addAll(throwsList, ((ExceptionTable) a).getExceptionNames());\n@@ -244,4 +370,1 @@\n-                final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();\n-                for (final AnnotationEntry element : aes) {\n-                    addAnnotationEntry(new AnnotationEntryGen(element, cp, false));\n-                }\n+                runtimeAnnotations.forEach(element -> addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n@@ -254,0 +377,6 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        addAll(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries()));\n+    }\n@@ -255,4 +384,34 @@\n-    private static byte[] getByteCodes(final Method method) {\n-        final Code code = method.getCode();\n-        if (code == null) {\n-            throw new IllegalStateException(String.format(\"The method '%s' has no code.\", method));\n+    \/**\n+     * Add an attribute to the code. Currently, the JVM knows about the LineNumberTable, LocalVariableTable and StackMap\n+     * attributes, where the former two will be generated automatically and the latter is used for the MIDP only. Other\n+     * attributes will be ignored by the JVM but do no harm.\n+     *\n+     * @param a attribute to be added\n+     *\/\n+    public void addCodeAttribute(final Attribute a) {\n+        codeAttrsList.add(a);\n+    }\n+\n+    \/**\n+     * Add an exception possibly thrown by this method.\n+     *\n+     * @param className (fully qualified) name of exception\n+     *\/\n+    public void addException(final String className) {\n+        throwsList.add(className);\n+    }\n+\n+    \/**\n+     * Add an exception handler, i.e., specify region where a handler is active and an instruction where the actual handling\n+     * is done.\n+     *\n+     * @param startPc Start of region (inclusive)\n+     * @param endPc End of region (inclusive)\n+     * @param handlerPc Where handling is done\n+     * @param catchType class type of handled exception or null if any exception is handled\n+     * @return new exception handler object\n+     *\/\n+    public CodeExceptionGen addExceptionHandler(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc,\n+        final ObjectType catchType) {\n+        if (startPc == null || endPc == null || handlerPc == null) {\n+            throw new ClassGenException(\"Exception handler target is null instruction\");\n@@ -260,1 +419,3 @@\n-        return code.getCode();\n+        final CodeExceptionGen c = new CodeExceptionGen(startPc, endPc, handlerPc, catchType);\n+        exceptionList.add(c);\n+        return c;\n@@ -264,1 +425,14 @@\n-     * Adds a local variable to this method.\n+     * Give an instruction a line number corresponding to the source code line.\n+     *\n+     * @param ih instruction to tag\n+     * @return new line number object\n+     * @see LineNumber\n+     *\/\n+    public LineNumberGen addLineNumber(final InstructionHandle ih, final int srcLine) {\n+        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n+        lineNumberList.add(l);\n+        return l;\n+    }\n+\n+    \/**\n+     * Adds a local variable to this method and assigns an index automatically.\n@@ -268,5 +442,2 @@\n-     * @param slot the index of the local variable, if type is long or double, the next available\n-     * index is slot+2\n-     * @param start from where the variable is valid\n-     * @param end until where the variable is valid\n-     * @param orig_index the index of the local variable prior to any modifications\n+     * @param start from where the variable is valid, if this is null, it is valid from the start\n+     * @param end until where the variable is valid, if this is null, it is valid to the end\n@@ -276,19 +447,2 @@\n-    public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,\n-            final InstructionHandle start, final InstructionHandle end, final int orig_index ) {\n-        final byte t = type.getType();\n-        if (t != Const.T_ADDRESS) {\n-            final int add = type.getSize();\n-            if (slot + add > maxLocals) {\n-                maxLocals = slot + add;\n-            }\n-            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);\n-            int i;\n-            if ((i = variableList.indexOf(l)) >= 0) {\n-                variableList.set(i, l);\n-            } else {\n-                variableList.add(l);\n-            }\n-            return l;\n-        }\n-        throw new IllegalArgumentException(\"Can not use \" + type\n-                + \" as type for local variable\");\n+    public LocalVariableGen addLocalVariable(final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n+        return addLocalVariable(name, type, maxLocals, start, end);\n@@ -297,1 +451,0 @@\n-\n@@ -303,2 +456,1 @@\n-     * @param slot the index of the local variable, if type is long or double, the next available\n-     * index is slot+2\n+     * @param slot the index of the local variable, if type is long or double, the next available index is slot+2\n@@ -310,2 +462,1 @@\n-    public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,\n-            final InstructionHandle start, final InstructionHandle end ) {\n+    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end) {\n@@ -316,1 +467,1 @@\n-     * Adds a local variable to this method and assigns an index automatically.\n+     * Adds a local variable to this method.\n@@ -320,4 +471,4 @@\n-     * @param start from where the variable is valid, if this is null,\n-     * it is valid from the start\n-     * @param end until where the variable is valid, if this is null,\n-     * it is valid to the end\n+     * @param slot the index of the local variable, if type is long or double, the next available index is slot+2\n+     * @param start from where the variable is valid\n+     * @param end until where the variable is valid\n+     * @param origIndex the index of the local variable prior to any modifications\n@@ -327,3 +478,18 @@\n-    public LocalVariableGen addLocalVariable( final String name, final Type type, final InstructionHandle start,\n-            final InstructionHandle end ) {\n-        return addLocalVariable(name, type, maxLocals, start, end);\n+    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end,\n+        final int origIndex) {\n+        final byte t = type.getType();\n+        if (t != Const.T_ADDRESS) {\n+            final int add = type.getSize();\n+            if (slot + add > maxLocals) {\n+                maxLocals = slot + add;\n+            }\n+            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, origIndex);\n+            int i;\n+            if ((i = variableList.indexOf(l)) >= 0) {\n+                variableList.set(i, l);\n+            } else {\n+                variableList.add(l);\n+            }\n+            return l;\n+        }\n+        throw new IllegalArgumentException(\"Can not use \" + type + \" as type for local variable\");\n@@ -332,1 +498,0 @@\n-\n@@ -334,2 +499,1 @@\n-     * Remove a local variable, its slot will not be reused, if you do not use\n-     * addLocalVariable with an explicit index argument.\n+     * Add observer for this object.\n@@ -337,2 +501,5 @@\n-    public void removeLocalVariable(final LocalVariableGen l) {\n-        variableList.remove(l);\n+    public void addObserver(final MethodObserver o) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n@@ -341,26 +508,7 @@\n-\n-    \/**\n-     * Remove all local variables.\n-     *\/\n-    public void removeLocalVariables() {\n-        variableList.clear();\n-    }\n-\n-\n-    \/*\n-     * If the range of the variable has not been set yet, it will be set to be valid from\n-     * the start to the end of the instruction list.\n-     *\n-     * @return array of declared local variables sorted by index\n-     *\/\n-    public LocalVariableGen[] getLocalVariables() {\n-        final int size = variableList.size();\n-        final LocalVariableGen[] lg = new LocalVariableGen[size];\n-        variableList.toArray(lg);\n-        for (int i = 0; i < size; i++) {\n-            if ((lg[i].getStart() == null) && (il != null)) {\n-                lg[i].setStart(il.getStart());\n-            }\n-            if ((lg[i].getEnd() == null) && (il != null)) {\n-                lg[i].setEnd(il.getEnd());\n-            }\n+    public void addParameterAnnotation(final int parameterIndex, final AnnotationEntryGen annotation) {\n+        ensureExistingParameterAnnotationsUnpacked();\n+        if (!hasParameterAnnotations) {\n+            @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+            final List<AnnotationEntryGen>[] parmList = (List<AnnotationEntryGen>[])new List[argTypes.length];\n+            paramAnnotations = parmList;\n+            hasParameterAnnotations = true;\n@@ -368,2 +516,7 @@\n-        if (size > 1) {\n-            Arrays.sort(lg, (o1, o2) -> o1.getIndex() - o2.getIndex());\n+        final List<AnnotationEntryGen> existingAnnotations = paramAnnotations[parameterIndex];\n+        if (existingAnnotations != null) {\n+            existingAnnotations.add(annotation);\n+        } else {\n+            final List<AnnotationEntryGen> l = new ArrayList<>();\n+            l.add(annotation);\n+            paramAnnotations[parameterIndex] = l;\n@@ -371,1 +524,0 @@\n-        return lg;\n@@ -374,1 +526,0 @@\n-\n@@ -376,1 +527,1 @@\n-     * @return `LocalVariableTable' attribute of all the local variables of this method.\n+     * @since 6.0\n@@ -378,6 +529,7 @@\n-    public LocalVariableTable getLocalVariableTable( final ConstantPoolGen cp ) {\n-        final LocalVariableGen[] lg = getLocalVariables();\n-        final int size = lg.length;\n-        final LocalVariable[] lv = new LocalVariable[size];\n-        for (int i = 0; i < size; i++) {\n-            lv[i] = lg[i].getLocalVariable(cp);\n+    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        if (!hasParameterAnnotations) {\n+            return;\n+        }\n+        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n+        if (attrs != null) {\n+            addAll(attrs);\n@@ -385,2 +537,0 @@\n-        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp\n-                .getConstantPool());\n@@ -389,5 +539,4 @@\n-    \/**\n-     * @return `LocalVariableTypeTable' attribute of this method.\n-     *\/\n-    public LocalVariableTypeTable getLocalVariableTypeTable() {\n-        return localVariableTypeTable;\n+    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        addAll(attrs);\n+        return attrs;\n@@ -396,11 +545,7 @@\n-    \/**\n-     * Give an instruction a line number corresponding to the source code line.\n-     *\n-     * @param ih instruction to tag\n-     * @return new line number object\n-     * @see LineNumber\n-     *\/\n-    public LineNumberGen addLineNumber( final InstructionHandle ih, final int srcLine ) {\n-        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n-        lineNumberList.add(l);\n-        return l;\n+    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        if (!hasParameterAnnotations) {\n+            return Attribute.EMPTY_ARRAY;\n+        }\n+        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n+        addAll(attrs);\n+        return attrs;\n@@ -409,6 +554,12 @@\n-\n-    \/**\n-     * Remove a line number.\n-     *\/\n-    public void removeLineNumber( final LineNumberGen l ) {\n-        lineNumberList.remove(l);\n+    private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n+        final LocalVariable[] lv = lvt.getLocalVariableTable();\n+        for (final LocalVariable element : localVariableTypeTable.getLocalVariableTypeTable()) {\n+            for (final LocalVariable l : lv) {\n+                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n+                    element.setLength(l.getLength());\n+                    element.setStartPC(l.getStartPC());\n+                    element.setIndex(l.getIndex());\n+                    break;\n+                }\n+            }\n+        }\n@@ -417,1 +568,0 @@\n-\n@@ -419,9 +569,1 @@\n-     * Remove all line numbers.\n-     *\/\n-    public void removeLineNumbers() {\n-        lineNumberList.clear();\n-    }\n-\n-\n-    \/*\n-     * @return array of line numbers\n+     * @return deep copy of this method\n@@ -429,4 +571,8 @@\n-    public LineNumberGen[] getLineNumbers() {\n-        final LineNumberGen[] lg = new LineNumberGen[lineNumberList.size()];\n-        lineNumberList.toArray(lg);\n-        return lg;\n+    public MethodGen copy(final String className, final ConstantPoolGen cp) {\n+        final Method m = ((MethodGen) clone()).getMethod();\n+        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n+        if (super.getConstantPool() != cp) {\n+            mg.setConstantPool(cp);\n+            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n+        }\n+        return mg;\n@@ -435,1 +581,0 @@\n-\n@@ -437,1 +582,4 @@\n-     * @return `LineNumberTable' attribute of all the local variables of this method.\n+     * Goes through the attributes on the method and identifies any that are RuntimeParameterAnnotations, extracting their\n+     * contents and storing them as parameter annotations. There are two kinds of parameter annotation - visible and\n+     * invisible. Once they have been unpacked, these attributes are deleted. (The annotations will be rebuilt as attributes\n+     * when someone builds a Method object out of this MethodGen object).\n@@ -439,5 +587,40 @@\n-    public LineNumberTable getLineNumberTable( final ConstantPoolGen cp ) {\n-        final int size = lineNumberList.size();\n-        final LineNumber[] ln = new LineNumber[size];\n-        for (int i = 0; i < size; i++) {\n-            ln[i] = lineNumberList.get(i).getLineNumber();\n+    private void ensureExistingParameterAnnotationsUnpacked() {\n+        if (haveUnpackedParameterAnnotations) {\n+            return;\n+        }\n+        \/\/ Find attributes that contain parameter annotation data\n+        final Attribute[] attrs = getAttributes();\n+        ParameterAnnotations paramAnnVisAttr = null;\n+        ParameterAnnotations paramAnnInvisAttr = null;\n+        for (final Attribute attribute : attrs) {\n+            if (attribute instanceof ParameterAnnotations) {\n+                \/\/ Initialize paramAnnotations\n+                if (!hasParameterAnnotations) {\n+                    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+                    final List<AnnotationEntryGen>[] parmList = (List<AnnotationEntryGen>[])new List[argTypes.length];\n+                    paramAnnotations = parmList;\n+                    Arrays.setAll(paramAnnotations, i -> new ArrayList<>());\n+                }\n+                hasParameterAnnotations = true;\n+                final ParameterAnnotations rpa = (ParameterAnnotations) attribute;\n+                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n+                    paramAnnVisAttr = rpa;\n+                } else {\n+                    paramAnnInvisAttr = rpa;\n+                }\n+                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n+                for (int j = 0; j < parameterAnnotationEntries.length; j++) {\n+                    \/\/ This returns Annotation[] ...\n+                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n+                    \/\/ ... which needs transforming into an AnnotationGen[] ...\n+                    final List<AnnotationEntryGen> mutable = makeMutableVersion(immutableArray.getAnnotationEntries());\n+                    \/\/ ... then add these to any we already know about\n+                    paramAnnotations[j].addAll(mutable);\n+                }\n+            }\n+        }\n+        if (paramAnnVisAttr != null) {\n+            removeAttribute(paramAnnVisAttr);\n+        }\n+        if (paramAnnInvisAttr != null) {\n+            removeAttribute(paramAnnInvisAttr);\n@@ -445,2 +628,1 @@\n-        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp\n-                .getConstantPool());\n+        haveUnpackedParameterAnnotations = true;\n@@ -449,1 +631,0 @@\n-\n@@ -451,2 +632,2 @@\n-     * Add an exception handler, i.e., specify region where a handler is active and an\n-     * instruction where the actual handling is done.\n+     * Return value as defined by given BCELComparator strategy. By default two MethodGen objects are said to be equal when\n+     * their names and signatures are equal.\n@@ -454,6 +635,1 @@\n-     * @param start_pc Start of region (inclusive)\n-     * @param end_pc End of region (inclusive)\n-     * @param handler_pc Where handling is done\n-     * @param catch_type class type of handled exception or null if any\n-     * exception is handled\n-     * @return new exception handler object\n+     * @see Object#equals(Object)\n@@ -461,8 +637,3 @@\n-    public CodeExceptionGen addExceptionHandler( final InstructionHandle start_pc,\n-            final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type ) {\n-        if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {\n-            throw new ClassGenException(\"Exception handler target is null instruction\");\n-        }\n-        final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);\n-        exceptionList.add(c);\n-        return c;\n+    @Override\n+    public boolean equals(final Object obj) {\n+        return bcelComparator.equals(this, obj);\n@@ -471,1 +642,2 @@\n-\n+    \/\/ J5TODO: Should paramAnnotations be an array of arrays? Rather than an array of lists, this\n+    \/\/ is more likely to suggest to the caller it is readonly (which a List does not).\n@@ -473,1 +645,3 @@\n-     * Remove an exception handler.\n+     * Return a list of AnnotationGen objects representing parameter annotations\n+     *\n+     * @since 6.0\n@@ -475,2 +649,6 @@\n-    public void removeExceptionHandler( final CodeExceptionGen c ) {\n-        exceptionList.remove(c);\n+    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) {\n+        ensureExistingParameterAnnotationsUnpacked();\n+        if (!hasParameterAnnotations || i > argTypes.length) {\n+            return null;\n+        }\n+        return paramAnnotations[i];\n@@ -479,6 +657,2 @@\n-\n-    \/**\n-     * Remove all line numbers.\n-     *\/\n-    public void removeExceptionHandlers() {\n-        exceptionList.clear();\n+    public String getArgumentName(final int i) {\n+        return argNames[i];\n@@ -487,0 +661,3 @@\n+    public String[] getArgumentNames() {\n+        return argNames.clone();\n+    }\n@@ -488,7 +665,2 @@\n-    \/*\n-     * @return array of declared exception handlers\n-     *\/\n-    public CodeExceptionGen[] getExceptionHandlers() {\n-        final CodeExceptionGen[] cg = new CodeExceptionGen[exceptionList.size()];\n-        exceptionList.toArray(cg);\n-        return cg;\n+    public Type getArgumentType(final int i) {\n+        return argTypes[i];\n@@ -497,0 +669,3 @@\n+    public Type[] getArgumentTypes() {\n+        return argTypes.clone();\n+    }\n@@ -499,1 +674,1 @@\n-     * @return code exceptions for `Code' attribute\n+     * @return class that contains this method\n@@ -501,8 +676,2 @@\n-    private CodeException[] getCodeExceptions() {\n-        final int size = exceptionList.size();\n-        final CodeException[] c_exc = new CodeException[size];\n-        for (int i = 0; i < size; i++) {\n-            final CodeExceptionGen c =  exceptionList.get(i);\n-            c_exc[i] = c.getCodeException(super.getConstantPool());\n-        }\n-        return c_exc;\n+    public String getClassName() {\n+        return className;\n@@ -511,1 +680,0 @@\n-\n@@ -513,3 +681,1 @@\n-     * Add an exception possibly thrown by this method.\n-     *\n-     * @param className (fully qualified) name of exception\n+     * @return all attributes of this method.\n@@ -517,2 +683,2 @@\n-    public void addException( final String className ) {\n-        throwsList.add(className);\n+    public Attribute[] getCodeAttributes() {\n+        return codeAttrsList.toArray(Attribute.EMPTY_ARRAY);\n@@ -521,1 +687,0 @@\n-\n@@ -523,1 +688,1 @@\n-     * Remove an exception.\n+     * @return code exceptions for 'Code' attribute\n@@ -525,2 +690,5 @@\n-    public void removeException( final String c ) {\n-        throwsList.remove(c);\n+    private CodeException[] getCodeExceptions() {\n+        final int size = exceptionList.size();\n+        final CodeException[] cExc = new CodeException[size];\n+        Arrays.setAll(cExc, i -> exceptionList.get(i).getCodeException(super.getConstantPool()));\n+        return cExc;\n@@ -529,3 +697,2 @@\n-\n-    \/**\n-     * Remove all exceptions.\n+    \/*\n+     * @return array of declared exception handlers\n@@ -533,2 +700,2 @@\n-    public void removeExceptions() {\n-        throwsList.clear();\n+    public CodeExceptionGen[] getExceptionHandlers() {\n+        return exceptionList.toArray(CodeExceptionGen.EMPTY_ARRAY);\n@@ -537,1 +704,0 @@\n-\n@@ -542,1 +708,1 @@\n-        return throwsList.toArray(new String[0]);\n+        return throwsList.toArray(Const.EMPTY_STRING_ARRAY);\n@@ -545,1 +711,0 @@\n-\n@@ -547,1 +712,1 @@\n-     * @return `Exceptions' attribute of all the exceptions thrown by this method.\n+     * @return 'Exceptions' attribute of all the exceptions thrown by this method.\n@@ -549,1 +714,1 @@\n-    private ExceptionTable getExceptionTable( final ConstantPoolGen cp ) {\n+    private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {\n@@ -552,3 +717,1 @@\n-        for (int i = 0; i < size; i++) {\n-            ex[i] = cp.addClass(throwsList.get(i));\n-        }\n+        Arrays.setAll(ex, i -> cp.addClass(throwsList.get(i)));\n@@ -558,0 +721,3 @@\n+    public InstructionList getInstructionList() {\n+        return il;\n+    }\n@@ -559,8 +725,2 @@\n-    \/**\n-     * Add an attribute to the code. Currently, the JVM knows about the\n-     * LineNumberTable, LocalVariableTable and StackMap attributes,\n-     * where the former two will be generated automatically and the\n-     * latter is used for the MIDP only. Other attributes will be\n-     * ignored by the JVM but do no harm.\n-     *\n-     * @param a attribute to be added\n+    \/*\n+     * @return array of line numbers\n@@ -568,2 +728,2 @@\n-    public void addCodeAttribute( final Attribute a ) {\n-        codeAttrsList.add(a);\n+    public LineNumberGen[] getLineNumbers() {\n+        return lineNumberList.toArray(LineNumberGen.EMPTY_ARRAY);\n@@ -572,1 +732,0 @@\n-\n@@ -574,1 +733,1 @@\n-     * Remove the LocalVariableTypeTable\n+     * @return 'LineNumberTable' attribute of all the local variables of this method.\n@@ -576,2 +735,5 @@\n-    public void removeLocalVariableTypeTable( ) {\n-        localVariableTypeTable = null;\n+    public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {\n+        final int size = lineNumberList.size();\n+        final LineNumber[] ln = new LineNumber[size];\n+        Arrays.setAll(ln, i -> lineNumberList.get(i).getLineNumber());\n+        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp.getConstantPool());\n@@ -580,2 +742,5 @@\n-    \/**\n-     * Remove a code attribute.\n+    \/*\n+     * If the range of the variable has not been set yet, it will be set to be valid from the start to the end of the\n+     * instruction list.\n+     *\n+     * @return array of declared local variables sorted by index\n@@ -583,2 +748,16 @@\n-    public void removeCodeAttribute( final Attribute a ) {\n-        codeAttrsList.remove(a);\n+    public LocalVariableGen[] getLocalVariables() {\n+        final int size = variableList.size();\n+        final LocalVariableGen[] lg = new LocalVariableGen[size];\n+        variableList.toArray(lg);\n+        for (int i = 0; i < size; i++) {\n+            if (lg[i].getStart() == null && il != null) {\n+                lg[i].setStart(il.getStart());\n+            }\n+            if (lg[i].getEnd() == null && il != null) {\n+                lg[i].setEnd(il.getEnd());\n+            }\n+        }\n+        if (size > 1) {\n+            Arrays.sort(lg, Comparator.comparingInt(LocalVariableGen::getIndex));\n+        }\n+        return lg;\n@@ -587,1 +766,0 @@\n-\n@@ -589,1 +767,1 @@\n-     * Remove all code attributes.\n+     * @return 'LocalVariableTable' attribute of all the local variables of this method.\n@@ -591,3 +769,6 @@\n-    public void removeCodeAttributes() {\n-        localVariableTypeTable = null;\n-        codeAttrsList.clear();\n+    public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {\n+        final LocalVariableGen[] lg = getLocalVariables();\n+        final int size = lg.length;\n+        final LocalVariable[] lv = new LocalVariable[size];\n+        Arrays.setAll(lv, i -> lg[i].getLocalVariable(cp));\n+        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp.getConstantPool());\n@@ -596,1 +777,0 @@\n-\n@@ -598,1 +778,1 @@\n-     * @return all attributes of this method.\n+     * @return 'LocalVariableTypeTable' attribute of this method.\n@@ -600,2 +780,2 @@\n-    public Attribute[] getCodeAttributes() {\n-        return codeAttrsList.toArray(new Attribute[0]);\n+    public LocalVariableTypeTable getLocalVariableTypeTable() {\n+        return localVariableTypeTable;\n@@ -604,42 +784,2 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n-        for (final Attribute attr : attrs) {\n-            addAttribute(attr);\n-        }\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        if (!hasParameterAnnotations) {\n-            return;\n-        }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n-        if (attrs != null) {\n-            for (final Attribute attr : attrs) {\n-                addAttribute(attr);\n-            }\n-        }\n-    }\n-\n-    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n-        for (final Attribute attr : attrs) {\n-            addAttribute(attr);\n-        }\n-        return attrs;\n-    }\n-\n-    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        if (!hasParameterAnnotations) {\n-            return new Attribute[0];\n-        }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n-        for (final Attribute attr : attrs) {\n-            addAttribute(attr);\n-        }\n-        return attrs;\n+    public int getMaxLocals() {\n+        return maxLocals;\n@@ -648,9 +788,2 @@\n-    \/**\n-     * Would prefer to make this private, but need a way to test if client is\n-     * using BCEL version 6.5.0 or later that contains fix for BCEL-329.\n-     * @since 6.5.0\n-     *\/\n-    public void removeRuntimeAttributes(final Attribute[] attrs) {\n-        for (final Attribute attr : attrs) {\n-            removeAttribute(attr);\n-        }\n+    public int getMaxStack() {\n+        return maxStack;\n@@ -659,1 +792,0 @@\n-\n@@ -661,2 +793,2 @@\n-     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,\n-     * before calling this method (the same applies for max locals).\n+     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively, before calling this method\n+     * (the same applies for max locals).\n@@ -668,4 +800,5 @@\n-        final ConstantPoolGen _cp = super.getConstantPool();\n-        final int name_index = _cp.addUtf8(super.getName());\n-        final int signature_index = _cp.addUtf8(signature);\n-        \/* Also updates positions of instructions, i.e., their indices\n+        final ConstantPoolGen cp = super.getConstantPool();\n+        final int nameIndex = cp.addUtf8(super.getName());\n+        final int signatureIndex = cp.addUtf8(signature);\n+        \/*\n+         * Also updates positions of instructions, i.e., their indices\n@@ -673,4 +806,1 @@\n-        byte[] byte_code = null;\n-        if (il != null) {\n-            byte_code = il.getByteCode();\n-        }\n+        final byte[] byteCode = il != null ? il.getByteCode() : null;\n@@ -679,1 +809,2 @@\n-        \/* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)\n+        \/*\n+         * Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)\n@@ -681,3 +812,3 @@\n-        if ((variableList.size() > 0) && !stripAttributes) {\n-            updateLocalVariableTable(getLocalVariableTable(_cp));\n-            addCodeAttribute(lvt = getLocalVariableTable(_cp));\n+        if (!variableList.isEmpty() && !stripAttributes) {\n+            updateLocalVariableTable(getLocalVariableTable(cp));\n+            addCodeAttribute(lvt = getLocalVariableTable(cp));\n@@ -686,1 +817,2 @@\n-            \/\/ LocalVariable length in LocalVariableTypeTable is not updated automatically. It's a difference with LocalVariableTable.\n+            \/\/ LocalVariable length in LocalVariableTypeTable is not updated automatically. It's a difference with\n+            \/\/ LocalVariableTable.\n@@ -692,2 +824,2 @@\n-        if ((lineNumberList.size() > 0) && !stripAttributes) {\n-            addCodeAttribute(lnt = getLineNumberTable(_cp));\n+        if (!lineNumberList.isEmpty() && !stripAttributes) {\n+            addCodeAttribute(lnt = getLineNumberTable(cp));\n@@ -695,2 +827,3 @@\n-        final Attribute[] code_attrs = getCodeAttributes();\n-        \/* Each attribute causes 6 additional header bytes\n+        final Attribute[] codeAttrs = getCodeAttributes();\n+        \/*\n+         * Each attribute causes 6 additional header bytes\n@@ -698,3 +831,3 @@\n-        int attrs_len = 0;\n-        for (final Attribute code_attr : code_attrs) {\n-            attrs_len += code_attr.getLength() + 6;\n+        int attrsLen = 0;\n+        for (final Attribute codeAttr : codeAttrs) {\n+            attrsLen += codeAttr.getLength() + 6;\n@@ -702,2 +835,2 @@\n-        final CodeException[] c_exc = getCodeExceptions();\n-        final int exc_len = c_exc.length * 8; \/\/ Every entry takes 8 bytes\n+        final CodeException[] cExc = getCodeExceptions();\n+        final int excLen = cExc.length * 8; \/\/ Every entry takes 8 bytes\n@@ -705,1 +838,1 @@\n-        if ((il != null) && !isAbstract() && !isNative()) {\n+        if (byteCode != null && !isAbstract() && !isNative()) {\n@@ -713,4 +846,4 @@\n-            code = new Code(_cp.addUtf8(\"Code\"), 8 + byte_code.length + \/\/ prologue byte code\n-                    2 + exc_len + \/\/ exceptions\n-                    2 + attrs_len, \/\/ attributes\n-                    maxStack, maxLocals, byte_code, c_exc, code_attrs, _cp.getConstantPool());\n+            code = new Code(cp.addUtf8(\"Code\"), 8 + byteCode.length + \/\/ prologue byte code\n+                2 + excLen + \/\/ exceptions\n+                2 + attrsLen, \/\/ attributes\n+                maxStack, maxLocals, byteCode, cExc, codeAttrs, cp.getConstantPool());\n@@ -719,2 +852,2 @@\n-        final Attribute[] annotations = addRuntimeAnnotationsAsAttribute(_cp);\n-        final Attribute[] parameterAnnotations = addRuntimeParameterAnnotationsAsAttribute(_cp);\n+        final Attribute[] annotations = addRuntimeAnnotationsAsAttribute(cp);\n+        final Attribute[] parameterAnnotations = addRuntimeParameterAnnotationsAsAttribute(cp);\n@@ -722,3 +855,3 @@\n-        if (throwsList.size() > 0) {\n-            addAttribute(et = getExceptionTable(_cp));\n-            \/\/ Add `Exceptions' if there are \"throws\" clauses\n+        if (!throwsList.isEmpty()) {\n+            addAttribute(et = getExceptionTable(cp));\n+            \/\/ Add 'Exceptions' if there are \"throws\" clauses\n@@ -726,2 +859,1 @@\n-        final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp\n-                .getConstantPool());\n+        final Method m = new Method(super.getAccessFlags(), nameIndex, signatureIndex, getAttributes(), cp.getConstantPool());\n@@ -749,16 +881,2 @@\n-    private void updateLocalVariableTable(final LocalVariableTable a) {\n-        final LocalVariable[] lv = a.getLocalVariableTable();\n-        removeLocalVariables();\n-        for (final LocalVariable l : lv) {\n-            InstructionHandle start = il.findHandle(l.getStartPC());\n-            final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());\n-            \/\/ Repair malformed handles\n-            if (null == start) {\n-                start = il.getStart();\n-            }\n-            \/\/ end == null => live to end of method\n-            \/\/ Since we are recreating the LocalVaraible, we must\n-            \/\/ propagate the orig_index to new copy.\n-            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l\n-                    .getIndex(), start, end, l.getOrigIndex());\n-        }\n+    public Type getReturnType() {\n+        return getType();\n@@ -767,14 +885,3 @@\n-    private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n-        final LocalVariable[] lv = lvt.getLocalVariableTable();\n-        final LocalVariable[] lvg = localVariableTypeTable.getLocalVariableTypeTable();\n-\n-        for (final LocalVariable element : lvg) {\n-            for (final LocalVariable l : lv) {\n-                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n-                    element.setLength(l.getLength());\n-                    element.setStartPC(l.getStartPC());\n-                    element.setIndex(l.getIndex());\n-                    break;\n-                }\n-            }\n-        }\n+    @Override\n+    public String getSignature() {\n+        return Type.getMethodSignature(super.getType(), argTypes);\n@@ -783,1 +890,0 @@\n-\n@@ -785,3 +891,4 @@\n-     * Remove all NOPs from the instruction list (if possible) and update every\n-     * object referring to them, i.e., branch instructions, local variables and\n-     * exception handlers.\n+     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n+     * signature.\n+     *\n+     * @see Object#hashCode()\n@@ -789,20 +896,3 @@\n-    public void removeNOPs() {\n-        if (il != null) {\n-            InstructionHandle next;\n-            \/* Check branch instructions.\n-             *\/\n-            for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {\n-                next = ih.getNext();\n-                if ((next != null) && (ih.getInstruction() instanceof NOP)) {\n-                    try {\n-                        il.delete(ih);\n-                    } catch (final TargetLostException e) {\n-                        for (final InstructionHandle target : e.getTargets()) {\n-                            for (final InstructionTargeter targeter : target.getTargeters()) {\n-                                targeter.updateTarget(target, next);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n@@ -811,0 +901,7 @@\n+    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray) {\n+        final List<AnnotationEntryGen> result = new ArrayList<>();\n+        for (final AnnotationEntry element : mutableArray) {\n+            result.add(new AnnotationEntryGen(element, getConstantPool(), false));\n+        }\n+        return result;\n+    }\n@@ -813,1 +910,1 @@\n-     * Set maximum number of local variables.\n+     * Remove a code attribute.\n@@ -815,2 +912,2 @@\n-    public void setMaxLocals( final int m ) {\n-        maxLocals = m;\n+    public void removeCodeAttribute(final Attribute a) {\n+        codeAttrsList.remove(a);\n@@ -819,3 +916,6 @@\n-\n-    public int getMaxLocals() {\n-        return maxLocals;\n+    \/**\n+     * Remove all code attributes.\n+     *\/\n+    public void removeCodeAttributes() {\n+        localVariableTypeTable = null;\n+        codeAttrsList.clear();\n@@ -824,1 +924,0 @@\n-\n@@ -826,1 +925,1 @@\n-     * Set maximum stack size for this method.\n+     * Remove an exception.\n@@ -828,2 +927,2 @@\n-    public void setMaxStack( final int m ) { \/\/ TODO could be package-protected?\n-        maxStack = m;\n+    public void removeException(final String c) {\n+        throwsList.remove(c);\n@@ -832,3 +931,5 @@\n-\n-    public int getMaxStack() {\n-        return maxStack;\n+    \/**\n+     * Remove an exception handler.\n+     *\/\n+    public void removeExceptionHandler(final CodeExceptionGen c) {\n+        exceptionList.remove(c);\n@@ -837,2 +938,2 @@\n-\n-    \/** @return class that contains this method\n+    \/**\n+     * Remove all line numbers.\n@@ -840,2 +941,2 @@\n-    public String getClassName() {\n-        return className;\n+    public void removeExceptionHandlers() {\n+        exceptionList.clear();\n@@ -844,3 +945,5 @@\n-\n-    public void setClassName( final String class_name ) { \/\/ TODO could be package-protected?\n-        this.className = class_name;\n+    \/**\n+     * Remove all exceptions.\n+     *\/\n+    public void removeExceptions() {\n+        throwsList.clear();\n@@ -849,3 +952,5 @@\n-\n-    public void setReturnType( final Type return_type ) {\n-        setType(return_type);\n+    \/**\n+     * Remove a line number.\n+     *\/\n+    public void removeLineNumber(final LineNumberGen l) {\n+        lineNumberList.remove(l);\n@@ -854,3 +959,5 @@\n-\n-    public Type getReturnType() {\n-        return getType();\n+    \/**\n+     * Remove all line numbers.\n+     *\/\n+    public void removeLineNumbers() {\n+        lineNumberList.clear();\n@@ -859,3 +966,6 @@\n-\n-    public void setArgumentTypes( final Type[] arg_types ) {\n-        this.argTypes = arg_types;\n+    \/**\n+     * Remove a local variable, its slot will not be reused, if you do not use addLocalVariable with an explicit index\n+     * argument.\n+     *\/\n+    public void removeLocalVariable(final LocalVariableGen l) {\n+        variableList.remove(l);\n@@ -864,3 +974,5 @@\n-\n-    public Type[] getArgumentTypes() {\n-        return argTypes.clone();\n+    \/**\n+     * Remove all local variables.\n+     *\/\n+    public void removeLocalVariables() {\n+        variableList.clear();\n@@ -869,3 +981,5 @@\n-\n-    public void setArgumentType( final int i, final Type type ) {\n-        argTypes[i] = type;\n+    \/**\n+     * Remove the LocalVariableTypeTable\n+     *\/\n+    public void removeLocalVariableTypeTable() {\n+        localVariableTypeTable = null;\n@@ -874,3 +988,25 @@\n-\n-    public Type getArgumentType( final int i ) {\n-        return argTypes[i];\n+    \/**\n+     * Remove all NOPs from the instruction list (if possible) and update every object referring to them, i.e., branch\n+     * instructions, local variables and exception handlers.\n+     *\/\n+    public void removeNOPs() {\n+        if (il != null) {\n+            InstructionHandle next;\n+            \/*\n+             * Check branch instructions.\n+             *\/\n+            for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {\n+                next = ih.getNext();\n+                if (next != null && ih.getInstruction() instanceof NOP) {\n+                    try {\n+                        il.delete(ih);\n+                    } catch (final TargetLostException e) {\n+                        for (final InstructionHandle target : e.getTargets()) {\n+                            for (final InstructionTargeter targeter : target.getTargeters()) {\n+                                targeter.updateTarget(target, next);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n@@ -879,3 +1015,7 @@\n-\n-    public void setArgumentNames( final String[] arg_names ) {\n-        this.argNames = arg_names;\n+    \/**\n+     * Remove observer for this object.\n+     *\/\n+    public void removeObserver(final MethodObserver o) {\n+        if (observers != null) {\n+            observers.remove(o);\n+        }\n@@ -884,3 +1024,10 @@\n-\n-    public String[] getArgumentNames() {\n-        return argNames.clone();\n+    \/**\n+     * Would prefer to make this private, but need a way to test if client is using BCEL version 6.5.0 or later that\n+     * contains fix for BCEL-329.\n+     *\n+     * @since 6.5.0\n+     *\/\n+    public void removeRuntimeAttributes(final Attribute[] attrs) {\n+        for (final Attribute attr : attrs) {\n+            removeAttribute(attr);\n+        }\n@@ -889,2 +1036,1 @@\n-\n-    public void setArgumentName( final int i, final String name ) {\n+    public void setArgumentName(final int i, final String name) {\n@@ -894,3 +1040,2 @@\n-\n-    public String getArgumentName( final int i ) {\n-        return argNames[i];\n+    public void setArgumentNames(final String[] argNames) {\n+        this.argNames = argNames;\n@@ -899,3 +1044,2 @@\n-\n-    public InstructionList getInstructionList() {\n-        return il;\n+    public void setArgumentType(final int i, final Type type) {\n+        argTypes[i] = type;\n@@ -904,3 +1048,2 @@\n-\n-    public void setInstructionList( final InstructionList il ) { \/\/ TODO could be package-protected?\n-        this.il = il;\n+    public void setArgumentTypes(final Type[] argTypes) {\n+        this.argTypes = argTypes;\n@@ -909,4 +1052,2 @@\n-\n-    @Override\n-    public String getSignature() {\n-        return Type.getMethodSignature(super.getType(), argTypes);\n+    public void setClassName(final String className) { \/\/ TODO could be package-protected?\n+        this.className = className;\n@@ -915,10 +1056,2 @@\n-\n-    \/**\n-     * Computes max. stack size by performing control flow analysis.\n-     *\/\n-    public void setMaxStack() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n-        if (il != null) {\n-            maxStack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());\n-        } else {\n-            maxStack = 0;\n-        }\n+    public void setInstructionList(final InstructionList il) { \/\/ TODO could be package-protected?\n+        this.il = il;\n@@ -927,1 +1060,0 @@\n-\n@@ -935,2 +1067,2 @@\n-                for (final Type arg_type : argTypes) {\n-                    max += arg_type.getSize();\n+                for (final Type argType : argTypes) {\n+                    max += argType.getSize();\n@@ -941,4 +1073,2 @@\n-                if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)\n-                        || (ins instanceof IINC)) {\n-                    final int index = ((IndexedInstruction) ins).getIndex()\n-                            + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();\n+                if (ins instanceof LocalVariableInstruction || ins instanceof RET || ins instanceof IINC) {\n+                    final int index = ((IndexedInstruction) ins).getIndex() + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();\n@@ -956,3 +1086,2 @@\n-\n-    \/** Do not\/Do produce attributes code attributesLineNumberTable and\n-     * LocalVariableTable, like javac -O\n+    \/**\n+     * Set maximum number of local variables.\n@@ -960,49 +1089,2 @@\n-    public void stripAttributes( final boolean flag ) {\n-        stripAttributes = flag;\n-    }\n-\n-    static final class BranchTarget {\n-\n-        final InstructionHandle target;\n-        final int stackDepth;\n-\n-\n-        BranchTarget(final InstructionHandle target, final int stackDepth) {\n-            this.target = target;\n-            this.stackDepth = stackDepth;\n-        }\n-    }\n-\n-    static final class BranchStack {\n-\n-        private final Stack<BranchTarget> branchTargets = new Stack<>();\n-        private final Map<InstructionHandle, BranchTarget> visitedTargets = new HashMap<>();\n-\n-\n-        public void push( final InstructionHandle target, final int stackDepth ) {\n-            if (visited(target)) {\n-                return;\n-            }\n-            branchTargets.push(visit(target, stackDepth));\n-        }\n-\n-\n-        public BranchTarget pop() {\n-            if (!branchTargets.empty()) {\n-                final BranchTarget bt = branchTargets.pop();\n-                return bt;\n-            }\n-            return null;\n-        }\n-\n-\n-        private BranchTarget visit( final InstructionHandle target, final int stackDepth ) {\n-            final BranchTarget bt = new BranchTarget(target, stackDepth);\n-            visitedTargets.put(target, bt);\n-            return bt;\n-        }\n-\n-\n-        private boolean visited( final InstructionHandle target ) {\n-            return visitedTargets.get(target) != null;\n-        }\n+    public void setMaxLocals(final int m) {\n+        maxLocals = m;\n@@ -1011,1 +1093,0 @@\n-\n@@ -1013,3 +1094,1 @@\n-     * Computes stack usage of an instruction list by performing control flow analysis.\n-     *\n-     * @return maximum stack depth used by method\n+     * Computes max. stack size by performing control flow analysis.\n@@ -1017,67 +1096,5 @@\n-    public static int getMaxStack( final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et ) {\n-        final BranchStack branchTargets = new BranchStack();\n-        \/* Initially, populate the branch stack with the exception\n-         * handlers, because these aren't (necessarily) branched to\n-         * explicitly. in each case, the stack will have depth 1,\n-         * containing the exception object.\n-         *\/\n-        for (final CodeExceptionGen element : et) {\n-            final InstructionHandle handler_pc = element.getHandlerPC();\n-            if (handler_pc != null) {\n-                branchTargets.push(handler_pc, 1);\n-            }\n-        }\n-        int stackDepth = 0;\n-        int maxStackDepth = 0;\n-        InstructionHandle ih = il.getStart();\n-        while (ih != null) {\n-            final Instruction instruction = ih.getInstruction();\n-            final short opcode = instruction.getOpcode();\n-            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n-            stackDepth += delta;\n-            if (stackDepth > maxStackDepth) {\n-                maxStackDepth = stackDepth;\n-            }\n-            \/\/ choose the next instruction based on whether current is a branch.\n-            if (instruction instanceof BranchInstruction) {\n-                final BranchInstruction branch = (BranchInstruction) instruction;\n-                if (instruction instanceof Select) {\n-                    \/\/ explore all of the select's targets. the default target is handled below.\n-                    final Select select = (Select) branch;\n-                    final InstructionHandle[] targets = select.getTargets();\n-                    for (final InstructionHandle target : targets) {\n-                        branchTargets.push(target, stackDepth);\n-                    }\n-                    \/\/ nothing to fall through to.\n-                    ih = null;\n-                } else if (!(branch instanceof IfInstruction)) {\n-                    \/\/ if an instruction that comes back to following PC,\n-                    \/\/ push next instruction, with stack depth reduced by 1.\n-                    if (opcode == Const.JSR || opcode == Const.JSR_W) {\n-                        branchTargets.push(ih.getNext(), stackDepth - 1);\n-                    }\n-                    ih = null;\n-                }\n-                \/\/ for all branches, the target of the branch is pushed on the branch stack.\n-                \/\/ conditional branches have a fall through case, selects don't, and\n-                \/\/ jsr\/jsr_w return to the next instruction.\n-                branchTargets.push(branch.getTarget(), stackDepth);\n-            } else {\n-                \/\/ check for instructions that terminate the method.\n-                if (opcode == Const.ATHROW || opcode == Const.RET\n-                        || (opcode >= Const.IRETURN && opcode <= Const.RETURN)) {\n-                    ih = null;\n-                }\n-            }\n-            \/\/ normal case, go to the next instruction.\n-            if (ih != null) {\n-                ih = ih.getNext();\n-            }\n-            \/\/ if we have no more instructions, see if there are any deferred branches to explore.\n-            if (ih == null) {\n-                final BranchTarget bt = branchTargets.pop();\n-                if (bt != null) {\n-                    ih = bt.target;\n-                    stackDepth = bt.stackDepth;\n-                }\n-            }\n+    public void setMaxStack() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n+        if (il != null) {\n+            maxStack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());\n+        } else {\n+            maxStack = 0;\n@@ -1085,1 +1102,0 @@\n-        return maxStackDepth;\n@@ -1088,4 +1104,2 @@\n-    private List<MethodObserver> observers;\n-\n-\n-    \/** Add observer for this object.\n+    \/**\n+     * Set maximum stack size for this method.\n@@ -1093,5 +1107,2 @@\n-    public void addObserver( final MethodObserver o ) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n+    public void setMaxStack(final int m) { \/\/ TODO could be package-protected?\n+        maxStack = m;\n@@ -1100,7 +1111,2 @@\n-\n-    \/** Remove observer for this object.\n-     *\/\n-    public void removeObserver( final MethodObserver o ) {\n-        if (observers != null) {\n-            observers.remove(o);\n-        }\n+    public void setReturnType(final Type returnType) {\n+        setType(returnType);\n@@ -1109,4 +1115,2 @@\n-\n-    \/** Call notify() method on all observers. This method is not called\n-     * automatically whenever the state has changed, but has to be\n-     * called by the user after he has finished editing the object.\n+    \/**\n+     * Do not\/Do produce attributes code attributesLineNumberTable and LocalVariableTable, like javac -O\n@@ -1114,6 +1118,2 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final MethodObserver observer : observers) {\n-                observer.notify(this);\n-            }\n-        }\n+    public void stripAttributes(final boolean flag) {\n+        stripAttributes = flag;\n@@ -1122,1 +1122,0 @@\n-\n@@ -1124,2 +1123,2 @@\n-     * Return string representation close to declaration format,\n-     * `public static void main(String[]) throws IOException', e.g.\n+     * Return string representation close to declaration format, 'public static void main(String[]) throws IOException',\n+     * e.g.\n@@ -1133,2 +1132,1 @@\n-        signature = Utility.methodSignatureToString(signature, super.getName(), access, true,\n-                getLocalVariableTable(super.getConstantPool()));\n+        signature = Utility.methodSignatureToString(signature, super.getName(), access, true, getLocalVariableTable(super.getConstantPool()));\n@@ -1137,1 +1135,1 @@\n-            if (!((a instanceof Code) || (a instanceof ExceptionTable))) {\n+            if (!(a instanceof Code || a instanceof ExceptionTable)) {\n@@ -1142,1 +1140,1 @@\n-        if (throwsList.size() > 0) {\n+        if (!throwsList.isEmpty()) {\n@@ -1150,27 +1148,0 @@\n-\n-    \/** @return deep copy of this method\n-     *\/\n-    public MethodGen copy( final String className, final ConstantPoolGen cp ) {\n-        final Method m = ((MethodGen) clone()).getMethod();\n-        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n-        if (super.getConstantPool() != cp) {\n-            mg.setConstantPool(cp);\n-            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n-        }\n-        return mg;\n-    }\n-\n-    \/\/J5TODO: Should paramAnnotations be an array of arrays? Rather than an array of lists, this\n-    \/\/ is more likely to suggest to the caller it is readonly (which a List does not).\n-    \/**\n-     * Return a list of AnnotationGen objects representing parameter annotations\n-     * @since 6.0\n-     *\/\n-    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) {\n-        ensureExistingParameterAnnotationsUnpacked();\n-        if (!hasParameterAnnotations || i > argTypes.length) {\n-            return null;\n-        }\n-        return paramAnnotations[i];\n-    }\n-\n@@ -1178,6 +1149,2 @@\n-     * Goes through the attributes on the method and identifies any that are\n-     * RuntimeParameterAnnotations, extracting their contents and storing them\n-     * as parameter annotations. There are two kinds of parameter annotation -\n-     * visible and invisible. Once they have been unpacked, these attributes are\n-     * deleted. (The annotations will be rebuilt as attributes when someone\n-     * builds a Method object out of this MethodGen object).\n+     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n+     * has to be called by the user after they have finished editing the object.\n@@ -1185,39 +1152,4 @@\n-    private void ensureExistingParameterAnnotationsUnpacked()\n-    {\n-        if (haveUnpackedParameterAnnotations) {\n-            return;\n-        }\n-        \/\/ Find attributes that contain parameter annotation data\n-        final Attribute[] attrs = getAttributes();\n-        ParameterAnnotations paramAnnVisAttr = null;\n-        ParameterAnnotations paramAnnInvisAttr = null;\n-        for (final Attribute attribute : attrs) {\n-            if (attribute instanceof ParameterAnnotations)\n-            {\n-                \/\/ Initialize paramAnnotations\n-                if (!hasParameterAnnotations)\n-                {\n-                    @SuppressWarnings({\"rawtypes\", \"unchecked\"}) \/\/ OK\n-                    final List<AnnotationEntryGen>[] parmList = new List[argTypes.length];\n-                    paramAnnotations = parmList;\n-                    for (int j = 0; j < argTypes.length; j++) {\n-                        paramAnnotations[j] = new ArrayList<>();\n-                    }\n-                }\n-                hasParameterAnnotations = true;\n-                final ParameterAnnotations rpa = (ParameterAnnotations) attribute;\n-                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n-                    paramAnnVisAttr = rpa;\n-                } else {\n-                    paramAnnInvisAttr = rpa;\n-                }\n-                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n-                for (int j = 0; j < parameterAnnotationEntries.length; j++)\n-                {\n-                    \/\/ This returns Annotation[] ...\n-                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n-                    \/\/ ... which needs transforming into an AnnotationGen[] ...\n-                    final List<AnnotationEntryGen> mutable = makeMutableVersion(immutableArray.getAnnotationEntries());\n-                    \/\/ ... then add these to any we already know about\n-                    paramAnnotations[j].addAll(mutable);\n-                }\n+    public void update() {\n+        if (observers != null) {\n+            for (final MethodObserver observer : observers) {\n+                observer.notify(this);\n@@ -1226,17 +1158,0 @@\n-        if (paramAnnVisAttr != null) {\n-            removeAttribute(paramAnnVisAttr);\n-        }\n-        if (paramAnnInvisAttr != null) {\n-            removeAttribute(paramAnnInvisAttr);\n-        }\n-        haveUnpackedParameterAnnotations = true;\n-    }\n-\n-    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray)\n-    {\n-        final List<AnnotationEntryGen> result = new ArrayList<>();\n-        for (final AnnotationEntry element : mutableArray) {\n-            result.add(new AnnotationEntryGen(element, getConstantPool(),\n-                    false));\n-        }\n-        return result;\n@@ -1245,21 +1160,13 @@\n-    public void addParameterAnnotation(final int parameterIndex,\n-            final AnnotationEntryGen annotation)\n-    {\n-        ensureExistingParameterAnnotationsUnpacked();\n-        if (!hasParameterAnnotations)\n-        {\n-            @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-            final List<AnnotationEntryGen>[] parmList = new List[argTypes.length];\n-            paramAnnotations = parmList;\n-            hasParameterAnnotations = true;\n-        }\n-        final List<AnnotationEntryGen> existingAnnotations = paramAnnotations[parameterIndex];\n-        if (existingAnnotations != null)\n-        {\n-            existingAnnotations.add(annotation);\n-        }\n-        else\n-        {\n-            final List<AnnotationEntryGen> l = new ArrayList<>();\n-            l.add(annotation);\n-            paramAnnotations[parameterIndex] = l;\n+    private void updateLocalVariableTable(final LocalVariableTable a) {\n+        removeLocalVariables();\n+        for (final LocalVariable l : a.getLocalVariableTable()) {\n+            InstructionHandle start = il.findHandle(l.getStartPC());\n+            final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());\n+            \/\/ Repair malformed handles\n+            if (null == start) {\n+                start = il.getStart();\n+            }\n+            \/\/ end == null => live to end of method\n+            \/\/ Since we are recreating the LocalVaraible, we must\n+            \/\/ propagate the orig_index to new copy.\n+            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l.getIndex(), start, end, l.getOrigIndex());\n@@ -1268,40 +1175,0 @@\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator( final BCELComparator comparator ) {\n-        bcelComparator = comparator;\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default two MethodGen objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see java.lang.Object#equals(java.lang.Object)\n-     *\/\n-    @Override\n-    public boolean equals( final Object obj ) {\n-        return bcelComparator.equals(this, obj);\n-    }\n-\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy.\n-     * By default return the hashcode of the method's name XOR signature.\n-     *\n-     * @see java.lang.Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MethodGen.java","additions":711,"deletions":844,"binary":false,"changes":1555,"status":"modified"},{"patch":"@@ -25,3 +25,2 @@\n- * Implement this interface if you're interested in changes to a MethodGen object\n- * and register yourself with addObserver().\n- *\n+ * Implement this interface if you're interested in changes to a MethodGen object and register yourself with\n+ * addObserver().\n@@ -31,1 +30,1 @@\n-    void notify( MethodGen method );\n+    void notify(MethodGen method);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MethodObserver.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n- * <PRE>Stack: ... -&gt; ..., objectref<\/PRE>\n@@ -30,0 +29,3 @@\n+ * <PRE>\n+ * Stack: ... -&gt; ..., objectref\n+ * <\/PRE>\n@@ -31,2 +33,1 @@\n-public class NEW extends CPInstruction implements LoadClass, AllocationInstruction,\n-        ExceptionThrower, StackProducer {\n+public class NEW extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower, StackProducer {\n@@ -35,2 +36,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -41,1 +41,0 @@\n-\n@@ -46,15 +45,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n-            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n-            ExceptionConst.INSTANTIATION_ERROR);\n-    }\n-\n-\n-    @Override\n-    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n-        return (ObjectType) getType(cpg);\n-    }\n-\n-\n@@ -62,4 +46,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -70,1 +52,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -79,0 +61,11 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+            ExceptionConst.INSTANTIATION_ERROR);\n+    }\n+\n+    @Override\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+        return (ObjectType) getType(cpg);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NEW.java","additions":19,"deletions":26,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,3 +30,5 @@\n- * NEWARRAY -  Create new array of basic type (int, short, ...)\n- * <PRE>Stack: ..., count -&gt; ..., arrayref<\/PRE>\n- * type must be one of T_INT, T_SHORT, ...\n+ * NEWARRAY - Create new array of basic type (int, short, ...)\n+ *\n+ * <PRE>\n+ * Stack: ..., count -&gt; ..., arrayref\n+ * <\/PRE>\n@@ -34,0 +36,1 @@\n+ * type must be one of T_INT, T_SHORT, ...\n@@ -36,2 +39,1 @@\n-public class NEWARRAY extends Instruction implements AllocationInstruction, ExceptionThrower,\n-        StackProducer {\n+public class NEWARRAY extends Instruction implements AllocationInstruction, ExceptionThrower, StackProducer {\n@@ -41,1 +43,0 @@\n-\n@@ -43,2 +44,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -49,0 +49,3 @@\n+    public NEWARRAY(final BasicType type) {\n+        this(type.getType());\n+    }\n@@ -55,3 +58,12 @@\n-\n-    public NEWARRAY(final BasicType type) {\n-        this(type.getType());\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitAllocationInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitStackProducer(this);\n+        v.visitNEWARRAY(this);\n@@ -60,1 +72,0 @@\n-\n@@ -63,0 +74,1 @@\n+     *\n@@ -66,1 +78,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -71,6 +83,3 @@\n-\n-    \/**\n-     * @return numeric code for basic element type\n-     *\/\n-    public final byte getTypecode() {\n-        return type;\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION};\n@@ -79,1 +88,0 @@\n-\n@@ -87,1 +95,0 @@\n-\n@@ -89,1 +96,1 @@\n-     * @return mnemonic for instruction\n+     * @return numeric code for basic element type\n@@ -91,3 +98,2 @@\n-    @Override\n-    public String toString( final boolean verbose ) {\n-        return super.toString(verbose) + \" \" + com.sun.org.apache.bcel.internal.Const.getTypeName(type);\n+    public final byte getTypecode() {\n+        return type;\n@@ -96,1 +102,0 @@\n-\n@@ -101,1 +106,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -106,9 +111,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {\n-            ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION\n-        };\n-    }\n-\n-\n@@ -116,6 +112,1 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * @return mnemonic for instruction\n@@ -124,5 +115,2 @@\n-    public void accept( final Visitor v ) {\n-        v.visitAllocationInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitStackProducer(this);\n-        v.visitNEWARRAY(this);\n+    public String toString(final boolean verbose) {\n+        return super.toString(verbose) + \" \" + com.sun.org.apache.bcel.internal.Const.getTypeName(type);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NEWARRAY.java","additions":35,"deletions":47,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -34,1 +33,0 @@\n-\n@@ -36,4 +34,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +40,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NOP.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * Super class for FieldOrMethod and INVOKEDYNAMIC, since they both have\n- * names and signatures\n+ * Super class for FieldOrMethod and INVOKEDYNAMIC, since they both have names and signatures\n@@ -38,1 +37,0 @@\n-        super();\n@@ -45,0 +43,9 @@\n+    \/**\n+     * @return name of referenced method\/field.\n+     *\/\n+    public String getName(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantNameAndType cnat = getNameAndType(cpg);\n+        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n+    }\n+\n@@ -48,1 +55,1 @@\n-        return  (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n@@ -50,1 +57,3 @@\n-    \/** @return signature of referenced method\/field.\n+\n+    \/**\n+     * @return signature of referenced method\/field.\n@@ -58,8 +67,0 @@\n-    \/** @return name of referenced method\/field.\n-     *\/\n-    public String getName(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantNameAndType cnat = getNameAndType(cpg);\n-        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NameSignatureInstruction.java","additions":14,"deletions":13,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Denote entity that has both name and type. This is true for local variables,\n- * methods and fields.\n- *\n+ * Denote entity that has both name and type. This is true for local variables, methods and fields.\n@@ -33,1 +31,0 @@\n-\n@@ -36,0 +33,1 @@\n+    void setName(String name);\n@@ -37,4 +35,1 @@\n-    void setName( String name );\n-\n-\n-    void setType( Type type );\n+    void setType(Type type);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NamedAndTyped.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -30,1 +31,0 @@\n- *\n@@ -34,2 +34,0 @@\n-    private final String className; \/\/ Class name of type\n-\n@@ -37,0 +35,4 @@\n+     * Constructs a new instance.\n+     *\n+     * @param className fully qualified class name, e.g. java.lang.String\n+     * @return a new instance.\n@@ -43,0 +45,2 @@\n+    private final String className; \/\/ Class name of type\n+\n@@ -44,0 +48,2 @@\n+     * Constructs a new instance.\n+     *\n@@ -47,2 +53,2 @@\n-        super(Const.T_REFERENCE, \"L\" + className.replace('.', '\/') + \";\");\n-        this.className = className.replace('\/', '.');\n+        super(Const.T_REFERENCE, \"L\" + Utility.packageToPath(className) + \";\");\n+        this.className = Utility.pathToPackage(className);\n@@ -51,2 +57,4 @@\n-\n-    \/** @return name of referenced class\n+    \/**\n+     * Java Virtual Machine Specification edition 2,  5.4.4 Access Control\n+     *\n+     * @throws ClassNotFoundException if the class referenced by this type can't be found\n@@ -54,2 +62,7 @@\n-    public String getClassName() {\n-        return className;\n+    public boolean accessibleTo(final ObjectType accessor) throws ClassNotFoundException {\n+        final JavaClass jc = Repository.lookupClass(className);\n+        if (jc.isPublic()) {\n+            return true;\n+        }\n+        final JavaClass acc = Repository.lookupClass(accessor.className);\n+        return acc.getPackageName().equals(jc.getPackageName());\n@@ -58,2 +71,2 @@\n-\n-    \/** @return a hash code value for the object.\n+    \/**\n+     * @return true if both type objects refer to the same class.\n@@ -62,2 +75,2 @@\n-    public int hashCode() {\n-        return className.hashCode();\n+    public boolean equals(final Object type) {\n+        return type instanceof ObjectType && ((ObjectType) type).className.equals(className);\n@@ -66,2 +79,2 @@\n-\n-    \/** @return true if both type objects refer to the same class.\n+    \/**\n+     * @return name of referenced class\n@@ -70,4 +83,2 @@\n-    public boolean equals( final Object type ) {\n-        return (type instanceof ObjectType)\n-                ? ((ObjectType) type).className.equals(className)\n-                : false;\n+    public String getClassName() {\n+        return className;\n@@ -76,0 +87,7 @@\n+    \/**\n+     * @return a hash code value for the object.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return className.hashCode();\n+    }\n@@ -78,5 +96,3 @@\n-     * If \"this\" doesn't reference a class, it references an interface\n-     * or a non-existant entity.\n-     * @deprecated (since 6.0) this method returns an inaccurate result\n-     *   if the class or interface referenced cannot\n-     *   be found: use referencesClassExact() instead\n+     * If \"this\" doesn't reference a class, it references an interface or a non-existant entity.\n+     * @deprecated (since 6.0) this method returns an inaccurate result if the class or interface referenced cannot be\n+     *             found: use referencesClassExact() instead\n@@ -94,0 +110,10 @@\n+    \/**\n+     * Return true if this type references a class, false if it references an interface.\n+     *\n+     * @return true if the type references a class, false if it references an interface\n+     * @throws ClassNotFoundException if the class or interface referenced by this type can't be found\n+     *\/\n+    public boolean referencesClassExact() throws ClassNotFoundException {\n+        final JavaClass jc = Repository.lookupClass(className);\n+        return jc.isClass();\n+    }\n@@ -96,5 +122,4 @@\n-     * If \"this\" doesn't reference an interface, it references a class\n-     * or a non-existant entity.\n-     * @deprecated (since 6.0) this method returns an inaccurate result\n-     *   if the class or interface referenced cannot\n-     *   be found: use referencesInterfaceExact() instead\n+     * If \"this\" doesn't reference an interface, it references a class or a non-existant entity.\n+     *\n+     * @deprecated (since 6.0) this method returns an inaccurate result if the class or interface referenced cannot be\n+     *             found: use referencesInterfaceExact() instead\n@@ -112,1 +137,0 @@\n-\n@@ -114,20 +138,4 @@\n-     * Return true if this type references a class,\n-     * false if it references an interface.\n-     * @return true if the type references a class, false if\n-     *   it references an interface\n-     * @throws ClassNotFoundException if the class or interface\n-     *   referenced by this type can't be found\n-     *\/\n-    public boolean referencesClassExact() throws ClassNotFoundException {\n-        final JavaClass jc = Repository.lookupClass(className);\n-        return jc.isClass();\n-    }\n-\n-\n-    \/**\n-     * Return true if this type references an interface,\n-     * false if it references a class.\n-     * @return true if the type references an interface, false if\n-     *   it references a class\n-     * @throws ClassNotFoundException if the class or interface\n-     *   referenced by this type can't be found\n+     * Return true if this type references an interface, false if it references a class.\n+     *\n+     * @return true if the type references an interface, false if it references a class\n+     * @throws ClassNotFoundException if the class or interface referenced by this type can't be found\n@@ -140,1 +148,0 @@\n-\n@@ -143,2 +150,2 @@\n-     * @throws ClassNotFoundException if any of this class's superclasses\n-     *  can't be found\n+     *\n+     * @throws ClassNotFoundException if any of this class's superclasses can't be found\n@@ -146,1 +153,1 @@\n-    public boolean subclassOf( final ObjectType superclass ) throws ClassNotFoundException {\n+    public boolean subclassOf(final ObjectType superclass) throws ClassNotFoundException {\n@@ -152,15 +159,0 @@\n-\n-\n-    \/**\n-     * Java Virtual Machine Specification edition 2,  5.4.4 Access Control\n-     * @throws ClassNotFoundException if the class referenced by this type\n-     *   can't be found\n-     *\/\n-    public boolean accessibleTo( final ObjectType accessor ) throws ClassNotFoundException {\n-        final JavaClass jc = Repository.lookupClass(className);\n-        if (jc.isPublic()) {\n-            return true;\n-        }\n-        final JavaClass acc = Repository.lookupClass(accessor.className);\n-        return acc.getPackageName().equals(jc.getPackageName());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ObjectType.java","additions":61,"deletions":69,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., word -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., word -&gt; ...\n+ * <\/PRE>\n@@ -36,1 +37,0 @@\n-\n@@ -38,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/POP.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,2 +27,3 @@\n- * <PRE>Stack: ..., word2, word1 -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ..., word2, word1 -&gt; ...\n+ * <\/PRE>\n@@ -36,1 +37,0 @@\n-\n@@ -38,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/POP2.java","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,2 @@\n+import java.util.Objects;\n+\n@@ -26,4 +28,2 @@\n- * Wrapper class for push operations, which are implemented either as BIPUSH,\n- * LDC or xCONST_n instructions.\n- *\n- * @LastModified: Jan 2020\n+ * Wrapper class for push operations, which are implemented either as BIPUSH, LDC or xCONST_n instructions.\n+ * @LastModified: Feb 2023\n@@ -33,2 +33,1 @@\n-    private Instruction instruction;\n-\n+    private final Instruction instruction;\n@@ -37,1 +36,1 @@\n-     * This constructor also applies for values of type short, char, byte\n+     * Pushes an array type constant, for example {@code int[].class}, {@code String[].class}, and so on.\n@@ -39,2 +38,3 @@\n-     * @param cp Constant pool\n-     * @param value to be pushed\n+     * @param cp generated constant pool.\n+     * @param value to be pushed.\n+     * @since 6.7.0\n@@ -42,7 +42,3 @@\n-    public PUSH(final ConstantPoolGen cp, final int value) {\n-        if ((value >= -1) && (value <= 5)) {\n-            instruction = InstructionConst.getInstruction(Const.ICONST_0 + value);\n-        } else if (Instruction.isValidByte(value)) {\n-            instruction = new BIPUSH((byte) value);\n-        } else if (Instruction.isValidShort(value)) {\n-            instruction = new SIPUSH((short) value);\n+    public PUSH(final ConstantPoolGen cp, final ArrayType value) {\n+        if (value == null) {\n+            instruction = InstructionConst.ACONST_NULL;\n@@ -50,1 +46,1 @@\n-            instruction = new LDC(cp.addInteger(value));\n+            instruction = new LDC(cp.addArrayClass(value));\n@@ -54,2 +50,1 @@\n-\n-    \/**\n+   \/**\n@@ -60,0 +55,1 @@\n+        Objects.requireNonNull(cp, \"cp\");\n@@ -63,1 +59,0 @@\n-\n@@ -68,10 +63,2 @@\n-    public PUSH(final ConstantPoolGen cp, final float value) {\n-        if (value == 0.0) {\n-            instruction = InstructionConst.FCONST_0;\n-        } else if (value == 1.0) {\n-            instruction = InstructionConst.FCONST_1;\n-        } else if (value == 2.0) {\n-            instruction = InstructionConst.FCONST_2;\n-        } else {\n-            instruction = new LDC(cp.addFloat(value));\n-        }\n+    public PUSH(final ConstantPoolGen cp, final Boolean value) {\n+        this(cp, value.booleanValue());\n@@ -80,1 +67,0 @@\n-\n@@ -82,0 +68,3 @@\n+     * creates a push object from a Character value. Warning: Make sure not to attempt to allow autoboxing to create this\n+     * value parameter, as an alternative constructor will be called\n+     *\n@@ -85,8 +74,2 @@\n-    public PUSH(final ConstantPoolGen cp, final long value) {\n-        if (value == 0) {\n-            instruction = InstructionConst.LCONST_0;\n-        } else if (value == 1) {\n-            instruction = InstructionConst.LCONST_1;\n-        } else {\n-            instruction = new LDC2_W(cp.addLong(value));\n-        }\n+    public PUSH(final ConstantPoolGen cp, final Character value) {\n+        this(cp, value.charValue());\n@@ -95,1 +78,0 @@\n-\n@@ -110,1 +92,0 @@\n-\n@@ -115,3 +96,7 @@\n-    public PUSH(final ConstantPoolGen cp, final String value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n+    public PUSH(final ConstantPoolGen cp, final float value) {\n+        if (value == 0.0) {\n+            instruction = InstructionConst.FCONST_0;\n+        } else if (value == 1.0) {\n+            instruction = InstructionConst.FCONST_1;\n+        } else if (value == 2.0) {\n+            instruction = InstructionConst.FCONST_2;\n@@ -119,1 +104,1 @@\n-            instruction = new LDC(cp.addString(value));\n+            instruction = new LDC(cp.addFloat(value));\n@@ -124,0 +109,1 @@\n+     * This constructor also applies for values of type short, char, byte\n@@ -125,3 +111,2 @@\n-     * @param cp\n-     * @param value\n-     * @since 6.0\n+     * @param cp Constant pool\n+     * @param value to be pushed\n@@ -129,3 +114,7 @@\n-    public PUSH(final ConstantPoolGen cp, final ObjectType value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n+    public PUSH(final ConstantPoolGen cp, final int value) {\n+        if (value >= -1 && value <= 5) {\n+            instruction = InstructionConst.getInstruction(Const.ICONST_0 + value);\n+        } else if (Instruction.isValidByte(value)) {\n+            instruction = new BIPUSH((byte) value);\n+        } else if (Instruction.isValidShort(value)) {\n+            instruction = new SIPUSH((short) value);\n@@ -133,1 +122,15 @@\n-            instruction = new LDC(cp.addClass(value));\n+            instruction = new LDC(cp.addInteger(value));\n+        }\n+    }\n+\n+    \/**\n+     * @param cp Constant pool\n+     * @param value to be pushed\n+     *\/\n+    public PUSH(final ConstantPoolGen cp, final long value) {\n+        if (value == 0) {\n+            instruction = InstructionConst.LCONST_0;\n+        } else if (value == 1) {\n+            instruction = InstructionConst.LCONST_1;\n+        } else {\n+            instruction = new LDC2_W(cp.addLong(value));\n@@ -142,1 +145,1 @@\n-        if ((value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n+        if (value instanceof Integer || value instanceof Short || value instanceof Byte) {\n@@ -155,1 +158,0 @@\n-\n@@ -157,2 +159,0 @@\n-     * creates a push object from a Character value. Warning: Make sure not to attempt to allow\n-     * autoboxing to create this value parameter, as an alternative constructor will be called\n@@ -160,2 +160,3 @@\n-     * @param cp Constant pool\n-     * @param value to be pushed\n+     * @param cp\n+     * @param value\n+     * @since 6.0\n@@ -163,2 +164,6 @@\n-    public PUSH(final ConstantPoolGen cp, final Character value) {\n-        this(cp, value.charValue());\n+    public PUSH(final ConstantPoolGen cp, final ObjectType value) {\n+        if (value == null) {\n+            instruction = InstructionConst.ACONST_NULL;\n+        } else {\n+            instruction = new LDC(cp.addClass(value));\n+        }\n@@ -167,1 +172,0 @@\n-\n@@ -172,2 +176,6 @@\n-    public PUSH(final ConstantPoolGen cp, final Boolean value) {\n-        this(cp, value.booleanValue());\n+    public PUSH(final ConstantPoolGen cp, final String value) {\n+        if (value == null) {\n+            instruction = InstructionConst.ACONST_NULL;\n+        } else {\n+            instruction = new LDC(cp.addString(value));\n+        }\n@@ -176,0 +184,3 @@\n+    public Instruction getInstruction() {\n+        return instruction;\n+    }\n@@ -182,6 +193,0 @@\n-\n-    public Instruction getInstruction() {\n-        return instruction;\n-    }\n-\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUSH.java","additions":75,"deletions":70,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -29,1 +29,5 @@\n- * <PRE>Stack: ..., objectref, value -&gt; ...<\/PRE>\n+ *\n+ * <PRE>\n+ * Stack: ..., objectref, value -&gt; ...\n+ * <\/PRE>\n+ *\n@@ -31,1 +35,0 @@\n- * <PRE>Stack: ..., objectref, value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -33,0 +36,3 @@\n+ * <PRE>\n+ * Stack: ..., objectref, value.word1, value.word2 -&gt; ...\n+ * <\/PRE>\n@@ -37,2 +43,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,1 +48,0 @@\n-\n@@ -48,15 +52,0 @@\n-\n-    @Override\n-    public int consumeStack( final ConstantPoolGen cpg ) {\n-        return getFieldSize(cpg) + 1;\n-    }\n-\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n-            ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-\n@@ -64,4 +53,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -72,1 +59,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -83,0 +70,11 @@\n+\n+    @Override\n+    public int consumeStack(final ConstantPoolGen cpg) {\n+        return getFieldSize(cpg) + 1;\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUTFIELD.java","additions":23,"deletions":25,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,1 +29,5 @@\n- * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n+ * <PRE>\n+ * Stack: ..., value -&gt; ...\n+ * <\/PRE>\n+ *\n@@ -31,1 +35,0 @@\n- * <PRE>Stack: ..., value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -33,0 +36,3 @@\n+ * <PRE>\n+ * Stack: ..., value.word1, value.word2 -&gt; ...\n+ * <\/PRE>\n@@ -37,2 +43,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,1 +48,0 @@\n-\n@@ -48,14 +52,0 @@\n-\n-    @Override\n-    public int consumeStack( final ConstantPoolGen cpg ) {\n-        return getFieldSize(cpg);\n-    }\n-\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-\n@@ -63,4 +53,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -71,1 +59,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n@@ -82,0 +70,10 @@\n+\n+    @Override\n+    public int consumeStack(final ConstantPoolGen cpg) {\n+        return getFieldSize(cpg);\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUTSTATIC.java","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * Denotes an unparameterized instruction to pop a value on top from the stack,\n- * such as ISTORE, POP, PUTSTATIC.\n+ * Denotes an unparameterized instruction to pop a value on top from the stack, such as ISTORE, POP, PUTSTATIC.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PopInstruction.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Denotes an unparameterized instruction to produce a value on top of the stack,\n- * such as ILOAD, LDC, SIPUSH, DUP, ICONST, etc.\n+ * Denotes an unparameterized instruction to produce a value on top of the stack, such as ILOAD, LDC, SIPUSH, DUP,\n+ * ICONST, etc.\n+ *\n@@ -28,1 +29,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PushInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * <PRE>Stack: ... -&gt; ...<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ...\n+ * <\/PRE>\n@@ -40,1 +41,0 @@\n-\n@@ -42,2 +42,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -48,1 +47,0 @@\n-\n@@ -54,0 +52,10 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitRET(this);\n+    }\n@@ -57,0 +65,1 @@\n+     *\n@@ -60,1 +69,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -72,8 +81,6 @@\n-\n-    private void setWide() {\n-        wide = index > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n-        if (wide) {\n-            super.setLength(4); \/\/ Including the wide byte\n-        } else {\n-            super.setLength(2);\n-        }\n+    \/**\n+     * @return index of local variable containg the return address\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return index;\n@@ -82,0 +89,7 @@\n+    \/**\n+     * @return return address type\n+     *\/\n+    @Override\n+    public Type getType(final ConstantPoolGen cp) {\n+        return ReturnaddressType.NO_TARGET;\n+    }\n@@ -87,1 +101,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -98,10 +112,0 @@\n-\n-    \/**\n-     * @return index of local variable containg the return address\n-     *\/\n-    @Override\n-    public final int getIndex() {\n-        return index;\n-    }\n-\n-\n@@ -112,1 +116,1 @@\n-    public final void setIndex( final int n ) {\n+    public final void setIndex(final int n) {\n@@ -120,0 +124,8 @@\n+    private void setWide() {\n+        wide = index > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n+        if (wide) {\n+            super.setLength(4); \/\/ Including the wide byte\n+        } else {\n+            super.setLength(2);\n+        }\n+    }\n@@ -125,1 +137,1 @@\n-    public String toString( final boolean verbose ) {\n+    public String toString(final boolean verbose) {\n@@ -128,22 +140,0 @@\n-\n-\n-    \/** @return return address type\n-     *\/\n-    @Override\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return ReturnaddressType.NO_TARGET;\n-    }\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitRET(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/RET.java","additions":40,"deletions":50,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -25,2 +25,1 @@\n- * RETURN -  Return from void method\n- * <PRE>Stack: ... -&gt; &lt;empty&gt;<\/PRE>\n+ * RETURN - Return from void method\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ... -&gt; &lt;empty&gt;\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/RETURN.java","additions":7,"deletions":8,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- *\n@@ -33,0 +32,7 @@\n+    \/**\n+     * Class is non-abstract but not instantiable from the outside\n+     *\/\n+    ReferenceType() {\n+        super(Const.T_OBJECT, \"<null object>\");\n+    }\n+\n@@ -37,2 +43,10 @@\n-\n-    \/** Class is non-abstract but not instantiable from the outside\n+    \/**\n+     * This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an\n+     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n+     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n+     * \"this\" or t is an ArrayType, then Type.OBJECT is returned. If \"this\" or t is a ReferenceType referencing an\n+     * interface, then Type.OBJECT is returned. If not all of the two classes' superclasses cannot be found, \"null\" is\n+     * returned. See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n+     *\n+     * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has slightly changed semantics.\n+     * @throws ClassNotFoundException on failure to find superclasses of this type, or the type passed as a parameter\n@@ -40,2 +54,18 @@\n-    ReferenceType() {\n-        super(Const.T_OBJECT, \"<null object>\");\n+    @Deprecated\n+    public ReferenceType firstCommonSuperclass(final ReferenceType t) throws ClassNotFoundException {\n+        if (this.equals(Type.NULL)) {\n+            return t;\n+        }\n+        if (t.equals(Type.NULL) || this.equals(t)) {\n+            return this;\n+            \/*\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n+             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n+             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n+             *\/\n+        }\n+        if (this instanceof ArrayType || t instanceof ArrayType) {\n+            return Type.OBJECT;\n+            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+        }\n+        return getFirstCommonSuperclassInternal(t);\n@@ -44,1 +74,0 @@\n-\n@@ -46,6 +75,8 @@\n-     * Return true iff this type is castable to another type t as defined in\n-     * the JVM specification.  The case where this is Type.NULL is not\n-     * defined (see the CHECKCAST definition in the JVM specification).\n-     * However, because e.g. CHECKCAST doesn't throw a\n-     * ClassCastException when casting a null reference to any Object,\n-     * true is returned in this case.\n+     * This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an\n+     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n+     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n+     * \"this\" or t is an ArrayType, then Type.OBJECT is returned; unless their dimensions match. Then an ArrayType of the\n+     * same number of dimensions is returned, with its basic type being the first common super class of the basic types of\n+     * \"this\" and t. If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned. If not all of\n+     * the two classes' superclasses cannot be found, \"null\" is returned. See the JVM specification edition 2, \"4.9.2 The\n+     * Bytecode Verifier\".\n@@ -53,2 +84,1 @@\n-     * @throws ClassNotFoundException if any classes or interfaces required\n-     *  to determine assignment compatibility can't be found\n+     * @throws ClassNotFoundException on failure to find superclasses of this type, or the type passed as a parameter\n@@ -56,1 +86,1 @@\n-    public boolean isCastableTo( final Type t ) throws ClassNotFoundException {\n+    public ReferenceType getFirstCommonSuperclass(final ReferenceType t) throws ClassNotFoundException {\n@@ -58,1 +88,1 @@\n-            return t instanceof ReferenceType; \/\/ If this is ever changed in isAssignmentCompatible()\n+            return t;\n@@ -60,4 +90,23 @@\n-        return isAssignmentCompatibleWith(t);\n-        \/* Yes, it's true: It's the same definition.\n-         * See vmspec2 AASTORE \/ CHECKCAST definitions.\n-         *\/\n+        if (t.equals(Type.NULL) || this.equals(t)) {\n+            return this;\n+            \/*\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n+             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n+             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n+             *\/\n+        }\n+        \/* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> *\/\n+        if (this instanceof ArrayType && t instanceof ArrayType) {\n+            final ArrayType arrType1 = (ArrayType) this;\n+            final ArrayType arrType2 = (ArrayType) t;\n+            if (arrType1.getDimensions() == arrType2.getDimensions() && arrType1.getBasicType() instanceof ObjectType\n+                && arrType2.getBasicType() instanceof ObjectType) {\n+                return new ArrayType(((ObjectType) arrType1.getBasicType()).getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()),\n+                    arrType1.getDimensions());\n+            }\n+        }\n+        if (this instanceof ArrayType || t instanceof ArrayType) {\n+            return Type.OBJECT;\n+            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+        }\n+        return getFirstCommonSuperclassInternal(t);\n@@ -66,0 +115,33 @@\n+    private ReferenceType getFirstCommonSuperclassInternal(final ReferenceType t) throws ClassNotFoundException {\n+        if (this instanceof ObjectType && ((ObjectType) this).referencesInterfaceExact()\n+            || t instanceof ObjectType && ((ObjectType) t).referencesInterfaceExact()) {\n+            return Type.OBJECT;\n+            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n+            \/\/ make class file verification a bit stronger here by using the notion of\n+            \/\/ superinterfaces or even castability or assignment compatibility.\n+        }\n+        \/\/ this and t are ObjectTypes, see above.\n+        final ObjectType thiz = (ObjectType) this;\n+        final ObjectType other = (ObjectType) t;\n+        final JavaClass[] thizSups = Repository.getSuperClasses(thiz.getClassName());\n+        final JavaClass[] otherSups = Repository.getSuperClasses(other.getClassName());\n+        if (thizSups == null || otherSups == null) {\n+            return null;\n+        }\n+        \/\/ Waaahh...\n+        final JavaClass[] thisSups = new JavaClass[thizSups.length + 1];\n+        final JavaClass[] tSups = new JavaClass[otherSups.length + 1];\n+        System.arraycopy(thizSups, 0, thisSups, 1, thizSups.length);\n+        System.arraycopy(otherSups, 0, tSups, 1, otherSups.length);\n+        thisSups[0] = Repository.lookupClass(thiz.getClassName());\n+        tSups[0] = Repository.lookupClass(other.getClassName());\n+        for (final JavaClass tSup : tSups) {\n+            for (final JavaClass thisSup : thisSups) {\n+                if (thisSup.equals(tSup)) {\n+                    return ObjectType.getInstance(thisSup.getClassName());\n+                }\n+            }\n+        }\n+        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n+        return null;\n+    }\n@@ -68,5 +150,5 @@\n-     * Return true iff this is assignment compatible with another type t\n-     * as defined in the JVM specification; see the AASTORE definition\n-     * there.\n-     * @throws ClassNotFoundException if any classes or interfaces required\n-     *  to determine assignment compatibility can't be found\n+     * Return true iff this is assignment compatible with another type t as defined in the JVM specification; see the\n+     * AASTORE definition there.\n+     *\n+     * @throws ClassNotFoundException if any classes or interfaces required to determine assignment compatibility can't be\n+     *         found\n@@ -74,1 +156,1 @@\n-    public boolean isAssignmentCompatibleWith( final Type t ) throws ClassNotFoundException {\n+    public boolean isAssignmentCompatibleWith(final Type t) throws ClassNotFoundException {\n@@ -80,1 +162,1 @@\n-            return true; \/\/ This is not explicitely stated, but clear. Isn't it?\n+            return true; \/\/ This is not explicitly stated, but clear. Isn't it?\n@@ -82,1 +164,2 @@\n-        \/* If this is a class type then\n+        \/*\n+         * If this is a class type then\n@@ -84,3 +167,3 @@\n-        if ((this instanceof ObjectType) && (((ObjectType) this).referencesClassExact())) {\n-            \/* If T is a class type, then this must be the same class as T,\n-             or this must be a subclass of T;\n+        if (this instanceof ObjectType && ((ObjectType) this).referencesClassExact()) {\n+            \/*\n+             * If T is a class type, then this must be the same class as T, or this must be a subclass of T;\n@@ -88,8 +171,3 @@\n-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n-                if (this.equals(T)) {\n-                    return true;\n-                }\n-                if (Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T)\n-                        .getClassName())) {\n-                    return true;\n-                }\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact()\n+                && (this.equals(T) || Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n+                return true;\n@@ -97,1 +175,2 @@\n-            \/* If T is an interface type, this must implement interface T.\n+            \/*\n+             * If T is an interface type, this must implement interface T.\n@@ -99,5 +178,3 @@\n-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n-                if (Repository.implementationOf(((ObjectType) this).getClassName(),\n-                        ((ObjectType) T).getClassName())) {\n-                    return true;\n-                }\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()\n+                && Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName())) {\n+                return true;\n@@ -106,1 +183,2 @@\n-        \/* If this is an interface type, then:\n+        \/*\n+         * If this is an interface type, then:\n@@ -108,2 +186,3 @@\n-        if ((this instanceof ObjectType) && (((ObjectType) this).referencesInterfaceExact())) {\n-            \/* If T is a class type, then T must be Object (2.4.7).\n+        if (this instanceof ObjectType && ((ObjectType) this).referencesInterfaceExact()) {\n+            \/*\n+             * If T is a class type, then T must be Object (2.4.7).\n@@ -111,4 +190,2 @@\n-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n-                if (T.equals(Type.OBJECT)) {\n-                    return true;\n-                }\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n+                return true;\n@@ -116,2 +193,2 @@\n-            \/* If T is an interface type, then T must be the same interface\n-             * as this or a superinterface of this (2.13.2).\n+            \/*\n+             * If T is an interface type, then T must be the same interface as this or a superinterface of this (2.13.2).\n@@ -119,8 +196,3 @@\n-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n-                if (this.equals(T)) {\n-                    return true;\n-                }\n-                if (Repository.implementationOf(((ObjectType) this).getClassName(),\n-                        ((ObjectType) T).getClassName())) {\n-                    return true;\n-                }\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()\n+                && (this.equals(T) || Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n+                return true;\n@@ -129,2 +201,2 @@\n-        \/* If this is an array type, namely, the type SC[], that is, an\n-         * array of components of type SC, then:\n+        \/*\n+         * If this is an array type, namely, the type SC[], that is, an array of components of type SC, then:\n@@ -133,1 +205,2 @@\n-            \/* If T is a class type, then T must be Object (2.4.7).\n+            \/*\n+             * If T is a class type, then T must be Object (2.4.7).\n@@ -135,4 +208,2 @@\n-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n-                if (T.equals(Type.OBJECT)) {\n-                    return true;\n-                }\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n+                return true;\n@@ -140,2 +211,2 @@\n-            \/* If T is an array type TC[], that is, an array of components\n-             * of type TC, then one of the following must be true:\n+            \/*\n+             * If T is an array type TC[], that is, an array of components of type TC, then one of the following must be true:\n@@ -144,1 +215,2 @@\n-                \/* TC and SC are the same primitive type (2.4.1).\n+                \/*\n+                 * TC and SC are the same primitive type (2.4.1).\n@@ -151,2 +223,2 @@\n-                \/* TC and SC are reference types (2.4.6), and type SC is\n-                 * assignable to TC by these runtime rules.\n+                \/*\n+                 * TC and SC are reference types (2.4.6), and type SC is assignable to TC by these runtime rules.\n@@ -154,2 +226,1 @@\n-                if (tc instanceof ReferenceType && sc instanceof ReferenceType\n-                        && ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {\n+                if (tc instanceof ReferenceType && sc instanceof ReferenceType && ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {\n@@ -165,1 +236,1 @@\n-            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n+            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()) {\n@@ -176,1 +247,0 @@\n-\n@@ -178,13 +248,3 @@\n-     * This commutative operation returns the first common superclass (narrowest ReferenceType\n-     * referencing a class, not an interface).\n-     * If one of the types is a superclass of the other, the former is returned.\n-     * If \"this\" is Type.NULL, then t is returned.\n-     * If t is Type.NULL, then \"this\" is returned.\n-     * If \"this\" equals t ['this.equals(t)'] \"this\" is returned.\n-     * If \"this\" or t is an ArrayType, then Type.OBJECT is returned;\n-     * unless their dimensions match. Then an ArrayType of the same\n-     * number of dimensions is returned, with its basic type being the\n-     * first common super class of the basic types of \"this\" and t.\n-     * If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.\n-     * If not all of the two classes' superclasses cannot be found, \"null\" is returned.\n-     * See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n+     * Return true iff this type is castable to another type t as defined in the JVM specification. The case where this is\n+     * Type.NULL is not defined (see the CHECKCAST definition in the JVM specification). However, because e.g. CHECKCAST\n+     * doesn't throw a ClassCastException when casting a null reference to any Object, true is returned in this case.\n@@ -192,2 +252,2 @@\n-     * @throws ClassNotFoundException on failure to find superclasses of this\n-     *  type, or the type passed as a parameter\n+     * @throws ClassNotFoundException if any classes or interfaces required to determine assignment compatibility can't be\n+     *         found\n@@ -195,1 +255,1 @@\n-    public ReferenceType getFirstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {\n+    public boolean isCastableTo(final Type t) throws ClassNotFoundException {\n@@ -197,131 +257,1 @@\n-            return t;\n-        }\n-        if (t.equals(Type.NULL)) {\n-            return this;\n-        }\n-        if (this.equals(t)) {\n-            return this;\n-            \/*\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is\n-             * no object referenced by Type.NULL so we can also say all the objects\n-             * referenced by Type.NULL were derived from java.lang.Object.\n-             * However, the Java Language's \"instanceof\" operator proves us wrong:\n-             * \"null\" is not referring to an instance of java.lang.Object :)\n-             *\/\n-        }\n-        \/* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> *\/\n-        if ((this instanceof ArrayType) && (t instanceof ArrayType)) {\n-            final ArrayType arrType1 = (ArrayType) this;\n-            final ArrayType arrType2 = (ArrayType) t;\n-            if ((arrType1.getDimensions() == arrType2.getDimensions())\n-                    && arrType1.getBasicType() instanceof ObjectType\n-                    && arrType2.getBasicType() instanceof ObjectType) {\n-                return new ArrayType(((ObjectType) arrType1.getBasicType())\n-                        .getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()), arrType1\n-                        .getDimensions());\n-            }\n-        }\n-        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n-        }\n-        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterfaceExact())\n-                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterfaceExact())) {\n-            return Type.OBJECT;\n-            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n-            \/\/ make class file verification a bit stronger here by using the notion of\n-            \/\/ superinterfaces or even castability or assignment compatibility.\n-        }\n-        \/\/ this and t are ObjectTypes, see above.\n-        final ObjectType thiz = (ObjectType) this;\n-        final ObjectType other = (ObjectType) t;\n-        final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());\n-        final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());\n-        if ((thiz_sups == null) || (other_sups == null)) {\n-            return null;\n-        }\n-        \/\/ Waaahh...\n-        final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];\n-        final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];\n-        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);\n-        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);\n-        this_sups[0] = Repository.lookupClass(thiz.getClassName());\n-        t_sups[0] = Repository.lookupClass(other.getClassName());\n-        for (final JavaClass t_sup : t_sups) {\n-            for (final JavaClass this_sup : this_sups) {\n-                if (this_sup.equals(t_sup)) {\n-                    return ObjectType.getInstance(this_sup.getClassName());\n-                }\n-            }\n-        }\n-        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n-        return null;\n-    }\n-\n-    \/**\n-     * This commutative operation returns the first common superclass (narrowest ReferenceType\n-     * referencing a class, not an interface).\n-     * If one of the types is a superclass of the other, the former is returned.\n-     * If \"this\" is Type.NULL, then t is returned.\n-     * If t is Type.NULL, then \"this\" is returned.\n-     * If \"this\" equals t ['this.equals(t)'] \"this\" is returned.\n-     * If \"this\" or t is an ArrayType, then Type.OBJECT is returned.\n-     * If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.\n-     * If not all of the two classes' superclasses cannot be found, \"null\" is returned.\n-     * See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n-     *\n-     * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has\n-     *             slightly changed semantics.\n-     * @throws ClassNotFoundException on failure to find superclasses of this\n-     *  type, or the type passed as a parameter\n-     *\/\n-    @Deprecated\n-    public ReferenceType firstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {\n-        if (this.equals(Type.NULL)) {\n-            return t;\n-        }\n-        if (t.equals(Type.NULL)) {\n-            return this;\n-        }\n-        if (this.equals(t)) {\n-            return this;\n-            \/*\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is\n-             * no object referenced by Type.NULL so we can also say all the objects\n-             * referenced by Type.NULL were derived from java.lang.Object.\n-             * However, the Java Language's \"instanceof\" operator proves us wrong:\n-             * \"null\" is not referring to an instance of java.lang.Object :)\n-             *\/\n-        }\n-        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n-        }\n-        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterface())\n-                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterface())) {\n-            return Type.OBJECT;\n-            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n-            \/\/ make class file verification a bit stronger here by using the notion of\n-            \/\/ superinterfaces or even castability or assignment compatibility.\n-        }\n-        \/\/ this and t are ObjectTypes, see above.\n-        final ObjectType thiz = (ObjectType) this;\n-        final ObjectType other = (ObjectType) t;\n-        final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());\n-        final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());\n-        if ((thiz_sups == null) || (other_sups == null)) {\n-            return null;\n-        }\n-        \/\/ Waaahh...\n-        final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];\n-        final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];\n-        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);\n-        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);\n-        this_sups[0] = Repository.lookupClass(thiz.getClassName());\n-        t_sups[0] = Repository.lookupClass(other.getClassName());\n-        for (final JavaClass t_sup : t_sups) {\n-            for (final JavaClass this_sup : this_sups) {\n-                if (this_sup.equals(t_sup)) {\n-                    return ObjectType.getInstance(this_sup.getClassName());\n-                }\n-            }\n+            return t instanceof ReferenceType; \/\/ If this is ever changed in isAssignmentCompatible()\n@@ -329,2 +259,4 @@\n-        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n-        return null;\n+        return isAssignmentCompatibleWith(t);\n+        \/*\n+         * Yes, it's true: It's the same definition. See vmspec2 AASTORE \/ CHECKCAST definitions.\n+         *\/\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReferenceType.java","additions":159,"deletions":227,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Feb 2023\n@@ -31,2 +31,1 @@\n-public abstract class ReturnInstruction extends Instruction implements ExceptionThrower,\n-        TypedInstruction, StackConsumer {\n+public abstract class ReturnInstruction extends Instruction implements ExceptionThrower, TypedInstruction, StackConsumer {\n@@ -35,2 +34,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -41,1 +39,0 @@\n-\n@@ -49,22 +46,0 @@\n-\n-    public Type getType() {\n-        final short _opcode = super.getOpcode();\n-        switch (_opcode) {\n-            case Const.IRETURN:\n-                return Type.INT;\n-            case Const.LRETURN:\n-                return Type.LONG;\n-            case Const.FRETURN:\n-                return Type.FLOAT;\n-            case Const.DRETURN:\n-                return Type.DOUBLE;\n-            case Const.ARETURN:\n-                return Type.OBJECT;\n-            case Const.RETURN:\n-                return Type.VOID;\n-            default: \/\/ Never reached\n-                throw new ClassGenException(\"Unknown type \" + _opcode);\n-        }\n-    }\n-\n-\n@@ -73,3 +48,1 @@\n-        return new Class<?>[] {\n-            ExceptionConst.ILLEGAL_MONITOR_STATE\n-        };\n+        return new Class<?>[] {ExceptionConst.ILLEGAL_MONITOR_STATE};\n@@ -78,0 +51,19 @@\n+    public Type getType() {\n+        final short opcode = super.getOpcode();\n+        switch (opcode) {\n+        case Const.IRETURN:\n+            return Type.INT;\n+        case Const.LRETURN:\n+            return Type.LONG;\n+        case Const.FRETURN:\n+            return Type.FLOAT;\n+        case Const.DRETURN:\n+            return Type.DOUBLE;\n+        case Const.ARETURN:\n+            return Type.OBJECT;\n+        case Const.RETURN:\n+            return Type.VOID;\n+        default: \/\/ Never reached\n+            throw new ClassGenException(\"Unknown type \" + opcode);\n+        }\n+    }\n@@ -79,1 +71,2 @@\n-    \/** @return type associated with the instruction\n+    \/**\n+     * @return type associated with the instruction\n@@ -82,1 +75,1 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n+    public Type getType(final ConstantPoolGen cp) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReturnInstruction.java","additions":27,"deletions":34,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -36,1 +36,0 @@\n-\n@@ -44,1 +43,0 @@\n-\n@@ -53,12 +51,0 @@\n-\n-    \/** @return a hash code value for the object.\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        if (returnTarget == null) {\n-            return 0;\n-        }\n-        return returnTarget.hashCode();\n-    }\n-\n-\n@@ -69,1 +55,1 @@\n-    public boolean equals( final Object rat ) {\n+    public boolean equals(final Object rat) {\n@@ -80,1 +66,0 @@\n-\n@@ -87,0 +72,11 @@\n+\n+    \/**\n+     * @return a hash code value for the object.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        if (returnTarget == null) {\n+            return 0;\n+        }\n+        return returnTarget.hashCode();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReturnaddressType.java","additions":12,"deletions":16,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index -&gt; ..., value\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SALOAD.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., arrayref, index, value -&gt; ...\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SASTORE.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * <PRE>Stack: ... -&gt; ..., value<\/PRE>\n- *\n+ * <PRE>\n+ * Stack: ... -&gt; ..., value\n+ * <\/PRE>\n@@ -38,1 +39,0 @@\n-\n@@ -40,2 +40,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -46,1 +45,0 @@\n-\n@@ -52,1 +50,0 @@\n-\n@@ -54,1 +51,4 @@\n-     * Dump instruction as short code to stream out.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -57,3 +57,6 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        super.dump(out);\n-        out.writeShort(b);\n+    public void accept(final Visitor v) {\n+        v.visitPushInstruction(this);\n+        v.visitStackProducer(this);\n+        v.visitTypedInstruction(this);\n+        v.visitConstantPushInstruction(this);\n+        v.visitSIPUSH(this);\n@@ -62,1 +65,0 @@\n-\n@@ -64,1 +66,1 @@\n-     * @return mnemonic for instruction\n+     * Dump instruction as short code to stream out.\n@@ -67,2 +69,3 @@\n-    public String toString( final boolean verbose ) {\n-        return super.toString(verbose) + \" \" + b;\n+    public void dump(final DataOutputStream out) throws IOException {\n+        super.dump(out);\n+        out.writeShort(b);\n@@ -71,1 +74,0 @@\n-\n@@ -73,1 +75,1 @@\n-     * Read needed data (e.g. index) from file.\n+     * @return Type.SHORT\n@@ -76,3 +78,2 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n-        super.setLength(3);\n-        b = bytes.readShort();\n+    public Type getType(final ConstantPoolGen cp) {\n+        return Type.SHORT;\n@@ -81,1 +82,0 @@\n-\n@@ -87,2 +87,2 @@\n-\n-    \/** @return Type.SHORT\n+    \/**\n+     * Read needed data (e.g. index) from file.\n@@ -91,2 +91,3 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n-        return Type.SHORT;\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+        super.setLength(3);\n+        b = bytes.readShort();\n@@ -95,1 +96,0 @@\n-\n@@ -97,6 +97,1 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * @return mnemonic for instruction\n@@ -105,6 +100,2 @@\n-    public void accept( final Visitor v ) {\n-        v.visitPushInstruction(this);\n-        v.visitStackProducer(this);\n-        v.visitTypedInstruction(this);\n-        v.visitConstantPushInstruction(this);\n-        v.visitSIPUSH(this);\n+    public String toString(final boolean verbose) {\n+        return super.toString(verbose) + \" \" + b;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SIPUSH.java","additions":29,"deletions":38,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2<\/PRE>\n@@ -28,0 +27,3 @@\n+ * <PRE>\n+ * Stack: ..., word2, word1 -&gt; ..., word1, word2\n+ * <\/PRE>\n@@ -35,1 +37,0 @@\n-\n@@ -37,4 +38,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +44,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SWAP.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+import java.util.Arrays;\n+\n@@ -25,4 +27,2 @@\n- * SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or\n- * TABLESWITCH instruction, depending on whether the match values (int[]) can be\n- * sorted with no gaps between the numbers.\n- *\n+ * SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or TABLESWITCH instruction, depending on\n+ * whether the match values (int[]) can be sorted with no gaps between the numbers.\n@@ -32,6 +32,0 @@\n-    private int[] match;\n-    private InstructionHandle[] targets;\n-    private Select instruction;\n-    private int matchLength;\n-\n-\n@@ -39,13 +33,1 @@\n-     * Template for switch() constructs. If the match array can be\n-     * sorted in ascending order with gaps no larger than max_gap\n-     * between the numbers, a TABLESWITCH instruction is generated, and\n-     * a LOOKUPSWITCH otherwise. The former may be more efficient, but\n-     * needs more space.\n-     *\n-     * Note, that the key array always will be sorted, though we leave\n-     * the original arrays unaltered.\n-     *\n-     * @param match array of match values (case 2: ... case 7: ..., etc.)\n-     * @param targets the instructions to be branched to for each case\n-     * @param target the default target\n-     * @param max_gap maximum gap that may between case branches\n+     * @return match is sorted in ascending order with no gap bigger than maxGap?\n@@ -53,29 +35,1 @@\n-    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int max_gap) {\n-        this.match = match.clone();\n-        this.targets = targets.clone();\n-        if ((matchLength = match.length) < 2) {\n-            instruction = new TABLESWITCH(match, targets, target);\n-        } else {\n-            sort(0, matchLength - 1);\n-            if (matchIsOrdered(max_gap)) {\n-                fillup(max_gap, target);\n-                instruction = new TABLESWITCH(this.match, this.targets, target);\n-            } else {\n-                instruction = new LOOKUPSWITCH(this.match, this.targets, target);\n-            }\n-        }\n-    }\n-\n-\n-    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n-        this(match, targets, target, 1);\n-    }\n-\n-\n-    private void fillup( final int max_gap, final InstructionHandle target ) {\n-        final int max_size = matchLength + matchLength * max_gap;\n-        final int[] m_vec = new int[max_size];\n-        final InstructionHandle[] t_vec = new InstructionHandle[max_size];\n-        int count = 1;\n-        m_vec[0] = match[0];\n-        t_vec[0] = targets[0];\n+    private static boolean matchIsOrdered(final int[] match, final int matchLength, final int maxGap) {\n@@ -83,6 +37,2 @@\n-            final int prev = match[i - 1];\n-            final int gap = match[i] - prev;\n-            for (int j = 1; j < gap; j++) {\n-                m_vec[count] = prev + j;\n-                t_vec[count] = target;\n-                count++;\n+            if (match[i] - match[i - 1] > maxGap) {\n+                return false;\n@@ -90,3 +40,0 @@\n-            m_vec[count] = match[i];\n-            t_vec[count] = targets[i];\n-            count++;\n@@ -94,4 +41,1 @@\n-        match = new int[count];\n-        targets = new InstructionHandle[count];\n-        System.arraycopy(m_vec, 0, match, 0, count);\n-        System.arraycopy(t_vec, 0, targets, 0, count);\n+        return true;\n@@ -100,1 +44,0 @@\n-\n@@ -102,1 +45,1 @@\n-     * Sort match and targets array with QuickSort.\n+     * Sorts match and targets array with QuickSort.\n@@ -104,1 +47,1 @@\n-    private void sort( final int l, final int r ) {\n+    private static void sort(final int l, final int r, final int[] match, final InstructionHandle[] targets) {\n@@ -108,1 +51,1 @@\n-        final int m = match[(l + r) >>> 1];\n+        final int m = match[l + r >>> 1];\n@@ -129,1 +72,1 @@\n-            sort(l, j);\n+            sort(l, j, match, targets);\n@@ -132,1 +75,1 @@\n-            sort(i, r);\n+            sort(i, r, match, targets);\n@@ -136,0 +79,5 @@\n+    private final Select instruction;\n+\n+    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n+        this(match, targets, target, 1);\n+    }\n@@ -138,1 +86,10 @@\n-     * @return match is sorted in ascending order with no gap bigger than max_gap?\n+     * Template for switch() constructs. If the match array can be sorted in ascending order with gaps no larger than\n+     * maxGap between the numbers, a TABLESWITCH instruction is generated, and a LOOKUPSWITCH otherwise. The former may be\n+     * more efficient, but needs more space.\n+     *\n+     * Note, that the key array always will be sorted, though we leave the original arrays unaltered.\n+     *\n+     * @param match array of match values (case 2: ... case 7: ..., etc.)\n+     * @param targets the instructions to be branched to for each case\n+     * @param target the default target\n+     * @param maxGap maximum gap that may between case branches\n@@ -140,4 +97,30 @@\n-    private boolean matchIsOrdered( final int max_gap ) {\n-        for (int i = 1; i < matchLength; i++) {\n-            if (match[i] - match[i - 1] > max_gap) {\n-                return false;\n+    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int maxGap) {\n+        int[] matchClone = match.clone();\n+        final InstructionHandle[] targetsClone = targets.clone();\n+        final int matchLength = match.length;\n+        if (matchLength < 2) {\n+            instruction = new TABLESWITCH(match, targets, target);\n+        } else {\n+            sort(0, matchLength - 1, matchClone, targetsClone);\n+            if (matchIsOrdered(matchClone, matchLength, maxGap)) {\n+                final int maxSize = matchLength + matchLength * maxGap;\n+                final int[] mVec = new int[maxSize];\n+                final InstructionHandle[] tVec = new InstructionHandle[maxSize];\n+                int count = 1;\n+                mVec[0] = match[0];\n+                tVec[0] = targets[0];\n+                for (int i = 1; i < matchLength; i++) {\n+                    final int prev = match[i - 1];\n+                    final int gap = match[i] - prev;\n+                    for (int j = 1; j < gap; j++) {\n+                        mVec[count] = prev + j;\n+                        tVec[count] = target;\n+                        count++;\n+                    }\n+                    mVec[count] = match[i];\n+                    tVec[count] = targets[i];\n+                    count++;\n+                }\n+                instruction = new TABLESWITCH(Arrays.copyOf(mVec, count), Arrays.copyOf(tVec, count), target);\n+            } else {\n+                instruction = new LOOKUPSWITCH(matchClone, targetsClone, target);\n@@ -146,1 +129,0 @@\n-        return true;\n@@ -149,0 +131,3 @@\n+    public Instruction getInstruction() {\n+        return instruction;\n+    }\n@@ -154,5 +139,0 @@\n-\n-\n-    public Instruction getInstruction() {\n-        return instruction;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SWITCH.java","additions":62,"deletions":82,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * <p>We use our super's {@code target} property as the default target.\n+ * <p>\n+ * We use our super's {@code target} property as the default target.\n@@ -37,2 +38,1 @@\n-public abstract class Select extends BranchInstruction implements VariableLengthInstruction,\n-        StackConsumer \/* @since 6.0 *\/, StackProducer {\n+public abstract class Select extends BranchInstruction implements VariableLengthInstruction, StackConsumer \/* @since 6.0 *\/, StackProducer {\n@@ -40,6 +40,17 @@\n-    private int[] match; \/\/ matches, i.e., case 1: ... TODO could be package-protected?\n-    private int[] indices; \/\/ target offsets TODO could be package-protected?\n-    private InstructionHandle[] targets; \/\/ target objects in instruction list TODO could be package-protected?\n-    private int fixed_length; \/\/ fixed length defined by subclasses TODO could be package-protected?\n-    private int match_length; \/\/ number of cases TODO could be package-protected?\n-    private int padding = 0; \/\/ number of pad bytes for alignment TODO could be package-protected?\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int[] match; \/\/ matches, i.e., case 1: ... TODO could be package-protected?\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int[] indices; \/\/ target offsets TODO could be package-protected?\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected InstructionHandle[] targets; \/\/ target objects in instruction list TODO could be package-protected?\n@@ -48,2 +59,19 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int fixed_length; \/\/ fixed length defined by subclasses TODO could be package-protected?\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int match_length; \/\/ number of cases TODO could be package-protected?\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected int padding; \/\/ number of pad bytes for alignment TODO could be package-protected?\n+\n+    \/**\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -54,1 +82,0 @@\n-\n@@ -56,2 +83,1 @@\n-     * (Match, target) pairs for switch.\n-     * `Match' and `targets' must have the same length of course.\n+     * (Match, target) pairs for switch. 'Match' and 'targets' must have the same length of course.\n@@ -74,2 +100,1 @@\n-            throw new ClassGenException(\"Match and target array have not the same length: Match length: \" +\n-                match.length + \" Target length: \" + targets.length);\n+            throw new ClassGenException(\"Match and target array have not the same length: Match length: \" + match.length + \" Target length: \" + targets.length);\n@@ -80,90 +105,0 @@\n-\n-    \/**\n-     * Since this is a variable length instruction, it may shift the following\n-     * instructions which then need to update their position.\n-     *\n-     * Called by InstructionList.setPositions when setting the position for every\n-     * instruction. In the presence of variable length instructions `setPositions'\n-     * performs multiple passes over the instruction list to calculate the\n-     * correct (byte) positions and offsets by calling this function.\n-     *\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param max_offset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n-     *\/\n-    @Override\n-    protected int updatePosition( final int offset, final int max_offset ) {\n-        setPosition(getPosition() + offset); \/\/ Additional offset caused by preceding SWITCHs, GOTOs, etc.\n-        final short old_length = (short) super.getLength();\n-        \/* Alignment on 4-byte-boundary, + 1, because of tag byte.\n-         *\/\n-        padding = (4 - ((getPosition() + 1) % 4)) % 4;\n-        super.setLength((short) (fixed_length + padding)); \/\/ Update length\n-        return super.getLength() - old_length;\n-    }\n-\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump( final DataOutputStream out ) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        for (int i = 0; i < padding; i++) {\n-            out.writeByte(0);\n-        }\n-        super.setIndex(getTargetOffset()); \/\/ Write default target offset\n-        out.writeInt(super.getIndex());\n-    }\n-\n-\n-    \/**\n-     * Read needed data (e.g. index) from file.\n-     *\/\n-    @Override\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n-        padding = (4 - (bytes.getIndex() % 4)) % 4; \/\/ Compute number of pad bytes\n-        for (int i = 0; i < padding; i++) {\n-            bytes.readByte();\n-        }\n-        \/\/ Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)\n-        super.setIndex(bytes.readInt());\n-    }\n-\n-\n-    \/**\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString( final boolean verbose ) {\n-        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n-        if (verbose) {\n-            for (int i = 0; i < match_length; i++) {\n-                String s = \"null\";\n-                if (targets[i] != null) {\n-                    s = targets[i].getInstruction().toString();\n-                }\n-                buf.append(\"(\").append(match[i]).append(\", \").append(s).append(\" = {\").append(\n-                        indices[i]).append(\"})\");\n-            }\n-        } else {\n-            buf.append(\" ...\");\n-        }\n-        return buf.toString();\n-    }\n-\n-\n-    \/**\n-     * Set branch target for `i'th case\n-     *\/\n-    public void setTarget( final int i, final InstructionHandle target ) { \/\/ TODO could be package-protected?\n-        notifyTarget(targets[i], target, this);\n-        targets[i] = target;\n-    }\n-\n-\n-    \/**\n-     * @param old_ih old target\n-     * @param new_ih new target\n-     *\/\n@@ -171,15 +106,6 @@\n-    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n-        boolean targeted = false;\n-        if (super.getTarget() == old_ih) {\n-            targeted = true;\n-            setTarget(new_ih);\n-        }\n-        for (int i = 0; i < targets.length; i++) {\n-            if (targets[i] == old_ih) {\n-                targeted = true;\n-                setTarget(i, new_ih);\n-            }\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + old_ih);\n-        }\n+    protected Object clone() throws CloneNotSupportedException {\n+        final Select copy = (Select) super.clone();\n+        copy.match = match.clone();\n+        copy.indices = indices.clone();\n+        copy.targets = targets.clone();\n+        return copy;\n@@ -188,1 +114,0 @@\n-\n@@ -193,1 +118,1 @@\n-    public boolean containsTarget( final InstructionHandle ih ) {\n+    public boolean containsTarget(final InstructionHandle ih) {\n@@ -205,11 +130,0 @@\n-\n-    @Override\n-    protected Object clone() throws CloneNotSupportedException {\n-        final Select copy = (Select) super.clone();\n-        copy.match = match.clone();\n-        copy.indices = indices.clone();\n-        copy.targets = targets.clone();\n-        return copy;\n-    }\n-\n-\n@@ -227,1 +141,0 @@\n-\n@@ -229,1 +142,3 @@\n-     * @return array of match indices\n+     * Dump instruction as byte code to stream out.\n+     *\n+     * @param out Output stream\n@@ -231,2 +146,8 @@\n-    public int[] getMatchs() {\n-        return match;\n+    @Override\n+    public void dump(final DataOutputStream out) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        for (int i = 0; i < padding; i++) {\n+            out.writeByte(0);\n+        }\n+        super.setIndex(getTargetOffset()); \/\/ Write default target offset\n+        out.writeInt(super.getIndex());\n@@ -235,0 +156,7 @@\n+    \/**\n+     * @return the fixed_length\n+     * @since 6.0\n+     *\/\n+    final int getFixedLength() {\n+        return fixed_length;\n+    }\n@@ -243,1 +171,0 @@\n-\n@@ -245,1 +172,2 @@\n-     * @return array of match targets\n+     * @return index entry from indices\n+     * @since 6.0\n@@ -247,2 +175,2 @@\n-    public InstructionHandle[] getTargets() {\n-        return targets;\n+    final int getIndices(final int index) {\n+        return indices[index];\n@@ -259,0 +187,7 @@\n+    \/**\n+     * @return the match_length\n+     * @since 6.0\n+     *\/\n+    final int getMatchLength() {\n+        return match_length;\n+    }\n@@ -261,1 +196,9 @@\n-     * @return index entry from indices\n+     * @return array of match indices\n+     *\/\n+    public int[] getMatchs() {\n+        return match;\n+    }\n+\n+    \/**\n+     *\n+     * @return the padding\n@@ -264,2 +207,2 @@\n-    final int getIndices(final int index) {\n-        return indices[index];\n+    final int getPadding() {\n+        return padding;\n@@ -276,1 +219,0 @@\n-\n@@ -278,2 +220,1 @@\n-     * @return the fixed_length\n-     * @since 6.0\n+     * @return array of match targets\n@@ -281,2 +222,2 @@\n-    final int getFixed_length() {\n-        return fixed_length;\n+    public InstructionHandle[] getTargets() {\n+        return targets;\n@@ -285,1 +226,0 @@\n-\n@@ -287,2 +227,1 @@\n-     * @param fixed_length the fixed_length to set\n-     * @since 6.0\n+     * Read needed data (e.g. index) from file.\n@@ -290,2 +229,8 @@\n-    final void setFixed_length(final int fixed_length) {\n-        this.fixed_length = fixed_length;\n+    @Override\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+        padding = (4 - bytes.getIndex() % 4) % 4; \/\/ Compute number of pad bytes\n+        for (int i = 0; i < padding; i++) {\n+            bytes.readByte();\n+        }\n+        \/\/ Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)\n+        super.setIndex(bytes.readInt());\n@@ -294,1 +239,0 @@\n-\n@@ -296,1 +240,1 @@\n-     * @return the match_length\n+     * @param fixedLength the fixed_length to set\n@@ -299,2 +243,2 @@\n-    final int getMatch_length() {\n-        return match_length;\n+    final void setFixedLength(final int fixedLength) {\n+        this.fixed_length = fixedLength;\n@@ -303,0 +247,5 @@\n+    \/** @since 6.0 *\/\n+    final int setIndices(final int i, final int value) {\n+        indices[i] = value;\n+        return value; \/\/ Allow use in nested calls\n+    }\n@@ -305,1 +254,2 @@\n-     * @param match_length the match_length to set\n+     *\n+     * @param array\n@@ -308,3 +258,2 @@\n-    final int setMatch_length(final int match_length) {\n-        this.match_length = match_length;\n-        return match_length;\n+    final void setIndices(final int[] array) {\n+        indices = array;\n@@ -328,2 +277,2 @@\n-    final void setIndices(final int[] array) {\n-        indices = array;\n+    final void setMatches(final int[] array) {\n+        match = array;\n@@ -333,2 +282,1 @@\n-     *\n-     * @param array\n+     * @param matchLength the match_length to set\n@@ -337,2 +285,11 @@\n-    final void setMatches(final int[] array) {\n-        match = array;\n+    final int setMatchLength(final int matchLength) {\n+        this.match_length = matchLength;\n+        return matchLength;\n+    }\n+\n+    \/**\n+     * Set branch target for 'i'th case\n+     *\/\n+    public void setTarget(final int i, final InstructionHandle target) { \/\/ TODO could be package-protected?\n+        notifyTarget(targets[i], target, this);\n+        targets[i] = target;\n@@ -351,3 +308,1 @@\n-     *\n-     * @return the padding\n-     * @since 6.0\n+     * @return mnemonic for instruction\n@@ -355,2 +310,15 @@\n-    final int getPadding() {\n-        return padding;\n+    @Override\n+    public String toString(final boolean verbose) {\n+        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n+        if (verbose) {\n+            for (int i = 0; i < match_length; i++) {\n+                String s = \"null\";\n+                if (targets[i] != null) {\n+                    s = targets[i].getInstruction().toString();\n+                }\n+                buf.append(\"(\").append(match[i]).append(\", \").append(s).append(\" = {\").append(indices[i]).append(\"})\");\n+            }\n+        } else {\n+            buf.append(\" ...\");\n+        }\n+        return buf.toString();\n@@ -359,0 +327,23 @@\n+    \/**\n+     * Since this is a variable length instruction, it may shift the following instructions which then need to update their\n+     * position.\n+     *\n+     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n+     * length instructions 'setPositions' performs multiple passes over the instruction list to calculate the correct (byte)\n+     * positions and offsets by calling this function.\n+     *\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param maxOffset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n+     *\/\n+    @Override\n+    protected int updatePosition(final int offset, final int maxOffset) {\n+        setPosition(getPosition() + offset); \/\/ Additional offset caused by preceding SWITCHs, GOTOs, etc.\n+        final short oldLength = (short) super.getLength();\n+        \/*\n+         * Alignment on 4-byte-boundary, + 1, because of tag byte.\n+         *\/\n+        padding = (4 - (getPosition() + 1) % 4) % 4;\n+        super.setLength((short) (fixed_length + padding)); \/\/ Update length\n+        return super.getLength() - oldLength;\n+    }\n@@ -360,4 +351,20 @@\n-    \/** @since 6.0 *\/\n-    final int setIndices(final int i, final int value) {\n-        indices[i] = value;\n-        return value;  \/\/ Allow use in nested calls\n+    \/**\n+     * @param oldIh old target\n+     * @param newIh new target\n+     *\/\n+    @Override\n+    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n+        boolean targeted = false;\n+        if (super.getTarget() == oldIh) {\n+            targeted = true;\n+            setTarget(newIh);\n+        }\n+        for (int i = 0; i < targets.length; i++) {\n+            if (targets[i] == oldIh) {\n+                targeted = true;\n+                setTarget(i, newIh);\n+            }\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + oldIh);\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Select.java","additions":185,"deletions":178,"binary":false,"changes":363,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-public class SimpleElementValueGen extends ElementValueGen\n-{\n+public class SimpleElementValueGen extends ElementValueGen {\n@@ -43,1 +42,1 @@\n-    private int idx;\n+    private final int idx;\n@@ -45,8 +44,1 @@\n-    \/\/ ctors for each supported type... type could be inferred but for now lets\n-    \/\/ force it to be passed\n-    \/**\n-     * Protected ctor used for deserialization, doesn't *put* an entry in the\n-     * constant pool, assumes the one at the supplied index is correct.\n-     *\/\n-    protected SimpleElementValueGen(final int type, final int idx, final ConstantPoolGen cpGen)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final boolean value) {\n@@ -54,1 +46,5 @@\n-        this.idx = idx;\n+        if (value) {\n+            idx = getConstantPool().addInteger(1);\n+        } else {\n+            idx = getConstantPool().addInteger(0);\n+        }\n@@ -57,2 +53,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final int value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final byte value) {\n@@ -63,2 +58,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final long value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final char value) {\n@@ -66,1 +60,1 @@\n-        idx = getConstantPool().addLong(value);\n+        idx = getConstantPool().addInteger(value);\n@@ -69,2 +63,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final double value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final double value) {\n@@ -75,2 +68,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final float value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final float value) {\n@@ -81,2 +73,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final short value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final int value) {\n@@ -87,2 +78,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final byte value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final long value) {\n@@ -90,1 +80,1 @@\n-        idx = getConstantPool().addInteger(value);\n+        idx = getConstantPool().addLong(value);\n@@ -93,2 +83,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final char value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final short value) {\n@@ -99,2 +88,1 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final boolean value)\n-    {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final String value) {\n@@ -102,5 +90,1 @@\n-        if (value) {\n-            idx = getConstantPool().addInteger(1);\n-        } else {\n-            idx = getConstantPool().addInteger(0);\n-        }\n+        idx = getConstantPool().addUtf8(value);\n@@ -109,2 +93,7 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final String value)\n-    {\n+    \/\/ ctors for each supported type... type could be inferred but for now lets\n+    \/\/ force it to be passed\n+    \/**\n+     * Protected ctor used for deserialization, doesn't *put* an entry in the constant pool, assumes the one at the supplied\n+     * index is correct.\n+     *\/\n+    protected SimpleElementValueGen(final int type, final int idx, final ConstantPoolGen cpGen) {\n@@ -112,1 +101,1 @@\n-        idx = getConstantPool().addUtf8(value);\n+        this.idx = idx;\n@@ -116,3 +105,2 @@\n-     * The boolean controls whether we copy info from the 'old' constant pool to\n-     * the 'new'. You need to use this ctor if the annotation is being copied\n-     * from one file to another.\n+     * The boolean controls whether we copy info from the 'old' constant pool to the 'new'. You need to use this ctor if the\n+     * annotation is being copied from one file to another.\n@@ -120,3 +108,1 @@\n-    public SimpleElementValueGen(final SimpleElementValue value,\n-            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n-    {\n+    public SimpleElementValueGen(final SimpleElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n@@ -124,2 +110,1 @@\n-        if (!copyPoolEntries)\n-        {\n+        if (!copyPoolEntries) {\n@@ -129,5 +114,2 @@\n-        }\n-        else\n-        {\n-            switch (value.getElementValueType())\n-            {\n+        } else {\n+            switch (value.getElementValueType()) {\n@@ -156,2 +138,1 @@\n-                if (value.getValueBoolean())\n-                {\n+                if (value.getValueBoolean()) {\n@@ -159,3 +140,1 @@\n-                }\n-                else\n-                {\n+                } else {\n@@ -169,2 +148,1 @@\n-                throw new IllegalArgumentException(\n-                    \"SimpleElementValueGen class does not know how to copy this type \" + super.getElementValueType());\n+                throw new IllegalArgumentException(\"SimpleElementValueGen class does not know how to copy this type \" + super.getElementValueType());\n@@ -175,0 +153,20 @@\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n+        switch (super.getElementValueType()) {\n+        case PRIMITIVE_INT:\n+        case PRIMITIVE_BYTE:\n+        case PRIMITIVE_CHAR:\n+        case PRIMITIVE_FLOAT:\n+        case PRIMITIVE_LONG:\n+        case PRIMITIVE_BOOLEAN:\n+        case PRIMITIVE_SHORT:\n+        case PRIMITIVE_DOUBLE:\n+        case STRING:\n+            dos.writeShort(idx);\n+            break;\n+        default:\n+            throw new IllegalStateException(\"SimpleElementValueGen doesnt know how to write out type \" + super.getElementValueType());\n+        }\n+    }\n+\n@@ -179,2 +177,1 @@\n-    public ElementValue getElementValue()\n-    {\n+    public ElementValue getElementValue() {\n@@ -184,2 +181,1 @@\n-    public int getIndex()\n-    {\n+    public int getIndex() {\n@@ -189,5 +185,3 @@\n-    public String getValueString()\n-    {\n-        if (super.getElementValueType() != STRING) {\n-            throw new IllegalStateException(\n-                    \"Dont call getValueString() on a non STRING ElementValue\");\n+    public int getValueInt() {\n+        if (super.getElementValueType() != PRIMITIVE_INT) {\n+            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n@@ -195,1 +189,1 @@\n-        final ConstantUtf8 c = (ConstantUtf8) getConstantPool().getConstant(idx);\n+        final ConstantInteger c = (ConstantInteger) getConstantPool().getConstant(idx);\n@@ -199,5 +193,3 @@\n-    public int getValueInt()\n-    {\n-        if (super.getElementValueType() != PRIMITIVE_INT) {\n-            throw new IllegalStateException(\n-                    \"Dont call getValueString() on a non STRING ElementValue\");\n+    public String getValueString() {\n+        if (super.getElementValueType() != STRING) {\n+            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n@@ -205,1 +197,1 @@\n-        final ConstantInteger c = (ConstantInteger) getConstantPool().getConstant(idx);\n+        final ConstantUtf8 c = (ConstantUtf8) getConstantPool().getConstant(idx);\n@@ -211,4 +203,2 @@\n-    public String stringifyValue()\n-    {\n-        switch (super.getElementValueType())\n-        {\n+    public String stringifyValue() {\n+        switch (super.getElementValueType()) {\n@@ -246,25 +236,1 @@\n-            throw new IllegalStateException(\n-                \"SimpleElementValueGen class does not know how to stringify type \" + super.getElementValueType());\n-        }\n-    }\n-\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException\n-    {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n-        switch (super.getElementValueType())\n-        {\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_BOOLEAN:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_DOUBLE:\n-        case STRING:\n-            dos.writeShort(idx);\n-            break;\n-        default:\n-            throw new IllegalStateException(\n-                \"SimpleElementValueGen doesnt know how to write out type \" + super.getElementValueType());\n+            throw new IllegalStateException(\"SimpleElementValueGen class does not know how to stringify type \" + super.getElementValueType());\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SimpleElementValueGen.java","additions":69,"deletions":103,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -30,1 +29,2 @@\n-    \/** @return how many words are consumed from stack\n+    \/**\n+     * @return how many words are consumed from stack\n@@ -32,1 +32,1 @@\n-    int consumeStack( ConstantPoolGen cpg );\n+    int consumeStack(ConstantPoolGen cpg);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackConsumer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n- *\n@@ -31,2 +30,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -37,1 +35,0 @@\n-\n@@ -45,2 +42,2 @@\n-\n-    \/** @return Type.UNKNOWN\n+    \/**\n+     * @return Type.UNKNOWN\n@@ -48,1 +45,1 @@\n-    public Type getType( final ConstantPoolGen cp ) {\n+    public Type getType(final ConstantPoolGen cp) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackInstruction.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Denote an instruction that may produce a value on top of the stack\n- * (this excludes DUP_X1, e.g.)\n- *\n+ * Denotes an instruction that may produce a value on top of the stack (this excludes DUP_X1, e.g.)\n@@ -31,1 +29,2 @@\n-    \/** @return how many words are produced on stack\n+    \/**\n+     * @return how many words are produced on stack\n@@ -33,1 +32,1 @@\n-    int produceStack( ConstantPoolGen cpg );\n+    int produceStack(ConstantPoolGen cpg);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackProducer.java","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Denotes an unparameterized instruction to store a value into a local variable,\n- * e.g. ISTORE.\n- *\n+ * Denotes an unparameterized instruction to store a value into a local variable, e.g. ISTORE.\n@@ -32,3 +30,2 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n-     * tag and length are defined in readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n+     * readInstruction and initFromFile, respectively.\n@@ -36,2 +33,2 @@\n-    StoreInstruction(final short canon_tag, final short c_tag) {\n-        super(canon_tag, c_tag);\n+    StoreInstruction(final short canonTag, final short cTag) {\n+        super(canonTag, cTag);\n@@ -40,1 +37,0 @@\n-\n@@ -43,1 +39,1 @@\n-     * @param c_tag Instruction number for compact version, ASTORE_0, e.g.\n+     * @param cTag Instruction number for compact version, ASTORE_0, e.g.\n@@ -46,2 +42,2 @@\n-    protected StoreInstruction(final short opcode, final short c_tag, final int n) {\n-        super(opcode, c_tag, n);\n+    protected StoreInstruction(final short opcode, final short cTag, final int n) {\n+        super(opcode, cTag, n);\n@@ -50,1 +46,0 @@\n-\n@@ -52,4 +47,2 @@\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +53,1 @@\n-    public void accept( final Visitor v ) {\n+    public void accept(final Visitor v) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StoreInstruction.java","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,2 +37,1 @@\n-     * Empty constructor needed for Instruction.readInstruction.\n-     * Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n@@ -43,1 +42,0 @@\n-\n@@ -45,2 +43,1 @@\n-     * @param match sorted array of match values, match[0] must be low value,\n-     * match[match_length - 1] high value\n+     * @param match sorted array of match values, match[0] must be low value, match[match_length - 1] high value\n@@ -53,3 +50,3 @@\n-        final short _length = (short) (13 + getMatch_length() * 4);\n-        super.setLength(_length);\n-        setFixed_length(_length);\n+        final short length = (short) (13 + getMatchLength() * 4);\n+        super.setLength(length);\n+        setFixedLength(length);\n@@ -58,0 +55,14 @@\n+    \/**\n+     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n+     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept(final Visitor v) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitSelect(this);\n+        v.visitTABLESWITCH(this);\n+    }\n@@ -61,0 +72,1 @@\n+     *\n@@ -64,1 +76,1 @@\n-    public void dump( final DataOutputStream out ) throws IOException {\n+    public void dump(final DataOutputStream out) throws IOException {\n@@ -66,2 +78,2 @@\n-        final int _match_length = getMatch_length();\n-        final int low = (_match_length > 0) ? super.getMatch(0) : 0;\n+        final int matchLength = getMatchLength();\n+        final int low = matchLength > 0 ? super.getMatch(0) : 0;\n@@ -69,1 +81,1 @@\n-        final int high = (_match_length > 0) ? super.getMatch(_match_length - 1) : 0;\n+        final int high = matchLength > 0 ? super.getMatch(matchLength - 1) : 0;\n@@ -71,1 +83,1 @@\n-        for (int i = 0; i < _match_length; i++) {\n+        for (int i = 0; i < matchLength; i++) {\n@@ -76,1 +88,0 @@\n-\n@@ -81,1 +92,1 @@\n-    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n@@ -85,9 +96,9 @@\n-        final int _match_length = high - low + 1;\n-        setMatch_length(_match_length);\n-        final short _fixed_length = (short) (13 + _match_length * 4);\n-        setFixed_length(_fixed_length);\n-        super.setLength((short) (_fixed_length + super.getPadding()));\n-        super.setMatches(new int[_match_length]);\n-        super.setIndices(new int[_match_length]);\n-        super.setTargets(new InstructionHandle[_match_length]);\n-        for (int i = 0; i < _match_length; i++) {\n+        final int matchLength = high - low + 1;\n+        setMatchLength(matchLength);\n+        final short fixedLength = (short) (13 + matchLength * 4);\n+        setFixedLength(fixedLength);\n+        super.setLength((short) (fixedLength + super.getPadding()));\n+        super.setMatches(new int[matchLength]);\n+        super.setIndices(new int[matchLength]);\n+        super.setTargets(new InstructionHandle[matchLength]);\n+        for (int i = 0; i < matchLength; i++) {\n@@ -98,18 +109,0 @@\n-\n-\n-    \/**\n-     * Call corresponding visitor method(s). The order is:\n-     * Call visitor methods of implemented interfaces first, then\n-     * call methods according to the class hierarchy in descending order,\n-     * i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept( final Visitor v ) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitSelect(this);\n-        v.visitTABLESWITCH(this);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TABLESWITCH.java","additions":35,"deletions":42,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +24,3 @@\n- * Thrown by InstructionList.remove() when one or multiple disposed instructions\n- * are still being referenced by an InstructionTargeter object. I.e. the\n- * InstructionTargeter has to be notified that (one of) the InstructionHandle it\n- * is referencing is being removed from the InstructionList and thus not valid anymore.\n+ * Thrown by InstructionList.remove() when one or multiple disposed instructions are still being referenced by an\n+ * InstructionTargeter object. I.e. the InstructionTargeter has to be notified that (one of) the InstructionHandle it is\n+ * referencing is being removed from the InstructionList and thus not valid anymore.\n@@ -30,3 +28,4 @@\n- * <p>Making this an exception instead of a return value forces the user to handle\n- * these case explicitely in a try { ... } catch. The following code illustrates\n- * how this may be done:<\/p>\n+ * <p>\n+ * Making this an exception instead of a return value forces the user to handle these case explicitly in a try { ... }\n+ * catch. The following code illustrates how this may be done:\n+ * <\/p>\n@@ -50,0 +49,1 @@\n+ * @LastModified: Feb 2023\n@@ -56,1 +56,0 @@\n-\n@@ -62,1 +61,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TargetLostException.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -23,0 +23,1 @@\n+import java.util.Arrays;\n@@ -24,0 +25,1 @@\n+import java.util.Objects;\n@@ -30,3 +32,2 @@\n- * Abstract super class for all possible java types, namely basic types\n- * such as int, object types like String and array types, e.g. int[]\n- *\n+ * Abstract super class for all possible java types, namely basic types such as int, object types like String and array\n+ * types, e.g. int[]\n@@ -37,2 +38,0 @@\n-    private final byte type;\n-    private String signature; \/\/ signature for the type\n@@ -43,0 +42,1 @@\n+\n@@ -56,12 +56,0 @@\n-    public static final Type[] NO_ARGS = new Type[0]; \/\/ EMPTY, so immutable\n-    public static final ReferenceType NULL = new ReferenceType() {\n-    };\n-    public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, \"<unknown object>\") {\n-    };\n-\n-\n-    protected Type(final byte t, final String s) {\n-        type = t;\n-        signature = s;\n-    }\n-\n@@ -70,1 +58,1 @@\n-     * @return hashcode of Type\n+     * Empty array.\n@@ -72,5 +60,3 @@\n-    @Override\n-    public int hashCode() {\n-        return type ^ signature.hashCode();\n-    }\n-\n+    public static final Type[] NO_ARGS = {};\n+    public static final ReferenceType NULL = new ReferenceType() {\n+    };\n@@ -78,11 +64,2 @@\n-    \/**\n-     * @return whether the Types are equal\n-     *\/\n-    @Override\n-    public boolean equals(final Object o) {\n-          if (o instanceof Type) {\n-              final Type t = (Type)o;\n-              return (type == t.type) && signature.equals(t.signature);\n-          }\n-          return false;\n-    }\n+    public static final Type UNKNOWN = new Type(Const.T_UNKNOWN, \"<unknown object>\") {\n+    };\n@@ -90,0 +67,1 @@\n+    private static final ThreadLocal<Integer> CONSUMED_CHARS = ThreadLocal.withInitial(() -> Integer.valueOf(0));\n@@ -91,5 +69,3 @@\n-    \/**\n-     * @return signature for given type.\n-     *\/\n-    public String getSignature() {\n-        return signature;\n+    \/\/ int consumed_chars=0; \/\/ Remember position in string, see getArgumentTypes\n+    static int consumed(final int coded) {\n+        return coded >> 2;\n@@ -98,6 +74,2 @@\n-\n-    \/**\n-     * @return type as defined in Constants\n-     *\/\n-    public byte getType() {\n-        return type;\n+    static int encode(final int size, final int consumed) {\n+        return consumed << 2 | size;\n@@ -107,4 +79,4 @@\n-     * boolean, short and char variable are considered as int in the stack or local variable area.\n-     * Returns {@link Type#INT} for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise\n-     * returns the given type.\n-     * @since 6.0\n+     * Convert arguments of a method (signature) to an array of Type objects.\n+     *\n+     * @param signature signature string such as (Ljava\/lang\/String;)V\n+     * @return array of argument types\n@@ -112,3 +84,16 @@\n-    public Type normalizeForStackOrLocal() {\n-        if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {\n-            return Type.INT;\n+    public static Type[] getArgumentTypes(final String signature) {\n+        final List<Type> vec = new ArrayList<>();\n+        int index;\n+        try {\n+            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n+            index = signature.indexOf('(') + 1;\n+            if (index <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            while (signature.charAt(index) != ')') {\n+                vec.add(getType(signature.substring(index)));\n+                \/\/ corrected concurrent private static field acess\n+                index += unwrap(CONSUMED_CHARS); \/\/ update position\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n@@ -116,1 +101,3 @@\n-        return this;\n+        final Type[] types = new Type[vec.size()];\n+        vec.toArray(types);\n+        return types;\n@@ -119,12 +106,16 @@\n-    \/**\n-     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)\n-     *\/\n-    public int getSize() {\n-        switch (type) {\n-            case Const.T_DOUBLE:\n-            case Const.T_LONG:\n-                return 2;\n-            case Const.T_VOID:\n-                return 0;\n-            default:\n-                return 1;\n+    static int getArgumentTypesSize(final String signature) {\n+        int res = 0;\n+        int index;\n+        try {\n+            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n+            index = signature.indexOf('(') + 1;\n+            if (index <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            while (signature.charAt(index) != ')') {\n+                final int coded = getTypeSize(signature.substring(index));\n+                res += size(coded);\n+                index += consumed(coded);\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n@@ -132,0 +123,1 @@\n+        return res;\n@@ -134,11 +126,0 @@\n-\n-    \/**\n-     * @return Type string, e.g. `int[]'\n-     *\/\n-    @Override\n-    public String toString() {\n-        return ((this.equals(Type.NULL) || (type >= Const.T_UNKNOWN))) ? signature : Utility\n-                .signatureToString(signature, false);\n-    }\n-\n-\n@@ -146,2 +127,1 @@\n-     * Convert type to Java method signature, e.g. int[] f(java.lang.String x)\n-     * becomes (Ljava\/lang\/String;)[I\n+     * Convert type to Java method signature, e.g. int[] f(java.lang.String x) becomes (Ljava\/lang\/String;)[I\n@@ -149,2 +129,2 @@\n-     * @param return_type what the method returns\n-     * @param arg_types what are the argument types\n+     * @param returnType what the method returns\n+     * @param argTypes what are the argument types\n@@ -153,1 +133,1 @@\n-    public static String getMethodSignature( final Type return_type, final Type[] arg_types ) {\n+    public static String getMethodSignature(final Type returnType, final Type[] argTypes) {\n@@ -155,3 +135,3 @@\n-        if (arg_types != null) {\n-            for (final Type arg_type : arg_types) {\n-                buf.append(arg_type.getSignature());\n+        if (argTypes != null) {\n+            for (final Type argType : argTypes) {\n+                buf.append(argType.getSignature());\n@@ -161,1 +141,1 @@\n-        buf.append(return_type.getSignature());\n+        buf.append(returnType.getSignature());\n@@ -165,52 +145,0 @@\n-    private static final ThreadLocal<Integer> consumed_chars = new ThreadLocal<Integer>() {\n-\n-        @Override\n-        protected Integer initialValue() {\n-            return Integer.valueOf(0);\n-        }\n-    };\/\/int consumed_chars=0; \/\/ Remember position in string, see getArgumentTypes\n-\n-\n-    private static int unwrap( final ThreadLocal<Integer> tl ) {\n-        return tl.get().intValue();\n-    }\n-\n-\n-    private static void wrap( final ThreadLocal<Integer> tl, final int value ) {\n-        tl.set(Integer.valueOf(value));\n-    }\n-\n-\n-    \/**\n-     * Convert signature to a Type object.\n-     * @param signature signature string such as Ljava\/lang\/String;\n-     * @return type object\n-     *\/\n-    \/\/ @since 6.0 no longer final\n-    public static Type getType( final String signature ) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= Const.T_VOID) {\n-            \/\/corrected concurrent private static field acess\n-            wrap(consumed_chars, 1);\n-            return BasicType.getType(type);\n-        } else if (type == Const.T_ARRAY) {\n-            int dim = 0;\n-            do { \/\/ Count dimensions\n-                dim++;\n-            } while (signature.charAt(dim) == '[');\n-            \/\/ Recurse, but just once, if the signature is ok\n-            final Type t = getType(signature.substring(dim));\n-            \/\/corrected concurrent private static field acess\n-            \/\/  consumed_chars += dim; \/\/ update counter - is replaced by\n-            final int _temp = unwrap(consumed_chars) + dim;\n-            wrap(consumed_chars, _temp);\n-            return new ArrayType(t, dim);\n-        } else { \/\/ type == T_REFERENCE\n-            \/\/ Utility.typeSignatureToString understands how to parse generic types.\n-            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n-            wrap(consumed_chars, parsedSignature.length() + 2); \/\/ \"Lblabla;\" `L' and `;' are removed\n-            return ObjectType.getInstance(parsedSignature.replace('\/', '.'));\n-        }\n-    }\n-\n-\n@@ -223,1 +151,1 @@\n-    public static Type getReturnType( final String signature ) {\n+    public static Type getReturnType(final String signature) {\n@@ -225,1 +153,1 @@\n-            \/\/ Read return type after `)'\n+            \/\/ Read return type after ')'\n@@ -233,0 +161,4 @@\n+    static int getReturnTypeSize(final String signature) {\n+        final int index = signature.lastIndexOf(')') + 1;\n+        return Type.size(getTypeSize(signature.substring(index)));\n+    }\n@@ -234,22 +166,5 @@\n-    \/**\n-     * Convert arguments of a method (signature) to an array of Type objects.\n-     * @param signature signature string such as (Ljava\/lang\/String;)V\n-     * @return array of argument types\n-     *\/\n-    public static Type[] getArgumentTypes( final String signature ) {\n-        final List<Type> vec = new ArrayList<>();\n-        int index;\n-        Type[] types;\n-        try {\n-            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n-            index = signature.indexOf('(') + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(getType(signature.substring(index)));\n-                \/\/corrected concurrent private static field acess\n-                index += unwrap(consumed_chars); \/\/ update position\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+    public static String getSignature(final java.lang.reflect.Method meth) {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        final Class<?>[] params = meth.getParameterTypes(); \/\/ avoid clone\n+        for (final Class<?> param : params) {\n+            sb.append(getType(param).getSignature());\n@@ -257,3 +172,3 @@\n-        types = new Type[vec.size()];\n-        vec.toArray(types);\n-        return types;\n+        sb.append(\")\");\n+        sb.append(getType(meth.getReturnType()).getSignature());\n+        return sb.toString();\n@@ -262,3 +177,4 @@\n-\n-    \/** Convert runtime java.lang.Class to BCEL Type object.\n-     * @param cl Java class\n+    \/**\n+     * Convert runtime java.lang.Class to BCEL Type object.\n+     *\n+     * @param cls Java class\n@@ -267,6 +183,4 @@\n-    public static Type getType( final java.lang.Class<?> cl ) {\n-        if (cl == null) {\n-            throw new IllegalArgumentException(\"Class must not be null\");\n-        }\n-        \/* That's an amzingly easy case, because getName() returns\n-         * the signature. That's what we would have liked anyway.\n+    public static Type getType(final Class<?> cls) {\n+        Objects.requireNonNull(cls, \"cls\");\n+        \/*\n+         * That's an amzingly easy case, because getName() returns the signature. That's what we would have liked anyway.\n@@ -274,28 +188,29 @@\n-        if (cl.isArray()) {\n-            return getType(cl.getName());\n-        } else if (cl.isPrimitive()) {\n-            if (cl == Integer.TYPE) {\n-                return INT;\n-            } else if (cl == Void.TYPE) {\n-                return VOID;\n-            } else if (cl == Double.TYPE) {\n-                return DOUBLE;\n-            } else if (cl == Float.TYPE) {\n-                return FLOAT;\n-            } else if (cl == Boolean.TYPE) {\n-                return BOOLEAN;\n-            } else if (cl == Byte.TYPE) {\n-                return BYTE;\n-            } else if (cl == Short.TYPE) {\n-                return SHORT;\n-            } else if (cl == Byte.TYPE) {\n-                return BYTE;\n-            } else if (cl == Long.TYPE) {\n-                return LONG;\n-            } else if (cl == Character.TYPE) {\n-                return CHAR;\n-            } else {\n-                throw new IllegalStateException(\"Unknown primitive type \" + cl);\n-            }\n-        } else { \/\/ \"Real\" class\n-            return ObjectType.getInstance(cl.getName());\n+        if (cls.isArray()) {\n+            return getType(cls.getName());\n+        }\n+        if (!cls.isPrimitive()) { \/\/ \"Real\" class\n+            return ObjectType.getInstance(cls.getName());\n+        }\n+        if (cls == Integer.TYPE) {\n+            return INT;\n+        }\n+        if (cls == Void.TYPE) {\n+            return VOID;\n+        }\n+        if (cls == Double.TYPE) {\n+            return DOUBLE;\n+        }\n+        if (cls == Float.TYPE) {\n+            return FLOAT;\n+        }\n+        if (cls == Boolean.TYPE) {\n+            return BOOLEAN;\n+        }\n+        if (cls == Byte.TYPE) {\n+            return BYTE;\n+        }\n+        if (cls == Short.TYPE) {\n+            return SHORT;\n+        }\n+        if (cls == Long.TYPE) {\n+            return LONG;\n@@ -303,0 +218,4 @@\n+        if (cls == Character.TYPE) {\n+            return CHAR;\n+        }\n+        throw new IllegalStateException(\"Unknown primitive type \" + cls);\n@@ -305,0 +224,31 @@\n+    \/**\n+     * Convert signature to a Type object.\n+     *\n+     * @param signature signature string such as Ljava\/lang\/String;\n+     * @return type object\n+     *\/\n+    public static Type getType(final String signature) throws StringIndexOutOfBoundsException {\n+        final byte type = Utility.typeOfSignature(signature);\n+        if (type <= Const.T_VOID) {\n+            \/\/ corrected concurrent private static field acess\n+            wrap(CONSUMED_CHARS, 1);\n+            return BasicType.getType(type);\n+        }\n+        if (type != Const.T_ARRAY) { \/\/ type == T_REFERENCE\n+            \/\/ Utility.typeSignatureToString understands how to parse generic types.\n+            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n+            wrap(CONSUMED_CHARS, parsedSignature.length() + 2); \/\/ \"Lblabla;\" 'L' and ';' are removed\n+            return ObjectType.getInstance(Utility.pathToPackage(parsedSignature));\n+        }\n+        int dim = 0;\n+        do { \/\/ Count dimensions\n+            dim++;\n+        } while (signature.charAt(dim) == '[');\n+        \/\/ Recurse, but just once, if the signature is ok\n+        final Type t = getType(signature.substring(dim));\n+        \/\/ corrected concurrent private static field acess\n+        \/\/ consumed_chars += dim; \/\/ update counter - is replaced by\n+        final int temp = unwrap(CONSUMED_CHARS) + dim;\n+        wrap(CONSUMED_CHARS, temp);\n+        return new ArrayType(t, dim);\n+    }\n@@ -308,0 +258,1 @@\n+     *\n@@ -311,1 +262,1 @@\n-    public static Type[] getTypes( final java.lang.Class<?>[] classes ) {\n+    public static Type[] getTypes(final Class<?>[] classes) {\n@@ -313,3 +264,1 @@\n-        for (int i = 0; i < ret.length; i++) {\n-            ret[i] = getType(classes[i]);\n-        }\n+        Arrays.setAll(ret, i -> getType(classes[i]));\n@@ -319,6 +268,4 @@\n-\n-    public static String getSignature( final java.lang.reflect.Method meth ) {\n-        final StringBuilder sb = new StringBuilder(\"(\");\n-        final Class<?>[] params = meth.getParameterTypes(); \/\/ avoid clone\n-        for (final Class<?> param : params) {\n-            sb.append(getType(param).getSignature());\n+    static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {\n+        final byte type = Utility.typeOfSignature(signature);\n+        if (type <= Const.T_VOID) {\n+            return encode(BasicType.getType(type).getSize(), 1);\n@@ -326,3 +273,14 @@\n-        sb.append(\")\");\n-        sb.append(getType(meth.getReturnType()).getSignature());\n-        return sb.toString();\n+        if (type == Const.T_ARRAY) {\n+            int dim = 0;\n+            do { \/\/ Count dimensions\n+                dim++;\n+            } while (signature.charAt(dim) == '[');\n+            \/\/ Recurse, but just once, if the signature is ok\n+            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n+            return encode(1, dim + consumed);\n+        }\n+        final int index = signature.indexOf(';'); \/\/ Look for closing ';'\n+        if (index < 0) {\n+            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+        }\n+        return encode(1, index + 1);\n@@ -335,2 +293,2 @@\n-    static int consumed(final int coded) {\n-        return coded >> 2;\n+    private static int unwrap(final ThreadLocal<Integer> tl) {\n+        return tl.get().intValue();\n@@ -339,2 +297,2 @@\n-    static int encode(final int size, final int consumed) {\n-        return consumed << 2 | size;\n+    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n+        tl.set(Integer.valueOf(value));\n@@ -343,16 +301,25 @@\n-    static int getArgumentTypesSize( final String signature ) {\n-        int res = 0;\n-        int index;\n-        try {\n-            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n-            index = signature.indexOf('(') + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            while (signature.charAt(index) != ')') {\n-                final int coded = getTypeSize(signature.substring(index));\n-                res += size(coded);\n-                index += consumed(coded);\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected byte type; \/\/ TODO should be final (and private)\n+\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     *\/\n+    @Deprecated\n+    protected String signature; \/\/ signature for the type TODO should be private\n+\n+    protected Type(final byte type, final String signature) {\n+        this.type = type;\n+        this.signature = signature;\n+    }\n+\n+    \/**\n+     * @return whether the Types are equal\n+     *\/\n+    @Override\n+    public boolean equals(final Object o) {\n+        if (o instanceof Type) {\n+            final Type t = (Type) o;\n+            return type == t.type && signature.equals(t.signature);\n@@ -360,1 +327,1 @@\n-        return res;\n+        return false;\n@@ -363,18 +330,23 @@\n-    static int getTypeSize( final String signature ) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= Const.T_VOID) {\n-            return encode(BasicType.getType(type).getSize(), 1);\n-        } else if (type == Const.T_ARRAY) {\n-            int dim = 0;\n-            do { \/\/ Count dimensions\n-                dim++;\n-            } while (signature.charAt(dim) == '[');\n-            \/\/ Recurse, but just once, if the signature is ok\n-            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n-            return encode(1, dim + consumed);\n-        } else { \/\/ type == T_REFERENCE\n-            final int index = signature.indexOf(';'); \/\/ Look for closing `;'\n-            if (index < 0) {\n-                throw new ClassFormatException(\"Invalid signature: \" + signature);\n-            }\n-            return encode(1, index + 1);\n+    public String getClassName() {\n+        return toString();\n+    }\n+\n+    \/**\n+     * @return signature for given type.\n+     *\/\n+    public String getSignature() {\n+        return signature;\n+    }\n+\n+    \/**\n+     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)\n+     *\/\n+    public int getSize() {\n+        switch (type) {\n+        case Const.T_DOUBLE:\n+        case Const.T_LONG:\n+            return 2;\n+        case Const.T_VOID:\n+            return 0;\n+        default:\n+            return 1;\n@@ -384,0 +356,6 @@\n+    \/**\n+     * @return type as defined in Constants\n+     *\/\n+    public byte getType() {\n+        return type;\n+    }\n@@ -385,3 +363,6 @@\n-    static int getReturnTypeSize(final String signature) {\n-        final int index = signature.lastIndexOf(')') + 1;\n-        return Type.size(getTypeSize(signature.substring(index)));\n+    \/**\n+     * @return hashcode of Type\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return type ^ signature.hashCode();\n@@ -390,0 +371,12 @@\n+    \/**\n+     * boolean, short and char variable are considered as int in the stack or local variable area. Returns {@link Type#INT}\n+     * for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise returns the given type.\n+     *\n+     * @since 6.0\n+     *\/\n+    public Type normalizeForStackOrLocal() {\n+        if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {\n+            return Type.INT;\n+        }\n+        return this;\n+    }\n@@ -392,3 +385,2 @@\n-     * Currently only used by the ArrayType constructor.\n-     * The signature has a complicated dependency on other parameter\n-     * so it's tricky to do it in a call to the super ctor.\n+     * Currently only used by the ArrayType constructor. The signature has a complicated dependency on other parameter so\n+     * it's tricky to do it in a call to the super ctor.\n@@ -399,0 +391,8 @@\n+\n+    \/**\n+     * @return Type string, e.g. 'int[]'\n+     *\/\n+    @Override\n+    public String toString() {\n+        return this.equals(Type.NULL) || type >= Const.T_UNKNOWN ? signature : Utility.signatureToString(signature, false);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Type.java","additions":259,"deletions":259,"binary":false,"changes":518,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * Get the type associated with an instruction, int for ILOAD, or the type\n- * of the field of a PUTFIELD instruction, e.g..\n- *\n+ * Get the type associated with an instruction, int for ILOAD, or the type of the field of a PUTFIELD instruction, e.g..\n@@ -31,1 +29,1 @@\n-    Type getType( ConstantPoolGen cpg );\n+    Type getType(ConstantPoolGen cpg);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TypedInstruction.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/UnconditionalBranch.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Denotes an instruction to be a variable length instruction, such as\n- * GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n+ * Denotes an instruction to be a variable length instruction, such as GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n+ *\n@@ -28,1 +28,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/VariableLengthInstruction.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,5 +25,2 @@\n- * Interface implementing the Visitor pattern programming style.\n- * I.e., a class that implements this interface can handle all types of\n- * instructions with the properly typed methods just by calling the accept()\n- * method.\n- *\n+ * Interface implementing the Visitor pattern programming style. I.e., a class that implements this interface can handle\n+ * all types of instructions with the properly typed methods just by calling the accept() method.\n@@ -33,136 +30,1 @@\n-    void visitStackInstruction( StackInstruction obj );\n-\n-\n-    void visitLocalVariableInstruction( LocalVariableInstruction obj );\n-\n-\n-    void visitBranchInstruction( BranchInstruction obj );\n-\n-\n-    void visitLoadClass( LoadClass obj );\n-\n-\n-    void visitFieldInstruction( FieldInstruction obj );\n-\n-\n-    void visitIfInstruction( IfInstruction obj );\n-\n-\n-    void visitConversionInstruction( ConversionInstruction obj );\n-\n-\n-    void visitPopInstruction( PopInstruction obj );\n-\n-\n-    void visitStoreInstruction( StoreInstruction obj );\n-\n-\n-    void visitTypedInstruction( TypedInstruction obj );\n-\n-\n-    void visitSelect( Select obj );\n-\n-\n-    void visitJsrInstruction( JsrInstruction obj );\n-\n-\n-    void visitGotoInstruction( GotoInstruction obj );\n-\n-\n-    void visitUnconditionalBranch( UnconditionalBranch obj );\n-\n-\n-    void visitPushInstruction( PushInstruction obj );\n-\n-\n-    void visitArithmeticInstruction( ArithmeticInstruction obj );\n-\n-\n-    void visitCPInstruction( CPInstruction obj );\n-\n-\n-    void visitInvokeInstruction( InvokeInstruction obj );\n-\n-\n-    void visitArrayInstruction( ArrayInstruction obj );\n-\n-\n-    void visitAllocationInstruction( AllocationInstruction obj );\n-\n-\n-    void visitReturnInstruction( ReturnInstruction obj );\n-\n-\n-    void visitFieldOrMethod( FieldOrMethod obj );\n-\n-\n-    void visitConstantPushInstruction( ConstantPushInstruction obj );\n-\n-\n-    void visitExceptionThrower( ExceptionThrower obj );\n-\n-\n-    void visitLoadInstruction( LoadInstruction obj );\n-\n-\n-    void visitVariableLengthInstruction( VariableLengthInstruction obj );\n-\n-\n-    void visitStackProducer( StackProducer obj );\n-\n-\n-    void visitStackConsumer( StackConsumer obj );\n-\n-\n-    void visitACONST_NULL( ACONST_NULL obj );\n-\n-\n-    void visitGETSTATIC( GETSTATIC obj );\n-\n-\n-    void visitIF_ICMPLT( IF_ICMPLT obj );\n-\n-\n-    void visitMONITOREXIT( MONITOREXIT obj );\n-\n-\n-    void visitIFLT( IFLT obj );\n-\n-\n-    void visitLSTORE( LSTORE obj );\n-\n-\n-    void visitPOP2( POP2 obj );\n-\n-\n-    void visitBASTORE( BASTORE obj );\n-\n-\n-    void visitISTORE( ISTORE obj );\n-\n-\n-    void visitCHECKCAST( CHECKCAST obj );\n-\n-\n-    void visitFCMPG( FCMPG obj );\n-\n-\n-    void visitI2F( I2F obj );\n-\n-\n-    void visitATHROW( ATHROW obj );\n-\n-\n-    void visitDCMPL( DCMPL obj );\n-\n-\n-    void visitARRAYLENGTH( ARRAYLENGTH obj );\n-\n-\n-    void visitDUP( DUP obj );\n-\n-\n-    void visitINVOKESTATIC( INVOKESTATIC obj );\n-\n-\n-    void visitLCONST( LCONST obj );\n+    void visitAALOAD(AALOAD obj);\n@@ -170,0 +32,1 @@\n+    void visitAASTORE(AASTORE obj);\n@@ -171,1 +34,1 @@\n-    void visitDREM( DREM obj );\n+    void visitACONST_NULL(ACONST_NULL obj);\n@@ -173,0 +36,1 @@\n+    void visitAllocationInstruction(AllocationInstruction obj);\n@@ -174,1 +38,1 @@\n-    void visitIFGE( IFGE obj );\n+    void visitALOAD(ALOAD obj);\n@@ -176,0 +40,1 @@\n+    void visitANEWARRAY(ANEWARRAY obj);\n@@ -177,1 +42,1 @@\n-    void visitCALOAD( CALOAD obj );\n+    void visitARETURN(ARETURN obj);\n@@ -179,0 +44,1 @@\n+    void visitArithmeticInstruction(ArithmeticInstruction obj);\n@@ -180,1 +46,1 @@\n-    void visitLASTORE( LASTORE obj );\n+    void visitArrayInstruction(ArrayInstruction obj);\n@@ -182,0 +48,1 @@\n+    void visitARRAYLENGTH(ARRAYLENGTH obj);\n@@ -183,1 +50,1 @@\n-    void visitI2D( I2D obj );\n+    void visitASTORE(ASTORE obj);\n@@ -185,0 +52,1 @@\n+    void visitATHROW(ATHROW obj);\n@@ -186,1 +54,1 @@\n-    void visitDADD( DADD obj );\n+    void visitBALOAD(BALOAD obj);\n@@ -188,0 +56,1 @@\n+    void visitBASTORE(BASTORE obj);\n@@ -189,1 +58,1 @@\n-    void visitINVOKESPECIAL( INVOKESPECIAL obj );\n+    void visitBIPUSH(BIPUSH obj);\n@@ -191,0 +60,1 @@\n+    void visitBranchInstruction(BranchInstruction obj);\n@@ -192,1 +62,1 @@\n-    void visitIAND( IAND obj );\n+    void visitBREAKPOINT(BREAKPOINT obj);\n@@ -194,0 +64,1 @@\n+    void visitCALOAD(CALOAD obj);\n@@ -195,1 +66,1 @@\n-    void visitPUTFIELD( PUTFIELD obj );\n+    void visitCASTORE(CASTORE obj);\n@@ -197,0 +68,1 @@\n+    void visitCHECKCAST(CHECKCAST obj);\n@@ -198,1 +70,1 @@\n-    void visitILOAD( ILOAD obj );\n+    void visitConstantPushInstruction(ConstantPushInstruction obj);\n@@ -200,0 +72,1 @@\n+    void visitConversionInstruction(ConversionInstruction obj);\n@@ -201,1 +74,1 @@\n-    void visitDLOAD( DLOAD obj );\n+    void visitCPInstruction(CPInstruction obj);\n@@ -203,0 +76,1 @@\n+    void visitD2F(D2F obj);\n@@ -204,1 +78,1 @@\n-    void visitDCONST( DCONST obj );\n+    void visitD2I(D2I obj);\n@@ -206,0 +80,1 @@\n+    void visitD2L(D2L obj);\n@@ -207,1 +82,1 @@\n-    void visitNEW( NEW obj );\n+    void visitDADD(DADD obj);\n@@ -209,0 +84,1 @@\n+    void visitDALOAD(DALOAD obj);\n@@ -210,1 +86,1 @@\n-    void visitIFNULL( IFNULL obj );\n+    void visitDASTORE(DASTORE obj);\n@@ -212,0 +88,1 @@\n+    void visitDCMPG(DCMPG obj);\n@@ -213,1 +90,1 @@\n-    void visitLSUB( LSUB obj );\n+    void visitDCMPL(DCMPL obj);\n@@ -215,0 +92,1 @@\n+    void visitDCONST(DCONST obj);\n@@ -216,1 +94,1 @@\n-    void visitL2I( L2I obj );\n+    void visitDDIV(DDIV obj);\n@@ -218,0 +96,1 @@\n+    void visitDLOAD(DLOAD obj);\n@@ -219,1 +98,1 @@\n-    void visitISHR( ISHR obj );\n+    void visitDMUL(DMUL obj);\n@@ -221,0 +100,1 @@\n+    void visitDNEG(DNEG obj);\n@@ -222,1 +102,1 @@\n-    void visitTABLESWITCH( TABLESWITCH obj );\n+    void visitDREM(DREM obj);\n@@ -224,0 +104,1 @@\n+    void visitDRETURN(DRETURN obj);\n@@ -225,1 +106,1 @@\n-    void visitIINC( IINC obj );\n+    void visitDSTORE(DSTORE obj);\n@@ -227,0 +108,1 @@\n+    void visitDSUB(DSUB obj);\n@@ -228,1 +110,1 @@\n-    void visitDRETURN( DRETURN obj );\n+    void visitDUP(DUP obj);\n@@ -230,0 +112,1 @@\n+    void visitDUP_X1(DUP_X1 obj);\n@@ -231,1 +114,1 @@\n-    void visitFSTORE( FSTORE obj );\n+    void visitDUP_X2(DUP_X2 obj);\n@@ -233,0 +116,1 @@\n+    void visitDUP2(DUP2 obj);\n@@ -234,1 +118,1 @@\n-    void visitDASTORE( DASTORE obj );\n+    void visitDUP2_X1(DUP2_X1 obj);\n@@ -236,0 +120,1 @@\n+    void visitDUP2_X2(DUP2_X2 obj);\n@@ -237,1 +122,1 @@\n-    void visitIALOAD( IALOAD obj );\n+    void visitExceptionThrower(ExceptionThrower obj);\n@@ -239,0 +124,1 @@\n+    void visitF2D(F2D obj);\n@@ -240,1 +126,1 @@\n-    void visitDDIV( DDIV obj );\n+    void visitF2I(F2I obj);\n@@ -242,0 +128,1 @@\n+    void visitF2L(F2L obj);\n@@ -243,1 +130,1 @@\n-    void visitIF_ICMPGE( IF_ICMPGE obj );\n+    void visitFADD(FADD obj);\n@@ -245,0 +132,1 @@\n+    void visitFALOAD(FALOAD obj);\n@@ -246,1 +134,1 @@\n-    void visitLAND( LAND obj );\n+    void visitFASTORE(FASTORE obj);\n@@ -248,0 +136,1 @@\n+    void visitFCMPG(FCMPG obj);\n@@ -249,1 +138,1 @@\n-    void visitIDIV( IDIV obj );\n+    void visitFCMPL(FCMPL obj);\n@@ -251,0 +140,1 @@\n+    void visitFCONST(FCONST obj);\n@@ -252,1 +142,1 @@\n-    void visitLOR( LOR obj );\n+    void visitFDIV(FDIV obj);\n@@ -254,0 +144,1 @@\n+    void visitFieldInstruction(FieldInstruction obj);\n@@ -255,1 +146,1 @@\n-    void visitCASTORE( CASTORE obj );\n+    void visitFieldOrMethod(FieldOrMethod obj);\n@@ -257,0 +148,1 @@\n+    void visitFLOAD(FLOAD obj);\n@@ -258,1 +150,1 @@\n-    void visitFREM( FREM obj );\n+    void visitFMUL(FMUL obj);\n@@ -260,0 +152,1 @@\n+    void visitFNEG(FNEG obj);\n@@ -261,1 +154,1 @@\n-    void visitLDC( LDC obj );\n+    void visitFREM(FREM obj);\n@@ -263,0 +156,1 @@\n+    void visitFRETURN(FRETURN obj);\n@@ -264,1 +158,1 @@\n-    void visitBIPUSH( BIPUSH obj );\n+    void visitFSTORE(FSTORE obj);\n@@ -266,0 +160,1 @@\n+    void visitFSUB(FSUB obj);\n@@ -267,1 +162,1 @@\n-    void visitDSTORE( DSTORE obj );\n+    void visitGETFIELD(GETFIELD obj);\n@@ -269,0 +164,1 @@\n+    void visitGETSTATIC(GETSTATIC obj);\n@@ -270,1 +166,1 @@\n-    void visitF2L( F2L obj );\n+    void visitGOTO(GOTO obj);\n@@ -272,0 +168,1 @@\n+    void visitGOTO_W(GOTO_W obj);\n@@ -273,1 +170,1 @@\n-    void visitFMUL( FMUL obj );\n+    void visitGotoInstruction(GotoInstruction obj);\n@@ -275,0 +172,1 @@\n+    void visitI2B(I2B obj);\n@@ -276,1 +174,1 @@\n-    void visitLLOAD( LLOAD obj );\n+    void visitI2C(I2C obj);\n@@ -278,0 +176,1 @@\n+    void visitI2D(I2D obj);\n@@ -279,1 +178,1 @@\n-    void visitJSR( JSR obj );\n+    void visitI2F(I2F obj);\n@@ -281,0 +180,1 @@\n+    void visitI2L(I2L obj);\n@@ -282,1 +182,1 @@\n-    void visitFSUB( FSUB obj );\n+    void visitI2S(I2S obj);\n@@ -284,0 +184,1 @@\n+    void visitIADD(IADD obj);\n@@ -285,1 +186,1 @@\n-    void visitSASTORE( SASTORE obj );\n+    void visitIALOAD(IALOAD obj);\n@@ -287,0 +188,1 @@\n+    void visitIAND(IAND obj);\n@@ -288,1 +190,1 @@\n-    void visitALOAD( ALOAD obj );\n+    void visitIASTORE(IASTORE obj);\n@@ -290,0 +192,1 @@\n+    void visitICONST(ICONST obj);\n@@ -291,1 +194,1 @@\n-    void visitDUP2_X2( DUP2_X2 obj );\n+    void visitIDIV(IDIV obj);\n@@ -293,0 +196,1 @@\n+    void visitIF_ACMPEQ(IF_ACMPEQ obj);\n@@ -294,1 +198,1 @@\n-    void visitRETURN( RETURN obj );\n+    void visitIF_ACMPNE(IF_ACMPNE obj);\n@@ -296,0 +200,1 @@\n+    void visitIF_ICMPEQ(IF_ICMPEQ obj);\n@@ -297,1 +202,1 @@\n-    void visitDALOAD( DALOAD obj );\n+    void visitIF_ICMPGE(IF_ICMPGE obj);\n@@ -299,0 +204,1 @@\n+    void visitIF_ICMPGT(IF_ICMPGT obj);\n@@ -300,1 +206,1 @@\n-    void visitSIPUSH( SIPUSH obj );\n+    void visitIF_ICMPLE(IF_ICMPLE obj);\n@@ -302,0 +208,1 @@\n+    void visitIF_ICMPLT(IF_ICMPLT obj);\n@@ -303,1 +210,1 @@\n-    void visitDSUB( DSUB obj );\n+    void visitIF_ICMPNE(IF_ICMPNE obj);\n@@ -305,0 +212,1 @@\n+    void visitIFEQ(IFEQ obj);\n@@ -306,1 +214,1 @@\n-    void visitL2F( L2F obj );\n+    void visitIFGE(IFGE obj);\n@@ -308,0 +216,1 @@\n+    void visitIFGT(IFGT obj);\n@@ -309,1 +218,1 @@\n-    void visitIF_ICMPGT( IF_ICMPGT obj );\n+    void visitIfInstruction(IfInstruction obj);\n@@ -311,0 +220,1 @@\n+    void visitIFLE(IFLE obj);\n@@ -312,1 +222,1 @@\n-    void visitF2D( F2D obj );\n+    void visitIFLT(IFLT obj);\n@@ -314,0 +224,1 @@\n+    void visitIFNE(IFNE obj);\n@@ -315,1 +226,1 @@\n-    void visitI2L( I2L obj );\n+    void visitIFNONNULL(IFNONNULL obj);\n@@ -317,0 +228,1 @@\n+    void visitIFNULL(IFNULL obj);\n@@ -318,1 +230,1 @@\n-    void visitIF_ACMPNE( IF_ACMPNE obj );\n+    void visitIINC(IINC obj);\n@@ -320,0 +232,1 @@\n+    void visitILOAD(ILOAD obj);\n@@ -321,1 +234,1 @@\n-    void visitPOP( POP obj );\n+    void visitIMPDEP1(IMPDEP1 obj);\n@@ -323,0 +236,1 @@\n+    void visitIMPDEP2(IMPDEP2 obj);\n@@ -324,1 +238,1 @@\n-    void visitI2S( I2S obj );\n+    void visitIMUL(IMUL obj);\n@@ -326,0 +240,1 @@\n+    void visitINEG(INEG obj);\n@@ -327,125 +242,1 @@\n-    void visitIFEQ( IFEQ obj );\n-\n-\n-    void visitSWAP( SWAP obj );\n-\n-\n-    void visitIOR( IOR obj );\n-\n-\n-    void visitIREM( IREM obj );\n-\n-\n-    void visitIASTORE( IASTORE obj );\n-\n-\n-    void visitNEWARRAY( NEWARRAY obj );\n-\n-\n-    void visitINVOKEINTERFACE( INVOKEINTERFACE obj );\n-\n-\n-    void visitINEG( INEG obj );\n-\n-\n-    void visitLCMP( LCMP obj );\n-\n-\n-    void visitJSR_W( JSR_W obj );\n-\n-\n-    void visitMULTIANEWARRAY( MULTIANEWARRAY obj );\n-\n-\n-    void visitDUP_X2( DUP_X2 obj );\n-\n-\n-    void visitSALOAD( SALOAD obj );\n-\n-\n-    void visitIFNONNULL( IFNONNULL obj );\n-\n-\n-    void visitDMUL( DMUL obj );\n-\n-\n-    void visitIFNE( IFNE obj );\n-\n-\n-    void visitIF_ICMPLE( IF_ICMPLE obj );\n-\n-\n-    void visitLDC2_W( LDC2_W obj );\n-\n-\n-    void visitGETFIELD( GETFIELD obj );\n-\n-\n-    void visitLADD( LADD obj );\n-\n-\n-    void visitNOP( NOP obj );\n-\n-\n-    void visitFALOAD( FALOAD obj );\n-\n-\n-    void visitINSTANCEOF( INSTANCEOF obj );\n-\n-\n-    void visitIFLE( IFLE obj );\n-\n-\n-    void visitLXOR( LXOR obj );\n-\n-\n-    void visitLRETURN( LRETURN obj );\n-\n-\n-    void visitFCONST( FCONST obj );\n-\n-\n-    void visitIUSHR( IUSHR obj );\n-\n-\n-    void visitBALOAD( BALOAD obj );\n-\n-\n-    void visitDUP2( DUP2 obj );\n-\n-\n-    void visitIF_ACMPEQ( IF_ACMPEQ obj );\n-\n-\n-    void visitIMPDEP1( IMPDEP1 obj );\n-\n-\n-    void visitMONITORENTER( MONITORENTER obj );\n-\n-\n-    void visitLSHL( LSHL obj );\n-\n-\n-    void visitDCMPG( DCMPG obj );\n-\n-\n-    void visitD2L( D2L obj );\n-\n-\n-    void visitIMPDEP2( IMPDEP2 obj );\n-\n-\n-    void visitL2D( L2D obj );\n-\n-\n-    void visitRET( RET obj );\n-\n-\n-    void visitIFGT( IFGT obj );\n-\n-\n-    void visitIXOR( IXOR obj );\n-\n-\n-    void visitINVOKEVIRTUAL( INVOKEVIRTUAL obj );\n-\n+    void visitINSTANCEOF(INSTANCEOF obj);\n@@ -456,11 +247,1 @@\n-    void visitINVOKEDYNAMIC( INVOKEDYNAMIC obj );\n-\n-\n-    void visitFASTORE( FASTORE obj );\n-\n-\n-    void visitIRETURN( IRETURN obj );\n-\n-\n-    void visitIF_ICMPNE( IF_ICMPNE obj );\n-\n+    void visitINVOKEDYNAMIC(INVOKEDYNAMIC obj);\n@@ -468,1 +249,1 @@\n-    void visitFLOAD( FLOAD obj );\n+    void visitInvokeInstruction(InvokeInstruction obj);\n@@ -470,0 +251,1 @@\n+    void visitINVOKEINTERFACE(INVOKEINTERFACE obj);\n@@ -471,1 +253,1 @@\n-    void visitLDIV( LDIV obj );\n+    void visitINVOKESPECIAL(INVOKESPECIAL obj);\n@@ -473,0 +255,1 @@\n+    void visitINVOKESTATIC(INVOKESTATIC obj);\n@@ -474,1 +257,1 @@\n-    void visitPUTSTATIC( PUTSTATIC obj );\n+    void visitINVOKEVIRTUAL(INVOKEVIRTUAL obj);\n@@ -476,0 +259,1 @@\n+    void visitIOR(IOR obj);\n@@ -477,1 +261,1 @@\n-    void visitAALOAD( AALOAD obj );\n+    void visitIREM(IREM obj);\n@@ -479,0 +263,1 @@\n+    void visitIRETURN(IRETURN obj);\n@@ -480,1 +265,1 @@\n-    void visitD2I( D2I obj );\n+    void visitISHL(ISHL obj);\n@@ -482,0 +267,1 @@\n+    void visitISHR(ISHR obj);\n@@ -483,1 +269,1 @@\n-    void visitIF_ICMPEQ( IF_ICMPEQ obj );\n+    void visitISTORE(ISTORE obj);\n@@ -485,0 +271,1 @@\n+    void visitISUB(ISUB obj);\n@@ -486,1 +273,1 @@\n-    void visitAASTORE( AASTORE obj );\n+    void visitIUSHR(IUSHR obj);\n@@ -488,0 +275,1 @@\n+    void visitIXOR(IXOR obj);\n@@ -489,1 +277,1 @@\n-    void visitARETURN( ARETURN obj );\n+    void visitJSR(JSR obj);\n@@ -491,0 +279,1 @@\n+    void visitJSR_W(JSR_W obj);\n@@ -492,1 +281,1 @@\n-    void visitDUP2_X1( DUP2_X1 obj );\n+    void visitJsrInstruction(JsrInstruction obj);\n@@ -494,0 +283,1 @@\n+    void visitL2D(L2D obj);\n@@ -495,1 +285,1 @@\n-    void visitFNEG( FNEG obj );\n+    void visitL2F(L2F obj);\n@@ -497,0 +287,1 @@\n+    void visitL2I(L2I obj);\n@@ -498,1 +289,1 @@\n-    void visitGOTO_W( GOTO_W obj );\n+    void visitLADD(LADD obj);\n@@ -500,0 +291,1 @@\n+    void visitLALOAD(LALOAD obj);\n@@ -501,1 +293,1 @@\n-    void visitD2F( D2F obj );\n+    void visitLAND(LAND obj);\n@@ -503,0 +295,1 @@\n+    void visitLASTORE(LASTORE obj);\n@@ -504,1 +297,1 @@\n-    void visitGOTO( GOTO obj );\n+    void visitLCMP(LCMP obj);\n@@ -506,0 +299,1 @@\n+    void visitLCONST(LCONST obj);\n@@ -507,1 +301,1 @@\n-    void visitISUB( ISUB obj );\n+    void visitLDC(LDC obj);\n@@ -509,0 +303,1 @@\n+    void visitLDC2_W(LDC2_W obj);\n@@ -510,1 +305,1 @@\n-    void visitF2I( F2I obj );\n+    void visitLDIV(LDIV obj);\n@@ -512,0 +307,1 @@\n+    void visitLLOAD(LLOAD obj);\n@@ -513,1 +309,1 @@\n-    void visitDNEG( DNEG obj );\n+    void visitLMUL(LMUL obj);\n@@ -515,0 +311,1 @@\n+    void visitLNEG(LNEG obj);\n@@ -516,1 +313,1 @@\n-    void visitICONST( ICONST obj );\n+    void visitLoadClass(LoadClass obj);\n@@ -518,0 +315,1 @@\n+    void visitLoadInstruction(LoadInstruction obj);\n@@ -519,1 +317,1 @@\n-    void visitFDIV( FDIV obj );\n+    void visitLocalVariableInstruction(LocalVariableInstruction obj);\n@@ -521,0 +319,1 @@\n+    void visitLOOKUPSWITCH(LOOKUPSWITCH obj);\n@@ -522,1 +321,1 @@\n-    void visitI2B( I2B obj );\n+    void visitLOR(LOR obj);\n@@ -524,0 +323,1 @@\n+    void visitLREM(LREM obj);\n@@ -525,1 +325,1 @@\n-    void visitLNEG( LNEG obj );\n+    void visitLRETURN(LRETURN obj);\n@@ -527,0 +327,1 @@\n+    void visitLSHL(LSHL obj);\n@@ -528,1 +329,1 @@\n-    void visitLREM( LREM obj );\n+    void visitLSHR(LSHR obj);\n@@ -530,0 +331,1 @@\n+    void visitLSTORE(LSTORE obj);\n@@ -531,1 +333,1 @@\n-    void visitIMUL( IMUL obj );\n+    void visitLSUB(LSUB obj);\n@@ -533,0 +335,1 @@\n+    void visitLUSHR(LUSHR obj);\n@@ -534,1 +337,1 @@\n-    void visitIADD( IADD obj );\n+    void visitLXOR(LXOR obj);\n@@ -536,0 +339,1 @@\n+    void visitMONITORENTER(MONITORENTER obj);\n@@ -537,1 +341,1 @@\n-    void visitLSHR( LSHR obj );\n+    void visitMONITOREXIT(MONITOREXIT obj);\n@@ -539,0 +343,1 @@\n+    void visitMULTIANEWARRAY(MULTIANEWARRAY obj);\n@@ -540,1 +345,1 @@\n-    void visitLOOKUPSWITCH( LOOKUPSWITCH obj );\n+    void visitNEW(NEW obj);\n@@ -542,0 +347,1 @@\n+    void visitNEWARRAY(NEWARRAY obj);\n@@ -543,1 +349,1 @@\n-    void visitDUP_X1( DUP_X1 obj );\n+    void visitNOP(NOP obj);\n@@ -545,0 +351,1 @@\n+    void visitPOP(POP obj);\n@@ -546,1 +353,1 @@\n-    void visitFCMPL( FCMPL obj );\n+    void visitPOP2(POP2 obj);\n@@ -548,0 +355,1 @@\n+    void visitPopInstruction(PopInstruction obj);\n@@ -549,1 +357,1 @@\n-    void visitI2C( I2C obj );\n+    void visitPushInstruction(PushInstruction obj);\n@@ -551,0 +359,1 @@\n+    void visitPUTFIELD(PUTFIELD obj);\n@@ -552,1 +361,1 @@\n-    void visitLMUL( LMUL obj );\n+    void visitPUTSTATIC(PUTSTATIC obj);\n@@ -554,0 +363,1 @@\n+    void visitRET(RET obj);\n@@ -555,1 +365,1 @@\n-    void visitLUSHR( LUSHR obj );\n+    void visitRETURN(RETURN obj);\n@@ -557,0 +367,1 @@\n+    void visitReturnInstruction(ReturnInstruction obj);\n@@ -558,1 +369,1 @@\n-    void visitISHL( ISHL obj );\n+    void visitSALOAD(SALOAD obj);\n@@ -560,0 +371,1 @@\n+    void visitSASTORE(SASTORE obj);\n@@ -561,1 +373,1 @@\n-    void visitLALOAD( LALOAD obj );\n+    void visitSelect(Select obj);\n@@ -563,0 +375,1 @@\n+    void visitSIPUSH(SIPUSH obj);\n@@ -564,1 +377,1 @@\n-    void visitASTORE( ASTORE obj );\n+    void visitStackConsumer(StackConsumer obj);\n@@ -566,0 +379,1 @@\n+    void visitStackInstruction(StackInstruction obj);\n@@ -567,1 +381,1 @@\n-    void visitANEWARRAY( ANEWARRAY obj );\n+    void visitStackProducer(StackProducer obj);\n@@ -569,0 +383,1 @@\n+    void visitStoreInstruction(StoreInstruction obj);\n@@ -570,1 +385,1 @@\n-    void visitFRETURN( FRETURN obj );\n+    void visitSWAP(SWAP obj);\n@@ -572,0 +387,1 @@\n+    void visitTABLESWITCH(TABLESWITCH obj);\n@@ -573,1 +389,1 @@\n-    void visitFADD( FADD obj );\n+    void visitTypedInstruction(TypedInstruction obj);\n@@ -575,0 +391,1 @@\n+    void visitUnconditionalBranch(UnconditionalBranch obj);\n@@ -576,1 +393,1 @@\n-    void visitBREAKPOINT( BREAKPOINT obj );\n+    void visitVariableLengthInstruction(VariableLengthInstruction obj);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Visitor.java","additions":183,"deletions":366,"binary":false,"changes":549,"status":"modified"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n+ *\/\n+\/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *\/\n+\n+package com.sun.org.apache.bcel.internal.util;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;\n+\n+\/**\n+ * Argument validation.\n+ *\n+ * @since 6.7.0\n+ *\/\n+public class Args {\n+\n+    \/**\n+     * Requires a specific value.\n+     *\n+     * @param value    The value to test.\n+     * @param required The required value.\n+     * @param message  The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int require(final int value, final int required, final String message) {\n+        if (value != required) {\n+            throw new ClassFormatException(String.format(\"%s [Value must be 0: %,d]\", message, value));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Requires a 0 value.\n+     *\n+     * @param value   The value to test.\n+     * @param message The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int require0(final int value, final String message) {\n+        return require(value, 0, message);\n+    }\n+\n+    \/**\n+     * Requires a u1 value.\n+     *\n+     * @param value   The value to test.\n+     * @param message The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int requireU1(final int value, final String message) {\n+        if (value < 0 || value > Const.MAX_BYTE) {\n+            throw new ClassFormatException(String.format(\"%s [Value out of range (0 - %,d) for type u1: %,d]\", message, Const.MAX_BYTE, value));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Requires a u2 value of at least {@code min} and not above {@code max}.\n+     *\n+     * @param value   The value to test.\n+     * @param min     The minimum required u2 value.\n+     * @param max     The maximum required u2 value.\n+     * @param message The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int requireU2(final int value, final int min, final int max, final String message) {\n+        if (max > Const.MAX_SHORT) {\n+            throw new IllegalArgumentException(String.format(\"%s programming error: max %,d > %,d\", message, max, Const.MAX_SHORT));\n+        }\n+        if (min < 0) {\n+            throw new IllegalArgumentException(String.format(\"%s programming error: min %,d < 0\", message, min));\n+        }\n+        if (value < min || value > max) {\n+            throw new ClassFormatException(String.format(\"%s [Value out of range (%,d - %,d) for type u2: %,d]\", message, min, Const.MAX_SHORT, value));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Requires a u2 value of at least {@code min}.\n+     *\n+     * @param value   The value to test.\n+     * @param min     The minimum required value.\n+     * @param message The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int requireU2(final int value, final int min, final String message) {\n+        return requireU2(value, min, Const.MAX_SHORT, message);\n+    }\n+\n+    \/**\n+     * Requires a u2 value.\n+     *\n+     * @param value   The value to test.\n+     * @param message The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int requireU2(final int value, final String message) {\n+        return requireU2(value, 0, message);\n+    }\n+\n+    \/**\n+     * Requires a u4 value of at least {@code min}.\n+     *\n+     * @param value   The value to test.\n+     * @param min     The minimum required value.\n+     * @param message The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int requireU4(final int value, final int min, final String message) {\n+        if (min < 0) {\n+            throw new IllegalArgumentException(String.format(\"%s programming error: min %,d < 0\", message, min));\n+        }\n+        if (value < min) {\n+            throw new ClassFormatException(\n+                    String.format(\"%s [Value out of range (%,d - %,d) for type u2: %,d]\", message, min, Integer.MAX_VALUE, value & 0xFFFFFFFFL));\n+        }\n+        return value;\n+    }\n+\n+    \/**\n+     * Requires a u4 value.\n+     *\n+     * @param value   The value to test.\n+     * @param message The message prefix\n+     * @return The value to test.\n+     *\/\n+    public static int requireU4(final int value, final String message) {\n+        return requireU4(value, 0, message);\n+    }\n+}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Args.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -24,2 +24,2 @@\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n+import java.io.Closeable;\n+import java.io.FileNotFoundException;\n@@ -27,0 +27,2 @@\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.Charset;\n@@ -33,1 +35,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;\n@@ -40,1 +41,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.LocalVariable;\n@@ -47,2 +47,0 @@\n- *\n- *\n@@ -50,1 +48,1 @@\n-final class AttributeHTML {\n+final class AttributeHTML implements Closeable {\n@@ -52,5 +50,5 @@\n-    private final String class_name; \/\/ name of current class\n-    private final PrintWriter file; \/\/ file to write to\n-    private int attr_count = 0;\n-    private final ConstantHTML constant_html;\n-    private final ConstantPool constant_pool;\n+    private final String className; \/\/ name of current class\n+    private final PrintWriter printWriter; \/\/ file to write to\n+    private int attrCount;\n+    private final ConstantHTML constantHtml;\n+    private final ConstantPool constantPool;\n@@ -58,8 +56,10 @@\n-\n-    AttributeHTML(final String dir, final String class_name, final ConstantPool constant_pool,\n-            final ConstantHTML constant_html) throws IOException {\n-        this.class_name = class_name;\n-        this.constant_pool = constant_pool;\n-        this.constant_html = constant_html;\n-        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_attributes.html\"));\n-        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+    AttributeHTML(final String dir, final String className, final ConstantPool constantPool, final ConstantHTML constantHtml, final Charset charset)\n+        throws FileNotFoundException, UnsupportedEncodingException {\n+        this.className = className;\n+        this.constantPool = constantPool;\n+        this.constantHtml = constantHtml;\n+        printWriter = new PrintWriter(dir + className + \"_attributes.html\", charset.name());\n+        printWriter.print(\"<HTML><head><meta charset=\\\"\");\n+        printWriter.print(charset.name());\n+        printWriter.println(\"\\\"><\/head>\");\n+        printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n@@ -68,4 +68,4 @@\n-\n-    private String codeLink( final int link, final int method_number ) {\n-        return \"<A HREF=\\\"\" + class_name + \"_code.html#code\" + method_number + \"@\" + link\n-                + \"\\\" TARGET=Code>\" + link + \"<\/A>\";\n+    @Override\n+    public void close() {\n+        printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+        printWriter.close();\n@@ -74,4 +74,2 @@\n-\n-    void close() {\n-        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n-        file.close();\n+    private String codeLink(final int link, final int methodNumber) {\n+        return \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + link + \"\\\" TARGET=Code>\" + link + \"<\/A>\";\n@@ -80,2 +78,1 @@\n-\n-    void writeAttribute( final Attribute attribute, final String anchor ) {\n+    void writeAttribute(final Attribute attribute, final String anchor) {\n@@ -85,2 +82,1 @@\n-\n-    void writeAttribute( final Attribute attribute, final String anchor, final int method_number ) {\n+    void writeAttribute(final Attribute attribute, final String anchor, final int methodNumber) {\n@@ -92,3 +88,3 @@\n-        attr_count++; \/\/ Increment number of attributes found so far\n-        if (attr_count % 2 == 0) {\n-            file.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n+        attrCount++; \/\/ Increment number of attributes found so far\n+        if (attrCount % 2 == 0) {\n+            printWriter.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n@@ -96,1 +92,1 @@\n-            file.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n+            printWriter.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n@@ -98,3 +94,3 @@\n-        file.println(\"<H4><A NAME=\\\"\" + anchor + \"\\\">\" + attr_count + \" \" + Const.getAttributeName(tag)\n-                + \"<\/A><\/H4>\");\n-        \/* Handle different attributes\n+        printWriter.println(\"<H4><A NAME=\\\"\" + anchor + \"\\\">\" + attrCount + \" \" + Const.getAttributeName(tag) + \"<\/A><\/H4>\");\n+        \/*\n+         * Handle different attributes\n@@ -103,61 +99,17 @@\n-            case Const.ATTR_CODE:\n-                final Code c = (Code) attribute;\n-                \/\/ Some directly printable values\n-                file.print(\"<UL><LI>Maximum stack size = \" + c.getMaxStack()\n-                        + \"<\/LI>\\n<LI>Number of local variables = \" + c.getMaxLocals()\n-                        + \"<\/LI>\\n<LI><A HREF=\\\"\" + class_name + \"_code.html#method\"\n-                        + method_number + \"\\\" TARGET=Code>Byte code<\/A><\/LI><\/UL>\\n\");\n-                \/\/ Get handled exceptions and list them\n-                final CodeException[] ce = c.getExceptionTable();\n-                final int len = ce.length;\n-                if (len > 0) {\n-                    file.print(\"<P><B>Exceptions handled<\/B><UL>\");\n-                    for (final CodeException cex : ce) {\n-                        final int catch_type = cex.getCatchType(); \/\/ Index in constant pool\n-                        file.print(\"<LI>\");\n-                        if (catch_type != 0) {\n-                            file.print(constant_html.referenceConstant(catch_type)); \/\/ Create Link to _cp.html\n-                        } else {\n-                            file.print(\"Any Exception\");\n-                        }\n-                        file.print(\"<BR>(Ranging from lines \"\n-                                + codeLink(cex.getStartPC(), method_number) + \" to \"\n-                                + codeLink(cex.getEndPC(), method_number) + \", handled at line \"\n-                                + codeLink(cex.getHandlerPC(), method_number) + \")<\/LI>\");\n-                    }\n-                    file.print(\"<\/UL>\");\n-                }\n-                break;\n-            case Const.ATTR_CONSTANT_VALUE:\n-                index = ((ConstantValue) attribute).getConstantValueIndex();\n-                \/\/ Reference _cp.html\n-                file.print(\"<UL><LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index\n-                        + \"\\\" TARGET=\\\"ConstantPool\\\">Constant value index(\" + index\n-                        + \")<\/A><\/UL>\\n\");\n-                break;\n-            case Const.ATTR_SOURCE_FILE:\n-                index = ((SourceFile) attribute).getSourceFileIndex();\n-                \/\/ Reference _cp.html\n-                file.print(\"<UL><LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index\n-                        + \"\\\" TARGET=\\\"ConstantPool\\\">Source file index(\" + index + \")<\/A><\/UL>\\n\");\n-                break;\n-            case Const.ATTR_EXCEPTIONS:\n-                \/\/ List thrown exceptions\n-                final int[] indices = ((ExceptionTable) attribute).getExceptionIndexTable();\n-                file.print(\"<UL>\");\n-                for (final int indice : indices) {\n-                    file.print(\"<LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + indice\n-                            + \"\\\" TARGET=\\\"ConstantPool\\\">Exception class index(\" + indice\n-                            + \")<\/A>\\n\");\n-                }\n-                file.print(\"<\/UL>\\n\");\n-                break;\n-            case Const.ATTR_LINE_NUMBER_TABLE:\n-                final LineNumber[] line_numbers = ((LineNumberTable) attribute).getLineNumberTable();\n-                \/\/ List line number pairs\n-                file.print(\"<P>\");\n-                for (int i = 0; i < line_numbers.length; i++) {\n-                    file.print(\"(\" + line_numbers[i].getStartPC() + \",&nbsp;\"\n-                            + line_numbers[i].getLineNumber() + \")\");\n-                    if (i < line_numbers.length - 1) {\n-                        file.print(\", \"); \/\/ breakable\n+        case Const.ATTR_CODE:\n+            final Code c = (Code) attribute;\n+            \/\/ Some directly printable values\n+            printWriter.print(\"<UL><LI>Maximum stack size = \" + c.getMaxStack() + \"<\/LI>\\n<LI>Number of local variables = \" + c.getMaxLocals()\n+                + \"<\/LI>\\n<LI><A HREF=\\\"\" + className + \"_code.html#method\" + methodNumber + \"\\\" TARGET=Code>Byte code<\/A><\/LI><\/UL>\\n\");\n+            \/\/ Get handled exceptions and list them\n+            final CodeException[] ce = c.getExceptionTable();\n+            final int len = ce.length;\n+            if (len > 0) {\n+                printWriter.print(\"<P><B>Exceptions handled<\/B><UL>\");\n+                for (final CodeException cex : ce) {\n+                    final int catchType = cex.getCatchType(); \/\/ Index in constant pool\n+                    printWriter.print(\"<LI>\");\n+                    if (catchType != 0) {\n+                        printWriter.print(constantHtml.referenceConstant(catchType)); \/\/ Create Link to _cp.html\n+                    } else {\n+                        printWriter.print(\"Any Exception\");\n@@ -165,0 +117,2 @@\n+                    printWriter.print(\"<BR>(Ranging from lines \" + codeLink(cex.getStartPC(), methodNumber) + \" to \" + codeLink(cex.getEndPC(), methodNumber)\n+                        + \", handled at line \" + codeLink(cex.getHandlerPC(), methodNumber) + \")<\/LI>\");\n@@ -166,18 +120,33 @@\n-                break;\n-            case Const.ATTR_LOCAL_VARIABLE_TABLE:\n-                final LocalVariable[] vars = ((LocalVariableTable) attribute).getLocalVariableTable();\n-                \/\/ List name, range and type\n-                file.print(\"<UL>\");\n-                for (final LocalVariable var : vars) {\n-                    index = var.getSignatureIndex();\n-                    String signature = ((ConstantUtf8) constant_pool.getConstant(index,\n-                            Const.CONSTANT_Utf8)).getBytes();\n-                    signature = Utility.signatureToString(signature, false);\n-                    final int start = var.getStartPC();\n-                    final int end = start + var.getLength();\n-                    file.println(\"<LI>\" + Class2HTML.referenceType(signature) + \"&nbsp;<B>\"\n-                            + var.getName() + \"<\/B> in slot %\" + var.getIndex()\n-                            + \"<BR>Valid from lines \" + \"<A HREF=\\\"\" + class_name\n-                            + \"_code.html#code\" + method_number + \"@\" + start + \"\\\" TARGET=Code>\"\n-                            + start + \"<\/A> to \" + \"<A HREF=\\\"\" + class_name + \"_code.html#code\"\n-                            + method_number + \"@\" + end + \"\\\" TARGET=Code>\" + end + \"<\/A><\/LI>\");\n+                printWriter.print(\"<\/UL>\");\n+            }\n+            break;\n+        case Const.ATTR_CONSTANT_VALUE:\n+            index = ((ConstantValue) attribute).getConstantValueIndex();\n+            \/\/ Reference _cp.html\n+            printWriter\n+                .print(\"<UL><LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=\\\"ConstantPool\\\">Constant value index(\" + index + \")<\/A><\/UL>\\n\");\n+            break;\n+        case Const.ATTR_SOURCE_FILE:\n+            index = ((SourceFile) attribute).getSourceFileIndex();\n+            \/\/ Reference _cp.html\n+            printWriter\n+                .print(\"<UL><LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=\\\"ConstantPool\\\">Source file index(\" + index + \")<\/A><\/UL>\\n\");\n+            break;\n+        case Const.ATTR_EXCEPTIONS:\n+            \/\/ List thrown exceptions\n+            final int[] indices = ((ExceptionTable) attribute).getExceptionIndexTable();\n+            printWriter.print(\"<UL>\");\n+            for (final int indice : indices) {\n+                printWriter\n+                    .print(\"<LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + indice + \"\\\" TARGET=\\\"ConstantPool\\\">Exception class index(\" + indice + \")<\/A>\\n\");\n+            }\n+            printWriter.print(\"<\/UL>\\n\");\n+            break;\n+        case Const.ATTR_LINE_NUMBER_TABLE:\n+            final LineNumber[] lineNumbers = ((LineNumberTable) attribute).getLineNumberTable();\n+            \/\/ List line number pairs\n+            printWriter.print(\"<P>\");\n+            for (int i = 0; i < lineNumbers.length; i++) {\n+                printWriter.print(\"(\" + lineNumbers[i].getStartPC() + \",&nbsp;\" + lineNumbers[i].getLineNumber() + \")\");\n+                if (i < lineNumbers.length - 1) {\n+                    printWriter.print(\", \"); \/\/ breakable\n@@ -185,22 +154,28 @@\n-                file.print(\"<\/UL>\\n\");\n-                break;\n-            case Const.ATTR_INNER_CLASSES:\n-                final InnerClass[] classes = ((InnerClasses) attribute).getInnerClasses();\n-                \/\/ List inner classes\n-                file.print(\"<UL>\");\n-                for (final InnerClass classe : classes) {\n-                    String name;\n-                    String access;\n-                    index = classe.getInnerNameIndex();\n-                    if (index > 0) {\n-                        name = ((ConstantUtf8) constant_pool.getConstant(index, Const.CONSTANT_Utf8))\n-                                .getBytes();\n-                    } else {\n-                        name = \"&lt;anonymous&gt;\";\n-                    }\n-                    access = Utility.accessToString(classe.getInnerAccessFlags());\n-                    file.print(\"<LI><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT> \"\n-                            + constant_html.referenceConstant(classe.getInnerClassIndex())\n-                            + \" in&nbsp;class \"\n-                            + constant_html.referenceConstant(classe.getOuterClassIndex())\n-                            + \" named \" + name + \"<\/LI>\\n\");\n+            }\n+            break;\n+        case Const.ATTR_LOCAL_VARIABLE_TABLE:\n+            \/\/ List name, range and type\n+            printWriter.print(\"<UL>\");\n+            ((LocalVariableTable) attribute).forEach(var -> {\n+                final int sigIdx = var.getSignatureIndex();\n+                String signature = constantPool.getConstantUtf8(sigIdx).getBytes();\n+                signature = Utility.signatureToString(signature, false);\n+                final int start = var.getStartPC();\n+                final int end = start + var.getLength();\n+                printWriter.println(\"<LI>\" + Class2HTML.referenceType(signature) + \"&nbsp;<B>\" + var.getName() + \"<\/B> in slot %\" + var.getIndex()\n+                    + \"<BR>Valid from lines \" + \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + start + \"\\\" TARGET=Code>\" + start\n+                    + \"<\/A> to \" + \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + end + \"\\\" TARGET=Code>\" + end + \"<\/A><\/LI>\");\n+            });\n+            printWriter.print(\"<\/UL>\\n\");\n+            break;\n+        case Const.ATTR_INNER_CLASSES:\n+            \/\/ List inner classes\n+            printWriter.print(\"<UL>\");\n+            for (final InnerClass clazz : ((InnerClasses) attribute).getInnerClasses()) {\n+                final String name;\n+                final String access;\n+                index = clazz.getInnerNameIndex();\n+                if (index > 0) {\n+                    name = constantPool.getConstantUtf8(index).getBytes();\n+                } else {\n+                    name = \"&lt;anonymous&gt;\";\n@@ -208,4 +183,8 @@\n-                file.print(\"<\/UL>\\n\");\n-                break;\n-            default: \/\/ Such as Unknown attribute or Deprecated\n-                file.print(\"<P>\" + attribute);\n+                access = Utility.accessToString(clazz.getInnerAccessFlags());\n+                printWriter.print(\"<LI><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT> \" + constantHtml.referenceConstant(clazz.getInnerClassIndex())\n+                    + \" in&nbsp;class \" + constantHtml.referenceConstant(clazz.getOuterClassIndex()) + \" named \" + name + \"<\/LI>\\n\");\n+            }\n+            printWriter.print(\"<\/UL>\\n\");\n+            break;\n+        default: \/\/ Such as Unknown attribute or Deprecated\n+            printWriter.print(\"<P>\" + attribute);\n@@ -213,2 +192,2 @@\n-        file.println(\"<\/TD><\/TR>\");\n-        file.flush();\n+        printWriter.println(\"<\/TD><\/TR>\");\n+        printWriter.flush();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/AttributeHTML.java","additions":125,"deletions":146,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-    boolean equals( Object THIS, Object THAT );\n-\n+    boolean equals(Object THIS, Object THAT);\n@@ -47,1 +46,1 @@\n-    int hashCode( Object THIS );\n+    int hashCode(Object THIS);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELComparator.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,2 +63,1 @@\n- * Factory creates il.append() statements, and sets instruction targets.\n- * A helper class for BCELifier.\n+ * Factory creates il.append() statements, and sets instruction targets. A helper class for BCELifier.\n@@ -67,1 +66,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -71,4 +70,4 @@\n-    private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+\".\";\n-    private final MethodGen _mg;\n-    private final PrintWriter _out;\n-    private final ConstantPoolGen _cp;\n+    private static final String CONSTANT_PREFIX = Const.class.getSimpleName() + \".\";\n+    private final MethodGen methodGen;\n+    private final PrintWriter printWriter;\n+    private final ConstantPoolGen constantPoolGen;\n@@ -76,0 +75,4 @@\n+    private final Map<Instruction, InstructionHandle> branchMap = new HashMap<>();\n+\n+    \/\/ Memorize BranchInstructions that need an update\n+    private final List<BranchInstruction> branches = new ArrayList<>();\n@@ -78,3 +81,3 @@\n-        _mg = mg;\n-        _cp = mg.getConstantPool();\n-        _out = out;\n+        methodGen = mg;\n+        constantPoolGen = mg.getConstantPool();\n+        printWriter = out;\n@@ -83,1 +86,37 @@\n-    private final Map<Instruction, InstructionHandle> branch_map = new HashMap<>();\n+    private void createConstant(final Object value) {\n+        String embed = value.toString();\n+        if (value instanceof String) {\n+            embed = '\"' + Utility.convertString(embed) + '\"';\n+        } else if (value instanceof Character) {\n+            embed = \"(char)0x\" + Integer.toHexString(((Character) value).charValue());\n+        } else if (value instanceof Float) {\n+            final Float f = (Float) value;\n+            if (Float.isNaN(f)) {\n+                embed = \"Float.NaN\";\n+            } else if (f == Float.POSITIVE_INFINITY) {\n+                embed = \"Float.POSITIVE_INFINITY\";\n+            } else if (f == Float.NEGATIVE_INFINITY) {\n+                embed = \"Float.NEGATIVE_INFINITY\";\n+            } else {\n+                embed += \"f\";\n+            }\n+        }  else if (value instanceof Double) {\n+            final Double d = (Double) value;\n+            if (Double.isNaN(d)) {\n+                embed = \"Double.NaN\";\n+            } else if (d == Double.POSITIVE_INFINITY) {\n+                embed = \"Double.POSITIVE_INFINITY\";\n+            } else if (d == Double.NEGATIVE_INFINITY) {\n+                embed = \"Double.NEGATIVE_INFINITY\";\n+            } else {\n+                embed += \"d\";\n+            }\n+        } else if (value instanceof Long) {\n+            embed += \"L\";\n+        } else if (value instanceof ObjectType) {\n+            final ObjectType ot = (ObjectType) value;\n+            embed = \"new ObjectType(\\\"\" + ot.getClassName() + \"\\\")\";\n+        } else if (value instanceof ArrayType) {\n+            final ArrayType at = (ArrayType) value;\n+            embed = \"new ArrayType(\" + BCELifier.printType(at.getBasicType()) + \", \" + at.getDimensions() + \")\";\n+        }\n@@ -85,0 +124,2 @@\n+        printWriter.println(\"il.append(new PUSH(_cp, \" + embed + \"));\");\n+    }\n@@ -87,3 +128,2 @@\n-        if (!_mg.isAbstract() && !_mg.isNative()) {\n-            for (InstructionHandle ih = _mg.getInstructionList().getStart(); ih != null; ih = ih\n-                    .getNext()) {\n+        if (!methodGen.isAbstract() && !methodGen.isNative()) {\n+            for (InstructionHandle ih = methodGen.getInstructionList().getStart(); ih != null; ih = ih.getNext()) {\n@@ -92,1 +132,1 @@\n-                    branch_map.put(i, ih); \/\/ memorize container\n+                    branchMap.put(i, ih); \/\/ memorize container\n@@ -96,1 +136,1 @@\n-                        _out.println(\"    InstructionHandle ih_\" + ih.getPosition() + \";\");\n+                        printWriter.println(\"    InstructionHandle ih_\" + ih.getPosition() + \";\");\n@@ -98,1 +138,1 @@\n-                        _out.print(\"    InstructionHandle ih_\" + ih.getPosition() + \" = \");\n+                        printWriter.print(\"    InstructionHandle ih_\" + ih.getPosition() + \" = \");\n@@ -101,1 +141,1 @@\n-                    _out.print(\"    \");\n+                    printWriter.print(\"    \");\n@@ -112,10 +152,15 @@\n-\n-    private boolean visitInstruction( final Instruction i ) {\n-        final short opcode = i.getOpcode();\n-        if ((InstructionConst.getInstruction(opcode) != null)\n-                && !(i instanceof ConstantPushInstruction) && !(i instanceof ReturnInstruction)) { \/\/ Handled below\n-            _out.println(\"il.append(InstructionConst.\"\n-                    + i.getName().toUpperCase(Locale.ENGLISH) + \");\");\n-            return true;\n-        }\n-        return false;\n+    private void updateBranchTargets() {\n+        branches.forEach(bi -> {\n+            final BranchHandle bh = (BranchHandle) branchMap.get(bi);\n+            final int pos = bh.getPosition();\n+            final String name = bi.getName() + \"_\" + pos;\n+            int targetPos = bh.getTarget().getPosition();\n+            printWriter.println(\"    \" + name + \".setTarget(ih_\" + targetPos + \");\");\n+            if (bi instanceof Select) {\n+                final InstructionHandle[] ihs = ((Select) bi).getTargets();\n+                for (int j = 0; j < ihs.length; j++) {\n+                    targetPos = ihs[j].getPosition();\n+                    printWriter.println(\"    \" + name + \".setTarget(\" + j + \", ih_\" + targetPos + \");\");\n+                }\n+            }\n+        });\n@@ -124,12 +169,6 @@\n-\n-    @Override\n-    public void visitLocalVariableInstruction( final LocalVariableInstruction i ) {\n-        final short opcode = i.getOpcode();\n-        final Type type = i.getType(_cp);\n-        if (opcode == Const.IINC) {\n-            _out.println(\"il.append(new IINC(\" + i.getIndex() + \", \" + ((IINC) i).getIncrement()\n-                    + \"));\");\n-        } else {\n-            final String kind = (opcode < Const.ISTORE) ? \"Load\" : \"Store\";\n-            _out.println(\"il.append(_factory.create\" + kind + \"(\" + BCELifier.printType(type)\n-                    + \", \" + i.getIndex() + \"));\");\n+    private void updateExceptionHandlers() {\n+        final CodeExceptionGen[] handlers = methodGen.getExceptionHandlers();\n+        for (final CodeExceptionGen h : handlers) {\n+            final String type = h.getCatchType() == null ? \"null\" : BCELifier.printType(h.getCatchType());\n+            printWriter.println(\"    method.addExceptionHandler(\" + \"ih_\" + h.getStartPC().getPosition() + \", \" + \"ih_\" + h.getEndPC().getPosition() + \", \"\n+                + \"ih_\" + h.getHandlerPC().getPosition() + \", \" + type + \");\");\n@@ -139,37 +178,0 @@\n-\n-    @Override\n-    public void visitArrayInstruction( final ArrayInstruction i ) {\n-        final short opcode = i.getOpcode();\n-        final Type type = i.getType(_cp);\n-        final String kind = (opcode < Const.IASTORE) ? \"Load\" : \"Store\";\n-        _out.println(\"il.append(_factory.createArray\" + kind + \"(\" + BCELifier.printType(type)\n-                + \"));\");\n-    }\n-\n-\n-    @Override\n-    public void visitFieldInstruction( final FieldInstruction i ) {\n-        final short opcode = i.getOpcode();\n-        final String class_name = i.getReferenceType(_cp).getSignature();\n-        final String field_name = i.getFieldName(_cp);\n-        final Type type = i.getFieldType(_cp);\n-        _out.println(\"il.append(_factory.createFieldAccess(\\\"\" + class_name + \"\\\", \\\"\" + field_name\n-                + \"\\\", \" + BCELifier.printType(type) + \", \" + CONSTANT_PREFIX\n-                + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n-    }\n-\n-\n-    @Override\n-    public void visitInvokeInstruction( final InvokeInstruction i ) {\n-        final short opcode = i.getOpcode();\n-        final String class_name = i.getReferenceType(_cp).getSignature();\n-        final String method_name = i.getMethodName(_cp);\n-        final Type type = i.getReturnType(_cp);\n-        final Type[] arg_types = i.getArgumentTypes(_cp);\n-        _out.println(\"il.append(_factory.createInvoke(\\\"\" + class_name + \"\\\", \\\"\" + method_name\n-                + \"\\\", \" + BCELifier.printType(type) + \", \"\n-                + BCELifier.printArgumentTypes(arg_types) + \", \" + CONSTANT_PREFIX\n-                + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n-    }\n-\n-\n@@ -178,1 +180,1 @@\n-    public void visitAllocationInstruction( final AllocationInstruction i ) {\n+    public void visitAllocationInstruction(final AllocationInstruction i) {\n@@ -181,1 +183,1 @@\n-            type = ((CPInstruction) i).getType(_cp);\n+            type = ((CPInstruction) i).getType(constantPoolGen);\n@@ -188,34 +190,16 @@\n-            case Const.NEW:\n-                _out.println(\"il.append(_factory.createNew(\\\"\" + ((ObjectType) type).getClassName()\n-                        + \"\\\"));\");\n-                break;\n-            case Const.MULTIANEWARRAY:\n-                dim = ((MULTIANEWARRAY) i).getDimensions();\n-                \/\/$FALL-THROUGH$\n-            case Const.ANEWARRAY:\n-            case Const.NEWARRAY:\n-                if (type instanceof ArrayType) {\n-                    type = ((ArrayType) type).getBasicType();\n-                }\n-                _out.println(\"il.append(_factory.createNewArray(\" + BCELifier.printType(type)\n-                        + \", (short) \" + dim + \"));\");\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Unhandled opcode: \" + opcode);\n-        }\n-    }\n-\n-\n-    private void createConstant( final Object value ) {\n-        String embed = value.toString();\n-        if (value instanceof String) {\n-            embed = '\"' + Utility.convertString(embed) + '\"';\n-        } else if (value instanceof Character) {\n-            embed = \"(char)0x\" + Integer.toHexString(((Character) value).charValue());\n-        } else if (value instanceof Float) {\n-            embed += \"f\";\n-        } else if (value instanceof Long) {\n-            embed += \"L\";\n-        } else if (value instanceof ObjectType) {\n-            final ObjectType ot = (ObjectType) value;\n-            embed = \"new ObjectType(\\\"\"+ot.getClassName()+\"\\\")\";\n+        case Const.NEW:\n+            printWriter.println(\"il.append(_factory.createNew(\\\"\" + ((ObjectType) type).getClassName() + \"\\\"));\");\n+            break;\n+        case Const.MULTIANEWARRAY:\n+            dim = ((MULTIANEWARRAY) i).getDimensions();\n+            \/\/$FALL-THROUGH$\n+        case Const.NEWARRAY:\n+            if (type instanceof ArrayType) {\n+                type = ((ArrayType) type).getBasicType();\n+            }\n+            \/\/$FALL-THROUGH$\n+        case Const.ANEWARRAY:\n+            printWriter.println(\"il.append(_factory.createNewArray(\" + BCELifier.printType(type) + \", (short) \" + dim + \"));\");\n+            break;\n+        default:\n+            throw new IllegalArgumentException(\"Unhandled opcode: \" + opcode);\n@@ -223,14 +207,0 @@\n-\n-        _out.println(\"il.append(new PUSH(_cp, \" + embed + \"));\");\n-    }\n-\n-\n-    @Override\n-    public void visitLDC( final LDC i ) {\n-        createConstant(i.getValue(_cp));\n-    }\n-\n-\n-    @Override\n-    public void visitLDC2_W( final LDC2_W i ) {\n-        createConstant(i.getValue(_cp));\n@@ -239,1 +209,0 @@\n-\n@@ -241,16 +210,5 @@\n-    public void visitConstantPushInstruction( final ConstantPushInstruction i ) {\n-        createConstant(i.getValue());\n-    }\n-\n-\n-    @Override\n-    public void visitINSTANCEOF( final INSTANCEOF i ) {\n-        final Type type = i.getType(_cp);\n-        _out.println(\"il.append(new INSTANCEOF(_cp.addClass(\" + BCELifier.printType(type) + \")));\");\n-    }\n-\n-\n-    @Override\n-    public void visitCHECKCAST( final CHECKCAST i ) {\n-        final Type type = i.getType(_cp);\n-        _out.println(\"il.append(_factory.createCheckCast(\" + BCELifier.printType(type) + \"));\");\n+    public void visitArrayInstruction(final ArrayInstruction i) {\n+        final short opcode = i.getOpcode();\n+        final Type type = i.getType(constantPoolGen);\n+        final String kind = opcode < Const.IASTORE ? \"Load\" : \"Store\";\n+        printWriter.println(\"il.append(_factory.createArray\" + kind + \"(\" + BCELifier.printType(type) + \"));\");\n@@ -259,1 +217,0 @@\n-\n@@ -261,12 +218,2 @@\n-    public void visitReturnInstruction( final ReturnInstruction i ) {\n-        final Type type = i.getType(_cp);\n-        _out.println(\"il.append(_factory.createReturn(\" + BCELifier.printType(type) + \"));\");\n-    }\n-\n-    \/\/ Memorize BranchInstructions that need an update\n-    private final List<BranchInstruction> branches = new ArrayList<>();\n-\n-\n-    @Override\n-    public void visitBranchInstruction( final BranchInstruction bi ) {\n-        final BranchHandle bh = (BranchHandle) branch_map.get(bi);\n+    public void visitBranchInstruction(final BranchInstruction bi) {\n+        final BranchHandle bh = (BranchHandle) branchMap.get(bi);\n@@ -287,2 +234,1 @@\n-            _out.print(\"Select \" + name + \" = new \" + bi.getName().toUpperCase(Locale.ENGLISH)\n-                    + \"(\" + args + \", new InstructionHandle[] { \");\n+            printWriter.print(\"Select \" + name + \" = new \" + bi.getName().toUpperCase(Locale.ENGLISH) + \"(\" + args + \", new InstructionHandle[] { \");\n@@ -290,1 +236,1 @@\n-                _out.print(\"null\");\n+                printWriter.print(\"null\");\n@@ -292,1 +238,1 @@\n-                    _out.print(\", \");\n+                    printWriter.print(\", \");\n@@ -295,1 +241,1 @@\n-            _out.println(\" }, null);\");\n+            printWriter.println(\" }, null);\");\n@@ -297,1 +243,1 @@\n-            final int t_pos = bh.getTarget().getPosition();\n+            final int tPos = bh.getTarget().getPosition();\n@@ -299,2 +245,2 @@\n-            if (pos > t_pos) {\n-                target = \"ih_\" + t_pos;\n+            if (pos > tPos) {\n+                target = \"ih_\" + tPos;\n@@ -305,3 +251,2 @@\n-            _out.println(\"    BranchInstruction \" + name + \" = _factory.createBranchInstruction(\"\n-                    + CONSTANT_PREFIX + bi.getName().toUpperCase(Locale.ENGLISH) + \", \" + target\n-                    + \");\");\n+            printWriter.println(\"    BranchInstruction \" + name + \" = _factory.createBranchInstruction(\" + CONSTANT_PREFIX\n+                + bi.getName().toUpperCase(Locale.ENGLISH) + \", \" + target + \");\");\n@@ -310,1 +255,1 @@\n-            _out.println(\"    ih_\" + pos + \" = il.append(\" + name + \");\");\n+            printWriter.println(\"    ih_\" + pos + \" = il.append(\" + name + \");\");\n@@ -312,1 +257,1 @@\n-            _out.println(\"    il.append(\" + name + \");\");\n+            printWriter.println(\"    il.append(\" + name + \");\");\n@@ -316,0 +261,10 @@\n+    @Override\n+    public void visitCHECKCAST(final CHECKCAST i) {\n+        final Type type = i.getType(constantPoolGen);\n+        printWriter.println(\"il.append(_factory.createCheckCast(\" + BCELifier.printType(type) + \"));\");\n+    }\n+\n+    @Override\n+    public void visitConstantPushInstruction(final ConstantPushInstruction i) {\n+        createConstant(i.getValue());\n+    }\n@@ -318,2 +273,7 @@\n-    public void visitRET( final RET i ) {\n-        _out.println(\"il.append(new RET(\" + i.getIndex() + \")));\");\n+    public void visitFieldInstruction(final FieldInstruction i) {\n+        final short opcode = i.getOpcode();\n+        final String className = i.getReferenceType(constantPoolGen).getClassName();\n+        final String fieldName = i.getFieldName(constantPoolGen);\n+        final Type type = i.getFieldType(constantPoolGen);\n+        printWriter.println(\"il.append(_factory.createFieldAccess(\\\"\" + className + \"\\\", \\\"\" + fieldName + \"\\\", \" + BCELifier.printType(type) + \", \"\n+            + CONSTANT_PREFIX + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n@@ -322,0 +282,5 @@\n+    @Override\n+    public void visitINSTANCEOF(final INSTANCEOF i) {\n+        final Type type = i.getType(constantPoolGen);\n+        printWriter.println(\"il.append(_factory.createInstanceOf(\" + BCELifier.printType(type) + \"));\");\n+    }\n@@ -323,14 +288,5 @@\n-    private void updateBranchTargets() {\n-        for (final BranchInstruction bi : branches) {\n-            final BranchHandle bh = (BranchHandle) branch_map.get(bi);\n-            final int pos = bh.getPosition();\n-            final String name = bi.getName() + \"_\" + pos;\n-            int t_pos = bh.getTarget().getPosition();\n-            _out.println(\"    \" + name + \".setTarget(ih_\" + t_pos + \");\");\n-            if (bi instanceof Select) {\n-                final InstructionHandle[] ihs = ((Select) bi).getTargets();\n-                for (int j = 0; j < ihs.length; j++) {\n-                    t_pos = ihs[j].getPosition();\n-                    _out.println(\"    \" + name + \".setTarget(\" + j + \", ih_\" + t_pos + \");\");\n-                }\n-            }\n+    private boolean visitInstruction(final Instruction i) {\n+        final short opcode = i.getOpcode();\n+        if (InstructionConst.getInstruction(opcode) != null && !(i instanceof ConstantPushInstruction) && !(i instanceof ReturnInstruction)) { \/\/ Handled below\n+            printWriter.println(\"il.append(InstructionConst.\" + i.getName().toUpperCase(Locale.ENGLISH) + \");\");\n+            return true;\n@@ -338,0 +294,1 @@\n+        return false;\n@@ -340,0 +297,10 @@\n+    @Override\n+    public void visitInvokeInstruction(final InvokeInstruction i) {\n+        final short opcode = i.getOpcode();\n+        final String className = i.getReferenceType(constantPoolGen).getClassName();\n+        final String methodName = i.getMethodName(constantPoolGen);\n+        final Type type = i.getReturnType(constantPoolGen);\n+        final Type[] argTypes = i.getArgumentTypes(constantPoolGen);\n+        printWriter.println(\"il.append(_factory.createInvoke(\\\"\" + className + \"\\\", \\\"\" + methodName + \"\\\", \" + BCELifier.printType(type) + \", \"\n+            + BCELifier.printArgumentTypes(argTypes) + \", \" + CONSTANT_PREFIX + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n+    }\n@@ -341,8 +308,19 @@\n-    private void updateExceptionHandlers() {\n-        final CodeExceptionGen[] handlers = _mg.getExceptionHandlers();\n-        for (final CodeExceptionGen h : handlers) {\n-            final String type = (h.getCatchType() == null) ? \"null\" : BCELifier.printType(h\n-                    .getCatchType());\n-            _out.println(\"    method.addExceptionHandler(\" + \"ih_\" + h.getStartPC().getPosition()\n-                    + \", \" + \"ih_\" + h.getEndPC().getPosition() + \", \" + \"ih_\"\n-                    + h.getHandlerPC().getPosition() + \", \" + type + \");\");\n+    @Override\n+    public void visitLDC(final LDC i) {\n+        createConstant(i.getValue(constantPoolGen));\n+    }\n+\n+    @Override\n+    public void visitLDC2_W(final LDC2_W i) {\n+        createConstant(i.getValue(constantPoolGen));\n+    }\n+\n+    @Override\n+    public void visitLocalVariableInstruction(final LocalVariableInstruction i) {\n+        final short opcode = i.getOpcode();\n+        final Type type = i.getType(constantPoolGen);\n+        if (opcode == Const.IINC) {\n+            printWriter.println(\"il.append(new IINC(\" + i.getIndex() + \", \" + ((IINC) i).getIncrement() + \"));\");\n+        } else {\n+            final String kind = opcode < Const.ISTORE ? \"Load\" : \"Store\";\n+            printWriter.println(\"il.append(_factory.create\" + kind + \"(\" + BCELifier.printType(type) + \", \" + i.getIndex() + \"));\");\n@@ -351,0 +329,11 @@\n+\n+    @Override\n+    public void visitRET(final RET i) {\n+        printWriter.println(\"il.append(new RET(\" + i.getIndex() + \"));\");\n+    }\n+\n+    @Override\n+    public void visitReturnInstruction(final ReturnInstruction i) {\n+        final Type type = i.getType(constantPoolGen);\n+        printWriter.println(\"il.append(_factory.createReturn(\" + BCELifier.printType(type) + \"));\");\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELFactory.java","additions":184,"deletions":195,"binary":false,"changes":379,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +25,1 @@\n+import java.io.OutputStreamWriter;\n@@ -27,0 +27,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -33,0 +34,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;\n@@ -43,5 +45,3 @@\n- * This class takes a given JavaClass object and converts it to a\n- * Java program that creates that very class using BCEL. This\n- * gives new users of BCEL a useful example showing how things\n- * are done with BCEL. It does not cover all features of BCEL,\n- * but tries to mimic hand-written code as close as possible.\n+ * This class takes a given JavaClass object and converts it to a Java program that creates that very class using BCEL.\n+ * This gives new users of BCEL a useful example showing how things are done with BCEL. It does not cover all features\n+ * of BCEL, but tries to mimic hand-written code as close as possible.\n@@ -49,0 +49,1 @@\n+ * @LastModified: Feb 2023\n@@ -56,3 +57,1 @@\n-        UNKNOWN,\n-        CLASS,\n-        METHOD,\n+        UNKNOWN, CLASS, METHOD,\n@@ -64,1 +63,1 @@\n-    private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+\".\";\n+    private static final String CONSTANT_PREFIX = Const.class.getSimpleName() + \".\";\n@@ -66,11 +65,7 @@\n-    private final JavaClass _clazz;\n-    private final PrintWriter _out;\n-    private final ConstantPoolGen _cp;\n-\n-    \/** @param clazz Java class to \"decompile\"\n-     * @param out where to output Java program\n-     *\/\n-    public BCELifier(final JavaClass clazz, final OutputStream out) {\n-        _clazz = clazz;\n-        _out = new PrintWriter(out);\n-        _cp = new ConstantPoolGen(_clazz.getConstantPool());\n+    \/\/ Needs to be accessible from unit test code\n+    static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {\n+        JavaClass javaClass;\n+        if ((javaClass = Repository.lookupClass(name)) == null) {\n+            javaClass = new ClassParser(name).parse(); \/\/ May throw IOException\n+        }\n+        return javaClass;\n@@ -79,2 +74,2 @@\n-\n-    \/** Start Java code generation\n+    \/**\n+     * Default main method\n@@ -82,57 +77,5 @@\n-    public void start() {\n-        visitJavaClass(_clazz);\n-        _out.flush();\n-    }\n-\n-\n-    @Override\n-    public void visitJavaClass( final JavaClass clazz ) {\n-        String class_name = clazz.getClassName();\n-        final String super_name = clazz.getSuperclassName();\n-        final String package_name = clazz.getPackageName();\n-        final String inter = Utility.printArray(clazz.getInterfaceNames(), false, true);\n-        if (!\"\".equals(package_name)) {\n-            class_name = class_name.substring(package_name.length() + 1);\n-            _out.println(\"package \" + package_name + \";\");\n-            _out.println();\n-        }\n-        _out.println(\"import \" + BASE_PACKAGE + \".generic.*;\");\n-        _out.println(\"import \" + BASE_PACKAGE + \".classfile.*;\");\n-        _out.println(\"import \" + BASE_PACKAGE + \".*;\");\n-        _out.println(\"import java.io.*;\");\n-        _out.println();\n-        _out.println(\"public class \" + class_name + \"Creator {\");\n-        _out.println(\"  private InstructionFactory _factory;\");\n-        _out.println(\"  private ConstantPoolGen    _cp;\");\n-        _out.println(\"  private ClassGen           _cg;\");\n-        _out.println();\n-        _out.println(\"  public \" + class_name + \"Creator() {\");\n-        _out.println(\"    _cg = new ClassGen(\\\"\"\n-                + ((\"\".equals(package_name)) ? class_name : package_name + \".\" + class_name)\n-                + \"\\\", \\\"\" + super_name + \"\\\", \" + \"\\\"\" + clazz.getSourceFileName() + \"\\\", \"\n-                + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + \", \"\n-                + \"new String[] { \" + inter + \" });\");\n-        _out.println(\"    _cg.setMajor(\" + clazz.getMajor() +\");\");\n-        _out.println(\"    _cg.setMinor(\" + clazz.getMinor() +\");\");\n-        _out.println();\n-        _out.println(\"    _cp = _cg.getConstantPool();\");\n-        _out.println(\"    _factory = new InstructionFactory(_cg, _cp);\");\n-        _out.println(\"  }\");\n-        _out.println();\n-        printCreate();\n-        final Field[] fields = clazz.getFields();\n-        if (fields.length > 0) {\n-            _out.println(\"  private void createFields() {\");\n-            _out.println(\"    FieldGen field;\");\n-            for (final Field field : fields) {\n-                field.accept(this);\n-            }\n-            _out.println(\"  }\");\n-            _out.println();\n-        }\n-        final Method[] methods = clazz.getMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            _out.println(\"  private void createMethod_\" + i + \"() {\");\n-            methods[i].accept(this);\n-            _out.println(\"  }\");\n-            _out.println();\n+    public static void _main(final String[] argv) throws Exception {\n+        if (argv.length != 1) {\n+            System.out.println(\"Usage: BCELifier className\");\n+            System.out.println(\"\\tThe class must exist on the classpath\");\n+            return;\n@@ -140,2 +83,2 @@\n-        printMain();\n-        _out.println(\"}\");\n+        final BCELifier bcelifier = new BCELifier(getJavaClass(argv[0]), System.out);\n+        bcelifier.start();\n@@ -144,10 +87,3 @@\n-\n-    private void printCreate() {\n-        _out.println(\"  public void create(OutputStream out) throws IOException {\");\n-        final Field[] fields = _clazz.getFields();\n-        if (fields.length > 0) {\n-            _out.println(\"    createFields();\");\n-        }\n-        final Method[] methods = _clazz.getMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            _out.println(\"    createMethod_\" + i + \"();\");\n+    static String printArgumentTypes(final Type[] argTypes) {\n+        if (argTypes.length == 0) {\n+            return \"Type.NO_ARGS\";\n@@ -155,24 +91,6 @@\n-        _out.println(\"    _cg.getJavaClass().dump(out);\");\n-        _out.println(\"  }\");\n-        _out.println();\n-    }\n-\n-\n-    private void printMain() {\n-        final String class_name = _clazz.getClassName();\n-        _out.println(\"  public static void main(String[] args) throws Exception {\");\n-        _out.println(\"    \" + class_name + \"Creator creator = new \" + class_name + \"Creator();\");\n-        _out.println(\"    creator.create(new FileOutputStream(\\\"\" + class_name + \".class\\\"));\");\n-        _out.println(\"  }\");\n-    }\n-\n-\n-    @Override\n-    public void visitField( final Field field ) {\n-        _out.println();\n-        _out.println(\"    field = new FieldGen(\" + printFlags(field.getAccessFlags()) + \", \"\n-                + printType(field.getSignature()) + \", \\\"\" + field.getName() + \"\\\", _cp);\");\n-        final ConstantValue cv = field.getConstantValue();\n-        if (cv != null) {\n-            final String value = cv.toString();\n-            _out.println(\"    field.setInitValue(\" + value + \")\");\n+        final StringBuilder args = new StringBuilder();\n+        for (int i = 0; i < argTypes.length; i++) {\n+            args.append(printType(argTypes[i]));\n+            if (i < argTypes.length - 1) {\n+                args.append(\", \");\n+            }\n@@ -180,21 +98,1 @@\n-        _out.println(\"    _cg.addField(field.getField());\");\n-    }\n-\n-\n-    @Override\n-    public void visitMethod( final Method method ) {\n-        final MethodGen mg = new MethodGen(method, _clazz.getClassName(), _cp);\n-        _out.println(\"    InstructionList il = new InstructionList();\");\n-        _out.println(\"    MethodGen method = new MethodGen(\"\n-                + printFlags(method.getAccessFlags(), FLAGS.METHOD) + \", \"\n-                + printType(mg.getReturnType()) + \", \"\n-                + printArgumentTypes(mg.getArgumentTypes()) + \", \"\n-                + \"new String[] { \" + Utility.printArray(mg.getArgumentNames(), false, true)\n-                + \" }, \\\"\" + method.getName() + \"\\\", \\\"\" + _clazz.getClassName() + \"\\\", il, _cp);\");\n-        _out.println();\n-        final BCELFactory factory = new BCELFactory(mg, _out);\n-        factory.start();\n-        _out.println(\"    method.setMaxStack();\");\n-        _out.println(\"    method.setMaxLocals();\");\n-        _out.println(\"    _cg.addMethod(method.getMethod());\");\n-        _out.println(\"    il.dispose();\");\n+        return \"new Type[] { \" + args.toString() + \" }\";\n@@ -203,2 +101,1 @@\n-\n-    static String printFlags( final int flags ) {\n+    static String printFlags(final int flags) {\n@@ -210,0 +107,1 @@\n+     *\n@@ -215,1 +113,1 @@\n-    public static String printFlags( final int flags, final FLAGS location ) {\n+    public static String printFlags(final int flags, final FLAGS location) {\n@@ -222,6 +120,8 @@\n-                if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {\n-                    buf.append(CONSTANT_PREFIX+\"ACC_SUPER | \");\n-                } else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {\n-                    buf.append(CONSTANT_PREFIX+\"ACC_BRIDGE | \");\n-                } else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {\n-                    buf.append(CONSTANT_PREFIX+\"ACC_VARARGS | \");\n+                if (pow == Const.ACC_SYNCHRONIZED && location == FLAGS.CLASS) {\n+                    buf.append(CONSTANT_PREFIX).append(\"ACC_SUPER | \");\n+                } else if (pow == Const.ACC_VOLATILE && location == FLAGS.METHOD) {\n+                    buf.append(CONSTANT_PREFIX).append(\"ACC_BRIDGE | \");\n+                } else if (pow == Const.ACC_TRANSIENT && location == FLAGS.METHOD) {\n+                    buf.append(CONSTANT_PREFIX).append(\"ACC_VARARGS | \");\n+                } else if (i < Const.ACCESS_NAMES_LENGTH) {\n+                    buf.append(CONSTANT_PREFIX).append(\"ACC_\").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append(\" | \");\n@@ -229,7 +129,1 @@\n-                    if (i < Const.ACCESS_NAMES_LENGTH) {\n-                        buf.append(CONSTANT_PREFIX+\"ACC_\")\n-                                .append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH))\n-                                .append( \" | \");\n-                    } else {\n-                        buf.append(String.format (CONSTANT_PREFIX+\"ACC_BIT %x | \", pow));\n-                    }\n+                    buf.append(String.format(CONSTANT_PREFIX + \"ACC_BIT %x | \", pow));\n@@ -244,22 +138,1 @@\n-\n-    static String printArgumentTypes( final Type[] arg_types ) {\n-        if (arg_types.length == 0) {\n-            return \"Type.NO_ARGS\";\n-        }\n-        final StringBuilder args = new StringBuilder();\n-        for (int i = 0; i < arg_types.length; i++) {\n-            args.append(printType(arg_types[i]));\n-            if (i < arg_types.length - 1) {\n-                args.append(\", \");\n-            }\n-        }\n-        return \"new Type[] { \" + args.toString() + \" }\";\n-    }\n-\n-\n-    static String printType( final Type type ) {\n-        return printType(type.getSignature());\n-    }\n-\n-\n-    static String printType( final String signature ) {\n+    static String printType(final String signature) {\n@@ -270,1 +143,2 @@\n-        } else if (type.toString().equals(\"java.lang.String\")) {\n+        }\n+        if (type.toString().equals(\"java.lang.String\")) {\n@@ -272,1 +146,2 @@\n-        } else if (type.toString().equals(\"java.lang.Object\")) {\n+        }\n+        if (type.toString().equals(\"java.lang.Object\")) {\n@@ -274,1 +149,2 @@\n-        } else if (type.toString().equals(\"java.lang.StringBuffer\")) {\n+        }\n+        if (type.toString().equals(\"java.lang.StringBuffer\")) {\n@@ -276,1 +152,2 @@\n-        } else if (type instanceof ArrayType) {\n+        }\n+        if (type instanceof ArrayType) {\n@@ -278,4 +155,1 @@\n-            return \"new ArrayType(\" + printType(at.getBasicType()) + \", \" + at.getDimensions()\n-                    + \")\";\n-        } else {\n-            return \"new ObjectType(\\\"\" + Utility.signatureToString(signature, false) + \"\\\")\";\n+            return \"new ArrayType(\" + printType(at.getBasicType()) + \", \" + at.getDimensions() + \")\";\n@@ -283,0 +157,1 @@\n+        return \"new ObjectType(\\\"\" + Utility.signatureToString(signature, false) + \"\\\")\";\n@@ -285,0 +160,3 @@\n+    static String printType(final Type type) {\n+        return printType(type.getSignature());\n+    }\n@@ -286,1 +164,11 @@\n-    \/** Default main method\n+    private final JavaClass clazz;\n+\n+    private final PrintWriter printWriter;\n+\n+    private final ConstantPoolGen constantPoolGen;\n+\n+    \/**\n+     * Constructs a new instance.\n+     *\n+     * @param clazz Java class to \"decompile\".\n+     * @param out where to print the Java program in UTF-8.\n@@ -288,5 +176,11 @@\n-    public static void main( final String[] argv ) throws Exception {\n-        if (argv.length != 1) {\n-            System.out.println(\"Usage: BCELifier classname\");\n-            System.out.println(\"\\tThe class must exist on the classpath\");\n-            return;\n+    public BCELifier(final JavaClass clazz, final OutputStream out) {\n+        this.clazz = clazz;\n+        this.printWriter = new PrintWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8), false);\n+        this.constantPoolGen = new ConstantPoolGen(this.clazz.getConstantPool());\n+    }\n+\n+    private void printCreate() {\n+        printWriter.println(\"  public void create(OutputStream out) throws IOException {\");\n+        final Field[] fields = clazz.getFields();\n+        if (fields.length > 0) {\n+            printWriter.println(\"    createFields();\");\n@@ -294,3 +188,7 @@\n-        final JavaClass java_class = getJavaClass(argv[0]);\n-        final BCELifier bcelifier = new BCELifier(java_class, System.out);\n-        bcelifier.start();\n+        final Method[] methods = clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            printWriter.println(\"    createMethod_\" + i + \"();\");\n+        }\n+        printWriter.println(\"    _cg.getJavaClass().dump(out);\");\n+        printWriter.println(\"  }\");\n+        printWriter.println();\n@@ -299,0 +197,7 @@\n+    private void printMain() {\n+        final String className = clazz.getClassName();\n+        printWriter.println(\"  public static void main(String[] args) throws Exception {\");\n+        printWriter.println(\"    \" + className + \"Creator creator = new \" + className + \"Creator();\");\n+        printWriter.println(\"    creator.create(new FileOutputStream(\\\"\" + className + \".class\\\"));\");\n+        printWriter.println(\"  }\");\n+    }\n@@ -300,5 +205,50 @@\n-    \/\/ Needs to be accessible from unit test code\n-    static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {\n-        JavaClass java_class;\n-        if ((java_class = Repository.lookupClass(name)) == null) {\n-            java_class = new ClassParser(name).parse(); \/\/ May throw IOException\n+    \/**\n+     * Start Java code generation\n+     *\/\n+    public void start() {\n+        visitJavaClass(clazz);\n+        printWriter.flush();\n+    }\n+\n+    @Override\n+    public void visitField(final Field field) {\n+        printWriter.println();\n+        printWriter.println(\n+            \"    field = new FieldGen(\" + printFlags(field.getAccessFlags()) + \", \" + printType(field.getSignature()) + \", \\\"\" + field.getName() + \"\\\", _cp);\");\n+        final ConstantValue cv = field.getConstantValue();\n+        if (cv != null) {\n+            printWriter.print(\"    field.setInitValue(\");\n+            if (field.getType() == Type.CHAR) {\n+                printWriter.print(\"(char)\");\n+            }\n+            if (field.getType() == Type.SHORT) {\n+                printWriter.print(\"(short)\");\n+            }\n+            if (field.getType() == Type.BYTE) {\n+                printWriter.print(\"(byte)\");\n+            }\n+            printWriter.print(cv);\n+            if (field.getType() == Type.LONG) {\n+                printWriter.print(\"L\");\n+            }\n+            if (field.getType() == Type.FLOAT) {\n+                printWriter.print(\"F\");\n+            }\n+            if (field.getType() == Type.DOUBLE) {\n+                printWriter.print(\"D\");\n+            }\n+            printWriter.println(\");\");\n+        }\n+        printWriter.println(\"    _cg.addField(field.getField());\");\n+    }\n+\n+    @Override\n+    public void visitJavaClass(final JavaClass clazz) {\n+        String className = clazz.getClassName();\n+        final String superName = clazz.getSuperclassName();\n+        final String packageName = clazz.getPackageName();\n+        final String inter = Utility.printArray(clazz.getInterfaceNames(), false, true);\n+        if (packageName != null && !packageName.trim().isEmpty()) {\n+            className = className.substring(packageName.length() + 1);\n+            printWriter.println(\"package \" + packageName + \";\");\n+            printWriter.println();\n@@ -306,1 +256,65 @@\n-        return java_class;\n+        printWriter.println(\"import \" + BASE_PACKAGE + \".generic.*;\");\n+        printWriter.println(\"import \" + BASE_PACKAGE + \".classfile.*;\");\n+        printWriter.println(\"import \" + BASE_PACKAGE + \".*;\");\n+        printWriter.println(\"import java.io.*;\");\n+        printWriter.println();\n+        printWriter.println(\"public class \" + className + \"Creator {\");\n+        printWriter.println(\"  private InstructionFactory _factory;\");\n+        printWriter.println(\"  private ConstantPoolGen    _cp;\");\n+        printWriter.println(\"  private ClassGen           _cg;\");\n+        printWriter.println();\n+        printWriter.println(\"  public \" + className + \"Creator() {\");\n+        printWriter.println(\"    _cg = new ClassGen(\\\"\" + (packageName.isEmpty() ? className : packageName + \".\" + className) + \"\\\", \\\"\" + superName\n+            + \"\\\", \" + \"\\\"\" + clazz.getSourceFileName() + \"\\\", \" + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + \", \" + \"new String[] { \" + inter + \" });\");\n+        printWriter.println(\"    _cg.setMajor(\" + clazz.getMajor() + \");\");\n+        printWriter.println(\"    _cg.setMinor(\" + clazz.getMinor() + \");\");\n+        printWriter.println();\n+        printWriter.println(\"    _cp = _cg.getConstantPool();\");\n+        printWriter.println(\"    _factory = new InstructionFactory(_cg, _cp);\");\n+        printWriter.println(\"  }\");\n+        printWriter.println();\n+        printCreate();\n+        final Field[] fields = clazz.getFields();\n+        if (fields.length > 0) {\n+            printWriter.println(\"  private void createFields() {\");\n+            printWriter.println(\"    FieldGen field;\");\n+            for (final Field field : fields) {\n+                field.accept(this);\n+            }\n+            printWriter.println(\"  }\");\n+            printWriter.println();\n+        }\n+        final Method[] methods = clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            printWriter.println(\"  private void createMethod_\" + i + \"() {\");\n+            methods[i].accept(this);\n+            printWriter.println(\"  }\");\n+            printWriter.println();\n+        }\n+        printMain();\n+        printWriter.println(\"}\");\n+    }\n+\n+    @Override\n+    public void visitMethod(final Method method) {\n+        final MethodGen mg = new MethodGen(method, clazz.getClassName(), constantPoolGen);\n+        printWriter.println(\"    InstructionList il = new InstructionList();\");\n+        printWriter.println(\"    MethodGen method = new MethodGen(\" + printFlags(method.getAccessFlags(), FLAGS.METHOD) + \", \" + printType(mg.getReturnType())\n+            + \", \" + printArgumentTypes(mg.getArgumentTypes()) + \", \" + \"new String[] { \" + Utility.printArray(mg.getArgumentNames(), false, true) + \" }, \\\"\"\n+            + method.getName() + \"\\\", \\\"\" + clazz.getClassName() + \"\\\", il, _cp);\");\n+        final ExceptionTable exceptionTable = method.getExceptionTable();\n+        if (exceptionTable != null) {\n+            final String[] exceptionNames = exceptionTable.getExceptionNames();\n+            for (final String exceptionName : exceptionNames) {\n+                printWriter.print(\"    method.addException(\\\"\");\n+                printWriter.print(exceptionName);\n+                printWriter.println(\"\\\");\");\n+            }\n+        }\n+        printWriter.println();\n+        final BCELFactory factory = new BCELFactory(mg, printWriter);\n+        factory.start();\n+        printWriter.println(\"    method.setMaxStack();\");\n+        printWriter.println(\"    method.setMaxLocals();\");\n+        printWriter.println(\"    _cg.addMethod(method.getMethod());\");\n+        printWriter.println(\"    il.dispose();\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELifier.java","additions":213,"deletions":199,"binary":false,"changes":412,"status":"modified"},{"patch":"@@ -28,4 +28,2 @@\n- * Utility class that implements a sequence of bytes which can be read\n- * via the `readByte()' method. This is used to implement a wrapper for the\n- * Java byte code stream to gain some more readability.\n- *\n+ * Utility class that implements a sequence of bytes which can be read via the 'readByte()' method. This is used to\n+ * implement a wrapper for the Java byte code stream to gain some more readability.\n@@ -35,18 +33,0 @@\n-    private final ByteArrayStream byteStream;\n-\n-\n-    public ByteSequence(final byte[] bytes) {\n-        super(new ByteArrayStream(bytes));\n-        byteStream = (ByteArrayStream) in;\n-    }\n-\n-\n-    public int getIndex() {\n-        return byteStream.getPosition();\n-    }\n-\n-\n-    void unreadByte() {\n-        byteStream.unreadByte();\n-    }\n-\n@@ -70,0 +50,15 @@\n+\n+    private final ByteArrayStream byteStream;\n+\n+    public ByteSequence(final byte[] bytes) {\n+        super(new ByteArrayStream(bytes));\n+        byteStream = (ByteArrayStream) in;\n+    }\n+\n+    public int getIndex() {\n+        return byteStream.getPosition();\n+    }\n+\n+    void unreadByte() {\n+        byteStream.unreadByte();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ByteSequence.java","additions":17,"deletions":22,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-import java.io.FileOutputStream;\n+import java.io.FileNotFoundException;\n@@ -26,0 +26,3 @@\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n@@ -40,2 +43,1 @@\n- * Given a JavaClass object \"class\" that is in package \"package\" five files\n- * will be created in the specified directory.\n+ * Given a JavaClass object \"class\" that is in package \"package\" five files will be created in the specified directory.\n@@ -44,6 +46,5 @@\n- * <LI> \"package\".\"class\".html as the main file which defines the frames for\n- * the following subfiles.\n- * <LI>  \"package\".\"class\"_attributes.html contains all (known) attributes found in the file\n- * <LI>  \"package\".\"class\"_cp.html contains the constant pool\n- * <LI>  \"package\".\"class\"_code.html contains the byte code\n- * <LI>  \"package\".\"class\"_methods.html contains references to all methods and fields of the class\n+ * <LI>\"package\".\"class\".html as the main file which defines the frames for the following subfiles.\n+ * <LI>\"package\".\"class\"_attributes.html contains all (known) attributes found in the file\n+ * <LI>\"package\".\"class\"_cp.html contains the constant pool\n+ * <LI>\"package\".\"class\"_code.html contains the byte code\n+ * <LI>\"package\".\"class\"_methods.html contains references to all methods and fields of the class\n@@ -52,3 +53,2 @@\n- * All subfiles reference each other appropriately, e.g. clicking on a\n- * method in the Method's frame will jump to the appropriate method in\n- * the Code frame.\n+ * All subfiles reference each other appropriately, e.g. clicking on a method in the Method's frame will jump to the\n+ * appropriate method in the Code frame.\n@@ -56,1 +56,1 @@\n- * @LastModified: Jan 2020\n+ * @LastModified: Feb 2023\n@@ -60,7 +60,4 @@\n-    private final JavaClass java_class; \/\/ current class object\n-    private final String dir;\n-    private static String class_package; \/\/ name of package, unclean to make it static, but ...\n-    private static String class_name; \/\/ name of current class, dito\n-    private static ConstantPool constant_pool;\n-    private static final Set<String> basic_types = new HashSet<>();\n-\n+    private static String classPackage; \/\/ name of package, unclean to make it static, but ...\n+    private static String className; \/\/ name of current class, dito\n+    private static ConstantPool constantPool;\n+    private static final Set<String> basicTypes = new HashSet<>();\n@@ -68,9 +65,9 @@\n-        basic_types.add(\"int\");\n-        basic_types.add(\"short\");\n-        basic_types.add(\"boolean\");\n-        basic_types.add(\"void\");\n-        basic_types.add(\"char\");\n-        basic_types.add(\"byte\");\n-        basic_types.add(\"long\");\n-        basic_types.add(\"double\");\n-        basic_types.add(\"float\");\n+        basicTypes.add(\"int\");\n+        basicTypes.add(\"short\");\n+        basicTypes.add(\"boolean\");\n+        basicTypes.add(\"void\");\n+        basicTypes.add(\"char\");\n+        basicTypes.add(\"byte\");\n+        basicTypes.add(\"long\");\n+        basicTypes.add(\"double\");\n+        basicTypes.add(\"float\");\n@@ -79,37 +76,2 @@\n-    \/**\n-     * Write contents of the given JavaClass into HTML files.\n-     *\n-     * @param java_class The class to write\n-     * @param dir The directory to put the files in\n-     *\/\n-    public Class2HTML(final JavaClass java_class, final String dir) throws IOException {\n-        final Method[] methods = java_class.getMethods();\n-        this.java_class = java_class;\n-        this.dir = dir;\n-        class_name = java_class.getClassName(); \/\/ Remember full name\n-        constant_pool = java_class.getConstantPool();\n-        \/\/ Get package name by tacking off everything after the last `.'\n-        final int index = class_name.lastIndexOf('.');\n-        if (index > -1) {\n-            class_package = class_name.substring(0, index);\n-        } else {\n-            class_package = \"\"; \/\/ default package\n-        }\n-        final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods,\n-                constant_pool);\n-        \/* Attributes can't be written in one step, so we just open a file\n-         * which will be written consequently.\n-         *\/\n-        final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool,\n-                constant_html);\n-        new MethodHTML(dir, class_name, methods, java_class.getFields(),\n-                constant_html, attribute_html);\n-        \/\/ Write main file (with frames, yuk)\n-        writeMainHTML(attribute_html);\n-        new CodeHTML(dir, class_name, methods, constant_pool, constant_html);\n-        attribute_html.close();\n-    }\n-\n-\n-    public static void main( final String[] argv ) throws IOException {\n-        final String[] file_name = new String[argv.length];\n+    public static void _main(final String[] argv) throws IOException {\n+        final String[] fileName = new String[argv.length];\n@@ -118,2 +80,2 @@\n-        JavaClass java_class = null;\n-        String zip_file = null;\n+        JavaClass javaClass = null;\n+        String zipFile = null;\n@@ -122,1 +84,2 @@\n-        \/* Parse command line arguments.\n+        \/*\n+         * Parse command line arguments.\n@@ -134,4 +97,2 @@\n-                        if (!created) {\n-                            if (!store.isDirectory()) {\n-                                System.out.println(\"Tried to create the directory \" + dir + \" but failed\");\n-                            }\n+                        if (!created && !store.isDirectory()) {\n+                            System.out.println(\"Tried to create the directory \" + dir + \" but failed\");\n@@ -141,1 +102,1 @@\n-                    zip_file = argv[++i];\n+                    zipFile = argv[++i];\n@@ -146,1 +107,1 @@\n-                file_name[files++] = argv[i];\n+                fileName[files++] = argv[i];\n@@ -153,3 +114,3 @@\n-                System.out.print(\"Processing \" + file_name[i] + \"...\");\n-                if (zip_file == null) {\n-                    parser = new ClassParser(file_name[i]); \/\/ Create parser object from file\n+                System.out.print(\"Processing \" + fileName[i] + \"...\");\n+                if (zipFile == null) {\n+                    parser = new ClassParser(fileName[i]); \/\/ Create parser object from file\n@@ -157,1 +118,1 @@\n-                    parser = new ClassParser(zip_file, file_name[i]); \/\/ Create parser object from zip file\n+                    parser = new ClassParser(zipFile, fileName[i]); \/\/ Create parser object from zip file\n@@ -159,2 +120,2 @@\n-                java_class = parser.parse();\n-                new Class2HTML(java_class, dir);\n+                javaClass = parser.parse();\n+                new Class2HTML(javaClass, dir);\n@@ -167,2 +128,1 @@\n-     * Utility method that converts a class reference in the constant pool,\n-     * i.e., an index to a string.\n+     * Utility method that converts a class reference in the constant pool, i.e., an index to a string.\n@@ -171,1 +131,1 @@\n-        String str = constant_pool.getConstantString(index, Const.CONSTANT_Class);\n+        String str = constantPool.getConstantString(index, Const.CONSTANT_Class);\n@@ -173,3 +133,2 @@\n-        str = Utility.compactClassName(str, class_package + \".\", true);\n-        return \"<A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + str\n-                + \"<\/A>\";\n+        str = Utility.compactClassName(str, classPackage + \".\", true);\n+        return \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + str + \"<\/A>\";\n@@ -178,4 +137,3 @@\n-\n-    static String referenceType( final String type ) {\n-        String short_type = Utility.compactClassName(type);\n-        short_type = Utility.compactClassName(short_type, class_package + \".\", true);\n+    static String referenceType(final String type) {\n+        String shortType = Utility.compactClassName(type);\n+        shortType = Utility.compactClassName(shortType, classPackage + \".\", true);\n@@ -183,1 +141,1 @@\n-        String base_type = type;\n+        String baseType = type;\n@@ -185,1 +143,1 @@\n-            base_type = type.substring(0, index); \/\/ Tack of the `['\n+            baseType = type.substring(0, index); \/\/ Tack of the '['\n@@ -188,1 +146,1 @@\n-        if (basic_types.contains(base_type)) {\n+        if (basicTypes.contains(baseType)) {\n@@ -191,1 +149,1 @@\n-        return \"<A HREF=\\\"\" + base_type + \".html\\\" TARGET=_top>\" + short_type + \"<\/A>\";\n+        return \"<A HREF=\\\"\" + baseType + \".html\\\" TARGET=_top>\" + shortType + \"<\/A>\";\n@@ -194,2 +152,1 @@\n-\n-    static String toHTML( final String str ) {\n+    static String toHTML(final String str) {\n@@ -200,14 +157,14 @@\n-                case '<':\n-                    buf.append(\"&lt;\");\n-                    break;\n-                case '>':\n-                    buf.append(\"&gt;\");\n-                    break;\n-                case '\\n':\n-                    buf.append(\"\\\\n\");\n-                    break;\n-                case '\\r':\n-                    buf.append(\"\\\\r\");\n-                    break;\n-                default:\n-                    buf.append(ch);\n+            case '<':\n+                buf.append(\"&lt;\");\n+                break;\n+            case '>':\n+                buf.append(\"&gt;\");\n+                break;\n+            case '\\n':\n+                buf.append(\"\\\\n\");\n+                break;\n+            case '\\r':\n+                buf.append(\"\\\\r\");\n+                break;\n+            default:\n+                buf.append(ch);\n@@ -219,0 +176,39 @@\n+    private final JavaClass javaClass; \/\/ current class object\n+\n+    private final String dir;\n+\n+    \/**\n+     * Write contents of the given JavaClass into HTML files.\n+     *\n+     * @param javaClass The class to write\n+     * @param dir The directory to put the files in\n+     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     *\/\n+    public Class2HTML(final JavaClass javaClass, final String dir) throws IOException {\n+        this(javaClass, dir, StandardCharsets.UTF_8);\n+    }\n+\n+    private Class2HTML(final JavaClass javaClass, final String dir, final Charset charset) throws IOException {\n+        final Method[] methods = javaClass.getMethods();\n+        this.javaClass = javaClass;\n+        this.dir = dir;\n+        className = javaClass.getClassName(); \/\/ Remember full name\n+        constantPool = javaClass.getConstantPool();\n+        \/\/ Get package name by tacking off everything after the last '.'\n+        final int index = className.lastIndexOf('.');\n+        if (index > -1) {\n+            classPackage = className.substring(0, index);\n+        } else {\n+            classPackage = \"\"; \/\/ default package\n+        }\n+        final ConstantHTML constantHtml = new ConstantHTML(dir, className, classPackage, methods, constantPool, charset);\n+        \/*\n+         * Attributes can't be written in one step, so we just open a file which will be written consequently.\n+         *\/\n+        try (AttributeHTML attributeHtml = new AttributeHTML(dir, className, constantPool, constantHtml, charset)) {\n+            new MethodHTML(dir, className, methods, javaClass.getFields(), constantHtml, attributeHtml, charset);\n+            \/\/ Write main file (with frames, yuk)\n+            writeMainHTML(attributeHtml, charset);\n+            new CodeHTML(dir, className, methods, constantPool, constantHtml, charset);\n+        }\n+    }\n@@ -220,12 +216,9 @@\n-    private void writeMainHTML( final AttributeHTML attribute_html ) throws IOException {\n-        try (PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + \".html\"))) {\n-            file.println(\"<HTML>\\n\" + \"<HEAD><TITLE>Documentation for \" + class_name + \"<\/TITLE>\" + \"<\/HEAD>\\n\"\n-                    + \"<FRAMESET BORDER=1 cols=\\\"30%,*\\\">\\n\" + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\"\n-                    + \"<FRAME NAME=\\\"ConstantPool\\\" SRC=\\\"\" + class_name + \"_cp.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n-                    + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Attributes\\\" SRC=\\\"\"\n-                    + class_name + \"_attributes.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n-                    + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET>\\n\"\n-                    + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"Code\\\" SRC=\\\"\" + class_name\n-                    + \"_code.html\\\"\\n MARGINWIDTH=0 \" + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\"\n-                    + \"<FRAME NAME=\\\"Methods\\\" SRC=\\\"\" + class_name + \"_methods.html\\\"\\n MARGINWIDTH=0 \"\n-                    + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET><\/FRAMESET><\/HTML>\");\n+    private void writeMainHTML(final AttributeHTML attributeHtml, final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n+        try (PrintWriter file = new PrintWriter(dir + className + \".html\", charset.name())) {\n+            file.println(\"<HTML>\\n\" + \"<HEAD><TITLE>Documentation for \" + className + \"<\/TITLE>\" + \"<\/HEAD>\\n\" + \"<FRAMESET BORDER=1 cols=\\\"30%,*\\\">\\n\"\n+                + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"ConstantPool\\\" SRC=\\\"\" + className + \"_cp.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n+                + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Attributes\\\" SRC=\\\"\" + className + \"_attributes.html\"\n+                + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \" + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET>\\n\"\n+                + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"Code\\\" SRC=\\\"\" + className + \"_code.html\\\"\\n MARGINWIDTH=0 \"\n+                + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Methods\\\" SRC=\\\"\" + className + \"_methods.html\\\"\\n MARGINWIDTH=0 \"\n+                + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET><\/FRAMESET><\/HTML>\");\n@@ -233,1 +226,1 @@\n-        final Attribute[] attributes = java_class.getAttributes();\n+        final Attribute[] attributes = javaClass.getAttributes();\n@@ -235,1 +228,1 @@\n-            attribute_html.writeAttribute(attributes[i], \"class\" + i);\n+            attributeHtml.writeAttribute(attributes[i], \"class\" + i);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Class2HTML.java","additions":119,"deletions":126,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -27,3 +27,1 @@\n- * Utility class implementing a (typesafe) queue of JavaClass\n- * objects.\n- *\n+ * Utility class implementing a (typesafe) queue of JavaClass objects.\n@@ -34,7 +32,5 @@\n-    private final LinkedList<JavaClass> vec = new LinkedList<>();\n-\n-\n-    public void enqueue( final JavaClass clazz ) {\n-        vec.addLast(clazz);\n-    }\n-\n+    \/**\n+     * @deprecated (since 6.0) will be made private; do not access\n+     *\/\n+    @Deprecated\n+    protected LinkedList<JavaClass> vec = new LinkedList<>(); \/\/ TODO not used externally\n@@ -46,1 +42,0 @@\n-\n@@ -51,0 +46,3 @@\n+    public void enqueue(final JavaClass clazz) {\n+        vec.addLast(clazz);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassQueue.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,2 +2,1 @@\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,1 +23,1 @@\n-import java.util.Collection;\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -31,3 +30,1 @@\n- * Utility class implementing a (typesafe) set of JavaClass objects.\n- * Since JavaClass has no equals() method, the name of the class is\n- * used for comparison.\n+ * Utility class implementing a (type-safe) set of JavaClass objects. Since JavaClass has no equals() method, the name of the class is used for comparison.\n@@ -36,0 +33,1 @@\n+ * @LastModified: Feb 2023\n@@ -41,8 +39,2 @@\n-\n-    public boolean add( final JavaClass clazz ) {\n-        boolean result = false;\n-        if (!map.containsKey(clazz.getClassName())) {\n-            result = true;\n-            map.put(clazz.getClassName(), clazz);\n-        }\n-        return result;\n+    public boolean add(final JavaClass clazz) {\n+        return map.putIfAbsent(clazz.getClassName(), clazz) != null;\n@@ -51,6 +43,0 @@\n-\n-    public void remove( final JavaClass clazz ) {\n-        map.remove(clazz.getClassName());\n-    }\n-\n-\n@@ -61,6 +47,2 @@\n-\n-    public JavaClass[] toArray() {\n-        final Collection<JavaClass> values = map.values();\n-        final JavaClass[] classes = new JavaClass[values.size()];\n-        values.toArray(classes);\n-        return classes;\n+    public String[] getClassNames() {\n+        return map.keySet().toArray(Const.EMPTY_STRING_ARRAY);\n@@ -69,0 +51,3 @@\n+    public void remove(final JavaClass clazz) {\n+        map.remove(clazz.getClassName());\n+    }\n@@ -70,2 +55,2 @@\n-    public String[] getClassNames() {\n-        return map.keySet().toArray(new String[map.size()]);\n+    public JavaClass[] toArray() {\n+        return map.values().toArray(JavaClass.EMPTY_ARRAY);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassSet.java","additions":13,"deletions":28,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -37,3 +37,2 @@\n-\n-    public void push( final JavaClass clazz ) {\n-        stack.push(clazz);\n+    public boolean empty() {\n+        return stack.empty();\n@@ -42,1 +41,0 @@\n-\n@@ -47,0 +45,3 @@\n+    public void push(final JavaClass clazz) {\n+        stack.push(clazz);\n+    }\n@@ -51,5 +52,0 @@\n-\n-\n-    public boolean empty() {\n-        return stack.empty();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassStack.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -24,1 +24,0 @@\n-import java.io.FileOutputStream;\n@@ -27,0 +26,1 @@\n+import java.nio.charset.Charset;\n@@ -39,1 +39,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.LocalVariable;\n@@ -46,2 +45,0 @@\n- *\n- *\n@@ -51,0 +48,1 @@\n+    private static boolean wide;\n@@ -52,2 +50,2 @@\n-\/\/    private Method[] methods; \/\/ Methods to print\n-    private final PrintWriter file; \/\/ file to write to\n+    \/\/ private Method[] methods; \/\/ Methods to print\n+    private final PrintWriter printWriter; \/\/ file to write to\n@@ -57,1 +55,0 @@\n-    private static boolean wide = false;\n@@ -59,4 +56,3 @@\n-\n-    CodeHTML(final String dir, final String class_name, final Method[] methods, final ConstantPool constant_pool,\n-            final ConstantHTML constant_html) throws IOException {\n-        this.className = class_name;\n+    CodeHTML(final String dir, final String className, final Method[] methods, final ConstantPool constantPool, final ConstantHTML constantHtml,\n+        final Charset charset) throws IOException {\n+        this.className = className;\n@@ -64,6 +60,12 @@\n-        this.constantPool = constant_pool;\n-        this.constantHtml = constant_html;\n-        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_code.html\"));\n-        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\">\");\n-        for (int i = 0; i < methods.length; i++) {\n-            writeMethod(methods[i], i);\n+        this.constantPool = constantPool;\n+        this.constantHtml = constantHtml;\n+        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_code.html\", charset.name())) {\n+            printWriter = newPrintWriter;\n+            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n+            printWriter.print(charset.name());\n+            printWriter.println(\"\\\"><\/head>\");\n+            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\">\");\n+            for (int i = 0; i < methods.length; i++) {\n+                writeMethod(methods[i], i);\n+            }\n+            printWriter.println(\"<\/BODY><\/HTML>\");\n@@ -71,2 +73,0 @@\n-        file.println(\"<\/BODY><\/HTML>\");\n-        file.close();\n@@ -75,1 +75,0 @@\n-\n@@ -77,2 +76,1 @@\n-     * Disassemble a stream of byte codes and return the\n-     * string representation.\n+     * Disassemble a stream of byte codes and return the string representation.\n@@ -80,1 +78,1 @@\n-     * @param  stream data input stream\n+     * @param stream data input stream\n@@ -83,1 +81,1 @@\n-    private String codeToHTML( final ByteSequence bytes, final int method_number ) throws IOException {\n+    private String codeToHTML(final ByteSequence bytes, final int methodNumber) throws IOException {\n@@ -87,1 +85,1 @@\n-        int default_offset = 0;\n+        int defaultOffset = 0;\n@@ -91,1 +89,1 @@\n-        int class_index;\n+        int classIndex;\n@@ -94,2 +92,2 @@\n-        int[] jump_table;\n-        int no_pad_bytes = 0;\n+        int[] jumpTable;\n+        int noPadBytes = 0;\n@@ -99,2 +97,2 @@\n-        \/* Special case: Skip (0-3) padding bytes, i.e., the\n-         * following bytes are 4-byte-aligned\n+        \/*\n+         * Special case: Skip (0-3) padding bytes, i.e., the following bytes are 4-byte-aligned\n@@ -102,1 +100,1 @@\n-        if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\n+        if (opcode == Const.TABLESWITCH || opcode == Const.LOOKUPSWITCH) {\n@@ -104,2 +102,2 @@\n-            no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n-            for (int i = 0; i < no_pad_bytes; i++) {\n+            noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n+            for (int i = 0; i < noPadBytes; i++) {\n@@ -109,1 +107,1 @@\n-            default_offset = bytes.readInt();\n+            defaultOffset = bytes.readInt();\n@@ -112,17 +110,11 @@\n-            case Const.TABLESWITCH:\n-                low = bytes.readInt();\n-                high = bytes.readInt();\n-                offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n-                default_offset += offset;\n-                buf.append(\"<TABLE BORDER=1><TR>\");\n-                \/\/ Print switch indices in first row (and default)\n-                jump_table = new int[high - low + 1];\n-                for (int i = 0; i < jump_table.length; i++) {\n-                    jump_table[i] = offset + bytes.readInt();\n-                    buf.append(\"<TH>\").append(low + i).append(\"<\/TH>\");\n-                }\n-                buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n-                \/\/ Print target and default indices in second row\n-            for (final int element : jump_table) {\n-                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n-                        element).append(\"\\\">\").append(element).append(\"<\/A><\/TD>\");\n+        case Const.TABLESWITCH:\n+            low = bytes.readInt();\n+            high = bytes.readInt();\n+            offset = bytes.getIndex() - 12 - noPadBytes - 1;\n+            defaultOffset += offset;\n+            buf.append(\"<TABLE BORDER=1><TR>\");\n+            \/\/ Print switch indices in first row (and default)\n+            jumpTable = new int[high - low + 1];\n+            for (int i = 0; i < jumpTable.length; i++) {\n+                jumpTable[i] = offset + bytes.readInt();\n+                buf.append(\"<TH>\").append(low + i).append(\"<\/TH>\");\n@@ -130,140 +122,143 @@\n-                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n-                        default_offset).append(\"\\\">\").append(default_offset).append(\n-                        \"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n-                break;\n-            \/* Lookup switch has variable length arguments.\n-             *\/\n-            case Const.LOOKUPSWITCH:\n-                final int npairs = bytes.readInt();\n-                offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n-                jump_table = new int[npairs];\n-                default_offset += offset;\n-                buf.append(\"<TABLE BORDER=1><TR>\");\n-                \/\/ Print switch indices in first row (and default)\n-                for (int i = 0; i < npairs; i++) {\n-                    final int match = bytes.readInt();\n-                    jump_table[i] = offset + bytes.readInt();\n-                    buf.append(\"<TH>\").append(match).append(\"<\/TH>\");\n-                }\n-                buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n-                \/\/ Print target and default indices in second row\n-                for (int i = 0; i < npairs; i++) {\n-                    buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n-                            jump_table[i]).append(\"\\\">\").append(jump_table[i]).append(\"<\/A><\/TD>\");\n-                }\n-                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n-                        default_offset).append(\"\\\">\").append(default_offset).append(\n-                        \"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n-                break;\n-            \/* Two address bytes + offset from start of byte stream form the\n-             * jump target.\n-             *\/\n-            case Const.GOTO:\n-            case Const.IFEQ:\n-            case Const.IFGE:\n-            case Const.IFGT:\n-            case Const.IFLE:\n-            case Const.IFLT:\n-            case Const.IFNE:\n-            case Const.IFNONNULL:\n-            case Const.IFNULL:\n-            case Const.IF_ACMPEQ:\n-            case Const.IF_ACMPNE:\n-            case Const.IF_ICMPEQ:\n-            case Const.IF_ICMPGE:\n-            case Const.IF_ICMPGT:\n-            case Const.IF_ICMPLE:\n-            case Const.IF_ICMPLT:\n-            case Const.IF_ICMPNE:\n-            case Const.JSR:\n-                index = bytes.getIndex() + bytes.readShort() - 1;\n-                buf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(index)\n-                        .append(\"\\\">\").append(index).append(\"<\/A>\");\n-                break;\n-            \/* Same for 32-bit wide jumps\n-             *\/\n-            case Const.GOTO_W:\n-            case Const.JSR_W:\n-                final int windex = bytes.getIndex() + bytes.readInt() - 1;\n-                buf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(windex)\n-                        .append(\"\\\">\").append(windex).append(\"<\/A>\");\n-                break;\n-            \/* Index byte references local variable (register)\n-             *\/\n-            case Const.ALOAD:\n-            case Const.ASTORE:\n-            case Const.DLOAD:\n-            case Const.DSTORE:\n-            case Const.FLOAD:\n-            case Const.FSTORE:\n-            case Const.ILOAD:\n-            case Const.ISTORE:\n-            case Const.LLOAD:\n-            case Const.LSTORE:\n-            case Const.RET:\n-                if (wide) {\n-                    vindex = bytes.readShort();\n-                    wide = false; \/\/ Clear flag\n-                } else {\n-                    vindex = bytes.readUnsignedByte();\n-                }\n-                buf.append(\"%\").append(vindex);\n-                break;\n-            \/*\n-             * Remember wide byte which is used to form a 16-bit address in the\n-             * following instruction. Relies on that the method is called again with\n-             * the following opcode.\n-             *\/\n-            case Const.WIDE:\n-                wide = true;\n-                buf.append(\"(wide)\");\n-                break;\n-            \/* Array of basic type.\n-             *\/\n-            case Const.NEWARRAY:\n-                buf.append(\"<FONT COLOR=\\\"#00FF00\\\">\").append(Const.getTypeName(bytes.readByte())).append(\n-                        \"<\/FONT>\");\n-                break;\n-            \/* Access object\/class fields.\n-             *\/\n-            case Const.GETFIELD:\n-            case Const.GETSTATIC:\n-            case Const.PUTFIELD:\n-            case Const.PUTSTATIC:\n-                index = bytes.readShort();\n-                final ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index,\n-                        Const.CONSTANT_Fieldref);\n-                class_index = c1.getClassIndex();\n-                name = constantPool.getConstantString(class_index, Const.CONSTANT_Class);\n-                name = Utility.compactClassName(name, false);\n-                index = c1.getNameAndTypeIndex();\n-                final String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);\n-                if (name.equals(className)) { \/\/ Local field\n-                    buf.append(\"<A HREF=\\\"\").append(className).append(\"_methods.html#field\")\n-                            .append(field_name).append(\"\\\" TARGET=Methods>\").append(field_name)\n-                            .append(\"<\/A>\\n\");\n-                } else {\n-                    buf.append(constantHtml.referenceConstant(class_index)).append(\".\").append(\n-                            field_name);\n-                }\n-                break;\n-            \/* Operands are references to classes in constant pool\n-             *\/\n-            case Const.CHECKCAST:\n-            case Const.INSTANCEOF:\n-            case Const.NEW:\n-                index = bytes.readShort();\n-                buf.append(constantHtml.referenceConstant(index));\n-                break;\n-            \/* Operands are references to methods in constant pool\n-             *\/\n-            case Const.INVOKESPECIAL:\n-            case Const.INVOKESTATIC:\n-            case Const.INVOKEVIRTUAL:\n-            case Const.INVOKEINTERFACE:\n-            case Const.INVOKEDYNAMIC:\n-                final int m_index = bytes.readShort();\n-                String str;\n-                if (opcode == Const.INVOKEINTERFACE) { \/\/ Special treatment needed\n-                    bytes.readUnsignedByte(); \/\/ Redundant\n-                    bytes.readUnsignedByte(); \/\/ Reserved\n+            buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n+            \/\/ Print target and default indices in second row\n+            for (final int element : jumpTable) {\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(element).append(\"\\\">\").append(element).append(\"<\/A><\/TD>\");\n+            }\n+            buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(defaultOffset).append(\"\\\">\").append(defaultOffset)\n+                .append(\"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n+            break;\n+        \/*\n+         * Lookup switch has variable length arguments.\n+         *\/\n+        case Const.LOOKUPSWITCH:\n+            final int npairs = bytes.readInt();\n+            offset = bytes.getIndex() - 8 - noPadBytes - 1;\n+            jumpTable = new int[npairs];\n+            defaultOffset += offset;\n+            buf.append(\"<TABLE BORDER=1><TR>\");\n+            \/\/ Print switch indices in first row (and default)\n+            for (int i = 0; i < npairs; i++) {\n+                final int match = bytes.readInt();\n+                jumpTable[i] = offset + bytes.readInt();\n+                buf.append(\"<TH>\").append(match).append(\"<\/TH>\");\n+            }\n+            buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n+            \/\/ Print target and default indices in second row\n+            for (int i = 0; i < npairs; i++) {\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(jumpTable[i]).append(\"\\\">\").append(jumpTable[i])\n+                    .append(\"<\/A><\/TD>\");\n+            }\n+            buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(defaultOffset).append(\"\\\">\").append(defaultOffset)\n+                .append(\"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n+            break;\n+        \/*\n+         * Two address bytes + offset from start of byte stream form the jump target.\n+         *\/\n+        case Const.GOTO:\n+        case Const.IFEQ:\n+        case Const.IFGE:\n+        case Const.IFGT:\n+        case Const.IFLE:\n+        case Const.IFLT:\n+        case Const.IFNE:\n+        case Const.IFNONNULL:\n+        case Const.IFNULL:\n+        case Const.IF_ACMPEQ:\n+        case Const.IF_ACMPNE:\n+        case Const.IF_ICMPEQ:\n+        case Const.IF_ICMPGE:\n+        case Const.IF_ICMPGT:\n+        case Const.IF_ICMPLE:\n+        case Const.IF_ICMPLT:\n+        case Const.IF_ICMPNE:\n+        case Const.JSR:\n+            index = bytes.getIndex() + bytes.readShort() - 1;\n+            buf.append(\"<A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(index).append(\"\\\">\").append(index).append(\"<\/A>\");\n+            break;\n+        \/*\n+         * Same for 32-bit wide jumps\n+         *\/\n+        case Const.GOTO_W:\n+        case Const.JSR_W:\n+            final int windex = bytes.getIndex() + bytes.readInt() - 1;\n+            buf.append(\"<A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(windex).append(\"\\\">\").append(windex).append(\"<\/A>\");\n+            break;\n+        \/*\n+         * Index byte references local variable (register)\n+         *\/\n+        case Const.ALOAD:\n+        case Const.ASTORE:\n+        case Const.DLOAD:\n+        case Const.DSTORE:\n+        case Const.FLOAD:\n+        case Const.FSTORE:\n+        case Const.ILOAD:\n+        case Const.ISTORE:\n+        case Const.LLOAD:\n+        case Const.LSTORE:\n+        case Const.RET:\n+            if (wide) {\n+                vindex = bytes.readShort();\n+                wide = false; \/\/ Clear flag\n+            } else {\n+                vindex = bytes.readUnsignedByte();\n+            }\n+            buf.append(\"%\").append(vindex);\n+            break;\n+        \/*\n+         * Remember wide byte which is used to form a 16-bit address in the following instruction. Relies on that the method is\n+         * called again with the following opcode.\n+         *\/\n+        case Const.WIDE:\n+            wide = true;\n+            buf.append(\"(wide)\");\n+            break;\n+        \/*\n+         * Array of basic type.\n+         *\/\n+        case Const.NEWARRAY:\n+            buf.append(\"<FONT COLOR=\\\"#00FF00\\\">\").append(Const.getTypeName(bytes.readByte())).append(\"<\/FONT>\");\n+            break;\n+        \/*\n+         * Access object\/class fields.\n+         *\/\n+        case Const.GETFIELD:\n+        case Const.GETSTATIC:\n+        case Const.PUTFIELD:\n+        case Const.PUTSTATIC:\n+            index = bytes.readShort();\n+            final ConstantFieldref c1 = constantPool.getConstant(index, Const.CONSTANT_Fieldref, ConstantFieldref.class);\n+            classIndex = c1.getClassIndex();\n+            name = constantPool.getConstantString(classIndex, Const.CONSTANT_Class);\n+            name = Utility.compactClassName(name, false);\n+            index = c1.getNameAndTypeIndex();\n+            final String fieldName = constantPool.constantToString(index, Const.CONSTANT_NameAndType);\n+            if (name.equals(className)) { \/\/ Local field\n+                buf.append(\"<A HREF=\\\"\").append(className).append(\"_methods.html#field\").append(fieldName).append(\"\\\" TARGET=Methods>\").append(fieldName)\n+                    .append(\"<\/A>\\n\");\n+            } else {\n+                buf.append(constantHtml.referenceConstant(classIndex)).append(\".\").append(fieldName);\n+            }\n+            break;\n+        \/*\n+         * Operands are references to classes in constant pool\n+         *\/\n+        case Const.CHECKCAST:\n+        case Const.INSTANCEOF:\n+        case Const.NEW:\n+            index = bytes.readShort();\n+            buf.append(constantHtml.referenceConstant(index));\n+            break;\n+        \/*\n+         * Operands are references to methods in constant pool\n+         *\/\n+        case Const.INVOKESPECIAL:\n+        case Const.INVOKESTATIC:\n+        case Const.INVOKEVIRTUAL:\n+        case Const.INVOKEINTERFACE:\n+        case Const.INVOKEDYNAMIC:\n+            final int mIndex = bytes.readShort();\n+            String str;\n+            if (opcode == Const.INVOKEINTERFACE) { \/\/ Special treatment needed\n+                bytes.readUnsignedByte(); \/\/ Redundant\n+                bytes.readUnsignedByte(); \/\/ Reserved\n@@ -272,84 +267,32 @@\n-                    final ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool\n-                            .getConstant(m_index, Const.CONSTANT_InterfaceMethodref);\n-                    class_index = c.getClassIndex();\n-                    index = c.getNameAndTypeIndex();\n-                    name = Class2HTML.referenceClass(class_index);\n-                } else if (opcode == Const.INVOKEDYNAMIC) { \/\/ Special treatment needed\n-                    bytes.readUnsignedByte(); \/\/ Reserved\n-                    bytes.readUnsignedByte(); \/\/ Reserved\n-                    final ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool\n-                            .getConstant(m_index, Const.CONSTANT_InvokeDynamic);\n-                    index = c.getNameAndTypeIndex();\n-                    name = \"#\" + c.getBootstrapMethodAttrIndex();\n-                } else {\n-                    \/\/ UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to\n-                    \/\/ reference EITHER a Methodref OR an InterfaceMethodref.\n-                    \/\/ Not sure if that affects this code or not.  (markro)\n-                    final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index,\n-                            Const.CONSTANT_Methodref);\n-                    class_index = c.getClassIndex();\n-                    index = c.getNameAndTypeIndex();\n-                name = Class2HTML.referenceClass(class_index);\n-                }\n-                str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(\n-                        index, Const.CONSTANT_NameAndType)));\n-                \/\/ Get signature, i.e., types\n-                final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index,\n-                        Const.CONSTANT_NameAndType);\n-                signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n-                final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n-                final String type = Utility.methodSignatureReturnType(signature, false);\n-                buf.append(name).append(\".<A HREF=\\\"\").append(className).append(\"_cp.html#cp\")\n-                        .append(m_index).append(\"\\\" TARGET=ConstantPool>\").append(str).append(\n-                                \"<\/A>\").append(\"(\");\n-                \/\/ List arguments\n-                for (int i = 0; i < args.length; i++) {\n-                    buf.append(Class2HTML.referenceType(args[i]));\n-                    if (i < args.length - 1) {\n-                        buf.append(\", \");\n-                    }\n-                }\n-                \/\/ Attach return type\n-                buf.append(\"):\").append(Class2HTML.referenceType(type));\n-                break;\n-            \/* Operands are references to items in constant pool\n-             *\/\n-            case Const.LDC_W:\n-            case Const.LDC2_W:\n-                index = bytes.readShort();\n-                buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index)\n-                        .append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(\n-                                Class2HTML.toHTML(constantPool.constantToString(index,\n-                                        constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n-                break;\n-            case Const.LDC:\n-                index = bytes.readUnsignedByte();\n-                buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index)\n-                        .append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(\n-                                Class2HTML.toHTML(constantPool.constantToString(index,\n-                                        constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n-                break;\n-            \/* Array of references.\n-             *\/\n-            case Const.ANEWARRAY:\n-                index = bytes.readShort();\n-                buf.append(constantHtml.referenceConstant(index));\n-                break;\n-            \/* Multidimensional array of references.\n-             *\/\n-            case Const.MULTIANEWARRAY:\n-                index = bytes.readShort();\n-                final int dimensions = bytes.readByte();\n-                buf.append(constantHtml.referenceConstant(index)).append(\":\").append(dimensions)\n-                        .append(\"-dimensional\");\n-                break;\n-            \/* Increment local variable.\n-             *\/\n-            case Const.IINC:\n-                if (wide) {\n-                    vindex = bytes.readShort();\n-                    constant = bytes.readShort();\n-                    wide = false;\n-                } else {\n-                    vindex = bytes.readUnsignedByte();\n-                    constant = bytes.readByte();\n+                final ConstantInterfaceMethodref c = constantPool.getConstant(mIndex, Const.CONSTANT_InterfaceMethodref, ConstantInterfaceMethodref.class);\n+                classIndex = c.getClassIndex();\n+                index = c.getNameAndTypeIndex();\n+                name = Class2HTML.referenceClass(classIndex);\n+            } else if (opcode == Const.INVOKEDYNAMIC) { \/\/ Special treatment needed\n+                bytes.readUnsignedByte(); \/\/ Reserved\n+                bytes.readUnsignedByte(); \/\/ Reserved\n+                final ConstantInvokeDynamic c = constantPool.getConstant(mIndex, Const.CONSTANT_InvokeDynamic, ConstantInvokeDynamic.class);\n+                index = c.getNameAndTypeIndex();\n+                name = \"#\" + c.getBootstrapMethodAttrIndex();\n+            } else {\n+                \/\/ UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to\n+                \/\/ reference EITHER a Methodref OR an InterfaceMethodref.\n+                \/\/ Not sure if that affects this code or not. (markro)\n+                final ConstantMethodref c = constantPool.getConstant(mIndex, Const.CONSTANT_Methodref, ConstantMethodref.class);\n+                classIndex = c.getClassIndex();\n+                index = c.getNameAndTypeIndex();\n+                name = Class2HTML.referenceClass(classIndex);\n+            }\n+            str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));\n+            \/\/ Get signature, i.e., types\n+            final ConstantNameAndType c2 = constantPool.getConstant(index, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n+            signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n+            final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n+            final String type = Utility.methodSignatureReturnType(signature, false);\n+            buf.append(name).append(\".<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(mIndex).append(\"\\\" TARGET=ConstantPool>\").append(str)\n+                .append(\"<\/A>\").append(\"(\");\n+            \/\/ List arguments\n+            for (int i = 0; i < args.length; i++) {\n+                buf.append(Class2HTML.referenceType(args[i]));\n+                if (i < args.length - 1) {\n+                    buf.append(\", \");\n@@ -357,21 +300,62 @@\n-                buf.append(\"%\").append(vindex).append(\" \").append(constant);\n-                break;\n-            default:\n-                if (Const.getNoOfOperands(opcode) > 0) {\n-                    for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n-                        switch (Const.getOperandType(opcode, i)) {\n-                            case Const.T_BYTE:\n-                                buf.append(bytes.readUnsignedByte());\n-                                break;\n-                            case Const.T_SHORT: \/\/ Either branch or index\n-                                buf.append(bytes.readShort());\n-                                break;\n-                            case Const.T_INT:\n-                                buf.append(bytes.readInt());\n-                                break;\n-                            default: \/\/ Never reached\n-                                throw new IllegalStateException(\n-                                        \"Unreachable default case reached! \" +\n-                                                Const.getOperandType(opcode, i));\n-                        }\n-                        buf.append(\"&nbsp;\");\n+            }\n+            \/\/ Attach return type\n+            buf.append(\"):\").append(Class2HTML.referenceType(type));\n+            break;\n+        \/*\n+         * Operands are references to items in constant pool\n+         *\/\n+        case Const.LDC_W:\n+        case Const.LDC2_W:\n+            index = bytes.readShort();\n+            buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\")\n+                .append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n+            break;\n+        case Const.LDC:\n+            index = bytes.readUnsignedByte();\n+            buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\")\n+                .append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n+            break;\n+        \/*\n+         * Array of references.\n+         *\/\n+        case Const.ANEWARRAY:\n+            index = bytes.readShort();\n+            buf.append(constantHtml.referenceConstant(index));\n+            break;\n+        \/*\n+         * Multidimensional array of references.\n+         *\/\n+        case Const.MULTIANEWARRAY:\n+            index = bytes.readShort();\n+            final int dimensions = bytes.readByte();\n+            buf.append(constantHtml.referenceConstant(index)).append(\":\").append(dimensions).append(\"-dimensional\");\n+            break;\n+        \/*\n+         * Increment local variable.\n+         *\/\n+        case Const.IINC:\n+            if (wide) {\n+                vindex = bytes.readShort();\n+                constant = bytes.readShort();\n+                wide = false;\n+            } else {\n+                vindex = bytes.readUnsignedByte();\n+                constant = bytes.readByte();\n+            }\n+            buf.append(\"%\").append(vindex).append(\" \").append(constant);\n+            break;\n+        default:\n+            if (Const.getNoOfOperands(opcode) > 0) {\n+                for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n+                    switch (Const.getOperandType(opcode, i)) {\n+                    case Const.T_BYTE:\n+                        buf.append(bytes.readUnsignedByte());\n+                        break;\n+                    case Const.T_SHORT: \/\/ Either branch or index\n+                        buf.append(bytes.readShort());\n+                        break;\n+                    case Const.T_INT:\n+                        buf.append(bytes.readInt());\n+                        break;\n+                    default: \/\/ Never reached\n+                        throw new IllegalStateException(\"Unreachable default case reached! \" + Const.getOperandType(opcode, i));\n@@ -379,0 +363,1 @@\n+                    buf.append(\"&nbsp;\");\n@@ -380,0 +365,1 @@\n+            }\n@@ -385,1 +371,0 @@\n-\n@@ -387,2 +372,2 @@\n-     * Find all target addresses in code, so that they can be marked\n-     * with &lt;A NAME = ...&gt;. Target addresses are kept in an BitSet object.\n+     * Find all target addresses in code, so that they can be marked with &lt;A NAME = ...&gt;. Target addresses are kept in\n+     * an BitSet object.\n@@ -390,1 +375,1 @@\n-    private void findGotos( final ByteSequence bytes, final Code code ) throws IOException {\n+    private void findGotos(final ByteSequence bytes, final Code code) throws IOException {\n@@ -394,2 +379,3 @@\n-        \/* First get Code attribute from method and the exceptions handled\n-         * (try .. catch) in this method. We only need the line number here.\n+        \/*\n+         * First get Code attribute from method and the exceptions handled (try .. catch) in this method. We only need the line\n+         * number here.\n@@ -408,3 +394,1 @@\n-                    final LocalVariable[] vars = ((LocalVariableTable) attribute)\n-                            .getLocalVariableTable();\n-                    for (final LocalVariable var : vars) {\n+                    ((LocalVariableTable) attribute).forEach(var -> {\n@@ -412,1 +396,0 @@\n-                        final int end = start + var.getLength();\n@@ -414,2 +397,2 @@\n-                        gotoSet.set(end);\n-                    }\n+                        gotoSet.set(start + var.getLength());\n+                    });\n@@ -421,1 +404,1 @@\n-        for (; bytes.available() > 0;) {\n+        while (bytes.available() > 0) {\n@@ -423,1 +406,1 @@\n-            \/\/System.out.println(getOpcodeName(opcode));\n+            \/\/ System.out.println(getOpcodeName(opcode));\n@@ -425,9 +408,21 @@\n-                case Const.TABLESWITCH:\n-                case Const.LOOKUPSWITCH:\n-                    \/\/bytes.readByte(); \/\/ Skip already read byte\n-                    final int remainder = bytes.getIndex() % 4;\n-                    final int no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n-                    int default_offset;\n-                    int offset;\n-                    for (int j = 0; j < no_pad_bytes; j++) {\n-                        bytes.readByte();\n+            case Const.TABLESWITCH:\n+            case Const.LOOKUPSWITCH:\n+                \/\/ bytes.readByte(); \/\/ Skip already read byte\n+                final int remainder = bytes.getIndex() % 4;\n+                final int noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n+                int defaultOffset;\n+                int offset;\n+                for (int j = 0; j < noPadBytes; j++) {\n+                    bytes.readByte();\n+                }\n+                \/\/ Both cases have a field default_offset in common\n+                defaultOffset = bytes.readInt();\n+                if (opcode == Const.TABLESWITCH) {\n+                    final int low = bytes.readInt();\n+                    final int high = bytes.readInt();\n+                    offset = bytes.getIndex() - 12 - noPadBytes - 1;\n+                    defaultOffset += offset;\n+                    gotoSet.set(defaultOffset);\n+                    for (int j = 0; j < high - low + 1; j++) {\n+                        index = offset + bytes.readInt();\n+                        gotoSet.set(index);\n@@ -435,18 +430,6 @@\n-                    \/\/ Both cases have a field default_offset in common\n-                    default_offset = bytes.readInt();\n-                    if (opcode == Const.TABLESWITCH) {\n-                        final int low = bytes.readInt();\n-                        final int high = bytes.readInt();\n-                        offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n-                        default_offset += offset;\n-                        gotoSet.set(default_offset);\n-                        for (int j = 0; j < (high - low + 1); j++) {\n-                            index = offset + bytes.readInt();\n-                            gotoSet.set(index);\n-                        }\n-                    } else { \/\/ LOOKUPSWITCH\n-                        final int npairs = bytes.readInt();\n-                        offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n-                        default_offset += offset;\n-                        gotoSet.set(default_offset);\n-                        for (int j = 0; j < npairs; j++) {\n+                } else { \/\/ LOOKUPSWITCH\n+                    final int npairs = bytes.readInt();\n+                    offset = bytes.getIndex() - 8 - noPadBytes - 1;\n+                    defaultOffset += offset;\n+                    gotoSet.set(defaultOffset);\n+                    for (int j = 0; j < npairs; j++) {\n@@ -454,4 +437,3 @@\n-                            bytes.readInt();\n-                            index = offset + bytes.readInt();\n-                            gotoSet.set(index);\n-                        }\n+                        bytes.readInt();\n+                        index = offset + bytes.readInt();\n+                        gotoSet.set(index);\n@@ -459,32 +441,33 @@\n-                    break;\n-                case Const.GOTO:\n-                case Const.IFEQ:\n-                case Const.IFGE:\n-                case Const.IFGT:\n-                case Const.IFLE:\n-                case Const.IFLT:\n-                case Const.IFNE:\n-                case Const.IFNONNULL:\n-                case Const.IFNULL:\n-                case Const.IF_ACMPEQ:\n-                case Const.IF_ACMPNE:\n-                case Const.IF_ICMPEQ:\n-                case Const.IF_ICMPGE:\n-                case Const.IF_ICMPGT:\n-                case Const.IF_ICMPLE:\n-                case Const.IF_ICMPLT:\n-                case Const.IF_ICMPNE:\n-                case Const.JSR:\n-                    \/\/bytes.readByte(); \/\/ Skip already read byte\n-                    index = bytes.getIndex() + bytes.readShort() - 1;\n-                    gotoSet.set(index);\n-                    break;\n-                case Const.GOTO_W:\n-                case Const.JSR_W:\n-                    \/\/bytes.readByte(); \/\/ Skip already read byte\n-                    index = bytes.getIndex() + bytes.readInt() - 1;\n-                    gotoSet.set(index);\n-                    break;\n-                default:\n-                    bytes.unreadByte();\n-                    codeToHTML(bytes, 0); \/\/ Ignore output\n+                }\n+                break;\n+            case Const.GOTO:\n+            case Const.IFEQ:\n+            case Const.IFGE:\n+            case Const.IFGT:\n+            case Const.IFLE:\n+            case Const.IFLT:\n+            case Const.IFNE:\n+            case Const.IFNONNULL:\n+            case Const.IFNULL:\n+            case Const.IF_ACMPEQ:\n+            case Const.IF_ACMPNE:\n+            case Const.IF_ICMPEQ:\n+            case Const.IF_ICMPGE:\n+            case Const.IF_ICMPGT:\n+            case Const.IF_ICMPLE:\n+            case Const.IF_ICMPLT:\n+            case Const.IF_ICMPNE:\n+            case Const.JSR:\n+                \/\/ bytes.readByte(); \/\/ Skip already read byte\n+                index = bytes.getIndex() + bytes.readShort() - 1;\n+                gotoSet.set(index);\n+                break;\n+            case Const.GOTO_W:\n+            case Const.JSR_W:\n+                \/\/ bytes.readByte(); \/\/ Skip already read byte\n+                index = bytes.getIndex() + bytes.readInt() - 1;\n+                gotoSet.set(index);\n+                break;\n+            default:\n+                bytes.unreadByte();\n+                codeToHTML(bytes, 0); \/\/ Ignore output\n@@ -495,1 +478,0 @@\n-\n@@ -499,1 +481,1 @@\n-    private void writeMethod( final Method method, final int method_number ) throws IOException {\n+    private void writeMethod(final Method method, final int methodNumber) throws IOException {\n@@ -508,1 +490,1 @@\n-        final String html_name = Class2HTML.toHTML(name);\n+        final String htmlName = Class2HTML.toHTML(name);\n@@ -514,4 +496,2 @@\n-        file.print(\"<P><B><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT>&nbsp;\" + \"<A NAME=method\"\n-                + method_number + \">\" + Class2HTML.referenceType(type) + \"<\/A>&nbsp<A HREF=\\\"\"\n-                + className + \"_methods.html#method\" + method_number + \"\\\" TARGET=Methods>\"\n-                + html_name + \"<\/A>(\");\n+        printWriter.print(\"<P><B><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT>&nbsp;\" + \"<A NAME=method\" + methodNumber + \">\" + Class2HTML.referenceType(type)\n+            + \"<\/A>&nbsp<A HREF=\\\"\" + className + \"_methods.html#method\" + methodNumber + \"\\\" TARGET=Methods>\" + htmlName + \"<\/A>(\");\n@@ -519,1 +499,1 @@\n-            file.print(Class2HTML.referenceType(args[i]));\n+            printWriter.print(Class2HTML.referenceType(args[i]));\n@@ -521,1 +501,1 @@\n-                file.print(\",&nbsp;\");\n+                printWriter.print(\",&nbsp;\");\n@@ -524,1 +504,1 @@\n-        file.println(\")<\/B><\/P>\");\n+        printWriter.println(\")<\/B><\/P>\");\n@@ -528,1 +508,1 @@\n-            file.print(\"<H4>Attributes<\/H4><UL>\\n\");\n+            printWriter.print(\"<H4>Attributes<\/H4><UL>\\n\");\n@@ -532,3 +512,2 @@\n-                    file.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#method\"\n-                            + method_number + \"@\" + i + \"\\\" TARGET=Attributes>\"\n-                            + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n+                    printWriter.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#method\" + methodNumber + \"@\" + i + \"\\\" TARGET=Attributes>\"\n+                        + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n@@ -536,1 +515,1 @@\n-                    file.print(\"<LI>\" + attributes[i] + \"<\/LI>\");\n+                    printWriter.print(\"<LI>\" + attributes[i] + \"<\/LI>\");\n@@ -542,1 +521,1 @@\n-                    file.print(\"<UL>\");\n+                    printWriter.print(\"<UL>\");\n@@ -545,3 +524,2 @@\n-                        file.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#\" + \"method\"\n-                                + method_number + \"@\" + i + \"@\" + j + \"\\\" TARGET=Attributes>\"\n-                                + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n+                        printWriter.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#\" + \"method\" + methodNumber + \"@\" + i + \"@\" + j\n+                            + \"\\\" TARGET=Attributes>\" + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n@@ -549,1 +527,1 @@\n-                    file.print(\"<\/UL>\");\n+                    printWriter.print(\"<\/UL>\");\n@@ -552,1 +530,1 @@\n-            file.println(\"<\/UL>\");\n+            printWriter.println(\"<\/UL>\");\n@@ -555,1 +533,1 @@\n-            \/\/System.out.println(name + \"\\n\" + Utility.codeToString(code, constantPool, 0, -1));\n+            \/\/ System.out.println(name + \"\\n\" + Utility.codeToString(code, constantPool, 0, -1));\n@@ -561,3 +539,2 @@\n-                file.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Byte<BR>offset<\/TH>\"\n-                        + \"<TH ALIGN=LEFT>Instruction<\/TH><TH ALIGN=LEFT>Argument<\/TH>\");\n-                for (; stream.available() > 0;) {\n+                printWriter.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Byte<BR>offset<\/TH>\" + \"<TH ALIGN=LEFT>Instruction<\/TH><TH ALIGN=LEFT>Argument<\/TH>\");\n+                while (stream.available() > 0) {\n@@ -565,1 +542,1 @@\n-                    final String str = codeToHTML(stream, method_number);\n+                    final String str = codeToHTML(stream, methodNumber);\n@@ -568,2 +545,2 @@\n-                     * Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every\n-                     * line is very inefficient!\n+                     * Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every line is very\n+                     * inefficient!\n@@ -572,1 +549,1 @@\n-                        anchor = \"<A NAME=code\" + method_number + \"@\" + offset + \"><\/A>\";\n+                        anchor = \"<A NAME=code\" + methodNumber + \"@\" + offset + \"><\/A>\";\n@@ -576,1 +553,1 @@\n-                        anchor2 = \"<A NAME=code\" + method_number + \"@\" + code.length + \">\" + offset + \"<\/A>\";\n+                        anchor2 = \"<A NAME=code\" + methodNumber + \"@\" + code.length + \">\" + offset + \"<\/A>\";\n@@ -580,1 +557,1 @@\n-                    file.println(\"<TR VALIGN=TOP><TD>\" + anchor2 + \"<\/TD><TD>\" + anchor + str + \"<\/TR>\");\n+                    printWriter.println(\"<TR VALIGN=TOP><TD>\" + anchor2 + \"<\/TD><TD>\" + anchor + str + \"<\/TR>\");\n@@ -584,2 +561,2 @@\n-            file.println(\"<TR><TD> <\/A><\/TD><\/TR>\");\n-            file.println(\"<\/TABLE>\");\n+            printWriter.println(\"<TR><TD> <\/A><\/TD><\/TR>\");\n+            printWriter.println(\"<\/TABLE>\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/CodeHTML.java","additions":383,"deletions":406,"binary":false,"changes":789,"status":"modified"},{"patch":"@@ -24,2 +24,1 @@\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n+import java.io.FileNotFoundException;\n@@ -27,0 +26,2 @@\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.Charset;\n@@ -42,2 +43,0 @@\n- *\n- *\n@@ -50,1 +49,1 @@\n-    private final PrintWriter file; \/\/ file to write to\n+    private final PrintWriter printWriter; \/\/ file to write to\n@@ -55,6 +54,5 @@\n-\n-    ConstantHTML(final String dir, final String class_name, final String class_package, final Method[] methods,\n-            final ConstantPool constant_pool) throws IOException {\n-        this.className = class_name;\n-        this.classPackage = class_package;\n-        this.constantPool = constant_pool;\n+    ConstantHTML(final String dir, final String className, final String classPackage, final Method[] methods, final ConstantPool constantPool,\n+        final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n+        this.className = className;\n+        this.classPackage = classPackage;\n+        this.constantPool = constantPool;\n@@ -62,14 +60,20 @@\n-        constants = constant_pool.getConstantPool();\n-        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_cp.html\"));\n-        constantRef = new String[constants.length];\n-        constantRef[0] = \"&lt;unknown&gt;\";\n-        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n-        \/\/ Loop through constants, constants[0] is reserved\n-        for (int i = 1; i < constants.length; i++) {\n-            if (i % 2 == 0) {\n-                file.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n-            } else {\n-                file.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n-            }\n-            if (constants[i] != null) {\n-                writeConstant(i);\n+        this.constants = constantPool.getConstantPool();\n+        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_cp.html\", charset.name())) {\n+            printWriter = newPrintWriter;\n+            constantRef = new String[constants.length];\n+            constantRef[0] = \"&lt;unknown&gt;\";\n+            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n+            printWriter.print(charset.name());\n+            printWriter.println(\"\\\"><\/head>\");\n+            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+            \/\/ Loop through constants, constants[0] is reserved\n+            for (int i = 1; i < constants.length; i++) {\n+                if (i % 2 == 0) {\n+                    printWriter.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n+                } else {\n+                    printWriter.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n+                }\n+                if (constants[i] != null) {\n+                    writeConstant(i);\n+                }\n+                printWriter.print(\"<\/TD><\/TR>\\n\");\n@@ -77,1 +81,1 @@\n-            file.print(\"<\/TD><\/TR>\\n\");\n+            printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n@@ -79,2 +83,0 @@\n-        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n-        file.close();\n@@ -83,0 +85,9 @@\n+    private int getMethodNumber(final String str) {\n+        for (int i = 0; i < methods.length; i++) {\n+            final String cmp = methods[i].getName() + methods[i].getSignature();\n+            if (cmp.equals(str)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n@@ -84,1 +95,1 @@\n-    String referenceConstant( final int index ) {\n+    String referenceConstant(final int index) {\n@@ -88,2 +99,1 @@\n-\n-    private void writeConstant( final int index ) {\n+    private void writeConstant(final int index) {\n@@ -91,2 +101,2 @@\n-        int class_index;\n-        int name_index;\n+        int classIndex;\n+        int nameIndex;\n@@ -95,3 +105,3 @@\n-        file.println(\"<H4> <A NAME=cp\" + index + \">\" + index + \"<\/A> \" + Const.getConstantName(tag)\n-                + \"<\/H4>\");\n-        \/* For every constant type get the needed parameters and print them appropiately\n+        printWriter.println(\"<H4> <A NAME=cp\" + index + \">\" + index + \"<\/A> \" + Const.getConstantName(tag) + \"<\/H4>\");\n+        \/*\n+         * For every constant type get the needed parameters and print them appropriately\n@@ -100,78 +110,32 @@\n-            case Const.CONSTANT_InterfaceMethodref:\n-            case Const.CONSTANT_Methodref:\n-                \/\/ Get class_index and name_and_type_index, depending on type\n-                if (tag == Const.CONSTANT_Methodref) {\n-                    final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(index,\n-                            Const.CONSTANT_Methodref);\n-                    class_index = c.getClassIndex();\n-                    name_index = c.getNameAndTypeIndex();\n-                } else {\n-                    final ConstantInterfaceMethodref c1 = (ConstantInterfaceMethodref) constantPool\n-                            .getConstant(index, Const.CONSTANT_InterfaceMethodref);\n-                    class_index = c1.getClassIndex();\n-                    name_index = c1.getNameAndTypeIndex();\n-                }\n-                \/\/ Get method name and its class\n-                final String method_name = constantPool.constantToString(name_index,\n-                        Const.CONSTANT_NameAndType);\n-                final String html_method_name = Class2HTML.toHTML(method_name);\n-                \/\/ Partially compacted class name, i.e., \/ -> .\n-                final String method_class = constantPool.constantToString(class_index, Const.CONSTANT_Class);\n-                String short_method_class = Utility.compactClassName(method_class); \/\/ I.e., remove java.lang.\n-                short_method_class = Utility.compactClassName(short_method_class, classPackage\n-                        + \".\", true); \/\/ Remove class package prefix\n-                \/\/ Get method signature\n-                final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(\n-                        name_index, Const.CONSTANT_NameAndType);\n-                final String signature = constantPool.constantToString(c2.getSignatureIndex(),\n-                        Const.CONSTANT_Utf8);\n-                \/\/ Get array of strings containing the argument types\n-                final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n-                \/\/ Get return type string\n-                final String type = Utility.methodSignatureReturnType(signature, false);\n-                final String ret_type = Class2HTML.referenceType(type);\n-                final StringBuilder buf = new StringBuilder(\"(\");\n-                for (int i = 0; i < args.length; i++) {\n-                    buf.append(Class2HTML.referenceType(args[i]));\n-                    if (i < args.length - 1) {\n-                        buf.append(\",&nbsp;\");\n-                    }\n-                }\n-                buf.append(\")\");\n-                final String arg_types = buf.toString();\n-                if (method_class.equals(className)) {\n-                    ref = \"<A HREF=\\\"\" + className + \"_code.html#method\"\n-                            + getMethodNumber(method_name + signature) + \"\\\" TARGET=Code>\"\n-                            + html_method_name + \"<\/A>\";\n-                } else {\n-                    ref = \"<A HREF=\\\"\" + method_class + \".html\" + \"\\\" TARGET=_top>\"\n-                            + short_method_class + \"<\/A>.\" + html_method_name;\n-                }\n-                constantRef[index] = ret_type + \"&nbsp;<A HREF=\\\"\" + className + \"_cp.html#cp\"\n-                        + class_index + \"\\\" TARGET=Constants>\" + short_method_class\n-                        + \"<\/A>.<A HREF=\\\"\" + className + \"_cp.html#cp\" + index\n-                        + \"\\\" TARGET=ConstantPool>\" + html_method_name + \"<\/A>&nbsp;\" + arg_types;\n-                file.println(\"<P><TT>\" + ret_type + \"&nbsp;\" + ref + arg_types\n-                        + \"&nbsp;<\/TT>\\n<UL>\" + \"<LI><A HREF=\\\"#cp\" + class_index\n-                        + \"\\\">Class index(\" + class_index + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\"\n-                        + name_index + \"\\\">NameAndType index(\" + name_index + \")<\/A><\/UL>\");\n-                break;\n-            case Const.CONSTANT_Fieldref:\n-                \/\/ Get class_index and name_and_type_index\n-                final ConstantFieldref c3 = (ConstantFieldref) constantPool.getConstant(index,\n-                        Const.CONSTANT_Fieldref);\n-                class_index = c3.getClassIndex();\n-                name_index = c3.getNameAndTypeIndex();\n-                \/\/ Get method name and its class (compacted)\n-                final String field_class = constantPool.constantToString(class_index, Const.CONSTANT_Class);\n-                String short_field_class = Utility.compactClassName(field_class); \/\/ I.e., remove java.lang.\n-                short_field_class = Utility.compactClassName(short_field_class,\n-                        classPackage + \".\", true); \/\/ Remove class package prefix\n-                final String field_name = constantPool\n-                        .constantToString(name_index, Const.CONSTANT_NameAndType);\n-                if (field_class.equals(className)) {\n-                    ref = \"<A HREF=\\\"\" + field_class + \"_methods.html#field\" + field_name\n-                            + \"\\\" TARGET=Methods>\" + field_name + \"<\/A>\";\n-                } else {\n-                    ref = \"<A HREF=\\\"\" + field_class + \".html\\\" TARGET=_top>\" + short_field_class\n-                            + \"<\/A>.\" + field_name + \"\\n\";\n+        case Const.CONSTANT_InterfaceMethodref:\n+        case Const.CONSTANT_Methodref:\n+            \/\/ Get class_index and name_and_type_index, depending on type\n+            if (tag == Const.CONSTANT_Methodref) {\n+                final ConstantMethodref c = constantPool.getConstant(index, Const.CONSTANT_Methodref, ConstantMethodref.class);\n+                classIndex = c.getClassIndex();\n+                nameIndex = c.getNameAndTypeIndex();\n+            } else {\n+                final ConstantInterfaceMethodref c1 = constantPool.getConstant(index, Const.CONSTANT_InterfaceMethodref, ConstantInterfaceMethodref.class);\n+                classIndex = c1.getClassIndex();\n+                nameIndex = c1.getNameAndTypeIndex();\n+            }\n+            \/\/ Get method name and its class\n+            final String methodName = constantPool.constantToString(nameIndex, Const.CONSTANT_NameAndType);\n+            final String htmlMethodName = Class2HTML.toHTML(methodName);\n+            \/\/ Partially compacted class name, i.e., \/ -> .\n+            final String methodClass = constantPool.constantToString(classIndex, Const.CONSTANT_Class);\n+            String shortMethodClass = Utility.compactClassName(methodClass); \/\/ I.e., remove java.lang.\n+            shortMethodClass = Utility.compactClassName(shortMethodClass, classPackage + \".\", true); \/\/ Remove class package prefix\n+            \/\/ Get method signature\n+            final ConstantNameAndType c2 = constantPool.getConstant(nameIndex, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n+            final String signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n+            \/\/ Get array of strings containing the argument types\n+            final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n+            \/\/ Get return type string\n+            final String type = Utility.methodSignatureReturnType(signature, false);\n+            final String retType = Class2HTML.referenceType(type);\n+            final StringBuilder buf = new StringBuilder(\"(\");\n+            for (int i = 0; i < args.length; i++) {\n+                buf.append(Class2HTML.referenceType(args[i]));\n+                if (i < args.length - 1) {\n+                    buf.append(\",&nbsp;\");\n@@ -179,53 +143,0 @@\n-                constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + class_index\n-                        + \"\\\" TARGET=Constants>\" + short_field_class + \"<\/A>.<A HREF=\\\"\"\n-                        + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\"\n-                        + field_name + \"<\/A>\";\n-                file.println(\"<P><TT>\" + ref + \"<\/TT><BR>\\n\" + \"<UL>\" + \"<LI><A HREF=\\\"#cp\"\n-                        + class_index + \"\\\">Class(\" + class_index + \")<\/A><BR>\\n\"\n-                        + \"<LI><A HREF=\\\"#cp\" + name_index + \"\\\">NameAndType(\" + name_index\n-                        + \")<\/A><\/UL>\");\n-                break;\n-            case Const.CONSTANT_Class:\n-                final ConstantClass c4 = (ConstantClass) constantPool.getConstant(index, Const.CONSTANT_Class);\n-                name_index = c4.getNameIndex();\n-                final String class_name2 = constantPool.constantToString(index, tag); \/\/ \/ -> .\n-                String short_class_name = Utility.compactClassName(class_name2); \/\/ I.e., remove java.lang.\n-                short_class_name = Utility.compactClassName(short_class_name, classPackage + \".\",\n-                        true); \/\/ Remove class package prefix\n-                ref = \"<A HREF=\\\"\" + class_name2 + \".html\\\" TARGET=_top>\" + short_class_name\n-                        + \"<\/A>\";\n-                constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index\n-                        + \"\\\" TARGET=ConstantPool>\" + short_class_name + \"<\/A>\";\n-                file.println(\"<P><TT>\" + ref + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index\n-                        + \"\\\">Name index(\" + name_index + \")<\/A><\/UL>\\n\");\n-                break;\n-            case Const.CONSTANT_String:\n-                final ConstantString c5 = (ConstantString) constantPool.getConstant(index,\n-                        Const.CONSTANT_String);\n-                name_index = c5.getStringIndex();\n-                final String str = Class2HTML.toHTML(constantPool.constantToString(index, tag));\n-                file.println(\"<P><TT>\" + str + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index\n-                        + \"\\\">Name index(\" + name_index + \")<\/A><\/UL>\\n\");\n-                break;\n-            case Const.CONSTANT_NameAndType:\n-                final ConstantNameAndType c6 = (ConstantNameAndType) constantPool.getConstant(index,\n-                        Const.CONSTANT_NameAndType);\n-                name_index = c6.getNameIndex();\n-                final int signature_index = c6.getSignatureIndex();\n-                file.println(\"<P><TT>\"\n-                        + Class2HTML.toHTML(constantPool.constantToString(index, tag))\n-                        + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index + \"\\\">Name index(\"\n-                        + name_index + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + signature_index\n-                        + \"\\\">Signature index(\" + signature_index + \")<\/A><\/UL>\\n\");\n-                break;\n-            default:\n-                file.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT>\\n\");\n-        } \/\/ switch\n-    }\n-\n-\n-    private int getMethodNumber( final String str ) {\n-        for (int i = 0; i < methods.length; i++) {\n-            final String cmp = methods[i].getName() + methods[i].getSignature();\n-            if (cmp.equals(str)) {\n-                return i;\n@@ -233,2 +144,58 @@\n-        }\n-        return -1;\n+            buf.append(\")\");\n+            final String argTypes = buf.toString();\n+            if (methodClass.equals(className)) {\n+                ref = \"<A HREF=\\\"\" + className + \"_code.html#method\" + getMethodNumber(methodName + signature) + \"\\\" TARGET=Code>\" + htmlMethodName + \"<\/A>\";\n+            } else {\n+                ref = \"<A HREF=\\\"\" + methodClass + \".html\" + \"\\\" TARGET=_top>\" + shortMethodClass + \"<\/A>.\" + htmlMethodName;\n+            }\n+            constantRef[index] = retType + \"&nbsp;<A HREF=\\\"\" + className + \"_cp.html#cp\" + classIndex + \"\\\" TARGET=Constants>\" + shortMethodClass\n+                + \"<\/A>.<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + htmlMethodName + \"<\/A>&nbsp;\" + argTypes;\n+            printWriter.println(\"<P><TT>\" + retType + \"&nbsp;\" + ref + argTypes + \"&nbsp;<\/TT>\\n<UL>\" + \"<LI><A HREF=\\\"#cp\" + classIndex + \"\\\">Class index(\"\n+                + classIndex + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">NameAndType index(\" + nameIndex + \")<\/A><\/UL>\");\n+            break;\n+        case Const.CONSTANT_Fieldref:\n+            \/\/ Get class_index and name_and_type_index\n+            final ConstantFieldref c3 = constantPool.getConstant(index, Const.CONSTANT_Fieldref, ConstantFieldref.class);\n+            classIndex = c3.getClassIndex();\n+            nameIndex = c3.getNameAndTypeIndex();\n+            \/\/ Get method name and its class (compacted)\n+            final String fieldClass = constantPool.constantToString(classIndex, Const.CONSTANT_Class);\n+            String shortFieldClass = Utility.compactClassName(fieldClass); \/\/ I.e., remove java.lang.\n+            shortFieldClass = Utility.compactClassName(shortFieldClass, classPackage + \".\", true); \/\/ Remove class package prefix\n+            final String fieldName = constantPool.constantToString(nameIndex, Const.CONSTANT_NameAndType);\n+            if (fieldClass.equals(className)) {\n+                ref = \"<A HREF=\\\"\" + fieldClass + \"_methods.html#field\" + fieldName + \"\\\" TARGET=Methods>\" + fieldName + \"<\/A>\";\n+            } else {\n+                ref = \"<A HREF=\\\"\" + fieldClass + \".html\\\" TARGET=_top>\" + shortFieldClass + \"<\/A>.\" + fieldName + \"\\n\";\n+            }\n+            constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + classIndex + \"\\\" TARGET=Constants>\" + shortFieldClass + \"<\/A>.<A HREF=\\\"\"\n+                + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + fieldName + \"<\/A>\";\n+            printWriter.println(\"<P><TT>\" + ref + \"<\/TT><BR>\\n\" + \"<UL>\" + \"<LI><A HREF=\\\"#cp\" + classIndex + \"\\\">Class(\" + classIndex + \")<\/A><BR>\\n\"\n+                + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">NameAndType(\" + nameIndex + \")<\/A><\/UL>\");\n+            break;\n+        case Const.CONSTANT_Class:\n+            final ConstantClass c4 = constantPool.getConstant(index, Const.CONSTANT_Class, ConstantClass.class);\n+            nameIndex = c4.getNameIndex();\n+            final String className2 = constantPool.constantToString(index, tag); \/\/ \/ -> .\n+            String shortClassName = Utility.compactClassName(className2); \/\/ I.e., remove java.lang.\n+            shortClassName = Utility.compactClassName(shortClassName, classPackage + \".\", true); \/\/ Remove class package prefix\n+            ref = \"<A HREF=\\\"\" + className2 + \".html\\\" TARGET=_top>\" + shortClassName + \"<\/A>\";\n+            constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + shortClassName + \"<\/A>\";\n+            printWriter.println(\"<P><TT>\" + ref + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">Name index(\" + nameIndex + \")<\/A><\/UL>\\n\");\n+            break;\n+        case Const.CONSTANT_String:\n+            final ConstantString c5 = constantPool.getConstant(index, Const.CONSTANT_String, ConstantString.class);\n+            nameIndex = c5.getStringIndex();\n+            final String str = Class2HTML.toHTML(constantPool.constantToString(index, tag));\n+            printWriter.println(\"<P><TT>\" + str + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">Name index(\" + nameIndex + \")<\/A><\/UL>\\n\");\n+            break;\n+        case Const.CONSTANT_NameAndType:\n+            final ConstantNameAndType c6 = constantPool.getConstant(index, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n+            nameIndex = c6.getNameIndex();\n+            final int signatureIndex = c6.getSignatureIndex();\n+            printWriter.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex\n+                + \"\\\">Name index(\" + nameIndex + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + signatureIndex + \"\\\">Signature index(\" + signatureIndex + \")<\/A><\/UL>\\n\");\n+            break;\n+        default:\n+            printWriter.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT>\\n\");\n+        } \/\/ switch\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ConstantHTML.java","additions":136,"deletions":169,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -23,4 +23,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.generic.ClassGenException;\n-import com.sun.org.apache.bcel.internal.generic.InstructionHandle;\n-import com.sun.org.apache.bcel.internal.generic.InstructionList;\n@@ -28,0 +24,1 @@\n+import java.util.Arrays;\n@@ -36,0 +33,5 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.generic.ClassGenException;\n+import com.sun.org.apache.bcel.internal.generic.InstructionHandle;\n+import com.sun.org.apache.bcel.internal.generic.InstructionList;\n+\n@@ -37,5 +39,3 @@\n- * InstructionFinder is a tool to search for given instructions patterns, i.e.,\n- * match sequences of instructions in an instruction list via regular\n- * expressions. This can be used, e.g., in order to implement a peep hole\n- * optimizer that looks for code patterns and replaces them with faster\n- * equivalents.\n+ * InstructionFinder is a tool to search for given instructions patterns, i.e., match sequences of instructions in an\n+ * instruction list via regular expressions. This can be used, e.g., in order to implement a peep hole optimizer that\n+ * looks for code patterns and replaces them with faster equivalents.\n@@ -44,2 +44,1 @@\n- * This class internally uses the java.util.regex\n- * package to search for regular expressions.\n+ * This class internally uses the java.util.regex package to search for regular expressions.\n@@ -71,9 +70,0 @@\n-    private static final int OFFSET = 32767; \/\/ char + OFFSET is outside of LATIN-1\n-    private static final int NO_OPCODES = 256; \/\/ Potential number, some are not used\n-    private static final Map<String, String> map = new HashMap<>();\n-    private final InstructionList il;\n-    private String ilString; \/\/ instruction list as string\n-    private InstructionHandle[] handles; \/\/ map instruction\n-\n-\n-    \/\/ list to array\n@@ -81,2 +71,3 @@\n-     * @param il\n-     *          instruction list to search for given patterns\n+     * Code patterns found may be checked using an additional user-defined constraint object whether they really match the\n+     * needed criterion. I.e., check constraints that can not expressed with regular expressions.\n+     *\n@@ -84,5 +75,1 @@\n-    public InstructionFinder(final InstructionList il) {\n-        this.il = il;\n-        reread();\n-    }\n-\n+    public interface CodeConstraint {\n@@ -90,13 +77,5 @@\n-    \/**\n-     * Reread the instruction list, e.g., after you've altered the list upon a\n-     * match.\n-     *\/\n-    public final void reread() {\n-        final int size = il.getLength();\n-        final char[] buf = new char[size]; \/\/ Create a string with length equal to il length\n-        handles = il.getInstructionHandles();\n-        \/\/ Map opcodes to characters\n-        for (int i = 0; i < size; i++) {\n-            buf[i] = makeChar(handles[i].getInstruction().getOpcode());\n-        }\n-        ilString = new String(buf);\n+        \/**\n+         * @param match array of instructions matching the requested pattern\n+         * @return true if the matched area is really useful\n+         *\/\n+        boolean checkCode(InstructionHandle[] match);\n@@ -105,0 +84,3 @@\n+    private static final int OFFSET = 32767; \/\/ char + OFFSET is outside of LATIN-1\n+    private static final int NO_OPCODES = 256; \/\/ Potential number, some are not used\n+    private static final Map<String, String> map = new HashMap<>();\n@@ -106,12 +88,71 @@\n-    \/**\n-     * Map symbolic instruction names like \"getfield\" to a single character.\n-     *\n-     * @param pattern\n-     *          instruction pattern in lower case\n-     * @return encoded string for a pattern such as \"BranchInstruction\".\n-     *\/\n-    private static String mapName( final String pattern ) {\n-        final String result = map.get(pattern);\n-        if (result != null) {\n-            return result;\n-        }\n+    \/\/ Initialize pattern map\n+    static {\n+        map.put(\"arithmeticinstruction\",\n+            \"(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)\");\n+        map.put(\"invokeinstruction\", \"(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)\");\n+        map.put(\"arrayinstruction\",\n+            \"(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)\");\n+        map.put(\"gotoinstruction\", \"(goto|goto_w)\");\n+        map.put(\"conversioninstruction\", \"(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)\");\n+        map.put(\"localvariableinstruction\", \"(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)\");\n+        map.put(\"loadinstruction\", \"(fload|dload|lload|iload|aload)\");\n+        map.put(\"fieldinstruction\", \"(getfield|putstatic|getstatic|putfield)\");\n+        map.put(\"cpinstruction\",\n+            \"(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)\");\n+        map.put(\"stackinstruction\", \"(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)\");\n+        map.put(\"branchinstruction\",\n+            \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n+        map.put(\"returninstruction\", \"(lreturn|ireturn|freturn|dreturn|areturn|return)\");\n+        map.put(\"storeinstruction\", \"(istore|fstore|dstore|astore|lstore)\");\n+        map.put(\"select\", \"(tableswitch|lookupswitch)\");\n+        map.put(\"ifinstruction\",\n+            \"(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)\");\n+        map.put(\"jsrinstruction\", \"(jsr|jsr_w)\");\n+        map.put(\"variablelengthinstruction\", \"(tableswitch|jsr|goto|lookupswitch)\");\n+        map.put(\"unconditionalbranch\", \"(goto|jsr|jsr_w|athrow|goto_w)\");\n+        map.put(\"constantpushinstruction\", \"(dconst|bipush|sipush|fconst|iconst|lconst)\");\n+        map.put(\"typedinstruction\",\n+            \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)\");\n+        map.put(\"popinstruction\", \"(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)\");\n+        map.put(\"allocationinstruction\", \"(multianewarray|new|anewarray|newarray)\");\n+        map.put(\"indexedinstruction\",\n+            \"(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)\");\n+        map.put(\"pushinstruction\", \"(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)\");\n+        map.put(\"stackproducer\",\n+            \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)\");\n+        map.put(\"stackconsumer\",\n+            \"(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)\");\n+        map.put(\"exceptionthrower\",\n+            \"(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)\");\n+        map.put(\"loadclass\",\n+            \"(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)\");\n+        map.put(\"instructiontargeter\",\n+            \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n+        \/\/ Some aliases\n+        map.put(\"if_icmp\", \"(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)\");\n+        map.put(\"if_acmp\", \"(if_acmpeq|if_acmpne)\");\n+        map.put(\"if\", \"(ifeq|ifne|iflt|ifge|ifgt|ifle)\");\n+        \/\/ Precompile some aliases first\n+        map.put(\"iconst\", precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));\n+        map.put(\"lconst\", new String(new char[] {'(', makeChar(Const.LCONST_0), '|', makeChar(Const.LCONST_1), ')'}));\n+        map.put(\"dconst\", new String(new char[] {'(', makeChar(Const.DCONST_0), '|', makeChar(Const.DCONST_1), ')'}));\n+        map.put(\"fconst\", new String(new char[] {'(', makeChar(Const.FCONST_0), '|', makeChar(Const.FCONST_1), '|', makeChar(Const.FCONST_2), ')'}));\n+        map.put(\"lload\", precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));\n+        map.put(\"iload\", precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));\n+        map.put(\"dload\", precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));\n+        map.put(\"fload\", precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));\n+        map.put(\"aload\", precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));\n+        map.put(\"lstore\", precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));\n+        map.put(\"istore\", precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));\n+        map.put(\"dstore\", precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));\n+        map.put(\"fstore\", precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));\n+        map.put(\"astore\", precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));\n+        \/\/ Compile strings\n+        map.forEach((key, value) -> {\n+            final char ch = value.charAt(1); \/\/ Omit already precompiled patterns\n+            if (ch < OFFSET) {\n+                map.put(key, compilePattern(value)); \/\/ precompile all patterns\n+            }\n+        });\n+        \/\/ Add instruction alias to match anything\n+        final StringBuilder buf = new StringBuilder(\"(\");\n@@ -119,2 +160,5 @@\n-            if (pattern.equals(Const.getOpcodeName(i))) {\n-                return \"\" + makeChar(i);\n+            if (Const.getNoOfOperands(i) != Const.UNDEFINED) { \/\/ Not an invalid opcode\n+                buf.append(makeChar(i));\n+                if (i < NO_OPCODES - 1) {\n+                    buf.append('|');\n+                }\n@@ -123,1 +167,2 @@\n-        throw new IllegalArgumentException(\"Instruction unknown: \" + pattern);\n+        buf.append(')');\n+        map.put(\"instruction\", buf.toString());\n@@ -126,1 +171,0 @@\n-\n@@ -128,3 +172,2 @@\n-     * Replace symbolic names of instructions with the appropiate character and\n-     * remove all white space from string. Meta characters such as +, * are\n-     * ignored.\n+     * Replace symbolic names of instructions with the appropriate character and remove all white space from string. Meta\n+     * characters such as +, * are ignored.\n@@ -132,2 +175,1 @@\n-     * @param pattern\n-     *          The pattern to compile\n+     * @param pattern The pattern to compile\n@@ -136,2 +178,2 @@\n-    private static String compilePattern( final String pattern ) {\n-        \/\/Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues\n+    private static String compilePattern(final String pattern) {\n+        \/\/ Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues\n@@ -147,3 +189,1 @@\n-                    if (++i < size) {\n-                        ch = lower.charAt(i);\n-                    } else {\n+                    if (++i >= size) {\n@@ -152,0 +192,1 @@\n+                    ch = lower.charAt(i);\n@@ -162,1 +203,0 @@\n-\n@@ -164,1 +204,1 @@\n-     * @return the matched piece of code as an array of instruction (handles)\n+     * Convert opcode number to char.\n@@ -166,4 +206,2 @@\n-    private InstructionHandle[] getMatch( final int matched_from, final int match_length ) {\n-        final InstructionHandle[] match = new InstructionHandle[match_length];\n-        System.arraycopy(handles, matched_from, match, 0, match_length);\n-        return match;\n+    private static char makeChar(final short opcode) {\n+        return (char) (opcode + OFFSET);\n@@ -172,1 +210,0 @@\n-\n@@ -174,23 +211,1 @@\n-     * Search for the given pattern in the instruction list. You can search for\n-     * any valid opcode via its symbolic name, e.g. \"istore\". You can also use a\n-     * super class or an interface name to match a whole set of instructions, e.g.\n-     * \"BranchInstruction\" or \"LoadInstruction\". \"istore\" is also an alias for all\n-     * \"istore_x\" instructions. Additional aliases are \"if\" for \"ifxx\", \"if_icmp\"\n-     * for \"if_icmpxx\", \"if_acmp\" for \"if_acmpxx\".\n-     *\n-     * Consecutive instruction names must be separated by white space which will\n-     * be removed during the compilation of the pattern.\n-     *\n-     * For the rest the usual pattern matching rules for regular expressions\n-     * apply.\n-     * <P>\n-     * Example pattern:\n-     *\n-     * <pre>\n-     * search(&quot;BranchInstruction NOP ((IfInstruction|GOTO)+ ISTORE Instruction)*&quot;);\n-     * <\/pre>\n-     *\n-     * <p>\n-     * If you alter the instruction list upon a match such that other matching\n-     * areas are affected, you should call reread() to update the finder and call\n-     * search() again, because the matches are cached.\n+     * Map symbolic instruction names like \"getfield\" to a single character.\n@@ -198,9 +213,2 @@\n-     * @param pattern\n-     *          the instruction pattern to search for, where case is ignored\n-     * @param from\n-     *          where to start the search in the instruction list\n-     * @param constraint\n-     *          optional CodeConstraint to check the found code pattern for\n-     *          user-defined constraints\n-     * @return iterator of matches where e.nextElement() returns an array of\n-     *         instruction handles describing the matched area\n+     * @param pattern instruction pattern in lower case\n+     * @return encoded string for a pattern such as \"BranchInstruction\".\n@@ -208,13 +216,4 @@\n-    public final Iterator<InstructionHandle[]> search( final String pattern,\n-            final InstructionHandle from, final CodeConstraint constraint ) {\n-        final String search = compilePattern(pattern);\n-        int start = -1;\n-        for (int i = 0; i < handles.length; i++) {\n-            if (handles[i] == from) {\n-                start = i; \/\/ Where to start search from (index)\n-                break;\n-            }\n-        }\n-        if (start == -1) {\n-            throw new ClassGenException(\"Instruction handle \" + from\n-                    + \" not found in instruction list.\");\n+    private static String mapName(final String pattern) {\n+        final String result = map.get(pattern);\n+        if (result != null) {\n+            return result;\n@@ -222,10 +221,3 @@\n-        final Pattern regex = Pattern.compile(search);\n-        final List<InstructionHandle[]> matches = new ArrayList<>();\n-        final Matcher matcher = regex.matcher(ilString);\n-        while (start < ilString.length() && matcher.find(start)) {\n-            final int startExpr = matcher.start();\n-            final int endExpr = matcher.end();\n-            final int lenExpr = endExpr - startExpr;\n-            final InstructionHandle[] match = getMatch(startExpr, lenExpr);\n-            if ((constraint == null) || constraint.checkCode(match)) {\n-                matches.add(match);\n+        for (short i = 0; i < NO_OPCODES; i++) {\n+            if (pattern.equals(Const.getOpcodeName(i))) {\n+                return String.valueOf(makeChar(i));\n@@ -233,1 +225,0 @@\n-            start = endExpr;\n@@ -235,1 +226,1 @@\n-        return matches.iterator();\n+        throw new IllegalArgumentException(\"Instruction unknown: \" + pattern);\n@@ -238,0 +229,16 @@\n+    private static String precompile(final short from, final short to, final short extra) {\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        for (short i = from; i <= to; i++) {\n+            buf.append(makeChar(i));\n+            buf.append('|');\n+        }\n+        buf.append(makeChar(extra));\n+        buf.append(\")\");\n+        return buf.toString();\n+    }\n+\n+    private final InstructionList il;\n+\n+    private String ilString; \/\/ instruction list as string\n+\n+    private InstructionHandle[] handles; \/\/ map instruction\n@@ -239,0 +246,1 @@\n+    \/\/ list to array\n@@ -240,6 +248,1 @@\n-     * Start search beginning from the start of the given instruction list.\n-     *\n-     * @param pattern\n-     *          the instruction pattern to search for, where case is ignored\n-     * @return iterator of matches where e.nextElement() returns an array of\n-     *         instruction handles describing the matched area\n+     * @param il instruction list to search for given patterns\n@@ -247,2 +250,3 @@\n-    public final Iterator<InstructionHandle[]> search( final String pattern ) {\n-        return search(pattern, il.getStart(), null);\n+    public InstructionFinder(final InstructionList il) {\n+        this.il = il;\n+        reread();\n@@ -251,1 +255,0 @@\n-\n@@ -253,8 +256,1 @@\n-     * Start search beginning from `from'.\n-     *\n-     * @param pattern\n-     *          the instruction pattern to search for, where case is ignored\n-     * @param from\n-     *          where to start the search in the instruction list\n-     * @return iterator of matches where e.nextElement() returns an array of\n-     *         instruction handles describing the matched area\n+     * @return the inquired instruction list\n@@ -262,3 +258,2 @@\n-    public final Iterator<InstructionHandle[]> search( final String pattern,\n-            final InstructionHandle from ) {\n-        return search(pattern, from, null);\n+    public final InstructionList getInstructionList() {\n+        return il;\n@@ -267,1 +262,0 @@\n-\n@@ -269,8 +263,1 @@\n-     * Start search beginning from the start of the given instruction list. Check\n-     * found matches with the constraint object.\n-     *\n-     * @param pattern\n-     *          the instruction pattern to search for, case is ignored\n-     * @param constraint\n-     *          constraints to be checked on matching code\n-     * @return instruction handle or `null' if the match failed\n+     * @return the matched piece of code as an array of instruction (handles)\n@@ -278,3 +265,2 @@\n-    public final Iterator<InstructionHandle[]> search( final String pattern,\n-            final CodeConstraint constraint ) {\n-        return search(pattern, il.getStart(), constraint);\n+    private InstructionHandle[] getMatch(final int matchedFrom, final int matchLength) {\n+        return Arrays.copyOfRange(handles, matchedFrom, matchedFrom + matchLength);\n@@ -283,1 +269,0 @@\n-\n@@ -285,1 +270,1 @@\n-     * Convert opcode number to char.\n+     * Reread the instruction list, e.g., after you've altered the list upon a match.\n@@ -287,2 +272,9 @@\n-    private static char makeChar( final short opcode ) {\n-        return (char) (opcode + OFFSET);\n+    public final void reread() {\n+        final int size = il.getLength();\n+        final char[] buf = new char[size]; \/\/ Create a string with length equal to il length\n+        handles = il.getInstructionHandles();\n+        \/\/ Map opcodes to characters\n+        for (int i = 0; i < size; i++) {\n+            buf[i] = makeChar(handles[i].getInstruction().getOpcode());\n+        }\n+        ilString = new String(buf);\n@@ -291,1 +283,0 @@\n-\n@@ -293,1 +284,4 @@\n-     * @return the inquired instruction list\n+     * Start search beginning from the start of the given instruction list.\n+     *\n+     * @param pattern the instruction pattern to search for, where case is ignored\n+     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n@@ -295,2 +289,2 @@\n-    public final InstructionList getInstructionList() {\n-        return il;\n+    public final Iterator<InstructionHandle[]> search(final String pattern) {\n+        return search(pattern, il.getStart(), null);\n@@ -300,3 +294,1 @@\n-     * Code patterns found may be checked using an additional user-defined\n-     * constraint object whether they really match the needed criterion. I.e.,\n-     * check constraints that can not expressed with regular expressions.\n+     * Start search beginning from the start of the given instruction list. Check found matches with the constraint object.\n@@ -304,0 +296,3 @@\n+     * @param pattern the instruction pattern to search for, case is ignored\n+     * @param constraint constraints to be checked on matching code\n+     * @return instruction handle or 'null' if the match failed\n@@ -305,1 +300,3 @@\n-    public interface CodeConstraint {\n+    public final Iterator<InstructionHandle[]> search(final String pattern, final CodeConstraint constraint) {\n+        return search(pattern, il.getStart(), constraint);\n+    }\n@@ -307,6 +304,9 @@\n-        \/**\n-         * @param match\n-         *          array of instructions matching the requested pattern\n-         * @return true if the matched area is really useful\n-         *\/\n-        boolean checkCode( InstructionHandle[] match );\n+    \/**\n+     * Start search beginning from 'from'.\n+     *\n+     * @param pattern the instruction pattern to search for, where case is ignored\n+     * @param from where to start the search in the instruction list\n+     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     *\/\n+    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from) {\n+        return search(pattern, from, null);\n@@ -315,57 +315,33 @@\n-    \/\/ Initialize pattern map\n-    static {\n-        map.put(\"arithmeticinstruction\",\"(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)\");\n-        map.put(\"invokeinstruction\", \"(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)\");\n-        map.put(\"arrayinstruction\", \"(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)\");\n-        map.put(\"gotoinstruction\", \"(goto|goto_w)\");\n-        map.put(\"conversioninstruction\", \"(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)\");\n-        map.put(\"localvariableinstruction\",\"(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)\");\n-        map.put(\"loadinstruction\", \"(fload|dload|lload|iload|aload)\");\n-        map.put(\"fieldinstruction\", \"(getfield|putstatic|getstatic|putfield)\");\n-        map.put(\"cpinstruction\", \"(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)\");\n-        map.put(\"stackinstruction\", \"(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)\");\n-        map.put(\"branchinstruction\", \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n-        map.put(\"returninstruction\", \"(lreturn|ireturn|freturn|dreturn|areturn|return)\");\n-        map.put(\"storeinstruction\", \"(istore|fstore|dstore|astore|lstore)\");\n-        map.put(\"select\", \"(tableswitch|lookupswitch)\");\n-        map.put(\"ifinstruction\", \"(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)\");\n-        map.put(\"jsrinstruction\", \"(jsr|jsr_w)\");\n-        map.put(\"variablelengthinstruction\", \"(tableswitch|jsr|goto|lookupswitch)\");\n-        map.put(\"unconditionalbranch\", \"(goto|jsr|jsr_w|athrow|goto_w)\");\n-        map.put(\"constantpushinstruction\", \"(dconst|bipush|sipush|fconst|iconst|lconst)\");\n-        map.put(\"typedinstruction\", \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)\");\n-        map.put(\"popinstruction\", \"(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)\");\n-        map.put(\"allocationinstruction\", \"(multianewarray|new|anewarray|newarray)\");\n-        map.put(\"indexedinstruction\", \"(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)\");\n-        map.put(\"pushinstruction\", \"(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)\");\n-        map.put(\"stackproducer\", \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)\");\n-        map.put(\"stackconsumer\", \"(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)\");\n-        map.put(\"exceptionthrower\",\"(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)\");\n-        map.put(\"loadclass\", \"(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)\");\n-        map.put(\"instructiontargeter\", \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n-        \/\/ Some aliases\n-        map.put(\"if_icmp\", \"(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)\");\n-        map.put(\"if_acmp\", \"(if_acmpeq|if_acmpne)\");\n-        map.put(\"if\", \"(ifeq|ifne|iflt|ifge|ifgt|ifle)\");\n-        \/\/ Precompile some aliases first\n-        map.put(\"iconst\", precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));\n-        map.put(\"lconst\", new String(new char[] { '(', makeChar(Const.LCONST_0), '|', makeChar(Const.LCONST_1), ')' }));\n-        map.put(\"dconst\", new String(new char[] { '(', makeChar(Const.DCONST_0), '|', makeChar(Const.DCONST_1), ')' }));\n-        map.put(\"fconst\", new String(new char[] { '(', makeChar(Const.FCONST_0), '|', makeChar(Const.FCONST_1), '|', makeChar(Const.FCONST_2), ')' }));\n-        map.put(\"lload\", precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));\n-        map.put(\"iload\", precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));\n-        map.put(\"dload\", precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));\n-        map.put(\"fload\", precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));\n-        map.put(\"aload\", precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));\n-        map.put(\"lstore\", precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));\n-        map.put(\"istore\", precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));\n-        map.put(\"dstore\", precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));\n-        map.put(\"fstore\", precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));\n-        map.put(\"astore\", precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));\n-        \/\/ Compile strings\n-        for (final Map.Entry<String, String> entry : map.entrySet()) {\n-            final String key = entry.getKey();\n-            final String value = entry.getValue();\n-            final char ch = value.charAt(1); \/\/ Omit already precompiled patterns\n-            if (ch < OFFSET) {\n-                map.put(key, compilePattern(value)); \/\/ precompile all patterns\n+    \/**\n+     * Search for the given pattern in the instruction list. You can search for any valid opcode via its symbolic name, e.g.\n+     * \"istore\". You can also use a super class or an interface name to match a whole set of instructions, e.g.\n+     * \"BranchInstruction\" or \"LoadInstruction\". \"istore\" is also an alias for all \"istore_x\" instructions. Additional\n+     * aliases are \"if\" for \"ifxx\", \"if_icmp\" for \"if_icmpxx\", \"if_acmp\" for \"if_acmpxx\".\n+     *\n+     * Consecutive instruction names must be separated by white space which will be removed during the compilation of the\n+     * pattern.\n+     *\n+     * For the rest the usual pattern matching rules for regular expressions apply.\n+     * <P>\n+     * Example pattern:\n+     *\n+     * <pre>\n+     * search(&quot;BranchInstruction NOP ((IfInstruction|GOTO)+ ISTORE Instruction)*&quot;);\n+     * <\/pre>\n+     *\n+     * <p>\n+     * If you alter the instruction list upon a match such that other matching areas are affected, you should call reread()\n+     * to update the finder and call search() again, because the matches are cached.\n+     *\n+     * @param pattern the instruction pattern to search for, where case is ignored\n+     * @param from where to start the search in the instruction list\n+     * @param constraint optional CodeConstraint to check the found code pattern for user-defined constraints\n+     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     *\/\n+    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from, final CodeConstraint constraint) {\n+        final String search = compilePattern(pattern);\n+        int start = -1;\n+        for (int i = 0; i < handles.length; i++) {\n+            if (handles[i] == from) {\n+                start = i; \/\/ Where to start search from (index)\n+                break;\n@@ -374,9 +350,2 @@\n-        \/\/ Add instruction alias to match anything\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = 0; i < NO_OPCODES; i++) {\n-            if (Const.getNoOfOperands(i) != Const.UNDEFINED) { \/\/ Not an invalid opcode\n-                buf.append(makeChar(i));\n-                if (i < NO_OPCODES - 1) {\n-                    buf.append('|');\n-                }\n-            }\n+        if (start == -1) {\n+            throw new ClassGenException(\"Instruction handle \" + from + \" not found in instruction list.\");\n@@ -384,10 +353,12 @@\n-        buf.append(')');\n-        map.put(\"instruction\", buf.toString());\n-    }\n-\n-\n-    private static String precompile( final short from, final short to, final short extra ) {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = from; i <= to; i++) {\n-            buf.append(makeChar(i));\n-            buf.append('|');\n+        final Pattern regex = Pattern.compile(search);\n+        final List<InstructionHandle[]> matches = new ArrayList<>();\n+        final Matcher matcher = regex.matcher(ilString);\n+        while (start < ilString.length() && matcher.find(start)) {\n+            final int startExpr = matcher.start();\n+            final int endExpr = matcher.end();\n+            final int lenExpr = endExpr - startExpr;\n+            final InstructionHandle[] match = getMatch(startExpr, lenExpr);\n+            if (constraint == null || constraint.checkCode(match)) {\n+                matches.add(match);\n+            }\n+            start = endExpr;\n@@ -395,3 +366,1 @@\n-        buf.append(makeChar(extra));\n-        buf.append(\")\");\n-        return buf.toString();\n+        return matches.iterator();\n@@ -400,1 +369,0 @@\n-\n@@ -408,1 +376,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/InstructionFinder.java","additions":228,"deletions":261,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -24,2 +24,1 @@\n-import java.io.FileOutputStream;\n-import java.io.IOException;\n+import java.io.FileNotFoundException;\n@@ -27,0 +26,2 @@\n+import java.io.UnsupportedEncodingException;\n+import java.nio.charset.Charset;\n@@ -31,1 +32,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.ConstantValue;\n@@ -39,2 +39,0 @@\n- *\n- *\n@@ -45,1 +43,1 @@\n-    private final PrintWriter file; \/\/ file to write to\n+    private final PrintWriter printWriter; \/\/ file to write to\n@@ -47,1 +45,1 @@\n-    private final AttributeHTML attribute_html;\n+    private final AttributeHTML attributeHtml;\n@@ -49,19 +47,22 @@\n-\n-    MethodHTML(final String dir, final String class_name, final Method[] methods, final Field[] fields,\n-            final ConstantHTML constant_html, final AttributeHTML attribute_html) throws IOException {\n-        this.className = class_name;\n-        this.attribute_html = attribute_html;\n-        this.constantHtml = constant_html;\n-        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_methods.html\"));\n-        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n-        file.println(\"<TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH><TH ALIGN=LEFT>Type<\/TH>\"\n-                + \"<TH ALIGN=LEFT>Field&nbsp;name<\/TH><\/TR>\");\n-        for (final Field field : fields) {\n-            writeField(field);\n-        }\n-        file.println(\"<\/TABLE>\");\n-        file.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH>\"\n-                + \"<TH ALIGN=LEFT>Return&nbsp;type<\/TH><TH ALIGN=LEFT>Method&nbsp;name<\/TH>\"\n-                + \"<TH ALIGN=LEFT>Arguments<\/TH><\/TR>\");\n-        for (int i = 0; i < methods.length; i++) {\n-            writeMethod(methods[i], i);\n+    MethodHTML(final String dir, final String className, final Method[] methods, final Field[] fields, final ConstantHTML constantHtml,\n+        final AttributeHTML attributeHtml, final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n+        this.className = className;\n+        this.attributeHtml = attributeHtml;\n+        this.constantHtml = constantHtml;\n+        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_methods.html\", charset.name())) {\n+            printWriter = newPrintWriter;\n+            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n+            printWriter.print(charset.name());\n+            printWriter.println(\"\\\"><\/head>\");\n+            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+            printWriter.println(\"<TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH><TH ALIGN=LEFT>Type<\/TH>\" + \"<TH ALIGN=LEFT>Field&nbsp;name<\/TH><\/TR>\");\n+            for (final Field field : fields) {\n+                writeField(field);\n+            }\n+            printWriter.println(\"<\/TABLE>\");\n+            printWriter.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH>\"\n+                + \"<TH ALIGN=LEFT>Return&nbsp;type<\/TH><TH ALIGN=LEFT>Method&nbsp;name<\/TH>\" + \"<TH ALIGN=LEFT>Arguments<\/TH><\/TR>\");\n+            for (int i = 0; i < methods.length; i++) {\n+                writeMethod(methods[i], i);\n+            }\n+            printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n@@ -69,2 +70,0 @@\n-        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n-        file.close();\n@@ -73,1 +72,0 @@\n-\n@@ -78,1 +76,0 @@\n-     * @throws java.io.IOException\n@@ -80,1 +77,1 @@\n-    private void writeField( final Field field ) throws IOException {\n+    private void writeField(final Field field) {\n@@ -86,3 +83,2 @@\n-        file.print(\"<TR><TD><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT><\/TD>\\n<TD>\"\n-                + Class2HTML.referenceType(type) + \"<\/TD><TD><A NAME=\\\"field\" + name + \"\\\">\" + name\n-                + \"<\/A><\/TD>\");\n+        printWriter.print(\"<TR><TD><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT><\/TD>\\n<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD><A NAME=\\\"field\"\n+            + name + \"\\\">\" + name + \"<\/A><\/TD>\");\n@@ -92,1 +88,1 @@\n-            attribute_html.writeAttribute(attributes[i], name + \"@\" + i);\n+            attributeHtml.writeAttribute(attributes[i], name + \"@\" + i);\n@@ -96,1 +92,1 @@\n-                final String str = ((ConstantValue) attributes[i]).toString();\n+                final String str = attributes[i].toString();\n@@ -98,2 +94,1 @@\n-                file.print(\"<TD>= <A HREF=\\\"\" + className + \"_attributes.html#\" + name + \"@\" + i\n-                        + \"\\\" TARGET=\\\"Attributes\\\">\" + str + \"<\/TD>\\n\");\n+                printWriter.print(\"<TD>= <A HREF=\\\"\" + className + \"_attributes.html#\" + name + \"@\" + i + \"\\\" TARGET=\\\"Attributes\\\">\" + str + \"<\/TD>\\n\");\n@@ -103,1 +98,1 @@\n-        file.println(\"<\/TR>\");\n+        printWriter.println(\"<\/TR>\");\n@@ -106,2 +101,1 @@\n-\n-    private void writeMethod( final Method method, final int method_number ) {\n+    private void writeMethod(final Method method, final int methodNumber) {\n@@ -116,1 +110,1 @@\n-        String html_name;\n+        String htmlName;\n@@ -121,2 +115,2 @@\n-        \/* HTML doesn't like names like <clinit> and spaces are places to break\n-         * lines. Both we don't want...\n+        \/*\n+         * HTML doesn't like names like <clinit> and spaces are places to break lines. Both we don't want...\n@@ -125,6 +119,4 @@\n-        html_name = Class2HTML.toHTML(name);\n-        file.print(\"<TR VALIGN=TOP><TD><FONT COLOR=\\\"#FF0000\\\"><A NAME=method\" + method_number\n-                + \">\" + access + \"<\/A><\/FONT><\/TD>\");\n-        file.print(\"<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD>\" + \"<A HREF=\" + className\n-                + \"_code.html#method\" + method_number + \" TARGET=Code>\" + html_name\n-                + \"<\/A><\/TD>\\n<TD>(\");\n+        htmlName = Class2HTML.toHTML(name);\n+        printWriter.print(\"<TR VALIGN=TOP><TD><FONT COLOR=\\\"#FF0000\\\"><A NAME=method\" + methodNumber + \">\" + access + \"<\/A><\/FONT><\/TD>\");\n+        printWriter.print(\"<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD>\" + \"<A HREF=\" + className + \"_code.html#method\" + methodNumber + \" TARGET=Code>\"\n+            + htmlName + \"<\/A><\/TD>\\n<TD>(\");\n@@ -132,1 +124,1 @@\n-            file.print(Class2HTML.referenceType(args[i]));\n+            printWriter.print(Class2HTML.referenceType(args[i]));\n@@ -134,1 +126,1 @@\n-                file.print(\", \");\n+                printWriter.print(\", \");\n@@ -137,1 +129,1 @@\n-        file.print(\")<\/TD><\/TR>\");\n+        printWriter.print(\")<\/TD><\/TR>\");\n@@ -140,2 +132,1 @@\n-            attribute_html.writeAttribute(attributes[i], \"method\" + method_number + \"@\" + i,\n-                    method_number);\n+            attributeHtml.writeAttribute(attributes[i], \"method\" + methodNumber + \"@\" + i, methodNumber);\n@@ -144,1 +135,1 @@\n-                file.print(\"<TR VALIGN=TOP><TD COLSPAN=2><\/TD><TH ALIGN=LEFT>throws<\/TH><TD>\");\n+                printWriter.print(\"<TR VALIGN=TOP><TD COLSPAN=2><\/TD><TH ALIGN=LEFT>throws<\/TH><TD>\");\n@@ -147,1 +138,1 @@\n-                    file.print(constantHtml.referenceConstant(exceptions[j]));\n+                    printWriter.print(constantHtml.referenceConstant(exceptions[j]));\n@@ -149,1 +140,1 @@\n-                        file.print(\", \");\n+                        printWriter.print(\", \");\n@@ -152,1 +143,1 @@\n-                file.println(\"<\/TD><\/TR>\");\n+                printWriter.println(\"<\/TD><\/TR>\");\n@@ -154,4 +145,3 @@\n-                final Attribute[] c_a = ((Code) attributes[i]).getAttributes();\n-                for (int j = 0; j < c_a.length; j++) {\n-                    attribute_html.writeAttribute(c_a[j], \"method\" + method_number + \"@\" + i + \"@\"\n-                            + j, method_number);\n+                final Attribute[] attributeArray = ((Code) attributes[i]).getAttributes();\n+                for (int j = 0; j < attributeArray.length; j++) {\n+                    attributeHtml.writeAttribute(attributeArray[j], \"method\" + methodNumber + \"@\" + i + \"@\" + j, methodNumber);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/MethodHTML.java","additions":53,"deletions":63,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-import java.util.Iterator;\n@@ -57,3 +56,0 @@\n-     *\n-     * @throws IOException\n-     *             an I\/O error occurs accessing the file system\n@@ -61,1 +57,2 @@\n-    public ModularRuntimeImage() throws IOException {\n+    @SuppressWarnings(\"resource\") \/\/ See #close()\n+    public ModularRuntimeImage() {\n@@ -68,2 +65,1 @@\n-     * @param javaHome\n-     *            Path to a Java 9 or greater home.\n+     * @param javaHome Path to a Java 9 or greater home.\n@@ -71,2 +67,1 @@\n-     * @throws IOException\n-     *             an I\/O error occurs accessing the file system\n+     * @throws IOException an I\/O error occurs accessing the file system\n@@ -78,1 +73,1 @@\n-        this.classLoader = new URLClassLoader(new URL[] {jrtFsPath.toUri().toURL() });\n+        this.classLoader = URLClassLoader.newInstance(new URL[] {jrtFsPath.toUri().toURL()});\n@@ -97,0 +92,4 @@\n+    public FileSystem getFileSystem() {\n+        return fileSystem;\n+    }\n+\n@@ -100,2 +99,1 @@\n-     * @param dirPath\n-     *            directory path.\n+     * @param dirPath directory path.\n@@ -103,2 +101,1 @@\n-     * @throws IOException\n-     *             an I\/O error occurs accessing the file system\n+     * @throws IOException an I\/O error occurs accessing the file system\n@@ -109,4 +106,1 @@\n-            final Iterator<Path> iterator = ds.iterator();\n-            while (iterator.hasNext()) {\n-                list.add(iterator.next());\n-            }\n+            ds.forEach(list::add);\n@@ -120,2 +114,1 @@\n-     * @param dirName\n-     *            directory path.\n+     * @param dirName directory path.\n@@ -123,2 +116,1 @@\n-     * @throws IOException\n-     *             an I\/O error occurs accessing the file system\n+     * @throws IOException an I\/O error occurs accessing the file system\n@@ -134,2 +126,1 @@\n-     * @throws IOException\n-     *             an I\/O error occurs accessing the file system\n+     * @throws IOException an I\/O error occurs accessing the file system\n@@ -145,2 +136,1 @@\n-     * @throws IOException\n-     *             an I\/O error occurs accessing the file system\n+     * @throws IOException an I\/O error occurs accessing the file system\n@@ -152,4 +142,0 @@\n-    public FileSystem getFileSystem() {\n-        return fileSystem;\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ModularRuntimeImage.java","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,3 +25,2 @@\n- * Abstract definition of a class repository. Instances may be used\n- * to load classes from different sources and may be used in the\n- * Repository.setRepository method.\n+ * Abstract definition of a class repository. Instances may be used to load classes from different sources and may be\n+ * used in the Repository.setRepository method.\n@@ -29,2 +28,2 @@\n- * @see com.sun.org.apache.bcel.internal.Repository\n- * @LastModified: Jan 2020\n+ * @see org.apache.bcel.Repository\n+ * @LastModified: Feb 2023\n@@ -35,1 +34,1 @@\n-     * Stores the provided class under \"clazz.getClassName()\"\n+     * Clears all entries from cache.\n@@ -37,1 +36,1 @@\n-    void storeClass(JavaClass clazz);\n+    void clear();\n@@ -40,1 +39,1 @@\n-     * Removes class from repository\n+     * Finds the class with the name provided, if the class isn't there, return NULL.\n@@ -42,1 +41,1 @@\n-    void removeClass(JavaClass clazz);\n+    JavaClass findClass(String className);\n@@ -45,1 +44,3 @@\n-     * Finds the class with the name provided, if the class isn't there, return NULL.\n+     * Finds the JavaClass instance for the given run-time class object.\n+     *\n+     * @throws ClassNotFoundException if the class can't be found.\n@@ -47,1 +48,1 @@\n-    JavaClass findClass(String className);\n+    JavaClass loadClass(Class<?> clazz) throws ClassNotFoundException;\n@@ -51,0 +52,2 @@\n+     *\n+     * @throws ClassNotFoundException if the class can't be found.\n@@ -52,1 +55,1 @@\n-    JavaClass loadClass(String className) throws java.lang.ClassNotFoundException;\n+    JavaClass loadClass(String className) throws ClassNotFoundException;\n@@ -55,1 +58,1 @@\n-     * Finds the JavaClass instance for the given run-time class object\n+     * Removes class from repository\n@@ -57,1 +60,1 @@\n-    JavaClass loadClass(Class<?> clazz) throws java.lang.ClassNotFoundException;\n+    void removeClass(JavaClass clazz);\n@@ -60,1 +63,1 @@\n-     * Clears all entries from cache.\n+     * Stores the provided class under \"clazz.getClassName()\"\n@@ -62,1 +65,1 @@\n-    void clear();\n+    void storeClass(JavaClass clazz);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Repository.java","additions":20,"deletions":17,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -32,7 +33,7 @@\n- * This repository is used in situations where a Class is created outside the\n- * realm of a ClassLoader. Classes are loaded from the file systems using the\n- * paths specified in the given class path. By default, this is the value\n- * returned by ClassPath.getClassPath(). <br>\n- * This repository uses a factory design, allowing it to maintain a collection\n- * of different classpaths, and as such It is designed to be used as a singleton\n- * per classpath.\n+ * This repository is used in situations where a Class is created outside the realm of a ClassLoader. Classes are loaded\n+ * from the file systems using the paths specified in the given class path. By default, this is the value returned by\n+ * ClassPath.getClassPath().\n+ * <p>\n+ * This repository uses a factory design, allowing it to maintain a collection of different classpaths, and as such It\n+ * is designed to be used as a singleton per classpath.\n+ * <\/p>\n@@ -42,1 +43,1 @@\n- * @LastModified: May 2021\n+ * @LastModified: Feb 2023\n@@ -57,10 +58,1 @@\n-     * Store a new JavaClass instance into this Repository.\n-     *\/\n-    @Override\n-    public void storeClass(final JavaClass clazz) {\n-        loadedClasses.put(clazz.getClassName(), new SoftReference<>(clazz));\n-        clazz.setRepository(this);\n-        }\n-\n-    \/**\n-     * Remove class from repository\n+     * Clear all entries from cache.\n@@ -69,2 +61,2 @@\n-    public void removeClass(final JavaClass clazz) {\n-        loadedClasses.remove(clazz.getClassName());\n+    public void clear() {\n+        loadedClasses.clear();\n@@ -79,4 +71,1 @@\n-        if (ref == null) {\n-            return null;\n-}\n-        return ref.get();\n+        return ref == null ? null : ref.get();\n@@ -86,6 +75,1 @@\n-     * Finds a JavaClass object by name. If it is already in this Repository, the\n-     * Repository version is returned.\n-     *\n-     * @param className the name of the class\n-     * @return the JavaClass object\n-     * @throws ClassNotFoundException if the class is not in the Repository\n+     * Remove class from repository\n@@ -94,3 +78,2 @@\n-    public JavaClass loadClass(String className) throws ClassNotFoundException {\n-        if ((className == null) || className.isEmpty()) {\n-            throw new IllegalArgumentException(\"Invalid class name \" + className);\n+    public void removeClass(final JavaClass clazz) {\n+        loadedClasses.remove(clazz.getClassName());\n@@ -98,5 +81,0 @@\n-        className = className.replace('\/', '.'); \/\/ Just in case, canonical form\n-        final JavaClass clazz = findClass(className);\n-        if (clazz != null) {\n-            return clazz;\n-        }\n@@ -104,3 +82,8 @@\n-        IOException e = new IOException(\"Couldn't find: \" + className + \".class\");\n-        throw new ClassNotFoundException(\"Exception while looking for class \" +\n-                className + \": \" + e, e);\n+    \/**\n+     * Store a new JavaClass instance into this Repository.\n+     *\/\n+    @Override\n+    public void storeClass(final JavaClass clazz) {\n+        \/\/ Not calling super.storeClass because this subclass maintains the mapping.\n+        loadedClasses.put(clazz.getClassName(), new SoftReference<>(clazz));\n+        clazz.setRepository(this);\n@@ -110,5 +93,3 @@\n-     * Find the JavaClass object for a runtime Class object. If a class with the\n-     * same name is already in this Repository, the Repository version is\n-     * returned. Otherwise, getResourceAsStream() is called on the Class object\n-     * to find the class's representation. If the representation is found, it is\n-     * added to the Repository.\n+     * Finds the JavaClass object for a runtime Class object. If a class with the same name is already in this Repository,\n+     * the Repository version is returned. Otherwise, getResourceAsStream() is called on the Class object to find the\n+     * class's representation. If the representation is found, it is added to the Repository.\n@@ -119,2 +100,1 @@\n-     * @throws ClassNotFoundException if the class is not in the Repository, and\n-     * its representation could not be found\n+     * @throws ClassNotFoundException if the class is not in the Repository, and its representation could not be found\n@@ -128,1 +108,1 @@\n-    }\n+        }\n@@ -134,3 +114,3 @@\n-        JavaClass cls = null;\n-        try (InputStream clsStream = clazz.getResourceAsStream(name + \".class\")) {\n-            return cls = loadClass(clsStream, className);\n+\n+        try (InputStream clsStream = clazz.getResourceAsStream(name + JavaClass.EXTENSION)) {\n+            return loadClass(clsStream, className);\n@@ -138,1 +118,1 @@\n-            return cls;\n+            return null;\n@@ -140,1 +120,0 @@\n-\n@@ -143,3 +122,1 @@\n-\n-    private JavaClass loadClass(final InputStream is, final String className)\n-            throws ClassNotFoundException {\n+    private JavaClass loadClass(final InputStream inputStream, final String className) throws ClassNotFoundException {\n@@ -147,2 +124,2 @@\n-            if (is != null) {\n-                final ClassParser parser = new ClassParser(is, className);\n+            if (inputStream != null) {\n+                final ClassParser parser = new ClassParser(inputStream, className);\n@@ -154,10 +131,1 @@\n-            throw new ClassNotFoundException(\"Exception while looking for class \"\n-                    + className + \": \" + e, e);\n-        } finally {\n-            if (is != null) {\n-                try {\n-                    is.close();\n-                } catch (final IOException e) {\n-                    \/\/ ignored\n-                }\n-            }\n+            throw new ClassNotFoundException(\"Exception while looking for class \" + className + \": \" + e, e);\n@@ -165,2 +133,1 @@\n-        throw new ClassNotFoundException(\"SyntheticRepository could not load \"\n-                + className);\n+        throw new ClassNotFoundException(\"ClassRepository could not load \" + className);\n@@ -170,1 +137,6 @@\n-     * Clear all entries from cache.\n+     * Finds a JavaClass object by name. If it is already in this Repository, the Repository version is returned. Otherwise,\n+     * the Repository's classpath is searched for the class (and it is added to the Repository if found).\n+     *\n+     * @param className the name of the class\n+     * @return the JavaClass object\n+     * @throws ClassNotFoundException if the class is not in the Repository, and could not be found on the classpath\n@@ -173,2 +145,12 @@\n-    public void clear() {\n-        loadedClasses.clear();\n+    public JavaClass loadClass(String className) throws ClassNotFoundException {\n+        if (className == null || className.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid class name \" + className);\n+        }\n+        className = Utility.pathToPackage(className); \/\/ Just in case, canonical form\n+        final JavaClass clazz = findClass(className);\n+        if (clazz != null) {\n+            return clazz;\n+        }\n+        IOException e = new IOException(\"Couldn't find: \" + className + \".class\");\n+        throw new ClassNotFoundException(\"Exception while looking for class \" +\n+                className + \": \" + e, e);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/SyntheticRepository.java","additions":57,"deletions":75,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.xml.internal;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * General utility. Use JdkXmlUtils for XML processing related functions.\n+ *\/\n+public class Utils {\n+    \/**\n+     * Creates a new array with copies of the original array and additional items\n+     * appended to the end of it.\n+     *\n+     * @param original the original array\n+     * @param items items to be appended to the original array\n+     * @return a new array with copies of the original array and additional items\n+     *\/\n+    public static Class<?>[] arraysAppend(final Class<?>[] original, final Class<?>... items) {\n+        if (original == null && items == null) {\n+            return null;\n+        }\n+        if (items == null) {\n+            return Arrays.copyOf(original, original.length);\n+        }\n+        if (original == null) {\n+            return Arrays.copyOf(items, items.length);\n+        }\n+\n+        Class<?>[] result = Arrays.copyOf(original, original.length + items.length);\n+        System.arraycopy(items, 0, result, original.length, items.length);\n+        return result;\n+    }\n+}\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/Utils.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -1,1 +1,1 @@\n-## Apache Commons Byte Code Engineering Library (BCEL) Version 6.5.0\n+## Apache Commons Byte Code Engineering Library (BCEL) Version 6.7.0\n@@ -7,1 +7,1 @@\n-    Copyright 2004-2020 The Apache Software Foundation\n+    Copyright 2004-2022 The Apache Software Foundation\n","filename":"src\/java.xml\/share\/legal\/bcel.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}