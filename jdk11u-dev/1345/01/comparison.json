{"files":[{"patch":"@@ -316,1 +316,1 @@\n-                                             address destination);\n+                                             address destination = NULL);\n@@ -345,1 +345,1 @@\n-  friend NativeCall* nativeCall_overwriting_at(address instr, address destination = NULL) {\n+  friend NativeCall* nativeCall_overwriting_at(address instr, address destination) {\n@@ -414,1 +414,1 @@\n-inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination);\n+inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL);\n@@ -453,1 +453,1 @@\n-  friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination = NULL) {\n+  friend inline NativeFarCall* nativeFarCall_overwriting_at(address instr, address destination) {\n","filename":"src\/hotspot\/cpu\/sparc\/nativeInst_sparc.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -263,0 +263,5 @@\n+      \/\/ On some systems we have mixed cgroups v1 and cgroups v2 controllers (e.g. freezer on cg1 and\n+      \/\/ all relevant controllers on cg2). Only set the cgroup path when we see a hierarchy id of 0.\n+      if (hierarchy_id != 0) {\n+        continue;\n+      }\n@@ -264,0 +269,1 @@\n+        assert(cg_infos[i]._cgroup_path == NULL, \"cgroup path must only be set once\");\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -148,0 +148,4 @@\n+            \/\/ Only the following controllers are important to Java. All\n+            \/\/ other controllers (such as freezer) are ignored and\n+            \/\/ are not considered in the checks below for\n+            \/\/ anyCgroupsV1Controller\/anyCgroupsV2Controller.\n@@ -225,0 +229,6 @@\n+        String name = tokens[1];\n+        if (!name.equals(\"\")) {\n+            \/\/ This must be a v1 controller that we have ignored (e.g., freezer)\n+            assert infos.get(name) == null;\n+            return;\n+        }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -99,1 +99,0 @@\n-\n@@ -103,0 +102,4 @@\n+                    \/\/ Prevent endless loop\n+                    if (w == 0) {\n+                        return out.size();\n+                    }\n@@ -114,1 +117,1 @@\n-                return pos;\n+                return out.size();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ChunksChannel.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -694,2 +694,6 @@\n-                        cc.transferTo(fc);\n-                        fc.force(true);\n+                        long bytes = cc.transferTo(fc);\n+                        Logger.log(LogTag.JFR, LogLevel.INFO, \"Transferred \" + bytes + \" bytes from the disk repository\");\n+                        \/\/ No need to force if no data was transferred, which avoids IOException when device is \/dev\/null\n+                        if (bytes != 0) {\n+                            fc.force(true);\n+                        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecording.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2021, Red Hat Inc.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n@@ -26,0 +26,1 @@\n+ * @bug 8287107\n@@ -76,0 +77,3 @@\n+    private Path cgroupv2CgInfoNoZeroHierarchyOnlyFreezer;\n+    private Path cgroupv2MntInfoNoZeroHierarchyOnlyFreezer;\n+    private Path cgroupv2SelfNoZeroHierarchyOnlyFreezer;\n@@ -180,0 +184,24 @@\n+    \/\/ We have a mix of V1 and V2 controllers, but none of the V1 controllers\n+    \/\/ are used by Java, so the JDK should start in V2 mode.\n+    private String cgroupsNonZeroHierarchyOnlyFreezer =\n+            \"#subsys_name hierarchy  num_cgroups  enabled\\n\" +\n+            \"cpuset  0  171  1\\n\" +\n+            \"cpu  0  171  1\\n\" +\n+            \"cpuacct  0  171  1\\n\" +\n+            \"blkio  0  171  1\\n\" +\n+            \"memory  0  171  1\\n\" +\n+            \"devices  0  171  1\\n\" +\n+            \"freezer  1  1  1\\n\" +\n+            \"net_cls  0  171  1\\n\" +\n+            \"perf_event  0  171  1\\n\" +\n+            \"net_prio  0  171  1\\n\" +\n+            \"hugetlb  0  171  1\\n\" +\n+            \"pids  0  171  1\\n\" +\n+            \"rdma  0  171  1\\n\" +\n+            \"misc  0  171  1\\n\";\n+    private String cgroupv1SelfOnlyFreezerContent = \"1:freezer:\/\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-2.scope\";\n+    private String mntInfoOnlyFreezerInV1 =\n+            \"32 23 0:27 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:9 - cgroup2 cgroup2 rw,nsdelegate,memory_recursiveprot\\n\" +\n+            \"911 32 0:47 \/ \/sys\/fs\/cgroup\/freezer rw,relatime shared:476 - cgroup freezer rw,freezer\\n\";\n+\n@@ -231,0 +259,9 @@\n+\n+            cgroupv2CgInfoNoZeroHierarchyOnlyFreezer = Paths.get(existingDirectory.toString(), \"cgroups_cgv2_non_zero_only_freezer\");\n+            Files.writeString(cgroupv2CgInfoNoZeroHierarchyOnlyFreezer, cgroupsNonZeroHierarchyOnlyFreezer);\n+\n+            cgroupv2SelfNoZeroHierarchyOnlyFreezer = Paths.get(existingDirectory.toString(), \"self_cgroup_non_zero_only_freezer\");\n+            Files.writeString(cgroupv2SelfNoZeroHierarchyOnlyFreezer, cgroupv1SelfOnlyFreezerContent);\n+\n+            cgroupv2MntInfoNoZeroHierarchyOnlyFreezer = Paths.get(existingDirectory.toString(), \"self_mountinfo_cgv2_non_zero_only_freezer\");\n+            Files.writeString(cgroupv2MntInfoNoZeroHierarchyOnlyFreezer, mntInfoOnlyFreezerInV1);\n@@ -338,0 +375,9 @@\n+    public void testNonZeroHierarchyOnlyFreezer(WhiteBox wb) {\n+        String cgroups = cgroupv2CgInfoNoZeroHierarchyOnlyFreezer.toString();\n+        String mountInfo = cgroupv2MntInfoNoZeroHierarchyOnlyFreezer.toString();\n+        String selfCgroup = cgroupv2SelfNoZeroHierarchyOnlyFreezer.toString();\n+        int retval = wb.validateCgroup(cgroups, selfCgroup, mountInfo);\n+        Asserts.assertEQ(CGROUPS_V2, retval, \"All V1 controllers are ignored\");\n+        Asserts.assertTrue(isValidCgroup(retval));\n+        System.out.println(\"testNonZeroHierarchyOnlyFreezer PASSED!\");\n+    }\n@@ -354,0 +400,1 @@\n+            test.testNonZeroHierarchyOnlyFreezer(wb);\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    private static String UNSUPPORTED_OPTION_MESSAGE = \"-XX:TieredCompilation not supported in this VM\";\n+    private static String UNSUPPORTED_OPTION_MESSAGE = \"-XX:+TieredCompilation not supported in this VM\";\n@@ -59,1 +59,1 @@\n-            if (output.getStdout().contains(UNSUPPORTED_OPTION_MESSAGE)) {\n+            if (output.getStderr().contains(UNSUPPORTED_OPTION_MESSAGE)) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/jit\/tiered\/Test.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2022, Red Hat Inc.\n@@ -53,0 +53,1 @@\n+ * @bug 8287107\n@@ -58,1 +59,1 @@\n- * @run junit\/othervm TestCgroupSubsystemFactory\n+ * @run junit\/othervm -esa TestCgroupSubsystemFactory\n@@ -82,0 +83,3 @@\n+    private Path cgroupv2CgInfoNoZeroHierarchyOnlyFreezer;\n+    private Path cgroupv2MntInfoNoZeroHierarchyOnlyFreezer;\n+    private Path cgroupv2SelfNoZeroHierarchyOnlyFreezer;\n@@ -222,0 +226,24 @@\n+    \/\/ We have a mix of V1 and V2 controllers, but none of the V1 controllers\n+    \/\/ are used by Java, so the JDK should start in V2 mode.\n+    private String cgroupsNonZeroHierarchyOnlyFreezer =\n+            \"#subsys_name hierarchy  num_cgroups  enabled\\n\" +\n+            \"cpuset  0  171  1\\n\" +\n+            \"cpu  0  171  1\\n\" +\n+            \"cpuacct  0  171  1\\n\" +\n+            \"blkio  0  171  1\\n\" +\n+            \"memory  0  171  1\\n\" +\n+            \"devices  0  171  1\\n\" +\n+            \"freezer  1  1  1\\n\" +\n+            \"net_cls  0  171  1\\n\" +\n+            \"perf_event  0  171  1\\n\" +\n+            \"net_prio  0  171  1\\n\" +\n+            \"hugetlb  0  171  1\\n\" +\n+            \"pids  0  171  1\\n\" +\n+            \"rdma  0  171  1\\n\" +\n+            \"misc  0  171  1\\n\";\n+    private String cgroupv1SelfOnlyFreezerContent = \"1:freezer:\/\\n\" +\n+            \"0::\/user.slice\/user-1000.slice\/session-2.scope\";\n+    private String mntInfoOnlyFreezerInV1 =\n+            \"32 23 0:27 \/ \/sys\/fs\/cgroup rw,nosuid,nodev,noexec,relatime shared:9 - cgroup2 cgroup2 rw,nsdelegate,memory_recursiveprot\\n\" +\n+            \"911 32 0:47 \/ \/sys\/fs\/cgroup\/freezer rw,relatime shared:476 - cgroup freezer rw,freezer\\n\";\n+\n@@ -280,0 +308,9 @@\n+\n+            cgroupv2CgInfoNoZeroHierarchyOnlyFreezer = Paths.get(existingDirectory.toString(), \"cgroups_cgv2_non_zero_only_freezer\");\n+            Files.writeString(cgroupv2CgInfoNoZeroHierarchyOnlyFreezer, cgroupsNonZeroHierarchyOnlyFreezer);\n+\n+            cgroupv2SelfNoZeroHierarchyOnlyFreezer = Paths.get(existingDirectory.toString(), \"self_cgroup_non_zero_only_freezer\");\n+            Files.writeString(cgroupv2SelfNoZeroHierarchyOnlyFreezer, cgroupv1SelfOnlyFreezerContent);\n+\n+            cgroupv2MntInfoNoZeroHierarchyOnlyFreezer = Paths.get(existingDirectory.toString(), \"self_mountinfo_cgv2_non_zero_only_freezer\");\n+            Files.writeString(cgroupv2MntInfoNoZeroHierarchyOnlyFreezer, mntInfoOnlyFreezerInV1);\n@@ -406,0 +443,20 @@\n+    @Test\n+    public void testNonZeroHierarchyOnlyFreezer() throws IOException {\n+        String cgroups = cgroupv2CgInfoNoZeroHierarchyOnlyFreezer.toString();\n+        String mountInfo = cgroupv2MntInfoNoZeroHierarchyOnlyFreezer.toString();\n+        String selfCgroup = cgroupv2SelfNoZeroHierarchyOnlyFreezer.toString();\n+        Optional<CgroupTypeResult> result = CgroupSubsystemFactory.determineType(mountInfo, cgroups, selfCgroup);\n+\n+        assertTrue(\"Expected non-empty cgroup result\", result.isPresent());\n+        CgroupTypeResult res = result.get();\n+\n+        assertTrue(\"if all mounted v1 controllers are ignored, we should user cgroups v2\", res.isCgroupV2());\n+        CgroupInfo memoryInfo = res.getInfos().get(\"memory\");\n+        assertEquals(\"\/user.slice\/user-1000.slice\/session-2.scope\", memoryInfo.getCgroupPath());\n+        CgroupInfo cpuInfo = res.getInfos().get(\"cpu\");\n+        assertEquals(memoryInfo.getCgroupPath(), cpuInfo.getCgroupPath());\n+        assertEquals(memoryInfo.getMountPoint(), cpuInfo.getMountPoint());\n+        assertEquals(memoryInfo.getMountRoot(), cpuInfo.getMountRoot());\n+        assertEquals(\"\/sys\/fs\/cgroup\", cpuInfo.getMountPoint());\n+    }\n+\n","filename":"test\/jdk\/jdk\/internal\/platform\/cgroup\/TestCgroupSubsystemFactory.java","additions":59,"deletions":2,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.api.recording.dump;\n+\n+import java.nio.file.Path;\n+\n+import jdk.jfr.Recording;\n+\n+\/**\n+ * @test\n+ * @summary Tests that it's possible to dump to \/dev\/null without a livelock\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm -Xlog:jfr jdk.jfr.api.recording.dump.TestDumpDevNull\n+ *\/\n+public class TestDumpDevNull {\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r1 = new Recording()) {\n+            r1.setDestination(Path.of(\"\/dev\/null\"));\n+            r1.start();\n+            \/\/ Force a chunk rotation which ensures that jdk.jfr.internal.ChunkChannel\n+            \/\/ invokes FileChannel::transferFrom(ReadableByteChannel, position, count) twice.\n+            \/\/ FileChannel will return 0 the second time because position exceeds\n+            \/\/ FileChannel::size(), which is always 0 for \/dev\/null\n+            \/\/ Without proper handling of return value 0, the ChunkChannel will spin indefinitely.\n+            try (Recording r2 = new Recording()) {\n+                r2.start();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/dump\/TestDumpDevNull.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"}]}