{"files":[{"patch":"@@ -644,1 +644,1 @@\n-  $1_JTREG_MAX_RAM_PERCENTAGE := $$(shell $$(EXPR) 25 \/ $$($1_JTREG_JOBS))\n+  $1_JTREG_MAX_RAM_PERCENTAGE := $$(shell $(AWK) 'BEGIN { print 25 \/ $$($1_JTREG_JOBS); }')\n","filename":"make\/RunTests.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -345,3 +345,0 @@\n-  \/\/ To call this, one must have the MultiArray_lock held, but the _klasses list still has lock free reads.\n-  assert_locked_or_safepoint(MultiArray_lock);\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1630,3 +1630,0 @@\n-  \/\/ To get a consistent list of classes we need MultiArray_lock to ensure\n-  \/\/ array classes aren't created.\n-  MutexLocker locker(MultiArray_lock);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2381,3 +2381,0 @@\n-    \/\/ To get a consistent list of classes we need MultiArray_lock to ensure\n-    \/\/ array classes aren't observed while they are being restored.\n-     MutexLocker ml(MultiArray_lock);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -121,0 +121,3 @@\n+    int so_rv;\n+    SOCKET s = (SOCKET)fd;\n+    int type = 0, optlen = sizeof(type);\n@@ -128,0 +131,10 @@\n+    so_rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&type, &optlen);\n+\n+    \/**\n+     * Windows has a very long socket connect timeout of 2 seconds.\n+     * If it's the loopback adapter we can shorten the wait interval.\n+     *\/\n+    if (so_rv == 0 && type == SOCK_STREAM && IS_LOOPBACK_ADDRESS(&sa)) {\n+        NET_EnableFastTcpLoopbackConnect(fd);\n+    }\n+\n","filename":"src\/java.base\/windows\/native\/libnet\/PlainSocketImpl.c","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -757,0 +757,51 @@\n+int\n+IsWindows10RS3OrGreater() {\n+    OSVERSIONINFOEXW osvi = { sizeof(osvi), 0, 0, 0, 0, {0}, 0, 0 };\n+    DWORDLONG const cond_mask = VerSetConditionMask(\n+        VerSetConditionMask(\n+          VerSetConditionMask(\n+            0, VER_MAJORVERSION, VER_GREATER_EQUAL),\n+               VER_MINORVERSION, VER_GREATER_EQUAL),\n+               VER_BUILDNUMBER,  VER_GREATER_EQUAL);\n+\n+    osvi.dwMajorVersion = HIBYTE(_WIN32_WINNT_WIN10);\n+    osvi.dwMinorVersion = LOBYTE(_WIN32_WINNT_WIN10);\n+    osvi.dwBuildNumber  = 16299; \/\/ RS3 (Redstone 3)\n+\n+    return VerifyVersionInfoW(&osvi, VER_MAJORVERSION | VER_MINORVERSION | VER_BUILDNUMBER, cond_mask) != 0;\n+}\n+\n+\/**\n+ * Shortens the default Windows socket\n+ * connect timeout. Recommended for usage\n+ * on the loopback adapter only.\n+ *\/\n+JNIEXPORT jint JNICALL\n+NET_EnableFastTcpLoopbackConnect(int fd) {\n+    TCP_INITIAL_RTO_PARAMETERS rto = {\n+        TCP_INITIAL_RTO_UNSPECIFIED_RTT,    \/\/ Use the default or overriden by the Administrator\n+        1                                   \/\/ Minimum possible value before Windows 10 RS3\n+    };\n+\n+    \/**\n+     * In Windows 10 RS3+ we can use the no retransmissions flag to\n+     * completely remove the timeout delay, which is fixed to 500ms\n+     * if Windows receives RST when the destination port is not open.\n+     *\/\n+    if (IsWindows10RS3OrGreater()) {\n+        rto.MaxSynRetransmissions = TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS;\n+    }\n+\n+    DWORD result_byte_count = -1;\n+    int result = WSAIoctl(fd,                       \/\/ descriptor identifying a socket\n+                          SIO_TCP_INITIAL_RTO,      \/\/ dwIoControlCode\n+                          &rto,                     \/\/ pointer to TCP_INITIAL_RTO_PARAMETERS structure\n+                          sizeof(rto),              \/\/ size, in bytes, of the input buffer\n+                          NULL,                     \/\/ pointer to output buffer\n+                          0,                        \/\/ size of output buffer\n+                          &result_byte_count,       \/\/ number of bytes returned\n+                          NULL,                     \/\/ OVERLAPPED structure\n+                          NULL);                    \/\/ completion routine\n+    return (result == SOCKET_ERROR) ? WSAGetLastError() : 0;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include <mstcpip.h>\n@@ -89,0 +90,24 @@\n+\/**\n+ * With dual socket implementation the\n+ * IPv4 addresseses might be mapped as IPv6.\n+ * The IPv4 loopback adapter address ranges (127.0.0.0 through 127.255.255.255) will\n+ * be mapped as the following IPv6 ::ffff:127.0.0.0 through ::ffff:127.255.255.255.\n+ * For example, this is done by NET_InetAddressToSockaddr.\n+ *\/\n+#define IN6_IS_ADDR_V4MAPPED_LOOPBACK(x) ( \\\n+    (((x)->s6_words[0] == 0)               &&  \\\n+     ((x)->s6_words[1] == 0)               &&  \\\n+     ((x)->s6_words[2] == 0)               &&  \\\n+     ((x)->s6_words[3] == 0)               &&  \\\n+     ((x)->s6_words[4] == 0)               &&  \\\n+     ((x)->s6_words[5] == 0xFFFF)          &&  \\\n+     (((x)->s6_words[6] & 0x00FF) == 0x007F)) \\\n+)\n+\n+\/**\n+ * Check for IPv4 loopback adapter address ranges (127.0.0.0 through 127.255.255.255)\n+ *\/\n+#define IN4_IS_ADDR_NETLONG_LOOPBACK(l) ( \\\n+    ((l & 0xFF000000) == 0x7F000000) \\\n+)\n+\n@@ -91,2 +116,3 @@\n-        (ntohl((x)->sa4.sin_addr.s_addr) == INADDR_LOOPBACK) : \\\n-        (IN6ADDR_ISLOOPBACK(x)) \\\n+        (IN4_IS_ADDR_NETLONG_LOOPBACK(ntohl((x)->sa4.sin_addr.s_addr))) : \\\n+        ((IN6_IS_ADDR_LOOPBACK(&(x)->sa6.sin6_addr)) || \\\n+         (IN6_IS_ADDR_V4MAPPED_LOOPBACK(&(x)->sa6.sin6_addr))) \\\n@@ -122,0 +148,2 @@\n+JNIEXPORT jint JNICALL NET_EnableFastTcpLoopbackConnect(int fd);\n+\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.h","additions":30,"deletions":2,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    int so_rv;\n@@ -199,0 +200,1 @@\n+    int type = 0, optlen = sizeof(type);\n@@ -204,0 +206,10 @@\n+    so_rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&type, &optlen);\n+\n+    \/**\n+     * Windows has a very long socket connect timeout of 2 seconds.\n+     * If it's the loopback adapter we can shorten the wait interval.\n+     *\/\n+    if (so_rv == 0 && type == SOCK_STREAM && IS_LOOPBACK_ADDRESS(&sa)) {\n+        NET_EnableFastTcpLoopbackConnect((jint)s);\n+    }\n+\n@@ -214,3 +226,1 @@\n-        int type = 0, optlen = sizeof(type);\n-        rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&type, &optlen);\n-        if (rv == 0 && type == SOCK_DGRAM) {\n+        if (so_rv == 0 && type == SOCK_DGRAM) {\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/Net.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -171,1 +171,0 @@\n-java\/awt\/Focus\/6382144\/EndlessLoopTest.java 8198617 macosx-all\n@@ -173,2 +172,0 @@\n-java\/awt\/Focus\/8073453\/AWTFocusTransitionTest.java 8136517 macosx-all\n-java\/awt\/Focus\/8073453\/SwingFocusTransitionTest.java 8136517 macosx-all\n@@ -761,1 +758,0 @@\n-javax\/swing\/text\/StyledEditorKit\/4506788\/bug4506788.java 8233562 macosx-all\n","filename":"test\/jdk\/ProblemList.txt","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-  @author oleg.sukhodolsky: area=awt.focus\n@@ -60,0 +59,1 @@\n+import javax.swing.SwingUtilities;\n@@ -66,0 +66,3 @@\n+    static JFrame frame;\n+    static JTextField t1;\n+    static JButton button;\n@@ -67,2 +70,1 @@\n-\n-    private static void init()\n+    private static void init() throws Exception\n@@ -72,7 +74,31 @@\n-        JFrame frame = new JFrame();\n-        final JDialog dialog = new JDialog(frame, true);\n-        JButton button = new JButton(\"press me\");\n-        button.addActionListener(new ActionListener() {\n-                public void actionPerformed(ActionEvent ae) {\n-                    dialog.dispose();\n-                }\n+        try {\n+            SwingUtilities.invokeAndWait(() -> {\n+                frame = new JFrame();\n+                final JDialog dialog = new JDialog(frame, true);\n+                button = new JButton(\"press me\");\n+                button.addActionListener(new ActionListener() {\n+                    public void actionPerformed(ActionEvent ae) {\n+                        dialog.dispose();\n+                    }\n+                });\n+                dialog.getContentPane().add(button);\n+                dialog.setLocationRelativeTo(null);\n+                dialog.pack();\n+\n+                t1 = new JTextField();\n+                t1.setInputVerifier(new InputVerifier() {\n+                    public boolean verify(JComponent input) {\n+                        n_iv_calls++;\n+                        if (n_iv_calls == 1) {\n+                            dialog.setVisible(true);\n+                        }\n+                        return true;\n+                    }\n+                });\n+                JTextField t2 = new JTextField();\n+\n+                frame.getContentPane().add(t1, BorderLayout.NORTH);\n+                frame.getContentPane().add(t2, BorderLayout.SOUTH);\n+                frame.setLocationRelativeTo(null);\n+                frame.setSize(200, 200);\n+                frame.setVisible(true);\n@@ -80,14 +106,0 @@\n-        dialog.getContentPane().add(button);\n-        dialog.pack();\n-\n-        JTextField t1 = new JTextField();\n-        t1.setInputVerifier(new InputVerifier() {\n-            public boolean verify(JComponent input) {\n-                n_iv_calls++;\n-                if (n_iv_calls == 1) {\n-                    dialog.setVisible(true);\n-                }\n-                return true;\n-            }\n-        });\n-        JTextField t2 = new JTextField();\n@@ -95,0 +107,6 @@\n+            Robot r = null;\n+            try {\n+                r = new Robot();\n+            } catch (AWTException e) {\n+                EndlessLoopTest.fail(e);\n+            }\n@@ -96,4 +114,4 @@\n-        frame.getContentPane().add(t1, BorderLayout.NORTH);\n-        frame.getContentPane().add(t2, BorderLayout.SOUTH);\n-        frame.setSize(200, 200);\n-        frame.setVisible(true);\n+            try {\n+                r.setAutoDelay(100);\n+                r.waitForIdle();\n+                r.delay(1000);\n@@ -101,6 +119,2 @@\n-        Robot r = null;\n-        try {\n-            r = new Robot();\n-        } catch (AWTException e) {\n-            EndlessLoopTest.fail(e);\n-        }\n+                mouseClickOnComp(r, t1);\n+                r.waitForIdle();\n@@ -108,5 +122,13 @@\n-        try {\n-            r.waitForIdle();\n-\n-            mouseClickOnComp(r, t1);\n-            r.waitForIdle();\n+                if (!t1.isFocusOwner()) {\n+                    throw new RuntimeException(\"t1 is not a focus owner\");\n+                }\n+                n_iv_calls = 0;\n+                r.keyPress(KeyEvent.VK_TAB);\n+                r.keyRelease(KeyEvent.VK_TAB);\n+                r.waitForIdle();\n+\n+                mouseClickOnComp(r, button);\n+                r.waitForIdle();\n+            } catch (Exception e) {\n+                EndlessLoopTest.fail(e);\n+            }\n@@ -114,2 +136,2 @@\n-            if (!t1.isFocusOwner()) {\n-                throw new RuntimeException(\"t1 is not a focus owner\");\n+            if (n_iv_calls != 1) {\n+                EndlessLoopTest.fail(new RuntimeException(\"InputVerifier was called \" + n_iv_calls + \" times\"));\n@@ -117,11 +139,0 @@\n-            n_iv_calls = 0;\n-            r.keyPress(KeyEvent.VK_TAB);\n-            r.delay(10);\n-            r.keyRelease(KeyEvent.VK_TAB);\n-            r.waitForIdle();\n-\n-            mouseClickOnComp(r, button);\n-            r.waitForIdle();\n-        } catch (Exception e) {\n-            EndlessLoopTest.fail(e);\n-        }\n@@ -129,2 +140,7 @@\n-        if (n_iv_calls != 1) {\n-            EndlessLoopTest.fail(new RuntimeException(\"InputVerifier was called \" + n_iv_calls + \" times\"));\n+            EndlessLoopTest.pass();\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n@@ -132,3 +148,0 @@\n-\n-        EndlessLoopTest.pass();\n-\n@@ -143,4 +156,3 @@\n-        r.delay(10);\n-        r.mousePress(InputEvent.BUTTON1_MASK);\n-        r.delay(10);\n-        r.mouseRelease(InputEvent.BUTTON1_MASK);\n+        r.waitForIdle();\n+        r.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        r.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n@@ -173,1 +185,1 @@\n-    public static void main( String args[] ) throws InterruptedException\n+    public static void main( String args[] ) throws Exception\n","filename":"test\/jdk\/java\/awt\/Focus\/6382144\/EndlessLoopTest.java","additions":75,"deletions":63,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @author Dmitry Markov\n@@ -34,1 +33,8 @@\n-import java.awt.*;\n+import java.awt.Button;\n+import java.awt.Component;\n+import java.awt.DefaultFocusTraversalPolicy;\n+import java.awt.Frame;\n+import java.awt.GridLayout;\n+import java.awt.Panel;\n+import java.awt.Robot;\n+import java.awt.TextField;\n@@ -46,1 +52,1 @@\n-        robot.setAutoDelay(50);\n+        robot.setAutoDelay(100);\n@@ -104,0 +110,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -109,1 +116,2 @@\n-            throw new RuntimeException(\"Test Failed! Incorrect focus owner: \" + frame.getFocusOwner() +\n+            throw new RuntimeException(\"Test Failed! Incorrect focus \" +\n+                    \"owner: \" + frame.getFocusOwner() +\n@@ -114,1 +122,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/Focus\/8073453\/AWTFocusTransitionTest.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n- * @author Dmitry Markov\n@@ -34,2 +33,10 @@\n-import javax.swing.*;\n-import java.awt.*;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.JPanel;\n+import javax.swing.JTextField;\n+import javax.swing.LayoutFocusTraversalPolicy;\n+import javax.swing.SwingUtilities;\n+import java.awt.Component;\n+import java.awt.DefaultFocusTraversalPolicy;\n+import java.awt.GridLayout;\n+import java.awt.Robot;\n@@ -47,1 +54,1 @@\n-        robot.setAutoDelay(50);\n+        robot.setAutoDelay(100);\n@@ -115,0 +122,1 @@\n+        frame.setLocationRelativeTo(null);\n@@ -118,1 +126,2 @@\n-    private static void checkFocusOwner(final Component component) throws Exception {\n+    private static void checkFocusOwner(final Component component)\n+            throws Exception {\n@@ -123,1 +132,2 @@\n-                    throw new RuntimeException(\"Test Failed! Incorrect focus owner: \" + frame.getFocusOwner() +\n+                    throw new RuntimeException(\"Test Failed! Incorrect focus\" +\n+                            \" owner: \" + frame.getFocusOwner() +\n@@ -130,1 +140,0 @@\n-\n","filename":"test\/jdk\/java\/awt\/Focus\/8073453\/SwingFocusTransitionTest.java","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- * @requires vm.gc != \"Z\"\n+ * @requires vm.gc != \"Z\" & vm.gc != \"Shenandoah\"\n","filename":"test\/jdk\/java\/lang\/management\/ManagementFactory\/MXBeanException.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.awt.Toolkit;\n@@ -41,2 +40,0 @@\n-import sun.awt.SunToolkit;\n-\n@@ -50,1 +47,0 @@\n-   @modules java.desktop\/sun.awt\n@@ -61,1 +57,0 @@\n-        final SunToolkit toolkit = ((SunToolkit) Toolkit.getDefaultToolkit());\n@@ -97,1 +92,1 @@\n-        toolkit.realSync();\n+        robot.waitForIdle();\n@@ -106,1 +101,1 @@\n-        toolkit.realSync();\n+        robot.waitForIdle();\n@@ -124,1 +119,1 @@\n-        toolkit.realSync();\n+        robot.waitForIdle();\n","filename":"test\/jdk\/javax\/swing\/JPopupMenu\/7156657\/bug7156657.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+            robot.setAutoDelay(100);\n@@ -81,1 +82,0 @@\n-        robot.setAutoDelay(50);\n","filename":"test\/jdk\/javax\/swing\/text\/StyledEditorKit\/4506788\/bug4506788.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,1 @@\n+        long timeout = 10_000;\n@@ -56,1 +57,1 @@\n-        while (!parsingDone && exception == null && System.currentTimeMillis() - s < 5_000) {\n+        while (!parsingDone && exception == null && System.currentTimeMillis() - s < timeout) {\n@@ -63,1 +64,1 @@\n-        if (took > 5_000) {\n+        if (took > timeout) {\n","filename":"test\/jdk\/javax\/swing\/text\/html\/parser\/Parser\/8078268\/bug8078268.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"}]}