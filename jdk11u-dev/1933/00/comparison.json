{"files":[{"patch":"@@ -127,1 +127,1 @@\n-        if (FileUtils.areFileSystemsAccessible()) {\n+        if (FileUtils.areAllMountPointsAccessible()) {\n","filename":"test\/jdk\/java\/nio\/file\/FileStore\/Basic.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+import java.io.BufferedReader;\n+import java.io.InputStreamReader;\n@@ -44,0 +46,2 @@\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n@@ -241,0 +245,87 @@\n+    \/**\n+     * Checks whether all file systems are accessible. This is performed\n+     * by checking free disk space on all mounted file systems via a\n+     * separate, spawned process. File systems are considered to be\n+     * accessible if this process completes successfully before a given\n+     * fixed duration has elapsed.\n+     *\n+     * @implNote On Unix this executes the {@code df} command in a separate\n+     * process and on Windows always returns {@code true}.\n+     *\n+     * @return whether file systems appear to be accessible\n+     *\n+     * @throws RuntimeException if there are duplicate mount points or some\n+     * other execution problem occurs\n+     *\/\n+    public static boolean areAllMountPointsAccessible() {\n+        final AtomicBoolean areMountPointsOK = new AtomicBoolean(true);\n+        if (!IS_WINDOWS) {\n+            Thread thr = new Thread(() -> {\n+                try {\n+                    Process proc = new ProcessBuilder(\"df\").start();\n+                    BufferedReader reader = new BufferedReader\n+                            (new InputStreamReader(proc.getInputStream()));\n+                    \/\/ Skip the first line as it is the \"df\" output header.\n+                    if (reader.readLine() != null ) {\n+                        String prevMountPoint = null, mountPoint = null;\n+                        while ((mountPoint = reader.readLine()) != null) {\n+                            if (prevMountPoint != null &&\n+                                    mountPoint.equals(prevMountPoint)) {\n+                                throw new RuntimeException\n+                                        (\"System configuration error: \" +\n+                                                \"duplicate mount point \" + mountPoint +\n+                                                \" detected\");\n+                            }\n+                            prevMountPoint = mountPoint;\n+                        }\n+                    }\n+\n+                    try {\n+                        proc.waitFor(90, TimeUnit.SECONDS);\n+                    } catch (InterruptedException ignored) {\n+                    }\n+                    try {\n+                        int exitValue = proc.exitValue();\n+                        if (exitValue != 0) {\n+                            System.err.printf(\"df process exited with %d != 0%n\",\n+                                    exitValue);\n+                            areMountPointsOK.set(false);\n+                        }\n+                    } catch (IllegalThreadStateException ignored) {\n+                        System.err.println(\"df command apparently hung\");\n+                        areMountPointsOK.set(false);\n+                    }\n+                } catch (IOException ioe) {\n+                    throw new RuntimeException(ioe);\n+                };\n+            });\n+\n+            final AtomicReference throwableReference =\n+                    new AtomicReference<Throwable>();\n+            thr.setUncaughtExceptionHandler(\n+                    new Thread.UncaughtExceptionHandler() {\n+                        public void uncaughtException(Thread t, Throwable e) {\n+                            throwableReference.set(e);\n+                        }\n+                    });\n+\n+            thr.start();\n+            try {\n+                thr.join(120*1000L);\n+            } catch (InterruptedException ie) {\n+                throw new RuntimeException(ie);\n+            }\n+\n+            Throwable uncaughtException = (Throwable)throwableReference.get();\n+            if (uncaughtException != null) {\n+                throw new RuntimeException(uncaughtException);\n+            }\n+\n+            if (thr.isAlive()) {\n+                throw new RuntimeException(\"df thread did not join in time\");\n+            }\n+        }\n+\n+        return areMountPointsOK.get();\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/util\/FileUtils.java","additions":92,"deletions":1,"binary":false,"changes":93,"status":"modified"}]}