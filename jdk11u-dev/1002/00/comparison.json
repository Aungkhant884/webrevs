{"files":[{"patch":"@@ -255,1 +255,1 @@\n-    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, iffast_pred, loop);\n+    ProjNode* fast_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, iffast_pred);\n@@ -257,1 +257,1 @@\n-    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, uncommon_proj, reason, ifslow_pred, loop);\n+    ProjNode* slow_proj = clone_skeleton_predicate_for_unswitched_loops(iff, predicate_proj, reason, ifslow_pred);\n@@ -283,4 +283,4 @@\n-ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj,\n-                                                                    Deoptimization::DeoptReason reason, ProjNode* output_proj,\n-                                                                    IdealLoopTree* loop) {\n-  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, predicate, uncommon_proj, output_proj, loop);\n+ProjNode* PhaseIdealLoop::clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                                        Deoptimization::DeoptReason reason,\n+                                                                        ProjNode* output_proj) {\n+  Node* bol = clone_skeleton_predicate_bool(iff, NULL, NULL, output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1181,1 +1181,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, opaque_init, NULL, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, opaque_init, NULL, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1184,1 +1185,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, stride, predicate, uncommon_proj, current_proj, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, predicate, uncommon_proj,\n+                                                                   current_proj, outer_loop, prev_proj);\n@@ -1261,2 +1263,1 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                    Node* control, IdealLoopTree* outer_loop) {\n+Node* PhaseIdealLoop::clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control) {\n@@ -1338,3 +1339,3 @@\n-Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n-                                                             Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n-  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, predicate, uncommon_proj, control, outer_loop);\n+Node* PhaseIdealLoop::clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj,\n+                                                                     Node* control, IdealLoopTree* outer_loop, Node* input_proj) {\n+  Node* result = clone_skeleton_predicate_bool(iff, new_init, new_stride, control);\n@@ -1354,2 +1355,2 @@\n-  register_control(new_iff, outer_loop->_parent, input_proj);\n-  register_control(proj, outer_loop->_parent, new_iff);\n+  register_control(new_iff, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, input_proj);\n+  register_control(proj, outer_loop == _ltree_root ? _ltree_root : outer_loop->_parent, new_iff);\n@@ -1438,1 +1439,2 @@\n-  Node *main_exit = insert_post_loop(loop, old_new, main_head, main_end, incr, limit, post_head);\n+  Node* post_incr = incr;\n+  Node* main_exit = insert_post_loop(loop, old_new, main_head, main_end, post_incr, limit, post_head);\n@@ -1538,0 +1540,1 @@\n+  copy_skeleton_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n@@ -1660,0 +1663,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1706,0 +1710,1 @@\n+  copy_skeleton_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n@@ -1722,3 +1727,3 @@\n-Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                                       CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                                       Node *incr, Node *limit, CountedLoopNode *&post_head) {\n+Node *PhaseIdealLoop::insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                                       CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                                       Node*& incr, Node* limit, CountedLoopNode*& post_head) {\n@@ -1809,2 +1814,2 @@\n-  Node* castii = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n-  assert(castii != NULL, \"no castII inserted\");\n+  incr = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n+  assert(incr != NULL, \"no castII inserted\");\n@@ -1852,1 +1857,2 @@\n-        prev_proj = clone_skeleton_predicate_for_main_loop(iff, init, max_value, entry, proj, ctrl, outer_loop, prev_proj);\n+        prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, max_value, entry, proj, ctrl, outer_loop,\n+                                                                   prev_proj);\n@@ -1864,0 +1870,28 @@\n+void PhaseIdealLoop::copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride) {\n+  \/\/ Go over the skeleton predicates of the main loop and make a copy for the post loop with its initial iv value and\n+  \/\/ stride as inputs.\n+  Node* post_loop_entry = post_loop_head->in(LoopNode::EntryControl);\n+  Node* main_loop_entry = main_loop_head->in(LoopNode::EntryControl);\n+  IdealLoopTree* post_loop = get_loop(post_loop_head);\n+\n+  Node* ctrl = main_loop_entry;\n+  Node* prev_proj = post_loop_entry;\n+  while (ctrl != NULL && ctrl->is_Proj() && ctrl->in(0)->is_If()) {\n+    IfNode* iff = ctrl->in(0)->as_If();\n+    ProjNode* proj = iff->proj_out(1 - ctrl->as_Proj()->_con);\n+    if (proj->unique_ctrl_out()->Opcode() != Op_Halt) {\n+      break;\n+    }\n+    if (iff->in(1)->Opcode() == Op_Opaque4 && skeleton_predicate_has_opaque(iff)) {\n+      prev_proj = clone_skeleton_predicate_for_main_or_post_loop(iff, init, stride, ctrl, proj, post_loop_entry,\n+                                                                 post_loop, prev_proj);\n+      assert(!skeleton_predicate_has_opaque(prev_proj->in(0)->as_If()), \"unexpected\");\n+    }\n+    ctrl = ctrl->in(0)->in(0);\n+  }\n+  if (prev_proj != post_loop_entry) {\n+    _igvn.replace_input_of(post_loop_head, LoopNode::EntryControl, prev_proj);\n+    set_idom(post_loop_head, prev_proj, dom_depth(post_loop_head));\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":50,"deletions":16,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -1342,0 +1342,1 @@\n+  Node* ctrl = in(LoopNode::EntryControl);\n@@ -1343,2 +1344,3 @@\n-    Node* ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n-\n+    ctrl = skip_strip_mined()->in(LoopNode::EntryControl);\n+  }\n+  if (is_main_loop() || is_post_loop()) {\n@@ -1347,1 +1349,1 @@\n-  return in(LoopNode::EntryControl);\n+  return ctrl;\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -798,4 +798,3 @@\n-  Node* clone_skeleton_predicate_for_main_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                               IdealLoopTree* outer_loop, Node* input_proj);\n-  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n-                                      IdealLoopTree* outer_loop);\n+  Node* clone_skeleton_predicate_for_main_or_post_loop(Node* iff, Node* new_init, Node* new_stride, Node* predicate, Node* uncommon_proj, Node* control,\n+                                                       IdealLoopTree* outer_loop, Node* input_proj);\n+  Node* clone_skeleton_predicate_bool(Node* iff, Node* new_init, Node* new_stride, Node* control);\n@@ -804,0 +803,1 @@\n+  void copy_skeleton_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init, Node* stride);\n@@ -1100,3 +1100,3 @@\n-  Node *insert_post_loop(IdealLoopTree *loop, Node_List &old_new,\n-                         CountedLoopNode *main_head, CountedLoopEndNode *main_end,\n-                         Node *incr, Node *limit, CountedLoopNode *&post_head);\n+  Node *insert_post_loop(IdealLoopTree* loop, Node_List& old_new,\n+                         CountedLoopNode* main_head, CountedLoopEndNode* main_end,\n+                         Node*& incr, Node* limit, CountedLoopNode*& post_head);\n@@ -1349,2 +1349,3 @@\n-  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate, Node* uncommon_proj, Deoptimization::DeoptReason reason,\n-                                                          ProjNode* output_proj, IdealLoopTree* loop);\n+  ProjNode* clone_skeleton_predicate_for_unswitched_loops(Node* iff, ProjNode* predicate,\n+                                                          Deoptimization::DeoptReason reason,\n+                                                          ProjNode* output_proj);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8275330\n+ * @summary C2: assert(n->is_Root() || n->is_Region() || n->is_Phi() || n->is_MachMerge() || def_block->dominates(block)) failed: uses must be dominated by definitions\n+ *\n+ * @run main\/othervm -Xmx512m -XX:+UnlockDiagnosticVMOptions -Xcomp -XX:CompileOnly=TestDeadPostLoopBecausePredicate TestDeadPostLoopBecausePredicate\n+ *\n+ *\/\n+\n+\n+public class TestDeadPostLoopBecausePredicate {\n+\n+    public static final int N = 400;\n+\n+    public static int iFld=54270;\n+    public static int iFld1=-4;\n+    public int iFld2=201;\n+\n+    public int mainTest(String[] strArr1) {\n+\n+        int i=0, i17=8052, i19=22380, i20=60894, iArr[]=new int[N];\n+        init(iArr, 4);\n+\n+        i = 1;\n+        do {\n+            for (i17 = 5; i17 < 114; i17++) {\n+                switch ((i17 % 7) + 126) {\n+                case 126:\n+                    for (i19 = 2; i19 > i; i19 -= 3) {\n+                        try {\n+                            i20 = (iFld2 % TestDeadPostLoopBecausePredicate.iFld1);\n+                            i20 = (iArr[i19 - 1] % TestDeadPostLoopBecausePredicate.iFld);\n+                            TestDeadPostLoopBecausePredicate.iFld = (TestDeadPostLoopBecausePredicate.iFld1 % iArr[i19]);\n+                        } catch (ArithmeticException a_e) {}\n+                    }\n+                    break;\n+                }\n+            }\n+        } while (++i < 220);\n+\n+        return i20;\n+    }\n+\n+    public static void init(int[] a, int seed) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = (j % 2 == 0) ? seed + j : seed - j;\n+        }\n+    }\n+\n+    public static void main(String[] strArr) {\n+        TestDeadPostLoopBecausePredicate _instance = new TestDeadPostLoopBecausePredicate();\n+        for (int i = 0; i < 10; i++ ) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestDeadPostLoopBecausePredicate.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"}]}