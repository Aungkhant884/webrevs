{"files":[{"patch":"@@ -548,0 +548,4 @@\n+  ifeq ($(OPENJDK_TARGET_OS), aix)\n+    LIBFONTMANAGER_EXTRA_SRC = $(TOPDIR)\/src\/$(MODULE)\/aix\/native\/libharfbuzz\n+    LIBFONTMANAGER_EXCLUDE_FILES += libharfbuzz\/hb-coretext.cc\n+  endif\n","filename":"make\/lib\/Awt2dLibraries.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+## Harfbuzz v2.3.1\n+\n+### Harfbuzz License\n+\n+http:\/\/cgit.freedesktop.org\/harfbuzz\/tree\/COPYING\n+\n+<pre>\n+\n+HarfBuzz is licensed under the so-called \"Old MIT\" license. Details follow.\n+For parts of HarfBuzz that are licensed under different licenses see individual\n+files names COPYING in subdirectories where applicable.\n+\n+Copyright © 2010,2011,2012  Google, Inc.\n+Copyright © 2012  Mozilla Foundation\n+Copyright © 2011  Codethink Limited\n+Copyright © 2008,2010  Nokia Corporation and\/or its subsidiary(-ies)\n+Copyright © 2009  Keith Stribley\n+Copyright © 2009  Martin Hosken and SIL International\n+Copyright © 2007  Chris Wilson\n+Copyright © 2006  Behdad Esfahbod\n+Copyright © 2005  David Turner\n+Copyright © 2004,2007,2008,2009,2010  Red Hat, Inc.\n+Copyright © 1998-2004  David Turner and Werner Lemberg\n+\n+For full copyright notices consult the individual files in the package.\n+\n+\n+Permission is hereby granted, without written agreement and without\n+license or royalty fees, to use, copy, modify, and distribute this\n+software and its documentation for any purpose, provided that the\n+above copyright notice and the following two paragraphs appear in\n+all copies of this software.\n+\n+IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+DAMAGE.\n+\n+THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+\n+All source code, except for one section, is licensed as above. The one\n+exception is licensed with a slightly different MIT variant:\n+The contents of this directory are licensed under the following terms:\n+\n+Copyright (C) 2012 Grigori Goronzy <greg@kinoho.net>\n+\n+Permission to use, copy, modify, and\/or distribute this software for any\n+purpose with or without fee is hereby granted, provided that the above\n+copyright notice and this permission notice appear in all copies.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+\n+<\/pre>\n","filename":"src\/java.desktop\/aix\/legal\/harfbuzz.md","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_AAT_FDSC_TABLE_HH\n+#define HB_AAT_FDSC_TABLE_HH\n+\n+#include \"hb-aat-layout-common.hh\"\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * fdsc -- Font descriptors\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6fdsc.html\n+ *\/\n+#define HB_AAT_TAG_fdsc HB_TAG('f','d','s','c')\n+\n+\n+namespace AAT {\n+\n+\n+struct FontDescriptor\n+{\n+  bool has_data () const { return tag; }\n+\n+  int cmp (hb_tag_t a) const { return tag.cmp (a); }\n+\n+  float get_value () const { return u.value.to_float (); }\n+\n+  enum non_alphabetic_value_t {\n+    Alphabetic          = 0,\n+    Dingbats            = 1,\n+    PiCharacters        = 2,\n+    Fleurons            = 3,\n+    DecorativeBorders   = 4,\n+    InternationalSymbols= 5,\n+    MathSymbols         = 6\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  Tag           tag;            \/* The 4-byte table tag name. *\/\n+  union {\n+  Fixed         value;          \/* The value for the descriptor tag. *\/\n+  HBUINT32      nalfType;       \/* If the tag is `nalf`, see non_alphabetic_value_t *\/\n+  } u;\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct fdsc\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_fdsc;\n+\n+  enum {\n+    Weight       = HB_TAG ('w','g','h','t'),\n+                                \/* Percent weight relative to regular weight.\n+                                 * (defaul value: 1.0) *\/\n+    Width        = HB_TAG ('w','d','t','h'),\n+                                \/* Percent width relative to regular width.\n+                                 * (default value: 1.0) *\/\n+    Slant        = HB_TAG ('s','l','n','t'),\n+                                \/* Angle of slant in degrees, where positive\n+                                 * is clockwise from straight up.\n+                                 * (default value: 0.0) *\/\n+    OpticalSize  = HB_TAG ('o','p','s','z'),\n+                                \/* Point size the font was designed for.\n+                                 * (default value: 12.0) *\/\n+    NonAlphabetic= HB_TAG ('n','a','l','f')\n+                                \/* These values are treated as integers,\n+                                 * not fixed32s. 0 means alphabetic, and greater\n+                                 * integers mean the font is non-alphabetic (e.g. symbols).\n+                                 * (default value: 0) *\/\n+  };\n+\n+  const FontDescriptor &get_descriptor (hb_tag_t style) const\n+  { return descriptors.lsearch (style); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  descriptors.sanitize (c));\n+  }\n+\n+  protected:\n+  Fixed         version;        \/* Version number of the font descriptors\n+                                 * table (0x00010000 for the current version). *\/\n+  LArrayOf<FontDescriptor>\n+                descriptors;    \/* List of tagged-coordinate pairs style descriptors\n+                                 * that will be included to characterize this font.\n+                                 * Each descriptor consists of a <tag, value> pair.\n+                                 * These pairs are located in the gxFontDescriptor\n+                                 * array that follows. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, descriptors);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_FDSC_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-fdsc-table.hh","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_ANKR_TABLE_HH\n+#define HB_AAT_LAYOUT_ANKR_TABLE_HH\n+\n+#include \"hb-aat-layout-common.hh\"\n+\n+\/*\n+ * ankr -- Anchor Point\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6ankr.html\n+ *\/\n+#define HB_AAT_TAG_ankr HB_TAG('a','n','k','r')\n+\n+\n+namespace AAT {\n+\n+using namespace OT;\n+\n+\n+struct Anchor\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  FWORD         xCoordinate;\n+  FWORD         yCoordinate;\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+typedef LArrayOf<Anchor> GlyphAnchors;\n+\n+struct ankr\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_ankr;\n+\n+  const Anchor &get_anchor (hb_codepoint_t glyph_id,\n+                            unsigned int i,\n+                            unsigned int num_glyphs) const\n+  {\n+    const NNOffsetTo<GlyphAnchors> *offset = (this+lookupTable).get_value (glyph_id, num_glyphs);\n+    if (!offset)\n+      return Null(Anchor);\n+    const GlyphAnchors &anchors = &(this+anchorData) + *offset;\n+    return anchors[i];\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          version == 0 &&\n+                          lookupTable.sanitize (c, this, &(this+anchorData))));\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Version number (set to zero) *\/\n+  HBUINT16      flags;          \/* Flags (currently unused; set to zero) *\/\n+  LOffsetTo<Lookup<NNOffsetTo<GlyphAnchors> > >\n+                lookupTable;    \/* Offset to the table's lookup table *\/\n+  LNNOffsetTo<HBUINT8>\n+                anchorData;     \/* Offset to the glyph data table *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LAYOUT_ANKR_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-ankr-table.hh","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_BSLN_TABLE_HH\n+#define HB_AAT_LAYOUT_BSLN_TABLE_HH\n+\n+#include \"hb-aat-layout-common.hh\"\n+\n+\/*\n+ * bsln -- Baseline\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6bsln.html\n+ *\/\n+#define HB_AAT_TAG_bsln HB_TAG('b','s','l','n')\n+\n+\n+namespace AAT {\n+\n+\n+struct BaselineTableFormat0Part\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  \/\/ Roman, Ideographic centered, Ideographic low, Hanging and Math\n+  \/\/ are the default defined ones, but any other maybe accessed also.\n+  HBINT16       deltas[32];     \/* These are the FUnit distance deltas from\n+                                 * the font's natural baseline to the other\n+                                 * baselines used in the font. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (64);\n+};\n+\n+struct BaselineTableFormat1Part\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          lookupTable.sanitize (c)));\n+  }\n+\n+  protected:\n+  HBINT16       deltas[32];     \/* ditto *\/\n+  Lookup<HBUINT16>\n+                lookupTable;    \/* Lookup table that maps glyphs to their\n+                                 * baseline values. *\/\n+  public:\n+  DEFINE_SIZE_MIN (66);\n+};\n+\n+struct BaselineTableFormat2Part\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  GlyphID       stdGlyph;       \/* The specific glyph index number in this\n+                                 * font that is used to set the baseline values.\n+                                 * This is the standard glyph.\n+                                 * This glyph must contain a set of control points\n+                                 * (whose numbers are contained in the ctlPoints field)\n+                                 * that are used to determine baseline distances. *\/\n+  HBUINT16      ctlPoints[32];  \/* Set of control point numbers,\n+                                 * associated with the standard glyph.\n+                                 * A value of 0xFFFF means there is no corresponding\n+                                 * control point in the standard glyph. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (66);\n+};\n+\n+struct BaselineTableFormat3Part\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && lookupTable.sanitize (c));\n+  }\n+\n+  protected:\n+  GlyphID       stdGlyph;       \/* ditto *\/\n+  HBUINT16      ctlPoints[32];  \/* ditto *\/\n+  Lookup<HBUINT16>\n+                lookupTable;    \/* Lookup table that maps glyphs to their\n+                                 * baseline values. *\/\n+  public:\n+  DEFINE_SIZE_MIN (68);\n+};\n+\n+struct bsln\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_bsln;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!(c->check_struct (this) && defaultBaseline < 32)))\n+      return_trace (false);\n+\n+    switch (format)\n+    {\n+    case 0: return_trace (parts.format0.sanitize (c));\n+    case 1: return_trace (parts.format1.sanitize (c));\n+    case 2: return_trace (parts.format2.sanitize (c));\n+    case 3: return_trace (parts.format3.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version number of the Baseline table. *\/\n+  HBUINT16      format;         \/* Format of the baseline table. Only one baseline\n+                                 * format may be selected for the font. *\/\n+  HBUINT16      defaultBaseline;\/* Default baseline value for all glyphs.\n+                                 * This value can be from 0 through 31. *\/\n+  union {\n+  \/\/ Distance-Based Formats\n+  BaselineTableFormat0Part      format0;\n+  BaselineTableFormat1Part      format1;\n+  \/\/ Control Point-based Formats\n+  BaselineTableFormat2Part      format2;\n+  BaselineTableFormat3Part      format3;\n+  } parts;\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LAYOUT_BSLN_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-bsln-table.hh","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,845 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_COMMON_HH\n+#define HB_AAT_LAYOUT_COMMON_HH\n+\n+#include \"hb-aat-layout.hh\"\n+#include \"hb-open-type.hh\"\n+\n+\n+namespace AAT {\n+\n+using namespace OT;\n+\n+\n+\/*\n+ * Lookup Table\n+ *\/\n+\n+template <typename T> struct Lookup;\n+\n+template <typename T>\n+struct LookupFormat0\n+{\n+  friend struct Lookup<T>;\n+\n+  private:\n+  const T* get_value (hb_codepoint_t glyph_id, unsigned int num_glyphs) const\n+  {\n+    if (unlikely (glyph_id >= num_glyphs)) return nullptr;\n+    return &arrayZ[glyph_id];\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (arrayZ.sanitize (c, c->get_num_glyphs ()));\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (arrayZ.sanitize (c, c->get_num_glyphs (), base));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 0 *\/\n+  UnsizedArrayOf<T>\n+                arrayZ;         \/* Array of lookup values, indexed by glyph index. *\/\n+  public:\n+  DEFINE_SIZE_UNBOUNDED (2);\n+};\n+\n+\n+template <typename T>\n+struct LookupSegmentSingle\n+{\n+  static constexpr unsigned TerminationWordCount = 2u;\n+\n+  int cmp (hb_codepoint_t g) const\n+  { return g < first ? -1 : g <= last ? 0 : +1 ; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c));\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c, base));\n+  }\n+\n+  GlyphID       last;           \/* Last GlyphID in this segment *\/\n+  GlyphID       first;          \/* First GlyphID in this segment *\/\n+  T             value;          \/* The lookup value (only one) *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4 + T::static_size);\n+};\n+\n+template <typename T>\n+struct LookupFormat2\n+{\n+  friend struct Lookup<T>;\n+\n+  private:\n+  const T* get_value (hb_codepoint_t glyph_id) const\n+  {\n+    const LookupSegmentSingle<T> *v = segments.bsearch (glyph_id);\n+    return v ? &v->value : nullptr;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (segments.sanitize (c));\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (segments.sanitize (c, base));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 2 *\/\n+  VarSizedBinSearchArrayOf<LookupSegmentSingle<T> >\n+                segments;       \/* The actual segments. These must already be sorted,\n+                                 * according to the first word in each one (the last\n+                                 * glyph in each segment). *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, segments);\n+};\n+\n+template <typename T>\n+struct LookupSegmentArray\n+{\n+  static constexpr unsigned TerminationWordCount = 2u;\n+\n+  const T* get_value (hb_codepoint_t glyph_id, const void *base) const\n+  {\n+    return first <= glyph_id && glyph_id <= last ? &(base+valuesZ)[glyph_id - first] : nullptr;\n+  }\n+\n+  int cmp (hb_codepoint_t g) const\n+  { return g < first ? -1 : g <= last ? 0 : +1; }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  first <= last &&\n+                  valuesZ.sanitize (c, base, last - first + 1));\n+  }\n+  template <typename T2>\n+  bool sanitize (hb_sanitize_context_t *c, const void *base, T2 user_data) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  first <= last &&\n+                  valuesZ.sanitize (c, base, last - first + 1, user_data));\n+  }\n+\n+  GlyphID       last;           \/* Last GlyphID in this segment *\/\n+  GlyphID       first;          \/* First GlyphID in this segment *\/\n+  NNOffsetTo<UnsizedArrayOf<T> >\n+                valuesZ;        \/* A 16-bit offset from the start of\n+                                 * the table to the data. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+template <typename T>\n+struct LookupFormat4\n+{\n+  friend struct Lookup<T>;\n+\n+  private:\n+  const T* get_value (hb_codepoint_t glyph_id) const\n+  {\n+    const LookupSegmentArray<T> *v = segments.bsearch (glyph_id);\n+    return v ? v->get_value (glyph_id, this) : nullptr;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (segments.sanitize (c, this));\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (segments.sanitize (c, this, base));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 4 *\/\n+  VarSizedBinSearchArrayOf<LookupSegmentArray<T> >\n+                segments;       \/* The actual segments. These must already be sorted,\n+                                 * according to the first word in each one (the last\n+                                 * glyph in each segment). *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, segments);\n+};\n+\n+template <typename T>\n+struct LookupSingle\n+{\n+  static constexpr unsigned TerminationWordCount = 1u;\n+\n+  int cmp (hb_codepoint_t g) const { return glyph.cmp (g); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c));\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && value.sanitize (c, base));\n+  }\n+\n+  GlyphID       glyph;          \/* Last GlyphID *\/\n+  T             value;          \/* The lookup value (only one) *\/\n+  public:\n+  DEFINE_SIZE_STATIC (2 + T::static_size);\n+};\n+\n+template <typename T>\n+struct LookupFormat6\n+{\n+  friend struct Lookup<T>;\n+\n+  private:\n+  const T* get_value (hb_codepoint_t glyph_id) const\n+  {\n+    const LookupSingle<T> *v = entries.bsearch (glyph_id);\n+    return v ? &v->value : nullptr;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (entries.sanitize (c));\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (entries.sanitize (c, base));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 6 *\/\n+  VarSizedBinSearchArrayOf<LookupSingle<T> >\n+                entries;        \/* The actual entries, sorted by glyph index. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, entries);\n+};\n+\n+template <typename T>\n+struct LookupFormat8\n+{\n+  friend struct Lookup<T>;\n+\n+  private:\n+  const T* get_value (hb_codepoint_t glyph_id) const\n+  {\n+    return firstGlyph <= glyph_id && glyph_id - firstGlyph < glyphCount ?\n+           &valueArrayZ[glyph_id - firstGlyph] : nullptr;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && valueArrayZ.sanitize (c, glyphCount));\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && valueArrayZ.sanitize (c, glyphCount, base));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 8 *\/\n+  GlyphID       firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n+  HBUINT16      glyphCount;     \/* Total number of glyphs (equivalent to the last\n+                                 * glyph minus the value of firstGlyph plus 1). *\/\n+  UnsizedArrayOf<T>\n+                valueArrayZ;    \/* The lookup values (indexed by the glyph index\n+                                 * minus the value of firstGlyph). *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, valueArrayZ);\n+};\n+\n+template <typename T>\n+struct LookupFormat10\n+{\n+  friend struct Lookup<T>;\n+\n+  private:\n+  const typename T::type get_value_or_null (hb_codepoint_t glyph_id) const\n+  {\n+    if (!(firstGlyph <= glyph_id && glyph_id - firstGlyph < glyphCount))\n+      return Null(T);\n+\n+    const HBUINT8 *p = &valueArrayZ[(glyph_id - firstGlyph) * valueSize];\n+\n+    unsigned int v = 0;\n+    unsigned int count = valueSize;\n+    for (unsigned int i = 0; i < count; i++)\n+      v = (v << 8) | *p++;\n+\n+    return v;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  valueSize <= 4 &&\n+                  valueArrayZ.sanitize (c, glyphCount * valueSize));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 8 *\/\n+  HBUINT16      valueSize;      \/* Byte size of each value. *\/\n+  GlyphID       firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n+  HBUINT16      glyphCount;     \/* Total number of glyphs (equivalent to the last\n+                                 * glyph minus the value of firstGlyph plus 1). *\/\n+  UnsizedArrayOf<HBUINT8>\n+                valueArrayZ;    \/* The lookup values (indexed by the glyph index\n+                                 * minus the value of firstGlyph). *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, valueArrayZ);\n+};\n+\n+template <typename T>\n+struct Lookup\n+{\n+  const T* get_value (hb_codepoint_t glyph_id, unsigned int num_glyphs) const\n+  {\n+    switch (u.format) {\n+    case 0: return u.format0.get_value (glyph_id, num_glyphs);\n+    case 2: return u.format2.get_value (glyph_id);\n+    case 4: return u.format4.get_value (glyph_id);\n+    case 6: return u.format6.get_value (glyph_id);\n+    case 8: return u.format8.get_value (glyph_id);\n+    default:return nullptr;\n+    }\n+  }\n+\n+  const typename T::type get_value_or_null (hb_codepoint_t glyph_id, unsigned int num_glyphs) const\n+  {\n+    switch (u.format) {\n+      \/* Format 10 cannot return a pointer. *\/\n+      case 10: return u.format10.get_value_or_null (glyph_id);\n+      default:\n+      const T *v = get_value (glyph_id, num_glyphs);\n+      return v ? *v : Null(T);\n+    }\n+  }\n+\n+  typename T::type get_class (hb_codepoint_t glyph_id,\n+                              unsigned int num_glyphs,\n+                              unsigned int outOfRange) const\n+  {\n+    const T *v = get_value (glyph_id, num_glyphs);\n+    return v ? *v : outOfRange;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 0: return_trace (u.format0.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    case 4: return_trace (u.format4.sanitize (c));\n+    case 6: return_trace (u.format6.sanitize (c));\n+    case 8: return_trace (u.format8.sanitize (c));\n+    case 10: return_trace (u.format10.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 0: return_trace (u.format0.sanitize (c, base));\n+    case 2: return_trace (u.format2.sanitize (c, base));\n+    case 4: return_trace (u.format4.sanitize (c, base));\n+    case 6: return_trace (u.format6.sanitize (c, base));\n+    case 8: return_trace (u.format8.sanitize (c, base));\n+    case 10: return_trace (false); \/* We don't support format10 here currently. *\/\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  LookupFormat0<T>      format0;\n+  LookupFormat2<T>      format2;\n+  LookupFormat4<T>      format4;\n+  LookupFormat6<T>      format6;\n+  LookupFormat8<T>      format8;\n+  LookupFormat10<T>     format10;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\/* Lookup 0 has unbounded size (dependant on num_glyphs).  So we need to defined\n+ * special NULL objects for Lookup<> objects, but since it's template our macros\n+ * don't work.  So we have to hand-code them here.  UGLY. *\/\n+} \/* Close namespace. *\/\n+\/* Ugly hand-coded null objects for template Lookup<> :(. *\/\n+extern HB_INTERNAL const unsigned char _hb_Null_AAT_Lookup[2];\n+template <>\n+\/*static*\/ inline const AAT::Lookup<OT::HBUINT16>& Null<AAT::Lookup<OT::HBUINT16> > ()\n+{ return *reinterpret_cast<const AAT::Lookup<OT::HBUINT16> *> (_hb_Null_AAT_Lookup); }\n+template <>\n+\/*static*\/ inline const AAT::Lookup<OT::HBUINT32>& Null<AAT::Lookup<OT::HBUINT32> > ()\n+{ return *reinterpret_cast<const AAT::Lookup<OT::HBUINT32> *> (_hb_Null_AAT_Lookup); }\n+template <>\n+\/*static*\/ inline const AAT::Lookup<OT::Offset<OT::HBUINT16, false> >& Null<AAT::Lookup<OT::Offset<OT::HBUINT16, false> > > ()\n+{ return *reinterpret_cast<const AAT::Lookup<OT::Offset<OT::HBUINT16, false> > *> (_hb_Null_AAT_Lookup); }\n+namespace AAT {\n+\n+enum { DELETED_GLYPH = 0xFFFF };\n+\n+\/*\n+ * (Extended) State Table\n+ *\/\n+\n+template <typename T>\n+struct Entry\n+{\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* Note, we don't recurse-sanitize data because we don't access it.\n+     * That said, in our DEFINE_SIZE_STATIC we access T::static_size,\n+     * which ensures that data has a simple sanitize(). To be determined\n+     * if I need to remove that as well.\n+     *\n+     * HOWEVER! Because we are a template, our DEFINE_SIZE_STATIC\n+     * assertion wouldn't be checked, hence the line below. *\/\n+    static_assert (T::static_size, \"\");\n+\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBUINT16      newState;       \/* Byte offset from beginning of state table\n+                                 * to the new state. Really?!?! Or just state\n+                                 * number?  The latter in morx for sure. *\/\n+  HBUINT16      flags;          \/* Table specific. *\/\n+  T             data;           \/* Optional offsets to per-glyph tables. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4 + T::static_size);\n+};\n+\n+template <>\n+struct Entry<void>\n+{\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count \/*XXX Unused?*\/) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBUINT16      newState;       \/* Byte offset from beginning of state table to the new state. *\/\n+  HBUINT16      flags;          \/* Table specific. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+template <typename Types, typename Extra>\n+struct StateTable\n+{\n+  typedef typename Types::HBUINT HBUINT;\n+  typedef typename Types::HBUSHORT HBUSHORT;\n+  typedef typename Types::ClassTypeNarrow ClassType;\n+\n+  enum State\n+  {\n+    STATE_START_OF_TEXT = 0,\n+    STATE_START_OF_LINE = 1,\n+  };\n+  enum Class\n+  {\n+    CLASS_END_OF_TEXT = 0,\n+    CLASS_OUT_OF_BOUNDS = 1,\n+    CLASS_DELETED_GLYPH = 2,\n+    CLASS_END_OF_LINE = 3,\n+  };\n+\n+  int new_state (unsigned int newState) const\n+  { return Types::extended ? newState : ((int) newState - (int) stateArrayTable) \/ (int) nClasses; }\n+\n+  unsigned int get_class (hb_codepoint_t glyph_id, unsigned int num_glyphs) const\n+  {\n+    if (unlikely (glyph_id == DELETED_GLYPH)) return CLASS_DELETED_GLYPH;\n+    return (this+classTable).get_class (glyph_id, num_glyphs, 1);\n+  }\n+\n+  const Entry<Extra> *get_entries () const\n+  { return (this+entryTable).arrayZ; }\n+\n+  const Entry<Extra> &get_entry (int state, unsigned int klass) const\n+  {\n+    if (unlikely (klass >= nClasses))\n+      klass = StateTable<Types, Entry<Extra> >::CLASS_OUT_OF_BOUNDS;\n+\n+    const HBUSHORT *states = (this+stateArrayTable).arrayZ;\n+    const Entry<Extra> *entries = (this+entryTable).arrayZ;\n+\n+    unsigned int entry = states[state * nClasses + klass];\n+    DEBUG_MSG (APPLY, nullptr, \"e%u\", entry);\n+\n+    return entries[entry];\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 unsigned int *num_entries_out = nullptr) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!(c->check_struct (this) &&\n+                    nClasses >= 4 \/* Ensure pre-defined classes fit.  *\/ &&\n+                    classTable.sanitize (c, this)))) return_trace (false);\n+\n+    const HBUSHORT *states = (this+stateArrayTable).arrayZ;\n+    const Entry<Extra> *entries = (this+entryTable).arrayZ;\n+\n+    unsigned int num_classes = nClasses;\n+    if (unlikely (hb_unsigned_mul_overflows (num_classes, states[0].static_size)))\n+      return_trace (false);\n+    unsigned int row_stride = num_classes * states[0].static_size;\n+\n+    \/* Apple 'kern' table has this peculiarity:\n+     *\n+     * \"Because the stateTableOffset in the state table header is (strictly\n+     * speaking) redundant, some 'kern' tables use it to record an initial\n+     * state where that should not be StartOfText. To determine if this is\n+     * done, calculate what the stateTableOffset should be. If it's different\n+     * from the actual stateTableOffset, use it as the initial state.\"\n+     *\n+     * We implement this by calling the initial state zero, but allow *negative*\n+     * states if the start state indeed was not the first state.  Since the code\n+     * is shared, this will also apply to 'mort' table.  The 'kerx' \/ 'morx'\n+     * tables are not affected since those address states by index, not offset.\n+     *\/\n+\n+    int min_state = 0;\n+    int max_state = 0;\n+    unsigned int num_entries = 0;\n+\n+    int state_pos = 0;\n+    int state_neg = 0;\n+    unsigned int entry = 0;\n+    while (min_state < state_neg || state_pos <= max_state)\n+    {\n+      if (min_state < state_neg)\n+      {\n+        \/* Negative states. *\/\n+        if (unlikely (hb_unsigned_mul_overflows (min_state, num_classes)))\n+          return_trace (false);\n+        if (unlikely (!c->check_range (&states[min_state * num_classes],\n+                                       -min_state,\n+                                       row_stride)))\n+          return_trace (false);\n+        if ((c->max_ops -= state_neg - min_state) <= 0)\n+          return_trace (false);\n+        { \/* Sweep new states. *\/\n+          const HBUSHORT *stop = &states[min_state * num_classes];\n+          if (unlikely (stop > states))\n+            return_trace (false);\n+          for (const HBUSHORT *p = states; stop < p; p--)\n+            num_entries = MAX<unsigned int> (num_entries, *(p - 1) + 1);\n+          state_neg = min_state;\n+        }\n+      }\n+\n+      if (state_pos <= max_state)\n+      {\n+        \/* Positive states. *\/\n+        if (unlikely (!c->check_range (states,\n+                                       max_state + 1,\n+                                       row_stride)))\n+          return_trace (false);\n+        if ((c->max_ops -= max_state - state_pos + 1) <= 0)\n+          return_trace (false);\n+        { \/* Sweep new states. *\/\n+          if (unlikely (hb_unsigned_mul_overflows ((max_state + 1), num_classes)))\n+            return_trace (false);\n+          const HBUSHORT *stop = &states[(max_state + 1) * num_classes];\n+          if (unlikely (stop < states))\n+            return_trace (false);\n+          for (const HBUSHORT *p = &states[state_pos * num_classes]; p < stop; p++)\n+            num_entries = MAX<unsigned int> (num_entries, *p + 1);\n+          state_pos = max_state + 1;\n+        }\n+      }\n+\n+      if (unlikely (!c->check_array (entries, num_entries)))\n+        return_trace (false);\n+      if ((c->max_ops -= num_entries - entry) <= 0)\n+        return_trace (false);\n+      { \/* Sweep new entries. *\/\n+        const Entry<Extra> *stop = &entries[num_entries];\n+        for (const Entry<Extra> *p = &entries[entry]; p < stop; p++)\n+        {\n+          int newState = new_state (p->newState);\n+          min_state = MIN (min_state, newState);\n+          max_state = MAX (max_state, newState);\n+        }\n+        entry = num_entries;\n+      }\n+    }\n+\n+    if (num_entries_out)\n+      *num_entries_out = num_entries;\n+\n+    return_trace (true);\n+  }\n+\n+  protected:\n+  HBUINT        nClasses;       \/* Number of classes, which is the number of indices\n+                                 * in a single line in the state array. *\/\n+  NNOffsetTo<ClassType, HBUINT>\n+                classTable;     \/* Offset to the class table. *\/\n+  NNOffsetTo<UnsizedArrayOf<HBUSHORT>, HBUINT>\n+                stateArrayTable;\/* Offset to the state array. *\/\n+  NNOffsetTo<UnsizedArrayOf<Entry<Extra> >, HBUINT>\n+                entryTable;     \/* Offset to the entry array. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4 * sizeof (HBUINT));\n+};\n+\n+template <typename HBUCHAR>\n+struct ClassTable\n+{\n+  unsigned int get_class (hb_codepoint_t glyph_id, unsigned int outOfRange) const\n+  {\n+    unsigned int i = glyph_id - firstGlyph;\n+    return i >= classArray.len ? outOfRange : classArray.arrayZ[i];\n+  }\n+  unsigned int get_class (hb_codepoint_t glyph_id,\n+                          unsigned int num_glyphs HB_UNUSED,\n+                          unsigned int outOfRange) const\n+  {\n+    return get_class (glyph_id, outOfRange);\n+  }\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && classArray.sanitize (c));\n+  }\n+  protected:\n+  GlyphID               firstGlyph;     \/* First glyph index included in the trimmed array. *\/\n+  ArrayOf<HBUCHAR>      classArray;     \/* The class codes (indexed by glyph index minus\n+                                         * firstGlyph). *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, classArray);\n+};\n+\n+struct ObsoleteTypes\n+{\n+  static constexpr bool extended = false;\n+  typedef HBUINT16 HBUINT;\n+  typedef HBUINT8 HBUSHORT;\n+  typedef ClassTable<HBUINT8> ClassTypeNarrow;\n+  typedef ClassTable<HBUINT16> ClassTypeWide;\n+\n+  template <typename T>\n+  static unsigned int offsetToIndex (unsigned int offset,\n+                                     const void *base,\n+                                     const T *array)\n+  {\n+    return (offset - ((const char *) array - (const char *) base)) \/ sizeof (T);\n+  }\n+  template <typename T>\n+  static unsigned int byteOffsetToIndex (unsigned int offset,\n+                                         const void *base,\n+                                         const T *array)\n+  {\n+    return offsetToIndex (offset, base, array);\n+  }\n+  template <typename T>\n+  static unsigned int wordOffsetToIndex (unsigned int offset,\n+                                         const void *base,\n+                                         const T *array)\n+  {\n+    return offsetToIndex (2 * offset, base, array);\n+  }\n+};\n+struct ExtendedTypes\n+{\n+  static constexpr bool extended = true;\n+  typedef HBUINT32 HBUINT;\n+  typedef HBUINT16 HBUSHORT;\n+  typedef Lookup<HBUINT16> ClassTypeNarrow;\n+  typedef Lookup<HBUINT16> ClassTypeWide;\n+\n+  template <typename T>\n+  static unsigned int offsetToIndex (unsigned int offset,\n+                                     const void *base HB_UNUSED,\n+                                     const T *array HB_UNUSED)\n+  {\n+    return offset;\n+  }\n+  template <typename T>\n+  static unsigned int byteOffsetToIndex (unsigned int offset,\n+                                         const void *base HB_UNUSED,\n+                                         const T *array HB_UNUSED)\n+  {\n+    return offset \/ 2;\n+  }\n+  template <typename T>\n+  static unsigned int wordOffsetToIndex (unsigned int offset,\n+                                         const void *base HB_UNUSED,\n+                                         const T *array HB_UNUSED)\n+  {\n+    return offset;\n+  }\n+};\n+\n+template <typename Types, typename EntryData>\n+struct StateTableDriver\n+{\n+  StateTableDriver (const StateTable<Types, EntryData> &machine_,\n+                    hb_buffer_t *buffer_,\n+                    hb_face_t *face_) :\n+              machine (machine_),\n+              buffer (buffer_),\n+              num_glyphs (face_->get_num_glyphs ()) {}\n+\n+  template <typename context_t>\n+  void drive (context_t *c)\n+  {\n+    if (!c->in_place)\n+      buffer->clear_output ();\n+\n+    int state = StateTable<Types, EntryData>::STATE_START_OF_TEXT;\n+    for (buffer->idx = 0; buffer->successful;)\n+    {\n+      unsigned int klass = buffer->idx < buffer->len ?\n+                           machine.get_class (buffer->info[buffer->idx].codepoint, num_glyphs) :\n+                           (unsigned) StateTable<Types, EntryData>::CLASS_END_OF_TEXT;\n+      DEBUG_MSG (APPLY, nullptr, \"c%u at %u\", klass, buffer->idx);\n+      const Entry<EntryData> &entry = machine.get_entry (state, klass);\n+\n+      \/* Unsafe-to-break before this if not in state 0, as things might\n+       * go differently if we start from state 0 here.\n+       *\n+       * Ugh.  The indexing here is ugly... *\/\n+      if (state && buffer->backtrack_len () && buffer->idx < buffer->len)\n+      {\n+        \/* If there's no action and we're just epsilon-transitioning to state 0,\n+         * safe to break. *\/\n+        if (c->is_actionable (this, entry) ||\n+            !(entry.newState == StateTable<Types, EntryData>::STATE_START_OF_TEXT &&\n+              entry.flags == context_t::DontAdvance))\n+          buffer->unsafe_to_break_from_outbuffer (buffer->backtrack_len () - 1, buffer->idx + 1);\n+      }\n+\n+      \/* Unsafe-to-break if end-of-text would kick in here. *\/\n+      if (buffer->idx + 2 <= buffer->len)\n+      {\n+        const Entry<EntryData> &end_entry = machine.get_entry (state, StateTable<Types, EntryData>::CLASS_END_OF_TEXT);\n+        if (c->is_actionable (this, end_entry))\n+          buffer->unsafe_to_break (buffer->idx, buffer->idx + 2);\n+      }\n+\n+      c->transition (this, entry);\n+\n+      state = machine.new_state (entry.newState);\n+      DEBUG_MSG (APPLY, nullptr, \"s%d\", state);\n+\n+      if (buffer->idx == buffer->len)\n+        break;\n+\n+      if (!(entry.flags & context_t::DontAdvance) || buffer->max_ops-- <= 0)\n+        buffer->next_glyph ();\n+    }\n+\n+    if (!c->in_place)\n+    {\n+      for (; buffer->successful && buffer->idx < buffer->len;)\n+        buffer->next_glyph ();\n+      buffer->swap_buffers ();\n+    }\n+  }\n+\n+  public:\n+  const StateTable<Types, EntryData> &machine;\n+  hb_buffer_t *buffer;\n+  unsigned int num_glyphs;\n+};\n+\n+\n+struct ankr;\n+\n+struct hb_aat_apply_context_t :\n+       hb_dispatch_context_t<hb_aat_apply_context_t, bool, HB_DEBUG_APPLY>\n+{\n+  const char *get_name () { return \"APPLY\"; }\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.apply (this); }\n+  static return_t default_return_value () { return false; }\n+  bool stop_sublookup_iteration (return_t r) const { return r; }\n+\n+  const hb_ot_shape_plan_t *plan;\n+  hb_font_t *font;\n+  hb_face_t *face;\n+  hb_buffer_t *buffer;\n+  hb_sanitize_context_t sanitizer;\n+  const ankr *ankr_table;\n+\n+  \/* Unused. For debug tracing only. *\/\n+  unsigned int lookup_index;\n+  unsigned int debug_depth;\n+\n+  HB_INTERNAL hb_aat_apply_context_t (const hb_ot_shape_plan_t *plan_,\n+                                      hb_font_t *font_,\n+                                      hb_buffer_t *buffer_,\n+                                      hb_blob_t *blob = const_cast<hb_blob_t *> (&Null(hb_blob_t)));\n+\n+  HB_INTERNAL ~hb_aat_apply_context_t ();\n+\n+  HB_INTERNAL void set_ankr_table (const AAT::ankr *ankr_table_);\n+\n+  void set_lookup_index (unsigned int i) { lookup_index = i; }\n+};\n+\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LAYOUT_COMMON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-common.hh","additions":845,"deletions":0,"binary":false,"changes":845,"status":"added"},{"patch":"@@ -0,0 +1,217 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_FEAT_TABLE_HH\n+#define HB_AAT_LAYOUT_FEAT_TABLE_HH\n+\n+#include \"hb-aat-layout-common.hh\"\n+\n+\/*\n+ * feat -- Feature Name\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6feat.html\n+ *\/\n+#define HB_AAT_TAG_feat HB_TAG('f','e','a','t')\n+\n+\n+namespace AAT {\n+\n+\n+struct SettingName\n+{\n+  friend struct FeatureName;\n+\n+  int cmp (hb_aat_layout_feature_selector_t key) const\n+  { return (int) key - (int) setting; }\n+\n+  hb_aat_layout_feature_selector_t get_selector () const\n+  { return (hb_aat_layout_feature_selector_t) (unsigned) setting; }\n+\n+  void get_info (hb_aat_layout_feature_selector_info_t *s,\n+                        hb_aat_layout_feature_selector_t default_selector) const\n+  {\n+    s->name_id = nameIndex;\n+\n+    s->enable = (hb_aat_layout_feature_selector_t) (unsigned int) setting;\n+    s->disable = default_selector == HB_AAT_LAYOUT_FEATURE_SELECTOR_INVALID ?\n+                 (hb_aat_layout_feature_selector_t) (s->enable + 1) :\n+                 default_selector;\n+\n+    s->reserved = 0;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT16      setting;        \/* The setting. *\/\n+  NameID        nameIndex;      \/* The name table index for the setting's name. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (AAT, SettingName);\n+\n+struct feat;\n+\n+struct FeatureName\n+{\n+  int cmp (hb_aat_layout_feature_type_t key) const\n+  { return (int) key - (int) feature; }\n+\n+  enum {\n+    Exclusive   = 0x8000,       \/* If set, the feature settings are mutually exclusive. *\/\n+    NotDefault  = 0x4000,       \/* If clear, then the setting with an index of 0 in\n+                                 * the setting name array for this feature should\n+                                 * be taken as the default for the feature\n+                                 * (if one is required). If set, then bits 0-15 of this\n+                                 * featureFlags field contain the index of the setting\n+                                 * which is to be taken as the default. *\/\n+    IndexMask   = 0x00FF        \/* If bits 30 and 31 are set, then these sixteen bits\n+                                 * indicate the index of the setting in the setting name\n+                                 * array for this feature which should be taken\n+                                 * as the default. *\/\n+  };\n+\n+  unsigned int get_selector_infos (unsigned int                           start_offset,\n+                                   unsigned int                          *selectors_count, \/* IN\/OUT.  May be NULL. *\/\n+                                   hb_aat_layout_feature_selector_info_t *selectors,       \/* OUT.     May be NULL. *\/\n+                                   unsigned int                          *pdefault_index,  \/* OUT.     May be NULL. *\/\n+                                   const void *base) const\n+  {\n+    hb_array_t< const SettingName> settings_table = (base+settingTableZ).as_array (nSettings);\n+\n+    static_assert (Index::NOT_FOUND_INDEX == HB_AAT_LAYOUT_NO_SELECTOR_INDEX, \"\");\n+\n+    hb_aat_layout_feature_selector_t default_selector = HB_AAT_LAYOUT_FEATURE_SELECTOR_INVALID;\n+    unsigned int default_index = Index::NOT_FOUND_INDEX;\n+    if (featureFlags & Exclusive)\n+    {\n+      default_index = (featureFlags & NotDefault) ? featureFlags & IndexMask : 0;\n+      default_selector = settings_table[default_index].get_selector ();\n+    }\n+    if (pdefault_index)\n+      *pdefault_index = default_index;\n+\n+    if (selectors_count)\n+    {\n+      hb_array_t<const SettingName> arr = settings_table.sub_array (start_offset, selectors_count);\n+      for (unsigned int i = 0; i < arr.length; i++)\n+        settings_table[start_offset + i].get_info (&selectors[i], default_selector);\n+    }\n+    return settings_table.length;\n+  }\n+\n+  hb_aat_layout_feature_type_t get_feature_type () const\n+  { return (hb_aat_layout_feature_type_t) (unsigned int) feature; }\n+\n+  hb_ot_name_id_t get_feature_name_id () const { return nameIndex; }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (base+settingTableZ).sanitize (c, nSettings)));\n+  }\n+\n+  protected:\n+  HBUINT16      feature;        \/* Feature type. *\/\n+  HBUINT16      nSettings;      \/* The number of records in the setting name array. *\/\n+  LOffsetTo<UnsizedArrayOf<SettingName>, false>\n+                settingTableZ;  \/* Offset in bytes from the beginning of this table to\n+                                 * this feature's setting name array. The actual type of\n+                                 * record this offset refers to will depend on the\n+                                 * exclusivity value, as described below. *\/\n+  HBUINT16      featureFlags;   \/* Single-bit flags associated with the feature type. *\/\n+  HBINT16       nameIndex;      \/* The name table index for the feature's name.\n+                                 * This index has values greater than 255 and\n+                                 * less than 32768. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct feat\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_feat;\n+\n+  bool has_data () const { return version.to_int (); }\n+\n+  unsigned int get_feature_types (unsigned int                  start_offset,\n+                                  unsigned int                 *count,\n+                                  hb_aat_layout_feature_type_t *features) const\n+  {\n+    unsigned int feature_count = featureNameCount;\n+    if (count && *count)\n+    {\n+      unsigned int len = MIN (feature_count - start_offset, *count);\n+      for (unsigned int i = 0; i < len; i++)\n+        features[i] = namesZ[i + start_offset].get_feature_type ();\n+      *count = len;\n+    }\n+    return featureNameCount;\n+  }\n+\n+  const FeatureName& get_feature (hb_aat_layout_feature_type_t feature_type) const\n+  {\n+    return namesZ.bsearch (featureNameCount, feature_type);\n+  }\n+\n+  hb_ot_name_id_t get_feature_name_id (hb_aat_layout_feature_type_t feature) const\n+  { return get_feature (feature).get_feature_name_id (); }\n+\n+  unsigned int get_selector_infos (hb_aat_layout_feature_type_t           feature_type,\n+                                   unsigned int                           start_offset,\n+                                   unsigned int                          *selectors_count, \/* IN\/OUT.  May be NULL. *\/\n+                                   hb_aat_layout_feature_selector_info_t *selectors,       \/* OUT.     May be NULL. *\/\n+                                   unsigned int                          *default_index    \/* OUT.     May be NULL. *\/) const\n+  {\n+    return get_feature (feature_type).get_selector_infos (start_offset, selectors_count, selectors,\n+                                                          default_index, this);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          version.major == 1 &&\n+                          namesZ.sanitize (c, featureNameCount, this)));\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version number of the feature name table\n+                                 * (0x00010000 for the current version). *\/\n+  HBUINT16      featureNameCount;\n+                                \/* The number of entries in the feature name array. *\/\n+  HBUINT16      reserved1;      \/* Reserved (set to zero). *\/\n+  HBUINT32      reserved2;      \/* Reserved (set to zero). *\/\n+  SortedUnsizedArrayOf<FeatureName>\n+                namesZ;         \/* The feature name array. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (24);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+#endif \/* HB_AAT_LAYOUT_FEAT_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-feat-table.hh","additions":217,"deletions":0,"binary":false,"changes":217,"status":"added"},{"patch":"@@ -0,0 +1,417 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_JUST_TABLE_HH\n+#define HB_AAT_LAYOUT_JUST_TABLE_HH\n+\n+#include \"hb-aat-layout-common.hh\"\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-open-type.hh\"\n+\n+#include \"hb-aat-layout-morx-table.hh\"\n+\n+\/*\n+ * just -- Justification\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6just.html\n+ *\/\n+#define HB_AAT_TAG_just HB_TAG('j','u','s','t')\n+\n+\n+namespace AAT {\n+\n+using namespace OT;\n+\n+\n+struct ActionSubrecordHeader\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  HBUINT16      actionClass;    \/* The JustClass value associated with this\n+                                 * ActionSubrecord. *\/\n+  HBUINT16      actionType;     \/* The type of postcompensation action. *\/\n+  HBUINT16      actionLength;   \/* Length of this ActionSubrecord record, which\n+                                 * must be a multiple of 4. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct DecompositionAction\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  ActionSubrecordHeader\n+                header;\n+  Fixed         lowerLimit;     \/* If the distance factor is less than this value,\n+                                 * then the ligature is decomposed. *\/\n+  Fixed         upperLimit;     \/* If the distance factor is greater than this value,\n+                                 * then the ligature is decomposed. *\/\n+  HBUINT16      order;          \/* Numerical order in which this ligature will\n+                                 * be decomposed; you may want infrequent ligatures\n+                                 * to decompose before more frequent ones. The ligatures\n+                                 * on the line of text will decompose in increasing\n+                                 * value of this field. *\/\n+  ArrayOf<HBUINT16>\n+                decomposedglyphs;\n+                                \/* Number of 16-bit glyph indexes that follow;\n+                                 * the ligature will be decomposed into these glyphs.\n+                                 *\n+                                 * Array of decomposed glyphs. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (18, decomposedglyphs);\n+};\n+\n+struct UnconditionalAddGlyphAction\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  ActionSubrecordHeader\n+                header;\n+  GlyphID       addGlyph;       \/* Glyph that should be added if the distance factor\n+                                 * is growing. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct ConditionalAddGlyphAction\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  ActionSubrecordHeader\n+                header;\n+  Fixed         substThreshold; \/* Distance growth factor (in ems) at which\n+                                 * this glyph is replaced and the growth factor\n+                                 * recalculated. *\/\n+  GlyphID       addGlyph;       \/* Glyph to be added as kashida. If this value is\n+                                 * 0xFFFF, no extra glyph will be added. Note that\n+                                 * generally when a glyph is added, justification\n+                                 * will need to be redone. *\/\n+  GlyphID       substGlyph;     \/* Glyph to be substituted for this glyph if the\n+                                 * growth factor equals or exceeds the value of\n+                                 * substThreshold. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (14);\n+};\n+\n+struct DuctileGlyphAction\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  ActionSubrecordHeader\n+                header;\n+  HBUINT32      variationAxis;  \/* The 4-byte tag identifying the ductile axis.\n+                                 * This would normally be 0x64756374 ('duct'),\n+                                 * but you may use any axis the font contains. *\/\n+  Fixed         minimumLimit;   \/* The lowest value for the ductility axis tha\n+                                 * still yields an acceptable appearance. Normally\n+                                 * this will be 1.0. *\/\n+  Fixed         noStretchValue; \/* This is the default value that corresponds to\n+                                 * no change in appearance. Normally, this will\n+                                 * be 1.0. *\/\n+  Fixed         maximumLimit;   \/* The highest value for the ductility axis that\n+                                 * still yields an acceptable appearance. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (22);\n+};\n+\n+struct RepeatedAddGlyphAction\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  ActionSubrecordHeader\n+                header;\n+  HBUINT16      flags;          \/* Currently unused; set to 0. *\/\n+  GlyphID       glyph;          \/* Glyph that should be added if the distance factor\n+                                 * is growing. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+struct ActionSubrecord\n+{\n+  unsigned int get_length () const { return u.header.actionLength; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+\n+    switch (u.header.actionType)\n+    {\n+    case 0:  return_trace (u.decompositionAction.sanitize (c));\n+    case 1:  return_trace (u.unconditionalAddGlyphAction.sanitize (c));\n+    case 2:  return_trace (u.conditionalAddGlyphAction.sanitize (c));\n+    \/\/ case 3: return_trace (u.stretchGlyphAction.sanitize (c));\n+    case 4:  return_trace (u.decompositionAction.sanitize (c));\n+    case 5:  return_trace (u.decompositionAction.sanitize (c));\n+    default: return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  ActionSubrecordHeader         header;\n+  DecompositionAction           decompositionAction;\n+  UnconditionalAddGlyphAction   unconditionalAddGlyphAction;\n+  ConditionalAddGlyphAction     conditionalAddGlyphAction;\n+  \/* StretchGlyphAction stretchGlyphAction; -- Not supported by CoreText *\/\n+  DuctileGlyphAction            ductileGlyphAction;\n+  RepeatedAddGlyphAction        repeatedAddGlyphAction;\n+  } u;                          \/* Data. The format of this data depends on\n+                                 * the value of the actionType field. *\/\n+  public:\n+  DEFINE_SIZE_UNION (6, header);\n+};\n+\n+struct PostcompensationActionChain\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+\n+    unsigned int offset = min_size;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      const ActionSubrecord& subrecord = StructAtOffset<ActionSubrecord> (this, offset);\n+      if (unlikely (!subrecord.sanitize (c))) return_trace (false);\n+      offset += subrecord.get_length ();\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  protected:\n+  HBUINT32      count;\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct JustWidthDeltaEntry\n+{\n+  enum Flags\n+  {\n+    Reserved1           =0xE000,\/* Reserved. You should set these bits to zero. *\/\n+    UnlimiteGap         =0x1000,\/* The glyph can take unlimited gap. When this\n+                                 * glyph participates in the justification process,\n+                                 * it and any other glyphs on the line having this\n+                                 * bit set absorb all the remaining gap. *\/\n+    Reserved2           =0x0FF0,\/* Reserved. You should set these bits to zero. *\/\n+    Priority            =0x000F \/* The justification priority of the glyph. *\/\n+  };\n+\n+  enum Priority\n+  {\n+    Kashida             = 0,    \/* Kashida priority. This is the highest priority\n+                                 * during justification. *\/\n+    Whitespace          = 1,    \/* Whitespace priority. Any whitespace glyphs (as\n+                                 * identified in the glyph properties table) will\n+                                 * get this priority. *\/\n+    InterCharacter      = 2,    \/* Inter-character priority. Give this to any\n+                                 * remaining glyphs. *\/\n+    NullPriority        = 3     \/* Null priority. You should set this priority for\n+                                 * glyphs that only participate in justification\n+                                 * after the above priorities. Normally all glyphs\n+                                 * have one of the previous three values. If you\n+                                 * don't want a glyph to participate in justification,\n+                                 * and you don't want to set its factors to zero,\n+                                 * you may instead assign it to the null priority. *\/\n+  };\n+\n+  protected:\n+  Fixed         beforeGrowLimit;\/* The ratio by which the advance width of the\n+                                 * glyph is permitted to grow on the left or top side. *\/\n+  Fixed         beforeShrinkLimit;\n+                                \/* The ratio by which the advance width of the\n+                                 * glyph is permitted to shrink on the left or top side. *\/\n+  Fixed         afterGrowLimit; \/* The ratio by which the advance width of the glyph\n+                                 * is permitted to shrink on the left or top side. *\/\n+  Fixed         afterShrinkLimit;\n+                                \/* The ratio by which the advance width of the glyph\n+                                 * is at most permitted to shrink on the right or\n+                                 * bottom side. *\/\n+  HBUINT16      growFlags;      \/* Flags controlling the grow case. *\/\n+  HBUINT16      shrinkFlags;    \/* Flags controlling the shrink case. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+struct WidthDeltaPair\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT32      justClass;      \/* The justification category associated\n+                                 * with the wdRecord field. Only 7 bits of\n+                                 * this field are used. (The other bits are\n+                                 * used as padding to guarantee longword\n+                                 * alignment of the following record). *\/\n+  JustWidthDeltaEntry\n+                wdRecord;       \/* The actual width delta record. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (24);\n+};\n+\n+typedef OT::LArrayOf<WidthDeltaPair> WidthDeltaCluster;\n+\n+struct JustificationCategory\n+{\n+  typedef void EntryData;\n+\n+  enum Flags\n+  {\n+    SetMark             =0x8000,\/* If set, make the current glyph the marked\n+                                 * glyph. *\/\n+    DontAdvance         =0x4000,\/* If set, don't advance to the next glyph before\n+                                 * going to the new state. *\/\n+    MarkCategory        =0x3F80,\/* The justification category for the marked\n+                                 * glyph if nonzero. *\/\n+    CurrentCategory     =0x007F \/* The justification category for the current\n+                                 * glyph if nonzero. *\/\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          morphHeader.sanitize (c) &&\n+                          stHeader.sanitize (c)));\n+  }\n+\n+  protected:\n+  ChainSubtable<ObsoleteTypes>\n+                morphHeader;    \/* Metamorphosis-style subtable header. *\/\n+  StateTable<ObsoleteTypes, EntryData>\n+                stHeader;       \/* The justification insertion state table header *\/\n+  public:\n+  DEFINE_SIZE_STATIC (30);\n+};\n+\n+struct JustificationHeader\n+{\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          justClassTable.sanitize (c, base, base) &&\n+                          wdcTable.sanitize (c, base) &&\n+                          pcTable.sanitize (c, base) &&\n+                          lookupTable.sanitize (c, base)));\n+  }\n+\n+  protected:\n+  OffsetTo<JustificationCategory>\n+                justClassTable; \/* Offset to the justification category state table. *\/\n+  OffsetTo<WidthDeltaCluster>\n+                wdcTable;       \/* Offset from start of justification table to start\n+                                 * of the subtable containing the width delta factors\n+                                 * for the glyphs in your font.\n+                                 *\n+                                 * The width delta clusters table. *\/\n+  OffsetTo<PostcompensationActionChain>\n+                pcTable;        \/* Offset from start of justification table to start\n+                                 * of postcompensation subtable (set to zero if none).\n+                                 *\n+                                 * The postcompensation subtable, if present in the font. *\/\n+  Lookup<OffsetTo<WidthDeltaCluster> >\n+                lookupTable;    \/* Lookup table associating glyphs with width delta\n+                                 * clusters. See the description of Width Delta Clusters\n+                                 * table for details on how to interpret the lookup values. *\/\n+\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+struct just\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_just;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    return_trace (likely (c->check_struct (this) &&\n+                          version.major == 1 &&\n+                          horizData.sanitize (c, this, this) &&\n+                          vertData.sanitize (c, this, this)));\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the justification table\n+                                 * (0x00010000u for version 1.0). *\/\n+  HBUINT16      format;         \/* Format of the justification table (set to 0). *\/\n+  OffsetTo<JustificationHeader>\n+                horizData;      \/* Byte offset from the start of the justification table\n+                                 * to the header for tables that contain justification\n+                                 * information for horizontal text.\n+                                 * If you are not including this information,\n+                                 * store 0. *\/\n+  OffsetTo<JustificationHeader>\n+                vertData;       \/* ditto, vertical *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LAYOUT_JUST_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-just-table.hh","additions":417,"deletions":0,"binary":false,"changes":417,"status":"added"},{"patch":"@@ -0,0 +1,1001 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_KERX_TABLE_HH\n+#define HB_AAT_LAYOUT_KERX_TABLE_HH\n+\n+#include \"hb-kern.hh\"\n+#include \"hb-aat-layout-ankr-table.hh\"\n+\n+\/*\n+ * kerx -- Extended Kerning\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6kerx.html\n+ *\/\n+#define HB_AAT_TAG_kerx HB_TAG('k','e','r','x')\n+\n+\n+namespace AAT {\n+\n+using namespace OT;\n+\n+\n+static inline int\n+kerxTupleKern (int value,\n+               unsigned int tupleCount,\n+               const void *base,\n+               hb_aat_apply_context_t *c)\n+{\n+  if (likely (!tupleCount || !c)) return value;\n+\n+  unsigned int offset = value;\n+  const FWORD *pv = &StructAtOffset<FWORD> (base, offset);\n+  if (unlikely (!c->sanitizer.check_array (pv, tupleCount))) return 0;\n+  return *pv;\n+}\n+\n+\n+struct hb_glyph_pair_t\n+{\n+  hb_codepoint_t left;\n+  hb_codepoint_t right;\n+};\n+\n+struct KernPair\n+{\n+  int get_kerning () const { return value; }\n+\n+  int cmp (const hb_glyph_pair_t &o) const\n+  {\n+    int ret = left.cmp (o.left);\n+    if (ret) return ret;\n+    return right.cmp (o.right);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  GlyphID       left;\n+  GlyphID       right;\n+  FWORD         value;\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+template <typename KernSubTableHeader>\n+struct KerxSubTableFormat0\n+{\n+  int get_kerning (hb_codepoint_t left, hb_codepoint_t right,\n+                   hb_aat_apply_context_t *c = nullptr) const\n+  {\n+    hb_glyph_pair_t pair = {left, right};\n+    int v = pairs.bsearch (pair).get_kerning ();\n+    return kerxTupleKern (v, header.tuple_count (), this, c);\n+  }\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    if (!c->plan->requested_kerning)\n+      return false;\n+\n+    if (header.coverage & header.Backwards)\n+      return false;\n+\n+    accelerator_t accel (*this, c);\n+    hb_kern_machine_t<accelerator_t> machine (accel, header.coverage & header.CrossStream);\n+    machine.kern (c->font, c->buffer, c->plan->kern_mask);\n+\n+    return_trace (true);\n+  }\n+\n+  struct accelerator_t\n+  {\n+    const KerxSubTableFormat0 &table;\n+    hb_aat_apply_context_t *c;\n+\n+    accelerator_t (const KerxSubTableFormat0 &table_,\n+                   hb_aat_apply_context_t *c_) :\n+                     table (table_), c (c_) {}\n+\n+    int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const\n+    { return table.get_kerning (left, right, c); }\n+  };\n+\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (pairs.sanitize (c)));\n+  }\n+\n+  protected:\n+  KernSubTableHeader    header;\n+  BinSearchArrayOf<KernPair, typename KernSubTableHeader::Types::HBUINT>\n+                        pairs;  \/* Sorted kern records. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (KernSubTableHeader::static_size + 16, pairs);\n+};\n+\n+\n+template <bool extended>\n+struct Format1Entry;\n+\n+template <>\n+struct Format1Entry<true>\n+{\n+  enum Flags\n+  {\n+    Push                = 0x8000,       \/* If set, push this glyph on the kerning stack. *\/\n+    DontAdvance         = 0x4000,       \/* If set, don't advance to the next glyph\n+                                         * before going to the new state. *\/\n+    Reset               = 0x2000,       \/* If set, reset the kerning data (clear the stack) *\/\n+    Reserved            = 0x1FFF,       \/* Not used; set to 0. *\/\n+  };\n+\n+  struct EntryData\n+  {\n+    HBUINT16    kernActionIndex;\/* Index into the kerning value array. If\n+                                 * this index is 0xFFFF, then no kerning\n+                                 * is to be performed. *\/\n+    public:\n+    DEFINE_SIZE_STATIC (2);\n+  };\n+\n+  static bool performAction (const Entry<EntryData> &entry)\n+  { return entry.data.kernActionIndex != 0xFFFF; }\n+\n+  static unsigned int kernActionIndex (const Entry<EntryData> &entry)\n+  { return entry.data.kernActionIndex; }\n+};\n+template <>\n+struct Format1Entry<false>\n+{\n+  enum Flags\n+  {\n+    Push                = 0x8000,       \/* If set, push this glyph on the kerning stack. *\/\n+    DontAdvance         = 0x4000,       \/* If set, don't advance to the next glyph\n+                                         * before going to the new state. *\/\n+    Offset              = 0x3FFF,       \/* Byte offset from beginning of subtable to the\n+                                         * value table for the glyphs on the kerning stack. *\/\n+\n+    Reset               = 0x0000,       \/* Not supported? *\/\n+  };\n+\n+  typedef void EntryData;\n+\n+  static bool performAction (const Entry<EntryData> &entry)\n+  { return entry.flags & Offset; }\n+\n+  static unsigned int kernActionIndex (const Entry<EntryData> &entry)\n+  { return entry.flags & Offset; }\n+};\n+\n+template <typename KernSubTableHeader>\n+struct KerxSubTableFormat1\n+{\n+  typedef typename KernSubTableHeader::Types Types;\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  typedef Format1Entry<Types::extended> Format1EntryT;\n+  typedef typename Format1EntryT::EntryData EntryData;\n+\n+  struct driver_context_t\n+  {\n+    static constexpr bool in_place = true;\n+    enum\n+    {\n+      DontAdvance       = Format1EntryT::DontAdvance,\n+    };\n+\n+    driver_context_t (const KerxSubTableFormat1 *table_,\n+                      hb_aat_apply_context_t *c_) :\n+        c (c_),\n+        table (table_),\n+        \/* Apparently the offset kernAction is from the beginning of the state-machine,\n+         * similar to offsets in morx table, NOT from beginning of this table, like\n+         * other subtables in kerx.  Discovered via testing. *\/\n+        kernAction (&table->machine + table->kernAction),\n+        depth (0),\n+        crossStream (table->header.coverage & table->header.CrossStream) {}\n+\n+    bool is_actionable (StateTableDriver<Types, EntryData> *driver HB_UNUSED,\n+                        const Entry<EntryData> &entry)\n+    {\n+      return Format1EntryT::performAction (entry);\n+    }\n+    void transition (StateTableDriver<Types, EntryData> *driver,\n+                     const Entry<EntryData> &entry)\n+    {\n+      hb_buffer_t *buffer = driver->buffer;\n+      unsigned int flags = entry.flags;\n+\n+      if (flags & Format1EntryT::Reset)\n+        depth = 0;\n+\n+      if (flags & Format1EntryT::Push)\n+      {\n+        if (likely (depth < ARRAY_LENGTH (stack)))\n+          stack[depth++] = buffer->idx;\n+        else\n+          depth = 0; \/* Probably not what CoreText does, but better? *\/\n+      }\n+\n+      if (Format1EntryT::performAction (entry) && depth)\n+      {\n+        unsigned int tuple_count = MAX (1u, table->header.tuple_count ());\n+\n+        unsigned int kern_idx = Format1EntryT::kernActionIndex (entry);\n+        kern_idx = Types::byteOffsetToIndex (kern_idx, &table->machine, kernAction.arrayZ);\n+        const FWORD *actions = &kernAction[kern_idx];\n+        if (!c->sanitizer.check_array (actions, depth, tuple_count))\n+        {\n+          depth = 0;\n+          return;\n+        }\n+\n+        hb_mask_t kern_mask = c->plan->kern_mask;\n+\n+        \/* From Apple 'kern' spec:\n+         * \"Each pops one glyph from the kerning stack and applies the kerning value to it.\n+         * The end of the list is marked by an odd value... *\/\n+        bool last = false;\n+        while (!last && depth)\n+        {\n+          unsigned int idx = stack[--depth];\n+          int v = *actions;\n+          actions += tuple_count;\n+          if (idx >= buffer->len) continue;\n+\n+          \/* \"The end of the list is marked by an odd value...\" *\/\n+          last = v & 1;\n+          v &= ~1;\n+\n+          hb_glyph_position_t &o = buffer->pos[idx];\n+\n+          \/* Testing shows that CoreText only applies kern (cross-stream or not)\n+           * if none has been applied by previous subtables.  That is, it does\n+           * NOT seem to accumulate as otherwise implied by specs. *\/\n+\n+          \/* The following flag is undocumented in the spec, but described\n+           * in the 'kern' table example. *\/\n+          if (v == -0x8000)\n+          {\n+            o.attach_type() = ATTACH_TYPE_NONE;\n+            o.attach_chain() = 0;\n+            o.x_offset = o.y_offset = 0;\n+          }\n+          else if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction))\n+          {\n+            if (crossStream)\n+            {\n+              if (buffer->pos[idx].attach_type() && !buffer->pos[idx].y_offset)\n+              {\n+                o.y_offset = c->font->em_scale_y (v);\n+                buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+              }\n+            }\n+            else if (buffer->info[idx].mask & kern_mask)\n+            {\n+              if (!buffer->pos[idx].x_offset)\n+              {\n+                buffer->pos[idx].x_advance += c->font->em_scale_x (v);\n+                buffer->pos[idx].x_offset += c->font->em_scale_x (v);\n+              }\n+            }\n+          }\n+          else\n+          {\n+            if (crossStream)\n+            {\n+              \/* CoreText doesn't do crossStream kerning in vertical.  We do. *\/\n+              if (buffer->pos[idx].attach_type() && !buffer->pos[idx].x_offset)\n+              {\n+                o.x_offset = c->font->em_scale_x (v);\n+                buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+              }\n+            }\n+            else if (buffer->info[idx].mask & kern_mask)\n+            {\n+              if (!buffer->pos[idx].y_offset)\n+              {\n+                buffer->pos[idx].y_advance += c->font->em_scale_y (v);\n+                buffer->pos[idx].y_offset += c->font->em_scale_y (v);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    private:\n+    hb_aat_apply_context_t *c;\n+    const KerxSubTableFormat1 *table;\n+    const UnsizedArrayOf<FWORD> &kernAction;\n+    unsigned int stack[8];\n+    unsigned int depth;\n+    bool crossStream;\n+  };\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    if (!c->plan->requested_kerning &&\n+        !(header.coverage & header.CrossStream))\n+      return false;\n+\n+    driver_context_t dc (this, c);\n+\n+    StateTableDriver<Types, EntryData> driver (machine, c->buffer, c->font->face);\n+    driver.drive (&dc);\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* The rest of array sanitizations are done at run-time. *\/\n+    return_trace (likely (c->check_struct (this) &&\n+                          machine.sanitize (c)));\n+  }\n+\n+  protected:\n+  KernSubTableHeader                            header;\n+  StateTable<Types, EntryData>                  machine;\n+  NNOffsetTo<UnsizedArrayOf<FWORD>, HBUINT>     kernAction;\n+  public:\n+  DEFINE_SIZE_STATIC (KernSubTableHeader::static_size + 5 * sizeof (HBUINT));\n+};\n+\n+template <typename KernSubTableHeader>\n+struct KerxSubTableFormat2\n+{\n+  typedef typename KernSubTableHeader::Types Types;\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  int get_kerning (hb_codepoint_t left, hb_codepoint_t right,\n+                   hb_aat_apply_context_t *c) const\n+  {\n+    unsigned int num_glyphs = c->sanitizer.get_num_glyphs ();\n+    unsigned int l = (this+leftClassTable).get_class (left, num_glyphs, 0);\n+    unsigned int r = (this+rightClassTable).get_class (right, num_glyphs, 0);\n+\n+    const UnsizedArrayOf<FWORD> &arrayZ = this+array;\n+    unsigned int kern_idx = l + r;\n+    kern_idx = Types::offsetToIndex (kern_idx, this, &arrayZ);\n+    const FWORD *v = &arrayZ[kern_idx];\n+    if (unlikely (!v->sanitize (&c->sanitizer))) return 0;\n+\n+    return kerxTupleKern (*v, header.tuple_count (), this, c);\n+  }\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    if (!c->plan->requested_kerning)\n+      return false;\n+\n+    if (header.coverage & header.Backwards)\n+      return false;\n+\n+    accelerator_t accel (*this, c);\n+    hb_kern_machine_t<accelerator_t> machine (accel, header.coverage & header.CrossStream);\n+    machine.kern (c->font, c->buffer, c->plan->kern_mask);\n+\n+    return_trace (true);\n+  }\n+\n+  struct accelerator_t\n+  {\n+    const KerxSubTableFormat2 &table;\n+    hb_aat_apply_context_t *c;\n+\n+    accelerator_t (const KerxSubTableFormat2 &table_,\n+                   hb_aat_apply_context_t *c_) :\n+                     table (table_), c (c_) {}\n+\n+    int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const\n+    { return table.get_kerning (left, right, c); }\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          leftClassTable.sanitize (c, this) &&\n+                          rightClassTable.sanitize (c, this) &&\n+                          c->check_range (this, array)));\n+  }\n+\n+  protected:\n+  KernSubTableHeader    header;\n+  HBUINT                rowWidth;       \/* The width, in bytes, of a row in the table. *\/\n+  NNOffsetTo<typename Types::ClassTypeWide, HBUINT>\n+                        leftClassTable; \/* Offset from beginning of this subtable to\n+                                         * left-hand class table. *\/\n+  NNOffsetTo<typename Types::ClassTypeWide, HBUINT>\n+                        rightClassTable;\/* Offset from beginning of this subtable to\n+                                         * right-hand class table. *\/\n+  NNOffsetTo<UnsizedArrayOf<FWORD>, HBUINT>\n+                         array;         \/* Offset from beginning of this subtable to\n+                                         * the start of the kerning array. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (KernSubTableHeader::static_size + 4 * sizeof (HBUINT));\n+};\n+\n+template <typename KernSubTableHeader>\n+struct KerxSubTableFormat4\n+{\n+  typedef ExtendedTypes Types;\n+\n+  struct EntryData\n+  {\n+    HBUINT16    ankrActionIndex;\/* Either 0xFFFF (for no action) or the index of\n+                                 * the action to perform. *\/\n+    public:\n+    DEFINE_SIZE_STATIC (2);\n+  };\n+\n+  struct driver_context_t\n+  {\n+    static constexpr bool in_place = true;\n+    enum Flags\n+    {\n+      Mark              = 0x8000,       \/* If set, remember this glyph as the marked glyph. *\/\n+      DontAdvance       = 0x4000,       \/* If set, don't advance to the next glyph before\n+                                         * going to the new state. *\/\n+      Reserved          = 0x3FFF,       \/* Not used; set to 0. *\/\n+    };\n+\n+    enum SubTableFlags\n+    {\n+      ActionType        = 0xC0000000,   \/* A two-bit field containing the action type. *\/\n+      Unused            = 0x3F000000,   \/* Unused - must be zero. *\/\n+      Offset            = 0x00FFFFFF,   \/* Masks the offset in bytes from the beginning\n+                                         * of the subtable to the beginning of the control\n+                                         * point table. *\/\n+    };\n+\n+    driver_context_t (const KerxSubTableFormat4 *table,\n+                             hb_aat_apply_context_t *c_) :\n+        c (c_),\n+        action_type ((table->flags & ActionType) >> 30),\n+        ankrData ((HBUINT16 *) ((const char *) &table->machine + (table->flags & Offset))),\n+        mark_set (false),\n+        mark (0) {}\n+\n+    bool is_actionable (StateTableDriver<Types, EntryData> *driver HB_UNUSED,\n+                        const Entry<EntryData> &entry)\n+    {\n+      return entry.data.ankrActionIndex != 0xFFFF;\n+    }\n+    void transition (StateTableDriver<Types, EntryData> *driver,\n+                     const Entry<EntryData> &entry)\n+    {\n+      hb_buffer_t *buffer = driver->buffer;\n+\n+      if (mark_set && entry.data.ankrActionIndex != 0xFFFF && buffer->idx < buffer->len)\n+      {\n+        hb_glyph_position_t &o = buffer->cur_pos();\n+        switch (action_type)\n+        {\n+          case 0: \/* Control Point Actions.*\/\n+          {\n+            \/* indexed into glyph outline. *\/\n+            const HBUINT16 *data = &ankrData[entry.data.ankrActionIndex];\n+            if (!c->sanitizer.check_array (data, 2)) return;\n+            HB_UNUSED unsigned int markControlPoint = *data++;\n+            HB_UNUSED unsigned int currControlPoint = *data++;\n+            hb_position_t markX = 0;\n+            hb_position_t markY = 0;\n+            hb_position_t currX = 0;\n+            hb_position_t currY = 0;\n+            if (!c->font->get_glyph_contour_point_for_origin (c->buffer->info[mark].codepoint,\n+                                                              markControlPoint,\n+                                                              HB_DIRECTION_LTR \/*XXX*\/,\n+                                                              &markX, &markY) ||\n+                !c->font->get_glyph_contour_point_for_origin (c->buffer->cur ().codepoint,\n+                                                              currControlPoint,\n+                                                              HB_DIRECTION_LTR \/*XXX*\/,\n+                                                              &currX, &currY))\n+              return;\n+\n+            o.x_offset = markX - currX;\n+            o.y_offset = markY - currY;\n+          }\n+          break;\n+\n+          case 1: \/* Anchor Point Actions. *\/\n+          {\n+           \/* Indexed into 'ankr' table. *\/\n+            const HBUINT16 *data = &ankrData[entry.data.ankrActionIndex];\n+            if (!c->sanitizer.check_array (data, 2)) return;\n+            unsigned int markAnchorPoint = *data++;\n+            unsigned int currAnchorPoint = *data++;\n+            const Anchor &markAnchor = c->ankr_table->get_anchor (c->buffer->info[mark].codepoint,\n+                                                                  markAnchorPoint,\n+                                                                  c->sanitizer.get_num_glyphs ());\n+            const Anchor &currAnchor = c->ankr_table->get_anchor (c->buffer->cur ().codepoint,\n+                                                                  currAnchorPoint,\n+                                                                  c->sanitizer.get_num_glyphs ());\n+\n+            o.x_offset = c->font->em_scale_x (markAnchor.xCoordinate) - c->font->em_scale_x (currAnchor.xCoordinate);\n+            o.y_offset = c->font->em_scale_y (markAnchor.yCoordinate) - c->font->em_scale_y (currAnchor.yCoordinate);\n+          }\n+          break;\n+\n+          case 2: \/* Control Point Coordinate Actions. *\/\n+          {\n+            const FWORD *data = (const FWORD *) &ankrData[entry.data.ankrActionIndex];\n+            if (!c->sanitizer.check_array (data, 4)) return;\n+            int markX = *data++;\n+            int markY = *data++;\n+            int currX = *data++;\n+            int currY = *data++;\n+\n+            o.x_offset = c->font->em_scale_x (markX) - c->font->em_scale_x (currX);\n+            o.y_offset = c->font->em_scale_y (markY) - c->font->em_scale_y (currY);\n+          }\n+          break;\n+        }\n+        o.attach_type() = ATTACH_TYPE_MARK;\n+        o.attach_chain() = (int) mark - (int) buffer->idx;\n+        buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+      }\n+\n+      if (entry.flags & Mark)\n+      {\n+        mark_set = true;\n+        mark = buffer->idx;\n+      }\n+    }\n+\n+    private:\n+    hb_aat_apply_context_t *c;\n+    unsigned int action_type;\n+    const HBUINT16 *ankrData;\n+    bool mark_set;\n+    unsigned int mark;\n+  };\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    driver_context_t dc (this, c);\n+\n+    StateTableDriver<Types, EntryData> driver (machine, c->buffer, c->font->face);\n+    driver.drive (&dc);\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* The rest of array sanitizations are done at run-time. *\/\n+    return_trace (likely (c->check_struct (this) &&\n+                          machine.sanitize (c)));\n+  }\n+\n+  protected:\n+  KernSubTableHeader            header;\n+  StateTable<Types, EntryData>  machine;\n+  HBUINT32                      flags;\n+  public:\n+  DEFINE_SIZE_STATIC (KernSubTableHeader::static_size + 20);\n+};\n+\n+template <typename KernSubTableHeader>\n+struct KerxSubTableFormat6\n+{\n+  enum Flags\n+  {\n+    ValuesAreLong       = 0x00000001,\n+  };\n+\n+  bool is_long () const { return flags & ValuesAreLong; }\n+\n+  int get_kerning (hb_codepoint_t left, hb_codepoint_t right,\n+                          hb_aat_apply_context_t *c) const\n+  {\n+    unsigned int num_glyphs = c->sanitizer.get_num_glyphs ();\n+    if (is_long ())\n+    {\n+      const typename U::Long &t = u.l;\n+      unsigned int l = (this+t.rowIndexTable).get_value_or_null (left, num_glyphs);\n+      unsigned int r = (this+t.columnIndexTable).get_value_or_null (right, num_glyphs);\n+      unsigned int offset = l + r;\n+      if (unlikely (offset < l)) return 0; \/* Addition overflow. *\/\n+      if (unlikely (hb_unsigned_mul_overflows (offset, sizeof (FWORD32)))) return 0;\n+      const FWORD32 *v = &StructAtOffset<FWORD32> (&(this+t.array), offset * sizeof (FWORD32));\n+      if (unlikely (!v->sanitize (&c->sanitizer))) return 0;\n+      return kerxTupleKern (*v, header.tuple_count (), &(this+vector), c);\n+    }\n+    else\n+    {\n+      const typename U::Short &t = u.s;\n+      unsigned int l = (this+t.rowIndexTable).get_value_or_null (left, num_glyphs);\n+      unsigned int r = (this+t.columnIndexTable).get_value_or_null (right, num_glyphs);\n+      unsigned int offset = l + r;\n+      const FWORD *v = &StructAtOffset<FWORD> (&(this+t.array), offset * sizeof (FWORD));\n+      if (unlikely (!v->sanitize (&c->sanitizer))) return 0;\n+      return kerxTupleKern (*v, header.tuple_count (), &(this+vector), c);\n+    }\n+  }\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    if (!c->plan->requested_kerning)\n+      return false;\n+\n+    if (header.coverage & header.Backwards)\n+      return false;\n+\n+    accelerator_t accel (*this, c);\n+    hb_kern_machine_t<accelerator_t> machine (accel, header.coverage & header.CrossStream);\n+    machine.kern (c->font, c->buffer, c->plan->kern_mask);\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (is_long () ?\n+                           (\n+                             u.l.rowIndexTable.sanitize (c, this) &&\n+                             u.l.columnIndexTable.sanitize (c, this) &&\n+                             c->check_range (this, u.l.array)\n+                           ) : (\n+                             u.s.rowIndexTable.sanitize (c, this) &&\n+                             u.s.columnIndexTable.sanitize (c, this) &&\n+                             c->check_range (this, u.s.array)\n+                           )) &&\n+                          (header.tuple_count () == 0 ||\n+                           c->check_range (this, vector))));\n+  }\n+\n+  struct accelerator_t\n+  {\n+    const KerxSubTableFormat6 &table;\n+    hb_aat_apply_context_t *c;\n+\n+    accelerator_t (const KerxSubTableFormat6 &table_,\n+                   hb_aat_apply_context_t *c_) :\n+                     table (table_), c (c_) {}\n+\n+    int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const\n+    { return table.get_kerning (left, right, c); }\n+  };\n+\n+  protected:\n+  KernSubTableHeader            header;\n+  HBUINT32                      flags;\n+  HBUINT16                      rowCount;\n+  HBUINT16                      columnCount;\n+  union U\n+  {\n+    struct Long\n+    {\n+      LNNOffsetTo<Lookup<HBUINT32> >            rowIndexTable;\n+      LNNOffsetTo<Lookup<HBUINT32> >            columnIndexTable;\n+      LNNOffsetTo<UnsizedArrayOf<FWORD32> >     array;\n+    } l;\n+    struct Short\n+    {\n+      LNNOffsetTo<Lookup<HBUINT16> >            rowIndexTable;\n+      LNNOffsetTo<Lookup<HBUINT16> >            columnIndexTable;\n+      LNNOffsetTo<UnsizedArrayOf<FWORD> >       array;\n+    } s;\n+  } u;\n+  LNNOffsetTo<UnsizedArrayOf<FWORD> >   vector;\n+  public:\n+  DEFINE_SIZE_STATIC (KernSubTableHeader::static_size + 24);\n+};\n+\n+\n+struct KerxSubTableHeader\n+{\n+  typedef ExtendedTypes Types;\n+\n+  unsigned int tuple_count () const { return tupleCount; }\n+  bool is_horizontal () const       { return !(coverage & Vertical); }\n+\n+  enum Coverage\n+  {\n+    Vertical    = 0x80000000u,  \/* Set if table has vertical kerning values. *\/\n+    CrossStream = 0x40000000u,  \/* Set if table has cross-stream kerning values. *\/\n+    Variation   = 0x20000000u,  \/* Set if table has variation kerning values. *\/\n+    Backwards   = 0x10000000u,  \/* If clear, process the glyphs forwards, that\n+                                 * is, from first to last in the glyph stream.\n+                                 * If we, process them from last to first.\n+                                 * This flag only applies to state-table based\n+                                 * 'kerx' subtables (types 1 and 4). *\/\n+    Reserved    = 0x0FFFFF00u,  \/* Reserved, set to zero. *\/\n+    SubtableType= 0x000000FFu,  \/* Subtable type. *\/\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  public:\n+  HBUINT32      length;\n+  HBUINT32      coverage;\n+  HBUINT32      tupleCount;\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct KerxSubTable\n+{\n+  friend struct kerx;\n+\n+  unsigned int get_size () const { return u.header.length; }\n+  unsigned int get_type () const { return u.header.coverage & u.header.SubtableType; }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    unsigned int subtable_type = get_type ();\n+    TRACE_DISPATCH (this, subtable_type);\n+    switch (subtable_type) {\n+    case 0:     return_trace (c->dispatch (u.format0));\n+    case 1:     return_trace (c->dispatch (u.format1));\n+    case 2:     return_trace (c->dispatch (u.format2));\n+    case 4:     return_trace (c->dispatch (u.format4));\n+    case 6:     return_trace (c->dispatch (u.format6));\n+    default:    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.header.sanitize (c) ||\n+        u.header.length <= u.header.static_size ||\n+        !c->check_range (this, u.header.length))\n+      return_trace (false);\n+\n+    return_trace (dispatch (c));\n+  }\n+\n+  public:\n+  union {\n+  KerxSubTableHeader                            header;\n+  KerxSubTableFormat0<KerxSubTableHeader>       format0;\n+  KerxSubTableFormat1<KerxSubTableHeader>       format1;\n+  KerxSubTableFormat2<KerxSubTableHeader>       format2;\n+  KerxSubTableFormat4<KerxSubTableHeader>       format4;\n+  KerxSubTableFormat6<KerxSubTableHeader>       format6;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (12);\n+};\n+\n+\n+\/*\n+ * The 'kerx' Table\n+ *\/\n+\n+template <typename T>\n+struct KerxTable\n+{\n+  \/* https:\/\/en.wikipedia.org\/wiki\/Curiously_recurring_template_pattern *\/\n+  const T* thiz () const { return static_cast<const T *> (this); }\n+\n+  bool has_state_machine () const\n+  {\n+    typedef typename T::SubTable SubTable;\n+\n+    const SubTable *st = &thiz()->firstSubTable;\n+    unsigned int count = thiz()->tableCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (st->get_type () == 1)\n+        return true;\n+      st = &StructAfter<SubTable> (*st);\n+    }\n+    return false;\n+  }\n+\n+  bool has_cross_stream () const\n+  {\n+    typedef typename T::SubTable SubTable;\n+\n+    const SubTable *st = &thiz()->firstSubTable;\n+    unsigned int count = thiz()->tableCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (st->u.header.coverage & st->u.header.CrossStream)\n+        return true;\n+      st = &StructAfter<SubTable> (*st);\n+    }\n+    return false;\n+  }\n+\n+  int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const\n+  {\n+    typedef typename T::SubTable SubTable;\n+\n+    int v = 0;\n+    const SubTable *st = &thiz()->firstSubTable;\n+    unsigned int count = thiz()->tableCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if ((st->u.header.coverage & (st->u.header.Variation | st->u.header.CrossStream)) ||\n+          !st->u.header.is_horizontal ())\n+        continue;\n+      v += st->get_kerning (left, right);\n+      st = &StructAfter<SubTable> (*st);\n+    }\n+    return v;\n+  }\n+\n+  bool apply (AAT::hb_aat_apply_context_t *c) const\n+  {\n+    typedef typename T::SubTable SubTable;\n+\n+    bool ret = false;\n+    bool seenCrossStream = false;\n+    c->set_lookup_index (0);\n+    const SubTable *st = &thiz()->firstSubTable;\n+    unsigned int count = thiz()->tableCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      bool reverse;\n+\n+      if (!T::Types::extended && (st->u.header.coverage & st->u.header.Variation))\n+        goto skip;\n+\n+      if (HB_DIRECTION_IS_HORIZONTAL (c->buffer->props.direction) != st->u.header.is_horizontal ())\n+        goto skip;\n+\n+      reverse = bool (st->u.header.coverage & st->u.header.Backwards) !=\n+                HB_DIRECTION_IS_BACKWARD (c->buffer->props.direction);\n+\n+      if (!c->buffer->message (c->font, \"start %c%c%c%c subtable %d\", HB_UNTAG (thiz()->tableTag), c->lookup_index))\n+        goto skip;\n+\n+      if (!seenCrossStream &&\n+          (st->u.header.coverage & st->u.header.CrossStream))\n+      {\n+        \/* Attach all glyphs into a chain. *\/\n+        seenCrossStream = true;\n+        hb_glyph_position_t *pos = c->buffer->pos;\n+        unsigned int count = c->buffer->len;\n+        for (unsigned int i = 0; i < count; i++)\n+        {\n+          pos[i].attach_type() = ATTACH_TYPE_CURSIVE;\n+          pos[i].attach_chain() = HB_DIRECTION_IS_FORWARD (c->buffer->props.direction) ? -1 : +1;\n+          \/* We intentionally don't set HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT,\n+           * since there needs to be a non-zero attachment for post-positioning to\n+           * be needed. *\/\n+        }\n+      }\n+\n+      if (reverse)\n+        c->buffer->reverse ();\n+\n+      {\n+        \/* See comment in sanitize() for conditional here. *\/\n+        hb_sanitize_with_object_t with (&c->sanitizer, i < count - 1 ? st : (const SubTable *) nullptr);\n+        ret |= st->dispatch (c);\n+      }\n+\n+      if (reverse)\n+        c->buffer->reverse ();\n+\n+      (void) c->buffer->message (c->font, \"end %c%c%c%c subtable %d\", HB_UNTAG (thiz()->tableTag), c->lookup_index);\n+\n+    skip:\n+      st = &StructAfter<SubTable> (*st);\n+      c->set_lookup_index (c->lookup_index + 1);\n+    }\n+\n+    return ret;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!thiz()->version.sanitize (c) ||\n+                  (unsigned) thiz()->version < (unsigned) T::minVersion ||\n+                  !thiz()->tableCount.sanitize (c)))\n+      return_trace (false);\n+\n+    typedef typename T::SubTable SubTable;\n+\n+    const SubTable *st = &thiz()->firstSubTable;\n+    unsigned int count = thiz()->tableCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (unlikely (!st->u.header.sanitize (c)))\n+        return_trace (false);\n+      \/* OpenType kern table has 2-byte subtable lengths.  That's limiting.\n+       * MS implementation also only supports one subtable, of format 0,\n+       * anyway.  Certain versions of some fonts, like Calibry, contain\n+       * kern subtable that exceeds 64kb.  Looks like, the subtable length\n+       * is simply ignored.  Which makes sense.  It's only needed if you\n+       * have multiple subtables.  To handle such fonts, we just ignore\n+       * the length for the last subtable. *\/\n+      hb_sanitize_with_object_t with (c, i < count - 1 ? st : (const SubTable *) nullptr);\n+\n+      if (unlikely (!st->sanitize (c)))\n+        return_trace (false);\n+\n+      st = &StructAfter<SubTable> (*st);\n+    }\n+\n+    return_trace (true);\n+  }\n+};\n+\n+struct kerx : KerxTable<kerx>\n+{\n+  friend struct KerxTable<kerx>;\n+\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_kerx;\n+  static constexpr unsigned minVersion = 2u;\n+\n+  typedef KerxSubTableHeader SubTableHeader;\n+  typedef SubTableHeader::Types Types;\n+  typedef KerxSubTable SubTable;\n+\n+  bool has_data () const { return version; }\n+\n+  protected:\n+  HBUINT16      version;        \/* The version number of the extended kerning table\n+                                 * (currently 2, 3, or 4). *\/\n+  HBUINT16      unused;         \/* Set to 0. *\/\n+  HBUINT32      tableCount;     \/* The number of subtables included in the extended kerning\n+                                 * table. *\/\n+  SubTable      firstSubTable;  \/* Subtables. *\/\n+\/*subtableGlyphCoverageArray*\/  \/* Only if version >= 3. We don't use. *\/\n+\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LAYOUT_KERX_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-kerx-table.hh","additions":1001,"deletions":0,"binary":false,"changes":1001,"status":"added"},{"patch":"@@ -0,0 +1,93 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+#ifndef HB_AAT_LAYOUT_LCAR_TABLE_HH\n+#define HB_AAT_LAYOUT_LCAR_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-aat-layout-common.hh\"\n+\n+\/*\n+ * lcar -- Ligature caret\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6lcar.html\n+ *\/\n+#define HB_AAT_TAG_lcar HB_TAG('l','c','a','r')\n+\n+\n+namespace AAT {\n+\n+typedef ArrayOf<HBINT16> LigCaretClassEntry;\n+\n+struct lcar\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_lcar;\n+\n+  unsigned int get_lig_carets (hb_font_t      *font,\n+                               hb_direction_t  direction,\n+                               hb_codepoint_t  glyph,\n+                               unsigned int    start_offset,\n+                               unsigned int   *caret_count \/* IN\/OUT *\/,\n+                               hb_position_t  *caret_array \/* OUT *\/) const\n+  {\n+    const OffsetTo<LigCaretClassEntry>* entry_offset = lookup.get_value (glyph,\n+                                                                         font->face->get_num_glyphs ());\n+    const LigCaretClassEntry& array = entry_offset ? this+*entry_offset : Null (LigCaretClassEntry);\n+    if (caret_count)\n+    {\n+      hb_array_t<const HBINT16> arr = array.sub_array (start_offset, caret_count);\n+      unsigned int count = arr.length;\n+      for (unsigned int i = 0; i < count; ++i)\n+        switch (format)\n+        {\n+        case 0: caret_array[i] = font->em_scale_dir (arr[i], direction); break;\n+        case 1:\n+          hb_position_t x, y;\n+          font->get_glyph_contour_point_for_origin (glyph, arr[i], direction, &x, &y);\n+          caret_array[i] = HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;\n+          break;\n+        }\n+    }\n+    return array.len;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          version.major == 1 &&\n+                          lookup.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version number of the ligature caret table *\/\n+  HBUINT16      format;         \/* Format of the ligature caret table. *\/\n+  Lookup<OffsetTo<LigCaretClassEntry> >\n+                lookup;         \/* data Lookup table associating glyphs *\/\n+\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+#endif \/* HB_AAT_LAYOUT_LCAR_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-lcar-table.hh","additions":93,"deletions":0,"binary":false,"changes":93,"status":"added"},{"patch":"@@ -0,0 +1,1159 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_MORX_TABLE_HH\n+#define HB_AAT_LAYOUT_MORX_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-aat-layout-common.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-aat-map.hh\"\n+\n+\/*\n+ * morx -- Extended Glyph Metamorphosis\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6morx.html\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6mort.html\n+ *\/\n+#define HB_AAT_TAG_morx HB_TAG('m','o','r','x')\n+#define HB_AAT_TAG_mort HB_TAG('m','o','r','t')\n+\n+\n+namespace AAT {\n+\n+using namespace OT;\n+\n+template <typename Types>\n+struct RearrangementSubtable\n+{\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  typedef void EntryData;\n+\n+  struct driver_context_t\n+  {\n+    static constexpr bool in_place = true;\n+    enum Flags\n+    {\n+      MarkFirst         = 0x8000,       \/* If set, make the current glyph the first\n+                                         * glyph to be rearranged. *\/\n+      DontAdvance       = 0x4000,       \/* If set, don't advance to the next glyph\n+                                         * before going to the new state. This means\n+                                         * that the glyph index doesn't change, even\n+                                         * if the glyph at that index has changed. *\/\n+      MarkLast          = 0x2000,       \/* If set, make the current glyph the last\n+                                         * glyph to be rearranged. *\/\n+      Reserved          = 0x1FF0,       \/* These bits are reserved and should be set to 0. *\/\n+      Verb              = 0x000F,       \/* The type of rearrangement specified. *\/\n+    };\n+\n+    driver_context_t (const RearrangementSubtable *table HB_UNUSED) :\n+        ret (false),\n+        start (0), end (0) {}\n+\n+    bool is_actionable (StateTableDriver<Types, EntryData> *driver HB_UNUSED,\n+                        const Entry<EntryData> &entry)\n+    {\n+      return (entry.flags & Verb) && start < end;\n+    }\n+    void transition (StateTableDriver<Types, EntryData> *driver,\n+                     const Entry<EntryData> &entry)\n+    {\n+      hb_buffer_t *buffer = driver->buffer;\n+      unsigned int flags = entry.flags;\n+\n+      if (flags & MarkFirst)\n+        start = buffer->idx;\n+\n+      if (flags & MarkLast)\n+        end = MIN (buffer->idx + 1, buffer->len);\n+\n+      if ((flags & Verb) && start < end)\n+      {\n+        \/* The following map has two nibbles, for start-side\n+         * and end-side. Values of 0,1,2 mean move that many\n+         * to the other side. Value of 3 means move 2 and\n+         * flip them. *\/\n+        const unsigned char map[16] =\n+        {\n+          0x00, \/* 0    no change *\/\n+          0x10, \/* 1    Ax => xA *\/\n+          0x01, \/* 2    xD => Dx *\/\n+          0x11, \/* 3    AxD => DxA *\/\n+          0x20, \/* 4    ABx => xAB *\/\n+          0x30, \/* 5    ABx => xBA *\/\n+          0x02, \/* 6    xCD => CDx *\/\n+          0x03, \/* 7    xCD => DCx *\/\n+          0x12, \/* 8    AxCD => CDxA *\/\n+          0x13, \/* 9    AxCD => DCxA *\/\n+          0x21, \/* 10   ABxD => DxAB *\/\n+          0x31, \/* 11   ABxD => DxBA *\/\n+          0x22, \/* 12   ABxCD => CDxAB *\/\n+          0x32, \/* 13   ABxCD => CDxBA *\/\n+          0x23, \/* 14   ABxCD => DCxAB *\/\n+          0x33, \/* 15   ABxCD => DCxBA *\/\n+        };\n+\n+        unsigned int m = map[flags & Verb];\n+        unsigned int l = MIN<unsigned int> (2, m >> 4);\n+        unsigned int r = MIN<unsigned int> (2, m & 0x0F);\n+        bool reverse_l = 3 == (m >> 4);\n+        bool reverse_r = 3 == (m & 0x0F);\n+\n+        if (end - start >= l + r)\n+        {\n+          buffer->merge_clusters (start, MIN (buffer->idx + 1, buffer->len));\n+          buffer->merge_clusters (start, end);\n+\n+          hb_glyph_info_t *info = buffer->info;\n+          hb_glyph_info_t buf[4];\n+\n+          memcpy (buf, info + start, l * sizeof (buf[0]));\n+          memcpy (buf + 2, info + end - r, r * sizeof (buf[0]));\n+\n+          if (l != r)\n+            memmove (info + start + r, info + start + l, (end - start - l - r) * sizeof (buf[0]));\n+\n+          memcpy (info + start, buf + 2, r * sizeof (buf[0]));\n+          memcpy (info + end - l, buf, l * sizeof (buf[0]));\n+          if (reverse_l)\n+          {\n+            buf[0] = info[end - 1];\n+            info[end - 1] = info[end - 2];\n+            info[end - 2] = buf[0];\n+          }\n+          if (reverse_r)\n+          {\n+            buf[0] = info[start];\n+            info[start] = info[start + 1];\n+            info[start + 1] = buf[0];\n+          }\n+        }\n+      }\n+    }\n+\n+    public:\n+    bool ret;\n+    private:\n+    unsigned int start;\n+    unsigned int end;\n+  };\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    driver_context_t dc (this);\n+\n+    StateTableDriver<Types, EntryData> driver (machine, c->buffer, c->face);\n+    driver.drive (&dc);\n+\n+    return_trace (dc.ret);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (machine.sanitize (c));\n+  }\n+\n+  protected:\n+  StateTable<Types, EntryData>  machine;\n+  public:\n+  DEFINE_SIZE_STATIC (16);\n+};\n+\n+template <typename Types>\n+struct ContextualSubtable\n+{\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  struct EntryData\n+  {\n+    HBUINT16    markIndex;      \/* Index of the substitution table for the\n+                                 * marked glyph (use 0xFFFF for none). *\/\n+    HBUINT16    currentIndex;   \/* Index of the substitution table for the\n+                                 * current glyph (use 0xFFFF for none). *\/\n+    public:\n+    DEFINE_SIZE_STATIC (4);\n+  };\n+\n+  struct driver_context_t\n+  {\n+    static constexpr bool in_place = true;\n+    enum Flags\n+    {\n+      SetMark           = 0x8000,       \/* If set, make the current glyph the marked glyph. *\/\n+      DontAdvance       = 0x4000,       \/* If set, don't advance to the next glyph before\n+                                         * going to the new state. *\/\n+      Reserved          = 0x3FFF,       \/* These bits are reserved and should be set to 0. *\/\n+    };\n+\n+    driver_context_t (const ContextualSubtable *table_,\n+                             hb_aat_apply_context_t *c_) :\n+        ret (false),\n+        c (c_),\n+        mark_set (false),\n+        mark (0),\n+        table (table_),\n+        subs (table+table->substitutionTables) {}\n+\n+    bool is_actionable (StateTableDriver<Types, EntryData> *driver,\n+                        const Entry<EntryData> &entry)\n+    {\n+      hb_buffer_t *buffer = driver->buffer;\n+\n+      if (buffer->idx == buffer->len && !mark_set)\n+        return false;\n+\n+      return entry.data.markIndex != 0xFFFF || entry.data.currentIndex != 0xFFFF;\n+    }\n+    void transition (StateTableDriver<Types, EntryData> *driver,\n+                     const Entry<EntryData> &entry)\n+    {\n+      hb_buffer_t *buffer = driver->buffer;\n+\n+      \/* Looks like CoreText applies neither mark nor current substitution for\n+       * end-of-text if mark was not explicitly set. *\/\n+      if (buffer->idx == buffer->len && !mark_set)\n+        return;\n+\n+      const GlyphID *replacement;\n+\n+      replacement = nullptr;\n+      if (Types::extended)\n+      {\n+        if (entry.data.markIndex != 0xFFFF)\n+        {\n+          const Lookup<GlyphID> &lookup = subs[entry.data.markIndex];\n+          replacement = lookup.get_value (buffer->info[mark].codepoint, driver->num_glyphs);\n+        }\n+      }\n+      else\n+      {\n+        unsigned int offset = entry.data.markIndex + buffer->info[mark].codepoint;\n+        const UnsizedArrayOf<GlyphID> &subs_old = (const UnsizedArrayOf<GlyphID> &) subs;\n+        replacement = &subs_old[Types::wordOffsetToIndex (offset, table, subs_old.arrayZ)];\n+        if (!replacement->sanitize (&c->sanitizer) || !*replacement)\n+          replacement = nullptr;\n+      }\n+      if (replacement)\n+      {\n+        buffer->unsafe_to_break (mark, MIN (buffer->idx + 1, buffer->len));\n+        buffer->info[mark].codepoint = *replacement;\n+        ret = true;\n+      }\n+\n+      replacement = nullptr;\n+      unsigned int idx = MIN (buffer->idx, buffer->len - 1);\n+      if (Types::extended)\n+      {\n+        if (entry.data.currentIndex != 0xFFFF)\n+        {\n+          const Lookup<GlyphID> &lookup = subs[entry.data.currentIndex];\n+          replacement = lookup.get_value (buffer->info[idx].codepoint, driver->num_glyphs);\n+        }\n+      }\n+      else\n+      {\n+        unsigned int offset = entry.data.currentIndex + buffer->info[idx].codepoint;\n+        const UnsizedArrayOf<GlyphID> &subs_old = (const UnsizedArrayOf<GlyphID> &) subs;\n+        replacement = &subs_old[Types::wordOffsetToIndex (offset, table, subs_old.arrayZ)];\n+        if (!replacement->sanitize (&c->sanitizer) || !*replacement)\n+          replacement = nullptr;\n+      }\n+      if (replacement)\n+      {\n+        buffer->info[idx].codepoint = *replacement;\n+        ret = true;\n+      }\n+\n+      if (entry.flags & SetMark)\n+      {\n+        mark_set = true;\n+        mark = buffer->idx;\n+      }\n+    }\n+\n+    public:\n+    bool ret;\n+    private:\n+    hb_aat_apply_context_t *c;\n+    bool mark_set;\n+    unsigned int mark;\n+    const ContextualSubtable *table;\n+    const UnsizedOffsetListOf<Lookup<GlyphID>, HBUINT, false> &subs;\n+  };\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    driver_context_t dc (this, c);\n+\n+    StateTableDriver<Types, EntryData> driver (machine, c->buffer, c->face);\n+    driver.drive (&dc);\n+\n+    return_trace (dc.ret);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    unsigned int num_entries = 0;\n+    if (unlikely (!machine.sanitize (c, &num_entries))) return_trace (false);\n+\n+    if (!Types::extended)\n+      return_trace (substitutionTables.sanitize (c, this, 0));\n+\n+    unsigned int num_lookups = 0;\n+\n+    const Entry<EntryData> *entries = machine.get_entries ();\n+    for (unsigned int i = 0; i < num_entries; i++)\n+    {\n+      const EntryData &data = entries[i].data;\n+\n+      if (data.markIndex != 0xFFFF)\n+        num_lookups = MAX<unsigned int> (num_lookups, 1 + data.markIndex);\n+      if (data.currentIndex != 0xFFFF)\n+        num_lookups = MAX<unsigned int> (num_lookups, 1 + data.currentIndex);\n+    }\n+\n+    return_trace (substitutionTables.sanitize (c, this, num_lookups));\n+  }\n+\n+  protected:\n+  StateTable<Types, EntryData>\n+                machine;\n+  NNOffsetTo<UnsizedOffsetListOf<Lookup<GlyphID>, HBUINT, false>, HBUINT>\n+                substitutionTables;\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+\n+template <bool extended>\n+struct LigatureEntry;\n+\n+template <>\n+struct LigatureEntry<true>\n+{\n+  enum Flags\n+  {\n+    SetComponent        = 0x8000,       \/* Push this glyph onto the component stack for\n+                                         * eventual processing. *\/\n+    DontAdvance         = 0x4000,       \/* Leave the glyph pointer at this glyph for the\n+                                           next iteration. *\/\n+    PerformAction       = 0x2000,       \/* Use the ligActionIndex to process a ligature\n+                                         * group. *\/\n+    Reserved            = 0x1FFF,       \/* These bits are reserved and should be set to 0. *\/\n+  };\n+\n+  struct EntryData\n+  {\n+    HBUINT16    ligActionIndex; \/* Index to the first ligActionTable entry\n+                                 * for processing this group, if indicated\n+                                 * by the flags. *\/\n+    public:\n+    DEFINE_SIZE_STATIC (2);\n+  };\n+\n+  static bool performAction (const Entry<EntryData> &entry)\n+  { return entry.flags & PerformAction; }\n+\n+  static unsigned int ligActionIndex (const Entry<EntryData> &entry)\n+  { return entry.data.ligActionIndex; }\n+};\n+template <>\n+struct LigatureEntry<false>\n+{\n+  enum Flags\n+  {\n+    SetComponent        = 0x8000,       \/* Push this glyph onto the component stack for\n+                                         * eventual processing. *\/\n+    DontAdvance         = 0x4000,       \/* Leave the glyph pointer at this glyph for the\n+                                           next iteration. *\/\n+    Offset              = 0x3FFF,       \/* Byte offset from beginning of subtable to the\n+                                         * ligature action list. This value must be a\n+                                         * multiple of 4. *\/\n+  };\n+\n+  typedef void EntryData;\n+\n+  static bool performAction (const Entry<EntryData> &entry)\n+  { return entry.flags & Offset; }\n+\n+  static unsigned int ligActionIndex (const Entry<EntryData> &entry)\n+  { return entry.flags & Offset; }\n+};\n+\n+\n+template <typename Types>\n+struct LigatureSubtable\n+{\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  typedef LigatureEntry<Types::extended> LigatureEntryT;\n+  typedef typename LigatureEntryT::EntryData EntryData;\n+\n+  struct driver_context_t\n+  {\n+    static constexpr bool in_place = false;\n+    enum\n+    {\n+      DontAdvance       = LigatureEntryT::DontAdvance,\n+    };\n+    enum LigActionFlags\n+    {\n+      LigActionLast     = 0x80000000,   \/* This is the last action in the list. This also\n+                                         * implies storage. *\/\n+      LigActionStore    = 0x40000000,   \/* Store the ligature at the current cumulated index\n+                                         * in the ligature table in place of the marked\n+                                         * (i.e. currently-popped) glyph. *\/\n+      LigActionOffset   = 0x3FFFFFFF,   \/* A 30-bit value which is sign-extended to 32-bits\n+                                         * and added to the glyph ID, resulting in an index\n+                                         * into the component table. *\/\n+    };\n+\n+    driver_context_t (const LigatureSubtable *table_,\n+                      hb_aat_apply_context_t *c_) :\n+        ret (false),\n+        c (c_),\n+        table (table_),\n+        ligAction (table+table->ligAction),\n+        component (table+table->component),\n+        ligature (table+table->ligature),\n+        match_length (0) {}\n+\n+    bool is_actionable (StateTableDriver<Types, EntryData> *driver HB_UNUSED,\n+                        const Entry<EntryData> &entry)\n+    {\n+      return LigatureEntryT::performAction (entry);\n+    }\n+    void transition (StateTableDriver<Types, EntryData> *driver,\n+                     const Entry<EntryData> &entry)\n+    {\n+      hb_buffer_t *buffer = driver->buffer;\n+\n+      DEBUG_MSG (APPLY, nullptr, \"Ligature transition at %u\", buffer->idx);\n+      if (entry.flags & LigatureEntryT::SetComponent)\n+      {\n+        \/* Never mark same index twice, in case DontAdvance was used... *\/\n+        if (match_length && match_positions[(match_length - 1u) % ARRAY_LENGTH (match_positions)] == buffer->out_len)\n+          match_length--;\n+\n+        match_positions[match_length++ % ARRAY_LENGTH (match_positions)] = buffer->out_len;\n+        DEBUG_MSG (APPLY, nullptr, \"Set component at %u\", buffer->out_len);\n+      }\n+\n+      if (LigatureEntryT::performAction (entry))\n+      {\n+        DEBUG_MSG (APPLY, nullptr, \"Perform action with %u\", match_length);\n+        unsigned int end = buffer->out_len;\n+\n+        if (unlikely (!match_length))\n+          return;\n+\n+        if (buffer->idx >= buffer->len)\n+          return; \/* TODO Work on previous instead? *\/\n+\n+        unsigned int cursor = match_length;\n+\n+        unsigned int action_idx = LigatureEntryT::ligActionIndex (entry);\n+        action_idx = Types::offsetToIndex (action_idx, table, ligAction.arrayZ);\n+        const HBUINT32 *actionData = &ligAction[action_idx];\n+\n+        unsigned int ligature_idx = 0;\n+        unsigned int action;\n+        do\n+        {\n+          if (unlikely (!cursor))\n+          {\n+            \/* Stack underflow.  Clear the stack. *\/\n+            DEBUG_MSG (APPLY, nullptr, \"Stack underflow\");\n+            match_length = 0;\n+            break;\n+          }\n+\n+          DEBUG_MSG (APPLY, nullptr, \"Moving to stack position %u\", cursor - 1);\n+          buffer->move_to (match_positions[--cursor % ARRAY_LENGTH (match_positions)]);\n+\n+          if (unlikely (!actionData->sanitize (&c->sanitizer))) break;\n+          action = *actionData;\n+\n+          uint32_t uoffset = action & LigActionOffset;\n+          if (uoffset & 0x20000000)\n+            uoffset |= 0xC0000000; \/* Sign-extend. *\/\n+          int32_t offset = (int32_t) uoffset;\n+          unsigned int component_idx = buffer->cur().codepoint + offset;\n+          component_idx = Types::wordOffsetToIndex (component_idx, table, component.arrayZ);\n+          const HBUINT16 &componentData = component[component_idx];\n+          if (unlikely (!componentData.sanitize (&c->sanitizer))) break;\n+          ligature_idx += componentData;\n+\n+          DEBUG_MSG (APPLY, nullptr, \"Action store %u last %u\",\n+                     bool (action & LigActionStore),\n+                     bool (action & LigActionLast));\n+          if (action & (LigActionStore | LigActionLast))\n+          {\n+            ligature_idx = Types::offsetToIndex (ligature_idx, table, ligature.arrayZ);\n+            const GlyphID &ligatureData = ligature[ligature_idx];\n+            if (unlikely (!ligatureData.sanitize (&c->sanitizer))) break;\n+            hb_codepoint_t lig = ligatureData;\n+\n+            DEBUG_MSG (APPLY, nullptr, \"Produced ligature %u\", lig);\n+            buffer->replace_glyph (lig);\n+\n+            unsigned int lig_end = match_positions[(match_length - 1u) % ARRAY_LENGTH (match_positions)] + 1u;\n+            \/* Now go and delete all subsequent components. *\/\n+            while (match_length - 1u > cursor)\n+            {\n+              DEBUG_MSG (APPLY, nullptr, \"Skipping ligature component\");\n+              buffer->move_to (match_positions[--match_length % ARRAY_LENGTH (match_positions)]);\n+              buffer->replace_glyph (DELETED_GLYPH);\n+            }\n+\n+            buffer->move_to (lig_end);\n+            buffer->merge_out_clusters (match_positions[cursor % ARRAY_LENGTH (match_positions)], buffer->out_len);\n+          }\n+\n+          actionData++;\n+        }\n+        while (!(action & LigActionLast));\n+        buffer->move_to (end);\n+      }\n+    }\n+\n+    public:\n+    bool ret;\n+    private:\n+    hb_aat_apply_context_t *c;\n+    const LigatureSubtable *table;\n+    const UnsizedArrayOf<HBUINT32> &ligAction;\n+    const UnsizedArrayOf<HBUINT16> &component;\n+    const UnsizedArrayOf<GlyphID> &ligature;\n+    unsigned int match_length;\n+    unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n+  };\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    driver_context_t dc (this, c);\n+\n+    StateTableDriver<Types, EntryData> driver (machine, c->buffer, c->face);\n+    driver.drive (&dc);\n+\n+    return_trace (dc.ret);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* The rest of array sanitizations are done at run-time. *\/\n+    return_trace (c->check_struct (this) && machine.sanitize (c) &&\n+                  ligAction && component && ligature);\n+  }\n+\n+  protected:\n+  StateTable<Types, EntryData>\n+                machine;\n+  NNOffsetTo<UnsizedArrayOf<HBUINT32>, HBUINT>\n+                ligAction;      \/* Offset to the ligature action table. *\/\n+  NNOffsetTo<UnsizedArrayOf<HBUINT16>, HBUINT>\n+                component;      \/* Offset to the component table. *\/\n+  NNOffsetTo<UnsizedArrayOf<GlyphID>, HBUINT>\n+                ligature;       \/* Offset to the actual ligature lists. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (28);\n+};\n+\n+template <typename Types>\n+struct NoncontextualSubtable\n+{\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    bool ret = false;\n+    unsigned int num_glyphs = c->face->get_num_glyphs ();\n+\n+    hb_glyph_info_t *info = c->buffer->info;\n+    unsigned int count = c->buffer->len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      const GlyphID *replacement = substitute.get_value (info[i].codepoint, num_glyphs);\n+      if (replacement)\n+      {\n+        info[i].codepoint = *replacement;\n+        ret = true;\n+      }\n+    }\n+\n+    return_trace (ret);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (substitute.sanitize (c));\n+  }\n+\n+  protected:\n+  Lookup<GlyphID>       substitute;\n+  public:\n+  DEFINE_SIZE_MIN (2);\n+};\n+\n+template <typename Types>\n+struct InsertionSubtable\n+{\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  struct EntryData\n+  {\n+    HBUINT16    currentInsertIndex;     \/* Zero-based index into the insertion glyph table.\n+                                         * The number of glyphs to be inserted is contained\n+                                         * in the currentInsertCount field in the flags.\n+                                         * A value of 0xFFFF indicates no insertion is to\n+                                         * be done. *\/\n+    HBUINT16    markedInsertIndex;      \/* Zero-based index into the insertion glyph table.\n+                                         * The number of glyphs to be inserted is contained\n+                                         * in the markedInsertCount field in the flags.\n+                                         * A value of 0xFFFF indicates no insertion is to\n+                                         * be done. *\/\n+    public:\n+    DEFINE_SIZE_STATIC (4);\n+  };\n+\n+  struct driver_context_t\n+  {\n+    static constexpr bool in_place = false;\n+    enum Flags\n+    {\n+      SetMark           = 0x8000,       \/* If set, mark the current glyph. *\/\n+      DontAdvance       = 0x4000,       \/* If set, don't advance to the next glyph before\n+                                         * going to the new state.  This does not mean\n+                                         * that the glyph pointed to is the same one as\n+                                         * before. If you've made insertions immediately\n+                                         * downstream of the current glyph, the next glyph\n+                                         * processed would in fact be the first one\n+                                         * inserted. *\/\n+      CurrentIsKashidaLike= 0x2000,     \/* If set, and the currentInsertList is nonzero,\n+                                         * then the specified glyph list will be inserted\n+                                         * as a kashida-like insertion, either before or\n+                                         * after the current glyph (depending on the state\n+                                         * of the currentInsertBefore flag). If clear, and\n+                                         * the currentInsertList is nonzero, then the\n+                                         * specified glyph list will be inserted as a\n+                                         * split-vowel-like insertion, either before or\n+                                         * after the current glyph (depending on the state\n+                                         * of the currentInsertBefore flag). *\/\n+      MarkedIsKashidaLike= 0x1000,      \/* If set, and the markedInsertList is nonzero,\n+                                         * then the specified glyph list will be inserted\n+                                         * as a kashida-like insertion, either before or\n+                                         * after the marked glyph (depending on the state\n+                                         * of the markedInsertBefore flag). If clear, and\n+                                         * the markedInsertList is nonzero, then the\n+                                         * specified glyph list will be inserted as a\n+                                         * split-vowel-like insertion, either before or\n+                                         * after the marked glyph (depending on the state\n+                                         * of the markedInsertBefore flag). *\/\n+      CurrentInsertBefore= 0x0800,      \/* If set, specifies that insertions are to be made\n+                                         * to the left of the current glyph. If clear,\n+                                         * they're made to the right of the current glyph. *\/\n+      MarkedInsertBefore= 0x0400,       \/* If set, specifies that insertions are to be\n+                                         * made to the left of the marked glyph. If clear,\n+                                         * they're made to the right of the marked glyph. *\/\n+      CurrentInsertCount= 0x3E0,        \/* This 5-bit field is treated as a count of the\n+                                         * number of glyphs to insert at the current\n+                                         * position. Since zero means no insertions, the\n+                                         * largest number of insertions at any given\n+                                         * current location is 31 glyphs. *\/\n+      MarkedInsertCount= 0x001F,        \/* This 5-bit field is treated as a count of the\n+                                         * number of glyphs to insert at the marked\n+                                         * position. Since zero means no insertions, the\n+                                         * largest number of insertions at any given\n+                                         * marked location is 31 glyphs. *\/\n+    };\n+\n+    driver_context_t (const InsertionSubtable *table,\n+                      hb_aat_apply_context_t *c_) :\n+        ret (false),\n+        c (c_),\n+        mark (0),\n+        insertionAction (table+table->insertionAction) {}\n+\n+    bool is_actionable (StateTableDriver<Types, EntryData> *driver HB_UNUSED,\n+                        const Entry<EntryData> &entry)\n+    {\n+      return (entry.flags & (CurrentInsertCount | MarkedInsertCount)) &&\n+             (entry.data.currentInsertIndex != 0xFFFF ||entry.data.markedInsertIndex != 0xFFFF);\n+    }\n+    void transition (StateTableDriver<Types, EntryData> *driver,\n+                     const Entry<EntryData> &entry)\n+    {\n+      hb_buffer_t *buffer = driver->buffer;\n+      unsigned int flags = entry.flags;\n+\n+      unsigned mark_loc = buffer->out_len;\n+\n+      if (entry.data.markedInsertIndex != 0xFFFF)\n+      {\n+        unsigned int count = (flags & MarkedInsertCount);\n+        unsigned int start = entry.data.markedInsertIndex;\n+        const GlyphID *glyphs = &insertionAction[start];\n+        if (unlikely (!c->sanitizer.check_array (glyphs, count))) count = 0;\n+\n+        bool before = flags & MarkedInsertBefore;\n+\n+        unsigned int end = buffer->out_len;\n+        buffer->move_to (mark);\n+\n+        if (buffer->idx < buffer->len && !before)\n+          buffer->copy_glyph ();\n+        \/* TODO We ignore KashidaLike setting. *\/\n+        for (unsigned int i = 0; i < count; i++)\n+          buffer->output_glyph (glyphs[i]);\n+        if (buffer->idx < buffer->len && !before)\n+          buffer->skip_glyph ();\n+\n+        buffer->move_to (end + count);\n+\n+        buffer->unsafe_to_break_from_outbuffer (mark, MIN (buffer->idx + 1, buffer->len));\n+      }\n+\n+      if (flags & SetMark)\n+        mark = mark_loc;\n+\n+      if (entry.data.currentInsertIndex != 0xFFFF)\n+      {\n+        unsigned int count = (flags & CurrentInsertCount) >> 5;\n+        unsigned int start = entry.data.currentInsertIndex;\n+        const GlyphID *glyphs = &insertionAction[start];\n+        if (unlikely (!c->sanitizer.check_array (glyphs, count))) count = 0;\n+\n+        bool before = flags & CurrentInsertBefore;\n+\n+        unsigned int end = buffer->out_len;\n+\n+        if (buffer->idx < buffer->len && !before)\n+          buffer->copy_glyph ();\n+        \/* TODO We ignore KashidaLike setting. *\/\n+        for (unsigned int i = 0; i < count; i++)\n+          buffer->output_glyph (glyphs[i]);\n+        if (buffer->idx < buffer->len && !before)\n+          buffer->skip_glyph ();\n+\n+        \/* Humm. Not sure where to move to.  There's this wording under\n+         * DontAdvance flag:\n+         *\n+         * \"If set, don't update the glyph index before going to the new state.\n+         * This does not mean that the glyph pointed to is the same one as\n+         * before. If you've made insertions immediately downstream of the\n+         * current glyph, the next glyph processed would in fact be the first\n+         * one inserted.\"\n+         *\n+         * This suggests that if DontAdvance is NOT set, we should move to\n+         * end+count.  If it *was*, then move to end, such that newly inserted\n+         * glyphs are now visible.\n+         *\n+         * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1224#issuecomment-427691417\n+         *\/\n+        buffer->move_to ((flags & DontAdvance) ? end : end + count);\n+      }\n+    }\n+\n+    public:\n+    bool ret;\n+    private:\n+    hb_aat_apply_context_t *c;\n+    unsigned int mark;\n+    const UnsizedArrayOf<GlyphID> &insertionAction;\n+  };\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    driver_context_t dc (this, c);\n+\n+    StateTableDriver<Types, EntryData> driver (machine, c->buffer, c->face);\n+    driver.drive (&dc);\n+\n+    return_trace (dc.ret);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* The rest of array sanitizations are done at run-time. *\/\n+    return_trace (c->check_struct (this) && machine.sanitize (c) &&\n+                  insertionAction);\n+  }\n+\n+  protected:\n+  StateTable<Types, EntryData>\n+                machine;\n+  NNOffsetTo<UnsizedArrayOf<GlyphID>, HBUINT>\n+                insertionAction;        \/* Byte offset from stateHeader to the start of\n+                                         * the insertion glyph table. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+\n+struct Feature\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBUINT16      featureType;    \/* The type of feature. *\/\n+  HBUINT16      featureSetting; \/* The feature's setting (aka selector). *\/\n+  HBUINT32      enableFlags;    \/* Flags for the settings that this feature\n+                                 * and setting enables. *\/\n+  HBUINT32      disableFlags;   \/* Complement of flags for the settings that this\n+                                 * feature and setting disable. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+template <typename Types>\n+struct ChainSubtable\n+{\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  template <typename T>\n+  friend struct Chain;\n+\n+  unsigned int get_size () const     { return length; }\n+  unsigned int get_type () const     { return coverage & 0xFF; }\n+  unsigned int get_coverage () const { return coverage >> (sizeof (HBUINT) * 8 - 8); }\n+\n+  enum Coverage\n+  {\n+    Vertical            = 0x80, \/* If set, this subtable will only be applied\n+                                 * to vertical text. If clear, this subtable\n+                                 * will only be applied to horizontal text. *\/\n+    Backwards           = 0x40, \/* If set, this subtable will process glyphs\n+                                 * in descending order. If clear, it will\n+                                 * process the glyphs in ascending order. *\/\n+    AllDirections       = 0x20, \/* If set, this subtable will be applied to\n+                                 * both horizontal and vertical text (i.e.\n+                                 * the state of bit 0x80000000 is ignored). *\/\n+    Logical             = 0x10, \/* If set, this subtable will process glyphs\n+                                 * in logical order (or reverse logical order,\n+                                 * depending on the value of bit 0x80000000). *\/\n+  };\n+  enum Type\n+  {\n+    Rearrangement       = 0,\n+    Contextual          = 1,\n+    Ligature            = 2,\n+    Noncontextual       = 4,\n+    Insertion           = 5\n+  };\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    unsigned int subtable_type = get_type ();\n+    TRACE_DISPATCH (this, subtable_type);\n+    switch (subtable_type) {\n+    case Rearrangement:         return_trace (c->dispatch (u.rearrangement));\n+    case Contextual:            return_trace (c->dispatch (u.contextual));\n+    case Ligature:              return_trace (c->dispatch (u.ligature));\n+    case Noncontextual:         return_trace (c->dispatch (u.noncontextual));\n+    case Insertion:             return_trace (c->dispatch (u.insertion));\n+    default:                    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_sanitize_with_object_t with (&c->sanitizer, this);\n+    return_trace (dispatch (c));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!length.sanitize (c) ||\n+        length <= min_size ||\n+        !c->check_range (this, length))\n+      return_trace (false);\n+\n+    hb_sanitize_with_object_t with (c, this);\n+    return_trace (dispatch (c));\n+  }\n+\n+  protected:\n+  HBUINT        length;         \/* Total subtable length, including this header. *\/\n+  HBUINT        coverage;       \/* Coverage flags and subtable type. *\/\n+  HBUINT32      subFeatureFlags;\/* The 32-bit mask identifying which subtable this is. *\/\n+  union {\n+  RearrangementSubtable<Types>  rearrangement;\n+  ContextualSubtable<Types>     contextual;\n+  LigatureSubtable<Types>       ligature;\n+  NoncontextualSubtable<Types>  noncontextual;\n+  InsertionSubtable<Types>      insertion;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (2 * sizeof (HBUINT) + 4);\n+};\n+\n+template <typename Types>\n+struct Chain\n+{\n+  typedef typename Types::HBUINT HBUINT;\n+\n+  hb_mask_t compile_flags (const hb_aat_map_builder_t *map) const\n+  {\n+    hb_mask_t flags = defaultFlags;\n+    {\n+      unsigned int count = featureCount;\n+      for (unsigned i = 0; i < count; i++)\n+      {\n+        const Feature &feature = featureZ[i];\n+        hb_aat_layout_feature_type_t type = (hb_aat_layout_feature_type_t) (unsigned int) feature.featureType;\n+        hb_aat_layout_feature_selector_t setting = (hb_aat_layout_feature_selector_t) (unsigned int) feature.featureSetting;\n+      retry:\n+        const hb_aat_map_builder_t::feature_info_t *info = map->features.bsearch (type);\n+        if (info && info->setting == setting)\n+        {\n+          flags &= feature.disableFlags;\n+          flags |= feature.enableFlags;\n+        }\n+        else if (type == HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE && setting == HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS)\n+        {\n+          \/* Deprecated. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1342 *\/\n+          type = HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE;\n+          setting = HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS;\n+          goto retry;\n+        }\n+      }\n+    }\n+    return flags;\n+  }\n+\n+  void apply (hb_aat_apply_context_t *c,\n+                     hb_mask_t flags) const\n+  {\n+    const ChainSubtable<Types> *subtable = &StructAfter<ChainSubtable<Types> > (featureZ.as_array (featureCount));\n+    unsigned int count = subtableCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      bool reverse;\n+\n+      if (!(subtable->subFeatureFlags & flags))\n+        goto skip;\n+\n+      if (!(subtable->get_coverage() & ChainSubtable<Types>::AllDirections) &&\n+          HB_DIRECTION_IS_VERTICAL (c->buffer->props.direction) !=\n+          bool (subtable->get_coverage() & ChainSubtable<Types>::Vertical))\n+        goto skip;\n+\n+      \/* Buffer contents is always in logical direction.  Determine if\n+       * we need to reverse before applying this subtable.  We reverse\n+       * back after if we did reverse indeed.\n+       *\n+       * Quoting the spac:\n+       * \"\"\"\n+       * Bits 28 and 30 of the coverage field control the order in which\n+       * glyphs are processed when the subtable is run by the layout engine.\n+       * Bit 28 is used to indicate if the glyph processing direction is\n+       * the same as logical order or layout order. Bit 30 is used to\n+       * indicate whether glyphs are processed forwards or backwards within\n+       * that order.\n+\n+                Bit 30  Bit 28  Interpretation for Horizontal Text\n+                0       0       The subtable is processed in layout order\n+                                (the same order as the glyphs, which is\n+                                always left-to-right).\n+                1       0       The subtable is processed in reverse layout order\n+                                (the order opposite that of the glyphs, which is\n+                                always right-to-left).\n+                0       1       The subtable is processed in logical order\n+                                (the same order as the characters, which may be\n+                                left-to-right or right-to-left).\n+                1       1       The subtable is processed in reverse logical order\n+                                (the order opposite that of the characters, which\n+                                may be right-to-left or left-to-right).\n+       *\/\n+      reverse = subtable->get_coverage () & ChainSubtable<Types>::Logical ?\n+                bool (subtable->get_coverage () & ChainSubtable<Types>::Backwards) :\n+                bool (subtable->get_coverage () & ChainSubtable<Types>::Backwards) !=\n+                HB_DIRECTION_IS_BACKWARD (c->buffer->props.direction);\n+\n+      if (!c->buffer->message (c->font, \"start chain subtable %d\", c->lookup_index))\n+        goto skip;\n+\n+      if (reverse)\n+        c->buffer->reverse ();\n+\n+      subtable->apply (c);\n+\n+      if (reverse)\n+        c->buffer->reverse ();\n+\n+      (void) c->buffer->message (c->font, \"end chain subtable %d\", c->lookup_index);\n+\n+      if (unlikely (!c->buffer->successful)) return;\n+\n+    skip:\n+      subtable = &StructAfter<ChainSubtable<Types> > (*subtable);\n+      c->set_lookup_index (c->lookup_index + 1);\n+    }\n+  }\n+\n+  unsigned int get_size () const { return length; }\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int version HB_UNUSED) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!length.sanitize (c) ||\n+        length < min_size ||\n+        !c->check_range (this, length))\n+      return_trace (false);\n+\n+    if (!c->check_array (featureZ.arrayZ, featureCount))\n+      return_trace (false);\n+\n+    const ChainSubtable<Types> *subtable = &StructAfter<ChainSubtable<Types> > (featureZ.as_array (featureCount));\n+    unsigned int count = subtableCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (!subtable->sanitize (c))\n+        return_trace (false);\n+      subtable = &StructAfter<ChainSubtable<Types> > (*subtable);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  protected:\n+  HBUINT32      defaultFlags;   \/* The default specification for subtables. *\/\n+  HBUINT32      length;         \/* Total byte count, including this header. *\/\n+  HBUINT        featureCount;   \/* Number of feature subtable entries. *\/\n+  HBUINT        subtableCount;  \/* The number of subtables in the chain. *\/\n+\n+  UnsizedArrayOf<Feature>       featureZ;       \/* Features. *\/\n+\/*ChainSubtable firstSubtable;*\/\/* Subtables. *\/\n+\/*subtableGlyphCoverageArray*\/  \/* Only if version >= 3. We don't use. *\/\n+\n+  public:\n+  DEFINE_SIZE_MIN (8 + 2 * sizeof (HBUINT));\n+};\n+\n+\n+\/*\n+ * The 'mort'\/'morx' Table\n+ *\/\n+\n+template <typename Types>\n+struct mortmorx\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_morx;\n+\n+  bool has_data () const { return version != 0; }\n+\n+  void compile_flags (const hb_aat_map_builder_t *mapper,\n+                      hb_aat_map_t *map) const\n+  {\n+    const Chain<Types> *chain = &firstChain;\n+    unsigned int count = chainCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      map->chain_flags.push (chain->compile_flags (mapper));\n+      chain = &StructAfter<Chain<Types> > (*chain);\n+    }\n+  }\n+\n+  void apply (hb_aat_apply_context_t *c) const\n+  {\n+    if (unlikely (!c->buffer->successful)) return;\n+    c->set_lookup_index (0);\n+    const Chain<Types> *chain = &firstChain;\n+    unsigned int count = chainCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      chain->apply (c, c->plan->aat_map.chain_flags[i]);\n+      if (unlikely (!c->buffer->successful)) return;\n+      chain = &StructAfter<Chain<Types> > (*chain);\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!version.sanitize (c) || !version || !chainCount.sanitize (c))\n+      return_trace (false);\n+\n+    const Chain<Types> *chain = &firstChain;\n+    unsigned int count = chainCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (!chain->sanitize (c, version))\n+        return_trace (false);\n+      chain = &StructAfter<Chain<Types> > (*chain);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Version number of the glyph metamorphosis table.\n+                                 * 1, 2, or 3. *\/\n+  HBUINT16      unused;         \/* Set to 0. *\/\n+  HBUINT32      chainCount;     \/* Number of metamorphosis chains contained in this\n+                                 * table. *\/\n+  Chain<Types>  firstChain;     \/* Chains. *\/\n+\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+struct morx : mortmorx<ExtendedTypes>\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_morx;\n+};\n+struct mort : mortmorx<ObsoleteTypes>\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_mort;\n+};\n+\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LAYOUT_MORX_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-morx-table.hh","additions":1159,"deletions":0,"binary":false,"changes":1159,"status":"added"},{"patch":"@@ -0,0 +1,237 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_TRAK_TABLE_HH\n+#define HB_AAT_LAYOUT_TRAK_TABLE_HH\n+\n+#include \"hb-aat-layout-common.hh\"\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * trak -- Tracking\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6trak.html\n+ *\/\n+#define HB_AAT_TAG_trak HB_TAG('t','r','a','k')\n+\n+\n+namespace AAT {\n+\n+\n+struct TrackTableEntry\n+{\n+  friend struct TrackData;\n+\n+  float get_track_value () const { return track.to_float (); }\n+\n+  int get_value (const void *base, unsigned int index,\n+                 unsigned int table_size) const\n+  { return (base+valuesZ).as_array (table_size)[index]; }\n+\n+  public:\n+  bool sanitize (hb_sanitize_context_t *c, const void *base,\n+                 unsigned int table_size) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (valuesZ.sanitize (c, base, table_size))));\n+  }\n+\n+  protected:\n+  Fixed         track;          \/* Track value for this record. *\/\n+  NameID        trackNameID;    \/* The 'name' table index for this track.\n+                                 * (a short word or phrase like \"loose\"\n+                                 * or \"very tight\") *\/\n+  NNOffsetTo<UnsizedArrayOf<FWORD> >\n+                valuesZ;        \/* Offset from start of tracking table to\n+                                 * per-size tracking values for this track. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct TrackData\n+{\n+  float interpolate_at (unsigned int idx,\n+                        float target_size,\n+                        const TrackTableEntry &trackTableEntry,\n+                        const void *base) const\n+  {\n+    unsigned int sizes = nSizes;\n+    hb_array_t<const Fixed> size_table ((base+sizeTable).arrayZ, sizes);\n+\n+    float s0 = size_table[idx].to_float ();\n+    float s1 = size_table[idx + 1].to_float ();\n+    float t = unlikely (s0 == s1) ? 0.f : (target_size - s0) \/ (s1 - s0);\n+    return t * trackTableEntry.get_value (base, idx + 1, sizes) +\n+           (1.f - t) * trackTableEntry.get_value (base, idx, sizes);\n+  }\n+\n+  int get_tracking (const void *base, float ptem) const\n+  {\n+    \/* CoreText points are CSS pixels (96 per inch),\n+     * NOT typographic points (72 per inch).\n+     *\n+     * https:\/\/developer.apple.com\/library\/content\/documentation\/GraphicsAnimation\/Conceptual\/HighResolutionOSX\/Explained\/Explained.html\n+     *\/\n+    float csspx = ptem * 96.f \/ 72.f;\n+\n+    \/*\n+     * Choose track.\n+     *\/\n+    const TrackTableEntry *trackTableEntry = nullptr;\n+    unsigned int count = nTracks;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      \/* Note: Seems like the track entries are sorted by values.  But the\n+       * spec doesn't explicitly say that.  It just mentions it in the example. *\/\n+\n+      \/* For now we only seek for track entries with zero tracking value *\/\n+\n+      if (trackTable[i].get_track_value () == 0.f)\n+      {\n+        trackTableEntry = &trackTable[i];\n+        break;\n+      }\n+    }\n+    if (!trackTableEntry) return 0.;\n+\n+    \/*\n+     * Choose size.\n+     *\/\n+    unsigned int sizes = nSizes;\n+    if (!sizes) return 0.;\n+    if (sizes == 1) return trackTableEntry->get_value (base, 0, sizes);\n+\n+    hb_array_t<const Fixed> size_table ((base+sizeTable).arrayZ, sizes);\n+    unsigned int size_index;\n+    for (size_index = 0; size_index < sizes - 1; size_index++)\n+      if (size_table[size_index].to_float () >= csspx)\n+        break;\n+\n+    return round (interpolate_at (size_index ? size_index - 1 : 0, csspx,\n+                                  *trackTableEntry, base));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          sizeTable.sanitize (c, base, nSizes) &&\n+                          trackTable.sanitize (c, nTracks, base, nSizes)));\n+  }\n+\n+  protected:\n+  HBUINT16      nTracks;        \/* Number of separate tracks included in this table. *\/\n+  HBUINT16      nSizes;         \/* Number of point sizes included in this table. *\/\n+  LOffsetTo<UnsizedArrayOf<Fixed>, false>\n+                sizeTable;      \/* Offset from start of the tracking table to\n+                                 * Array[nSizes] of size values.. *\/\n+  UnsizedArrayOf<TrackTableEntry>\n+                trackTable;     \/* Array[nTracks] of TrackTableEntry records. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (8, trackTable);\n+};\n+\n+struct trak\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_trak;\n+\n+  bool has_data () const { return version.to_int (); }\n+\n+  bool apply (hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    hb_mask_t trak_mask = c->plan->trak_mask;\n+\n+    const float ptem = c->font->ptem;\n+    if (unlikely (ptem <= 0.f))\n+      return_trace (false);\n+\n+    hb_buffer_t *buffer = c->buffer;\n+    if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction))\n+    {\n+      const TrackData &trackData = this+horizData;\n+      int tracking = trackData.get_tracking (this, ptem);\n+      hb_position_t offset_to_add = c->font->em_scalef_x (tracking \/ 2);\n+      hb_position_t advance_to_add = c->font->em_scalef_x (tracking);\n+      foreach_grapheme (buffer, start, end)\n+      {\n+        if (!(buffer->info[start].mask & trak_mask)) continue;\n+        buffer->pos[start].x_advance += advance_to_add;\n+        buffer->pos[start].x_offset += offset_to_add;\n+      }\n+    }\n+    else\n+    {\n+      const TrackData &trackData = this+vertData;\n+      int tracking = trackData.get_tracking (this, ptem);\n+      hb_position_t offset_to_add = c->font->em_scalef_y (tracking \/ 2);\n+      hb_position_t advance_to_add = c->font->em_scalef_y (tracking);\n+      foreach_grapheme (buffer, start, end)\n+      {\n+        if (!(buffer->info[start].mask & trak_mask)) continue;\n+        buffer->pos[start].y_advance += advance_to_add;\n+        buffer->pos[start].y_offset += offset_to_add;\n+      }\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    return_trace (likely (c->check_struct (this) &&\n+                          version.major == 1 &&\n+                          horizData.sanitize (c, this, this) &&\n+                          vertData.sanitize (c, this, this)));\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the tracking table\n+                                         * (0x00010000u for version 1.0). *\/\n+  HBUINT16      format;         \/* Format of the tracking table (set to 0). *\/\n+  OffsetTo<TrackData>\n+                horizData;      \/* Offset from start of tracking table to TrackData\n+                                 * for horizontal text (or 0 if none). *\/\n+  OffsetTo<TrackData>\n+                vertData;       \/* Offset from start of tracking table to TrackData\n+                                 * for vertical text (or 0 if none). *\/\n+  HBUINT16      reserved;       \/* Reserved. Set to 0. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LAYOUT_TRAK_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout-trak-table.hh","additions":237,"deletions":0,"binary":false,"changes":237,"status":"added"},{"patch":"@@ -0,0 +1,384 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+\n+#include \"hb-ot-face.hh\"\n+#include \"hb-aat-layout.hh\"\n+#include \"hb-aat-fdsc-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-aat-layout-ankr-table.hh\"\n+#include \"hb-aat-layout-bsln-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-aat-layout-feat-table.hh\"\n+#include \"hb-aat-layout-just-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-aat-layout-kerx-table.hh\"\n+#include \"hb-aat-layout-morx-table.hh\"\n+#include \"hb-aat-layout-trak-table.hh\"\n+#include \"hb-aat-ltag-table.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-aat-layout\n+ * @title: hb-aat-layout\n+ * @short_description: Apple Advanced Typography Layout\n+ * @include: hb-aat.h\n+ *\n+ * Functions for querying OpenType Layout features in the font face.\n+ **\/\n+\n+\n+\/* Table data courtesy of Apple.  Converted from mnemonics to integers\n+ * when moving to this file. *\/\n+static const hb_aat_feature_mapping_t feature_mappings[] =\n+{\n+  {HB_TAG ('a','f','r','c'), HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS,               HB_AAT_LAYOUT_FEATURE_SELECTOR_VERTICAL_FRACTIONS,             HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_FRACTIONS},\n+  {HB_TAG ('c','2','p','c'), HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE,              HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_PETITE_CAPS,         HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_UPPER_CASE},\n+  {HB_TAG ('c','2','s','c'), HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE,              HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_SMALL_CAPS,          HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_UPPER_CASE},\n+  {HB_TAG ('c','a','l','t'), HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES, HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_ON,       HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_OFF},\n+  {HB_TAG ('c','a','s','e'), HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT,   HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_ON,       HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_OFF},\n+  {HB_TAG ('c','l','i','g'), HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES,               HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_OFF},\n+  {HB_TAG ('c','p','s','p'), HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT,   HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_ON,      HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_OFF},\n+  {HB_TAG ('c','s','w','h'), HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES, HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_ON, HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_OFF},\n+  {HB_TAG ('d','l','i','g'), HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES,               HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_ON,              HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_OFF},\n+  {HB_TAG ('e','x','p','t'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPERT_CHARACTERS,              (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('f','r','a','c'), HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS,               HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAGONAL_FRACTIONS,             HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_FRACTIONS},\n+  {HB_TAG ('f','w','i','d'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_TEXT,                (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('h','a','l','t'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_HALF_WIDTH_TEXT,            (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('h','i','s','t'), HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES,               HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF},\n+  {HB_TAG ('h','k','n','a'), HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA,          HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_OFF},\n+  {HB_TAG ('h','l','i','g'), HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES,               HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF},\n+  {HB_TAG ('h','n','g','l'), HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION,         HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL,                HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_TRANSLITERATION},\n+  {HB_TAG ('h','o','j','o'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_HOJO_CHARACTERS,                (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('h','w','i','d'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_TEXT,                (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('i','t','a','l'), HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN,        HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON,            HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF},\n+  {HB_TAG ('j','p','0','4'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS2004_CHARACTERS,             (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('j','p','7','8'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1978_CHARACTERS,             (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('j','p','8','3'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1983_CHARACTERS,             (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('j','p','9','0'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1990_CHARACTERS,             (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('l','i','g','a'), HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES,               HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_ON,            HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_OFF},\n+  {HB_TAG ('l','n','u','m'), HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE,             HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_NUMBERS,             (hb_aat_layout_feature_selector_t) 2},\n+  {HB_TAG ('m','g','r','k'), HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS,     HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_ON,          HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_OFF},\n+  {HB_TAG ('n','l','c','k'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_NLCCHARACTERS,                  (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('o','n','u','m'), HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE,             HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_NUMBERS,             (hb_aat_layout_feature_selector_t) 2},\n+  {HB_TAG ('o','r','d','n'), HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION,       HB_AAT_LAYOUT_FEATURE_SELECTOR_ORDINALS,                       HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION},\n+  {HB_TAG ('p','a','l','t'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT,          (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('p','c','a','p'), HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE,              HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_PETITE_CAPS,         HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_LOWER_CASE},\n+  {HB_TAG ('p','k','n','a'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_TEXT,              (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('p','n','u','m'), HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING,          HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_NUMBERS,           (hb_aat_layout_feature_selector_t) 4},\n+  {HB_TAG ('p','w','i','d'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_TEXT,              (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('q','w','i','d'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_TEXT,             (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('r','u','b','y'), HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA,               HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON,                   HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF},\n+  {HB_TAG ('s','i','n','f'), HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION,       HB_AAT_LAYOUT_FEATURE_SELECTOR_SCIENTIFIC_INFERIORS,           HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION},\n+  {HB_TAG ('s','m','c','p'), HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE,              HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS,          HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_LOWER_CASE},\n+  {HB_TAG ('s','m','p','l'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_SIMPLIFIED_CHARACTERS,          (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('s','s','0','1'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_ON,           HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_OFF},\n+  {HB_TAG ('s','s','0','2'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_ON,           HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_OFF},\n+  {HB_TAG ('s','s','0','3'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_ON,         HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_OFF},\n+  {HB_TAG ('s','s','0','4'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_ON,          HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_OFF},\n+  {HB_TAG ('s','s','0','5'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_ON,          HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_OFF},\n+  {HB_TAG ('s','s','0','6'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_ON,           HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_OFF},\n+  {HB_TAG ('s','s','0','7'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_ON,         HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_OFF},\n+  {HB_TAG ('s','s','0','8'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_ON,         HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_OFF},\n+  {HB_TAG ('s','s','0','9'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_ON,          HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_OFF},\n+  {HB_TAG ('s','s','1','0'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_ON,           HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_OFF},\n+  {HB_TAG ('s','s','1','1'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_OFF},\n+  {HB_TAG ('s','s','1','2'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_OFF},\n+  {HB_TAG ('s','s','1','3'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_ON,      HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_OFF},\n+  {HB_TAG ('s','s','1','4'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_ON,      HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_OFF},\n+  {HB_TAG ('s','s','1','5'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_ON,       HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_OFF},\n+  {HB_TAG ('s','s','1','6'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_ON,       HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_OFF},\n+  {HB_TAG ('s','s','1','7'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_ON,     HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_OFF},\n+  {HB_TAG ('s','s','1','8'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_ON,      HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_OFF},\n+  {HB_TAG ('s','s','1','9'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_ON,      HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_OFF},\n+  {HB_TAG ('s','s','2','0'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES,  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_ON,        HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_OFF},\n+  {HB_TAG ('s','u','b','s'), HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION,       HB_AAT_LAYOUT_FEATURE_SELECTOR_INFERIORS,                      HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION},\n+  {HB_TAG ('s','u','p','s'), HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION,       HB_AAT_LAYOUT_FEATURE_SELECTOR_SUPERIORS,                      HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION},\n+  {HB_TAG ('s','w','s','h'), HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES, HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_ON,            HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_OFF},\n+  {HB_TAG ('t','i','t','l'), HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS,           HB_AAT_LAYOUT_FEATURE_SELECTOR_TITLING_CAPS,                   HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLE_OPTIONS},\n+  {HB_TAG ('t','n','a','m'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_NAMES_CHARACTERS,   (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('t','n','u','m'), HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING,          HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_NUMBERS,             (hb_aat_layout_feature_selector_t) 4},\n+  {HB_TAG ('t','r','a','d'), HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE,         HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_CHARACTERS,         (hb_aat_layout_feature_selector_t) 16},\n+  {HB_TAG ('t','w','i','d'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_TEXT,               (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('u','n','i','c'), HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE,             (hb_aat_layout_feature_selector_t) 14,                 (hb_aat_layout_feature_selector_t) 15},\n+  {HB_TAG ('v','a','l','t'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT,          (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('v','e','r','t'), HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION,   HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_ON,   HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_OFF},\n+  {HB_TAG ('v','h','a','l'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_HALF_WIDTH_TEXT,            (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('v','k','n','a'), HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA,          HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_ON,         HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_OFF},\n+  {HB_TAG ('v','p','a','l'), HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING,            HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT,          (hb_aat_layout_feature_selector_t) 7},\n+  {HB_TAG ('v','r','t','2'), HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION,   HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_ON,   HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_OFF},\n+  {HB_TAG ('z','e','r','o'), HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS,      HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_ON,                HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_OFF},\n+};\n+\n+const hb_aat_feature_mapping_t *\n+hb_aat_layout_find_feature_mapping (hb_tag_t tag)\n+{\n+  return (const hb_aat_feature_mapping_t *) bsearch (&tag,\n+                                                     feature_mappings,\n+                                                     ARRAY_LENGTH (feature_mappings),\n+                                                     sizeof (feature_mappings[0]),\n+                                                     hb_aat_feature_mapping_t::cmp);\n+}\n+\n+\n+\/*\n+ * hb_aat_apply_context_t\n+ *\/\n+\n+AAT::hb_aat_apply_context_t::hb_aat_apply_context_t (const hb_ot_shape_plan_t *plan_,\n+                                                     hb_font_t *font_,\n+                                                     hb_buffer_t *buffer_,\n+                                                     hb_blob_t *blob) :\n+                                                       plan (plan_),\n+                                                       font (font_),\n+                                                       face (font->face),\n+                                                       buffer (buffer_),\n+                                                       sanitizer (),\n+                                                       ankr_table (&Null(AAT::ankr)),\n+                                                       lookup_index (0),\n+                                                       debug_depth (0)\n+{\n+  sanitizer.init (blob);\n+  sanitizer.set_num_glyphs (face->get_num_glyphs ());\n+  sanitizer.start_processing ();\n+  sanitizer.set_max_ops (HB_SANITIZE_MAX_OPS_MAX);\n+}\n+\n+AAT::hb_aat_apply_context_t::~hb_aat_apply_context_t ()\n+{ sanitizer.end_processing (); }\n+\n+void\n+AAT::hb_aat_apply_context_t::set_ankr_table (const AAT::ankr *ankr_table_)\n+{ ankr_table = ankr_table_; }\n+\n+\n+\/*\n+ * mort\/morx\/kerx\/trak\n+ *\/\n+\n+\n+void\n+hb_aat_layout_compile_map (const hb_aat_map_builder_t *mapper,\n+                           hb_aat_map_t *map)\n+{\n+  const AAT::morx& morx = *mapper->face->table.morx;\n+  if (morx.has_data ())\n+  {\n+    morx.compile_flags (mapper, map);\n+    return;\n+  }\n+\n+  const AAT::mort& mort = *mapper->face->table.mort;\n+  if (mort.has_data ())\n+  {\n+    mort.compile_flags (mapper, map);\n+    return;\n+  }\n+}\n+\n+\n+\/*\n+ * hb_aat_layout_has_substitution:\n+ * @face:\n+ *\n+ * Returns:\n+ * Since: 2.3.0\n+ *\/\n+hb_bool_t\n+hb_aat_layout_has_substitution (hb_face_t *face)\n+{\n+  return face->table.morx->has_data () ||\n+         face->table.mort->has_data ();\n+}\n+\n+void\n+hb_aat_layout_substitute (const hb_ot_shape_plan_t *plan,\n+                          hb_font_t *font,\n+                          hb_buffer_t *buffer)\n+{\n+  hb_blob_t *morx_blob = font->face->table.morx.get_blob ();\n+  const AAT::morx& morx = *morx_blob->as<AAT::morx> ();\n+  if (morx.has_data ())\n+  {\n+    AAT::hb_aat_apply_context_t c (plan, font, buffer, morx_blob);\n+    morx.apply (&c);\n+    return;\n+  }\n+\n+  hb_blob_t *mort_blob = font->face->table.mort.get_blob ();\n+  const AAT::mort& mort = *mort_blob->as<AAT::mort> ();\n+  if (mort.has_data ())\n+  {\n+    AAT::hb_aat_apply_context_t c (plan, font, buffer, mort_blob);\n+    mort.apply (&c);\n+    return;\n+  }\n+}\n+\n+void\n+hb_aat_layout_zero_width_deleted_glyphs (hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  hb_glyph_position_t *pos = buffer->pos;\n+  for (unsigned int i = 0; i < count; i++)\n+    if (unlikely (info[i].codepoint == AAT::DELETED_GLYPH))\n+      pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;\n+}\n+\n+static bool\n+is_deleted_glyph (const hb_glyph_info_t *info)\n+{\n+  return info->codepoint == AAT::DELETED_GLYPH;\n+}\n+\n+void\n+hb_aat_layout_remove_deleted_glyphs (hb_buffer_t *buffer)\n+{\n+  hb_ot_layout_delete_glyphs_inplace (buffer, is_deleted_glyph);\n+}\n+\n+\/*\n+ * hb_aat_layout_has_positioning:\n+ * @face:\n+ *\n+ * Returns:\n+ * Since: 2.3.0\n+ *\/\n+hb_bool_t\n+hb_aat_layout_has_positioning (hb_face_t *face)\n+{\n+  return face->table.kerx->has_data ();\n+}\n+\n+void\n+hb_aat_layout_position (const hb_ot_shape_plan_t *plan,\n+                        hb_font_t *font,\n+                        hb_buffer_t *buffer)\n+{\n+  hb_blob_t *kerx_blob = font->face->table.kerx.get_blob ();\n+  const AAT::kerx& kerx = *kerx_blob->as<AAT::kerx> ();\n+\n+  AAT::hb_aat_apply_context_t c (plan, font, buffer, kerx_blob);\n+  c.set_ankr_table (font->face->table.ankr.get ());\n+  kerx.apply (&c);\n+}\n+\n+\n+\/*\n+ * hb_aat_layout_has_tracking:\n+ * @face:\n+ *\n+ * Returns:\n+ * Since: 2.3.0\n+ *\/\n+hb_bool_t\n+hb_aat_layout_has_tracking (hb_face_t *face)\n+{\n+  return face->table.trak->has_data ();\n+}\n+\n+void\n+hb_aat_layout_track (const hb_ot_shape_plan_t *plan,\n+                     hb_font_t *font,\n+                     hb_buffer_t *buffer)\n+{\n+  const AAT::trak& trak = *font->face->table.trak;\n+\n+  AAT::hb_aat_apply_context_t c (plan, font, buffer);\n+  trak.apply (&c);\n+}\n+\n+\n+hb_language_t\n+_hb_aat_language_get (hb_face_t *face,\n+                      unsigned int i)\n+{\n+  return face->table.ltag->get_language (i);\n+}\n+\n+\/**\n+ * hb_aat_layout_get_feature_types:\n+ * @face: a face object\n+ * @start_offset: iteration's start offset\n+ * @feature_count:(inout) (allow-none): buffer size as input, filled size as output\n+ * @features: (out caller-allocates) (array length=feature_count): features buffer\n+ *\n+ * Return value: Number of all available feature types.\n+ *\n+ * Since: 2.2.0\n+ *\/\n+unsigned int\n+hb_aat_layout_get_feature_types (hb_face_t                    *face,\n+                                 unsigned int                  start_offset,\n+                                 unsigned int                 *feature_count, \/* IN\/OUT.  May be NULL. *\/\n+                                 hb_aat_layout_feature_type_t *features       \/* OUT.     May be NULL. *\/)\n+{\n+  return face->table.feat->get_feature_types (start_offset, feature_count, features);\n+}\n+\n+\/**\n+ * hb_aat_layout_feature_type_get_name_id:\n+ * @face: a face object\n+ * @feature_type: feature id\n+ *\n+ * Return value: Name ID index\n+ *\n+ * Since: 2.2.0\n+ *\/\n+hb_ot_name_id_t\n+hb_aat_layout_feature_type_get_name_id (hb_face_t                    *face,\n+                                        hb_aat_layout_feature_type_t  feature_type)\n+{\n+  return face->table.feat->get_feature_name_id (feature_type);\n+}\n+\n+\/**\n+ * hb_aat_layout_feature_type_get_selectors:\n+ * @face:    a face object\n+ * @feature_type: feature id\n+ * @start_offset:    iteration's start offset\n+ * @selector_count: (inout) (allow-none): buffer size as input, filled size as output\n+ * @selectors: (out caller-allocates) (array length=selector_count): settings buffer\n+ * @default_index: (out) (allow-none): index of default selector if any\n+ *\n+ * If upon return, @default_index is set to #HB_AAT_LAYOUT_NO_SELECTOR_INDEX, then\n+ * the feature type is non-exclusive.  Otherwise, @default_index is the index of\n+ * the selector that is selected by default.\n+ *\n+ * Return value: Number of all available feature selectors.\n+ *\n+ * Since: 2.2.0\n+ *\/\n+unsigned int\n+hb_aat_layout_feature_type_get_selector_infos (hb_face_t                             *face,\n+                                               hb_aat_layout_feature_type_t           feature_type,\n+                                               unsigned int                           start_offset,\n+                                               unsigned int                          *selector_count, \/* IN\/OUT.  May be NULL. *\/\n+                                               hb_aat_layout_feature_selector_info_t *selectors,      \/* OUT.     May be NULL. *\/\n+                                               unsigned int                          *default_index   \/* OUT.     May be NULL. *\/)\n+{\n+  return face->table.feat->get_selector_infos (feature_type, start_offset, selector_count, selectors, default_index);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout.cc","additions":384,"deletions":0,"binary":false,"changes":384,"status":"added"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_AAT_H_IN\n+#error \"Include <hb-aat.h> instead.\"\n+#endif\n+\n+#ifndef HB_AAT_LAYOUT_H\n+#define HB_AAT_LAYOUT_H\n+\n+#include \"hb.h\"\n+\n+#include \"hb-ot.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\/**\n+ * hb_aat_layout_feature_type_t:\n+ *\n+ *\n+ * Since: 2.2.0\n+ *\/\n+typedef enum\n+{\n+  HB_AAT_LAYOUT_FEATURE_TYPE_INVALID                            = 0xFFFF,\n+\n+  HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC                    = 0,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES                          = 1,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CURISVE_CONNECTION                 = 2,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE                        = 3,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION              = 4,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT           = 5,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING                     = 6,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE                   = 8,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE                    = 9,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION                  = 10,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS                          = 11,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE        = 13,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS                 = 14,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS                = 15,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE                 = 16,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES             = 17,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE             = 18,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS                      = 19,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE                    = 20,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE                        = 21,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING                       = 22,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION                    = 23,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE                    = 24,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE                  = 25,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE           = 26,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE         = 27,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA                          = 28,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE       = 29,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE      = 30,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE  = 31,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN                   = 32,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT              = 33,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA                     = 34,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES             = 35,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES            = 36,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE                         = 37,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE                         = 38,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_LANGUAGE_TAG_TYPE                  = 39,\n+  HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE             = 103,\n+\n+  _HB_AAT_LAYOUT_FEATURE_TYPE_MAX_VALUE= 0x7FFFFFFFu, \/*< skip >*\/\n+} hb_aat_layout_feature_type_t;\n+\n+\/**\n+ * hb_aat_layout_feature_selector_t:\n+ *\n+ *\n+ * Since: 2.2.0\n+ *\/\n+typedef enum\n+{\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INVALID                        = 0xFFFF,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_ALL_TYPOGRAPHIC *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_ON           = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_TYPE_FEATURES_OFF          = 1,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_ON          = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_REQUIRED_LIGATURES_OFF         = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_ON            = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_COMMON_LIGATURES_OFF           = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_ON              = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_RARE_LIGATURES_OFF             = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_ON                       = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LOGOS_OFF                      = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_ON              = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_REBUS_PICTURES_OFF             = 9,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_ON         = 10,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DIPHTHONG_LIGATURES_OFF        = 11,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_ON           = 12,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SQUARED_LIGATURES_OFF          = 13,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_ON    = 14,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ABBREV_SQUARED_LIGATURES_OFF   = 15,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_ON            = 16,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SYMBOL_LIGATURES_OFF           = 17,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_ON        = 18,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_LIGATURES_OFF       = 19,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_ON        = 20,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HISTORICAL_LIGATURES_OFF       = 21,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_LIGATURES *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_UNCONNECTED                    = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PARTIALLY_CONNECTED            = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CURSIVE                        = 2,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_LETTER_CASE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_AND_LOWER_CASE           = 0, \/* deprecated *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_CAPS                       = 1, \/* deprecated *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALL_LOWER_CASE                 = 2, \/* deprecated *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SMALL_CAPS                     = 3, \/* deprecated *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS                   = 4, \/* deprecated *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INITIAL_CAPS_AND_SMALL_CAPS    = 5, \/* deprecated *\/\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_SUBSTITUTION *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_ON   = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SUBSTITUTE_VERTICAL_FORMS_OFF  = 1,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_LINGUISTIC_REARRANGEMENT *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_ON    = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LINGUISTIC_REARRANGEMENT_OFF   = 1,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_SPACING *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_NUMBERS             = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_NUMBERS           = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_NUMBERS            = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_NUMBERS          = 3,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_SMART_SWASH_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_ON        = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_INITIAL_SWASHES_OFF       = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_ON          = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_WORD_FINAL_SWASHES_OFF         = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_ON        = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_INITIAL_SWASHES_OFF       = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_ON          = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LINE_FINAL_SWASHES_OFF         = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_ON           = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NON_FINAL_SWASHES_OFF          = 9,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_DIACRITICS_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SHOW_DIACRITICS                = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HIDE_DIACRITICS                = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DECOMPOSE_DIACRITICS           = 2,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_VERTICAL_POSITION *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NORMAL_POSITION                = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SUPERIORS                      = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INFERIORS                      = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ORDINALS                       = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SCIENTIFIC_INFERIORS           = 4,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_FRACTIONS *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_FRACTIONS                   = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_VERTICAL_FRACTIONS             = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAGONAL_FRACTIONS             = 2,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_OVERLAPPING_CHARACTERS_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_ON             = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PREVENT_OVERLAP_OFF            = 1,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_TYPOGRAPHIC_EXTRAS *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_ON          = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHENS_TO_EM_DASH_OFF         = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_ON           = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_EN_DASH_OFF          = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_ON                = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASHED_ZERO_OFF               = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_ON            = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_FORM_INTERROBANG_OFF           = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_ON                = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SMART_QUOTES_OFF               = 9,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_ON         = 10,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIODS_TO_ELLIPSIS_OFF        = 11,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_MATHEMATICAL_EXTRAS *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_ON             = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HYPHEN_TO_MINUS_OFF            = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_ON        = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ASTERISK_TO_MULTIPLY_OFF       = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_ON             = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SLASH_TO_DIVIDE_OFF            = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_ON        = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INEQUALITY_LIGATURES_OFF       = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_ON                   = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPONENTS_OFF                  = 9,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_ON          = 10,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_MATHEMATICAL_GREEK_OFF         = 11,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_ORNAMENT_SETS_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ORNAMENTS                   = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DINGBATS                       = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PI_CHARACTERS                  = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_FLEURONS                       = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DECORATIVE_BORDERS             = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INTERNATIONAL_SYMBOLS          = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_MATH_SYMBOLS                   = 6,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ALTERNATES                  = 0,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_DESIGN_COMPLEXITY_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL1                  = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL2                  = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL3                  = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL4                  = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DESIGN_LEVEL5                  = 4,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLE_OPTIONS *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLE_OPTIONS               = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DISPLAY_TEXT                   = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ENGRAVED_TEXT                  = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ILLUMINATED_CAPS               = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TITLING_CAPS                   = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TALL_CAPS                      = 5,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_SHAPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_CHARACTERS         = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SIMPLIFIED_CHARACTERS          = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1978_CHARACTERS             = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1983_CHARACTERS             = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS1990_CHARACTERS             = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_ONE            = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_TWO            = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_THREE          = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FOUR           = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_ALT_FIVE           = 9,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_EXPERT_CHARACTERS              = 10,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_JIS2004_CHARACTERS             = 11,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HOJO_CHARACTERS                = 12,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NLCCHARACTERS                  = 13,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRADITIONAL_NAMES_CHARACTERS   = 14,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_NUMBER_CASE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_NUMBERS             = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_NUMBERS             = 1,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_TEXT_SPACING *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_TEXT              = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_MONOSPACED_TEXT                = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_TEXT                = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_THIRD_WIDTH_TEXT               = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_QUARTER_WIDTH_TEXT             = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_PROPORTIONAL_TEXT          = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALT_HALF_WIDTH_TEXT            = 6,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_TRANSLITERATION *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_TRANSLITERATION             = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL                = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HIRAGANA_TO_KATAKANA           = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_KATAKANA_TO_HIRAGANA           = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_KANA_TO_ROMANIZATION           = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_HIRAGANA       = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMANIZATION_TO_KATAKANA       = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_ONE        = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_TWO        = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HANJA_TO_HANGUL_ALT_THREE      = 9,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_ANNOTATION_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_ANNOTATION                  = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_BOX_ANNOTATION                 = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ROUNDED_BOX_ANNOTATION         = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CIRCLE_ANNOTATION              = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_CIRCLE_ANNOTATION     = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PARENTHESIS_ANNOTATION         = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PERIOD_ANNOTATION              = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ROMAN_NUMERAL_ANNOTATION       = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DIAMOND_ANNOTATION             = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_BOX_ANNOTATION        = 9,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_INVERTED_ROUNDED_BOX_ANNOTATION= 10,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_KANA_SPACING_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_KANA                = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_KANA              = 1,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_SPACING_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_IDEOGRAPHS          = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_IDEOGRAPHS        = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_IDEOGRAPHS          = 2,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_UNICODE_DECOMPOSITION_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_ON       = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CANONICAL_COMPOSITION_OFF      = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_ON   = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_COMPATIBILITY_COMPOSITION_OFF  = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_ON     = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_TRANSCODING_COMPOSITION_OFF    = 5,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_RUBY_KANA *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_RUBY_KANA                   = 0, \/* deprecated - use HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF instead *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA                      = 1, \/* deprecated - use HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON instead *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_ON                   = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_RUBY_KANA_OFF                  = 3,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_SYMBOL_ALTERNATIVES_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_SYMBOL_ALTERNATIVES     = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_ONE             = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_TWO             = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_THREE           = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FOUR            = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_SYMBOL_ALT_FIVE            = 5,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_IDEOGRAPHIC_ALTERNATIVES_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_IDEOGRAPHIC_ALTERNATIVES    = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_ONE            = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_TWO            = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_THREE          = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FOUR           = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_IDEOGRAPHIC_ALT_FIVE           = 5,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_VERTICAL_ROMAN_PLACEMENT_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_CENTERED    = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_VERTICAL_ROMAN_HBASELINE   = 1,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_ITALIC_CJK_ROMAN *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_CJK_ITALIC_ROMAN            = 0,    \/* deprecated - use HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF instead *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN               = 1,    \/* deprecated - use HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON instead *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_ON            = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CJK_ITALIC_ROMAN_OFF           = 3,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_CASE_SENSITIVE_LAYOUT *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_ON       = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_LAYOUT_OFF      = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_ON      = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CASE_SENSITIVE_SPACING_OFF     = 3,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_ALTERNATE_KANA *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_ON        = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_HORIZ_KANA_OFF       = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_ON         = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_ALTERNATE_VERT_KANA_OFF        = 3,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_STYLISTIC_ALTERNATIVES *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_NO_STYLISTIC_ALTERNATES        = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_ON           = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ONE_OFF          = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_ON           = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWO_OFF          = 5,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_ON         = 6,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THREE_OFF        = 7,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_ON          = 8,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOUR_OFF         = 9,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_ON          = 10,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIVE_OFF         = 11,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_ON           = 12,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIX_OFF          = 13,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_ON         = 14,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVEN_OFF        = 15,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_ON         = 16,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHT_OFF        = 17,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_ON          = 18,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINE_OFF         = 19,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_ON           = 20,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TEN_OFF          = 21,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_ON        = 22,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_ELEVEN_OFF       = 23,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_ON        = 24,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWELVE_OFF       = 25,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_ON      = 26,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_THIRTEEN_OFF     = 27,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_ON      = 28,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FOURTEEN_OFF     = 29,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_ON       = 30,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_FIFTEEN_OFF      = 31,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_ON       = 32,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SIXTEEN_OFF      = 33,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_ON     = 34,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_SEVENTEEN_OFF    = 35,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_ON      = 36,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_EIGHTEEN_OFF     = 37,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_ON      = 38,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_NINETEEN_OFF     = 39,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_ON        = 40,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_STYLISTIC_ALT_TWENTY_OFF       = 41,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_CONTEXTUAL_ALTERNATIVES *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_ON       = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_ALTERNATES_OFF      = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_ON            = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_SWASH_ALTERNATES_OFF           = 3,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_ON = 4,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_CONTEXTUAL_SWASH_ALTERNATES_OFF= 5,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_LOWER_CASE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_LOWER_CASE             = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_SMALL_CAPS          = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_LOWER_CASE_PETITE_CAPS         = 2,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_UPPER_CASE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_UPPER_CASE             = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_SMALL_CAPS          = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_UPPER_CASE_PETITE_CAPS         = 2,\n+\n+  \/* Selectors for #HB_AAT_LAYOUT_FEATURE_TYPE_CJK_ROMAN_SPACING_TYPE *\/\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_HALF_WIDTH_CJK_ROMAN           = 0,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_PROPORTIONAL_CJK_ROMAN         = 1,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_DEFAULT_CJK_ROMAN              = 2,\n+  HB_AAT_LAYOUT_FEATURE_SELECTOR_FULL_WIDTH_CJK_ROMAN           = 3,\n+\n+  _HB_AAT_LAYOUT_FEATURE_SELECTOR_MAX_VALUE= 0x7FFFFFFFu, \/*< skip >*\/\n+} hb_aat_layout_feature_selector_t;\n+\n+HB_EXTERN unsigned int\n+hb_aat_layout_get_feature_types (hb_face_t                    *face,\n+                                 unsigned int                  start_offset,\n+                                 unsigned int                 *feature_count, \/* IN\/OUT.  May be NULL. *\/\n+                                 hb_aat_layout_feature_type_t *features       \/* OUT.     May be NULL. *\/);\n+\n+HB_EXTERN hb_ot_name_id_t\n+hb_aat_layout_feature_type_get_name_id (hb_face_t                    *face,\n+                                        hb_aat_layout_feature_type_t  feature_type);\n+\n+typedef struct hb_aat_layout_feature_selector_info_t\n+{\n+  hb_ot_name_id_t                       name_id;\n+  hb_aat_layout_feature_selector_t      enable;\n+  hb_aat_layout_feature_selector_t      disable;\n+  \/*< private >*\/\n+  unsigned int                          reserved;\n+} hb_aat_layout_feature_selector_info_t;\n+\n+#define HB_AAT_LAYOUT_NO_SELECTOR_INDEX         0xFFFFu\n+\n+HB_EXTERN unsigned int\n+hb_aat_layout_feature_type_get_selector_infos (hb_face_t                             *face,\n+                                               hb_aat_layout_feature_type_t           feature_type,\n+                                               unsigned int                           start_offset,\n+                                               unsigned int                          *selector_count, \/* IN\/OUT.  May be NULL. *\/\n+                                               hb_aat_layout_feature_selector_info_t *selectors,      \/* OUT.     May be NULL. *\/\n+                                               unsigned int                          *default_index   \/* OUT.     May be NULL. *\/);\n+\n+\n+\/*\n+ * morx\/mort\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_aat_layout_has_substitution (hb_face_t *face);\n+\n+\n+\/*\n+ * kerx\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_aat_layout_has_positioning (hb_face_t *face);\n+\n+\n+\/*\n+ * trak\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_aat_layout_has_tracking (hb_face_t *face);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_AAT_LAYOUT_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout.h","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_AAT_LAYOUT_HH\n+#define HB_AAT_LAYOUT_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shape.hh\"\n+\n+\n+struct hb_aat_feature_mapping_t\n+{\n+  hb_tag_t otFeatureTag;\n+  hb_aat_layout_feature_type_t aatFeatureType;\n+  hb_aat_layout_feature_selector_t selectorToEnable;\n+  hb_aat_layout_feature_selector_t selectorToDisable;\n+\n+  static int cmp (const void *key_, const void *entry_)\n+  {\n+    hb_tag_t key = * (unsigned int *) key_;\n+    const hb_aat_feature_mapping_t * entry = (const hb_aat_feature_mapping_t *) entry_;\n+    return key < entry->otFeatureTag ? -1 :\n+           key > entry->otFeatureTag ? 1 :\n+           0;\n+  }\n+};\n+\n+HB_INTERNAL const hb_aat_feature_mapping_t *\n+hb_aat_layout_find_feature_mapping (hb_tag_t tag);\n+\n+HB_INTERNAL void\n+hb_aat_layout_compile_map (const hb_aat_map_builder_t *mapper,\n+                           hb_aat_map_t *map);\n+\n+HB_INTERNAL void\n+hb_aat_layout_substitute (const hb_ot_shape_plan_t *plan,\n+                          hb_font_t *font,\n+                          hb_buffer_t *buffer);\n+\n+HB_INTERNAL void\n+hb_aat_layout_zero_width_deleted_glyphs (hb_buffer_t *buffer);\n+\n+HB_INTERNAL void\n+hb_aat_layout_remove_deleted_glyphs (hb_buffer_t *buffer);\n+\n+HB_INTERNAL void\n+hb_aat_layout_position (const hb_ot_shape_plan_t *plan,\n+                        hb_font_t *font,\n+                        hb_buffer_t *buffer);\n+\n+HB_INTERNAL void\n+hb_aat_layout_track (const hb_ot_shape_plan_t *plan,\n+                     hb_font_t *font,\n+                     hb_buffer_t *buffer);\n+\n+HB_INTERNAL hb_language_t\n+_hb_aat_language_get (hb_face_t *face,\n+                      unsigned int i);\n+\n+\n+#endif \/* HB_AAT_LAYOUT_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-layout.hh","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_AAT_LTAG_TABLE_HH\n+#define HB_AAT_LTAG_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * ltag -- Language Tag\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6ltag.html\n+ *\/\n+#define HB_AAT_TAG_ltag HB_TAG('l','t','a','g')\n+\n+\n+namespace AAT {\n+\n+using namespace OT;\n+\n+\n+struct FTStringRange\n+{\n+  friend struct ltag;\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && (base+tag).sanitize (c, length));\n+  }\n+\n+  protected:\n+  NNOffsetTo<UnsizedArrayOf<HBUINT8> >\n+                tag;            \/* Offset from the start of the table to\n+                                 * the beginning of the string *\/\n+  HBUINT16      length;         \/* String length (in bytes) *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct ltag\n+{\n+  static constexpr hb_tag_t tableTag = HB_AAT_TAG_ltag;\n+\n+  hb_language_t get_language (unsigned int i) const\n+  {\n+    const FTStringRange &range = tagRanges[i];\n+    return hb_language_from_string ((const char *) (this+range.tag).arrayZ,\n+                                    range.length);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          version >= 1 &&\n+                          tagRanges.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  HBUINT32      version;        \/* Table version; currently 1 *\/\n+  HBUINT32      flags;          \/* Table flags; currently none defined *\/\n+  LArrayOf<FTStringRange>\n+                tagRanges;      \/* Range for each tag's string *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (12, tagRanges);\n+};\n+\n+} \/* namespace AAT *\/\n+\n+\n+#endif \/* HB_AAT_LTAG_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-ltag-table.hh","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2010,2011,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-aat-map.hh\"\n+\n+#include \"hb-aat-layout.hh\"\n+\n+\n+void hb_aat_map_builder_t::add_feature (hb_tag_t tag,\n+                                        unsigned int value)\n+{\n+  if (tag == HB_TAG ('a','a','l','t'))\n+  {\n+    feature_info_t *info = features.push();\n+    info->type = HB_AAT_LAYOUT_FEATURE_TYPE_CHARACTER_ALTERNATIVES;\n+    info->setting = (hb_aat_layout_feature_selector_t) value;\n+    return;\n+  }\n+\n+  const hb_aat_feature_mapping_t *mapping = hb_aat_layout_find_feature_mapping (tag);\n+  if (!mapping) return;\n+\n+  feature_info_t *info = features.push();\n+  info->type = mapping->aatFeatureType;\n+  info->setting = value ? mapping->selectorToEnable : mapping->selectorToDisable;\n+}\n+\n+void\n+hb_aat_map_builder_t::compile (hb_aat_map_t  &m)\n+{\n+  \/* Sort features and merge duplicates *\/\n+  if (features.length)\n+  {\n+    features.qsort ();\n+    unsigned int j = 0;\n+    for (unsigned int i = 1; i < features.length; i++)\n+      if (features[i].type != features[j].type)\n+        features[++j] = features[i];\n+    features.shrink (j + 1);\n+  }\n+\n+  hb_aat_layout_compile_map (this, &m);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-map.cc","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_AAT_MAP_HH\n+#define HB_AAT_MAP_HH\n+\n+#include \"hb.hh\"\n+\n+\n+struct hb_aat_map_t\n+{\n+  friend struct hb_aat_map_builder_t;\n+\n+  public:\n+\n+  void init ()\n+  {\n+    memset (this, 0, sizeof (*this));\n+    chain_flags.init ();\n+  }\n+  void fini () { chain_flags.fini (); }\n+\n+  public:\n+  hb_vector_t<hb_mask_t> chain_flags;\n+};\n+\n+struct hb_aat_map_builder_t\n+{\n+  public:\n+\n+  HB_INTERNAL hb_aat_map_builder_t (hb_face_t *face_,\n+                                    const hb_segment_properties_t *props_ HB_UNUSED) :\n+                                      face (face_) {}\n+\n+  HB_INTERNAL void add_feature (hb_tag_t tag, unsigned int value=1);\n+\n+  HB_INTERNAL void compile (hb_aat_map_t  &m);\n+\n+  public:\n+  struct feature_info_t\n+  {\n+    hb_aat_layout_feature_type_t  type;\n+    hb_aat_layout_feature_selector_t  setting;\n+    unsigned  seq; \/* For stable sorting only. *\/\n+\n+    static int cmp (const void *pa, const void *pb)\n+    {\n+      const feature_info_t *a = (const feature_info_t *) pa;\n+      const feature_info_t *b = (const feature_info_t *) pb;\n+      return (a->type != b->type) ? (a->type < b->type ? -1 : 1) :\n+             (a->seq < b->seq ? -1 : a->seq > b->seq ? 1 : 0);\n+    }\n+\n+    int cmp (hb_aat_layout_feature_type_t ty) const\n+    {\n+      return (type != ty) ? (type < ty ? -1 : 1) : 0;\n+    }\n+  };\n+\n+  public:\n+  hb_face_t *face;\n+\n+  public:\n+  hb_vector_t<feature_info_t> features;\n+};\n+\n+\n+#endif \/* HB_AAT_MAP_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat-map.hh","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-aat.h","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-aat.h","status":"copied"},{"patch":"@@ -0,0 +1,277 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_ARRAY_HH\n+#define HB_ARRAY_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-dsalgs.hh\"\n+#include \"hb-iter.hh\"\n+#include \"hb-null.hh\"\n+\n+\n+template <typename Type>\n+struct hb_sorted_array_t;\n+\n+template <typename Type>\n+struct hb_array_t :\n+        hb_iter_t<hb_array_t<Type>, Type>,\n+        hb_iter_mixin_t<hb_array_t<Type>, Type>\n+{\n+  \/*\n+   * Constructors.\n+   *\/\n+  hb_array_t () : arrayZ (nullptr), length (0) {}\n+  hb_array_t (Type *array_, unsigned int length_) : arrayZ (array_), length (length_) {}\n+  template <unsigned int length_> hb_array_t (Type (&array_)[length_]) : arrayZ (array_), length (length_) {}\n+\n+\n+  \/*\n+   * Iterator implementation.\n+   *\/\n+  typedef Type __item_type__;\n+  Type& __item_at__ (unsigned i) const\n+  {\n+    if (unlikely (i >= length)) return CrapOrNull (Type);\n+    return arrayZ[i];\n+  }\n+  void __forward__ (unsigned n)\n+  {\n+    if (unlikely (n > length))\n+      n = length;\n+    length -= n;\n+    arrayZ += n;\n+  }\n+  void __rewind__ (unsigned n)\n+  {\n+    if (unlikely (n > length))\n+      n = length;\n+    length -= n;\n+  }\n+  unsigned __len__ () const { return length; }\n+  bool __random_access__ () const { return true; }\n+\n+  \/* Extra operators.\n+   *\/\n+  Type * operator & () const { return arrayZ; }\n+  operator hb_array_t<const Type> () { return hb_array_t<const Type> (arrayZ, length); }\n+  template <typename T> operator T * () const { return arrayZ; }\n+\n+  \/*\n+   * Compare, Sort, and Search.\n+   *\/\n+\n+  \/* Note: our compare is NOT lexicographic; it also does NOT call Type::cmp. *\/\n+  int cmp (const hb_array_t<Type> &a) const\n+  {\n+    if (length != a.length)\n+      return (int) a.length - (int) length;\n+    return hb_memcmp (a.arrayZ, arrayZ, get_size ());\n+  }\n+  static int cmp (const void *pa, const void *pb)\n+  {\n+    hb_array_t<Type> *a = (hb_array_t<Type> *) pa;\n+    hb_array_t<Type> *b = (hb_array_t<Type> *) pb;\n+    return b->cmp (*a);\n+  }\n+\n+  template <typename T>\n+  Type *lsearch (const T &x, Type *not_found = nullptr)\n+  {\n+    unsigned int count = length;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!this->arrayZ[i].cmp (x))\n+        return &this->arrayZ[i];\n+    return not_found;\n+  }\n+  template <typename T>\n+  const Type *lsearch (const T &x, const Type *not_found = nullptr) const\n+  {\n+    unsigned int count = length;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!this->arrayZ[i].cmp (x))\n+        return &this->arrayZ[i];\n+    return not_found;\n+  }\n+\n+  hb_sorted_array_t<Type> qsort (int (*cmp_)(const void*, const void*))\n+  {\n+    if (likely (length))\n+      ::qsort (arrayZ, length, this->item_size, cmp_);\n+    return hb_sorted_array_t<Type> (*this);\n+  }\n+  hb_sorted_array_t<Type> qsort ()\n+  {\n+    if (likely (length))\n+      ::qsort (arrayZ, length, this->item_size, Type::cmp);\n+    return hb_sorted_array_t<Type> (*this);\n+  }\n+  void qsort (unsigned int start, unsigned int end)\n+  {\n+    end = MIN (end, length);\n+    assert (start <= end);\n+    if (likely (start < end))\n+      ::qsort (arrayZ + start, end - start, this->item_size, Type::cmp);\n+  }\n+\n+  \/*\n+   * Other methods.\n+   *\/\n+\n+  unsigned int get_size () const { return length * this->item_size; }\n+\n+  hb_array_t<Type> sub_array (unsigned int start_offset = 0, unsigned int *seg_count = nullptr \/* IN\/OUT *\/) const\n+  {\n+    if (!start_offset && !seg_count)\n+      return *this;\n+\n+    unsigned int count = length;\n+    if (unlikely (start_offset > count))\n+      count = 0;\n+    else\n+      count -= start_offset;\n+    if (seg_count)\n+      count = *seg_count = MIN (count, *seg_count);\n+    return hb_array_t<Type> (arrayZ + start_offset, count);\n+  }\n+  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int seg_count) const\n+  { return sub_array (start_offset, &seg_count); }\n+\n+  \/* Only call if you allocated the underlying array using malloc() or similar. *\/\n+  void free ()\n+  { ::free ((void *) arrayZ); arrayZ = nullptr; length = 0; }\n+\n+  template <typename hb_sanitize_context_t>\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return c->check_array (arrayZ, length); }\n+\n+  \/*\n+   * Members\n+   *\/\n+\n+  public:\n+  Type *arrayZ;\n+  unsigned int length;\n+};\n+template <typename T> inline hb_array_t<T>\n+hb_array (T *array, unsigned int length)\n+{ return hb_array_t<T> (array, length); }\n+template <typename T, unsigned int length_> inline hb_array_t<T>\n+hb_array (T (&array_)[length_])\n+{ return hb_array_t<T> (array_); }\n+\n+\n+enum hb_bfind_not_found_t\n+{\n+  HB_BFIND_NOT_FOUND_DONT_STORE,\n+  HB_BFIND_NOT_FOUND_STORE,\n+  HB_BFIND_NOT_FOUND_STORE_CLOSEST,\n+};\n+\n+template <typename Type>\n+struct hb_sorted_array_t :\n+        hb_sorted_iter_t<hb_sorted_array_t<Type>, Type>,\n+        hb_array_t<Type>,\n+        hb_iter_mixin_t<hb_sorted_array_t<Type>, Type>\n+{\n+  hb_sorted_array_t () : hb_array_t<Type> () {}\n+  hb_sorted_array_t (const hb_array_t<Type> &o) : hb_array_t<Type> (o) {}\n+  hb_sorted_array_t (Type *array_, unsigned int length_) : hb_array_t<Type> (array_, length_) {}\n+  template <unsigned int length_> hb_sorted_array_t (Type (&array_)[length_]) : hb_array_t<Type> (array_) {}\n+\n+  hb_sorted_array_t<Type> sub_array (unsigned int start_offset, unsigned int *seg_count \/* IN\/OUT *\/) const\n+  { return hb_sorted_array_t<Type> (((const hb_array_t<Type> *) (this))->sub_array (start_offset, seg_count)); }\n+  hb_sorted_array_t<Type> sub_array (unsigned int start_offset, unsigned int seg_count) const\n+  { return sub_array (start_offset, &seg_count); }\n+\n+  template <typename T>\n+  Type *bsearch (const T &x, Type *not_found = nullptr)\n+  {\n+    unsigned int i;\n+    return bfind (x, &i) ? &this->arrayZ[i] : not_found;\n+  }\n+  template <typename T>\n+  const Type *bsearch (const T &x, const Type *not_found = nullptr) const\n+  {\n+    unsigned int i;\n+    return bfind (x, &i) ? &this->arrayZ[i] : not_found;\n+  }\n+  template <typename T>\n+  bool bfind (const T &x, unsigned int *i = nullptr,\n+                     hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+                     unsigned int to_store = (unsigned int) -1) const\n+  {\n+    int min = 0, max = (int) this->length - 1;\n+    const Type *array = this->arrayZ;\n+    while (min <= max)\n+    {\n+      int mid = ((unsigned int) min + (unsigned int) max) \/ 2;\n+      int c = array[mid].cmp (x);\n+      if (c < 0)\n+        max = mid - 1;\n+      else if (c > 0)\n+        min = mid + 1;\n+      else\n+      {\n+        if (i)\n+          *i = mid;\n+        return true;\n+      }\n+    }\n+    if (i)\n+    {\n+      switch (not_found)\n+      {\n+        case HB_BFIND_NOT_FOUND_DONT_STORE:\n+          break;\n+\n+        case HB_BFIND_NOT_FOUND_STORE:\n+          *i = to_store;\n+          break;\n+\n+        case HB_BFIND_NOT_FOUND_STORE_CLOSEST:\n+          if (max < 0 || (max < (int) this->length && array[max].cmp (x) > 0))\n+            max++;\n+          *i = max;\n+          break;\n+      }\n+    }\n+    return false;\n+  }\n+};\n+template <typename T> inline hb_sorted_array_t<T>\n+hb_sorted_array (T *array, unsigned int length)\n+{ return hb_sorted_array_t<T> (array, length); }\n+template <typename T, unsigned int length_> inline hb_sorted_array_t<T>\n+hb_sorted_array (T (&array_)[length_])\n+{ return hb_sorted_array_t<T> (array_); }\n+\n+\n+typedef hb_array_t<const char> hb_bytes_t;\n+typedef hb_array_t<const unsigned char> hb_ubytes_t;\n+\n+\n+#endif \/* HB_ARRAY_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-array.hh","additions":277,"deletions":0,"binary":false,"changes":277,"status":"added"},{"patch":"@@ -0,0 +1,300 @@\n+\/*\n+ * Copyright © 2007  Chris Wilson\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Contributor(s):\n+ *      Chris Wilson <chris@chris-wilson.co.uk>\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_ATOMIC_HH\n+#define HB_ATOMIC_HH\n+\n+#include \"hb.hh\"\n+\n+\n+\/*\n+ * Atomic integers and pointers.\n+ *\/\n+\n+\n+\/* We need external help for these *\/\n+\n+#if defined(hb_atomic_int_impl_add) \\\n+ && defined(hb_atomic_ptr_impl_get) \\\n+ && defined(hb_atomic_ptr_impl_cmpexch)\n+\n+\/* Defined externally, i.e. in config.h. *\/\n+\n+\n+#elif !defined(HB_NO_MT) && defined(__ATOMIC_ACQUIRE)\n+\n+\/* C++11-style GCC primitives. *\/\n+\n+#define _hb_memory_barrier()                    __sync_synchronize ()\n+\n+#define hb_atomic_int_impl_add(AI, V)           __atomic_fetch_add ((AI), (V), __ATOMIC_ACQ_REL)\n+#define hb_atomic_int_impl_set_relaxed(AI, V)   __atomic_store_n ((AI), (V), __ATOMIC_RELAXED)\n+#define hb_atomic_int_impl_set(AI, V)           __atomic_store_n ((AI), (V), __ATOMIC_RELEASE)\n+#define hb_atomic_int_impl_get_relaxed(AI)      __atomic_load_n ((AI), __ATOMIC_RELAXED)\n+#define hb_atomic_int_impl_get(AI)              __atomic_load_n ((AI), __ATOMIC_ACQUIRE)\n+\n+#define hb_atomic_ptr_impl_set_relaxed(P, V)    __atomic_store_n ((P), (V), __ATOMIC_RELAXED)\n+#define hb_atomic_ptr_impl_get_relaxed(P)       __atomic_load_n ((P), __ATOMIC_RELAXED)\n+#define hb_atomic_ptr_impl_get(P)               __atomic_load_n ((P), __ATOMIC_ACQUIRE)\n+static inline bool\n+_hb_atomic_ptr_impl_cmplexch (const void **P, const void *O_, const void *N)\n+{\n+  const void *O = O_; \/\/ Need lvalue\n+  return __atomic_compare_exchange_n ((void **) P, (void **) &O, (void *) N, true, __ATOMIC_ACQ_REL, __ATOMIC_RELAXED);\n+}\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       _hb_atomic_ptr_impl_cmplexch ((const void **) (P), (O), (N))\n+\n+#elif !defined(HB_NO_MT) && __cplusplus >= 201103L\n+\n+\/* C++11 atomics. *\/\n+\n+#include <atomic>\n+\n+#define _hb_memory_barrier()                    std::atomic_thread_fence(std::memory_order_ack_rel)\n+#define _hb_memory_r_barrier()                  std::atomic_thread_fence(std::memory_order_acquire)\n+#define _hb_memory_w_barrier()                  std::atomic_thread_fence(std::memory_order_release)\n+\n+#define hb_atomic_int_impl_add(AI, V)           (reinterpret_cast<std::atomic<int> *> (AI)->fetch_add ((V), std::memory_order_acq_rel))\n+#define hb_atomic_int_impl_set_relaxed(AI, V)   (reinterpret_cast<std::atomic<int> *> (AI)->store ((V), std::memory_order_relaxed))\n+#define hb_atomic_int_impl_set(AI, V)           (reinterpret_cast<std::atomic<int> *> (AI)->store ((V), std::memory_order_release))\n+#define hb_atomic_int_impl_get_relaxed(AI)      (reinterpret_cast<std::atomic<int> *> (AI)->load (std::memory_order_relaxed))\n+#define hb_atomic_int_impl_get(AI)              (reinterpret_cast<std::atomic<int> *> (AI)->load (std::memory_order_acquire))\n+\n+#define hb_atomic_ptr_impl_set_relaxed(P, V)    (reinterpret_cast<std::atomic<void*> *> (P)->store ((V), std::memory_order_relaxed))\n+#define hb_atomic_ptr_impl_get_relaxed(P)       (reinterpret_cast<std::atomic<void*> *> (P)->load (std::memory_order_relaxed))\n+#define hb_atomic_ptr_impl_get(P)               (reinterpret_cast<std::atomic<void*> *> (P)->load (std::memory_order_acquire))\n+static inline bool\n+_hb_atomic_ptr_impl_cmplexch (const void **P, const void *O_, const void *N)\n+{\n+  const void *O = O_; \/\/ Need lvalue\n+  return reinterpret_cast<std::atomic<const void*> *> (P)->compare_exchange_weak (O, N, std::memory_order_acq_rel, std::memory_order_relaxed);\n+}\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       _hb_atomic_ptr_impl_cmplexch ((const void **) (P), (O), (N))\n+\n+\n+#elif !defined(HB_NO_MT) && defined(_WIN32)\n+\n+#include <windows.h>\n+\n+static inline void _hb_memory_barrier ()\n+{\n+#if !defined(MemoryBarrier)\n+  \/* MinGW has a convoluted history of supporting MemoryBarrier. *\/\n+  LONG dummy = 0;\n+  InterlockedExchange (&dummy, 1);\n+#else\n+  MemoryBarrier ();\n+#endif\n+}\n+#define _hb_memory_barrier()                    _hb_memory_barrier ()\n+\n+#define hb_atomic_int_impl_add(AI, V)           InterlockedExchangeAdd ((LONG *) (AI), (V))\n+static_assert ((sizeof (LONG) == sizeof (int)), \"\");\n+\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       (InterlockedCompareExchangePointer ((P), (N), (O)) == (O))\n+\n+\n+#elif !defined(HB_NO_MT) && defined(HAVE_INTEL_ATOMIC_PRIMITIVES)\n+\n+#define _hb_memory_barrier()                    __sync_synchronize ()\n+\n+#define hb_atomic_int_impl_add(AI, V)           __sync_fetch_and_add ((AI), (V))\n+\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       __sync_bool_compare_and_swap ((P), (O), (N))\n+\n+\n+#elif !defined(HB_NO_MT) && defined(HAVE_SOLARIS_ATOMIC_OPS)\n+\n+#include <atomic.h>\n+#include <mbarrier.h>\n+\n+#define _hb_memory_r_barrier()                  __machine_r_barrier ()\n+#define _hb_memory_w_barrier()                  __machine_w_barrier ()\n+#define _hb_memory_barrier()                    __machine_rw_barrier ()\n+\n+static inline int _hb_fetch_and_add (int *AI, int V)\n+{\n+  _hb_memory_w_barrier ();\n+  int result = atomic_add_int_nv ((uint_t *) AI, V) - V;\n+  _hb_memory_r_barrier ();\n+  return result;\n+}\n+static inline bool _hb_compare_and_swap_ptr (void **P, void *O, void *N)\n+{\n+  _hb_memory_w_barrier ();\n+  bool result = atomic_cas_ptr (P, O, N) == O;\n+  _hb_memory_r_barrier ();\n+  return result;\n+}\n+\n+#define hb_atomic_int_impl_add(AI, V)           _hb_fetch_and_add ((AI), (V))\n+\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       _hb_compare_and_swap_ptr ((P), (O), (N))\n+\n+\n+#elif !defined(HB_NO_MT) && defined(__APPLE__)\n+\n+#include <libkern\/OSAtomic.h>\n+#ifdef __MAC_OS_X_MIN_REQUIRED\n+#include <AvailabilityMacros.h>\n+#elif defined(__IPHONE_OS_MIN_REQUIRED)\n+#include <Availability.h>\n+#endif\n+\n+#define _hb_memory_barrier()                    OSMemoryBarrier ()\n+\n+#define hb_atomic_int_impl_add(AI, V)           (OSAtomicAdd32Barrier ((V), (AI)) - (V))\n+\n+#if (MAC_OS_X_VERSION_MIN_REQUIRED > MAC_OS_X_VERSION_10_4 || __IPHONE_VERSION_MIN_REQUIRED >= 20100)\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       OSAtomicCompareAndSwapPtrBarrier ((O), (N), (P))\n+#else\n+#if __ppc64__ || __x86_64__ || __aarch64__\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       OSAtomicCompareAndSwap64Barrier ((int64_t) (O), (int64_t) (N), (int64_t*) (P))\n+#else\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       OSAtomicCompareAndSwap32Barrier ((int32_t) (O), (int32_t) (N), (int32_t*) (P))\n+#endif\n+#endif\n+\n+\n+#elif !defined(HB_NO_MT) && defined(_AIX) && defined(__IBMCPP__)\n+\n+#include <builtins.h>\n+\n+#define _hb_memory_barrier()                    __lwsync ()\n+\n+static inline int _hb_fetch_and_add (int *AI, int V)\n+{\n+  _hb_memory_barrier ();\n+  int result = __fetch_and_add (AI, V);\n+  _hb_memory_barrier ();\n+  return result;\n+}\n+static inline bool _hb_compare_and_swaplp (long *P, long O, long N)\n+{\n+  _hb_memory_barrier ();\n+  bool result = __compare_and_swaplp (P, &O, N);\n+  _hb_memory_barrier ();\n+  return result;\n+}\n+\n+#define hb_atomic_int_impl_add(AI, V)           _hb_fetch_and_add ((AI), (V))\n+\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       _hb_compare_and_swaplp ((long *) (P), (long) (O), (long) (N))\n+static_assert ((sizeof (long) == sizeof (void *)), \"\");\n+\n+\n+#elif !defined(HB_NO_MT)\n+\n+#define HB_ATOMIC_INT_NIL 1 \/* Warn that fallback implementation is in use. *\/\n+\n+#define _hb_memory_barrier()\n+\n+#define hb_atomic_int_impl_add(AI, V)           ((*(AI) += (V)) - (V))\n+\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       (* (void **) (P) == (void *) (O) ? (* (void **) (P) = (void *) (N), true) : false)\n+\n+\n+#else \/* HB_NO_MT *\/\n+\n+#define hb_atomic_int_impl_add(AI, V)           ((*(AI) += (V)) - (V))\n+\n+#define _hb_memory_barrier()\n+\n+#define hb_atomic_ptr_impl_cmpexch(P,O,N)       (* (void **) (P) == (void *) (O) ? (* (void **) (P) = (void *) (N), true) : false)\n+\n+\n+#endif\n+\n+\n+#ifndef _hb_memory_r_barrier\n+#define _hb_memory_r_barrier()                  _hb_memory_barrier ()\n+#endif\n+#ifndef _hb_memory_w_barrier\n+#define _hb_memory_w_barrier()                  _hb_memory_barrier ()\n+#endif\n+#ifndef hb_atomic_int_impl_set_relaxed\n+#define hb_atomic_int_impl_set_relaxed(AI, V)   (*(AI) = (V))\n+#endif\n+#ifndef hb_atomic_int_impl_get_relaxed\n+#define hb_atomic_int_impl_get_relaxed(AI)      (*(AI))\n+#endif\n+\n+#ifndef hb_atomic_ptr_impl_set_relaxed\n+#define hb_atomic_ptr_impl_set_relaxed(P, V)    (*(P) = (V))\n+#endif\n+#ifndef hb_atomic_ptr_impl_get_relaxed\n+#define hb_atomic_ptr_impl_get_relaxed(P)       (*(P))\n+#endif\n+#ifndef hb_atomic_int_impl_set\n+inline void hb_atomic_int_impl_set (int *AI, int v)     { _hb_memory_w_barrier (); *AI = v; }\n+#endif\n+#ifndef hb_atomic_int_impl_get\n+inline int hb_atomic_int_impl_get (const int *AI)       { int v = *AI; _hb_memory_r_barrier (); return v; }\n+#endif\n+#ifndef hb_atomic_ptr_impl_get\n+inline void *hb_atomic_ptr_impl_get (void ** const P)   { void *v = *P; _hb_memory_r_barrier (); return v; }\n+#endif\n+\n+\n+#define HB_ATOMIC_INT_INIT(V)          {V}\n+struct hb_atomic_int_t\n+{\n+  void set_relaxed (int v_) { hb_atomic_int_impl_set_relaxed (&v, v_); }\n+  void set (int v_) { hb_atomic_int_impl_set (&v, v_); }\n+  int get_relaxed () const { return hb_atomic_int_impl_get_relaxed (&v); }\n+  int get () const { return hb_atomic_int_impl_get (&v); }\n+  int inc () { return hb_atomic_int_impl_add (&v,  1); }\n+  int dec () { return hb_atomic_int_impl_add (&v, -1); }\n+\n+  int v;\n+};\n+\n+\n+#define HB_ATOMIC_PTR_INIT(V)          {V}\n+template <typename P>\n+struct hb_atomic_ptr_t\n+{\n+  typedef typename hb_remove_pointer (P) T;\n+\n+  void init (T* v_ = nullptr) { set_relaxed (v_); }\n+  void set_relaxed (T* v_) { hb_atomic_ptr_impl_set_relaxed (&v, v_); }\n+  T *get_relaxed () const { return (T *) hb_atomic_ptr_impl_get_relaxed (&v); }\n+  T *get () const { return (T *) hb_atomic_ptr_impl_get ((void **) &v); }\n+  bool cmpexch (const T *old, T *new_) const { return hb_atomic_ptr_impl_cmpexch ((void **) &v, (void *) old, (void *) new_); }\n+\n+  T * operator -> () const                    { return get (); }\n+  template <typename C> operator C * () const { return get (); }\n+\n+  T *v;\n+};\n+\n+\n+#endif \/* HB_ATOMIC_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-atomic.hh","additions":300,"deletions":0,"binary":false,"changes":300,"status":"added"},{"patch":"@@ -0,0 +1,678 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1308\n+ * http:\/\/www.gnu.org\/software\/libc\/manual\/html_node\/Feature-Test-Macros.html\n+ * https:\/\/www.oracle.com\/technetwork\/articles\/servers-storage-dev\/standardheaderfiles-453865.html\n+ *\/\n+#ifndef _POSIX_C_SOURCE\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-macros\"\n+#define _POSIX_C_SOURCE 200809L\n+#pragma GCC diagnostic pop\n+#endif\n+\n+#include \"hb.hh\"\n+#include \"hb-blob.hh\"\n+\n+#ifdef HAVE_SYS_MMAN_H\n+#ifdef HAVE_UNISTD_H\n+#include <unistd.h>\n+#endif \/* HAVE_UNISTD_H *\/\n+#include <sys\/mman.h>\n+#endif \/* HAVE_SYS_MMAN_H *\/\n+\n+#include <stdio.h>\n+#include <errno.h>\n+#include <stdlib.h>\n+\n+\n+\/**\n+ * SECTION: hb-blob\n+ * @title: hb-blob\n+ * @short_description: Binary data containers\n+ * @include: hb.h\n+ *\n+ * Blobs wrap a chunk of binary data to handle lifecycle management of data\n+ * while it is passed between client and HarfBuzz.  Blobs are primarily used\n+ * to create font faces, but also to access font face tables, as well as\n+ * pass around other binary data.\n+ **\/\n+\n+\n+\/**\n+ * hb_blob_create: (skip)\n+ * @data: Pointer to blob data.\n+ * @length: Length of @data in bytes.\n+ * @mode: Memory mode for @data.\n+ * @user_data: Data parameter to pass to @destroy.\n+ * @destroy: Callback to call when @data is not needed anymore.\n+ *\n+ * Creates a new \"blob\" object wrapping @data.  The @mode parameter is used\n+ * to negotiate ownership and lifecycle of @data.\n+ *\n+ * Return value: New blob, or the empty blob if something failed or if @length is\n+ * zero.  Destroy with hb_blob_destroy().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_blob_t *\n+hb_blob_create (const char        *data,\n+                unsigned int       length,\n+                hb_memory_mode_t   mode,\n+                void              *user_data,\n+                hb_destroy_func_t  destroy)\n+{\n+  hb_blob_t *blob;\n+\n+  if (!length ||\n+      length >= 1u << 31 ||\n+      !(blob = hb_object_create<hb_blob_t> ())) {\n+    if (destroy)\n+      destroy (user_data);\n+    return hb_blob_get_empty ();\n+  }\n+\n+  blob->data = data;\n+  blob->length = length;\n+  blob->mode = mode;\n+\n+  blob->user_data = user_data;\n+  blob->destroy = destroy;\n+\n+  if (blob->mode == HB_MEMORY_MODE_DUPLICATE) {\n+    blob->mode = HB_MEMORY_MODE_READONLY;\n+    if (!blob->try_make_writable ()) {\n+      hb_blob_destroy (blob);\n+      return hb_blob_get_empty ();\n+    }\n+  }\n+\n+  return blob;\n+}\n+\n+static void\n+_hb_blob_destroy (void *data)\n+{\n+  hb_blob_destroy ((hb_blob_t *) data);\n+}\n+\n+\/**\n+ * hb_blob_create_sub_blob:\n+ * @parent: Parent blob.\n+ * @offset: Start offset of sub-blob within @parent, in bytes.\n+ * @length: Length of sub-blob.\n+ *\n+ * Returns a blob that represents a range of bytes in @parent.  The new\n+ * blob is always created with %HB_MEMORY_MODE_READONLY, meaning that it\n+ * will never modify data in the parent blob.  The parent data is not\n+ * expected to be modified, and will result in undefined behavior if it\n+ * is.\n+ *\n+ * Makes @parent immutable.\n+ *\n+ * Return value: New blob, or the empty blob if something failed or if\n+ * @length is zero or @offset is beyond the end of @parent's data.  Destroy\n+ * with hb_blob_destroy().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_blob_t *\n+hb_blob_create_sub_blob (hb_blob_t    *parent,\n+                         unsigned int  offset,\n+                         unsigned int  length)\n+{\n+  hb_blob_t *blob;\n+\n+  if (!length || !parent || offset >= parent->length)\n+    return hb_blob_get_empty ();\n+\n+  hb_blob_make_immutable (parent);\n+\n+  blob = hb_blob_create (parent->data + offset,\n+                         MIN (length, parent->length - offset),\n+                         HB_MEMORY_MODE_READONLY,\n+                         hb_blob_reference (parent),\n+                         _hb_blob_destroy);\n+\n+  return blob;\n+}\n+\n+\/**\n+ * hb_blob_copy_writable_or_fail:\n+ * @blob: A blob.\n+ *\n+ * Makes a writable copy of @blob.\n+ *\n+ * Return value: New blob, or nullptr if allocation failed.\n+ *\n+ * Since: 1.8.0\n+ **\/\n+hb_blob_t *\n+hb_blob_copy_writable_or_fail (hb_blob_t *blob)\n+{\n+  blob = hb_blob_create (blob->data,\n+                         blob->length,\n+                         HB_MEMORY_MODE_DUPLICATE,\n+                         nullptr,\n+                         nullptr);\n+\n+  if (unlikely (blob == hb_blob_get_empty ()))\n+    blob = nullptr;\n+\n+  return blob;\n+}\n+\n+\/**\n+ * hb_blob_get_empty:\n+ *\n+ * Returns the singleton empty blob.\n+ *\n+ * See TODO:link object types for more information.\n+ *\n+ * Return value: (transfer full): the empty blob.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_blob_t *\n+hb_blob_get_empty ()\n+{\n+  return const_cast<hb_blob_t *> (&Null(hb_blob_t));\n+}\n+\n+\/**\n+ * hb_blob_reference: (skip)\n+ * @blob: a blob.\n+ *\n+ * Increases the reference count on @blob.\n+ *\n+ * See TODO:link object types for more information.\n+ *\n+ * Return value: @blob.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_blob_t *\n+hb_blob_reference (hb_blob_t *blob)\n+{\n+  return hb_object_reference (blob);\n+}\n+\n+\/**\n+ * hb_blob_destroy: (skip)\n+ * @blob: a blob.\n+ *\n+ * Decreases the reference count on @blob, and if it reaches zero, destroys\n+ * @blob, freeing all memory, possibly calling the destroy-callback the blob\n+ * was created for if it has not been called already.\n+ *\n+ * See TODO:link object types for more information.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_blob_destroy (hb_blob_t *blob)\n+{\n+  if (!hb_object_destroy (blob)) return;\n+\n+  blob->fini_shallow ();\n+\n+  free (blob);\n+}\n+\n+\/**\n+ * hb_blob_set_user_data: (skip)\n+ * @blob: a blob.\n+ * @key: key for data to set.\n+ * @data: data to set.\n+ * @destroy: callback to call when @data is not needed anymore.\n+ * @replace: whether to replace an existing data with the same key.\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_blob_set_user_data (hb_blob_t          *blob,\n+                       hb_user_data_key_t *key,\n+                       void *              data,\n+                       hb_destroy_func_t   destroy,\n+                       hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (blob, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_blob_get_user_data: (skip)\n+ * @blob: a blob.\n+ * @key: key for data to get.\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void *\n+hb_blob_get_user_data (hb_blob_t          *blob,\n+                       hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (blob, key);\n+}\n+\n+\n+\/**\n+ * hb_blob_make_immutable:\n+ * @blob: a blob.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_blob_make_immutable (hb_blob_t *blob)\n+{\n+  if (hb_object_is_immutable (blob))\n+    return;\n+\n+  hb_object_make_immutable (blob);\n+}\n+\n+\/**\n+ * hb_blob_is_immutable:\n+ * @blob: a blob.\n+ *\n+ *\n+ *\n+ * Return value: TODO\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_blob_is_immutable (hb_blob_t *blob)\n+{\n+  return hb_object_is_immutable (blob);\n+}\n+\n+\n+\/**\n+ * hb_blob_get_length:\n+ * @blob: a blob.\n+ *\n+ *\n+ *\n+ * Return value: the length of blob data in bytes.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+unsigned int\n+hb_blob_get_length (hb_blob_t *blob)\n+{\n+  return blob->length;\n+}\n+\n+\/**\n+ * hb_blob_get_data:\n+ * @blob: a blob.\n+ * @length: (out):\n+ *\n+ *\n+ *\n+ * Returns: (transfer none) (array length=length):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+const char *\n+hb_blob_get_data (hb_blob_t *blob, unsigned int *length)\n+{\n+  if (length)\n+    *length = blob->length;\n+\n+  return blob->data;\n+}\n+\n+\/**\n+ * hb_blob_get_data_writable:\n+ * @blob: a blob.\n+ * @length: (out): output length of the writable data.\n+ *\n+ * Tries to make blob data writable (possibly copying it) and\n+ * return pointer to data.\n+ *\n+ * Fails if blob has been made immutable, or if memory allocation\n+ * fails.\n+ *\n+ * Returns: (transfer none) (array length=length): Writable blob data,\n+ * or %NULL if failed.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+char *\n+hb_blob_get_data_writable (hb_blob_t *blob, unsigned int *length)\n+{\n+  if (!blob->try_make_writable ()) {\n+    if (length)\n+      *length = 0;\n+\n+    return nullptr;\n+  }\n+\n+  if (length)\n+    *length = blob->length;\n+\n+  return const_cast<char *> (blob->data);\n+}\n+\n+\n+bool\n+hb_blob_t::try_make_writable_inplace_unix ()\n+{\n+#if defined(HAVE_SYS_MMAN_H) && defined(HAVE_MPROTECT)\n+  uintptr_t pagesize = -1, mask, length;\n+  const char *addr;\n+\n+#if defined(HAVE_SYSCONF) && defined(_SC_PAGE_SIZE)\n+  pagesize = (uintptr_t) sysconf (_SC_PAGE_SIZE);\n+#elif defined(HAVE_SYSCONF) && defined(_SC_PAGESIZE)\n+  pagesize = (uintptr_t) sysconf (_SC_PAGESIZE);\n+#elif defined(HAVE_GETPAGESIZE)\n+  pagesize = (uintptr_t) getpagesize ();\n+#endif\n+\n+  if ((uintptr_t) -1L == pagesize) {\n+    DEBUG_MSG_FUNC (BLOB, this, \"failed to get pagesize: %s\", strerror (errno));\n+    return false;\n+  }\n+  DEBUG_MSG_FUNC (BLOB, this, \"pagesize is %lu\", (unsigned long) pagesize);\n+\n+  mask = ~(pagesize-1);\n+  addr = (const char *) (((uintptr_t) this->data) & mask);\n+  length = (const char *) (((uintptr_t) this->data + this->length + pagesize-1) & mask)  - addr;\n+  DEBUG_MSG_FUNC (BLOB, this,\n+                  \"calling mprotect on [%p..%p] (%lu bytes)\",\n+                  addr, addr+length, (unsigned long) length);\n+  if (-1 == mprotect ((void *) addr, length, PROT_READ | PROT_WRITE)) {\n+    DEBUG_MSG_FUNC (BLOB, this, \"mprotect failed: %s\", strerror (errno));\n+    return false;\n+  }\n+\n+  this->mode = HB_MEMORY_MODE_WRITABLE;\n+\n+  DEBUG_MSG_FUNC (BLOB, this,\n+                  \"successfully made [%p..%p] (%lu bytes) writable\\n\",\n+                  addr, addr+length, (unsigned long) length);\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n+\n+bool\n+hb_blob_t::try_make_writable_inplace ()\n+{\n+  DEBUG_MSG_FUNC (BLOB, this, \"making writable inplace\\n\");\n+\n+  if (this->try_make_writable_inplace_unix ())\n+    return true;\n+\n+  DEBUG_MSG_FUNC (BLOB, this, \"making writable -> FAILED\\n\");\n+\n+  \/* Failed to make writable inplace, mark that *\/\n+  this->mode = HB_MEMORY_MODE_READONLY;\n+  return false;\n+}\n+\n+bool\n+hb_blob_t::try_make_writable ()\n+{\n+  if (hb_object_is_immutable (this))\n+    return false;\n+\n+  if (this->mode == HB_MEMORY_MODE_WRITABLE)\n+    return true;\n+\n+  if (this->mode == HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE && this->try_make_writable_inplace ())\n+    return true;\n+\n+  if (this->mode == HB_MEMORY_MODE_WRITABLE)\n+    return true;\n+\n+\n+  DEBUG_MSG_FUNC (BLOB, this, \"current data is -> %p\\n\", this->data);\n+\n+  char *new_data;\n+\n+  new_data = (char *) malloc (this->length);\n+  if (unlikely (!new_data))\n+    return false;\n+\n+  DEBUG_MSG_FUNC (BLOB, this, \"dupped successfully -> %p\\n\", this->data);\n+\n+  memcpy (new_data, this->data, this->length);\n+  this->destroy_user_data ();\n+  this->mode = HB_MEMORY_MODE_WRITABLE;\n+  this->data = new_data;\n+  this->user_data = new_data;\n+  this->destroy = free;\n+\n+  return true;\n+}\n+\n+\/*\n+ * Mmap\n+ *\/\n+\n+#ifdef HAVE_MMAP\n+# include <sys\/types.h>\n+# include <sys\/stat.h>\n+# include <fcntl.h>\n+#endif\n+\n+#ifdef _WIN32\n+# include <windows.h>\n+#else\n+# ifndef O_BINARY\n+#  define O_BINARY 0\n+# endif\n+#endif\n+\n+#ifndef MAP_NORESERVE\n+# define MAP_NORESERVE 0\n+#endif\n+\n+struct hb_mapped_file_t\n+{\n+  char *contents;\n+  unsigned long length;\n+#ifdef _WIN32\n+  HANDLE mapping;\n+#endif\n+};\n+\n+#if (defined(HAVE_MMAP) || defined(_WIN32)) && !defined(HB_NO_MMAP)\n+static void\n+_hb_mapped_file_destroy (void *file_)\n+{\n+  hb_mapped_file_t *file = (hb_mapped_file_t *) file_;\n+#ifdef HAVE_MMAP\n+  munmap (file->contents, file->length);\n+#elif defined(_WIN32)\n+  UnmapViewOfFile (file->contents);\n+  CloseHandle (file->mapping);\n+#else\n+  assert (0); \/\/ If we don't have mmap we shouldn't reach here\n+#endif\n+\n+  free (file);\n+}\n+#endif\n+\n+\/**\n+ * hb_blob_create_from_file:\n+ * @file_name: font filename.\n+ *\n+ * Returns: A hb_blob_t pointer with the content of the file\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_blob_t *\n+hb_blob_create_from_file (const char *file_name)\n+{\n+  \/* Adopted from glib's gmappedfile.c with Matthias Clasen and\n+     Allison Lortie permission but changed a lot to suit our need. *\/\n+#if defined(HAVE_MMAP) && !defined(HB_NO_MMAP)\n+  hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));\n+  if (unlikely (!file)) return hb_blob_get_empty ();\n+\n+  int fd = open (file_name, O_RDONLY | O_BINARY, 0);\n+  if (unlikely (fd == -1)) goto fail_without_close;\n+\n+  struct stat st;\n+  if (unlikely (fstat (fd, &st) == -1)) goto fail;\n+\n+  file->length = (unsigned long) st.st_size;\n+  file->contents = (char *) mmap (nullptr, file->length, PROT_READ,\n+                                  MAP_PRIVATE | MAP_NORESERVE, fd, 0);\n+\n+  if (unlikely (file->contents == MAP_FAILED)) goto fail;\n+\n+  close (fd);\n+\n+  return hb_blob_create (file->contents, file->length,\n+                         HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,\n+                         (hb_destroy_func_t) _hb_mapped_file_destroy);\n+\n+fail:\n+  close (fd);\n+fail_without_close:\n+  free (file);\n+\n+#elif defined(_WIN32) && !defined(HB_NO_MMAP)\n+  hb_mapped_file_t *file = (hb_mapped_file_t *) calloc (1, sizeof (hb_mapped_file_t));\n+  if (unlikely (!file)) return hb_blob_get_empty ();\n+\n+  HANDLE fd;\n+  unsigned int size = strlen (file_name) + 1;\n+  wchar_t * wchar_file_name = (wchar_t *) malloc (sizeof (wchar_t) * size);\n+  if (unlikely (wchar_file_name == nullptr)) goto fail_without_close;\n+  mbstowcs (wchar_file_name, file_name, size);\n+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)\n+  {\n+    CREATEFILE2_EXTENDED_PARAMETERS ceparams = { 0 };\n+    ceparams.dwSize = sizeof(CREATEFILE2_EXTENDED_PARAMETERS);\n+    ceparams.dwFileAttributes = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED & 0xFFFF;\n+    ceparams.dwFileFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED & 0xFFF00000;\n+    ceparams.dwSecurityQosFlags = FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED & 0x000F0000;\n+    ceparams.lpSecurityAttributes = nullptr;\n+    ceparams.hTemplateFile = nullptr;\n+    fd = CreateFile2 (wchar_file_name, GENERIC_READ, FILE_SHARE_READ,\n+                      OPEN_EXISTING, &ceparams);\n+  }\n+#else\n+  fd = CreateFileW (wchar_file_name, GENERIC_READ, FILE_SHARE_READ, nullptr,\n+                    OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL|FILE_FLAG_OVERLAPPED,\n+                    nullptr);\n+#endif\n+  free (wchar_file_name);\n+\n+  if (unlikely (fd == INVALID_HANDLE_VALUE)) goto fail_without_close;\n+\n+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)\n+  {\n+    LARGE_INTEGER length;\n+    GetFileSizeEx (fd, &length);\n+    file->length = length.LowPart;\n+    file->mapping = CreateFileMappingFromApp (fd, nullptr, PAGE_READONLY, length.QuadPart, nullptr);\n+  }\n+#else\n+  file->length = (unsigned long) GetFileSize (fd, nullptr);\n+  file->mapping = CreateFileMapping (fd, nullptr, PAGE_READONLY, 0, 0, nullptr);\n+#endif\n+  if (unlikely (file->mapping == nullptr)) goto fail;\n+\n+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)\n+  file->contents = (char *) MapViewOfFileFromApp (file->mapping, FILE_MAP_READ, 0, 0);\n+#else\n+  file->contents = (char *) MapViewOfFile (file->mapping, FILE_MAP_READ, 0, 0, 0);\n+#endif\n+  if (unlikely (file->contents == nullptr)) goto fail;\n+\n+  CloseHandle (fd);\n+  return hb_blob_create (file->contents, file->length,\n+                         HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE, (void *) file,\n+                         (hb_destroy_func_t) _hb_mapped_file_destroy);\n+\n+fail:\n+  CloseHandle (fd);\n+fail_without_close:\n+  free (file);\n+\n+#endif\n+\n+  \/* The following tries to read a file without knowing its size beforehand\n+     It's used as a fallback for systems without mmap or to read from pipes *\/\n+  unsigned long len = 0, allocated = BUFSIZ * 16;\n+  char *data = (char *) malloc (allocated);\n+  if (unlikely (data == nullptr)) return hb_blob_get_empty ();\n+\n+  FILE *fp = fopen (file_name, \"rb\");\n+  if (unlikely (fp == nullptr)) goto fread_fail_without_close;\n+\n+  while (!feof (fp))\n+  {\n+    if (allocated - len < BUFSIZ)\n+    {\n+      allocated *= 2;\n+      \/* Don't allocate and go more than ~536MB, our mmap reader still\n+         can cover files like that but lets limit our fallback reader *\/\n+      if (unlikely (allocated > (2 << 28))) goto fread_fail;\n+      char *new_data = (char *) realloc (data, allocated);\n+      if (unlikely (new_data == nullptr)) goto fread_fail;\n+      data = new_data;\n+    }\n+\n+    unsigned long addition = fread (data + len, 1, allocated - len, fp);\n+\n+    int err = ferror (fp);\n+#ifdef EINTR \/\/ armcc doesn't have it\n+    if (unlikely (err == EINTR)) continue;\n+#endif\n+    if (unlikely (err)) goto fread_fail;\n+\n+    len += addition;\n+  }\n+\n+  return hb_blob_create (data, len, HB_MEMORY_MODE_WRITABLE, data,\n+                         (hb_destroy_func_t) free);\n+\n+fread_fail:\n+  fclose (fp);\n+fread_fail_without_close:\n+  free (data);\n+  return hb_blob_get_empty ();\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-blob.cc","additions":678,"deletions":0,"binary":false,"changes":678,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_BLOB_H\n+#define HB_BLOB_H\n+\n+#include \"hb-common.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/*\n+ * Note re various memory-modes:\n+ *\n+ * - In no case shall the HarfBuzz client modify memory\n+ *   that is passed to HarfBuzz in a blob.  If there is\n+ *   any such possibility, MODE_DUPLICATE should be used\n+ *   such that HarfBuzz makes a copy immediately,\n+ *\n+ * - Use MODE_READONLY otherwise, unless you really really\n+ *   really know what you are doing,\n+ *\n+ * - MODE_WRITABLE is appropriate if you really made a\n+ *   copy of data solely for the purpose of passing to\n+ *   HarfBuzz and doing that just once (no reuse!),\n+ *\n+ * - If the font is mmap()ed, it's ok to use\n+ *   READONLY_MAY_MAKE_WRITABLE, however, using that mode\n+ *   correctly is very tricky.  Use MODE_READONLY instead.\n+ *\/\n+typedef enum {\n+  HB_MEMORY_MODE_DUPLICATE,\n+  HB_MEMORY_MODE_READONLY,\n+  HB_MEMORY_MODE_WRITABLE,\n+  HB_MEMORY_MODE_READONLY_MAY_MAKE_WRITABLE\n+} hb_memory_mode_t;\n+\n+typedef struct hb_blob_t hb_blob_t;\n+\n+HB_EXTERN hb_blob_t *\n+hb_blob_create (const char        *data,\n+                unsigned int       length,\n+                hb_memory_mode_t   mode,\n+                void              *user_data,\n+                hb_destroy_func_t  destroy);\n+\n+\/* Always creates with MEMORY_MODE_READONLY.\n+ * Even if the parent blob is writable, we don't\n+ * want the user of the sub-blob to be able to\n+ * modify the parent data as that data may be\n+ * shared among multiple sub-blobs.\n+ *\/\n+HB_EXTERN hb_blob_t *\n+hb_blob_create_sub_blob (hb_blob_t    *parent,\n+                         unsigned int  offset,\n+                         unsigned int  length);\n+\n+HB_EXTERN hb_blob_t *\n+hb_blob_copy_writable_or_fail (hb_blob_t *blob);\n+\n+HB_EXTERN hb_blob_t *\n+hb_blob_get_empty (void);\n+\n+HB_EXTERN hb_blob_t *\n+hb_blob_reference (hb_blob_t *blob);\n+\n+HB_EXTERN void\n+hb_blob_destroy (hb_blob_t *blob);\n+\n+HB_EXTERN hb_bool_t\n+hb_blob_set_user_data (hb_blob_t          *blob,\n+                       hb_user_data_key_t *key,\n+                       void *              data,\n+                       hb_destroy_func_t   destroy,\n+                       hb_bool_t           replace);\n+\n+\n+HB_EXTERN void *\n+hb_blob_get_user_data (hb_blob_t          *blob,\n+                       hb_user_data_key_t *key);\n+\n+\n+HB_EXTERN void\n+hb_blob_make_immutable (hb_blob_t *blob);\n+\n+HB_EXTERN hb_bool_t\n+hb_blob_is_immutable (hb_blob_t *blob);\n+\n+\n+HB_EXTERN unsigned int\n+hb_blob_get_length (hb_blob_t *blob);\n+\n+HB_EXTERN const char *\n+hb_blob_get_data (hb_blob_t *blob, unsigned int *length);\n+\n+HB_EXTERN char *\n+hb_blob_get_data_writable (hb_blob_t *blob, unsigned int *length);\n+\n+HB_EXTERN hb_blob_t *\n+hb_blob_create_from_file (const char *file_name);\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_BLOB_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-blob.h","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,101 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BLOB_HH\n+#define HB_BLOB_HH\n+\n+#include \"hb.hh\"\n+\n+\n+\/*\n+ * hb_blob_t\n+ *\/\n+\n+struct hb_blob_t\n+{\n+  void fini_shallow () { destroy_user_data (); }\n+\n+  void destroy_user_data ()\n+  {\n+    if (destroy)\n+    {\n+      destroy (user_data);\n+      user_data = nullptr;\n+      destroy = nullptr;\n+    }\n+  }\n+\n+  HB_INTERNAL bool try_make_writable ();\n+  HB_INTERNAL bool try_make_writable_inplace ();\n+  HB_INTERNAL bool try_make_writable_inplace_unix ();\n+\n+  template <typename Type>\n+  const Type* as () const\n+  {\n+    return length < hb_null_size (Type) ? &Null(Type) : reinterpret_cast<const Type *> (data);\n+  }\n+  hb_bytes_t as_bytes () const\n+  { return hb_bytes_t (data, length); }\n+\n+  public:\n+  hb_object_header_t header;\n+\n+  const char *data;\n+  unsigned int length;\n+  hb_memory_mode_t mode;\n+\n+  void *user_data;\n+  hb_destroy_func_t destroy;\n+};\n+\n+\n+\/*\n+ * hb_blob_ptr_t\n+ *\/\n+\n+template <typename P>\n+struct hb_blob_ptr_t\n+{\n+  typedef typename hb_remove_pointer (P) T;\n+\n+  hb_blob_ptr_t (hb_blob_t *b_ = nullptr) : b (b_) {}\n+  hb_blob_t * operator = (hb_blob_t *b_) { return b = b_; }\n+  const T * operator -> () const { return get (); }\n+  const T & operator * () const  { return *get (); }\n+  template <typename C> operator const C * () const { return get (); }\n+  operator const char * () const { return (const char *) get (); }\n+  const T * get () const { return b->as<T> (); }\n+  hb_blob_t * get_blob () const { return b.get_raw (); }\n+  unsigned int get_length () const { return b.get ()->length; }\n+  void destroy () { hb_blob_destroy (b.get ()); b = nullptr; }\n+\n+  hb_nonnull_ptr_t<hb_blob_t> b;\n+};\n+\n+\n+#endif \/* HB_BLOB_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-blob.hh","additions":101,"deletions":0,"binary":false,"changes":101,"status":"added"},{"patch":"@@ -0,0 +1,643 @@\n+\n+#line 1 \"hb-buffer-deserialize-json.rl\"\n+\/*\n+ * Copyright © 2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BUFFER_DESERIALIZE_JSON_HH\n+#define HB_BUFFER_DESERIALIZE_JSON_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 36 \"hb-buffer-deserialize-json.hh\"\n+static const unsigned char _deserialize_json_trans_keys[] = {\n+        0u, 0u, 9u, 123u, 9u, 34u, 97u, 103u, 120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u,\n+        48u, 57u, 9u, 125u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u,\n+        9u, 125u, 9u, 125u, 108u, 108u, 34u, 34u, 9u, 58u, 9u, 57u, 9u, 125u, 9u, 125u,\n+        120u, 121u, 34u, 34u, 9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 34u, 34u,\n+        9u, 58u, 9u, 57u, 48u, 57u, 9u, 125u, 9u, 125u, 34u, 34u, 9u, 58u, 9u, 57u,\n+        65u, 122u, 34u, 122u, 9u, 125u, 9u, 125u, 9u, 93u, 9u, 123u, 0u, 0u, 0\n+};\n+\n+static const char _deserialize_json_key_spans[] = {\n+        0, 115, 26, 7, 2, 1, 50, 49,\n+        10, 117, 117, 117, 1, 50, 49, 10,\n+        117, 117, 1, 1, 50, 49, 117, 117,\n+        2, 1, 50, 49, 10, 117, 117, 1,\n+        50, 49, 10, 117, 117, 1, 50, 49,\n+        58, 89, 117, 117, 85, 115, 0\n+};\n+\n+static const short _deserialize_json_index_offsets[] = {\n+        0, 0, 116, 143, 151, 154, 156, 207,\n+        257, 268, 386, 504, 622, 624, 675, 725,\n+        736, 854, 972, 974, 976, 1027, 1077, 1195,\n+        1313, 1316, 1318, 1369, 1419, 1430, 1548, 1666,\n+        1668, 1719, 1769, 1780, 1898, 2016, 2018, 2069,\n+        2119, 2178, 2268, 2386, 2504, 2590, 2706\n+};\n+\n+static const char _deserialize_json_indicies[] = {\n+        0, 0, 0, 0, 0, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        0, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 2, 1, 3, 3, 3,\n+        3, 3, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 3, 1, 4, 1,\n+        5, 1, 6, 7, 1, 1, 8, 1,\n+        9, 10, 1, 11, 1, 11, 11, 11,\n+        11, 11, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 11, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 12, 1,\n+        12, 12, 12, 12, 12, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 12,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 13, 1, 1, 14,\n+        15, 15, 15, 15, 15, 15, 15, 15,\n+        15, 1, 16, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 1, 18, 18, 18,\n+        18, 18, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 18, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        19, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 20, 1, 21, 21, 21, 21, 21,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 21, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 3, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 22,\n+        1, 18, 18, 18, 18, 18, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        18, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 19, 1, 1, 1,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 20, 1, 23,\n+        1, 23, 23, 23, 23, 23, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        23, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 24, 1, 24, 24, 24, 24,\n+        24, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 24, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        25, 1, 1, 26, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 1, 28, 29,\n+        29, 29, 29, 29, 29, 29, 29, 29,\n+        1, 30, 30, 30, 30, 30, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        30, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 31, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 32, 1, 30,\n+        30, 30, 30, 30, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 30, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 31, 1, 1, 1, 29, 29,\n+        29, 29, 29, 29, 29, 29, 29, 29,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 32, 1, 33, 1, 34,\n+        1, 34, 34, 34, 34, 34, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        34, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 35, 1, 35, 35, 35, 35,\n+        35, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 35, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 36, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 1, 38, 38,\n+        38, 38, 38, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 38, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 39, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 40, 1, 38, 38, 38, 38,\n+        38, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 38, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 39,\n+        1, 1, 1, 41, 41, 41, 41, 41,\n+        41, 41, 41, 41, 41, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        40, 1, 42, 43, 1, 44, 1, 44,\n+        44, 44, 44, 44, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 44, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        45, 1, 45, 45, 45, 45, 45, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 45, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 46, 1,\n+        1, 47, 48, 48, 48, 48, 48, 48,\n+        48, 48, 48, 1, 49, 50, 50, 50,\n+        50, 50, 50, 50, 50, 50, 1, 51,\n+        51, 51, 51, 51, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 51, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 52, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 53, 1, 51, 51, 51,\n+        51, 51, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 51, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        52, 1, 1, 1, 50, 50, 50, 50,\n+        50, 50, 50, 50, 50, 50, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 53, 1, 54, 1, 54, 54, 54,\n+        54, 54, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 54, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 55, 1,\n+        55, 55, 55, 55, 55, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 55,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 56, 1, 1, 57,\n+        58, 58, 58, 58, 58, 58, 58, 58,\n+        58, 1, 59, 60, 60, 60, 60, 60,\n+        60, 60, 60, 60, 1, 61, 61, 61,\n+        61, 61, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 61, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        62, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 63, 1, 61, 61, 61, 61, 61,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 61, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 62, 1,\n+        1, 1, 60, 60, 60, 60, 60, 60,\n+        60, 60, 60, 60, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 63,\n+        1, 64, 1, 64, 64, 64, 64, 64,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 64, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 65, 1, 65, 65,\n+        65, 65, 65, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 65, 1, 66,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 67, 68, 68,\n+        68, 68, 68, 68, 68, 68, 68, 1,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 1, 1, 1, 1, 1, 1,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 1, 70, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 71, 71,\n+        1, 71, 71, 71, 71, 71, 71, 71,\n+        71, 71, 71, 1, 1, 1, 1, 1,\n+        1, 1, 71, 71, 71, 71, 71, 71,\n+        71, 71, 71, 71, 71, 71, 71, 71,\n+        71, 71, 71, 71, 71, 71, 71, 71,\n+        71, 71, 71, 71, 1, 1, 1, 1,\n+        71, 1, 71, 71, 71, 71, 71, 71,\n+        71, 71, 71, 71, 71, 71, 71, 71,\n+        71, 71, 71, 71, 71, 71, 71, 71,\n+        71, 71, 71, 71, 1, 72, 72, 72,\n+        72, 72, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 72, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        73, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 74, 1, 72, 72, 72, 72, 72,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 72, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 73, 1,\n+        1, 1, 75, 75, 75, 75, 75, 75,\n+        75, 75, 75, 75, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 74,\n+        1, 76, 76, 76, 76, 76, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        76, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 77, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 78, 1, 0,\n+        0, 0, 0, 0, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 0, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 2, 1, 1, 0\n+};\n+\n+static const char _deserialize_json_trans_targs[] = {\n+        1, 0, 2, 2, 3, 4, 18, 24,\n+        37, 5, 12, 6, 7, 8, 9, 11,\n+        9, 11, 10, 2, 44, 10, 44, 13,\n+        14, 15, 16, 17, 16, 17, 10, 2,\n+        44, 19, 20, 21, 22, 23, 10, 2,\n+        44, 23, 25, 31, 26, 27, 28, 29,\n+        30, 29, 30, 10, 2, 44, 32, 33,\n+        34, 35, 36, 35, 36, 10, 2, 44,\n+        38, 39, 40, 42, 43, 41, 10, 41,\n+        10, 2, 44, 43, 44, 45, 46\n+};\n+\n+static const char _deserialize_json_trans_actions[] = {\n+        0, 0, 1, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 2, 2, 2,\n+        0, 0, 3, 3, 4, 0, 5, 0,\n+        0, 2, 2, 2, 0, 0, 6, 6,\n+        7, 0, 0, 0, 2, 2, 8, 8,\n+        9, 0, 0, 0, 0, 0, 2, 2,\n+        2, 0, 0, 10, 10, 11, 0, 0,\n+        2, 2, 2, 0, 0, 12, 12, 13,\n+        0, 0, 0, 2, 2, 2, 14, 0,\n+        15, 15, 16, 0, 0, 0, 0\n+};\n+\n+static const int deserialize_json_start = 1;\n+static const int deserialize_json_first_final = 44;\n+static const int deserialize_json_error = 0;\n+\n+static const int deserialize_json_en_main = 1;\n+\n+\n+#line 97 \"hb-buffer-deserialize-json.rl\"\n+\n+\n+static hb_bool_t\n+_hb_buffer_deserialize_glyphs_json (hb_buffer_t *buffer,\n+                                    const char *buf,\n+                                    unsigned int buf_len,\n+                                    const char **end_ptr,\n+                                    hb_font_t *font)\n+{\n+  const char *p = buf, *pe = buf + buf_len;\n+\n+  \/* Ensure we have positions. *\/\n+  (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n+\n+  while (p < pe && ISSPACE (*p))\n+    p++;\n+  if (p < pe && *p == (buffer->len ? ',' : '['))\n+  {\n+    *end_ptr = ++p;\n+  }\n+\n+  const char *tok = nullptr;\n+  int cs;\n+  hb_glyph_info_t info = {0};\n+  hb_glyph_position_t pos = {0};\n+\n+#line 466 \"hb-buffer-deserialize-json.hh\"\n+        {\n+        cs = deserialize_json_start;\n+        }\n+\n+#line 471 \"hb-buffer-deserialize-json.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+        if ( cs == 0 )\n+                goto _out;\n+_resume:\n+        _keys = _deserialize_json_trans_keys + (cs<<1);\n+        _inds = _deserialize_json_indicies + _deserialize_json_index_offsets[cs];\n+\n+        _slen = _deserialize_json_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n+                (*p) <= _keys[1] ?\n+                (*p) - _keys[0] : _slen ];\n+\n+        cs = _deserialize_json_trans_targs[_trans];\n+\n+        if ( _deserialize_json_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _deserialize_json_trans_actions[_trans] ) {\n+        case 1:\n+#line 38 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n+        break;\n+        case 5:\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 2:\n+#line 51 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 14:\n+#line 55 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+        break;\n+        case 15:\n+#line 62 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_uint (tok, p, &info.codepoint)) return false; }\n+        break;\n+        case 8:\n+#line 63 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+        break;\n+        case 10:\n+#line 64 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n+        break;\n+        case 12:\n+#line 65 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+        break;\n+        case 3:\n+#line 66 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+        break;\n+        case 6:\n+#line 67 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+        break;\n+        case 16:\n+#line 62 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_uint (tok, p, &info.codepoint)) return false; }\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 9:\n+#line 63 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n+#line 64 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 13:\n+#line 65 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 4:\n+#line 66 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 7:\n+#line 67 \"hb-buffer-deserialize-json.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-json.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 624 \"hb-buffer-deserialize-json.hh\"\n+        }\n+\n+_again:\n+        if ( cs == 0 )\n+                goto _out;\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        _out: {}\n+        }\n+\n+#line 125 \"hb-buffer-deserialize-json.rl\"\n+\n+\n+  *end_ptr = p;\n+\n+  return p == pe && *(p-1) != ']';\n+}\n+\n+#endif \/* HB_BUFFER_DESERIALIZE_JSON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-buffer-deserialize-json.hh","additions":643,"deletions":0,"binary":false,"changes":643,"status":"added"},{"patch":"@@ -0,0 +1,571 @@\n+\n+#line 1 \"hb-buffer-deserialize-text.rl\"\n+\/*\n+ * Copyright © 2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BUFFER_DESERIALIZE_TEXT_HH\n+#define HB_BUFFER_DESERIALIZE_TEXT_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 36 \"hb-buffer-deserialize-text.hh\"\n+static const unsigned char _deserialize_text_trans_keys[] = {\n+        0u, 0u, 9u, 122u, 45u, 57u, 48u, 57u, 45u, 57u, 48u, 57u, 48u, 57u, 45u, 57u,\n+        48u, 57u, 44u, 44u, 45u, 57u, 48u, 57u, 44u, 57u, 9u, 124u, 9u, 124u, 0u, 0u,\n+        9u, 122u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u, 9u, 124u,\n+        9u, 124u, 9u, 124u, 9u, 124u, 0\n+};\n+\n+static const char _deserialize_text_key_spans[] = {\n+        0, 114, 13, 10, 13, 10, 10, 13,\n+        10, 1, 13, 10, 14, 116, 116, 0,\n+        114, 116, 116, 116, 116, 116, 116, 116,\n+        116, 116, 116\n+};\n+\n+static const short _deserialize_text_index_offsets[] = {\n+        0, 0, 115, 129, 140, 154, 165, 176,\n+        190, 201, 203, 217, 228, 243, 360, 477,\n+        478, 593, 710, 827, 944, 1061, 1178, 1295,\n+        1412, 1529, 1646\n+};\n+\n+static const char _deserialize_text_indicies[] = {\n+        0, 0, 0, 0, 0, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        0, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        2, 3, 3, 3, 3, 3, 3, 3,\n+        3, 3, 1, 1, 1, 1, 1, 1,\n+        1, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 1, 1, 1, 1, 1,\n+        1, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 1, 5, 1, 1, 6,\n+        7, 7, 7, 7, 7, 7, 7, 7,\n+        7, 1, 8, 9, 9, 9, 9, 9,\n+        9, 9, 9, 9, 1, 10, 1, 1,\n+        11, 12, 12, 12, 12, 12, 12, 12,\n+        12, 12, 1, 13, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 1, 15, 16,\n+        16, 16, 16, 16, 16, 16, 16, 16,\n+        1, 17, 1, 1, 18, 19, 19, 19,\n+        19, 19, 19, 19, 19, 19, 1, 20,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 1, 22, 1, 23, 1, 1, 24,\n+        25, 25, 25, 25, 25, 25, 25, 25,\n+        25, 1, 26, 27, 27, 27, 27, 27,\n+        27, 27, 27, 27, 1, 22, 1, 1,\n+        1, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 1, 28, 28, 28, 28,\n+        28, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 28, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 29, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        30, 1, 1, 31, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        32, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 33,\n+        1, 34, 34, 34, 34, 34, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        34, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 35, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 36, 1, 1, 0,\n+        0, 0, 0, 0, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 0, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 2, 3,\n+        3, 3, 3, 3, 3, 3, 3, 3,\n+        1, 1, 1, 1, 1, 1, 1, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 1, 1, 1, 1, 1, 1, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 4, 4, 4, 4, 4, 4, 4,\n+        4, 1, 28, 28, 28, 28, 28, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 28, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 29, 1, 1, 1,\n+        1, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 1, 1, 1, 30, 1,\n+        1, 31, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 32, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 33, 1, 38,\n+        38, 38, 38, 38, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 38, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 39, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 40, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 41, 1, 42, 42, 42, 42,\n+        42, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 42, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        43, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 44,\n+        1, 42, 42, 42, 42, 42, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        42, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        14, 14, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 43, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 44, 1, 38, 38,\n+        38, 38, 38, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 38, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 39, 1, 1, 1, 9, 9, 9,\n+        9, 9, 9, 9, 9, 9, 9, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 40, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 41, 1, 45, 45, 45, 45, 45,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 45, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 46, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 47, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 48,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 49, 1,\n+        50, 50, 50, 50, 50, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 50,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 51, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 52, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 53, 1, 50, 50, 50,\n+        50, 50, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 50, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 51,\n+        1, 1, 1, 1, 27, 27, 27, 27,\n+        27, 27, 27, 27, 27, 27, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 52, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        53, 1, 45, 45, 45, 45, 45, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 45, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 46, 1, 1, 1,\n+        1, 54, 54, 54, 54, 54, 54, 54,\n+        54, 54, 54, 1, 1, 1, 1, 1,\n+        1, 47, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 48, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 49, 1, 28,\n+        28, 28, 28, 28, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 28, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 29, 1, 55, 55, 1, 55, 55,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        1, 1, 1, 30, 1, 1, 31, 55,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        55, 1, 1, 32, 1, 55, 1, 55,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        55, 55, 55, 55, 55, 55, 55, 55,\n+        55, 1, 33, 1, 0\n+};\n+\n+static const char _deserialize_text_trans_targs[] = {\n+        1, 0, 13, 17, 26, 3, 18, 21,\n+        18, 21, 5, 19, 20, 19, 20, 22,\n+        25, 8, 9, 12, 9, 12, 10, 11,\n+        23, 24, 23, 24, 14, 2, 6, 7,\n+        15, 16, 14, 15, 16, 17, 14, 4,\n+        15, 16, 14, 15, 16, 14, 2, 7,\n+        15, 16, 14, 2, 15, 16, 25, 26\n+};\n+\n+static const char _deserialize_text_trans_actions[] = {\n+        0, 0, 1, 1, 1, 2, 2, 2,\n+        0, 0, 2, 2, 2, 0, 0, 2,\n+        2, 2, 2, 2, 0, 0, 3, 2,\n+        2, 2, 0, 0, 4, 5, 5, 5,\n+        4, 4, 0, 0, 0, 0, 6, 7,\n+        6, 6, 8, 8, 8, 9, 10, 10,\n+        9, 9, 11, 12, 11, 11, 0, 0\n+};\n+\n+static const char _deserialize_text_eof_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 4, 0, 0,\n+        0, 4, 6, 8, 8, 6, 9, 11,\n+        11, 9, 4\n+};\n+\n+static const int deserialize_text_start = 1;\n+static const int deserialize_text_first_final = 13;\n+static const int deserialize_text_error = 0;\n+\n+static const int deserialize_text_en_main = 1;\n+\n+\n+#line 91 \"hb-buffer-deserialize-text.rl\"\n+\n+\n+static hb_bool_t\n+_hb_buffer_deserialize_glyphs_text (hb_buffer_t *buffer,\n+                                    const char *buf,\n+                                    unsigned int buf_len,\n+                                    const char **end_ptr,\n+                                    hb_font_t *font)\n+{\n+  const char *p = buf, *pe = buf + buf_len;\n+\n+  \/* Ensure we have positions. *\/\n+  (void) hb_buffer_get_glyph_positions (buffer, nullptr);\n+\n+  while (p < pe && ISSPACE (*p))\n+    p++;\n+  if (p < pe && *p == (buffer->len ? '|' : '['))\n+  {\n+    *end_ptr = ++p;\n+  }\n+\n+  const char *eof = pe, *tok = nullptr;\n+  int cs;\n+  hb_glyph_info_t info = {0};\n+  hb_glyph_position_t pos = {0};\n+\n+#line 343 \"hb-buffer-deserialize-text.hh\"\n+        {\n+        cs = deserialize_text_start;\n+        }\n+\n+#line 348 \"hb-buffer-deserialize-text.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+        if ( cs == 0 )\n+                goto _out;\n+_resume:\n+        _keys = _deserialize_text_trans_keys + (cs<<1);\n+        _inds = _deserialize_text_indicies + _deserialize_text_index_offsets[cs];\n+\n+        _slen = _deserialize_text_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=(*p) &&\n+                (*p) <= _keys[1] ?\n+                (*p) - _keys[0] : _slen ];\n+\n+        cs = _deserialize_text_trans_targs[_trans];\n+\n+        if ( _deserialize_text_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _deserialize_text_trans_actions[_trans] ) {\n+        case 2:\n+#line 51 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 5:\n+#line 55 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+        break;\n+        case 10:\n+#line 62 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+        break;\n+        case 3:\n+#line 63 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_offset )) return false; }\n+        break;\n+        case 12:\n+#line 64 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+        break;\n+        case 7:\n+#line 65 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+        break;\n+        case 1:\n+#line 38 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        memset (&info, 0, sizeof (info));\n+        memset (&pos , 0, sizeof (pos ));\n+}\n+#line 51 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        tok = p;\n+}\n+        break;\n+        case 4:\n+#line 55 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 9:\n+#line 62 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n+#line 64 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 6:\n+#line 65 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 8:\n+#line 66 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 480 \"hb-buffer-deserialize-text.hh\"\n+        }\n+\n+_again:\n+        if ( cs == 0 )\n+                goto _out;\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        switch ( _deserialize_text_eof_actions[cs] ) {\n+        case 4:\n+#line 55 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        if (!hb_font_glyph_from_string (font,\n+                                        tok, p - tok,\n+                                        &info.codepoint))\n+          return false;\n+}\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 9:\n+#line 62 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_uint (tok, p, &info.cluster )) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 11:\n+#line 64 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_offset )) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 6:\n+#line 65 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.x_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+        case 8:\n+#line 66 \"hb-buffer-deserialize-text.rl\"\n+        { if (!parse_int  (tok, p, &pos.y_advance)) return false; }\n+#line 43 \"hb-buffer-deserialize-text.rl\"\n+        {\n+        buffer->add_info (info);\n+        if (unlikely (!buffer->successful))\n+          return false;\n+        buffer->pos[buffer->len - 1] = pos;\n+        *end_ptr = p;\n+}\n+        break;\n+#line 557 \"hb-buffer-deserialize-text.hh\"\n+        }\n+        }\n+\n+        _out: {}\n+        }\n+\n+#line 119 \"hb-buffer-deserialize-text.rl\"\n+\n+\n+  *end_ptr = p;\n+\n+  return p == pe && *(p-1) != ']';\n+}\n+\n+#endif \/* HB_BUFFER_DESERIALIZE_TEXT_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-buffer-deserialize-text.hh","additions":571,"deletions":0,"binary":false,"changes":571,"status":"added"},{"patch":"@@ -0,0 +1,486 @@\n+\/*\n+ * Copyright © 2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-buffer.hh\"\n+\n+\n+static const char *serialize_formats[] = {\n+  \"text\",\n+  \"json\",\n+  nullptr\n+};\n+\n+\/**\n+ * hb_buffer_serialize_list_formats:\n+ *\n+ * Returns a list of supported buffer serialization formats.\n+ *\n+ * Return value: (transfer none):\n+ * A string array of buffer serialization formats. Should not be freed.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+const char **\n+hb_buffer_serialize_list_formats ()\n+{\n+  return serialize_formats;\n+}\n+\n+\/**\n+ * hb_buffer_serialize_format_from_string:\n+ * @str: (array length=len) (element-type uint8_t): a string to parse\n+ * @len: length of @str, or -1 if string is %NULL terminated\n+ *\n+ * Parses a string into an #hb_buffer_serialize_format_t. Does not check if\n+ * @str is a valid buffer serialization format, use\n+ * hb_buffer_serialize_list_formats() to get the list of supported formats.\n+ *\n+ * Return value:\n+ * The parsed #hb_buffer_serialize_format_t.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_buffer_serialize_format_t\n+hb_buffer_serialize_format_from_string (const char *str, int len)\n+{\n+  \/* Upper-case it. *\/\n+  return (hb_buffer_serialize_format_t) (hb_tag_from_string (str, len) & ~0x20202020u);\n+}\n+\n+\/**\n+ * hb_buffer_serialize_format_to_string:\n+ * @format: an #hb_buffer_serialize_format_t to convert.\n+ *\n+ * Converts @format to the string corresponding it, or %NULL if it is not a valid\n+ * #hb_buffer_serialize_format_t.\n+ *\n+ * Return value: (transfer none):\n+ * A %NULL terminated string corresponding to @format. Should not be freed.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+const char *\n+hb_buffer_serialize_format_to_string (hb_buffer_serialize_format_t format)\n+{\n+  switch (format)\n+  {\n+    case HB_BUFFER_SERIALIZE_FORMAT_TEXT:       return serialize_formats[0];\n+    case HB_BUFFER_SERIALIZE_FORMAT_JSON:       return serialize_formats[1];\n+    default:\n+    case HB_BUFFER_SERIALIZE_FORMAT_INVALID:    return nullptr;\n+  }\n+}\n+\n+static unsigned int\n+_hb_buffer_serialize_glyphs_json (hb_buffer_t *buffer,\n+                                  unsigned int start,\n+                                  unsigned int end,\n+                                  char *buf,\n+                                  unsigned int buf_size,\n+                                  unsigned int *buf_consumed,\n+                                  hb_font_t *font,\n+                                  hb_buffer_serialize_flags_t flags)\n+{\n+  hb_glyph_info_t *info = hb_buffer_get_glyph_infos (buffer, nullptr);\n+  hb_glyph_position_t *pos = (flags & HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS) ?\n+                             nullptr : hb_buffer_get_glyph_positions (buffer, nullptr);\n+\n+  *buf_consumed = 0;\n+  hb_position_t x = 0, y = 0;\n+  for (unsigned int i = start; i < end; i++)\n+  {\n+    char b[1024];\n+    char *p = b;\n+\n+    \/* In the following code, we know b is large enough that no overflow can happen. *\/\n+\n+#define APPEND(s) HB_STMT_START { strcpy (p, s); p += strlen (s); } HB_STMT_END\n+\n+    if (i)\n+      *p++ = ',';\n+\n+    *p++ = '{';\n+\n+    APPEND (\"\\\"g\\\":\");\n+    if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES))\n+    {\n+      char g[128];\n+      hb_font_glyph_to_string (font, info[i].codepoint, g, sizeof (g));\n+      *p++ = '\"';\n+      for (char *q = g; *q; q++) {\n+        if (*q == '\"')\n+          *p++ = '\\\\';\n+        *p++ = *q;\n+      }\n+      *p++ = '\"';\n+    }\n+    else\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"%u\", info[i].codepoint));\n+\n+    if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS)) {\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"cl\\\":%u\", info[i].cluster));\n+    }\n+\n+    if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS))\n+    {\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"dx\\\":%d,\\\"dy\\\":%d\",\n+                             x+pos[i].x_offset, y+pos[i].y_offset));\n+      if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES))\n+        p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"ax\\\":%d,\\\"ay\\\":%d\",\n+                               pos[i].x_advance, pos[i].y_advance));\n+    }\n+\n+    if (flags & HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS)\n+    {\n+      if (info[i].mask & HB_GLYPH_FLAG_DEFINED)\n+        p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"fl\\\":%u\", info[i].mask & HB_GLYPH_FLAG_DEFINED));\n+    }\n+\n+    if (flags & HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS)\n+    {\n+      hb_glyph_extents_t extents;\n+      hb_font_get_glyph_extents(font, info[i].codepoint, &extents);\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"xb\\\":%d,\\\"yb\\\":%d\",\n+                extents.x_bearing, extents.y_bearing));\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",\\\"w\\\":%d,\\\"h\\\":%d\",\n+                extents.width, extents.height));\n+    }\n+\n+    *p++ = '}';\n+\n+    unsigned int l = p - b;\n+    if (buf_size > l)\n+    {\n+      memcpy (buf, b, l);\n+      buf += l;\n+      buf_size -= l;\n+      *buf_consumed += l;\n+      *buf = '\\0';\n+    } else\n+      return i - start;\n+\n+    if (pos && (flags & HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES))\n+    {\n+      x += pos[i].x_advance;\n+      y += pos[i].y_advance;\n+    }\n+  }\n+\n+  return end - start;\n+}\n+\n+static unsigned int\n+_hb_buffer_serialize_glyphs_text (hb_buffer_t *buffer,\n+                                  unsigned int start,\n+                                  unsigned int end,\n+                                  char *buf,\n+                                  unsigned int buf_size,\n+                                  unsigned int *buf_consumed,\n+                                  hb_font_t *font,\n+                                  hb_buffer_serialize_flags_t flags)\n+{\n+  hb_glyph_info_t *info = hb_buffer_get_glyph_infos (buffer, nullptr);\n+  hb_glyph_position_t *pos = (flags & HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS) ?\n+                             nullptr : hb_buffer_get_glyph_positions (buffer, nullptr);\n+\n+  *buf_consumed = 0;\n+  hb_position_t x = 0, y = 0;\n+  for (unsigned int i = start; i < end; i++)\n+  {\n+    char b[1024];\n+    char *p = b;\n+\n+    \/* In the following code, we know b is large enough that no overflow can happen. *\/\n+\n+    if (i)\n+      *p++ = '|';\n+\n+    if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES))\n+    {\n+      hb_font_glyph_to_string (font, info[i].codepoint, p, 128);\n+      p += strlen (p);\n+    }\n+    else\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"%u\", info[i].codepoint));\n+\n+    if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS)) {\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"=%u\", info[i].cluster));\n+    }\n+\n+    if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS))\n+    {\n+      if (x+pos[i].x_offset || y+pos[i].y_offset)\n+        p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"@%d,%d\", x+pos[i].x_offset, y+pos[i].y_offset));\n+\n+      if (!(flags & HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES))\n+      {\n+        *p++ = '+';\n+        p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"%d\", pos[i].x_advance));\n+        if (pos[i].y_advance)\n+          p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \",%d\", pos[i].y_advance));\n+      }\n+    }\n+\n+    if (flags & HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS)\n+    {\n+      if (info[i].mask & HB_GLYPH_FLAG_DEFINED)\n+        p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"#%X\", info[i].mask &HB_GLYPH_FLAG_DEFINED));\n+    }\n+\n+    if (flags & HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS)\n+    {\n+      hb_glyph_extents_t extents;\n+      hb_font_get_glyph_extents(font, info[i].codepoint, &extents);\n+      p += MAX (0, snprintf (p, ARRAY_LENGTH (b) - (p - b), \"<%d,%d,%d,%d>\", extents.x_bearing, extents.y_bearing, extents.width, extents.height));\n+    }\n+\n+    unsigned int l = p - b;\n+    if (buf_size > l)\n+    {\n+      memcpy (buf, b, l);\n+      buf += l;\n+      buf_size -= l;\n+      *buf_consumed += l;\n+      *buf = '\\0';\n+    } else\n+      return i - start;\n+\n+    if (pos && (flags & HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES))\n+    {\n+      x += pos[i].x_advance;\n+      y += pos[i].y_advance;\n+    }\n+  }\n+\n+  return end - start;\n+}\n+\n+\/**\n+ * hb_buffer_serialize_glyphs:\n+ * @buffer: an #hb_buffer_t buffer.\n+ * @start: the first item in @buffer to serialize.\n+ * @end: the last item in @buffer to serialize.\n+ * @buf: (out) (array length=buf_size) (element-type uint8_t): output string to\n+ *       write serialized buffer into.\n+ * @buf_size: the size of @buf.\n+ * @buf_consumed: (out) (allow-none): if not %NULL, will be set to the number of byes written into @buf.\n+ * @font: (allow-none): the #hb_font_t used to shape this buffer, needed to\n+ *        read glyph names and extents. If %NULL, and empty font will be used.\n+ * @format: the #hb_buffer_serialize_format_t to use for formatting the output.\n+ * @flags: the #hb_buffer_serialize_flags_t that control what glyph properties\n+ *         to serialize.\n+ *\n+ * Serializes @buffer into a textual representation of its glyph content,\n+ * useful for showing the contents of the buffer, for example during debugging.\n+ * There are currently two supported serialization formats:\n+ *\n+ * ## text\n+ * A human-readable, plain text format.\n+ * The serialized glyphs will look something like:\n+ *\n+ * ```\n+ * [uni0651=0@518,0+0|uni0628=0+1897]\n+ * ```\n+ * - The serialized glyphs are delimited with `[` and `]`.\n+ * - Glyphs are separated with `|`\n+ * - Each glyph starts with glyph name, or glyph index if\n+ *   #HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES flag is set. Then,\n+ *   - If #HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS is not set, `=` then #hb_glyph_info_t.cluster.\n+ *   - If #HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS is not set, the #hb_glyph_position_t in the format:\n+ *     - If both #hb_glyph_position_t.x_offset and #hb_glyph_position_t.y_offset are not 0, `@x_offset,y_offset`. Then,\n+ *     - `+x_advance`, then `,y_advance` if #hb_glyph_position_t.y_advance is not 0. Then,\n+ *   - If #HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS is set, the\n+ *     #hb_glyph_extents_t in the format\n+ *     `&lt;x_bearing,y_bearing,width,height&gt;`\n+ *\n+ * ## json\n+ * TODO.\n+ *\n+ * Return value:\n+ * The number of serialized items.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+unsigned int\n+hb_buffer_serialize_glyphs (hb_buffer_t *buffer,\n+                            unsigned int start,\n+                            unsigned int end,\n+                            char *buf,\n+                            unsigned int buf_size,\n+                            unsigned int *buf_consumed,\n+                            hb_font_t *font,\n+                            hb_buffer_serialize_format_t format,\n+                            hb_buffer_serialize_flags_t flags)\n+{\n+  assert (start <= end && end <= buffer->len);\n+\n+  unsigned int sconsumed;\n+  if (!buf_consumed)\n+    buf_consumed = &sconsumed;\n+  *buf_consumed = 0;\n+  if (buf_size)\n+    *buf = '\\0';\n+\n+  assert ((!buffer->len && buffer->content_type == HB_BUFFER_CONTENT_TYPE_INVALID) ||\n+          buffer->content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS);\n+\n+  if (!buffer->have_positions)\n+    flags |= HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS;\n+\n+  if (unlikely (start == end))\n+    return 0;\n+\n+  if (!font)\n+    font = hb_font_get_empty ();\n+\n+  switch (format)\n+  {\n+    case HB_BUFFER_SERIALIZE_FORMAT_TEXT:\n+      return _hb_buffer_serialize_glyphs_text (buffer, start, end,\n+                                               buf, buf_size, buf_consumed,\n+                                               font, flags);\n+\n+    case HB_BUFFER_SERIALIZE_FORMAT_JSON:\n+      return _hb_buffer_serialize_glyphs_json (buffer, start, end,\n+                                               buf, buf_size, buf_consumed,\n+                                               font, flags);\n+\n+    default:\n+    case HB_BUFFER_SERIALIZE_FORMAT_INVALID:\n+      return 0;\n+\n+  }\n+}\n+\n+\n+static hb_bool_t\n+parse_uint (const char *pp, const char *end, uint32_t *pv)\n+{\n+  char buf[32];\n+  unsigned int len = MIN (ARRAY_LENGTH (buf) - 1, (unsigned int) (end - pp));\n+  strncpy (buf, pp, len);\n+  buf[len] = '\\0';\n+\n+  char *p = buf;\n+  char *pend = p;\n+  uint32_t v;\n+\n+  errno = 0;\n+  v = strtol (p, &pend, 10);\n+  if (errno || p == pend || pend - p != end - pp)\n+    return false;\n+\n+  *pv = v;\n+  return true;\n+}\n+\n+static hb_bool_t\n+parse_int (const char *pp, const char *end, int32_t *pv)\n+{\n+  char buf[32];\n+  unsigned int len = MIN (ARRAY_LENGTH (buf) - 1, (unsigned int) (end - pp));\n+  strncpy (buf, pp, len);\n+  buf[len] = '\\0';\n+\n+  char *p = buf;\n+  char *pend = p;\n+  int32_t v;\n+\n+  errno = 0;\n+  v = strtol (p, &pend, 10);\n+  if (errno || p == pend || pend - p != end - pp)\n+    return false;\n+\n+  *pv = v;\n+  return true;\n+}\n+\n+#include \"hb-buffer-deserialize-json.hh\"\n+#include \"hb-buffer-deserialize-text.hh\"\n+\n+\/**\n+ * hb_buffer_deserialize_glyphs:\n+ * @buffer: an #hb_buffer_t buffer.\n+ * @buf: (array length=buf_len):\n+ * @buf_len:\n+ * @end_ptr: (out):\n+ * @font:\n+ * @format:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_buffer_deserialize_glyphs (hb_buffer_t *buffer,\n+                              const char *buf,\n+                              int buf_len, \/* -1 means nul-terminated *\/\n+                              const char **end_ptr, \/* May be NULL *\/\n+                              hb_font_t *font, \/* May be NULL *\/\n+                              hb_buffer_serialize_format_t format)\n+{\n+  const char *end;\n+  if (!end_ptr)\n+    end_ptr = &end;\n+  *end_ptr = buf;\n+\n+  assert ((!buffer->len && buffer->content_type == HB_BUFFER_CONTENT_TYPE_INVALID) ||\n+          buffer->content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS);\n+\n+  if (buf_len == -1)\n+    buf_len = strlen (buf);\n+\n+  if (!buf_len)\n+  {\n+    *end_ptr = buf;\n+    return false;\n+  }\n+\n+  hb_buffer_set_content_type (buffer, HB_BUFFER_CONTENT_TYPE_GLYPHS);\n+\n+  if (!font)\n+    font = hb_font_get_empty ();\n+\n+  switch (format)\n+  {\n+    case HB_BUFFER_SERIALIZE_FORMAT_TEXT:\n+      return _hb_buffer_deserialize_glyphs_text (buffer,\n+                                                 buf, buf_len, end_ptr,\n+                                                 font);\n+\n+    case HB_BUFFER_SERIALIZE_FORMAT_JSON:\n+      return _hb_buffer_deserialize_glyphs_json (buffer,\n+                                                 buf, buf_len, end_ptr,\n+                                                 font);\n+\n+    default:\n+    case HB_BUFFER_SERIALIZE_FORMAT_INVALID:\n+      return false;\n+\n+  }\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-buffer-serialize.cc","additions":486,"deletions":0,"binary":false,"changes":486,"status":"added"},{"patch":"@@ -0,0 +1,2032 @@\n+\/*\n+ * Copyright © 1998-2004  David Turner and Werner Lemberg\n+ * Copyright © 2004,2007,2009,2010  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-buffer.hh\"\n+#include \"hb-utf.hh\"\n+\n+\n+\/**\n+ * SECTION: hb-buffer\n+ * @title: hb-buffer\n+ * @short_description: Input and output buffers\n+ * @include: hb.h\n+ *\n+ * Buffers serve dual role in HarfBuzz; they hold the input characters that are\n+ * passed to hb_shape(), and after shaping they hold the output glyphs.\n+ **\/\n+\n+\n+\/**\n+ * hb_segment_properties_equal:\n+ * @a: first #hb_segment_properties_t to compare.\n+ * @b: second #hb_segment_properties_t to compare.\n+ *\n+ * Checks the equality of two #hb_segment_properties_t's.\n+ *\n+ * Return value:\n+ * %true if all properties of @a equal those of @b, false otherwise.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_segment_properties_equal (const hb_segment_properties_t *a,\n+                             const hb_segment_properties_t *b)\n+{\n+  return a->direction == b->direction &&\n+         a->script    == b->script    &&\n+         a->language  == b->language  &&\n+         a->reserved1 == b->reserved1 &&\n+         a->reserved2 == b->reserved2;\n+\n+}\n+\n+\/**\n+ * hb_segment_properties_hash:\n+ * @p: #hb_segment_properties_t to hash.\n+ *\n+ * Creates a hash representing @p.\n+ *\n+ * Return value:\n+ * A hash of @p.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+unsigned int\n+hb_segment_properties_hash (const hb_segment_properties_t *p)\n+{\n+  return (unsigned int) p->direction ^\n+         (unsigned int) p->script ^\n+         (intptr_t) (p->language);\n+}\n+\n+\n+\n+\/* Here is how the buffer works internally:\n+ *\n+ * There are two info pointers: info and out_info.  They always have\n+ * the same allocated size, but different lengths.\n+ *\n+ * As an optimization, both info and out_info may point to the\n+ * same piece of memory, which is owned by info.  This remains the\n+ * case as long as out_len doesn't exceed i at any time.\n+ * In that case, swap_buffers() is no-op and the glyph operations operate\n+ * mostly in-place.\n+ *\n+ * As soon as out_info gets longer than info, out_info is moved over\n+ * to an alternate buffer (which we reuse the pos buffer for!), and its\n+ * current contents (out_len entries) are copied to the new place.\n+ * This should all remain transparent to the user.  swap_buffers() then\n+ * switches info and out_info.\n+ *\/\n+\n+\n+\n+\/* Internal API *\/\n+\n+bool\n+hb_buffer_t::enlarge (unsigned int size)\n+{\n+  if (unlikely (!successful))\n+    return false;\n+  if (unlikely (size > max_len))\n+  {\n+    successful = false;\n+    return false;\n+  }\n+\n+  unsigned int new_allocated = allocated;\n+  hb_glyph_position_t *new_pos = nullptr;\n+  hb_glyph_info_t *new_info = nullptr;\n+  bool separate_out = out_info != info;\n+\n+  if (unlikely (hb_unsigned_mul_overflows (size, sizeof (info[0]))))\n+    goto done;\n+\n+  while (size >= new_allocated)\n+    new_allocated += (new_allocated >> 1) + 32;\n+\n+  static_assert ((sizeof (info[0]) == sizeof (pos[0])), \"\");\n+  if (unlikely (hb_unsigned_mul_overflows (new_allocated, sizeof (info[0]))))\n+    goto done;\n+\n+  new_pos = (hb_glyph_position_t *) realloc (pos, new_allocated * sizeof (pos[0]));\n+  new_info = (hb_glyph_info_t *) realloc (info, new_allocated * sizeof (info[0]));\n+\n+done:\n+  if (unlikely (!new_pos || !new_info))\n+    successful = false;\n+\n+  if (likely (new_pos))\n+    pos = new_pos;\n+\n+  if (likely (new_info))\n+    info = new_info;\n+\n+  out_info = separate_out ? (hb_glyph_info_t *) pos : info;\n+  if (likely (successful))\n+    allocated = new_allocated;\n+\n+  return likely (successful);\n+}\n+\n+bool\n+hb_buffer_t::make_room_for (unsigned int num_in,\n+                            unsigned int num_out)\n+{\n+  if (unlikely (!ensure (out_len + num_out))) return false;\n+\n+  if (out_info == info &&\n+      out_len + num_out > idx + num_in)\n+  {\n+    assert (have_output);\n+\n+    out_info = (hb_glyph_info_t *) pos;\n+    memcpy (out_info, info, out_len * sizeof (out_info[0]));\n+  }\n+\n+  return true;\n+}\n+\n+bool\n+hb_buffer_t::shift_forward (unsigned int count)\n+{\n+  assert (have_output);\n+  if (unlikely (!ensure (len + count))) return false;\n+\n+  memmove (info + idx + count, info + idx, (len - idx) * sizeof (info[0]));\n+  if (idx + count > len)\n+  {\n+    \/* Under memory failure we might expose this area.  At least\n+     * clean it up.  Oh well...\n+     *\n+     * Ideally, we should at least set Default_Ignorable bits on\n+     * these, as well as consistent cluster values.  But the former\n+     * is layering violation... *\/\n+    memset (info + len, 0, (idx + count - len) * sizeof (info[0]));\n+  }\n+  len += count;\n+  idx += count;\n+\n+  return true;\n+}\n+\n+hb_buffer_t::scratch_buffer_t *\n+hb_buffer_t::get_scratch_buffer (unsigned int *size)\n+{\n+  have_output = false;\n+  have_positions = false;\n+\n+  out_len = 0;\n+  out_info = info;\n+\n+  assert ((uintptr_t) pos % sizeof (scratch_buffer_t) == 0);\n+  *size = allocated * sizeof (pos[0]) \/ sizeof (scratch_buffer_t);\n+  return (scratch_buffer_t *) (void *) pos;\n+}\n+\n+\n+\n+\/* HarfBuzz-Internal API *\/\n+\n+void\n+hb_buffer_t::reset ()\n+{\n+  if (unlikely (hb_object_is_immutable (this)))\n+    return;\n+\n+  hb_unicode_funcs_destroy (unicode);\n+  unicode = hb_unicode_funcs_reference (hb_unicode_funcs_get_default ());\n+  flags = HB_BUFFER_FLAG_DEFAULT;\n+  replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;\n+  invisible = 0;\n+\n+  clear ();\n+}\n+\n+void\n+hb_buffer_t::clear ()\n+{\n+  if (unlikely (hb_object_is_immutable (this)))\n+    return;\n+\n+  hb_segment_properties_t default_props = HB_SEGMENT_PROPERTIES_DEFAULT;\n+  props = default_props;\n+  scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;\n+\n+  content_type = HB_BUFFER_CONTENT_TYPE_INVALID;\n+  successful = true;\n+  have_output = false;\n+  have_positions = false;\n+\n+  idx = 0;\n+  len = 0;\n+  out_len = 0;\n+  out_info = info;\n+\n+  serial = 0;\n+\n+  memset (context, 0, sizeof context);\n+  memset (context_len, 0, sizeof context_len);\n+\n+  deallocate_var_all ();\n+}\n+\n+void\n+hb_buffer_t::add (hb_codepoint_t  codepoint,\n+                  unsigned int    cluster)\n+{\n+  hb_glyph_info_t *glyph;\n+\n+  if (unlikely (!ensure (len + 1))) return;\n+\n+  glyph = &info[len];\n+\n+  memset (glyph, 0, sizeof (*glyph));\n+  glyph->codepoint = codepoint;\n+  glyph->mask = 0;\n+  glyph->cluster = cluster;\n+\n+  len++;\n+}\n+\n+void\n+hb_buffer_t::add_info (const hb_glyph_info_t &glyph_info)\n+{\n+  if (unlikely (!ensure (len + 1))) return;\n+\n+  info[len] = glyph_info;\n+\n+  len++;\n+}\n+\n+\n+void\n+hb_buffer_t::remove_output ()\n+{\n+  if (unlikely (hb_object_is_immutable (this)))\n+    return;\n+\n+  have_output = false;\n+  have_positions = false;\n+\n+  out_len = 0;\n+  out_info = info;\n+}\n+\n+void\n+hb_buffer_t::clear_output ()\n+{\n+  if (unlikely (hb_object_is_immutable (this)))\n+    return;\n+\n+  have_output = true;\n+  have_positions = false;\n+\n+  out_len = 0;\n+  out_info = info;\n+}\n+\n+void\n+hb_buffer_t::clear_positions ()\n+{\n+  if (unlikely (hb_object_is_immutable (this)))\n+    return;\n+\n+  have_output = false;\n+  have_positions = true;\n+\n+  out_len = 0;\n+  out_info = info;\n+\n+  memset (pos, 0, sizeof (pos[0]) * len);\n+}\n+\n+void\n+hb_buffer_t::swap_buffers ()\n+{\n+  if (unlikely (!successful)) return;\n+\n+  assert (have_output);\n+  have_output = false;\n+\n+  if (out_info != info)\n+  {\n+    hb_glyph_info_t *tmp_string;\n+    tmp_string = info;\n+    info = out_info;\n+    out_info = tmp_string;\n+    pos = (hb_glyph_position_t *) out_info;\n+  }\n+\n+  unsigned int tmp;\n+  tmp = len;\n+  len = out_len;\n+  out_len = tmp;\n+\n+  idx = 0;\n+}\n+\n+\n+void\n+hb_buffer_t::replace_glyphs (unsigned int num_in,\n+                             unsigned int num_out,\n+                             const uint32_t *glyph_data)\n+{\n+  if (unlikely (!make_room_for (num_in, num_out))) return;\n+\n+  assert (idx + num_in <= len);\n+\n+  merge_clusters (idx, idx + num_in);\n+\n+  hb_glyph_info_t orig_info = info[idx];\n+  hb_glyph_info_t *pinfo = &out_info[out_len];\n+  for (unsigned int i = 0; i < num_out; i++)\n+  {\n+    *pinfo = orig_info;\n+    pinfo->codepoint = glyph_data[i];\n+    pinfo++;\n+  }\n+\n+  idx  += num_in;\n+  out_len += num_out;\n+}\n+\n+bool\n+hb_buffer_t::move_to (unsigned int i)\n+{\n+  if (!have_output)\n+  {\n+    assert (i <= len);\n+    idx = i;\n+    return true;\n+  }\n+  if (unlikely (!successful))\n+    return false;\n+\n+  assert (i <= out_len + (len - idx));\n+\n+  if (out_len < i)\n+  {\n+    unsigned int count = i - out_len;\n+    if (unlikely (!make_room_for (count, count))) return false;\n+\n+    memmove (out_info + out_len, info + idx, count * sizeof (out_info[0]));\n+    idx += count;\n+    out_len += count;\n+  }\n+  else if (out_len > i)\n+  {\n+    \/* Tricky part: rewinding... *\/\n+    unsigned int count = out_len - i;\n+\n+    \/* This will blow in our face if memory allocation fails later\n+     * in this same lookup...\n+     *\n+     * We used to shift with extra 32 items, instead of the 0 below.\n+     * But that would leave empty slots in the buffer in case of allocation\n+     * failures.  Setting to zero for now to avoid other problems (see\n+     * comments in shift_forward().  This can cause O(N^2) behavior more\n+     * severely than adding 32 empty slots can... *\/\n+    if (unlikely (idx < count && !shift_forward (count + 0))) return false;\n+\n+    assert (idx >= count);\n+\n+    idx -= count;\n+    out_len -= count;\n+    memmove (info + idx, out_info + out_len, count * sizeof (out_info[0]));\n+  }\n+\n+  return true;\n+}\n+\n+\n+void\n+hb_buffer_t::set_masks (hb_mask_t    value,\n+                        hb_mask_t    mask,\n+                        unsigned int cluster_start,\n+                        unsigned int cluster_end)\n+{\n+  hb_mask_t not_mask = ~mask;\n+  value &= mask;\n+\n+  if (!mask)\n+    return;\n+\n+  if (cluster_start == 0 && cluster_end == (unsigned int)-1) {\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+      info[i].mask = (info[i].mask & not_mask) | value;\n+    return;\n+  }\n+\n+  unsigned int count = len;\n+  for (unsigned int i = 0; i < count; i++)\n+    if (cluster_start <= info[i].cluster && info[i].cluster < cluster_end)\n+      info[i].mask = (info[i].mask & not_mask) | value;\n+}\n+\n+void\n+hb_buffer_t::reverse_range (unsigned int start,\n+                            unsigned int end)\n+{\n+  unsigned int i, j;\n+\n+  if (end - start < 2)\n+    return;\n+\n+  for (i = start, j = end - 1; i < j; i++, j--) {\n+    hb_glyph_info_t t;\n+\n+    t = info[i];\n+    info[i] = info[j];\n+    info[j] = t;\n+  }\n+\n+  if (have_positions) {\n+    for (i = start, j = end - 1; i < j; i++, j--) {\n+      hb_glyph_position_t t;\n+\n+      t = pos[i];\n+      pos[i] = pos[j];\n+      pos[j] = t;\n+    }\n+  }\n+}\n+\n+void\n+hb_buffer_t::reverse ()\n+{\n+  if (unlikely (!len))\n+    return;\n+\n+  reverse_range (0, len);\n+}\n+\n+void\n+hb_buffer_t::reverse_clusters ()\n+{\n+  unsigned int i, start, count, last_cluster;\n+\n+  if (unlikely (!len))\n+    return;\n+\n+  reverse ();\n+\n+  count = len;\n+  start = 0;\n+  last_cluster = info[0].cluster;\n+  for (i = 1; i < count; i++) {\n+    if (last_cluster != info[i].cluster) {\n+      reverse_range (start, i);\n+      start = i;\n+      last_cluster = info[i].cluster;\n+    }\n+  }\n+  reverse_range (start, i);\n+}\n+\n+void\n+hb_buffer_t::merge_clusters_impl (unsigned int start,\n+                                  unsigned int end)\n+{\n+  if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS)\n+  {\n+    unsafe_to_break (start, end);\n+    return;\n+  }\n+\n+  unsigned int cluster = info[start].cluster;\n+\n+  for (unsigned int i = start + 1; i < end; i++)\n+    cluster = MIN<unsigned int> (cluster, info[i].cluster);\n+\n+  \/* Extend end *\/\n+  while (end < len && info[end - 1].cluster == info[end].cluster)\n+    end++;\n+\n+  \/* Extend start *\/\n+  while (idx < start && info[start - 1].cluster == info[start].cluster)\n+    start--;\n+\n+  \/* If we hit the start of buffer, continue in out-buffer. *\/\n+  if (idx == start)\n+    for (unsigned int i = out_len; i && out_info[i - 1].cluster == info[start].cluster; i--)\n+      set_cluster (out_info[i - 1], cluster);\n+\n+  for (unsigned int i = start; i < end; i++)\n+    set_cluster (info[i], cluster);\n+}\n+void\n+hb_buffer_t::merge_out_clusters (unsigned int start,\n+                                 unsigned int end)\n+{\n+  if (cluster_level == HB_BUFFER_CLUSTER_LEVEL_CHARACTERS)\n+    return;\n+\n+  if (unlikely (end - start < 2))\n+    return;\n+\n+  unsigned int cluster = out_info[start].cluster;\n+\n+  for (unsigned int i = start + 1; i < end; i++)\n+    cluster = MIN<unsigned int> (cluster, out_info[i].cluster);\n+\n+  \/* Extend start *\/\n+  while (start && out_info[start - 1].cluster == out_info[start].cluster)\n+    start--;\n+\n+  \/* Extend end *\/\n+  while (end < out_len && out_info[end - 1].cluster == out_info[end].cluster)\n+    end++;\n+\n+  \/* If we hit the end of out-buffer, continue in buffer. *\/\n+  if (end == out_len)\n+    for (unsigned int i = idx; i < len && info[i].cluster == out_info[end - 1].cluster; i++)\n+      set_cluster (info[i], cluster);\n+\n+  for (unsigned int i = start; i < end; i++)\n+    set_cluster (out_info[i], cluster);\n+}\n+void\n+hb_buffer_t::delete_glyph ()\n+{\n+  \/* The logic here is duplicated in hb_ot_hide_default_ignorables(). *\/\n+\n+  unsigned int cluster = info[idx].cluster;\n+  if (idx + 1 < len && cluster == info[idx + 1].cluster)\n+  {\n+    \/* Cluster survives; do nothing. *\/\n+    goto done;\n+  }\n+\n+  if (out_len)\n+  {\n+    \/* Merge cluster backward. *\/\n+    if (cluster < out_info[out_len - 1].cluster)\n+    {\n+      unsigned int mask = info[idx].mask;\n+      unsigned int old_cluster = out_info[out_len - 1].cluster;\n+      for (unsigned i = out_len; i && out_info[i - 1].cluster == old_cluster; i--)\n+        set_cluster (out_info[i - 1], cluster, mask);\n+    }\n+    goto done;\n+  }\n+\n+  if (idx + 1 < len)\n+  {\n+    \/* Merge cluster forward. *\/\n+    merge_clusters (idx, idx + 2);\n+    goto done;\n+  }\n+\n+done:\n+  skip_glyph ();\n+}\n+\n+void\n+hb_buffer_t::unsafe_to_break_impl (unsigned int start, unsigned int end)\n+{\n+  unsigned int cluster = (unsigned int) -1;\n+  cluster = _unsafe_to_break_find_min_cluster (info, start, end, cluster);\n+  _unsafe_to_break_set_mask (info, start, end, cluster);\n+}\n+void\n+hb_buffer_t::unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end)\n+{\n+  if (!have_output)\n+  {\n+    unsafe_to_break_impl (start, end);\n+    return;\n+  }\n+\n+  assert (start <= out_len);\n+  assert (idx <= end);\n+\n+  unsigned int cluster = (unsigned int) -1;\n+  cluster = _unsafe_to_break_find_min_cluster (out_info, start, out_len, cluster);\n+  cluster = _unsafe_to_break_find_min_cluster (info, idx, end, cluster);\n+  _unsafe_to_break_set_mask (out_info, start, out_len, cluster);\n+  _unsafe_to_break_set_mask (info, idx, end, cluster);\n+}\n+\n+void\n+hb_buffer_t::guess_segment_properties ()\n+{\n+  assert (content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||\n+          (!len && content_type == HB_BUFFER_CONTENT_TYPE_INVALID));\n+\n+  \/* If script is set to INVALID, guess from buffer contents *\/\n+  if (props.script == HB_SCRIPT_INVALID) {\n+    for (unsigned int i = 0; i < len; i++) {\n+      hb_script_t script = unicode->script (info[i].codepoint);\n+      if (likely (script != HB_SCRIPT_COMMON &&\n+                  script != HB_SCRIPT_INHERITED &&\n+                  script != HB_SCRIPT_UNKNOWN)) {\n+        props.script = script;\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/* If direction is set to INVALID, guess from script *\/\n+  if (props.direction == HB_DIRECTION_INVALID) {\n+    props.direction = hb_script_get_horizontal_direction (props.script);\n+    if (props.direction == HB_DIRECTION_INVALID)\n+      props.direction = HB_DIRECTION_LTR;\n+  }\n+\n+  \/* If language is not set, use default language from locale *\/\n+  if (props.language == HB_LANGUAGE_INVALID) {\n+    \/* TODO get_default_for_script? using $LANGUAGE *\/\n+    props.language = hb_language_get_default ();\n+  }\n+}\n+\n+\n+\/* Public API *\/\n+\n+DEFINE_NULL_INSTANCE (hb_buffer_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  const_cast<hb_unicode_funcs_t *> (&_hb_Null_hb_unicode_funcs_t),\n+  HB_BUFFER_FLAG_DEFAULT,\n+  HB_BUFFER_CLUSTER_LEVEL_DEFAULT,\n+  HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT,\n+  0, \/* invisible *\/\n+  HB_BUFFER_SCRATCH_FLAG_DEFAULT,\n+  HB_BUFFER_MAX_LEN_DEFAULT,\n+  HB_BUFFER_MAX_OPS_DEFAULT,\n+\n+  HB_BUFFER_CONTENT_TYPE_INVALID,\n+  HB_SEGMENT_PROPERTIES_DEFAULT,\n+  false, \/* successful *\/\n+  true, \/* have_output *\/\n+  true  \/* have_positions *\/\n+\n+  \/* Zero is good enough for everything else. *\/\n+};\n+\n+\n+\/**\n+ * hb_buffer_create: (Xconstructor)\n+ *\n+ * Creates a new #hb_buffer_t with all properties to defaults.\n+ *\n+ * Return value: (transfer full):\n+ * A newly allocated #hb_buffer_t with a reference count of 1. The initial\n+ * reference count should be released with hb_buffer_destroy() when you are done\n+ * using the #hb_buffer_t. This function never returns %NULL. If memory cannot\n+ * be allocated, a special #hb_buffer_t object will be returned on which\n+ * hb_buffer_allocation_successful() returns %false.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_buffer_t *\n+hb_buffer_create ()\n+{\n+  hb_buffer_t *buffer;\n+\n+  if (!(buffer = hb_object_create<hb_buffer_t> ()))\n+    return hb_buffer_get_empty ();\n+\n+  buffer->max_len = HB_BUFFER_MAX_LEN_DEFAULT;\n+  buffer->max_ops = HB_BUFFER_MAX_OPS_DEFAULT;\n+\n+  buffer->reset ();\n+\n+  return buffer;\n+}\n+\n+\/**\n+ * hb_buffer_get_empty:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_buffer_t *\n+hb_buffer_get_empty ()\n+{\n+  return const_cast<hb_buffer_t *> (&Null(hb_buffer_t));\n+}\n+\n+\/**\n+ * hb_buffer_reference: (skip)\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Increases the reference count on @buffer by one. This prevents @buffer from\n+ * being destroyed until a matching call to hb_buffer_destroy() is made.\n+ *\n+ * Return value: (transfer full):\n+ * The referenced #hb_buffer_t.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_buffer_t *\n+hb_buffer_reference (hb_buffer_t *buffer)\n+{\n+  return hb_object_reference (buffer);\n+}\n+\n+\/**\n+ * hb_buffer_destroy: (skip)\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Deallocate the @buffer.\n+ * Decreases the reference count on @buffer by one. If the result is zero, then\n+ * @buffer and all associated resources are freed. See hb_buffer_reference().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_destroy (hb_buffer_t *buffer)\n+{\n+  if (!hb_object_destroy (buffer)) return;\n+\n+  hb_unicode_funcs_destroy (buffer->unicode);\n+\n+  free (buffer->info);\n+  free (buffer->pos);\n+  if (buffer->message_destroy)\n+    buffer->message_destroy (buffer->message_data);\n+\n+  free (buffer);\n+}\n+\n+\/**\n+ * hb_buffer_set_user_data: (skip)\n+ * @buffer: an #hb_buffer_t.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_buffer_set_user_data (hb_buffer_t        *buffer,\n+                         hb_user_data_key_t *key,\n+                         void *              data,\n+                         hb_destroy_func_t   destroy,\n+                         hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (buffer, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_buffer_get_user_data: (skip)\n+ * @buffer: an #hb_buffer_t.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void *\n+hb_buffer_get_user_data (hb_buffer_t        *buffer,\n+                         hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (buffer, key);\n+}\n+\n+\n+\/**\n+ * hb_buffer_set_content_type:\n+ * @buffer: an #hb_buffer_t.\n+ * @content_type: the type of buffer contents to set\n+ *\n+ * Sets the type of @buffer contents, buffers are either empty, contain\n+ * characters (before shaping) or glyphs (the result of shaping).\n+ *\n+ * Since: 0.9.5\n+ **\/\n+void\n+hb_buffer_set_content_type (hb_buffer_t              *buffer,\n+                            hb_buffer_content_type_t  content_type)\n+{\n+  buffer->content_type = content_type;\n+}\n+\n+\/**\n+ * hb_buffer_get_content_type:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * see hb_buffer_set_content_type().\n+ *\n+ * Return value:\n+ * The type of @buffer contents.\n+ *\n+ * Since: 0.9.5\n+ **\/\n+hb_buffer_content_type_t\n+hb_buffer_get_content_type (hb_buffer_t *buffer)\n+{\n+  return buffer->content_type;\n+}\n+\n+\n+\/**\n+ * hb_buffer_set_unicode_funcs:\n+ * @buffer: an #hb_buffer_t.\n+ * @unicode_funcs:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,\n+                             hb_unicode_funcs_t *unicode_funcs)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  if (!unicode_funcs)\n+    unicode_funcs = hb_unicode_funcs_get_default ();\n+\n+  hb_unicode_funcs_reference (unicode_funcs);\n+  hb_unicode_funcs_destroy (buffer->unicode);\n+  buffer->unicode = unicode_funcs;\n+}\n+\n+\/**\n+ * hb_buffer_get_unicode_funcs:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_unicode_funcs_t *\n+hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer)\n+{\n+  return buffer->unicode;\n+}\n+\n+\/**\n+ * hb_buffer_set_direction:\n+ * @buffer: an #hb_buffer_t.\n+ * @direction: the #hb_direction_t of the @buffer\n+ *\n+ * Set the text flow direction of the buffer. No shaping can happen without\n+ * setting @buffer direction, and it controls the visual direction for the\n+ * output glyphs; for RTL direction the glyphs will be reversed. Many layout\n+ * features depend on the proper setting of the direction, for example,\n+ * reversing RTL text before shaping, then shaping with LTR direction is not\n+ * the same as keeping the text in logical order and shaping with RTL\n+ * direction.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_set_direction (hb_buffer_t    *buffer,\n+                         hb_direction_t  direction)\n+\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->props.direction = direction;\n+}\n+\n+\/**\n+ * hb_buffer_get_direction:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * See hb_buffer_set_direction()\n+ *\n+ * Return value:\n+ * The direction of the @buffer.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_direction_t\n+hb_buffer_get_direction (hb_buffer_t    *buffer)\n+{\n+  return buffer->props.direction;\n+}\n+\n+\/**\n+ * hb_buffer_set_script:\n+ * @buffer: an #hb_buffer_t.\n+ * @script: an #hb_script_t to set.\n+ *\n+ * Sets the script of @buffer to @script.\n+ *\n+ * Script is crucial for choosing the proper shaping behaviour for scripts that\n+ * require it (e.g. Arabic) and the which OpenType features defined in the font\n+ * to be applied.\n+ *\n+ * You can pass one of the predefined #hb_script_t values, or use\n+ * hb_script_from_string() or hb_script_from_iso15924_tag() to get the\n+ * corresponding script from an ISO 15924 script tag.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_set_script (hb_buffer_t *buffer,\n+                      hb_script_t  script)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->props.script = script;\n+}\n+\n+\/**\n+ * hb_buffer_get_script:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * See hb_buffer_set_script().\n+ *\n+ * Return value:\n+ * The #hb_script_t of the @buffer.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_script_t\n+hb_buffer_get_script (hb_buffer_t *buffer)\n+{\n+  return buffer->props.script;\n+}\n+\n+\/**\n+ * hb_buffer_set_language:\n+ * @buffer: an #hb_buffer_t.\n+ * @language: an hb_language_t to set.\n+ *\n+ * Sets the language of @buffer to @language.\n+ *\n+ * Languages are crucial for selecting which OpenType feature to apply to the\n+ * buffer which can result in applying language-specific behaviour. Languages\n+ * are orthogonal to the scripts, and though they are related, they are\n+ * different concepts and should not be confused with each other.\n+ *\n+ * Use hb_language_from_string() to convert from BCP 47 language tags to\n+ * #hb_language_t.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_set_language (hb_buffer_t   *buffer,\n+                        hb_language_t  language)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->props.language = language;\n+}\n+\n+\/**\n+ * hb_buffer_get_language:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * See hb_buffer_set_language().\n+ *\n+ * Return value: (transfer none):\n+ * The #hb_language_t of the buffer. Must not be freed by the caller.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_language_t\n+hb_buffer_get_language (hb_buffer_t *buffer)\n+{\n+  return buffer->props.language;\n+}\n+\n+\/**\n+ * hb_buffer_set_segment_properties:\n+ * @buffer: an #hb_buffer_t.\n+ * @props: an #hb_segment_properties_t to use.\n+ *\n+ * Sets the segment properties of the buffer, a shortcut for calling\n+ * hb_buffer_set_direction(), hb_buffer_set_script() and\n+ * hb_buffer_set_language() individually.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_buffer_set_segment_properties (hb_buffer_t *buffer,\n+                                  const hb_segment_properties_t *props)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->props = *props;\n+}\n+\n+\/**\n+ * hb_buffer_get_segment_properties:\n+ * @buffer: an #hb_buffer_t.\n+ * @props: (out): the output #hb_segment_properties_t.\n+ *\n+ * Sets @props to the #hb_segment_properties_t of @buffer.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_buffer_get_segment_properties (hb_buffer_t *buffer,\n+                                  hb_segment_properties_t *props)\n+{\n+  *props = buffer->props;\n+}\n+\n+\n+\/**\n+ * hb_buffer_set_flags:\n+ * @buffer: an #hb_buffer_t.\n+ * @flags: the buffer flags to set.\n+ *\n+ * Sets @buffer flags to @flags. See #hb_buffer_flags_t.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_buffer_set_flags (hb_buffer_t       *buffer,\n+                     hb_buffer_flags_t  flags)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->flags = flags;\n+}\n+\n+\/**\n+ * hb_buffer_get_flags:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * See hb_buffer_set_flags().\n+ *\n+ * Return value:\n+ * The @buffer flags.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_buffer_flags_t\n+hb_buffer_get_flags (hb_buffer_t *buffer)\n+{\n+  return buffer->flags;\n+}\n+\n+\/**\n+ * hb_buffer_set_cluster_level:\n+ * @buffer: an #hb_buffer_t.\n+ * @cluster_level:\n+ *\n+ *\n+ *\n+ * Since: 0.9.42\n+ **\/\n+void\n+hb_buffer_set_cluster_level (hb_buffer_t       *buffer,\n+                     hb_buffer_cluster_level_t  cluster_level)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->cluster_level = cluster_level;\n+}\n+\n+\/**\n+ * hb_buffer_get_cluster_level:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.42\n+ **\/\n+hb_buffer_cluster_level_t\n+hb_buffer_get_cluster_level (hb_buffer_t *buffer)\n+{\n+  return buffer->cluster_level;\n+}\n+\n+\n+\/**\n+ * hb_buffer_set_replacement_codepoint:\n+ * @buffer: an #hb_buffer_t.\n+ * @replacement: the replacement #hb_codepoint_t\n+ *\n+ * Sets the #hb_codepoint_t that replaces invalid entries for a given encoding\n+ * when adding text to @buffer.\n+ *\n+ * Default is %HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT.\n+ *\n+ * Since: 0.9.31\n+ **\/\n+void\n+hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,\n+                                     hb_codepoint_t  replacement)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->replacement = replacement;\n+}\n+\n+\/**\n+ * hb_buffer_get_replacement_codepoint:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * See hb_buffer_set_replacement_codepoint().\n+ *\n+ * Return value:\n+ * The @buffer replacement #hb_codepoint_t.\n+ *\n+ * Since: 0.9.31\n+ **\/\n+hb_codepoint_t\n+hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer)\n+{\n+  return buffer->replacement;\n+}\n+\n+\n+\/**\n+ * hb_buffer_set_invisible_glyph:\n+ * @buffer: an #hb_buffer_t.\n+ * @invisible: the invisible #hb_codepoint_t\n+ *\n+ * Sets the #hb_codepoint_t that replaces invisible characters in\n+ * the shaping result.  If set to zero (default), the glyph for the\n+ * U+0020 SPACE character is used.  Otherwise, this value is used\n+ * verbatim.\n+ *\n+ * Since: 2.0.0\n+ **\/\n+void\n+hb_buffer_set_invisible_glyph (hb_buffer_t    *buffer,\n+                               hb_codepoint_t  invisible)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  buffer->invisible = invisible;\n+}\n+\n+\/**\n+ * hb_buffer_get_invisible_glyph:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * See hb_buffer_set_invisible_glyph().\n+ *\n+ * Return value:\n+ * The @buffer invisible #hb_codepoint_t.\n+ *\n+ * Since: 2.0.0\n+ **\/\n+hb_codepoint_t\n+hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer)\n+{\n+  return buffer->invisible;\n+}\n+\n+\n+\/**\n+ * hb_buffer_reset:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Resets the buffer to its initial status, as if it was just newly created\n+ * with hb_buffer_create().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_reset (hb_buffer_t *buffer)\n+{\n+  buffer->reset ();\n+}\n+\n+\/**\n+ * hb_buffer_clear_contents:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Similar to hb_buffer_reset(), but does not clear the Unicode functions and\n+ * the replacement code point.\n+ *\n+ * Since: 0.9.11\n+ **\/\n+void\n+hb_buffer_clear_contents (hb_buffer_t *buffer)\n+{\n+  buffer->clear ();\n+}\n+\n+\/**\n+ * hb_buffer_pre_allocate:\n+ * @buffer: an #hb_buffer_t.\n+ * @size: number of items to pre allocate.\n+ *\n+ * Pre allocates memory for @buffer to fit at least @size number of items.\n+ *\n+ * Return value:\n+ * %true if @buffer memory allocation succeeded, %false otherwise.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_buffer_pre_allocate (hb_buffer_t *buffer, unsigned int size)\n+{\n+  return buffer->ensure (size);\n+}\n+\n+\/**\n+ * hb_buffer_allocation_successful:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Check if allocating memory for the buffer succeeded.\n+ *\n+ * Return value:\n+ * %true if @buffer memory allocation succeeded, %false otherwise.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_buffer_allocation_successful (hb_buffer_t  *buffer)\n+{\n+  return buffer->successful;\n+}\n+\n+\/**\n+ * hb_buffer_add:\n+ * @buffer: an #hb_buffer_t.\n+ * @codepoint: a Unicode code point.\n+ * @cluster: the cluster value of @codepoint.\n+ *\n+ * Appends a character with the Unicode value of @codepoint to @buffer, and\n+ * gives it the initial cluster value of @cluster. Clusters can be any thing\n+ * the client wants, they are usually used to refer to the index of the\n+ * character in the input text stream and are output in\n+ * #hb_glyph_info_t.cluster field.\n+ *\n+ * This function does not check the validity of @codepoint, it is up to the\n+ * caller to ensure it is a valid Unicode code point.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_buffer_add (hb_buffer_t    *buffer,\n+               hb_codepoint_t  codepoint,\n+               unsigned int    cluster)\n+{\n+  buffer->add (codepoint, cluster);\n+  buffer->clear_context (1);\n+}\n+\n+\/**\n+ * hb_buffer_set_length:\n+ * @buffer: an #hb_buffer_t.\n+ * @length: the new length of @buffer.\n+ *\n+ * Similar to hb_buffer_pre_allocate(), but clears any new items added at the\n+ * end.\n+ *\n+ * Return value:\n+ * %true if @buffer memory allocation succeeded, %false otherwise.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_buffer_set_length (hb_buffer_t  *buffer,\n+                      unsigned int  length)\n+{\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return length == 0;\n+\n+  if (!buffer->ensure (length))\n+    return false;\n+\n+  \/* Wipe the new space *\/\n+  if (length > buffer->len) {\n+    memset (buffer->info + buffer->len, 0, sizeof (buffer->info[0]) * (length - buffer->len));\n+    if (buffer->have_positions)\n+      memset (buffer->pos + buffer->len, 0, sizeof (buffer->pos[0]) * (length - buffer->len));\n+  }\n+\n+  buffer->len = length;\n+\n+  if (!length)\n+  {\n+    buffer->content_type = HB_BUFFER_CONTENT_TYPE_INVALID;\n+    buffer->clear_context (0);\n+  }\n+  buffer->clear_context (1);\n+\n+  return true;\n+}\n+\n+\/**\n+ * hb_buffer_get_length:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Returns the number of items in the buffer.\n+ *\n+ * Return value:\n+ * The @buffer length.\n+ * The value valid as long as buffer has not been modified.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+unsigned int\n+hb_buffer_get_length (hb_buffer_t *buffer)\n+{\n+  return buffer->len;\n+}\n+\n+\/**\n+ * hb_buffer_get_glyph_infos:\n+ * @buffer: an #hb_buffer_t.\n+ * @length: (out): output array length.\n+ *\n+ * Returns @buffer glyph information array.  Returned pointer\n+ * is valid as long as @buffer contents are not modified.\n+ *\n+ * Return value: (transfer none) (array length=length):\n+ * The @buffer glyph information array.\n+ * The value valid as long as buffer has not been modified.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_glyph_info_t *\n+hb_buffer_get_glyph_infos (hb_buffer_t  *buffer,\n+                           unsigned int *length)\n+{\n+  if (length)\n+    *length = buffer->len;\n+\n+  return (hb_glyph_info_t *) buffer->info;\n+}\n+\n+\/**\n+ * hb_buffer_get_glyph_positions:\n+ * @buffer: an #hb_buffer_t.\n+ * @length: (out): output length.\n+ *\n+ * Returns @buffer glyph position array.  Returned pointer\n+ * is valid as long as @buffer contents are not modified.\n+ *\n+ * Return value: (transfer none) (array length=length):\n+ * The @buffer glyph position array.\n+ * The value valid as long as buffer has not been modified.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_glyph_position_t *\n+hb_buffer_get_glyph_positions (hb_buffer_t  *buffer,\n+                               unsigned int *length)\n+{\n+  if (!buffer->have_positions)\n+    buffer->clear_positions ();\n+\n+  if (length)\n+    *length = buffer->len;\n+\n+  return (hb_glyph_position_t *) buffer->pos;\n+}\n+\n+\/**\n+ * hb_glyph_info_get_glyph_flags:\n+ * @info: a #hb_glyph_info_t.\n+ *\n+ * Returns glyph flags encoded within a #hb_glyph_info_t.\n+ *\n+ * Return value:\n+ * The #hb_glyph_flags_t encoded within @info.\n+ *\n+ * Since: 1.5.0\n+ **\/\n+hb_glyph_flags_t\n+(hb_glyph_info_get_glyph_flags) (const hb_glyph_info_t *info)\n+{\n+  return hb_glyph_info_get_glyph_flags (info);\n+}\n+\n+\/**\n+ * hb_buffer_reverse:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Reverses buffer contents.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_reverse (hb_buffer_t *buffer)\n+{\n+  buffer->reverse ();\n+}\n+\n+\/**\n+ * hb_buffer_reverse_range:\n+ * @buffer: an #hb_buffer_t.\n+ * @start: start index.\n+ * @end: end index.\n+ *\n+ * Reverses buffer contents between start to end.\n+ *\n+ * Since: 0.9.41\n+ **\/\n+void\n+hb_buffer_reverse_range (hb_buffer_t *buffer,\n+                         unsigned int start, unsigned int end)\n+{\n+  buffer->reverse_range (start, end);\n+}\n+\n+\/**\n+ * hb_buffer_reverse_clusters:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Reverses buffer clusters.  That is, the buffer contents are\n+ * reversed, then each cluster (consecutive items having the\n+ * same cluster number) are reversed again.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_reverse_clusters (hb_buffer_t *buffer)\n+{\n+  buffer->reverse_clusters ();\n+}\n+\n+\/**\n+ * hb_buffer_guess_segment_properties:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Sets unset buffer segment properties based on buffer Unicode\n+ * contents.  If buffer is not empty, it must have content type\n+ * %HB_BUFFER_CONTENT_TYPE_UNICODE.\n+ *\n+ * If buffer script is not set (ie. is %HB_SCRIPT_INVALID), it\n+ * will be set to the Unicode script of the first character in\n+ * the buffer that has a script other than %HB_SCRIPT_COMMON,\n+ * %HB_SCRIPT_INHERITED, and %HB_SCRIPT_UNKNOWN.\n+ *\n+ * Next, if buffer direction is not set (ie. is %HB_DIRECTION_INVALID),\n+ * it will be set to the natural horizontal direction of the\n+ * buffer script as returned by hb_script_get_horizontal_direction().\n+ * If hb_script_get_horizontal_direction() returns %HB_DIRECTION_INVALID,\n+ * then %HB_DIRECTION_LTR is used.\n+ *\n+ * Finally, if buffer language is not set (ie. is %HB_LANGUAGE_INVALID),\n+ * it will be set to the process's default language as returned by\n+ * hb_language_get_default().  This may change in the future by\n+ * taking buffer script into consideration when choosing a language.\n+ * Note that hb_language_get_default() is NOT threadsafe the first time\n+ * it is called.  See documentation for that function for details.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_buffer_guess_segment_properties (hb_buffer_t *buffer)\n+{\n+  buffer->guess_segment_properties ();\n+}\n+\n+template <typename utf_t>\n+static inline void\n+hb_buffer_add_utf (hb_buffer_t  *buffer,\n+                   const typename utf_t::codepoint_t *text,\n+                   int           text_length,\n+                   unsigned int  item_offset,\n+                   int           item_length)\n+{\n+  typedef typename utf_t::codepoint_t T;\n+  const hb_codepoint_t replacement = buffer->replacement;\n+\n+  assert (buffer->content_type == HB_BUFFER_CONTENT_TYPE_UNICODE ||\n+          (!buffer->len && buffer->content_type == HB_BUFFER_CONTENT_TYPE_INVALID));\n+\n+  if (unlikely (hb_object_is_immutable (buffer)))\n+    return;\n+\n+  if (text_length == -1)\n+    text_length = utf_t::strlen (text);\n+\n+  if (item_length == -1)\n+    item_length = text_length - item_offset;\n+\n+  buffer->ensure (buffer->len + item_length * sizeof (T) \/ 4);\n+\n+  \/* If buffer is empty and pre-context provided, install it.\n+   * This check is written this way, to make sure people can\n+   * provide pre-context in one add_utf() call, then provide\n+   * text in a follow-up call.  See:\n+   *\n+   * https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=801410#c13\n+   *\/\n+  if (!buffer->len && item_offset > 0)\n+  {\n+    \/* Add pre-context *\/\n+    buffer->clear_context (0);\n+    const T *prev = text + item_offset;\n+    const T *start = text;\n+    while (start < prev && buffer->context_len[0] < buffer->CONTEXT_LENGTH)\n+    {\n+      hb_codepoint_t u;\n+      prev = utf_t::prev (prev, start, &u, replacement);\n+      buffer->context[0][buffer->context_len[0]++] = u;\n+    }\n+  }\n+\n+  const T *next = text + item_offset;\n+  const T *end = next + item_length;\n+  while (next < end)\n+  {\n+    hb_codepoint_t u;\n+    const T *old_next = next;\n+    next = utf_t::next (next, end, &u, replacement);\n+    buffer->add (u, old_next - (const T *) text);\n+  }\n+\n+  \/* Add post-context *\/\n+  buffer->clear_context (1);\n+  end = text + text_length;\n+  while (next < end && buffer->context_len[1] < buffer->CONTEXT_LENGTH)\n+  {\n+    hb_codepoint_t u;\n+    next = utf_t::next (next, end, &u, replacement);\n+    buffer->context[1][buffer->context_len[1]++] = u;\n+  }\n+\n+  buffer->content_type = HB_BUFFER_CONTENT_TYPE_UNICODE;\n+}\n+\n+\/**\n+ * hb_buffer_add_utf8:\n+ * @buffer: an #hb_buffer_t.\n+ * @text: (array length=text_length) (element-type uint8_t): an array of UTF-8\n+ *               characters to append.\n+ * @text_length: the length of the @text, or -1 if it is %NULL terminated.\n+ * @item_offset: the offset of the first character to add to the @buffer.\n+ * @item_length: the number of characters to add to the @buffer, or -1 for the\n+ *               end of @text (assuming it is %NULL terminated).\n+ *\n+ * See hb_buffer_add_codepoints().\n+ *\n+ * Replaces invalid UTF-8 characters with the @buffer replacement code point,\n+ * see hb_buffer_set_replacement_codepoint().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_add_utf8 (hb_buffer_t  *buffer,\n+                    const char   *text,\n+                    int           text_length,\n+                    unsigned int  item_offset,\n+                    int           item_length)\n+{\n+  hb_buffer_add_utf<hb_utf8_t> (buffer, (const uint8_t *) text, text_length, item_offset, item_length);\n+}\n+\n+\/**\n+ * hb_buffer_add_utf16:\n+ * @buffer: an #hb_buffer_t.\n+ * @text: (array length=text_length): an array of UTF-16 characters to append.\n+ * @text_length: the length of the @text, or -1 if it is %NULL terminated.\n+ * @item_offset: the offset of the first character to add to the @buffer.\n+ * @item_length: the number of characters to add to the @buffer, or -1 for the\n+ *               end of @text (assuming it is %NULL terminated).\n+ *\n+ * See hb_buffer_add_codepoints().\n+ *\n+ * Replaces invalid UTF-16 characters with the @buffer replacement code point,\n+ * see hb_buffer_set_replacement_codepoint().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_add_utf16 (hb_buffer_t    *buffer,\n+                     const uint16_t *text,\n+                     int             text_length,\n+                     unsigned int    item_offset,\n+                     int             item_length)\n+{\n+  hb_buffer_add_utf<hb_utf16_t> (buffer, text, text_length, item_offset, item_length);\n+}\n+\n+\/**\n+ * hb_buffer_add_utf32:\n+ * @buffer: an #hb_buffer_t.\n+ * @text: (array length=text_length): an array of UTF-32 characters to append.\n+ * @text_length: the length of the @text, or -1 if it is %NULL terminated.\n+ * @item_offset: the offset of the first character to add to the @buffer.\n+ * @item_length: the number of characters to add to the @buffer, or -1 for the\n+ *               end of @text (assuming it is %NULL terminated).\n+ *\n+ * See hb_buffer_add_codepoints().\n+ *\n+ * Replaces invalid UTF-32 characters with the @buffer replacement code point,\n+ * see hb_buffer_set_replacement_codepoint().\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_add_utf32 (hb_buffer_t    *buffer,\n+                     const uint32_t *text,\n+                     int             text_length,\n+                     unsigned int    item_offset,\n+                     int             item_length)\n+{\n+  hb_buffer_add_utf<hb_utf32_t> (buffer, text, text_length, item_offset, item_length);\n+}\n+\n+\/**\n+ * hb_buffer_add_latin1:\n+ * @buffer: an #hb_buffer_t.\n+ * @text: (array length=text_length) (element-type uint8_t): an array of UTF-8\n+ *               characters to append.\n+ * @text_length: the length of the @text, or -1 if it is %NULL terminated.\n+ * @item_offset: the offset of the first character to add to the @buffer.\n+ * @item_length: the number of characters to add to the @buffer, or -1 for the\n+ *               end of @text (assuming it is %NULL terminated).\n+ *\n+ * Similar to hb_buffer_add_codepoints(), but allows only access to first 256\n+ * Unicode code points that can fit in 8-bit strings.\n+ *\n+ * <note>Has nothing to do with non-Unicode Latin-1 encoding.<\/note>\n+ *\n+ * Since: 0.9.39\n+ **\/\n+void\n+hb_buffer_add_latin1 (hb_buffer_t   *buffer,\n+                      const uint8_t *text,\n+                      int            text_length,\n+                      unsigned int   item_offset,\n+                      int            item_length)\n+{\n+  hb_buffer_add_utf<hb_latin1_t> (buffer, text, text_length, item_offset, item_length);\n+}\n+\n+\/**\n+ * hb_buffer_add_codepoints:\n+ * @buffer: a #hb_buffer_t to append characters to.\n+ * @text: (array length=text_length): an array of Unicode code points to append.\n+ * @text_length: the length of the @text, or -1 if it is %NULL terminated.\n+ * @item_offset: the offset of the first code point to add to the @buffer.\n+ * @item_length: the number of code points to add to the @buffer, or -1 for the\n+ *               end of @text (assuming it is %NULL terminated).\n+ *\n+ * Appends characters from @text array to @buffer. The @item_offset is the\n+ * position of the first character from @text that will be appended, and\n+ * @item_length is the number of character. When shaping part of a larger text\n+ * (e.g. a run of text from a paragraph), instead of passing just the substring\n+ * corresponding to the run, it is preferable to pass the whole\n+ * paragraph and specify the run start and length as @item_offset and\n+ * @item_length, respectively, to give HarfBuzz the full context to be able,\n+ * for example, to do cross-run Arabic shaping or properly handle combining\n+ * marks at stat of run.\n+ *\n+ * This function does not check the validity of @text, it is up to the caller\n+ * to ensure it contains a valid Unicode code points.\n+ *\n+ * Since: 0.9.31\n+ **\/\n+void\n+hb_buffer_add_codepoints (hb_buffer_t          *buffer,\n+                          const hb_codepoint_t *text,\n+                          int                   text_length,\n+                          unsigned int          item_offset,\n+                          int                   item_length)\n+{\n+  hb_buffer_add_utf<hb_utf32_novalidate_t> (buffer, text, text_length, item_offset, item_length);\n+}\n+\n+\n+\/**\n+ * hb_buffer_append:\n+ * @buffer: an #hb_buffer_t.\n+ * @source: source #hb_buffer_t.\n+ * @start: start index into source buffer to copy.  Use 0 to copy from start of buffer.\n+ * @end: end index into source buffer to copy.  Use (unsigned int) -1 to copy to end of buffer.\n+ *\n+ * Append (part of) contents of another buffer to this buffer.\n+ *\n+ * Since: 1.5.0\n+ **\/\n+HB_EXTERN void\n+hb_buffer_append (hb_buffer_t *buffer,\n+                  hb_buffer_t *source,\n+                  unsigned int start,\n+                  unsigned int end)\n+{\n+  assert (!buffer->have_output && !source->have_output);\n+  assert (buffer->have_positions == source->have_positions ||\n+          !buffer->len || !source->len);\n+  assert (buffer->content_type == source->content_type ||\n+          !buffer->len || !source->len);\n+\n+  if (end > source->len)\n+    end = source->len;\n+  if (start > end)\n+    start = end;\n+  if (start == end)\n+    return;\n+\n+  if (!buffer->len)\n+    buffer->content_type = source->content_type;\n+  if (!buffer->have_positions && source->have_positions)\n+    buffer->clear_positions ();\n+\n+  if (buffer->len + (end - start) < buffer->len) \/* Overflows. *\/\n+  {\n+    buffer->successful = false;\n+    return;\n+  }\n+\n+  unsigned int orig_len = buffer->len;\n+  hb_buffer_set_length (buffer, buffer->len + (end - start));\n+  if (unlikely (!buffer->successful))\n+    return;\n+\n+  memcpy (buffer->info + orig_len, source->info + start, (end - start) * sizeof (buffer->info[0]));\n+  if (buffer->have_positions)\n+    memcpy (buffer->pos + orig_len, source->pos + start, (end - start) * sizeof (buffer->pos[0]));\n+}\n+\n+\n+static int\n+compare_info_codepoint (const hb_glyph_info_t *pa,\n+                        const hb_glyph_info_t *pb)\n+{\n+  return (int) pb->codepoint - (int) pa->codepoint;\n+}\n+\n+static inline void\n+normalize_glyphs_cluster (hb_buffer_t *buffer,\n+                          unsigned int start,\n+                          unsigned int end,\n+                          bool backward)\n+{\n+  hb_glyph_position_t *pos = buffer->pos;\n+\n+  \/* Total cluster advance *\/\n+  hb_position_t total_x_advance = 0, total_y_advance = 0;\n+  for (unsigned int i = start; i < end; i++)\n+  {\n+    total_x_advance += pos[i].x_advance;\n+    total_y_advance += pos[i].y_advance;\n+  }\n+\n+  hb_position_t x_advance = 0, y_advance = 0;\n+  for (unsigned int i = start; i < end; i++)\n+  {\n+    pos[i].x_offset += x_advance;\n+    pos[i].y_offset += y_advance;\n+\n+    x_advance += pos[i].x_advance;\n+    y_advance += pos[i].y_advance;\n+\n+    pos[i].x_advance = 0;\n+    pos[i].y_advance = 0;\n+  }\n+\n+  if (backward)\n+  {\n+    \/* Transfer all cluster advance to the last glyph. *\/\n+    pos[end - 1].x_advance = total_x_advance;\n+    pos[end - 1].y_advance = total_y_advance;\n+\n+    hb_stable_sort (buffer->info + start, end - start - 1, compare_info_codepoint, buffer->pos + start);\n+  } else {\n+    \/* Transfer all cluster advance to the first glyph. *\/\n+    pos[start].x_advance += total_x_advance;\n+    pos[start].y_advance += total_y_advance;\n+    for (unsigned int i = start + 1; i < end; i++) {\n+      pos[i].x_offset -= total_x_advance;\n+      pos[i].y_offset -= total_y_advance;\n+    }\n+    hb_stable_sort (buffer->info + start + 1, end - start - 1, compare_info_codepoint, buffer->pos + start + 1);\n+  }\n+}\n+\n+\/**\n+ * hb_buffer_normalize_glyphs:\n+ * @buffer: an #hb_buffer_t.\n+ *\n+ * Reorders a glyph buffer to have canonical in-cluster glyph order \/ position.\n+ * The resulting clusters should behave identical to pre-reordering clusters.\n+ *\n+ * <note>This has nothing to do with Unicode normalization.<\/note>\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_buffer_normalize_glyphs (hb_buffer_t *buffer)\n+{\n+  assert (buffer->have_positions);\n+  assert (buffer->content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS ||\n+          (!buffer->len && buffer->content_type == HB_BUFFER_CONTENT_TYPE_INVALID));\n+\n+  bool backward = HB_DIRECTION_IS_BACKWARD (buffer->props.direction);\n+\n+  unsigned int count = buffer->len;\n+  if (unlikely (!count)) return;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  unsigned int start = 0;\n+  unsigned int end;\n+  for (end = start + 1; end < count; end++)\n+    if (info[start].cluster != info[end].cluster) {\n+      normalize_glyphs_cluster (buffer, start, end, backward);\n+      start = end;\n+    }\n+  normalize_glyphs_cluster (buffer, start, end, backward);\n+}\n+\n+void\n+hb_buffer_t::sort (unsigned int start, unsigned int end, int(*compar)(const hb_glyph_info_t *, const hb_glyph_info_t *))\n+{\n+  assert (!have_positions);\n+  for (unsigned int i = start + 1; i < end; i++)\n+  {\n+    unsigned int j = i;\n+    while (j > start && compar (&info[j - 1], &info[i]) > 0)\n+      j--;\n+    if (i == j)\n+      continue;\n+    \/* Move item i to occupy place for item j, shift what's in between. *\/\n+    merge_clusters (j, i + 1);\n+    {\n+      hb_glyph_info_t t = info[i];\n+      memmove (&info[j + 1], &info[j], (i - j) * sizeof (hb_glyph_info_t));\n+      info[j] = t;\n+    }\n+  }\n+}\n+\n+\n+\/*\n+ * Comparing buffers.\n+ *\/\n+\n+\/**\n+ * hb_buffer_diff:\n+ * @buffer: a buffer.\n+ * @reference: other buffer to compare to.\n+ * @dottedcircle_glyph: glyph id of U+25CC DOTTED CIRCLE, or (hb_codepont_t) -1.\n+ * @position_fuzz: allowed absolute difference in position values.\n+ *\n+ * If dottedcircle_glyph is (hb_codepoint_t) -1 then %HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT\n+ * and %HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT are never returned.  This should be used by most\n+ * callers if just comparing two buffers is needed.\n+ *\n+ * Since: 1.5.0\n+ **\/\n+hb_buffer_diff_flags_t\n+hb_buffer_diff (hb_buffer_t *buffer,\n+                hb_buffer_t *reference,\n+                hb_codepoint_t dottedcircle_glyph,\n+                unsigned int position_fuzz)\n+{\n+  if (buffer->content_type != reference->content_type && buffer->len && reference->len)\n+    return HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH;\n+\n+  hb_buffer_diff_flags_t result = HB_BUFFER_DIFF_FLAG_EQUAL;\n+  bool contains = dottedcircle_glyph != (hb_codepoint_t) -1;\n+\n+  unsigned int count = reference->len;\n+\n+  if (buffer->len != count)\n+  {\n+    \/*\n+     * we can't compare glyph-by-glyph, but we do want to know if there\n+     * are .notdef or dottedcircle glyphs present in the reference buffer\n+     *\/\n+    const hb_glyph_info_t *info = reference->info;\n+    unsigned int i;\n+    for (i = 0; i < count; i++)\n+    {\n+      if (contains && info[i].codepoint == dottedcircle_glyph)\n+        result |= HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT;\n+      if (contains && info[i].codepoint == 0)\n+        result |= HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT;\n+    }\n+    result |= HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH;\n+    return hb_buffer_diff_flags_t (result);\n+  }\n+\n+  if (!count)\n+    return hb_buffer_diff_flags_t (result);\n+\n+  const hb_glyph_info_t *buf_info = buffer->info;\n+  const hb_glyph_info_t *ref_info = reference->info;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    if (buf_info->codepoint != ref_info->codepoint)\n+      result |= HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH;\n+    if (buf_info->cluster != ref_info->cluster)\n+      result |= HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH;\n+    if ((buf_info->mask & ~ref_info->mask & HB_GLYPH_FLAG_DEFINED))\n+      result |= HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH;\n+    if (contains && ref_info->codepoint == dottedcircle_glyph)\n+      result |= HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT;\n+    if (contains && ref_info->codepoint == 0)\n+      result |= HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT;\n+    buf_info++;\n+    ref_info++;\n+  }\n+\n+  if (buffer->content_type == HB_BUFFER_CONTENT_TYPE_GLYPHS)\n+  {\n+    assert (buffer->have_positions);\n+    const hb_glyph_position_t *buf_pos = buffer->pos;\n+    const hb_glyph_position_t *ref_pos = reference->pos;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if ((unsigned int) abs (buf_pos->x_advance - ref_pos->x_advance) > position_fuzz ||\n+          (unsigned int) abs (buf_pos->y_advance - ref_pos->y_advance) > position_fuzz ||\n+          (unsigned int) abs (buf_pos->x_offset - ref_pos->x_offset) > position_fuzz ||\n+          (unsigned int) abs (buf_pos->y_offset - ref_pos->y_offset) > position_fuzz)\n+      {\n+        result |= HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH;\n+        break;\n+      }\n+      buf_pos++;\n+      ref_pos++;\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+\n+\/*\n+ * Debugging.\n+ *\/\n+\n+\/**\n+ * hb_buffer_set_message_func:\n+ * @buffer: an #hb_buffer_t.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 1.1.3\n+ **\/\n+void\n+hb_buffer_set_message_func (hb_buffer_t *buffer,\n+                            hb_buffer_message_func_t func,\n+                            void *user_data, hb_destroy_func_t destroy)\n+{\n+  if (buffer->message_destroy)\n+    buffer->message_destroy (buffer->message_data);\n+\n+  if (func) {\n+    buffer->message_func = func;\n+    buffer->message_data = user_data;\n+    buffer->message_destroy = destroy;\n+  } else {\n+    buffer->message_func = nullptr;\n+    buffer->message_data = nullptr;\n+    buffer->message_destroy = nullptr;\n+  }\n+}\n+\n+bool\n+hb_buffer_t::message_impl (hb_font_t *font, const char *fmt, va_list ap)\n+{\n+  char buf[100];\n+  vsnprintf (buf, sizeof (buf),  fmt, ap);\n+  return (bool) this->message_func (this, font, buf, this->message_data);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-buffer.cc","additions":2032,"deletions":0,"binary":false,"changes":2032,"status":"added"},{"patch":"@@ -0,0 +1,581 @@\n+\/*\n+ * Copyright © 1998-2004  David Turner and Werner Lemberg\n+ * Copyright © 2004,2007,2009  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_BUFFER_H\n+#define HB_BUFFER_H\n+\n+#include \"hb-common.h\"\n+#include \"hb-unicode.h\"\n+#include \"hb-font.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\/**\n+ * hb_glyph_info_t:\n+ * @codepoint: either a Unicode code point (before shaping) or a glyph index\n+ *             (after shaping).\n+ * @cluster: the index of the character in the original text that corresponds\n+ *           to this #hb_glyph_info_t, or whatever the client passes to\n+ *           hb_buffer_add(). More than one #hb_glyph_info_t can have the same\n+ *           @cluster value, if they resulted from the same character (e.g. one\n+ *           to many glyph substitution), and when more than one character gets\n+ *           merged in the same glyph (e.g. many to one glyph substitution) the\n+ *           #hb_glyph_info_t will have the smallest cluster value of them.\n+ *           By default some characters are merged into the same cluster\n+ *           (e.g. combining marks have the same cluster as their bases)\n+ *           even if they are separate glyphs, hb_buffer_set_cluster_level()\n+ *           allow selecting more fine-grained cluster handling.\n+ *\n+ * The #hb_glyph_info_t is the structure that holds information about the\n+ * glyphs and their relation to input text.\n+ *\/\n+typedef struct hb_glyph_info_t\n+{\n+  hb_codepoint_t codepoint;\n+  \/*< private >*\/\n+  hb_mask_t      mask;\n+  \/*< public >*\/\n+  uint32_t       cluster;\n+\n+  \/*< private >*\/\n+  hb_var_int_t   var1;\n+  hb_var_int_t   var2;\n+} hb_glyph_info_t;\n+\n+\/**\n+ * hb_glyph_flags_t:\n+ * @HB_GLYPH_FLAG_UNSAFE_TO_BREAK: Indicates that if input text is broken at the\n+ *                                 beginning of the cluster this glyph is part of,\n+ *                                 then both sides need to be re-shaped, as the\n+ *                                 result might be different.  On the flip side,\n+ *                                 it means that when this flag is not present,\n+ *                                 then it's safe to break the glyph-run at the\n+ *                                 beginning of this cluster, and the two sides\n+ *                                 represent the exact same result one would get\n+ *                                 if breaking input text at the beginning of\n+ *                                 this cluster and shaping the two sides\n+ *                                 separately.  This can be used to optimize\n+ *                                 paragraph layout, by avoiding re-shaping\n+ *                                 of each line after line-breaking, or limiting\n+ *                                 the reshaping to a small piece around the\n+ *                                 breaking point only.\n+ * @HB_GLYPH_FLAG_DEFINED: All the currently defined flags.\n+ *\n+ * Since: 1.5.0\n+ *\/\n+typedef enum { \/*< flags >*\/\n+  HB_GLYPH_FLAG_UNSAFE_TO_BREAK         = 0x00000001,\n+\n+  HB_GLYPH_FLAG_DEFINED                 = 0x00000001 \/* OR of all defined flags *\/\n+} hb_glyph_flags_t;\n+\n+HB_EXTERN hb_glyph_flags_t\n+hb_glyph_info_get_glyph_flags (const hb_glyph_info_t *info);\n+\n+#define hb_glyph_info_get_glyph_flags(info) \\\n+        ((hb_glyph_flags_t) ((unsigned int) (info)->mask & HB_GLYPH_FLAG_DEFINED))\n+\n+\n+\/**\n+ * hb_glyph_position_t:\n+ * @x_advance: how much the line advances after drawing this glyph when setting\n+ *             text in horizontal direction.\n+ * @y_advance: how much the line advances after drawing this glyph when setting\n+ *             text in vertical direction.\n+ * @x_offset: how much the glyph moves on the X-axis before drawing it, this\n+ *            should not affect how much the line advances.\n+ * @y_offset: how much the glyph moves on the Y-axis before drawing it, this\n+ *            should not affect how much the line advances.\n+ *\n+ * The #hb_glyph_position_t is the structure that holds the positions of the\n+ * glyph in both horizontal and vertical directions. All positions in\n+ * #hb_glyph_position_t are relative to the current point.\n+ *\n+ *\/\n+typedef struct hb_glyph_position_t {\n+  hb_position_t  x_advance;\n+  hb_position_t  y_advance;\n+  hb_position_t  x_offset;\n+  hb_position_t  y_offset;\n+\n+  \/*< private >*\/\n+  hb_var_int_t   var;\n+} hb_glyph_position_t;\n+\n+\/**\n+ * hb_segment_properties_t:\n+ * @direction: the #hb_direction_t of the buffer, see hb_buffer_set_direction().\n+ * @script: the #hb_script_t of the buffer, see hb_buffer_set_script().\n+ * @language: the #hb_language_t of the buffer, see hb_buffer_set_language().\n+ *\n+ * The structure that holds various text properties of an #hb_buffer_t. Can be\n+ * set and retrieved using hb_buffer_set_segment_properties() and\n+ * hb_buffer_get_segment_properties(), respectively.\n+ *\/\n+typedef struct hb_segment_properties_t {\n+  hb_direction_t  direction;\n+  hb_script_t     script;\n+  hb_language_t   language;\n+  \/*< private >*\/\n+  void           *reserved1;\n+  void           *reserved2;\n+} hb_segment_properties_t;\n+\n+#define HB_SEGMENT_PROPERTIES_DEFAULT {HB_DIRECTION_INVALID, \\\n+                                       HB_SCRIPT_INVALID, \\\n+                                       HB_LANGUAGE_INVALID, \\\n+                                       (void *) 0, \\\n+                                       (void *) 0}\n+\n+HB_EXTERN hb_bool_t\n+hb_segment_properties_equal (const hb_segment_properties_t *a,\n+                             const hb_segment_properties_t *b);\n+\n+HB_EXTERN unsigned int\n+hb_segment_properties_hash (const hb_segment_properties_t *p);\n+\n+\n+\n+\/**\n+ * hb_buffer_t:\n+ *\n+ * The main structure holding the input text and its properties before shaping,\n+ * and output glyphs and their information after shaping.\n+ *\/\n+\n+typedef struct hb_buffer_t hb_buffer_t;\n+\n+HB_EXTERN hb_buffer_t *\n+hb_buffer_create (void);\n+\n+HB_EXTERN hb_buffer_t *\n+hb_buffer_get_empty (void);\n+\n+HB_EXTERN hb_buffer_t *\n+hb_buffer_reference (hb_buffer_t *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_destroy (hb_buffer_t *buffer);\n+\n+HB_EXTERN hb_bool_t\n+hb_buffer_set_user_data (hb_buffer_t        *buffer,\n+                         hb_user_data_key_t *key,\n+                         void *              data,\n+                         hb_destroy_func_t   destroy,\n+                         hb_bool_t           replace);\n+\n+HB_EXTERN void *\n+hb_buffer_get_user_data (hb_buffer_t        *buffer,\n+                         hb_user_data_key_t *key);\n+\n+\n+\/**\n+ * hb_buffer_content_type_t:\n+ * @HB_BUFFER_CONTENT_TYPE_INVALID: Initial value for new buffer.\n+ * @HB_BUFFER_CONTENT_TYPE_UNICODE: The buffer contains input characters (before shaping).\n+ * @HB_BUFFER_CONTENT_TYPE_GLYPHS: The buffer contains output glyphs (after shaping).\n+ *\/\n+typedef enum {\n+  HB_BUFFER_CONTENT_TYPE_INVALID = 0,\n+  HB_BUFFER_CONTENT_TYPE_UNICODE,\n+  HB_BUFFER_CONTENT_TYPE_GLYPHS\n+} hb_buffer_content_type_t;\n+\n+HB_EXTERN void\n+hb_buffer_set_content_type (hb_buffer_t              *buffer,\n+                            hb_buffer_content_type_t  content_type);\n+\n+HB_EXTERN hb_buffer_content_type_t\n+hb_buffer_get_content_type (hb_buffer_t *buffer);\n+\n+\n+HB_EXTERN void\n+hb_buffer_set_unicode_funcs (hb_buffer_t        *buffer,\n+                             hb_unicode_funcs_t *unicode_funcs);\n+\n+HB_EXTERN hb_unicode_funcs_t *\n+hb_buffer_get_unicode_funcs (hb_buffer_t        *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_set_direction (hb_buffer_t    *buffer,\n+                         hb_direction_t  direction);\n+\n+HB_EXTERN hb_direction_t\n+hb_buffer_get_direction (hb_buffer_t *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_set_script (hb_buffer_t *buffer,\n+                      hb_script_t  script);\n+\n+HB_EXTERN hb_script_t\n+hb_buffer_get_script (hb_buffer_t *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_set_language (hb_buffer_t   *buffer,\n+                        hb_language_t  language);\n+\n+\n+HB_EXTERN hb_language_t\n+hb_buffer_get_language (hb_buffer_t *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_set_segment_properties (hb_buffer_t *buffer,\n+                                  const hb_segment_properties_t *props);\n+\n+HB_EXTERN void\n+hb_buffer_get_segment_properties (hb_buffer_t *buffer,\n+                                  hb_segment_properties_t *props);\n+\n+HB_EXTERN void\n+hb_buffer_guess_segment_properties (hb_buffer_t *buffer);\n+\n+\n+\/**\n+ * hb_buffer_flags_t:\n+ * @HB_BUFFER_FLAG_DEFAULT: the default buffer flag.\n+ * @HB_BUFFER_FLAG_BOT: flag indicating that special handling of the beginning\n+ *                      of text paragraph can be applied to this buffer. Should usually\n+ *                      be set, unless you are passing to the buffer only part\n+ *                      of the text without the full context.\n+ * @HB_BUFFER_FLAG_EOT: flag indicating that special handling of the end of text\n+ *                      paragraph can be applied to this buffer, similar to\n+ *                      @HB_BUFFER_FLAG_BOT.\n+ * @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES:\n+ *                      flag indication that character with Default_Ignorable\n+ *                      Unicode property should use the corresponding glyph\n+ *                      from the font, instead of hiding them (done by\n+ *                      replacing them with the space glyph and zeroing the\n+ *                      advance width.)  This flag takes precedence over\n+ *                      @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES.\n+ * @HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES:\n+ *                      flag indication that character with Default_Ignorable\n+ *                      Unicode property should be removed from glyph string\n+ *                      instead of hiding them (done by replacing them with the\n+ *                      space glyph and zeroing the advance width.)\n+ *                      @HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES takes\n+ *                      precedence over this flag. Since: 1.8.0\n+ *\n+ * Since: 0.9.20\n+ *\/\n+typedef enum { \/*< flags >*\/\n+  HB_BUFFER_FLAG_DEFAULT                        = 0x00000000u,\n+  HB_BUFFER_FLAG_BOT                            = 0x00000001u, \/* Beginning-of-text *\/\n+  HB_BUFFER_FLAG_EOT                            = 0x00000002u, \/* End-of-text *\/\n+  HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES    = 0x00000004u,\n+  HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES      = 0x00000008u\n+} hb_buffer_flags_t;\n+\n+HB_EXTERN void\n+hb_buffer_set_flags (hb_buffer_t       *buffer,\n+                     hb_buffer_flags_t  flags);\n+\n+HB_EXTERN hb_buffer_flags_t\n+hb_buffer_get_flags (hb_buffer_t *buffer);\n+\n+\/**\n+ * hb_buffer_cluster_level_t:\n+ * @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES: Return cluster values grouped by graphemes into\n+ *   monotone order.\n+ * @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS: Return cluster values grouped into monotone order.\n+ * @HB_BUFFER_CLUSTER_LEVEL_CHARACTERS: Don't group cluster values.\n+ * @HB_BUFFER_CLUSTER_LEVEL_DEFAULT: Default cluster level,\n+ *   equal to @HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES.\n+ *\n+ * Since: 0.9.42\n+ *\/\n+typedef enum {\n+  HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES    = 0,\n+  HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS   = 1,\n+  HB_BUFFER_CLUSTER_LEVEL_CHARACTERS            = 2,\n+  HB_BUFFER_CLUSTER_LEVEL_DEFAULT = HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES\n+} hb_buffer_cluster_level_t;\n+\n+HB_EXTERN void\n+hb_buffer_set_cluster_level (hb_buffer_t               *buffer,\n+                             hb_buffer_cluster_level_t  cluster_level);\n+\n+HB_EXTERN hb_buffer_cluster_level_t\n+hb_buffer_get_cluster_level (hb_buffer_t *buffer);\n+\n+\/**\n+ * HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT:\n+ *\n+ * The default code point for replacing invalid characters in a given encoding.\n+ * Set to U+FFFD REPLACEMENT CHARACTER.\n+ *\n+ * Since: 0.9.31\n+ *\/\n+#define HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT 0xFFFDu\n+\n+HB_EXTERN void\n+hb_buffer_set_replacement_codepoint (hb_buffer_t    *buffer,\n+                                     hb_codepoint_t  replacement);\n+\n+HB_EXTERN hb_codepoint_t\n+hb_buffer_get_replacement_codepoint (hb_buffer_t    *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_set_invisible_glyph (hb_buffer_t    *buffer,\n+                               hb_codepoint_t  invisible);\n+\n+HB_EXTERN hb_codepoint_t\n+hb_buffer_get_invisible_glyph (hb_buffer_t    *buffer);\n+\n+\n+HB_EXTERN void\n+hb_buffer_reset (hb_buffer_t *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_clear_contents (hb_buffer_t *buffer);\n+\n+HB_EXTERN hb_bool_t\n+hb_buffer_pre_allocate (hb_buffer_t  *buffer,\n+                        unsigned int  size);\n+\n+\n+HB_EXTERN hb_bool_t\n+hb_buffer_allocation_successful (hb_buffer_t  *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_reverse (hb_buffer_t *buffer);\n+\n+HB_EXTERN void\n+hb_buffer_reverse_range (hb_buffer_t *buffer,\n+                         unsigned int start, unsigned int end);\n+\n+HB_EXTERN void\n+hb_buffer_reverse_clusters (hb_buffer_t *buffer);\n+\n+\n+\/* Filling the buffer in *\/\n+\n+HB_EXTERN void\n+hb_buffer_add (hb_buffer_t    *buffer,\n+               hb_codepoint_t  codepoint,\n+               unsigned int    cluster);\n+\n+HB_EXTERN void\n+hb_buffer_add_utf8 (hb_buffer_t  *buffer,\n+                    const char   *text,\n+                    int           text_length,\n+                    unsigned int  item_offset,\n+                    int           item_length);\n+\n+HB_EXTERN void\n+hb_buffer_add_utf16 (hb_buffer_t    *buffer,\n+                     const uint16_t *text,\n+                     int             text_length,\n+                     unsigned int    item_offset,\n+                     int             item_length);\n+\n+HB_EXTERN void\n+hb_buffer_add_utf32 (hb_buffer_t    *buffer,\n+                     const uint32_t *text,\n+                     int             text_length,\n+                     unsigned int    item_offset,\n+                     int             item_length);\n+\n+HB_EXTERN void\n+hb_buffer_add_latin1 (hb_buffer_t   *buffer,\n+                      const uint8_t *text,\n+                      int            text_length,\n+                      unsigned int   item_offset,\n+                      int            item_length);\n+\n+HB_EXTERN void\n+hb_buffer_add_codepoints (hb_buffer_t          *buffer,\n+                          const hb_codepoint_t *text,\n+                          int                   text_length,\n+                          unsigned int          item_offset,\n+                          int                   item_length);\n+\n+HB_EXTERN void\n+hb_buffer_append (hb_buffer_t *buffer,\n+                  hb_buffer_t *source,\n+                  unsigned int start,\n+                  unsigned int end);\n+\n+HB_EXTERN hb_bool_t\n+hb_buffer_set_length (hb_buffer_t  *buffer,\n+                      unsigned int  length);\n+\n+HB_EXTERN unsigned int\n+hb_buffer_get_length (hb_buffer_t *buffer);\n+\n+\/* Getting glyphs out of the buffer *\/\n+\n+HB_EXTERN hb_glyph_info_t *\n+hb_buffer_get_glyph_infos (hb_buffer_t  *buffer,\n+                           unsigned int *length);\n+\n+HB_EXTERN hb_glyph_position_t *\n+hb_buffer_get_glyph_positions (hb_buffer_t  *buffer,\n+                               unsigned int *length);\n+\n+\n+HB_EXTERN void\n+hb_buffer_normalize_glyphs (hb_buffer_t *buffer);\n+\n+\n+\/*\n+ * Serialize\n+ *\/\n+\n+\/**\n+ * hb_buffer_serialize_flags_t:\n+ * @HB_BUFFER_SERIALIZE_FLAG_DEFAULT: serialize glyph names, clusters and positions.\n+ * @HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS: do not serialize glyph cluster.\n+ * @HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS: do not serialize glyph position information.\n+ * @HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES: do no serialize glyph name.\n+ * @HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS: serialize glyph extents.\n+ * @HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS: serialize glyph flags. Since: 1.5.0\n+ * @HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES: do not serialize glyph advances,\n+ *  glyph offsets will reflect absolute glyph positions. Since: 1.8.0\n+ *\n+ * Flags that control what glyph information are serialized in hb_buffer_serialize_glyphs().\n+ *\n+ * Since: 0.9.20\n+ *\/\n+typedef enum { \/*< flags >*\/\n+  HB_BUFFER_SERIALIZE_FLAG_DEFAULT              = 0x00000000u,\n+  HB_BUFFER_SERIALIZE_FLAG_NO_CLUSTERS          = 0x00000001u,\n+  HB_BUFFER_SERIALIZE_FLAG_NO_POSITIONS         = 0x00000002u,\n+  HB_BUFFER_SERIALIZE_FLAG_NO_GLYPH_NAMES       = 0x00000004u,\n+  HB_BUFFER_SERIALIZE_FLAG_GLYPH_EXTENTS        = 0x00000008u,\n+  HB_BUFFER_SERIALIZE_FLAG_GLYPH_FLAGS          = 0x00000010u,\n+  HB_BUFFER_SERIALIZE_FLAG_NO_ADVANCES          = 0x00000020u\n+} hb_buffer_serialize_flags_t;\n+\n+\/**\n+ * hb_buffer_serialize_format_t:\n+ * @HB_BUFFER_SERIALIZE_FORMAT_TEXT: a human-readable, plain text format.\n+ * @HB_BUFFER_SERIALIZE_FORMAT_JSON: a machine-readable JSON format.\n+ * @HB_BUFFER_SERIALIZE_FORMAT_INVALID: invalid format.\n+ *\n+ * The buffer serialization and de-serialization format used in\n+ * hb_buffer_serialize_glyphs() and hb_buffer_deserialize_glyphs().\n+ *\n+ * Since: 0.9.2\n+ *\/\n+typedef enum {\n+  HB_BUFFER_SERIALIZE_FORMAT_TEXT       = HB_TAG('T','E','X','T'),\n+  HB_BUFFER_SERIALIZE_FORMAT_JSON       = HB_TAG('J','S','O','N'),\n+  HB_BUFFER_SERIALIZE_FORMAT_INVALID    = HB_TAG_NONE\n+} hb_buffer_serialize_format_t;\n+\n+HB_EXTERN hb_buffer_serialize_format_t\n+hb_buffer_serialize_format_from_string (const char *str, int len);\n+\n+HB_EXTERN const char *\n+hb_buffer_serialize_format_to_string (hb_buffer_serialize_format_t format);\n+\n+HB_EXTERN const char **\n+hb_buffer_serialize_list_formats (void);\n+\n+HB_EXTERN unsigned int\n+hb_buffer_serialize_glyphs (hb_buffer_t *buffer,\n+                            unsigned int start,\n+                            unsigned int end,\n+                            char *buf,\n+                            unsigned int buf_size,\n+                            unsigned int *buf_consumed,\n+                            hb_font_t *font,\n+                            hb_buffer_serialize_format_t format,\n+                            hb_buffer_serialize_flags_t flags);\n+\n+HB_EXTERN hb_bool_t\n+hb_buffer_deserialize_glyphs (hb_buffer_t *buffer,\n+                              const char *buf,\n+                              int buf_len,\n+                              const char **end_ptr,\n+                              hb_font_t *font,\n+                              hb_buffer_serialize_format_t format);\n+\n+\n+\/*\n+ * Compare buffers\n+ *\/\n+\n+typedef enum { \/*< flags >*\/\n+  HB_BUFFER_DIFF_FLAG_EQUAL                     = 0x0000,\n+\n+  \/* Buffers with different content_type cannot be meaningfully compared\n+   * in any further detail. *\/\n+  HB_BUFFER_DIFF_FLAG_CONTENT_TYPE_MISMATCH     = 0x0001,\n+\n+  \/* For buffers with differing length, the per-glyph comparison is not\n+   * attempted, though we do still scan reference for dottedcircle \/ .notdef\n+   * glyphs. *\/\n+  HB_BUFFER_DIFF_FLAG_LENGTH_MISMATCH           = 0x0002,\n+\n+  \/* We want to know if dottedcircle \/ .notdef glyphs are present in the\n+   * reference, as we may not care so much about other differences in this\n+   * case. *\/\n+  HB_BUFFER_DIFF_FLAG_NOTDEF_PRESENT            = 0x0004,\n+  HB_BUFFER_DIFF_FLAG_DOTTED_CIRCLE_PRESENT     = 0x0008,\n+\n+  \/* If the buffers have the same length, we compare them glyph-by-glyph\n+   * and report which aspect(s) of the glyph info\/position are different. *\/\n+  HB_BUFFER_DIFF_FLAG_CODEPOINT_MISMATCH        = 0x0010,\n+  HB_BUFFER_DIFF_FLAG_CLUSTER_MISMATCH          = 0x0020,\n+  HB_BUFFER_DIFF_FLAG_GLYPH_FLAGS_MISMATCH      = 0x0040,\n+  HB_BUFFER_DIFF_FLAG_POSITION_MISMATCH         = 0x0080\n+\n+} hb_buffer_diff_flags_t;\n+\n+\/* Compare the contents of two buffers, report types of differences. *\/\n+HB_EXTERN hb_buffer_diff_flags_t\n+hb_buffer_diff (hb_buffer_t *buffer,\n+                hb_buffer_t *reference,\n+                hb_codepoint_t dottedcircle_glyph,\n+                unsigned int position_fuzz);\n+\n+\n+\/*\n+ * Debugging.\n+ *\/\n+\n+typedef hb_bool_t       (*hb_buffer_message_func_t)     (hb_buffer_t *buffer,\n+                                                         hb_font_t   *font,\n+                                                         const char  *message,\n+                                                         void        *user_data);\n+\n+HB_EXTERN void\n+hb_buffer_set_message_func (hb_buffer_t *buffer,\n+                            hb_buffer_message_func_t func,\n+                            void *user_data, hb_destroy_func_t destroy);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_BUFFER_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-buffer.h","additions":581,"deletions":0,"binary":false,"changes":581,"status":"added"},{"patch":"@@ -0,0 +1,439 @@\n+\/*\n+ * Copyright © 1998-2004  David Turner and Werner Lemberg\n+ * Copyright © 2004,2007,2009,2010  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Owen Taylor, Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_BUFFER_HH\n+#define HB_BUFFER_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-unicode.hh\"\n+\n+\n+#ifndef HB_BUFFER_MAX_LEN_FACTOR\n+#define HB_BUFFER_MAX_LEN_FACTOR 32\n+#endif\n+#ifndef HB_BUFFER_MAX_LEN_MIN\n+#define HB_BUFFER_MAX_LEN_MIN 8192\n+#endif\n+#ifndef HB_BUFFER_MAX_LEN_DEFAULT\n+#define HB_BUFFER_MAX_LEN_DEFAULT 0x3FFFFFFF \/* Shaping more than a billion chars? Let us know! *\/\n+#endif\n+\n+#ifndef HB_BUFFER_MAX_OPS_FACTOR\n+#define HB_BUFFER_MAX_OPS_FACTOR 64\n+#endif\n+#ifndef HB_BUFFER_MAX_OPS_MIN\n+#define HB_BUFFER_MAX_OPS_MIN 1024\n+#endif\n+#ifndef HB_BUFFER_MAX_OPS_DEFAULT\n+#define HB_BUFFER_MAX_OPS_DEFAULT 0x1FFFFFFF \/* Shaping more than a billion operations? Let us know! *\/\n+#endif\n+\n+static_assert ((sizeof (hb_glyph_info_t) == 20), \"\");\n+static_assert ((sizeof (hb_glyph_info_t) == sizeof (hb_glyph_position_t)), \"\");\n+\n+HB_MARK_AS_FLAG_T (hb_buffer_flags_t);\n+HB_MARK_AS_FLAG_T (hb_buffer_serialize_flags_t);\n+HB_MARK_AS_FLAG_T (hb_buffer_diff_flags_t);\n+\n+enum hb_buffer_scratch_flags_t {\n+  HB_BUFFER_SCRATCH_FLAG_DEFAULT                        = 0x00000000u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII                  = 0x00000001u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES         = 0x00000002u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK             = 0x00000004u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT            = 0x00000008u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK            = 0x00000010u,\n+  HB_BUFFER_SCRATCH_FLAG_HAS_CGJ                        = 0x00000020u,\n+\n+  \/* Reserved for complex shapers' internal use. *\/\n+  HB_BUFFER_SCRATCH_FLAG_COMPLEX0                       = 0x01000000u,\n+  HB_BUFFER_SCRATCH_FLAG_COMPLEX1                       = 0x02000000u,\n+  HB_BUFFER_SCRATCH_FLAG_COMPLEX2                       = 0x04000000u,\n+  HB_BUFFER_SCRATCH_FLAG_COMPLEX3                       = 0x08000000u,\n+};\n+HB_MARK_AS_FLAG_T (hb_buffer_scratch_flags_t);\n+\n+\n+\/*\n+ * hb_buffer_t\n+ *\/\n+\n+struct hb_buffer_t\n+{\n+  hb_object_header_t header;\n+\n+  \/* Information about how the text in the buffer should be treated *\/\n+  hb_unicode_funcs_t *unicode; \/* Unicode functions *\/\n+  hb_buffer_flags_t flags; \/* BOT \/ EOT \/ etc. *\/\n+  hb_buffer_cluster_level_t cluster_level;\n+  hb_codepoint_t replacement; \/* U+FFFD or something else. *\/\n+  hb_codepoint_t invisible; \/* 0 or something else. *\/\n+  hb_buffer_scratch_flags_t scratch_flags; \/* Have space-fallback, etc. *\/\n+  unsigned int max_len; \/* Maximum allowed len. *\/\n+  int max_ops; \/* Maximum allowed operations. *\/\n+\n+  \/* Buffer contents *\/\n+  hb_buffer_content_type_t content_type;\n+  hb_segment_properties_t props; \/* Script, language, direction *\/\n+\n+  bool successful; \/* Allocations successful *\/\n+  bool have_output; \/* Whether we have an output buffer going on *\/\n+  bool have_positions; \/* Whether we have positions *\/\n+\n+  unsigned int idx; \/* Cursor into ->info and ->pos arrays *\/\n+  unsigned int len; \/* Length of ->info and ->pos arrays *\/\n+  unsigned int out_len; \/* Length of ->out array if have_output *\/\n+\n+  unsigned int allocated; \/* Length of allocated arrays *\/\n+  hb_glyph_info_t     *info;\n+  hb_glyph_info_t     *out_info;\n+  hb_glyph_position_t *pos;\n+\n+  unsigned int serial;\n+\n+  \/* Text before \/ after the main buffer contents.\n+   * Always in Unicode, and ordered outward.\n+   * Index 0 is for \"pre-context\", 1 for \"post-context\". *\/\n+  static constexpr unsigned CONTEXT_LENGTH = 5u;\n+  hb_codepoint_t context[2][CONTEXT_LENGTH];\n+  unsigned int context_len[2];\n+\n+  \/* Debugging API *\/\n+  hb_buffer_message_func_t message_func;\n+  void *message_data;\n+  hb_destroy_func_t message_destroy;\n+\n+  \/* Internal debugging. *\/\n+  \/* The bits here reflect current allocations of the bytes in glyph_info_t's var1 and var2. *\/\n+#ifndef HB_NDEBUG\n+  uint8_t allocated_var_bits;\n+#endif\n+\n+\n+  \/* Methods *\/\n+\n+  bool in_error () const { return !successful; }\n+\n+  void allocate_var (unsigned int start, unsigned int count)\n+  {\n+#ifndef HB_NDEBUG\n+    unsigned int end = start + count;\n+    assert (end <= 8);\n+    unsigned int bits = (1u<<end) - (1u<<start);\n+    assert (0 == (allocated_var_bits & bits));\n+    allocated_var_bits |= bits;\n+#endif\n+  }\n+  void deallocate_var (unsigned int start, unsigned int count)\n+  {\n+#ifndef HB_NDEBUG\n+    unsigned int end = start + count;\n+    assert (end <= 8);\n+    unsigned int bits = (1u<<end) - (1u<<start);\n+    assert (bits == (allocated_var_bits & bits));\n+    allocated_var_bits &= ~bits;\n+#endif\n+  }\n+  void assert_var (unsigned int start, unsigned int count)\n+  {\n+#ifndef HB_NDEBUG\n+    unsigned int end = start + count;\n+    assert (end <= 8);\n+    unsigned int bits = (1u<<end) - (1u<<start);\n+    assert (bits == (allocated_var_bits & bits));\n+#endif\n+  }\n+  void deallocate_var_all ()\n+  {\n+#ifndef HB_NDEBUG\n+    allocated_var_bits = 0;\n+#endif\n+  }\n+\n+  hb_glyph_info_t &cur (unsigned int i = 0) { return info[idx + i]; }\n+  hb_glyph_info_t cur (unsigned int i = 0) const { return info[idx + i]; }\n+\n+  hb_glyph_position_t &cur_pos (unsigned int i = 0) { return pos[idx + i]; }\n+  hb_glyph_position_t cur_pos (unsigned int i = 0) const { return pos[idx + i]; }\n+\n+  hb_glyph_info_t &prev ()      { return out_info[out_len ? out_len - 1 : 0]; }\n+  hb_glyph_info_t prev () const { return out_info[out_len ? out_len - 1 : 0]; }\n+\n+  bool has_separate_output () const { return info != out_info; }\n+\n+\n+  HB_INTERNAL void reset ();\n+  HB_INTERNAL void clear ();\n+\n+  unsigned int backtrack_len () const { return have_output? out_len : idx; }\n+  unsigned int lookahead_len () const { return len - idx; }\n+  unsigned int next_serial () { return serial++; }\n+\n+  HB_INTERNAL void add (hb_codepoint_t  codepoint,\n+                        unsigned int    cluster);\n+  HB_INTERNAL void add_info (const hb_glyph_info_t &glyph_info);\n+\n+  HB_INTERNAL void reverse_range (unsigned int start, unsigned int end);\n+  HB_INTERNAL void reverse ();\n+  HB_INTERNAL void reverse_clusters ();\n+  HB_INTERNAL void guess_segment_properties ();\n+\n+  HB_INTERNAL void swap_buffers ();\n+  HB_INTERNAL void remove_output ();\n+  HB_INTERNAL void clear_output ();\n+  HB_INTERNAL void clear_positions ();\n+\n+  HB_INTERNAL void replace_glyphs (unsigned int num_in,\n+                                   unsigned int num_out,\n+                                   const hb_codepoint_t *glyph_data);\n+\n+  void replace_glyph (hb_codepoint_t glyph_index)\n+  {\n+    if (unlikely (out_info != info || out_len != idx)) {\n+      if (unlikely (!make_room_for (1, 1))) return;\n+      out_info[out_len] = info[idx];\n+    }\n+    out_info[out_len].codepoint = glyph_index;\n+\n+    idx++;\n+    out_len++;\n+  }\n+  \/* Makes a copy of the glyph at idx to output and replace glyph_index *\/\n+  hb_glyph_info_t & output_glyph (hb_codepoint_t glyph_index)\n+  {\n+    if (unlikely (!make_room_for (0, 1))) return Crap(hb_glyph_info_t);\n+\n+    if (unlikely (idx == len && !out_len))\n+      return Crap(hb_glyph_info_t);\n+\n+    out_info[out_len] = idx < len ? info[idx] : out_info[out_len - 1];\n+    out_info[out_len].codepoint = glyph_index;\n+\n+    out_len++;\n+\n+    return out_info[out_len - 1];\n+  }\n+  void output_info (const hb_glyph_info_t &glyph_info)\n+  {\n+    if (unlikely (!make_room_for (0, 1))) return;\n+\n+    out_info[out_len] = glyph_info;\n+\n+    out_len++;\n+  }\n+  \/* Copies glyph at idx to output but doesn't advance idx *\/\n+  void copy_glyph ()\n+  {\n+    if (unlikely (!make_room_for (0, 1))) return;\n+\n+    out_info[out_len] = info[idx];\n+\n+    out_len++;\n+  }\n+  \/* Copies glyph at idx to output and advance idx.\n+   * If there's no output, just advance idx. *\/\n+  void\n+  next_glyph ()\n+  {\n+    if (have_output)\n+    {\n+      if (out_info != info || out_len != idx)\n+      {\n+        if (unlikely (!make_room_for (1, 1))) return;\n+        out_info[out_len] = info[idx];\n+      }\n+      out_len++;\n+    }\n+\n+    idx++;\n+  }\n+  \/* Copies n glyphs at idx to output and advance idx.\n+   * If there's no output, just advance idx. *\/\n+  void\n+  next_glyphs (unsigned int n)\n+  {\n+    if (have_output)\n+    {\n+      if (out_info != info || out_len != idx)\n+      {\n+        if (unlikely (!make_room_for (n, n))) return;\n+        memmove (out_info + out_len, info + idx, n * sizeof (out_info[0]));\n+      }\n+      out_len += n;\n+    }\n+\n+    idx += n;\n+  }\n+  \/* Advance idx without copying to output. *\/\n+  void skip_glyph () { idx++; }\n+  void reset_masks (hb_mask_t mask)\n+  {\n+    for (unsigned int j = 0; j < len; j++)\n+      info[j].mask = mask;\n+  }\n+  void add_masks (hb_mask_t mask)\n+  {\n+    for (unsigned int j = 0; j < len; j++)\n+      info[j].mask |= mask;\n+  }\n+  HB_INTERNAL void set_masks (hb_mask_t value, hb_mask_t mask,\n+                              unsigned int cluster_start, unsigned int cluster_end);\n+\n+  void merge_clusters (unsigned int start, unsigned int end)\n+  {\n+    if (end - start < 2)\n+      return;\n+    merge_clusters_impl (start, end);\n+  }\n+  HB_INTERNAL void merge_clusters_impl (unsigned int start, unsigned int end);\n+  HB_INTERNAL void merge_out_clusters (unsigned int start, unsigned int end);\n+  \/* Merge clusters for deleting current glyph, and skip it. *\/\n+  HB_INTERNAL void delete_glyph ();\n+\n+  void unsafe_to_break (unsigned int start,\n+                               unsigned int end)\n+  {\n+    if (end - start < 2)\n+      return;\n+    unsafe_to_break_impl (start, end);\n+  }\n+  HB_INTERNAL void unsafe_to_break_impl (unsigned int start, unsigned int end);\n+  HB_INTERNAL void unsafe_to_break_from_outbuffer (unsigned int start, unsigned int end);\n+\n+\n+  \/* Internal methods *\/\n+  HB_INTERNAL bool move_to (unsigned int i); \/* i is output-buffer index. *\/\n+\n+  HB_INTERNAL bool enlarge (unsigned int size);\n+\n+  bool ensure (unsigned int size)\n+  { return likely (!size || size < allocated) ? true : enlarge (size); }\n+\n+  bool ensure_inplace (unsigned int size)\n+  { return likely (!size || size < allocated); }\n+\n+  HB_INTERNAL bool make_room_for (unsigned int num_in, unsigned int num_out);\n+  HB_INTERNAL bool shift_forward (unsigned int count);\n+\n+  typedef long scratch_buffer_t;\n+  HB_INTERNAL scratch_buffer_t *get_scratch_buffer (unsigned int *size);\n+\n+  void clear_context (unsigned int side) { context_len[side] = 0; }\n+\n+  HB_INTERNAL void sort (unsigned int start, unsigned int end, int(*compar)(const hb_glyph_info_t *, const hb_glyph_info_t *));\n+\n+  bool messaging () { return unlikely (message_func); }\n+  bool message (hb_font_t *font, const char *fmt, ...) HB_PRINTF_FUNC(3, 4)\n+  {\n+    if (!messaging ())\n+      return true;\n+    va_list ap;\n+    va_start (ap, fmt);\n+    bool ret = message_impl (font, fmt, ap);\n+    va_end (ap);\n+    return ret;\n+  }\n+  HB_INTERNAL bool message_impl (hb_font_t *font, const char *fmt, va_list ap) HB_PRINTF_FUNC(3, 0);\n+\n+  static void\n+  set_cluster (hb_glyph_info_t &inf, unsigned int cluster, unsigned int mask = 0)\n+  {\n+    if (inf.cluster != cluster)\n+    {\n+      if (mask & HB_GLYPH_FLAG_UNSAFE_TO_BREAK)\n+        inf.mask |= HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n+      else\n+        inf.mask &= ~HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n+    }\n+    inf.cluster = cluster;\n+  }\n+\n+  int\n+  _unsafe_to_break_find_min_cluster (const hb_glyph_info_t *infos,\n+                                     unsigned int start, unsigned int end,\n+                                     unsigned int cluster) const\n+  {\n+    for (unsigned int i = start; i < end; i++)\n+      cluster = MIN<unsigned int> (cluster, infos[i].cluster);\n+    return cluster;\n+  }\n+  void\n+  _unsafe_to_break_set_mask (hb_glyph_info_t *infos,\n+                             unsigned int start, unsigned int end,\n+                             unsigned int cluster)\n+  {\n+    for (unsigned int i = start; i < end; i++)\n+      if (cluster != infos[i].cluster)\n+      {\n+        scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK;\n+        infos[i].mask |= HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n+      }\n+  }\n+\n+  void unsafe_to_break_all ()\n+  { unsafe_to_break_impl (0, len); }\n+  void safe_to_break_all ()\n+  {\n+    for (unsigned int i = 0; i < len; i++)\n+      info[i].mask &= ~HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n+  }\n+};\n+DECLARE_NULL_INSTANCE (hb_buffer_t);\n+\n+\n+\/* Loop over clusters. Duplicated in foreach_syllable(). *\/\n+#define foreach_cluster(buffer, start, end) \\\n+  for (unsigned int \\\n+       _count = buffer->len, \\\n+       start = 0, end = _count ? _next_cluster (buffer, 0) : 0; \\\n+       start < _count; \\\n+       start = end, end = _next_cluster (buffer, start))\n+\n+static inline unsigned int\n+_next_cluster (hb_buffer_t *buffer, unsigned int start)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+\n+  unsigned int cluster = info[start].cluster;\n+  while (++start < count && cluster == info[start].cluster)\n+    ;\n+\n+  return start;\n+}\n+\n+\n+#define HB_BUFFER_XALLOCATE_VAR(b, func, var) \\\n+  b->func (offsetof (hb_glyph_info_t, var) - offsetof(hb_glyph_info_t, var1), \\\n+           sizeof (b->info[0].var))\n+#define HB_BUFFER_ALLOCATE_VAR(b, var)          HB_BUFFER_XALLOCATE_VAR (b, allocate_var,   var ())\n+#define HB_BUFFER_DEALLOCATE_VAR(b, var)        HB_BUFFER_XALLOCATE_VAR (b, deallocate_var, var ())\n+#define HB_BUFFER_ASSERT_VAR(b, var)            HB_BUFFER_XALLOCATE_VAR (b, assert_var,     var ())\n+\n+\n+#endif \/* HB_BUFFER_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-buffer.hh","additions":439,"deletions":0,"binary":false,"changes":439,"status":"added"},{"patch":"@@ -0,0 +1,725 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+#ifndef HB_CFF_INTERP_COMMON_HH\n+#define HB_CFF_INTERP_COMMON_HH\n+\n+namespace CFF {\n+\n+using namespace OT;\n+\n+typedef unsigned int op_code_t;\n+\n+\n+\/* === Dict operators === *\/\n+\n+\/* One byte operators (0-31) *\/\n+#define OpCode_version            0 \/* CFF Top *\/\n+#define OpCode_Notice             1 \/* CFF Top *\/\n+#define OpCode_FullName           2 \/* CFF Top *\/\n+#define OpCode_FamilyName         3 \/* CFF Top *\/\n+#define OpCode_Weight             4 \/* CFF Top *\/\n+#define OpCode_FontBBox           5 \/* CFF Top *\/\n+#define OpCode_BlueValues         6 \/* CFF Private, CFF2 Private *\/\n+#define OpCode_OtherBlues         7 \/* CFF Private, CFF2 Private *\/\n+#define OpCode_FamilyBlues        8 \/* CFF Private, CFF2 Private *\/\n+#define OpCode_FamilyOtherBlues   9 \/* CFF Private, CFF2 Private *\/\n+#define OpCode_StdHW             10 \/* CFF Private, CFF2 Private *\/\n+#define OpCode_StdVW             11 \/* CFF Private, CFF2 Private *\/\n+#define OpCode_escape            12 \/* All. Shared with CS *\/\n+#define OpCode_UniqueID          13 \/* CFF Top *\/\n+#define OpCode_XUID              14 \/* CFF Top *\/\n+#define OpCode_charset           15 \/* CFF Top (0) *\/\n+#define OpCode_Encoding          16 \/* CFF Top (0) *\/\n+#define OpCode_CharStrings       17 \/* CFF Top, CFF2 Top *\/\n+#define OpCode_Private           18 \/* CFF Top, CFF2 FD *\/\n+#define OpCode_Subrs             19 \/* CFF Private, CFF2 Private *\/\n+#define OpCode_defaultWidthX     20 \/* CFF Private (0) *\/\n+#define OpCode_nominalWidthX     21 \/* CFF Private (0) *\/\n+#define OpCode_vsindexdict       22 \/* CFF2 Private\/CS *\/\n+#define OpCode_blenddict         23 \/* CFF2 Private\/CS *\/\n+#define OpCode_vstore            24 \/* CFF2 Top *\/\n+#define OpCode_reserved25        25\n+#define OpCode_reserved26        26\n+#define OpCode_reserved27        27\n+\n+\/* Numbers *\/\n+#define OpCode_shortint          28 \/* 16-bit integer, All *\/\n+#define OpCode_longintdict       29 \/* 32-bit integer, All *\/\n+#define OpCode_BCD               30 \/* Real number, CFF2 Top\/FD *\/\n+#define OpCode_reserved31        31\n+\n+\/* 1-byte integers *\/\n+#define OpCode_OneByteIntFirst   32 \/* All. beginning of the range of first byte ints *\/\n+#define OpCode_OneByteIntLast   246 \/* All. ending of the range of first byte int *\/\n+\n+\/* 2-byte integers *\/\n+#define OpCode_TwoBytePosInt0   247 \/* All. first byte of two byte positive int (+108 to +1131) *\/\n+#define OpCode_TwoBytePosInt1   248\n+#define OpCode_TwoBytePosInt2   249\n+#define OpCode_TwoBytePosInt3   250\n+\n+#define OpCode_TwoByteNegInt0   251 \/* All. first byte of two byte negative int (-1131 to -108) *\/\n+#define OpCode_TwoByteNegInt1   252\n+#define OpCode_TwoByteNegInt2   253\n+#define OpCode_TwoByteNegInt3   254\n+\n+\/* Two byte escape operators 12, (0-41) *\/\n+#define OpCode_ESC_Base         256\n+#define Make_OpCode_ESC(byte2)  ((op_code_t)(OpCode_ESC_Base + (byte2)))\n+\n+inline op_code_t Unmake_OpCode_ESC (op_code_t op)  { return (op_code_t)(op - OpCode_ESC_Base); }\n+inline bool Is_OpCode_ESC (op_code_t op) { return op >= OpCode_ESC_Base; }\n+inline unsigned int OpCode_Size (op_code_t op) { return Is_OpCode_ESC (op) ? 2: 1; }\n+\n+#define OpCode_Copyright        Make_OpCode_ESC(0) \/* CFF Top *\/\n+#define OpCode_isFixedPitch     Make_OpCode_ESC(1) \/* CFF Top (false) *\/\n+#define OpCode_ItalicAngle      Make_OpCode_ESC(2) \/* CFF Top (0) *\/\n+#define OpCode_UnderlinePosition Make_OpCode_ESC(3) \/* CFF Top (-100) *\/\n+#define OpCode_UnderlineThickness Make_OpCode_ESC(4) \/* CFF Top (50) *\/\n+#define OpCode_PaintType        Make_OpCode_ESC(5) \/* CFF Top (0) *\/\n+#define OpCode_CharstringType   Make_OpCode_ESC(6) \/* CFF Top (2) *\/\n+#define OpCode_FontMatrix       Make_OpCode_ESC(7) \/* CFF Top, CFF2 Top (.001 0 0 .001 0 0)*\/\n+#define OpCode_StrokeWidth      Make_OpCode_ESC(8) \/* CFF Top (0) *\/\n+#define OpCode_BlueScale        Make_OpCode_ESC(9) \/* CFF Private, CFF2 Private (0.039625) *\/\n+#define OpCode_BlueShift        Make_OpCode_ESC(10) \/* CFF Private, CFF2 Private (7) *\/\n+#define OpCode_BlueFuzz         Make_OpCode_ESC(11) \/* CFF Private, CFF2 Private (1) *\/\n+#define OpCode_StemSnapH        Make_OpCode_ESC(12) \/* CFF Private, CFF2 Private *\/\n+#define OpCode_StemSnapV        Make_OpCode_ESC(13) \/* CFF Private, CFF2 Private *\/\n+#define OpCode_ForceBold        Make_OpCode_ESC(14) \/* CFF Private (false) *\/\n+#define OpCode_reservedESC15    Make_OpCode_ESC(15)\n+#define OpCode_reservedESC16    Make_OpCode_ESC(16)\n+#define OpCode_LanguageGroup    Make_OpCode_ESC(17) \/* CFF Private, CFF2 Private (0) *\/\n+#define OpCode_ExpansionFactor  Make_OpCode_ESC(18) \/* CFF Private, CFF2 Private (0.06) *\/\n+#define OpCode_initialRandomSeed Make_OpCode_ESC(19) \/* CFF Private (0) *\/\n+#define OpCode_SyntheticBase    Make_OpCode_ESC(20) \/* CFF Top *\/\n+#define OpCode_PostScript       Make_OpCode_ESC(21) \/* CFF Top *\/\n+#define OpCode_BaseFontName     Make_OpCode_ESC(22) \/* CFF Top *\/\n+#define OpCode_BaseFontBlend    Make_OpCode_ESC(23) \/* CFF Top *\/\n+#define OpCode_reservedESC24    Make_OpCode_ESC(24)\n+#define OpCode_reservedESC25    Make_OpCode_ESC(25)\n+#define OpCode_reservedESC26    Make_OpCode_ESC(26)\n+#define OpCode_reservedESC27    Make_OpCode_ESC(27)\n+#define OpCode_reservedESC28    Make_OpCode_ESC(28)\n+#define OpCode_reservedESC29    Make_OpCode_ESC(29)\n+#define OpCode_ROS              Make_OpCode_ESC(30) \/* CFF Top_CID *\/\n+#define OpCode_CIDFontVersion   Make_OpCode_ESC(31) \/* CFF Top_CID (0) *\/\n+#define OpCode_CIDFontRevision  Make_OpCode_ESC(32) \/* CFF Top_CID (0) *\/\n+#define OpCode_CIDFontType      Make_OpCode_ESC(33) \/* CFF Top_CID (0) *\/\n+#define OpCode_CIDCount         Make_OpCode_ESC(34) \/* CFF Top_CID (8720) *\/\n+#define OpCode_UIDBase          Make_OpCode_ESC(35) \/* CFF Top_CID *\/\n+#define OpCode_FDArray          Make_OpCode_ESC(36) \/* CFF Top_CID, CFF2 Top *\/\n+#define OpCode_FDSelect         Make_OpCode_ESC(37) \/* CFF Top_CID, CFF2 Top *\/\n+#define OpCode_FontName         Make_OpCode_ESC(38) \/* CFF Top_CID *\/\n+\n+\n+\/* === CharString operators === *\/\n+\n+#define OpCode_hstem              1 \/* CFF, CFF2 *\/\n+#define OpCode_Reserved2          2\n+#define OpCode_vstem              3 \/* CFF, CFF2 *\/\n+#define OpCode_vmoveto            4 \/* CFF, CFF2 *\/\n+#define OpCode_rlineto            5 \/* CFF, CFF2 *\/\n+#define OpCode_hlineto            6 \/* CFF, CFF2 *\/\n+#define OpCode_vlineto            7 \/* CFF, CFF2 *\/\n+#define OpCode_rrcurveto          8 \/* CFF, CFF2 *\/\n+#define OpCode_Reserved9          9\n+#define OpCode_callsubr          10 \/* CFF, CFF2 *\/\n+#define OpCode_return            11 \/* CFF *\/\n+\/\/#define OpCode_escape          12 \/* CFF, CFF2 *\/\n+#define OpCode_Reserved13        13\n+#define OpCode_endchar           14 \/* CFF *\/\n+#define OpCode_vsindexcs         15 \/* CFF2 *\/\n+#define OpCode_blendcs           16 \/* CFF2 *\/\n+#define OpCode_Reserved17        17\n+#define OpCode_hstemhm           18 \/* CFF, CFF2 *\/\n+#define OpCode_hintmask          19 \/* CFF, CFF2 *\/\n+#define OpCode_cntrmask          20 \/* CFF, CFF2 *\/\n+#define OpCode_rmoveto           21 \/* CFF, CFF2 *\/\n+#define OpCode_hmoveto           22 \/* CFF, CFF2 *\/\n+#define OpCode_vstemhm           23 \/* CFF, CFF2 *\/\n+#define OpCode_rcurveline        24 \/* CFF, CFF2 *\/\n+#define OpCode_rlinecurve        25 \/* CFF, CFF2 *\/\n+#define OpCode_vvcurveto         26 \/* CFF, CFF2 *\/\n+#define OpCode_hhcurveto         27 \/* CFF, CFF2 *\/\n+\/\/#define OpCode_shortint        28 \/* CFF, CFF2 *\/\n+#define OpCode_callgsubr         29 \/* CFF, CFF2 *\/\n+#define OpCode_vhcurveto         30 \/* CFF, CFF2 *\/\n+#define OpCode_hvcurveto         31 \/* CFF, CFF2 *\/\n+\n+#define OpCode_fixedcs          255 \/* 32-bit fixed *\/\n+\n+\/* Two byte escape operators 12, (0-41) *\/\n+#define OpCode_dotsection       Make_OpCode_ESC(0) \/* CFF (obsoleted) *\/\n+#define OpCode_ReservedESC1     Make_OpCode_ESC(1)\n+#define OpCode_ReservedESC2     Make_OpCode_ESC(2)\n+#define OpCode_and              Make_OpCode_ESC(3) \/* CFF *\/\n+#define OpCode_or               Make_OpCode_ESC(4) \/* CFF *\/\n+#define OpCode_not              Make_OpCode_ESC(5) \/* CFF *\/\n+#define OpCode_ReservedESC6     Make_OpCode_ESC(6)\n+#define OpCode_ReservedESC7     Make_OpCode_ESC(7)\n+#define OpCode_ReservedESC8     Make_OpCode_ESC(8)\n+#define OpCode_abs              Make_OpCode_ESC(9) \/* CFF *\/\n+#define OpCode_add              Make_OpCode_ESC(10) \/* CFF *\/\n+#define OpCode_sub              Make_OpCode_ESC(11) \/* CFF *\/\n+#define OpCode_div              Make_OpCode_ESC(12) \/* CFF *\/\n+#define OpCode_ReservedESC13    Make_OpCode_ESC(13)\n+#define OpCode_neg              Make_OpCode_ESC(14) \/* CFF *\/\n+#define OpCode_eq               Make_OpCode_ESC(15) \/* CFF *\/\n+#define OpCode_ReservedESC16    Make_OpCode_ESC(16)\n+#define OpCode_ReservedESC17    Make_OpCode_ESC(17)\n+#define OpCode_drop             Make_OpCode_ESC(18) \/* CFF *\/\n+#define OpCode_ReservedESC19    Make_OpCode_ESC(19)\n+#define OpCode_put              Make_OpCode_ESC(20) \/* CFF *\/\n+#define OpCode_get              Make_OpCode_ESC(21) \/* CFF *\/\n+#define OpCode_ifelse           Make_OpCode_ESC(22) \/* CFF *\/\n+#define OpCode_random           Make_OpCode_ESC(23) \/* CFF *\/\n+#define OpCode_mul              Make_OpCode_ESC(24) \/* CFF *\/\n+\/\/#define OpCode_reservedESC25  Make_OpCode_ESC(25)\n+#define OpCode_sqrt             Make_OpCode_ESC(26) \/* CFF *\/\n+#define OpCode_dup              Make_OpCode_ESC(27) \/* CFF *\/\n+#define OpCode_exch             Make_OpCode_ESC(28) \/* CFF *\/\n+#define OpCode_index            Make_OpCode_ESC(29) \/* CFF *\/\n+#define OpCode_roll             Make_OpCode_ESC(30) \/* CFF *\/\n+#define OpCode_reservedESC31    Make_OpCode_ESC(31)\n+#define OpCode_reservedESC32    Make_OpCode_ESC(32)\n+#define OpCode_reservedESC33    Make_OpCode_ESC(33)\n+#define OpCode_hflex            Make_OpCode_ESC(34) \/* CFF, CFF2 *\/\n+#define OpCode_flex             Make_OpCode_ESC(35) \/* CFF, CFF2 *\/\n+#define OpCode_hflex1           Make_OpCode_ESC(36) \/* CFF, CFF2 *\/\n+#define OpCode_flex1            Make_OpCode_ESC(37) \/* CFF, CFF2 *\/\n+\n+\n+#define OpCode_Invalid          0xFFFFu\n+\n+\n+struct number_t\n+{\n+  void init () { set_real (0.0); }\n+  void fini () {}\n+\n+  void set_int (int v)       { value = (double) v; }\n+  int to_int () const        { return (int) value; }\n+\n+  void set_fixed (int32_t v) { value = v \/ 65536.0; }\n+  int32_t to_fixed () const  { return (int32_t) (value * 65536.0); }\n+\n+  void set_real (double v)       { value = v; }\n+  double to_real () const    { return value; }\n+\n+  int ceil () const          { return (int) ::ceil (value); }\n+  int floor () const         { return (int) ::floor (value); }\n+\n+  bool in_int_range () const\n+  { return ((double) (int16_t) to_int () == value); }\n+\n+  bool operator > (const number_t &n) const\n+  { return value > n.to_real (); }\n+\n+  bool operator < (const number_t &n) const\n+  { return n > *this; }\n+\n+  bool operator >= (const number_t &n) const\n+  { return !(*this < n); }\n+\n+  bool operator <= (const number_t &n) const\n+  { return !(*this > n); }\n+\n+  const number_t &operator += (const number_t &n)\n+  {\n+    set_real (to_real () + n.to_real ());\n+\n+    return *this;\n+  }\n+\n+  protected:\n+  double  value;\n+};\n+\n+\/* byte string *\/\n+struct UnsizedByteStr : UnsizedArrayOf <HBUINT8>\n+{\n+  \/\/ encode 2-byte int (Dict\/CharString) or 4-byte int (Dict)\n+  template <typename INTTYPE, int minVal, int maxVal>\n+  static bool serialize_int (hb_serialize_context_t *c, op_code_t intOp, int value)\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (unlikely ((value < minVal || value > maxVal)))\n+      return_trace (false);\n+\n+    HBUINT8 *p = c->allocate_size<HBUINT8> (1);\n+    if (unlikely (p == nullptr)) return_trace (false);\n+    p->set (intOp);\n+\n+    INTTYPE *ip = c->allocate_size<INTTYPE> (INTTYPE::static_size);\n+    if (unlikely (ip == nullptr)) return_trace (false);\n+    ip->set ((unsigned int)value);\n+\n+    return_trace (true);\n+  }\n+\n+  static bool serialize_int4 (hb_serialize_context_t *c, int value)\n+  { return serialize_int<HBUINT32, 0, 0x7FFFFFFF> (c, OpCode_longintdict, value); }\n+\n+  static bool serialize_int2 (hb_serialize_context_t *c, int value)\n+  { return serialize_int<HBUINT16, 0, 0x7FFF> (c, OpCode_shortint, value); }\n+\n+  \/* Defining null_size allows a Null object may be created. Should be safe because:\n+   * A descendent struct Dict uses a Null pointer to indicate a missing table,\n+   * checked before access.\n+   * byte_str_t, a wrapper struct pairing a byte pointer along with its length, always\n+   * checks the length before access. A Null pointer is used as the initial pointer\n+   * along with zero length by the default ctor.\n+   *\/\n+  DEFINE_SIZE_MIN(0);\n+};\n+\n+\/* Holder of a section of byte string within a CFFIndex entry *\/\n+struct byte_str_t : hb_ubytes_t\n+{\n+  byte_str_t ()\n+    : hb_ubytes_t () {}\n+  byte_str_t (const UnsizedByteStr& s, unsigned int l)\n+    : hb_ubytes_t ((const unsigned char*)&s, l) {}\n+  byte_str_t (const unsigned char *s, unsigned int l)\n+    : hb_ubytes_t (s, l) {}\n+  byte_str_t (const hb_ubytes_t &ub)    \/* conversion from hb_ubytes_t *\/\n+    : hb_ubytes_t (ub) {}\n+\n+  \/* sub-string *\/\n+  byte_str_t sub_str (unsigned int offset, unsigned int len_) const\n+  { return byte_str_t (hb_ubytes_t::sub_array (offset, len_)); }\n+\n+  bool check_limit (unsigned int offset, unsigned int count) const\n+  { return (offset + count <= length); }\n+};\n+\n+\/* A byte string associated with the current offset and an error condition *\/\n+struct byte_str_ref_t\n+{\n+  byte_str_ref_t ()\n+  { init (); }\n+\n+  void init ()\n+  {\n+    str = byte_str_t ();\n+    offset = 0;\n+    error = false;\n+  }\n+\n+  void fini () {}\n+\n+  byte_str_ref_t (const byte_str_t &str_, unsigned int offset_ = 0)\n+    : str (str_), offset (offset_), error (false) {}\n+\n+  void reset (const byte_str_t &str_, unsigned int offset_ = 0)\n+  {\n+    str = str_;\n+    offset = offset_;\n+    error = false;\n+  }\n+\n+  const unsigned char& operator [] (int i) {\n+    if (unlikely ((unsigned int)(offset + i) >= str.length))\n+    {\n+      set_error ();\n+      return Null(unsigned char);\n+    }\n+    else\n+      return str[offset + i];\n+  }\n+\n+  \/* Conversion to byte_str_t *\/\n+  operator byte_str_t () const { return str.sub_str (offset, str.length - offset); }\n+\n+  byte_str_t sub_str (unsigned int offset_, unsigned int len_) const\n+  { return str.sub_str (offset_, len_); }\n+\n+  bool avail (unsigned int count=1) const\n+  {\n+    return (!in_error () && str.check_limit (offset, count));\n+  }\n+  void inc (unsigned int count=1)\n+  {\n+    if (likely (!in_error () && (offset <= str.length) && (offset + count <= str.length)))\n+    {\n+      offset += count;\n+    }\n+    else\n+    {\n+      offset = str.length;\n+      set_error ();\n+    }\n+  }\n+\n+  void set_error ()      { error = true; }\n+  bool in_error () const { return error; }\n+\n+  byte_str_t       str;\n+  unsigned int  offset; \/* beginning of the sub-string within str *\/\n+\n+  protected:\n+  bool    error;\n+};\n+\n+typedef hb_vector_t<byte_str_t> byte_str_array_t;\n+\n+\/* stack *\/\n+template <typename ELEM, int LIMIT>\n+struct stack_t\n+{\n+  void init ()\n+  {\n+    error = false;\n+    count = 0;\n+    elements.init ();\n+    elements.resize (kSizeLimit);\n+    for (unsigned int i = 0; i < elements.length; i++)\n+      elements[i].init ();\n+  }\n+\n+  void fini ()\n+  {\n+    elements.fini_deep ();\n+  }\n+\n+  ELEM& operator [] (unsigned int i)\n+  {\n+    if (unlikely (i >= count)) set_error ();\n+    return elements[i];\n+  }\n+\n+  void push (const ELEM &v)\n+  {\n+    if (likely (count < elements.length))\n+      elements[count++] = v;\n+    else\n+      set_error ();\n+  }\n+\n+  ELEM &push ()\n+  {\n+    if (likely (count < elements.length))\n+      return elements[count++];\n+    else\n+    {\n+      set_error ();\n+      return Crap(ELEM);\n+    }\n+  }\n+\n+  ELEM& pop ()\n+  {\n+    if (likely (count > 0))\n+      return elements[--count];\n+    else\n+    {\n+      set_error ();\n+      return Crap(ELEM);\n+    }\n+  }\n+\n+  void pop (unsigned int n)\n+  {\n+    if (likely (count >= n))\n+      count -= n;\n+    else\n+      set_error ();\n+  }\n+\n+  const ELEM& peek ()\n+  {\n+    if (likely (count > 0))\n+      return elements[count-1];\n+    else\n+    {\n+      set_error ();\n+      return Null(ELEM);\n+    }\n+  }\n+\n+  void unpop ()\n+  {\n+    if (likely (count < elements.length))\n+      count++;\n+    else\n+      set_error ();\n+  }\n+\n+  void clear () { count = 0; }\n+\n+  bool in_error () const { return (error || elements.in_error ()); }\n+  void set_error ()      { error = true; }\n+\n+  unsigned int get_count () const { return count; }\n+  bool is_empty () const { return count == 0; }\n+\n+  static constexpr unsigned kSizeLimit = LIMIT;\n+\n+  protected:\n+  bool error;\n+  unsigned int count;\n+  hb_vector_t<ELEM> elements;\n+};\n+\n+\/* argument stack *\/\n+template <typename ARG=number_t>\n+struct arg_stack_t : stack_t<ARG, 513>\n+{\n+  void push_int (int v)\n+  {\n+    ARG &n = S::push ();\n+    n.set_int (v);\n+  }\n+\n+  void push_fixed (int32_t v)\n+  {\n+    ARG &n = S::push ();\n+    n.set_fixed (v);\n+  }\n+\n+  void push_real (double v)\n+  {\n+    ARG &n = S::push ();\n+    n.set_real (v);\n+  }\n+\n+  ARG& pop_num () { return this->pop (); }\n+\n+  int pop_int ()  { return this->pop ().to_int (); }\n+\n+  unsigned int pop_uint ()\n+  {\n+    int i = pop_int ();\n+    if (unlikely (i < 0))\n+    {\n+      i = 0;\n+      S::set_error ();\n+    }\n+    return (unsigned)i;\n+  }\n+\n+  void push_longint_from_substr (byte_str_ref_t& str_ref)\n+  {\n+    push_int ((str_ref[0] << 24) | (str_ref[1] << 16) | (str_ref[2] << 8) | (str_ref[3]));\n+    str_ref.inc (4);\n+  }\n+\n+  bool push_fixed_from_substr (byte_str_ref_t& str_ref)\n+  {\n+    if (unlikely (!str_ref.avail (4)))\n+      return false;\n+    push_fixed ((int32_t)*(const HBUINT32*)&str_ref[0]);\n+    str_ref.inc (4);\n+    return true;\n+  }\n+\n+  hb_array_t<const ARG> get_subarray (unsigned int start) const\n+  {\n+    return S::elements.sub_array (start);\n+  }\n+\n+  private:\n+  typedef stack_t<ARG, 513> S;\n+};\n+\n+\/* an operator prefixed by its operands in a byte string *\/\n+struct op_str_t\n+{\n+  void init () {}\n+  void fini () {}\n+\n+  op_code_t  op;\n+  byte_str_t str;\n+};\n+\n+\/* base of OP_SERIALIZER *\/\n+struct op_serializer_t\n+{\n+  protected:\n+  bool copy_opstr (hb_serialize_context_t *c, const op_str_t& opstr) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    HBUINT8 *d = c->allocate_size<HBUINT8> (opstr.str.length);\n+    if (unlikely (d == nullptr)) return_trace (false);\n+    memcpy (d, &opstr.str[0], opstr.str.length);\n+    return_trace (true);\n+  }\n+};\n+\n+template <typename VAL>\n+struct parsed_values_t\n+{\n+  void init ()\n+  {\n+    opStart = 0;\n+    values.init ();\n+  }\n+  void fini () { values.fini_deep (); }\n+\n+  void add_op (op_code_t op, const byte_str_ref_t& str_ref = byte_str_ref_t ())\n+  {\n+    VAL *val = values.push ();\n+    val->op = op;\n+    val->str = str_ref.str.sub_str (opStart, str_ref.offset - opStart);\n+    opStart = str_ref.offset;\n+  }\n+\n+  void add_op (op_code_t op, const byte_str_ref_t& str_ref, const VAL &v)\n+  {\n+    VAL *val = values.push (v);\n+    val->op = op;\n+    val->str = str_ref.sub_str ( opStart, str_ref.offset - opStart);\n+    opStart = str_ref.offset;\n+  }\n+\n+  bool has_op (op_code_t op) const\n+  {\n+    for (unsigned int i = 0; i < get_count (); i++)\n+      if (get_value (i).op == op) return true;\n+    return false;\n+  }\n+\n+  unsigned get_count () const { return values.length; }\n+  const VAL &get_value (unsigned int i) const { return values[i]; }\n+  const VAL &operator [] (unsigned int i) const { return get_value (i); }\n+\n+  unsigned int       opStart;\n+  hb_vector_t<VAL>   values;\n+};\n+\n+template <typename ARG=number_t>\n+struct interp_env_t\n+{\n+  void init (const byte_str_t &str_)\n+  {\n+    str_ref.reset (str_);\n+    argStack.init ();\n+    error = false;\n+  }\n+  void fini () { argStack.fini (); }\n+\n+  bool in_error () const\n+  { return error || str_ref.in_error () || argStack.in_error (); }\n+\n+  void set_error () { error = true; }\n+\n+  op_code_t fetch_op ()\n+  {\n+    op_code_t  op = OpCode_Invalid;\n+    if (unlikely (!str_ref.avail ()))\n+      return OpCode_Invalid;\n+    op = (op_code_t)(unsigned char)str_ref[0];\n+    if (op == OpCode_escape) {\n+      if (unlikely (!str_ref.avail ()))\n+        return OpCode_Invalid;\n+      op = Make_OpCode_ESC(str_ref[1]);\n+      str_ref.inc ();\n+    }\n+    str_ref.inc ();\n+    return op;\n+  }\n+\n+  const ARG& eval_arg (unsigned int i)\n+  {\n+    return argStack[i];\n+  }\n+\n+  ARG& pop_arg ()\n+  {\n+    return argStack.pop ();\n+  }\n+\n+  void pop_n_args (unsigned int n)\n+  {\n+    argStack.pop (n);\n+  }\n+\n+  void clear_args ()\n+  {\n+    pop_n_args (argStack.get_count ());\n+  }\n+\n+  byte_str_ref_t    str_ref;\n+  arg_stack_t<ARG> argStack;\n+  protected:\n+  bool    error;\n+};\n+\n+typedef interp_env_t<> num_interp_env_t;\n+\n+template <typename ARG=number_t>\n+struct opset_t\n+{\n+  static void process_op (op_code_t op, interp_env_t<ARG>& env)\n+  {\n+    switch (op) {\n+      case OpCode_shortint:\n+        env.argStack.push_int ((int16_t)((env.str_ref[0] << 8) | env.str_ref[1]));\n+        env.str_ref.inc (2);\n+        break;\n+\n+      case OpCode_TwoBytePosInt0: case OpCode_TwoBytePosInt1:\n+      case OpCode_TwoBytePosInt2: case OpCode_TwoBytePosInt3:\n+        env.argStack.push_int ((int16_t)((op - OpCode_TwoBytePosInt0) * 256 + env.str_ref[0] + 108));\n+        env.str_ref.inc ();\n+        break;\n+\n+      case OpCode_TwoByteNegInt0: case OpCode_TwoByteNegInt1:\n+      case OpCode_TwoByteNegInt2: case OpCode_TwoByteNegInt3:\n+        env.argStack.push_int ((int16_t)(-(op - OpCode_TwoByteNegInt0) * 256 - env.str_ref[0] - 108));\n+        env.str_ref.inc ();\n+        break;\n+\n+      default:\n+        \/* 1-byte integer *\/\n+        if (likely ((OpCode_OneByteIntFirst <= op) && (op <= OpCode_OneByteIntLast)))\n+        {\n+          env.argStack.push_int ((int)op - 139);\n+        } else {\n+          \/* invalid unknown operator *\/\n+          env.clear_args ();\n+          env.set_error ();\n+        }\n+        break;\n+    }\n+  }\n+};\n+\n+template <typename ENV>\n+struct interpreter_t {\n+\n+  ~interpreter_t() { fini (); }\n+\n+  void fini () { env.fini (); }\n+\n+  ENV env;\n+};\n+\n+} \/* namespace CFF *\/\n+\n+#endif \/* HB_CFF_INTERP_COMMON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-cff-interp-common.hh","additions":725,"deletions":0,"binary":false,"changes":725,"status":"added"},{"patch":"@@ -0,0 +1,905 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+#ifndef HB_CFF_INTERP_CS_COMMON_HH\n+#define HB_CFF_INTERP_CS_COMMON_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-cff-interp-common.hh\"\n+\n+namespace CFF {\n+\n+using namespace OT;\n+\n+enum cs_type_t {\n+  CSType_CharString,\n+  CSType_GlobalSubr,\n+  CSType_LocalSubr\n+};\n+\n+struct call_context_t\n+{\n+  void init (const byte_str_ref_t substr_=byte_str_ref_t (), cs_type_t type_=CSType_CharString, unsigned int subr_num_=0)\n+  {\n+    str_ref = substr_;\n+    type = type_;\n+    subr_num = subr_num_;\n+  }\n+\n+  void fini () {}\n+\n+  byte_str_ref_t  str_ref;\n+  cs_type_t       type;\n+  unsigned int    subr_num;\n+};\n+\n+\/* call stack *\/\n+const unsigned int kMaxCallLimit = 10;\n+struct call_stack_t : stack_t<call_context_t, kMaxCallLimit> {};\n+\n+template <typename SUBRS>\n+struct biased_subrs_t\n+{\n+  void init (const SUBRS &subrs_)\n+  {\n+    subrs = &subrs_;\n+    unsigned int  nSubrs = get_count ();\n+    if (nSubrs < 1240)\n+      bias = 107;\n+    else if (nSubrs < 33900)\n+      bias = 1131;\n+    else\n+      bias = 32768;\n+  }\n+\n+  void fini () {}\n+\n+  unsigned int get_count () const { return (subrs == nullptr)? 0: subrs->count; }\n+  unsigned int get_bias () const { return bias; }\n+\n+  byte_str_t operator [] (unsigned int index) const\n+  {\n+    if (unlikely ((subrs == nullptr) || index >= subrs->count))\n+      return Null(byte_str_t);\n+    else\n+      return (*subrs)[index];\n+  }\n+\n+  protected:\n+  unsigned int  bias;\n+  const SUBRS   *subrs;\n+};\n+\n+struct point_t\n+{\n+  void init ()\n+  {\n+    x.init ();\n+    y.init ();\n+  }\n+\n+  void set_int (int _x, int _y)\n+  {\n+    x.set_int (_x);\n+    y.set_int (_y);\n+  }\n+\n+  void move_x (const number_t &dx) { x += dx; }\n+  void move_y (const number_t &dy) { y += dy; }\n+  void move (const number_t &dx, const number_t &dy) { move_x (dx); move_y (dy); }\n+  void move (const point_t &d) { move_x (d.x); move_y (d.y); }\n+\n+  number_t  x;\n+  number_t  y;\n+};\n+\n+template <typename ARG, typename SUBRS>\n+struct cs_interp_env_t : interp_env_t<ARG>\n+{\n+  void init (const byte_str_t &str, const SUBRS &globalSubrs_, const SUBRS &localSubrs_)\n+  {\n+    interp_env_t<ARG>::init (str);\n+\n+    context.init (str, CSType_CharString);\n+    seen_moveto = true;\n+    seen_hintmask = false;\n+    hstem_count = 0;\n+    vstem_count = 0;\n+    hintmask_size = 0;\n+    pt.init ();\n+    callStack.init ();\n+    globalSubrs.init (globalSubrs_);\n+    localSubrs.init (localSubrs_);\n+  }\n+  void fini ()\n+  {\n+    interp_env_t<ARG>::fini ();\n+\n+    callStack.fini ();\n+    globalSubrs.fini ();\n+    localSubrs.fini ();\n+  }\n+\n+  bool in_error () const\n+  {\n+    return callStack.in_error () || SUPER::in_error ();\n+  }\n+\n+  bool popSubrNum (const biased_subrs_t<SUBRS>& biasedSubrs, unsigned int &subr_num)\n+  {\n+    int n = SUPER::argStack.pop_int ();\n+    n += biasedSubrs.get_bias ();\n+    if (unlikely ((n < 0) || ((unsigned int)n >= biasedSubrs.get_count ())))\n+      return false;\n+\n+    subr_num = (unsigned int)n;\n+    return true;\n+  }\n+\n+  void callSubr (const biased_subrs_t<SUBRS>& biasedSubrs, cs_type_t type)\n+  {\n+    unsigned int subr_num;\n+\n+    if (unlikely (!popSubrNum (biasedSubrs, subr_num)\n+                 || callStack.get_count () >= kMaxCallLimit))\n+    {\n+      SUPER::set_error ();\n+      return;\n+    }\n+    context.str_ref = SUPER::str_ref;\n+    callStack.push (context);\n+\n+    context.init ( biasedSubrs[subr_num], type, subr_num);\n+    SUPER::str_ref = context.str_ref;\n+  }\n+\n+  void returnFromSubr ()\n+  {\n+    if (unlikely (SUPER::str_ref.in_error ()))\n+      SUPER::set_error ();\n+    context = callStack.pop ();\n+    SUPER::str_ref = context.str_ref;\n+  }\n+\n+  void determine_hintmask_size ()\n+  {\n+    if (!seen_hintmask)\n+    {\n+      vstem_count += SUPER::argStack.get_count() \/ 2;\n+      hintmask_size = (hstem_count + vstem_count + 7) >> 3;\n+      seen_hintmask = true;\n+    }\n+  }\n+\n+  void set_endchar (bool endchar_flag_) { endchar_flag = endchar_flag_; }\n+  bool is_endchar () const { return endchar_flag; }\n+\n+  const number_t &get_x () const { return pt.x; }\n+  const number_t &get_y () const { return pt.y; }\n+  const point_t &get_pt () const { return pt; }\n+\n+  void moveto (const point_t &pt_ ) { pt = pt_; }\n+\n+  public:\n+  call_context_t   context;\n+  bool    endchar_flag;\n+  bool    seen_moveto;\n+  bool    seen_hintmask;\n+\n+  unsigned int  hstem_count;\n+  unsigned int  vstem_count;\n+  unsigned int  hintmask_size;\n+  call_stack_t  callStack;\n+  biased_subrs_t<SUBRS>   globalSubrs;\n+  biased_subrs_t<SUBRS>   localSubrs;\n+\n+  private:\n+  point_t        pt;\n+\n+  typedef interp_env_t<ARG> SUPER;\n+};\n+\n+template <typename ENV, typename PARAM>\n+struct path_procs_null_t\n+{\n+  static void rmoveto (ENV &env, PARAM& param) {}\n+  static void hmoveto (ENV &env, PARAM& param) {}\n+  static void vmoveto (ENV &env, PARAM& param) {}\n+  static void rlineto (ENV &env, PARAM& param) {}\n+  static void hlineto (ENV &env, PARAM& param) {}\n+  static void vlineto (ENV &env, PARAM& param) {}\n+  static void rrcurveto (ENV &env, PARAM& param) {}\n+  static void rcurveline (ENV &env, PARAM& param) {}\n+  static void rlinecurve (ENV &env, PARAM& param) {}\n+  static void vvcurveto (ENV &env, PARAM& param) {}\n+  static void hhcurveto (ENV &env, PARAM& param) {}\n+  static void vhcurveto (ENV &env, PARAM& param) {}\n+  static void hvcurveto (ENV &env, PARAM& param) {}\n+  static void moveto (ENV &env, PARAM& param, const point_t &pt) {}\n+  static void line (ENV &env, PARAM& param, const point_t &pt1) {}\n+  static void curve (ENV &env, PARAM& param, const point_t &pt1, const point_t &pt2, const point_t &pt3) {}\n+  static void hflex (ENV &env, PARAM& param) {}\n+  static void flex (ENV &env, PARAM& param) {}\n+  static void hflex1 (ENV &env, PARAM& param) {}\n+  static void flex1 (ENV &env, PARAM& param) {}\n+};\n+\n+template <typename ARG, typename OPSET, typename ENV, typename PARAM, typename PATH=path_procs_null_t<ENV, PARAM> >\n+struct cs_opset_t : opset_t<ARG>\n+{\n+  static void process_op (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    switch (op) {\n+\n+      case OpCode_return:\n+        env.returnFromSubr ();\n+        break;\n+      case OpCode_endchar:\n+        OPSET::check_width (op, env, param);\n+        env.set_endchar (true);\n+        OPSET::flush_args_and_op (op, env, param);\n+        break;\n+\n+      case OpCode_fixedcs:\n+        env.argStack.push_fixed_from_substr (env.str_ref);\n+        break;\n+\n+      case OpCode_callsubr:\n+        env.callSubr (env.localSubrs, CSType_LocalSubr);\n+        break;\n+\n+      case OpCode_callgsubr:\n+        env.callSubr (env.globalSubrs, CSType_GlobalSubr);\n+        break;\n+\n+      case OpCode_hstem:\n+      case OpCode_hstemhm:\n+        OPSET::check_width (op, env, param);\n+        OPSET::process_hstem (op, env, param);\n+        break;\n+      case OpCode_vstem:\n+      case OpCode_vstemhm:\n+        OPSET::check_width (op, env, param);\n+        OPSET::process_vstem (op, env, param);\n+        break;\n+      case OpCode_hintmask:\n+      case OpCode_cntrmask:\n+        OPSET::check_width (op, env, param);\n+        OPSET::process_hintmask (op, env, param);\n+        break;\n+      case OpCode_rmoveto:\n+        OPSET::check_width (op, env, param);\n+        PATH::rmoveto (env, param);\n+        OPSET::process_post_move (op, env, param);\n+        break;\n+      case OpCode_hmoveto:\n+        OPSET::check_width (op, env, param);\n+        PATH::hmoveto (env, param);\n+        OPSET::process_post_move (op, env, param);\n+        break;\n+      case OpCode_vmoveto:\n+        OPSET::check_width (op, env, param);\n+        PATH::vmoveto (env, param);\n+        OPSET::process_post_move (op, env, param);\n+        break;\n+      case OpCode_rlineto:\n+        PATH::rlineto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_hlineto:\n+        PATH::hlineto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_vlineto:\n+        PATH::vlineto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_rrcurveto:\n+        PATH::rrcurveto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_rcurveline:\n+        PATH::rcurveline (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_rlinecurve:\n+        PATH::rlinecurve (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_vvcurveto:\n+        PATH::vvcurveto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_hhcurveto:\n+        PATH::hhcurveto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_vhcurveto:\n+        PATH::vhcurveto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+      case OpCode_hvcurveto:\n+        PATH::hvcurveto (env, param);\n+        process_post_path (op, env, param);\n+        break;\n+\n+      case OpCode_hflex:\n+        PATH::hflex (env, param);\n+        OPSET::process_post_flex (op, env, param);\n+        break;\n+\n+      case OpCode_flex:\n+        PATH::flex (env, param);\n+        OPSET::process_post_flex (op, env, param);\n+        break;\n+\n+      case OpCode_hflex1:\n+        PATH::hflex1 (env, param);\n+        OPSET::process_post_flex (op, env, param);\n+        break;\n+\n+      case OpCode_flex1:\n+        PATH::flex1 (env, param);\n+        OPSET::process_post_flex (op, env, param);\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env);\n+        break;\n+    }\n+  }\n+\n+  static void process_hstem (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    env.hstem_count += env.argStack.get_count () \/ 2;\n+    OPSET::flush_args_and_op (op, env, param);\n+  }\n+\n+  static void process_vstem (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    env.vstem_count += env.argStack.get_count () \/ 2;\n+    OPSET::flush_args_and_op (op, env, param);\n+  }\n+\n+  static void process_hintmask (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    env.determine_hintmask_size ();\n+    if (likely (env.str_ref.avail (env.hintmask_size)))\n+    {\n+      OPSET::flush_hintmask (op, env, param);\n+      env.str_ref.inc (env.hintmask_size);\n+    }\n+  }\n+\n+  static void process_post_flex (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    OPSET::flush_args_and_op (op, env, param);\n+  }\n+\n+  static void check_width (op_code_t op, ENV &env, PARAM& param)\n+  {}\n+\n+  static void process_post_move (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    if (!env.seen_moveto)\n+    {\n+      env.determine_hintmask_size ();\n+      env.seen_moveto = true;\n+    }\n+    OPSET::flush_args_and_op (op, env, param);\n+  }\n+\n+  static void process_post_path (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    OPSET::flush_args_and_op (op, env, param);\n+  }\n+\n+  static void flush_args_and_op (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    OPSET::flush_args (env, param);\n+    OPSET::flush_op (op, env, param);\n+  }\n+\n+  static void flush_args (ENV &env, PARAM& param)\n+  {\n+    env.pop_n_args (env.argStack.get_count ());\n+  }\n+\n+  static void flush_op (op_code_t op, ENV &env, PARAM& param)\n+  {\n+  }\n+\n+  static void flush_hintmask (op_code_t op, ENV &env, PARAM& param)\n+  {\n+    OPSET::flush_args_and_op (op, env, param);\n+  }\n+\n+  static bool is_number_op (op_code_t op)\n+  {\n+    switch (op)\n+    {\n+      case OpCode_shortint:\n+      case OpCode_fixedcs:\n+      case OpCode_TwoBytePosInt0: case OpCode_TwoBytePosInt1:\n+      case OpCode_TwoBytePosInt2: case OpCode_TwoBytePosInt3:\n+      case OpCode_TwoByteNegInt0: case OpCode_TwoByteNegInt1:\n+      case OpCode_TwoByteNegInt2: case OpCode_TwoByteNegInt3:\n+        return true;\n+\n+      default:\n+        \/* 1-byte integer *\/\n+        return (OpCode_OneByteIntFirst <= op) && (op <= OpCode_OneByteIntLast);\n+    }\n+  }\n+\n+  protected:\n+  typedef opset_t<ARG>  SUPER;\n+};\n+\n+template <typename PATH, typename ENV, typename PARAM>\n+struct path_procs_t\n+{\n+  static void rmoveto (ENV &env, PARAM& param)\n+  {\n+    point_t pt1 = env.get_pt ();\n+    const number_t &dy = env.pop_arg ();\n+    const number_t &dx = env.pop_arg ();\n+    pt1.move (dx, dy);\n+    PATH::moveto (env, param, pt1);\n+  }\n+\n+  static void hmoveto (ENV &env, PARAM& param)\n+  {\n+    point_t pt1 = env.get_pt ();\n+    pt1.move_x (env.pop_arg ());\n+    PATH::moveto (env, param, pt1);\n+  }\n+\n+  static void vmoveto (ENV &env, PARAM& param)\n+  {\n+    point_t pt1 = env.get_pt ();\n+    pt1.move_y (env.pop_arg ());\n+    PATH::moveto (env, param, pt1);\n+  }\n+\n+  static void rlineto (ENV &env, PARAM& param)\n+  {\n+    for (unsigned int i = 0; i + 2 <= env.argStack.get_count (); i += 2)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (i), env.eval_arg (i+1));\n+      PATH::line (env, param, pt1);\n+    }\n+  }\n+\n+  static void hlineto (ENV &env, PARAM& param)\n+  {\n+    point_t pt1;\n+    unsigned int i = 0;\n+    for (; i + 2 <= env.argStack.get_count (); i += 2)\n+    {\n+      pt1 = env.get_pt ();\n+      pt1.move_x (env.eval_arg (i));\n+      PATH::line (env, param, pt1);\n+      pt1.move_y (env.eval_arg (i+1));\n+      PATH::line (env, param, pt1);\n+    }\n+    if (i < env.argStack.get_count ())\n+    {\n+      pt1 = env.get_pt ();\n+      pt1.move_x (env.eval_arg (i));\n+      PATH::line (env, param, pt1);\n+    }\n+  }\n+\n+  static void vlineto (ENV &env, PARAM& param)\n+  {\n+    point_t pt1;\n+    unsigned int i = 0;\n+    for (; i + 2 <= env.argStack.get_count (); i += 2)\n+    {\n+      pt1 = env.get_pt ();\n+      pt1.move_y (env.eval_arg (i));\n+      PATH::line (env, param, pt1);\n+      pt1.move_x (env.eval_arg (i+1));\n+      PATH::line (env, param, pt1);\n+    }\n+    if (i < env.argStack.get_count ())\n+    {\n+      pt1 = env.get_pt ();\n+      pt1.move_y (env.eval_arg (i));\n+      PATH::line (env, param, pt1);\n+    }\n+  }\n+\n+  static void rrcurveto (ENV &env, PARAM& param)\n+  {\n+    for (unsigned int i = 0; i + 6 <= env.argStack.get_count (); i += 6)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (i), env.eval_arg (i+1));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (i+2), env.eval_arg (i+3));\n+      point_t pt3 = pt2;\n+      pt3.move (env.eval_arg (i+4), env.eval_arg (i+5));\n+      PATH::curve (env, param, pt1, pt2, pt3);\n+    }\n+  }\n+\n+  static void rcurveline (ENV &env, PARAM& param)\n+  {\n+    unsigned int i = 0;\n+    for (; i + 6 <= env.argStack.get_count (); i += 6)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (i), env.eval_arg (i+1));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (i+2), env.eval_arg (i+3));\n+      point_t pt3 = pt2;\n+      pt3.move (env.eval_arg (i+4), env.eval_arg (i+5));\n+      PATH::curve (env, param, pt1, pt2, pt3);\n+    }\n+    for (; i + 2 <= env.argStack.get_count (); i += 2)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (i), env.eval_arg (i+1));\n+      PATH::line (env, param, pt1);\n+    }\n+  }\n+\n+  static void rlinecurve (ENV &env, PARAM& param)\n+  {\n+    unsigned int i = 0;\n+    unsigned int line_limit = (env.argStack.get_count () % 6);\n+    for (; i + 2 <= line_limit; i += 2)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (i), env.eval_arg (i+1));\n+      PATH::line (env, param, pt1);\n+    }\n+    for (; i + 6 <= env.argStack.get_count (); i += 6)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (i), env.eval_arg (i+1));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (i+2), env.eval_arg (i+3));\n+      point_t pt3 = pt2;\n+      pt3.move (env.eval_arg (i+4), env.eval_arg (i+5));\n+      PATH::curve (env, param, pt1, pt2, pt3);\n+    }\n+  }\n+\n+  static void vvcurveto (ENV &env, PARAM& param)\n+  {\n+    unsigned int i = 0;\n+    point_t pt1 = env.get_pt ();\n+    if ((env.argStack.get_count () & 1) != 0)\n+      pt1.move_x (env.eval_arg (i++));\n+    for (; i + 4 <= env.argStack.get_count (); i += 4)\n+    {\n+      pt1.move_y (env.eval_arg (i));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+      point_t pt3 = pt2;\n+      pt3.move_y (env.eval_arg (i+3));\n+      PATH::curve (env, param, pt1, pt2, pt3);\n+      pt1 = env.get_pt ();\n+    }\n+  }\n+\n+  static void hhcurveto (ENV &env, PARAM& param)\n+  {\n+    unsigned int i = 0;\n+    point_t pt1 = env.get_pt ();\n+    if ((env.argStack.get_count () & 1) != 0)\n+      pt1.move_y (env.eval_arg (i++));\n+    for (; i + 4 <= env.argStack.get_count (); i += 4)\n+    {\n+      pt1.move_x (env.eval_arg (i));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+      point_t pt3 = pt2;\n+      pt3.move_x (env.eval_arg (i+3));\n+      PATH::curve (env, param, pt1, pt2, pt3);\n+      pt1 = env.get_pt ();\n+    }\n+  }\n+\n+  static void vhcurveto (ENV &env, PARAM& param)\n+  {\n+    point_t pt1, pt2, pt3;\n+    unsigned int i = 0;\n+    if ((env.argStack.get_count () % 8) >= 4)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move_y (env.eval_arg (i));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+      point_t pt3 = pt2;\n+      pt3.move_x (env.eval_arg (i+3));\n+      i += 4;\n+\n+      for (; i + 8 <= env.argStack.get_count (); i += 8)\n+      {\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+        pt1 = env.get_pt ();\n+        pt1.move_x (env.eval_arg (i));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+        pt3 = pt2;\n+        pt3.move_y (env.eval_arg (i+3));\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+\n+        pt1 = pt3;\n+        pt1.move_y (env.eval_arg (i+4));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+5), env.eval_arg (i+6));\n+        pt3 = pt2;\n+        pt3.move_x (env.eval_arg (i+7));\n+      }\n+      if (i < env.argStack.get_count ())\n+        pt3.move_y (env.eval_arg (i));\n+      PATH::curve (env, param, pt1, pt2, pt3);\n+    }\n+    else\n+    {\n+      for (; i + 8 <= env.argStack.get_count (); i += 8)\n+      {\n+        pt1 = env.get_pt ();\n+        pt1.move_y (env.eval_arg (i));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+        pt3 = pt2;\n+        pt3.move_x (env.eval_arg (i+3));\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+\n+        pt1 = pt3;\n+        pt1.move_x (env.eval_arg (i+4));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+5), env.eval_arg (i+6));\n+        pt3 = pt2;\n+        pt3.move_y (env.eval_arg (i+7));\n+        if ((env.argStack.get_count () - i < 16) && ((env.argStack.get_count () & 1) != 0))\n+          pt3.move_x (env.eval_arg (i+8));\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+      }\n+    }\n+  }\n+\n+  static void hvcurveto (ENV &env, PARAM& param)\n+  {\n+    point_t pt1, pt2, pt3;\n+    unsigned int i = 0;\n+    if ((env.argStack.get_count () % 8) >= 4)\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move_x (env.eval_arg (i));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+      point_t pt3 = pt2;\n+      pt3.move_y (env.eval_arg (i+3));\n+      i += 4;\n+\n+      for (; i + 8 <= env.argStack.get_count (); i += 8)\n+      {\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+        pt1 = env.get_pt ();\n+        pt1.move_y (env.eval_arg (i));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+        pt3 = pt2;\n+        pt3.move_x (env.eval_arg (i+3));\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+\n+        pt1 = pt3;\n+        pt1.move_x (env.eval_arg (i+4));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+5), env.eval_arg (i+6));\n+        pt3 = pt2;\n+        pt3.move_y (env.eval_arg (i+7));\n+      }\n+      if (i < env.argStack.get_count ())\n+        pt3.move_x (env.eval_arg (i));\n+      PATH::curve (env, param, pt1, pt2, pt3);\n+    }\n+    else\n+    {\n+      for (; i + 8 <= env.argStack.get_count (); i += 8)\n+      {\n+        pt1 = env.get_pt ();\n+        pt1.move_x (env.eval_arg (i));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+1), env.eval_arg (i+2));\n+        pt3 = pt2;\n+        pt3.move_y (env.eval_arg (i+3));\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+\n+        pt1 = pt3;\n+        pt1.move_y (env.eval_arg (i+4));\n+        pt2 = pt1;\n+        pt2.move (env.eval_arg (i+5), env.eval_arg (i+6));\n+        pt3 = pt2;\n+        pt3.move_x (env.eval_arg (i+7));\n+        if ((env.argStack.get_count () - i < 16) && ((env.argStack.get_count () & 1) != 0))\n+          pt3.move_y (env.eval_arg (i+8));\n+        PATH::curve (env, param, pt1, pt2, pt3);\n+      }\n+    }\n+  }\n+\n+  \/* default actions to be overridden *\/\n+  static void moveto (ENV &env, PARAM& param, const point_t &pt)\n+  { env.moveto (pt); }\n+\n+  static void line (ENV &env, PARAM& param, const point_t &pt1)\n+  { PATH::moveto (env, param, pt1); }\n+\n+  static void curve (ENV &env, PARAM& param, const point_t &pt1, const point_t &pt2, const point_t &pt3)\n+  { PATH::moveto (env, param, pt3); }\n+\n+  static void hflex (ENV &env, PARAM& param)\n+  {\n+    if (likely (env.argStack.get_count () == 7))\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move_x (env.eval_arg (0));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (1), env.eval_arg (2));\n+      point_t pt3 = pt2;\n+      pt3.move_x (env.eval_arg (3));\n+      point_t pt4 = pt3;\n+      pt4.move_x (env.eval_arg (4));\n+      point_t pt5 = pt4;\n+      pt5.move_x (env.eval_arg (5));\n+      pt5.y = pt1.y;\n+      point_t pt6 = pt5;\n+      pt6.move_x (env.eval_arg (6));\n+\n+      curve2 (env, param, pt1, pt2, pt3, pt4, pt5, pt6);\n+    }\n+    else\n+      env.set_error ();\n+  }\n+\n+  static void flex (ENV &env, PARAM& param)\n+  {\n+    if (likely (env.argStack.get_count () == 13))\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (0), env.eval_arg (1));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (2), env.eval_arg (3));\n+      point_t pt3 = pt2;\n+      pt3.move (env.eval_arg (4), env.eval_arg (5));\n+      point_t pt4 = pt3;\n+      pt4.move (env.eval_arg (6), env.eval_arg (7));\n+      point_t pt5 = pt4;\n+      pt5.move (env.eval_arg (8), env.eval_arg (9));\n+      point_t pt6 = pt5;\n+      pt6.move (env.eval_arg (10), env.eval_arg (11));\n+\n+      curve2 (env, param, pt1, pt2, pt3, pt4, pt5, pt6);\n+    }\n+    else\n+      env.set_error ();\n+  }\n+\n+  static void hflex1 (ENV &env, PARAM& param)\n+  {\n+    if (likely (env.argStack.get_count () == 9))\n+    {\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (0), env.eval_arg (1));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (2), env.eval_arg (3));\n+      point_t pt3 = pt2;\n+      pt3.move_x (env.eval_arg (4));\n+      point_t pt4 = pt3;\n+      pt4.move_x (env.eval_arg (5));\n+      point_t pt5 = pt4;\n+      pt5.move (env.eval_arg (6), env.eval_arg (7));\n+      point_t pt6 = pt5;\n+      pt6.move_x (env.eval_arg (8));\n+      pt6.y = env.get_pt ().y;\n+\n+      curve2 (env, param, pt1, pt2, pt3, pt4, pt5, pt6);\n+    }\n+    else\n+      env.set_error ();\n+  }\n+\n+  static void flex1 (ENV &env, PARAM& param)\n+  {\n+    if (likely (env.argStack.get_count () == 11))\n+    {\n+      point_t d;\n+      d.init ();\n+      for (unsigned int i = 0; i < 10; i += 2)\n+        d.move (env.eval_arg (i), env.eval_arg (i+1));\n+\n+      point_t pt1 = env.get_pt ();\n+      pt1.move (env.eval_arg (0), env.eval_arg (1));\n+      point_t pt2 = pt1;\n+      pt2.move (env.eval_arg (2), env.eval_arg (3));\n+      point_t pt3 = pt2;\n+      pt3.move (env.eval_arg (4), env.eval_arg (5));\n+      point_t pt4 = pt3;\n+      pt4.move (env.eval_arg (6), env.eval_arg (7));\n+      point_t pt5 = pt4;\n+      pt5.move (env.eval_arg (8), env.eval_arg (9));\n+      point_t pt6 = pt5;\n+\n+      if (fabs (d.x.to_real ()) > fabs (d.y.to_real ()))\n+      {\n+        pt6.move_x (env.eval_arg (10));\n+        pt6.y = env.get_pt ().y;\n+      }\n+      else\n+      {\n+        pt6.x = env.get_pt ().x;\n+        pt6.move_y (env.eval_arg (10));\n+      }\n+\n+      curve2 (env, param, pt1, pt2, pt3, pt4, pt5, pt6);\n+    }\n+    else\n+      env.set_error ();\n+  }\n+\n+  protected:\n+  static void curve2 (ENV &env, PARAM& param,\n+                      const point_t &pt1, const point_t &pt2, const point_t &pt3,\n+                      const point_t &pt4, const point_t &pt5, const point_t &pt6)\n+  {\n+    PATH::curve (env, param, pt1, pt2, pt3);\n+    PATH::curve (env, param, pt4, pt5, pt6);\n+  }\n+};\n+\n+template <typename ENV, typename OPSET, typename PARAM>\n+struct cs_interpreter_t : interpreter_t<ENV>\n+{\n+  bool interpret (PARAM& param)\n+  {\n+    SUPER::env.set_endchar (false);\n+\n+    for (;;) {\n+      OPSET::process_op (SUPER::env.fetch_op (), SUPER::env, param);\n+      if (unlikely (SUPER::env.in_error ()))\n+        return false;\n+      if (SUPER::env.is_endchar ())\n+        break;\n+    }\n+\n+    return true;\n+  }\n+\n+  private:\n+  typedef interpreter_t<ENV> SUPER;\n+};\n+\n+} \/* namespace CFF *\/\n+\n+#endif \/* HB_CFF_INTERP_CS_COMMON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-cff-interp-cs-common.hh","additions":905,"deletions":0,"binary":false,"changes":905,"status":"added"},{"patch":"@@ -0,0 +1,294 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+#ifndef HB_CFF_INTERP_DICT_COMMON_HH\n+#define HB_CFF_INTERP_DICT_COMMON_HH\n+\n+#include \"hb-cff-interp-common.hh\"\n+#include <math.h>\n+#include <float.h>\n+\n+namespace CFF {\n+\n+using namespace OT;\n+\n+\/* an opstr and the parsed out dict value(s) *\/\n+struct dict_val_t : op_str_t\n+{\n+  void init () { single_val.set_int (0); }\n+  void fini () {}\n+\n+  number_t            single_val;\n+};\n+\n+typedef dict_val_t num_dict_val_t;\n+\n+template <typename VAL> struct dict_values_t : parsed_values_t<VAL> {};\n+\n+template <typename OPSTR=op_str_t>\n+struct top_dict_values_t : dict_values_t<OPSTR>\n+{\n+  void init ()\n+  {\n+    dict_values_t<OPSTR>::init ();\n+    charStringsOffset = 0;\n+    FDArrayOffset = 0;\n+  }\n+  void fini () { dict_values_t<OPSTR>::fini (); }\n+\n+  unsigned int calculate_serialized_op_size (const OPSTR& opstr) const\n+  {\n+    switch (opstr.op)\n+    {\n+      case OpCode_CharStrings:\n+      case OpCode_FDArray:\n+        return OpCode_Size (OpCode_longintdict) + 4 + OpCode_Size (opstr.op);\n+\n+      default:\n+        return opstr.str.length;\n+    }\n+  }\n+\n+  unsigned int  charStringsOffset;\n+  unsigned int  FDArrayOffset;\n+};\n+\n+struct dict_opset_t : opset_t<number_t>\n+{\n+  static void process_op (op_code_t op, interp_env_t<number_t>& env)\n+  {\n+    switch (op) {\n+      case OpCode_longintdict:  \/* 5-byte integer *\/\n+        env.argStack.push_longint_from_substr (env.str_ref);\n+        break;\n+\n+      case OpCode_BCD:  \/* real number *\/\n+        env.argStack.push_real (parse_bcd (env.str_ref));\n+        break;\n+\n+      default:\n+        opset_t<number_t>::process_op (op, env);\n+        break;\n+    }\n+  }\n+\n+  static double parse_bcd (byte_str_ref_t& str_ref)\n+  {\n+    bool    neg = false;\n+    double  int_part = 0;\n+    uint64_t frac_part = 0;\n+    uint32_t  frac_count = 0;\n+    bool    exp_neg = false;\n+    uint32_t  exp_part = 0;\n+    bool    exp_overflow = false;\n+    enum Part { INT_PART=0, FRAC_PART, EXP_PART } part = INT_PART;\n+    enum Nibble { DECIMAL=10, EXP_POS, EXP_NEG, RESERVED, NEG, END };\n+    const uint64_t MAX_FRACT = 0xFFFFFFFFFFFFFull; \/* 1^52-1 *\/\n+    const uint32_t MAX_EXP = 0x7FFu; \/* 1^11-1 *\/\n+\n+    double  value = 0.0;\n+    unsigned char byte = 0;\n+    for (uint32_t i = 0;; i++)\n+    {\n+      char d;\n+      if ((i & 1) == 0)\n+      {\n+        if (!str_ref.avail ())\n+        {\n+          str_ref.set_error ();\n+          return 0.0;\n+        }\n+        byte = str_ref[0];\n+        str_ref.inc ();\n+        d = byte >> 4;\n+      }\n+      else\n+        d = byte & 0x0F;\n+\n+      switch (d)\n+      {\n+        case RESERVED:\n+          str_ref.set_error ();\n+          return value;\n+\n+        case END:\n+          value = (double)(neg? -int_part: int_part);\n+          if (frac_count > 0)\n+          {\n+            double frac = (frac_part \/ pow (10.0, (double)frac_count));\n+            if (neg) frac = -frac;\n+            value += frac;\n+          }\n+          if (unlikely (exp_overflow))\n+          {\n+            if (value == 0.0)\n+              return value;\n+            if (exp_neg)\n+              return neg? -DBL_MIN: DBL_MIN;\n+            else\n+              return neg? -DBL_MAX: DBL_MAX;\n+          }\n+          if (exp_part != 0)\n+          {\n+            if (exp_neg)\n+              value \/= pow (10.0, (double)exp_part);\n+            else\n+              value *= pow (10.0, (double)exp_part);\n+          }\n+          return value;\n+\n+        case NEG:\n+          if (i != 0)\n+          {\n+            str_ref.set_error ();\n+            return 0.0;\n+          }\n+          neg = true;\n+          break;\n+\n+        case DECIMAL:\n+          if (part != INT_PART)\n+          {\n+            str_ref.set_error ();\n+            return value;\n+          }\n+          part = FRAC_PART;\n+          break;\n+\n+        case EXP_NEG:\n+          exp_neg = true;\n+          HB_FALLTHROUGH;\n+\n+        case EXP_POS:\n+          if (part == EXP_PART)\n+          {\n+            str_ref.set_error ();\n+            return value;\n+          }\n+          part = EXP_PART;\n+          break;\n+\n+        default:\n+          switch (part) {\n+            default:\n+            case INT_PART:\n+              int_part = (int_part * 10) + d;\n+              break;\n+\n+            case FRAC_PART:\n+              if (likely (frac_part <= MAX_FRACT \/ 10))\n+              {\n+                frac_part = (frac_part * 10) + (unsigned)d;\n+                frac_count++;\n+              }\n+              break;\n+\n+            case EXP_PART:\n+              if (likely (exp_part * 10 + d <= MAX_EXP))\n+              {\n+                exp_part = (exp_part * 10) + d;\n+              }\n+              else\n+                exp_overflow = true;\n+              break;\n+          }\n+      }\n+    }\n+\n+    return value;\n+  }\n+\n+  static bool is_hint_op (op_code_t op)\n+  {\n+    switch (op)\n+    {\n+      case OpCode_BlueValues:\n+      case OpCode_OtherBlues:\n+      case OpCode_FamilyBlues:\n+      case OpCode_FamilyOtherBlues:\n+      case OpCode_StemSnapH:\n+      case OpCode_StemSnapV:\n+      case OpCode_StdHW:\n+      case OpCode_StdVW:\n+      case OpCode_BlueScale:\n+      case OpCode_BlueShift:\n+      case OpCode_BlueFuzz:\n+      case OpCode_ForceBold:\n+      case OpCode_LanguageGroup:\n+      case OpCode_ExpansionFactor:\n+        return true;\n+      default:\n+        return false;\n+    }\n+  }\n+};\n+\n+template <typename VAL=op_str_t>\n+struct top_dict_opset_t : dict_opset_t\n+{\n+  static void process_op (op_code_t op, interp_env_t<number_t>& env, top_dict_values_t<VAL> & dictval)\n+  {\n+    switch (op) {\n+      case OpCode_CharStrings:\n+        dictval.charStringsOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_FDArray:\n+        dictval.FDArrayOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_FontMatrix:\n+        env.clear_args ();\n+        break;\n+      default:\n+        dict_opset_t::process_op (op, env);\n+        break;\n+    }\n+  }\n+};\n+\n+template <typename OPSET, typename PARAM, typename ENV=num_interp_env_t>\n+struct dict_interpreter_t : interpreter_t<ENV>\n+{\n+  bool interpret (PARAM& param)\n+  {\n+    param.init ();\n+    while (SUPER::env.str_ref.avail ())\n+    {\n+      OPSET::process_op (SUPER::env.fetch_op (), SUPER::env, param);\n+      if (unlikely (SUPER::env.in_error ()))\n+        return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private:\n+  typedef interpreter_t<ENV> SUPER;\n+};\n+\n+} \/* namespace CFF *\/\n+\n+#endif \/* HB_CFF_INTERP_DICT_COMMON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-cff-interp-dict-common.hh","additions":294,"deletions":0,"binary":false,"changes":294,"status":"added"},{"patch":"@@ -0,0 +1,161 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+#ifndef HB_CFF1_INTERP_CS_HH\n+#define HB_CFF1_INTERP_CS_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-cff-interp-cs-common.hh\"\n+\n+namespace CFF {\n+\n+using namespace OT;\n+\n+typedef biased_subrs_t<CFF1Subrs>   cff1_biased_subrs_t;\n+\n+struct cff1_cs_interp_env_t : cs_interp_env_t<number_t, CFF1Subrs>\n+{\n+  template <typename ACC>\n+  void init (const byte_str_t &str, ACC &acc, unsigned int fd)\n+  {\n+    SUPER::init (str, *acc.globalSubrs, *acc.privateDicts[fd].localSubrs);\n+    processed_width = false;\n+    has_width = false;\n+    arg_start = 0;\n+    in_seac = false;\n+  }\n+\n+  void fini () { SUPER::fini (); }\n+\n+  void set_width (bool has_width_)\n+  {\n+    if (likely (!processed_width && (SUPER::argStack.get_count () > 0)))\n+    {\n+      if (has_width_)\n+      {\n+        width = SUPER::argStack[0];\n+        has_width = true;\n+        arg_start = 1;\n+      }\n+    }\n+    processed_width = true;\n+  }\n+\n+  void clear_args ()\n+  {\n+    arg_start = 0;\n+    SUPER::clear_args ();\n+  }\n+\n+  void set_in_seac (bool _in_seac) { in_seac = _in_seac; }\n+\n+  bool    processed_width;\n+  bool    has_width;\n+  unsigned int  arg_start;\n+  number_t      width;\n+  bool    in_seac;\n+\n+  private:\n+  typedef cs_interp_env_t<number_t, CFF1Subrs> SUPER;\n+};\n+\n+template <typename OPSET, typename PARAM, typename PATH=path_procs_null_t<cff1_cs_interp_env_t, PARAM> >\n+struct cff1_cs_opset_t : cs_opset_t<number_t, OPSET, cff1_cs_interp_env_t, PARAM, PATH>\n+{\n+  \/* PostScript-originated legacy opcodes (OpCode_add etc) are unsupported *\/\n+  \/* Type 1-originated deprecated opcodes, seac behavior of endchar and dotsection are supported *\/\n+\n+  static void process_op (op_code_t op, cff1_cs_interp_env_t &env, PARAM& param)\n+  {\n+    switch (op) {\n+      case OpCode_dotsection:\n+        SUPER::flush_args_and_op (op, env, param);\n+        break;\n+\n+      case OpCode_endchar:\n+        OPSET::check_width (op, env, param);\n+        if (env.argStack.get_count () >= 4)\n+        {\n+          OPSET::process_seac (env, param);\n+        }\n+        OPSET::flush_args_and_op (op, env, param);\n+        env.set_endchar (true);\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env, param);\n+    }\n+  }\n+\n+  static void check_width (op_code_t op, cff1_cs_interp_env_t &env, PARAM& param)\n+  {\n+    if (!env.processed_width)\n+    {\n+      bool  has_width = false;\n+      switch (op)\n+      {\n+        case OpCode_endchar:\n+        case OpCode_hstem:\n+        case OpCode_hstemhm:\n+        case OpCode_vstem:\n+        case OpCode_vstemhm:\n+        case OpCode_hintmask:\n+        case OpCode_cntrmask:\n+          has_width = ((env.argStack.get_count () & 1) != 0);\n+          break;\n+        case OpCode_hmoveto:\n+        case OpCode_vmoveto:\n+          has_width = (env.argStack.get_count () > 1);\n+          break;\n+        case OpCode_rmoveto:\n+          has_width = (env.argStack.get_count () > 2);\n+          break;\n+        default:\n+          return;\n+      }\n+      env.set_width (has_width);\n+    }\n+  }\n+\n+  static void process_seac (cff1_cs_interp_env_t &env, PARAM& param)\n+  {\n+  }\n+\n+  static void flush_args (cff1_cs_interp_env_t &env, PARAM& param)\n+  {\n+    SUPER::flush_args (env, param);\n+    env.clear_args ();  \/* pop off width *\/\n+  }\n+\n+  private:\n+  typedef cs_opset_t<number_t, OPSET, cff1_cs_interp_env_t, PARAM, PATH>  SUPER;\n+};\n+\n+template <typename OPSET, typename PARAM>\n+struct cff1_cs_interpreter_t : cs_interpreter_t<cff1_cs_interp_env_t, OPSET, PARAM> {};\n+\n+} \/* namespace CFF *\/\n+\n+#endif \/* HB_CFF1_INTERP_CS_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-cff1-interp-cs.hh","additions":161,"deletions":0,"binary":false,"changes":161,"status":"added"},{"patch":"@@ -0,0 +1,272 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+#ifndef HB_CFF2_INTERP_CS_HH\n+#define HB_CFF2_INTERP_CS_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-cff-interp-cs-common.hh\"\n+\n+namespace CFF {\n+\n+using namespace OT;\n+\n+struct blend_arg_t : number_t\n+{\n+  void init ()\n+  {\n+    number_t::init ();\n+    deltas.init ();\n+  }\n+\n+  void fini ()\n+  {\n+    number_t::fini ();\n+    deltas.fini_deep ();\n+  }\n+\n+  void set_int (int v) { reset_blends (); number_t::set_int (v); }\n+  void set_fixed (int32_t v) { reset_blends (); number_t::set_fixed (v); }\n+  void set_real (double v) { reset_blends (); number_t::set_real (v); }\n+\n+  void set_blends (unsigned int numValues_, unsigned int valueIndex_,\n+                          unsigned int numBlends, hb_array_t<const blend_arg_t> blends_)\n+  {\n+    numValues = numValues_;\n+    valueIndex = valueIndex_;\n+    deltas.resize (numBlends);\n+    for (unsigned int i = 0; i < numBlends; i++)\n+      deltas[i] = blends_[i];\n+  }\n+\n+  bool blending () const { return deltas.length > 0; }\n+  void reset_blends ()\n+  {\n+    numValues = valueIndex = 0;\n+    deltas.resize (0);\n+  }\n+\n+  unsigned int numValues;\n+  unsigned int valueIndex;\n+  hb_vector_t<number_t> deltas;\n+};\n+\n+typedef interp_env_t<blend_arg_t> BlendInterpEnv;\n+typedef biased_subrs_t<CFF2Subrs>   cff2_biased_subrs_t;\n+\n+struct cff2_cs_interp_env_t : cs_interp_env_t<blend_arg_t, CFF2Subrs>\n+{\n+  template <typename ACC>\n+  void init (const byte_str_t &str, ACC &acc, unsigned int fd,\n+                    const int *coords_=nullptr, unsigned int num_coords_=0)\n+  {\n+    SUPER::init (str, *acc.globalSubrs, *acc.privateDicts[fd].localSubrs);\n+\n+    coords = coords_;\n+    num_coords = num_coords_;\n+    varStore = acc.varStore;\n+    seen_blend = false;\n+    seen_vsindex_ = false;\n+    scalars.init ();\n+    do_blend = (coords != nullptr) && num_coords && (varStore != &Null(CFF2VariationStore));\n+    set_ivs (acc.privateDicts[fd].ivs);\n+  }\n+\n+  void fini ()\n+  {\n+    scalars.fini ();\n+    SUPER::fini ();\n+  }\n+\n+  op_code_t fetch_op ()\n+  {\n+    if (this->str_ref.avail ())\n+      return SUPER::fetch_op ();\n+\n+    \/* make up return or endchar op *\/\n+    if (this->callStack.is_empty ())\n+      return OpCode_endchar;\n+    else\n+      return OpCode_return;\n+  }\n+\n+  const blend_arg_t& eval_arg (unsigned int i)\n+  {\n+    blend_arg_t  &arg = argStack[i];\n+    blend_arg (arg);\n+    return arg;\n+  }\n+\n+  const blend_arg_t& pop_arg ()\n+  {\n+    blend_arg_t  &arg = argStack.pop ();\n+    blend_arg (arg);\n+    return arg;\n+  }\n+\n+  void process_blend ()\n+  {\n+    if (!seen_blend)\n+    {\n+      region_count = varStore->varStore.get_region_index_count (get_ivs ());\n+      if (do_blend)\n+      {\n+        if (unlikely (!scalars.resize (region_count)))\n+          set_error ();\n+        else\n+          varStore->varStore.get_scalars (get_ivs (), (int *)coords, num_coords,\n+                                          &scalars[0], region_count);\n+      }\n+      seen_blend = true;\n+    }\n+  }\n+\n+  void process_vsindex ()\n+  {\n+    unsigned int  index = argStack.pop_uint ();\n+    if (unlikely (seen_vsindex () || seen_blend))\n+    {\n+      set_error ();\n+    }\n+    else\n+    {\n+      set_ivs (index);\n+    }\n+    seen_vsindex_ = true;\n+  }\n+\n+  unsigned int get_region_count () const { return region_count; }\n+  void   set_region_count (unsigned int region_count_) { region_count = region_count_; }\n+  unsigned int get_ivs () const { return ivs; }\n+  void   set_ivs (unsigned int ivs_) { ivs = ivs_; }\n+  bool   seen_vsindex () const { return seen_vsindex_; }\n+\n+  protected:\n+  void blend_arg (blend_arg_t &arg)\n+  {\n+    if (do_blend && arg.blending ())\n+    {\n+      if (likely (scalars.length == arg.deltas.length))\n+      {\n+        double v = arg.to_real ();\n+        for (unsigned int i = 0; i < scalars.length; i++)\n+        {\n+          v += (double)scalars[i] * arg.deltas[i].to_real ();\n+        }\n+        arg.set_real (v);\n+        arg.deltas.resize (0);\n+      }\n+    }\n+  }\n+\n+  protected:\n+  const int     *coords;\n+  unsigned int  num_coords;\n+  const  CFF2VariationStore *varStore;\n+  unsigned int  region_count;\n+  unsigned int  ivs;\n+  hb_vector_t<float>  scalars;\n+  bool    do_blend;\n+  bool    seen_vsindex_;\n+  bool    seen_blend;\n+\n+  typedef cs_interp_env_t<blend_arg_t, CFF2Subrs> SUPER;\n+};\n+template <typename OPSET, typename PARAM, typename PATH=path_procs_null_t<cff2_cs_interp_env_t, PARAM> >\n+struct cff2_cs_opset_t : cs_opset_t<blend_arg_t, OPSET, cff2_cs_interp_env_t, PARAM, PATH>\n+{\n+  static void process_op (op_code_t op, cff2_cs_interp_env_t &env, PARAM& param)\n+  {\n+    switch (op) {\n+      case OpCode_callsubr:\n+      case OpCode_callgsubr:\n+        \/* a subroutine number shoudln't be a blended value *\/\n+        if (unlikely (env.argStack.peek ().blending ()))\n+        {\n+          env.set_error ();\n+          break;\n+        }\n+        SUPER::process_op (op, env, param);\n+        break;\n+\n+      case OpCode_blendcs:\n+        OPSET::process_blend (env, param);\n+        break;\n+\n+      case OpCode_vsindexcs:\n+        if (unlikely (env.argStack.peek ().blending ()))\n+        {\n+          env.set_error ();\n+          break;\n+        }\n+        OPSET::process_vsindex (env, param);\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env, param);\n+    }\n+  }\n+\n+  static void process_blend (cff2_cs_interp_env_t &env, PARAM& param)\n+  {\n+    unsigned int n, k;\n+\n+    env.process_blend ();\n+    k = env.get_region_count ();\n+    n = env.argStack.pop_uint ();\n+    \/* copy the blend values into blend array of the default values *\/\n+    unsigned int start = env.argStack.get_count () - ((k+1) * n);\n+    \/* let an obvious error case fail, but note CFF2 spec doesn't forbid n==0 *\/\n+    if (unlikely (start > env.argStack.get_count ()))\n+    {\n+      env.set_error ();\n+      return;\n+    }\n+    for (unsigned int i = 0; i < n; i++)\n+    {\n+      const hb_array_t<const blend_arg_t>       blends = env.argStack.get_subarray (start + n + (i * k));\n+      env.argStack[start + i].set_blends (n, i, k, blends);\n+    }\n+\n+    \/* pop off blend values leaving default values now adorned with blend values *\/\n+    env.argStack.pop (k * n);\n+  }\n+\n+  static void process_vsindex (cff2_cs_interp_env_t &env, PARAM& param)\n+  {\n+    env.process_vsindex ();\n+    env.clear_args ();\n+  }\n+\n+  private:\n+  typedef cs_opset_t<blend_arg_t, OPSET, cff2_cs_interp_env_t, PARAM, PATH>  SUPER;\n+};\n+\n+template <typename OPSET, typename PARAM>\n+struct cff2_cs_interpreter_t : cs_interpreter_t<cff2_cs_interp_env_t, OPSET, PARAM> {};\n+\n+} \/* namespace CFF *\/\n+\n+#endif \/* HB_CFF2_INTERP_CS_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-cff2-interp-cs.hh","additions":272,"deletions":0,"binary":false,"changes":272,"status":"added"},{"patch":"@@ -0,0 +1,1131 @@\n+\/*\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-machinery.hh\"\n+\n+#include <locale.h>\n+#ifdef HAVE_XLOCALE_H\n+#include <xlocale.h>\n+#endif\n+\n+\n+\/**\n+ * SECTION:hb-common\n+ * @title: hb-common\n+ * @short_description: Common data types\n+ * @include: hb.h\n+ *\n+ * Common data types used across HarfBuzz are defined here.\n+ **\/\n+\n+\n+\/* hb_options_t *\/\n+\n+hb_atomic_int_t _hb_options;\n+\n+void\n+_hb_options_init ()\n+{\n+  hb_options_union_t u;\n+  u.i = 0;\n+  u.opts.initialized = true;\n+\n+  const char *c = getenv (\"HB_OPTIONS\");\n+  if (c)\n+  {\n+    while (*c)\n+    {\n+      const char *p = strchr (c, ':');\n+      if (!p)\n+        p = c + strlen (c);\n+\n+#define OPTION(name, symbol) \\\n+        if (0 == strncmp (c, name, p - c) && strlen (name) == p - c) u.opts.symbol = true;\n+\n+      OPTION (\"uniscribe-bug-compatible\", uniscribe_bug_compatible);\n+      OPTION (\"aat\", aat);\n+\n+#undef OPTION\n+\n+      c = *p ? p + 1 : p;\n+    }\n+\n+  }\n+\n+  \/* This is idempotent and threadsafe. *\/\n+  _hb_options.set_relaxed (u.i);\n+}\n+\n+\n+\/* hb_tag_t *\/\n+\n+\/**\n+ * hb_tag_from_string:\n+ * @str: (array length=len) (element-type uint8_t):\n+ * @len:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_tag_t\n+hb_tag_from_string (const char *str, int len)\n+{\n+  char tag[4];\n+  unsigned int i;\n+\n+  if (!str || !len || !*str)\n+    return HB_TAG_NONE;\n+\n+  if (len < 0 || len > 4)\n+    len = 4;\n+  for (i = 0; i < (unsigned) len && str[i]; i++)\n+    tag[i] = str[i];\n+  for (; i < 4; i++)\n+    tag[i] = ' ';\n+\n+  return HB_TAG (tag[0], tag[1], tag[2], tag[3]);\n+}\n+\n+\/**\n+ * hb_tag_to_string:\n+ * @tag:\n+ * @buf: (out caller-allocates) (array fixed-size=4) (element-type uint8_t):\n+ *\n+ *\n+ *\n+ * Since: 0.9.5\n+ **\/\n+void\n+hb_tag_to_string (hb_tag_t tag, char *buf)\n+{\n+  buf[0] = (char) (uint8_t) (tag >> 24);\n+  buf[1] = (char) (uint8_t) (tag >> 16);\n+  buf[2] = (char) (uint8_t) (tag >>  8);\n+  buf[3] = (char) (uint8_t) (tag >>  0);\n+}\n+\n+\n+\/* hb_direction_t *\/\n+\n+const char direction_strings[][4] = {\n+  \"ltr\",\n+  \"rtl\",\n+  \"ttb\",\n+  \"btt\"\n+};\n+\n+\/**\n+ * hb_direction_from_string:\n+ * @str: (array length=len) (element-type uint8_t):\n+ * @len:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_direction_t\n+hb_direction_from_string (const char *str, int len)\n+{\n+  if (unlikely (!str || !len || !*str))\n+    return HB_DIRECTION_INVALID;\n+\n+  \/* Lets match loosely: just match the first letter, such that\n+   * all of \"ltr\", \"left-to-right\", etc work!\n+   *\/\n+  char c = TOLOWER (str[0]);\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (direction_strings); i++)\n+    if (c == direction_strings[i][0])\n+      return (hb_direction_t) (HB_DIRECTION_LTR + i);\n+\n+  return HB_DIRECTION_INVALID;\n+}\n+\n+\/**\n+ * hb_direction_to_string:\n+ * @direction:\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+const char *\n+hb_direction_to_string (hb_direction_t direction)\n+{\n+  if (likely ((unsigned int) (direction - HB_DIRECTION_LTR)\n+              < ARRAY_LENGTH (direction_strings)))\n+    return direction_strings[direction - HB_DIRECTION_LTR];\n+\n+  return \"invalid\";\n+}\n+\n+\n+\/* hb_language_t *\/\n+\n+struct hb_language_impl_t {\n+  const char s[1];\n+};\n+\n+static const char canon_map[256] = {\n+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,\n+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,   0,   0,   0,\n+   0,   0,   0,   0,   0,   0,   0,   0,    0,   0,   0,   0,   0,  '-',  0,   0,\n+  '0', '1', '2', '3', '4', '5', '6', '7',  '8', '9',  0,   0,   0,   0,   0,   0,\n+   0,  'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n+  'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,  '-',\n+   0,  'a', 'b', 'c', 'd', 'e', 'f', 'g',  'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',\n+  'p', 'q', 'r', 's', 't', 'u', 'v', 'w',  'x', 'y', 'z',  0,   0,   0,   0,   0\n+};\n+\n+static bool\n+lang_equal (hb_language_t  v1,\n+            const void    *v2)\n+{\n+  const unsigned char *p1 = (const unsigned char *) v1;\n+  const unsigned char *p2 = (const unsigned char *) v2;\n+\n+  while (*p1 && *p1 == canon_map[*p2]) {\n+    p1++;\n+    p2++;\n+  }\n+\n+  return *p1 == canon_map[*p2];\n+}\n+\n+#if 0\n+static unsigned int\n+lang_hash (const void *key)\n+{\n+  const unsigned char *p = key;\n+  unsigned int h = 0;\n+  while (canon_map[*p])\n+    {\n+      h = (h << 5) - h + canon_map[*p];\n+      p++;\n+    }\n+\n+  return h;\n+}\n+#endif\n+\n+\n+struct hb_language_item_t {\n+\n+  struct hb_language_item_t *next;\n+  hb_language_t lang;\n+\n+  bool operator == (const char *s) const\n+  { return lang_equal (lang, s); }\n+\n+  hb_language_item_t & operator = (const char *s) {\n+    \/* If a custom allocated is used calling strdup() pairs\n+    badly with a call to the custom free() in fini() below.\n+    Therefore don't call strdup(), implement its behavior.\n+    *\/\n+    size_t len = strlen(s) + 1;\n+    lang = (hb_language_t) malloc(len);\n+    if (likely (lang))\n+    {\n+      memcpy((unsigned char *) lang, s, len);\n+      for (unsigned char *p = (unsigned char *) lang; *p; p++)\n+        *p = canon_map[*p];\n+    }\n+\n+    return *this;\n+  }\n+\n+  void fini () { free ((void *) lang); }\n+};\n+\n+\n+\/* Thread-safe lock-free language list *\/\n+\n+static hb_atomic_ptr_t <hb_language_item_t> langs;\n+\n+#if HB_USE_ATEXIT\n+static void\n+free_langs ()\n+{\n+retry:\n+  hb_language_item_t *first_lang = langs;\n+  if (unlikely (!langs.cmpexch (first_lang, nullptr)))\n+    goto retry;\n+\n+  while (first_lang) {\n+    hb_language_item_t *next = first_lang->next;\n+    first_lang->fini ();\n+    free (first_lang);\n+    first_lang = next;\n+  }\n+}\n+#endif\n+\n+static hb_language_item_t *\n+lang_find_or_insert (const char *key)\n+{\n+retry:\n+  hb_language_item_t *first_lang = langs;\n+\n+  for (hb_language_item_t *lang = first_lang; lang; lang = lang->next)\n+    if (*lang == key)\n+      return lang;\n+\n+  \/* Not found; allocate one. *\/\n+  hb_language_item_t *lang = (hb_language_item_t *) calloc (1, sizeof (hb_language_item_t));\n+  if (unlikely (!lang))\n+    return nullptr;\n+  lang->next = first_lang;\n+  *lang = key;\n+  if (unlikely (!lang->lang))\n+  {\n+    free (lang);\n+    return nullptr;\n+  }\n+\n+  if (unlikely (!langs.cmpexch (first_lang, lang)))\n+  {\n+    lang->fini ();\n+    free (lang);\n+    goto retry;\n+  }\n+\n+#if HB_USE_ATEXIT\n+  if (!first_lang)\n+    atexit (free_langs); \/* First person registers atexit() callback. *\/\n+#endif\n+\n+  return lang;\n+}\n+\n+\n+\/**\n+ * hb_language_from_string:\n+ * @str: (array length=len) (element-type uint8_t): a string representing\n+ *       a BCP 47 language tag\n+ * @len: length of the @str, or -1 if it is %NULL-terminated.\n+ *\n+ * Converts @str representing a BCP 47 language tag to the corresponding\n+ * #hb_language_t.\n+ *\n+ * Return value: (transfer none):\n+ * The #hb_language_t corresponding to the BCP 47 language tag.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_language_t\n+hb_language_from_string (const char *str, int len)\n+{\n+  if (!str || !len || !*str)\n+    return HB_LANGUAGE_INVALID;\n+\n+  hb_language_item_t *item = nullptr;\n+  if (len >= 0)\n+  {\n+    \/* NUL-terminate it. *\/\n+    char strbuf[64];\n+    len = MIN (len, (int) sizeof (strbuf) - 1);\n+    memcpy (strbuf, str, len);\n+    strbuf[len] = '\\0';\n+    item = lang_find_or_insert (strbuf);\n+  }\n+  else\n+    item = lang_find_or_insert (str);\n+\n+  return likely (item) ? item->lang : HB_LANGUAGE_INVALID;\n+}\n+\n+\/**\n+ * hb_language_to_string:\n+ * @language: an #hb_language_t to convert.\n+ *\n+ * See hb_language_from_string().\n+ *\n+ * Return value: (transfer none):\n+ * A %NULL-terminated string representing the @language. Must not be freed by\n+ * the caller.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+const char *\n+hb_language_to_string (hb_language_t language)\n+{\n+  \/* This is actually nullptr-safe! *\/\n+  return language->s;\n+}\n+\n+\/**\n+ * hb_language_get_default:\n+ *\n+ * Get default language from current locale.\n+ *\n+ * Note that the first time this function is called, it calls\n+ * \"setlocale (LC_CTYPE, nullptr)\" to fetch current locale.  The underlying\n+ * setlocale function is, in many implementations, NOT threadsafe.  To avoid\n+ * problems, call this function once before multiple threads can call it.\n+ * This function is only used from hb_buffer_guess_segment_properties() by\n+ * HarfBuzz itself.\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_language_t\n+hb_language_get_default ()\n+{\n+  static hb_atomic_ptr_t <hb_language_t> default_language;\n+\n+  hb_language_t language = default_language;\n+  if (unlikely (language == HB_LANGUAGE_INVALID))\n+  {\n+    language = hb_language_from_string (setlocale (LC_CTYPE, nullptr), -1);\n+    (void) default_language.cmpexch (HB_LANGUAGE_INVALID, language);\n+  }\n+\n+  return language;\n+}\n+\n+\n+\/* hb_script_t *\/\n+\n+\/**\n+ * hb_script_from_iso15924_tag:\n+ * @tag: an #hb_tag_t representing an ISO 15924 tag.\n+ *\n+ * Converts an ISO 15924 script tag to a corresponding #hb_script_t.\n+ *\n+ * Return value:\n+ * An #hb_script_t corresponding to the ISO 15924 tag.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_script_t\n+hb_script_from_iso15924_tag (hb_tag_t tag)\n+{\n+  if (unlikely (tag == HB_TAG_NONE))\n+    return HB_SCRIPT_INVALID;\n+\n+  \/* Be lenient, adjust case (one capital letter followed by three small letters) *\/\n+  tag = (tag & 0xDFDFDFDFu) | 0x00202020u;\n+\n+  switch (tag) {\n+\n+    \/* These graduated from the 'Q' private-area codes, but\n+     * the old code is still aliased by Unicode, and the Qaai\n+     * one in use by ICU. *\/\n+    case HB_TAG('Q','a','a','i'): return HB_SCRIPT_INHERITED;\n+    case HB_TAG('Q','a','a','c'): return HB_SCRIPT_COPTIC;\n+\n+    \/* Script variants from https:\/\/unicode.org\/iso15924\/ *\/\n+    case HB_TAG('C','y','r','s'): return HB_SCRIPT_CYRILLIC;\n+    case HB_TAG('L','a','t','f'): return HB_SCRIPT_LATIN;\n+    case HB_TAG('L','a','t','g'): return HB_SCRIPT_LATIN;\n+    case HB_TAG('S','y','r','e'): return HB_SCRIPT_SYRIAC;\n+    case HB_TAG('S','y','r','j'): return HB_SCRIPT_SYRIAC;\n+    case HB_TAG('S','y','r','n'): return HB_SCRIPT_SYRIAC;\n+  }\n+\n+  \/* If it looks right, just use the tag as a script *\/\n+  if (((uint32_t) tag & 0xE0E0E0E0u) == 0x40606060u)\n+    return (hb_script_t) tag;\n+\n+  \/* Otherwise, return unknown *\/\n+  return HB_SCRIPT_UNKNOWN;\n+}\n+\n+\/**\n+ * hb_script_from_string:\n+ * @str: (array length=len) (element-type uint8_t): a string representing an\n+ *       ISO 15924 tag.\n+ * @len: length of the @str, or -1 if it is %NULL-terminated.\n+ *\n+ * Converts a string @str representing an ISO 15924 script tag to a\n+ * corresponding #hb_script_t. Shorthand for hb_tag_from_string() then\n+ * hb_script_from_iso15924_tag().\n+ *\n+ * Return value:\n+ * An #hb_script_t corresponding to the ISO 15924 tag.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_script_t\n+hb_script_from_string (const char *str, int len)\n+{\n+  return hb_script_from_iso15924_tag (hb_tag_from_string (str, len));\n+}\n+\n+\/**\n+ * hb_script_to_iso15924_tag:\n+ * @script: an #hb_script_ to convert.\n+ *\n+ * See hb_script_from_iso15924_tag().\n+ *\n+ * Return value:\n+ * An #hb_tag_t representing an ISO 15924 script tag.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_tag_t\n+hb_script_to_iso15924_tag (hb_script_t script)\n+{\n+  return (hb_tag_t) script;\n+}\n+\n+\/**\n+ * hb_script_get_horizontal_direction:\n+ * @script:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_direction_t\n+hb_script_get_horizontal_direction (hb_script_t script)\n+{\n+  \/* https:\/\/docs.google.com\/spreadsheets\/d\/1Y90M0Ie3MUJ6UVCRDOypOtijlMDLNNyyLk36T6iMu0o *\/\n+  switch ((hb_tag_t) script)\n+  {\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_ARABIC:\n+    case HB_SCRIPT_HEBREW:\n+\n+    \/* Unicode-3.0 additions *\/\n+    case HB_SCRIPT_SYRIAC:\n+    case HB_SCRIPT_THAANA:\n+\n+    \/* Unicode-4.0 additions *\/\n+    case HB_SCRIPT_CYPRIOT:\n+\n+    \/* Unicode-4.1 additions *\/\n+    case HB_SCRIPT_KHAROSHTHI:\n+\n+    \/* Unicode-5.0 additions *\/\n+    case HB_SCRIPT_PHOENICIAN:\n+    case HB_SCRIPT_NKO:\n+\n+    \/* Unicode-5.1 additions *\/\n+    case HB_SCRIPT_LYDIAN:\n+\n+    \/* Unicode-5.2 additions *\/\n+    case HB_SCRIPT_AVESTAN:\n+    case HB_SCRIPT_IMPERIAL_ARAMAIC:\n+    case HB_SCRIPT_INSCRIPTIONAL_PAHLAVI:\n+    case HB_SCRIPT_INSCRIPTIONAL_PARTHIAN:\n+    case HB_SCRIPT_OLD_SOUTH_ARABIAN:\n+    case HB_SCRIPT_OLD_TURKIC:\n+    case HB_SCRIPT_SAMARITAN:\n+\n+    \/* Unicode-6.0 additions *\/\n+    case HB_SCRIPT_MANDAIC:\n+\n+    \/* Unicode-6.1 additions *\/\n+    case HB_SCRIPT_MEROITIC_CURSIVE:\n+    case HB_SCRIPT_MEROITIC_HIEROGLYPHS:\n+\n+    \/* Unicode-7.0 additions *\/\n+    case HB_SCRIPT_MANICHAEAN:\n+    case HB_SCRIPT_MENDE_KIKAKUI:\n+    case HB_SCRIPT_NABATAEAN:\n+    case HB_SCRIPT_OLD_NORTH_ARABIAN:\n+    case HB_SCRIPT_PALMYRENE:\n+    case HB_SCRIPT_PSALTER_PAHLAVI:\n+\n+    \/* Unicode-8.0 additions *\/\n+    case HB_SCRIPT_HATRAN:\n+\n+    \/* Unicode-9.0 additions *\/\n+    case HB_SCRIPT_ADLAM:\n+\n+    \/* Unicode-11.0 additions *\/\n+    case HB_SCRIPT_HANIFI_ROHINGYA:\n+    case HB_SCRIPT_OLD_SOGDIAN:\n+    case HB_SCRIPT_SOGDIAN:\n+\n+      return HB_DIRECTION_RTL;\n+\n+\n+    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1000 *\/\n+    case HB_SCRIPT_OLD_HUNGARIAN:\n+    case HB_SCRIPT_OLD_ITALIC:\n+    case HB_SCRIPT_RUNIC:\n+\n+      return HB_DIRECTION_INVALID;\n+  }\n+\n+  return HB_DIRECTION_LTR;\n+}\n+\n+\n+\/* hb_user_data_array_t *\/\n+\n+bool\n+hb_user_data_array_t::set (hb_user_data_key_t *key,\n+                           void *              data,\n+                           hb_destroy_func_t   destroy,\n+                           hb_bool_t           replace)\n+{\n+  if (!key)\n+    return false;\n+\n+  if (replace) {\n+    if (!data && !destroy) {\n+      items.remove (key, lock);\n+      return true;\n+    }\n+  }\n+  hb_user_data_item_t item = {key, data, destroy};\n+  bool ret = !!items.replace_or_insert (item, lock, (bool) replace);\n+\n+  return ret;\n+}\n+\n+void *\n+hb_user_data_array_t::get (hb_user_data_key_t *key)\n+{\n+  hb_user_data_item_t item = {nullptr, nullptr, nullptr};\n+\n+  return items.find (key, &item, lock) ? item.data : nullptr;\n+}\n+\n+\n+\/* hb_version *\/\n+\n+\n+\/**\n+ * SECTION:hb-version\n+ * @title: hb-version\n+ * @short_description: Information about the version of HarfBuzz in use\n+ * @include: hb.h\n+ *\n+ * These functions and macros allow accessing version of the HarfBuzz\n+ * library used at compile- as well as run-time, and to direct code\n+ * conditionally based on those versions, again, at compile- or run-time.\n+ **\/\n+\n+\n+\/**\n+ * hb_version:\n+ * @major: (out): Library major version component.\n+ * @minor: (out): Library minor version component.\n+ * @micro: (out): Library micro version component.\n+ *\n+ * Returns library version as three integer components.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_version (unsigned int *major,\n+            unsigned int *minor,\n+            unsigned int *micro)\n+{\n+  *major = HB_VERSION_MAJOR;\n+  *minor = HB_VERSION_MINOR;\n+  *micro = HB_VERSION_MICRO;\n+}\n+\n+\/**\n+ * hb_version_string:\n+ *\n+ * Returns library version as a string with three components.\n+ *\n+ * Return value: library version string.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+const char *\n+hb_version_string ()\n+{\n+  return HB_VERSION_STRING;\n+}\n+\n+\/**\n+ * hb_version_atleast:\n+ * @major:\n+ * @minor:\n+ * @micro:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.30\n+ **\/\n+hb_bool_t\n+hb_version_atleast (unsigned int major,\n+                    unsigned int minor,\n+                    unsigned int micro)\n+{\n+  return HB_VERSION_ATLEAST (major, minor, micro);\n+}\n+\n+\n+\n+\/* hb_feature_t and hb_variation_t *\/\n+\n+static bool\n+parse_space (const char **pp, const char *end)\n+{\n+  while (*pp < end && ISSPACE (**pp))\n+    (*pp)++;\n+  return true;\n+}\n+\n+static bool\n+parse_char (const char **pp, const char *end, char c)\n+{\n+  parse_space (pp, end);\n+\n+  if (*pp == end || **pp != c)\n+    return false;\n+\n+  (*pp)++;\n+  return true;\n+}\n+\n+static bool\n+parse_uint (const char **pp, const char *end, unsigned int *pv)\n+{\n+  char buf[32];\n+  unsigned int len = MIN (ARRAY_LENGTH (buf) - 1, (unsigned int) (end - *pp));\n+  strncpy (buf, *pp, len);\n+  buf[len] = '\\0';\n+\n+  char *p = buf;\n+  char *pend = p;\n+  unsigned int v;\n+\n+  \/* Intentionally use strtol instead of strtoul, such that\n+   * -1 turns into \"big number\"... *\/\n+  errno = 0;\n+  v = strtol (p, &pend, 0);\n+  if (errno || p == pend)\n+    return false;\n+\n+  *pv = v;\n+  *pp += pend - p;\n+  return true;\n+}\n+\n+static bool\n+parse_uint32 (const char **pp, const char *end, uint32_t *pv)\n+{\n+  char buf[32];\n+  unsigned int len = MIN (ARRAY_LENGTH (buf) - 1, (unsigned int) (end - *pp));\n+  strncpy (buf, *pp, len);\n+  buf[len] = '\\0';\n+\n+  char *p = buf;\n+  char *pend = p;\n+  unsigned int v;\n+\n+  \/* Intentionally use strtol instead of strtoul, such that\n+   * -1 turns into \"big number\"... *\/\n+  errno = 0;\n+  v = strtol (p, &pend, 0);\n+  if (errno || p == pend)\n+    return false;\n+\n+  *pv = v;\n+  *pp += pend - p;\n+  return true;\n+}\n+\n+#if defined (HAVE_NEWLOCALE) && defined (HAVE_STRTOD_L)\n+#define USE_XLOCALE 1\n+#define HB_LOCALE_T locale_t\n+#define HB_CREATE_LOCALE(locName) newlocale (LC_ALL_MASK, locName, nullptr)\n+#define HB_FREE_LOCALE(loc) freelocale (loc)\n+#elif defined(_MSC_VER)\n+#define USE_XLOCALE 1\n+#define HB_LOCALE_T _locale_t\n+#define HB_CREATE_LOCALE(locName) _create_locale (LC_ALL, locName)\n+#define HB_FREE_LOCALE(loc) _free_locale (loc)\n+#define strtod_l(a, b, c) _strtod_l ((a), (b), (c))\n+#endif\n+\n+#ifdef USE_XLOCALE\n+\n+#if HB_USE_ATEXIT\n+static void free_static_C_locale ();\n+#endif\n+\n+static struct hb_C_locale_lazy_loader_t : hb_lazy_loader_t<hb_remove_pointer (HB_LOCALE_T),\n+                                                          hb_C_locale_lazy_loader_t>\n+{\n+  static HB_LOCALE_T create ()\n+  {\n+    HB_LOCALE_T C_locale = HB_CREATE_LOCALE (\"C\");\n+\n+#if HB_USE_ATEXIT\n+    atexit (free_static_C_locale);\n+#endif\n+\n+    return C_locale;\n+  }\n+  static void destroy (HB_LOCALE_T p)\n+  {\n+    HB_FREE_LOCALE (p);\n+  }\n+  static HB_LOCALE_T get_null ()\n+  {\n+    return nullptr;\n+  }\n+} static_C_locale;\n+\n+#if HB_USE_ATEXIT\n+static\n+void free_static_C_locale ()\n+{\n+  static_C_locale.free_instance ();\n+}\n+#endif\n+\n+static HB_LOCALE_T\n+get_C_locale ()\n+{\n+  return static_C_locale.get_unconst ();\n+}\n+#endif \/* USE_XLOCALE *\/\n+\n+static bool\n+parse_float (const char **pp, const char *end, float *pv)\n+{\n+  char buf[32];\n+  unsigned int len = MIN (ARRAY_LENGTH (buf) - 1, (unsigned int) (end - *pp));\n+  strncpy (buf, *pp, len);\n+  buf[len] = '\\0';\n+\n+  char *p = buf;\n+  char *pend = p;\n+  float v;\n+\n+  errno = 0;\n+#ifdef USE_XLOCALE\n+  v = strtod_l (p, &pend, get_C_locale ());\n+#else\n+  v = strtod (p, &pend);\n+#endif\n+  if (errno || p == pend)\n+    return false;\n+\n+  *pv = v;\n+  *pp += pend - p;\n+  return true;\n+}\n+\n+static bool\n+parse_bool (const char **pp, const char *end, uint32_t *pv)\n+{\n+  parse_space (pp, end);\n+\n+  const char *p = *pp;\n+  while (*pp < end && ISALPHA(**pp))\n+    (*pp)++;\n+\n+  \/* CSS allows on\/off as aliases 1\/0. *\/\n+  if (*pp - p == 2 && 0 == strncmp (p, \"on\", 2))\n+    *pv = 1;\n+  else if (*pp - p == 3 && 0 == strncmp (p, \"off\", 3))\n+    *pv = 0;\n+  else\n+    return false;\n+\n+  return true;\n+}\n+\n+\/* hb_feature_t *\/\n+\n+static bool\n+parse_feature_value_prefix (const char **pp, const char *end, hb_feature_t *feature)\n+{\n+  if (parse_char (pp, end, '-'))\n+    feature->value = 0;\n+  else {\n+    parse_char (pp, end, '+');\n+    feature->value = 1;\n+  }\n+\n+  return true;\n+}\n+\n+static bool\n+parse_tag (const char **pp, const char *end, hb_tag_t *tag)\n+{\n+  parse_space (pp, end);\n+\n+  char quote = 0;\n+\n+  if (*pp < end && (**pp == '\\'' || **pp == '\"'))\n+  {\n+    quote = **pp;\n+    (*pp)++;\n+  }\n+\n+  const char *p = *pp;\n+  while (*pp < end && (ISALNUM(**pp) || **pp == '_'))\n+    (*pp)++;\n+\n+  if (p == *pp || *pp - p > 4)\n+    return false;\n+\n+  *tag = hb_tag_from_string (p, *pp - p);\n+\n+  if (quote)\n+  {\n+    \/* CSS expects exactly four bytes.  And we only allow quotations for\n+     * CSS compatibility.  So, enforce the length. *\/\n+     if (*pp - p != 4)\n+       return false;\n+    if (*pp == end || **pp != quote)\n+      return false;\n+    (*pp)++;\n+  }\n+\n+  return true;\n+}\n+\n+static bool\n+parse_feature_indices (const char **pp, const char *end, hb_feature_t *feature)\n+{\n+  parse_space (pp, end);\n+\n+  bool has_start;\n+\n+  feature->start = HB_FEATURE_GLOBAL_START;\n+  feature->end = HB_FEATURE_GLOBAL_END;\n+\n+  if (!parse_char (pp, end, '['))\n+    return true;\n+\n+  has_start = parse_uint (pp, end, &feature->start);\n+\n+  if (parse_char (pp, end, ':') || parse_char (pp, end, ';')) {\n+    parse_uint (pp, end, &feature->end);\n+  } else {\n+    if (has_start)\n+      feature->end = feature->start + 1;\n+  }\n+\n+  return parse_char (pp, end, ']');\n+}\n+\n+static bool\n+parse_feature_value_postfix (const char **pp, const char *end, hb_feature_t *feature)\n+{\n+  bool had_equal = parse_char (pp, end, '=');\n+  bool had_value = parse_uint32 (pp, end, &feature->value) ||\n+                   parse_bool (pp, end, &feature->value);\n+  \/* CSS doesn't use equal-sign between tag and value.\n+   * If there was an equal-sign, then there *must* be a value.\n+   * A value without an equal-sign is ok, but not required. *\/\n+  return !had_equal || had_value;\n+}\n+\n+static bool\n+parse_one_feature (const char **pp, const char *end, hb_feature_t *feature)\n+{\n+  return parse_feature_value_prefix (pp, end, feature) &&\n+         parse_tag (pp, end, &feature->tag) &&\n+         parse_feature_indices (pp, end, feature) &&\n+         parse_feature_value_postfix (pp, end, feature) &&\n+         parse_space (pp, end) &&\n+         *pp == end;\n+}\n+\n+\/**\n+ * hb_feature_from_string:\n+ * @str: (array length=len) (element-type uint8_t): a string to parse\n+ * @len: length of @str, or -1 if string is %NULL terminated\n+ * @feature: (out): the #hb_feature_t to initialize with the parsed values\n+ *\n+ * Parses a string into a #hb_feature_t.\n+ *\n+ * TODO: document the syntax here.\n+ *\n+ * Return value:\n+ * %true if @str is successfully parsed, %false otherwise.\n+ *\n+ * Since: 0.9.5\n+ **\/\n+hb_bool_t\n+hb_feature_from_string (const char *str, int len,\n+                        hb_feature_t *feature)\n+{\n+  hb_feature_t feat;\n+\n+  if (len < 0)\n+    len = strlen (str);\n+\n+  if (likely (parse_one_feature (&str, str + len, &feat)))\n+  {\n+    if (feature)\n+      *feature = feat;\n+    return true;\n+  }\n+\n+  if (feature)\n+    memset (feature, 0, sizeof (*feature));\n+  return false;\n+}\n+\n+\/**\n+ * hb_feature_to_string:\n+ * @feature: an #hb_feature_t to convert\n+ * @buf: (array length=size) (out): output string\n+ * @size: the allocated size of @buf\n+ *\n+ * Converts a #hb_feature_t into a %NULL-terminated string in the format\n+ * understood by hb_feature_from_string(). The client in responsible for\n+ * allocating big enough size for @buf, 128 bytes is more than enough.\n+ *\n+ * Since: 0.9.5\n+ **\/\n+void\n+hb_feature_to_string (hb_feature_t *feature,\n+                      char *buf, unsigned int size)\n+{\n+  if (unlikely (!size)) return;\n+\n+  char s[128];\n+  unsigned int len = 0;\n+  if (feature->value == 0)\n+    s[len++] = '-';\n+  hb_tag_to_string (feature->tag, s + len);\n+  len += 4;\n+  while (len && s[len - 1] == ' ')\n+    len--;\n+  if (feature->start != 0 || feature->end != (unsigned int) -1)\n+  {\n+    s[len++] = '[';\n+    if (feature->start)\n+      len += MAX (0, snprintf (s + len, ARRAY_LENGTH (s) - len, \"%u\", feature->start));\n+    if (feature->end != feature->start + 1) {\n+      s[len++] = ':';\n+      if (feature->end != (unsigned int) -1)\n+        len += MAX (0, snprintf (s + len, ARRAY_LENGTH (s) - len, \"%u\", feature->end));\n+    }\n+    s[len++] = ']';\n+  }\n+  if (feature->value > 1)\n+  {\n+    s[len++] = '=';\n+    len += MAX (0, snprintf (s + len, ARRAY_LENGTH (s) - len, \"%u\", feature->value));\n+  }\n+  assert (len < ARRAY_LENGTH (s));\n+  len = MIN (len, size - 1);\n+  memcpy (buf, s, len);\n+  buf[len] = '\\0';\n+}\n+\n+\/* hb_variation_t *\/\n+\n+static bool\n+parse_variation_value (const char **pp, const char *end, hb_variation_t *variation)\n+{\n+  parse_char (pp, end, '='); \/* Optional. *\/\n+  return parse_float (pp, end, &variation->value);\n+}\n+\n+static bool\n+parse_one_variation (const char **pp, const char *end, hb_variation_t *variation)\n+{\n+  return parse_tag (pp, end, &variation->tag) &&\n+         parse_variation_value (pp, end, variation) &&\n+         parse_space (pp, end) &&\n+         *pp == end;\n+}\n+\n+\/**\n+ * hb_variation_from_string:\n+ *\n+ * Since: 1.4.2\n+ *\/\n+hb_bool_t\n+hb_variation_from_string (const char *str, int len,\n+                          hb_variation_t *variation)\n+{\n+  hb_variation_t var;\n+\n+  if (len < 0)\n+    len = strlen (str);\n+\n+  if (likely (parse_one_variation (&str, str + len, &var)))\n+  {\n+    if (variation)\n+      *variation = var;\n+    return true;\n+  }\n+\n+  if (variation)\n+    memset (variation, 0, sizeof (*variation));\n+  return false;\n+}\n+\n+\/**\n+ * hb_variation_to_string:\n+ *\n+ * Since: 1.4.2\n+ *\/\n+void\n+hb_variation_to_string (hb_variation_t *variation,\n+                        char *buf, unsigned int size)\n+{\n+  if (unlikely (!size)) return;\n+\n+  char s[128];\n+  unsigned int len = 0;\n+  hb_tag_to_string (variation->tag, s + len);\n+  len += 4;\n+  while (len && s[len - 1] == ' ')\n+    len--;\n+  s[len++] = '=';\n+  len += MAX (0, snprintf (s + len, ARRAY_LENGTH (s) - len, \"%g\", (double) variation->value));\n+\n+  assert (len < ARRAY_LENGTH (s));\n+  len = MIN (len, size - 1);\n+  memcpy (buf, s, len);\n+  buf[len] = '\\0';\n+}\n+\n+\/* If there is no visibility control, then hb-static.cc will NOT\n+ * define anything.  Instead, we get it to define one set in here\n+ * only, so only libharfbuzz.so defines them, not other libs. *\/\n+#ifdef HB_NO_VISIBILITY\n+#undef HB_NO_VISIBILITY\n+#include \"hb-static.cc\"\n+#define HB_NO_VISIBILITY 1\n+#endif\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-common.cc","additions":1131,"deletions":0,"binary":false,"changes":1131,"status":"added"},{"patch":"@@ -0,0 +1,498 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_COMMON_H\n+#define HB_COMMON_H\n+\n+#ifndef HB_EXTERN\n+#define HB_EXTERN extern\n+#endif\n+\n+#ifndef HB_BEGIN_DECLS\n+# ifdef __cplusplus\n+#  define HB_BEGIN_DECLS        extern \"C\" {\n+#  define HB_END_DECLS          }\n+# else \/* !__cplusplus *\/\n+#  define HB_BEGIN_DECLS\n+#  define HB_END_DECLS\n+# endif \/* !__cplusplus *\/\n+#endif\n+\n+#if defined (_SVR4) || defined (SVR4) || defined (__OpenBSD__) || \\\n+    defined (_sgi) || defined (__sun) || defined (sun) || \\\n+    defined (__digital__) || defined (__HP_cc)\n+#  include <inttypes.h>\n+#elif defined (_AIX)\n+#  include <sys\/inttypes.h>\n+#elif defined (_MSC_VER) && _MSC_VER < 1600\n+\/* VS 2010 (_MSC_VER 1600) has stdint.h *\/\n+typedef __int8 int8_t;\n+typedef unsigned __int8 uint8_t;\n+typedef __int16 int16_t;\n+typedef unsigned __int16 uint16_t;\n+typedef __int32 int32_t;\n+typedef unsigned __int32 uint32_t;\n+typedef __int64 int64_t;\n+typedef unsigned __int64 uint64_t;\n+#else\n+#  include <stdint.h>\n+#endif\n+\n+#if defined(__GNUC__) && ((__GNUC__ > 3) || (__GNUC__ == 3 && __GNUC_MINOR__ >= 1))\n+#define HB_DEPRECATED __attribute__((__deprecated__))\n+#elif defined(_MSC_VER) && (_MSC_VER >= 1300)\n+#define HB_DEPRECATED __declspec(deprecated)\n+#else\n+#define HB_DEPRECATED\n+#endif\n+\n+#if defined(__GNUC__) && ((__GNUC__ > 4) || (__GNUC__ == 4 && __GNUC_MINOR__ >= 5))\n+#define HB_DEPRECATED_FOR(f) __attribute__((__deprecated__(\"Use '\" #f \"' instead\")))\n+#elif defined(_MSC_FULL_VER) && (_MSC_FULL_VER > 140050320)\n+#define HB_DEPRECATED_FOR(f) __declspec(deprecated(\"is deprecated. Use '\" #f \"' instead\"))\n+#else\n+#define HB_DEPRECATED_FOR(f) HB_DEPRECATED\n+#endif\n+\n+\n+HB_BEGIN_DECLS\n+\n+\n+typedef int hb_bool_t;\n+\n+typedef uint32_t hb_codepoint_t;\n+typedef int32_t hb_position_t;\n+typedef uint32_t hb_mask_t;\n+\n+typedef union _hb_var_int_t {\n+  uint32_t u32;\n+  int32_t i32;\n+  uint16_t u16[2];\n+  int16_t i16[2];\n+  uint8_t u8[4];\n+  int8_t i8[4];\n+} hb_var_int_t;\n+\n+\n+\/* hb_tag_t *\/\n+\n+typedef uint32_t hb_tag_t;\n+\n+#define HB_TAG(c1,c2,c3,c4) ((hb_tag_t)((((uint32_t)(c1)&0xFF)<<24)|(((uint32_t)(c2)&0xFF)<<16)|(((uint32_t)(c3)&0xFF)<<8)|((uint32_t)(c4)&0xFF)))\n+#define HB_UNTAG(tag)   (uint8_t)(((tag)>>24)&0xFF), (uint8_t)(((tag)>>16)&0xFF), (uint8_t)(((tag)>>8)&0xFF), (uint8_t)((tag)&0xFF)\n+\n+#define HB_TAG_NONE HB_TAG(0,0,0,0)\n+#define HB_TAG_MAX HB_TAG(0xff,0xff,0xff,0xff)\n+#define HB_TAG_MAX_SIGNED HB_TAG(0x7f,0xff,0xff,0xff)\n+\n+\/* len=-1 means str is NUL-terminated. *\/\n+HB_EXTERN hb_tag_t\n+hb_tag_from_string (const char *str, int len);\n+\n+\/* buf should have 4 bytes. *\/\n+HB_EXTERN void\n+hb_tag_to_string (hb_tag_t tag, char *buf);\n+\n+\n+\/**\n+ * hb_direction_t:\n+ * @HB_DIRECTION_INVALID: Initial, unset direction.\n+ * @HB_DIRECTION_LTR: Text is set horizontally from left to right.\n+ * @HB_DIRECTION_RTL: Text is set horizontally from right to left.\n+ * @HB_DIRECTION_TTB: Text is set vertically from top to bottom.\n+ * @HB_DIRECTION_BTT: Text is set vertically from bottom to top.\n+ *\/\n+typedef enum {\n+  HB_DIRECTION_INVALID = 0,\n+  HB_DIRECTION_LTR = 4,\n+  HB_DIRECTION_RTL,\n+  HB_DIRECTION_TTB,\n+  HB_DIRECTION_BTT\n+} hb_direction_t;\n+\n+\/* len=-1 means str is NUL-terminated *\/\n+HB_EXTERN hb_direction_t\n+hb_direction_from_string (const char *str, int len);\n+\n+HB_EXTERN const char *\n+hb_direction_to_string (hb_direction_t direction);\n+\n+#define HB_DIRECTION_IS_VALID(dir)      ((((unsigned int) (dir)) & ~3U) == 4)\n+\/* Direction must be valid for the following *\/\n+#define HB_DIRECTION_IS_HORIZONTAL(dir) ((((unsigned int) (dir)) & ~1U) == 4)\n+#define HB_DIRECTION_IS_VERTICAL(dir)   ((((unsigned int) (dir)) & ~1U) == 6)\n+#define HB_DIRECTION_IS_FORWARD(dir)    ((((unsigned int) (dir)) & ~2U) == 4)\n+#define HB_DIRECTION_IS_BACKWARD(dir)   ((((unsigned int) (dir)) & ~2U) == 5)\n+#define HB_DIRECTION_REVERSE(dir)       ((hb_direction_t) (((unsigned int) (dir)) ^ 1))\n+\n+\n+\/* hb_language_t *\/\n+\n+typedef const struct hb_language_impl_t *hb_language_t;\n+\n+HB_EXTERN hb_language_t\n+hb_language_from_string (const char *str, int len);\n+\n+HB_EXTERN const char *\n+hb_language_to_string (hb_language_t language);\n+\n+#define HB_LANGUAGE_INVALID ((hb_language_t) 0)\n+\n+HB_EXTERN hb_language_t\n+hb_language_get_default (void);\n+\n+\n+\/* hb_script_t *\/\n+\n+\/* https:\/\/unicode.org\/iso15924\/ *\/\n+\/* https:\/\/docs.google.com\/spreadsheets\/d\/1Y90M0Ie3MUJ6UVCRDOypOtijlMDLNNyyLk36T6iMu0o *\/\n+\/* Unicode Character Database property: Script (sc) *\/\n+typedef enum\n+{\n+  \/*1.1*\/ HB_SCRIPT_COMMON                      = HB_TAG ('Z','y','y','y'),\n+  \/*1.1*\/ HB_SCRIPT_INHERITED                   = HB_TAG ('Z','i','n','h'),\n+  \/*5.0*\/ HB_SCRIPT_UNKNOWN                     = HB_TAG ('Z','z','z','z'),\n+\n+  \/*1.1*\/ HB_SCRIPT_ARABIC                      = HB_TAG ('A','r','a','b'),\n+  \/*1.1*\/ HB_SCRIPT_ARMENIAN                    = HB_TAG ('A','r','m','n'),\n+  \/*1.1*\/ HB_SCRIPT_BENGALI                     = HB_TAG ('B','e','n','g'),\n+  \/*1.1*\/ HB_SCRIPT_CYRILLIC                    = HB_TAG ('C','y','r','l'),\n+  \/*1.1*\/ HB_SCRIPT_DEVANAGARI                  = HB_TAG ('D','e','v','a'),\n+  \/*1.1*\/ HB_SCRIPT_GEORGIAN                    = HB_TAG ('G','e','o','r'),\n+  \/*1.1*\/ HB_SCRIPT_GREEK                       = HB_TAG ('G','r','e','k'),\n+  \/*1.1*\/ HB_SCRIPT_GUJARATI                    = HB_TAG ('G','u','j','r'),\n+  \/*1.1*\/ HB_SCRIPT_GURMUKHI                    = HB_TAG ('G','u','r','u'),\n+  \/*1.1*\/ HB_SCRIPT_HANGUL                      = HB_TAG ('H','a','n','g'),\n+  \/*1.1*\/ HB_SCRIPT_HAN                         = HB_TAG ('H','a','n','i'),\n+  \/*1.1*\/ HB_SCRIPT_HEBREW                      = HB_TAG ('H','e','b','r'),\n+  \/*1.1*\/ HB_SCRIPT_HIRAGANA                    = HB_TAG ('H','i','r','a'),\n+  \/*1.1*\/ HB_SCRIPT_KANNADA                     = HB_TAG ('K','n','d','a'),\n+  \/*1.1*\/ HB_SCRIPT_KATAKANA                    = HB_TAG ('K','a','n','a'),\n+  \/*1.1*\/ HB_SCRIPT_LAO                         = HB_TAG ('L','a','o','o'),\n+  \/*1.1*\/ HB_SCRIPT_LATIN                       = HB_TAG ('L','a','t','n'),\n+  \/*1.1*\/ HB_SCRIPT_MALAYALAM                   = HB_TAG ('M','l','y','m'),\n+  \/*1.1*\/ HB_SCRIPT_ORIYA                       = HB_TAG ('O','r','y','a'),\n+  \/*1.1*\/ HB_SCRIPT_TAMIL                       = HB_TAG ('T','a','m','l'),\n+  \/*1.1*\/ HB_SCRIPT_TELUGU                      = HB_TAG ('T','e','l','u'),\n+  \/*1.1*\/ HB_SCRIPT_THAI                        = HB_TAG ('T','h','a','i'),\n+\n+  \/*2.0*\/ HB_SCRIPT_TIBETAN                     = HB_TAG ('T','i','b','t'),\n+\n+  \/*3.0*\/ HB_SCRIPT_BOPOMOFO                    = HB_TAG ('B','o','p','o'),\n+  \/*3.0*\/ HB_SCRIPT_BRAILLE                     = HB_TAG ('B','r','a','i'),\n+  \/*3.0*\/ HB_SCRIPT_CANADIAN_SYLLABICS          = HB_TAG ('C','a','n','s'),\n+  \/*3.0*\/ HB_SCRIPT_CHEROKEE                    = HB_TAG ('C','h','e','r'),\n+  \/*3.0*\/ HB_SCRIPT_ETHIOPIC                    = HB_TAG ('E','t','h','i'),\n+  \/*3.0*\/ HB_SCRIPT_KHMER                       = HB_TAG ('K','h','m','r'),\n+  \/*3.0*\/ HB_SCRIPT_MONGOLIAN                   = HB_TAG ('M','o','n','g'),\n+  \/*3.0*\/ HB_SCRIPT_MYANMAR                     = HB_TAG ('M','y','m','r'),\n+  \/*3.0*\/ HB_SCRIPT_OGHAM                       = HB_TAG ('O','g','a','m'),\n+  \/*3.0*\/ HB_SCRIPT_RUNIC                       = HB_TAG ('R','u','n','r'),\n+  \/*3.0*\/ HB_SCRIPT_SINHALA                     = HB_TAG ('S','i','n','h'),\n+  \/*3.0*\/ HB_SCRIPT_SYRIAC                      = HB_TAG ('S','y','r','c'),\n+  \/*3.0*\/ HB_SCRIPT_THAANA                      = HB_TAG ('T','h','a','a'),\n+  \/*3.0*\/ HB_SCRIPT_YI                          = HB_TAG ('Y','i','i','i'),\n+\n+  \/*3.1*\/ HB_SCRIPT_DESERET                     = HB_TAG ('D','s','r','t'),\n+  \/*3.1*\/ HB_SCRIPT_GOTHIC                      = HB_TAG ('G','o','t','h'),\n+  \/*3.1*\/ HB_SCRIPT_OLD_ITALIC                  = HB_TAG ('I','t','a','l'),\n+\n+  \/*3.2*\/ HB_SCRIPT_BUHID                       = HB_TAG ('B','u','h','d'),\n+  \/*3.2*\/ HB_SCRIPT_HANUNOO                     = HB_TAG ('H','a','n','o'),\n+  \/*3.2*\/ HB_SCRIPT_TAGALOG                     = HB_TAG ('T','g','l','g'),\n+  \/*3.2*\/ HB_SCRIPT_TAGBANWA                    = HB_TAG ('T','a','g','b'),\n+\n+  \/*4.0*\/ HB_SCRIPT_CYPRIOT                     = HB_TAG ('C','p','r','t'),\n+  \/*4.0*\/ HB_SCRIPT_LIMBU                       = HB_TAG ('L','i','m','b'),\n+  \/*4.0*\/ HB_SCRIPT_LINEAR_B                    = HB_TAG ('L','i','n','b'),\n+  \/*4.0*\/ HB_SCRIPT_OSMANYA                     = HB_TAG ('O','s','m','a'),\n+  \/*4.0*\/ HB_SCRIPT_SHAVIAN                     = HB_TAG ('S','h','a','w'),\n+  \/*4.0*\/ HB_SCRIPT_TAI_LE                      = HB_TAG ('T','a','l','e'),\n+  \/*4.0*\/ HB_SCRIPT_UGARITIC                    = HB_TAG ('U','g','a','r'),\n+\n+  \/*4.1*\/ HB_SCRIPT_BUGINESE                    = HB_TAG ('B','u','g','i'),\n+  \/*4.1*\/ HB_SCRIPT_COPTIC                      = HB_TAG ('C','o','p','t'),\n+  \/*4.1*\/ HB_SCRIPT_GLAGOLITIC                  = HB_TAG ('G','l','a','g'),\n+  \/*4.1*\/ HB_SCRIPT_KHAROSHTHI                  = HB_TAG ('K','h','a','r'),\n+  \/*4.1*\/ HB_SCRIPT_NEW_TAI_LUE                 = HB_TAG ('T','a','l','u'),\n+  \/*4.1*\/ HB_SCRIPT_OLD_PERSIAN                 = HB_TAG ('X','p','e','o'),\n+  \/*4.1*\/ HB_SCRIPT_SYLOTI_NAGRI                = HB_TAG ('S','y','l','o'),\n+  \/*4.1*\/ HB_SCRIPT_TIFINAGH                    = HB_TAG ('T','f','n','g'),\n+\n+  \/*5.0*\/ HB_SCRIPT_BALINESE                    = HB_TAG ('B','a','l','i'),\n+  \/*5.0*\/ HB_SCRIPT_CUNEIFORM                   = HB_TAG ('X','s','u','x'),\n+  \/*5.0*\/ HB_SCRIPT_NKO                         = HB_TAG ('N','k','o','o'),\n+  \/*5.0*\/ HB_SCRIPT_PHAGS_PA                    = HB_TAG ('P','h','a','g'),\n+  \/*5.0*\/ HB_SCRIPT_PHOENICIAN                  = HB_TAG ('P','h','n','x'),\n+\n+  \/*5.1*\/ HB_SCRIPT_CARIAN                      = HB_TAG ('C','a','r','i'),\n+  \/*5.1*\/ HB_SCRIPT_CHAM                        = HB_TAG ('C','h','a','m'),\n+  \/*5.1*\/ HB_SCRIPT_KAYAH_LI                    = HB_TAG ('K','a','l','i'),\n+  \/*5.1*\/ HB_SCRIPT_LEPCHA                      = HB_TAG ('L','e','p','c'),\n+  \/*5.1*\/ HB_SCRIPT_LYCIAN                      = HB_TAG ('L','y','c','i'),\n+  \/*5.1*\/ HB_SCRIPT_LYDIAN                      = HB_TAG ('L','y','d','i'),\n+  \/*5.1*\/ HB_SCRIPT_OL_CHIKI                    = HB_TAG ('O','l','c','k'),\n+  \/*5.1*\/ HB_SCRIPT_REJANG                      = HB_TAG ('R','j','n','g'),\n+  \/*5.1*\/ HB_SCRIPT_SAURASHTRA                  = HB_TAG ('S','a','u','r'),\n+  \/*5.1*\/ HB_SCRIPT_SUNDANESE                   = HB_TAG ('S','u','n','d'),\n+  \/*5.1*\/ HB_SCRIPT_VAI                         = HB_TAG ('V','a','i','i'),\n+\n+  \/*5.2*\/ HB_SCRIPT_AVESTAN                     = HB_TAG ('A','v','s','t'),\n+  \/*5.2*\/ HB_SCRIPT_BAMUM                       = HB_TAG ('B','a','m','u'),\n+  \/*5.2*\/ HB_SCRIPT_EGYPTIAN_HIEROGLYPHS        = HB_TAG ('E','g','y','p'),\n+  \/*5.2*\/ HB_SCRIPT_IMPERIAL_ARAMAIC            = HB_TAG ('A','r','m','i'),\n+  \/*5.2*\/ HB_SCRIPT_INSCRIPTIONAL_PAHLAVI       = HB_TAG ('P','h','l','i'),\n+  \/*5.2*\/ HB_SCRIPT_INSCRIPTIONAL_PARTHIAN      = HB_TAG ('P','r','t','i'),\n+  \/*5.2*\/ HB_SCRIPT_JAVANESE                    = HB_TAG ('J','a','v','a'),\n+  \/*5.2*\/ HB_SCRIPT_KAITHI                      = HB_TAG ('K','t','h','i'),\n+  \/*5.2*\/ HB_SCRIPT_LISU                        = HB_TAG ('L','i','s','u'),\n+  \/*5.2*\/ HB_SCRIPT_MEETEI_MAYEK                = HB_TAG ('M','t','e','i'),\n+  \/*5.2*\/ HB_SCRIPT_OLD_SOUTH_ARABIAN           = HB_TAG ('S','a','r','b'),\n+  \/*5.2*\/ HB_SCRIPT_OLD_TURKIC                  = HB_TAG ('O','r','k','h'),\n+  \/*5.2*\/ HB_SCRIPT_SAMARITAN                   = HB_TAG ('S','a','m','r'),\n+  \/*5.2*\/ HB_SCRIPT_TAI_THAM                    = HB_TAG ('L','a','n','a'),\n+  \/*5.2*\/ HB_SCRIPT_TAI_VIET                    = HB_TAG ('T','a','v','t'),\n+\n+  \/*6.0*\/ HB_SCRIPT_BATAK                       = HB_TAG ('B','a','t','k'),\n+  \/*6.0*\/ HB_SCRIPT_BRAHMI                      = HB_TAG ('B','r','a','h'),\n+  \/*6.0*\/ HB_SCRIPT_MANDAIC                     = HB_TAG ('M','a','n','d'),\n+\n+  \/*6.1*\/ HB_SCRIPT_CHAKMA                      = HB_TAG ('C','a','k','m'),\n+  \/*6.1*\/ HB_SCRIPT_MEROITIC_CURSIVE            = HB_TAG ('M','e','r','c'),\n+  \/*6.1*\/ HB_SCRIPT_MEROITIC_HIEROGLYPHS        = HB_TAG ('M','e','r','o'),\n+  \/*6.1*\/ HB_SCRIPT_MIAO                        = HB_TAG ('P','l','r','d'),\n+  \/*6.1*\/ HB_SCRIPT_SHARADA                     = HB_TAG ('S','h','r','d'),\n+  \/*6.1*\/ HB_SCRIPT_SORA_SOMPENG                = HB_TAG ('S','o','r','a'),\n+  \/*6.1*\/ HB_SCRIPT_TAKRI                       = HB_TAG ('T','a','k','r'),\n+\n+  \/*\n+   * Since: 0.9.30\n+   *\/\n+  \/*7.0*\/ HB_SCRIPT_BASSA_VAH                   = HB_TAG ('B','a','s','s'),\n+  \/*7.0*\/ HB_SCRIPT_CAUCASIAN_ALBANIAN          = HB_TAG ('A','g','h','b'),\n+  \/*7.0*\/ HB_SCRIPT_DUPLOYAN                    = HB_TAG ('D','u','p','l'),\n+  \/*7.0*\/ HB_SCRIPT_ELBASAN                     = HB_TAG ('E','l','b','a'),\n+  \/*7.0*\/ HB_SCRIPT_GRANTHA                     = HB_TAG ('G','r','a','n'),\n+  \/*7.0*\/ HB_SCRIPT_KHOJKI                      = HB_TAG ('K','h','o','j'),\n+  \/*7.0*\/ HB_SCRIPT_KHUDAWADI                   = HB_TAG ('S','i','n','d'),\n+  \/*7.0*\/ HB_SCRIPT_LINEAR_A                    = HB_TAG ('L','i','n','a'),\n+  \/*7.0*\/ HB_SCRIPT_MAHAJANI                    = HB_TAG ('M','a','h','j'),\n+  \/*7.0*\/ HB_SCRIPT_MANICHAEAN                  = HB_TAG ('M','a','n','i'),\n+  \/*7.0*\/ HB_SCRIPT_MENDE_KIKAKUI               = HB_TAG ('M','e','n','d'),\n+  \/*7.0*\/ HB_SCRIPT_MODI                        = HB_TAG ('M','o','d','i'),\n+  \/*7.0*\/ HB_SCRIPT_MRO                         = HB_TAG ('M','r','o','o'),\n+  \/*7.0*\/ HB_SCRIPT_NABATAEAN                   = HB_TAG ('N','b','a','t'),\n+  \/*7.0*\/ HB_SCRIPT_OLD_NORTH_ARABIAN           = HB_TAG ('N','a','r','b'),\n+  \/*7.0*\/ HB_SCRIPT_OLD_PERMIC                  = HB_TAG ('P','e','r','m'),\n+  \/*7.0*\/ HB_SCRIPT_PAHAWH_HMONG                = HB_TAG ('H','m','n','g'),\n+  \/*7.0*\/ HB_SCRIPT_PALMYRENE                   = HB_TAG ('P','a','l','m'),\n+  \/*7.0*\/ HB_SCRIPT_PAU_CIN_HAU                 = HB_TAG ('P','a','u','c'),\n+  \/*7.0*\/ HB_SCRIPT_PSALTER_PAHLAVI             = HB_TAG ('P','h','l','p'),\n+  \/*7.0*\/ HB_SCRIPT_SIDDHAM                     = HB_TAG ('S','i','d','d'),\n+  \/*7.0*\/ HB_SCRIPT_TIRHUTA                     = HB_TAG ('T','i','r','h'),\n+  \/*7.0*\/ HB_SCRIPT_WARANG_CITI                 = HB_TAG ('W','a','r','a'),\n+\n+  \/*8.0*\/ HB_SCRIPT_AHOM                        = HB_TAG ('A','h','o','m'),\n+  \/*8.0*\/ HB_SCRIPT_ANATOLIAN_HIEROGLYPHS       = HB_TAG ('H','l','u','w'),\n+  \/*8.0*\/ HB_SCRIPT_HATRAN                      = HB_TAG ('H','a','t','r'),\n+  \/*8.0*\/ HB_SCRIPT_MULTANI                     = HB_TAG ('M','u','l','t'),\n+  \/*8.0*\/ HB_SCRIPT_OLD_HUNGARIAN               = HB_TAG ('H','u','n','g'),\n+  \/*8.0*\/ HB_SCRIPT_SIGNWRITING                 = HB_TAG ('S','g','n','w'),\n+\n+  \/*\n+   * Since 1.3.0\n+   *\/\n+  \/*9.0*\/ HB_SCRIPT_ADLAM                       = HB_TAG ('A','d','l','m'),\n+  \/*9.0*\/ HB_SCRIPT_BHAIKSUKI                   = HB_TAG ('B','h','k','s'),\n+  \/*9.0*\/ HB_SCRIPT_MARCHEN                     = HB_TAG ('M','a','r','c'),\n+  \/*9.0*\/ HB_SCRIPT_OSAGE                       = HB_TAG ('O','s','g','e'),\n+  \/*9.0*\/ HB_SCRIPT_TANGUT                      = HB_TAG ('T','a','n','g'),\n+  \/*9.0*\/ HB_SCRIPT_NEWA                        = HB_TAG ('N','e','w','a'),\n+\n+  \/*\n+   * Since 1.6.0\n+   *\/\n+  \/*10.0*\/HB_SCRIPT_MASARAM_GONDI               = HB_TAG ('G','o','n','m'),\n+  \/*10.0*\/HB_SCRIPT_NUSHU                       = HB_TAG ('N','s','h','u'),\n+  \/*10.0*\/HB_SCRIPT_SOYOMBO                     = HB_TAG ('S','o','y','o'),\n+  \/*10.0*\/HB_SCRIPT_ZANABAZAR_SQUARE            = HB_TAG ('Z','a','n','b'),\n+\n+  \/*\n+   * Since 1.8.0\n+   *\/\n+  \/*11.0*\/HB_SCRIPT_DOGRA                       = HB_TAG ('D','o','g','r'),\n+  \/*11.0*\/HB_SCRIPT_GUNJALA_GONDI               = HB_TAG ('G','o','n','g'),\n+  \/*11.0*\/HB_SCRIPT_HANIFI_ROHINGYA             = HB_TAG ('R','o','h','g'),\n+  \/*11.0*\/HB_SCRIPT_MAKASAR                     = HB_TAG ('M','a','k','a'),\n+  \/*11.0*\/HB_SCRIPT_MEDEFAIDRIN                 = HB_TAG ('M','e','d','f'),\n+  \/*11.0*\/HB_SCRIPT_OLD_SOGDIAN                 = HB_TAG ('S','o','g','o'),\n+  \/*11.0*\/HB_SCRIPT_SOGDIAN                     = HB_TAG ('S','o','g','d'),\n+\n+  \/* No script set. *\/\n+  HB_SCRIPT_INVALID                             = HB_TAG_NONE,\n+\n+  \/* Dummy values to ensure any hb_tag_t value can be passed\/stored as hb_script_t\n+   * without risking undefined behavior.  We have two, for historical reasons.\n+   * HB_TAG_MAX used to be unsigned, but that was invalid Ansi C, so was changed\n+   * to _HB_SCRIPT_MAX_VALUE to be equal to HB_TAG_MAX_SIGNED as well.\n+   *\n+   * See this thread for technicalities:\n+   *\n+   *   https:\/\/lists.freedesktop.org\/archives\/harfbuzz\/2014-March\/004150.html\n+   *\/\n+  _HB_SCRIPT_MAX_VALUE                          = HB_TAG_MAX_SIGNED, \/*< skip >*\/\n+  _HB_SCRIPT_MAX_VALUE_SIGNED                   = HB_TAG_MAX_SIGNED \/*< skip >*\/\n+\n+} hb_script_t;\n+\n+\n+\/* Script functions *\/\n+\n+HB_EXTERN hb_script_t\n+hb_script_from_iso15924_tag (hb_tag_t tag);\n+\n+HB_EXTERN hb_script_t\n+hb_script_from_string (const char *str, int len);\n+\n+HB_EXTERN hb_tag_t\n+hb_script_to_iso15924_tag (hb_script_t script);\n+\n+HB_EXTERN hb_direction_t\n+hb_script_get_horizontal_direction (hb_script_t script);\n+\n+\n+\/* User data *\/\n+\n+typedef struct hb_user_data_key_t {\n+  \/*< private >*\/\n+  char unused;\n+} hb_user_data_key_t;\n+\n+typedef void (*hb_destroy_func_t) (void *user_data);\n+\n+\n+\/* Font features and variations. *\/\n+\n+\/**\n+ * HB_FEATURE_GLOBAL_START\n+ *\n+ * Since: 2.0.0\n+ *\/\n+#define HB_FEATURE_GLOBAL_START 0\n+\/**\n+ * HB_FEATURE_GLOBAL_END\n+ *\n+ * Since: 2.0.0\n+ *\/\n+#define HB_FEATURE_GLOBAL_END   ((unsigned int) -1)\n+\n+typedef struct hb_feature_t {\n+  hb_tag_t      tag;\n+  uint32_t      value;\n+  unsigned int  start;\n+  unsigned int  end;\n+} hb_feature_t;\n+\n+HB_EXTERN hb_bool_t\n+hb_feature_from_string (const char *str, int len,\n+                        hb_feature_t *feature);\n+\n+HB_EXTERN void\n+hb_feature_to_string (hb_feature_t *feature,\n+                      char *buf, unsigned int size);\n+\n+\/**\n+ * hb_variation_t:\n+ *\n+ * Since: 1.4.2\n+ *\/\n+typedef struct hb_variation_t {\n+  hb_tag_t tag;\n+  float    value;\n+} hb_variation_t;\n+\n+HB_EXTERN hb_bool_t\n+hb_variation_from_string (const char *str, int len,\n+                          hb_variation_t *variation);\n+\n+HB_EXTERN void\n+hb_variation_to_string (hb_variation_t *variation,\n+                        char *buf, unsigned int size);\n+\n+\/**\n+ * hb_color_t:\n+ *\n+ * Data type for holding color values.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+typedef uint32_t hb_color_t;\n+\n+#define HB_COLOR(b,g,r,a) ((hb_color_t) HB_TAG ((b),(g),(r),(a)))\n+\n+\/**\n+ * hb_color_get_alpha:\n+ *\n+ *\n+ *\n+ * Since: 2.1.0\n+ *\/\n+#define hb_color_get_alpha(color)       ((color) & 0xFF)\n+\/**\n+ * hb_color_get_red:\n+ *\n+ *\n+ *\n+ * Since: 2.1.0\n+ *\/\n+#define hb_color_get_red(color)         (((color) >> 8) & 0xFF)\n+\/**\n+ * hb_color_get_green:\n+ *\n+ *\n+ *\n+ * Since: 2.1.0\n+ *\/\n+#define hb_color_get_green(color)       (((color) >> 16) & 0xFF)\n+\/**\n+ * hb_color_get_blue:\n+ *\n+ *\n+ *\n+ * Since: 2.1.0\n+ *\/\n+#define hb_color_get_blue(color)        (((color) >> 24) & 0xFF)\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_COMMON_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-common.h","additions":498,"deletions":0,"binary":false,"changes":498,"status":"added"},{"patch":"@@ -0,0 +1,471 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_DEBUG_HH\n+#define HB_DEBUG_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-atomic.hh\"\n+#include \"hb-dsalgs.hh\"\n+\n+\n+#ifndef HB_DEBUG\n+#define HB_DEBUG 0\n+#endif\n+\n+\n+\/*\n+ * Global runtime options.\n+ *\/\n+\n+struct hb_options_t\n+{\n+  bool unused : 1; \/* In-case sign bit is here. *\/\n+  bool initialized : 1;\n+  bool uniscribe_bug_compatible : 1;\n+  bool aat : 1;\n+};\n+\n+union hb_options_union_t {\n+  int i;\n+  hb_options_t opts;\n+};\n+static_assert ((sizeof (hb_atomic_int_t) >= sizeof (hb_options_union_t)), \"\");\n+\n+HB_INTERNAL void\n+_hb_options_init ();\n+\n+extern HB_INTERNAL hb_atomic_int_t _hb_options;\n+\n+static inline hb_options_t\n+hb_options ()\n+{\n+  \/* Make a local copy, so we can access bitfield threadsafely. *\/\n+  hb_options_union_t u;\n+  u.i = _hb_options.get_relaxed ();\n+\n+  if (unlikely (!u.i))\n+  {\n+    _hb_options_init ();\n+    u.i = _hb_options.get_relaxed ();\n+  }\n+\n+  return u.opts;\n+}\n+\n+\n+\/*\n+ * Debug output (needs enabling at compile time.)\n+ *\/\n+\n+static inline bool\n+_hb_debug (unsigned int level,\n+           unsigned int max_level)\n+{\n+  return level < max_level;\n+}\n+\n+#define DEBUG_LEVEL_ENABLED(WHAT, LEVEL) (_hb_debug ((LEVEL), HB_DEBUG_##WHAT))\n+#define DEBUG_ENABLED(WHAT) (DEBUG_LEVEL_ENABLED (WHAT, 0))\n+\n+static inline void\n+_hb_print_func (const char *func)\n+{\n+  if (func)\n+  {\n+    unsigned int func_len = strlen (func);\n+    \/* Skip \"static\" *\/\n+    if (0 == strncmp (func, \"static \", 7))\n+      func += 7;\n+    \/* Skip \"typename\" *\/\n+    if (0 == strncmp (func, \"typename \", 9))\n+      func += 9;\n+    \/* Skip return type *\/\n+    const char *space = strchr (func, ' ');\n+    if (space)\n+      func = space + 1;\n+    \/* Skip parameter list *\/\n+    const char *paren = strchr (func, '(');\n+    if (paren)\n+      func_len = paren - func;\n+    fprintf (stderr, \"%.*s\", func_len, func);\n+  }\n+}\n+\n+template <int max_level> static inline void\n+_hb_debug_msg_va (const char *what,\n+                  const void *obj,\n+                  const char *func,\n+                  bool indented,\n+                  unsigned int level,\n+                  int level_dir,\n+                  const char *message,\n+                  va_list ap) HB_PRINTF_FUNC(7, 0);\n+template <int max_level> static inline void\n+_hb_debug_msg_va (const char *what,\n+                  const void *obj,\n+                  const char *func,\n+                  bool indented,\n+                  unsigned int level,\n+                  int level_dir,\n+                  const char *message,\n+                  va_list ap)\n+{\n+  if (!_hb_debug (level, max_level))\n+    return;\n+\n+  fprintf (stderr, \"%-10s\", what ? what : \"\");\n+\n+  if (obj)\n+    fprintf (stderr, \"(%*p) \", (unsigned int) (2 * sizeof (void *)), obj);\n+  else\n+    fprintf (stderr, \" %*s  \", (unsigned int) (2 * sizeof (void *)), \"\");\n+\n+  if (indented) {\n+#define VBAR    \"\\342\\224\\202\"  \/* U+2502 BOX DRAWINGS LIGHT VERTICAL *\/\n+#define VRBAR   \"\\342\\224\\234\"  \/* U+251C BOX DRAWINGS LIGHT VERTICAL AND RIGHT *\/\n+#define DLBAR   \"\\342\\225\\256\"  \/* U+256E BOX DRAWINGS LIGHT ARC DOWN AND LEFT *\/\n+#define ULBAR   \"\\342\\225\\257\"  \/* U+256F BOX DRAWINGS LIGHT ARC UP AND LEFT *\/\n+#define LBAR    \"\\342\\225\\264\"  \/* U+2574 BOX DRAWINGS LIGHT LEFT *\/\n+    static const char bars[] =\n+      VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR\n+      VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR\n+      VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR\n+      VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR\n+      VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR VBAR;\n+    fprintf (stderr, \"%2u %s\" VRBAR \"%s\",\n+             level,\n+             bars + sizeof (bars) - 1 - MIN ((unsigned int) sizeof (bars) - 1, (unsigned int) (sizeof (VBAR) - 1) * level),\n+             level_dir ? (level_dir > 0 ? DLBAR : ULBAR) : LBAR);\n+  } else\n+    fprintf (stderr, \"   \" VRBAR LBAR);\n+\n+  _hb_print_func (func);\n+\n+  if (message)\n+  {\n+    fprintf (stderr, \": \");\n+    vfprintf (stderr, message, ap);\n+  }\n+\n+  fprintf (stderr, \"\\n\");\n+}\n+template <> inline void HB_PRINTF_FUNC(7, 0)\n+_hb_debug_msg_va<0> (const char *what HB_UNUSED,\n+                     const void *obj HB_UNUSED,\n+                     const char *func HB_UNUSED,\n+                     bool indented HB_UNUSED,\n+                     unsigned int level HB_UNUSED,\n+                     int level_dir HB_UNUSED,\n+                     const char *message HB_UNUSED,\n+                     va_list ap HB_UNUSED) {}\n+\n+template <int max_level> static inline void\n+_hb_debug_msg (const char *what,\n+               const void *obj,\n+               const char *func,\n+               bool indented,\n+               unsigned int level,\n+               int level_dir,\n+               const char *message,\n+               ...) HB_PRINTF_FUNC(7, 8);\n+template <int max_level> static inline void HB_PRINTF_FUNC(7, 8)\n+_hb_debug_msg (const char *what,\n+               const void *obj,\n+               const char *func,\n+               bool indented,\n+               unsigned int level,\n+               int level_dir,\n+               const char *message,\n+               ...)\n+{\n+  va_list ap;\n+  va_start (ap, message);\n+  _hb_debug_msg_va<max_level> (what, obj, func, indented, level, level_dir, message, ap);\n+  va_end (ap);\n+}\n+template <> inline void\n+_hb_debug_msg<0> (const char *what HB_UNUSED,\n+                  const void *obj HB_UNUSED,\n+                  const char *func HB_UNUSED,\n+                  bool indented HB_UNUSED,\n+                  unsigned int level HB_UNUSED,\n+                  int level_dir HB_UNUSED,\n+                  const char *message HB_UNUSED,\n+                  ...) HB_PRINTF_FUNC(7, 8);\n+template <> inline void HB_PRINTF_FUNC(7, 8)\n+_hb_debug_msg<0> (const char *what HB_UNUSED,\n+                  const void *obj HB_UNUSED,\n+                  const char *func HB_UNUSED,\n+                  bool indented HB_UNUSED,\n+                  unsigned int level HB_UNUSED,\n+                  int level_dir HB_UNUSED,\n+                  const char *message HB_UNUSED,\n+                  ...) {}\n+\n+#define DEBUG_MSG_LEVEL(WHAT, OBJ, LEVEL, LEVEL_DIR, ...)       _hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), nullptr,    true, (LEVEL), (LEVEL_DIR), __VA_ARGS__)\n+#define DEBUG_MSG(WHAT, OBJ, ...)                               _hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), nullptr,    false, 0, 0, __VA_ARGS__)\n+#define DEBUG_MSG_FUNC(WHAT, OBJ, ...)                          _hb_debug_msg<HB_DEBUG_##WHAT> (#WHAT, (OBJ), HB_FUNC, false, 0, 0, __VA_ARGS__)\n+\n+\n+\/*\n+ * Printer\n+ *\/\n+\n+template <typename T>\n+struct hb_printer_t {\n+  const char *print (const T&) { return \"something\"; }\n+};\n+\n+template <>\n+struct hb_printer_t<bool> {\n+  const char *print (bool v) { return v ? \"true\" : \"false\"; }\n+};\n+\n+template <>\n+struct hb_printer_t<hb_void_t> {\n+  const char *print (hb_void_t) { return \"\"; }\n+};\n+\n+\n+\/*\n+ * Trace\n+ *\/\n+\n+template <typename T>\n+static inline void _hb_warn_no_return (bool returned)\n+{\n+  if (unlikely (!returned)) {\n+    fprintf (stderr, \"OUCH, returned with no call to return_trace().  This is a bug, please report.\\n\");\n+  }\n+}\n+template <>\n+\/*static*\/ inline void _hb_warn_no_return<hb_void_t> (bool returned HB_UNUSED)\n+{}\n+\n+template <int max_level, typename ret_t>\n+struct hb_auto_trace_t\n+{\n+  explicit inline hb_auto_trace_t (unsigned int *plevel_,\n+                                   const char *what_,\n+                                   const void *obj_,\n+                                   const char *func,\n+                                   const char *message,\n+                                   ...) HB_PRINTF_FUNC(6, 7)\n+                                   : plevel (plevel_), what (what_), obj (obj_), returned (false)\n+  {\n+    if (plevel) ++*plevel;\n+\n+    va_list ap;\n+    va_start (ap, message);\n+    _hb_debug_msg_va<max_level> (what, obj, func, true, plevel ? *plevel : 0, +1, message, ap);\n+    va_end (ap);\n+  }\n+  ~hb_auto_trace_t ()\n+  {\n+    _hb_warn_no_return<ret_t> (returned);\n+    if (!returned) {\n+      _hb_debug_msg<max_level> (what, obj, nullptr, true, plevel ? *plevel : 1, -1, \" \");\n+    }\n+    if (plevel) --*plevel;\n+  }\n+\n+  ret_t ret (ret_t v,\n+             const char *func = \"\",\n+             unsigned int line = 0)\n+  {\n+    if (unlikely (returned)) {\n+      fprintf (stderr, \"OUCH, double calls to return_trace().  This is a bug, please report.\\n\");\n+      return v;\n+    }\n+\n+    _hb_debug_msg<max_level> (what, obj, func, true, plevel ? *plevel : 1, -1,\n+                              \"return %s (line %d)\",\n+                              hb_printer_t<ret_t>().print (v), line);\n+    if (plevel) --*plevel;\n+    plevel = nullptr;\n+    returned = true;\n+    return v;\n+  }\n+\n+  private:\n+  unsigned int *plevel;\n+  const char *what;\n+  const void *obj;\n+  bool returned;\n+};\n+template <typename ret_t> \/* Make sure we don't use hb_auto_trace_t when not tracing. *\/\n+struct hb_auto_trace_t<0, ret_t>\n+{\n+  explicit inline hb_auto_trace_t (unsigned int *plevel_,\n+                                   const char *what_,\n+                                   const void *obj_,\n+                                   const char *func,\n+                                   const char *message,\n+                                   ...) HB_PRINTF_FUNC(6, 7) {}\n+\n+  ret_t ret (ret_t v,\n+             const char *func HB_UNUSED = nullptr,\n+             unsigned int line HB_UNUSED = 0) { return v; }\n+};\n+\n+\/* For disabled tracing; optimize out everything.\n+ * https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/605 *\/\n+template <typename ret_t>\n+struct hb_no_trace_t {\n+  ret_t ret (ret_t v,\n+             const char *func HB_UNUSED = \"\",\n+             unsigned int line HB_UNUSED = 0) { return v; }\n+};\n+\n+#define return_trace(RET) return trace.ret (RET, HB_FUNC, __LINE__)\n+\n+\n+\/*\n+ * Instances.\n+ *\/\n+\n+#ifndef HB_DEBUG_ARABIC\n+#define HB_DEBUG_ARABIC (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_BLOB\n+#define HB_DEBUG_BLOB (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_CORETEXT\n+#define HB_DEBUG_CORETEXT (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_DIRECTWRITE\n+#define HB_DEBUG_DIRECTWRITE (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_FT\n+#define HB_DEBUG_FT (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_GET_COVERAGE\n+#define HB_DEBUG_GET_COVERAGE (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_OBJECT\n+#define HB_DEBUG_OBJECT (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_SHAPE_PLAN\n+#define HB_DEBUG_SHAPE_PLAN (HB_DEBUG+0)\n+#endif\n+\n+#ifndef HB_DEBUG_UNISCRIBE\n+#define HB_DEBUG_UNISCRIBE (HB_DEBUG+0)\n+#endif\n+\n+\/*\n+ * With tracing.\n+ *\/\n+\n+#ifndef HB_DEBUG_APPLY\n+#define HB_DEBUG_APPLY (HB_DEBUG+0)\n+#endif\n+#if HB_DEBUG_APPLY\n+#define TRACE_APPLY(this) \\\n+        hb_auto_trace_t<HB_DEBUG_APPLY, bool> trace \\\n+        (&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n+         \"idx %d gid %u lookup %d\", \\\n+         c->buffer->idx, c->buffer->cur().codepoint, (int) c->lookup_index)\n+#else\n+#define TRACE_APPLY(this) hb_no_trace_t<bool> trace\n+#endif\n+\n+#ifndef HB_DEBUG_SANITIZE\n+#define HB_DEBUG_SANITIZE (HB_DEBUG+0)\n+#endif\n+#if HB_DEBUG_SANITIZE\n+#define TRACE_SANITIZE(this) \\\n+        hb_auto_trace_t<HB_DEBUG_SANITIZE, bool> trace \\\n+        (&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n+         \" \");\n+#else\n+#define TRACE_SANITIZE(this) hb_no_trace_t<bool> trace\n+#endif\n+\n+#ifndef HB_DEBUG_SERIALIZE\n+#define HB_DEBUG_SERIALIZE (HB_DEBUG+0)\n+#endif\n+#if HB_DEBUG_SERIALIZE\n+#define TRACE_SERIALIZE(this) \\\n+        hb_auto_trace_t<HB_DEBUG_SERIALIZE, bool> trace \\\n+        (&c->debug_depth, \"SERIALIZE\", c, HB_FUNC, \\\n+         \" \");\n+#else\n+#define TRACE_SERIALIZE(this) hb_no_trace_t<bool> trace\n+#endif\n+\n+#ifndef HB_DEBUG_SUBSET\n+#define HB_DEBUG_SUBSET (HB_DEBUG+0)\n+#endif\n+#if HB_DEBUG_SUBSET\n+#define TRACE_SUBSET(this) \\\n+  hb_auto_trace_t<HB_DEBUG_SUBSET, bool> trace \\\n+  (&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n+   \" \");\n+#else\n+#define TRACE_SUBSET(this) hb_no_trace_t<bool> trace\n+#endif\n+\n+#ifndef HB_DEBUG_WOULD_APPLY\n+#define HB_DEBUG_WOULD_APPLY (HB_DEBUG+0)\n+#endif\n+#if HB_DEBUG_WOULD_APPLY\n+#define TRACE_WOULD_APPLY(this) \\\n+        hb_auto_trace_t<HB_DEBUG_WOULD_APPLY, bool> trace \\\n+        (&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n+         \"%d glyphs\", c->len);\n+#else\n+#define TRACE_WOULD_APPLY(this) hb_no_trace_t<bool> trace\n+#endif\n+\n+#ifndef HB_DEBUG_DISPATCH\n+#define HB_DEBUG_DISPATCH ( \\\n+        HB_DEBUG_APPLY + \\\n+        HB_DEBUG_SANITIZE + \\\n+        HB_DEBUG_SERIALIZE + \\\n+  HB_DEBUG_SUBSET + \\\n+        HB_DEBUG_WOULD_APPLY + \\\n+        0)\n+#endif\n+#if HB_DEBUG_DISPATCH\n+#define TRACE_DISPATCH(this, format) \\\n+        hb_auto_trace_t<context_t::max_debug_depth, typename context_t::return_t> trace \\\n+        (&c->debug_depth, c->get_name (), this, HB_FUNC, \\\n+         \"format %d\", (int) format);\n+#else\n+#define TRACE_DISPATCH(this, format) hb_no_trace_t<typename context_t::return_t> trace\n+#endif\n+\n+\n+#endif \/* HB_DEBUG_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-debug.hh","additions":471,"deletions":0,"binary":false,"changes":471,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright © 2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_DEPRECATED_H\n+#define HB_DEPRECATED_H\n+\n+#include \"hb-common.h\"\n+#include \"hb-unicode.h\"\n+#include \"hb-font.h\"\n+#include \"hb-set.h\"\n+\n+\n+\/**\n+ * SECTION:hb-deprecated\n+ * @title: hb-deprecated\n+ * @short_description: Deprecated API\n+ * @include: hb.h\n+ *\n+ * These API have been deprecated in favor of newer API, or because they\n+ * were deemed unnecessary.\n+ **\/\n+\n+\n+HB_BEGIN_DECLS\n+\n+#ifndef HB_DISABLE_DEPRECATED\n+\n+\n+#define HB_SCRIPT_CANADIAN_ABORIGINAL           HB_SCRIPT_CANADIAN_SYLLABICS\n+\n+#define HB_BUFFER_FLAGS_DEFAULT                 HB_BUFFER_FLAG_DEFAULT\n+#define HB_BUFFER_SERIALIZE_FLAGS_DEFAULT       HB_BUFFER_SERIALIZE_FLAG_DEFAULT\n+\n+typedef hb_bool_t (*hb_font_get_glyph_func_t) (hb_font_t *font, void *font_data,\n+                                               hb_codepoint_t unicode, hb_codepoint_t variation_selector,\n+                                               hb_codepoint_t *glyph,\n+                                               void *user_data);\n+\n+HB_EXTERN HB_DEPRECATED_FOR(hb_font_funcs_set_nominal_glyph_func or hb_font_funcs_set_variation_glyph_func) void\n+hb_font_funcs_set_glyph_func (hb_font_funcs_t *ffuncs,\n+                              hb_font_get_glyph_func_t func,\n+                              void *user_data, hb_destroy_func_t destroy);\n+\n+HB_EXTERN HB_DEPRECATED void\n+hb_set_invert (hb_set_t *set);\n+\n+\/**\n+ * hb_unicode_eastasian_width_func_t:\n+ *\n+ * Deprecated: 2.0.0\n+ *\/\n+typedef unsigned int                    (*hb_unicode_eastasian_width_func_t)    (hb_unicode_funcs_t *ufuncs,\n+                                                                                 hb_codepoint_t      unicode,\n+                                                                                 void               *user_data);\n+\n+\/**\n+ * hb_unicode_funcs_set_eastasian_width_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+HB_EXTERN HB_DEPRECATED void\n+hb_unicode_funcs_set_eastasian_width_func (hb_unicode_funcs_t *ufuncs,\n+                                           hb_unicode_eastasian_width_func_t func,\n+                                           void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_unicode_eastasian_width:\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+HB_EXTERN HB_DEPRECATED unsigned int\n+hb_unicode_eastasian_width (hb_unicode_funcs_t *ufuncs,\n+                            hb_codepoint_t unicode);\n+\n+\n+\/**\n+ * hb_unicode_decompose_compatibility_func_t:\n+ * @ufuncs: a Unicode function structure\n+ * @u: codepoint to decompose\n+ * @decomposed: address of codepoint array (of length %HB_UNICODE_MAX_DECOMPOSITION_LEN) to write decomposition into\n+ * @user_data: user data pointer as passed to hb_unicode_funcs_set_decompose_compatibility_func()\n+ *\n+ * Fully decompose @u to its Unicode compatibility decomposition. The codepoints of the decomposition will be written to @decomposed.\n+ * The complete length of the decomposition will be returned.\n+ *\n+ * If @u has no compatibility decomposition, zero should be returned.\n+ *\n+ * The Unicode standard guarantees that a buffer of length %HB_UNICODE_MAX_DECOMPOSITION_LEN codepoints will always be sufficient for any\n+ * compatibility decomposition plus an terminating value of 0.  Consequently, @decompose must be allocated by the caller to be at least this length.  Implementations\n+ * of this function type must ensure that they do not write past the provided array.\n+ *\n+ * Return value: number of codepoints in the full compatibility decomposition of @u, or 0 if no decomposition available.\n+ *\n+ * Deprecated: 2.0.0\n+ *\/\n+typedef unsigned int                    (*hb_unicode_decompose_compatibility_func_t)    (hb_unicode_funcs_t *ufuncs,\n+                                                                                         hb_codepoint_t      u,\n+                                                                                         hb_codepoint_t     *decomposed,\n+                                                                                         void               *user_data);\n+\n+\/**\n+ * HB_UNICODE_MAX_DECOMPOSITION_LEN:\n+ *\n+ * See Unicode 6.1 for details on the maximum decomposition length.\n+ *\n+ * Deprecated: 2.0.0\n+ *\/\n+#define HB_UNICODE_MAX_DECOMPOSITION_LEN (18+1) \/* codepoints *\/\n+\n+\/**\n+ * hb_unicode_funcs_set_decompose_compatibility_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+HB_EXTERN HB_DEPRECATED void\n+hb_unicode_funcs_set_decompose_compatibility_func (hb_unicode_funcs_t *ufuncs,\n+                                                   hb_unicode_decompose_compatibility_func_t func,\n+                                                   void *user_data, hb_destroy_func_t destroy);\n+\n+HB_EXTERN HB_DEPRECATED unsigned int\n+hb_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,\n+                                    hb_codepoint_t      u,\n+                                    hb_codepoint_t     *decomposed);\n+\n+\n+typedef hb_position_t (*hb_font_get_glyph_kerning_func_t) (hb_font_t *font, void *font_data,\n+                                                           hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,\n+                                                           void *user_data);\n+typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_h_kerning_func_t;\n+typedef hb_font_get_glyph_kerning_func_t hb_font_get_glyph_v_kerning_func_t;\n+\n+\/**\n+ * hb_font_funcs_set_glyph_h_kerning_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_h_kerning_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_glyph_h_kerning_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_v_kerning_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_v_kerning_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_glyph_v_kerning_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+HB_EXTERN hb_position_t\n+hb_font_get_glyph_h_kerning (hb_font_t *font,\n+                             hb_codepoint_t left_glyph, hb_codepoint_t right_glyph);\n+HB_EXTERN hb_position_t\n+hb_font_get_glyph_v_kerning (hb_font_t *font,\n+                             hb_codepoint_t top_glyph, hb_codepoint_t bottom_glyph);\n+\n+HB_EXTERN void\n+hb_font_get_glyph_kerning_for_direction (hb_font_t *font,\n+                                         hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,\n+                                         hb_direction_t direction,\n+                                         hb_position_t *x, hb_position_t *y);\n+\n+\n+#endif\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_DEPRECATED_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-deprecated.h","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,632 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_DSALGS_HH\n+#define HB_DSALGS_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-null.hh\"\n+\n+\n+\/* Void! For when we need a expression-type of void. *\/\n+typedef const struct _hb_void_t *hb_void_t;\n+#define HB_VOID ((const _hb_void_t *) nullptr)\n+\n+\n+\/*\n+ * Bithacks.\n+ *\/\n+\n+\/* Return the number of 1 bits in v. *\/\n+template <typename T>\n+static inline HB_CONST_FUNC unsigned int\n+hb_popcount (T v)\n+{\n+#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+  if (sizeof (T) <= sizeof (unsigned int))\n+    return __builtin_popcount (v);\n+\n+  if (sizeof (T) <= sizeof (unsigned long))\n+    return __builtin_popcountl (v);\n+\n+  if (sizeof (T) <= sizeof (unsigned long long))\n+    return __builtin_popcountll (v);\n+#endif\n+\n+  if (sizeof (T) <= 4)\n+  {\n+    \/* \"HACKMEM 169\" *\/\n+    uint32_t y;\n+    y = (v >> 1) &033333333333;\n+    y = v - y - ((y >>1) & 033333333333);\n+    return (((y + (y >> 3)) & 030707070707) % 077);\n+  }\n+\n+  if (sizeof (T) == 8)\n+  {\n+    unsigned int shift = 32;\n+    return hb_popcount<uint32_t> ((uint32_t) v) + hb_popcount ((uint32_t) (v >> shift));\n+  }\n+\n+  if (sizeof (T) == 16)\n+  {\n+    unsigned int shift = 64;\n+    return hb_popcount<uint64_t> ((uint64_t) v) + hb_popcount ((uint64_t) (v >> shift));\n+  }\n+\n+  assert (0);\n+  return 0; \/* Shut up stupid compiler. *\/\n+}\n+\n+\/* Returns the number of bits needed to store number *\/\n+template <typename T>\n+static inline HB_CONST_FUNC unsigned int\n+hb_bit_storage (T v)\n+{\n+  if (unlikely (!v)) return 0;\n+\n+#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+  if (sizeof (T) <= sizeof (unsigned int))\n+    return sizeof (unsigned int) * 8 - __builtin_clz (v);\n+\n+  if (sizeof (T) <= sizeof (unsigned long))\n+    return sizeof (unsigned long) * 8 - __builtin_clzl (v);\n+\n+  if (sizeof (T) <= sizeof (unsigned long long))\n+    return sizeof (unsigned long long) * 8 - __builtin_clzll (v);\n+#endif\n+\n+#if (defined(_MSC_VER) && _MSC_VER >= 1500) || defined(__MINGW32__)\n+  if (sizeof (T) <= sizeof (unsigned int))\n+  {\n+    unsigned long where;\n+    _BitScanReverse (&where, v);\n+    return 1 + where;\n+  }\n+# if defined(_WIN64)\n+  if (sizeof (T) <= 8)\n+  {\n+    unsigned long where;\n+    _BitScanReverse64 (&where, v);\n+    return 1 + where;\n+  }\n+# endif\n+#endif\n+\n+  if (sizeof (T) <= 4)\n+  {\n+    \/* \"bithacks\" *\/\n+    const unsigned int b[] = {0x2, 0xC, 0xF0, 0xFF00, 0xFFFF0000};\n+    const unsigned int S[] = {1, 2, 4, 8, 16};\n+    unsigned int r = 0;\n+    for (int i = 4; i >= 0; i--)\n+      if (v & b[i])\n+      {\n+        v >>= S[i];\n+        r |= S[i];\n+      }\n+    return r + 1;\n+  }\n+  if (sizeof (T) <= 8)\n+  {\n+    \/* \"bithacks\" *\/\n+    const uint64_t b[] = {0x2ULL, 0xCULL, 0xF0ULL, 0xFF00ULL, 0xFFFF0000ULL, 0xFFFFFFFF00000000ULL};\n+    const unsigned int S[] = {1, 2, 4, 8, 16, 32};\n+    unsigned int r = 0;\n+    for (int i = 5; i >= 0; i--)\n+      if (v & b[i])\n+      {\n+        v >>= S[i];\n+        r |= S[i];\n+      }\n+    return r + 1;\n+  }\n+  if (sizeof (T) == 16)\n+  {\n+    unsigned int shift = 64;\n+    return (v >> shift) ? hb_bit_storage<uint64_t> ((uint64_t) (v >> shift)) + shift :\n+                          hb_bit_storage<uint64_t> ((uint64_t) v);\n+  }\n+\n+  assert (0);\n+  return 0; \/* Shut up stupid compiler. *\/\n+}\n+\n+\/* Returns the number of zero bits in the least significant side of v *\/\n+template <typename T>\n+static inline HB_CONST_FUNC unsigned int\n+hb_ctz (T v)\n+{\n+  if (unlikely (!v)) return 0;\n+\n+#if (defined(__GNUC__) && (__GNUC__ >= 4)) || defined(__clang__)\n+  if (sizeof (T) <= sizeof (unsigned int))\n+    return __builtin_ctz (v);\n+\n+  if (sizeof (T) <= sizeof (unsigned long))\n+    return __builtin_ctzl (v);\n+\n+  if (sizeof (T) <= sizeof (unsigned long long))\n+    return __builtin_ctzll (v);\n+#endif\n+\n+#if (defined(_MSC_VER) && _MSC_VER >= 1500) || defined(__MINGW32__)\n+  if (sizeof (T) <= sizeof (unsigned int))\n+  {\n+    unsigned long where;\n+    _BitScanForward (&where, v);\n+    return where;\n+  }\n+# if defined(_WIN64)\n+  if (sizeof (T) <= 8)\n+  {\n+    unsigned long where;\n+    _BitScanForward64 (&where, v);\n+    return where;\n+  }\n+# endif\n+#endif\n+\n+  if (sizeof (T) <= 4)\n+  {\n+    \/* \"bithacks\" *\/\n+    unsigned int c = 32;\n+    v &= - (int32_t) v;\n+    if (v) c--;\n+    if (v & 0x0000FFFF) c -= 16;\n+    if (v & 0x00FF00FF) c -= 8;\n+    if (v & 0x0F0F0F0F) c -= 4;\n+    if (v & 0x33333333) c -= 2;\n+    if (v & 0x55555555) c -= 1;\n+    return c;\n+  }\n+  if (sizeof (T) <= 8)\n+  {\n+    \/* \"bithacks\" *\/\n+    unsigned int c = 64;\n+    v &= - (int64_t) (v);\n+    if (v) c--;\n+    if (v & 0x00000000FFFFFFFFULL) c -= 32;\n+    if (v & 0x0000FFFF0000FFFFULL) c -= 16;\n+    if (v & 0x00FF00FF00FF00FFULL) c -= 8;\n+    if (v & 0x0F0F0F0F0F0F0F0FULL) c -= 4;\n+    if (v & 0x3333333333333333ULL) c -= 2;\n+    if (v & 0x5555555555555555ULL) c -= 1;\n+    return c;\n+  }\n+  if (sizeof (T) == 16)\n+  {\n+    unsigned int shift = 64;\n+    return (uint64_t) v ? hb_bit_storage<uint64_t> ((uint64_t) v) :\n+                          hb_bit_storage<uint64_t> ((uint64_t) (v >> shift)) + shift;\n+  }\n+\n+  assert (0);\n+  return 0; \/* Shut up stupid compiler. *\/\n+}\n+\n+\n+\/*\n+ * Tiny stuff.\n+ *\/\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wcast-align\"\n+template <typename T>\n+static inline T* hb_addressof (T& arg)\n+{\n+  \/* https:\/\/en.cppreference.com\/w\/cpp\/memory\/addressof *\/\n+  return reinterpret_cast<T*>(\n+           &const_cast<char&>(\n+              reinterpret_cast<const volatile char&>(arg)));\n+}\n+#pragma GCC diagnostic pop\n+\n+\/* ASCII tag\/character handling *\/\n+static inline bool ISALPHA (unsigned char c)\n+{ return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z'); }\n+static inline bool ISALNUM (unsigned char c)\n+{ return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'); }\n+static inline bool ISSPACE (unsigned char c)\n+{ return c == ' ' || c =='\\f'|| c =='\\n'|| c =='\\r'|| c =='\\t'|| c =='\\v'; }\n+static inline unsigned char TOUPPER (unsigned char c)\n+{ return (c >= 'a' && c <= 'z') ? c - 'a' + 'A' : c; }\n+static inline unsigned char TOLOWER (unsigned char c)\n+{ return (c >= 'A' && c <= 'Z') ? c - 'A' + 'a' : c; }\n+\n+#undef MIN\n+template <typename Type>\n+static inline Type MIN (const Type &a, const Type &b) { return a < b ? a : b; }\n+\n+#undef MAX\n+template <typename Type>\n+static inline Type MAX (const Type &a, const Type &b) { return a > b ? a : b; }\n+\n+static inline unsigned int DIV_CEIL (const unsigned int a, unsigned int b)\n+{ return (a + (b - 1)) \/ b; }\n+\n+\n+#undef  ARRAY_LENGTH\n+template <typename Type, unsigned int n>\n+static inline unsigned int ARRAY_LENGTH (const Type (&)[n]) { return n; }\n+\/* A const version, but does not detect erratically being called on pointers. *\/\n+#define ARRAY_LENGTH_CONST(__array) ((signed int) (sizeof (__array) \/ sizeof (__array[0])))\n+\n+\n+static inline int\n+hb_memcmp (const void *a, const void *b, unsigned int len)\n+{\n+  \/* It's illegal to pass NULL to memcmp(), even if len is zero.\n+   * So, wrap it.\n+   * https:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=23878 *\/\n+  if (!len) return 0;\n+  return memcmp (a, b, len);\n+}\n+\n+static inline bool\n+hb_unsigned_mul_overflows (unsigned int count, unsigned int size)\n+{\n+  return (size > 0) && (count >= ((unsigned int) -1) \/ size);\n+}\n+\n+static inline unsigned int\n+hb_ceil_to_4 (unsigned int v)\n+{\n+  return ((v - 1) | 3) + 1;\n+}\n+\n+template <typename T> struct hb_is_signed;\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1535 *\/\n+template <> struct hb_is_signed<int8_t> { enum { value = true }; };\n+template <> struct hb_is_signed<int16_t> { enum { value = true }; };\n+template <> struct hb_is_signed<int32_t> { enum { value = true }; };\n+template <> struct hb_is_signed<int64_t> { enum { value = true }; };\n+template <> struct hb_is_signed<uint8_t> { enum { value = false }; };\n+template <> struct hb_is_signed<uint16_t> { enum { value = false }; };\n+template <> struct hb_is_signed<uint32_t> { enum { value = false }; };\n+template <> struct hb_is_signed<uint64_t> { enum { value = false }; };\n+\n+template <typename T> static inline bool\n+hb_in_range (T u, T lo, T hi)\n+{\n+  \/* The sizeof() is here to force template instantiation.\n+   * I'm sure there are better ways to do this but can't think of\n+   * one right now.  Declaring a variable won't work as HB_UNUSED\n+   * is unusable on some platforms and unused types are less likely\n+   * to generate a warning than unused variables. *\/\n+  static_assert (!hb_is_signed<T>::value, \"\");\n+\n+  \/* The casts below are important as if T is smaller than int,\n+   * the subtract results will become a signed int! *\/\n+  return (T)(u - lo) <= (T)(hi - lo);\n+}\n+template <typename T> static inline bool\n+hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2)\n+{\n+  return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2);\n+}\n+template <typename T> static inline bool\n+hb_in_ranges (T u, T lo1, T hi1, T lo2, T hi2, T lo3, T hi3)\n+{\n+  return hb_in_range (u, lo1, hi1) || hb_in_range (u, lo2, hi2) || hb_in_range (u, lo3, hi3);\n+}\n+\n+\n+\/*\n+ * Sort and search.\n+ *\/\n+\n+static inline void *\n+hb_bsearch (const void *key, const void *base,\n+            size_t nmemb, size_t size,\n+            int (*compar)(const void *_key, const void *_item))\n+{\n+  int min = 0, max = (int) nmemb - 1;\n+  while (min <= max)\n+  {\n+    int mid = (min + max) \/ 2;\n+    const void *p = (const void *) (((const char *) base) + (mid * size));\n+    int c = compar (key, p);\n+    if (c < 0)\n+      max = mid - 1;\n+    else if (c > 0)\n+      min = mid + 1;\n+    else\n+      return (void *) p;\n+  }\n+  return nullptr;\n+}\n+\n+static inline void *\n+hb_bsearch_r (const void *key, const void *base,\n+              size_t nmemb, size_t size,\n+              int (*compar)(const void *_key, const void *_item, void *_arg),\n+              void *arg)\n+{\n+  int min = 0, max = (int) nmemb - 1;\n+  while (min <= max)\n+  {\n+    int mid = ((unsigned int) min + (unsigned int) max) \/ 2;\n+    const void *p = (const void *) (((const char *) base) + (mid * size));\n+    int c = compar (key, p, arg);\n+    if (c < 0)\n+      max = mid - 1;\n+    else if (c > 0)\n+      min = mid + 1;\n+    else\n+      return (void *) p;\n+  }\n+  return nullptr;\n+}\n+\n+\n+\/* From https:\/\/github.com\/noporpoise\/sort_r\n+ * With following modifications:\n+ *\n+ * 10 November 2018:\n+ * https:\/\/github.com\/noporpoise\/sort_r\/issues\/7\n+ *\/\n+\n+\/* Isaac Turner 29 April 2014 Public Domain *\/\n+\n+\/*\n+\n+hb_sort_r function to be exported.\n+\n+Parameters:\n+  base is the array to be sorted\n+  nel is the number of elements in the array\n+  width is the size in bytes of each element of the array\n+  compar is the comparison function\n+  arg is a pointer to be passed to the comparison function\n+\n+void hb_sort_r(void *base, size_t nel, size_t width,\n+               int (*compar)(const void *_a, const void *_b, void *_arg),\n+               void *arg);\n+*\/\n+\n+\n+\/* swap a, b iff a>b *\/\n+\/* __restrict is same as restrict but better support on old machines *\/\n+static int sort_r_cmpswap(char *__restrict a, char *__restrict b, size_t w,\n+                          int (*compar)(const void *_a, const void *_b,\n+                                        void *_arg),\n+                          void *arg)\n+{\n+  char tmp, *end = a+w;\n+  if(compar(a, b, arg) > 0) {\n+    for(; a < end; a++, b++) { tmp = *a; *a = *b; *b = tmp; }\n+    return 1;\n+  }\n+  return 0;\n+}\n+\n+\/* Note: quicksort is not stable, equivalent values may be swapped *\/\n+static inline void sort_r_simple(void *base, size_t nel, size_t w,\n+                                 int (*compar)(const void *_a, const void *_b,\n+                                               void *_arg),\n+                                 void *arg)\n+{\n+  char *b = (char *)base, *end = b + nel*w;\n+  if(nel < 7) {\n+    \/* Insertion sort for arbitrarily small inputs *\/\n+    char *pi, *pj;\n+    for(pi = b+w; pi < end; pi += w) {\n+      for(pj = pi; pj > b && sort_r_cmpswap(pj-w,pj,w,compar,arg); pj -= w) {}\n+    }\n+  }\n+  else\n+  {\n+    \/* nel > 6; Quicksort *\/\n+\n+    \/* Use median of first, middle and last items as pivot *\/\n+    char *x, *y, *xend, ch;\n+    char *pl, *pm, *pr;\n+    char *last = b+w*(nel-1), *tmp;\n+    char *l[3];\n+    l[0] = b;\n+    l[1] = b+w*(nel\/2);\n+    l[2] = last;\n+\n+    if(compar(l[0],l[1],arg) > 0) { tmp=l[0]; l[0]=l[1]; l[1]=tmp; }\n+    if(compar(l[1],l[2],arg) > 0) {\n+      tmp=l[1]; l[1]=l[2]; l[2]=tmp; \/* swap(l[1],l[2]) *\/\n+      if(compar(l[0],l[1],arg) > 0) { tmp=l[0]; l[0]=l[1]; l[1]=tmp; }\n+    }\n+\n+    \/* swap l[id], l[2] to put pivot as last element *\/\n+    for(x = l[1], y = last, xend = x+w; x<xend; x++, y++) {\n+      ch = *x; *x = *y; *y = ch;\n+    }\n+\n+    pl = b;\n+    pr = last;\n+\n+    while(pl < pr) {\n+      pm = pl+((pr-pl+1)>>1);\n+      for(; pl < pm; pl += w) {\n+        if(sort_r_cmpswap(pl, pr, w, compar, arg)) {\n+          pr -= w; \/* pivot now at pl *\/\n+          break;\n+        }\n+      }\n+      pm = pl+((pr-pl)>>1);\n+      for(; pm < pr; pr -= w) {\n+        if(sort_r_cmpswap(pl, pr, w, compar, arg)) {\n+          pl += w; \/* pivot now at pr *\/\n+          break;\n+        }\n+      }\n+    }\n+\n+    sort_r_simple(b, (pl-b)\/w, w, compar, arg);\n+    sort_r_simple(pl+w, (end-(pl+w))\/w, w, compar, arg);\n+  }\n+}\n+\n+static inline void hb_sort_r(void *base, size_t nel, size_t width,\n+                             int (*compar)(const void *_a, const void *_b, void *_arg),\n+                             void *arg)\n+{\n+    sort_r_simple(base, nel, width, compar, arg);\n+}\n+\n+\n+template <typename T, typename T2> static inline void\n+hb_stable_sort (T *array, unsigned int len, int(*compar)(const T *, const T *), T2 *array2)\n+{\n+  for (unsigned int i = 1; i < len; i++)\n+  {\n+    unsigned int j = i;\n+    while (j && compar (&array[j - 1], &array[i]) > 0)\n+      j--;\n+    if (i == j)\n+      continue;\n+    \/* Move item i to occupy place for item j, shift what's in between. *\/\n+    {\n+      T t = array[i];\n+      memmove (&array[j + 1], &array[j], (i - j) * sizeof (T));\n+      array[j] = t;\n+    }\n+    if (array2)\n+    {\n+      T2 t = array2[i];\n+      memmove (&array2[j + 1], &array2[j], (i - j) * sizeof (T2));\n+      array2[j] = t;\n+    }\n+  }\n+}\n+\n+template <typename T> static inline void\n+hb_stable_sort (T *array, unsigned int len, int(*compar)(const T *, const T *))\n+{\n+  hb_stable_sort (array, len, compar, (int *) nullptr);\n+}\n+\n+static inline hb_bool_t\n+hb_codepoint_parse (const char *s, unsigned int len, int base, hb_codepoint_t *out)\n+{\n+  \/* Pain because we don't know whether s is nul-terminated. *\/\n+  char buf[64];\n+  len = MIN (ARRAY_LENGTH (buf) - 1, len);\n+  strncpy (buf, s, len);\n+  buf[len] = '\\0';\n+\n+  char *end;\n+  errno = 0;\n+  unsigned long v = strtoul (buf, &end, base);\n+  if (errno) return false;\n+  if (*end) return false;\n+  *out = v;\n+  return true;\n+}\n+\n+\n+struct HbOpOr\n+{\n+  static constexpr bool passthru_left = true;\n+  static constexpr bool passthru_right = true;\n+  template <typename T> static void process (T &o, const T &a, const T &b) { o = a | b; }\n+};\n+struct HbOpAnd\n+{\n+  static constexpr bool passthru_left = false;\n+  static constexpr bool passthru_right = false;\n+  template <typename T> static void process (T &o, const T &a, const T &b) { o = a & b; }\n+};\n+struct HbOpMinus\n+{\n+  static constexpr bool passthru_left = true;\n+  static constexpr bool passthru_right = false;\n+  template <typename T> static void process (T &o, const T &a, const T &b) { o = a & ~b; }\n+};\n+struct HbOpXor\n+{\n+  static constexpr bool passthru_left = true;\n+  static constexpr bool passthru_right = true;\n+  template <typename T> static void process (T &o, const T &a, const T &b) { o = a ^ b; }\n+};\n+\n+\n+\/* Compiler-assisted vectorization. *\/\n+\n+\/* Type behaving similar to vectorized vars defined using __attribute__((vector_size(...))),\n+ * using vectorized operations if HB_VECTOR_SIZE is set to **bit** numbers (eg 128).\n+ * Define that to 0 to disable. *\/\n+template <typename elt_t, unsigned int byte_size>\n+struct hb_vector_size_t\n+{\n+  elt_t& operator [] (unsigned int i) { return u.v[i]; }\n+  const elt_t& operator [] (unsigned int i) const { return u.v[i]; }\n+\n+  void clear (unsigned char v = 0) { memset (this, v, sizeof (*this)); }\n+\n+  template <class Op>\n+  hb_vector_size_t process (const hb_vector_size_t &o) const\n+  {\n+    hb_vector_size_t r;\n+#if HB_VECTOR_SIZE\n+    if (HB_VECTOR_SIZE && 0 == (byte_size * 8) % HB_VECTOR_SIZE)\n+      for (unsigned int i = 0; i < ARRAY_LENGTH (u.vec); i++)\n+        Op::process (r.u.vec[i], u.vec[i], o.u.vec[i]);\n+    else\n+#endif\n+      for (unsigned int i = 0; i < ARRAY_LENGTH (u.v); i++)\n+        Op::process (r.u.v[i], u.v[i], o.u.v[i]);\n+    return r;\n+  }\n+  hb_vector_size_t operator | (const hb_vector_size_t &o) const\n+  { return process<HbOpOr> (o); }\n+  hb_vector_size_t operator & (const hb_vector_size_t &o) const\n+  { return process<HbOpAnd> (o); }\n+  hb_vector_size_t operator ^ (const hb_vector_size_t &o) const\n+  { return process<HbOpXor> (o); }\n+  hb_vector_size_t operator ~ () const\n+  {\n+    hb_vector_size_t r;\n+#if HB_VECTOR_SIZE && 0\n+    if (HB_VECTOR_SIZE && 0 == (byte_size * 8) % HB_VECTOR_SIZE)\n+      for (unsigned int i = 0; i < ARRAY_LENGTH (u.vec); i++)\n+        r.u.vec[i] = ~u.vec[i];\n+    else\n+#endif\n+    for (unsigned int i = 0; i < ARRAY_LENGTH (u.v); i++)\n+      r.u.v[i] = ~u.v[i];\n+    return r;\n+  }\n+\n+  private:\n+  static_assert (byte_size \/ sizeof (elt_t) * sizeof (elt_t) == byte_size, \"\");\n+  union {\n+    elt_t v[byte_size \/ sizeof (elt_t)];\n+#if HB_VECTOR_SIZE\n+    hb_vector_size_impl_t vec[byte_size \/ sizeof (hb_vector_size_impl_t)];\n+#endif\n+  } u;\n+};\n+\n+\n+#endif \/* HB_DSALGS_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-dsalgs.hh","additions":632,"deletions":0,"binary":false,"changes":632,"status":"added"},{"patch":"@@ -0,0 +1,723 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-face.hh\"\n+#include \"hb-blob.hh\"\n+#include \"hb-open-file.hh\"\n+#include \"hb-ot-face.hh\"\n+#include \"hb-ot-cmap-table.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-face\n+ * @title: hb-face\n+ * @short_description: Font face objects\n+ * @include: hb.h\n+ *\n+ * Font face is objects represent a single face in a font family.\n+ * More exactly, a font face represents a single face in a binary font file.\n+ * Font faces are typically built from a binary blob and a face index.\n+ * Font faces are used to create fonts.\n+ **\/\n+\n+\n+\/**\n+ * hb_face_count:\n+ * @blob: a blob.\n+ *\n+ * Get number of faces in a blob.\n+ *\n+ * Return value: Number of faces in @blob\n+ *\n+ * Since: 1.7.7\n+ **\/\n+unsigned int\n+hb_face_count (hb_blob_t *blob)\n+{\n+  if (unlikely (!blob))\n+    return 0;\n+\n+  \/* TODO We shouldn't be sanitizing blob.  Port to run sanitizer and return if not sane. *\/\n+  \/* Make API signature const after. *\/\n+  hb_blob_t *sanitized = hb_sanitize_context_t ().sanitize_blob<OT::OpenTypeFontFile> (hb_blob_reference (blob));\n+  const OT::OpenTypeFontFile& ot = *sanitized->as<OT::OpenTypeFontFile> ();\n+  unsigned int ret = ot.get_face_count ();\n+  hb_blob_destroy (sanitized);\n+\n+  return ret;\n+}\n+\n+\/*\n+ * hb_face_t\n+ *\/\n+\n+DEFINE_NULL_INSTANCE (hb_face_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  nullptr, \/* reference_table_func *\/\n+  nullptr, \/* user_data *\/\n+  nullptr, \/* destroy *\/\n+\n+  0,    \/* index *\/\n+  HB_ATOMIC_INT_INIT (1000), \/* upem *\/\n+  HB_ATOMIC_INT_INIT (0),    \/* num_glyphs *\/\n+\n+  \/* Zero for the rest is fine. *\/\n+};\n+\n+\n+\/**\n+ * hb_face_create_for_tables:\n+ * @reference_table_func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full)\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_face_t *\n+hb_face_create_for_tables (hb_reference_table_func_t  reference_table_func,\n+                           void                      *user_data,\n+                           hb_destroy_func_t          destroy)\n+{\n+  hb_face_t *face;\n+\n+  if (!reference_table_func || !(face = hb_object_create<hb_face_t> ())) {\n+    if (destroy)\n+      destroy (user_data);\n+    return hb_face_get_empty ();\n+  }\n+\n+  face->reference_table_func = reference_table_func;\n+  face->user_data = user_data;\n+  face->destroy = destroy;\n+\n+  face->num_glyphs.set_relaxed (-1);\n+\n+  face->data.init0 (face);\n+  face->table.init0 (face);\n+\n+  return face;\n+}\n+\n+\n+typedef struct hb_face_for_data_closure_t {\n+  hb_blob_t *blob;\n+  unsigned int  index;\n+} hb_face_for_data_closure_t;\n+\n+static hb_face_for_data_closure_t *\n+_hb_face_for_data_closure_create (hb_blob_t *blob, unsigned int index)\n+{\n+  hb_face_for_data_closure_t *closure;\n+\n+  closure = (hb_face_for_data_closure_t *) calloc (1, sizeof (hb_face_for_data_closure_t));\n+  if (unlikely (!closure))\n+    return nullptr;\n+\n+  closure->blob = blob;\n+  closure->index = index;\n+\n+  return closure;\n+}\n+\n+static void\n+_hb_face_for_data_closure_destroy (void *data)\n+{\n+  hb_face_for_data_closure_t *closure = (hb_face_for_data_closure_t *) data;\n+\n+  hb_blob_destroy (closure->blob);\n+  free (closure);\n+}\n+\n+static hb_blob_t *\n+_hb_face_for_data_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)\n+{\n+  hb_face_for_data_closure_t *data = (hb_face_for_data_closure_t *) user_data;\n+\n+  if (tag == HB_TAG_NONE)\n+    return hb_blob_reference (data->blob);\n+\n+  const OT::OpenTypeFontFile &ot_file = *data->blob->as<OT::OpenTypeFontFile> ();\n+  unsigned int base_offset;\n+  const OT::OpenTypeFontFace &ot_face = ot_file.get_face (data->index, &base_offset);\n+\n+  const OT::OpenTypeTable &table = ot_face.get_table_by_tag (tag);\n+\n+  hb_blob_t *blob = hb_blob_create_sub_blob (data->blob, base_offset + table.offset, table.length);\n+\n+  return blob;\n+}\n+\n+\/**\n+ * hb_face_create: (Xconstructor)\n+ * @blob:\n+ * @index:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_face_t *\n+hb_face_create (hb_blob_t    *blob,\n+                unsigned int  index)\n+{\n+  hb_face_t *face;\n+\n+  if (unlikely (!blob))\n+    blob = hb_blob_get_empty ();\n+\n+  hb_face_for_data_closure_t *closure = _hb_face_for_data_closure_create (hb_sanitize_context_t ().sanitize_blob<OT::OpenTypeFontFile> (hb_blob_reference (blob)), index);\n+\n+  if (unlikely (!closure))\n+    return hb_face_get_empty ();\n+\n+  face = hb_face_create_for_tables (_hb_face_for_data_reference_table,\n+                                    closure,\n+                                    _hb_face_for_data_closure_destroy);\n+\n+  face->index = index;\n+\n+  return face;\n+}\n+\n+\/**\n+ * hb_face_get_empty:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full)\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_face_t *\n+hb_face_get_empty ()\n+{\n+  return const_cast<hb_face_t *> (&Null(hb_face_t));\n+}\n+\n+\n+\/**\n+ * hb_face_reference: (skip)\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_face_t *\n+hb_face_reference (hb_face_t *face)\n+{\n+  return hb_object_reference (face);\n+}\n+\n+\/**\n+ * hb_face_destroy: (skip)\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_face_destroy (hb_face_t *face)\n+{\n+  if (!hb_object_destroy (face)) return;\n+\n+  for (hb_face_t::plan_node_t *node = face->shape_plans; node; )\n+  {\n+    hb_face_t::plan_node_t *next = node->next;\n+    hb_shape_plan_destroy (node->shape_plan);\n+    free (node);\n+    node = next;\n+  }\n+\n+  face->data.fini ();\n+  face->table.fini ();\n+\n+  if (face->destroy)\n+    face->destroy (face->user_data);\n+\n+  free (face);\n+}\n+\n+\/**\n+ * hb_face_set_user_data: (skip)\n+ * @face: a face.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_face_set_user_data (hb_face_t          *face,\n+                       hb_user_data_key_t *key,\n+                       void *              data,\n+                       hb_destroy_func_t   destroy,\n+                       hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (face, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_face_get_user_data: (skip)\n+ * @face: a face.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void *\n+hb_face_get_user_data (const hb_face_t    *face,\n+                       hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (face, key);\n+}\n+\n+\/**\n+ * hb_face_make_immutable:\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_face_make_immutable (hb_face_t *face)\n+{\n+  if (hb_object_is_immutable (face))\n+    return;\n+\n+  hb_object_make_immutable (face);\n+}\n+\n+\/**\n+ * hb_face_is_immutable:\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_face_is_immutable (const hb_face_t *face)\n+{\n+  return hb_object_is_immutable (face);\n+}\n+\n+\n+\/**\n+ * hb_face_reference_table:\n+ * @face: a face.\n+ * @tag:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_blob_t *\n+hb_face_reference_table (const hb_face_t *face,\n+                         hb_tag_t tag)\n+{\n+  return face->reference_table (tag);\n+}\n+\n+\/**\n+ * hb_face_reference_blob:\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_blob_t *\n+hb_face_reference_blob (hb_face_t *face)\n+{\n+  return face->reference_table (HB_TAG_NONE);\n+}\n+\n+\/**\n+ * hb_face_set_index:\n+ * @face: a face.\n+ * @index:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_face_set_index (hb_face_t    *face,\n+                   unsigned int  index)\n+{\n+  if (hb_object_is_immutable (face))\n+    return;\n+\n+  face->index = index;\n+}\n+\n+\/**\n+ * hb_face_get_index:\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+unsigned int\n+hb_face_get_index (const hb_face_t *face)\n+{\n+  return face->index;\n+}\n+\n+\/**\n+ * hb_face_set_upem:\n+ * @face: a face.\n+ * @upem:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_face_set_upem (hb_face_t    *face,\n+                  unsigned int  upem)\n+{\n+  if (hb_object_is_immutable (face))\n+    return;\n+\n+  face->upem.set_relaxed (upem);\n+}\n+\n+\/**\n+ * hb_face_get_upem:\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+unsigned int\n+hb_face_get_upem (const hb_face_t *face)\n+{\n+  return face->get_upem ();\n+}\n+\n+\/**\n+ * hb_face_set_glyph_count:\n+ * @face: a face.\n+ * @glyph_count:\n+ *\n+ *\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_face_set_glyph_count (hb_face_t    *face,\n+                         unsigned int  glyph_count)\n+{\n+  if (hb_object_is_immutable (face))\n+    return;\n+\n+  face->num_glyphs.set_relaxed (glyph_count);\n+}\n+\n+\/**\n+ * hb_face_get_glyph_count:\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+unsigned int\n+hb_face_get_glyph_count (const hb_face_t *face)\n+{\n+  return face->get_num_glyphs ();\n+}\n+\n+\/**\n+ * hb_face_get_table_tags:\n+ * @face: a face.\n+ * @start_offset: index of first tag to return.\n+ * @table_count: input length of @table_tags array, output number of items written.\n+ * @table_tags: array to write tags into.\n+ *\n+ * Retrieves table tags for a face, if possible.\n+ *\n+ * Return value: total number of tables, or 0 if not possible to list.\n+ *\n+ * Since: 1.6.0\n+ **\/\n+unsigned int\n+hb_face_get_table_tags (const hb_face_t *face,\n+                        unsigned int  start_offset,\n+                        unsigned int *table_count, \/* IN\/OUT *\/\n+                        hb_tag_t     *table_tags \/* OUT *\/)\n+{\n+  if (face->destroy != (hb_destroy_func_t) _hb_face_for_data_closure_destroy)\n+  {\n+    if (table_count)\n+      *table_count = 0;\n+    return 0;\n+  }\n+\n+  hb_face_for_data_closure_t *data = (hb_face_for_data_closure_t *) face->user_data;\n+\n+  const OT::OpenTypeFontFile &ot_file = *data->blob->as<OT::OpenTypeFontFile> ();\n+  const OT::OpenTypeFontFace &ot_face = ot_file.get_face (data->index);\n+\n+  return ot_face.get_table_tags (start_offset, table_count, table_tags);\n+}\n+\n+\n+\/*\n+ * Character set.\n+ *\/\n+\n+\n+\/**\n+ * hb_face_collect_unicodes:\n+ * @face: font face.\n+ * @out: set to add Unicode characters covered by @face to.\n+ *\n+ * Since: 1.9.0\n+ *\/\n+void\n+hb_face_collect_unicodes (hb_face_t *face,\n+                          hb_set_t  *out)\n+{\n+  face->table.cmap->collect_unicodes (out);\n+}\n+\n+\/**\n+ * hb_face_collect_variation_selectors:\n+ * @face: font face.\n+ * @out: set to add Variation Selector characters covered by @face to.\n+ *\n+ *\n+ *\n+ * Since: 1.9.0\n+ *\/\n+void\n+hb_face_collect_variation_selectors (hb_face_t *face,\n+                                     hb_set_t  *out)\n+{\n+  face->table.cmap->collect_variation_selectors (out);\n+}\n+\n+\/**\n+ * hb_face_collect_variation_unicodes:\n+ * @face: font face.\n+ * @out: set to add Unicode characters for @variation_selector covered by @face to.\n+ *\n+ *\n+ *\n+ * Since: 1.9.0\n+ *\/\n+void\n+hb_face_collect_variation_unicodes (hb_face_t *face,\n+                                    hb_codepoint_t variation_selector,\n+                                    hb_set_t  *out)\n+{\n+  face->table.cmap->collect_variation_unicodes (variation_selector, out);\n+}\n+\n+\n+\n+\/*\n+ * face-builder: A face that has add_table().\n+ *\/\n+\n+struct hb_face_builder_data_t\n+{\n+  struct table_entry_t\n+  {\n+    int cmp (hb_tag_t t) const\n+    {\n+      if (t < tag) return -1;\n+      if (t > tag) return -1;\n+      return 0;\n+    }\n+\n+    hb_tag_t   tag;\n+    hb_blob_t *blob;\n+  };\n+\n+  hb_vector_t<table_entry_t> tables;\n+};\n+\n+static hb_face_builder_data_t *\n+_hb_face_builder_data_create ()\n+{\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) calloc (1, sizeof (hb_face_builder_data_t));\n+  if (unlikely (!data))\n+    return nullptr;\n+\n+  data->tables.init ();\n+\n+  return data;\n+}\n+\n+static void\n+_hb_face_builder_data_destroy (void *user_data)\n+{\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;\n+\n+  for (unsigned int i = 0; i < data->tables.length; i++)\n+    hb_blob_destroy (data->tables[i].blob);\n+\n+  data->tables.fini ();\n+\n+  free (data);\n+}\n+\n+static hb_blob_t *\n+_hb_face_builder_data_reference_blob (hb_face_builder_data_t *data)\n+{\n+\n+  unsigned int table_count = data->tables.length;\n+  unsigned int face_length = table_count * 16 + 12;\n+\n+  for (unsigned int i = 0; i < table_count; i++)\n+    face_length += hb_ceil_to_4 (hb_blob_get_length (data->tables[i].blob));\n+\n+  char *buf = (char *) malloc (face_length);\n+  if (unlikely (!buf))\n+    return nullptr;\n+\n+  hb_serialize_context_t c (buf, face_length);\n+  c.propagate_error (data->tables);\n+  OT::OpenTypeFontFile *f = c.start_serialize<OT::OpenTypeFontFile> ();\n+\n+  bool is_cff = data->tables.lsearch (HB_TAG ('C','F','F',' ')) || data->tables.lsearch (HB_TAG ('C','F','F','2'));\n+  hb_tag_t sfnt_tag = is_cff ? OT::OpenTypeFontFile::CFFTag : OT::OpenTypeFontFile::TrueTypeTag;\n+\n+  bool ret = f->serialize_single (&c, sfnt_tag, data->tables.as_array ());\n+\n+  c.end_serialize ();\n+\n+  if (unlikely (!ret))\n+  {\n+    free (buf);\n+    return nullptr;\n+  }\n+\n+  return hb_blob_create (buf, face_length, HB_MEMORY_MODE_WRITABLE, buf, free);\n+}\n+\n+static hb_blob_t *\n+_hb_face_builder_reference_table (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)\n+{\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) user_data;\n+\n+  if (!tag)\n+    return _hb_face_builder_data_reference_blob (data);\n+\n+  hb_face_builder_data_t::table_entry_t *entry = data->tables.lsearch (tag);\n+  if (entry)\n+    return hb_blob_reference (entry->blob);\n+\n+  return nullptr;\n+}\n+\n+\n+\/**\n+ * hb_face_builder_create:\n+ *\n+ * Creates a #hb_face_t that can be used with hb_face_builder_add_table().\n+ * After tables are added to the face, it can be compiled to a binary\n+ * font file by calling hb_face_reference_blob().\n+ *\n+ * Return value: (transfer full): New face.\n+ *\n+ * Since: 1.9.0\n+ **\/\n+hb_face_t *\n+hb_face_builder_create ()\n+{\n+  hb_face_builder_data_t *data = _hb_face_builder_data_create ();\n+  if (unlikely (!data)) return hb_face_get_empty ();\n+\n+  return hb_face_create_for_tables (_hb_face_builder_reference_table,\n+                                    data,\n+                                    _hb_face_builder_data_destroy);\n+}\n+\n+\/**\n+ * hb_face_builder_add_table:\n+ *\n+ * Add table for @tag with data provided by @blob to the face.  @face must\n+ * be created using hb_face_builder_create().\n+ *\n+ * Since: 1.9.0\n+ **\/\n+hb_bool_t\n+hb_face_builder_add_table (hb_face_t *face, hb_tag_t tag, hb_blob_t *blob)\n+{\n+  if (unlikely (face->destroy != (hb_destroy_func_t) _hb_face_builder_data_destroy))\n+    return false;\n+\n+  hb_face_builder_data_t *data = (hb_face_builder_data_t *) face->user_data;\n+  hb_face_builder_data_t::table_entry_t *entry = data->tables.push ();\n+\n+  entry->tag = tag;\n+  entry->blob = hb_blob_reference (blob);\n+\n+  return true;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-face.cc","additions":723,"deletions":0,"binary":false,"changes":723,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_FACE_H\n+#define HB_FACE_H\n+\n+#include \"hb-common.h\"\n+#include \"hb-blob.h\"\n+#include \"hb-set.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+HB_EXTERN unsigned int\n+hb_face_count (hb_blob_t *blob);\n+\n+\n+\/*\n+ * hb_face_t\n+ *\/\n+\n+typedef struct hb_face_t hb_face_t;\n+\n+HB_EXTERN hb_face_t *\n+hb_face_create (hb_blob_t    *blob,\n+                unsigned int  index);\n+\n+typedef hb_blob_t * (*hb_reference_table_func_t)  (hb_face_t *face, hb_tag_t tag, void *user_data);\n+\n+\/* calls destroy() when not needing user_data anymore *\/\n+HB_EXTERN hb_face_t *\n+hb_face_create_for_tables (hb_reference_table_func_t  reference_table_func,\n+                           void                      *user_data,\n+                           hb_destroy_func_t          destroy);\n+\n+HB_EXTERN hb_face_t *\n+hb_face_get_empty (void);\n+\n+HB_EXTERN hb_face_t *\n+hb_face_reference (hb_face_t *face);\n+\n+HB_EXTERN void\n+hb_face_destroy (hb_face_t *face);\n+\n+HB_EXTERN hb_bool_t\n+hb_face_set_user_data (hb_face_t          *face,\n+                       hb_user_data_key_t *key,\n+                       void *              data,\n+                       hb_destroy_func_t   destroy,\n+                       hb_bool_t           replace);\n+\n+HB_EXTERN void *\n+hb_face_get_user_data (const hb_face_t    *face,\n+                       hb_user_data_key_t *key);\n+\n+HB_EXTERN void\n+hb_face_make_immutable (hb_face_t *face);\n+\n+HB_EXTERN hb_bool_t\n+hb_face_is_immutable (const hb_face_t *face);\n+\n+\n+HB_EXTERN hb_blob_t *\n+hb_face_reference_table (const hb_face_t *face,\n+                         hb_tag_t tag);\n+\n+HB_EXTERN hb_blob_t *\n+hb_face_reference_blob (hb_face_t *face);\n+\n+HB_EXTERN void\n+hb_face_set_index (hb_face_t    *face,\n+                   unsigned int  index);\n+\n+HB_EXTERN unsigned int\n+hb_face_get_index (const hb_face_t *face);\n+\n+HB_EXTERN void\n+hb_face_set_upem (hb_face_t    *face,\n+                  unsigned int  upem);\n+\n+HB_EXTERN unsigned int\n+hb_face_get_upem (const hb_face_t *face);\n+\n+HB_EXTERN void\n+hb_face_set_glyph_count (hb_face_t    *face,\n+                         unsigned int  glyph_count);\n+\n+HB_EXTERN unsigned int\n+hb_face_get_glyph_count (const hb_face_t *face);\n+\n+HB_EXTERN unsigned int\n+hb_face_get_table_tags (const hb_face_t *face,\n+                        unsigned int  start_offset,\n+                        unsigned int *table_count, \/* IN\/OUT *\/\n+                        hb_tag_t     *table_tags \/* OUT *\/);\n+\n+\n+\/*\n+ * Character set.\n+ *\/\n+\n+HB_EXTERN void\n+hb_face_collect_unicodes (hb_face_t *face,\n+                          hb_set_t  *out);\n+\n+HB_EXTERN void\n+hb_face_collect_variation_selectors (hb_face_t *face,\n+                                     hb_set_t  *out);\n+\n+HB_EXTERN void\n+hb_face_collect_variation_unicodes (hb_face_t *face,\n+                                    hb_codepoint_t variation_selector,\n+                                    hb_set_t  *out);\n+\n+\n+\/*\n+ * Builder face.\n+ *\/\n+\n+HB_EXTERN hb_face_t *\n+hb_face_builder_create (void);\n+\n+HB_EXTERN hb_bool_t\n+hb_face_builder_add_table (hb_face_t *face,\n+                           hb_tag_t   tag,\n+                           hb_blob_t *blob);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_FACE_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-face.h","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2011  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_FACE_HH\n+#define HB_FACE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-shaper.hh\"\n+#include \"hb-shape-plan.hh\"\n+#include \"hb-ot-face.hh\"\n+\n+\n+\/*\n+ * hb_face_t\n+ *\/\n+\n+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INSTANTIATE_SHAPERS(shaper, face);\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+\n+struct hb_face_t\n+{\n+  hb_object_header_t header;\n+\n+  hb_reference_table_func_t  reference_table_func;\n+  void                      *user_data;\n+  hb_destroy_func_t          destroy;\n+\n+  unsigned int index;                   \/* Face index in a collection, zero-based. *\/\n+  mutable hb_atomic_int_t upem;         \/* Units-per-EM. *\/\n+  mutable hb_atomic_int_t num_glyphs;   \/* Number of glyphs. *\/\n+\n+  hb_shaper_object_dataset_t<hb_face_t> data;\/* Various shaper data. *\/\n+  hb_ot_face_t table;                   \/* All the face's tables. *\/\n+\n+  \/* Cache *\/\n+  struct plan_node_t\n+  {\n+    hb_shape_plan_t *shape_plan;\n+    plan_node_t *next;\n+  };\n+  hb_atomic_ptr_t<plan_node_t> shape_plans;\n+\n+  hb_blob_t *reference_table (hb_tag_t tag) const\n+  {\n+    hb_blob_t *blob;\n+\n+    if (unlikely (!reference_table_func))\n+      return hb_blob_get_empty ();\n+\n+    blob = reference_table_func (\/*XXX*\/const_cast<hb_face_t *> (this), tag, user_data);\n+    if (unlikely (!blob))\n+      return hb_blob_get_empty ();\n+\n+    return blob;\n+  }\n+\n+  HB_PURE_FUNC unsigned int get_upem () const\n+  {\n+    unsigned int ret = upem.get_relaxed ();\n+    if (unlikely (!ret))\n+    {\n+      return load_upem ();\n+    }\n+    return ret;\n+  }\n+\n+  unsigned int get_num_glyphs () const\n+  {\n+    unsigned int ret = num_glyphs.get_relaxed ();\n+    if (unlikely (ret == (unsigned int) -1))\n+      return load_num_glyphs ();\n+    return ret;\n+  }\n+\n+  private:\n+  HB_INTERNAL unsigned int load_upem () const;\n+  HB_INTERNAL unsigned int load_num_glyphs () const;\n+};\n+DECLARE_NULL_INSTANCE (hb_face_t);\n+\n+\n+#endif \/* HB_FACE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-face.hh","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,122 @@\n+\/*\n+ * Copyright © 2011  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-shaper-impl.hh\"\n+\n+\n+\/*\n+ * shaper face data\n+ *\/\n+\n+struct hb_fallback_face_data_t {};\n+\n+hb_fallback_face_data_t *\n+_hb_fallback_shaper_face_data_create (hb_face_t *face HB_UNUSED)\n+{\n+  return (hb_fallback_face_data_t *) HB_SHAPER_DATA_SUCCEEDED;\n+}\n+\n+void\n+_hb_fallback_shaper_face_data_destroy (hb_fallback_face_data_t *data HB_UNUSED)\n+{\n+}\n+\n+\n+\/*\n+ * shaper font data\n+ *\/\n+\n+struct hb_fallback_font_data_t {};\n+\n+hb_fallback_font_data_t *\n+_hb_fallback_shaper_font_data_create (hb_font_t *font HB_UNUSED)\n+{\n+  return (hb_fallback_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;\n+}\n+\n+void\n+_hb_fallback_shaper_font_data_destroy (hb_fallback_font_data_t *data HB_UNUSED)\n+{\n+}\n+\n+\n+\/*\n+ * shaper\n+ *\/\n+\n+hb_bool_t\n+_hb_fallback_shape (hb_shape_plan_t    *shape_plan HB_UNUSED,\n+                    hb_font_t          *font,\n+                    hb_buffer_t        *buffer,\n+                    const hb_feature_t *features HB_UNUSED,\n+                    unsigned int        num_features HB_UNUSED)\n+{\n+  \/* TODO\n+   *\n+   * - Apply fallback kern.\n+   * - Handle Variation Selectors?\n+   * - Apply normalization?\n+   *\n+   * This will make the fallback shaper into a dumb \"TrueType\"\n+   * shaper which many people unfortunately still request.\n+   *\/\n+\n+  hb_codepoint_t space;\n+  bool has_space = (bool) font->get_nominal_glyph (' ', &space);\n+\n+  buffer->clear_positions ();\n+\n+  hb_direction_t direction = buffer->props.direction;\n+  hb_unicode_funcs_t *unicode = buffer->unicode;\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  hb_glyph_position_t *pos = buffer->pos;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    if (has_space && unicode->is_default_ignorable (info[i].codepoint)) {\n+      info[i].codepoint = space;\n+      pos[i].x_advance = 0;\n+      pos[i].y_advance = 0;\n+      continue;\n+    }\n+    (void) font->get_nominal_glyph (info[i].codepoint, &info[i].codepoint);\n+    font->get_glyph_advance_for_direction (info[i].codepoint,\n+                                           direction,\n+                                           &pos[i].x_advance,\n+                                           &pos[i].y_advance);\n+    font->subtract_glyph_origin_for_direction (info[i].codepoint,\n+                                               direction,\n+                                               &pos[i].x_offset,\n+                                               &pos[i].y_offset);\n+  }\n+\n+  if (HB_DIRECTION_IS_BACKWARD (direction))\n+    hb_buffer_reverse (buffer);\n+\n+  buffer->safe_to_break_all ();\n+\n+  return true;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-fallback-shape.cc","additions":122,"deletions":0,"binary":false,"changes":122,"status":"added"},{"patch":"@@ -0,0 +1,2038 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-font.hh\"\n+#include \"hb-machinery.hh\"\n+\n+#include \"hb-ot.h\"\n+\n+\n+\/**\n+ * SECTION:hb-font\n+ * @title: hb-font\n+ * @short_description: Font objects\n+ * @include: hb.h\n+ *\n+ * Font objects represent a font face at a certain size and other\n+ * parameters (pixels per EM, points per EM, variation settings.)\n+ * Fonts are created from font faces, and are used as input to\n+ * hb_shape() among other things.\n+ **\/\n+\n+\n+\/*\n+ * hb_font_funcs_t\n+ *\/\n+\n+static hb_bool_t\n+hb_font_get_font_h_extents_nil (hb_font_t *font HB_UNUSED,\n+                                void *font_data HB_UNUSED,\n+                                hb_font_extents_t *extents,\n+                                void *user_data HB_UNUSED)\n+{\n+  memset (extents, 0, sizeof (*extents));\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_font_h_extents_default (hb_font_t *font,\n+                                    void *font_data HB_UNUSED,\n+                                    hb_font_extents_t *extents,\n+                                    void *user_data HB_UNUSED)\n+{\n+  hb_bool_t ret = font->parent->get_font_h_extents (extents);\n+  if (ret) {\n+    extents->ascender = font->parent_scale_y_distance (extents->ascender);\n+    extents->descender = font->parent_scale_y_distance (extents->descender);\n+    extents->line_gap = font->parent_scale_y_distance (extents->line_gap);\n+  }\n+  return ret;\n+}\n+\n+static hb_bool_t\n+hb_font_get_font_v_extents_nil (hb_font_t *font HB_UNUSED,\n+                                void *font_data HB_UNUSED,\n+                                hb_font_extents_t *extents,\n+                                void *user_data HB_UNUSED)\n+{\n+  memset (extents, 0, sizeof (*extents));\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_font_v_extents_default (hb_font_t *font,\n+                                    void *font_data HB_UNUSED,\n+                                    hb_font_extents_t *extents,\n+                                    void *user_data HB_UNUSED)\n+{\n+  hb_bool_t ret = font->parent->get_font_v_extents (extents);\n+  if (ret) {\n+    extents->ascender = font->parent_scale_x_distance (extents->ascender);\n+    extents->descender = font->parent_scale_x_distance (extents->descender);\n+    extents->line_gap = font->parent_scale_x_distance (extents->line_gap);\n+  }\n+  return ret;\n+}\n+\n+static hb_bool_t\n+hb_font_get_nominal_glyph_nil (hb_font_t *font HB_UNUSED,\n+                               void *font_data HB_UNUSED,\n+                               hb_codepoint_t unicode HB_UNUSED,\n+                               hb_codepoint_t *glyph,\n+                               void *user_data HB_UNUSED)\n+{\n+  *glyph = 0;\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_nominal_glyph_default (hb_font_t *font,\n+                                   void *font_data HB_UNUSED,\n+                                   hb_codepoint_t unicode,\n+                                   hb_codepoint_t *glyph,\n+                                   void *user_data HB_UNUSED)\n+{\n+  if (font->has_nominal_glyphs_func_set ())\n+  {\n+    return font->get_nominal_glyphs (1, &unicode, 0, glyph, 0);\n+  }\n+  return font->parent->get_nominal_glyph (unicode, glyph);\n+}\n+\n+#define hb_font_get_nominal_glyphs_nil hb_font_get_nominal_glyphs_default\n+static unsigned int\n+hb_font_get_nominal_glyphs_default (hb_font_t *font,\n+                                    void *font_data HB_UNUSED,\n+                                    unsigned int count,\n+                                    const hb_codepoint_t *first_unicode,\n+                                    unsigned int unicode_stride,\n+                                    hb_codepoint_t *first_glyph,\n+                                    unsigned int glyph_stride,\n+                                    void *user_data HB_UNUSED)\n+{\n+  if (font->has_nominal_glyph_func_set ())\n+  {\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (!font->get_nominal_glyph (*first_unicode, first_glyph))\n+        return i;\n+\n+      first_unicode = &StructAtOffsetUnaligned<hb_codepoint_t> (first_unicode, unicode_stride);\n+      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+    }\n+    return count;\n+  }\n+\n+  return font->parent->get_nominal_glyphs (count,\n+                                           first_unicode, unicode_stride,\n+                                           first_glyph, glyph_stride);\n+}\n+\n+static hb_bool_t\n+hb_font_get_variation_glyph_nil (hb_font_t *font HB_UNUSED,\n+                                 void *font_data HB_UNUSED,\n+                                 hb_codepoint_t unicode HB_UNUSED,\n+                                 hb_codepoint_t variation_selector HB_UNUSED,\n+                                 hb_codepoint_t *glyph,\n+                                 void *user_data HB_UNUSED)\n+{\n+  *glyph = 0;\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_variation_glyph_default (hb_font_t *font,\n+                                     void *font_data HB_UNUSED,\n+                                     hb_codepoint_t unicode,\n+                                     hb_codepoint_t variation_selector,\n+                                     hb_codepoint_t *glyph,\n+                                     void *user_data HB_UNUSED)\n+{\n+  return font->parent->get_variation_glyph (unicode, variation_selector, glyph);\n+}\n+\n+\n+static hb_position_t\n+hb_font_get_glyph_h_advance_nil (hb_font_t *font,\n+                                 void *font_data HB_UNUSED,\n+                                 hb_codepoint_t glyph HB_UNUSED,\n+                                 void *user_data HB_UNUSED)\n+{\n+  return font->x_scale;\n+}\n+static hb_position_t\n+hb_font_get_glyph_h_advance_default (hb_font_t *font,\n+                                     void *font_data HB_UNUSED,\n+                                     hb_codepoint_t glyph,\n+                                     void *user_data HB_UNUSED)\n+{\n+  if (font->has_glyph_h_advances_func_set ())\n+  {\n+    hb_position_t ret;\n+    font->get_glyph_h_advances (1, &glyph, 0, &ret, 0);\n+    return ret;\n+  }\n+  return font->parent_scale_x_distance (font->parent->get_glyph_h_advance (glyph));\n+}\n+\n+static hb_position_t\n+hb_font_get_glyph_v_advance_nil (hb_font_t *font,\n+                                 void *font_data HB_UNUSED,\n+                                 hb_codepoint_t glyph HB_UNUSED,\n+                                 void *user_data HB_UNUSED)\n+{\n+  \/* TODO use font_extents.ascender+descender *\/\n+  return font->y_scale;\n+}\n+static hb_position_t\n+hb_font_get_glyph_v_advance_default (hb_font_t *font,\n+                                     void *font_data HB_UNUSED,\n+                                     hb_codepoint_t glyph,\n+                                     void *user_data HB_UNUSED)\n+{\n+  if (font->has_glyph_v_advances_func_set ())\n+  {\n+    hb_position_t ret;\n+    font->get_glyph_v_advances (1, &glyph, 0, &ret, 0);\n+    return ret;\n+  }\n+  return font->parent_scale_y_distance (font->parent->get_glyph_v_advance (glyph));\n+}\n+\n+#define hb_font_get_glyph_h_advances_nil hb_font_get_glyph_h_advances_default\n+static void\n+hb_font_get_glyph_h_advances_default (hb_font_t* font,\n+                                      void* font_data HB_UNUSED,\n+                                      unsigned int count,\n+                                      const hb_codepoint_t *first_glyph,\n+                                      unsigned int glyph_stride,\n+                                      hb_position_t *first_advance,\n+                                      unsigned int advance_stride,\n+                                      void *user_data HB_UNUSED)\n+{\n+  if (font->has_glyph_h_advance_func_set ())\n+  {\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance = font->get_glyph_h_advance (*first_glyph);\n+      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n+    return;\n+  }\n+\n+  font->parent->get_glyph_h_advances (count,\n+                                      first_glyph, glyph_stride,\n+                                      first_advance, advance_stride);\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    *first_advance = font->parent_scale_x_distance (*first_advance);\n+    first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+  }\n+}\n+\n+#define hb_font_get_glyph_v_advances_nil hb_font_get_glyph_v_advances_default\n+static void\n+hb_font_get_glyph_v_advances_default (hb_font_t* font,\n+                                      void* font_data HB_UNUSED,\n+                                      unsigned int count,\n+                                      const hb_codepoint_t *first_glyph,\n+                                      unsigned int glyph_stride,\n+                                      hb_position_t *first_advance,\n+                                      unsigned int advance_stride,\n+                                      void *user_data HB_UNUSED)\n+{\n+  if (font->has_glyph_v_advance_func_set ())\n+  {\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      *first_advance = font->get_glyph_v_advance (*first_glyph);\n+      first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+      first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+    }\n+    return;\n+  }\n+\n+  font->parent->get_glyph_v_advances (count,\n+                                      first_glyph, glyph_stride,\n+                                      first_advance, advance_stride);\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    *first_advance = font->parent_scale_y_distance (*first_advance);\n+    first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+  }\n+}\n+\n+static hb_bool_t\n+hb_font_get_glyph_h_origin_nil (hb_font_t *font HB_UNUSED,\n+                                void *font_data HB_UNUSED,\n+                                hb_codepoint_t glyph HB_UNUSED,\n+                                hb_position_t *x,\n+                                hb_position_t *y,\n+                                void *user_data HB_UNUSED)\n+{\n+  *x = *y = 0;\n+  return true;\n+}\n+static hb_bool_t\n+hb_font_get_glyph_h_origin_default (hb_font_t *font,\n+                                    void *font_data HB_UNUSED,\n+                                    hb_codepoint_t glyph,\n+                                    hb_position_t *x,\n+                                    hb_position_t *y,\n+                                    void *user_data HB_UNUSED)\n+{\n+  hb_bool_t ret = font->parent->get_glyph_h_origin (glyph, x, y);\n+  if (ret)\n+    font->parent_scale_position (x, y);\n+  return ret;\n+}\n+\n+static hb_bool_t\n+hb_font_get_glyph_v_origin_nil (hb_font_t *font HB_UNUSED,\n+                                void *font_data HB_UNUSED,\n+                                hb_codepoint_t glyph HB_UNUSED,\n+                                hb_position_t *x,\n+                                hb_position_t *y,\n+                                void *user_data HB_UNUSED)\n+{\n+  *x = *y = 0;\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_glyph_v_origin_default (hb_font_t *font,\n+                                    void *font_data HB_UNUSED,\n+                                    hb_codepoint_t glyph,\n+                                    hb_position_t *x,\n+                                    hb_position_t *y,\n+                                    void *user_data HB_UNUSED)\n+{\n+  hb_bool_t ret = font->parent->get_glyph_v_origin (glyph, x, y);\n+  if (ret)\n+    font->parent_scale_position (x, y);\n+  return ret;\n+}\n+\n+static hb_position_t\n+hb_font_get_glyph_h_kerning_nil (hb_font_t *font HB_UNUSED,\n+                                 void *font_data HB_UNUSED,\n+                                 hb_codepoint_t left_glyph HB_UNUSED,\n+                                 hb_codepoint_t right_glyph HB_UNUSED,\n+                                 void *user_data HB_UNUSED)\n+{\n+  return 0;\n+}\n+static hb_position_t\n+hb_font_get_glyph_h_kerning_default (hb_font_t *font,\n+                                     void *font_data HB_UNUSED,\n+                                     hb_codepoint_t left_glyph,\n+                                     hb_codepoint_t right_glyph,\n+                                     void *user_data HB_UNUSED)\n+{\n+  return font->parent_scale_x_distance (font->parent->get_glyph_h_kerning (left_glyph, right_glyph));\n+}\n+\n+static hb_position_t\n+hb_font_get_glyph_v_kerning_nil (hb_font_t *font HB_UNUSED,\n+                                 void *font_data HB_UNUSED,\n+                                 hb_codepoint_t top_glyph HB_UNUSED,\n+                                 hb_codepoint_t bottom_glyph HB_UNUSED,\n+                                 void *user_data HB_UNUSED)\n+{\n+  return 0;\n+}\n+static hb_position_t\n+hb_font_get_glyph_v_kerning_default (hb_font_t *font,\n+                                     void *font_data HB_UNUSED,\n+                                     hb_codepoint_t top_glyph,\n+                                     hb_codepoint_t bottom_glyph,\n+                                     void *user_data HB_UNUSED)\n+{\n+  return font->parent_scale_y_distance (font->parent->get_glyph_v_kerning (top_glyph, bottom_glyph));\n+}\n+\n+static hb_bool_t\n+hb_font_get_glyph_extents_nil (hb_font_t *font HB_UNUSED,\n+                               void *font_data HB_UNUSED,\n+                               hb_codepoint_t glyph HB_UNUSED,\n+                               hb_glyph_extents_t *extents,\n+                               void *user_data HB_UNUSED)\n+{\n+  memset (extents, 0, sizeof (*extents));\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_glyph_extents_default (hb_font_t *font,\n+                                   void *font_data HB_UNUSED,\n+                                   hb_codepoint_t glyph,\n+                                   hb_glyph_extents_t *extents,\n+                                   void *user_data HB_UNUSED)\n+{\n+  hb_bool_t ret = font->parent->get_glyph_extents (glyph, extents);\n+  if (ret) {\n+    font->parent_scale_position (&extents->x_bearing, &extents->y_bearing);\n+    font->parent_scale_distance (&extents->width, &extents->height);\n+  }\n+  return ret;\n+}\n+\n+static hb_bool_t\n+hb_font_get_glyph_contour_point_nil (hb_font_t *font HB_UNUSED,\n+                                     void *font_data HB_UNUSED,\n+                                     hb_codepoint_t glyph HB_UNUSED,\n+                                     unsigned int point_index HB_UNUSED,\n+                                     hb_position_t *x,\n+                                     hb_position_t *y,\n+                                     void *user_data HB_UNUSED)\n+{\n+  *x = *y = 0;\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_glyph_contour_point_default (hb_font_t *font,\n+                                         void *font_data HB_UNUSED,\n+                                         hb_codepoint_t glyph,\n+                                         unsigned int point_index,\n+                                         hb_position_t *x,\n+                                         hb_position_t *y,\n+                                         void *user_data HB_UNUSED)\n+{\n+  hb_bool_t ret = font->parent->get_glyph_contour_point (glyph, point_index, x, y);\n+  if (ret)\n+    font->parent_scale_position (x, y);\n+  return ret;\n+}\n+\n+static hb_bool_t\n+hb_font_get_glyph_name_nil (hb_font_t *font HB_UNUSED,\n+                            void *font_data HB_UNUSED,\n+                            hb_codepoint_t glyph HB_UNUSED,\n+                            char *name, unsigned int size,\n+                            void *user_data HB_UNUSED)\n+{\n+  if (size) *name = '\\0';\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_glyph_name_default (hb_font_t *font,\n+                                void *font_data HB_UNUSED,\n+                                hb_codepoint_t glyph,\n+                                char *name, unsigned int size,\n+                                void *user_data HB_UNUSED)\n+{\n+  return font->parent->get_glyph_name (glyph, name, size);\n+}\n+\n+static hb_bool_t\n+hb_font_get_glyph_from_name_nil (hb_font_t *font HB_UNUSED,\n+                                 void *font_data HB_UNUSED,\n+                                 const char *name HB_UNUSED,\n+                                 int len HB_UNUSED, \/* -1 means nul-terminated *\/\n+                                 hb_codepoint_t *glyph,\n+                                 void *user_data HB_UNUSED)\n+{\n+  *glyph = 0;\n+  return false;\n+}\n+static hb_bool_t\n+hb_font_get_glyph_from_name_default (hb_font_t *font,\n+                                     void *font_data HB_UNUSED,\n+                                     const char *name, int len, \/* -1 means nul-terminated *\/\n+                                     hb_codepoint_t *glyph,\n+                                     void *user_data HB_UNUSED)\n+{\n+  return font->parent->get_glyph_from_name (name, len, glyph);\n+}\n+\n+DEFINE_NULL_INSTANCE (hb_font_funcs_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  {\n+#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+  },\n+  {\n+#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+  },\n+  {\n+    {\n+#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_nil,\n+      HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+    }\n+  }\n+};\n+\n+static const hb_font_funcs_t _hb_font_funcs_default = {\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  {\n+#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+  },\n+  {\n+#define HB_FONT_FUNC_IMPLEMENT(name) nullptr,\n+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+  },\n+  {\n+    {\n+#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_default,\n+      HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+    }\n+  }\n+};\n+\n+\n+\/**\n+ * hb_font_funcs_create: (Xconstructor)\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_funcs_t *\n+hb_font_funcs_create ()\n+{\n+  hb_font_funcs_t *ffuncs;\n+\n+  if (!(ffuncs = hb_object_create<hb_font_funcs_t> ()))\n+    return hb_font_funcs_get_empty ();\n+\n+  ffuncs->get = _hb_font_funcs_default.get;\n+\n+  return ffuncs;\n+}\n+\n+\/**\n+ * hb_font_funcs_get_empty:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_funcs_t *\n+hb_font_funcs_get_empty ()\n+{\n+  return const_cast<hb_font_funcs_t *> (&_hb_font_funcs_default);\n+}\n+\n+\/**\n+ * hb_font_funcs_reference: (skip)\n+ * @ffuncs: font functions.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_funcs_t *\n+hb_font_funcs_reference (hb_font_funcs_t *ffuncs)\n+{\n+  return hb_object_reference (ffuncs);\n+}\n+\n+\/**\n+ * hb_font_funcs_destroy: (skip)\n+ * @ffuncs: font functions.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_funcs_destroy (hb_font_funcs_t *ffuncs)\n+{\n+  if (!hb_object_destroy (ffuncs)) return;\n+\n+#define HB_FONT_FUNC_IMPLEMENT(name) if (ffuncs->destroy.name) \\\n+  ffuncs->destroy.name (ffuncs->user_data.name);\n+  HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+\n+  free (ffuncs);\n+}\n+\n+\/**\n+ * hb_font_funcs_set_user_data: (skip)\n+ * @ffuncs: font functions.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_funcs_set_user_data (hb_font_funcs_t    *ffuncs,\n+                             hb_user_data_key_t *key,\n+                             void *              data,\n+                             hb_destroy_func_t   destroy,\n+                             hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (ffuncs, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_font_funcs_get_user_data: (skip)\n+ * @ffuncs: font functions.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void *\n+hb_font_funcs_get_user_data (hb_font_funcs_t    *ffuncs,\n+                             hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (ffuncs, key);\n+}\n+\n+\n+\/**\n+ * hb_font_funcs_make_immutable:\n+ * @ffuncs: font functions.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_funcs_make_immutable (hb_font_funcs_t *ffuncs)\n+{\n+  if (hb_object_is_immutable (ffuncs))\n+    return;\n+\n+  hb_object_make_immutable (ffuncs);\n+}\n+\n+\/**\n+ * hb_font_funcs_is_immutable:\n+ * @ffuncs: font functions.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_funcs_is_immutable (hb_font_funcs_t *ffuncs)\n+{\n+  return hb_object_is_immutable (ffuncs);\n+}\n+\n+\n+#define HB_FONT_FUNC_IMPLEMENT(name) \\\n+                                                                         \\\n+void                                                                     \\\n+hb_font_funcs_set_##name##_func (hb_font_funcs_t             *ffuncs,    \\\n+                                 hb_font_get_##name##_func_t  func,      \\\n+                                 void                        *user_data, \\\n+                                 hb_destroy_func_t            destroy)   \\\n+{                                                                        \\\n+  if (hb_object_is_immutable (ffuncs)) {                                 \\\n+    if (destroy)                                                         \\\n+      destroy (user_data);                                               \\\n+    return;                                                              \\\n+  }                                                                      \\\n+                                                                         \\\n+  if (ffuncs->destroy.name)                                              \\\n+    ffuncs->destroy.name (ffuncs->user_data.name);                       \\\n+                                                                         \\\n+  if (func) {                                                            \\\n+    ffuncs->get.f.name = func;                                           \\\n+    ffuncs->user_data.name = user_data;                                  \\\n+    ffuncs->destroy.name = destroy;                                      \\\n+  } else {                                                               \\\n+    ffuncs->get.f.name = hb_font_get_##name##_default;                   \\\n+    ffuncs->user_data.name = nullptr;                                    \\\n+    ffuncs->destroy.name = nullptr;                                      \\\n+  }                                                                      \\\n+}\n+\n+HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+\n+bool\n+hb_font_t::has_func_set (unsigned int i)\n+{\n+  return this->klass->get.array[i] != _hb_font_funcs_default.get.array[i];\n+}\n+\n+bool\n+hb_font_t::has_func (unsigned int i)\n+{\n+  return has_func_set (i) ||\n+         (parent && parent != &_hb_Null_hb_font_t && parent->has_func (i));\n+}\n+\n+\/* Public getters *\/\n+\n+\/**\n+ * hb_font_get_h_extents:\n+ * @font: a font.\n+ * @extents: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 1.1.3\n+ **\/\n+hb_bool_t\n+hb_font_get_h_extents (hb_font_t *font,\n+                       hb_font_extents_t *extents)\n+{\n+  return font->get_font_h_extents (extents);\n+}\n+\n+\/**\n+ * hb_font_get_v_extents:\n+ * @font: a font.\n+ * @extents: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 1.1.3\n+ **\/\n+hb_bool_t\n+hb_font_get_v_extents (hb_font_t *font,\n+                       hb_font_extents_t *extents)\n+{\n+  return font->get_font_v_extents (extents);\n+}\n+\n+\/**\n+ * hb_font_get_glyph:\n+ * @font: a font.\n+ * @unicode:\n+ * @variation_selector:\n+ * @glyph: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph (hb_font_t *font,\n+                   hb_codepoint_t unicode, hb_codepoint_t variation_selector,\n+                   hb_codepoint_t *glyph)\n+{\n+  if (unlikely (variation_selector))\n+    return font->get_variation_glyph (unicode, variation_selector, glyph);\n+  return font->get_nominal_glyph (unicode, glyph);\n+}\n+\n+\/**\n+ * hb_font_get_nominal_glyph:\n+ * @font: a font.\n+ * @unicode:\n+ * @glyph: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 1.2.3\n+ **\/\n+hb_bool_t\n+hb_font_get_nominal_glyph (hb_font_t *font,\n+                           hb_codepoint_t unicode,\n+                           hb_codepoint_t *glyph)\n+{\n+  return font->get_nominal_glyph (unicode, glyph);\n+}\n+\n+\/**\n+ * hb_font_get_variation_glyph:\n+ * @font: a font.\n+ * @unicode:\n+ * @variation_selector:\n+ * @glyph: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 1.2.3\n+ **\/\n+hb_bool_t\n+hb_font_get_variation_glyph (hb_font_t *font,\n+                             hb_codepoint_t unicode, hb_codepoint_t variation_selector,\n+                             hb_codepoint_t *glyph)\n+{\n+  return font->get_variation_glyph (unicode, variation_selector, glyph);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_h_advance:\n+ * @font: a font.\n+ * @glyph:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_position_t\n+hb_font_get_glyph_h_advance (hb_font_t *font,\n+                             hb_codepoint_t glyph)\n+{\n+  return font->get_glyph_h_advance (glyph);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_v_advance:\n+ * @font: a font.\n+ * @glyph:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_position_t\n+hb_font_get_glyph_v_advance (hb_font_t *font,\n+                             hb_codepoint_t glyph)\n+{\n+  return font->get_glyph_v_advance (glyph);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_h_advances:\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Since: 1.8.6\n+ **\/\n+void\n+hb_font_get_glyph_h_advances (hb_font_t* font,\n+                              unsigned int count,\n+                              const hb_codepoint_t *first_glyph,\n+                              unsigned glyph_stride,\n+                              hb_position_t *first_advance,\n+                              unsigned advance_stride)\n+{\n+  font->get_glyph_h_advances (count, first_glyph, glyph_stride, first_advance, advance_stride);\n+}\n+\/**\n+ * hb_font_get_glyph_v_advances:\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Since: 1.8.6\n+ **\/\n+void\n+hb_font_get_glyph_v_advances (hb_font_t* font,\n+                              unsigned int count,\n+                              const hb_codepoint_t *first_glyph,\n+                              unsigned glyph_stride,\n+                              hb_position_t *first_advance,\n+                              unsigned advance_stride)\n+{\n+  font->get_glyph_v_advances (count, first_glyph, glyph_stride, first_advance, advance_stride);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_h_origin:\n+ * @font: a font.\n+ * @glyph:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_h_origin (hb_font_t *font,\n+                            hb_codepoint_t glyph,\n+                            hb_position_t *x, hb_position_t *y)\n+{\n+  return font->get_glyph_h_origin (glyph, x, y);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_v_origin:\n+ * @font: a font.\n+ * @glyph:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_v_origin (hb_font_t *font,\n+                            hb_codepoint_t glyph,\n+                            hb_position_t *x, hb_position_t *y)\n+{\n+  return font->get_glyph_v_origin (glyph, x, y);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_h_kerning:\n+ * @font: a font.\n+ * @left_glyph:\n+ * @right_glyph:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+hb_position_t\n+hb_font_get_glyph_h_kerning (hb_font_t *font,\n+                             hb_codepoint_t left_glyph, hb_codepoint_t right_glyph)\n+{\n+  return font->get_glyph_h_kerning (left_glyph, right_glyph);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_v_kerning:\n+ * @font: a font.\n+ * @top_glyph:\n+ * @bottom_glyph:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+hb_position_t\n+hb_font_get_glyph_v_kerning (hb_font_t *font,\n+                             hb_codepoint_t top_glyph, hb_codepoint_t bottom_glyph)\n+{\n+  return font->get_glyph_v_kerning (top_glyph, bottom_glyph);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_extents:\n+ * @font: a font.\n+ * @glyph:\n+ * @extents: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_extents (hb_font_t *font,\n+                           hb_codepoint_t glyph,\n+                           hb_glyph_extents_t *extents)\n+{\n+  return font->get_glyph_extents (glyph, extents);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_contour_point:\n+ * @font: a font.\n+ * @glyph:\n+ * @point_index:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_contour_point (hb_font_t *font,\n+                                 hb_codepoint_t glyph, unsigned int point_index,\n+                                 hb_position_t *x, hb_position_t *y)\n+{\n+  return font->get_glyph_contour_point (glyph, point_index, x, y);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_name:\n+ * @font: a font.\n+ * @glyph:\n+ * @name: (array length=size):\n+ * @size:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_name (hb_font_t *font,\n+                        hb_codepoint_t glyph,\n+                        char *name, unsigned int size)\n+{\n+  return font->get_glyph_name (glyph, name, size);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_from_name:\n+ * @font: a font.\n+ * @name: (array length=len):\n+ * @len:\n+ * @glyph: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_from_name (hb_font_t *font,\n+                             const char *name, int len, \/* -1 means nul-terminated *\/\n+                             hb_codepoint_t *glyph)\n+{\n+  return font->get_glyph_from_name (name, len, glyph);\n+}\n+\n+\n+\/* A bit higher-level, and with fallback *\/\n+\n+\/**\n+ * hb_font_get_extents_for_direction:\n+ * @font: a font.\n+ * @direction:\n+ * @extents: (out):\n+ *\n+ *\n+ *\n+ * Since: 1.1.3\n+ **\/\n+void\n+hb_font_get_extents_for_direction (hb_font_t *font,\n+                                   hb_direction_t direction,\n+                                   hb_font_extents_t *extents)\n+{\n+  return font->get_extents_for_direction (direction, extents);\n+}\n+\/**\n+ * hb_font_get_glyph_advance_for_direction:\n+ * @font: a font.\n+ * @glyph:\n+ * @direction:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_get_glyph_advance_for_direction (hb_font_t *font,\n+                                         hb_codepoint_t glyph,\n+                                         hb_direction_t direction,\n+                                         hb_position_t *x, hb_position_t *y)\n+{\n+  return font->get_glyph_advance_for_direction (glyph, direction, x, y);\n+}\n+\/**\n+ * hb_font_get_glyph_advances_for_direction:\n+ * @font: a font.\n+ * @direction:\n+ *\n+ *\n+ *\n+ * Since: 1.8.6\n+ **\/\n+HB_EXTERN void\n+hb_font_get_glyph_advances_for_direction (hb_font_t* font,\n+                                          hb_direction_t direction,\n+                                          unsigned int count,\n+                                          const hb_codepoint_t *first_glyph,\n+                                          unsigned glyph_stride,\n+                                          hb_position_t *first_advance,\n+                                          unsigned advance_stride)\n+{\n+  font->get_glyph_advances_for_direction (direction, count, first_glyph, glyph_stride, first_advance, advance_stride);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_origin_for_direction:\n+ * @font: a font.\n+ * @glyph:\n+ * @direction:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_get_glyph_origin_for_direction (hb_font_t *font,\n+                                        hb_codepoint_t glyph,\n+                                        hb_direction_t direction,\n+                                        hb_position_t *x, hb_position_t *y)\n+{\n+  return font->get_glyph_origin_for_direction (glyph, direction, x, y);\n+}\n+\n+\/**\n+ * hb_font_add_glyph_origin_for_direction:\n+ * @font: a font.\n+ * @glyph:\n+ * @direction:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_add_glyph_origin_for_direction (hb_font_t *font,\n+                                        hb_codepoint_t glyph,\n+                                        hb_direction_t direction,\n+                                        hb_position_t *x, hb_position_t *y)\n+{\n+  return font->add_glyph_origin_for_direction (glyph, direction, x, y);\n+}\n+\n+\/**\n+ * hb_font_subtract_glyph_origin_for_direction:\n+ * @font: a font.\n+ * @glyph:\n+ * @direction:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_subtract_glyph_origin_for_direction (hb_font_t *font,\n+                                             hb_codepoint_t glyph,\n+                                             hb_direction_t direction,\n+                                             hb_position_t *x, hb_position_t *y)\n+{\n+  return font->subtract_glyph_origin_for_direction (glyph, direction, x, y);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_kerning_for_direction:\n+ * @font: a font.\n+ * @first_glyph:\n+ * @second_glyph:\n+ * @direction:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+void\n+hb_font_get_glyph_kerning_for_direction (hb_font_t *font,\n+                                         hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,\n+                                         hb_direction_t direction,\n+                                         hb_position_t *x, hb_position_t *y)\n+{\n+  return font->get_glyph_kerning_for_direction (first_glyph, second_glyph, direction, x, y);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_extents_for_origin:\n+ * @font: a font.\n+ * @glyph:\n+ * @direction:\n+ * @extents: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_extents_for_origin (hb_font_t *font,\n+                                      hb_codepoint_t glyph,\n+                                      hb_direction_t direction,\n+                                      hb_glyph_extents_t *extents)\n+{\n+  return font->get_glyph_extents_for_origin (glyph, direction, extents);\n+}\n+\n+\/**\n+ * hb_font_get_glyph_contour_point_for_origin:\n+ * @font: a font.\n+ * @glyph:\n+ * @point_index:\n+ * @direction:\n+ * @x: (out):\n+ * @y: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_get_glyph_contour_point_for_origin (hb_font_t *font,\n+                                            hb_codepoint_t glyph, unsigned int point_index,\n+                                            hb_direction_t direction,\n+                                            hb_position_t *x, hb_position_t *y)\n+{\n+  return font->get_glyph_contour_point_for_origin (glyph, point_index, direction, x, y);\n+}\n+\n+\/* Generates gidDDD if glyph has no name. *\/\n+\/**\n+ * hb_font_glyph_to_string:\n+ * @font: a font.\n+ * @glyph:\n+ * @s: (array length=size):\n+ * @size:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_glyph_to_string (hb_font_t *font,\n+                         hb_codepoint_t glyph,\n+                         char *s, unsigned int size)\n+{\n+  font->glyph_to_string (glyph, s, size);\n+}\n+\n+\/* Parses gidDDD and uniUUUU strings automatically. *\/\n+\/**\n+ * hb_font_glyph_from_string:\n+ * @font: a font.\n+ * @s: (array length=len) (element-type uint8_t):\n+ * @len:\n+ * @glyph: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_glyph_from_string (hb_font_t *font,\n+                           const char *s, int len, \/* -1 means nul-terminated *\/\n+                           hb_codepoint_t *glyph)\n+{\n+  return font->glyph_from_string (s, len, glyph);\n+}\n+\n+\n+\/*\n+ * hb_font_t\n+ *\/\n+\n+DEFINE_NULL_INSTANCE (hb_font_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  nullptr, \/* parent *\/\n+  const_cast<hb_face_t *> (&_hb_Null_hb_face_t),\n+\n+  1000, \/* x_scale *\/\n+  1000, \/* y_scale *\/\n+\n+  0, \/* x_ppem *\/\n+  0, \/* y_ppem *\/\n+  0, \/* ptem *\/\n+\n+  0, \/* num_coords *\/\n+  nullptr, \/* coords *\/\n+\n+  const_cast<hb_font_funcs_t *> (&_hb_Null_hb_font_funcs_t),\n+\n+  \/* Zero for the rest is fine. *\/\n+};\n+\n+\n+static hb_font_t *\n+_hb_font_create (hb_face_t *face)\n+{\n+  hb_font_t *font;\n+\n+  if (unlikely (!face))\n+    face = hb_face_get_empty ();\n+  if (!(font = hb_object_create<hb_font_t> ()))\n+    return hb_font_get_empty ();\n+\n+  hb_face_make_immutable (face);\n+  font->parent = hb_font_get_empty ();\n+  font->face = hb_face_reference (face);\n+  font->klass = hb_font_funcs_get_empty ();\n+  font->data.init0 (font);\n+  font->x_scale = font->y_scale = hb_face_get_upem (face);\n+\n+  return font;\n+}\n+\n+\/**\n+ * hb_font_create: (Xconstructor)\n+ * @face: a face.\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_t *\n+hb_font_create (hb_face_t *face)\n+{\n+  hb_font_t *font = _hb_font_create (face);\n+\n+  \/* Install our in-house, very lightweight, funcs. *\/\n+  hb_ot_font_set_funcs (font);\n+\n+  return font;\n+}\n+\n+\/**\n+ * hb_font_create_sub_font:\n+ * @parent: parent font.\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_t *\n+hb_font_create_sub_font (hb_font_t *parent)\n+{\n+  if (unlikely (!parent))\n+    parent = hb_font_get_empty ();\n+\n+  hb_font_t *font = _hb_font_create (parent->face);\n+\n+  if (unlikely (hb_object_is_immutable (font)))\n+    return font;\n+\n+  font->parent = hb_font_reference (parent);\n+\n+  font->x_scale = parent->x_scale;\n+  font->y_scale = parent->y_scale;\n+  font->x_ppem = parent->x_ppem;\n+  font->y_ppem = parent->y_ppem;\n+  font->ptem = parent->ptem;\n+\n+  font->num_coords = parent->num_coords;\n+  if (!font->num_coords)\n+    font->coords = nullptr;\n+  else\n+  {\n+    unsigned int size = parent->num_coords * sizeof (parent->coords[0]);\n+    font->coords = (int *) malloc (size);\n+    if (unlikely (!font->coords))\n+      font->num_coords = 0;\n+    else\n+      memcpy (font->coords, parent->coords, size);\n+  }\n+\n+  return font;\n+}\n+\n+\/**\n+ * hb_font_get_empty:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full)\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_t *\n+hb_font_get_empty ()\n+{\n+  return const_cast<hb_font_t *> (&Null(hb_font_t));\n+}\n+\n+\/**\n+ * hb_font_reference: (skip)\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_t *\n+hb_font_reference (hb_font_t *font)\n+{\n+  return hb_object_reference (font);\n+}\n+\n+\/**\n+ * hb_font_destroy: (skip)\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_destroy (hb_font_t *font)\n+{\n+  if (!hb_object_destroy (font)) return;\n+\n+  font->data.fini ();\n+\n+  if (font->destroy)\n+    font->destroy (font->user_data);\n+\n+  hb_font_destroy (font->parent);\n+  hb_face_destroy (font->face);\n+  hb_font_funcs_destroy (font->klass);\n+\n+  free (font->coords);\n+\n+  free (font);\n+}\n+\n+\/**\n+ * hb_font_set_user_data: (skip)\n+ * @font: a font.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_set_user_data (hb_font_t          *font,\n+                       hb_user_data_key_t *key,\n+                       void *              data,\n+                       hb_destroy_func_t   destroy,\n+                       hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (font, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_font_get_user_data: (skip)\n+ * @font: a font.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void *\n+hb_font_get_user_data (hb_font_t          *font,\n+                       hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (font, key);\n+}\n+\n+\/**\n+ * hb_font_make_immutable:\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_make_immutable (hb_font_t *font)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  if (font->parent)\n+    hb_font_make_immutable (font->parent);\n+\n+  hb_object_make_immutable (font);\n+}\n+\n+\/**\n+ * hb_font_is_immutable:\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_font_is_immutable (hb_font_t *font)\n+{\n+  return hb_object_is_immutable (font);\n+}\n+\n+\/**\n+ * hb_font_set_parent:\n+ * @font: a font.\n+ * @parent: new parent.\n+ *\n+ * Sets parent font of @font.\n+ *\n+ * Since: 1.0.5\n+ **\/\n+void\n+hb_font_set_parent (hb_font_t *font,\n+                    hb_font_t *parent)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  if (!parent)\n+    parent = hb_font_get_empty ();\n+\n+  hb_font_t *old = font->parent;\n+\n+  font->parent = hb_font_reference (parent);\n+\n+  hb_font_destroy (old);\n+}\n+\n+\/**\n+ * hb_font_get_parent:\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_font_t *\n+hb_font_get_parent (hb_font_t *font)\n+{\n+  return font->parent;\n+}\n+\n+\/**\n+ * hb_font_set_face:\n+ * @font: a font.\n+ * @face: new face.\n+ *\n+ * Sets font-face of @font.\n+ *\n+ * Since: 1.4.3\n+ **\/\n+void\n+hb_font_set_face (hb_font_t *font,\n+                  hb_face_t *face)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  if (unlikely (!face))\n+    face = hb_face_get_empty ();\n+\n+  hb_face_t *old = font->face;\n+\n+  font->face = hb_face_reference (face);\n+\n+  hb_face_destroy (old);\n+}\n+\n+\/**\n+ * hb_font_get_face:\n+ * @font: a font.\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_face_t *\n+hb_font_get_face (hb_font_t *font)\n+{\n+  return font->face;\n+}\n+\n+\n+\/**\n+ * hb_font_set_funcs:\n+ * @font: a font.\n+ * @klass: (closure font_data) (destroy destroy) (scope notified):\n+ * @font_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_set_funcs (hb_font_t         *font,\n+                   hb_font_funcs_t   *klass,\n+                   void              *font_data,\n+                   hb_destroy_func_t  destroy)\n+{\n+  if (hb_object_is_immutable (font))\n+  {\n+    if (destroy)\n+      destroy (font_data);\n+    return;\n+  }\n+\n+  if (font->destroy)\n+    font->destroy (font->user_data);\n+\n+  if (!klass)\n+    klass = hb_font_funcs_get_empty ();\n+\n+  hb_font_funcs_reference (klass);\n+  hb_font_funcs_destroy (font->klass);\n+  font->klass = klass;\n+  font->user_data = font_data;\n+  font->destroy = destroy;\n+}\n+\n+\/**\n+ * hb_font_set_funcs_data:\n+ * @font: a font.\n+ * @font_data: (destroy destroy) (scope notified):\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_set_funcs_data (hb_font_t         *font,\n+                        void              *font_data,\n+                        hb_destroy_func_t  destroy)\n+{\n+  \/* Destroy user_data? *\/\n+  if (hb_object_is_immutable (font))\n+  {\n+    if (destroy)\n+      destroy (font_data);\n+    return;\n+  }\n+\n+  if (font->destroy)\n+    font->destroy (font->user_data);\n+\n+  font->user_data = font_data;\n+  font->destroy = destroy;\n+}\n+\n+\n+\/**\n+ * hb_font_set_scale:\n+ * @font: a font.\n+ * @x_scale:\n+ * @y_scale:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_set_scale (hb_font_t *font,\n+                   int x_scale,\n+                   int y_scale)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  font->x_scale = x_scale;\n+  font->y_scale = y_scale;\n+}\n+\n+\/**\n+ * hb_font_get_scale:\n+ * @font: a font.\n+ * @x_scale: (out):\n+ * @y_scale: (out):\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_get_scale (hb_font_t *font,\n+                   int *x_scale,\n+                   int *y_scale)\n+{\n+  if (x_scale) *x_scale = font->x_scale;\n+  if (y_scale) *y_scale = font->y_scale;\n+}\n+\n+\/**\n+ * hb_font_set_ppem:\n+ * @font: a font.\n+ * @x_ppem:\n+ * @y_ppem:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_set_ppem (hb_font_t *font,\n+                  unsigned int x_ppem,\n+                  unsigned int y_ppem)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  font->x_ppem = x_ppem;\n+  font->y_ppem = y_ppem;\n+}\n+\n+\/**\n+ * hb_font_get_ppem:\n+ * @font: a font.\n+ * @x_ppem: (out):\n+ * @y_ppem: (out):\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_font_get_ppem (hb_font_t *font,\n+                  unsigned int *x_ppem,\n+                  unsigned int *y_ppem)\n+{\n+  if (x_ppem) *x_ppem = font->x_ppem;\n+  if (y_ppem) *y_ppem = font->y_ppem;\n+}\n+\n+\/**\n+ * hb_font_set_ptem:\n+ * @font: a font.\n+ * @ptem: font size in points.\n+ *\n+ * Sets \"point size\" of the font.  Set to 0 to unset.\n+ *\n+ * There are 72 points in an inch.\n+ *\n+ * Since: 1.6.0\n+ **\/\n+void\n+hb_font_set_ptem (hb_font_t *font, float ptem)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  font->ptem = ptem;\n+}\n+\n+\/**\n+ * hb_font_get_ptem:\n+ * @font: a font.\n+ *\n+ * Gets the \"point size\" of the font.  A value of 0 means unset.\n+ *\n+ * Return value: Point size.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+float\n+hb_font_get_ptem (hb_font_t *font)\n+{\n+  return font->ptem;\n+}\n+\n+\/*\n+ * Variations\n+ *\/\n+\n+static void\n+_hb_font_adopt_var_coords_normalized (hb_font_t *font,\n+                                      int *coords, \/* 2.14 normalized *\/\n+                                      unsigned int coords_length)\n+{\n+  free (font->coords);\n+\n+  font->coords = coords;\n+  font->num_coords = coords_length;\n+}\n+\n+\/**\n+ * hb_font_set_variations:\n+ *\n+ * Since: 1.4.2\n+ *\/\n+void\n+hb_font_set_variations (hb_font_t *font,\n+                        const hb_variation_t *variations,\n+                        unsigned int variations_length)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  if (!variations_length)\n+  {\n+    hb_font_set_var_coords_normalized (font, nullptr, 0);\n+    return;\n+  }\n+\n+  unsigned int coords_length = hb_ot_var_get_axis_count (font->face);\n+\n+  int *normalized = coords_length ? (int *) calloc (coords_length, sizeof (int)) : nullptr;\n+  if (unlikely (coords_length && !normalized))\n+    return;\n+\n+  hb_ot_var_normalize_variations (font->face,\n+                                  variations, variations_length,\n+                                  normalized, coords_length);\n+  _hb_font_adopt_var_coords_normalized (font, normalized, coords_length);\n+}\n+\n+\/**\n+ * hb_font_set_var_coords_design:\n+ *\n+ * Since: 1.4.2\n+ *\/\n+void\n+hb_font_set_var_coords_design (hb_font_t *font,\n+                               const float *coords,\n+                               unsigned int coords_length)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  int *normalized = coords_length ? (int *) calloc (coords_length, sizeof (int)) : nullptr;\n+  if (unlikely (coords_length && !normalized))\n+    return;\n+\n+  hb_ot_var_normalize_coords (font->face, coords_length, coords, normalized);\n+  _hb_font_adopt_var_coords_normalized (font, normalized, coords_length);\n+}\n+\n+\/**\n+ * hb_font_set_var_coords_normalized:\n+ *\n+ * Since: 1.4.2\n+ *\/\n+void\n+hb_font_set_var_coords_normalized (hb_font_t *font,\n+                                   const int *coords, \/* 2.14 normalized *\/\n+                                   unsigned int coords_length)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  int *copy = coords_length ? (int *) calloc (coords_length, sizeof (coords[0])) : nullptr;\n+  if (unlikely (coords_length && !copy))\n+    return;\n+\n+  if (coords_length)\n+    memcpy (copy, coords, coords_length * sizeof (coords[0]));\n+\n+  _hb_font_adopt_var_coords_normalized (font, copy, coords_length);\n+}\n+\n+\/**\n+ * hb_font_get_var_coords_normalized:\n+ *\n+ * Return value is valid as long as variation coordinates of the font\n+ * are not modified.\n+ *\n+ * Since: 1.4.2\n+ *\/\n+const int *\n+hb_font_get_var_coords_normalized (hb_font_t *font,\n+                                   unsigned int *length)\n+{\n+  if (length)\n+    *length = font->num_coords;\n+\n+  return font->coords;\n+}\n+\n+\n+\/*\n+ * Deprecated get_glyph_func():\n+ *\/\n+\n+struct hb_trampoline_closure_t\n+{\n+  void *user_data;\n+  hb_destroy_func_t destroy;\n+  unsigned int ref_count;\n+};\n+\n+template <typename FuncType>\n+struct hb_trampoline_t\n+{\n+  hb_trampoline_closure_t closure; \/* Must be first. *\/\n+  FuncType func;\n+};\n+\n+template <typename FuncType>\n+static hb_trampoline_t<FuncType> *\n+trampoline_create (FuncType           func,\n+                   void              *user_data,\n+                   hb_destroy_func_t  destroy)\n+{\n+  typedef hb_trampoline_t<FuncType> trampoline_t;\n+\n+  trampoline_t *trampoline = (trampoline_t *) calloc (1, sizeof (trampoline_t));\n+\n+  if (unlikely (!trampoline))\n+    return nullptr;\n+\n+  trampoline->closure.user_data = user_data;\n+  trampoline->closure.destroy = destroy;\n+  trampoline->closure.ref_count = 1;\n+  trampoline->func = func;\n+\n+  return trampoline;\n+}\n+\n+static void\n+trampoline_reference (hb_trampoline_closure_t *closure)\n+{\n+  closure->ref_count++;\n+}\n+\n+static void\n+trampoline_destroy (void *user_data)\n+{\n+  hb_trampoline_closure_t *closure = (hb_trampoline_closure_t *) user_data;\n+\n+  if (--closure->ref_count)\n+    return;\n+\n+  if (closure->destroy)\n+    closure->destroy (closure->user_data);\n+  free (closure);\n+}\n+\n+typedef hb_trampoline_t<hb_font_get_glyph_func_t> hb_font_get_glyph_trampoline_t;\n+\n+static hb_bool_t\n+hb_font_get_nominal_glyph_trampoline (hb_font_t *font,\n+                                      void *font_data,\n+                                      hb_codepoint_t unicode,\n+                                      hb_codepoint_t *glyph,\n+                                      void *user_data)\n+{\n+  hb_font_get_glyph_trampoline_t *trampoline = (hb_font_get_glyph_trampoline_t *) user_data;\n+  return trampoline->func (font, font_data, unicode, 0, glyph, trampoline->closure.user_data);\n+}\n+\n+static hb_bool_t\n+hb_font_get_variation_glyph_trampoline (hb_font_t *font,\n+                                        void *font_data,\n+                                        hb_codepoint_t unicode,\n+                                        hb_codepoint_t variation_selector,\n+                                        hb_codepoint_t *glyph,\n+                                        void *user_data)\n+{\n+  hb_font_get_glyph_trampoline_t *trampoline = (hb_font_get_glyph_trampoline_t *) user_data;\n+  return trampoline->func (font, font_data, unicode, variation_selector, glyph, trampoline->closure.user_data);\n+}\n+\n+\/**\n+ * hb_font_funcs_set_glyph_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified): callback function.\n+ * @user_data: data to pass to @func.\n+ * @destroy: function to call when @user_data is not needed anymore.\n+ *\n+ * Deprecated.  Use hb_font_funcs_set_nominal_glyph_func() and\n+ * hb_font_funcs_set_variation_glyph_func() instead.\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 1.2.3\n+ **\/\n+void\n+hb_font_funcs_set_glyph_func (hb_font_funcs_t *ffuncs,\n+                              hb_font_get_glyph_func_t func,\n+                              void *user_data, hb_destroy_func_t destroy)\n+{\n+  hb_font_get_glyph_trampoline_t *trampoline;\n+\n+  trampoline = trampoline_create (func, user_data, destroy);\n+  if (unlikely (!trampoline))\n+  {\n+    if (destroy)\n+      destroy (user_data);\n+    return;\n+  }\n+\n+  hb_font_funcs_set_nominal_glyph_func (ffuncs,\n+                                        hb_font_get_nominal_glyph_trampoline,\n+                                        trampoline,\n+                                        trampoline_destroy);\n+\n+  trampoline_reference (&trampoline->closure);\n+  hb_font_funcs_set_variation_glyph_func (ffuncs,\n+                                          hb_font_get_variation_glyph_trampoline,\n+                                          trampoline,\n+                                          trampoline_destroy);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-font.cc","additions":2038,"deletions":0,"binary":false,"changes":2038,"status":"added"},{"patch":"@@ -0,0 +1,679 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_FONT_H\n+#define HB_FONT_H\n+\n+#include \"hb-common.h\"\n+#include \"hb-face.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+typedef struct hb_font_t hb_font_t;\n+\n+\n+\/*\n+ * hb_font_funcs_t\n+ *\/\n+\n+typedef struct hb_font_funcs_t hb_font_funcs_t;\n+\n+HB_EXTERN hb_font_funcs_t *\n+hb_font_funcs_create (void);\n+\n+HB_EXTERN hb_font_funcs_t *\n+hb_font_funcs_get_empty (void);\n+\n+HB_EXTERN hb_font_funcs_t *\n+hb_font_funcs_reference (hb_font_funcs_t *ffuncs);\n+\n+HB_EXTERN void\n+hb_font_funcs_destroy (hb_font_funcs_t *ffuncs);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_funcs_set_user_data (hb_font_funcs_t    *ffuncs,\n+                             hb_user_data_key_t *key,\n+                             void *              data,\n+                             hb_destroy_func_t   destroy,\n+                             hb_bool_t           replace);\n+\n+\n+HB_EXTERN void *\n+hb_font_funcs_get_user_data (hb_font_funcs_t    *ffuncs,\n+                             hb_user_data_key_t *key);\n+\n+\n+HB_EXTERN void\n+hb_font_funcs_make_immutable (hb_font_funcs_t *ffuncs);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_funcs_is_immutable (hb_font_funcs_t *ffuncs);\n+\n+\n+\/* font and glyph extents *\/\n+\n+\/* Note that typically ascender is positive and descender negative in coordinate systems that grow up. *\/\n+typedef struct hb_font_extents_t\n+{\n+  hb_position_t ascender; \/* typographic ascender. *\/\n+  hb_position_t descender; \/* typographic descender. *\/\n+  hb_position_t line_gap; \/* suggested line spacing gap. *\/\n+  \/*< private >*\/\n+  hb_position_t reserved9;\n+  hb_position_t reserved8;\n+  hb_position_t reserved7;\n+  hb_position_t reserved6;\n+  hb_position_t reserved5;\n+  hb_position_t reserved4;\n+  hb_position_t reserved3;\n+  hb_position_t reserved2;\n+  hb_position_t reserved1;\n+} hb_font_extents_t;\n+\n+\/* Note that height is negative in coordinate systems that grow up. *\/\n+typedef struct hb_glyph_extents_t\n+{\n+  hb_position_t x_bearing; \/* left side of glyph from origin. *\/\n+  hb_position_t y_bearing; \/* top side of glyph from origin. *\/\n+  hb_position_t width; \/* distance from left to right side. *\/\n+  hb_position_t height; \/* distance from top to bottom side. *\/\n+} hb_glyph_extents_t;\n+\n+\/* func types *\/\n+\n+typedef hb_bool_t (*hb_font_get_font_extents_func_t) (hb_font_t *font, void *font_data,\n+                                                       hb_font_extents_t *extents,\n+                                                       void *user_data);\n+typedef hb_font_get_font_extents_func_t hb_font_get_font_h_extents_func_t;\n+typedef hb_font_get_font_extents_func_t hb_font_get_font_v_extents_func_t;\n+\n+\n+typedef hb_bool_t (*hb_font_get_nominal_glyph_func_t) (hb_font_t *font, void *font_data,\n+                                                       hb_codepoint_t unicode,\n+                                                       hb_codepoint_t *glyph,\n+                                                       void *user_data);\n+typedef hb_bool_t (*hb_font_get_variation_glyph_func_t) (hb_font_t *font, void *font_data,\n+                                                         hb_codepoint_t unicode, hb_codepoint_t variation_selector,\n+                                                         hb_codepoint_t *glyph,\n+                                                         void *user_data);\n+\n+typedef unsigned int (*hb_font_get_nominal_glyphs_func_t) (hb_font_t *font, void *font_data,\n+                                                           unsigned int count,\n+                                                           const hb_codepoint_t *first_unicode,\n+                                                           unsigned int unicode_stride,\n+                                                           hb_codepoint_t *first_glyph,\n+                                                           unsigned int glyph_stride,\n+                                                           void *user_data);\n+\n+\n+typedef hb_position_t (*hb_font_get_glyph_advance_func_t) (hb_font_t *font, void *font_data,\n+                                                           hb_codepoint_t glyph,\n+                                                           void *user_data);\n+typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_h_advance_func_t;\n+typedef hb_font_get_glyph_advance_func_t hb_font_get_glyph_v_advance_func_t;\n+\n+typedef void (*hb_font_get_glyph_advances_func_t) (hb_font_t* font, void* font_data,\n+                                                   unsigned int count,\n+                                                   const hb_codepoint_t *first_glyph,\n+                                                   unsigned glyph_stride,\n+                                                   hb_position_t *first_advance,\n+                                                   unsigned advance_stride,\n+                                                   void *user_data);\n+typedef hb_font_get_glyph_advances_func_t hb_font_get_glyph_h_advances_func_t;\n+typedef hb_font_get_glyph_advances_func_t hb_font_get_glyph_v_advances_func_t;\n+\n+typedef hb_bool_t (*hb_font_get_glyph_origin_func_t) (hb_font_t *font, void *font_data,\n+                                                      hb_codepoint_t glyph,\n+                                                      hb_position_t *x, hb_position_t *y,\n+                                                      void *user_data);\n+typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_h_origin_func_t;\n+typedef hb_font_get_glyph_origin_func_t hb_font_get_glyph_v_origin_func_t;\n+\n+\n+typedef hb_bool_t (*hb_font_get_glyph_extents_func_t) (hb_font_t *font, void *font_data,\n+                                                       hb_codepoint_t glyph,\n+                                                       hb_glyph_extents_t *extents,\n+                                                       void *user_data);\n+typedef hb_bool_t (*hb_font_get_glyph_contour_point_func_t) (hb_font_t *font, void *font_data,\n+                                                             hb_codepoint_t glyph, unsigned int point_index,\n+                                                             hb_position_t *x, hb_position_t *y,\n+                                                             void *user_data);\n+\n+\n+typedef hb_bool_t (*hb_font_get_glyph_name_func_t) (hb_font_t *font, void *font_data,\n+                                                    hb_codepoint_t glyph,\n+                                                    char *name, unsigned int size,\n+                                                    void *user_data);\n+typedef hb_bool_t (*hb_font_get_glyph_from_name_func_t) (hb_font_t *font, void *font_data,\n+                                                         const char *name, int len, \/* -1 means nul-terminated *\/\n+                                                         hb_codepoint_t *glyph,\n+                                                         void *user_data);\n+\n+\n+\/* func setters *\/\n+\n+\/**\n+ * hb_font_funcs_set_font_h_extents_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 1.1.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_font_h_extents_func (hb_font_funcs_t *ffuncs,\n+                                       hb_font_get_font_h_extents_func_t func,\n+                                       void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_font_v_extents_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 1.1.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_font_v_extents_func (hb_font_funcs_t *ffuncs,\n+                                       hb_font_get_font_v_extents_func_t func,\n+                                       void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_nominal_glyph_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 1.2.3\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_nominal_glyph_func (hb_font_funcs_t *ffuncs,\n+                                      hb_font_get_nominal_glyph_func_t func,\n+                                      void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_nominal_glyphs_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 2.0.0\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_nominal_glyphs_func (hb_font_funcs_t *ffuncs,\n+                                       hb_font_get_nominal_glyphs_func_t func,\n+                                       void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_variation_glyph_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 1.2.3\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_variation_glyph_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_variation_glyph_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_h_advance_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_h_advance_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_glyph_h_advance_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_v_advance_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_v_advance_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_glyph_v_advance_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_h_advances_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 1.8.6\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_h_advances_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_glyph_h_advances_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_v_advances_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 1.8.6\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_v_advances_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_glyph_v_advances_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_h_origin_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_h_origin_func (hb_font_funcs_t *ffuncs,\n+                                       hb_font_get_glyph_h_origin_func_t func,\n+                                       void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_v_origin_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_v_origin_func (hb_font_funcs_t *ffuncs,\n+                                       hb_font_get_glyph_v_origin_func_t func,\n+                                       void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_extents_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_extents_func (hb_font_funcs_t *ffuncs,\n+                                      hb_font_get_glyph_extents_func_t func,\n+                                      void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_contour_point_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_contour_point_func (hb_font_funcs_t *ffuncs,\n+                                            hb_font_get_glyph_contour_point_func_t func,\n+                                            void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_name_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_name_func (hb_font_funcs_t *ffuncs,\n+                                   hb_font_get_glyph_name_func_t func,\n+                                   void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_font_funcs_set_glyph_from_name_func:\n+ * @ffuncs: font functions.\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_font_funcs_set_glyph_from_name_func (hb_font_funcs_t *ffuncs,\n+                                        hb_font_get_glyph_from_name_func_t func,\n+                                        void *user_data, hb_destroy_func_t destroy);\n+\n+\/* func dispatch *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_h_extents (hb_font_t *font,\n+                       hb_font_extents_t *extents);\n+HB_EXTERN hb_bool_t\n+hb_font_get_v_extents (hb_font_t *font,\n+                       hb_font_extents_t *extents);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_nominal_glyph (hb_font_t *font,\n+                           hb_codepoint_t unicode,\n+                           hb_codepoint_t *glyph);\n+HB_EXTERN hb_bool_t\n+hb_font_get_variation_glyph (hb_font_t *font,\n+                             hb_codepoint_t unicode, hb_codepoint_t variation_selector,\n+                             hb_codepoint_t *glyph);\n+\n+HB_EXTERN hb_position_t\n+hb_font_get_glyph_h_advance (hb_font_t *font,\n+                             hb_codepoint_t glyph);\n+HB_EXTERN hb_position_t\n+hb_font_get_glyph_v_advance (hb_font_t *font,\n+                             hb_codepoint_t glyph);\n+\n+HB_EXTERN void\n+hb_font_get_glyph_h_advances (hb_font_t* font,\n+                              unsigned int count,\n+                              const hb_codepoint_t *first_glyph,\n+                              unsigned glyph_stride,\n+                              hb_position_t *first_advance,\n+                              unsigned advance_stride);\n+HB_EXTERN void\n+hb_font_get_glyph_v_advances (hb_font_t* font,\n+                              unsigned int count,\n+                              const hb_codepoint_t *first_glyph,\n+                              unsigned glyph_stride,\n+                              hb_position_t *first_advance,\n+                              unsigned advance_stride);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_h_origin (hb_font_t *font,\n+                            hb_codepoint_t glyph,\n+                            hb_position_t *x, hb_position_t *y);\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_v_origin (hb_font_t *font,\n+                            hb_codepoint_t glyph,\n+                            hb_position_t *x, hb_position_t *y);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_extents (hb_font_t *font,\n+                           hb_codepoint_t glyph,\n+                           hb_glyph_extents_t *extents);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_contour_point (hb_font_t *font,\n+                                 hb_codepoint_t glyph, unsigned int point_index,\n+                                 hb_position_t *x, hb_position_t *y);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_name (hb_font_t *font,\n+                        hb_codepoint_t glyph,\n+                        char *name, unsigned int size);\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_from_name (hb_font_t *font,\n+                             const char *name, int len, \/* -1 means nul-terminated *\/\n+                             hb_codepoint_t *glyph);\n+\n+\n+\/* high-level funcs, with fallback *\/\n+\n+\/* Calls either hb_font_get_nominal_glyph() if variation_selector is 0,\n+ * otherwise calls hb_font_get_variation_glyph(). *\/\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph (hb_font_t *font,\n+                   hb_codepoint_t unicode, hb_codepoint_t variation_selector,\n+                   hb_codepoint_t *glyph);\n+\n+HB_EXTERN void\n+hb_font_get_extents_for_direction (hb_font_t *font,\n+                                   hb_direction_t direction,\n+                                   hb_font_extents_t *extents);\n+HB_EXTERN void\n+hb_font_get_glyph_advance_for_direction (hb_font_t *font,\n+                                         hb_codepoint_t glyph,\n+                                         hb_direction_t direction,\n+                                         hb_position_t *x, hb_position_t *y);\n+HB_EXTERN void\n+hb_font_get_glyph_advances_for_direction (hb_font_t* font,\n+                                          hb_direction_t direction,\n+                                          unsigned int count,\n+                                          const hb_codepoint_t *first_glyph,\n+                                          unsigned glyph_stride,\n+                                          hb_position_t *first_advance,\n+                                          unsigned advance_stride);\n+HB_EXTERN void\n+hb_font_get_glyph_origin_for_direction (hb_font_t *font,\n+                                        hb_codepoint_t glyph,\n+                                        hb_direction_t direction,\n+                                        hb_position_t *x, hb_position_t *y);\n+HB_EXTERN void\n+hb_font_add_glyph_origin_for_direction (hb_font_t *font,\n+                                        hb_codepoint_t glyph,\n+                                        hb_direction_t direction,\n+                                        hb_position_t *x, hb_position_t *y);\n+HB_EXTERN void\n+hb_font_subtract_glyph_origin_for_direction (hb_font_t *font,\n+                                             hb_codepoint_t glyph,\n+                                             hb_direction_t direction,\n+                                             hb_position_t *x, hb_position_t *y);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_extents_for_origin (hb_font_t *font,\n+                                      hb_codepoint_t glyph,\n+                                      hb_direction_t direction,\n+                                      hb_glyph_extents_t *extents);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_get_glyph_contour_point_for_origin (hb_font_t *font,\n+                                            hb_codepoint_t glyph, unsigned int point_index,\n+                                            hb_direction_t direction,\n+                                            hb_position_t *x, hb_position_t *y);\n+\n+\/* Generates gidDDD if glyph has no name. *\/\n+HB_EXTERN void\n+hb_font_glyph_to_string (hb_font_t *font,\n+                         hb_codepoint_t glyph,\n+                         char *s, unsigned int size);\n+\/* Parses gidDDD and uniUUUU strings automatically. *\/\n+HB_EXTERN hb_bool_t\n+hb_font_glyph_from_string (hb_font_t *font,\n+                           const char *s, int len, \/* -1 means nul-terminated *\/\n+                           hb_codepoint_t *glyph);\n+\n+\n+\/*\n+ * hb_font_t\n+ *\/\n+\n+\/* Fonts are very light-weight objects *\/\n+\n+HB_EXTERN hb_font_t *\n+hb_font_create (hb_face_t *face);\n+\n+HB_EXTERN hb_font_t *\n+hb_font_create_sub_font (hb_font_t *parent);\n+\n+HB_EXTERN hb_font_t *\n+hb_font_get_empty (void);\n+\n+HB_EXTERN hb_font_t *\n+hb_font_reference (hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_font_destroy (hb_font_t *font);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_set_user_data (hb_font_t          *font,\n+                       hb_user_data_key_t *key,\n+                       void *              data,\n+                       hb_destroy_func_t   destroy,\n+                       hb_bool_t           replace);\n+\n+\n+HB_EXTERN void *\n+hb_font_get_user_data (hb_font_t          *font,\n+                       hb_user_data_key_t *key);\n+\n+HB_EXTERN void\n+hb_font_make_immutable (hb_font_t *font);\n+\n+HB_EXTERN hb_bool_t\n+hb_font_is_immutable (hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_font_set_parent (hb_font_t *font,\n+                    hb_font_t *parent);\n+\n+HB_EXTERN hb_font_t *\n+hb_font_get_parent (hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_font_set_face (hb_font_t *font,\n+                  hb_face_t *face);\n+\n+HB_EXTERN hb_face_t *\n+hb_font_get_face (hb_font_t *font);\n+\n+\n+HB_EXTERN void\n+hb_font_set_funcs (hb_font_t         *font,\n+                   hb_font_funcs_t   *klass,\n+                   void              *font_data,\n+                   hb_destroy_func_t  destroy);\n+\n+\/* Be *very* careful with this function! *\/\n+HB_EXTERN void\n+hb_font_set_funcs_data (hb_font_t         *font,\n+                        void              *font_data,\n+                        hb_destroy_func_t  destroy);\n+\n+\n+HB_EXTERN void\n+hb_font_set_scale (hb_font_t *font,\n+                   int x_scale,\n+                   int y_scale);\n+\n+HB_EXTERN void\n+hb_font_get_scale (hb_font_t *font,\n+                   int *x_scale,\n+                   int *y_scale);\n+\n+\/*\n+ * A zero value means \"no hinting in that direction\"\n+ *\/\n+HB_EXTERN void\n+hb_font_set_ppem (hb_font_t *font,\n+                  unsigned int x_ppem,\n+                  unsigned int y_ppem);\n+\n+HB_EXTERN void\n+hb_font_get_ppem (hb_font_t *font,\n+                  unsigned int *x_ppem,\n+                  unsigned int *y_ppem);\n+\n+\/*\n+ * Point size per EM.  Used for optical-sizing in CoreText.\n+ * A value of zero means \"not set\".\n+ *\/\n+HB_EXTERN void\n+hb_font_set_ptem (hb_font_t *font, float ptem);\n+\n+HB_EXTERN float\n+hb_font_get_ptem (hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_font_set_variations (hb_font_t *font,\n+                        const hb_variation_t *variations,\n+                        unsigned int variations_length);\n+\n+HB_EXTERN void\n+hb_font_set_var_coords_design (hb_font_t *font,\n+                               const float *coords,\n+                               unsigned int coords_length);\n+\n+HB_EXTERN void\n+hb_font_set_var_coords_normalized (hb_font_t *font,\n+                                   const int *coords, \/* 2.14 normalized *\/\n+                                   unsigned int coords_length);\n+\n+HB_EXTERN const int *\n+hb_font_get_var_coords_normalized (hb_font_t *font,\n+                                   unsigned int *length);\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_FONT_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-font.h","additions":679,"deletions":0,"binary":false,"changes":679,"status":"added"},{"patch":"@@ -0,0 +1,617 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2011  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_FONT_HH\n+#define HB_FONT_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-face.hh\"\n+#include \"hb-shaper.hh\"\n+\n+\n+\/*\n+ * hb_font_funcs_t\n+ *\/\n+\n+#define HB_FONT_FUNCS_IMPLEMENT_CALLBACKS \\\n+  HB_FONT_FUNC_IMPLEMENT (font_h_extents) \\\n+  HB_FONT_FUNC_IMPLEMENT (font_v_extents) \\\n+  HB_FONT_FUNC_IMPLEMENT (nominal_glyph) \\\n+  HB_FONT_FUNC_IMPLEMENT (nominal_glyphs) \\\n+  HB_FONT_FUNC_IMPLEMENT (variation_glyph) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_h_advance) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_v_advance) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_h_advances) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_v_advances) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_h_origin) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_v_origin) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_h_kerning) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_v_kerning) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_extents) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_contour_point) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_name) \\\n+  HB_FONT_FUNC_IMPLEMENT (glyph_from_name) \\\n+  \/* ^--- Add new callbacks here *\/\n+\n+struct hb_font_funcs_t\n+{\n+  hb_object_header_t header;\n+\n+  struct {\n+#define HB_FONT_FUNC_IMPLEMENT(name) void *name;\n+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+  } user_data;\n+\n+  struct {\n+#define HB_FONT_FUNC_IMPLEMENT(name) hb_destroy_func_t name;\n+    HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+  } destroy;\n+\n+  \/* Don't access these directly.  Call font->get_*() instead. *\/\n+  union get_t {\n+    struct get_funcs_t {\n+#define HB_FONT_FUNC_IMPLEMENT(name) hb_font_get_##name##_func_t name;\n+      HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+    } f;\n+    void (*array[0\n+#define HB_FONT_FUNC_IMPLEMENT(name) +1\n+      HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+                ]) ();\n+  } get;\n+};\n+DECLARE_NULL_INSTANCE (hb_font_funcs_t);\n+\n+\n+\/*\n+ * hb_font_t\n+ *\/\n+\n+#define HB_SHAPER_IMPLEMENT(shaper) HB_SHAPER_DATA_INSTANTIATE_SHAPERS(shaper, font);\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+\n+struct hb_font_t\n+{\n+  hb_object_header_t header;\n+\n+  hb_font_t *parent;\n+  hb_face_t *face;\n+\n+  int x_scale;\n+  int y_scale;\n+\n+  unsigned int x_ppem;\n+  unsigned int y_ppem;\n+\n+  float ptem;\n+\n+  \/* Font variation coordinates. *\/\n+  unsigned int num_coords;\n+  int *coords;\n+\n+  hb_font_funcs_t   *klass;\n+  void              *user_data;\n+  hb_destroy_func_t  destroy;\n+\n+  hb_shaper_object_dataset_t<hb_font_t> data; \/* Various shaper data. *\/\n+\n+\n+  \/* Convert from font-space to user-space *\/\n+  int dir_scale (hb_direction_t direction)\n+  { return HB_DIRECTION_IS_VERTICAL(direction) ? y_scale : x_scale; }\n+  hb_position_t em_scale_x (int16_t v) { return em_scale (v, x_scale); }\n+  hb_position_t em_scale_y (int16_t v) { return em_scale (v, y_scale); }\n+  hb_position_t em_scalef_x (float v) { return em_scalef (v, this->x_scale); }\n+  hb_position_t em_scalef_y (float v) { return em_scalef (v, this->y_scale); }\n+  float em_fscale_x (int16_t v) { return em_fscale (v, x_scale); }\n+  float em_fscale_y (int16_t v) { return em_fscale (v, y_scale); }\n+  hb_position_t em_scale_dir (int16_t v, hb_direction_t direction)\n+  { return em_scale (v, dir_scale (direction)); }\n+\n+  \/* Convert from parent-font user-space to our user-space *\/\n+  hb_position_t parent_scale_x_distance (hb_position_t v)\n+  {\n+    if (unlikely (parent && parent->x_scale != x_scale))\n+      return (hb_position_t) (v * (int64_t) this->x_scale \/ this->parent->x_scale);\n+    return v;\n+  }\n+  hb_position_t parent_scale_y_distance (hb_position_t v)\n+  {\n+    if (unlikely (parent && parent->y_scale != y_scale))\n+      return (hb_position_t) (v * (int64_t) this->y_scale \/ this->parent->y_scale);\n+    return v;\n+  }\n+  hb_position_t parent_scale_x_position (hb_position_t v)\n+  { return parent_scale_x_distance (v); }\n+  hb_position_t parent_scale_y_position (hb_position_t v)\n+  { return parent_scale_y_distance (v); }\n+\n+  void parent_scale_distance (hb_position_t *x, hb_position_t *y)\n+  {\n+    *x = parent_scale_x_distance (*x);\n+    *y = parent_scale_y_distance (*y);\n+  }\n+  void parent_scale_position (hb_position_t *x, hb_position_t *y)\n+  {\n+    *x = parent_scale_x_position (*x);\n+    *y = parent_scale_y_position (*y);\n+  }\n+\n+\n+  \/* Public getters *\/\n+\n+  HB_INTERNAL bool has_func (unsigned int i);\n+  HB_INTERNAL bool has_func_set (unsigned int i);\n+\n+  \/* has_* ... *\/\n+#define HB_FONT_FUNC_IMPLEMENT(name) \\\n+  bool \\\n+  has_##name##_func () \\\n+  { \\\n+    hb_font_funcs_t *funcs = this->klass; \\\n+    unsigned int i = offsetof (hb_font_funcs_t::get_t::get_funcs_t, name) \/ sizeof (funcs->get.array[0]); \\\n+    return has_func (i); \\\n+  } \\\n+  bool \\\n+  has_##name##_func_set () \\\n+  { \\\n+    hb_font_funcs_t *funcs = this->klass; \\\n+    unsigned int i = offsetof (hb_font_funcs_t::get_t::get_funcs_t, name) \/ sizeof (funcs->get.array[0]); \\\n+    return has_func_set (i); \\\n+  }\n+  HB_FONT_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_FONT_FUNC_IMPLEMENT\n+\n+  hb_bool_t get_font_h_extents (hb_font_extents_t *extents)\n+  {\n+    memset (extents, 0, sizeof (*extents));\n+    return klass->get.f.font_h_extents (this, user_data,\n+                                        extents,\n+                                        klass->user_data.font_h_extents);\n+  }\n+  hb_bool_t get_font_v_extents (hb_font_extents_t *extents)\n+  {\n+    memset (extents, 0, sizeof (*extents));\n+    return klass->get.f.font_v_extents (this, user_data,\n+                                        extents,\n+                                        klass->user_data.font_v_extents);\n+  }\n+\n+  bool has_glyph (hb_codepoint_t unicode)\n+  {\n+    hb_codepoint_t glyph;\n+    return get_nominal_glyph (unicode, &glyph);\n+  }\n+\n+  hb_bool_t get_nominal_glyph (hb_codepoint_t unicode,\n+                                      hb_codepoint_t *glyph)\n+  {\n+    *glyph = 0;\n+    return klass->get.f.nominal_glyph (this, user_data,\n+                                       unicode, glyph,\n+                                       klass->user_data.nominal_glyph);\n+  }\n+  unsigned int get_nominal_glyphs (unsigned int count,\n+                                   const hb_codepoint_t *first_unicode,\n+                                   unsigned int unicode_stride,\n+                                   hb_codepoint_t *first_glyph,\n+                                   unsigned int glyph_stride)\n+  {\n+    return klass->get.f.nominal_glyphs (this, user_data,\n+                                        count,\n+                                        first_unicode, unicode_stride,\n+                                        first_glyph, glyph_stride,\n+                                        klass->user_data.nominal_glyphs);\n+  }\n+\n+  hb_bool_t get_variation_glyph (hb_codepoint_t unicode, hb_codepoint_t variation_selector,\n+                                 hb_codepoint_t *glyph)\n+  {\n+    *glyph = 0;\n+    return klass->get.f.variation_glyph (this, user_data,\n+                                         unicode, variation_selector, glyph,\n+                                         klass->user_data.variation_glyph);\n+  }\n+\n+  hb_position_t get_glyph_h_advance (hb_codepoint_t glyph)\n+  {\n+    return klass->get.f.glyph_h_advance (this, user_data,\n+                                         glyph,\n+                                         klass->user_data.glyph_h_advance);\n+  }\n+\n+  hb_position_t get_glyph_v_advance (hb_codepoint_t glyph)\n+  {\n+    return klass->get.f.glyph_v_advance (this, user_data,\n+                                         glyph,\n+                                         klass->user_data.glyph_v_advance);\n+  }\n+\n+  void get_glyph_h_advances (unsigned int count,\n+                             const hb_codepoint_t *first_glyph,\n+                             unsigned int glyph_stride,\n+                             hb_position_t *first_advance,\n+                             unsigned int advance_stride)\n+  {\n+    return klass->get.f.glyph_h_advances (this, user_data,\n+                                          count,\n+                                          first_glyph, glyph_stride,\n+                                          first_advance, advance_stride,\n+                                          klass->user_data.glyph_h_advances);\n+  }\n+\n+  void get_glyph_v_advances (unsigned int count,\n+                             const hb_codepoint_t *first_glyph,\n+                             unsigned int glyph_stride,\n+                             hb_position_t *first_advance,\n+                             unsigned int advance_stride)\n+  {\n+    return klass->get.f.glyph_v_advances (this, user_data,\n+                                          count,\n+                                          first_glyph, glyph_stride,\n+                                          first_advance, advance_stride,\n+                                          klass->user_data.glyph_v_advances);\n+  }\n+\n+  hb_bool_t get_glyph_h_origin (hb_codepoint_t glyph,\n+                                       hb_position_t *x, hb_position_t *y)\n+  {\n+    *x = *y = 0;\n+    return klass->get.f.glyph_h_origin (this, user_data,\n+                                        glyph, x, y,\n+                                        klass->user_data.glyph_h_origin);\n+  }\n+\n+  hb_bool_t get_glyph_v_origin (hb_codepoint_t glyph,\n+                                hb_position_t *x, hb_position_t *y)\n+  {\n+    *x = *y = 0;\n+    return klass->get.f.glyph_v_origin (this, user_data,\n+                                        glyph, x, y,\n+                                        klass->user_data.glyph_v_origin);\n+  }\n+\n+  hb_position_t get_glyph_h_kerning (hb_codepoint_t left_glyph,\n+                                     hb_codepoint_t right_glyph)\n+  {\n+    return klass->get.f.glyph_h_kerning (this, user_data,\n+                                         left_glyph, right_glyph,\n+                                         klass->user_data.glyph_h_kerning);\n+  }\n+\n+  hb_position_t get_glyph_v_kerning (hb_codepoint_t top_glyph,\n+                                     hb_codepoint_t bottom_glyph)\n+  {\n+    return klass->get.f.glyph_v_kerning (this, user_data,\n+                                         top_glyph, bottom_glyph,\n+                                         klass->user_data.glyph_v_kerning);\n+  }\n+\n+  hb_bool_t get_glyph_extents (hb_codepoint_t glyph,\n+                                      hb_glyph_extents_t *extents)\n+  {\n+    memset (extents, 0, sizeof (*extents));\n+    return klass->get.f.glyph_extents (this, user_data,\n+                                       glyph,\n+                                       extents,\n+                                       klass->user_data.glyph_extents);\n+  }\n+\n+  hb_bool_t get_glyph_contour_point (hb_codepoint_t glyph, unsigned int point_index,\n+                                            hb_position_t *x, hb_position_t *y)\n+  {\n+    *x = *y = 0;\n+    return klass->get.f.glyph_contour_point (this, user_data,\n+                                             glyph, point_index,\n+                                             x, y,\n+                                             klass->user_data.glyph_contour_point);\n+  }\n+\n+  hb_bool_t get_glyph_name (hb_codepoint_t glyph,\n+                            char *name, unsigned int size)\n+  {\n+    if (size) *name = '\\0';\n+    return klass->get.f.glyph_name (this, user_data,\n+                                    glyph,\n+                                    name, size,\n+                                    klass->user_data.glyph_name);\n+  }\n+\n+  hb_bool_t get_glyph_from_name (const char *name, int len, \/* -1 means nul-terminated *\/\n+                                 hb_codepoint_t *glyph)\n+  {\n+    *glyph = 0;\n+    if (len == -1) len = strlen (name);\n+    return klass->get.f.glyph_from_name (this, user_data,\n+                                         name, len,\n+                                         glyph,\n+                                         klass->user_data.glyph_from_name);\n+  }\n+\n+\n+  \/* A bit higher-level, and with fallback *\/\n+\n+  void get_h_extents_with_fallback (hb_font_extents_t *extents)\n+  {\n+    if (!get_font_h_extents (extents))\n+    {\n+      extents->ascender = y_scale * .8;\n+      extents->descender = extents->ascender - y_scale;\n+      extents->line_gap = 0;\n+    }\n+  }\n+  void get_v_extents_with_fallback (hb_font_extents_t *extents)\n+  {\n+    if (!get_font_v_extents (extents))\n+    {\n+      extents->ascender = x_scale \/ 2;\n+      extents->descender = extents->ascender - x_scale;\n+      extents->line_gap = 0;\n+    }\n+  }\n+\n+  void get_extents_for_direction (hb_direction_t direction,\n+                                  hb_font_extents_t *extents)\n+  {\n+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction)))\n+      get_h_extents_with_fallback (extents);\n+    else\n+      get_v_extents_with_fallback (extents);\n+  }\n+\n+  void get_glyph_advance_for_direction (hb_codepoint_t glyph,\n+                                        hb_direction_t direction,\n+                                        hb_position_t *x, hb_position_t *y)\n+  {\n+    *x = *y = 0;\n+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction)))\n+      *x = get_glyph_h_advance (glyph);\n+    else\n+      *y = get_glyph_v_advance (glyph);\n+  }\n+  void get_glyph_advances_for_direction (hb_direction_t direction,\n+                                         unsigned int count,\n+                                         const hb_codepoint_t *first_glyph,\n+                                         unsigned glyph_stride,\n+                                         hb_position_t *first_advance,\n+                                         unsigned advance_stride)\n+  {\n+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction)))\n+      get_glyph_h_advances (count, first_glyph, glyph_stride, first_advance, advance_stride);\n+    else\n+      get_glyph_v_advances (count, first_glyph, glyph_stride, first_advance, advance_stride);\n+  }\n+\n+  void guess_v_origin_minus_h_origin (hb_codepoint_t glyph,\n+                                      hb_position_t *x, hb_position_t *y)\n+  {\n+    *x = get_glyph_h_advance (glyph) \/ 2;\n+\n+    \/* TODO cache this somehow?! *\/\n+    hb_font_extents_t extents;\n+    get_h_extents_with_fallback (&extents);\n+    *y = extents.ascender;\n+  }\n+\n+  void get_glyph_h_origin_with_fallback (hb_codepoint_t glyph,\n+                                         hb_position_t *x, hb_position_t *y)\n+  {\n+    if (!get_glyph_h_origin (glyph, x, y) &&\n+         get_glyph_v_origin (glyph, x, y))\n+    {\n+      hb_position_t dx, dy;\n+      guess_v_origin_minus_h_origin (glyph, &dx, &dy);\n+      *x -= dx; *y -= dy;\n+    }\n+  }\n+  void get_glyph_v_origin_with_fallback (hb_codepoint_t glyph,\n+                                         hb_position_t *x, hb_position_t *y)\n+  {\n+    if (!get_glyph_v_origin (glyph, x, y) &&\n+         get_glyph_h_origin (glyph, x, y))\n+    {\n+      hb_position_t dx, dy;\n+      guess_v_origin_minus_h_origin (glyph, &dx, &dy);\n+      *x += dx; *y += dy;\n+    }\n+  }\n+\n+  void get_glyph_origin_for_direction (hb_codepoint_t glyph,\n+                                       hb_direction_t direction,\n+                                       hb_position_t *x, hb_position_t *y)\n+  {\n+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction)))\n+      get_glyph_h_origin_with_fallback (glyph, x, y);\n+    else\n+      get_glyph_v_origin_with_fallback (glyph, x, y);\n+  }\n+\n+  void add_glyph_h_origin (hb_codepoint_t glyph,\n+                           hb_position_t *x, hb_position_t *y)\n+  {\n+    hb_position_t origin_x, origin_y;\n+\n+    get_glyph_h_origin_with_fallback (glyph, &origin_x, &origin_y);\n+\n+    *x += origin_x;\n+    *y += origin_y;\n+  }\n+  void add_glyph_v_origin (hb_codepoint_t glyph,\n+                           hb_position_t *x, hb_position_t *y)\n+  {\n+    hb_position_t origin_x, origin_y;\n+\n+    get_glyph_v_origin_with_fallback (glyph, &origin_x, &origin_y);\n+\n+    *x += origin_x;\n+    *y += origin_y;\n+  }\n+  void add_glyph_origin_for_direction (hb_codepoint_t glyph,\n+                                       hb_direction_t direction,\n+                                       hb_position_t *x, hb_position_t *y)\n+  {\n+    hb_position_t origin_x, origin_y;\n+\n+    get_glyph_origin_for_direction (glyph, direction, &origin_x, &origin_y);\n+\n+    *x += origin_x;\n+    *y += origin_y;\n+  }\n+\n+  void subtract_glyph_h_origin (hb_codepoint_t glyph,\n+                                hb_position_t *x, hb_position_t *y)\n+  {\n+    hb_position_t origin_x, origin_y;\n+\n+    get_glyph_h_origin_with_fallback (glyph, &origin_x, &origin_y);\n+\n+    *x -= origin_x;\n+    *y -= origin_y;\n+  }\n+  void subtract_glyph_v_origin (hb_codepoint_t glyph,\n+                                hb_position_t *x, hb_position_t *y)\n+  {\n+    hb_position_t origin_x, origin_y;\n+\n+    get_glyph_v_origin_with_fallback (glyph, &origin_x, &origin_y);\n+\n+    *x -= origin_x;\n+    *y -= origin_y;\n+  }\n+  void subtract_glyph_origin_for_direction (hb_codepoint_t glyph,\n+                                            hb_direction_t direction,\n+                                            hb_position_t *x, hb_position_t *y)\n+  {\n+    hb_position_t origin_x, origin_y;\n+\n+    get_glyph_origin_for_direction (glyph, direction, &origin_x, &origin_y);\n+\n+    *x -= origin_x;\n+    *y -= origin_y;\n+  }\n+\n+  void get_glyph_kerning_for_direction (hb_codepoint_t first_glyph, hb_codepoint_t second_glyph,\n+                                        hb_direction_t direction,\n+                                        hb_position_t *x, hb_position_t *y)\n+  {\n+    if (likely (HB_DIRECTION_IS_HORIZONTAL (direction))) {\n+      *y = 0;\n+      *x = get_glyph_h_kerning (first_glyph, second_glyph);\n+    } else {\n+      *x = 0;\n+      *y = get_glyph_v_kerning (first_glyph, second_glyph);\n+    }\n+  }\n+\n+  hb_bool_t get_glyph_extents_for_origin (hb_codepoint_t glyph,\n+                                          hb_direction_t direction,\n+                                          hb_glyph_extents_t *extents)\n+  {\n+    hb_bool_t ret = get_glyph_extents (glyph, extents);\n+\n+    if (ret)\n+      subtract_glyph_origin_for_direction (glyph, direction, &extents->x_bearing, &extents->y_bearing);\n+\n+    return ret;\n+  }\n+\n+  hb_bool_t get_glyph_contour_point_for_origin (hb_codepoint_t glyph, unsigned int point_index,\n+                                                hb_direction_t direction,\n+                                                hb_position_t *x, hb_position_t *y)\n+  {\n+    hb_bool_t ret = get_glyph_contour_point (glyph, point_index, x, y);\n+\n+    if (ret)\n+      subtract_glyph_origin_for_direction (glyph, direction, x, y);\n+\n+    return ret;\n+  }\n+\n+  \/* Generates gidDDD if glyph has no name. *\/\n+  void\n+  glyph_to_string (hb_codepoint_t glyph,\n+                   char *s, unsigned int size)\n+  {\n+    if (get_glyph_name (glyph, s, size)) return;\n+\n+    if (size && snprintf (s, size, \"gid%u\", glyph) < 0)\n+      *s = '\\0';\n+  }\n+\n+  \/* Parses gidDDD and uniUUUU strings automatically. *\/\n+  hb_bool_t\n+  glyph_from_string (const char *s, int len, \/* -1 means nul-terminated *\/\n+                     hb_codepoint_t *glyph)\n+  {\n+    if (get_glyph_from_name (s, len, glyph)) return true;\n+\n+    if (len == -1) len = strlen (s);\n+\n+    \/* Straight glyph index. *\/\n+    if (hb_codepoint_parse (s, len, 10, glyph))\n+      return true;\n+\n+    if (len > 3)\n+    {\n+      \/* gidDDD syntax for glyph indices. *\/\n+      if (0 == strncmp (s, \"gid\", 3) &&\n+          hb_codepoint_parse (s + 3, len - 3, 10, glyph))\n+        return true;\n+\n+      \/* uniUUUU and other Unicode character indices. *\/\n+      hb_codepoint_t unichar;\n+      if (0 == strncmp (s, \"uni\", 3) &&\n+          hb_codepoint_parse (s + 3, len - 3, 16, &unichar) &&\n+          get_nominal_glyph (unichar, glyph))\n+        return true;\n+    }\n+\n+    return false;\n+  }\n+\n+  hb_position_t em_scale (int16_t v, int scale)\n+  {\n+    int upem = face->get_upem ();\n+    int64_t scaled = v * (int64_t) scale;\n+    scaled += scaled >= 0 ? upem\/2 : -upem\/2; \/* Round. *\/\n+    return (hb_position_t) (scaled \/ upem);\n+  }\n+  hb_position_t em_scalef (float v, int scale)\n+  { return (hb_position_t) round (v * scale \/ face->get_upem ()); }\n+  float em_fscale (int16_t v, int scale)\n+  { return (float) v * scale \/ face->get_upem (); }\n+};\n+DECLARE_NULL_INSTANCE (hb_font_t);\n+\n+\n+#endif \/* HB_FONT_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-font.hh","additions":617,"deletions":0,"binary":false,"changes":617,"status":"added"},{"patch":"@@ -0,0 +1,856 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2009  Keith Stribley\n+ * Copyright © 2015  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ft.h\"\n+\n+#include \"hb-font.hh\"\n+#include \"hb-machinery.hh\"\n+#include \"hb-cache.hh\"\n+\n+#include FT_ADVANCES_H\n+#include FT_MULTIPLE_MASTERS_H\n+#include FT_TRUETYPE_TABLES_H\n+\n+\n+\/**\n+ * SECTION:hb-ft\n+ * @title: hb-ft\n+ * @short_description: FreeType integration\n+ * @include: hb-ft.h\n+ *\n+ * Functions for using HarfBuzz with the FreeType library to provide face and\n+ * font data.\n+ **\/\n+\n+\n+\/* TODO:\n+ *\n+ * In general, this file does a fine job of what it's supposed to do.\n+ * There are, however, things that need more work:\n+ *\n+ *   - FreeType works in 26.6 mode.  Clients can decide to use that mode, and everything\n+ *     would work fine.  However, we also abuse this API for performing in font-space,\n+ *     but don't pass the correct flags to FreeType.  We just abuse the no-hinting mode\n+ *     for that, such that no rounding etc happens.  As such, we don't set ppem, and\n+ *     pass NO_HINTING as load_flags.  Would be much better to use NO_SCALE, and scale\n+ *     ourselves.\n+ *\n+ *   - We don't handle \/ allow for emboldening \/ obliqueing.\n+ *\n+ *   - In the future, we should add constructors to create fonts in font space?\n+ *\/\n+\n+\n+struct hb_ft_font_t\n+{\n+  mutable hb_mutex_t lock;\n+  FT_Face ft_face;\n+  int load_flags;\n+  bool symbol; \/* Whether selected cmap is symbol cmap. *\/\n+  bool unref; \/* Whether to destroy ft_face when done. *\/\n+\n+  mutable hb_atomic_int_t cached_x_scale;\n+  mutable hb_advance_cache_t advance_cache;\n+};\n+\n+static hb_ft_font_t *\n+_hb_ft_font_create (FT_Face ft_face, bool symbol, bool unref)\n+{\n+  hb_ft_font_t *ft_font = (hb_ft_font_t *) calloc (1, sizeof (hb_ft_font_t));\n+\n+  if (unlikely (!ft_font))\n+    return nullptr;\n+\n+  ft_font->lock.init ();\n+  ft_font->ft_face = ft_face;\n+  ft_font->symbol = symbol;\n+  ft_font->unref = unref;\n+\n+  ft_font->load_flags = FT_LOAD_DEFAULT | FT_LOAD_NO_HINTING;\n+\n+  ft_font->cached_x_scale.set (0);\n+  ft_font->advance_cache.init ();\n+\n+  return ft_font;\n+}\n+\n+static void\n+_hb_ft_face_destroy (void *data)\n+{\n+  FT_Done_Face ((FT_Face) data);\n+}\n+\n+static void\n+_hb_ft_font_destroy (void *data)\n+{\n+  hb_ft_font_t *ft_font = (hb_ft_font_t *) data;\n+\n+  ft_font->advance_cache.fini ();\n+\n+  if (ft_font->unref)\n+    _hb_ft_face_destroy (ft_font->ft_face);\n+\n+  ft_font->lock.fini ();\n+\n+  free (ft_font);\n+}\n+\n+\/**\n+ * hb_ft_font_set_load_flags:\n+ * @font:\n+ * @load_flags:\n+ *\n+ *\n+ *\n+ * Since: 1.0.5\n+ **\/\n+void\n+hb_ft_font_set_load_flags (hb_font_t *font, int load_flags)\n+{\n+  if (hb_object_is_immutable (font))\n+    return;\n+\n+  if (font->destroy != (hb_destroy_func_t) _hb_ft_font_destroy)\n+    return;\n+\n+  hb_ft_font_t *ft_font = (hb_ft_font_t *) font->user_data;\n+\n+  ft_font->load_flags = load_flags;\n+}\n+\n+\/**\n+ * hb_ft_font_get_load_flags:\n+ * @font:\n+ *\n+ *\n+ *\n+ * Return value:\n+ * Since: 1.0.5\n+ **\/\n+int\n+hb_ft_font_get_load_flags (hb_font_t *font)\n+{\n+  if (font->destroy != (hb_destroy_func_t) _hb_ft_font_destroy)\n+    return 0;\n+\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font->user_data;\n+\n+  return ft_font->load_flags;\n+}\n+\n+FT_Face\n+hb_ft_font_get_face (hb_font_t *font)\n+{\n+  if (font->destroy != (hb_destroy_func_t) _hb_ft_font_destroy)\n+    return nullptr;\n+\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font->user_data;\n+\n+  return ft_font->ft_face;\n+}\n+\n+\n+\n+static hb_bool_t\n+hb_ft_get_nominal_glyph (hb_font_t *font HB_UNUSED,\n+                         void *font_data,\n+                         hb_codepoint_t unicode,\n+                         hb_codepoint_t *glyph,\n+                         void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  unsigned int g = FT_Get_Char_Index (ft_font->ft_face, unicode);\n+\n+  if (unlikely (!g))\n+  {\n+    if (unlikely (ft_font->symbol) && unicode <= 0x00FFu)\n+    {\n+      \/* For symbol-encoded OpenType fonts, we duplicate the\n+       * U+F000..F0FF range at U+0000..U+00FF.  That's what\n+       * Windows seems to do, and that's hinted about at:\n+       * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/recom\n+       * under \"Non-Standard (Symbol) Fonts\". *\/\n+      g = FT_Get_Char_Index (ft_font->ft_face, 0xF000u + unicode);\n+      if (!g)\n+        return false;\n+    }\n+    else\n+      return false;\n+  }\n+\n+  *glyph = g;\n+  return true;\n+}\n+\n+static unsigned int\n+hb_ft_get_nominal_glyphs (hb_font_t *font HB_UNUSED,\n+                          void *font_data,\n+                          unsigned int count,\n+                          const hb_codepoint_t *first_unicode,\n+                          unsigned int unicode_stride,\n+                          hb_codepoint_t *first_glyph,\n+                          unsigned int glyph_stride,\n+                          void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  unsigned int done;\n+  for (done = 0;\n+       done < count && (*first_glyph = FT_Get_Char_Index (ft_font->ft_face, *first_unicode));\n+       done++)\n+  {\n+    first_unicode = &StructAtOffsetUnaligned<hb_codepoint_t> (first_unicode, unicode_stride);\n+    first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+  }\n+  \/* We don't need to do ft_font->symbol dance here, since HB calls the singular\n+   * nominal_glyph() for what we don't handle here. *\/\n+  return done;\n+}\n+\n+\n+static hb_bool_t\n+hb_ft_get_variation_glyph (hb_font_t *font HB_UNUSED,\n+                           void *font_data,\n+                           hb_codepoint_t unicode,\n+                           hb_codepoint_t variation_selector,\n+                           hb_codepoint_t *glyph,\n+                           void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  unsigned int g = FT_Face_GetCharVariantIndex (ft_font->ft_face, unicode, variation_selector);\n+\n+  if (unlikely (!g))\n+    return false;\n+\n+  *glyph = g;\n+  return true;\n+}\n+\n+static void\n+hb_ft_get_glyph_h_advances (hb_font_t* font, void* font_data,\n+                            unsigned count,\n+                            const hb_codepoint_t *first_glyph,\n+                            unsigned glyph_stride,\n+                            hb_position_t *first_advance,\n+                            unsigned advance_stride,\n+                            void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+  int load_flags = ft_font->load_flags;\n+  int mult = font->x_scale < 0 ? -1 : +1;\n+\n+  if (font->x_scale != ft_font->cached_x_scale.get ())\n+  {\n+    ft_font->advance_cache.clear ();\n+    ft_font->cached_x_scale.set (font->x_scale);\n+  }\n+\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    FT_Fixed v = 0;\n+    hb_codepoint_t glyph = *first_glyph;\n+\n+    unsigned int cv;\n+    if (ft_font->advance_cache.get (glyph, &cv))\n+      v = cv;\n+    else\n+    {\n+      FT_Get_Advance (ft_face, glyph, load_flags, &v);\n+      ft_font->advance_cache.set (glyph, v);\n+    }\n+\n+    *first_advance = (v * mult + (1<<9)) >> 10;\n+    first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+    first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+  }\n+}\n+\n+static hb_position_t\n+hb_ft_get_glyph_v_advance (hb_font_t *font,\n+                           void *font_data,\n+                           hb_codepoint_t glyph,\n+                           void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Fixed v;\n+\n+  if (unlikely (FT_Get_Advance (ft_font->ft_face, glyph, ft_font->load_flags | FT_LOAD_VERTICAL_LAYOUT, &v)))\n+    return 0;\n+\n+  if (font->y_scale < 0)\n+    v = -v;\n+\n+  \/* Note: FreeType's vertical metrics grows downward while other FreeType coordinates\n+   * have a Y growing upward.  Hence the extra negation. *\/\n+  return (-v + (1<<9)) >> 10;\n+}\n+\n+static hb_bool_t\n+hb_ft_get_glyph_v_origin (hb_font_t *font,\n+                          void *font_data,\n+                          hb_codepoint_t glyph,\n+                          hb_position_t *x,\n+                          hb_position_t *y,\n+                          void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font->load_flags)))\n+    return false;\n+\n+  \/* Note: FreeType's vertical metrics grows downward while other FreeType coordinates\n+   * have a Y growing upward.  Hence the extra negation. *\/\n+  *x = ft_face->glyph->metrics.horiBearingX -   ft_face->glyph->metrics.vertBearingX;\n+  *y = ft_face->glyph->metrics.horiBearingY - (-ft_face->glyph->metrics.vertBearingY);\n+\n+  if (font->x_scale < 0)\n+    *x = -*x;\n+  if (font->y_scale < 0)\n+    *y = -*y;\n+\n+  return true;\n+}\n+\n+static hb_bool_t\n+hb_ft_get_glyph_extents (hb_font_t *font,\n+                         void *font_data,\n+                         hb_codepoint_t glyph,\n+                         hb_glyph_extents_t *extents,\n+                         void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font->load_flags)))\n+    return false;\n+\n+  extents->x_bearing = ft_face->glyph->metrics.horiBearingX;\n+  extents->y_bearing = ft_face->glyph->metrics.horiBearingY;\n+  extents->width = ft_face->glyph->metrics.width;\n+  extents->height = -ft_face->glyph->metrics.height;\n+  if (font->x_scale < 0)\n+  {\n+    extents->x_bearing = -extents->x_bearing;\n+    extents->width = -extents->width;\n+  }\n+  if (font->y_scale < 0)\n+  {\n+    extents->y_bearing = -extents->y_bearing;\n+    extents->height = -extents->height;\n+  }\n+  return true;\n+}\n+\n+static hb_bool_t\n+hb_ft_get_glyph_contour_point (hb_font_t *font HB_UNUSED,\n+                               void *font_data,\n+                               hb_codepoint_t glyph,\n+                               unsigned int point_index,\n+                               hb_position_t *x,\n+                               hb_position_t *y,\n+                               void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  if (unlikely (FT_Load_Glyph (ft_face, glyph, ft_font->load_flags)))\n+      return false;\n+\n+  if (unlikely (ft_face->glyph->format != FT_GLYPH_FORMAT_OUTLINE))\n+      return false;\n+\n+  if (unlikely (point_index >= (unsigned int) ft_face->glyph->outline.n_points))\n+      return false;\n+\n+  *x = ft_face->glyph->outline.points[point_index].x;\n+  *y = ft_face->glyph->outline.points[point_index].y;\n+\n+  return true;\n+}\n+\n+static hb_bool_t\n+hb_ft_get_glyph_name (hb_font_t *font HB_UNUSED,\n+                      void *font_data,\n+                      hb_codepoint_t glyph,\n+                      char *name, unsigned int size,\n+                      void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  hb_bool_t ret = !FT_Get_Glyph_Name (ft_face, glyph, name, size);\n+  if (ret && (size && !*name))\n+    ret = false;\n+\n+  return ret;\n+}\n+\n+static hb_bool_t\n+hb_ft_get_glyph_from_name (hb_font_t *font HB_UNUSED,\n+                           void *font_data,\n+                           const char *name, int len, \/* -1 means nul-terminated *\/\n+                           hb_codepoint_t *glyph,\n+                           void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  if (len < 0)\n+    *glyph = FT_Get_Name_Index (ft_face, (FT_String *) name);\n+  else {\n+    \/* Make a nul-terminated version. *\/\n+    char buf[128];\n+    len = MIN (len, (int) sizeof (buf) - 1);\n+    strncpy (buf, name, len);\n+    buf[len] = '\\0';\n+    *glyph = FT_Get_Name_Index (ft_face, buf);\n+  }\n+\n+  if (*glyph == 0)\n+  {\n+    \/* Check whether the given name was actually the name of glyph 0. *\/\n+    char buf[128];\n+    if (!FT_Get_Glyph_Name(ft_face, 0, buf, sizeof (buf)) &&\n+        len < 0 ? !strcmp (buf, name) : !strncmp (buf, name, len))\n+      return true;\n+  }\n+\n+  return *glyph != 0;\n+}\n+\n+static hb_bool_t\n+hb_ft_get_font_h_extents (hb_font_t *font HB_UNUSED,\n+                          void *font_data,\n+                          hb_font_extents_t *metrics,\n+                          void *user_data HB_UNUSED)\n+{\n+  const hb_ft_font_t *ft_font = (const hb_ft_font_t *) font_data;\n+  hb_lock_t lock (ft_font->lock);\n+  FT_Face ft_face = ft_font->ft_face;\n+  metrics->ascender = FT_MulFix(ft_face->ascender, ft_face->size->metrics.y_scale);\n+  metrics->descender = FT_MulFix(ft_face->descender, ft_face->size->metrics.y_scale);\n+  metrics->line_gap = FT_MulFix( ft_face->height, ft_face->size->metrics.y_scale ) - (metrics->ascender - metrics->descender);\n+  if (font->y_scale < 0)\n+  {\n+    metrics->ascender = -metrics->ascender;\n+    metrics->descender = -metrics->descender;\n+    metrics->line_gap = -metrics->line_gap;\n+  }\n+  return true;\n+}\n+\n+#if HB_USE_ATEXIT\n+static void free_static_ft_funcs ();\n+#endif\n+\n+static struct hb_ft_font_funcs_lazy_loader_t : hb_font_funcs_lazy_loader_t<hb_ft_font_funcs_lazy_loader_t>\n+{\n+  static hb_font_funcs_t *create ()\n+  {\n+    hb_font_funcs_t *funcs = hb_font_funcs_create ();\n+\n+    hb_font_funcs_set_font_h_extents_func (funcs, hb_ft_get_font_h_extents, nullptr, nullptr);\n+    \/\/hb_font_funcs_set_font_v_extents_func (funcs, hb_ft_get_font_v_extents, nullptr, nullptr);\n+    hb_font_funcs_set_nominal_glyph_func (funcs, hb_ft_get_nominal_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_nominal_glyphs_func (funcs, hb_ft_get_nominal_glyphs, nullptr, nullptr);\n+    hb_font_funcs_set_variation_glyph_func (funcs, hb_ft_get_variation_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_h_advances_func (funcs, hb_ft_get_glyph_h_advances, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_v_advance_func (funcs, hb_ft_get_glyph_v_advance, nullptr, nullptr);\n+    \/\/hb_font_funcs_set_glyph_h_origin_func (funcs, hb_ft_get_glyph_h_origin, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_v_origin_func (funcs, hb_ft_get_glyph_v_origin, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_extents_func (funcs, hb_ft_get_glyph_extents, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_contour_point_func (funcs, hb_ft_get_glyph_contour_point, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_name_func (funcs, hb_ft_get_glyph_name, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_from_name_func (funcs, hb_ft_get_glyph_from_name, nullptr, nullptr);\n+\n+    hb_font_funcs_make_immutable (funcs);\n+\n+#if HB_USE_ATEXIT\n+    atexit (free_static_ft_funcs);\n+#endif\n+\n+    return funcs;\n+  }\n+} static_ft_funcs;\n+\n+#if HB_USE_ATEXIT\n+static\n+void free_static_ft_funcs ()\n+{\n+  static_ft_funcs.free_instance ();\n+}\n+#endif\n+\n+static hb_font_funcs_t *\n+_hb_ft_get_font_funcs ()\n+{\n+  return static_ft_funcs.get_unconst ();\n+}\n+\n+static void\n+_hb_ft_font_set_funcs (hb_font_t *font, FT_Face ft_face, bool unref)\n+{\n+  bool symbol = ft_face->charmap && ft_face->charmap->encoding == FT_ENCODING_MS_SYMBOL;\n+\n+  hb_font_set_funcs (font,\n+                     _hb_ft_get_font_funcs (),\n+                     _hb_ft_font_create (ft_face, symbol, unref),\n+                     _hb_ft_font_destroy);\n+}\n+\n+\n+static hb_blob_t *\n+reference_table  (hb_face_t *face HB_UNUSED, hb_tag_t tag, void *user_data)\n+{\n+  FT_Face ft_face = (FT_Face) user_data;\n+  FT_Byte *buffer;\n+  FT_ULong  length = 0;\n+  FT_Error error;\n+\n+  \/* Note: FreeType like HarfBuzz uses the NONE tag for fetching the entire blob *\/\n+\n+  error = FT_Load_Sfnt_Table (ft_face, tag, 0, nullptr, &length);\n+  if (error)\n+    return nullptr;\n+\n+  buffer = (FT_Byte *) malloc (length);\n+  if (!buffer)\n+    return nullptr;\n+\n+  error = FT_Load_Sfnt_Table (ft_face, tag, 0, buffer, &length);\n+  if (error)\n+  {\n+    free (buffer);\n+    return nullptr;\n+  }\n+\n+  return hb_blob_create ((const char *) buffer, length,\n+                         HB_MEMORY_MODE_WRITABLE,\n+                         buffer, free);\n+}\n+\n+\/**\n+ * hb_ft_face_create:\n+ * @ft_face: (destroy destroy) (scope notified):\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ * Since: 0.9.2\n+ **\/\n+hb_face_t *\n+hb_ft_face_create (FT_Face           ft_face,\n+                   hb_destroy_func_t destroy)\n+{\n+  hb_face_t *face;\n+\n+  if (!ft_face->stream->read) {\n+    hb_blob_t *blob;\n+\n+    blob = hb_blob_create ((const char *) ft_face->stream->base,\n+                           (unsigned int) ft_face->stream->size,\n+                           HB_MEMORY_MODE_READONLY,\n+                           ft_face, destroy);\n+    face = hb_face_create (blob, ft_face->face_index);\n+    hb_blob_destroy (blob);\n+  } else {\n+    face = hb_face_create_for_tables (reference_table, ft_face, destroy);\n+  }\n+\n+  hb_face_set_index (face, ft_face->face_index);\n+  hb_face_set_upem (face, ft_face->units_per_EM);\n+\n+  return face;\n+}\n+\n+\/**\n+ * hb_ft_face_create_referenced:\n+ * @ft_face:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ * Since: 0.9.38\n+ **\/\n+hb_face_t *\n+hb_ft_face_create_referenced (FT_Face ft_face)\n+{\n+  FT_Reference_Face (ft_face);\n+  return hb_ft_face_create (ft_face, _hb_ft_face_destroy);\n+}\n+\n+static void\n+hb_ft_face_finalize (FT_Face ft_face)\n+{\n+  hb_face_destroy ((hb_face_t *) ft_face->generic.data);\n+}\n+\n+\/**\n+ * hb_ft_face_create_cached:\n+ * @ft_face:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ * Since: 0.9.2\n+ **\/\n+hb_face_t *\n+hb_ft_face_create_cached (FT_Face ft_face)\n+{\n+  if (unlikely (!ft_face->generic.data || ft_face->generic.finalizer != (FT_Generic_Finalizer) hb_ft_face_finalize))\n+  {\n+    if (ft_face->generic.finalizer)\n+      ft_face->generic.finalizer (ft_face);\n+\n+    ft_face->generic.data = hb_ft_face_create (ft_face, nullptr);\n+    ft_face->generic.finalizer = (FT_Generic_Finalizer) hb_ft_face_finalize;\n+  }\n+\n+  return hb_face_reference ((hb_face_t *) ft_face->generic.data);\n+}\n+\n+\n+\/**\n+ * hb_ft_font_create:\n+ * @ft_face: (destroy destroy) (scope notified):\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ * Since: 0.9.2\n+ **\/\n+hb_font_t *\n+hb_ft_font_create (FT_Face           ft_face,\n+                   hb_destroy_func_t destroy)\n+{\n+  hb_font_t *font;\n+  hb_face_t *face;\n+\n+  face = hb_ft_face_create (ft_face, destroy);\n+  font = hb_font_create (face);\n+  hb_face_destroy (face);\n+  _hb_ft_font_set_funcs (font, ft_face, false);\n+  hb_ft_font_changed (font);\n+  return font;\n+}\n+\n+void\n+hb_ft_font_changed (hb_font_t *font)\n+{\n+  if (font->destroy != (hb_destroy_func_t) _hb_ft_font_destroy)\n+    return;\n+\n+  hb_ft_font_t *ft_font = (hb_ft_font_t *) font->user_data;\n+  FT_Face ft_face = ft_font->ft_face;\n+\n+  hb_font_set_scale (font,\n+                     (int) (((uint64_t) ft_face->size->metrics.x_scale * (uint64_t) ft_face->units_per_EM + (1u<<15)) >> 16),\n+                     (int) (((uint64_t) ft_face->size->metrics.y_scale * (uint64_t) ft_face->units_per_EM + (1u<<15)) >> 16));\n+#if 0 \/* hb-ft works in no-hinting model *\/\n+  hb_font_set_ppem (font,\n+                    ft_face->size->metrics.x_ppem,\n+                    ft_face->size->metrics.y_ppem);\n+#endif\n+\n+#ifdef HAVE_FT_GET_VAR_BLEND_COORDINATES\n+  FT_MM_Var *mm_var = nullptr;\n+  if (!FT_Get_MM_Var (ft_face, &mm_var))\n+  {\n+    FT_Fixed *ft_coords = (FT_Fixed *) calloc (mm_var->num_axis, sizeof (FT_Fixed));\n+    int *coords = (int *) calloc (mm_var->num_axis, sizeof (int));\n+    if (coords && ft_coords)\n+    {\n+      if (!FT_Get_Var_Blend_Coordinates (ft_face, mm_var->num_axis, ft_coords))\n+      {\n+        bool nonzero = false;\n+\n+        for (unsigned int i = 0; i < mm_var->num_axis; ++i)\n+         {\n+          coords[i] = ft_coords[i] >>= 2;\n+          nonzero = nonzero || coords[i];\n+         }\n+\n+        if (nonzero)\n+          hb_font_set_var_coords_normalized (font, coords, mm_var->num_axis);\n+        else\n+          hb_font_set_var_coords_normalized (font, nullptr, 0);\n+      }\n+    }\n+    free (coords);\n+    free (ft_coords);\n+#ifdef HAVE_FT_DONE_MM_VAR\n+    FT_Done_MM_Var (ft_face->glyph->library, mm_var);\n+#else\n+    free (mm_var);\n+#endif\n+  }\n+#endif\n+}\n+\n+\/**\n+ * hb_ft_font_create_referenced:\n+ * @ft_face:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ * Since: 0.9.38\n+ **\/\n+hb_font_t *\n+hb_ft_font_create_referenced (FT_Face ft_face)\n+{\n+  FT_Reference_Face (ft_face);\n+  return hb_ft_font_create (ft_face, _hb_ft_face_destroy);\n+}\n+\n+#if HB_USE_ATEXIT\n+static void free_static_ft_library ();\n+#endif\n+\n+static struct hb_ft_library_lazy_loader_t : hb_lazy_loader_t<hb_remove_pointer (FT_Library),\n+                                                             hb_ft_library_lazy_loader_t>\n+{\n+  static FT_Library create ()\n+  {\n+    FT_Library l;\n+    if (FT_Init_FreeType (&l))\n+      return nullptr;\n+\n+#if HB_USE_ATEXIT\n+    atexit (free_static_ft_library);\n+#endif\n+\n+    return l;\n+  }\n+  static void destroy (FT_Library l)\n+  {\n+    FT_Done_FreeType (l);\n+  }\n+  static FT_Library get_null ()\n+  {\n+    return nullptr;\n+  }\n+} static_ft_library;\n+\n+#if HB_USE_ATEXIT\n+static\n+void free_static_ft_library ()\n+{\n+  static_ft_library.free_instance ();\n+}\n+#endif\n+\n+static FT_Library\n+get_ft_library ()\n+{\n+  return static_ft_library.get_unconst ();\n+}\n+\n+static void\n+_release_blob (FT_Face ft_face)\n+{\n+  hb_blob_destroy ((hb_blob_t *) ft_face->generic.data);\n+}\n+\n+void\n+hb_ft_font_set_funcs (hb_font_t *font)\n+{\n+  hb_blob_t *blob = hb_face_reference_blob (font->face);\n+  unsigned int blob_length;\n+  const char *blob_data = hb_blob_get_data (blob, &blob_length);\n+  if (unlikely (!blob_length))\n+    DEBUG_MSG (FT, font, \"Font face has empty blob\");\n+\n+  FT_Face ft_face = nullptr;\n+  FT_Error err = FT_New_Memory_Face (get_ft_library (),\n+                                     (const FT_Byte *) blob_data,\n+                                     blob_length,\n+                                     hb_face_get_index (font->face),\n+                                     &ft_face);\n+\n+  if (unlikely (err)) {\n+    hb_blob_destroy (blob);\n+    DEBUG_MSG (FT, font, \"Font face FT_New_Memory_Face() failed\");\n+    return;\n+  }\n+\n+  if (FT_Select_Charmap (ft_face, FT_ENCODING_UNICODE))\n+    FT_Select_Charmap (ft_face, FT_ENCODING_MS_SYMBOL);\n+\n+  FT_Set_Char_Size (ft_face,\n+                    abs (font->x_scale), abs (font->y_scale),\n+                    0, 0);\n+#if 0\n+                    font->x_ppem * 72 * 64 \/ font->x_scale,\n+                    font->y_ppem * 72 * 64 \/ font->y_scale);\n+#endif\n+  if (font->x_scale < 0 || font->y_scale < 0)\n+  {\n+    FT_Matrix matrix = { font->x_scale < 0 ? -1 : +1, 0,\n+                          0, font->y_scale < 0 ? -1 : +1};\n+    FT_Set_Transform (ft_face, &matrix, nullptr);\n+  }\n+\n+#ifdef HAVE_FT_SET_VAR_BLEND_COORDINATES\n+  unsigned int num_coords;\n+  const int *coords = hb_font_get_var_coords_normalized (font, &num_coords);\n+  if (num_coords)\n+  {\n+    FT_Fixed *ft_coords = (FT_Fixed *) calloc (num_coords, sizeof (FT_Fixed));\n+    if (ft_coords)\n+    {\n+      for (unsigned int i = 0; i < num_coords; i++)\n+        ft_coords[i] = coords[i] << 2;\n+      FT_Set_Var_Blend_Coordinates (ft_face, num_coords, ft_coords);\n+      free (ft_coords);\n+    }\n+  }\n+#endif\n+\n+  ft_face->generic.data = blob;\n+  ft_face->generic.finalizer = (FT_Generic_Finalizer) _release_blob;\n+\n+  _hb_ft_font_set_funcs (font, ft_face, true);\n+  hb_ft_font_set_load_flags (font, FT_LOAD_DEFAULT | FT_LOAD_NO_HINTING);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ft.cc","additions":856,"deletions":0,"binary":false,"changes":856,"status":"added"},{"patch":"@@ -0,0 +1,132 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2015  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_FT_H\n+#define HB_FT_H\n+\n+#include \"hb.h\"\n+\n+#include <ft2build.h>\n+#include FT_FREETYPE_H\n+\n+HB_BEGIN_DECLS\n+\n+\/*\n+ * Note: FreeType is not thread-safe.\n+ * Hence, these functions are not either.\n+ *\/\n+\n+\/*\n+ * hb-face from ft-face.\n+ *\/\n+\n+\/* This one creates a new hb-face for given ft-face.\n+ * When the returned hb-face is destroyed, the destroy\n+ * callback is called (if not NULL), with the ft-face passed\n+ * to it.\n+ *\n+ * The client is responsible to make sure that ft-face is\n+ * destroyed after hb-face is destroyed.\n+ *\n+ * Most often you don't want this function.  You should use either\n+ * hb_ft_face_create_cached(), or hb_ft_face_create_referenced().\n+ * In particular, if you are going to pass NULL as destroy, you\n+ * probably should use (the more recent) hb_ft_face_create_referenced()\n+ * instead.\n+ *\/\n+HB_EXTERN hb_face_t *\n+hb_ft_face_create (FT_Face           ft_face,\n+                   hb_destroy_func_t destroy);\n+\n+\/* This version is like hb_ft_face_create(), except that it caches\n+ * the hb-face using the generic pointer of the ft-face.  This means\n+ * that subsequent calls to this function with the same ft-face will\n+ * return the same hb-face (correctly referenced).\n+ *\n+ * Client is still responsible for making sure that ft-face is destroyed\n+ * after hb-face is.\n+ *\/\n+HB_EXTERN hb_face_t *\n+hb_ft_face_create_cached (FT_Face ft_face);\n+\n+\/* This version is like hb_ft_face_create(), except that it calls\n+ * FT_Reference_Face() on ft-face, as such keeping ft-face alive\n+ * as long as the hb-face is.\n+ *\n+ * This is the most convenient version to use.  Use it unless you have\n+ * very good reasons not to.\n+ *\/\n+HB_EXTERN hb_face_t *\n+hb_ft_face_create_referenced (FT_Face ft_face);\n+\n+\n+\/*\n+ * hb-font from ft-face.\n+ *\/\n+\n+\/*\n+ * Note:\n+ *\n+ * Set face size on ft-face before creating hb-font from it.\n+ * Otherwise hb-ft would NOT pick up the font size correctly.\n+ *\/\n+\n+\/* See notes on hb_ft_face_create().  Same issues re lifecycle-management\n+ * apply here.  Use hb_ft_font_create_referenced() if you can. *\/\n+HB_EXTERN hb_font_t *\n+hb_ft_font_create (FT_Face           ft_face,\n+                   hb_destroy_func_t destroy);\n+\n+\/* See notes on hb_ft_face_create_referenced() re lifecycle-management\n+ * issues. *\/\n+HB_EXTERN hb_font_t *\n+hb_ft_font_create_referenced (FT_Face ft_face);\n+\n+HB_EXTERN FT_Face\n+hb_ft_font_get_face (hb_font_t *font);\n+\n+HB_EXTERN void\n+hb_ft_font_set_load_flags (hb_font_t *font, int load_flags);\n+\n+HB_EXTERN int\n+hb_ft_font_get_load_flags (hb_font_t *font);\n+\n+\/* Call when size or variations settings on underlying FT_Face change. *\/\n+HB_EXTERN void\n+hb_ft_font_changed (hb_font_t *font);\n+\n+\/* Makes an hb_font_t use FreeType internally to implement font functions.\n+ * Note: this internally creates an FT_Face.  Use it when you create your\n+ * hb_face_t using hb_face_create(). *\/\n+HB_EXTERN void\n+hb_ft_font_set_funcs (hb_font_t *font);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_FT_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ft.h","additions":132,"deletions":0,"binary":false,"changes":132,"status":"added"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_ITER_HH\n+#define HB_ITER_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-null.hh\"\n+\n+\n+\/* Unified iterator object.\n+ *\n+ * The goal of this template is to make the same iterator interface\n+ * available to all types, and make it very easy and compact to use.\n+ * hb_iter_tator objects are small, light-weight, objects that can be\n+ * copied by value.  If the collection \/ object being iterated on\n+ * is writable, then the iterator returns lvalues, otherwise it\n+ * returns rvalues.\n+ *\/\n+\n+\/* Base class for all iterators. *\/\n+template <typename Iter, typename Item = typename Iter::__item_type__>\n+struct hb_iter_t\n+{\n+  typedef Iter iter_t;\n+  typedef iter_t const_iter_t;\n+  typedef Item item_t;\n+  static constexpr unsigned item_size = hb_static_size (Item);\n+\n+  private:\n+  \/* https:\/\/en.wikipedia.org\/wiki\/Curiously_recurring_template_pattern *\/\n+  const iter_t* thiz () const { return static_cast<const iter_t *> (this); }\n+        iter_t* thiz ()       { return static_cast<      iter_t *> (this); }\n+  public:\n+\n+  \/* Operators. *\/\n+  operator iter_t () { return iter(); }\n+  explicit_operator bool () const { return more (); }\n+  item_t& operator * () const { return item (); }\n+  item_t& operator [] (signed i) const { return item_at ((unsigned) i); }\n+  iter_t& operator += (unsigned count) { forward (count); return *thiz(); }\n+  iter_t& operator ++ () { next (); return *thiz(); }\n+  iter_t& operator -= (unsigned count) { rewind (count); return *thiz(); }\n+  iter_t& operator -- () { prev (); return *thiz(); }\n+  iter_t operator + (unsigned count) { iter_t c (*thiz()); c += count; return c; }\n+  iter_t operator ++ (int) { iter_t c (*thiz()); ++*thiz(); return c; }\n+  iter_t operator - (unsigned count) { iter_t c (*thiz()); c -= count; return c; }\n+  iter_t operator -- (int) { iter_t c (*thiz()); --*thiz(); return c; }\n+\n+  \/* Methods. *\/\n+  iter_t iter () const { return *thiz(); }\n+  const_iter_t const_iter () const { return iter (); }\n+  item_t& item () const { return thiz()->__item__ (); }\n+  item_t& item_at (unsigned i) const { return thiz()->__item_at__ (i); }\n+  bool more () const { return thiz()->__more__ (); }\n+  unsigned len () const { return thiz()->__len__ (); }\n+  void next () { thiz()->__next__ (); }\n+  void forward (unsigned n) { thiz()->__forward__ (n); }\n+  void prev () { thiz()->__prev__ (); }\n+  void rewind (unsigned n) { thiz()->__rewind__ (n); }\n+  bool random_access () const { return thiz()->__random_access__ (); }\n+\n+  protected:\n+  hb_iter_t () {}\n+  hb_iter_t (const hb_iter_t &o HB_UNUSED) {}\n+  void operator = (const hb_iter_t &o HB_UNUSED) {}\n+};\n+\n+\/* Base class for sorted iterators.  Does not enforce anything.\n+ * Just for class taxonomy and requirements. *\/\n+template <typename Iter, typename Item = typename Iter::__item_type__>\n+struct hb_sorted_iter_t : hb_iter_t<Iter, Item>\n+{\n+  protected:\n+  hb_sorted_iter_t () {}\n+  hb_sorted_iter_t (const hb_sorted_iter_t &o) : hb_iter_t<Iter, Item> (o) {}\n+  void operator = (const hb_sorted_iter_t &o HB_UNUSED) {}\n+};\n+\n+\/* Mixin to fill in what the subclass doesn't provide. *\/\n+template <typename iter_t, typename item_t = typename iter_t::__item_type__>\n+struct hb_iter_mixin_t\n+{\n+  private:\n+  \/* https:\/\/en.wikipedia.org\/wiki\/Curiously_recurring_template_pattern *\/\n+  const iter_t* thiz () const { return static_cast<const iter_t *> (this); }\n+        iter_t* thiz ()       { return static_cast<      iter_t *> (this); }\n+  public:\n+\n+  \/* Access: Implement __item__(), or __item_at__() if random-access. *\/\n+  item_t& __item__ () const { return thiz()->item_at (0); }\n+  item_t& __item_at__ (unsigned i) const { return *(thiz() + i); }\n+\n+  \/* Termination: Implement __more__(), or __len__() if random-access. *\/\n+  bool __more__ () const { return thiz()->__len__ (); }\n+  unsigned __len__ () const\n+  { iter_t c (*thiz()); unsigned l = 0; while (c) { c++; l++; }; return l; }\n+\n+  \/* Advancing: Implement __next__(), or __forward__() if random-access. *\/\n+  void __next__ () { thiz()->forward (1); }\n+  void __forward__ (unsigned n) { while (n--) thiz()->next (); }\n+\n+  \/* Rewinding: Implement __prev__() or __rewind__() if bidirectional. *\/\n+  void __prev__ () { thiz()->rewind (1); }\n+  void __rewind__ (unsigned n) { while (n--) thiz()->prev (); }\n+\n+  \/* Random access: Return true if item_at(), len(), forward() are fast. *\/\n+  bool __random_access__ () const { return false; }\n+};\n+\n+\n+\/* Functions operating on iterators or iteratables. *\/\n+\n+template <typename C, typename V> inline void\n+hb_fill (const C& c, const V &v)\n+{\n+  for (typename C::iter_t i (c); i; i++)\n+    hb_assign (*i, v);\n+}\n+\n+template <typename S, typename D> inline bool\n+hb_copy (hb_iter_t<D> &id, hb_iter_t<S> &is)\n+{\n+  for (; id && is; ++id, ++is)\n+    *id = *is;\n+  return !is;\n+}\n+\n+\n+#endif \/* HB_ITER_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-iter.hh","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_KERN_HH\n+#define HB_KERN_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-aat-layout-common.hh\"\n+#include \"hb-ot-layout-gpos-table.hh\"\n+\n+\n+namespace OT {\n+\n+\n+template <typename Driver>\n+struct hb_kern_machine_t\n+{\n+  hb_kern_machine_t (const Driver &driver_,\n+                     bool crossStream_ = false) :\n+                       driver (driver_),\n+                       crossStream (crossStream_) {}\n+\n+  HB_NO_SANITIZE_SIGNED_INTEGER_OVERFLOW\n+  void kern (hb_font_t   *font,\n+             hb_buffer_t *buffer,\n+             hb_mask_t    kern_mask,\n+             bool         scale = true) const\n+  {\n+    OT::hb_ot_apply_context_t c (1, font, buffer);\n+    c.set_lookup_mask (kern_mask);\n+    c.set_lookup_props (OT::LookupFlag::IgnoreMarks);\n+    OT::hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c.iter_input;\n+    skippy_iter.init (&c);\n+\n+    bool horizontal = HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction);\n+    unsigned int count = buffer->len;\n+    hb_glyph_info_t *info = buffer->info;\n+    hb_glyph_position_t *pos = buffer->pos;\n+    for (unsigned int idx = 0; idx < count;)\n+    {\n+      if (!(info[idx].mask & kern_mask))\n+      {\n+        idx++;\n+        continue;\n+      }\n+\n+      skippy_iter.reset (idx, 1);\n+      if (!skippy_iter.next ())\n+      {\n+        idx++;\n+        continue;\n+      }\n+\n+      unsigned int i = idx;\n+      unsigned int j = skippy_iter.idx;\n+\n+      hb_position_t kern = driver.get_kerning (info[i].codepoint,\n+                                               info[j].codepoint);\n+\n+\n+      if (likely (!kern))\n+        goto skip;\n+\n+      if (horizontal)\n+      {\n+        if (scale)\n+          kern = font->em_scale_x (kern);\n+        if (crossStream)\n+        {\n+          pos[j].y_offset = kern;\n+          buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+        }\n+        else\n+        {\n+          hb_position_t kern1 = kern >> 1;\n+          hb_position_t kern2 = kern - kern1;\n+          pos[i].x_advance += kern1;\n+          pos[j].x_advance += kern2;\n+          pos[j].x_offset += kern2;\n+        }\n+      }\n+      else\n+      {\n+        if (scale)\n+          kern = font->em_scale_y (kern);\n+        if (crossStream)\n+        {\n+          pos[j].x_offset = kern;\n+          buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+        }\n+        else\n+        {\n+          hb_position_t kern1 = kern >> 1;\n+          hb_position_t kern2 = kern - kern1;\n+          pos[i].y_advance += kern1;\n+          pos[j].y_advance += kern2;\n+          pos[j].y_offset += kern2;\n+        }\n+      }\n+\n+      buffer->unsafe_to_break (i, j + 1);\n+\n+    skip:\n+      idx = skippy_iter.idx;\n+    }\n+  }\n+\n+  const Driver &driver;\n+  bool crossStream;\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_KERN_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-kern.hh","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,932 @@\n+\/*\n+ * Copyright © 2007,2008,2009,2010  Red Hat, Inc.\n+ * Copyright © 2012,2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_MACHINERY_HH\n+#define HB_MACHINERY_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-blob.hh\"\n+\n+#include \"hb-array.hh\"\n+#include \"hb-vector.hh\"\n+\n+\n+\/*\n+ * Casts\n+ *\/\n+\n+\/* Cast to struct T, reference to reference *\/\n+template<typename Type, typename TObject>\n+static inline const Type& CastR(const TObject &X)\n+{ return reinterpret_cast<const Type&> (X); }\n+template<typename Type, typename TObject>\n+static inline Type& CastR(TObject &X)\n+{ return reinterpret_cast<Type&> (X); }\n+\n+\/* Cast to struct T, pointer to pointer *\/\n+template<typename Type, typename TObject>\n+static inline const Type* CastP(const TObject *X)\n+{ return reinterpret_cast<const Type*> (X); }\n+template<typename Type, typename TObject>\n+static inline Type* CastP(TObject *X)\n+{ return reinterpret_cast<Type*> (X); }\n+\n+\/* StructAtOffset<T>(P,Ofs) returns the struct T& that is placed at memory\n+ * location pointed to by P plus Ofs bytes. *\/\n+template<typename Type>\n+static inline const Type& StructAtOffset(const void *P, unsigned int offset)\n+{ return * reinterpret_cast<const Type*> ((const char *) P + offset); }\n+template<typename Type>\n+static inline Type& StructAtOffset(void *P, unsigned int offset)\n+{ return * reinterpret_cast<Type*> ((char *) P + offset); }\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wcast-align\"\n+template<typename Type>\n+static inline const Type& StructAtOffsetUnaligned(const void *P, unsigned int offset)\n+{\n+  return * reinterpret_cast<Type*> ((char *) P + offset);\n+}\n+#pragma GCC diagnostic pop\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wcast-align\"\n+template<typename Type>\n+static inline Type& StructAtOffsetUnaligned(void *P, unsigned int offset)\n+{\n+  return * reinterpret_cast<Type*> ((char *) P + offset);\n+}\n+#pragma GCC diagnostic pop\n+\n+\/* StructAfter<T>(X) returns the struct T& that is placed after X.\n+ * Works with X of variable size also.  X must implement get_size() *\/\n+template<typename Type, typename TObject>\n+static inline const Type& StructAfter(const TObject &X)\n+{ return StructAtOffset<Type>(&X, X.get_size()); }\n+template<typename Type, typename TObject>\n+static inline Type& StructAfter(TObject &X)\n+{ return StructAtOffset<Type>(&X, X.get_size()); }\n+\n+\n+\/*\n+ * Size checking\n+ *\/\n+\n+\/* Check _assertion in a method environment *\/\n+#define _DEFINE_INSTANCE_ASSERTION1(_line, _assertion) \\\n+  void _instance_assertion_on_line_##_line () const \\\n+  { static_assert ((_assertion), \"\"); }\n+# define _DEFINE_INSTANCE_ASSERTION0(_line, _assertion) _DEFINE_INSTANCE_ASSERTION1 (_line, _assertion)\n+# define DEFINE_INSTANCE_ASSERTION(_assertion) _DEFINE_INSTANCE_ASSERTION0 (__LINE__, _assertion)\n+\n+\/* Check that _code compiles in a method environment *\/\n+#define _DEFINE_COMPILES_ASSERTION1(_line, _code) \\\n+  void _compiles_assertion_on_line_##_line () const \\\n+  { _code; }\n+# define _DEFINE_COMPILES_ASSERTION0(_line, _code) _DEFINE_COMPILES_ASSERTION1 (_line, _code)\n+# define DEFINE_COMPILES_ASSERTION(_code) _DEFINE_COMPILES_ASSERTION0 (__LINE__, _code)\n+\n+\n+#define DEFINE_SIZE_STATIC(size) \\\n+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) == (size)) \\\n+  unsigned int get_size () const { return (size); } \\\n+  static constexpr unsigned null_size = (size); \\\n+  static constexpr unsigned min_size = (size); \\\n+  static constexpr unsigned static_size = (size)\n+\n+#define DEFINE_SIZE_UNION(size, _member) \\\n+  DEFINE_COMPILES_ASSERTION ((void) this->u._member.static_size) \\\n+  DEFINE_INSTANCE_ASSERTION (sizeof(this->u._member) == (size)) \\\n+  static constexpr unsigned null_size = (size); \\\n+  static constexpr unsigned min_size = (size)\n+\n+#define DEFINE_SIZE_MIN(size) \\\n+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) >= (size)) \\\n+  static constexpr unsigned null_size = (size); \\\n+  static constexpr unsigned min_size = (size)\n+\n+#define DEFINE_SIZE_UNBOUNDED(size) \\\n+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) >= (size)) \\\n+  static constexpr unsigned min_size = (size)\n+\n+#define DEFINE_SIZE_ARRAY(size, array) \\\n+  DEFINE_COMPILES_ASSERTION ((void) (array)[0].static_size) \\\n+  DEFINE_INSTANCE_ASSERTION (sizeof (*this) == (size) + VAR * sizeof ((array)[0])) \\\n+  static constexpr unsigned null_size = (size); \\\n+  static constexpr unsigned min_size = (size)\n+\n+#define DEFINE_SIZE_ARRAY_SIZED(size, array) \\\n+  unsigned int get_size () const { return (size - (array).min_size + (array).get_size ()); } \\\n+  DEFINE_SIZE_ARRAY(size, array)\n+\n+\n+\/*\n+ * Dispatch\n+ *\/\n+\n+template <typename Context, typename Return, unsigned int MaxDebugDepth>\n+struct hb_dispatch_context_t\n+{\n+  static constexpr unsigned max_debug_depth = MaxDebugDepth;\n+  typedef Return return_t;\n+  template <typename T, typename F>\n+  bool may_dispatch (const T *obj HB_UNUSED, const F *format HB_UNUSED) { return true; }\n+  static return_t no_dispatch_return_value () { return Context::default_return_value (); }\n+  static bool stop_sublookup_iteration (const return_t r HB_UNUSED) { return false; }\n+};\n+\n+\n+\/*\n+ * Sanitize\n+ *\n+ *\n+ * === Introduction ===\n+ *\n+ * The sanitize machinery is at the core of our zero-cost font loading.  We\n+ * mmap() font file into memory and create a blob out of it.  Font subtables\n+ * are returned as a readonly sub-blob of the main font blob.  These table\n+ * blobs are then sanitized before use, to ensure invalid memory access does\n+ * not happen.  The toplevel sanitize API use is like, eg. to load the 'head'\n+ * table:\n+ *\n+ *   hb_blob_t *head_blob = hb_sanitize_context_t ().reference_table<OT::head> (face);\n+ *\n+ * The blob then can be converted to a head table struct with:\n+ *\n+ *   const head *head_table = head_blob->as<head> ();\n+ *\n+ * What the reference_table does is, to call hb_face_reference_table() to load\n+ * the table blob, sanitize it and return either the sanitized blob, or empty\n+ * blob if sanitization failed.  The blob->as() function returns the null\n+ * object of its template type argument if the blob is empty.  Otherwise, it\n+ * just casts the blob contents to the desired type.\n+ *\n+ * Sanitizing a blob of data with a type T works as follows (with minor\n+ * simplification):\n+ *\n+ *   - Cast blob content to T*, call sanitize() method of it,\n+ *   - If sanitize succeeded, return blob.\n+ *   - Otherwise, if blob is not writable, try making it writable,\n+ *     or copy if cannot be made writable in-place,\n+ *   - Call sanitize() again.  Return blob if sanitize succeeded.\n+ *   - Return empty blob otherwise.\n+ *\n+ *\n+ * === The sanitize() contract ===\n+ *\n+ * The sanitize() method of each object type shall return true if it's safe to\n+ * call other methods of the object, and false otherwise.\n+ *\n+ * Note that what sanitize() checks for might align with what the specification\n+ * describes as valid table data, but does not have to be.  In particular, we\n+ * do NOT want to be pedantic and concern ourselves with validity checks that\n+ * are irrelevant to our use of the table.  On the contrary, we want to be\n+ * lenient with error handling and accept invalid data to the extent that it\n+ * does not impose extra burden on us.\n+ *\n+ * Based on the sanitize contract, one can see that what we check for depends\n+ * on how we use the data in other table methods.  Ie. if other table methods\n+ * assume that offsets do NOT point out of the table data block, then that's\n+ * something sanitize() must check for (GSUB\/GPOS\/GDEF\/etc work this way).  On\n+ * the other hand, if other methods do such checks themselves, then sanitize()\n+ * does not have to bother with them (glyf\/local work this way).  The choice\n+ * depends on the table structure and sanitize() performance.  For example, to\n+ * check glyf\/loca offsets in sanitize() would cost O(num-glyphs).  We try hard\n+ * to avoid such costs during font loading.  By postponing such checks to the\n+ * actual glyph loading, we reduce the sanitize cost to O(1) and total runtime\n+ * cost to O(used-glyphs).  As such, this is preferred.\n+ *\n+ * The same argument can be made re GSUB\/GPOS\/GDEF, but there, the table\n+ * structure is so complicated that by checking all offsets at sanitize() time,\n+ * we make the code much simpler in other methods, as offsets and referenced\n+ * objects do not need to be validated at each use site.\n+ *\/\n+\n+\/* This limits sanitizing time on really broken fonts. *\/\n+#ifndef HB_SANITIZE_MAX_EDITS\n+#define HB_SANITIZE_MAX_EDITS 32\n+#endif\n+#ifndef HB_SANITIZE_MAX_OPS_FACTOR\n+#define HB_SANITIZE_MAX_OPS_FACTOR 8\n+#endif\n+#ifndef HB_SANITIZE_MAX_OPS_MIN\n+#define HB_SANITIZE_MAX_OPS_MIN 16384\n+#endif\n+#ifndef HB_SANITIZE_MAX_OPS_MAX\n+#define HB_SANITIZE_MAX_OPS_MAX 0x3FFFFFFF\n+#endif\n+\n+struct hb_sanitize_context_t :\n+       hb_dispatch_context_t<hb_sanitize_context_t, bool, HB_DEBUG_SANITIZE>\n+{\n+  hb_sanitize_context_t () :\n+        debug_depth (0),\n+        start (nullptr), end (nullptr),\n+        max_ops (0),\n+        writable (false), edit_count (0),\n+        blob (nullptr),\n+        num_glyphs (65536),\n+        num_glyphs_set (false) {}\n+\n+  const char *get_name () { return \"SANITIZE\"; }\n+  template <typename T, typename F>\n+  bool may_dispatch (const T *obj HB_UNUSED, const F *format)\n+  { return format->sanitize (this); }\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.sanitize (this); }\n+  static return_t default_return_value () { return true; }\n+  static return_t no_dispatch_return_value () { return false; }\n+  bool stop_sublookup_iteration (const return_t r) const { return !r; }\n+\n+  void init (hb_blob_t *b)\n+  {\n+    this->blob = hb_blob_reference (b);\n+    this->writable = false;\n+  }\n+\n+  void set_num_glyphs (unsigned int num_glyphs_)\n+  {\n+    num_glyphs = num_glyphs_;\n+    num_glyphs_set = true;\n+  }\n+  unsigned int get_num_glyphs () { return num_glyphs; }\n+\n+  void set_max_ops (int max_ops_) { max_ops = max_ops_; }\n+\n+  template <typename T>\n+  void set_object (const T *obj)\n+  {\n+    reset_object ();\n+\n+    if (!obj) return;\n+\n+    const char *obj_start = (const char *) obj;\n+    if (unlikely (obj_start < this->start || this->end <= obj_start))\n+      this->start = this->end = nullptr;\n+    else\n+    {\n+      this->start = obj_start;\n+      this->end   = obj_start + MIN<uintptr_t> (this->end - obj_start, obj->get_size ());\n+    }\n+  }\n+\n+  void reset_object ()\n+  {\n+    this->start = this->blob->data;\n+    this->end = this->start + this->blob->length;\n+    assert (this->start <= this->end); \/* Must not overflow. *\/\n+  }\n+\n+  void start_processing ()\n+  {\n+    reset_object ();\n+    this->max_ops = MAX ((unsigned int) (this->end - this->start) * HB_SANITIZE_MAX_OPS_FACTOR,\n+                         (unsigned) HB_SANITIZE_MAX_OPS_MIN);\n+    this->edit_count = 0;\n+    this->debug_depth = 0;\n+\n+    DEBUG_MSG_LEVEL (SANITIZE, start, 0, +1,\n+                     \"start [%p..%p] (%lu bytes)\",\n+                     this->start, this->end,\n+                     (unsigned long) (this->end - this->start));\n+  }\n+\n+  void end_processing ()\n+  {\n+    DEBUG_MSG_LEVEL (SANITIZE, this->start, 0, -1,\n+                     \"end [%p..%p] %u edit requests\",\n+                     this->start, this->end, this->edit_count);\n+\n+    hb_blob_destroy (this->blob);\n+    this->blob = nullptr;\n+    this->start = this->end = nullptr;\n+  }\n+\n+  bool check_range (const void *base,\n+                           unsigned int len) const\n+  {\n+    const char *p = (const char *) base;\n+    bool ok = this->start <= p &&\n+              p <= this->end &&\n+              (unsigned int) (this->end - p) >= len &&\n+              this->max_ops-- > 0;\n+\n+    DEBUG_MSG_LEVEL (SANITIZE, p, this->debug_depth+1, 0,\n+       \"check_range [%p..%p] (%d bytes) in [%p..%p] -> %s\",\n+       p, p + len, len,\n+       this->start, this->end,\n+       ok ? \"OK\" : \"OUT-OF-RANGE\");\n+\n+    return likely (ok);\n+  }\n+\n+  template <typename T>\n+  bool check_range (const T *base,\n+                           unsigned int a,\n+                           unsigned int b) const\n+  {\n+    return !hb_unsigned_mul_overflows (a, b) &&\n+           this->check_range (base, a * b);\n+  }\n+\n+  template <typename T>\n+  bool check_range (const T *base,\n+                           unsigned int a,\n+                           unsigned int b,\n+                           unsigned int c) const\n+  {\n+    return !hb_unsigned_mul_overflows (a, b) &&\n+           this->check_range (base, a * b, c);\n+  }\n+\n+  template <typename T>\n+  bool check_array (const T *base, unsigned int len) const\n+  {\n+    return this->check_range (base, len, hb_static_size (T));\n+  }\n+\n+  template <typename T>\n+  bool check_array (const T *base,\n+                    unsigned int a,\n+                    unsigned int b) const\n+  {\n+    return this->check_range (base, a, b, hb_static_size (T));\n+  }\n+\n+  template <typename Type>\n+  bool check_struct (const Type *obj) const\n+  { return likely (this->check_range (obj, obj->min_size)); }\n+\n+  bool may_edit (const void *base, unsigned int len)\n+  {\n+    if (this->edit_count >= HB_SANITIZE_MAX_EDITS)\n+      return false;\n+\n+    const char *p = (const char *) base;\n+    this->edit_count++;\n+\n+    DEBUG_MSG_LEVEL (SANITIZE, p, this->debug_depth+1, 0,\n+       \"may_edit(%u) [%p..%p] (%d bytes) in [%p..%p] -> %s\",\n+       this->edit_count,\n+       p, p + len, len,\n+       this->start, this->end,\n+       this->writable ? \"GRANTED\" : \"DENIED\");\n+\n+    return this->writable;\n+  }\n+\n+  template <typename Type, typename ValueType>\n+  bool try_set (const Type *obj, const ValueType &v)\n+  {\n+    if (this->may_edit (obj, hb_static_size (Type)))\n+    {\n+      hb_assign (* const_cast<Type *> (obj), v);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  template <typename Type>\n+  hb_blob_t *sanitize_blob (hb_blob_t *blob)\n+  {\n+    bool sane;\n+\n+    init (blob);\n+\n+  retry:\n+    DEBUG_MSG_FUNC (SANITIZE, start, \"start\");\n+\n+    start_processing ();\n+\n+    if (unlikely (!start))\n+    {\n+      end_processing ();\n+      return blob;\n+    }\n+\n+    Type *t = CastP<Type> (const_cast<char *> (start));\n+\n+    sane = t->sanitize (this);\n+    if (sane)\n+    {\n+      if (edit_count)\n+      {\n+        DEBUG_MSG_FUNC (SANITIZE, start, \"passed first round with %d edits; going for second round\", edit_count);\n+\n+        \/* sanitize again to ensure no toe-stepping *\/\n+        edit_count = 0;\n+        sane = t->sanitize (this);\n+        if (edit_count) {\n+          DEBUG_MSG_FUNC (SANITIZE, start, \"requested %d edits in second round; FAILLING\", edit_count);\n+          sane = false;\n+        }\n+      }\n+    }\n+    else\n+    {\n+      if (edit_count && !writable) {\n+        start = hb_blob_get_data_writable (blob, nullptr);\n+        end = start + blob->length;\n+\n+        if (start)\n+        {\n+          writable = true;\n+          \/* ok, we made it writable by relocating.  try again *\/\n+          DEBUG_MSG_FUNC (SANITIZE, start, \"retry\");\n+          goto retry;\n+        }\n+      }\n+    }\n+\n+    end_processing ();\n+\n+    DEBUG_MSG_FUNC (SANITIZE, start, sane ? \"PASSED\" : \"FAILED\");\n+    if (sane)\n+    {\n+      hb_blob_make_immutable (blob);\n+      return blob;\n+    }\n+    else\n+    {\n+      hb_blob_destroy (blob);\n+      return hb_blob_get_empty ();\n+    }\n+  }\n+\n+  template <typename Type>\n+  hb_blob_t *reference_table (const hb_face_t *face, hb_tag_t tableTag = Type::tableTag)\n+  {\n+    if (!num_glyphs_set)\n+      set_num_glyphs (hb_face_get_glyph_count (face));\n+    return sanitize_blob<Type> (hb_face_reference_table (face, tableTag));\n+  }\n+\n+  mutable unsigned int debug_depth;\n+  const char *start, *end;\n+  mutable int max_ops;\n+  private:\n+  bool writable;\n+  unsigned int edit_count;\n+  hb_blob_t *blob;\n+  unsigned int num_glyphs;\n+  bool  num_glyphs_set;\n+};\n+\n+struct hb_sanitize_with_object_t\n+{\n+  template <typename T>\n+  hb_sanitize_with_object_t (hb_sanitize_context_t *c,\n+                                    const T& obj) : c (c)\n+  { c->set_object (obj); }\n+  ~hb_sanitize_with_object_t ()\n+  { c->reset_object (); }\n+\n+  private:\n+  hb_sanitize_context_t *c;\n+};\n+\n+\n+\/*\n+ * Serialize\n+ *\/\n+\n+struct hb_serialize_context_t\n+{\n+  hb_serialize_context_t (void *start_, unsigned int size)\n+  {\n+    this->start = (char *) start_;\n+    this->end = this->start + size;\n+    reset ();\n+  }\n+\n+  bool in_error () const { return !this->successful; }\n+\n+  void reset ()\n+  {\n+    this->successful = true;\n+    this->head = this->start;\n+    this->debug_depth = 0;\n+  }\n+\n+  bool propagate_error (bool e)\n+  { return this->successful = this->successful && e; }\n+  template <typename T> bool propagate_error (const T &obj)\n+  { return this->successful = this->successful && !obj.in_error (); }\n+  template <typename T> bool propagate_error (const T *obj)\n+  { return this->successful = this->successful && !obj->in_error (); }\n+  template <typename T1, typename T2> bool propagate_error (T1 &o1, T2 &o2)\n+  { return propagate_error (o1) && propagate_error (o2); }\n+  template <typename T1, typename T2> bool propagate_error (T1 *o1, T2 *o2)\n+  { return propagate_error (o1) && propagate_error (o2); }\n+  template <typename T1, typename T2, typename T3>\n+  bool propagate_error (T1 &o1, T2 &o2, T3 &o3)\n+  { return propagate_error (o1) && propagate_error (o2, o3); }\n+  template <typename T1, typename T2, typename T3>\n+  bool propagate_error (T1 *o1, T2 *o2, T3 *o3)\n+  { return propagate_error (o1) && propagate_error (o2, o3); }\n+\n+  \/* To be called around main operation. *\/\n+  template <typename Type>\n+  Type *start_serialize ()\n+  {\n+    DEBUG_MSG_LEVEL (SERIALIZE, this->start, 0, +1,\n+                     \"start [%p..%p] (%lu bytes)\",\n+                     this->start, this->end,\n+                     (unsigned long) (this->end - this->start));\n+\n+    return start_embed<Type> ();\n+  }\n+  void end_serialize ()\n+  {\n+    DEBUG_MSG_LEVEL (SERIALIZE, this->start, 0, -1,\n+                     \"end [%p..%p] serialized %d bytes; %s\",\n+                     this->start, this->end,\n+                     (int) (this->head - this->start),\n+                     this->successful ? \"successful\" : \"UNSUCCESSFUL\");\n+  }\n+\n+  unsigned int length () const { return this->head - this->start; }\n+\n+  void align (unsigned int alignment)\n+  {\n+    unsigned int l = length () % alignment;\n+    if (l)\n+      allocate_size<void> (alignment - l);\n+  }\n+\n+  template <typename Type>\n+  Type *start_embed (const Type *_ HB_UNUSED = nullptr) const\n+  {\n+    Type *ret = reinterpret_cast<Type *> (this->head);\n+    return ret;\n+  }\n+\n+  template <typename Type>\n+  Type *allocate_size (unsigned int size)\n+  {\n+    if (unlikely (!this->successful || this->end - this->head < ptrdiff_t (size))) {\n+      this->successful = false;\n+      return nullptr;\n+    }\n+    memset (this->head, 0, size);\n+    char *ret = this->head;\n+    this->head += size;\n+    return reinterpret_cast<Type *> (ret);\n+  }\n+\n+  template <typename Type>\n+  Type *allocate_min ()\n+  {\n+    return this->allocate_size<Type> (Type::min_size);\n+  }\n+\n+  template <typename Type>\n+  Type *embed (const Type &obj)\n+  {\n+    unsigned int size = obj.get_size ();\n+    Type *ret = this->allocate_size<Type> (size);\n+    if (unlikely (!ret)) return nullptr;\n+    memcpy (ret, &obj, size);\n+    return ret;\n+  }\n+  template <typename Type>\n+  hb_serialize_context_t &operator << (const Type &obj) { embed (obj); return *this; }\n+\n+  template <typename Type>\n+  Type *extend_size (Type &obj, unsigned int size)\n+  {\n+    assert (this->start <= (char *) &obj);\n+    assert ((char *) &obj <= this->head);\n+    assert ((char *) &obj + size >= this->head);\n+    if (unlikely (!this->allocate_size<Type> (((char *) &obj) + size - this->head))) return nullptr;\n+    return reinterpret_cast<Type *> (&obj);\n+  }\n+\n+  template <typename Type>\n+  Type *extend_min (Type &obj) { return extend_size (obj, obj.min_size); }\n+\n+  template <typename Type>\n+  Type *extend (Type &obj) { return extend_size (obj, obj.get_size ()); }\n+\n+  \/* Output routines. *\/\n+  template <typename Type>\n+  Type *copy () const\n+  {\n+    assert (this->successful);\n+    unsigned int len = this->head - this->start;\n+    void *p = malloc (len);\n+    if (p)\n+      memcpy (p, this->start, len);\n+    return reinterpret_cast<Type *> (p);\n+  }\n+  hb_bytes_t copy_bytes () const\n+  {\n+    assert (this->successful);\n+    unsigned int len = this->head - this->start;\n+    void *p = malloc (len);\n+    if (p)\n+      memcpy (p, this->start, len);\n+    else\n+      return hb_bytes_t ();\n+    return hb_bytes_t ((char *) p, len);\n+  }\n+  hb_blob_t *copy_blob () const\n+  {\n+    assert (this->successful);\n+    return hb_blob_create (this->start,\n+                           this->head - this->start,\n+                           HB_MEMORY_MODE_DUPLICATE,\n+                           nullptr, nullptr);\n+  }\n+\n+  public:\n+  unsigned int debug_depth;\n+  char *start, *end, *head;\n+  bool successful;\n+};\n+\n+\n+\n+\/*\n+ * Big-endian integers.\n+ *\/\n+\n+template <typename Type, int Bytes> struct BEInt;\n+\n+template <typename Type>\n+struct BEInt<Type, 1>\n+{\n+  public:\n+  void set (Type V)      { v = V; }\n+  operator Type () const { return v; }\n+  private: uint8_t v;\n+};\n+template <typename Type>\n+struct BEInt<Type, 2>\n+{\n+  public:\n+  void set (Type V)\n+  {\n+    v[0] = (V >>  8) & 0xFF;\n+    v[1] = (V      ) & 0xFF;\n+  }\n+  operator Type () const\n+  {\n+#if ((defined(__GNUC__) && __GNUC__ >= 5) || defined(__clang__)) && \\\n+    defined(__BYTE_ORDER) && \\\n+    (__BYTE_ORDER == __LITTLE_ENDIAN || __BYTE_ORDER == __BIG_ENDIAN)\n+    \/* Spoon-feed the compiler a big-endian integer with alignment 1.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/1398 *\/\n+    struct __attribute__((packed)) packed_uint16_t { uint16_t v; };\n+#if __BYTE_ORDER == __LITTLE_ENDIAN\n+    return __builtin_bswap16 (((packed_uint16_t *) this)->v);\n+#else \/* __BYTE_ORDER == __BIG_ENDIAN *\/\n+    return ((packed_uint16_t *) this)->v;\n+#endif\n+#endif\n+    return (v[0] <<  8)\n+         + (v[1]      );\n+  }\n+  private: uint8_t v[2];\n+};\n+template <typename Type>\n+struct BEInt<Type, 3>\n+{\n+  public:\n+  void set (Type V)\n+  {\n+    v[0] = (V >> 16) & 0xFF;\n+    v[1] = (V >>  8) & 0xFF;\n+    v[2] = (V      ) & 0xFF;\n+  }\n+  operator Type () const\n+  {\n+    return (v[0] << 16)\n+         + (v[1] <<  8)\n+         + (v[2]      );\n+  }\n+  private: uint8_t v[3];\n+};\n+template <typename Type>\n+struct BEInt<Type, 4>\n+{\n+  public:\n+  typedef Type type;\n+  void set (Type V)\n+  {\n+    v[0] = (V >> 24) & 0xFF;\n+    v[1] = (V >> 16) & 0xFF;\n+    v[2] = (V >>  8) & 0xFF;\n+    v[3] = (V      ) & 0xFF;\n+  }\n+  operator Type () const\n+  {\n+    return (v[0] << 24)\n+         + (v[1] << 16)\n+         + (v[2] <<  8)\n+         + (v[3]      );\n+  }\n+  private: uint8_t v[4];\n+};\n+\n+\n+\/*\n+ * Lazy loaders.\n+ *\/\n+\n+template <typename Data, unsigned int WheresData>\n+struct hb_data_wrapper_t\n+{\n+  static_assert (WheresData > 0, \"\");\n+\n+  Data * get_data () const\n+  { return *(((Data **) (void *) this) - WheresData); }\n+\n+  bool is_inert () const { return !get_data (); }\n+\n+  template <typename Stored, typename Subclass>\n+  Stored * call_create () const { return Subclass::create (get_data ()); }\n+};\n+template <>\n+struct hb_data_wrapper_t<void, 0>\n+{\n+  bool is_inert () const { return false; }\n+\n+  template <typename Stored, typename Funcs>\n+  Stored * call_create () const { return Funcs::create (); }\n+};\n+\n+template <typename T1, typename T2> struct hb_non_void_t { typedef T1 value; };\n+template <typename T2> struct hb_non_void_t<void, T2> { typedef T2 value; };\n+\n+template <typename Returned,\n+          typename Subclass = void,\n+          typename Data = void,\n+          unsigned int WheresData = 0,\n+          typename Stored = Returned>\n+struct hb_lazy_loader_t : hb_data_wrapper_t<Data, WheresData>\n+{\n+  typedef typename hb_non_void_t<Subclass,\n+                                 hb_lazy_loader_t<Returned,Subclass,Data,WheresData,Stored>\n+                                >::value Funcs;\n+\n+  void init0 () {} \/* Init, when memory is already set to 0. No-op for us. *\/\n+  void init ()  { instance.set_relaxed (nullptr); }\n+  void fini ()  { do_destroy (instance.get ()); }\n+\n+  void free_instance ()\n+  {\n+  retry:\n+    Stored *p = instance.get ();\n+    if (unlikely (p && !cmpexch (p, nullptr)))\n+      goto retry;\n+    do_destroy (p);\n+  }\n+\n+  static void do_destroy (Stored *p)\n+  {\n+    if (p && p != const_cast<Stored *> (Funcs::get_null ()))\n+      Funcs::destroy (p);\n+  }\n+\n+  const Returned * operator -> () const { return get (); }\n+  const Returned & operator * () const  { return *get (); }\n+  explicit_operator bool () const\n+  { return get_stored () != Funcs::get_null (); }\n+  template <typename C> operator const C * () const { return get (); }\n+\n+  Stored * get_stored () const\n+  {\n+  retry:\n+    Stored *p = this->instance.get ();\n+    if (unlikely (!p))\n+    {\n+      if (unlikely (this->is_inert ()))\n+        return const_cast<Stored *> (Funcs::get_null ());\n+\n+      p = this->template call_create<Stored, Funcs> ();\n+      if (unlikely (!p))\n+        p = const_cast<Stored *> (Funcs::get_null ());\n+\n+      if (unlikely (!cmpexch (nullptr, p)))\n+      {\n+        do_destroy (p);\n+        goto retry;\n+      }\n+    }\n+    return p;\n+  }\n+  Stored * get_stored_relaxed () const\n+  {\n+    return this->instance.get_relaxed ();\n+  }\n+\n+  bool cmpexch (Stored *current, Stored *value) const\n+  {\n+    \/* This *must* be called when there are no other threads accessing. *\/\n+    return this->instance.cmpexch (current, value);\n+  }\n+\n+  const Returned * get () const { return Funcs::convert (get_stored ()); }\n+  const Returned * get_relaxed () const { return Funcs::convert (get_stored_relaxed ()); }\n+  Returned * get_unconst () const { return const_cast<Returned *> (Funcs::convert (get_stored ())); }\n+\n+  \/* To be possibly overloaded by subclasses. *\/\n+  static Returned* convert (Stored *p) { return p; }\n+\n+  \/* By default null\/init\/fini the object. *\/\n+  static const Stored* get_null () { return &Null(Stored); }\n+  static Stored *create (Data *data)\n+  {\n+    Stored *p = (Stored *) calloc (1, sizeof (Stored));\n+    if (likely (p))\n+      p->init (data);\n+    return p;\n+  }\n+  static Stored *create ()\n+  {\n+    Stored *p = (Stored *) calloc (1, sizeof (Stored));\n+    if (likely (p))\n+      p->init ();\n+    return p;\n+  }\n+  static void destroy (Stored *p)\n+  {\n+    p->fini ();\n+    free (p);\n+  }\n+\n+\/\/  private:\n+  \/* Must only have one pointer. *\/\n+  hb_atomic_ptr_t<Stored *> instance;\n+};\n+\n+\/* Specializations. *\/\n+\n+template <typename T, unsigned int WheresFace>\n+struct hb_face_lazy_loader_t : hb_lazy_loader_t<T,\n+                                                hb_face_lazy_loader_t<T, WheresFace>,\n+                                                hb_face_t, WheresFace> {};\n+\n+template <typename T, unsigned int WheresFace>\n+struct hb_table_lazy_loader_t : hb_lazy_loader_t<T,\n+                                                 hb_table_lazy_loader_t<T, WheresFace>,\n+                                                 hb_face_t, WheresFace,\n+                                                 hb_blob_t>\n+{\n+  static hb_blob_t *create (hb_face_t *face)\n+  { return hb_sanitize_context_t ().reference_table<T> (face); }\n+  static void destroy (hb_blob_t *p) { hb_blob_destroy (p); }\n+\n+  static const hb_blob_t *get_null ()\n+  { return hb_blob_get_empty (); }\n+\n+  static const T* convert (const hb_blob_t *blob)\n+  { return blob->as<T> (); }\n+\n+  hb_blob_t* get_blob () const { return this->get_stored (); }\n+};\n+\n+template <typename Subclass>\n+struct hb_font_funcs_lazy_loader_t : hb_lazy_loader_t<hb_font_funcs_t, Subclass>\n+{\n+  static void destroy (hb_font_funcs_t *p)\n+  { hb_font_funcs_destroy (p); }\n+  static const hb_font_funcs_t *get_null ()\n+  { return hb_font_funcs_get_empty (); }\n+};\n+template <typename Subclass>\n+struct hb_unicode_funcs_lazy_loader_t : hb_lazy_loader_t<hb_unicode_funcs_t, Subclass>\n+{\n+  static void destroy (hb_unicode_funcs_t *p)\n+  { hb_unicode_funcs_destroy (p); }\n+  static const hb_unicode_funcs_t *get_null ()\n+  { return hb_unicode_funcs_get_empty (); }\n+};\n+\n+\n+#endif \/* HB_MACHINERY_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-machinery.hh","additions":932,"deletions":0,"binary":false,"changes":932,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-map.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-map\n+ * @title: hb-map\n+ * @short_description: Object representing integer to integer mapping\n+ * @include: hb.h\n+ *\n+ * Map objects are integer-to-integer hash-maps.  Currently they are\n+ * not used in the HarfBuzz public API, but are provided for client's\n+ * use if desired.\n+ **\/\n+\n+\n+\/**\n+ * hb_map_create: (Xconstructor)\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_map_t *\n+hb_map_create ()\n+{\n+  hb_map_t *map;\n+\n+  if (!(map = hb_object_create<hb_map_t> ()))\n+    return hb_map_get_empty ();\n+\n+  map->init_shallow ();\n+\n+  return map;\n+}\n+\n+\/**\n+ * hb_map_get_empty:\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_map_t *\n+hb_map_get_empty ()\n+{\n+  return const_cast<hb_map_t *> (&Null(hb_map_t));\n+}\n+\n+\/**\n+ * hb_map_reference: (skip)\n+ * @map: a map.\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_map_t *\n+hb_map_reference (hb_map_t *map)\n+{\n+  return hb_object_reference (map);\n+}\n+\n+\/**\n+ * hb_map_destroy: (skip)\n+ * @map: a map.\n+ *\n+ * Since: 1.7.7\n+ **\/\n+void\n+hb_map_destroy (hb_map_t *map)\n+{\n+  if (!hb_object_destroy (map)) return;\n+\n+  map->fini_shallow ();\n+\n+  free (map);\n+}\n+\n+\/**\n+ * hb_map_set_user_data: (skip)\n+ * @map: a map.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ * Return value:\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_bool_t\n+hb_map_set_user_data (hb_map_t           *map,\n+                      hb_user_data_key_t *key,\n+                      void *              data,\n+                      hb_destroy_func_t   destroy,\n+                      hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (map, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_map_get_user_data: (skip)\n+ * @map: a map.\n+ * @key:\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 1.7.7\n+ **\/\n+void *\n+hb_map_get_user_data (hb_map_t           *map,\n+                      hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (map, key);\n+}\n+\n+\n+\/**\n+ * hb_map_allocation_successful:\n+ * @map: a map.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_bool_t\n+hb_map_allocation_successful (const hb_map_t  *map)\n+{\n+  return map->successful;\n+}\n+\n+\n+\/**\n+ * hb_map_set:\n+ * @map: a map.\n+ * @key:\n+ * @value:\n+ *\n+ *\n+ *\n+ * Since: 1.7.7\n+ **\/\n+void\n+hb_map_set (hb_map_t       *map,\n+            hb_codepoint_t  key,\n+            hb_codepoint_t  value)\n+{\n+  map->set (key, value);\n+}\n+\n+\/**\n+ * hb_map_get:\n+ * @map: a map.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_codepoint_t\n+hb_map_get (const hb_map_t *map,\n+            hb_codepoint_t  key)\n+{\n+  return map->get (key);\n+}\n+\n+\/**\n+ * hb_map_del:\n+ * @map: a map.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Since: 1.7.7\n+ **\/\n+void\n+hb_map_del (hb_map_t       *map,\n+            hb_codepoint_t  key)\n+{\n+  map->del (key);\n+}\n+\n+\/**\n+ * hb_map_has:\n+ * @map: a map.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_bool_t\n+hb_map_has (const hb_map_t *map,\n+            hb_codepoint_t  key)\n+{\n+  return map->has (key);\n+}\n+\n+\n+\/**\n+ * hb_map_clear:\n+ * @map: a map.\n+ *\n+ *\n+ *\n+ * Since: 1.7.7\n+ **\/\n+void\n+hb_map_clear (hb_map_t *map)\n+{\n+  return map->clear ();\n+}\n+\n+\/**\n+ * hb_map_is_empty:\n+ * @map: a map.\n+ *\n+ *\n+ *\n+ * Since: 1.7.7\n+ **\/\n+hb_bool_t\n+hb_map_is_empty (const hb_map_t *map)\n+{\n+  return map->is_empty ();\n+}\n+\n+\/**\n+ * hb_map_get_population:\n+ * @map: a map.\n+ *\n+ *\n+ *\n+ * Since: 1.7.7\n+ **\/\n+unsigned int\n+hb_map_get_population (const hb_map_t *map)\n+{\n+  return map->get_population ();\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-map.cc","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_MAP_H\n+#define HB_MAP_H\n+\n+#include \"hb-common.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/*\n+ * Since: 1.7.7\n+ *\/\n+#define HB_MAP_VALUE_INVALID ((hb_codepoint_t) -1)\n+\n+typedef struct hb_map_t hb_map_t;\n+\n+\n+HB_EXTERN hb_map_t *\n+hb_map_create (void);\n+\n+HB_EXTERN hb_map_t *\n+hb_map_get_empty (void);\n+\n+HB_EXTERN hb_map_t *\n+hb_map_reference (hb_map_t *map);\n+\n+HB_EXTERN void\n+hb_map_destroy (hb_map_t *map);\n+\n+HB_EXTERN hb_bool_t\n+hb_map_set_user_data (hb_map_t           *map,\n+                      hb_user_data_key_t *key,\n+                      void *              data,\n+                      hb_destroy_func_t   destroy,\n+                      hb_bool_t           replace);\n+\n+HB_EXTERN void *\n+hb_map_get_user_data (hb_map_t           *map,\n+                      hb_user_data_key_t *key);\n+\n+\n+\/* Returns false if allocation has failed before *\/\n+HB_EXTERN hb_bool_t\n+hb_map_allocation_successful (const hb_map_t *map);\n+\n+HB_EXTERN void\n+hb_map_clear (hb_map_t *map);\n+\n+HB_EXTERN hb_bool_t\n+hb_map_is_empty (const hb_map_t *map);\n+\n+HB_EXTERN unsigned int\n+hb_map_get_population (const hb_map_t *map);\n+\n+HB_EXTERN void\n+hb_map_set (hb_map_t       *map,\n+            hb_codepoint_t  key,\n+            hb_codepoint_t  value);\n+\n+HB_EXTERN hb_codepoint_t\n+hb_map_get (const hb_map_t *map,\n+            hb_codepoint_t  key);\n+\n+HB_EXTERN void\n+hb_map_del (hb_map_t       *map,\n+            hb_codepoint_t  key);\n+\n+HB_EXTERN hb_bool_t\n+hb_map_has (const hb_map_t *map,\n+            hb_codepoint_t  key);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_MAP_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-map.h","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,252 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_MAP_HH\n+#define HB_MAP_HH\n+\n+#include \"hb.hh\"\n+\n+\n+template <typename T>\n+inline uint32_t Hash (const T &v)\n+{\n+  \/* Knuth's multiplicative method: *\/\n+  return (uint32_t) v * 2654435761u;\n+}\n+\n+\n+\/*\n+ * hb_map_t\n+ *\/\n+\n+struct hb_map_t\n+{\n+  HB_NO_COPY_ASSIGN (hb_map_t);\n+  hb_map_t ()  { init (); }\n+  ~hb_map_t () { fini (); }\n+\n+  struct item_t\n+  {\n+    hb_codepoint_t key;\n+    hb_codepoint_t value;\n+\n+    bool is_unused () const    { return key == INVALID; }\n+    bool is_tombstone () const { return key != INVALID && value == INVALID; }\n+  };\n+\n+  hb_object_header_t header;\n+  bool successful; \/* Allocations successful *\/\n+  unsigned int population; \/* Not including tombstones. *\/\n+  unsigned int occupancy; \/* Including tombstones. *\/\n+  unsigned int mask;\n+  unsigned int prime;\n+  item_t *items;\n+\n+  void init_shallow ()\n+  {\n+    successful = true;\n+    population = occupancy = 0;\n+    mask = 0;\n+    prime = 0;\n+    items = nullptr;\n+  }\n+  void init ()\n+  {\n+    hb_object_init (this);\n+    init_shallow ();\n+  }\n+  void fini_shallow ()\n+  {\n+    free (items);\n+    items = nullptr;\n+  }\n+  void fini ()\n+  {\n+    population = occupancy = 0;\n+    hb_object_fini (this);\n+    fini_shallow ();\n+  }\n+\n+  bool in_error () const { return !successful; }\n+\n+  bool resize ()\n+  {\n+    if (unlikely (!successful)) return false;\n+\n+    unsigned int power = hb_bit_storage (population * 2 + 8);\n+    unsigned int new_size = 1u << power;\n+    item_t *new_items = (item_t *) malloc ((size_t) new_size * sizeof (item_t));\n+    if (unlikely (!new_items))\n+    {\n+      successful = false;\n+      return false;\n+    }\n+    memset (new_items, 0xFF, (size_t) new_size * sizeof (item_t));\n+\n+    unsigned int old_size = mask + 1;\n+    item_t *old_items = items;\n+\n+    \/* Switch to new, empty, array. *\/\n+    population = occupancy = 0;\n+    mask = new_size - 1;\n+    prime = prime_for (power);\n+    items = new_items;\n+\n+    \/* Insert back old items. *\/\n+    if (old_items)\n+      for (unsigned int i = 0; i < old_size; i++)\n+        if (old_items[i].key != INVALID && old_items[i].value != INVALID)\n+          set (old_items[i].key, old_items[i].value);\n+\n+    free (old_items);\n+\n+    return true;\n+  }\n+\n+  void set (hb_codepoint_t key, hb_codepoint_t value)\n+  {\n+    if (unlikely (!successful)) return;\n+    if (unlikely (key == INVALID)) return;\n+    if ((occupancy + occupancy \/ 2) >= mask && !resize ()) return;\n+    unsigned int i = bucket_for (key);\n+\n+    if (value == INVALID && items[i].key != key)\n+      return; \/* Trying to delete non-existent key. *\/\n+\n+    if (!items[i].is_unused ())\n+    {\n+      occupancy--;\n+      if (items[i].is_tombstone ())\n+        population--;\n+    }\n+\n+    items[i].key = key;\n+    items[i].value = value;\n+\n+    occupancy++;\n+    if (!items[i].is_tombstone ())\n+      population++;\n+\n+  }\n+  hb_codepoint_t get (hb_codepoint_t key) const\n+  {\n+    if (unlikely (!items)) return INVALID;\n+    unsigned int i = bucket_for (key);\n+    return items[i].key == key ? items[i].value : INVALID;\n+  }\n+\n+  void del (hb_codepoint_t key) { set (key, INVALID); }\n+\n+  bool has (hb_codepoint_t key) const\n+  { return get (key) != INVALID; }\n+\n+  hb_codepoint_t operator [] (unsigned int key) const\n+  { return get (key); }\n+\n+  static constexpr hb_codepoint_t INVALID = HB_MAP_VALUE_INVALID;\n+\n+  void clear ()\n+  {\n+    memset (items, 0xFF, ((size_t) mask + 1) * sizeof (item_t));\n+    population = occupancy = 0;\n+  }\n+\n+  bool is_empty () const { return population == 0; }\n+\n+  unsigned int get_population () const { return population; }\n+\n+  protected:\n+\n+  unsigned int bucket_for (hb_codepoint_t key) const\n+  {\n+    unsigned int i = Hash (key) % prime;\n+    unsigned int step = 0;\n+    unsigned int tombstone = INVALID;\n+    while (!items[i].is_unused ())\n+    {\n+      if (items[i].key == key)\n+        return i;\n+      if (tombstone == INVALID && items[i].is_tombstone ())\n+        tombstone = i;\n+      i = (i + ++step) & mask;\n+    }\n+    return tombstone == INVALID ? i : tombstone;\n+  }\n+\n+  static unsigned int prime_for (unsigned int shift)\n+  {\n+    \/* Following comment and table copied from glib. *\/\n+    \/* Each table size has an associated prime modulo (the first prime\n+     * lower than the table size) used to find the initial bucket. Probing\n+     * then works modulo 2^n. The prime modulo is necessary to get a\n+     * good distribution with poor hash functions.\n+     *\/\n+    \/* Not declaring static to make all kinds of compilers happy... *\/\n+    \/*static*\/ const unsigned int prime_mod [32] =\n+    {\n+      1,          \/* For 1 << 0 *\/\n+      2,\n+      3,\n+      7,\n+      13,\n+      31,\n+      61,\n+      127,\n+      251,\n+      509,\n+      1021,\n+      2039,\n+      4093,\n+      8191,\n+      16381,\n+      32749,\n+      65521,      \/* For 1 << 16 *\/\n+      131071,\n+      262139,\n+      524287,\n+      1048573,\n+      2097143,\n+      4194301,\n+      8388593,\n+      16777213,\n+      33554393,\n+      67108859,\n+      134217689,\n+      268435399,\n+      536870909,\n+      1073741789,\n+      2147483647  \/* For 1 << 31 *\/\n+    };\n+\n+    if (unlikely (shift >= ARRAY_LENGTH (prime_mod)))\n+      return prime_mod[ARRAY_LENGTH (prime_mod) - 1];\n+\n+    return prime_mod[shift];\n+  }\n+};\n+\n+\n+#endif \/* HB_MAP_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-map.hh","additions":252,"deletions":0,"binary":false,"changes":252,"status":"added"},{"patch":"@@ -0,0 +1,149 @@\n+\/*\n+ * Copyright © 2007  Chris Wilson\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Contributor(s):\n+ *      Chris Wilson <chris@chris-wilson.co.uk>\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_MUTEX_HH\n+#define HB_MUTEX_HH\n+\n+#include \"hb.hh\"\n+\n+\n+\/* mutex *\/\n+\n+\/* We need external help for these *\/\n+\n+#if defined(HB_MUTEX_IMPL_INIT) \\\n+ && defined(hb_mutex_impl_init) \\\n+ && defined(hb_mutex_impl_lock) \\\n+ && defined(hb_mutex_impl_unlock) \\\n+ && defined(hb_mutex_impl_finish)\n+\n+\/* Defined externally, i.e. in config.h; must have typedef'ed hb_mutex_impl_t as well. *\/\n+\n+\n+#elif !defined(HB_NO_MT) && defined(_WIN32)\n+\n+#include <windows.h>\n+typedef CRITICAL_SECTION hb_mutex_impl_t;\n+#define HB_MUTEX_IMPL_INIT      {0}\n+#if defined(WINAPI_FAMILY) && (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)\n+#define hb_mutex_impl_init(M)   InitializeCriticalSectionEx (M, 0, 0)\n+#else\n+#define hb_mutex_impl_init(M)   InitializeCriticalSection (M)\n+#endif\n+#define hb_mutex_impl_lock(M)   EnterCriticalSection (M)\n+#define hb_mutex_impl_unlock(M) LeaveCriticalSection (M)\n+#define hb_mutex_impl_finish(M) DeleteCriticalSection (M)\n+\n+\n+#elif !defined(HB_NO_MT) && (defined(HAVE_PTHREAD) || defined(__APPLE__))\n+\n+#include <pthread.h>\n+typedef pthread_mutex_t hb_mutex_impl_t;\n+#define HB_MUTEX_IMPL_INIT      PTHREAD_MUTEX_INITIALIZER\n+#define hb_mutex_impl_init(M)   pthread_mutex_init (M, nullptr)\n+#define hb_mutex_impl_lock(M)   pthread_mutex_lock (M)\n+#define hb_mutex_impl_unlock(M) pthread_mutex_unlock (M)\n+#define hb_mutex_impl_finish(M) pthread_mutex_destroy (M)\n+\n+\n+#elif !defined(HB_NO_MT) && defined(HAVE_INTEL_ATOMIC_PRIMITIVES)\n+\n+#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_YIELD)\n+# include <sched.h>\n+# define HB_SCHED_YIELD() sched_yield ()\n+#else\n+# define HB_SCHED_YIELD() HB_STMT_START {} HB_STMT_END\n+#endif\n+\n+\/* This actually is not a totally awful implementation. *\/\n+typedef volatile int hb_mutex_impl_t;\n+#define HB_MUTEX_IMPL_INIT      0\n+#define hb_mutex_impl_init(M)   *(M) = 0\n+#define hb_mutex_impl_lock(M)   HB_STMT_START { while (__sync_lock_test_and_set((M), 1)) HB_SCHED_YIELD (); } HB_STMT_END\n+#define hb_mutex_impl_unlock(M) __sync_lock_release (M)\n+#define hb_mutex_impl_finish(M) HB_STMT_START {} HB_STMT_END\n+\n+\n+#elif !defined(HB_NO_MT)\n+\n+#if defined(HAVE_SCHED_H) && defined(HAVE_SCHED_YIELD)\n+# include <sched.h>\n+# define HB_SCHED_YIELD() sched_yield ()\n+#else\n+# define HB_SCHED_YIELD() HB_STMT_START {} HB_STMT_END\n+#endif\n+\n+#define HB_MUTEX_INT_NIL 1 \/* Warn that fallback implementation is in use. *\/\n+typedef volatile int hb_mutex_impl_t;\n+#define HB_MUTEX_IMPL_INIT      0\n+#define hb_mutex_impl_init(M)   *(M) = 0\n+#define hb_mutex_impl_lock(M)   HB_STMT_START { while (*(M)) HB_SCHED_YIELD (); (*(M))++; } HB_STMT_END\n+#define hb_mutex_impl_unlock(M) (*(M))--;\n+#define hb_mutex_impl_finish(M) HB_STMT_START {} HB_STMT_END\n+\n+\n+#else \/* HB_NO_MT *\/\n+\n+typedef int hb_mutex_impl_t;\n+#define HB_MUTEX_IMPL_INIT      0\n+#define hb_mutex_impl_init(M)   HB_STMT_START {} HB_STMT_END\n+#define hb_mutex_impl_lock(M)   HB_STMT_START {} HB_STMT_END\n+#define hb_mutex_impl_unlock(M) HB_STMT_START {} HB_STMT_END\n+#define hb_mutex_impl_finish(M) HB_STMT_START {} HB_STMT_END\n+\n+\n+#endif\n+\n+\n+#define HB_MUTEX_INIT           {HB_MUTEX_IMPL_INIT}\n+\n+struct hb_mutex_t\n+{\n+  \/* TODO Add tracing. *\/\n+\n+  hb_mutex_impl_t m;\n+\n+  void init   () { hb_mutex_impl_init   (&m); }\n+  void lock   () { hb_mutex_impl_lock   (&m); }\n+  void unlock () { hb_mutex_impl_unlock (&m); }\n+  void fini ()   { hb_mutex_impl_finish (&m); }\n+};\n+\n+struct hb_lock_t\n+{\n+  hb_lock_t (hb_mutex_t &mutex_) : mutex (mutex_) { mutex.lock (); }\n+  ~hb_lock_t () { mutex.unlock (); }\n+  private:\n+  hb_mutex_t &mutex;\n+};\n+\n+\n+#endif \/* HB_MUTEX_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-mutex.hh","additions":149,"deletions":0,"binary":false,"changes":149,"status":"added"},{"patch":"@@ -0,0 +1,206 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_NULL_HH\n+#define HB_NULL_HH\n+\n+#include \"hb.hh\"\n+\n+\n+\/*\n+ * Static pools\n+ *\/\n+\n+\/* Global nul-content Null pool.  Enlarge as necessary. *\/\n+\n+#define HB_NULL_POOL_SIZE 9880\n+\n+\/* Use SFINAE to sniff whether T has min_size; in which case return T::null_size,\n+ * otherwise return sizeof(T). *\/\n+\n+\/* The hard way...\n+ * https:\/\/stackoverflow.com\/questions\/7776448\/sfinae-tried-with-bool-gives-compiler-error-template-argument-tvalue-invol\n+ *\/\n+\n+template<bool> struct _hb_bool_type {};\n+\n+template <typename T, typename B>\n+struct _hb_null_size\n+{ enum { value = sizeof (T) }; };\n+template <typename T>\n+struct _hb_null_size<T, _hb_bool_type<(bool) (1 + (unsigned int) T::min_size)> >\n+{ enum { value = T::null_size }; };\n+\n+template <typename T>\n+struct hb_null_size\n+{ enum { value = _hb_null_size<T, _hb_bool_type<true> >::value }; };\n+#define hb_null_size(T) hb_null_size<T>::value\n+\n+\/* These doesn't belong here, but since is copy\/paste from above, put it here. *\/\n+\n+\/* hb_static_size (T)\n+ * Returns T::static_size if T::min_size is defined, or sizeof (T) otherwise. *\/\n+\n+template <typename T, typename B>\n+struct _hb_static_size\n+{ enum { value = sizeof (T) }; };\n+template <typename T>\n+struct _hb_static_size<T, _hb_bool_type<(bool) (1 + (unsigned int) T::min_size)> >\n+{ enum { value = T::static_size }; };\n+\n+template <typename T>\n+struct hb_static_size\n+{ enum { value = _hb_static_size<T, _hb_bool_type<true> >::value }; };\n+#define hb_static_size(T) hb_static_size<T>::value\n+\n+\n+\/* hb_assign (obj, value)\n+ * Calls obj.set (value) if obj.min_size is defined and value has different type\n+ * from obj, or obj = v otherwise. *\/\n+\n+template <typename T, typename V, typename B>\n+struct _hb_assign\n+\/\/ add cast to please AIX xlc12.1\n+\/\/{ static inline void value (T &o, const V v) { o = v; } };\n+{ static inline void value (T &o, const V v) { o = (T&) v; } };\n+template <typename T, typename V>\n+struct _hb_assign<T, V, _hb_bool_type<(bool) (1 + (unsigned int) T::min_size)> >\n+{ static inline void value (T &o, const V v) { o.set (v); } };\n+template <typename T>\n+struct _hb_assign<T, T, _hb_bool_type<(bool) (1 + (unsigned int) T::min_size)> >\n+{ static inline void value (T &o, const T v) { o = v; } };\n+\n+template <typename T, typename V>\n+static inline void hb_assign (T &o, const V v)\n+{ _hb_assign<T, V, _hb_bool_type<true> >::value (o, v); }\n+\n+\n+\/*\n+ * Null()\n+ *\/\n+\n+extern HB_INTERNAL\n+hb_vector_size_impl_t const _hb_NullPool[(HB_NULL_POOL_SIZE + sizeof (hb_vector_size_impl_t) - 1) \/ sizeof (hb_vector_size_impl_t)];\n+\n+\/* Generic nul-content Null objects. *\/\n+template <typename Type>\n+static inline Type const & Null () {\n+  static_assert (hb_null_size (Type) <= HB_NULL_POOL_SIZE, \"Increase HB_NULL_POOL_SIZE.\");\n+  return *reinterpret_cast<Type const *> (_hb_NullPool);\n+}\n+template <typename QType>\n+struct NullHelper\n+{\n+  typedef typename hb_remove_const (typename hb_remove_reference (QType)) Type;\n+  static const Type & get_null () { return Null<Type> (); }\n+};\n+#define Null(Type) NullHelper<Type>::get_null ()\n+\n+\/* Specializations for arbitrary-content Null objects expressed in bytes. *\/\n+#define DECLARE_NULL_NAMESPACE_BYTES(Namespace, Type) \\\n+        } \/* Close namespace. *\/ \\\n+        extern HB_INTERNAL const unsigned char _hb_Null_##Namespace##_##Type[Namespace::Type::null_size]; \\\n+        template <> \\\n+        \/*static*\/ inline const Namespace::Type& Null<Namespace::Type> () { \\\n+          return *reinterpret_cast<const Namespace::Type *> (_hb_Null_##Namespace##_##Type); \\\n+        } \\\n+        namespace Namespace { \\\n+        static_assert (true, \"Just so we take semicolon after.\")\n+#define DEFINE_NULL_NAMESPACE_BYTES(Namespace, Type) \\\n+        const unsigned char _hb_Null_##Namespace##_##Type[Namespace::Type::null_size]\n+\n+\/* Specializations for arbitrary-content Null objects expressed as struct initializer. *\/\n+#define DECLARE_NULL_INSTANCE(Type) \\\n+        extern HB_INTERNAL const Type _hb_Null_##Type; \\\n+        template <> \\\n+        \/*static*\/ inline const Type& Null<Type> () { \\\n+          return _hb_Null_##Type; \\\n+        } \\\n+static_assert (true, \"Just so we take semicolon after.\")\n+#define DEFINE_NULL_INSTANCE(Type) \\\n+        const Type _hb_Null_##Type\n+\n+\/* Global writable pool.  Enlarge as necessary. *\/\n+\n+\/* To be fully correct, CrapPool must be thread_local. However, we do not rely on CrapPool\n+ * for correct operation. It only exist to catch and divert program logic bugs instead of\n+ * causing bad memory access. So, races there are not actually introducing incorrectness\n+ * in the code. Has ~12kb binary size overhead to have it, also clang build fails with it. *\/\n+extern HB_INTERNAL\n+\/*thread_local*\/ hb_vector_size_impl_t _hb_CrapPool[(HB_NULL_POOL_SIZE + sizeof (hb_vector_size_impl_t) - 1) \/ sizeof (hb_vector_size_impl_t)];\n+\n+\/* CRAP pool: Common Region for Access Protection. *\/\n+template <typename Type>\n+static inline Type& Crap () {\n+  static_assert (hb_null_size (Type) <= HB_NULL_POOL_SIZE, \"Increase HB_NULL_POOL_SIZE.\");\n+  Type *obj = reinterpret_cast<Type *> (_hb_CrapPool);\n+  memcpy (obj, &Null(Type), sizeof (*obj));\n+  return *obj;\n+}\n+template <typename QType>\n+struct CrapHelper\n+{\n+  typedef typename hb_remove_const (typename hb_remove_reference (QType)) Type;\n+  static Type & get_crap () { return Crap<Type> (); }\n+};\n+#define Crap(Type) CrapHelper<Type>::get_crap ()\n+\n+template <typename Type>\n+struct CrapOrNullHelper {\n+  static Type & get () { return Crap(Type); }\n+};\n+template <typename Type>\n+struct CrapOrNullHelper<const Type> {\n+  static const Type & get () { return Null(Type); }\n+};\n+#define CrapOrNull(Type) CrapOrNullHelper<Type>::get ()\n+\n+\n+\/*\n+ * hb_nonnull_ptr_t\n+ *\/\n+\n+template <typename P>\n+struct hb_nonnull_ptr_t\n+{\n+  typedef typename hb_remove_pointer (P) T;\n+\n+  hb_nonnull_ptr_t (T *v_ = nullptr) : v (v_) {}\n+  T * operator = (T *v_)   { return v = v_; }\n+  T * operator -> () const { return get (); }\n+  T & operator * () const  { return *get (); }\n+  T ** operator & () const { return &v; }\n+  \/* Only auto-cast to const types. *\/\n+  template <typename C> operator const C * () const { return get (); }\n+  operator const char * () const { return (const char *) get (); }\n+  T * get () const { return v ? v : const_cast<T *> (&Null(T)); }\n+  T * get_raw () const { return v; }\n+\n+  T *v;\n+};\n+\n+\n+#endif \/* HB_NULL_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-null.hh","additions":206,"deletions":0,"binary":false,"changes":206,"status":"added"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright © 2007  Chris Wilson\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Contributor(s):\n+ *      Chris Wilson <chris@chris-wilson.co.uk>\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OBJECT_HH\n+#define HB_OBJECT_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-atomic.hh\"\n+#include \"hb-mutex.hh\"\n+#include \"hb-vector.hh\"\n+\n+\n+\/*\n+ * Lockable set\n+ *\/\n+\n+template <typename item_t, typename lock_t>\n+struct hb_lockable_set_t\n+{\n+  hb_vector_t<item_t> items;\n+\n+  void init () { items.init (); }\n+\n+  template <typename T>\n+  item_t *replace_or_insert (T v, lock_t &l, bool replace)\n+  {\n+    l.lock ();\n+    item_t *item = items.find (v);\n+    if (item) {\n+      if (replace) {\n+        item_t old = *item;\n+        *item = v;\n+        l.unlock ();\n+        old.fini ();\n+      }\n+      else {\n+        item = nullptr;\n+        l.unlock ();\n+      }\n+    } else {\n+      item = items.push (v);\n+      l.unlock ();\n+    }\n+    return item;\n+  }\n+\n+  template <typename T>\n+  void remove (T v, lock_t &l)\n+  {\n+    l.lock ();\n+    item_t *item = items.find (v);\n+    if (item)\n+    {\n+      item_t old = *item;\n+      *item = items[items.length - 1];\n+      items.pop ();\n+      l.unlock ();\n+      old.fini ();\n+    } else {\n+      l.unlock ();\n+    }\n+  }\n+\n+  template <typename T>\n+  bool find (T v, item_t *i, lock_t &l)\n+  {\n+    l.lock ();\n+    item_t *item = items.find (v);\n+    if (item)\n+      *i = *item;\n+    l.unlock ();\n+    return !!item;\n+  }\n+\n+  template <typename T>\n+  item_t *find_or_insert (T v, lock_t &l)\n+  {\n+    l.lock ();\n+    item_t *item = items.find (v);\n+    if (!item) {\n+      item = items.push (v);\n+    }\n+    l.unlock ();\n+    return item;\n+  }\n+\n+  void fini (lock_t &l)\n+  {\n+    if (!items.length)\n+    {\n+      \/* No need to lock. *\/\n+      items.fini ();\n+      return;\n+    }\n+    l.lock ();\n+    while (items.length)\n+    {\n+      item_t old = items[items.length - 1];\n+      items.pop ();\n+      l.unlock ();\n+      old.fini ();\n+      l.lock ();\n+    }\n+    items.fini ();\n+    l.unlock ();\n+  }\n+\n+};\n+\n+\n+\/*\n+ * Reference-count.\n+ *\/\n+\n+#define HB_REFERENCE_COUNT_INERT_VALUE 0\n+#define HB_REFERENCE_COUNT_POISON_VALUE -0x0000DEAD\n+#define HB_REFERENCE_COUNT_INIT {HB_ATOMIC_INT_INIT (HB_REFERENCE_COUNT_INERT_VALUE)}\n+\n+struct hb_reference_count_t\n+{\n+  mutable hb_atomic_int_t ref_count;\n+\n+  void init (int v = 1) { ref_count.set_relaxed (v); }\n+  int get_relaxed () const { return ref_count.get_relaxed (); }\n+  int inc () const { return ref_count.inc (); }\n+  int dec () const { return ref_count.dec (); }\n+  void fini () { ref_count.set_relaxed (HB_REFERENCE_COUNT_POISON_VALUE); }\n+\n+  bool is_inert () const { return ref_count.get_relaxed () == HB_REFERENCE_COUNT_INERT_VALUE; }\n+  bool is_valid () const { return ref_count.get_relaxed () > 0; }\n+};\n+\n+\n+\/* user_data *\/\n+\n+struct hb_user_data_array_t\n+{\n+  struct hb_user_data_item_t {\n+    hb_user_data_key_t *key;\n+    void *data;\n+    hb_destroy_func_t destroy;\n+\n+    bool operator == (hb_user_data_key_t *other_key) const { return key == other_key; }\n+    bool operator == (hb_user_data_item_t &other) const { return key == other.key; }\n+\n+    void fini () { if (destroy) destroy (data); }\n+  };\n+\n+  hb_mutex_t lock;\n+  hb_lockable_set_t<hb_user_data_item_t, hb_mutex_t> items;\n+\n+  void init () { lock.init (); items.init (); }\n+\n+  HB_INTERNAL bool set (hb_user_data_key_t *key,\n+                        void *              data,\n+                        hb_destroy_func_t   destroy,\n+                        hb_bool_t           replace);\n+\n+  HB_INTERNAL void *get (hb_user_data_key_t *key);\n+\n+  void fini () { items.fini (lock); lock.fini (); }\n+};\n+\n+\n+\/*\n+ * Object header\n+ *\/\n+\n+struct hb_object_header_t\n+{\n+  hb_reference_count_t ref_count;\n+  mutable hb_atomic_int_t writable;\n+  hb_atomic_ptr_t<hb_user_data_array_t> user_data;\n+};\n+#define HB_OBJECT_HEADER_STATIC \\\n+        { \\\n+          HB_REFERENCE_COUNT_INIT, \\\n+          HB_ATOMIC_INT_INIT (false), \\\n+          HB_ATOMIC_PTR_INIT (nullptr) \\\n+        }\n+\n+\n+\/*\n+ * Object\n+ *\/\n+\n+template <typename Type>\n+static inline void hb_object_trace (const Type *obj, const char *function)\n+{\n+  DEBUG_MSG (OBJECT, (void *) obj,\n+             \"%s refcount=%d\",\n+             function,\n+             obj ? obj->header.ref_count.get_relaxed () : 0);\n+}\n+\n+template <typename Type>\n+static inline Type *hb_object_create ()\n+{\n+  Type *obj = (Type *) calloc (1, sizeof (Type));\n+\n+  if (unlikely (!obj))\n+    return obj;\n+\n+  hb_object_init (obj);\n+  hb_object_trace (obj, HB_FUNC);\n+  return obj;\n+}\n+template <typename Type>\n+static inline void hb_object_init (Type *obj)\n+{\n+  obj->header.ref_count.init ();\n+  obj->header.writable.set_relaxed (true);\n+  obj->header.user_data.init ();\n+}\n+template <typename Type>\n+static inline bool hb_object_is_inert (const Type *obj)\n+{\n+  return unlikely (obj->header.ref_count.is_inert ());\n+}\n+template <typename Type>\n+static inline bool hb_object_is_valid (const Type *obj)\n+{\n+  return likely (obj->header.ref_count.is_valid ());\n+}\n+template <typename Type>\n+static inline bool hb_object_is_immutable (const Type *obj)\n+{\n+  return !obj->header.writable.get_relaxed ();\n+}\n+template <typename Type>\n+static inline void hb_object_make_immutable (const Type *obj)\n+{\n+  obj->header.writable.set_relaxed (false);\n+}\n+template <typename Type>\n+static inline Type *hb_object_reference (Type *obj)\n+{\n+  hb_object_trace (obj, HB_FUNC);\n+  if (unlikely (!obj || hb_object_is_inert (obj)))\n+    return obj;\n+  assert (hb_object_is_valid (obj));\n+  obj->header.ref_count.inc ();\n+  return obj;\n+}\n+template <typename Type>\n+static inline bool hb_object_destroy (Type *obj)\n+{\n+  hb_object_trace (obj, HB_FUNC);\n+  if (unlikely (!obj || hb_object_is_inert (obj)))\n+    return false;\n+  assert (hb_object_is_valid (obj));\n+  if (obj->header.ref_count.dec () != 1)\n+    return false;\n+\n+  hb_object_fini (obj);\n+  return true;\n+}\n+template <typename Type>\n+static inline void hb_object_fini (Type *obj)\n+{\n+  obj->header.ref_count.fini (); \/* Do this before user_data *\/\n+  hb_user_data_array_t *user_data = obj->header.user_data.get ();\n+  if (user_data)\n+  {\n+    user_data->fini ();\n+    free (user_data);\n+    user_data = nullptr;\n+  }\n+}\n+template <typename Type>\n+static inline bool hb_object_set_user_data (Type               *obj,\n+                                            hb_user_data_key_t *key,\n+                                            void *              data,\n+                                            hb_destroy_func_t   destroy,\n+                                            hb_bool_t           replace)\n+{\n+  if (unlikely (!obj || hb_object_is_inert (obj)))\n+    return false;\n+  assert (hb_object_is_valid (obj));\n+\n+retry:\n+  hb_user_data_array_t *user_data = obj->header.user_data.get ();\n+  if (unlikely (!user_data))\n+  {\n+    user_data = (hb_user_data_array_t *) calloc (sizeof (hb_user_data_array_t), 1);\n+    if (unlikely (!user_data))\n+      return false;\n+    user_data->init ();\n+    if (unlikely (!obj->header.user_data.cmpexch (nullptr, user_data)))\n+    {\n+      user_data->fini ();\n+      free (user_data);\n+      goto retry;\n+    }\n+  }\n+\n+  return user_data->set (key, data, destroy, replace);\n+}\n+\n+template <typename Type>\n+static inline void *hb_object_get_user_data (Type               *obj,\n+                                             hb_user_data_key_t *key)\n+{\n+  if (unlikely (!obj || hb_object_is_inert (obj)))\n+    return nullptr;\n+  assert (hb_object_is_valid (obj));\n+  hb_user_data_array_t *user_data = obj->header.user_data.get ();\n+  if (!user_data)\n+    return nullptr;\n+  return user_data->get (key);\n+}\n+\n+\n+#endif \/* HB_OBJECT_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-object.hh","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -0,0 +1,525 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OPEN_FILE_HH\n+#define HB_OPEN_FILE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-head-table.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/*\n+ *\n+ * The OpenType Font File\n+ *\n+ *\/\n+\n+\n+\/*\n+ * Organization of an OpenType Font\n+ *\/\n+\n+struct OpenTypeFontFile;\n+struct OffsetTable;\n+struct TTCHeader;\n+\n+\n+typedef struct TableRecord\n+{\n+  int cmp (Tag t) const { return -t.cmp (tag); }\n+\n+  static int cmp (const void *pa, const void *pb)\n+  {\n+    const TableRecord *a = (const TableRecord *) pa;\n+    const TableRecord *b = (const TableRecord *) pb;\n+    return b->cmp (a->tag);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  Tag           tag;            \/* 4-byte identifier. *\/\n+  CheckSum      checkSum;       \/* CheckSum for this table. *\/\n+  Offset32      offset;         \/* Offset from beginning of TrueType font\n+                                 * file. *\/\n+  HBUINT32      length;         \/* Length of this table. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (16);\n+} OpenTypeTable;\n+\n+typedef struct OffsetTable\n+{\n+  friend struct OpenTypeFontFile;\n+\n+  unsigned int get_table_count () const { return tables.len; }\n+  const TableRecord& get_table (unsigned int i) const\n+  { return tables[i]; }\n+  unsigned int get_table_tags (unsigned int  start_offset,\n+                                      unsigned int *table_count, \/* IN\/OUT *\/\n+                                      hb_tag_t     *table_tags \/* OUT *\/) const\n+  {\n+    if (table_count)\n+    {\n+      if (start_offset >= tables.len)\n+        *table_count = 0;\n+      else\n+        *table_count = MIN<unsigned int> (*table_count, tables.len - start_offset);\n+\n+      const TableRecord *sub_tables = tables.arrayZ + start_offset;\n+      unsigned int count = *table_count;\n+      for (unsigned int i = 0; i < count; i++)\n+        table_tags[i] = sub_tables[i].tag;\n+    }\n+    return tables.len;\n+  }\n+  bool find_table_index (hb_tag_t tag, unsigned int *table_index) const\n+  {\n+    Tag t;\n+    t.set (tag);\n+    return tables.bfind (t, table_index, HB_BFIND_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n+  }\n+  const TableRecord& get_table_by_tag (hb_tag_t tag) const\n+  {\n+    unsigned int table_index;\n+    find_table_index (tag, &table_index);\n+    return get_table (table_index);\n+  }\n+\n+  public:\n+\n+  template <typename item_t>\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_tag_t sfnt_tag,\n+                  hb_array_t<item_t> items)\n+  {\n+    TRACE_SERIALIZE (this);\n+    \/* Alloc 12 for the OTHeader. *\/\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    \/* Write sfntVersion (bytes 0..3). *\/\n+    sfnt_version.set (sfnt_tag);\n+    \/* Take space for numTables, searchRange, entrySelector, RangeShift\n+     * and the TableRecords themselves.  *\/\n+    if (unlikely (!tables.serialize (c, items.length))) return_trace (false);\n+\n+    const char *dir_end = (const char *) c->head;\n+    HBUINT32 *checksum_adjustment = nullptr;\n+\n+    \/* Write OffsetTables, alloc for and write actual table blobs. *\/\n+    for (unsigned int i = 0; i < tables.len; i++)\n+    {\n+      TableRecord &rec = tables.arrayZ[i];\n+      hb_blob_t *blob = items[i].blob;\n+      rec.tag.set (items[i].tag);\n+      rec.length.set (hb_blob_get_length (blob));\n+      rec.offset.serialize (c, this);\n+\n+      \/* Allocate room for the table and copy it. *\/\n+      char *start = (char *) c->allocate_size<void> (rec.length);\n+      if (unlikely (!start)) {return false;}\n+\n+      memcpy (start, hb_blob_get_data (blob, nullptr), rec.length);\n+\n+      \/* 4-byte alignment. *\/\n+      c->align (4);\n+      const char *end = (const char *) c->head;\n+\n+      if (items[i].tag == HB_OT_TAG_head &&\n+          (unsigned) (end - start) >= head::static_size)\n+      {\n+        head *h = (head *) start;\n+        checksum_adjustment = &h->checkSumAdjustment;\n+        checksum_adjustment->set (0);\n+      }\n+\n+      rec.checkSum.set_for_data (start, end - start);\n+    }\n+\n+    tables.qsort ();\n+\n+    if (checksum_adjustment)\n+    {\n+      CheckSum checksum;\n+\n+      \/* The following line is a slower version of the following block. *\/\n+      \/\/checksum.set_for_data (this, (const char *) c->head - (const char *) this);\n+      checksum.set_for_data (this, dir_end - (const char *) this);\n+      for (unsigned int i = 0; i < items.length; i++)\n+      {\n+        TableRecord &rec = tables.arrayZ[i];\n+        checksum.set (checksum + rec.checkSum);\n+      }\n+\n+      checksum_adjustment->set (0xB1B0AFBAu - checksum);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && tables.sanitize (c));\n+  }\n+\n+  protected:\n+  Tag           sfnt_version;   \/* '\\0\\001\\0\\00' if TrueType \/ 'OTTO' if CFF *\/\n+  BinSearchArrayOf<TableRecord>\n+                tables;\n+  public:\n+  DEFINE_SIZE_ARRAY (12, tables);\n+} OpenTypeFontFace;\n+\n+\n+\/*\n+ * TrueType Collections\n+ *\/\n+\n+struct TTCHeaderVersion1\n+{\n+  friend struct TTCHeader;\n+\n+  unsigned int get_face_count () const { return table.len; }\n+  const OpenTypeFontFace& get_face (unsigned int i) const { return this+table[i]; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (table.sanitize (c, this));\n+  }\n+\n+  protected:\n+  Tag           ttcTag;         \/* TrueType Collection ID string: 'ttcf' *\/\n+  FixedVersion<>version;        \/* Version of the TTC Header (1.0),\n+                                 * 0x00010000u *\/\n+  LArrayOf<LOffsetTo<OffsetTable> >\n+                table;          \/* Array of offsets to the OffsetTable for each font\n+                                 * from the beginning of the file *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (12, table);\n+};\n+\n+struct TTCHeader\n+{\n+  friend struct OpenTypeFontFile;\n+\n+  private:\n+\n+  unsigned int get_face_count () const\n+  {\n+    switch (u.header.version.major) {\n+    case 2: \/* version 2 is compatible with version 1 *\/\n+    case 1: return u.version1.get_face_count ();\n+    default:return 0;\n+    }\n+  }\n+  const OpenTypeFontFace& get_face (unsigned int i) const\n+  {\n+    switch (u.header.version.major) {\n+    case 2: \/* version 2 is compatible with version 1 *\/\n+    case 1: return u.version1.get_face (i);\n+    default:return Null(OpenTypeFontFace);\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!u.header.version.sanitize (c))) return_trace (false);\n+    switch (u.header.version.major) {\n+    case 2: \/* version 2 is compatible with version 1 *\/\n+    case 1: return_trace (u.version1.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  struct {\n+  Tag           ttcTag;         \/* TrueType Collection ID string: 'ttcf' *\/\n+  FixedVersion<>version;        \/* Version of the TTC Header (1.0 or 2.0),\n+                                 * 0x00010000u or 0x00020000u *\/\n+  }                     header;\n+  TTCHeaderVersion1     version1;\n+  } u;\n+};\n+\n+\/*\n+ * Mac Resource Fork\n+ *\n+ * http:\/\/mirror.informatimago.com\/next\/developer.apple.com\/documentation\/mac\/MoreToolbox\/MoreToolbox-99.html\n+ *\/\n+\n+struct ResourceRecord\n+{\n+  const OpenTypeFontFace & get_face (const void *data_base) const\n+  { return CastR<OpenTypeFontFace> ((data_base+offset).arrayZ); }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                        const void *data_base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  offset.sanitize (c, data_base) &&\n+                  get_face (data_base).sanitize (c));\n+  }\n+\n+  protected:\n+  HBUINT16      id;             \/* Resource ID. *\/\n+  HBINT16       nameOffset;     \/* Offset from beginning of resource name list\n+                                 * to resource name, -1 means there is none. *\/\n+  HBUINT8       attrs;          \/* Resource attributes *\/\n+  NNOffsetTo<LArrayOf<HBUINT8>, HBUINT24>\n+                offset;         \/* Offset from beginning of data block to\n+                                 * data for this resource *\/\n+  HBUINT32      reserved;       \/* Reserved for handle to resource *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+#define HB_TAG_sfnt HB_TAG ('s','f','n','t')\n+\n+struct ResourceTypeRecord\n+{\n+  unsigned int get_resource_count () const\n+  { return tag == HB_TAG_sfnt ? resCountM1 + 1 : 0; }\n+\n+  bool is_sfnt () const { return tag == HB_TAG_sfnt; }\n+\n+  const ResourceRecord& get_resource_record (unsigned int i,\n+                                             const void *type_base) const\n+  { return (type_base+resourcesZ).as_array (get_resource_count ())[i]; }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const void *type_base,\n+                 const void *data_base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  resourcesZ.sanitize (c, type_base,\n+                                       get_resource_count (),\n+                                       data_base));\n+  }\n+\n+  protected:\n+  Tag           tag;            \/* Resource type. *\/\n+  HBUINT16      resCountM1;     \/* Number of resources minus 1. *\/\n+  NNOffsetTo<UnsizedArrayOf<ResourceRecord> >\n+                resourcesZ;     \/* Offset from beginning of resource type list\n+                                 * to reference item list for this type. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct ResourceMap\n+{\n+  unsigned int get_face_count () const\n+  {\n+    unsigned int count = get_type_count ();\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      const ResourceTypeRecord& type = get_type_record (i);\n+      if (type.is_sfnt ())\n+        return type.get_resource_count ();\n+    }\n+    return 0;\n+  }\n+\n+  const OpenTypeFontFace& get_face (unsigned int idx,\n+                                    const void *data_base) const\n+  {\n+    unsigned int count = get_type_count ();\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      const ResourceTypeRecord& type = get_type_record (i);\n+      \/* The check for idx < count is here because ResourceRecord is NOT null-safe.\n+       * Because an offset of 0 there does NOT mean null. *\/\n+      if (type.is_sfnt () && idx < type.get_resource_count ())\n+        return type.get_resource_record (idx, &(this+typeList)).get_face (data_base);\n+    }\n+    return Null (OpenTypeFontFace);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *data_base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  typeList.sanitize (c, this,\n+                                     &(this+typeList),\n+                                     data_base));\n+  }\n+\n+  private:\n+  unsigned int get_type_count () const { return (this+typeList).lenM1 + 1; }\n+\n+  const ResourceTypeRecord& get_type_record (unsigned int i) const\n+  { return (this+typeList)[i]; }\n+\n+  protected:\n+  HBUINT8       reserved0[16];  \/* Reserved for copy of resource header *\/\n+  HBUINT32      reserved1;      \/* Reserved for handle to next resource map *\/\n+  HBUINT16      resreved2;      \/* Reserved for file reference number *\/\n+  HBUINT16      attrs;          \/* Resource fork attribute *\/\n+  NNOffsetTo<ArrayOfM1<ResourceTypeRecord> >\n+                typeList;       \/* Offset from beginning of map to\n+                                 * resource type list *\/\n+  Offset16      nameList;       \/* Offset from beginning of map to\n+                                 * resource name list *\/\n+  public:\n+  DEFINE_SIZE_STATIC (28);\n+};\n+\n+struct ResourceForkHeader\n+{\n+  unsigned int get_face_count () const\n+  { return (this+map).get_face_count (); }\n+\n+  const OpenTypeFontFace& get_face (unsigned int idx,\n+                                    unsigned int *base_offset = nullptr) const\n+  {\n+    const OpenTypeFontFace &face = (this+map).get_face (idx, &(this+data));\n+    if (base_offset)\n+      *base_offset = (const char *) &face - (const char *) this;\n+    return face;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  data.sanitize (c, this, dataLen) &&\n+                  map.sanitize (c, this, &(this+data)));\n+  }\n+\n+  protected:\n+  LNNOffsetTo<UnsizedArrayOf<HBUINT8> >\n+                data;           \/* Offset from beginning of resource fork\n+                                 * to resource data *\/\n+  LNNOffsetTo<ResourceMap >\n+                map;            \/* Offset from beginning of resource fork\n+                                 * to resource map *\/\n+  HBUINT32      dataLen;        \/* Length of resource data *\/\n+  HBUINT32      mapLen;         \/* Length of resource map *\/\n+  public:\n+  DEFINE_SIZE_STATIC (16);\n+};\n+\n+\/*\n+ * OpenType Font File\n+ *\/\n+\n+struct OpenTypeFontFile\n+{\n+  enum {\n+    CFFTag              = HB_TAG ('O','T','T','O'), \/* OpenType with Postscript outlines *\/\n+    TrueTypeTag         = HB_TAG ( 0 , 1 , 0 , 0 ), \/* OpenType with TrueType outlines *\/\n+    TTCTag              = HB_TAG ('t','t','c','f'), \/* TrueType Collection *\/\n+    DFontTag            = HB_TAG ( 0 , 0 , 1 , 0 ), \/* DFont Mac Resource Fork *\/\n+    TrueTag             = HB_TAG ('t','r','u','e'), \/* Obsolete Apple TrueType *\/\n+    Typ1Tag             = HB_TAG ('t','y','p','1')  \/* Obsolete Apple Type1 font in SFNT container *\/\n+  };\n+\n+  hb_tag_t get_tag () const { return u.tag; }\n+\n+  unsigned int get_face_count () const\n+  {\n+    switch (u.tag) {\n+    case CFFTag:        \/* All the non-collection tags *\/\n+    case TrueTag:\n+    case Typ1Tag:\n+    case TrueTypeTag:   return 1;\n+    case TTCTag:        return u.ttcHeader.get_face_count ();\n+    case DFontTag:      return u.rfHeader.get_face_count ();\n+    default:            return 0;\n+    }\n+  }\n+  const OpenTypeFontFace& get_face (unsigned int i, unsigned int *base_offset = nullptr) const\n+  {\n+    if (base_offset)\n+      *base_offset = 0;\n+    switch (u.tag) {\n+    \/* Note: for non-collection SFNT data we ignore index.  This is because\n+     * Apple dfont container is a container of SFNT's.  So each SFNT is a\n+     * non-TTC, but the index is more than zero. *\/\n+    case CFFTag:        \/* All the non-collection tags *\/\n+    case TrueTag:\n+    case Typ1Tag:\n+    case TrueTypeTag:   return u.fontFace;\n+    case TTCTag:        return u.ttcHeader.get_face (i);\n+    case DFontTag:      return u.rfHeader.get_face (i, base_offset);\n+    default:            return Null(OpenTypeFontFace);\n+    }\n+  }\n+\n+  template <typename item_t>\n+  bool serialize_single (hb_serialize_context_t *c,\n+                         hb_tag_t sfnt_tag,\n+                         hb_array_t<item_t> items)\n+  {\n+    TRACE_SERIALIZE (this);\n+    assert (sfnt_tag != TTCTag);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    return_trace (u.fontFace.serialize (c, sfnt_tag, items));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!u.tag.sanitize (c))) return_trace (false);\n+    switch (u.tag) {\n+    case CFFTag:        \/* All the non-collection tags *\/\n+    case TrueTag:\n+    case Typ1Tag:\n+    case TrueTypeTag:   return_trace (u.fontFace.sanitize (c));\n+    case TTCTag:        return_trace (u.ttcHeader.sanitize (c));\n+    case DFontTag:      return_trace (u.rfHeader.sanitize (c));\n+    default:            return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  Tag                   tag;            \/* 4-byte identifier. *\/\n+  OpenTypeFontFace      fontFace;\n+  TTCHeader             ttcHeader;\n+  ResourceForkHeader    rfHeader;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (4, tag);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OPEN_FILE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-open-file.hh","additions":525,"deletions":0,"binary":false,"changes":525,"status":"added"},{"patch":"@@ -0,0 +1,1008 @@\n+\/*\n+ * Copyright © 2007,2008,2009,2010  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OPEN_TYPE_HH\n+#define HB_OPEN_TYPE_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-blob.hh\"\n+#include \"hb-face.hh\"\n+#include \"hb-machinery.hh\"\n+#include \"hb-subset.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/*\n+ *\n+ * The OpenType Font File: Data Types\n+ *\/\n+\n+\n+\/* \"The following data types are used in the OpenType font file.\n+ *  All OpenType fonts use Motorola-style byte ordering (Big Endian):\" *\/\n+\n+\/*\n+ * Int types\n+ *\/\n+\n+template <bool is_signed> struct hb_signedness_int;\n+template <> struct hb_signedness_int<false> { typedef unsigned int value; };\n+template <> struct hb_signedness_int<true>  { typedef   signed int value; };\n+\n+\/* Integer types in big-endian order and no alignment requirement *\/\n+template <typename Type, unsigned int Size>\n+struct IntType\n+{\n+  typedef Type type;\n+  typedef typename hb_signedness_int<hb_is_signed<Type>::value>::value wide_type;\n+\n+  void set (wide_type i) { v.set (i); }\n+  operator wide_type () const { return v; }\n+  bool operator == (const IntType<Type,Size> &o) const { return (Type) v == (Type) o.v; }\n+  bool operator != (const IntType<Type,Size> &o) const { return !(*this == o); }\n+  static int cmp (const IntType<Type,Size> *a, const IntType<Type,Size> *b) { return b->cmp (*a); }\n+  template <typename Type2>\n+  int cmp (Type2 a) const\n+  {\n+    Type b = v;\n+    if (sizeof (Type) < sizeof (int) && sizeof (Type2) < sizeof (int))\n+      return (int) a - (int) b;\n+    else\n+      return a < b ? -1 : a == b ? 0 : +1;\n+  }\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+  protected:\n+  BEInt<Type, Size> v;\n+  public:\n+  DEFINE_SIZE_STATIC (Size);\n+};\n+\n+typedef IntType<uint8_t,  1> HBUINT8;   \/* 8-bit unsigned integer. *\/\n+typedef IntType<int8_t,   1> HBINT8;    \/* 8-bit signed integer. *\/\n+typedef IntType<uint16_t, 2> HBUINT16;  \/* 16-bit unsigned integer. *\/\n+typedef IntType<int16_t,  2> HBINT16;   \/* 16-bit signed integer. *\/\n+typedef IntType<uint32_t, 4> HBUINT32;  \/* 32-bit unsigned integer. *\/\n+typedef IntType<int32_t,  4> HBINT32;   \/* 32-bit signed integer. *\/\n+\/* Note: we cannot defined a signed HBINT24 because there's no corresponding C type.\n+ * Works for unsigned, but not signed, since we rely on compiler for sign-extension. *\/\n+typedef IntType<uint32_t, 3> HBUINT24;  \/* 24-bit unsigned integer. *\/\n+\n+\/* 16-bit signed integer (HBINT16) that describes a quantity in FUnits. *\/\n+typedef HBINT16 FWORD;\n+\n+\/* 32-bit signed integer (HBINT32) that describes a quantity in FUnits. *\/\n+typedef HBINT32 FWORD32;\n+\n+\/* 16-bit unsigned integer (HBUINT16) that describes a quantity in FUnits. *\/\n+typedef HBUINT16 UFWORD;\n+\n+\/* 16-bit signed fixed number with the low 14 bits of fraction (2.14). *\/\n+struct F2DOT14 : HBINT16\n+{\n+  \/\/ 16384 means 1<<14\n+  float to_float () const  { return ((int32_t) v) \/ 16384.f; }\n+  void set_float (float f) { v.set (round (f * 16384.f)); }\n+  public:\n+  DEFINE_SIZE_STATIC (2);\n+};\n+\n+\/* 32-bit signed fixed-point number (16.16). *\/\n+struct Fixed : HBINT32\n+{\n+  \/\/ 65536 means 1<<16\n+  float to_float () const  { return ((int32_t) v) \/ 65536.f; }\n+  void set_float (float f) { v.set (round (f * 65536.f)); }\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+\/* Date represented in number of seconds since 12:00 midnight, January 1,\n+ * 1904. The value is represented as a signed 64-bit integer. *\/\n+struct LONGDATETIME\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+  protected:\n+  HBINT32 major;\n+  HBUINT32 minor;\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+\/* Array of four uint8s (length = 32 bits) used to identify a script, language\n+ * system, feature, or baseline *\/\n+struct Tag : HBUINT32\n+{\n+  \/* What the char* converters return is NOT nul-terminated.  Print using \"%.4s\" *\/\n+  operator const char* () const { return reinterpret_cast<const char *> (&this->v); }\n+  operator char* ()             { return reinterpret_cast<char *> (&this->v); }\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+\/* Glyph index number, same as uint16 (length = 16 bits) *\/\n+typedef HBUINT16 GlyphID;\n+\n+\/* Script\/language-system\/feature index *\/\n+struct Index : HBUINT16 {\n+  static constexpr unsigned NOT_FOUND_INDEX = 0xFFFFu;\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (OT, Index);\n+\n+typedef Index NameID;\n+\n+\/* Offset, Null offset = 0 *\/\n+template <typename Type, bool has_null=true>\n+struct Offset : Type\n+{\n+  typedef Type type;\n+\n+  bool is_null () const { return has_null && 0 == *this; }\n+\n+  void *serialize (hb_serialize_context_t *c, const void *base)\n+  {\n+    void *t = c->start_embed<void> ();\n+    this->set ((char *) t - (char *) base); \/* TODO(serialize) Overflow? *\/\n+    return t;\n+  }\n+\n+  public:\n+  DEFINE_SIZE_STATIC (sizeof (Type));\n+};\n+\n+typedef Offset<HBUINT16> Offset16;\n+typedef Offset<HBUINT32> Offset32;\n+\n+\n+\/* CheckSum *\/\n+struct CheckSum : HBUINT32\n+{\n+  \/* This is reference implementation from the spec. *\/\n+  static uint32_t CalcTableChecksum (const HBUINT32 *Table, uint32_t Length)\n+  {\n+    uint32_t Sum = 0L;\n+    assert (0 == (Length & 3));\n+    const HBUINT32 *EndPtr = Table + Length \/ HBUINT32::static_size;\n+\n+    while (Table < EndPtr)\n+      Sum += *Table++;\n+    return Sum;\n+  }\n+\n+  \/* Note: data should be 4byte aligned and have 4byte padding at the end. *\/\n+  void set_for_data (const void *data, unsigned int length)\n+  { set (CalcTableChecksum ((const HBUINT32 *) data, length)); }\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+\n+\/*\n+ * Version Numbers\n+ *\/\n+\n+template <typename FixedType=HBUINT16>\n+struct FixedVersion\n+{\n+  uint32_t to_int () const { return (major << (sizeof (FixedType) * 8)) + minor; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  FixedType major;\n+  FixedType minor;\n+  public:\n+  DEFINE_SIZE_STATIC (2 * sizeof (FixedType));\n+};\n+\n+\n+\/*\n+ * Template subclasses of Offset that do the dereferencing.\n+ * Use: (base+offset)\n+ *\/\n+\n+template <typename Type, bool has_null>\n+struct _hb_has_null\n+{\n+  static const Type *get_null () { return nullptr; }\n+  static Type *get_crap ()       { return nullptr; }\n+};\n+template <typename Type>\n+struct _hb_has_null<Type, true>\n+{\n+  static const Type *get_null () { return &Null(Type); }\n+  static Type *get_crap ()       { return &Crap(Type); }\n+};\n+\n+template <typename Type, typename OffsetType=HBUINT16, bool has_null=true>\n+struct OffsetTo : Offset<OffsetType, has_null>\n+{\n+  const Type& operator () (const void *base) const\n+  {\n+    if (unlikely (this->is_null ())) return *_hb_has_null<Type, has_null>::get_null ();\n+    return StructAtOffset<const Type> (base, *this);\n+  }\n+  Type& operator () (void *base) const\n+  {\n+    if (unlikely (this->is_null ())) return *_hb_has_null<Type, has_null>::get_crap ();\n+    return StructAtOffset<Type> (base, *this);\n+  }\n+\n+  Type& serialize (hb_serialize_context_t *c, const void *base)\n+  {\n+    return * (Type *) Offset<OffsetType>::serialize (c, base);\n+  }\n+\n+  template <typename T>\n+  void serialize_subset (hb_subset_context_t *c, const T &src, const void *base)\n+  {\n+    if (&src == &Null (T))\n+    {\n+      this->set (0);\n+      return;\n+    }\n+    serialize (c->serializer, base);\n+    if (!src.subset (c))\n+      this->set (0);\n+  }\n+\n+  bool sanitize_shallow (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this))) return_trace (false);\n+    if (unlikely (this->is_null ())) return_trace (true);\n+    if (unlikely (!c->check_range (base, *this))) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (sanitize_shallow (c, base) &&\n+                  (this->is_null () ||\n+                   StructAtOffset<Type> (base, *this).sanitize (c) ||\n+                   neuter (c)));\n+  }\n+  template <typename T1>\n+  bool sanitize (hb_sanitize_context_t *c, const void *base, T1 d1) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (sanitize_shallow (c, base) &&\n+                  (this->is_null () ||\n+                   StructAtOffset<Type> (base, *this).sanitize (c, d1) ||\n+                   neuter (c)));\n+  }\n+  template <typename T1, typename T2>\n+  bool sanitize (hb_sanitize_context_t *c, const void *base, T1 d1, T2 d2) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (sanitize_shallow (c, base) &&\n+                  (this->is_null () ||\n+                   StructAtOffset<Type> (base, *this).sanitize (c, d1, d2) ||\n+                   neuter (c)));\n+  }\n+  template <typename T1, typename T2, typename T3>\n+  bool sanitize (hb_sanitize_context_t *c, const void *base, T1 d1, T2 d2, T3 d3) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (sanitize_shallow (c, base) &&\n+                  (this->is_null () ||\n+                   StructAtOffset<Type> (base, *this).sanitize (c, d1, d2, d3) ||\n+                   neuter (c)));\n+  }\n+\n+  \/* Set the offset to Null *\/\n+  bool neuter (hb_sanitize_context_t *c) const\n+  {\n+    if (!has_null) return false;\n+    return c->try_set (this, 0);\n+  }\n+  DEFINE_SIZE_STATIC (sizeof (OffsetType));\n+};\n+\/* Partial specializations. *\/\n+template <typename Type,                               bool has_null=true> struct   LOffsetTo : OffsetTo<Type, HBUINT32,   has_null> {};\n+template <typename Type, typename OffsetType=HBUINT16                    > struct  NNOffsetTo : OffsetTo<Type, OffsetType, false> {};\n+template <typename Type                                                  > struct LNNOffsetTo : OffsetTo<Type, HBUINT32,   false> {};\n+\n+template <typename Base, typename OffsetType, bool has_null, typename Type>\n+static inline const Type& operator + (const Base &base, const OffsetTo<Type, OffsetType, has_null> &offset) { return offset (base); }\n+template <typename Base, typename OffsetType, bool has_null, typename Type>\n+static inline Type& operator + (Base &base, OffsetTo<Type, OffsetType, has_null> &offset) { return offset (base); }\n+\n+\n+\/*\n+ * Array Types\n+ *\/\n+\n+template <typename Type>\n+struct UnsizedArrayOf\n+{\n+  typedef Type item_t;\n+  static constexpr unsigned item_size = hb_static_size (Type);\n+\n+  HB_NO_CREATE_COPY_ASSIGN_TEMPLATE (UnsizedArrayOf, Type);\n+\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    const Type *p = &arrayZ[i];\n+    if (unlikely (p < arrayZ)) return Null (Type); \/* Overflowed. *\/\n+    return *p;\n+  }\n+  Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    Type *p = &arrayZ[i];\n+    if (unlikely (p < arrayZ)) return Crap (Type); \/* Overflowed. *\/\n+    return *p;\n+  }\n+\n+  unsigned int get_size (unsigned int len) const\n+  { return len * Type::static_size; }\n+\n+  template <typename T> operator T * () { return arrayZ; }\n+  template <typename T> operator const T * () const { return arrayZ; }\n+  hb_array_t<Type> as_array (unsigned int len)\n+  { return hb_array (arrayZ, len); }\n+  hb_array_t<const Type> as_array (unsigned int len) const\n+  { return hb_array (arrayZ, len); }\n+  operator hb_array_t<Type> ()             { return as_array (); }\n+  operator hb_array_t<const Type> () const { return as_array (); }\n+\n+  template <typename T>\n+  Type &lsearch (unsigned int len, const T &x, Type &not_found = Crap (Type))\n+  { return *as_array (len).lsearch (x, &not_found); }\n+  template <typename T>\n+  const Type &lsearch (unsigned int len, const T &x, const Type &not_found = Null (Type)) const\n+  { return *as_array (len).lsearch (x, &not_found); }\n+\n+  void qsort (unsigned int len, unsigned int start = 0, unsigned int end = (unsigned int) -1)\n+  { as_array (len).qsort (start, end); }\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c, count))) return_trace (false);\n+\n+    \/* Note: for structs that do not reference other structs,\n+     * we do not need to call their sanitize() as we already did\n+     * a bound check on the aggregate array size.  We just include\n+     * a small unreachable expression to make sure the structs\n+     * pointed to do have a simple sanitize(), ie. they do not\n+     * reference other structs via offsets.\n+     *\/\n+    (void) (false && arrayZ[0].sanitize (c));\n+\n+    return_trace (true);\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c, count))) return_trace (false);\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!arrayZ[i].sanitize (c, base)))\n+        return_trace (false);\n+    return_trace (true);\n+  }\n+  template <typename T>\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count, const void *base, T user_data) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c, count))) return_trace (false);\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!arrayZ[i].sanitize (c, base, user_data)))\n+        return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize_shallow (hb_sanitize_context_t *c, unsigned int count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_array (arrayZ, count));\n+  }\n+\n+  public:\n+  Type          arrayZ[VAR];\n+  public:\n+  DEFINE_SIZE_UNBOUNDED (0);\n+};\n+\n+\/* Unsized array of offset's *\/\n+template <typename Type, typename OffsetType, bool has_null=true>\n+struct UnsizedOffsetArrayOf : UnsizedArrayOf<OffsetTo<Type, OffsetType, has_null> > {};\n+\n+\/* Unsized array of offsets relative to the beginning of the array itself. *\/\n+template <typename Type, typename OffsetType, bool has_null=true>\n+struct UnsizedOffsetListOf : UnsizedOffsetArrayOf<Type, OffsetType, has_null>\n+{\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    const OffsetTo<Type, OffsetType, has_null> *p = &this->arrayZ[i];\n+    if (unlikely (p < this->arrayZ)) return Null (Type); \/* Overflowed. *\/\n+    return this+*p;\n+  }\n+  Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    const OffsetTo<Type, OffsetType, has_null> *p = &this->arrayZ[i];\n+    if (unlikely (p < this->arrayZ)) return Crap (Type); \/* Overflowed. *\/\n+    return this+*p;\n+  }\n+\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace ((UnsizedOffsetArrayOf<Type, OffsetType, has_null>::sanitize (c, count, this)));\n+  }\n+  template <typename T>\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count, T user_data) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace ((UnsizedOffsetArrayOf<Type, OffsetType, has_null>::sanitize (c, count, this, user_data)));\n+  }\n+};\n+\n+\/* An array with sorted elements.  Supports binary searching. *\/\n+template <typename Type>\n+struct SortedUnsizedArrayOf : UnsizedArrayOf<Type>\n+{\n+  hb_sorted_array_t<Type> as_array (unsigned int len)\n+  { return hb_sorted_array (this->arrayZ, len); }\n+  hb_sorted_array_t<const Type> as_array (unsigned int len) const\n+  { return hb_sorted_array (this->arrayZ, len); }\n+  operator hb_sorted_array_t<Type> ()             { return as_array (); }\n+  operator hb_sorted_array_t<const Type> () const { return as_array (); }\n+\n+  template <typename T>\n+  Type &bsearch (unsigned int len, const T &x, Type &not_found = Crap (Type))\n+  { return *as_array (len).bsearch (x, &not_found); }\n+  template <typename T>\n+  const Type &bsearch (unsigned int len, const T &x, const Type &not_found = Null (Type)) const\n+  { return *as_array (len).bsearch (x, &not_found); }\n+  template <typename T>\n+  bool bfind (unsigned int len, const T &x, unsigned int *i = nullptr,\n+                     hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+                     unsigned int to_store = (unsigned int) -1) const\n+  { return as_array (len).bfind (x, i, not_found, to_store); }\n+};\n+\n+\n+\/* An array with a number of elements. *\/\n+template <typename Type, typename LenType=HBUINT16>\n+struct ArrayOf\n+{\n+  typedef Type item_t;\n+  static constexpr unsigned item_size = hb_static_size (Type);\n+\n+  HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2 (ArrayOf, Type, LenType);\n+\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= len)) return Null (Type);\n+    return arrayZ[i];\n+  }\n+  Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= len)) return Crap (Type);\n+    return arrayZ[i];\n+  }\n+\n+  unsigned int get_size () const\n+  { return len.static_size + len * Type::static_size; }\n+\n+  hb_array_t<Type> as_array ()\n+  { return hb_array (arrayZ, len); }\n+  hb_array_t<const Type> as_array () const\n+  { return hb_array (arrayZ, len); }\n+  operator hb_array_t<Type> (void)             { return as_array (); }\n+  operator hb_array_t<const Type> (void) const { return as_array (); }\n+\n+  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int count) const\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int count)\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n+  { return as_array ().sub_array (start_offset, count);}\n+\n+  bool serialize (hb_serialize_context_t *c, unsigned int items_len)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    len.set (items_len); \/* TODO(serialize) Overflow? *\/\n+    if (unlikely (!c->extend (*this))) return_trace (false);\n+    return_trace (true);\n+  }\n+  template <typename T>\n+  bool serialize (hb_serialize_context_t *c, hb_array_t<const T> items)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!serialize (c, items.length))) return_trace (false);\n+    for (unsigned int i = 0; i < items.length; i++)\n+      hb_assign (arrayZ[i], items[i]);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+\n+    \/* Note: for structs that do not reference other structs,\n+     * we do not need to call their sanitize() as we already did\n+     * a bound check on the aggregate array size.  We just include\n+     * a small unreachable expression to make sure the structs\n+     * pointed to do have a simple sanitize(), ie. they do not\n+     * reference other structs via offsets.\n+     *\/\n+    (void) (false && arrayZ[0].sanitize (c));\n+\n+    return_trace (true);\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!arrayZ[i].sanitize (c, base)))\n+        return_trace (false);\n+    return_trace (true);\n+  }\n+  template <typename T>\n+  bool sanitize (hb_sanitize_context_t *c, const void *base, T user_data) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!arrayZ[i].sanitize (c, base, user_data)))\n+        return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  template <typename T>\n+  Type &lsearch (const T &x, Type &not_found = Crap (Type))\n+  { return *as_array ().lsearch (x, &not_found); }\n+  template <typename T>\n+  const Type &lsearch (const T &x, const Type &not_found = Null (Type)) const\n+  { return *as_array ().lsearch (x, &not_found); }\n+\n+  void qsort (unsigned int start = 0, unsigned int end = (unsigned int) -1)\n+  { as_array ().qsort (start, end); }\n+\n+  bool sanitize_shallow (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (len.sanitize (c) && c->check_array (arrayZ, len));\n+  }\n+\n+  public:\n+  LenType       len;\n+  Type          arrayZ[VAR];\n+  public:\n+  DEFINE_SIZE_ARRAY (sizeof (LenType), arrayZ);\n+};\n+template <typename Type> struct LArrayOf : ArrayOf<Type, HBUINT32> {};\n+typedef ArrayOf<HBUINT8, HBUINT8> PString;\n+\n+\/* Array of Offset's *\/\n+template <typename Type>\n+struct OffsetArrayOf : ArrayOf<OffsetTo<Type, HBUINT16> > {};\n+template <typename Type>\n+struct LOffsetArrayOf : ArrayOf<OffsetTo<Type, HBUINT32> > {};\n+template <typename Type>\n+struct LOffsetLArrayOf : ArrayOf<OffsetTo<Type, HBUINT32>, HBUINT32> {};\n+\n+\/* Array of offsets relative to the beginning of the array itself. *\/\n+template <typename Type>\n+struct OffsetListOf : OffsetArrayOf<Type>\n+{\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= this->len)) return Null (Type);\n+    return this+this->arrayZ[i];\n+  }\n+  const Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= this->len)) return Crap (Type);\n+    return this+this->arrayZ[i];\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    struct OffsetListOf<Type> *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    unsigned int count = this->len;\n+    for (unsigned int i = 0; i < count; i++)\n+      out->arrayZ[i].serialize_subset (c, (*this)[i], out);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (OffsetArrayOf<Type>::sanitize (c, this));\n+  }\n+  template <typename T>\n+  bool sanitize (hb_sanitize_context_t *c, T user_data) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (OffsetArrayOf<Type>::sanitize (c, this, user_data));\n+  }\n+};\n+\n+\/* An array starting at second element. *\/\n+template <typename Type, typename LenType=HBUINT16>\n+struct HeadlessArrayOf\n+{\n+  static constexpr unsigned item_size = Type::static_size;\n+\n+  HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2 (HeadlessArrayOf, Type, LenType);\n+\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= lenP1 || !i)) return Null (Type);\n+    return arrayZ[i-1];\n+  }\n+  Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= lenP1 || !i)) return Crap (Type);\n+    return arrayZ[i-1];\n+  }\n+  unsigned int get_size () const\n+  { return lenP1.static_size + (lenP1 ? lenP1 - 1 : 0) * Type::static_size; }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const Type> items)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    lenP1.set (items.length + 1); \/* TODO(serialize) Overflow? *\/\n+    if (unlikely (!c->extend (*this))) return_trace (false);\n+    for (unsigned int i = 0; i < items.length; i++)\n+      arrayZ[i] = items[i];\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+\n+    \/* Note: for structs that do not reference other structs,\n+     * we do not need to call their sanitize() as we already did\n+     * a bound check on the aggregate array size.  We just include\n+     * a small unreachable expression to make sure the structs\n+     * pointed to do have a simple sanitize(), ie. they do not\n+     * reference other structs via offsets.\n+     *\/\n+    (void) (false && arrayZ[0].sanitize (c));\n+\n+    return_trace (true);\n+  }\n+\n+  private:\n+  bool sanitize_shallow (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (lenP1.sanitize (c) &&\n+                  (!lenP1 || c->check_array (arrayZ, lenP1 - 1)));\n+  }\n+\n+  public:\n+  LenType       lenP1;\n+  Type          arrayZ[VAR];\n+  public:\n+  DEFINE_SIZE_ARRAY (sizeof (LenType), arrayZ);\n+};\n+\n+\/* An array storing length-1. *\/\n+template <typename Type, typename LenType=HBUINT16>\n+struct ArrayOfM1\n+{\n+  HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2 (ArrayOfM1, Type, LenType);\n+\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i > lenM1)) return Null (Type);\n+    return arrayZ[i];\n+  }\n+  Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i > lenM1)) return Crap (Type);\n+    return arrayZ[i];\n+  }\n+  unsigned int get_size () const\n+  { return lenM1.static_size + (lenM1 + 1) * Type::static_size; }\n+\n+  template <typename T>\n+  bool sanitize (hb_sanitize_context_t *c, const void *base, T user_data) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+    unsigned int count = lenM1 + 1;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!arrayZ[i].sanitize (c, base, user_data)))\n+        return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  private:\n+  bool sanitize_shallow (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (lenM1.sanitize (c) &&\n+                  (c->check_array (arrayZ, lenM1 + 1)));\n+  }\n+\n+  public:\n+  LenType       lenM1;\n+  Type          arrayZ[VAR];\n+  public:\n+  DEFINE_SIZE_ARRAY (sizeof (LenType), arrayZ);\n+};\n+\n+\/* An array with sorted elements.  Supports binary searching. *\/\n+template <typename Type, typename LenType=HBUINT16>\n+struct SortedArrayOf : ArrayOf<Type, LenType>\n+{\n+  hb_sorted_array_t<Type> as_array ()\n+  { return hb_sorted_array (this->arrayZ, this->len); }\n+  hb_sorted_array_t<const Type> as_array () const\n+  { return hb_sorted_array (this->arrayZ, this->len); }\n+  operator hb_sorted_array_t<Type> ()             { return as_array (); }\n+  operator hb_sorted_array_t<const Type> () const { return as_array (); }\n+\n+  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int count) const\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int count)\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n+  { return as_array ().sub_array (start_offset, count);}\n+\n+  template <typename T>\n+  Type &bsearch (const T &x, Type &not_found = Crap (Type))\n+  { return *as_array ().bsearch (x, &not_found); }\n+  template <typename T>\n+  const Type &bsearch (const T &x, const Type &not_found = Null (Type)) const\n+  { return *as_array ().bsearch (x, &not_found); }\n+  template <typename T>\n+  bool bfind (const T &x, unsigned int *i = nullptr,\n+                     hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+                     unsigned int to_store = (unsigned int) -1) const\n+  { return as_array ().bfind (x, i, not_found, to_store); }\n+};\n+\n+\/*\n+ * Binary-search arrays\n+ *\/\n+\n+template <typename LenType=HBUINT16>\n+struct BinSearchHeader\n+{\n+  operator uint32_t () const { return len; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void set (unsigned int v)\n+  {\n+    len.set (v);\n+    assert (len == v);\n+    entrySelector.set (MAX (1u, hb_bit_storage (v)) - 1);\n+    searchRange.set (16 * (1u << entrySelector));\n+    rangeShift.set (v * 16 > searchRange\n+                    ? 16 * v - searchRange\n+                    : 0);\n+  }\n+\n+  protected:\n+  LenType       len;\n+  LenType       searchRange;\n+  LenType       entrySelector;\n+  LenType       rangeShift;\n+\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+template <typename Type, typename LenType=HBUINT16>\n+struct BinSearchArrayOf : SortedArrayOf<Type, BinSearchHeader<LenType> > {};\n+\n+\n+struct VarSizedBinSearchHeader\n+{\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT16      unitSize;       \/* Size of a lookup unit for this search in bytes. *\/\n+  HBUINT16      nUnits;         \/* Number of units of the preceding size to be searched. *\/\n+  HBUINT16      searchRange;    \/* The value of unitSize times the largest power of 2\n+                                 * that is less than or equal to the value of nUnits. *\/\n+  HBUINT16      entrySelector;  \/* The log base 2 of the largest power of 2 less than\n+                                 * or equal to the value of nUnits. *\/\n+  HBUINT16      rangeShift;     \/* The value of unitSize times the difference of the\n+                                 * value of nUnits minus the largest power of 2 less\n+                                 * than or equal to the value of nUnits. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+template <typename Type>\n+struct VarSizedBinSearchArrayOf\n+{\n+  static constexpr unsigned item_size = Type::static_size;\n+\n+  HB_NO_CREATE_COPY_ASSIGN_TEMPLATE (VarSizedBinSearchArrayOf, Type);\n+\n+  bool last_is_terminator () const\n+  {\n+    if (unlikely (!header.nUnits)) return false;\n+\n+    \/* Gah.\n+     *\n+     * \"The number of termination values that need to be included is table-specific.\n+     * The value that indicates binary search termination is 0xFFFF.\" *\/\n+    const HBUINT16 *words = &StructAtOffset<HBUINT16> (&bytesZ, (header.nUnits - 1) * header.unitSize);\n+    unsigned int count = Type::TerminationWordCount;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (words[i] != 0xFFFFu)\n+        return false;\n+    return true;\n+  }\n+\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= get_length ())) return Null (Type);\n+    return StructAtOffset<Type> (&bytesZ, i * header.unitSize);\n+  }\n+  Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= get_length ())) return Crap (Type);\n+    return StructAtOffset<Type> (&bytesZ, i * header.unitSize);\n+  }\n+  unsigned int get_length () const\n+  { return header.nUnits - last_is_terminator (); }\n+  unsigned int get_size () const\n+  { return header.static_size + header.nUnits * header.unitSize; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+\n+    \/* Note: for structs that do not reference other structs,\n+     * we do not need to call their sanitize() as we already did\n+     * a bound check on the aggregate array size.  We just include\n+     * a small unreachable expression to make sure the structs\n+     * pointed to do have a simple sanitize(), ie. they do not\n+     * reference other structs via offsets.\n+     *\/\n+    (void) (false && StructAtOffset<Type> (&bytesZ, 0).sanitize (c));\n+\n+    return_trace (true);\n+  }\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+    unsigned int count = get_length ();\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!(*this)[i].sanitize (c, base)))\n+        return_trace (false);\n+    return_trace (true);\n+  }\n+  template <typename T>\n+  bool sanitize (hb_sanitize_context_t *c, const void *base, T user_data) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!sanitize_shallow (c))) return_trace (false);\n+    unsigned int count = get_length ();\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!(*this)[i].sanitize (c, base, user_data)))\n+        return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  template <typename T>\n+  const Type *bsearch (const T &key) const\n+  {\n+    unsigned int size = header.unitSize;\n+    int min = 0, max = (int) get_length () - 1;\n+    while (min <= max)\n+    {\n+      int mid = ((unsigned int) min + (unsigned int) max) \/ 2;\n+      const Type *p = (const Type *) (((const char *) &bytesZ) + (mid * size));\n+      int c = p->cmp (key);\n+      if (c < 0) max = mid - 1;\n+      else if (c > 0) min = mid + 1;\n+      else return p;\n+    }\n+    return nullptr;\n+  }\n+\n+  private:\n+  bool sanitize_shallow (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (header.sanitize (c) &&\n+                  Type::static_size <= header.unitSize &&\n+                  c->check_range (bytesZ.arrayZ,\n+                                  header.nUnits,\n+                                  header.unitSize));\n+  }\n+\n+  protected:\n+  VarSizedBinSearchHeader       header;\n+  UnsizedArrayOf<HBUINT8>       bytesZ;\n+  public:\n+  DEFINE_SIZE_ARRAY (10, bytesZ);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OPEN_TYPE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-open-type.hh","additions":1008,"deletions":0,"binary":false,"changes":1008,"status":"added"},{"patch":"@@ -0,0 +1,713 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+#ifndef HB_OT_CFF_COMMON_HH\n+#define HB_OT_CFF_COMMON_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-cff-interp-dict-common.hh\"\n+#include \"hb-subset-plan.hh\"\n+\n+namespace CFF {\n+\n+using namespace OT;\n+\n+#define CFF_UNDEF_CODE  0xFFFFFFFF\n+\n+\/* utility macro *\/\n+template<typename Type>\n+static inline const Type& StructAtOffsetOrNull(const void *P, unsigned int offset)\n+{ return offset? (* reinterpret_cast<const Type*> ((const char *) P + offset)): Null(Type); }\n+\n+inline unsigned int calcOffSize(unsigned int dataSize)\n+{\n+  unsigned int size = 1;\n+  unsigned int offset = dataSize + 1;\n+  while ((offset & ~0xFF) != 0)\n+  {\n+    size++;\n+    offset >>= 8;\n+  }\n+  \/* format does not support size > 4; caller should handle it as an error *\/\n+  return size;\n+}\n+\n+struct code_pair_t\n+{\n+  hb_codepoint_t  code;\n+  hb_codepoint_t  glyph;\n+};\n+\n+typedef hb_vector_t<unsigned char> str_buff_t;\n+struct str_buff_vec_t : hb_vector_t<str_buff_t>\n+{\n+  void fini () { SUPER::fini_deep (); }\n+\n+  unsigned int total_size () const\n+  {\n+    unsigned int size = 0;\n+    for (unsigned int i = 0; i < length; i++)\n+      size += (*this)[i].length;\n+    return size;\n+  }\n+\n+  private:\n+  typedef hb_vector_t<str_buff_t> SUPER;\n+};\n+\n+\/* CFF INDEX *\/\n+template <typename COUNT>\n+struct CFFIndex\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely ((count.sanitize (c) && count == 0) || \/* empty INDEX *\/\n+                          (c->check_struct (this) && offSize >= 1 && offSize <= 4 &&\n+                           c->check_array (offsets, offSize, count + 1) &&\n+                           c->check_array ((const HBUINT8*)data_base (), 1, max_offset () - 1))));\n+  }\n+\n+  static unsigned int calculate_offset_array_size (unsigned int offSize, unsigned int count)\n+  { return offSize * (count + 1); }\n+\n+  unsigned int offset_array_size () const\n+  { return calculate_offset_array_size (offSize, count); }\n+\n+  static unsigned int calculate_serialized_size (unsigned int offSize, unsigned int count, unsigned int dataSize)\n+  {\n+    if (count == 0)\n+      return COUNT::static_size;\n+    else\n+      return min_size + calculate_offset_array_size (offSize, count) + dataSize;\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c, const CFFIndex &src)\n+  {\n+    TRACE_SERIALIZE (this);\n+    unsigned int size = src.get_size ();\n+    CFFIndex *dest = c->allocate_size<CFFIndex> (size);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    memcpy (dest, &src, size);\n+    return_trace (true);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned int offSize_,\n+                  const byte_str_array_t &byteArray)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (byteArray.length == 0)\n+    {\n+      COUNT *dest = c->allocate_min<COUNT> ();\n+      if (unlikely (dest == nullptr)) return_trace (false);\n+      dest->set (0);\n+    }\n+    else\n+    {\n+      \/* serialize CFFIndex header *\/\n+      if (unlikely (!c->extend_min (*this))) return_trace (false);\n+      this->count.set (byteArray.length);\n+      this->offSize.set (offSize_);\n+      if (!unlikely (c->allocate_size<HBUINT8> (offSize_ * (byteArray.length + 1))))\n+        return_trace (false);\n+\n+      \/* serialize indices *\/\n+      unsigned int  offset = 1;\n+      unsigned int  i = 0;\n+      for (; i < byteArray.length; i++)\n+      {\n+        set_offset_at (i, offset);\n+        offset += byteArray[i].get_size ();\n+      }\n+      set_offset_at (i, offset);\n+\n+      \/* serialize data *\/\n+      for (unsigned int i = 0; i < byteArray.length; i++)\n+      {\n+        const byte_str_t &bs = byteArray[i];\n+        unsigned char  *dest = c->allocate_size<unsigned char> (bs.length);\n+        if (unlikely (dest == nullptr))\n+          return_trace (false);\n+        memcpy (dest, &bs[0], bs.length);\n+      }\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned int offSize_,\n+                  const str_buff_vec_t &buffArray)\n+  {\n+    byte_str_array_t  byteArray;\n+    byteArray.init ();\n+    byteArray.resize (buffArray.length);\n+    for (unsigned int i = 0; i < byteArray.length; i++)\n+    {\n+      byteArray[i] = byte_str_t (buffArray[i].arrayZ (), buffArray[i].length);\n+    }\n+    bool result = this->serialize (c, offSize_, byteArray);\n+    byteArray.fini ();\n+    return result;\n+  }\n+\n+  void set_offset_at (unsigned int index, unsigned int offset)\n+  {\n+    HBUINT8 *p = offsets + offSize * index + offSize;\n+    unsigned int size = offSize;\n+    for (; size; size--)\n+    {\n+      --p;\n+      p->set (offset & 0xFF);\n+      offset >>= 8;\n+    }\n+  }\n+\n+  unsigned int offset_at (unsigned int index) const\n+  {\n+    assert (index <= count);\n+    const HBUINT8 *p = offsets + offSize * index;\n+    unsigned int size = offSize;\n+    unsigned int offset = 0;\n+    for (; size; size--)\n+      offset = (offset << 8) + *p++;\n+    return offset;\n+  }\n+\n+  unsigned int length_at (unsigned int index) const\n+  {\n+        if (likely ((offset_at (index + 1) >= offset_at (index)) &&\n+                    (offset_at (index + 1) <= offset_at (count))))\n+          return offset_at (index + 1) - offset_at (index);\n+        else\n+          return 0;\n+  }\n+\n+  const unsigned char *data_base () const\n+  { return (const unsigned char *)this + min_size + offset_array_size (); }\n+\n+  unsigned int data_size () const { return HBINT8::static_size; }\n+\n+  byte_str_t operator [] (unsigned int index) const\n+  {\n+    if (likely (index < count))\n+      return byte_str_t (data_base () + offset_at (index) - 1, length_at (index));\n+    else\n+      return Null(byte_str_t);\n+  }\n+\n+  unsigned int get_size () const\n+  {\n+    if (this != &Null(CFFIndex))\n+    {\n+      if (count > 0)\n+        return min_size + offset_array_size () + (offset_at (count) - 1);\n+      else\n+        return count.static_size;  \/* empty CFFIndex contains count only *\/\n+    }\n+    else\n+      return 0;\n+  }\n+\n+  protected:\n+  unsigned int max_offset () const\n+  {\n+    unsigned int max = 0;\n+    for (unsigned int i = 0; i < count + 1u; i++)\n+    {\n+      unsigned int off = offset_at (i);\n+      if (off > max) max = off;\n+    }\n+    return max;\n+  }\n+\n+  public:\n+  COUNT     count;      \/* Number of object data. Note there are (count+1) offsets *\/\n+  HBUINT8   offSize;      \/* The byte size of each offset in the offsets array. *\/\n+  HBUINT8   offsets[VAR]; \/* The array of (count + 1) offsets into objects array (1-base). *\/\n+  \/* HBUINT8 data[VAR];      Object data *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (COUNT::static_size + HBUINT8::static_size, offsets);\n+};\n+\n+template <typename COUNT, typename TYPE>\n+struct CFFIndexOf : CFFIndex<COUNT>\n+{\n+  const byte_str_t operator [] (unsigned int index) const\n+  {\n+    if (likely (index < CFFIndex<COUNT>::count))\n+      return byte_str_t (CFFIndex<COUNT>::data_base () + CFFIndex<COUNT>::offset_at (index) - 1, CFFIndex<COUNT>::length_at (index));\n+    return Null(byte_str_t);\n+  }\n+\n+  template <typename DATA, typename PARAM1, typename PARAM2>\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned int offSize_,\n+                  const DATA *dataArray,\n+                  unsigned int dataArrayLen,\n+                  const hb_vector_t<unsigned int> &dataSizeArray,\n+                  const PARAM1 &param1,\n+                  const PARAM2 &param2)\n+  {\n+    TRACE_SERIALIZE (this);\n+    \/* serialize CFFIndex header *\/\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    this->count.set (dataArrayLen);\n+    this->offSize.set (offSize_);\n+    if (!unlikely (c->allocate_size<HBUINT8> (offSize_ * (dataArrayLen + 1))))\n+      return_trace (false);\n+\n+    \/* serialize indices *\/\n+    unsigned int  offset = 1;\n+    unsigned int  i = 0;\n+    for (; i < dataArrayLen; i++)\n+    {\n+      CFFIndex<COUNT>::set_offset_at (i, offset);\n+      offset += dataSizeArray[i];\n+    }\n+    CFFIndex<COUNT>::set_offset_at (i, offset);\n+\n+    \/* serialize data *\/\n+    for (unsigned int i = 0; i < dataArrayLen; i++)\n+    {\n+      TYPE  *dest = c->start_embed<TYPE> ();\n+      if (unlikely (dest == nullptr ||\n+                    !dest->serialize (c, dataArray[i], param1, param2)))\n+        return_trace (false);\n+    }\n+    return_trace (true);\n+  }\n+\n+  \/* in parallel to above *\/\n+  template <typename DATA, typename PARAM>\n+  static unsigned int calculate_serialized_size (unsigned int &offSize_ \/* OUT *\/,\n+                                                 const DATA *dataArray,\n+                                                 unsigned int dataArrayLen,\n+                                                 hb_vector_t<unsigned int> &dataSizeArray, \/* OUT *\/\n+                                                 const PARAM &param)\n+  {\n+    \/* determine offset size *\/\n+    unsigned int  totalDataSize = 0;\n+    for (unsigned int i = 0; i < dataArrayLen; i++)\n+    {\n+      unsigned int dataSize = TYPE::calculate_serialized_size (dataArray[i], param);\n+      dataSizeArray[i] = dataSize;\n+      totalDataSize += dataSize;\n+    }\n+    offSize_ = calcOffSize (totalDataSize);\n+\n+    return CFFIndex<COUNT>::calculate_serialized_size (offSize_, dataArrayLen, totalDataSize);\n+  }\n+};\n+\n+\/* Top Dict, Font Dict, Private Dict *\/\n+struct Dict : UnsizedByteStr\n+{\n+  template <typename DICTVAL, typename OP_SERIALIZER, typename PARAM>\n+  bool serialize (hb_serialize_context_t *c,\n+                  const DICTVAL &dictval,\n+                  OP_SERIALIZER& opszr,\n+                  PARAM& param)\n+  {\n+    TRACE_SERIALIZE (this);\n+    for (unsigned int i = 0; i < dictval.get_count (); i++)\n+    {\n+      if (unlikely (!opszr.serialize (c, dictval[i], param)))\n+        return_trace (false);\n+    }\n+    return_trace (true);\n+  }\n+\n+  \/* in parallel to above *\/\n+  template <typename DICTVAL, typename OP_SERIALIZER, typename PARAM>\n+  static unsigned int calculate_serialized_size (const DICTVAL &dictval,\n+                                                 OP_SERIALIZER& opszr,\n+                                                 PARAM& param)\n+  {\n+    unsigned int size = 0;\n+    for (unsigned int i = 0; i < dictval.get_count (); i++)\n+      size += opszr.calculate_serialized_size (dictval[i], param);\n+    return size;\n+  }\n+\n+  template <typename DICTVAL, typename OP_SERIALIZER>\n+  static unsigned int calculate_serialized_size (const DICTVAL &dictval,\n+                                                 OP_SERIALIZER& opszr)\n+  {\n+    unsigned int size = 0;\n+    for (unsigned int i = 0; i < dictval.get_count (); i++)\n+      size += opszr.calculate_serialized_size (dictval[i]);\n+    return size;\n+  }\n+\n+  template <typename INTTYPE, int minVal, int maxVal>\n+  static bool serialize_int_op (hb_serialize_context_t *c, op_code_t op, int value, op_code_t intOp)\n+  {\n+    \/\/ XXX: not sure why but LLVM fails to compile the following 'unlikely' macro invocation\n+    if (\/*unlikely*\/ (!serialize_int<INTTYPE, minVal, maxVal> (c, intOp, value)))\n+      return false;\n+\n+    TRACE_SERIALIZE (this);\n+    \/* serialize the opcode *\/\n+    HBUINT8 *p = c->allocate_size<HBUINT8> (OpCode_Size (op));\n+    if (unlikely (p == nullptr)) return_trace (false);\n+    if (Is_OpCode_ESC (op))\n+    {\n+      p->set (OpCode_escape);\n+      op = Unmake_OpCode_ESC (op);\n+      p++;\n+    }\n+    p->set (op);\n+    return_trace (true);\n+  }\n+\n+  static bool serialize_uint4_op (hb_serialize_context_t *c, op_code_t op, int value)\n+  { return serialize_int_op<HBUINT32, 0, 0x7FFFFFFF> (c, op, value, OpCode_longintdict); }\n+\n+  static bool serialize_uint2_op (hb_serialize_context_t *c, op_code_t op, int value)\n+  { return serialize_int_op<HBUINT16, 0, 0x7FFF> (c, op, value, OpCode_shortint); }\n+\n+  static bool serialize_offset4_op (hb_serialize_context_t *c, op_code_t op, int value)\n+  {\n+    return serialize_uint4_op (c, op, value);\n+  }\n+\n+  static bool serialize_offset2_op (hb_serialize_context_t *c, op_code_t op, int value)\n+  {\n+    return serialize_uint2_op (c, op, value);\n+  }\n+};\n+\n+struct TopDict : Dict {};\n+struct FontDict : Dict {};\n+struct PrivateDict : Dict {};\n+\n+struct table_info_t\n+{\n+  void init () { offSize = offset = size = 0; }\n+\n+  unsigned int    offset;\n+  unsigned int    size;\n+  unsigned int    offSize;\n+};\n+\n+\/* used to remap font index or SID from fullset to subset.\n+ * set to CFF_UNDEF_CODE if excluded from subset *\/\n+struct remap_t : hb_vector_t<hb_codepoint_t>\n+{\n+  void init () { SUPER::init (); }\n+\n+  void fini () { SUPER::fini (); }\n+\n+  bool reset (unsigned int size)\n+  {\n+    if (unlikely (!SUPER::resize (size)))\n+      return false;\n+    for (unsigned int i = 0; i < length; i++)\n+      (*this)[i] = CFF_UNDEF_CODE;\n+    count = 0;\n+    return true;\n+  }\n+\n+  bool identity (unsigned int size)\n+  {\n+    if (unlikely (!SUPER::resize (size)))\n+      return false;\n+    unsigned int i;\n+    for (i = 0; i < length; i++)\n+      (*this)[i] = i;\n+    count = i;\n+    return true;\n+  }\n+\n+  bool excludes (hb_codepoint_t id) const\n+  { return (id < length) && ((*this)[id] == CFF_UNDEF_CODE); }\n+\n+  bool includes (hb_codepoint_t id) const\n+  { return !excludes (id); }\n+\n+  unsigned int add (unsigned int i)\n+  {\n+    if ((*this)[i] == CFF_UNDEF_CODE)\n+      (*this)[i] = count++;\n+    return (*this)[i];\n+  }\n+\n+  hb_codepoint_t get_count () const { return count; }\n+\n+  protected:\n+  hb_codepoint_t  count;\n+\n+  private:\n+  typedef hb_vector_t<hb_codepoint_t> SUPER;\n+};\n+\n+template <typename COUNT>\n+struct FDArray : CFFIndexOf<COUNT, FontDict>\n+{\n+  \/* used by CFF1 *\/\n+  template <typename DICTVAL, typename OP_SERIALIZER>\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned int offSize_,\n+                  const hb_vector_t<DICTVAL> &fontDicts,\n+                  OP_SERIALIZER& opszr)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    this->count.set (fontDicts.length);\n+    this->offSize.set (offSize_);\n+    if (!unlikely (c->allocate_size<HBUINT8> (offSize_ * (fontDicts.length + 1))))\n+      return_trace (false);\n+\n+    \/* serialize font dict offsets *\/\n+    unsigned int  offset = 1;\n+    unsigned int fid = 0;\n+    for (; fid < fontDicts.length; fid++)\n+    {\n+      CFFIndexOf<COUNT, FontDict>::set_offset_at (fid, offset);\n+      offset += FontDict::calculate_serialized_size (fontDicts[fid], opszr);\n+    }\n+    CFFIndexOf<COUNT, FontDict>::set_offset_at (fid, offset);\n+\n+    \/* serialize font dicts *\/\n+    for (unsigned int i = 0; i < fontDicts.length; i++)\n+    {\n+      FontDict *dict = c->start_embed<FontDict> ();\n+      if (unlikely (!dict->serialize (c, fontDicts[i], opszr, fontDicts[i])))\n+        return_trace (false);\n+    }\n+    return_trace (true);\n+  }\n+\n+  \/* used by CFF2 *\/\n+  template <typename DICTVAL, typename OP_SERIALIZER>\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned int offSize_,\n+                  const hb_vector_t<DICTVAL> &fontDicts,\n+                  unsigned int fdCount,\n+                  const remap_t &fdmap,\n+                  OP_SERIALIZER& opszr,\n+                  const hb_vector_t<table_info_t> &privateInfos)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    this->count.set (fdCount);\n+    this->offSize.set (offSize_);\n+    if (!unlikely (c->allocate_size<HBUINT8> (offSize_ * (fdCount + 1))))\n+      return_trace (false);\n+\n+    \/* serialize font dict offsets *\/\n+    unsigned int  offset = 1;\n+    unsigned int  fid = 0;\n+    for (unsigned i = 0; i < fontDicts.length; i++)\n+      if (fdmap.includes (i))\n+      {\n+        CFFIndexOf<COUNT, FontDict>::set_offset_at (fid++, offset);\n+        offset += FontDict::calculate_serialized_size (fontDicts[i], opszr);\n+      }\n+    CFFIndexOf<COUNT, FontDict>::set_offset_at (fid, offset);\n+\n+    \/* serialize font dicts *\/\n+    for (unsigned int i = 0; i < fontDicts.length; i++)\n+      if (fdmap.includes (i))\n+      {\n+        FontDict *dict = c->start_embed<FontDict> ();\n+        if (unlikely (!dict->serialize (c, fontDicts[i], opszr, privateInfos[fdmap[i]])))\n+          return_trace (false);\n+      }\n+    return_trace (true);\n+  }\n+\n+  \/* in parallel to above *\/\n+  template <typename OP_SERIALIZER, typename DICTVAL>\n+  static unsigned int calculate_serialized_size (unsigned int &offSize_ \/* OUT *\/,\n+                                                 const hb_vector_t<DICTVAL> &fontDicts,\n+                                                 unsigned int fdCount,\n+                                                 const remap_t &fdmap,\n+                                                 OP_SERIALIZER& opszr)\n+  {\n+    unsigned int dictsSize = 0;\n+    for (unsigned int i = 0; i < fontDicts.len; i++)\n+      if (fdmap.includes (i))\n+        dictsSize += FontDict::calculate_serialized_size (fontDicts[i], opszr);\n+\n+    offSize_ = calcOffSize (dictsSize);\n+    return CFFIndex<COUNT>::calculate_serialized_size (offSize_, fdCount, dictsSize);\n+  }\n+};\n+\n+\/* FDSelect *\/\n+struct FDSelect0 {\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int fdcount) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!(c->check_struct (this))))\n+      return_trace (false);\n+    for (unsigned int i = 0; i < c->get_num_glyphs (); i++)\n+      if (unlikely (!fds[i].sanitize (c)))\n+        return_trace (false);\n+\n+    return_trace (true);\n+  }\n+\n+  hb_codepoint_t get_fd (hb_codepoint_t glyph) const\n+  {\n+    return (hb_codepoint_t)fds[glyph];\n+  }\n+\n+  unsigned int get_size (unsigned int num_glyphs) const\n+  { return HBUINT8::static_size * num_glyphs; }\n+\n+  HBUINT8     fds[VAR];\n+\n+  DEFINE_SIZE_MIN (1);\n+};\n+\n+template <typename GID_TYPE, typename FD_TYPE>\n+struct FDSelect3_4_Range {\n+  bool sanitize (hb_sanitize_context_t *c, const void *\/*nullptr*\/, unsigned int fdcount) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (first < c->get_num_glyphs () && (fd < fdcount));\n+  }\n+\n+  GID_TYPE    first;\n+  FD_TYPE     fd;\n+\n+  DEFINE_SIZE_STATIC (GID_TYPE::static_size + FD_TYPE::static_size);\n+};\n+\n+template <typename GID_TYPE, typename FD_TYPE>\n+struct FDSelect3_4 {\n+  unsigned int get_size () const\n+  { return GID_TYPE::static_size * 2 + ranges.get_size (); }\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int fdcount) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this) || !ranges.sanitize (c, nullptr, fdcount) ||\n+                  (nRanges () == 0) || ranges[0].first != 0))\n+      return_trace (false);\n+\n+    for (unsigned int i = 1; i < nRanges (); i++)\n+    {\n+      if (unlikely (ranges[i - 1].first >= ranges[i].first))\n+          return_trace (false);\n+    }\n+\n+    if (unlikely (!sentinel().sanitize (c) || (sentinel() != c->get_num_glyphs ())))\n+      return_trace (false);\n+\n+    return_trace (true);\n+  }\n+\n+  hb_codepoint_t get_fd (hb_codepoint_t glyph) const\n+  {\n+    unsigned int i;\n+    for (i = 1; i < nRanges (); i++)\n+      if (glyph < ranges[i].first)\n+        break;\n+\n+    return (hb_codepoint_t)ranges[i - 1].fd;\n+  }\n+\n+  GID_TYPE &nRanges () { return ranges.len; }\n+  GID_TYPE nRanges () const { return ranges.len; }\n+  GID_TYPE &sentinel ()  { return StructAfter<GID_TYPE> (ranges[nRanges () - 1]); }\n+  const GID_TYPE &sentinel () const  { return StructAfter<GID_TYPE> (ranges[nRanges () - 1]); }\n+\n+  ArrayOf<FDSelect3_4_Range<GID_TYPE, FD_TYPE>, GID_TYPE> ranges;\n+  \/* GID_TYPE sentinel *\/\n+\n+  DEFINE_SIZE_ARRAY (GID_TYPE::static_size, ranges);\n+};\n+\n+typedef FDSelect3_4<HBUINT16, HBUINT8> FDSelect3;\n+typedef FDSelect3_4_Range<HBUINT16, HBUINT8> FDSelect3_Range;\n+\n+struct FDSelect {\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int fdcount) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    return_trace (likely (c->check_struct (this) && (format == 0 || format == 3) &&\n+                          (format == 0)?\n+                          u.format0.sanitize (c, fdcount):\n+                          u.format3.sanitize (c, fdcount)));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c, const FDSelect &src, unsigned int num_glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    unsigned int size = src.get_size (num_glyphs);\n+    FDSelect *dest = c->allocate_size<FDSelect> (size);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    memcpy (dest, &src, size);\n+    return_trace (true);\n+  }\n+\n+  unsigned int calculate_serialized_size (unsigned int num_glyphs) const\n+  { return get_size (num_glyphs); }\n+\n+  unsigned int get_size (unsigned int num_glyphs) const\n+  {\n+    unsigned int size = format.static_size;\n+    if (format == 0)\n+      size += u.format0.get_size (num_glyphs);\n+    else\n+      size += u.format3.get_size ();\n+    return size;\n+  }\n+\n+  hb_codepoint_t get_fd (hb_codepoint_t glyph) const\n+  {\n+    if (this == &Null(FDSelect))\n+      return 0;\n+    if (format == 0)\n+      return u.format0.get_fd (glyph);\n+    else\n+      return u.format3.get_fd (glyph);\n+  }\n+\n+  HBUINT8       format;\n+  union {\n+    FDSelect0   format0;\n+    FDSelect3   format3;\n+  } u;\n+\n+  DEFINE_SIZE_MIN (1);\n+};\n+\n+template <typename COUNT>\n+struct Subrs : CFFIndex<COUNT>\n+{\n+  typedef COUNT count_type;\n+  typedef CFFIndex<COUNT> SUPER;\n+};\n+\n+} \/* namespace CFF *\/\n+\n+#endif \/* HB_OT_CFF_COMMON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-cff-common.hh","additions":713,"deletions":0,"binary":false,"changes":713,"status":"added"},{"patch":"@@ -0,0 +1,385 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#include \"hb-ot-cff1-table.hh\"\n+#include \"hb-cff1-interp-cs.hh\"\n+\n+using namespace CFF;\n+\n+\/* SID to code *\/\n+static const uint8_t standard_encoding_to_code [] =\n+{\n+    0,   32,   33,   34,   35,   36,   37,   38,  39,   40,   41,   42,   43,   44,   45,   46,\n+   47,   48,   49,   50,   51,   52,   53,   54,  55,   56,   57,   58,   59,   60,   61,   62,\n+   63,   64,   65,   66,   67,   68,   69,   70,  71,   72,   73,   74,   75,   76,   77,   78,\n+   79,   80,   81,   82,   83,   84,   85,   86,  87,   88,   89,   90,   91,   92,   93,   94,\n+   95,   96,   97,   98,   99,  100,  101,  102, 103,  104,  105,  106,  107,  108,  109,  110,\n+  111,  112,  113,  114,  115,  116,  117,  118, 119,  120,  121,  122,  123,  124,  125,  126,\n+  161,  162,  163,  164,  165,  166,  167,  168, 169,  170,  171,  172,  173,  174,  175,  177,\n+  178,  179,  180,  182,  183,  184,  185,  186, 187,  188,  189,  191,  193,  194,  195,  196,\n+  197,  198,  199,  200,  202,  203,  205,  206, 207,  208,  225,  227,  232,  233,  234,  235,\n+  241,  245,  248,  249,  250,  251\n+};\n+\n+\/* SID to code *\/\n+static const uint8_t expert_encoding_to_code [] =\n+{\n+    0,   32,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   44,   45,   46,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,   58,   59,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,   47,    0,    0,    0,    0,    0,    0,    0,    0,    0,   87,   88,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,  201,    0,    0,    0,    0,  189,    0,    0,  188,    0,\n+    0,    0,    0,  190,  202,    0,    0,    0,    0,  203,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,   33,   34,   36,   37,   38,   39,   40,   41,   42,   43,   48,\n+   49,   50,   51,   52,   53,   54,   55,   56,   57,   60,   61,   62,   63,   65,   66,   67,\n+   68,   69,   73,   76,   77,   78,   79,   82,   83,   84,   86,   89,   90,   91,   93,   94,\n+   95,   96,   97,   98,   99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n+  111,  112,  113,  114,  115,  116,  117,  118,  119,  120,  121,  122,  123,  124,  125,  126,\n+  161,  162,  163,  166,  167,  168,  169,  170,  172,  175,  178,  179,  182,  183,  184,  191,\n+  192,  193,  194,  195,  196,  197,  200,  204,  205,  206,  207,  208,  209,  210,  211,  212,\n+  213,  214,  215,  216,  217,  218,  219,  220,  221,  222,  223,  224,  225,  226,  227,  228,\n+  229,  230,  231,  232,  233,  234,  235,  236,  237,  238,  239,  240,  241,  242,  243,  244,\n+  245,  246,  247,  248,  249,  250,  251,  252,  253,  254,  255\n+};\n+\n+\/* glyph ID to SID *\/\n+static const uint16_t expert_charset_to_sid [] =\n+{\n+    0,    1,  229,  230,  231,  232,  233,  234,  235,  236,  237,  238,   13,   14,   15,   99,\n+  239,  240,  241,  242,  243,  244,  245,  246,  247,  248,   27,   28,  249,  250,  251,  252,\n+  253,  254,  255,  256,  257,  258,  259,  260,  261,  262,  263,  264,  265,  266,  109,  110,\n+  267,  268,  269,  270,  271,  272,  273,  274,  275,  276,  277,  278,  279,  280,  281,  282,\n+  283,  284,  285,  286,  287,  288,  289,  290,  291,  292,  293,  294,  295,  296,  297,  298,\n+  299,  300,  301,  302,  303,  304,  305,  306,  307,  308,  309,  310,  311,  312,  313,  314,\n+  315,  316,  317,  318,  158,  155,  163,  319,  320,  321,  322,  323,  324,  325,  326,  150,\n+  164,  169,  327,  328,  329,  330,  331,  332,  333,  334,  335,  336,  337,  338,  339,  340,\n+  341,  342,  343,  344,  345,  346,  347,  348,  349,  350,  351,  352,  353,  354,  355,  356,\n+  357,  358,  359,  360,  361,  362,  363,  364,  365,  366,  367,  368,  369,  370,  371,  372,\n+  373,  374,  375,  376,  377,  378\n+};\n+\n+\/* glyph ID to SID *\/\n+static const uint16_t expert_subset_charset_to_sid [] =\n+{\n+    0,    1,  231,  232,  235,  236,  237,  238,   13,   14,   15,   99,  239,  240,  241,  242,\n+  243,  244,  245,  246,  247,  248,   27,   28,  249,  250,  251,  253,  254,  255,  256,  257,\n+  258,  259,  260,  261,  262,  263,  264,  265,  266,  109,  110,  267,  268,  269,  270,  272,\n+  300,  301,  302,  305,  314,  315,  158,  155,  163,  320,  321,  322,  323,  324,  325,  326,\n+  150,  164,  169,  327,  328,  329,  330,  331,  332,  333,  334,  335,  336,  337,  338,  339,\n+  340,  341,  342,  343,  344,  345,  346\n+};\n+\n+\/* code to SID *\/\n+static const uint8_t standard_encoding_to_sid [] =\n+{\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    1,    2,    3,    4,    5,    6,    7,    8,    9,   10,   11,   12,   13,   14,   15,   16,\n+    17,  18,   19,   20,   21,   22,   23,   24,   25,   26,   27,   28,   29,   30,   31,   32,\n+    33,  34,   35,   36,   37,   38,   39,   40,   41,   42,   43,   44,   45,   46,   47,   48,\n+    49,  50,   51,   52,   53,   54,   55,   56,   57,   58,   59,   60,   61,   62,   63,   64,\n+    65,  66,   67,   68,   69,   70,   71,   72,   73,   74,   75,   76,   77,   78,   79,   80,\n+    81,  82,   83,   84,   85,   86,   87,   88,   89,   90,   91,   92,   93,   94,   95,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,   96,   97,   98,   99,  100,  101,  102,  103,  104,  105,  106,  107,  108,  109,  110,\n+    0,  111,  112,  113,  114,    0,  115,  116,  117,  118,  119,  120,  121,  122,    0,  123,\n+    0,  124,  125,  126,  127,  128,  129,  130,  131,    0,  132,  133,    0,  134,  135,  136,\n+  137,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,\n+    0,   138,   0,  139,    0,    0,    0,    0,  140,  141,  142,  143,    0,    0,    0,    0,\n+    0,   144,   0,    0,    0,  145,    0,    0,  146,  147,  148,  149,    0,    0,    0,    0\n+};\n+\n+hb_codepoint_t OT::cff1::lookup_standard_encoding_for_code (hb_codepoint_t sid)\n+{\n+  if (sid < ARRAY_LENGTH (standard_encoding_to_code))\n+    return (hb_codepoint_t)standard_encoding_to_code[sid];\n+  else\n+    return 0;\n+}\n+\n+hb_codepoint_t OT::cff1::lookup_expert_encoding_for_code (hb_codepoint_t sid)\n+{\n+  if (sid < ARRAY_LENGTH (expert_encoding_to_code))\n+    return (hb_codepoint_t)expert_encoding_to_code[sid];\n+  else\n+    return 0;\n+}\n+\n+hb_codepoint_t OT::cff1::lookup_expert_charset_for_sid (hb_codepoint_t glyph)\n+{\n+  if (glyph < ARRAY_LENGTH (expert_charset_to_sid))\n+    return (hb_codepoint_t)expert_charset_to_sid[glyph];\n+  else\n+    return 0;\n+}\n+\n+hb_codepoint_t OT::cff1::lookup_expert_subset_charset_for_sid (hb_codepoint_t glyph)\n+{\n+  if (glyph < ARRAY_LENGTH (expert_subset_charset_to_sid))\n+    return (hb_codepoint_t)expert_subset_charset_to_sid[glyph];\n+  else\n+    return 0;\n+}\n+\n+hb_codepoint_t OT::cff1::lookup_standard_encoding_for_sid (hb_codepoint_t code)\n+{\n+  if (code < ARRAY_LENGTH (standard_encoding_to_sid))\n+    return (hb_codepoint_t)standard_encoding_to_sid[code];\n+  else\n+    return CFF_UNDEF_SID;\n+}\n+\n+struct bounds_t\n+{\n+  void init ()\n+  {\n+    min.set_int (0x7FFFFFFF, 0x7FFFFFFF);\n+    max.set_int (-0x80000000, -0x80000000);\n+  }\n+\n+  void update (const point_t &pt)\n+  {\n+    if (pt.x < min.x) min.x = pt.x;\n+    if (pt.x > max.x) max.x = pt.x;\n+    if (pt.y < min.y) min.y = pt.y;\n+    if (pt.y > max.y) max.y = pt.y;\n+  }\n+\n+  void merge (const bounds_t &b)\n+  {\n+    if (empty ())\n+      *this = b;\n+    else if (!b.empty ())\n+    {\n+      if (b.min.x < min.x) min.x = b.min.x;\n+      if (b.max.x > max.x) max.x = b.max.x;\n+      if (b.min.y < min.y) min.y = b.min.y;\n+      if (b.max.y > max.y) max.y = b.max.y;\n+    }\n+  }\n+\n+  void offset (const point_t &delta)\n+  {\n+    if (!empty ())\n+    {\n+      min.move (delta);\n+      max.move (delta);\n+    }\n+  }\n+\n+  bool empty () const\n+  { return (min.x >= max.x) || (min.y >= max.y); }\n+\n+  point_t min;\n+  point_t max;\n+};\n+\n+struct extents_param_t\n+{\n+  void init (const OT::cff1::accelerator_t *_cff)\n+  {\n+    path_open = false;\n+    cff = _cff;\n+    bounds.init ();\n+  }\n+\n+  void start_path ()         { path_open = true; }\n+  void end_path ()           { path_open = false; }\n+  bool is_path_open () const { return path_open; }\n+\n+  bool    path_open;\n+  bounds_t  bounds;\n+\n+  const OT::cff1::accelerator_t *cff;\n+};\n+\n+struct cff1_path_procs_extents_t : path_procs_t<cff1_path_procs_extents_t, cff1_cs_interp_env_t, extents_param_t>\n+{\n+  static void moveto (cff1_cs_interp_env_t &env, extents_param_t& param, const point_t &pt)\n+  {\n+    param.end_path ();\n+    env.moveto (pt);\n+  }\n+\n+  static void line (cff1_cs_interp_env_t &env, extents_param_t& param, const point_t &pt1)\n+  {\n+    if (!param.is_path_open ())\n+    {\n+      param.start_path ();\n+      param.bounds.update (env.get_pt ());\n+    }\n+    env.moveto (pt1);\n+    param.bounds.update (env.get_pt ());\n+  }\n+\n+  static void curve (cff1_cs_interp_env_t &env, extents_param_t& param, const point_t &pt1, const point_t &pt2, const point_t &pt3)\n+  {\n+    if (!param.is_path_open ())\n+    {\n+      param.start_path ();\n+      param.bounds.update (env.get_pt ());\n+    }\n+    \/* include control points *\/\n+    param.bounds.update (pt1);\n+    param.bounds.update (pt2);\n+    env.moveto (pt3);\n+    param.bounds.update (env.get_pt ());\n+  }\n+};\n+\n+static bool _get_bounds (const OT::cff1::accelerator_t *cff, hb_codepoint_t glyph, bounds_t &bounds, bool in_seac=false);\n+\n+struct cff1_cs_opset_extents_t : cff1_cs_opset_t<cff1_cs_opset_extents_t, extents_param_t, cff1_path_procs_extents_t>\n+{\n+  static void process_seac (cff1_cs_interp_env_t &env, extents_param_t& param)\n+  {\n+    unsigned int  n = env.argStack.get_count ();\n+    point_t delta;\n+    delta.x = env.argStack[n-4];\n+    delta.y = env.argStack[n-3];\n+    hb_codepoint_t base = param.cff->std_code_to_glyph (env.argStack[n-2].to_int ());\n+    hb_codepoint_t accent = param.cff->std_code_to_glyph (env.argStack[n-1].to_int ());\n+\n+    bounds_t  base_bounds, accent_bounds;\n+    if (likely (!env.in_seac && base && accent\n+               && _get_bounds (param.cff, base, base_bounds, true)\n+               && _get_bounds (param.cff, accent, accent_bounds, true)))\n+    {\n+      param.bounds.merge (base_bounds);\n+      accent_bounds.offset (delta);\n+      param.bounds.merge (accent_bounds);\n+    }\n+    else\n+      env.set_error ();\n+  }\n+};\n+\n+bool _get_bounds (const OT::cff1::accelerator_t *cff, hb_codepoint_t glyph, bounds_t &bounds, bool in_seac)\n+{\n+  bounds.init ();\n+  if (unlikely (!cff->is_valid () || (glyph >= cff->num_glyphs))) return false;\n+\n+  unsigned int fd = cff->fdSelect->get_fd (glyph);\n+  cff1_cs_interpreter_t<cff1_cs_opset_extents_t, extents_param_t> interp;\n+  const byte_str_t str = (*cff->charStrings)[glyph];\n+  interp.env.init (str, *cff, fd);\n+  interp.env.set_in_seac (in_seac);\n+  extents_param_t  param;\n+  param.init (cff);\n+  if (unlikely (!interp.interpret (param))) return false;\n+  bounds = param.bounds;\n+  return true;\n+}\n+\n+bool OT::cff1::accelerator_t::get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const\n+{\n+  bounds_t  bounds;\n+\n+  if (!_get_bounds (this, glyph, bounds))\n+    return false;\n+\n+  if (bounds.min.x >= bounds.max.x)\n+  {\n+    extents->width = 0;\n+    extents->x_bearing = 0;\n+  }\n+  else\n+  {\n+    extents->x_bearing = (int32_t)bounds.min.x.floor ();\n+    extents->width = (int32_t)bounds.max.x.ceil () - extents->x_bearing;\n+  }\n+  if (bounds.min.y >= bounds.max.y)\n+  {\n+    extents->height = 0;\n+    extents->y_bearing = 0;\n+  }\n+  else\n+  {\n+    extents->y_bearing = (int32_t)bounds.max.y.ceil ();\n+    extents->height = (int32_t)bounds.min.y.floor () - extents->y_bearing;\n+  }\n+\n+  return true;\n+}\n+\n+struct get_seac_param_t\n+{\n+  void init (const OT::cff1::accelerator_t *_cff)\n+  {\n+    cff = _cff;\n+    base = 0;\n+    accent = 0;\n+  }\n+\n+  bool has_seac () const { return base && accent; }\n+\n+  const OT::cff1::accelerator_t *cff;\n+  hb_codepoint_t  base;\n+  hb_codepoint_t  accent;\n+};\n+\n+struct cff1_cs_opset_seac_t : cff1_cs_opset_t<cff1_cs_opset_seac_t, get_seac_param_t>\n+{\n+  static void process_seac (cff1_cs_interp_env_t &env, get_seac_param_t& param)\n+  {\n+    unsigned int  n = env.argStack.get_count ();\n+    hb_codepoint_t  base_char = (hb_codepoint_t)env.argStack[n-2].to_int ();\n+    hb_codepoint_t  accent_char = (hb_codepoint_t)env.argStack[n-1].to_int ();\n+\n+    param.base = param.cff->std_code_to_glyph (base_char);\n+    param.accent = param.cff->std_code_to_glyph (accent_char);\n+  }\n+};\n+\n+bool OT::cff1::accelerator_t::get_seac_components (hb_codepoint_t glyph, hb_codepoint_t *base, hb_codepoint_t *accent) const\n+{\n+  if (unlikely (!is_valid () || (glyph >= num_glyphs))) return false;\n+\n+  unsigned int fd = fdSelect->get_fd (glyph);\n+  cff1_cs_interpreter_t<cff1_cs_opset_seac_t, get_seac_param_t> interp;\n+  const byte_str_t str = (*charStrings)[glyph];\n+  interp.env.init (str, *this, fd);\n+  get_seac_param_t  param;\n+  param.init (this);\n+  if (unlikely (!interp.interpret (param))) return false;\n+\n+  if (param.has_seac ())\n+  {\n+    *base = param.base;\n+    *accent = param.accent;\n+    return true;\n+  }\n+  return false;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-cff1-table.cc","additions":385,"deletions":0,"binary":false,"changes":385,"status":"added"},{"patch":"@@ -0,0 +1,1299 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#ifndef HB_OT_CFF1_TABLE_HH\n+#define HB_OT_CFF1_TABLE_HH\n+\n+#include \"hb-ot-head-table.hh\"\n+#include \"hb-ot-cff-common.hh\"\n+#include \"hb-subset-cff1.hh\"\n+\n+namespace CFF {\n+\n+\/*\n+ * CFF -- Compact Font Format (CFF)\n+ * http:\/\/www.adobe.com\/content\/dam\/acom\/en\/devnet\/font\/pdfs\/5176.CFF.pdf\n+ *\/\n+#define HB_OT_TAG_cff1 HB_TAG('C','F','F',' ')\n+\n+#define CFF_UNDEF_SID   CFF_UNDEF_CODE\n+\n+enum EncodingID { StandardEncoding = 0, ExpertEncoding = 1 };\n+enum CharsetID { ISOAdobeCharset = 0, ExpertCharset = 1, ExpertSubsetCharset = 2 };\n+\n+typedef CFFIndex<HBUINT16>  CFF1Index;\n+template <typename Type> struct CFF1IndexOf : CFFIndexOf<HBUINT16, Type> {};\n+\n+typedef CFFIndex<HBUINT16> CFF1Index;\n+typedef CFF1Index          CFF1CharStrings;\n+typedef FDArray<HBUINT16>  CFF1FDArray;\n+typedef Subrs<HBUINT16>    CFF1Subrs;\n+\n+struct CFF1FDSelect : FDSelect {};\n+\n+\/* Encoding *\/\n+struct Encoding0 {\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && codes[nCodes - 1].sanitize (c));\n+  }\n+\n+  hb_codepoint_t get_code (hb_codepoint_t glyph) const\n+  {\n+    assert (glyph > 0);\n+    glyph--;\n+    if (glyph < nCodes)\n+    {\n+      return (hb_codepoint_t)codes[glyph];\n+    }\n+    else\n+      return CFF_UNDEF_CODE;\n+  }\n+\n+  unsigned int get_size () const\n+  { return HBUINT8::static_size * (nCodes + 1); }\n+\n+  HBUINT8     nCodes;\n+  HBUINT8     codes[VAR];\n+\n+  DEFINE_SIZE_ARRAY(1, codes);\n+};\n+\n+struct Encoding1_Range {\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT8   first;\n+  HBUINT8   nLeft;\n+\n+  DEFINE_SIZE_STATIC (2);\n+};\n+\n+struct Encoding1 {\n+  unsigned int get_size () const\n+  { return HBUINT8::static_size + Encoding1_Range::static_size * nRanges; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && ((nRanges == 0) || (ranges[nRanges - 1]).sanitize (c)));\n+  }\n+\n+  hb_codepoint_t get_code (hb_codepoint_t glyph) const\n+  {\n+    assert (glyph > 0);\n+    glyph--;\n+    for (unsigned int i = 0; i < nRanges; i++)\n+    {\n+      if (glyph <= ranges[i].nLeft)\n+      {\n+        return (hb_codepoint_t)ranges[i].first + glyph;\n+      }\n+      glyph -= (ranges[i].nLeft + 1);\n+    }\n+    return CFF_UNDEF_CODE;\n+  }\n+\n+  HBUINT8          nRanges;\n+  Encoding1_Range   ranges[VAR];\n+\n+  DEFINE_SIZE_ARRAY (1, ranges);\n+};\n+\n+struct SuppEncoding {\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT8   code;\n+  HBUINT16  glyph;\n+\n+  DEFINE_SIZE_STATIC (3);\n+};\n+\n+struct CFF1SuppEncData {\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && ((nSups == 0) || (supps[nSups - 1]).sanitize (c)));\n+  }\n+\n+  void get_codes (hb_codepoint_t sid, hb_vector_t<hb_codepoint_t> &codes) const\n+  {\n+    for (unsigned int i = 0; i < nSups; i++)\n+      if (sid == supps[i].glyph)\n+        codes.push (supps[i].code);\n+  }\n+\n+  unsigned int get_size () const\n+  { return HBUINT8::static_size + SuppEncoding::static_size * nSups; }\n+\n+  HBUINT8        nSups;\n+  SuppEncoding   supps[VAR];\n+\n+  DEFINE_SIZE_ARRAY (1, supps);\n+};\n+\n+struct Encoding {\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+    unsigned int fmt = format & 0x7F;\n+    if (unlikely (fmt > 1))\n+      return_trace (false);\n+    if (unlikely (!((fmt == 0)? u.format0.sanitize (c): u.format1.sanitize (c))))\n+      return_trace (false);\n+    return_trace (((format & 0x80) == 0) || suppEncData ().sanitize (c));\n+  }\n+\n+  \/* serialize a fullset Encoding *\/\n+  bool serialize (hb_serialize_context_t *c, const Encoding &src)\n+  {\n+    TRACE_SERIALIZE (this);\n+    unsigned int size = src.get_size ();\n+    Encoding *dest = c->allocate_size<Encoding> (size);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    memcpy (dest, &src, size);\n+    return_trace (true);\n+  }\n+\n+  \/* serialize a subset Encoding *\/\n+  bool serialize (hb_serialize_context_t *c,\n+                  uint8_t format,\n+                  unsigned int enc_count,\n+                  const hb_vector_t<code_pair_t>& code_ranges,\n+                  const hb_vector_t<code_pair_t>& supp_codes)\n+  {\n+    TRACE_SERIALIZE (this);\n+    Encoding *dest = c->extend_min (*this);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    dest->format.set (format | ((supp_codes.length > 0)? 0x80: 0));\n+    if (format == 0)\n+    {\n+      Encoding0 *fmt0 = c->allocate_size<Encoding0> (Encoding0::min_size + HBUINT8::static_size * enc_count);\n+    if (unlikely (fmt0 == nullptr)) return_trace (false);\n+      fmt0->nCodes.set (enc_count);\n+      unsigned int glyph = 0;\n+      for (unsigned int i = 0; i < code_ranges.length; i++)\n+      {\n+        hb_codepoint_t code = code_ranges[i].code;\n+        for (int left = (int)code_ranges[i].glyph; left >= 0; left--)\n+          fmt0->codes[glyph++].set (code++);\n+        if (unlikely (!((glyph <= 0x100) && (code <= 0x100))))\n+          return_trace (false);\n+      }\n+    }\n+    else\n+    {\n+      Encoding1 *fmt1 = c->allocate_size<Encoding1> (Encoding1::min_size + Encoding1_Range::static_size * code_ranges.length);\n+      if (unlikely (fmt1 == nullptr)) return_trace (false);\n+      fmt1->nRanges.set (code_ranges.length);\n+      for (unsigned int i = 0; i < code_ranges.length; i++)\n+      {\n+        if (unlikely (!((code_ranges[i].code <= 0xFF) && (code_ranges[i].glyph <= 0xFF))))\n+          return_trace (false);\n+        fmt1->ranges[i].first.set (code_ranges[i].code);\n+        fmt1->ranges[i].nLeft.set (code_ranges[i].glyph);\n+      }\n+    }\n+    if (supp_codes.length > 0)\n+    {\n+      CFF1SuppEncData *suppData = c->allocate_size<CFF1SuppEncData> (CFF1SuppEncData::min_size + SuppEncoding::static_size * supp_codes.length);\n+      if (unlikely (suppData == nullptr)) return_trace (false);\n+      suppData->nSups.set (supp_codes.length);\n+      for (unsigned int i = 0; i < supp_codes.length; i++)\n+      {\n+        suppData->supps[i].code.set (supp_codes[i].code);\n+        suppData->supps[i].glyph.set (supp_codes[i].glyph); \/* actually SID *\/\n+      }\n+    }\n+    return_trace (true);\n+  }\n+\n+  \/* parallel to above: calculate the size of a subset Encoding *\/\n+  static unsigned int calculate_serialized_size (uint8_t format,\n+                                                 unsigned int enc_count,\n+                                                 unsigned int supp_count)\n+  {\n+    unsigned int  size = min_size;\n+    if (format == 0)\n+      size += Encoding0::min_size + HBUINT8::static_size * enc_count;\n+    else\n+      size += Encoding1::min_size + Encoding1_Range::static_size * enc_count;\n+    if (supp_count > 0)\n+      size += CFF1SuppEncData::min_size + SuppEncoding::static_size * supp_count;\n+    return size;\n+  }\n+\n+  unsigned int get_size () const\n+  {\n+    unsigned int size = min_size;\n+    if (table_format () == 0)\n+      size += u.format0.get_size ();\n+    else\n+      size += u.format1.get_size ();\n+    if (has_supplement ())\n+      size += suppEncData ().get_size ();\n+    return size;\n+  }\n+\n+  hb_codepoint_t get_code (hb_codepoint_t glyph) const\n+  {\n+    if (table_format () == 0)\n+      return u.format0.get_code (glyph);\n+    else\n+      return u.format1.get_code (glyph);\n+  }\n+\n+  uint8_t table_format () const { return (format & 0x7F); }\n+  bool  has_supplement () const { return (format & 0x80) != 0; }\n+\n+  void get_supplement_codes (hb_codepoint_t sid, hb_vector_t<hb_codepoint_t> &codes) const\n+  {\n+    codes.resize (0);\n+    if (has_supplement ())\n+      suppEncData().get_codes (sid, codes);\n+  }\n+\n+  protected:\n+  const CFF1SuppEncData &suppEncData () const\n+  {\n+    if ((format & 0x7F) == 0)\n+      return StructAfter<CFF1SuppEncData> (u.format0.codes[u.format0.nCodes-1]);\n+    else\n+      return StructAfter<CFF1SuppEncData> (u.format1.ranges[u.format1.nRanges-1]);\n+  }\n+\n+  public:\n+  HBUINT8       format;\n+\n+  union {\n+    Encoding0   format0;\n+    Encoding1   format1;\n+  } u;\n+  \/* CFF1SuppEncData  suppEncData; *\/\n+\n+  DEFINE_SIZE_MIN (1);\n+};\n+\n+\/* Charset *\/\n+struct Charset0 {\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int num_glyphs) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && sids[num_glyphs - 1].sanitize (c));\n+  }\n+\n+  hb_codepoint_t get_sid (hb_codepoint_t glyph) const\n+  {\n+    if (glyph == 0)\n+      return 0;\n+    else\n+      return sids[glyph - 1];\n+  }\n+\n+  hb_codepoint_t get_glyph (hb_codepoint_t sid, unsigned int num_glyphs) const\n+  {\n+    if (sid == 0)\n+      return 0;\n+\n+    for (unsigned int glyph = 1; glyph < num_glyphs; glyph++)\n+    {\n+      if (sids[glyph-1] == sid)\n+        return glyph;\n+    }\n+    return 0;\n+  }\n+\n+  unsigned int get_size (unsigned int num_glyphs) const\n+  {\n+    assert (num_glyphs > 0);\n+    return HBUINT16::static_size * (num_glyphs - 1);\n+  }\n+\n+  HBUINT16  sids[VAR];\n+\n+  DEFINE_SIZE_ARRAY(0, sids);\n+};\n+\n+template <typename TYPE>\n+struct Charset_Range {\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT16  first;\n+  TYPE      nLeft;\n+\n+  DEFINE_SIZE_STATIC (HBUINT16::static_size + TYPE::static_size);\n+};\n+\n+template <typename TYPE>\n+struct Charset1_2 {\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int num_glyphs) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+    num_glyphs--;\n+    for (unsigned int i = 0; num_glyphs > 0; i++)\n+    {\n+      if (unlikely (!ranges[i].sanitize (c) || (num_glyphs < ranges[i].nLeft + 1)))\n+        return_trace (false);\n+      num_glyphs -= (ranges[i].nLeft + 1);\n+    }\n+    return_trace (true);\n+  }\n+\n+  hb_codepoint_t get_sid (hb_codepoint_t glyph) const\n+  {\n+    if (glyph == 0) return 0;\n+    glyph--;\n+    for (unsigned int i = 0;; i++)\n+    {\n+      if (glyph <= ranges[i].nLeft)\n+        return (hb_codepoint_t)ranges[i].first + glyph;\n+      glyph -= (ranges[i].nLeft + 1);\n+    }\n+\n+    return 0;\n+  }\n+\n+  hb_codepoint_t get_glyph (hb_codepoint_t sid, unsigned int num_glyphs) const\n+  {\n+    if (sid == 0) return 0;\n+    hb_codepoint_t  glyph = 1;\n+    for (unsigned int i = 0;; i++)\n+    {\n+      if (glyph >= num_glyphs)\n+        return 0;\n+      if ((ranges[i].first <= sid) && (sid <= ranges[i].first + ranges[i].nLeft))\n+        return glyph + (sid - ranges[i].first);\n+      glyph += (ranges[i].nLeft + 1);\n+    }\n+\n+    return 0;\n+  }\n+\n+  unsigned int get_size (unsigned int num_glyphs) const\n+  {\n+    unsigned int size = HBUINT8::static_size;\n+    int glyph = (int)num_glyphs;\n+\n+    assert (glyph > 0);\n+    glyph--;\n+    for (unsigned int i = 0; glyph > 0; i++)\n+    {\n+      glyph -= (ranges[i].nLeft + 1);\n+      size += Charset_Range<TYPE>::static_size;\n+    }\n+\n+    return size;\n+  }\n+\n+  Charset_Range<TYPE>   ranges[VAR];\n+\n+  DEFINE_SIZE_ARRAY (0, ranges);\n+};\n+\n+typedef Charset1_2<HBUINT8>     Charset1;\n+typedef Charset1_2<HBUINT16>    Charset2;\n+typedef Charset_Range<HBUINT8>  Charset1_Range;\n+typedef Charset_Range<HBUINT16> Charset2_Range;\n+\n+struct Charset {\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+    if (format == 0)\n+      return_trace (u.format0.sanitize (c, c->get_num_glyphs ()));\n+    else if (format == 1)\n+      return_trace (u.format1.sanitize (c, c->get_num_glyphs ()));\n+    else if (likely (format == 2))\n+      return_trace (u.format2.sanitize (c, c->get_num_glyphs ()));\n+    else\n+      return_trace (false);\n+  }\n+\n+  \/* serialize a fullset Charset *\/\n+  bool serialize (hb_serialize_context_t *c, const Charset &src, unsigned int num_glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    unsigned int size = src.get_size (num_glyphs);\n+    Charset *dest = c->allocate_size<Charset> (size);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    memcpy (dest, &src, size);\n+    return_trace (true);\n+  }\n+\n+  \/* serialize a subset Charset *\/\n+  bool serialize (hb_serialize_context_t *c,\n+                  uint8_t format,\n+                  unsigned int num_glyphs,\n+                  const hb_vector_t<code_pair_t>& sid_ranges)\n+  {\n+    TRACE_SERIALIZE (this);\n+    Charset *dest = c->extend_min (*this);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    dest->format.set (format);\n+    if (format == 0)\n+    {\n+      Charset0 *fmt0 = c->allocate_size<Charset0> (Charset0::min_size + HBUINT16::static_size * (num_glyphs - 1));\n+    if (unlikely (fmt0 == nullptr)) return_trace (false);\n+      unsigned int glyph = 0;\n+      for (unsigned int i = 0; i < sid_ranges.length; i++)\n+      {\n+        hb_codepoint_t sid = sid_ranges[i].code;\n+        for (int left = (int)sid_ranges[i].glyph; left >= 0; left--)\n+          fmt0->sids[glyph++].set (sid++);\n+      }\n+    }\n+    else if (format == 1)\n+    {\n+      Charset1 *fmt1 = c->allocate_size<Charset1> (Charset1::min_size + Charset1_Range::static_size * sid_ranges.length);\n+      if (unlikely (fmt1 == nullptr)) return_trace (false);\n+      for (unsigned int i = 0; i < sid_ranges.length; i++)\n+      {\n+        if (unlikely (!(sid_ranges[i].glyph <= 0xFF)))\n+          return_trace (false);\n+        fmt1->ranges[i].first.set (sid_ranges[i].code);\n+        fmt1->ranges[i].nLeft.set (sid_ranges[i].glyph);\n+      }\n+    }\n+    else \/* format 2 *\/\n+    {\n+      Charset2 *fmt2 = c->allocate_size<Charset2> (Charset2::min_size + Charset2_Range::static_size * sid_ranges.length);\n+      if (unlikely (fmt2 == nullptr)) return_trace (false);\n+      for (unsigned int i = 0; i < sid_ranges.length; i++)\n+      {\n+        if (unlikely (!(sid_ranges[i].glyph <= 0xFFFF)))\n+          return_trace (false);\n+        fmt2->ranges[i].first.set (sid_ranges[i].code);\n+        fmt2->ranges[i].nLeft.set (sid_ranges[i].glyph);\n+      }\n+    }\n+    return_trace (true);\n+  }\n+\n+  \/* parallel to above: calculate the size of a subset Charset *\/\n+  static unsigned int calculate_serialized_size (\n+                        uint8_t format,\n+                        unsigned int count)\n+  {\n+    unsigned int  size = min_size;\n+    if (format == 0)\n+      size += Charset0::min_size + HBUINT16::static_size * (count - 1);\n+    else if (format == 1)\n+      size += Charset1::min_size + Charset1_Range::static_size * count;\n+    else\n+      size += Charset2::min_size + Charset2_Range::static_size * count;\n+\n+    return size;\n+  }\n+\n+  unsigned int get_size (unsigned int num_glyphs) const\n+  {\n+    unsigned int size = min_size;\n+    if (format == 0)\n+      size += u.format0.get_size (num_glyphs);\n+    else if (format == 1)\n+      size += u.format1.get_size (num_glyphs);\n+    else\n+      size += u.format2.get_size (num_glyphs);\n+    return size;\n+  }\n+\n+  hb_codepoint_t get_sid (hb_codepoint_t glyph) const\n+  {\n+    if (format == 0)\n+      return u.format0.get_sid (glyph);\n+    else if (format == 1)\n+      return u.format1.get_sid (glyph);\n+    else\n+      return u.format2.get_sid (glyph);\n+  }\n+\n+  hb_codepoint_t get_glyph (hb_codepoint_t sid, unsigned int num_glyphs) const\n+  {\n+    if (format == 0)\n+      return u.format0.get_glyph (sid, num_glyphs);\n+    else if (format == 1)\n+      return u.format1.get_glyph (sid, num_glyphs);\n+    else\n+      return u.format2.get_glyph (sid, num_glyphs);\n+  }\n+\n+  HBUINT8       format;\n+  union {\n+    Charset0    format0;\n+    Charset1    format1;\n+    Charset2    format2;\n+  } u;\n+\n+  DEFINE_SIZE_MIN (1);\n+};\n+\n+struct CFF1StringIndex : CFF1Index\n+{\n+  bool serialize (hb_serialize_context_t *c, const CFF1StringIndex &strings,\n+                  unsigned int offSize_, const remap_t &sidmap)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely ((strings.count == 0) || (sidmap.get_count () == 0)))\n+    {\n+      if (!unlikely (c->extend_min (this->count)))\n+        return_trace (false);\n+      count.set (0);\n+      return_trace (true);\n+    }\n+\n+    byte_str_array_t bytesArray;\n+    bytesArray.init ();\n+    if (!bytesArray.resize (sidmap.get_count ()))\n+      return_trace (false);\n+    for (unsigned int i = 0; i < strings.count; i++)\n+    {\n+      hb_codepoint_t  j = sidmap[i];\n+      if (j != CFF_UNDEF_CODE)\n+        bytesArray[j] = strings[i];\n+    }\n+\n+    bool result = CFF1Index::serialize (c, offSize_, bytesArray);\n+    bytesArray.fini ();\n+    return_trace (result);\n+  }\n+\n+  \/* in parallel to above *\/\n+  unsigned int calculate_serialized_size (unsigned int &offSize \/*OUT*\/, const remap_t &sidmap) const\n+  {\n+    offSize = 0;\n+    if ((count == 0) || (sidmap.get_count () == 0))\n+      return count.static_size;\n+\n+    unsigned int dataSize = 0;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (sidmap[i] != CFF_UNDEF_CODE)\n+        dataSize += length_at (i);\n+\n+    offSize = calcOffSize(dataSize);\n+    return CFF1Index::calculate_serialized_size (offSize, sidmap.get_count (), dataSize);\n+  }\n+};\n+\n+struct cff1_top_dict_interp_env_t : num_interp_env_t\n+{\n+  cff1_top_dict_interp_env_t ()\n+    : num_interp_env_t(), prev_offset(0), last_offset(0) {}\n+\n+  unsigned int prev_offset;\n+  unsigned int last_offset;\n+};\n+\n+struct name_dict_values_t\n+{\n+  enum name_dict_val_index_t\n+  {\n+      version,\n+      notice,\n+      copyright,\n+      fullName,\n+      familyName,\n+      weight,\n+      postscript,\n+      fontName,\n+      baseFontName,\n+      registry,\n+      ordering,\n+\n+      ValCount\n+  };\n+\n+  void init ()\n+  {\n+    for (unsigned int i = 0; i < ValCount; i++)\n+      values[i] = CFF_UNDEF_SID;\n+  }\n+\n+  unsigned int& operator[] (unsigned int i)\n+  { assert (i < ValCount); return values[i]; }\n+\n+  unsigned int operator[] (unsigned int i) const\n+  { assert (i < ValCount); return values[i]; }\n+\n+  static enum name_dict_val_index_t name_op_to_index (op_code_t op)\n+  {\n+    switch (op) {\n+      default: \/\/ can't happen - just make some compiler happy\n+      case OpCode_version:\n+        return version;\n+      case OpCode_Notice:\n+        return notice;\n+      case OpCode_Copyright:\n+        return copyright;\n+      case OpCode_FullName:\n+        return fullName;\n+      case OpCode_FamilyName:\n+        return familyName;\n+      case OpCode_Weight:\n+        return weight;\n+      case OpCode_PostScript:\n+        return postscript;\n+      case OpCode_FontName:\n+        return fontName;\n+      case OpCode_BaseFontName:\n+        return baseFontName;\n+    }\n+  }\n+\n+  unsigned int  values[ValCount];\n+};\n+\n+struct cff1_top_dict_val_t : op_str_t\n+{\n+  unsigned int  last_arg_offset;\n+};\n+\n+struct cff1_top_dict_values_t : top_dict_values_t<cff1_top_dict_val_t>\n+{\n+  void init ()\n+  {\n+    top_dict_values_t<cff1_top_dict_val_t>::init ();\n+\n+    nameSIDs.init ();\n+    ros_supplement = 0;\n+    cidCount = 8720;\n+    EncodingOffset = 0;\n+    CharsetOffset = 0;\n+    FDSelectOffset = 0;\n+    privateDictInfo.init ();\n+  }\n+  void fini () { top_dict_values_t<cff1_top_dict_val_t>::fini (); }\n+\n+  bool is_CID () const\n+  { return nameSIDs[name_dict_values_t::registry] != CFF_UNDEF_SID; }\n+\n+  name_dict_values_t  nameSIDs;\n+  unsigned int    ros_supplement_offset;\n+  unsigned int    ros_supplement;\n+  unsigned int    cidCount;\n+\n+  unsigned int    EncodingOffset;\n+  unsigned int    CharsetOffset;\n+  unsigned int    FDSelectOffset;\n+  table_info_t       privateDictInfo;\n+};\n+\n+struct cff1_top_dict_opset_t : top_dict_opset_t<cff1_top_dict_val_t>\n+{\n+  static void process_op (op_code_t op, cff1_top_dict_interp_env_t& env, cff1_top_dict_values_t& dictval)\n+  {\n+    cff1_top_dict_val_t  val;\n+    val.last_arg_offset = (env.last_offset-1) - dictval.opStart;  \/* offset to the last argument *\/\n+\n+    switch (op) {\n+      case OpCode_version:\n+      case OpCode_Notice:\n+      case OpCode_Copyright:\n+      case OpCode_FullName:\n+      case OpCode_FamilyName:\n+      case OpCode_Weight:\n+      case OpCode_PostScript:\n+      case OpCode_BaseFontName:\n+        dictval.nameSIDs[name_dict_values_t::name_op_to_index (op)] = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_isFixedPitch:\n+      case OpCode_ItalicAngle:\n+      case OpCode_UnderlinePosition:\n+      case OpCode_UnderlineThickness:\n+      case OpCode_PaintType:\n+      case OpCode_CharstringType:\n+      case OpCode_UniqueID:\n+      case OpCode_StrokeWidth:\n+      case OpCode_SyntheticBase:\n+      case OpCode_CIDFontVersion:\n+      case OpCode_CIDFontRevision:\n+      case OpCode_CIDFontType:\n+      case OpCode_UIDBase:\n+      case OpCode_FontBBox:\n+      case OpCode_XUID:\n+      case OpCode_BaseFontBlend:\n+        env.clear_args ();\n+        break;\n+\n+      case OpCode_CIDCount:\n+        dictval.cidCount = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      case OpCode_ROS:\n+        dictval.ros_supplement = env.argStack.pop_uint ();\n+        dictval.nameSIDs[name_dict_values_t::ordering] = env.argStack.pop_uint ();\n+        dictval.nameSIDs[name_dict_values_t::registry] = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      case OpCode_Encoding:\n+        dictval.EncodingOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        if (unlikely (dictval.EncodingOffset == 0)) return;\n+        break;\n+\n+      case OpCode_charset:\n+        dictval.CharsetOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        if (unlikely (dictval.CharsetOffset == 0)) return;\n+        break;\n+\n+      case OpCode_FDSelect:\n+        dictval.FDSelectOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      case OpCode_Private:\n+        dictval.privateDictInfo.offset = env.argStack.pop_uint ();\n+        dictval.privateDictInfo.size = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      default:\n+        env.last_offset = env.str_ref.offset;\n+        top_dict_opset_t<cff1_top_dict_val_t>::process_op (op, env, dictval);\n+        \/* Record this operand below if stack is empty, otherwise done *\/\n+        if (!env.argStack.is_empty ()) return;\n+        break;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref, val);\n+  }\n+};\n+\n+struct cff1_font_dict_values_t : dict_values_t<op_str_t>\n+{\n+  void init ()\n+  {\n+    dict_values_t<op_str_t>::init ();\n+    privateDictInfo.init ();\n+    fontName = CFF_UNDEF_SID;\n+  }\n+  void fini () { dict_values_t<op_str_t>::fini (); }\n+\n+  table_info_t       privateDictInfo;\n+  unsigned int    fontName;\n+};\n+\n+struct cff1_font_dict_opset_t : dict_opset_t\n+{\n+  static void process_op (op_code_t op, num_interp_env_t& env, cff1_font_dict_values_t& dictval)\n+  {\n+    switch (op) {\n+      case OpCode_FontName:\n+        dictval.fontName = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_FontMatrix:\n+      case OpCode_PaintType:\n+        env.clear_args ();\n+        break;\n+      case OpCode_Private:\n+        dictval.privateDictInfo.offset = env.argStack.pop_uint ();\n+        dictval.privateDictInfo.size = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      default:\n+        dict_opset_t::process_op (op, env);\n+        if (!env.argStack.is_empty ()) return;\n+        break;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref);\n+  }\n+};\n+\n+template <typename VAL>\n+struct cff1_private_dict_values_base_t : dict_values_t<VAL>\n+{\n+  void init ()\n+  {\n+    dict_values_t<VAL>::init ();\n+    subrsOffset = 0;\n+    localSubrs = &Null(CFF1Subrs);\n+  }\n+  void fini () { dict_values_t<VAL>::fini (); }\n+\n+  unsigned int calculate_serialized_size () const\n+  {\n+    unsigned int size = 0;\n+    for (unsigned int i = 0; i < dict_values_t<VAL>::get_count; i++)\n+      if (dict_values_t<VAL>::get_value (i).op == OpCode_Subrs)\n+        size += OpCode_Size (OpCode_shortint) + 2 + OpCode_Size (OpCode_Subrs);\n+      else\n+        size += dict_values_t<VAL>::get_value (i).str.length;\n+    return size;\n+  }\n+\n+  unsigned int      subrsOffset;\n+  const CFF1Subrs    *localSubrs;\n+};\n+\n+typedef cff1_private_dict_values_base_t<op_str_t> cff1_private_dict_values_subset_t;\n+typedef cff1_private_dict_values_base_t<num_dict_val_t> cff1_private_dict_values_t;\n+\n+struct cff1_private_dict_opset_t : dict_opset_t\n+{\n+  static void process_op (op_code_t op, num_interp_env_t& env, cff1_private_dict_values_t& dictval)\n+  {\n+    num_dict_val_t val;\n+    val.init ();\n+\n+    switch (op) {\n+      case OpCode_BlueValues:\n+      case OpCode_OtherBlues:\n+      case OpCode_FamilyBlues:\n+      case OpCode_FamilyOtherBlues:\n+      case OpCode_StemSnapH:\n+      case OpCode_StemSnapV:\n+        env.clear_args ();\n+        break;\n+      case OpCode_StdHW:\n+      case OpCode_StdVW:\n+      case OpCode_BlueScale:\n+      case OpCode_BlueShift:\n+      case OpCode_BlueFuzz:\n+      case OpCode_ForceBold:\n+      case OpCode_LanguageGroup:\n+      case OpCode_ExpansionFactor:\n+      case OpCode_initialRandomSeed:\n+      case OpCode_defaultWidthX:\n+      case OpCode_nominalWidthX:\n+        val.single_val = env.argStack.pop_num ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_Subrs:\n+        dictval.subrsOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      default:\n+        dict_opset_t::process_op (op, env);\n+        if (!env.argStack.is_empty ()) return;\n+        break;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref, val);\n+  }\n+};\n+\n+struct cff1_private_dict_opset_subset : dict_opset_t\n+{\n+  static void process_op (op_code_t op, num_interp_env_t& env, cff1_private_dict_values_subset_t& dictval)\n+  {\n+    switch (op) {\n+      case OpCode_BlueValues:\n+      case OpCode_OtherBlues:\n+      case OpCode_FamilyBlues:\n+      case OpCode_FamilyOtherBlues:\n+      case OpCode_StemSnapH:\n+      case OpCode_StemSnapV:\n+      case OpCode_StdHW:\n+      case OpCode_StdVW:\n+      case OpCode_BlueScale:\n+      case OpCode_BlueShift:\n+      case OpCode_BlueFuzz:\n+      case OpCode_ForceBold:\n+      case OpCode_LanguageGroup:\n+      case OpCode_ExpansionFactor:\n+      case OpCode_initialRandomSeed:\n+      case OpCode_defaultWidthX:\n+      case OpCode_nominalWidthX:\n+        env.clear_args ();\n+        break;\n+\n+      case OpCode_Subrs:\n+        dictval.subrsOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      default:\n+        dict_opset_t::process_op (op, env);\n+        if (!env.argStack.is_empty ()) return;\n+        break;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref);\n+  }\n+};\n+\n+typedef dict_interpreter_t<cff1_top_dict_opset_t, cff1_top_dict_values_t, cff1_top_dict_interp_env_t> cff1_top_dict_interpreter_t;\n+typedef dict_interpreter_t<cff1_font_dict_opset_t, cff1_font_dict_values_t> cff1_font_dict_interpreter_t;\n+\n+typedef CFF1Index CFF1NameIndex;\n+typedef CFF1IndexOf<TopDict> CFF1TopDictIndex;\n+\n+} \/* namespace CFF *\/\n+\n+namespace OT {\n+\n+using namespace CFF;\n+\n+struct cff1\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_cff1;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  likely (version.major == 1));\n+  }\n+\n+  template <typename PRIVOPSET, typename PRIVDICTVAL>\n+  struct accelerator_templ_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      topDict.init ();\n+      fontDicts.init ();\n+      privateDicts.init ();\n+\n+      this->blob = sc.reference_table<cff1> (face);\n+\n+      \/* setup for run-time santization *\/\n+      sc.init (this->blob);\n+      sc.start_processing ();\n+\n+      const OT::cff1 *cff = this->blob->template as<OT::cff1> ();\n+\n+      if (cff == &Null(OT::cff1))\n+      { fini (); return; }\n+\n+      nameIndex = &cff->nameIndex (cff);\n+      if ((nameIndex == &Null (CFF1NameIndex)) || !nameIndex->sanitize (&sc))\n+      { fini (); return; }\n+\n+      topDictIndex = &StructAtOffset<CFF1TopDictIndex> (nameIndex, nameIndex->get_size ());\n+      if ((topDictIndex == &Null (CFF1TopDictIndex)) || !topDictIndex->sanitize (&sc) || (topDictIndex->count == 0))\n+      { fini (); return; }\n+\n+      { \/* parse top dict *\/\n+        const byte_str_t topDictStr = (*topDictIndex)[0];\n+        if (unlikely (!topDictStr.sanitize (&sc))) { fini (); return; }\n+        cff1_top_dict_interpreter_t top_interp;\n+        top_interp.env.init (topDictStr);\n+        topDict.init ();\n+        if (unlikely (!top_interp.interpret (topDict))) { fini (); return; }\n+      }\n+\n+      if (is_predef_charset ())\n+        charset = &Null(Charset);\n+      else\n+      {\n+        charset = &StructAtOffsetOrNull<Charset> (cff, topDict.CharsetOffset);\n+        if (unlikely ((charset == &Null (Charset)) || !charset->sanitize (&sc))) { fini (); return; }\n+      }\n+\n+      fdCount = 1;\n+      if (is_CID ())\n+      {\n+        fdArray = &StructAtOffsetOrNull<CFF1FDArray> (cff, topDict.FDArrayOffset);\n+        fdSelect = &StructAtOffsetOrNull<CFF1FDSelect> (cff, topDict.FDSelectOffset);\n+        if (unlikely ((fdArray == &Null(CFF1FDArray)) || !fdArray->sanitize (&sc) ||\n+            (fdSelect == &Null(CFF1FDSelect)) || !fdSelect->sanitize (&sc, fdArray->count)))\n+        { fini (); return; }\n+\n+        fdCount = fdArray->count;\n+      }\n+      else\n+      {\n+        fdArray = &Null(CFF1FDArray);\n+        fdSelect = &Null(CFF1FDSelect);\n+      }\n+\n+      stringIndex = &StructAtOffset<CFF1StringIndex> (topDictIndex, topDictIndex->get_size ());\n+      if ((stringIndex == &Null (CFF1StringIndex)) || !stringIndex->sanitize (&sc))\n+      { fini (); return; }\n+\n+      globalSubrs = &StructAtOffset<CFF1Subrs> (stringIndex, stringIndex->get_size ());\n+      if ((globalSubrs != &Null (CFF1Subrs)) && !globalSubrs->sanitize (&sc))\n+      { fini (); return; }\n+\n+      charStrings = &StructAtOffsetOrNull<CFF1CharStrings> (cff, topDict.charStringsOffset);\n+\n+      if ((charStrings == &Null(CFF1CharStrings)) || unlikely (!charStrings->sanitize (&sc)))\n+      { fini (); return; }\n+\n+      num_glyphs = charStrings->count;\n+      if (num_glyphs != sc.get_num_glyphs ())\n+      { fini (); return; }\n+\n+      privateDicts.resize (fdCount);\n+      for (unsigned int i = 0; i < fdCount; i++)\n+        privateDicts[i].init ();\n+\n+      \/\/ parse CID font dicts and gather private dicts\n+      if (is_CID ())\n+      {\n+        for (unsigned int i = 0; i < fdCount; i++)\n+        {\n+          byte_str_t fontDictStr = (*fdArray)[i];\n+          if (unlikely (!fontDictStr.sanitize (&sc))) { fini (); return; }\n+          cff1_font_dict_values_t  *font;\n+          cff1_font_dict_interpreter_t font_interp;\n+          font_interp.env.init (fontDictStr);\n+          font = fontDicts.push ();\n+          if (unlikely (font == &Crap(cff1_font_dict_values_t))) { fini (); return; }\n+          font->init ();\n+          if (unlikely (!font_interp.interpret (*font))) { fini (); return; }\n+          PRIVDICTVAL  *priv = &privateDicts[i];\n+          const byte_str_t privDictStr (StructAtOffset<UnsizedByteStr> (cff, font->privateDictInfo.offset), font->privateDictInfo.size);\n+          if (unlikely (!privDictStr.sanitize (&sc))) { fini (); return; }\n+          dict_interpreter_t<PRIVOPSET, PRIVDICTVAL> priv_interp;\n+          priv_interp.env.init (privDictStr);\n+          priv->init ();\n+          if (unlikely (!priv_interp.interpret (*priv))) { fini (); return; }\n+\n+          priv->localSubrs = &StructAtOffsetOrNull<CFF1Subrs> (&privDictStr, priv->subrsOffset);\n+          if (priv->localSubrs != &Null(CFF1Subrs) &&\n+              unlikely (!priv->localSubrs->sanitize (&sc)))\n+          { fini (); return; }\n+        }\n+      }\n+      else  \/* non-CID *\/\n+      {\n+        cff1_top_dict_values_t  *font = &topDict;\n+        PRIVDICTVAL  *priv = &privateDicts[0];\n+\n+        const byte_str_t privDictStr (StructAtOffset<UnsizedByteStr> (cff, font->privateDictInfo.offset), font->privateDictInfo.size);\n+        if (unlikely (!privDictStr.sanitize (&sc))) { fini (); return; }\n+        dict_interpreter_t<PRIVOPSET, PRIVDICTVAL> priv_interp;\n+        priv_interp.env.init (privDictStr);\n+        priv->init ();\n+        if (unlikely (!priv_interp.interpret (*priv))) { fini (); return; }\n+\n+        priv->localSubrs = &StructAtOffsetOrNull<CFF1Subrs> (&privDictStr, priv->subrsOffset);\n+        if (priv->localSubrs != &Null(CFF1Subrs) &&\n+            unlikely (!priv->localSubrs->sanitize (&sc)))\n+        { fini (); return; }\n+      }\n+    }\n+\n+    void fini ()\n+    {\n+      sc.end_processing ();\n+      topDict.fini ();\n+      fontDicts.fini_deep ();\n+      privateDicts.fini_deep ();\n+      hb_blob_destroy (blob);\n+      blob = nullptr;\n+    }\n+\n+    bool is_valid () const { return blob != nullptr; }\n+    bool is_CID () const { return topDict.is_CID (); }\n+\n+    bool is_predef_charset () const { return topDict.CharsetOffset <= ExpertSubsetCharset; }\n+\n+    unsigned int std_code_to_glyph (hb_codepoint_t code) const\n+    {\n+      hb_codepoint_t sid = lookup_standard_encoding_for_sid (code);\n+      if (unlikely (sid == CFF_UNDEF_SID))\n+        return 0;\n+\n+      if (charset != &Null(Charset))\n+        return charset->get_glyph (sid, num_glyphs);\n+      else if ((topDict.CharsetOffset == ISOAdobeCharset)\n+              && (code <= 228 \/*zcaron*\/)) return sid;\n+      return 0;\n+    }\n+\n+    protected:\n+    hb_blob_t          *blob;\n+    hb_sanitize_context_t   sc;\n+\n+    public:\n+    const Charset          *charset;\n+    const CFF1NameIndex     *nameIndex;\n+    const CFF1TopDictIndex  *topDictIndex;\n+    const CFF1StringIndex   *stringIndex;\n+    const CFF1Subrs      *globalSubrs;\n+    const CFF1CharStrings   *charStrings;\n+    const CFF1FDArray       *fdArray;\n+    const CFF1FDSelect      *fdSelect;\n+    unsigned int            fdCount;\n+\n+    cff1_top_dict_values_t       topDict;\n+    hb_vector_t<cff1_font_dict_values_t>   fontDicts;\n+    hb_vector_t<PRIVDICTVAL>      privateDicts;\n+\n+    unsigned int            num_glyphs;\n+  };\n+\n+  struct accelerator_t : accelerator_templ_t<cff1_private_dict_opset_t, cff1_private_dict_values_t>\n+  {\n+    HB_INTERNAL bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const;\n+    HB_INTERNAL bool get_seac_components (hb_codepoint_t glyph, hb_codepoint_t *base, hb_codepoint_t *accent) const;\n+  };\n+\n+  struct accelerator_subset_t : accelerator_templ_t<cff1_private_dict_opset_subset, cff1_private_dict_values_subset_t>\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      SUPER::init (face);\n+      if (blob == nullptr) return;\n+\n+      const OT::cff1 *cff = this->blob->as<OT::cff1> ();\n+      encoding = &Null(Encoding);\n+      if (is_CID ())\n+      {\n+        if (unlikely (charset == &Null(Charset))) { fini (); return; }\n+      }\n+      else\n+      {\n+        if (!is_predef_encoding ())\n+        {\n+          encoding = &StructAtOffsetOrNull<Encoding> (cff, topDict.EncodingOffset);\n+          if (unlikely ((encoding == &Null (Encoding)) || !encoding->sanitize (&sc))) { fini (); return; }\n+        }\n+      }\n+    }\n+\n+    bool is_predef_encoding () const { return topDict.EncodingOffset <= ExpertEncoding; }\n+\n+    hb_codepoint_t  glyph_to_code (hb_codepoint_t glyph) const\n+    {\n+      if (encoding != &Null(Encoding))\n+        return encoding->get_code (glyph);\n+      else\n+      {\n+        hb_codepoint_t  sid = glyph_to_sid (glyph);\n+        if (sid == 0) return 0;\n+        hb_codepoint_t  code = 0;\n+        switch (topDict.EncodingOffset)\n+        {\n+          case  StandardEncoding:\n+            code = lookup_standard_encoding_for_code (sid);\n+            break;\n+          case  ExpertEncoding:\n+            code = lookup_expert_encoding_for_code (sid);\n+            break;\n+          default:\n+            break;\n+        }\n+        return code;\n+      }\n+    }\n+\n+    hb_codepoint_t glyph_to_sid (hb_codepoint_t glyph) const\n+    {\n+      if (charset != &Null(Charset))\n+        return charset->get_sid (glyph);\n+      else\n+      {\n+        hb_codepoint_t sid = 0;\n+        switch (topDict.CharsetOffset)\n+        {\n+          case  ISOAdobeCharset:\n+            if (glyph <= 228 \/*zcaron*\/) sid = glyph;\n+            break;\n+          case  ExpertCharset:\n+            sid = lookup_expert_charset_for_sid (glyph);\n+            break;\n+          case  ExpertSubsetCharset:\n+              sid = lookup_expert_subset_charset_for_sid (glyph);\n+            break;\n+          default:\n+            break;\n+        }\n+        return sid;\n+      }\n+    }\n+\n+    const Encoding        *encoding;\n+\n+    private:\n+    typedef accelerator_templ_t<cff1_private_dict_opset_subset, cff1_private_dict_values_subset_t> SUPER;\n+  };\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    hb_blob_t *cff_prime = nullptr;\n+\n+    bool success = true;\n+    if (hb_subset_cff1 (plan, &cff_prime)) {\n+      success = success && plan->add_table (HB_OT_TAG_cff1, cff_prime);\n+      hb_blob_t *head_blob = hb_sanitize_context_t().reference_table<head> (plan->source);\n+      success = success && head_blob && plan->add_table (HB_OT_TAG_head, head_blob);\n+      hb_blob_destroy (head_blob);\n+    } else {\n+      success = false;\n+    }\n+    hb_blob_destroy (cff_prime);\n+\n+    return success;\n+  }\n+\n+  protected:\n+  HB_INTERNAL static hb_codepoint_t lookup_standard_encoding_for_code (hb_codepoint_t sid);\n+  HB_INTERNAL static hb_codepoint_t lookup_expert_encoding_for_code (hb_codepoint_t sid);\n+  HB_INTERNAL static hb_codepoint_t lookup_expert_charset_for_sid (hb_codepoint_t glyph);\n+  HB_INTERNAL static hb_codepoint_t lookup_expert_subset_charset_for_sid (hb_codepoint_t glyph);\n+  HB_INTERNAL static hb_codepoint_t lookup_standard_encoding_for_sid (hb_codepoint_t code);\n+\n+  public:\n+  FixedVersion<HBUINT8> version;          \/* Version of CFF table. set to 0x0100u *\/\n+  OffsetTo<CFF1NameIndex, HBUINT8> nameIndex; \/* headerSize = Offset to Name INDEX. *\/\n+  HBUINT8              offSize;   \/* offset size (unused?) *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct cff1_accelerator_t : cff1::accelerator_t {};\n+} \/* namespace OT *\/\n+\n+#endif \/* HB_OT_CFF1_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-cff1-table.hh","additions":1299,"deletions":0,"binary":false,"changes":1299,"status":"added"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#include \"hb-ot-cff2-table.hh\"\n+#include \"hb-cff2-interp-cs.hh\"\n+\n+using namespace CFF;\n+\n+struct extents_param_t\n+{\n+  void init ()\n+  {\n+    path_open = false;\n+    min_x.set_int (0x7FFFFFFF);\n+    min_y.set_int (0x7FFFFFFF);\n+    max_x.set_int (-0x80000000);\n+    max_y.set_int (-0x80000000);\n+  }\n+\n+  void start_path ()         { path_open = true; }\n+  void end_path ()           { path_open = false; }\n+  bool is_path_open () const { return path_open; }\n+\n+  void update_bounds (const point_t &pt)\n+  {\n+    if (pt.x < min_x) min_x = pt.x;\n+    if (pt.x > max_x) max_x = pt.x;\n+    if (pt.y < min_y) min_y = pt.y;\n+    if (pt.y > max_y) max_y = pt.y;\n+  }\n+\n+  bool  path_open;\n+  number_t min_x;\n+  number_t min_y;\n+  number_t max_x;\n+  number_t max_y;\n+};\n+\n+struct cff2_path_procs_extents_t : path_procs_t<cff2_path_procs_extents_t, cff2_cs_interp_env_t, extents_param_t>\n+{\n+  static void moveto (cff2_cs_interp_env_t &env, extents_param_t& param, const point_t &pt)\n+  {\n+    param.end_path ();\n+    env.moveto (pt);\n+  }\n+\n+  static void line (cff2_cs_interp_env_t &env, extents_param_t& param, const point_t &pt1)\n+  {\n+    if (!param.is_path_open ())\n+    {\n+      param.start_path ();\n+      param.update_bounds (env.get_pt ());\n+    }\n+    env.moveto (pt1);\n+    param.update_bounds (env.get_pt ());\n+  }\n+\n+  static void curve (cff2_cs_interp_env_t &env, extents_param_t& param, const point_t &pt1, const point_t &pt2, const point_t &pt3)\n+  {\n+    if (!param.is_path_open ())\n+    {\n+      param.start_path ();\n+      param.update_bounds (env.get_pt ());\n+    }\n+    \/* include control points *\/\n+    param.update_bounds (pt1);\n+    param.update_bounds (pt2);\n+    env.moveto (pt3);\n+    param.update_bounds (env.get_pt ());\n+  }\n+};\n+\n+struct cff2_cs_opset_extents_t : cff2_cs_opset_t<cff2_cs_opset_extents_t, extents_param_t, cff2_path_procs_extents_t> {};\n+\n+bool OT::cff2::accelerator_t::get_extents (hb_font_t *font,\n+                                           hb_codepoint_t glyph,\n+                                           hb_glyph_extents_t *extents) const\n+{\n+  if (unlikely (!is_valid () || (glyph >= num_glyphs))) return false;\n+\n+  unsigned int num_coords;\n+  const int *coords = hb_font_get_var_coords_normalized (font, &num_coords);\n+  unsigned int fd = fdSelect->get_fd (glyph);\n+  cff2_cs_interpreter_t<cff2_cs_opset_extents_t, extents_param_t> interp;\n+  const byte_str_t str = (*charStrings)[glyph];\n+  interp.env.init (str, *this, fd, coords, num_coords);\n+  extents_param_t  param;\n+  param.init ();\n+  if (unlikely (!interp.interpret (param))) return false;\n+\n+  if (param.min_x >= param.max_x)\n+  {\n+    extents->width = 0;\n+    extents->x_bearing = 0;\n+  }\n+  else\n+  {\n+    extents->x_bearing = (int32_t)param.min_x.floor ();\n+    extents->width = (int32_t)param.max_x.ceil () - extents->x_bearing;\n+  }\n+  if (param.min_y >= param.max_y)\n+  {\n+    extents->height = 0;\n+    extents->y_bearing = 0;\n+  }\n+  else\n+  {\n+    extents->y_bearing = (int32_t)param.max_y.ceil ();\n+    extents->height = (int32_t)param.min_y.floor () - extents->y_bearing;\n+  }\n+\n+  return true;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-cff2-table.cc","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,566 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#ifndef HB_OT_CFF2_TABLE_HH\n+#define HB_OT_CFF2_TABLE_HH\n+\n+#include \"hb-ot-head-table.hh\"\n+#include \"hb-ot-cff-common.hh\"\n+#include \"hb-subset-cff2.hh\"\n+\n+namespace CFF {\n+\n+\/*\n+ * CFF2 -- Compact Font Format (CFF) Version 2\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cff2\n+ *\/\n+#define HB_OT_TAG_cff2 HB_TAG('C','F','F','2')\n+\n+typedef CFFIndex<HBUINT32>  CFF2Index;\n+template <typename Type> struct CFF2IndexOf : CFFIndexOf<HBUINT32, Type> {};\n+\n+typedef CFF2Index         CFF2CharStrings;\n+typedef FDArray<HBUINT32> CFF2FDArray;\n+typedef Subrs<HBUINT32>   CFF2Subrs;\n+\n+typedef FDSelect3_4<HBUINT32, HBUINT16> FDSelect4;\n+typedef FDSelect3_4_Range<HBUINT32, HBUINT16> FDSelect4_Range;\n+\n+struct CFF2FDSelect\n+{\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int fdcount) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    return_trace (likely (c->check_struct (this) && (format == 0 || format == 3 || format == 4) &&\n+                          (format == 0)?\n+                          u.format0.sanitize (c, fdcount):\n+                            ((format == 3)?\n+                            u.format3.sanitize (c, fdcount):\n+                            u.format4.sanitize (c, fdcount))));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c, const CFF2FDSelect &src, unsigned int num_glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    unsigned int size = src.get_size (num_glyphs);\n+    CFF2FDSelect *dest = c->allocate_size<CFF2FDSelect> (size);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    memcpy (dest, &src, size);\n+    return_trace (true);\n+  }\n+\n+  unsigned int calculate_serialized_size (unsigned int num_glyphs) const\n+  { return get_size (num_glyphs); }\n+\n+  unsigned int get_size (unsigned int num_glyphs) const\n+  {\n+    unsigned int size = format.static_size;\n+    if (format == 0)\n+      size += u.format0.get_size (num_glyphs);\n+    else if (format == 3)\n+      size += u.format3.get_size ();\n+    else\n+      size += u.format4.get_size ();\n+    return size;\n+  }\n+\n+  hb_codepoint_t get_fd (hb_codepoint_t glyph) const\n+  {\n+    if (this == &Null(CFF2FDSelect))\n+      return 0;\n+    if (format == 0)\n+      return u.format0.get_fd (glyph);\n+    else if (format == 3)\n+      return u.format3.get_fd (glyph);\n+    else\n+      return u.format4.get_fd (glyph);\n+  }\n+\n+  HBUINT8       format;\n+  union {\n+    FDSelect0   format0;\n+    FDSelect3   format3;\n+    FDSelect4   format4;\n+  } u;\n+\n+  DEFINE_SIZE_MIN (2);\n+};\n+\n+struct CFF2VariationStore\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)) && c->check_range (&varStore, size) && varStore.sanitize (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c, const CFF2VariationStore *varStore)\n+  {\n+    TRACE_SERIALIZE (this);\n+    unsigned int size_ = varStore->get_size ();\n+    CFF2VariationStore *dest = c->allocate_size<CFF2VariationStore> (size_);\n+    if (unlikely (dest == nullptr)) return_trace (false);\n+    memcpy (dest, varStore, size_);\n+    return_trace (true);\n+  }\n+\n+  unsigned int get_size () const { return HBUINT16::static_size + size; }\n+\n+  HBUINT16      size;\n+  VariationStore  varStore;\n+\n+  DEFINE_SIZE_MIN (2 + VariationStore::min_size);\n+};\n+\n+struct cff2_top_dict_values_t : top_dict_values_t<>\n+{\n+  void init ()\n+  {\n+    top_dict_values_t<>::init ();\n+    vstoreOffset = 0;\n+    FDSelectOffset = 0;\n+  }\n+  void fini () { top_dict_values_t<>::fini (); }\n+\n+  unsigned int calculate_serialized_size () const\n+  {\n+    unsigned int size = 0;\n+    for (unsigned int i = 0; i < get_count (); i++)\n+    {\n+      op_code_t op = get_value (i).op;\n+      switch (op)\n+      {\n+        case OpCode_vstore:\n+        case OpCode_FDSelect:\n+          size += OpCode_Size (OpCode_longintdict) + 4 + OpCode_Size (op);\n+          break;\n+        default:\n+          size += top_dict_values_t<>::calculate_serialized_op_size (get_value (i));\n+          break;\n+      }\n+    }\n+    return size;\n+  }\n+\n+  unsigned int  vstoreOffset;\n+  unsigned int  FDSelectOffset;\n+};\n+\n+struct cff2_top_dict_opset_t : top_dict_opset_t<>\n+{\n+  static void process_op (op_code_t op, num_interp_env_t& env, cff2_top_dict_values_t& dictval)\n+  {\n+    switch (op) {\n+      case OpCode_FontMatrix:\n+        {\n+          dict_val_t val;\n+          val.init ();\n+          dictval.add_op (op, env.str_ref);\n+          env.clear_args ();\n+        }\n+        break;\n+\n+      case OpCode_vstore:\n+        dictval.vstoreOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_FDSelect:\n+        dictval.FDSelectOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env, dictval);\n+        \/* Record this operand below if stack is empty, otherwise done *\/\n+        if (!env.argStack.is_empty ()) return;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref);\n+  }\n+\n+  typedef top_dict_opset_t<> SUPER;\n+};\n+\n+struct cff2_font_dict_values_t : dict_values_t<op_str_t>\n+{\n+  void init ()\n+  {\n+    dict_values_t<op_str_t>::init ();\n+    privateDictInfo.init ();\n+  }\n+  void fini () { dict_values_t<op_str_t>::fini (); }\n+\n+  table_info_t    privateDictInfo;\n+};\n+\n+struct cff2_font_dict_opset_t : dict_opset_t\n+{\n+  static void process_op (op_code_t op, num_interp_env_t& env, cff2_font_dict_values_t& dictval)\n+  {\n+    switch (op) {\n+      case OpCode_Private:\n+        dictval.privateDictInfo.offset = env.argStack.pop_uint ();\n+        dictval.privateDictInfo.size = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env);\n+        if (!env.argStack.is_empty ())\n+          return;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref);\n+  }\n+\n+  private:\n+  typedef dict_opset_t SUPER;\n+};\n+\n+template <typename VAL>\n+struct cff2_private_dict_values_base_t : dict_values_t<VAL>\n+{\n+  void init ()\n+  {\n+    dict_values_t<VAL>::init ();\n+    subrsOffset = 0;\n+    localSubrs = &Null(CFF2Subrs);\n+    ivs = 0;\n+  }\n+  void fini () { dict_values_t<VAL>::fini (); }\n+\n+  unsigned int calculate_serialized_size () const\n+  {\n+    unsigned int size = 0;\n+    for (unsigned int i = 0; i < dict_values_t<VAL>::get_count; i++)\n+      if (dict_values_t<VAL>::get_value (i).op == OpCode_Subrs)\n+        size += OpCode_Size (OpCode_shortint) + 2 + OpCode_Size (OpCode_Subrs);\n+      else\n+        size += dict_values_t<VAL>::get_value (i).str.length;\n+    return size;\n+  }\n+\n+  unsigned int      subrsOffset;\n+  const CFF2Subrs   *localSubrs;\n+  unsigned int      ivs;\n+};\n+\n+typedef cff2_private_dict_values_base_t<op_str_t> cff2_private_dict_values_subset_t;\n+typedef cff2_private_dict_values_base_t<num_dict_val_t> cff2_private_dict_values_t;\n+\n+struct cff2_priv_dict_interp_env_t : num_interp_env_t\n+{\n+  void init (const byte_str_t &str)\n+  {\n+    num_interp_env_t::init (str);\n+    ivs = 0;\n+    seen_vsindex = false;\n+  }\n+\n+  void process_vsindex ()\n+  {\n+    if (likely (!seen_vsindex))\n+    {\n+      set_ivs (argStack.pop_uint ());\n+    }\n+    seen_vsindex = true;\n+  }\n+\n+  unsigned int get_ivs () const { return ivs; }\n+  void   set_ivs (unsigned int ivs_) { ivs = ivs_; }\n+\n+  protected:\n+  unsigned int  ivs;\n+  bool    seen_vsindex;\n+};\n+\n+struct cff2_private_dict_opset_t : dict_opset_t\n+{\n+  static void process_op (op_code_t op, cff2_priv_dict_interp_env_t& env, cff2_private_dict_values_t& dictval)\n+  {\n+    num_dict_val_t val;\n+    val.init ();\n+\n+    switch (op) {\n+      case OpCode_StdHW:\n+      case OpCode_StdVW:\n+      case OpCode_BlueScale:\n+      case OpCode_BlueShift:\n+      case OpCode_BlueFuzz:\n+      case OpCode_ExpansionFactor:\n+      case OpCode_LanguageGroup:\n+        val.single_val = env.argStack.pop_num ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_BlueValues:\n+      case OpCode_OtherBlues:\n+      case OpCode_FamilyBlues:\n+      case OpCode_FamilyOtherBlues:\n+      case OpCode_StemSnapH:\n+      case OpCode_StemSnapV:\n+        env.clear_args ();\n+        break;\n+      case OpCode_Subrs:\n+        dictval.subrsOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_vsindexdict:\n+        env.process_vsindex ();\n+        dictval.ivs = env.get_ivs ();\n+        env.clear_args ();\n+        break;\n+      case OpCode_blenddict:\n+        break;\n+\n+      default:\n+        dict_opset_t::process_op (op, env);\n+        if (!env.argStack.is_empty ()) return;\n+        break;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref, val);\n+  }\n+};\n+\n+struct cff2_private_dict_opset_subset_t : dict_opset_t\n+{\n+  static void process_op (op_code_t op, cff2_priv_dict_interp_env_t& env, cff2_private_dict_values_subset_t& dictval)\n+  {\n+    switch (op) {\n+      case OpCode_BlueValues:\n+      case OpCode_OtherBlues:\n+      case OpCode_FamilyBlues:\n+      case OpCode_FamilyOtherBlues:\n+      case OpCode_StdHW:\n+      case OpCode_StdVW:\n+      case OpCode_BlueScale:\n+      case OpCode_BlueShift:\n+      case OpCode_BlueFuzz:\n+      case OpCode_StemSnapH:\n+      case OpCode_StemSnapV:\n+      case OpCode_LanguageGroup:\n+      case OpCode_ExpansionFactor:\n+        env.clear_args ();\n+        break;\n+\n+      case OpCode_blenddict:\n+        env.clear_args ();\n+        return;\n+\n+      case OpCode_Subrs:\n+        dictval.subrsOffset = env.argStack.pop_uint ();\n+        env.clear_args ();\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env);\n+        if (!env.argStack.is_empty ()) return;\n+        break;\n+    }\n+\n+    if (unlikely (env.in_error ())) return;\n+\n+    dictval.add_op (op, env.str_ref);\n+  }\n+\n+  private:\n+  typedef dict_opset_t SUPER;\n+};\n+\n+typedef dict_interpreter_t<cff2_top_dict_opset_t, cff2_top_dict_values_t> cff2_top_dict_interpreter_t;\n+typedef dict_interpreter_t<cff2_font_dict_opset_t, cff2_font_dict_values_t> cff2_font_dict_interpreter_t;\n+\n+} \/* namespace CFF *\/\n+\n+namespace OT {\n+\n+using namespace CFF;\n+\n+struct cff2\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_cff2;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  likely (version.major == 2));\n+  }\n+\n+  template <typename PRIVOPSET, typename PRIVDICTVAL>\n+  struct accelerator_templ_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      topDict.init ();\n+      fontDicts.init ();\n+      privateDicts.init ();\n+\n+      this->blob = sc.reference_table<cff2> (face);\n+\n+      \/* setup for run-time santization *\/\n+      sc.init (this->blob);\n+      sc.start_processing ();\n+\n+      const OT::cff2 *cff2 = this->blob->template as<OT::cff2> ();\n+\n+      if (cff2 == &Null(OT::cff2))\n+      { fini (); return; }\n+\n+      { \/* parse top dict *\/\n+        byte_str_t topDictStr (cff2 + cff2->topDict, cff2->topDictSize);\n+        if (unlikely (!topDictStr.sanitize (&sc))) { fini (); return; }\n+        cff2_top_dict_interpreter_t top_interp;\n+        top_interp.env.init (topDictStr);\n+        topDict.init ();\n+        if (unlikely (!top_interp.interpret (topDict))) { fini (); return; }\n+      }\n+\n+      globalSubrs = &StructAtOffset<CFF2Subrs> (cff2, cff2->topDict + cff2->topDictSize);\n+      varStore = &StructAtOffsetOrNull<CFF2VariationStore> (cff2, topDict.vstoreOffset);\n+      charStrings = &StructAtOffsetOrNull<CFF2CharStrings> (cff2, topDict.charStringsOffset);\n+      fdArray = &StructAtOffsetOrNull<CFF2FDArray> (cff2, topDict.FDArrayOffset);\n+      fdSelect = &StructAtOffsetOrNull<CFF2FDSelect> (cff2, topDict.FDSelectOffset);\n+\n+      if (((varStore != &Null(CFF2VariationStore)) && unlikely (!varStore->sanitize (&sc))) ||\n+          (charStrings == &Null(CFF2CharStrings)) || unlikely (!charStrings->sanitize (&sc)) ||\n+          (globalSubrs == &Null(CFF2Subrs)) || unlikely (!globalSubrs->sanitize (&sc)) ||\n+          (fdArray == &Null(CFF2FDArray)) || unlikely (!fdArray->sanitize (&sc)) ||\n+          (((fdSelect != &Null(CFF2FDSelect)) && unlikely (!fdSelect->sanitize (&sc, fdArray->count)))))\n+      { fini (); return; }\n+\n+      num_glyphs = charStrings->count;\n+      if (num_glyphs != sc.get_num_glyphs ())\n+      { fini (); return; }\n+\n+      fdCount = fdArray->count;\n+      privateDicts.resize (fdCount);\n+\n+      \/* parse font dicts and gather private dicts *\/\n+      for (unsigned int i = 0; i < fdCount; i++)\n+      {\n+        const byte_str_t fontDictStr = (*fdArray)[i];\n+        if (unlikely (!fontDictStr.sanitize (&sc))) { fini (); return; }\n+        cff2_font_dict_values_t  *font;\n+        cff2_font_dict_interpreter_t font_interp;\n+        font_interp.env.init (fontDictStr);\n+        font = fontDicts.push ();\n+        if (unlikely (font == &Crap(cff2_font_dict_values_t))) { fini (); return; }\n+        font->init ();\n+        if (unlikely (!font_interp.interpret (*font))) { fini (); return; }\n+\n+        const byte_str_t privDictStr (StructAtOffsetOrNull<UnsizedByteStr> (cff2, font->privateDictInfo.offset), font->privateDictInfo.size);\n+        if (unlikely (!privDictStr.sanitize (&sc))) { fini (); return; }\n+        dict_interpreter_t<PRIVOPSET, PRIVDICTVAL, cff2_priv_dict_interp_env_t>  priv_interp;\n+        priv_interp.env.init(privDictStr);\n+        privateDicts[i].init ();\n+        if (unlikely (!priv_interp.interpret (privateDicts[i]))) { fini (); return; }\n+\n+        privateDicts[i].localSubrs = &StructAtOffsetOrNull<CFF2Subrs> (&privDictStr[0], privateDicts[i].subrsOffset);\n+        if (privateDicts[i].localSubrs != &Null(CFF2Subrs) &&\n+          unlikely (!privateDicts[i].localSubrs->sanitize (&sc)))\n+        { fini (); return; }\n+      }\n+    }\n+\n+    void fini ()\n+    {\n+      sc.end_processing ();\n+      topDict.fini ();\n+      fontDicts.fini_deep ();\n+      privateDicts.fini_deep ();\n+      hb_blob_destroy (blob);\n+      blob = nullptr;\n+    }\n+\n+    bool is_valid () const { return blob != nullptr; }\n+\n+    protected:\n+    hb_blob_t                   *blob;\n+    hb_sanitize_context_t       sc;\n+\n+    public:\n+    cff2_top_dict_values_t      topDict;\n+    const CFF2Subrs             *globalSubrs;\n+    const CFF2VariationStore    *varStore;\n+    const CFF2CharStrings       *charStrings;\n+    const CFF2FDArray           *fdArray;\n+    const CFF2FDSelect          *fdSelect;\n+    unsigned int                fdCount;\n+\n+    hb_vector_t<cff2_font_dict_values_t>     fontDicts;\n+    hb_vector_t<PRIVDICTVAL>  privateDicts;\n+\n+    unsigned int              num_glyphs;\n+  };\n+\n+  struct accelerator_t : accelerator_templ_t<cff2_private_dict_opset_t, cff2_private_dict_values_t>\n+  {\n+    HB_INTERNAL bool get_extents (hb_font_t *font,\n+                                  hb_codepoint_t glyph,\n+                                  hb_glyph_extents_t *extents) const;\n+  };\n+\n+  typedef accelerator_templ_t<cff2_private_dict_opset_subset_t, cff2_private_dict_values_subset_t> accelerator_subset_t;\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    hb_blob_t *cff2_prime = nullptr;\n+\n+    bool success = true;\n+    if (hb_subset_cff2 (plan, &cff2_prime)) {\n+      success = success && plan->add_table (HB_OT_TAG_cff2, cff2_prime);\n+      hb_blob_t *head_blob = hb_sanitize_context_t().reference_table<head> (plan->source);\n+      success = success && head_blob && plan->add_table (HB_OT_TAG_head, head_blob);\n+      hb_blob_destroy (head_blob);\n+    } else {\n+      success = false;\n+    }\n+    hb_blob_destroy (cff2_prime);\n+\n+    return success;\n+  }\n+\n+  public:\n+  FixedVersion<HBUINT8>         version;        \/* Version of CFF2 table. set to 0x0200u *\/\n+  NNOffsetTo<TopDict, HBUINT8>  topDict;        \/* headerSize = Offset to Top DICT. *\/\n+  HBUINT16                      topDictSize;    \/* Top DICT size *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (5);\n+};\n+\n+struct cff2_accelerator_t : cff2::accelerator_t {};\n+} \/* namespace OT *\/\n+\n+#endif \/* HB_OT_CFF2_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-cff2-table.hh","additions":566,"deletions":0,"binary":false,"changes":566,"status":"added"},{"patch":"@@ -0,0 +1,1180 @@\n+\/*\n+ * Copyright © 2014  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_CMAP_TABLE_HH\n+#define HB_OT_CMAP_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-set.hh\"\n+\n+\/*\n+ * cmap -- Character to Glyph Index Mapping\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cmap\n+ *\/\n+#define HB_OT_TAG_cmap HB_TAG('c','m','a','p')\n+\n+namespace OT {\n+\n+\n+struct CmapSubtableFormat0\n+{\n+  bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const\n+  {\n+    hb_codepoint_t gid = codepoint < 256 ? glyphIdArray[codepoint] : 0;\n+    if (!gid)\n+      return false;\n+    *glyph = gid;\n+    return true;\n+  }\n+  void collect_unicodes (hb_set_t *out) const\n+  {\n+    for (unsigned int i = 0; i < 256; i++)\n+      if (glyphIdArray[i])\n+        out->add (i);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format number is set to 0. *\/\n+  HBUINT16      length;         \/* Byte length of this subtable. *\/\n+  HBUINT16      language;       \/* Ignore. *\/\n+  HBUINT8       glyphIdArray[256];\/* An array that maps character\n+                                 * code to glyph index values. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6 + 256);\n+};\n+\n+struct CmapSubtableFormat4\n+{\n+  struct segment_plan\n+  {\n+    HBUINT16 start_code;\n+    HBUINT16 end_code;\n+    bool use_delta;\n+  };\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  const hb_subset_plan_t *plan,\n+                  const hb_vector_t<segment_plan> &segments)\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+\n+    this->format.set (4);\n+    this->length.set (get_sub_table_size (segments));\n+\n+    this->segCountX2.set (segments.length * 2);\n+    this->entrySelector.set (MAX (1u, hb_bit_storage (segments.length)) - 1);\n+    this->searchRange.set (2 * (1u << this->entrySelector));\n+    this->rangeShift.set (segments.length * 2 > this->searchRange\n+                          ? 2 * segments.length - this->searchRange\n+                          : 0);\n+\n+    HBUINT16 *end_count = c->allocate_size<HBUINT16> (HBUINT16::static_size * segments.length);\n+    c->allocate_size<HBUINT16> (HBUINT16::static_size); \/\/ 2 bytes of padding.\n+    HBUINT16 *start_count = c->allocate_size<HBUINT16> (HBUINT16::static_size * segments.length);\n+    HBINT16 *id_delta = c->allocate_size<HBINT16> (HBUINT16::static_size * segments.length);\n+    HBUINT16 *id_range_offset = c->allocate_size<HBUINT16> (HBUINT16::static_size * segments.length);\n+\n+    if (id_range_offset == nullptr)\n+      return_trace (false);\n+\n+    for (unsigned int i = 0; i < segments.length; i++)\n+    {\n+      end_count[i].set (segments[i].end_code);\n+      start_count[i].set (segments[i].start_code);\n+      if (segments[i].use_delta)\n+      {\n+        hb_codepoint_t cp = segments[i].start_code;\n+        hb_codepoint_t start_gid = 0;\n+        if (unlikely (!plan->new_gid_for_codepoint (cp, &start_gid) && cp != 0xFFFF))\n+          return_trace (false);\n+        id_delta[i].set (start_gid - segments[i].start_code);\n+      } else {\n+        id_delta[i].set (0);\n+        unsigned int num_codepoints = segments[i].end_code - segments[i].start_code + 1;\n+        HBUINT16 *glyph_id_array = c->allocate_size<HBUINT16> (HBUINT16::static_size * num_codepoints);\n+        if (glyph_id_array == nullptr)\n+          return_trace (false);\n+        \/\/ From the cmap spec:\n+        \/\/\n+        \/\/ id_range_offset[i]\/2\n+        \/\/ + (cp - segments[i].start_code)\n+        \/\/ + (id_range_offset + i)\n+        \/\/ =\n+        \/\/ glyph_id_array + (cp - segments[i].start_code)\n+        \/\/\n+        \/\/ So, solve for id_range_offset[i]:\n+        \/\/\n+        \/\/ id_range_offset[i]\n+        \/\/ =\n+        \/\/ 2 * (glyph_id_array - id_range_offset - i)\n+        id_range_offset[i].set (2 * (\n+            glyph_id_array - id_range_offset - i));\n+        for (unsigned int j = 0; j < num_codepoints; j++)\n+        {\n+          hb_codepoint_t cp = segments[i].start_code + j;\n+          hb_codepoint_t new_gid;\n+          if (unlikely (!plan->new_gid_for_codepoint (cp, &new_gid)))\n+            return_trace (false);\n+          glyph_id_array[j].set (new_gid);\n+        }\n+      }\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  static size_t get_sub_table_size (const hb_vector_t<segment_plan> &segments)\n+  {\n+    size_t segment_size = 0;\n+    for (unsigned int i = 0; i < segments.length; i++)\n+    {\n+      \/\/ Parallel array entries\n+      segment_size +=\n+            2  \/\/ end count\n+          + 2  \/\/ start count\n+          + 2  \/\/ delta\n+          + 2; \/\/ range offset\n+\n+      if (!segments[i].use_delta)\n+        \/\/ Add bytes for the glyph index array entries for this segment.\n+        segment_size += (segments[i].end_code - segments[i].start_code + 1) * 2;\n+    }\n+\n+    return min_size\n+        + 2 \/\/ Padding\n+        + segment_size;\n+  }\n+\n+  static bool create_sub_table_plan (const hb_subset_plan_t *plan,\n+                                     hb_vector_t<segment_plan> *segments)\n+  {\n+    segment_plan *segment = nullptr;\n+    hb_codepoint_t last_gid = 0;\n+\n+    hb_codepoint_t cp = HB_SET_VALUE_INVALID;\n+    while (plan->unicodes->next (&cp)) {\n+      hb_codepoint_t new_gid;\n+      if (unlikely (!plan->new_gid_for_codepoint (cp, &new_gid)))\n+      {\n+        DEBUG_MSG(SUBSET, nullptr, \"Unable to find new gid for %04x\", cp);\n+        return false;\n+      }\n+\n+      \/* Stop adding to cmap if we are now outside of unicode BMP. *\/\n+      if (cp > 0xFFFF) break;\n+\n+      if (!segment ||\n+          cp != segment->end_code + 1u)\n+      {\n+        segment = segments->push ();\n+        segment->start_code.set (cp);\n+        segment->end_code.set (cp);\n+        segment->use_delta = true;\n+      } else {\n+        segment->end_code.set (cp);\n+        if (last_gid + 1u != new_gid)\n+          \/\/ gid's are not consecutive in this segment so delta\n+          \/\/ cannot be used.\n+          segment->use_delta = false;\n+      }\n+\n+      last_gid = new_gid;\n+    }\n+\n+    \/\/ There must be a final entry with end_code == 0xFFFF. Check if we need to add one.\n+    if (segment == nullptr || segment->end_code != 0xFFFF)\n+    {\n+      segment = segments->push ();\n+      segment->start_code.set (0xFFFF);\n+      segment->end_code.set (0xFFFF);\n+      segment->use_delta = true;\n+    }\n+\n+    return true;\n+  }\n+\n+  struct accelerator_t\n+  {\n+    accelerator_t () {}\n+    accelerator_t (const CmapSubtableFormat4 *subtable) { init (subtable); }\n+    ~accelerator_t () { fini (); }\n+\n+    void init (const CmapSubtableFormat4 *subtable)\n+    {\n+      segCount = subtable->segCountX2 \/ 2;\n+      endCount = subtable->values.arrayZ;\n+      startCount = endCount + segCount + 1;\n+      idDelta = startCount + segCount;\n+      idRangeOffset = idDelta + segCount;\n+      glyphIdArray = idRangeOffset + segCount;\n+      glyphIdArrayLength = (subtable->length - 16 - 8 * segCount) \/ 2;\n+    }\n+    void fini () {}\n+\n+    bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const\n+    {\n+      \/* Custom two-array bsearch. *\/\n+      int min = 0, max = (int) this->segCount - 1;\n+      const HBUINT16 *startCount = this->startCount;\n+      const HBUINT16 *endCount = this->endCount;\n+      unsigned int i;\n+      while (min <= max)\n+      {\n+        int mid = ((unsigned int) min + (unsigned int) max) \/ 2;\n+        if (codepoint < startCount[mid])\n+          max = mid - 1;\n+        else if (codepoint > endCount[mid])\n+          min = mid + 1;\n+        else\n+        {\n+          i = mid;\n+          goto found;\n+        }\n+      }\n+      return false;\n+\n+    found:\n+      hb_codepoint_t gid;\n+      unsigned int rangeOffset = this->idRangeOffset[i];\n+      if (rangeOffset == 0)\n+        gid = codepoint + this->idDelta[i];\n+      else\n+      {\n+        \/* Somebody has been smoking... *\/\n+        unsigned int index = rangeOffset \/ 2 + (codepoint - this->startCount[i]) + i - this->segCount;\n+        if (unlikely (index >= this->glyphIdArrayLength))\n+          return false;\n+        gid = this->glyphIdArray[index];\n+        if (unlikely (!gid))\n+          return false;\n+        gid += this->idDelta[i];\n+      }\n+      gid &= 0xFFFFu;\n+      if (!gid)\n+        return false;\n+      *glyph = gid;\n+      return true;\n+    }\n+    static bool get_glyph_func (const void *obj, hb_codepoint_t codepoint, hb_codepoint_t *glyph)\n+    {\n+      return ((const accelerator_t *) obj)->get_glyph (codepoint, glyph);\n+    }\n+    void collect_unicodes (hb_set_t *out) const\n+    {\n+      unsigned int count = this->segCount;\n+      if (count && this->startCount[count - 1] == 0xFFFFu)\n+        count--; \/* Skip sentinel segment. *\/\n+      for (unsigned int i = 0; i < count; i++)\n+      {\n+        unsigned int rangeOffset = this->idRangeOffset[i];\n+        if (rangeOffset == 0)\n+          out->add_range (this->startCount[i], this->endCount[i]);\n+        else\n+        {\n+          for (hb_codepoint_t codepoint = this->startCount[i];\n+               codepoint <= this->endCount[i];\n+               codepoint++)\n+          {\n+            unsigned int index = rangeOffset \/ 2 + (codepoint - this->startCount[i]) + i - this->segCount;\n+            if (unlikely (index >= this->glyphIdArrayLength))\n+              break;\n+            hb_codepoint_t gid = this->glyphIdArray[index];\n+            if (unlikely (!gid))\n+              continue;\n+            out->add (codepoint);\n+          }\n+        }\n+      }\n+    }\n+\n+    const HBUINT16 *endCount;\n+    const HBUINT16 *startCount;\n+    const HBUINT16 *idDelta;\n+    const HBUINT16 *idRangeOffset;\n+    const HBUINT16 *glyphIdArray;\n+    unsigned int segCount;\n+    unsigned int glyphIdArrayLength;\n+  };\n+\n+  bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const\n+  {\n+    accelerator_t accel (this);\n+    return accel.get_glyph_func (&accel, codepoint, glyph);\n+  }\n+  void collect_unicodes (hb_set_t *out) const\n+  {\n+    accelerator_t accel (this);\n+    accel.collect_unicodes (out);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+\n+    if (unlikely (!c->check_range (this, length)))\n+    {\n+      \/* Some broken fonts have too long of a \"length\" value.\n+       * If that is the case, just change the value to truncate\n+       * the subtable at the end of the blob. *\/\n+      uint16_t new_length = (uint16_t) MIN ((uintptr_t) 65535,\n+                                            (uintptr_t) (c->end -\n+                                                         (char *) this));\n+      if (!c->try_set (&length, new_length))\n+        return_trace (false);\n+    }\n+\n+    return_trace (16 + 4 * (unsigned int) segCountX2 <= length);\n+  }\n+\n+\n+\n+  protected:\n+  HBUINT16      format;         \/* Format number is set to 4. *\/\n+  HBUINT16      length;         \/* This is the length in bytes of the\n+                                 * subtable. *\/\n+  HBUINT16      language;       \/* Ignore. *\/\n+  HBUINT16      segCountX2;     \/* 2 x segCount. *\/\n+  HBUINT16      searchRange;    \/* 2 * (2**floor(log2(segCount))) *\/\n+  HBUINT16      entrySelector;  \/* log2(searchRange\/2) *\/\n+  HBUINT16      rangeShift;     \/* 2 x segCount - searchRange *\/\n+\n+  UnsizedArrayOf<HBUINT16>\n+                values;\n+#if 0\n+  HBUINT16      endCount[segCount];     \/* End characterCode for each segment,\n+                                         * last=0xFFFFu. *\/\n+  HBUINT16      reservedPad;            \/* Set to 0. *\/\n+  HBUINT16      startCount[segCount];   \/* Start character code for each segment. *\/\n+  HBINT16               idDelta[segCount];      \/* Delta for all character codes in segment. *\/\n+  HBUINT16      idRangeOffset[segCount];\/* Offsets into glyphIdArray or 0 *\/\n+  UnsizedArrayOf<HBUINT16>\n+                glyphIdArray;   \/* Glyph index array (arbitrary length) *\/\n+#endif\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (14, values);\n+};\n+\n+struct CmapSubtableLongGroup\n+{\n+  friend struct CmapSubtableFormat12;\n+  friend struct CmapSubtableFormat13;\n+  template<typename U>\n+  friend struct CmapSubtableLongSegmented;\n+  friend struct cmap;\n+\n+  int cmp (hb_codepoint_t codepoint) const\n+  {\n+    if (codepoint < startCharCode) return -1;\n+    if (codepoint > endCharCode)   return +1;\n+    return 0;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  private:\n+  HBUINT32              startCharCode;  \/* First character code in this group. *\/\n+  HBUINT32              endCharCode;    \/* Last character code in this group. *\/\n+  HBUINT32              glyphID;        \/* Glyph index; interpretation depends on\n+                                         * subtable format. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (OT, CmapSubtableLongGroup);\n+\n+template <typename UINT>\n+struct CmapSubtableTrimmed\n+{\n+  bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const\n+  {\n+    \/* Rely on our implicit array bound-checking. *\/\n+    hb_codepoint_t gid = glyphIdArray[codepoint - startCharCode];\n+    if (!gid)\n+      return false;\n+    *glyph = gid;\n+    return true;\n+  }\n+  void collect_unicodes (hb_set_t *out) const\n+  {\n+    hb_codepoint_t start = startCharCode;\n+    unsigned int count = glyphIdArray.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (glyphIdArray[i])\n+        out->add (start + i);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && glyphIdArray.sanitize (c));\n+  }\n+\n+  protected:\n+  UINT          formatReserved; \/* Subtable format and (maybe) padding. *\/\n+  UINT          length;         \/* Byte length of this subtable. *\/\n+  UINT          language;       \/* Ignore. *\/\n+  UINT          startCharCode;  \/* First character code covered. *\/\n+  ArrayOf<GlyphID, UINT>\n+                glyphIdArray;   \/* Array of glyph index values for character\n+                                 * codes in the range. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (5 * sizeof (UINT), glyphIdArray);\n+};\n+\n+struct CmapSubtableFormat6  : CmapSubtableTrimmed<HBUINT16> {};\n+struct CmapSubtableFormat10 : CmapSubtableTrimmed<HBUINT32 > {};\n+\n+template <typename T>\n+struct CmapSubtableLongSegmented\n+{\n+  friend struct cmap;\n+\n+  bool get_glyph (hb_codepoint_t codepoint, hb_codepoint_t *glyph) const\n+  {\n+    hb_codepoint_t gid = T::group_get_glyph (groups.bsearch (codepoint), codepoint);\n+    if (!gid)\n+      return false;\n+    *glyph = gid;\n+    return true;\n+  }\n+\n+  void collect_unicodes (hb_set_t *out) const\n+  {\n+    for (unsigned int i = 0; i < this->groups.len; i++) {\n+      out->add_range (this->groups[i].startCharCode,\n+                      MIN ((hb_codepoint_t) this->groups[i].endCharCode,\n+                           (hb_codepoint_t) HB_UNICODE_MAX));\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && groups.sanitize (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  const hb_vector_t<CmapSubtableLongGroup> &group_data)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!groups.serialize (c, group_data.as_array ()))) return_trace (false);\n+    return true;\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Subtable format; set to 12. *\/\n+  HBUINT16      reserved;       \/* Reserved; set to 0. *\/\n+  HBUINT32      length;         \/* Byte length of this subtable. *\/\n+  HBUINT32      language;       \/* Ignore. *\/\n+  SortedArrayOf<CmapSubtableLongGroup, HBUINT32>\n+                groups;         \/* Groupings. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (16, groups);\n+};\n+\n+struct CmapSubtableFormat12 : CmapSubtableLongSegmented<CmapSubtableFormat12>\n+{\n+  static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &group,\n+                                         hb_codepoint_t u)\n+  { return likely (group.startCharCode <= group.endCharCode) ?\n+           group.glyphID + (u - group.startCharCode) : 0; }\n+\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  const hb_vector_t<CmapSubtableLongGroup> &groups)\n+  {\n+    if (unlikely (!c->extend_min (*this))) return false;\n+\n+    this->format.set (12);\n+    this->reserved.set (0);\n+    this->length.set (get_sub_table_size (groups));\n+\n+    return CmapSubtableLongSegmented<CmapSubtableFormat12>::serialize (c, groups);\n+  }\n+\n+  static size_t get_sub_table_size (const hb_vector_t<CmapSubtableLongGroup> &groups)\n+  {\n+    return 16 + 12 * groups.length;\n+  }\n+\n+  static bool create_sub_table_plan (const hb_subset_plan_t *plan,\n+                                     hb_vector_t<CmapSubtableLongGroup> *groups)\n+  {\n+    CmapSubtableLongGroup *group = nullptr;\n+\n+    hb_codepoint_t cp = HB_SET_VALUE_INVALID;\n+    while (plan->unicodes->next (&cp)) {\n+      hb_codepoint_t new_gid;\n+      if (unlikely (!plan->new_gid_for_codepoint (cp, &new_gid)))\n+      {\n+        DEBUG_MSG(SUBSET, nullptr, \"Unable to find new gid for %04x\", cp);\n+        return false;\n+      }\n+\n+      if (!group || !_is_gid_consecutive (group, cp, new_gid))\n+      {\n+        group = groups->push ();\n+        group->startCharCode.set (cp);\n+        group->endCharCode.set (cp);\n+        group->glyphID.set (new_gid);\n+      }\n+      else group->endCharCode.set (cp);\n+    }\n+\n+    DEBUG_MSG(SUBSET, nullptr, \"cmap\");\n+    for (unsigned int i = 0; i < groups->length; i++) {\n+      CmapSubtableLongGroup& group = (*groups)[i];\n+      DEBUG_MSG(SUBSET, nullptr, \"  %d: U+%04X-U+%04X, gid %d-%d\", i, (uint32_t) group.startCharCode, (uint32_t) group.endCharCode, (uint32_t) group.glyphID, (uint32_t) group.glyphID + ((uint32_t) group.endCharCode - (uint32_t) group.startCharCode));\n+    }\n+\n+    return true;\n+  }\n+\n+ private:\n+  static bool _is_gid_consecutive (CmapSubtableLongGroup *group,\n+                                   hb_codepoint_t cp,\n+                                   hb_codepoint_t new_gid)\n+  {\n+    return (cp - 1 == group->endCharCode) &&\n+        new_gid == group->glyphID + (cp - group->startCharCode);\n+  }\n+\n+};\n+\n+struct CmapSubtableFormat13 : CmapSubtableLongSegmented<CmapSubtableFormat13>\n+{\n+  static hb_codepoint_t group_get_glyph (const CmapSubtableLongGroup &group,\n+                                         hb_codepoint_t u HB_UNUSED)\n+  { return group.glyphID; }\n+};\n+\n+typedef enum\n+{\n+  GLYPH_VARIANT_NOT_FOUND = 0,\n+  GLYPH_VARIANT_FOUND = 1,\n+  GLYPH_VARIANT_USE_DEFAULT = 2\n+} glyph_variant_t;\n+\n+struct UnicodeValueRange\n+{\n+  int cmp (const hb_codepoint_t &codepoint) const\n+  {\n+    if (codepoint < startUnicodeValue) return -1;\n+    if (codepoint > startUnicodeValue + additionalCount) return +1;\n+    return 0;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT24      startUnicodeValue;      \/* First value in this range. *\/\n+  HBUINT8       additionalCount;        \/* Number of additional values in this\n+                                         * range. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct DefaultUVS : SortedArrayOf<UnicodeValueRange, HBUINT32>\n+{\n+  void collect_unicodes (hb_set_t *out) const\n+  {\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      hb_codepoint_t first = arrayZ[i].startUnicodeValue;\n+      hb_codepoint_t last = MIN ((hb_codepoint_t) (first + arrayZ[i].additionalCount),\n+                                 (hb_codepoint_t) HB_UNICODE_MAX);\n+      out->add_range (first, last);\n+    }\n+  }\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (4, *this);\n+};\n+\n+struct UVSMapping\n+{\n+  int cmp (const hb_codepoint_t &codepoint) const\n+  {\n+    return unicodeValue.cmp (codepoint);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT24      unicodeValue;   \/* Base Unicode value of the UVS *\/\n+  GlyphID       glyphID;        \/* Glyph ID of the UVS *\/\n+  public:\n+  DEFINE_SIZE_STATIC (5);\n+};\n+\n+struct NonDefaultUVS : SortedArrayOf<UVSMapping, HBUINT32>\n+{\n+  void collect_unicodes (hb_set_t *out) const\n+  {\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+      out->add (arrayZ[i].glyphID);\n+  }\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (4, *this);\n+};\n+\n+struct VariationSelectorRecord\n+{\n+  glyph_variant_t get_glyph (hb_codepoint_t codepoint,\n+                             hb_codepoint_t *glyph,\n+                             const void *base) const\n+  {\n+    if ((base+defaultUVS).bfind (codepoint))\n+      return GLYPH_VARIANT_USE_DEFAULT;\n+    const UVSMapping &nonDefault = (base+nonDefaultUVS).bsearch (codepoint);\n+    if (nonDefault.glyphID)\n+    {\n+      *glyph = nonDefault.glyphID;\n+       return GLYPH_VARIANT_FOUND;\n+    }\n+    return GLYPH_VARIANT_NOT_FOUND;\n+  }\n+\n+  void collect_unicodes (hb_set_t *out, const void *base) const\n+  {\n+    (base+defaultUVS).collect_unicodes (out);\n+    (base+nonDefaultUVS).collect_unicodes (out);\n+  }\n+\n+  int cmp (const hb_codepoint_t &variation_selector) const\n+  {\n+    return varSelector.cmp (variation_selector);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  defaultUVS.sanitize (c, base) &&\n+                  nonDefaultUVS.sanitize (c, base));\n+  }\n+\n+  HBUINT24      varSelector;    \/* Variation selector. *\/\n+  LOffsetTo<DefaultUVS>\n+                defaultUVS;     \/* Offset to Default UVS Table.  May be 0. *\/\n+  LOffsetTo<NonDefaultUVS>\n+                nonDefaultUVS;  \/* Offset to Non-Default UVS Table.  May be 0. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (11);\n+};\n+\n+struct CmapSubtableFormat14\n+{\n+  glyph_variant_t get_glyph_variant (hb_codepoint_t codepoint,\n+                                     hb_codepoint_t variation_selector,\n+                                     hb_codepoint_t *glyph) const\n+  {\n+    return record.bsearch (variation_selector).get_glyph (codepoint, glyph, this);\n+  }\n+\n+  void collect_variation_selectors (hb_set_t *out) const\n+  {\n+    unsigned int count = record.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      out->add (record.arrayZ[i].varSelector);\n+  }\n+  void collect_variation_unicodes (hb_codepoint_t variation_selector,\n+                                   hb_set_t *out) const\n+  {\n+    record.bsearch (variation_selector).collect_unicodes (out, this);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  record.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format number is set to 14. *\/\n+  HBUINT32      length;         \/* Byte length of this subtable. *\/\n+  SortedArrayOf<VariationSelectorRecord, HBUINT32>\n+                record;         \/* Variation selector records; sorted\n+                                 * in increasing order of `varSelector'. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (10, record);\n+};\n+\n+struct CmapSubtable\n+{\n+  \/* Note: We intentionally do NOT implement subtable formats 2 and 8. *\/\n+\n+  bool get_glyph (hb_codepoint_t codepoint,\n+                  hb_codepoint_t *glyph) const\n+  {\n+    switch (u.format) {\n+    case  0: return u.format0 .get_glyph (codepoint, glyph);\n+    case  4: return u.format4 .get_glyph (codepoint, glyph);\n+    case  6: return u.format6 .get_glyph (codepoint, glyph);\n+    case 10: return u.format10.get_glyph (codepoint, glyph);\n+    case 12: return u.format12.get_glyph (codepoint, glyph);\n+    case 13: return u.format13.get_glyph (codepoint, glyph);\n+    case 14:\n+    default: return false;\n+    }\n+  }\n+  void collect_unicodes (hb_set_t *out) const\n+  {\n+    switch (u.format) {\n+    case  0: u.format0 .collect_unicodes (out); return;\n+    case  4: u.format4 .collect_unicodes (out); return;\n+    case  6: u.format6 .collect_unicodes (out); return;\n+    case 10: u.format10.collect_unicodes (out); return;\n+    case 12: u.format12.collect_unicodes (out); return;\n+    case 13: u.format13.collect_unicodes (out); return;\n+    case 14:\n+    default: return;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case  0: return_trace (u.format0 .sanitize (c));\n+    case  4: return_trace (u.format4 .sanitize (c));\n+    case  6: return_trace (u.format6 .sanitize (c));\n+    case 10: return_trace (u.format10.sanitize (c));\n+    case 12: return_trace (u.format12.sanitize (c));\n+    case 13: return_trace (u.format13.sanitize (c));\n+    case 14: return_trace (u.format14.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  public:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  CmapSubtableFormat0   format0;\n+  CmapSubtableFormat4   format4;\n+  CmapSubtableFormat6   format6;\n+  CmapSubtableFormat10  format10;\n+  CmapSubtableFormat12  format12;\n+  CmapSubtableFormat13  format13;\n+  CmapSubtableFormat14  format14;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+\n+struct EncodingRecord\n+{\n+  int cmp (const EncodingRecord &other) const\n+  {\n+    int ret;\n+    ret = platformID.cmp (other.platformID);\n+    if (ret) return ret;\n+    ret = encodingID.cmp (other.encodingID);\n+    if (ret) return ret;\n+    return 0;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  subtable.sanitize (c, base));\n+  }\n+\n+  HBUINT16      platformID;     \/* Platform ID. *\/\n+  HBUINT16      encodingID;     \/* Platform-specific encoding ID. *\/\n+  LOffsetTo<CmapSubtable>\n+                subtable;       \/* Byte offset from beginning of table to the subtable for this encoding. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct cmap\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_cmap;\n+\n+  struct subset_plan\n+  {\n+    size_t final_size () const\n+    {\n+      return 4 \/\/ header\n+          +  8 * 3 \/\/ 3 EncodingRecord\n+          +  CmapSubtableFormat4::get_sub_table_size (this->format4_segments)\n+          +  CmapSubtableFormat12::get_sub_table_size (this->format12_groups);\n+    }\n+\n+    hb_vector_t<CmapSubtableFormat4::segment_plan> format4_segments;\n+    hb_vector_t<CmapSubtableLongGroup> format12_groups;\n+  };\n+\n+  bool _create_plan (const hb_subset_plan_t *plan,\n+                     subset_plan *cmap_plan) const\n+  {\n+    if (unlikely (!CmapSubtableFormat4::create_sub_table_plan (plan, &cmap_plan->format4_segments)))\n+      return false;\n+\n+    return CmapSubtableFormat12::create_sub_table_plan (plan, &cmap_plan->format12_groups);\n+  }\n+\n+  bool _subset (const hb_subset_plan_t *plan,\n+                const subset_plan &cmap_subset_plan,\n+                size_t dest_sz,\n+                void *dest) const\n+  {\n+    hb_serialize_context_t c (dest, dest_sz);\n+\n+    cmap *table = c.start_serialize<cmap> ();\n+    if (unlikely (!c.extend_min (*table)))\n+    {\n+      return false;\n+    }\n+\n+    table->version.set (0);\n+\n+    if (unlikely (!table->encodingRecord.serialize (&c, \/* numTables *\/ 3)))\n+      return false;\n+\n+    \/\/ TODO(grieger): Convert the below to a for loop\n+\n+    \/\/ Format 4, Plat 0 Encoding Record\n+    EncodingRecord &format4_plat0_rec = table->encodingRecord[0];\n+    format4_plat0_rec.platformID.set (0); \/\/ Unicode\n+    format4_plat0_rec.encodingID.set (3);\n+\n+    \/\/ Format 4, Plat 3 Encoding Record\n+    EncodingRecord &format4_plat3_rec = table->encodingRecord[1];\n+    format4_plat3_rec.platformID.set (3); \/\/ Windows\n+    format4_plat3_rec.encodingID.set (1); \/\/ Unicode BMP\n+\n+    \/\/ Format 12 Encoding Record\n+    EncodingRecord &format12_rec = table->encodingRecord[2];\n+    format12_rec.platformID.set (3); \/\/ Windows\n+    format12_rec.encodingID.set (10); \/\/ Unicode UCS-4\n+\n+    \/\/ Write out format 4 sub table\n+    {\n+      CmapSubtable &subtable = format4_plat0_rec.subtable.serialize (&c, table);\n+      format4_plat3_rec.subtable.set (format4_plat0_rec.subtable);\n+      subtable.u.format.set (4);\n+\n+      CmapSubtableFormat4 &format4 = subtable.u.format4;\n+      if (unlikely (!format4.serialize (&c, plan, cmap_subset_plan.format4_segments)))\n+        return false;\n+    }\n+\n+    \/\/ Write out format 12 sub table.\n+    {\n+      CmapSubtable &subtable = format12_rec.subtable.serialize (&c, table);\n+      subtable.u.format.set (12);\n+\n+      CmapSubtableFormat12 &format12 = subtable.u.format12;\n+      if (unlikely (!format12.serialize (&c, cmap_subset_plan.format12_groups)))\n+        return false;\n+    }\n+\n+    c.end_serialize ();\n+\n+    return true;\n+  }\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    subset_plan cmap_subset_plan;\n+\n+    if (unlikely (!_create_plan (plan, &cmap_subset_plan)))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"Failed to generate a cmap subsetting plan.\");\n+      return false;\n+    }\n+\n+    \/\/ We now know how big our blob needs to be\n+    size_t dest_sz = cmap_subset_plan.final_size ();\n+    void *dest = malloc (dest_sz);\n+    if (unlikely (!dest)) {\n+      DEBUG_MSG(SUBSET, nullptr, \"Unable to alloc %lu for cmap subset output\", (unsigned long) dest_sz);\n+      return false;\n+    }\n+\n+    if (unlikely (!_subset (plan, cmap_subset_plan, dest_sz, dest)))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"Failed to perform subsetting of cmap.\");\n+      free (dest);\n+      return false;\n+    }\n+\n+    \/\/ all done, write the blob into dest\n+    hb_blob_t *cmap_prime = hb_blob_create ((const char *) dest,\n+                                            dest_sz,\n+                                            HB_MEMORY_MODE_READONLY,\n+                                            dest,\n+                                            free);\n+    bool result =  plan->add_table (HB_OT_TAG_cmap, cmap_prime);\n+    hb_blob_destroy (cmap_prime);\n+    return result;\n+  }\n+\n+  const CmapSubtable *find_best_subtable (bool *symbol = nullptr) const\n+  {\n+    if (symbol) *symbol = false;\n+\n+    const CmapSubtable *subtable;\n+\n+    \/* 32-bit subtables. *\/\n+    if ((subtable = this->find_subtable (3, 10))) return subtable;\n+    if ((subtable = this->find_subtable (0, 6))) return subtable;\n+    if ((subtable = this->find_subtable (0, 4))) return subtable;\n+\n+    \/* 16-bit subtables. *\/\n+    if ((subtable = this->find_subtable (3, 1))) return subtable;\n+    if ((subtable = this->find_subtable (0, 3))) return subtable;\n+    if ((subtable = this->find_subtable (0, 2))) return subtable;\n+    if ((subtable = this->find_subtable (0, 1))) return subtable;\n+    if ((subtable = this->find_subtable (0, 0))) return subtable;\n+\n+    \/* Symbol subtable. *\/\n+    if ((subtable = this->find_subtable (3, 0)))\n+    {\n+      if (symbol) *symbol = true;\n+      return subtable;\n+    }\n+\n+    \/* Meh. *\/\n+    return &Null (CmapSubtable);\n+  }\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      this->table = hb_sanitize_context_t ().reference_table<cmap> (face);\n+      bool symbol;\n+      this->subtable = table->find_best_subtable (&symbol);\n+      this->subtable_uvs = &Null (CmapSubtableFormat14);\n+      {\n+        const CmapSubtable *st = table->find_subtable (0, 5);\n+        if (st && st->u.format == 14)\n+          subtable_uvs = &st->u.format14;\n+      }\n+\n+      this->get_glyph_data = subtable;\n+      if (unlikely (symbol))\n+      {\n+        this->get_glyph_funcZ = get_glyph_from_symbol<CmapSubtable>;\n+      } else {\n+        switch (subtable->u.format) {\n+        \/* Accelerate format 4 and format 12. *\/\n+        default:\n+          this->get_glyph_funcZ = get_glyph_from<CmapSubtable>;\n+          break;\n+        case 12:\n+          this->get_glyph_funcZ = get_glyph_from<CmapSubtableFormat12>;\n+          break;\n+        case  4:\n+          {\n+            this->format4_accel.init (&subtable->u.format4);\n+            this->get_glyph_data = &this->format4_accel;\n+            this->get_glyph_funcZ = this->format4_accel.get_glyph_func;\n+          }\n+          break;\n+        }\n+      }\n+    }\n+\n+    void fini () { this->table.destroy (); }\n+\n+    bool get_nominal_glyph (hb_codepoint_t  unicode,\n+                                   hb_codepoint_t *glyph) const\n+    {\n+      if (unlikely (!this->get_glyph_funcZ)) return false;\n+      return this->get_glyph_funcZ (this->get_glyph_data, unicode, glyph);\n+    }\n+    unsigned int get_nominal_glyphs (unsigned int count,\n+                                     const hb_codepoint_t *first_unicode,\n+                                     unsigned int unicode_stride,\n+                                     hb_codepoint_t *first_glyph,\n+                                     unsigned int glyph_stride) const\n+    {\n+      if (unlikely (!this->get_glyph_funcZ)) return 0;\n+\n+      hb_cmap_get_glyph_func_t get_glyph_funcZ = this->get_glyph_funcZ;\n+      const void *get_glyph_data = this->get_glyph_data;\n+\n+      unsigned int done;\n+      for (done = 0;\n+           done < count && get_glyph_funcZ (get_glyph_data, *first_unicode, first_glyph);\n+           done++)\n+      {\n+        first_unicode = &StructAtOffsetUnaligned<hb_codepoint_t> (first_unicode, unicode_stride);\n+        first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+      }\n+      return done;\n+    }\n+\n+    bool get_variation_glyph (hb_codepoint_t  unicode,\n+                              hb_codepoint_t  variation_selector,\n+                              hb_codepoint_t *glyph) const\n+    {\n+      switch (this->subtable_uvs->get_glyph_variant (unicode,\n+                                                     variation_selector,\n+                                                     glyph))\n+      {\n+        case GLYPH_VARIANT_NOT_FOUND:   return false;\n+        case GLYPH_VARIANT_FOUND:       return true;\n+        case GLYPH_VARIANT_USE_DEFAULT: break;\n+      }\n+\n+      return get_nominal_glyph (unicode, glyph);\n+    }\n+\n+    void collect_unicodes (hb_set_t *out) const\n+    {\n+      subtable->collect_unicodes (out);\n+    }\n+    void collect_variation_selectors (hb_set_t *out) const\n+    {\n+      subtable_uvs->collect_variation_selectors (out);\n+    }\n+    void collect_variation_unicodes (hb_codepoint_t variation_selector,\n+                                     hb_set_t *out) const\n+    {\n+      subtable_uvs->collect_variation_unicodes (variation_selector, out);\n+    }\n+\n+    protected:\n+    typedef bool (*hb_cmap_get_glyph_func_t) (const void *obj,\n+                                              hb_codepoint_t codepoint,\n+                                              hb_codepoint_t *glyph);\n+\n+    template <typename Type>\n+    static bool get_glyph_from (const void *obj,\n+                                hb_codepoint_t codepoint,\n+                                hb_codepoint_t *glyph)\n+    {\n+      const Type *typed_obj = (const Type *) obj;\n+      return typed_obj->get_glyph (codepoint, glyph);\n+    }\n+\n+    template <typename Type>\n+    static bool get_glyph_from_symbol (const void *obj,\n+                                              hb_codepoint_t codepoint,\n+                                              hb_codepoint_t *glyph)\n+    {\n+      const Type *typed_obj = (const Type *) obj;\n+      if (likely (typed_obj->get_glyph (codepoint, glyph)))\n+        return true;\n+\n+      if (codepoint <= 0x00FFu)\n+      {\n+        \/* For symbol-encoded OpenType fonts, we duplicate the\n+         * U+F000..F0FF range at U+0000..U+00FF.  That's what\n+         * Windows seems to do, and that's hinted about at:\n+         * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/recom\n+         * under \"Non-Standard (Symbol) Fonts\". *\/\n+        return typed_obj->get_glyph (0xF000u + codepoint, glyph);\n+      }\n+\n+      return false;\n+    }\n+\n+    private:\n+    hb_nonnull_ptr_t<const CmapSubtable> subtable;\n+    hb_nonnull_ptr_t<const CmapSubtableFormat14> subtable_uvs;\n+\n+    hb_cmap_get_glyph_func_t get_glyph_funcZ;\n+    const void *get_glyph_data;\n+\n+    CmapSubtableFormat4::accelerator_t format4_accel;\n+\n+    hb_blob_ptr_t<cmap> table;\n+  };\n+\n+  protected:\n+\n+  const CmapSubtable *find_subtable (unsigned int platform_id,\n+                                     unsigned int encoding_id) const\n+  {\n+    EncodingRecord key;\n+    key.platformID.set (platform_id);\n+    key.encodingID.set (encoding_id);\n+\n+    const EncodingRecord &result = encodingRecord.bsearch (key);\n+    if (!result.subtable)\n+      return nullptr;\n+\n+    return &(this+result.subtable);\n+  }\n+\n+  public:\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  likely (version == 0) &&\n+                  encodingRecord.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16              version;        \/* Table version number (0). *\/\n+  SortedArrayOf<EncodingRecord>\n+                        encodingRecord; \/* Encoding tables. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, encodingRecord);\n+};\n+\n+struct cmap_accelerator_t : cmap::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_CMAP_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-cmap-table.hh","additions":1180,"deletions":0,"binary":false,"changes":1180,"status":"added"},{"patch":"@@ -0,0 +1,535 @@\n+\/*\n+ * Copyright © 2016  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Seigo Nonaka\n+ *\/\n+\n+#ifndef HB_OT_COLOR_CBDT_TABLE_HH\n+#define HB_OT_COLOR_CBDT_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * CBLC -- Color Bitmap Location\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cblc\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/eblc\n+ * CBDT -- Color Bitmap Data\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cbdt\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/ebdt\n+ *\/\n+#define HB_OT_TAG_CBLC HB_TAG('C','B','L','C')\n+#define HB_OT_TAG_CBDT HB_TAG('C','B','D','T')\n+\n+\n+namespace OT {\n+\n+struct SmallGlyphMetrics\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void get_extents (hb_glyph_extents_t *extents) const\n+  {\n+    extents->x_bearing = bearingX;\n+    extents->y_bearing = bearingY;\n+    extents->width = width;\n+    extents->height = - (hb_position_t) height;\n+  }\n+\n+  HBUINT8       height;\n+  HBUINT8       width;\n+  HBINT8        bearingX;\n+  HBINT8        bearingY;\n+  HBUINT8       advance;\n+  public:\n+  DEFINE_SIZE_STATIC(5);\n+};\n+\n+struct BigGlyphMetrics : SmallGlyphMetrics\n+{\n+  HBINT8        vertBearingX;\n+  HBINT8        vertBearingY;\n+  HBUINT8       vertAdvance;\n+  public:\n+  DEFINE_SIZE_STATIC(8);\n+};\n+\n+struct SBitLineMetrics\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBINT8        ascender;\n+  HBINT8        decender;\n+  HBUINT8       widthMax;\n+  HBINT8        caretSlopeNumerator;\n+  HBINT8        caretSlopeDenominator;\n+  HBINT8        caretOffset;\n+  HBINT8        minOriginSB;\n+  HBINT8        minAdvanceSB;\n+  HBINT8        maxBeforeBL;\n+  HBINT8        minAfterBL;\n+  HBINT8        padding1;\n+  HBINT8        padding2;\n+  public:\n+  DEFINE_SIZE_STATIC(12);\n+};\n+\n+\n+\/*\n+ * Index Subtables.\n+ *\/\n+\n+struct IndexSubtableHeader\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT16      indexFormat;\n+  HBUINT16      imageFormat;\n+  HBUINT32      imageDataOffset;\n+  public:\n+  DEFINE_SIZE_STATIC(8);\n+};\n+\n+template <typename OffsetType>\n+struct IndexSubtableFormat1Or3\n+{\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  offsetArrayZ.sanitize (c, glyph_count + 1));\n+  }\n+\n+  bool get_image_data (unsigned int idx,\n+                       unsigned int *offset,\n+                       unsigned int *length) const\n+  {\n+    if (unlikely (offsetArrayZ[idx + 1] <= offsetArrayZ[idx]))\n+      return false;\n+\n+    *offset = header.imageDataOffset + offsetArrayZ[idx];\n+    *length = offsetArrayZ[idx + 1] - offsetArrayZ[idx];\n+    return true;\n+  }\n+\n+  IndexSubtableHeader   header;\n+  UnsizedArrayOf<Offset<OffsetType> >\n+                        offsetArrayZ;\n+  public:\n+  DEFINE_SIZE_ARRAY(8, offsetArrayZ);\n+};\n+\n+struct IndexSubtableFormat1 : IndexSubtableFormat1Or3<HBUINT32> {};\n+struct IndexSubtableFormat3 : IndexSubtableFormat1Or3<HBUINT16> {};\n+\n+struct IndexSubtable\n+{\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int glyph_count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.header.sanitize (c)) return_trace (false);\n+    switch (u.header.indexFormat) {\n+    case 1: return_trace (u.format1.sanitize (c, glyph_count));\n+    case 3: return_trace (u.format3.sanitize (c, glyph_count));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  bool get_extents (hb_glyph_extents_t *extents HB_UNUSED) const\n+  {\n+    switch (u.header.indexFormat) {\n+    case 2: case 5: \/* TODO *\/\n+    case 1: case 3: case 4: \/* Variable-metrics formats do not have metrics here. *\/\n+    default:return (false);\n+    }\n+  }\n+\n+  bool get_image_data (unsigned int idx,\n+                       unsigned int *offset,\n+                       unsigned int *length,\n+                       unsigned int *format) const\n+  {\n+    *format = u.header.imageFormat;\n+    switch (u.header.indexFormat) {\n+    case 1: return u.format1.get_image_data (idx, offset, length);\n+    case 3: return u.format3.get_image_data (idx, offset, length);\n+    default: return false;\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  IndexSubtableHeader   header;\n+  IndexSubtableFormat1  format1;\n+  IndexSubtableFormat3  format3;\n+  \/* TODO: Format 2, 4, 5. *\/\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (8, header);\n+};\n+\n+struct IndexSubtableRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  firstGlyphIndex <= lastGlyphIndex &&\n+                  offsetToSubtable.sanitize (c, base, lastGlyphIndex - firstGlyphIndex + 1));\n+  }\n+\n+  bool get_extents (hb_glyph_extents_t *extents,\n+                    const void *base) const\n+  {\n+    return (base+offsetToSubtable).get_extents (extents);\n+  }\n+\n+  bool get_image_data (unsigned int  gid,\n+                       const void   *base,\n+                       unsigned int *offset,\n+                       unsigned int *length,\n+                       unsigned int *format) const\n+  {\n+    if (gid < firstGlyphIndex || gid > lastGlyphIndex) return false;\n+    return (base+offsetToSubtable).get_image_data (gid - firstGlyphIndex,\n+                                                   offset, length, format);\n+  }\n+\n+  GlyphID                       firstGlyphIndex;\n+  GlyphID                       lastGlyphIndex;\n+  LOffsetTo<IndexSubtable>      offsetToSubtable;\n+  public:\n+  DEFINE_SIZE_STATIC(8);\n+};\n+\n+struct IndexSubtableArray\n+{\n+  friend struct CBDT;\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (indexSubtablesZ.sanitize (c, count, this));\n+  }\n+\n+  public:\n+  const IndexSubtableRecord* find_table (hb_codepoint_t glyph, unsigned int numTables) const\n+  {\n+    for (unsigned int i = 0; i < numTables; ++i)\n+    {\n+      unsigned int firstGlyphIndex = indexSubtablesZ[i].firstGlyphIndex;\n+      unsigned int lastGlyphIndex = indexSubtablesZ[i].lastGlyphIndex;\n+      if (firstGlyphIndex <= glyph && glyph <= lastGlyphIndex)\n+        return &indexSubtablesZ[i];\n+    }\n+    return nullptr;\n+  }\n+\n+  protected:\n+  UnsizedArrayOf<IndexSubtableRecord>   indexSubtablesZ;\n+};\n+\n+struct BitmapSizeTable\n+{\n+  friend struct CBLC;\n+  friend struct CBDT;\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  indexSubtableArrayOffset.sanitize (c, base, numberOfIndexSubtables) &&\n+                  horizontal.sanitize (c) &&\n+                  vertical.sanitize (c));\n+  }\n+\n+  const IndexSubtableRecord *find_table (hb_codepoint_t glyph,\n+                                         const void *base,\n+                                         const void **out_base) const\n+  {\n+    *out_base = &(base+indexSubtableArrayOffset);\n+    return (base+indexSubtableArrayOffset).find_table (glyph, numberOfIndexSubtables);\n+  }\n+\n+  protected:\n+  LNNOffsetTo<IndexSubtableArray>\n+                        indexSubtableArrayOffset;\n+  HBUINT32              indexTablesSize;\n+  HBUINT32              numberOfIndexSubtables;\n+  HBUINT32              colorRef;\n+  SBitLineMetrics       horizontal;\n+  SBitLineMetrics       vertical;\n+  GlyphID               startGlyphIndex;\n+  GlyphID               endGlyphIndex;\n+  HBUINT8               ppemX;\n+  HBUINT8               ppemY;\n+  HBUINT8               bitDepth;\n+  HBINT8                flags;\n+  public:\n+  DEFINE_SIZE_STATIC(48);\n+};\n+\n+\n+\/*\n+ * Glyph Bitmap Data Formats.\n+ *\/\n+\n+struct GlyphBitmapDataFormat17\n+{\n+  SmallGlyphMetrics     glyphMetrics;\n+  LArrayOf<HBUINT8>     data;\n+  public:\n+  DEFINE_SIZE_ARRAY(9, data);\n+};\n+\n+struct GlyphBitmapDataFormat18\n+{\n+  BigGlyphMetrics       glyphMetrics;\n+  LArrayOf<HBUINT8>     data;\n+  public:\n+  DEFINE_SIZE_ARRAY(12, data);\n+};\n+\n+struct GlyphBitmapDataFormat19\n+{\n+  LArrayOf<HBUINT8>     data;\n+  public:\n+  DEFINE_SIZE_ARRAY(4, data);\n+};\n+\n+struct CBLC\n+{\n+  friend struct CBDT;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_CBLC;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  likely (version.major == 2 || version.major == 3) &&\n+                  sizeTables.sanitize (c, this));\n+  }\n+\n+  protected:\n+  const BitmapSizeTable &choose_strike (hb_font_t *font) const\n+  {\n+    unsigned count = sizeTables.len;\n+    if (unlikely (!count))\n+      return Null(BitmapSizeTable);\n+\n+    unsigned int requested_ppem = MAX (font->x_ppem, font->y_ppem);\n+    if (!requested_ppem)\n+      requested_ppem = 1<<30; \/* Choose largest strike. *\/\n+    unsigned int best_i = 0;\n+    unsigned int best_ppem = MAX (sizeTables[0].ppemX, sizeTables[0].ppemY);\n+\n+    for (unsigned int i = 1; i < count; i++)\n+    {\n+      unsigned int ppem = MAX (sizeTables[i].ppemX, sizeTables[i].ppemY);\n+      if ((requested_ppem <= ppem && ppem < best_ppem) ||\n+          (requested_ppem > best_ppem && ppem > best_ppem))\n+      {\n+        best_i = i;\n+        best_ppem = ppem;\n+      }\n+    }\n+\n+    return sizeTables[best_i];\n+  }\n+\n+  protected:\n+  FixedVersion<>                version;\n+  LArrayOf<BitmapSizeTable>     sizeTables;\n+  public:\n+  DEFINE_SIZE_ARRAY(8, sizeTables);\n+};\n+\n+struct CBDT\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_CBDT;\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      cblc = hb_sanitize_context_t().reference_table<CBLC> (face);\n+      cbdt = hb_sanitize_context_t().reference_table<CBDT> (face);\n+\n+      upem = hb_face_get_upem (face);\n+    }\n+\n+    void fini ()\n+    {\n+      this->cblc.destroy ();\n+      this->cbdt.destroy ();\n+    }\n+\n+    bool get_extents (hb_font_t *font, hb_codepoint_t glyph,\n+                      hb_glyph_extents_t *extents) const\n+    {\n+      const void *base;\n+      const BitmapSizeTable &strike = this->cblc->choose_strike (font);\n+      const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &base);\n+      if (!subtable_record || !strike.ppemX || !strike.ppemY)\n+        return false;\n+\n+      if (subtable_record->get_extents (extents, base))\n+        return true;\n+\n+      unsigned int image_offset = 0, image_length = 0, image_format = 0;\n+      if (!subtable_record->get_image_data (glyph, base, &image_offset, &image_length, &image_format))\n+        return false;\n+\n+      {\n+        unsigned int cbdt_len = cbdt.get_length ();\n+        if (unlikely (image_offset > cbdt_len || cbdt_len - image_offset < image_length))\n+          return false;\n+\n+        switch (image_format)\n+        {\n+          case 17: {\n+            if (unlikely (image_length < GlyphBitmapDataFormat17::min_size))\n+              return false;\n+            const GlyphBitmapDataFormat17& glyphFormat17 =\n+                StructAtOffset<GlyphBitmapDataFormat17> (this->cbdt, image_offset);\n+            glyphFormat17.glyphMetrics.get_extents (extents);\n+            break;\n+          }\n+          case 18: {\n+            if (unlikely (image_length < GlyphBitmapDataFormat18::min_size))\n+              return false;\n+            const GlyphBitmapDataFormat18& glyphFormat18 =\n+                StructAtOffset<GlyphBitmapDataFormat18> (this->cbdt, image_offset);\n+            glyphFormat18.glyphMetrics.get_extents (extents);\n+            break;\n+          }\n+          default:\n+            \/\/ TODO: Support other image formats.\n+            return false;\n+        }\n+      }\n+\n+      \/* Convert to font units. *\/\n+      double x_scale = upem \/ (double) strike.ppemX;\n+      double y_scale = upem \/ (double) strike.ppemY;\n+      extents->x_bearing = round (extents->x_bearing * x_scale);\n+      extents->y_bearing = round (extents->y_bearing * y_scale);\n+      extents->width = round (extents->width * x_scale);\n+      extents->height = round (extents->height * y_scale);\n+\n+      return true;\n+    }\n+\n+    hb_blob_t* reference_png (hb_font_t      *font,\n+                                     hb_codepoint_t  glyph) const\n+    {\n+      const void *base;\n+      const BitmapSizeTable &strike = this->cblc->choose_strike (font);\n+      const IndexSubtableRecord *subtable_record = strike.find_table (glyph, cblc, &base);\n+      if (!subtable_record || !strike.ppemX || !strike.ppemY)\n+        return hb_blob_get_empty ();\n+\n+      unsigned int image_offset = 0, image_length = 0, image_format = 0;\n+      if (!subtable_record->get_image_data (glyph, base, &image_offset, &image_length, &image_format))\n+        return hb_blob_get_empty ();\n+\n+      {\n+        unsigned int cbdt_len = cbdt.get_length ();\n+        if (unlikely (image_offset > cbdt_len || cbdt_len - image_offset < image_length))\n+          return hb_blob_get_empty ();\n+\n+        switch (image_format)\n+        {\n+          case 17: {\n+            if (unlikely (image_length < GlyphBitmapDataFormat17::min_size))\n+              return hb_blob_get_empty ();\n+            const GlyphBitmapDataFormat17& glyphFormat17 =\n+              StructAtOffset<GlyphBitmapDataFormat17> (this->cbdt, image_offset);\n+            return hb_blob_create_sub_blob (cbdt.get_blob (),\n+                                            image_offset + GlyphBitmapDataFormat17::min_size,\n+                                            glyphFormat17.data.len);\n+          }\n+          case 18: {\n+            if (unlikely (image_length < GlyphBitmapDataFormat18::min_size))\n+              return hb_blob_get_empty ();\n+            const GlyphBitmapDataFormat18& glyphFormat18 =\n+              StructAtOffset<GlyphBitmapDataFormat18> (this->cbdt, image_offset);\n+            return hb_blob_create_sub_blob (cbdt.get_blob (),\n+                                            image_offset + GlyphBitmapDataFormat18::min_size,\n+                                            glyphFormat18.data.len);\n+          }\n+          case 19: {\n+            if (unlikely (image_length < GlyphBitmapDataFormat19::min_size))\n+              return hb_blob_get_empty ();\n+            const GlyphBitmapDataFormat19& glyphFormat19 =\n+              StructAtOffset<GlyphBitmapDataFormat19> (this->cbdt, image_offset);\n+            return hb_blob_create_sub_blob (cbdt.get_blob (),\n+                                            image_offset + GlyphBitmapDataFormat19::min_size,\n+                                            glyphFormat19.data.len);\n+          }\n+        }\n+      }\n+\n+      return hb_blob_get_empty ();\n+    }\n+\n+    bool has_data () const { return cbdt.get_length (); }\n+\n+    private:\n+    hb_blob_ptr_t<CBLC> cblc;\n+    hb_blob_ptr_t<CBDT> cbdt;\n+\n+    unsigned int upem;\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  likely (version.major == 2 || version.major == 3));\n+  }\n+\n+  protected:\n+  FixedVersion<>                version;\n+  UnsizedArrayOf<HBUINT8>       dataZ;\n+  public:\n+  DEFINE_SIZE_ARRAY(4, dataZ);\n+};\n+\n+struct CBDT_accelerator_t : CBDT::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+#endif \/* HB_OT_COLOR_CBDT_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-color-cbdt-table.hh","additions":535,"deletions":0,"binary":false,"changes":535,"status":"added"},{"patch":"@@ -0,0 +1,140 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_OT_COLOR_COLR_TABLE_HH\n+#define HB_OT_COLOR_COLR_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * COLR -- Color\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/colr\n+ *\/\n+#define HB_OT_TAG_COLR HB_TAG('C','O','L','R')\n+\n+\n+namespace OT {\n+\n+\n+struct LayerRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  GlyphID       glyphId;        \/* Glyph ID of layer glyph *\/\n+  Index         colorIdx;       \/* Index value to use with a\n+                                 * selected color palette.\n+                                 * An index value of 0xFFFF\n+                                 * is a special case indicating\n+                                 * that the text foreground\n+                                 * color (defined by a\n+                                 * higher-level client) should\n+                                 * be used and shall not be\n+                                 * treated as actual index\n+                                 * into CPAL ColorRecord array. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct BaseGlyphRecord\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < glyphId ? -1 : g > glyphId ? 1 : 0; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  public:\n+  GlyphID       glyphId;        \/* Glyph ID of reference glyph *\/\n+  HBUINT16      firstLayerIdx;  \/* Index (from beginning of\n+                                 * the Layer Records) to the\n+                                 * layer record. There will be\n+                                 * numLayers consecutive entries\n+                                 * for this base glyph. *\/\n+  HBUINT16      numLayers;      \/* Number of color layers\n+                                 * associated with this glyph *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct COLR\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_COLR;\n+\n+  bool has_data () const { return numBaseGlyphs; }\n+\n+  unsigned int get_glyph_layers (hb_codepoint_t       glyph,\n+                                 unsigned int         start_offset,\n+                                 unsigned int        *count, \/* IN\/OUT.  May be NULL. *\/\n+                                 hb_ot_color_layer_t *layers \/* OUT.     May be NULL. *\/) const\n+  {\n+    const BaseGlyphRecord &record = (this+baseGlyphsZ).bsearch (numBaseGlyphs, glyph);\n+\n+    hb_array_t<const LayerRecord> all_layers ((this+layersZ).arrayZ, numLayers);\n+    hb_array_t<const LayerRecord> glyph_layers = all_layers.sub_array (record.firstLayerIdx,\n+                                                                       record.numLayers);\n+    if (count)\n+    {\n+      hb_array_t<const LayerRecord> segment_layers = glyph_layers.sub_array (start_offset, *count);\n+      *count = segment_layers.length;\n+      for (unsigned int i = 0; i < segment_layers.length; i++)\n+      {\n+        layers[i].glyph = segment_layers.arrayZ[i].glyphId;\n+        layers[i].color_index = segment_layers.arrayZ[i].colorIdx;\n+      }\n+    }\n+    return glyph_layers.length;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (this+baseGlyphsZ).sanitize (c, numBaseGlyphs) &&\n+                          (this+layersZ).sanitize (c, numLayers)));\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Table version number (starts at 0). *\/\n+  HBUINT16      numBaseGlyphs;  \/* Number of Base Glyph Records. *\/\n+  LNNOffsetTo<SortedUnsizedArrayOf<BaseGlyphRecord> >\n+                baseGlyphsZ;    \/* Offset to Base Glyph records. *\/\n+  LNNOffsetTo<UnsizedArrayOf<LayerRecord> >\n+                layersZ;        \/* Offset to Layer Records. *\/\n+  HBUINT16      numLayers;      \/* Number of Layer Records. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (14);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_COLOR_COLR_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-color-colr-table.hh","additions":140,"deletions":0,"binary":false,"changes":140,"status":"added"},{"patch":"@@ -0,0 +1,193 @@\n+\/*\n+ * Copyright © 2016  Google, Inc.\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Sascha Brawer\n+ *\/\n+\n+#ifndef HB_OT_COLOR_CPAL_TABLE_HH\n+#define HB_OT_COLOR_CPAL_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-color.h\"\n+#include \"hb-ot-name.h\"\n+\n+\n+\/*\n+ * CPAL -- Color Palette\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/cpal\n+ *\/\n+#define HB_OT_TAG_CPAL HB_TAG('C','P','A','L')\n+\n+\n+namespace OT {\n+\n+\n+struct CPALV1Tail\n+{\n+  friend struct CPAL;\n+\n+  private:\n+  hb_ot_color_palette_flags_t get_palette_flags (const void *base,\n+                                                 unsigned int palette_index,\n+                                                 unsigned int palette_count) const\n+  {\n+    if (!paletteFlagsZ) return HB_OT_COLOR_PALETTE_FLAG_DEFAULT;\n+    return (hb_ot_color_palette_flags_t) (uint32_t)\n+           (base+paletteFlagsZ).as_array (palette_count)[palette_index];\n+  }\n+\n+  hb_ot_name_id_t get_palette_name_id (const void *base,\n+                                       unsigned int palette_index,\n+                                       unsigned int palette_count) const\n+  {\n+    if (!paletteLabelsZ) return HB_OT_NAME_ID_INVALID;\n+    return (base+paletteLabelsZ).as_array (palette_count)[palette_index];\n+  }\n+\n+  hb_ot_name_id_t get_color_name_id (const void *base,\n+                                     unsigned int color_index,\n+                                     unsigned int color_count) const\n+  {\n+    if (!colorLabelsZ) return HB_OT_NAME_ID_INVALID;\n+    return (base+colorLabelsZ).as_array (color_count)[color_index];\n+  }\n+\n+  public:\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const void *base,\n+                 unsigned int palette_count,\n+                 unsigned int color_count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  (!paletteFlagsZ  || (base+paletteFlagsZ).sanitize (c, palette_count)) &&\n+                  (!paletteLabelsZ || (base+paletteLabelsZ).sanitize (c, palette_count)) &&\n+                  (!colorLabelsZ   || (base+colorLabelsZ).sanitize (c, color_count)));\n+  }\n+\n+  protected:\n+  LNNOffsetTo<UnsizedArrayOf<HBUINT32> >\n+                paletteFlagsZ;          \/* Offset from the beginning of CPAL table to\n+                                         * the Palette Type Array. Set to 0 if no array\n+                                         * is provided. *\/\n+  LNNOffsetTo<UnsizedArrayOf<NameID> >\n+                paletteLabelsZ;         \/* Offset from the beginning of CPAL table to\n+                                         * the palette labels array. Set to 0 if no\n+                                         * array is provided. *\/\n+  LNNOffsetTo<UnsizedArrayOf<NameID> >\n+                colorLabelsZ;           \/* Offset from the beginning of CPAL table to\n+                                         * the color labels array. Set to 0\n+                                         * if no array is provided. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+typedef HBUINT32 BGRAColor;\n+\n+struct CPAL\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_CPAL;\n+\n+  bool has_data () const { return numPalettes; }\n+\n+  unsigned int get_size () const\n+  { return min_size + numPalettes * sizeof (colorRecordIndicesZ[0]); }\n+\n+  unsigned int get_palette_count () const { return numPalettes; }\n+  unsigned int get_color_count () const   { return numColors; }\n+\n+  hb_ot_color_palette_flags_t get_palette_flags (unsigned int palette_index) const\n+  { return v1 ().get_palette_flags (this, palette_index, numPalettes); }\n+\n+  hb_ot_name_id_t get_palette_name_id (unsigned int palette_index) const\n+  { return v1 ().get_palette_name_id (this, palette_index, numPalettes); }\n+\n+  hb_ot_name_id_t get_color_name_id (unsigned int color_index) const\n+  { return v1 ().get_color_name_id (this, color_index, numColors); }\n+\n+  unsigned int get_palette_colors (unsigned int  palette_index,\n+                                   unsigned int  start_offset,\n+                                   unsigned int *color_count, \/* IN\/OUT.  May be NULL. *\/\n+                                   hb_color_t   *colors       \/* OUT.     May be NULL. *\/) const\n+  {\n+    if (unlikely (palette_index >= numPalettes))\n+    {\n+      if (color_count) *color_count = 0;\n+      return 0;\n+    }\n+    unsigned int start_index = colorRecordIndicesZ[palette_index];\n+    hb_array_t<const BGRAColor> all_colors ((this+colorRecordsZ).arrayZ, numColorRecords);\n+    hb_array_t<const BGRAColor> palette_colors = all_colors.sub_array (start_index,\n+                                                                       numColors);\n+    if (color_count)\n+    {\n+      hb_array_t<const BGRAColor> segment_colors = palette_colors.sub_array (start_offset, *color_count);\n+      \/* Always return numColors colors per palette even if it has out-of-bounds start index. *\/\n+      unsigned int count = MIN<unsigned int> (MAX<int> (numColors - start_offset, 0), *color_count);\n+      *color_count = count;\n+      for (unsigned int i = 0; i < count; i++)\n+        colors[i] = segment_colors[i]; \/* Bound-checked read. *\/\n+    }\n+    return numColors;\n+  }\n+\n+  private:\n+  const CPALV1Tail& v1 () const\n+  {\n+    if (version == 0) return Null(CPALV1Tail);\n+    return StructAfter<CPALV1Tail> (*this);\n+  }\n+\n+  public:\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  (this+colorRecordsZ).sanitize (c, numColorRecords) &&\n+                  colorRecordIndicesZ.sanitize (c, numPalettes) &&\n+                  (version == 0 || v1 ().sanitize (c, this, numPalettes, numColors)));\n+  }\n+\n+  protected:\n+  HBUINT16      version;                \/* Table version number *\/\n+  \/* Version 0 *\/\n+  HBUINT16      numColors;              \/* Number of colors in each palette. *\/\n+  HBUINT16      numPalettes;            \/* Number of palettes in the table. *\/\n+  HBUINT16      numColorRecords;        \/* Total number of color records, combined for\n+                                         * all palettes. *\/\n+  LNNOffsetTo<UnsizedArrayOf<BGRAColor> >\n+                colorRecordsZ;          \/* Offset from the beginning of CPAL table to\n+                                         * the first ColorRecord. *\/\n+  UnsizedArrayOf<HBUINT16>\n+                colorRecordIndicesZ;    \/* Index of each palette’s first color record in\n+                                         * the combined color record array. *\/\n+\/*CPALV1Tail    v1;*\/\n+  public:\n+  DEFINE_SIZE_ARRAY (12, colorRecordIndicesZ);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_COLOR_CPAL_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-color-cpal-table.hh","additions":193,"deletions":0,"binary":false,"changes":193,"status":"added"},{"patch":"@@ -0,0 +1,286 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_OT_COLOR_SBIX_TABLE_HH\n+#define HB_OT_COLOR_SBIX_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * sbix -- Standard Bitmap Graphics\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/sbix\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6sbix.html\n+ *\/\n+#define HB_OT_TAG_sbix HB_TAG('s','b','i','x')\n+\n+\n+namespace OT {\n+\n+\n+struct SBIXGlyph\n+{\n+  HBINT16       xOffset;        \/* The horizontal (x-axis) offset from the left\n+                                 * edge of the graphic to the glyph’s origin.\n+                                 * That is, the x-coordinate of the point on the\n+                                 * baseline at the left edge of the glyph. *\/\n+  HBINT16       yOffset;        \/* The vertical (y-axis) offset from the bottom\n+                                 * edge of the graphic to the glyph’s origin.\n+                                 * That is, the y-coordinate of the point on the\n+                                 * baseline at the left edge of the glyph. *\/\n+  Tag           graphicType;    \/* Indicates the format of the embedded graphic\n+                                 * data: one of 'jpg ', 'png ' or 'tiff', or the\n+                                 * special format 'dupe'. *\/\n+  UnsizedArrayOf<HBUINT8>\n+                data;           \/* The actual embedded graphic data. The total\n+                                 * length is inferred from sequential entries in\n+                                 * the glyphDataOffsets array and the fixed size\n+                                 * (8 bytes) of the preceding fields. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, data);\n+};\n+\n+struct SBIXStrike\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  imageOffsetsZ.sanitize_shallow (c, c->get_num_glyphs () + 1));\n+  }\n+\n+  hb_blob_t *get_glyph_blob (unsigned int  glyph_id,\n+                             hb_blob_t    *sbix_blob,\n+                             hb_tag_t      file_type,\n+                             int          *x_offset,\n+                             int          *y_offset,\n+                             unsigned int  num_glyphs,\n+                             unsigned int *strike_ppem) const\n+  {\n+    if (unlikely (!ppem)) return hb_blob_get_empty (); \/* To get Null() object out of the way. *\/\n+\n+    unsigned int retry_count = 8;\n+    unsigned int sbix_len = sbix_blob->length;\n+    unsigned int strike_offset = (const char *) this - (const char *) sbix_blob->data;\n+    assert (strike_offset < sbix_len);\n+\n+  retry:\n+    if (unlikely (glyph_id >= num_glyphs ||\n+                  imageOffsetsZ[glyph_id + 1] <= imageOffsetsZ[glyph_id] ||\n+                  imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] <= SBIXGlyph::min_size ||\n+                  (unsigned int) imageOffsetsZ[glyph_id + 1] > sbix_len - strike_offset))\n+      return hb_blob_get_empty ();\n+\n+    unsigned int glyph_offset = strike_offset + (unsigned int) imageOffsetsZ[glyph_id] + SBIXGlyph::min_size;\n+    unsigned int glyph_length = imageOffsetsZ[glyph_id + 1] - imageOffsetsZ[glyph_id] - SBIXGlyph::min_size;\n+\n+    const SBIXGlyph *glyph = &(this+imageOffsetsZ[glyph_id]);\n+\n+    if (glyph->graphicType == HB_TAG ('d','u','p','e'))\n+    {\n+      if (glyph_length >= 2)\n+      {\n+        glyph_id = *((HBUINT16 *) &glyph->data);\n+        if (retry_count--)\n+          goto retry;\n+      }\n+      return hb_blob_get_empty ();\n+    }\n+\n+    if (unlikely (file_type != glyph->graphicType))\n+      return hb_blob_get_empty ();\n+\n+    if (strike_ppem) *strike_ppem = ppem;\n+    if (x_offset) *x_offset = glyph->xOffset;\n+    if (y_offset) *y_offset = glyph->yOffset;\n+    return hb_blob_create_sub_blob (sbix_blob, glyph_offset, glyph_length);\n+  }\n+\n+  public:\n+  HBUINT16      ppem;           \/* The PPEM size for which this strike was designed. *\/\n+  HBUINT16      resolution;     \/* The device pixel density (in PPI) for which this\n+                                 * strike was designed. (E.g., 96 PPI, 192 PPI.) *\/\n+  protected:\n+  UnsizedArrayOf<LOffsetTo<SBIXGlyph> >\n+                imageOffsetsZ;  \/* Offset from the beginning of the strike data header\n+                                 * to bitmap data for an individual glyph ID. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct sbix\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_sbix;\n+\n+  bool has_data () const { return version; }\n+\n+  const SBIXStrike &get_strike (unsigned int i) const { return this+strikes[i]; }\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      table = hb_sanitize_context_t().reference_table<sbix> (face);\n+      num_glyphs = face->get_num_glyphs ();\n+    }\n+    void fini () { table.destroy (); }\n+\n+    bool has_data () const { return table->has_data (); }\n+\n+    bool get_extents (hb_font_t          *font,\n+                      hb_codepoint_t      glyph,\n+                      hb_glyph_extents_t *extents) const\n+    {\n+      \/* We only support PNG right now, and following function checks type. *\/\n+      return get_png_extents (font, glyph, extents);\n+    }\n+\n+    hb_blob_t *reference_png (hb_font_t      *font,\n+                              hb_codepoint_t  glyph_id,\n+                              int            *x_offset,\n+                              int            *y_offset,\n+                              unsigned int   *available_ppem) const\n+    {\n+      return choose_strike (font).get_glyph_blob (glyph_id, table.get_blob (),\n+                                                  HB_TAG ('p','n','g',' '),\n+                                                  x_offset, y_offset,\n+                                                  num_glyphs, available_ppem);\n+    }\n+\n+    private:\n+\n+    const SBIXStrike &choose_strike (hb_font_t *font) const\n+    {\n+      unsigned count = table->strikes.len;\n+      if (unlikely (!count))\n+        return Null(SBIXStrike);\n+\n+      unsigned int requested_ppem = MAX (font->x_ppem, font->y_ppem);\n+      if (!requested_ppem)\n+        requested_ppem = 1<<30; \/* Choose largest strike. *\/\n+      \/* TODO Add DPI sensitivity as well? *\/\n+      unsigned int best_i = 0;\n+      unsigned int best_ppem = table->get_strike (0).ppem;\n+\n+      for (unsigned int i = 1; i < count; i++)\n+      {\n+        unsigned int ppem = (table->get_strike (i)).ppem;\n+        if ((requested_ppem <= ppem && ppem < best_ppem) ||\n+            (requested_ppem > best_ppem && ppem > best_ppem))\n+        {\n+          best_i = i;\n+          best_ppem = ppem;\n+        }\n+      }\n+\n+      return table->get_strike (best_i);\n+    }\n+\n+    struct PNGHeader\n+    {\n+      HBUINT8   signature[8];\n+      struct\n+      {\n+        struct\n+        {\n+          HBUINT32      length;\n+          Tag           type;\n+        }               header;\n+        HBUINT32        width;\n+        HBUINT32        height;\n+        HBUINT8         bitDepth;\n+        HBUINT8         colorType;\n+        HBUINT8         compressionMethod;\n+        HBUINT8         filterMethod;\n+        HBUINT8         interlaceMethod;\n+      } IHDR;\n+\n+      public:\n+      DEFINE_SIZE_STATIC (29);\n+    };\n+\n+    bool get_png_extents (hb_font_t          *font,\n+                          hb_codepoint_t      glyph,\n+                          hb_glyph_extents_t *extents) const\n+    {\n+      \/* Following code is safe to call even without data.\n+       * But faster to short-circuit. *\/\n+      if (!has_data ())\n+        return false;\n+\n+      int x_offset = 0, y_offset = 0;\n+      unsigned int strike_ppem = 0;\n+      hb_blob_t *blob = reference_png (font, glyph, &x_offset, &y_offset, &strike_ppem);\n+\n+      const PNGHeader &png = *blob->as<PNGHeader>();\n+\n+      extents->x_bearing = x_offset;\n+      extents->y_bearing = y_offset;\n+      extents->width     = png.IHDR.width;\n+      extents->height    = png.IHDR.height;\n+\n+      \/* Convert to font units. *\/\n+      if (strike_ppem)\n+      {\n+        double scale = font->face->get_upem () \/ (double) strike_ppem;\n+        extents->x_bearing = round (extents->x_bearing * scale);\n+        extents->y_bearing = round (extents->y_bearing * scale);\n+        extents->width = round (extents->width * scale);\n+        extents->height = round (extents->height * scale);\n+      }\n+\n+      hb_blob_destroy (blob);\n+\n+      return strike_ppem;\n+    }\n+\n+    private:\n+    hb_blob_ptr_t<sbix> table;\n+\n+    unsigned int num_glyphs;\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          version >= 1 &&\n+                          strikes.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Table version number — set to 1 *\/\n+  HBUINT16      flags;          \/* Bit 0: Set to 1. Bit 1: Draw outlines.\n+                                 * Bits 2 to 15: reserved (set to 0). *\/\n+  LOffsetLArrayOf<SBIXStrike>\n+                strikes;        \/* Offsets from the beginning of the 'sbix'\n+                                 * table to data for each individual bitmap strike. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, strikes);\n+};\n+\n+struct sbix_accelerator_t : sbix::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+#endif \/* HB_OT_COLOR_SBIX_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-color-sbix-table.hh","additions":286,"deletions":0,"binary":false,"changes":286,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_OT_COLOR_SVG_TABLE_HH\n+#define HB_OT_COLOR_SVG_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * SVG -- SVG (Scalable Vector Graphics)\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/svg\n+ *\/\n+\n+#define HB_OT_TAG_SVG HB_TAG('S','V','G',' ')\n+\n+\n+namespace OT {\n+\n+\n+struct SVGDocumentIndexEntry\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < startGlyphID ? -1 : g > endGlyphID ? 1 : 0; }\n+\n+  hb_blob_t *reference_blob (hb_blob_t *svg_blob, unsigned int index_offset) const\n+  {\n+    return hb_blob_create_sub_blob (svg_blob,\n+                                    index_offset + (unsigned int) svgDoc,\n+                                    svgDocLength);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  svgDoc.sanitize (c, base, svgDocLength));\n+  }\n+\n+  protected:\n+  HBUINT16      startGlyphID;   \/* The first glyph ID in the range described by\n+                                 * this index entry. *\/\n+  HBUINT16      endGlyphID;     \/* The last glyph ID in the range described by\n+                                 * this index entry. Must be >= startGlyphID. *\/\n+  LNNOffsetTo<UnsizedArrayOf<HBUINT8> >\n+                svgDoc;         \/* Offset from the beginning of the SVG Document Index\n+                                 * to an SVG document. Must be non-zero. *\/\n+  HBUINT32      svgDocLength;   \/* Length of the SVG document.\n+                                 * Must be non-zero. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct SVG\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_SVG;\n+\n+  bool has_data () const { return svgDocEntries; }\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    { table = hb_sanitize_context_t().reference_table<SVG> (face); }\n+    void fini () { table.destroy (); }\n+\n+    hb_blob_t *reference_blob_for_glyph (hb_codepoint_t glyph_id) const\n+    {\n+      return table->get_glyph_entry (glyph_id).reference_blob (table.get_blob (),\n+                                                               table->svgDocEntries);\n+    }\n+\n+    bool has_data () const { return table->has_data (); }\n+\n+    private:\n+    hb_blob_ptr_t<SVG> table;\n+  };\n+\n+  const SVGDocumentIndexEntry &get_glyph_entry (hb_codepoint_t glyph_id) const\n+  { return (this+svgDocEntries).bsearch (glyph_id); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (this+svgDocEntries).sanitize_shallow (c)));\n+  }\n+\n+  protected:\n+  HBUINT16      version;        \/* Table version (starting at 0). *\/\n+  LOffsetTo<SortedArrayOf<SVGDocumentIndexEntry> >\n+                svgDocEntries;  \/* Offset (relative to the start of the SVG table) to the\n+                                 * SVG Documents Index. Must be non-zero. *\/\n+                                \/* Array of SVG Document Index Entries. *\/\n+  HBUINT32      reserved;       \/* Set to 0. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+struct SVG_accelerator_t : SVG::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_COLOR_SVG_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-color-svg-table.hh","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright © 2016  Google, Inc.\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Sascha Brawer, Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-color-cbdt-table.hh\"\n+#include \"hb-ot-color-colr-table.hh\"\n+#include \"hb-ot-color-cpal-table.hh\"\n+#include \"hb-ot-color-sbix-table.hh\"\n+#include \"hb-ot-color-svg-table.hh\"\n+#include \"hb-ot-face.hh\"\n+#include \"hb-ot.h\"\n+\n+#include <stdlib.h>\n+#include <string.h>\n+\n+#include \"hb-ot-layout.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-ot-color\n+ * @title: hb-ot-color\n+ * @short_description: OpenType Color Fonts\n+ * @include: hb-ot.h\n+ *\n+ * Functions for fetching color-font information from OpenType font faces.\n+ **\/\n+\n+\n+\/*\n+ * CPAL\n+ *\/\n+\n+\n+\/**\n+ * hb_ot_color_has_palettes:\n+ * @face: a font face.\n+ *\n+ * Returns: whether CPAL table is available.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_bool_t\n+hb_ot_color_has_palettes (hb_face_t *face)\n+{\n+  return face->table.CPAL->has_data ();\n+}\n+\n+\/**\n+ * hb_ot_color_palette_get_count:\n+ * @face: a font face.\n+ *\n+ * Returns: the number of color palettes in @face, or zero if @face has\n+ * no colors.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+unsigned int\n+hb_ot_color_palette_get_count (hb_face_t *face)\n+{\n+  return face->table.CPAL->get_palette_count ();\n+}\n+\n+\/**\n+ * hb_ot_color_palette_get_name_id:\n+ * @face:    a font face.\n+ * @palette_index: the index of the color palette whose name is being requested.\n+ *\n+ * Retrieves the name id of a color palette. For example, a color font can\n+ * have themed palettes like \"Spring\", \"Summer\", \"Fall\", and \"Winter\".\n+ *\n+ * Returns: an identifier within @face's `name` table.\n+ * If the requested palette has no name the result is #HB_OT_NAME_ID_INVALID.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_ot_name_id_t\n+hb_ot_color_palette_get_name_id (hb_face_t *face,\n+                                 unsigned int palette_index)\n+{\n+  return face->table.CPAL->get_palette_name_id (palette_index);\n+}\n+\n+\/**\n+ * hb_ot_color_palette_color_get_name_id:\n+ * @face:        a font face.\n+ * @color_index: palette entry index.\n+ *\n+ * Returns: Name ID associated with a palette entry, e.g. eye color\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_ot_name_id_t\n+hb_ot_color_palette_color_get_name_id (hb_face_t *face,\n+                                       unsigned int color_index)\n+{\n+  return face->table.CPAL->get_color_name_id (color_index);\n+}\n+\n+\/**\n+ * hb_ot_color_palette_get_flags:\n+ * @face:          a font face\n+ * @palette_index: the index of the color palette whose flags are being requested\n+ *\n+ * Returns: the flags for the requested color palette.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_ot_color_palette_flags_t\n+hb_ot_color_palette_get_flags (hb_face_t *face,\n+                               unsigned int palette_index)\n+{\n+  return face->table.CPAL->get_palette_flags (palette_index);\n+}\n+\n+\/**\n+ * hb_ot_color_palette_get_colors:\n+ * @face:         a font face.\n+ * @palette_index:the index of the color palette whose colors\n+ *                are being requested.\n+ * @start_offset: the index of the first color being requested.\n+ * @color_count:  (inout) (optional): on input, how many colors\n+ *                can be maximally stored into the @colors array;\n+ *                on output, how many colors were actually stored.\n+ * @colors: (array length=color_count) (out) (optional):\n+ *                an array of #hb_color_t records. After calling\n+ *                this function, @colors will be filled with\n+ *                the palette colors. If @colors is NULL, the function\n+ *                will just return the number of total colors\n+ *                without storing any actual colors; this can be used\n+ *                for allocating a buffer of suitable size before calling\n+ *                hb_ot_color_palette_get_colors() a second time.\n+ *\n+ * Retrieves the colors in a color palette.\n+ *\n+ * Returns: the total number of colors in the palette.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+unsigned int\n+hb_ot_color_palette_get_colors (hb_face_t     *face,\n+                                unsigned int   palette_index,\n+                                unsigned int   start_offset,\n+                                unsigned int  *colors_count  \/* IN\/OUT.  May be NULL. *\/,\n+                                hb_color_t    *colors        \/* OUT.     May be NULL. *\/)\n+{\n+  return face->table.CPAL->get_palette_colors (palette_index, start_offset, colors_count, colors);\n+}\n+\n+\n+\/*\n+ * COLR\n+ *\/\n+\n+\/**\n+ * hb_ot_color_has_layers:\n+ * @face: a font face.\n+ *\n+ * Returns: whether COLR table is available.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_bool_t\n+hb_ot_color_has_layers (hb_face_t *face)\n+{\n+  return face->table.COLR->has_data ();\n+}\n+\n+\/**\n+ * hb_ot_color_glyph_get_layers:\n+ * @face:         a font face.\n+ * @glyph:        a layered color glyph id.\n+ * @start_offset: starting offset of layers.\n+ * @count:  (inout) (optional): gets number of layers available to be written on buffer\n+ *                              and returns number of written layers.\n+ * @layers: (array length=count) (out) (optional): layers buffer to buffer.\n+ *\n+ * Returns: Total number of layers a layered color glyph have.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+unsigned int\n+hb_ot_color_glyph_get_layers (hb_face_t           *face,\n+                              hb_codepoint_t       glyph,\n+                              unsigned int         start_offset,\n+                              unsigned int        *count, \/* IN\/OUT.  May be NULL. *\/\n+                              hb_ot_color_layer_t *layers \/* OUT.     May be NULL. *\/)\n+{\n+  return face->table.COLR->get_glyph_layers (glyph, start_offset, count, layers);\n+}\n+\n+\n+\/*\n+ * SVG\n+ *\/\n+\n+\/**\n+ * hb_ot_color_has_svg:\n+ * @face: a font face.\n+ *\n+ * Check whether @face has SVG glyph images.\n+ *\n+ * Returns true if available, false otherwise.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_bool_t\n+hb_ot_color_has_svg (hb_face_t *face)\n+{\n+  return face->table.SVG->has_data ();\n+}\n+\n+\/**\n+ * hb_ot_color_glyph_reference_svg:\n+ * @face:  a font face.\n+ * @glyph: a svg glyph index.\n+ *\n+ * Get SVG document for a glyph. The blob may be either plain text or gzip-encoded.\n+ *\n+ * Returns: (transfer full): respective svg blob of the glyph, if available.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_blob_t *\n+hb_ot_color_glyph_reference_svg (hb_face_t *face, hb_codepoint_t glyph)\n+{\n+  return face->table.SVG->reference_blob_for_glyph (glyph);\n+}\n+\n+\n+\/*\n+ * PNG: CBDT or sbix\n+ *\/\n+\n+\/**\n+ * hb_ot_color_has_png:\n+ * @face: a font face.\n+ *\n+ * Check whether @face has PNG glyph images (either CBDT or sbix tables).\n+ *\n+ * Returns true if available, false otherwise.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_bool_t\n+hb_ot_color_has_png (hb_face_t *face)\n+{\n+  return face->table.CBDT->has_data () || face->table.sbix->has_data ();\n+}\n+\n+\/**\n+ * hb_ot_color_glyph_reference_png:\n+ * @font:  a font object, not face. upem should be set on\n+ *         that font object if one wants to get optimal png blob, otherwise\n+ *         return the biggest one\n+ * @glyph: a glyph index.\n+ *\n+ * Get PNG image for a glyph.\n+ *\n+ * Returns: (transfer full): respective PNG blob of the glyph, if available.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+hb_blob_t *\n+hb_ot_color_glyph_reference_png (hb_font_t *font, hb_codepoint_t  glyph)\n+{\n+  hb_blob_t *blob = hb_blob_get_empty ();\n+\n+  if (font->face->table.sbix->has_data ())\n+    blob = font->face->table.sbix->reference_png (font, glyph, nullptr, nullptr, nullptr);\n+\n+  if (!blob->length && font->face->table.CBDT->has_data ())\n+    blob = font->face->table.CBDT->reference_png (font, glyph);\n+\n+  return blob;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-color.cc","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright © 2016  Google, Inc.\n+ * Copyright © 2018  Khaled Hosny\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Sascha Brawer, Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_COLOR_H\n+#define HB_OT_COLOR_H\n+\n+#include \"hb.h\"\n+#include \"hb-ot-name.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/*\n+ * Color palettes.\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_color_has_palettes (hb_face_t *face);\n+\n+HB_EXTERN unsigned int\n+hb_ot_color_palette_get_count (hb_face_t *face);\n+\n+HB_EXTERN hb_ot_name_id_t\n+hb_ot_color_palette_get_name_id (hb_face_t *face,\n+                                 unsigned int palette_index);\n+\n+HB_EXTERN hb_ot_name_id_t\n+hb_ot_color_palette_color_get_name_id (hb_face_t *face,\n+                                       unsigned int color_index);\n+\n+\/**\n+ * hb_ot_color_palette_flags_t:\n+ * @HB_OT_COLOR_PALETTE_FLAG_DEFAULT: default indicating that there is nothing special\n+ *   to note about a color palette.\n+ * @HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_LIGHT_BACKGROUND: flag indicating that the color\n+ *   palette is appropriate to use when displaying the font on a light background such as white.\n+ * @HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_DARK_BACKGROUND: flag indicating that the color\n+ *   palette is appropriate to use when displaying the font on a dark background such as black.\n+ *\n+ * Since: 2.1.0\n+ *\/\n+typedef enum { \/*< flags >*\/\n+  HB_OT_COLOR_PALETTE_FLAG_DEFAULT                      = 0x00000000u,\n+  HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_LIGHT_BACKGROUND = 0x00000001u,\n+  HB_OT_COLOR_PALETTE_FLAG_USABLE_WITH_DARK_BACKGROUND  = 0x00000002u\n+} hb_ot_color_palette_flags_t;\n+\n+HB_EXTERN hb_ot_color_palette_flags_t\n+hb_ot_color_palette_get_flags (hb_face_t *face,\n+                               unsigned int palette_index);\n+\n+HB_EXTERN unsigned int\n+hb_ot_color_palette_get_colors (hb_face_t    *face,\n+                                unsigned int  palette_index,\n+                                unsigned int  start_offset,\n+                                unsigned int *color_count,  \/* IN\/OUT.  May be NULL. *\/\n+                                hb_color_t   *colors        \/* OUT.     May be NULL. *\/);\n+\n+\n+\/*\n+ * Color layers.\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_color_has_layers (hb_face_t *face);\n+\n+\/**\n+ * hb_ot_color_layer_t:\n+ *\n+ * Pairs of glyph and color index.\n+ *\n+ * Since: 2.1.0\n+ **\/\n+typedef struct hb_ot_color_layer_t\n+{\n+  hb_codepoint_t glyph;\n+  unsigned int   color_index;\n+} hb_ot_color_layer_t;\n+\n+HB_EXTERN unsigned int\n+hb_ot_color_glyph_get_layers (hb_face_t           *face,\n+                              hb_codepoint_t       glyph,\n+                              unsigned int         start_offset,\n+                              unsigned int        *count, \/* IN\/OUT.  May be NULL. *\/\n+                              hb_ot_color_layer_t *layers \/* OUT.     May be NULL. *\/);\n+\n+\/*\n+ * SVG\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_color_has_svg (hb_face_t *face);\n+\n+HB_EXTERN hb_blob_t *\n+hb_ot_color_glyph_reference_svg (hb_face_t *face, hb_codepoint_t glyph);\n+\n+\/*\n+ * PNG: CBDT or sbix\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_color_has_png (hb_face_t *face);\n+\n+HB_EXTERN hb_blob_t *\n+hb_ot_color_glyph_reference_png (hb_font_t *font, hb_codepoint_t glyph);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_COLOR_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-color.h","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_DEPRECATED_H\n+#define HB_OT_DEPRECATED_H\n+\n+#include \"hb.h\"\n+#include \"hb-ot-name.h\"\n+\n+\n+HB_BEGIN_DECLS\n+\n+#ifndef HB_DISABLE_DEPRECATED\n+\n+\n+\/* Like hb_ot_layout_table_find_script, but takes zero-terminated array of scripts to test *\/\n+HB_EXTERN HB_DEPRECATED_FOR (hb_ot_layout_table_select_script) hb_bool_t\n+hb_ot_layout_table_choose_script (hb_face_t      *face,\n+                                  hb_tag_t        table_tag,\n+                                  const hb_tag_t *script_tags,\n+                                  unsigned int   *script_index,\n+                                  hb_tag_t       *chosen_script);\n+\n+HB_EXTERN HB_DEPRECATED_FOR (hb_ot_layout_script_select_language) hb_bool_t\n+hb_ot_layout_script_find_language (hb_face_t    *face,\n+                                   hb_tag_t      table_tag,\n+                                   unsigned int  script_index,\n+                                   hb_tag_t      language_tag,\n+                                   unsigned int *language_index);\n+\n+HB_EXTERN HB_DEPRECATED_FOR (hb_ot_tags_from_script_and_language) void\n+hb_ot_tags_from_script (hb_script_t  script,\n+                        hb_tag_t    *script_tag_1,\n+                        hb_tag_t    *script_tag_2);\n+\n+HB_EXTERN HB_DEPRECATED_FOR (hb_ot_tags_from_script_and_language) hb_tag_t\n+hb_ot_tag_from_language (hb_language_t language);\n+\n+\n+\/**\n+ * HB_OT_VAR_NO_AXIS_INDEX:\n+ *\n+ * Since: 1.4.2\n+ * Deprecated: 2.2.0\n+ *\/\n+#define HB_OT_VAR_NO_AXIS_INDEX         0xFFFFFFFFu\n+\n+\/**\n+ * hb_ot_var_axis_t:\n+ *\n+ * Since: 1.4.2\n+ * Deprecated: 2.2.0\n+ *\/\n+typedef struct hb_ot_var_axis_t\n+{\n+  hb_tag_t tag;\n+  hb_ot_name_id_t name_id;\n+  float min_value;\n+  float default_value;\n+  float max_value;\n+} hb_ot_var_axis_t;\n+\n+HB_EXTERN HB_DEPRECATED_FOR (hb_ot_var_get_axis_infos) unsigned int\n+hb_ot_var_get_axes (hb_face_t        *face,\n+                    unsigned int      start_offset,\n+                    unsigned int     *axes_count \/* IN\/OUT *\/,\n+                    hb_ot_var_axis_t *axes_array \/* OUT *\/);\n+\n+HB_EXTERN HB_DEPRECATED_FOR (hb_ot_var_find_axis_info) hb_bool_t\n+hb_ot_var_find_axis (hb_face_t        *face,\n+                     hb_tag_t          axis_tag,\n+                     unsigned int     *axis_index,\n+                     hb_ot_var_axis_t *axis_info);\n+\n+\n+#endif\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_DEPRECATED_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-deprecated.h","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-face.hh\"\n+\n+#include \"hb-ot-cmap-table.hh\"\n+#include \"hb-ot-glyf-table.hh\"\n+#include \"hb-ot-cff1-table.hh\"\n+#include \"hb-ot-cff2-table.hh\"\n+#include \"hb-ot-hmtx-table.hh\"\n+#include \"hb-ot-kern-table.hh\"\n+#include \"hb-ot-name-table.hh\"\n+#include \"hb-ot-post-table.hh\"\n+#include \"hb-ot-color-cbdt-table.hh\"\n+#include \"hb-ot-color-sbix-table.hh\"\n+#include \"hb-ot-color-svg-table.hh\"\n+#include \"hb-ot-layout-gdef-table.hh\"\n+#include \"hb-ot-layout-gsub-table.hh\"\n+#include \"hb-ot-layout-gpos-table.hh\"\n+\n+\n+void hb_ot_face_t::init0 (hb_face_t *face)\n+{\n+  this->face = face;\n+#define HB_OT_TABLE(Namespace, Type) Type.init0 ();\n+#define HB_OT_ACCELERATOR(Namespace, Type) HB_OT_TABLE (Namespace, Type)\n+  HB_OT_TABLES\n+#undef HB_OT_ACCELERATOR\n+#undef HB_OT_TABLE\n+}\n+void hb_ot_face_t::fini ()\n+{\n+#define HB_OT_TABLE(Namespace, Type) Type.fini ();\n+#define HB_OT_ACCELERATOR(Namespace, Type) HB_OT_TABLE (Namespace, Type)\n+  HB_OT_TABLES\n+#undef HB_OT_ACCELERATOR\n+#undef HB_OT_TABLE\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-face.cc","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_FACE_HH\n+#define HB_OT_FACE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-machinery.hh\"\n+\n+\n+\/*\n+ * hb_ot_face_t\n+ *\/\n+\n+#define HB_OT_TABLES \\\n+    \/* OpenType fundamentals. *\/ \\\n+    HB_OT_TABLE(OT, head) \\\n+    HB_OT_ACCELERATOR(OT, cmap) \\\n+    HB_OT_ACCELERATOR(OT, hmtx) \\\n+    HB_OT_ACCELERATOR(OT, vmtx) \\\n+    HB_OT_ACCELERATOR(OT, post) \\\n+    HB_OT_TABLE(OT, kern) \\\n+    HB_OT_ACCELERATOR(OT, glyf) \\\n+    HB_OT_ACCELERATOR(OT, cff1) \\\n+    HB_OT_ACCELERATOR(OT, cff2) \\\n+    HB_OT_TABLE(OT, VORG) \\\n+    HB_OT_ACCELERATOR(OT, name) \\\n+    HB_OT_TABLE(OT, OS2) \\\n+    HB_OT_TABLE(OT, STAT) \\\n+    \/* OpenType shaping. *\/ \\\n+    HB_OT_ACCELERATOR(OT, GDEF) \\\n+    HB_OT_ACCELERATOR(OT, GSUB) \\\n+    HB_OT_ACCELERATOR(OT, GPOS) \\\n+    HB_OT_TABLE(OT, BASE) \\\n+    HB_OT_TABLE(OT, JSTF) \\\n+    \/* AAT shaping. *\/ \\\n+    HB_OT_TABLE(AAT, mort) \\\n+    HB_OT_TABLE(AAT, morx) \\\n+    HB_OT_TABLE(AAT, kerx) \\\n+    HB_OT_TABLE(AAT, ankr) \\\n+    HB_OT_TABLE(AAT, trak) \\\n+    HB_OT_TABLE(AAT, lcar) \\\n+    HB_OT_TABLE(AAT, ltag) \\\n+    HB_OT_TABLE(AAT, feat) \\\n+    \/* OpenType variations. *\/ \\\n+    HB_OT_TABLE(OT, fvar) \\\n+    HB_OT_TABLE(OT, avar) \\\n+    HB_OT_TABLE(OT, MVAR) \\\n+    \/* OpenType math. *\/ \\\n+    HB_OT_TABLE(OT, MATH) \\\n+    \/* OpenType color fonts. *\/ \\\n+    HB_OT_TABLE(OT, COLR) \\\n+    HB_OT_TABLE(OT, CPAL) \\\n+    HB_OT_ACCELERATOR(OT, CBDT) \\\n+    HB_OT_ACCELERATOR(OT, sbix) \\\n+    HB_OT_ACCELERATOR(OT, SVG) \\\n+    \/* *\/\n+\n+\/* Declare tables. *\/\n+#define HB_OT_TABLE(Namespace, Type) namespace Namespace { struct Type; }\n+#define HB_OT_ACCELERATOR(Namespace, Type) HB_OT_TABLE (Namespace, Type##_accelerator_t)\n+HB_OT_TABLES\n+#undef HB_OT_ACCELERATOR\n+#undef HB_OT_TABLE\n+\n+struct hb_ot_face_t\n+{\n+  HB_INTERNAL void init0 (hb_face_t *face);\n+  HB_INTERNAL void fini ();\n+\n+#define HB_OT_TABLE_ORDER(Namespace, Type) \\\n+    HB_PASTE (ORDER_, HB_PASTE (Namespace, HB_PASTE (_, Type)))\n+  enum order_t\n+  {\n+    ORDER_ZERO,\n+#define HB_OT_TABLE(Namespace, Type) HB_OT_TABLE_ORDER (Namespace, Type),\n+#define HB_OT_ACCELERATOR(Namespace, Type) HB_OT_TABLE (Namespace, Type)\n+    HB_OT_TABLES\n+#undef HB_OT_ACCELERATOR\n+#undef HB_OT_TABLE\n+  };\n+\n+  hb_face_t *face; \/* MUST be JUST before the lazy loaders. *\/\n+#define HB_OT_TABLE(Namespace, Type) \\\n+  hb_table_lazy_loader_t<Namespace::Type, HB_OT_TABLE_ORDER (Namespace, Type)> Type;\n+#define HB_OT_ACCELERATOR(Namespace, Type) \\\n+  hb_face_lazy_loader_t<Namespace::Type##_accelerator_t, HB_OT_TABLE_ORDER (Namespace, Type)> Type;\n+  HB_OT_TABLES\n+#undef HB_OT_ACCELERATOR\n+#undef HB_OT_TABLE\n+};\n+\n+\n+#endif \/* HB_OT_FACE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-face.hh","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"},{"patch":"@@ -0,0 +1,313 @@\n+\/*\n+ * Copyright © 2011,2014  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod, Roozbeh Pournader\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot.h\"\n+\n+#include \"hb-font.hh\"\n+#include \"hb-machinery.hh\"\n+#include \"hb-ot-face.hh\"\n+\n+#include \"hb-ot-cmap-table.hh\"\n+#include \"hb-ot-glyf-table.hh\"\n+#include \"hb-ot-cff1-table.hh\"\n+#include \"hb-ot-cff2-table.hh\"\n+#include \"hb-ot-hmtx-table.hh\"\n+#include \"hb-ot-kern-table.hh\"\n+#include \"hb-ot-os2-table.hh\"\n+#include \"hb-ot-post-table.hh\"\n+#include \"hb-ot-stat-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-ot-vorg-table.hh\"\n+#include \"hb-ot-color-cbdt-table.hh\"\n+#include \"hb-ot-color-sbix-table.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-ot-font\n+ * @title: hb-ot-font\n+ * @short_description: OpenType font implementation\n+ * @include: hb-ot.h\n+ *\n+ * Functions for using OpenType fonts with hb_shape().  Not that fonts returned\n+ * by hb_font_create() default to using these functions, so most clients would\n+ * never need to call these functions directly.\n+ **\/\n+\n+\n+static hb_bool_t\n+hb_ot_get_nominal_glyph (hb_font_t *font HB_UNUSED,\n+                         void *font_data,\n+                         hb_codepoint_t unicode,\n+                         hb_codepoint_t *glyph,\n+                         void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  return ot_face->cmap->get_nominal_glyph (unicode, glyph);\n+}\n+\n+static unsigned int\n+hb_ot_get_nominal_glyphs (hb_font_t *font HB_UNUSED,\n+                          void *font_data,\n+                          unsigned int count,\n+                          const hb_codepoint_t *first_unicode,\n+                          unsigned int unicode_stride,\n+                          hb_codepoint_t *first_glyph,\n+                          unsigned int glyph_stride,\n+                          void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  return ot_face->cmap->get_nominal_glyphs (count,\n+                                            first_unicode, unicode_stride,\n+                                            first_glyph, glyph_stride);\n+}\n+\n+static hb_bool_t\n+hb_ot_get_variation_glyph (hb_font_t *font HB_UNUSED,\n+                           void *font_data,\n+                           hb_codepoint_t unicode,\n+                           hb_codepoint_t variation_selector,\n+                           hb_codepoint_t *glyph,\n+                           void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  return ot_face->cmap->get_variation_glyph (unicode, variation_selector, glyph);\n+}\n+\n+static void\n+hb_ot_get_glyph_h_advances (hb_font_t* font, void* font_data,\n+                            unsigned count,\n+                            const hb_codepoint_t *first_glyph,\n+                            unsigned glyph_stride,\n+                            hb_position_t *first_advance,\n+                            unsigned advance_stride,\n+                            void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const OT::hmtx_accelerator_t &hmtx = *ot_face->hmtx;\n+\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    *first_advance = font->em_scale_x (hmtx.get_advance (*first_glyph, font));\n+    first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+    first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+  }\n+}\n+\n+static void\n+hb_ot_get_glyph_v_advances (hb_font_t* font, void* font_data,\n+                            unsigned count,\n+                            const hb_codepoint_t *first_glyph,\n+                            unsigned glyph_stride,\n+                            hb_position_t *first_advance,\n+                            unsigned advance_stride,\n+                            void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n+\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    *first_advance = font->em_scale_y (-(int) vmtx.get_advance (*first_glyph, font));\n+    first_glyph = &StructAtOffsetUnaligned<hb_codepoint_t> (first_glyph, glyph_stride);\n+    first_advance = &StructAtOffsetUnaligned<hb_position_t> (first_advance, advance_stride);\n+  }\n+}\n+\n+static hb_bool_t\n+hb_ot_get_glyph_v_origin (hb_font_t *font,\n+                          void *font_data,\n+                          hb_codepoint_t glyph,\n+                          hb_position_t *x,\n+                          hb_position_t *y,\n+                          void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+\n+  *x = font->get_glyph_h_advance (glyph) \/ 2;\n+\n+  const OT::VORG &VORG = *ot_face->VORG;\n+  if (VORG.has_data ())\n+  {\n+    *y = font->em_scale_y (VORG.get_y_origin (glyph));\n+    return true;\n+  }\n+\n+  hb_glyph_extents_t extents = {0};\n+  if (ot_face->glyf->get_extents (glyph, &extents))\n+  {\n+    const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n+    hb_position_t tsb = vmtx.get_side_bearing (glyph);\n+    *y = font->em_scale_y (extents.y_bearing + tsb);\n+    return true;\n+  }\n+\n+  hb_font_extents_t font_extents;\n+  font->get_h_extents_with_fallback (&font_extents);\n+  *y = font_extents.ascender;\n+\n+  return true;\n+}\n+\n+static hb_bool_t\n+hb_ot_get_glyph_extents (hb_font_t *font,\n+                         void *font_data,\n+                         hb_codepoint_t glyph,\n+                         hb_glyph_extents_t *extents,\n+                         void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  bool ret = ot_face->sbix->get_extents (font, glyph, extents);\n+  if (!ret)\n+    ret = ot_face->glyf->get_extents (glyph, extents);\n+  if (!ret)\n+    ret = ot_face->cff1->get_extents (glyph, extents);\n+  if (!ret)\n+    ret = ot_face->cff2->get_extents (font, glyph, extents);\n+  if (!ret)\n+    ret = ot_face->CBDT->get_extents (font, glyph, extents);\n+  \/\/ TODO Hook up side-bearings variations.\n+  extents->x_bearing = font->em_scale_x (extents->x_bearing);\n+  extents->y_bearing = font->em_scale_y (extents->y_bearing);\n+  extents->width     = font->em_scale_x (extents->width);\n+  extents->height    = font->em_scale_y (extents->height);\n+  return ret;\n+}\n+\n+static hb_bool_t\n+hb_ot_get_glyph_name (hb_font_t *font HB_UNUSED,\n+                      void *font_data,\n+                      hb_codepoint_t glyph,\n+                      char *name, unsigned int size,\n+                      void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  return ot_face->post->get_glyph_name (glyph, name, size);\n+}\n+\n+static hb_bool_t\n+hb_ot_get_glyph_from_name (hb_font_t *font HB_UNUSED,\n+                           void *font_data,\n+                           const char *name, int len,\n+                           hb_codepoint_t *glyph,\n+                           void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  return ot_face->post->get_glyph_from_name (name, len, glyph);\n+}\n+\n+static hb_bool_t\n+hb_ot_get_font_h_extents (hb_font_t *font,\n+                          void *font_data,\n+                          hb_font_extents_t *metrics,\n+                          void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const OT::hmtx_accelerator_t &hmtx = *ot_face->hmtx;\n+  metrics->ascender = font->em_scale_y (hmtx.ascender);\n+  metrics->descender = font->em_scale_y (hmtx.descender);\n+  metrics->line_gap = font->em_scale_y (hmtx.line_gap);\n+  \/\/ TODO Hook up variations.\n+  return hmtx.has_font_extents;\n+}\n+\n+static hb_bool_t\n+hb_ot_get_font_v_extents (hb_font_t *font,\n+                          void *font_data,\n+                          hb_font_extents_t *metrics,\n+                          void *user_data HB_UNUSED)\n+{\n+  const hb_ot_face_t *ot_face = (const hb_ot_face_t *) font_data;\n+  const OT::vmtx_accelerator_t &vmtx = *ot_face->vmtx;\n+  metrics->ascender = font->em_scale_x (vmtx.ascender);\n+  metrics->descender = font->em_scale_x (vmtx.descender);\n+  metrics->line_gap = font->em_scale_x (vmtx.line_gap);\n+  \/\/ TODO Hook up variations.\n+  return vmtx.has_font_extents;\n+}\n+\n+#if HB_USE_ATEXIT\n+static void free_static_ot_funcs ();\n+#endif\n+\n+static struct hb_ot_font_funcs_lazy_loader_t : hb_font_funcs_lazy_loader_t<hb_ot_font_funcs_lazy_loader_t>\n+{\n+  static hb_font_funcs_t *create ()\n+  {\n+    hb_font_funcs_t *funcs = hb_font_funcs_create ();\n+\n+    hb_font_funcs_set_font_h_extents_func (funcs, hb_ot_get_font_h_extents, nullptr, nullptr);\n+    hb_font_funcs_set_font_v_extents_func (funcs, hb_ot_get_font_v_extents, nullptr, nullptr);\n+    hb_font_funcs_set_nominal_glyph_func (funcs, hb_ot_get_nominal_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_nominal_glyphs_func (funcs, hb_ot_get_nominal_glyphs, nullptr, nullptr);\n+    hb_font_funcs_set_variation_glyph_func (funcs, hb_ot_get_variation_glyph, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_h_advances_func (funcs, hb_ot_get_glyph_h_advances, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_v_advances_func (funcs, hb_ot_get_glyph_v_advances, nullptr, nullptr);\n+    \/\/hb_font_funcs_set_glyph_h_origin_func (funcs, hb_ot_get_glyph_h_origin, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_v_origin_func (funcs, hb_ot_get_glyph_v_origin, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_extents_func (funcs, hb_ot_get_glyph_extents, nullptr, nullptr);\n+    \/\/hb_font_funcs_set_glyph_contour_point_func (funcs, hb_ot_get_glyph_contour_point, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_name_func (funcs, hb_ot_get_glyph_name, nullptr, nullptr);\n+    hb_font_funcs_set_glyph_from_name_func (funcs, hb_ot_get_glyph_from_name, nullptr, nullptr);\n+\n+    hb_font_funcs_make_immutable (funcs);\n+\n+#if HB_USE_ATEXIT\n+    atexit (free_static_ot_funcs);\n+#endif\n+\n+    return funcs;\n+  }\n+} static_ot_funcs;\n+\n+#if HB_USE_ATEXIT\n+static\n+void free_static_ot_funcs ()\n+{\n+  static_ot_funcs.free_instance ();\n+}\n+#endif\n+\n+static hb_font_funcs_t *\n+_hb_ot_get_font_funcs ()\n+{\n+  return static_ot_funcs.get_unconst ();\n+}\n+\n+\n+\/**\n+ * hb_ot_font_set_funcs:\n+ *\n+ * Since: 0.9.28\n+ **\/\n+void\n+hb_ot_font_set_funcs (hb_font_t *font)\n+{\n+  hb_font_set_funcs (font,\n+                     _hb_ot_get_font_funcs (),\n+                     &font->face->table,\n+                     nullptr);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-font.cc","additions":313,"deletions":0,"binary":false,"changes":313,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright © 2014  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod, Roozbeh Pournader\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_FONT_H\n+#define HB_OT_FONT_H\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+HB_EXTERN void\n+hb_ot_font_set_funcs (hb_font_t *font);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_FONT_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-font.h","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-gasp-table.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-gasp-table.hh","status":"copied"},{"patch":"@@ -0,0 +1,482 @@\n+\/*\n+ * Copyright © 2015  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_GLYF_TABLE_HH\n+#define HB_OT_GLYF_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-head-table.hh\"\n+#include \"hb-subset-glyf.hh\"\n+\n+namespace OT {\n+\n+\n+\/*\n+ * loca -- Index to Location\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/loca\n+ *\/\n+#define HB_OT_TAG_loca HB_TAG('l','o','c','a')\n+\n+\n+struct loca\n+{\n+  friend struct glyf;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_loca;\n+\n+  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (true);\n+  }\n+\n+  protected:\n+  UnsizedArrayOf<HBUINT8>       dataZ;          \/* Location data. *\/\n+  public:\n+  DEFINE_SIZE_MIN (0); \/* In reality, this is UNBOUNDED() type; but since we always\n+                        * check the size externally, allow Null() object of it by\n+                        * defining it MIN() instead. *\/\n+};\n+\n+\n+\/*\n+ * glyf -- TrueType Glyph Data\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/glyf\n+ *\/\n+#define HB_OT_TAG_glyf HB_TAG('g','l','y','f')\n+\n+\n+struct glyf\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_glyf;\n+\n+  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* We don't check for anything specific here.  The users of the\n+     * struct do all the hard work... *\/\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    hb_blob_t *glyf_prime = nullptr;\n+    hb_blob_t *loca_prime = nullptr;\n+\n+    bool success = true;\n+    bool use_short_loca = false;\n+    if (hb_subset_glyf_and_loca (plan, &use_short_loca, &glyf_prime, &loca_prime)) {\n+      success = success && plan->add_table (HB_OT_TAG_glyf, glyf_prime);\n+      success = success && plan->add_table (HB_OT_TAG_loca, loca_prime);\n+      success = success && _add_head_and_set_loca_version (plan, use_short_loca);\n+    } else {\n+      success = false;\n+    }\n+    hb_blob_destroy (loca_prime);\n+    hb_blob_destroy (glyf_prime);\n+\n+    return success;\n+  }\n+\n+  static bool\n+  _add_head_and_set_loca_version (hb_subset_plan_t *plan, bool use_short_loca)\n+  {\n+    hb_blob_t *head_blob = hb_sanitize_context_t ().reference_table<head> (plan->source);\n+    hb_blob_t *head_prime_blob = hb_blob_copy_writable_or_fail (head_blob);\n+    hb_blob_destroy (head_blob);\n+\n+    if (unlikely (!head_prime_blob))\n+      return false;\n+\n+    head *head_prime = (head *) hb_blob_get_data_writable (head_prime_blob, nullptr);\n+    head_prime->indexToLocFormat.set (use_short_loca ? 0 : 1);\n+    bool success = plan->add_table (HB_OT_TAG_head, head_prime_blob);\n+\n+    hb_blob_destroy (head_prime_blob);\n+    return success;\n+  }\n+\n+  struct GlyphHeader\n+  {\n+    HBINT16             numberOfContours;       \/* If the number of contours is\n+                                                 * greater than or equal to zero,\n+                                                 * this is a simple glyph; if negative,\n+                                                 * this is a composite glyph. *\/\n+    FWORD               xMin;                   \/* Minimum x for coordinate data. *\/\n+    FWORD               yMin;                   \/* Minimum y for coordinate data. *\/\n+    FWORD               xMax;                   \/* Maximum x for coordinate data. *\/\n+    FWORD               yMax;                   \/* Maximum y for coordinate data. *\/\n+\n+    DEFINE_SIZE_STATIC (10);\n+  };\n+\n+  struct CompositeGlyphHeader\n+  {\n+    enum composite_glyph_flag_t {\n+      ARG_1_AND_2_ARE_WORDS =      0x0001,\n+      ARGS_ARE_XY_VALUES =         0x0002,\n+      ROUND_XY_TO_GRID =           0x0004,\n+      WE_HAVE_A_SCALE =            0x0008,\n+      MORE_COMPONENTS =            0x0020,\n+      WE_HAVE_AN_X_AND_Y_SCALE =   0x0040,\n+      WE_HAVE_A_TWO_BY_TWO =       0x0080,\n+      WE_HAVE_INSTRUCTIONS =       0x0100,\n+      USE_MY_METRICS =             0x0200,\n+      OVERLAP_COMPOUND =           0x0400,\n+      SCALED_COMPONENT_OFFSET =    0x0800,\n+      UNSCALED_COMPONENT_OFFSET =  0x1000\n+    };\n+\n+    HBUINT16 flags;\n+    GlyphID  glyphIndex;\n+\n+    unsigned int get_size () const\n+    {\n+      unsigned int size = min_size;\n+      \/\/ arg1 and 2 are int16\n+      if (flags & ARG_1_AND_2_ARE_WORDS) size += 4;\n+      \/\/ arg1 and 2 are int8\n+      else size += 2;\n+\n+      \/\/ One x 16 bit (scale)\n+      if (flags & WE_HAVE_A_SCALE) size += 2;\n+      \/\/ Two x 16 bit (xscale, yscale)\n+      else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) size += 4;\n+      \/\/ Four x 16 bit (xscale, scale01, scale10, yscale)\n+      else if (flags & WE_HAVE_A_TWO_BY_TWO) size += 8;\n+\n+      return size;\n+    }\n+\n+    struct Iterator\n+    {\n+      const char *glyph_start;\n+      const char *glyph_end;\n+      const CompositeGlyphHeader *current;\n+\n+      bool move_to_next ()\n+      {\n+        if (current->flags & CompositeGlyphHeader::MORE_COMPONENTS)\n+        {\n+          const CompositeGlyphHeader *possible =\n+            &StructAfter<CompositeGlyphHeader, CompositeGlyphHeader> (*current);\n+          if (!in_range (possible))\n+            return false;\n+          current = possible;\n+          return true;\n+        }\n+        return false;\n+      }\n+\n+      bool in_range (const CompositeGlyphHeader *composite) const\n+      {\n+        return (const char *) composite >= glyph_start\n+          && ((const char *) composite + CompositeGlyphHeader::min_size) <= glyph_end\n+          && ((const char *) composite + composite->get_size ()) <= glyph_end;\n+      }\n+    };\n+\n+    static bool get_iterator (const char * glyph_data,\n+                              unsigned int length,\n+                              CompositeGlyphHeader::Iterator *iterator \/* OUT *\/)\n+    {\n+      if (length < GlyphHeader::static_size)\n+        return false; \/* Empty glyph; zero extents. *\/\n+\n+      const GlyphHeader &glyph_header = StructAtOffset<GlyphHeader> (glyph_data, 0);\n+      if (glyph_header.numberOfContours < 0)\n+      {\n+        const CompositeGlyphHeader *possible =\n+          &StructAfter<CompositeGlyphHeader, GlyphHeader> (glyph_header);\n+\n+        iterator->glyph_start = glyph_data;\n+        iterator->glyph_end = (const char *) glyph_data + length;\n+        if (!iterator->in_range (possible))\n+          return false;\n+        iterator->current = possible;\n+        return true;\n+      }\n+\n+      return false;\n+    }\n+\n+    DEFINE_SIZE_MIN (4);\n+  };\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      memset (this, 0, sizeof (accelerator_t));\n+\n+      const OT::head &head = *face->table.head;\n+      if (head.indexToLocFormat > 1 || head.glyphDataFormat != 0)\n+        \/* Unknown format.  Leave num_glyphs=0, that takes care of disabling us. *\/\n+        return;\n+      short_offset = 0 == head.indexToLocFormat;\n+\n+      loca_table = hb_sanitize_context_t ().reference_table<loca> (face);\n+      glyf_table = hb_sanitize_context_t ().reference_table<glyf> (face);\n+\n+      num_glyphs = MAX (1u, loca_table.get_length () \/ (short_offset ? 2 : 4)) - 1;\n+    }\n+\n+    void fini ()\n+    {\n+      loca_table.destroy ();\n+      glyf_table.destroy ();\n+    }\n+\n+    \/*\n+     * Returns true if the referenced glyph is a valid glyph and a composite glyph.\n+     * If true is returned a pointer to the composite glyph will be written into\n+     * composite.\n+     *\/\n+    bool get_composite (hb_codepoint_t glyph,\n+                        CompositeGlyphHeader::Iterator *composite \/* OUT *\/) const\n+    {\n+      if (unlikely (!num_glyphs))\n+        return false;\n+\n+      unsigned int start_offset, end_offset;\n+      if (!get_offsets (glyph, &start_offset, &end_offset))\n+        return false; \/* glyph not found *\/\n+\n+      return CompositeGlyphHeader::get_iterator ((const char *) this->glyf_table + start_offset,\n+                                                 end_offset - start_offset,\n+                                                 composite);\n+    }\n+\n+    enum simple_glyph_flag_t {\n+      FLAG_ON_CURVE = 0x01,\n+      FLAG_X_SHORT = 0x02,\n+      FLAG_Y_SHORT = 0x04,\n+      FLAG_REPEAT = 0x08,\n+      FLAG_X_SAME = 0x10,\n+      FLAG_Y_SAME = 0x20,\n+      FLAG_RESERVED1 = 0x40,\n+      FLAG_RESERVED2 = 0x80\n+    };\n+\n+    \/* based on FontTools _g_l_y_f.py::trim *\/\n+    bool remove_padding (unsigned int start_offset,\n+                                unsigned int *end_offset) const\n+    {\n+      if (*end_offset - start_offset < GlyphHeader::static_size) return true;\n+\n+      const char *glyph = ((const char *) glyf_table) + start_offset;\n+      const char * const glyph_end = glyph + (*end_offset - start_offset);\n+      const GlyphHeader &glyph_header = StructAtOffset<GlyphHeader> (glyph, 0);\n+      int16_t num_contours = (int16_t) glyph_header.numberOfContours;\n+\n+      if (num_contours < 0)\n+        \/* Trimming for composites not implemented.\n+         * If removing hints it falls out of that. *\/\n+        return true;\n+      else if (num_contours > 0)\n+      {\n+        \/* simple glyph w\/contours, possibly trimmable *\/\n+        glyph += GlyphHeader::static_size + 2 * num_contours;\n+\n+        if (unlikely (glyph + 2 >= glyph_end)) return false;\n+        uint16_t nCoordinates = (uint16_t) StructAtOffset<HBUINT16> (glyph - 2, 0) + 1;\n+        uint16_t nInstructions = (uint16_t) StructAtOffset<HBUINT16> (glyph, 0);\n+\n+        glyph += 2 + nInstructions;\n+        if (unlikely (glyph + 2 >= glyph_end)) return false;\n+\n+        unsigned int coordBytes = 0;\n+        unsigned int coordsWithFlags = 0;\n+        while (glyph < glyph_end)\n+        {\n+          uint8_t flag = (uint8_t) *glyph;\n+          glyph++;\n+\n+          unsigned int repeat = 1;\n+          if (flag & FLAG_REPEAT)\n+          {\n+            if (glyph >= glyph_end)\n+            {\n+              DEBUG_MSG(SUBSET, nullptr, \"Bad flag\");\n+              return false;\n+            }\n+            repeat = ((uint8_t) *glyph) + 1;\n+            glyph++;\n+          }\n+\n+          unsigned int xBytes, yBytes;\n+          xBytes = yBytes = 0;\n+          if (flag & FLAG_X_SHORT) xBytes = 1;\n+          else if ((flag & FLAG_X_SAME) == 0) xBytes = 2;\n+\n+          if (flag & FLAG_Y_SHORT) yBytes = 1;\n+          else if ((flag & FLAG_Y_SAME) == 0) yBytes = 2;\n+\n+          coordBytes += (xBytes + yBytes) * repeat;\n+          coordsWithFlags += repeat;\n+          if (coordsWithFlags >= nCoordinates)\n+            break;\n+        }\n+\n+        if (coordsWithFlags != nCoordinates)\n+        {\n+          DEBUG_MSG(SUBSET, nullptr, \"Expect %d coords to have flags, got flags for %d\", nCoordinates, coordsWithFlags);\n+          return false;\n+        }\n+        glyph += coordBytes;\n+\n+        if (glyph < glyph_end)\n+          *end_offset -= glyph_end - glyph;\n+      }\n+      return true;\n+    }\n+\n+    bool get_offsets (hb_codepoint_t  glyph,\n+                      unsigned int   *start_offset \/* OUT *\/,\n+                      unsigned int   *end_offset   \/* OUT *\/) const\n+    {\n+      if (unlikely (glyph >= num_glyphs))\n+        return false;\n+\n+      if (short_offset)\n+      {\n+        const HBUINT16 *offsets = (const HBUINT16 *) loca_table->dataZ.arrayZ;\n+        *start_offset = 2 * offsets[glyph];\n+        *end_offset   = 2 * offsets[glyph + 1];\n+      }\n+      else\n+      {\n+        const HBUINT32 *offsets = (const HBUINT32 *) loca_table->dataZ.arrayZ;\n+\n+        *start_offset = offsets[glyph];\n+        *end_offset   = offsets[glyph + 1];\n+      }\n+\n+      if (*start_offset > *end_offset || *end_offset > glyf_table.get_length ())\n+        return false;\n+\n+      return true;\n+    }\n+\n+    bool get_instruction_offsets (unsigned int start_offset,\n+                                  unsigned int end_offset,\n+                                  unsigned int *instruction_start \/* OUT *\/,\n+                                  unsigned int *instruction_end \/* OUT *\/) const\n+    {\n+      if (end_offset - start_offset < GlyphHeader::static_size)\n+      {\n+        *instruction_start = 0;\n+        *instruction_end = 0;\n+        return true; \/* Empty glyph; no instructions. *\/\n+      }\n+      const GlyphHeader &glyph_header = StructAtOffset<GlyphHeader> (glyf_table, start_offset);\n+      int16_t num_contours = (int16_t) glyph_header.numberOfContours;\n+      if (num_contours < 0)\n+      {\n+        CompositeGlyphHeader::Iterator composite_it;\n+        if (unlikely (!CompositeGlyphHeader::get_iterator (\n+            (const char*) this->glyf_table + start_offset,\n+             end_offset - start_offset, &composite_it))) return false;\n+        const CompositeGlyphHeader *last;\n+        do {\n+          last = composite_it.current;\n+        } while (composite_it.move_to_next ());\n+\n+        if ((uint16_t) last->flags & CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS)\n+          *instruction_start = ((char *) last - (char *) glyf_table->dataZ.arrayZ) + last->get_size ();\n+        else\n+          *instruction_start = end_offset;\n+        *instruction_end = end_offset;\n+        if (unlikely (*instruction_start > *instruction_end))\n+        {\n+          DEBUG_MSG(SUBSET, nullptr, \"Invalid instruction offset, %d is outside [%d, %d]\", *instruction_start, start_offset, end_offset);\n+          return false;\n+        }\n+      }\n+      else\n+      {\n+        unsigned int instruction_length_offset = start_offset + GlyphHeader::static_size + 2 * num_contours;\n+        if (unlikely (instruction_length_offset + 2 > end_offset))\n+        {\n+          DEBUG_MSG(SUBSET, nullptr, \"Glyph size is too short, missing field instructionLength.\");\n+          return false;\n+        }\n+\n+        const HBUINT16 &instruction_length = StructAtOffset<HBUINT16> (glyf_table, instruction_length_offset);\n+        unsigned int start = instruction_length_offset + 2;\n+        unsigned int end = start + (uint16_t) instruction_length;\n+        if (unlikely (end > end_offset)) \/\/ Out of bounds of the current glyph\n+        {\n+          DEBUG_MSG(SUBSET, nullptr, \"The instructions array overruns the glyph's boundaries.\");\n+          return false;\n+        }\n+\n+        *instruction_start = start;\n+        *instruction_end = end;\n+      }\n+      return true;\n+    }\n+\n+    bool get_extents (hb_codepoint_t glyph, hb_glyph_extents_t *extents) const\n+    {\n+      unsigned int start_offset, end_offset;\n+      if (!get_offsets (glyph, &start_offset, &end_offset))\n+        return false;\n+\n+      if (end_offset - start_offset < GlyphHeader::static_size)\n+        return true; \/* Empty glyph; zero extents. *\/\n+\n+      const GlyphHeader &glyph_header = StructAtOffset<GlyphHeader> (glyf_table, start_offset);\n+\n+      extents->x_bearing = MIN (glyph_header.xMin, glyph_header.xMax);\n+      extents->y_bearing = MAX (glyph_header.yMin, glyph_header.yMax);\n+      extents->width     = MAX (glyph_header.xMin, glyph_header.xMax) - extents->x_bearing;\n+      extents->height    = MIN (glyph_header.yMin, glyph_header.yMax) - extents->y_bearing;\n+\n+      return true;\n+    }\n+\n+    private:\n+    bool short_offset;\n+    unsigned int num_glyphs;\n+    hb_blob_ptr_t<loca> loca_table;\n+    hb_blob_ptr_t<glyf> glyf_table;\n+  };\n+\n+  protected:\n+  UnsizedArrayOf<HBUINT8>       dataZ;          \/* Glyphs data. *\/\n+  public:\n+  DEFINE_SIZE_MIN (0); \/* In reality, this is UNBOUNDED() type; but since we always\n+                        * check the size externally, allow Null() object of it by\n+                        * defining it MIN() instead. *\/\n+};\n+\n+struct glyf_accelerator_t : glyf::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_GLYF_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-glyf-table.hh","additions":482,"deletions":0,"binary":false,"changes":482,"status":"added"},{"patch":"@@ -0,0 +1,214 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef HB_OT_HDMX_TABLE_HH\n+#define HB_OT_HDMX_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * hdmx -- Horizontal Device Metrics\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/hdmx\n+ *\/\n+#define HB_OT_TAG_hdmx HB_TAG('h','d','m','x')\n+\n+\n+namespace OT {\n+\n+\n+struct DeviceRecord\n+{\n+  struct SubsetView\n+  {\n+    const DeviceRecord *source_device_record;\n+    unsigned int sizeDeviceRecord;\n+    hb_subset_plan_t *subset_plan;\n+\n+    void init (const DeviceRecord *source_device_record,\n+               unsigned int sizeDeviceRecord,\n+               hb_subset_plan_t   *subset_plan)\n+    {\n+      this->source_device_record = source_device_record;\n+      this->sizeDeviceRecord = sizeDeviceRecord;\n+      this->subset_plan = subset_plan;\n+    }\n+\n+    unsigned int len () const\n+    { return this->subset_plan->glyphs.length; }\n+\n+    const HBUINT8* operator [] (unsigned int i) const\n+    {\n+      if (unlikely (i >= len ())) return nullptr;\n+      hb_codepoint_t gid = this->subset_plan->glyphs [i];\n+\n+      if (gid >= sizeDeviceRecord - DeviceRecord::min_size)\n+        return nullptr;\n+      return &(this->source_device_record->widthsZ[gid]);\n+    }\n+  };\n+\n+  static unsigned int get_size (unsigned int count)\n+  { return hb_ceil_to_4 (min_size + count * HBUINT8::static_size); }\n+\n+  bool serialize (hb_serialize_context_t *c, const SubsetView &subset_view)\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    unsigned int size = get_size (subset_view.len ());\n+    if (unlikely (!c->allocate_size<DeviceRecord> (size)))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"Couldn't allocate enough space for DeviceRecord: %d.\",\n+                 size);\n+      return_trace (false);\n+    }\n+\n+    this->pixelSize.set (subset_view.source_device_record->pixelSize);\n+    this->maxWidth.set (subset_view.source_device_record->maxWidth);\n+\n+    for (unsigned int i = 0; i < subset_view.len (); i++)\n+    {\n+      const HBUINT8 *width = subset_view[i];\n+      if (!width)\n+      {\n+        DEBUG_MSG(SUBSET, nullptr, \"HDMX width for new gid %d is missing.\", i);\n+        return_trace (false);\n+      }\n+      widthsZ[i].set (*width);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int sizeDeviceRecord) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          c->check_range (this, sizeDeviceRecord)));\n+  }\n+\n+  HBUINT8                       pixelSize;      \/* Pixel size for following widths (as ppem). *\/\n+  HBUINT8                       maxWidth;       \/* Maximum width. *\/\n+  UnsizedArrayOf<HBUINT8>       widthsZ;        \/* Array of widths (numGlyphs is from the 'maxp' table). *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, widthsZ);\n+};\n+\n+\n+struct hdmx\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_hdmx;\n+\n+  unsigned int get_size () const\n+  { return min_size + numRecords * sizeDeviceRecord; }\n+\n+  const DeviceRecord& operator [] (unsigned int i) const\n+  {\n+    \/* XXX Null(DeviceRecord) is NOT safe as it's num-glyphs lengthed.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1300 *\/\n+    if (unlikely (i >= numRecords)) return Null (DeviceRecord);\n+    return StructAtOffset<DeviceRecord> (&this->firstDeviceRecord, i * sizeDeviceRecord);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c, const hdmx *source_hdmx, hb_subset_plan_t *plan)\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (unlikely (!c->extend_min ((*this))))  return_trace (false);\n+\n+    this->version.set (source_hdmx->version);\n+    this->numRecords.set (source_hdmx->numRecords);\n+    this->sizeDeviceRecord.set (DeviceRecord::get_size (plan->glyphs.length));\n+\n+    for (unsigned int i = 0; i < source_hdmx->numRecords; i++)\n+    {\n+      DeviceRecord::SubsetView subset_view;\n+      subset_view.init (&(*source_hdmx)[i], source_hdmx->sizeDeviceRecord, plan);\n+\n+      if (!c->start_embed<DeviceRecord> ()->serialize (c, subset_view))\n+        return_trace (false);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  static size_t get_subsetted_size (const hdmx *source_hdmx, hb_subset_plan_t *plan)\n+  {\n+    return min_size + source_hdmx->numRecords * DeviceRecord::get_size (plan->glyphs.length);\n+  }\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    size_t dest_size = get_subsetted_size (this, plan);\n+    hdmx *dest = (hdmx *) malloc (dest_size);\n+    if (unlikely (!dest))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"Unable to alloc %lu for hdmx subset output.\", (unsigned long) dest_size);\n+      return false;\n+    }\n+\n+    hb_serialize_context_t c (dest, dest_size);\n+    hdmx *hdmx_prime = c.start_serialize<hdmx> ();\n+    if (!hdmx_prime || !hdmx_prime->serialize (&c, this, plan))\n+    {\n+      free (dest);\n+      DEBUG_MSG(SUBSET, nullptr, \"Failed to serialize write new hdmx.\");\n+      return false;\n+    }\n+    c.end_serialize ();\n+\n+    hb_blob_t *hdmx_prime_blob = hb_blob_create ((const char *) dest,\n+                                                 dest_size,\n+                                                 HB_MEMORY_MODE_READONLY,\n+                                                 dest,\n+                                                 free);\n+    bool result = plan->add_table (HB_OT_TAG_hdmx, hdmx_prime_blob);\n+    hb_blob_destroy (hdmx_prime_blob);\n+\n+    return result;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  !hb_unsigned_mul_overflows (numRecords, sizeDeviceRecord) &&\n+                  sizeDeviceRecord >= DeviceRecord::min_size &&\n+                  c->check_range (this, get_size ()));\n+  }\n+\n+  protected:\n+  HBUINT16              version;                \/* Table version number (0) *\/\n+  HBUINT16              numRecords;             \/* Number of device records. *\/\n+  HBUINT32              sizeDeviceRecord;       \/* Size of a device record, 32-bit aligned. *\/\n+  DeviceRecord          firstDeviceRecord;      \/* Array of device records. *\/\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_HDMX_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-hdmx-table.hh","additions":214,"deletions":0,"binary":false,"changes":214,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright © 2010  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_HEAD_TABLE_HH\n+#define HB_OT_HEAD_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * head -- Font Header\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/head\n+ *\/\n+#define HB_OT_TAG_head HB_TAG('h','e','a','d')\n+\n+\n+namespace OT {\n+\n+\n+struct head\n+{\n+  friend struct OffsetTable;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_head;\n+\n+  unsigned int get_upem () const\n+  {\n+    unsigned int upem = unitsPerEm;\n+    \/* If no valid head table found, assume 1000, which matches typical Type1 usage. *\/\n+    return 16 <= upem && upem <= 16384 ? upem : 1000;\n+  }\n+\n+  enum mac_style_flag_t {\n+    BOLD        = 1u<<0,\n+    ITALIC      = 1u<<1,\n+    UNDERLINE   = 1u<<2,\n+    OUTLINE     = 1u<<3,\n+    SHADOW      = 1u<<4,\n+    CONDENSED   = 1u<<5\n+  };\n+\n+  bool is_bold () const      { return macStyle & BOLD; }\n+  bool is_italic () const    { return macStyle & ITALIC; }\n+  bool is_condensed () const { return macStyle & CONDENSED; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  version.major == 1 &&\n+                  magicNumber == 0x5F0F3CF5u);\n+  }\n+\n+  protected:\n+  FixedVersion<>version;                \/* Version of the head table--currently\n+                                         * 0x00010000u for version 1.0. *\/\n+  FixedVersion<>fontRevision;           \/* Set by font manufacturer. *\/\n+  HBUINT32      checkSumAdjustment;     \/* To compute: set it to 0, sum the\n+                                         * entire font as HBUINT32, then store\n+                                         * 0xB1B0AFBAu - sum. *\/\n+  HBUINT32      magicNumber;            \/* Set to 0x5F0F3CF5u. *\/\n+  HBUINT16      flags;                  \/* Bit 0: Baseline for font at y=0;\n+                                         * Bit 1: Left sidebearing point at x=0;\n+                                         * Bit 2: Instructions may depend on point size;\n+                                         * Bit 3: Force ppem to integer values for all\n+                                         *   internal scaler math; may use fractional\n+                                         *   ppem sizes if this bit is clear;\n+                                         * Bit 4: Instructions may alter advance width\n+                                         *   (the advance widths might not scale linearly);\n+                                         * Bits 5-10: These should be set according to\n+                                         *   Apple's specification. However, they are not\n+                                         *   implemented in OpenType.\n+                                         * Bit 5: This bit should be set in fonts that are\n+                                         *   intended to e laid out vertically, and in\n+                                         *   which the glyphs have been drawn such that an\n+                                         *   x-coordinate of 0 corresponds to the desired\n+                                         *   vertical baseline.\n+                                         * Bit 6: This bit must be set to zero.\n+                                         * Bit 7: This bit should be set if the font\n+                                         *   requires layout for correct linguistic\n+                                         *   rendering (e.g. Arabic fonts).\n+                                         * Bit 8: This bit should be set for a GX font\n+                                         *   which has one or more metamorphosis effects\n+                                         *   designated as happening by default.\n+                                         * Bit 9: This bit should be set if the font\n+                                         *   contains any strong right-to-left glyphs.\n+                                         * Bit 10: This bit should be set if the font\n+                                         *   contains Indic-style rearrangement effects.\n+                                         * Bit 11: Font data is 'lossless,' as a result\n+                                         *   of having been compressed and decompressed\n+                                         *   with the Agfa MicroType Express engine.\n+                                         * Bit 12: Font converted (produce compatible metrics)\n+                                         * Bit 13: Font optimized for ClearType™.\n+                                         *   Note, fonts that rely on embedded bitmaps (EBDT)\n+                                         *   for rendering should not be considered optimized\n+                                         *   for ClearType, and therefore should keep this bit\n+                                         *   cleared.\n+                                         * Bit 14: Last Resort font. If set, indicates that\n+                                         * the glyphs encoded in the cmap subtables are simply\n+                                         * generic symbolic representations of code point\n+                                         * ranges and don’t truly represent support for those\n+                                         * code points. If unset, indicates that the glyphs\n+                                         * encoded in the cmap subtables represent proper\n+                                         * support for those code points.\n+                                         * Bit 15: Reserved, set to 0. *\/\n+  HBUINT16      unitsPerEm;             \/* Valid range is from 16 to 16384. This value\n+                                         * should be a power of 2 for fonts that have\n+                                         * TrueType outlines. *\/\n+  LONGDATETIME  created;                \/* Number of seconds since 12:00 midnight,\n+                                           January 1, 1904. 64-bit integer *\/\n+  LONGDATETIME  modified;               \/* Number of seconds since 12:00 midnight,\n+                                           January 1, 1904. 64-bit integer *\/\n+  HBINT16       xMin;                   \/* For all glyph bounding boxes. *\/\n+  HBINT16       yMin;                   \/* For all glyph bounding boxes. *\/\n+  HBINT16       xMax;                   \/* For all glyph bounding boxes. *\/\n+  HBINT16       yMax;                   \/* For all glyph bounding boxes. *\/\n+  HBUINT16      macStyle;               \/* Bit 0: Bold (if set to 1);\n+                                         * Bit 1: Italic (if set to 1)\n+                                         * Bit 2: Underline (if set to 1)\n+                                         * Bit 3: Outline (if set to 1)\n+                                         * Bit 4: Shadow (if set to 1)\n+                                         * Bit 5: Condensed (if set to 1)\n+                                         * Bit 6: Extended (if set to 1)\n+                                         * Bits 7-15: Reserved (set to 0). *\/\n+  HBUINT16      lowestRecPPEM;          \/* Smallest readable size in pixels. *\/\n+  HBINT16       fontDirectionHint;      \/* Deprecated (Set to 2).\n+                                         * 0: Fully mixed directional glyphs;\n+                                         * 1: Only strongly left to right;\n+                                         * 2: Like 1 but also contains neutrals;\n+                                         * -1: Only strongly right to left;\n+                                         * -2: Like -1 but also contains neutrals. *\/\n+  public:\n+  HBUINT16      indexToLocFormat;       \/* 0 for short offsets, 1 for long. *\/\n+  HBUINT16      glyphDataFormat;        \/* 0 for current format. *\/\n+\n+  DEFINE_SIZE_STATIC (54);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_HEAD_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-head-table.hh","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_HHEA_TABLE_HH\n+#define HB_OT_HHEA_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * hhea -- Horizontal Header\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/hhea\n+ * vhea -- Vertical Header\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/vhea\n+ *\/\n+#define HB_OT_TAG_hhea HB_TAG('h','h','e','a')\n+#define HB_OT_TAG_vhea HB_TAG('v','h','e','a')\n+\n+\n+namespace OT {\n+\n+\n+template <typename T>\n+struct _hea\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && likely (version.major == 1));\n+  }\n+\n+  public:\n+  FixedVersion<>version;                \/* 0x00010000u for version 1.0. *\/\n+  FWORD         ascender;               \/* Typographic ascent. *\/\n+  FWORD         descender;              \/* Typographic descent. *\/\n+  FWORD         lineGap;                \/* Typographic line gap. *\/\n+  UFWORD        advanceMax;             \/* Maximum advance width\/height value in\n+                                         * metrics table. *\/\n+  FWORD         minLeadingBearing;      \/* Minimum left\/top sidebearing value in\n+                                         * metrics table. *\/\n+  FWORD         minTrailingBearing;     \/* Minimum right\/bottom sidebearing value;\n+                                         * calculated as Min(aw - lsb -\n+                                         * (xMax - xMin)) for horizontal. *\/\n+  FWORD         maxExtent;              \/* horizontal: Max(lsb + (xMax - xMin)),\n+                                         * vertical: minLeadingBearing+(yMax-yMin). *\/\n+  HBINT16               caretSlopeRise;         \/* Used to calculate the slope of the\n+                                         * cursor (rise\/run); 1 for vertical caret,\n+                                         * 0 for horizontal.*\/\n+  HBINT16               caretSlopeRun;          \/* 0 for vertical caret, 1 for horizontal. *\/\n+  HBINT16               caretOffset;            \/* The amount by which a slanted\n+                                         * highlight on a glyph needs\n+                                         * to be shifted to produce the\n+                                         * best appearance. Set to 0 for\n+                                         * non-slanted fonts. *\/\n+  HBINT16               reserved1;              \/* Set to 0. *\/\n+  HBINT16               reserved2;              \/* Set to 0. *\/\n+  HBINT16               reserved3;              \/* Set to 0. *\/\n+  HBINT16               reserved4;              \/* Set to 0. *\/\n+  HBINT16               metricDataFormat;       \/* 0 for current format. *\/\n+  HBUINT16      numberOfLongMetrics;    \/* Number of LongMetric entries in metric\n+                                         * table. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (36);\n+};\n+\n+struct hhea : _hea<hhea> {\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_hhea;\n+};\n+struct vhea : _hea<vhea> {\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_vhea;\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_HHEA_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-hhea-table.hh","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,342 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod, Roderick Sheeter\n+ *\/\n+\n+#ifndef HB_OT_HMTX_TABLE_HH\n+#define HB_OT_HMTX_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-hhea-table.hh\"\n+#include \"hb-ot-os2-table.hh\"\n+#include \"hb-ot-var-hvar-table.hh\"\n+\n+\/*\n+ * hmtx -- Horizontal Metrics\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/hmtx\n+ * vmtx -- Vertical Metrics\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/vmtx\n+ *\/\n+#define HB_OT_TAG_hmtx HB_TAG('h','m','t','x')\n+#define HB_OT_TAG_vmtx HB_TAG('v','m','t','x')\n+\n+\n+namespace OT {\n+\n+\n+struct LongMetric\n+{\n+  UFWORD        advance; \/* Advance width\/height. *\/\n+  FWORD         sb; \/* Leading (left\/top) side bearing. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+template <typename T, typename H>\n+struct hmtxvmtx\n+{\n+  bool sanitize (hb_sanitize_context_t *c HB_UNUSED) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* We don't check for anything specific here.  The users of the\n+     * struct do all the hard work... *\/\n+    return_trace (true);\n+  }\n+\n+\n+  bool subset_update_header (hb_subset_plan_t *plan,\n+                                    unsigned int num_hmetrics) const\n+  {\n+    hb_blob_t *src_blob = hb_sanitize_context_t ().reference_table<H> (plan->source, H::tableTag);\n+    hb_blob_t *dest_blob = hb_blob_copy_writable_or_fail (src_blob);\n+    hb_blob_destroy (src_blob);\n+\n+    if (unlikely (!dest_blob)) {\n+      return false;\n+    }\n+\n+    unsigned int length;\n+    H *table = (H *) hb_blob_get_data (dest_blob, &length);\n+    table->numberOfLongMetrics.set (num_hmetrics);\n+\n+    bool result = plan->add_table (H::tableTag, dest_blob);\n+    hb_blob_destroy (dest_blob);\n+\n+    return result;\n+  }\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    typename T::accelerator_t _mtx;\n+    _mtx.init (plan->source);\n+\n+    \/* All the trailing glyphs with the same advance can use one LongMetric\n+     * and just keep LSB *\/\n+    hb_vector_t<hb_codepoint_t> &gids = plan->glyphs;\n+    unsigned int num_advances = gids.length;\n+    unsigned int last_advance = _mtx.get_advance (gids[num_advances - 1]);\n+    while (num_advances > 1 &&\n+           last_advance == _mtx.get_advance (gids[num_advances - 2]))\n+    {\n+      num_advances--;\n+    }\n+\n+    \/* alloc the new table *\/\n+    size_t dest_sz = num_advances * 4\n+                  + (gids.length - num_advances) * 2;\n+    void *dest = (void *) malloc (dest_sz);\n+    if (unlikely (!dest))\n+    {\n+      return false;\n+    }\n+    DEBUG_MSG(SUBSET, nullptr, \"%c%c%c%c in src has %d advances, %d lsbs\", HB_UNTAG(T::tableTag), _mtx.num_advances, _mtx.num_metrics - _mtx.num_advances);\n+    DEBUG_MSG(SUBSET, nullptr, \"%c%c%c%c in dest has %d advances, %d lsbs, %u bytes\", HB_UNTAG(T::tableTag), num_advances, gids.length - num_advances, (unsigned int) dest_sz);\n+\n+    const char *source_table = hb_blob_get_data (_mtx.table.get_blob (), nullptr);\n+    \/\/ Copy everything over\n+    LongMetric * old_metrics = (LongMetric *) source_table;\n+    FWORD *lsbs = (FWORD *) (old_metrics + _mtx.num_advances);\n+    char * dest_pos = (char *) dest;\n+\n+    bool failed = false;\n+    for (unsigned int i = 0; i < gids.length; i++)\n+    {\n+      \/* the last metric or the one for gids[i] *\/\n+      LongMetric *src_metric = old_metrics + MIN ((hb_codepoint_t) _mtx.num_advances - 1, gids[i]);\n+      if (gids[i] < _mtx.num_advances)\n+      {\n+        \/* src is a LongMetric *\/\n+        if (i < num_advances)\n+        {\n+          \/* dest is a LongMetric, copy it *\/\n+          *((LongMetric *) dest_pos) = *src_metric;\n+        }\n+        else\n+        {\n+          \/* dest just sb *\/\n+          *((FWORD *) dest_pos) = src_metric->sb;\n+        }\n+      }\n+      else\n+      {\n+        if (gids[i] >= _mtx.num_metrics)\n+        {\n+          DEBUG_MSG(SUBSET, nullptr, \"gid %d is >= number of source metrics %d\",\n+                    gids[i], _mtx.num_metrics);\n+          failed = true;\n+          break;\n+        }\n+        FWORD src_sb = *(lsbs + gids[i] - _mtx.num_advances);\n+        if (i < num_advances)\n+        {\n+          \/* dest needs a full LongMetric *\/\n+          LongMetric *metric = (LongMetric *)dest_pos;\n+          metric->advance = src_metric->advance;\n+          metric->sb = src_sb;\n+        }\n+        else\n+        {\n+          \/* dest just needs an sb *\/\n+          *((FWORD *) dest_pos) = src_sb;\n+        }\n+      }\n+      dest_pos += (i < num_advances ? 4 : 2);\n+    }\n+    _mtx.fini ();\n+\n+    \/\/ Amend header num hmetrics\n+    if (failed || unlikely (!subset_update_header (plan, num_advances)))\n+    {\n+      free (dest);\n+      return false;\n+    }\n+\n+    hb_blob_t *result = hb_blob_create ((const char *)dest,\n+                                        dest_sz,\n+                                        HB_MEMORY_MODE_READONLY,\n+                                        dest,\n+                                        free);\n+    bool success = plan->add_table (T::tableTag, result);\n+    hb_blob_destroy (result);\n+    return success;\n+  }\n+\n+  struct accelerator_t\n+  {\n+    friend struct hmtxvmtx;\n+\n+    void init (hb_face_t *face,\n+                      unsigned int default_advance_ = 0)\n+    {\n+      default_advance = default_advance_ ? default_advance_ : hb_face_get_upem (face);\n+\n+      bool got_font_extents = false;\n+      if (T::os2Tag != HB_TAG_NONE && face->table.OS2->is_typo_metrics ())\n+      {\n+        ascender = abs (face->table.OS2->sTypoAscender);\n+        descender = -abs (face->table.OS2->sTypoDescender);\n+        line_gap = face->table.OS2->sTypoLineGap;\n+        got_font_extents = (ascender | descender) != 0;\n+      }\n+\n+      hb_blob_t *_hea_blob = hb_sanitize_context_t().reference_table<H> (face);\n+      const H *_hea_table = _hea_blob->as<H> ();\n+      num_advances = _hea_table->numberOfLongMetrics;\n+      if (!got_font_extents)\n+      {\n+        ascender = abs (_hea_table->ascender);\n+        descender = -abs (_hea_table->descender);\n+        line_gap = _hea_table->lineGap;\n+        got_font_extents = (ascender | descender) != 0;\n+      }\n+      hb_blob_destroy (_hea_blob);\n+\n+      has_font_extents = got_font_extents;\n+\n+      table = hb_sanitize_context_t().reference_table<hmtxvmtx> (face, T::tableTag);\n+\n+      \/* Cap num_metrics() and num_advances() based on table length. *\/\n+      unsigned int len = table.get_length ();\n+      if (unlikely (num_advances * 4 > len))\n+        num_advances = len \/ 4;\n+      num_metrics = num_advances + (len - 4 * num_advances) \/ 2;\n+\n+      \/* We MUST set num_metrics to zero if num_advances is zero.\n+       * Our get_advance() depends on that. *\/\n+      if (unlikely (!num_advances))\n+      {\n+        num_metrics = num_advances = 0;\n+        table.destroy ();\n+        table = hb_blob_get_empty ();\n+      }\n+\n+      var_table = hb_sanitize_context_t().reference_table<HVARVVAR> (face, T::variationsTag);\n+    }\n+\n+    void fini ()\n+    {\n+      table.destroy ();\n+      var_table.destroy ();\n+    }\n+\n+    \/* TODO Add variations version. *\/\n+    unsigned int get_side_bearing (hb_codepoint_t glyph) const\n+    {\n+      if (glyph < num_advances)\n+        return table->longMetricZ[glyph].sb;\n+\n+      if (unlikely (glyph >= num_metrics))\n+        return 0;\n+\n+      const FWORD *bearings = (const FWORD *) &table->longMetricZ[num_advances];\n+      return bearings[glyph - num_advances];\n+    }\n+\n+    unsigned int get_advance (hb_codepoint_t glyph) const\n+    {\n+      if (unlikely (glyph >= num_metrics))\n+      {\n+        \/* If num_metrics is zero, it means we don't have the metrics table\n+         * for this direction: return default advance.  Otherwise, it means that the\n+         * glyph index is out of bound: return zero. *\/\n+        if (num_metrics)\n+          return 0;\n+        else\n+          return default_advance;\n+      }\n+\n+      return table->longMetricZ[MIN (glyph, (uint32_t) num_advances - 1)].advance;\n+    }\n+\n+    unsigned int get_advance (hb_codepoint_t  glyph,\n+                              hb_font_t      *font) const\n+    {\n+      unsigned int advance = get_advance (glyph);\n+      if (likely (glyph < num_metrics))\n+      {\n+        advance += (font->num_coords ? var_table->get_advance_var (glyph, font->coords, font->num_coords) : 0); \/\/ TODO Optimize?!\n+      }\n+      return advance;\n+    }\n+\n+    public:\n+    bool has_font_extents;\n+    int ascender;\n+    int descender;\n+    int line_gap;\n+\n+    protected:\n+    unsigned int num_metrics;\n+    unsigned int num_advances;\n+    unsigned int default_advance;\n+\n+    private:\n+    hb_blob_ptr_t<hmtxvmtx> table;\n+    hb_blob_ptr_t<HVARVVAR> var_table;\n+  };\n+\n+  protected:\n+  UnsizedArrayOf<LongMetric>longMetricZ;\/* Paired advance width and leading\n+                                         * bearing values for each glyph. The\n+                                         * value numOfHMetrics comes from\n+                                         * the 'hhea' table. If the font is\n+                                         * monospaced, only one entry need\n+                                         * be in the array, but that entry is\n+                                         * required. The last entry applies to\n+                                         * all subsequent glyphs. *\/\n+\/*UnsizedArrayOf<FWORD> leadingBearingX;*\/\/* Here the advance is assumed\n+                                         * to be the same as the advance\n+                                         * for the last entry above. The\n+                                         * number of entries in this array is\n+                                         * derived from numGlyphs (from 'maxp'\n+                                         * table) minus numberOfLongMetrics.\n+                                         * This generally is used with a run\n+                                         * of monospaced glyphs (e.g., Kanji\n+                                         * fonts or Courier fonts). Only one\n+                                         * run is allowed and it must be at\n+                                         * the end. This allows a monospaced\n+                                         * font to vary the side bearing\n+                                         * values for each glyph. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (0, longMetricZ);\n+};\n+\n+struct hmtx : hmtxvmtx<hmtx, hhea> {\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_hmtx;\n+  static constexpr hb_tag_t variationsTag = HB_OT_TAG_HVAR;\n+  static constexpr hb_tag_t os2Tag = HB_OT_TAG_OS2;\n+};\n+struct vmtx : hmtxvmtx<vmtx, vhea> {\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_vmtx;\n+  static constexpr hb_tag_t variationsTag = HB_OT_TAG_VVAR;\n+  static constexpr hb_tag_t os2Tag = HB_TAG_NONE;\n+};\n+\n+struct hmtx_accelerator_t : hmtx::accelerator_t {};\n+struct vmtx_accelerator_t : vmtx::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_HMTX_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-hmtx-table.hh","additions":342,"deletions":0,"binary":false,"changes":342,"status":"added"},{"patch":"@@ -0,0 +1,340 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_KERN_TABLE_HH\n+#define HB_OT_KERN_TABLE_HH\n+\n+#include \"hb-aat-layout-kerx-table.hh\"\n+\n+\n+\/*\n+ * kern -- Kerning\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/kern\n+ * https:\/\/developer.apple.com\/fonts\/TrueType-Reference-Manual\/RM06\/Chap6kern.html\n+ *\/\n+#define HB_OT_TAG_kern HB_TAG('k','e','r','n')\n+\n+\n+namespace OT {\n+\n+\n+template <typename KernSubTableHeader>\n+struct KernSubTableFormat3\n+{\n+  int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const\n+  {\n+    hb_array_t<const FWORD> kernValue = kernValueZ.as_array (kernValueCount);\n+    hb_array_t<const HBUINT8> leftClass = StructAfter<const UnsizedArrayOf<HBUINT8> > (kernValue).as_array (glyphCount);\n+    hb_array_t<const HBUINT8> rightClass = StructAfter<const UnsizedArrayOf<HBUINT8> > (leftClass).as_array (glyphCount);\n+    hb_array_t<const HBUINT8> kernIndex = StructAfter<const UnsizedArrayOf<HBUINT8> > (rightClass).as_array (leftClassCount * rightClassCount);\n+\n+    unsigned int leftC = leftClass[left];\n+    unsigned int rightC = rightClass[right];\n+    if (unlikely (leftC >= leftClassCount || rightC >= rightClassCount))\n+      return 0;\n+    unsigned int i = leftC * rightClassCount + rightC;\n+    return kernValue[kernIndex[i]];\n+  }\n+\n+  bool apply (AAT::hb_aat_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    if (!c->plan->requested_kerning)\n+      return false;\n+\n+    if (header.coverage & header.Backwards)\n+      return false;\n+\n+    hb_kern_machine_t<KernSubTableFormat3> machine (*this, header.coverage & header.CrossStream);\n+    machine.kern (c->font, c->buffer, c->plan->kern_mask);\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  c->check_range (kernValueZ,\n+                                  kernValueCount * sizeof (FWORD) +\n+                                  glyphCount * 2 +\n+                                  leftClassCount * rightClassCount));\n+  }\n+\n+  protected:\n+  KernSubTableHeader    header;\n+  HBUINT16              glyphCount;     \/* The number of glyphs in this font. *\/\n+  HBUINT8               kernValueCount; \/* The number of kerning values. *\/\n+  HBUINT8               leftClassCount; \/* The number of left-hand classes. *\/\n+  HBUINT8               rightClassCount;\/* The number of right-hand classes. *\/\n+  HBUINT8               flags;          \/* Set to zero (reserved for future use). *\/\n+  UnsizedArrayOf<FWORD> kernValueZ;     \/* The kerning values.\n+                                         * Length kernValueCount. *\/\n+#if 0\n+  UnsizedArrayOf<HBUINT8>leftClass;     \/* The left-hand classes.\n+                                         * Length glyphCount. *\/\n+  UnsizedArrayOf<HBUINT8>rightClass;    \/* The right-hand classes.\n+                                         * Length glyphCount. *\/\n+  UnsizedArrayOf<HBUINT8>kernIndex;     \/* The indices into the kernValue array.\n+                                         * Length leftClassCount * rightClassCount *\/\n+#endif\n+  public:\n+  DEFINE_SIZE_ARRAY (KernSubTableHeader::static_size + 6, kernValueZ);\n+};\n+\n+template <typename KernSubTableHeader>\n+struct KernSubTable\n+{\n+  unsigned int get_size () const { return u.header.length; }\n+  unsigned int get_type () const { return u.header.format; }\n+\n+  int get_kerning (hb_codepoint_t left, hb_codepoint_t right) const\n+  {\n+    switch (get_type ()) {\n+    \/* This method hooks up to hb_font_t's get_h_kerning.  Only support Format0. *\/\n+    case 0: return u.format0.get_kerning (left, right);\n+    default:return 0;\n+    }\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    unsigned int subtable_type = get_type ();\n+    TRACE_DISPATCH (this, subtable_type);\n+    switch (subtable_type) {\n+    case 0:     return_trace (c->dispatch (u.format0));\n+    case 1:     return_trace (u.header.apple ? c->dispatch (u.format1) : c->default_return_value ());\n+    case 2:     return_trace (c->dispatch (u.format2));\n+    case 3:     return_trace (u.header.apple ? c->dispatch (u.format3) : c->default_return_value ());\n+    default:    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!u.header.sanitize (c) ||\n+                  u.header.length < u.header.min_size ||\n+                  !c->check_range (this, u.header.length))) return_trace (false);\n+\n+    return_trace (dispatch (c));\n+  }\n+\n+  public:\n+  union {\n+  KernSubTableHeader                            header;\n+  AAT::KerxSubTableFormat0<KernSubTableHeader>  format0;\n+  AAT::KerxSubTableFormat1<KernSubTableHeader>  format1;\n+  AAT::KerxSubTableFormat2<KernSubTableHeader>  format2;\n+  KernSubTableFormat3<KernSubTableHeader>       format3;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (KernSubTableHeader::static_size);\n+};\n+\n+\n+struct KernOTSubTableHeader\n+{\n+  static constexpr bool apple = false;\n+  typedef AAT::ObsoleteTypes Types;\n+\n+  unsigned int tuple_count () const { return 0; }\n+  bool is_horizontal () const { return (coverage & Horizontal); }\n+\n+  enum Coverage\n+  {\n+    Horizontal  = 0x01u,\n+    Minimum     = 0x02u,\n+    CrossStream = 0x04u,\n+    Override    = 0x08u,\n+\n+    \/* Not supported: *\/\n+    Backwards   = 0x00u,\n+    Variation   = 0x00u,\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBUINT16      versionZ;       \/* Unused. *\/\n+  HBUINT16      length;         \/* Length of the subtable (including this header). *\/\n+  HBUINT8       format;         \/* Subtable format. *\/\n+  HBUINT8       coverage;       \/* Coverage bits. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct KernOT : AAT::KerxTable<KernOT>\n+{\n+  friend struct AAT::KerxTable<KernOT>;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;\n+  static constexpr unsigned minVersion = 0u;\n+\n+  typedef KernOTSubTableHeader SubTableHeader;\n+  typedef SubTableHeader::Types Types;\n+  typedef KernSubTable<SubTableHeader> SubTable;\n+\n+  protected:\n+  HBUINT16      version;        \/* Version--0x0000u *\/\n+  HBUINT16      tableCount;     \/* Number of subtables in the kerning table. *\/\n+  SubTable      firstSubTable;  \/* Subtables. *\/\n+  public:\n+  DEFINE_SIZE_MIN (4);\n+};\n+\n+\n+struct KernAATSubTableHeader\n+{\n+  static constexpr bool apple = true;\n+  typedef AAT::ObsoleteTypes Types;\n+\n+  unsigned int tuple_count () const { return 0; }\n+  bool is_horizontal () const       { return !(coverage & Vertical); }\n+\n+  enum Coverage\n+  {\n+    Vertical    = 0x80u,\n+    CrossStream = 0x40u,\n+    Variation   = 0x20u,\n+\n+    \/* Not supported: *\/\n+    Backwards   = 0x00u,\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBUINT32      length;         \/* Length of the subtable (including this header). *\/\n+  HBUINT8       coverage;       \/* Coverage bits. *\/\n+  HBUINT8       format;         \/* Subtable format. *\/\n+  HBUINT16      tupleIndex;     \/* The tuple index (used for variations fonts).\n+                               * This value specifies which tuple this subtable covers.\n+                               * Note: We don't implement. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct KernAAT : AAT::KerxTable<KernAAT>\n+{\n+  friend struct AAT::KerxTable<KernAAT>;\n+\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;\n+  static constexpr unsigned minVersion = 0x00010000u;\n+\n+  typedef KernAATSubTableHeader SubTableHeader;\n+  typedef SubTableHeader::Types Types;\n+  typedef KernSubTable<SubTableHeader> SubTable;\n+\n+  protected:\n+  HBUINT32      version;        \/* Version--0x00010000u *\/\n+  HBUINT32      tableCount;     \/* Number of subtables in the kerning table. *\/\n+  SubTable      firstSubTable;  \/* Subtables. *\/\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+struct kern\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_kern;\n+\n+  bool has_data () const { return u.version32; }\n+  unsigned int get_type () const { return u.major; }\n+\n+  bool has_state_machine () const\n+  {\n+    switch (get_type ()) {\n+    case 0: return u.ot.has_state_machine ();\n+    case 1: return u.aat.has_state_machine ();\n+    default:return false;\n+    }\n+  }\n+\n+  bool has_cross_stream () const\n+  {\n+    switch (get_type ()) {\n+    case 0: return u.ot.has_cross_stream ();\n+    case 1: return u.aat.has_cross_stream ();\n+    default:return false;\n+    }\n+  }\n+\n+  int get_h_kerning (hb_codepoint_t left, hb_codepoint_t right) const\n+  {\n+    switch (get_type ()) {\n+    case 0: return u.ot.get_h_kerning (left, right);\n+    case 1: return u.aat.get_h_kerning (left, right);\n+    default:return 0;\n+    }\n+  }\n+\n+  bool apply (AAT::hb_aat_apply_context_t *c) const\n+  { return dispatch (c); }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    unsigned int subtable_type = get_type ();\n+    TRACE_DISPATCH (this, subtable_type);\n+    switch (subtable_type) {\n+    case 0:     return_trace (c->dispatch (u.ot));\n+    case 1:     return_trace (c->dispatch (u.aat));\n+    default:    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.version32.sanitize (c)) return_trace (false);\n+    return_trace (dispatch (c));\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT32              version32;\n+  HBUINT16              major;\n+  KernOT                ot;\n+  KernAAT               aat;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (4, version32);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_KERN_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-kern-table.hh","additions":340,"deletions":0,"binary":false,"changes":340,"status":"added"},{"patch":"@@ -0,0 +1,541 @@\n+\/*\n+ * Copyright © 2016 Elie Roux <elie.roux@telecom-bretagne.eu>\n+ * Copyright © 2018  Google, Inc.\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_BASE_TABLE_HH\n+#define HB_OT_LAYOUT_BASE_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+\n+\/* To be removed *\/\n+typedef hb_tag_t hb_ot_layout_baseline_t;\n+\n+namespace OT {\n+\n+\/*\n+ * BASE -- Baseline\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/base\n+ *\/\n+\n+struct BaseCoordFormat1\n+{\n+  hb_position_t get_coord () const { return coordinate; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 1 *\/\n+  FWORD         coordinate;     \/* X or Y value, in design units *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct BaseCoordFormat2\n+{\n+  hb_position_t get_coord () const\n+  {\n+    \/* TODO *\/\n+    return coordinate;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 2 *\/\n+  FWORD         coordinate;     \/* X or Y value, in design units *\/\n+  GlyphID       referenceGlyph; \/* Glyph ID of control glyph *\/\n+  HBUINT16      coordPoint;     \/* Index of contour point on the\n+                                 * reference glyph *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct BaseCoordFormat3\n+{\n+  hb_position_t get_coord (hb_font_t *font,\n+                           const VariationStore &var_store,\n+                           hb_direction_t direction) const\n+  {\n+    const Device &device = this+deviceTable;\n+    return coordinate + (HB_DIRECTION_IS_VERTICAL (direction) ?\n+                         device.get_y_delta (font, var_store) :\n+                         device.get_x_delta (font, var_store));\n+  }\n+\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          deviceTable.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 3 *\/\n+  FWORD         coordinate;     \/* X or Y value, in design units *\/\n+  OffsetTo<Device>\n+                deviceTable;    \/* Offset to Device table for X or\n+                                 * Y value, from beginning of\n+                                 * BaseCoord table (may be NULL). *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct BaseCoord\n+{\n+  hb_position_t get_coord (hb_font_t *font,\n+                           const VariationStore &var_store,\n+                           hb_direction_t direction) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_coord ();\n+    case 2: return u.format2.get_coord ();\n+    case 3: return u.format3.get_coord (font, var_store, direction);\n+    default:return 0;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!u.format.sanitize (c))) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    case 3: return_trace (u.format3.sanitize (c));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+    HBUINT16            format;\n+    BaseCoordFormat1    format1;\n+    BaseCoordFormat2    format2;\n+    BaseCoordFormat3    format3;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+struct FeatMinMaxRecord\n+{\n+  static int cmp (const void *key_, const void *entry_)\n+  {\n+    hb_tag_t key = * (hb_tag_t *) key_;\n+    const FeatMinMaxRecord &entry = * (const FeatMinMaxRecord *) entry_;\n+    return key < (unsigned int) entry.tag ? -1 :\n+           key > (unsigned int) entry.tag ? 1 :\n+           0;\n+  }\n+\n+  void get_min_max (const BaseCoord **min, const BaseCoord **max) const\n+  {\n+    if (likely (min)) *min = &(this+minCoord);\n+    if (likely (max)) *max = &(this+maxCoord);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          minCoord.sanitize (c, this) &&\n+                          maxCoord.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  Tag           tag;            \/* 4-byte feature identification tag--must\n+                                 * match feature tag in FeatureList *\/\n+  OffsetTo<BaseCoord>\n+                minCoord;       \/* Offset to BaseCoord table that defines\n+                                 * the minimum extent value, from beginning\n+                                 * of MinMax table (may be NULL) *\/\n+  OffsetTo<BaseCoord>\n+                maxCoord;       \/* Offset to BaseCoord table that defines\n+                                 * the maximum extent value, from beginning\n+                                 * of MinMax table (may be NULL) *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+\n+};\n+\n+struct MinMax\n+{\n+  void get_min_max (hb_tag_t          feature_tag,\n+                           const BaseCoord **min,\n+                           const BaseCoord **max) const\n+  {\n+    \/* TODO Replace hb_bsearch() with .bsearch(). *\/\n+    const FeatMinMaxRecord *minMaxCoord = (const FeatMinMaxRecord *)\n+                                          hb_bsearch (&feature_tag, featMinMaxRecords.arrayZ,\n+                                                      featMinMaxRecords.len,\n+                                                      FeatMinMaxRecord::static_size,\n+                                                      FeatMinMaxRecord::cmp);\n+    if (minMaxCoord)\n+      minMaxCoord->get_min_max (min, max);\n+    else\n+    {\n+      if (likely (min)) *min = &(this+minCoord);\n+      if (likely (max)) *max = &(this+maxCoord);\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          minCoord.sanitize (c, this) &&\n+                          maxCoord.sanitize (c, this) &&\n+                          featMinMaxRecords.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  OffsetTo<BaseCoord>\n+                minCoord;       \/* Offset to BaseCoord table that defines\n+                                 * minimum extent value, from the beginning\n+                                 * of MinMax table (may be NULL) *\/\n+  OffsetTo<BaseCoord>\n+                maxCoord;       \/* Offset to BaseCoord table that defines\n+                                 * maximum extent value, from the beginning\n+                                 * of MinMax table (may be NULL) *\/\n+  SortedArrayOf<FeatMinMaxRecord>\n+                featMinMaxRecords;\n+                                \/* Array of FeatMinMaxRecords, in alphabetical\n+                                 * order by featureTableTag *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, featMinMaxRecords);\n+};\n+\n+struct BaseValues\n+{\n+  const BaseCoord &get_base_coord (int baseline_tag_index) const\n+  {\n+    if (baseline_tag_index == -1) baseline_tag_index = defaultIndex;\n+    return this+baseCoords[baseline_tag_index];\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          baseCoords.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  Index         defaultIndex;   \/* Index number of default baseline for this\n+                                 * script — equals index position of baseline tag\n+                                 * in baselineTags array of the BaseTagList *\/\n+  OffsetArrayOf<BaseCoord>\n+                baseCoords;     \/* Number of BaseCoord tables defined — should equal\n+                                 * baseTagCount in the BaseTagList\n+                                 *\n+                                 * Array of offsets to BaseCoord tables, from beginning of\n+                                 * BaseValues table — order matches baselineTags array in\n+                                 * the BaseTagList *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, baseCoords);\n+};\n+\n+struct BaseLangSysRecord\n+{\n+  static int cmp (const void *key_, const void *entry_)\n+  {\n+    hb_tag_t key = * (hb_tag_t *) key_;\n+    const BaseLangSysRecord &entry = * (const BaseLangSysRecord *) entry_;\n+    return key < (unsigned int) entry.baseLangSysTag ? -1 :\n+           key > (unsigned int) entry.baseLangSysTag ? 1 :\n+           0;\n+  }\n+\n+  const MinMax &get_min_max () const\n+  { return this+minMax; }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          minMax.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  Tag           baseLangSysTag; \/* 4-byte language system identification tag *\/\n+  OffsetTo<MinMax>\n+                minMax;         \/* Offset to MinMax table, from beginning\n+                                 * of BaseScript table *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct BaseScript\n+{\n+  const MinMax &get_min_max (hb_tag_t language_tag) const\n+  {\n+    \/* TODO Replace hb_bsearch() with .bsearch(). *\/\n+    const BaseLangSysRecord* record = (const BaseLangSysRecord *)\n+                                      hb_bsearch (&language_tag, baseLangSysRecords.arrayZ,\n+                                                  baseLangSysRecords.len,\n+                                                  BaseLangSysRecord::static_size,\n+                                                  BaseLangSysRecord::cmp);\n+    return record ? record->get_min_max () : this+defaultMinMax;\n+  }\n+\n+  const BaseCoord &get_base_coord (int baseline_tag_index) const\n+  { return (this+baseValues).get_base_coord (baseline_tag_index); }\n+\n+  bool is_empty () const { return !baseValues; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          baseValues.sanitize (c, this) &&\n+                          defaultMinMax.sanitize (c, this) &&\n+                          baseLangSysRecords.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  OffsetTo<BaseValues>\n+                baseValues;     \/* Offset to BaseValues table, from beginning\n+                                 * of BaseScript table (may be NULL) *\/\n+  OffsetTo<MinMax>\n+                defaultMinMax;  \/* Offset to MinMax table, from beginning of\n+                                 * BaseScript table (may be NULL) *\/\n+  SortedArrayOf<BaseLangSysRecord>\n+                baseLangSysRecords;\n+                                \/* Number of BaseLangSysRecords\n+                                 * defined — may be zero (0) *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (6, baseLangSysRecords);\n+};\n+\n+struct BaseScriptList;\n+struct BaseScriptRecord\n+{\n+  static int cmp (const void *key_, const void *entry_)\n+  {\n+    hb_tag_t key = * (hb_tag_t *) key_;\n+    const BaseScriptRecord &entry = * (const BaseScriptRecord *) entry_;\n+    return key < (unsigned int) entry.baseScriptTag ? -1 :\n+           key > (unsigned int) entry.baseScriptTag ? 1 :\n+           0;\n+  }\n+\n+  const BaseScript &get_base_script (const BaseScriptList *list) const\n+  { return list+baseScript; }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          baseScript.sanitize (c, base)));\n+  }\n+\n+  protected:\n+  Tag           baseScriptTag;  \/* 4-byte script identification tag *\/\n+  OffsetTo<BaseScript>\n+                baseScript;     \/* Offset to BaseScript table, from beginning\n+                                 * of BaseScriptList *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct BaseScriptList\n+{\n+  const BaseScriptRecord *find_record (hb_tag_t script) const\n+  {\n+    \/* TODO Replace hb_bsearch() with .bsearch(). *\/\n+    return (const BaseScriptRecord *) hb_bsearch (&script, baseScriptRecords.arrayZ,\n+                                                  baseScriptRecords.len,\n+                                                  BaseScriptRecord::static_size,\n+                                                  BaseScriptRecord::cmp);\n+  }\n+\n+  \/* TODO: Or client should handle fallback? *\/\n+  const BaseScript &get_base_script (hb_tag_t script) const\n+  {\n+    const BaseScriptRecord *record = find_record (script);\n+    if (!record) record = find_record ((hb_script_t) HB_TAG ('D','F','L','T'));\n+\n+    return record ? record->get_base_script (this) : Null (BaseScript);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  baseScriptRecords.sanitize (c, this));\n+  }\n+\n+  protected:\n+  SortedArrayOf<BaseScriptRecord>\n+                        baseScriptRecords;\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (2, baseScriptRecords);\n+};\n+\n+struct Axis\n+{\n+  bool get_baseline (hb_ot_layout_baseline_t   baseline,\n+                            hb_tag_t                  script_tag,\n+                            hb_tag_t                  language_tag,\n+                            const BaseCoord         **coord) const\n+  {\n+    const BaseScript &base_script = (this+baseScriptList).get_base_script (script_tag);\n+    if (base_script.is_empty ()) return false;\n+\n+    if (likely (coord)) *coord = &base_script.get_base_coord ((this+baseTagList).bsearch (baseline));\n+\n+    return true;\n+  }\n+\n+  bool get_min_max (hb_tag_t          script_tag,\n+                    hb_tag_t          language_tag,\n+                    hb_tag_t          feature_tag,\n+                    const BaseCoord **min_coord,\n+                    const BaseCoord **max_coord) const\n+  {\n+    const BaseScript &base_script = (this+baseScriptList).get_base_script (script_tag);\n+    if (base_script.is_empty ()) return false;\n+\n+    base_script.get_min_max (language_tag).get_min_max (feature_tag, min_coord, max_coord);\n+\n+    return true;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (this+baseTagList).sanitize (c) &&\n+                          (this+baseScriptList).sanitize (c)));\n+  }\n+\n+  protected:\n+  OffsetTo<SortedArrayOf<Tag> >\n+                baseTagList;    \/* Offset to BaseTagList table, from beginning\n+                                 * of Axis table (may be NULL)\n+                                 * Array of 4-byte baseline identification tags — must\n+                                 * be in alphabetical order *\/\n+  OffsetTo<BaseScriptList>\n+                baseScriptList; \/* Offset to BaseScriptList table, from beginning\n+                                 * of Axis table\n+                                 * Array of BaseScriptRecords, in alphabetical order\n+                                 * by baseScriptTag *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct BASE\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_BASE;\n+\n+  const Axis &get_axis (hb_direction_t direction) const\n+  { return HB_DIRECTION_IS_VERTICAL (direction) ? this+vAxis : this+hAxis; }\n+\n+  const VariationStore &get_var_store () const\n+  { return version.to_int () < 0x00010001u ? Null (VariationStore) : this+varStore; }\n+\n+  bool get_baseline (hb_font_t               *font,\n+                     hb_ot_layout_baseline_t  baseline,\n+                     hb_direction_t           direction,\n+                     hb_tag_t                 script_tag,\n+                     hb_tag_t                 language_tag,\n+                     hb_position_t           *base) const\n+  {\n+    const BaseCoord *base_coord;\n+    if (!get_axis (direction).get_baseline (baseline, script_tag, language_tag, &base_coord))\n+      return false;\n+\n+    if (likely (base && base_coord)) *base = base_coord->get_coord (font,\n+                                                                    get_var_store (),\n+                                                                    direction);\n+    return true;\n+  }\n+\n+  \/* TODO: Expose this separately sometime? *\/\n+  bool get_min_max (hb_font_t      *font,\n+                    hb_direction_t  direction,\n+                    hb_tag_t        script_tag,\n+                    hb_tag_t        language_tag,\n+                    hb_tag_t        feature_tag,\n+                    hb_position_t  *min,\n+                    hb_position_t  *max)\n+  {\n+    const BaseCoord *min_coord, *max_coord;\n+    if (!get_axis (direction).get_min_max (script_tag, language_tag, feature_tag,\n+                                           &min_coord, &max_coord))\n+      return false;\n+\n+    const VariationStore &var_store = get_var_store ();\n+    if (likely (min && min_coord)) *min = min_coord->get_coord (font, var_store, direction);\n+    if (likely (max && max_coord)) *max = max_coord->get_coord (font, var_store, direction);\n+    return true;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          likely (version.major == 1) &&\n+                          hAxis.sanitize (c, this) &&\n+                          vAxis.sanitize (c, this) &&\n+                          (version.to_int () < 0x00010001u || varStore.sanitize (c, this))));\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the BASE table *\/\n+  OffsetTo<Axis>hAxis;          \/* Offset to horizontal Axis table, from beginning\n+                                 * of BASE table (may be NULL) *\/\n+  OffsetTo<Axis>vAxis;          \/* Offset to vertical Axis table, from beginning\n+                                 * of BASE table (may be NULL) *\/\n+  LOffsetTo<VariationStore>\n+                varStore;       \/* Offset to the table of Item Variation\n+                                 * Store--from beginning of BASE\n+                                 * header (may be NULL).  Introduced\n+                                 * in version 0x00010001. *\/\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_LAYOUT_BASE_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout-base-table.hh","additions":541,"deletions":0,"binary":false,"changes":541,"status":"added"},{"patch":"@@ -0,0 +1,2178 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_COMMON_HH\n+#define HB_OT_LAYOUT_COMMON_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-open-type.hh\"\n+#include \"hb-set.hh\"\n+\n+\n+#ifndef HB_MAX_NESTING_LEVEL\n+#define HB_MAX_NESTING_LEVEL    6\n+#endif\n+#ifndef HB_MAX_CONTEXT_LENGTH\n+#define HB_MAX_CONTEXT_LENGTH   64\n+#endif\n+#ifndef HB_CLOSURE_MAX_STAGES\n+\/*\n+ * The maximum number of times a lookup can be applied during shaping.\n+ * Used to limit the number of iterations of the closure algorithm.\n+ * This must be larger than the number of times add_pause() is\n+ * called in a collect_features call of any shaper.\n+ *\/\n+#define HB_CLOSURE_MAX_STAGES   32\n+#endif\n+\n+#ifndef HB_MAX_SCRIPTS\n+#define HB_MAX_SCRIPTS  500\n+#endif\n+\n+#ifndef HB_MAX_LANGSYS\n+#define HB_MAX_LANGSYS  2000\n+#endif\n+\n+\n+namespace OT {\n+\n+\n+#define NOT_COVERED             ((unsigned int) -1)\n+\n+\n+\n+\/*\n+ *\n+ * OpenType Layout Common Table Formats\n+ *\n+ *\/\n+\n+\n+\/*\n+ * Script, ScriptList, LangSys, Feature, FeatureList, Lookup, LookupList\n+ *\/\n+\n+struct Record_sanitize_closure_t {\n+  hb_tag_t tag;\n+  const void *list_base;\n+};\n+\n+template <typename Type>\n+struct Record\n+{\n+  int cmp (hb_tag_t a) const { return tag.cmp (a); }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    const Record_sanitize_closure_t closure = {tag, base};\n+    return_trace (c->check_struct (this) && offset.sanitize (c, base, &closure));\n+  }\n+\n+  Tag           tag;            \/* 4-byte Tag identifier *\/\n+  OffsetTo<Type>\n+                offset;         \/* Offset from beginning of object holding\n+                                 * the Record *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+template <typename Type>\n+struct RecordArrayOf : SortedArrayOf<Record<Type> >\n+{\n+  const OffsetTo<Type>& get_offset (unsigned int i) const\n+  { return (*this)[i].offset; }\n+  OffsetTo<Type>& get_offset (unsigned int i)\n+  { return (*this)[i].offset; }\n+  const Tag& get_tag (unsigned int i) const\n+  { return (*this)[i].tag; }\n+  unsigned int get_tags (unsigned int start_offset,\n+                         unsigned int *record_count \/* IN\/OUT *\/,\n+                         hb_tag_t     *record_tags \/* OUT *\/) const\n+  {\n+    if (record_count) {\n+      const Record<Type> *arr = this->sub_array (start_offset, record_count);\n+      unsigned int count = *record_count;\n+      for (unsigned int i = 0; i < count; i++)\n+        record_tags[i] = arr[i].tag;\n+    }\n+    return this->len;\n+  }\n+  bool find_index (hb_tag_t tag, unsigned int *index) const\n+  {\n+    return this->bfind (tag, index, HB_BFIND_NOT_FOUND_STORE, Index::NOT_FOUND_INDEX);\n+  }\n+};\n+\n+template <typename Type>\n+struct RecordListOf : RecordArrayOf<Type>\n+{\n+  const Type& operator [] (unsigned int i) const\n+  { return this+this->get_offset (i); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    struct RecordListOf<Type> *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    unsigned int count = this->len;\n+    for (unsigned int i = 0; i < count; i++)\n+      out->get_offset (i).serialize_subset (c, (*this)[i], out);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (RecordArrayOf<Type>::sanitize (c, this));\n+  }\n+};\n+\n+\n+struct RangeRecord\n+{\n+  int cmp (hb_codepoint_t g) const\n+  { return g < start ? -1 : g <= end ? 0 : +1; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return glyphs->intersects (start, end); }\n+\n+  template <typename set_t>\n+  bool add_coverage (set_t *glyphs) const\n+  { return glyphs->add_range (start, end); }\n+\n+  GlyphID       start;          \/* First GlyphID in the range *\/\n+  GlyphID       end;            \/* Last GlyphID in the range *\/\n+  HBUINT16      value;          \/* Value *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (OT, RangeRecord);\n+\n+\n+struct IndexArray : ArrayOf<Index>\n+{\n+  unsigned int get_indexes (unsigned int start_offset,\n+                            unsigned int *_count \/* IN\/OUT *\/,\n+                            unsigned int *_indexes \/* OUT *\/) const\n+  {\n+    if (_count) {\n+      const HBUINT16 *arr = this->sub_array (start_offset, _count);\n+      unsigned int count = *_count;\n+      for (unsigned int i = 0; i < count; i++)\n+        _indexes[i] = arr[i];\n+    }\n+    return this->len;\n+  }\n+\n+  void add_indexes_to (hb_set_t* output \/* OUT *\/) const\n+  {\n+    output->add_array (arrayZ, len);\n+  }\n+};\n+\n+\n+struct Script;\n+struct LangSys;\n+struct Feature;\n+\n+\n+struct LangSys\n+{\n+  unsigned int get_feature_count () const\n+  { return featureIndex.len; }\n+  hb_tag_t get_feature_index (unsigned int i) const\n+  { return featureIndex[i]; }\n+  unsigned int get_feature_indexes (unsigned int start_offset,\n+                                    unsigned int *feature_count \/* IN\/OUT *\/,\n+                                    unsigned int *feature_indexes \/* OUT *\/) const\n+  { return featureIndex.get_indexes (start_offset, feature_count, feature_indexes); }\n+  void add_feature_indexes_to (hb_set_t *feature_indexes) const\n+  { featureIndex.add_indexes_to (feature_indexes); }\n+\n+  bool has_required_feature () const { return reqFeatureIndex != 0xFFFFu; }\n+  unsigned int get_required_feature_index () const\n+  {\n+    if (reqFeatureIndex == 0xFFFFu)\n+      return Index::NOT_FOUND_INDEX;\n+   return reqFeatureIndex;;\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    return_trace (c->serializer->embed (*this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const Record_sanitize_closure_t * = nullptr) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && featureIndex.sanitize (c));\n+  }\n+\n+  Offset16      lookupOrderZ;   \/* = Null (reserved for an offset to a\n+                                 * reordering table) *\/\n+  HBUINT16      reqFeatureIndex;\/* Index of a feature required for this\n+                                 * language system--if no required features\n+                                 * = 0xFFFFu *\/\n+  IndexArray    featureIndex;   \/* Array of indices into the FeatureList *\/\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (6, featureIndex);\n+};\n+DECLARE_NULL_NAMESPACE_BYTES (OT, LangSys);\n+\n+struct Script\n+{\n+  unsigned int get_lang_sys_count () const\n+  { return langSys.len; }\n+  const Tag& get_lang_sys_tag (unsigned int i) const\n+  { return langSys.get_tag (i); }\n+  unsigned int get_lang_sys_tags (unsigned int start_offset,\n+                                  unsigned int *lang_sys_count \/* IN\/OUT *\/,\n+                                  hb_tag_t     *lang_sys_tags \/* OUT *\/) const\n+  { return langSys.get_tags (start_offset, lang_sys_count, lang_sys_tags); }\n+  const LangSys& get_lang_sys (unsigned int i) const\n+  {\n+    if (i == Index::NOT_FOUND_INDEX) return get_default_lang_sys ();\n+    return this+langSys[i].offset;\n+  }\n+  bool find_lang_sys_index (hb_tag_t tag, unsigned int *index) const\n+  { return langSys.find_index (tag, index); }\n+\n+  bool has_default_lang_sys () const           { return defaultLangSys != 0; }\n+  const LangSys& get_default_lang_sys () const { return this+defaultLangSys; }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    struct Script *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    out->defaultLangSys.serialize_subset (c, this+defaultLangSys, out);\n+    unsigned int count = langSys.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      out->langSys.arrayZ[i].offset.serialize_subset (c, this+langSys[i].offset, out);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const Record_sanitize_closure_t * = nullptr) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (defaultLangSys.sanitize (c, this) && langSys.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetTo<LangSys>\n+                defaultLangSys; \/* Offset to DefaultLangSys table--from\n+                                 * beginning of Script table--may be Null *\/\n+  RecordArrayOf<LangSys>\n+                langSys;        \/* Array of LangSysRecords--listed\n+                                 * alphabetically by LangSysTag *\/\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (4, langSys);\n+};\n+\n+typedef RecordListOf<Script> ScriptList;\n+\n+\n+\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/features_pt#size *\/\n+struct FeatureParamsSize\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this))) return_trace (false);\n+\n+    \/* This subtable has some \"history\", if you will.  Some earlier versions of\n+     * Adobe tools calculated the offset of the FeatureParams sutable from the\n+     * beginning of the FeatureList table!  Now, that is dealt with in the\n+     * Feature implementation.  But we still need to be able to tell junk from\n+     * real data.  Note: We don't check that the nameID actually exists.\n+     *\n+     * Read Roberts wrote on 9\/15\/06 on opentype-list@indx.co.uk :\n+     *\n+     * Yes, it is correct that a new version of the AFDKO (version 2.0) will be\n+     * coming out soon, and that the makeotf program will build a font with a\n+     * 'size' feature that is correct by the specification.\n+     *\n+     * The specification for this feature tag is in the \"OpenType Layout Tag\n+     * Registry\". You can see a copy of this at:\n+     * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/features_pt#tag-size\n+     *\n+     * Here is one set of rules to determine if the 'size' feature is built\n+     * correctly, or as by the older versions of MakeOTF. You may be able to do\n+     * better.\n+     *\n+     * Assume that the offset to the size feature is according to specification,\n+     * and make the following value checks. If it fails, assume the size\n+     * feature is calculated as versions of MakeOTF before the AFDKO 2.0 built it.\n+     * If this fails, reject the 'size' feature. The older makeOTF's calculated the\n+     * offset from the beginning of the FeatureList table, rather than from the\n+     * beginning of the 'size' Feature table.\n+     *\n+     * If \"design size\" == 0:\n+     *     fails check\n+     *\n+     * Else if (\"subfamily identifier\" == 0 and\n+     *     \"range start\" == 0 and\n+     *     \"range end\" == 0 and\n+     *     \"range start\" == 0 and\n+     *     \"menu name ID\" == 0)\n+     *     passes check: this is the format used when there is a design size\n+     * specified, but there is no recommended size range.\n+     *\n+     * Else if (\"design size\" <  \"range start\" or\n+     *     \"design size\" >   \"range end\" or\n+     *     \"range end\" <= \"range start\" or\n+     *     \"menu name ID\"  < 256 or\n+     *     \"menu name ID\"  > 32767 or\n+     *     menu name ID is not a name ID which is actually in the name table)\n+     *     fails test\n+     * Else\n+     *     passes test.\n+     *\/\n+\n+    if (!designSize)\n+      return_trace (false);\n+    else if (subfamilyID == 0 &&\n+             subfamilyNameID == 0 &&\n+             rangeStart == 0 &&\n+             rangeEnd == 0)\n+      return_trace (true);\n+    else if (designSize < rangeStart ||\n+             designSize > rangeEnd ||\n+             subfamilyNameID < 256 ||\n+             subfamilyNameID > 32767)\n+      return_trace (false);\n+    else\n+      return_trace (true);\n+  }\n+\n+  HBUINT16      designSize;     \/* Represents the design size in 720\/inch\n+                                 * units (decipoints).  The design size entry\n+                                 * must be non-zero.  When there is a design\n+                                 * size but no recommended size range, the\n+                                 * rest of the array will consist of zeros. *\/\n+  HBUINT16      subfamilyID;    \/* Has no independent meaning, but serves\n+                                 * as an identifier that associates fonts\n+                                 * in a subfamily. All fonts which share a\n+                                 * Preferred or Font Family name and which\n+                                 * differ only by size range shall have the\n+                                 * same subfamily value, and no fonts which\n+                                 * differ in weight or style shall have the\n+                                 * same subfamily value. If this value is\n+                                 * zero, the remaining fields in the array\n+                                 * will be ignored. *\/\n+  NameID        subfamilyNameID;\/* If the preceding value is non-zero, this\n+                                 * value must be set in the range 256 - 32767\n+                                 * (inclusive). It records the value of a\n+                                 * field in the name table, which must\n+                                 * contain English-language strings encoded\n+                                 * in Windows Unicode and Macintosh Roman,\n+                                 * and may contain additional strings\n+                                 * localized to other scripts and languages.\n+                                 * Each of these strings is the name an\n+                                 * application should use, in combination\n+                                 * with the family name, to represent the\n+                                 * subfamily in a menu.  Applications will\n+                                 * choose the appropriate version based on\n+                                 * their selection criteria. *\/\n+  HBUINT16      rangeStart;     \/* Large end of the recommended usage range\n+                                 * (inclusive), stored in 720\/inch units\n+                                 * (decipoints). *\/\n+  HBUINT16      rangeEnd;       \/* Small end of the recommended usage range\n+                                   (exclusive), stored in 720\/inch units\n+                                 * (decipoints). *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/features_pt#ssxx *\/\n+struct FeatureParamsStylisticSet\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* Right now minorVersion is at zero.  Which means, any table supports\n+     * the uiNameID field. *\/\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT16      version;        \/* (set to 0): This corresponds to a “minor”\n+                                 * version number. Additional data may be\n+                                 * added to the end of this Feature Parameters\n+                                 * table in the future. *\/\n+\n+  NameID        uiNameID;       \/* The 'name' table name ID that specifies a\n+                                 * string (or strings, for multiple languages)\n+                                 * for a user-interface label for this\n+                                 * feature.  The values of uiLabelNameId and\n+                                 * sampleTextNameId are expected to be in the\n+                                 * font-specific name ID range (256-32767),\n+                                 * though that is not a requirement in this\n+                                 * Feature Parameters specification. The\n+                                 * user-interface label for the feature can\n+                                 * be provided in multiple languages. An\n+                                 * English string should be included as a\n+                                 * fallback. The string should be kept to a\n+                                 * minimal length to fit comfortably with\n+                                 * different application interfaces. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+\/* https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/features_ae#cv01-cv99 *\/\n+struct FeatureParamsCharacterVariants\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  characters.sanitize (c));\n+  }\n+\n+  HBUINT16      format;                 \/* Format number is set to 0. *\/\n+  NameID        featUILableNameID;      \/* The ‘name’ table name ID that\n+                                         * specifies a string (or strings,\n+                                         * for multiple languages) for a\n+                                         * user-interface label for this\n+                                         * feature. (May be NULL.) *\/\n+  NameID        featUITooltipTextNameID;\/* The ‘name’ table name ID that\n+                                         * specifies a string (or strings,\n+                                         * for multiple languages) that an\n+                                         * application can use for tooltip\n+                                         * text for this feature. (May be\n+                                         * nullptr.) *\/\n+  NameID        sampleTextNameID;       \/* The ‘name’ table name ID that\n+                                         * specifies sample text that\n+                                         * illustrates the effect of this\n+                                         * feature. (May be NULL.) *\/\n+  HBUINT16      numNamedParameters;     \/* Number of named parameters. (May\n+                                         * be zero.) *\/\n+  NameID        firstParamUILabelNameID;\/* The first ‘name’ table name ID\n+                                         * used to specify strings for\n+                                         * user-interface labels for the\n+                                         * feature parameters. (Must be zero\n+                                         * if numParameters is zero.) *\/\n+  ArrayOf<HBUINT24>\n+                characters;             \/* Array of the Unicode Scalar Value\n+                                         * of the characters for which this\n+                                         * feature provides glyph variants.\n+                                         * (May be zero.) *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (14, characters);\n+};\n+\n+struct FeatureParams\n+{\n+  bool sanitize (hb_sanitize_context_t *c, hb_tag_t tag) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (tag == HB_TAG ('s','i','z','e'))\n+      return_trace (u.size.sanitize (c));\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('s','s','\\0','\\0')) \/* ssXX *\/\n+      return_trace (u.stylisticSet.sanitize (c));\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('c','v','\\0','\\0')) \/* cvXX *\/\n+      return_trace (u.characterVariants.sanitize (c));\n+    return_trace (true);\n+  }\n+\n+  const FeatureParamsSize& get_size_params (hb_tag_t tag) const\n+  {\n+    if (tag == HB_TAG ('s','i','z','e'))\n+      return u.size;\n+    return Null (FeatureParamsSize);\n+  }\n+\n+  const FeatureParamsStylisticSet& get_stylistic_set_params (hb_tag_t tag) const\n+  {\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('s','s','\\0','\\0')) \/* ssXX *\/\n+      return u.stylisticSet;\n+    return Null (FeatureParamsStylisticSet);\n+  }\n+\n+  const FeatureParamsCharacterVariants& get_character_variants_params (hb_tag_t tag) const\n+  {\n+    if ((tag & 0xFFFF0000u) == HB_TAG ('c','v','\\0','\\0')) \/* cvXX *\/\n+      return u.characterVariants;\n+    return Null (FeatureParamsCharacterVariants);\n+  }\n+\n+  private:\n+  union {\n+  FeatureParamsSize                     size;\n+  FeatureParamsStylisticSet             stylisticSet;\n+  FeatureParamsCharacterVariants        characterVariants;\n+  } u;\n+  public:\n+  DEFINE_SIZE_STATIC (17);\n+};\n+\n+struct Feature\n+{\n+  unsigned int get_lookup_count () const\n+  { return lookupIndex.len; }\n+  hb_tag_t get_lookup_index (unsigned int i) const\n+  { return lookupIndex[i]; }\n+  unsigned int get_lookup_indexes (unsigned int start_index,\n+                                   unsigned int *lookup_count \/* IN\/OUT *\/,\n+                                   unsigned int *lookup_tags \/* OUT *\/) const\n+  { return lookupIndex.get_indexes (start_index, lookup_count, lookup_tags); }\n+  void add_lookup_indexes_to (hb_set_t *lookup_indexes) const\n+  { lookupIndex.add_indexes_to (lookup_indexes); }\n+\n+  const FeatureParams &get_feature_params () const\n+  { return this+featureParams; }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    struct Feature *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+    out->featureParams.set (0); \/* TODO(subset) FeatureParams. *\/\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const Record_sanitize_closure_t *closure = nullptr) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!(c->check_struct (this) && lookupIndex.sanitize (c))))\n+      return_trace (false);\n+\n+    \/* Some earlier versions of Adobe tools calculated the offset of the\n+     * FeatureParams subtable from the beginning of the FeatureList table!\n+     *\n+     * If sanitizing \"failed\" for the FeatureParams subtable, try it with the\n+     * alternative location.  We would know sanitize \"failed\" if old value\n+     * of the offset was non-zero, but it's zeroed now.\n+     *\n+     * Only do this for the 'size' feature, since at the time of the faulty\n+     * Adobe tools, only the 'size' feature had FeatureParams defined.\n+     *\/\n+\n+    OffsetTo<FeatureParams> orig_offset = featureParams;\n+    if (unlikely (!featureParams.sanitize (c, this, closure ? closure->tag : HB_TAG_NONE)))\n+      return_trace (false);\n+\n+    if (likely (orig_offset.is_null ()))\n+      return_trace (true);\n+\n+    if (featureParams == 0 && closure &&\n+        closure->tag == HB_TAG ('s','i','z','e') &&\n+        closure->list_base && closure->list_base < this)\n+    {\n+      unsigned int new_offset_int = (unsigned int) orig_offset -\n+                                    (((char *) this) - ((char *) closure->list_base));\n+\n+      OffsetTo<FeatureParams> new_offset;\n+      \/* Check that it did not overflow. *\/\n+      new_offset.set (new_offset_int);\n+      if (new_offset == new_offset_int &&\n+          c->try_set (&featureParams, new_offset) &&\n+          !featureParams.sanitize (c, this, closure ? closure->tag : HB_TAG_NONE))\n+        return_trace (false);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  OffsetTo<FeatureParams>\n+                 featureParams; \/* Offset to Feature Parameters table (if one\n+                                 * has been defined for the feature), relative\n+                                 * to the beginning of the Feature Table; = Null\n+                                 * if not required *\/\n+  IndexArray     lookupIndex;   \/* Array of LookupList indices *\/\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (4, lookupIndex);\n+};\n+\n+typedef RecordListOf<Feature> FeatureList;\n+\n+\n+struct LookupFlag : HBUINT16\n+{\n+  enum Flags {\n+    RightToLeft         = 0x0001u,\n+    IgnoreBaseGlyphs    = 0x0002u,\n+    IgnoreLigatures     = 0x0004u,\n+    IgnoreMarks         = 0x0008u,\n+    IgnoreFlags         = 0x000Eu,\n+    UseMarkFilteringSet = 0x0010u,\n+    Reserved            = 0x00E0u,\n+    MarkAttachmentType  = 0xFF00u\n+  };\n+  public:\n+  DEFINE_SIZE_STATIC (2);\n+};\n+\n+} \/* namespace OT *\/\n+\/* This has to be outside the namespace. *\/\n+HB_MARK_AS_FLAG_T (OT::LookupFlag::Flags);\n+namespace OT {\n+\n+struct Lookup\n+{\n+  unsigned int get_subtable_count () const { return subTable.len; }\n+\n+  template <typename TSubTable>\n+  const TSubTable& get_subtable (unsigned int i) const\n+  { return this+CastR<OffsetArrayOf<TSubTable> > (subTable)[i]; }\n+\n+  template <typename TSubTable>\n+  const OffsetArrayOf<TSubTable>& get_subtables () const\n+  { return CastR<OffsetArrayOf<TSubTable> > (subTable); }\n+  template <typename TSubTable>\n+  OffsetArrayOf<TSubTable>& get_subtables ()\n+  { return CastR<OffsetArrayOf<TSubTable> > (subTable); }\n+\n+  unsigned int get_size () const\n+  {\n+    const HBUINT16 &markFilteringSet = StructAfter<const HBUINT16> (subTable);\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n+      return (const char *) &StructAfter<const char> (markFilteringSet) - (const char *) this;\n+    return (const char *) &markFilteringSet - (const char *) this;\n+  }\n+\n+  unsigned int get_type () const { return lookupType; }\n+\n+  \/* lookup_props is a 32-bit integer where the lower 16-bit is LookupFlag and\n+   * higher 16-bit is mark-filtering-set if the lookup uses one.\n+   * Not to be confused with glyph_props which is very similar. *\/\n+  uint32_t get_props () const\n+  {\n+    unsigned int flag = lookupFlag;\n+    if (unlikely (flag & LookupFlag::UseMarkFilteringSet))\n+    {\n+      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      flag += (markFilteringSet << 16);\n+    }\n+    return flag;\n+  }\n+\n+  template <typename TSubTable, typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    unsigned int lookup_type = get_type ();\n+    TRACE_DISPATCH (this, lookup_type);\n+    unsigned int count = get_subtable_count ();\n+    for (unsigned int i = 0; i < count; i++) {\n+      typename context_t::return_t r = get_subtable<TSubTable> (i).dispatch (c, lookup_type);\n+      if (c->stop_sublookup_iteration (r))\n+        return_trace (r);\n+    }\n+    return_trace (c->default_return_value ());\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  unsigned int lookup_type,\n+                  uint32_t lookup_props,\n+                  unsigned int num_subtables)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    lookupType.set (lookup_type);\n+    lookupFlag.set (lookup_props & 0xFFFFu);\n+    if (unlikely (!subTable.serialize (c, num_subtables))) return_trace (false);\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n+    {\n+      if (unlikely (!c->extend (*this))) return_trace (false);\n+      HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      markFilteringSet.set (lookup_props >> 16);\n+    }\n+    return_trace (true);\n+  }\n+\n+  \/* Older compilers need this to NOT be locally defined in a function. *\/\n+  template <typename TSubTable>\n+  struct SubTableSubsetWrapper\n+  {\n+    SubTableSubsetWrapper (const TSubTable &subtable_,\n+                           unsigned int lookup_type_) :\n+                             subtable (subtable_),\n+                             lookup_type (lookup_type_) {}\n+\n+    bool subset (hb_subset_context_t *c) const\n+    { return subtable.dispatch (c, lookup_type); }\n+\n+    private:\n+    const TSubTable &subtable;\n+    unsigned int lookup_type;\n+  };\n+\n+  template <typename TSubTable>\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    struct Lookup *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    \/* Subset the actual subtables. *\/\n+    \/* TODO Drop empty ones, either by calling intersects() beforehand,\n+     * or just dropping null offsets after. *\/\n+    const OffsetArrayOf<TSubTable>& subtables = get_subtables<TSubTable> ();\n+    OffsetArrayOf<TSubTable>& out_subtables = out->get_subtables<TSubTable> ();\n+    unsigned int count = subTable.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      SubTableSubsetWrapper<TSubTable> wrapper (this+subtables[i], get_type ());\n+\n+      out_subtables[i].serialize_subset (c, wrapper, out);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  \/* Older compilers need this to NOT be locally defined in a function. *\/\n+  template <typename TSubTable>\n+  struct SubTableSanitizeWrapper : TSubTable\n+  {\n+    bool sanitize (hb_sanitize_context_t *c, unsigned int lookup_type) const\n+    { return this->dispatch (c, lookup_type); }\n+  };\n+\n+  template <typename TSubTable>\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(c->check_struct (this) && subTable.sanitize (c))) return_trace (false);\n+    if (lookupFlag & LookupFlag::UseMarkFilteringSet)\n+    {\n+      const HBUINT16 &markFilteringSet = StructAfter<HBUINT16> (subTable);\n+      if (!markFilteringSet.sanitize (c)) return_trace (false);\n+    }\n+\n+    if (unlikely (!CastR<OffsetArrayOf<SubTableSanitizeWrapper<TSubTable> > > (subTable)\n+                   .sanitize (c, this, get_type ())))\n+      return_trace (false);\n+\n+    if (unlikely (get_type () == TSubTable::Extension))\n+    {\n+      \/* The spec says all subtables of an Extension lookup should\n+       * have the same type, which shall not be the Extension type\n+       * itself (but we already checked for that).\n+       * This is specially important if one has a reverse type! *\/\n+      unsigned int type = get_subtable<TSubTable> (0).u.extension.get_type ();\n+      unsigned int count = get_subtable_count ();\n+      for (unsigned int i = 1; i < count; i++)\n+        if (get_subtable<TSubTable> (i).u.extension.get_type () != type)\n+          return_trace (false);\n+    }\n+    return_trace (true);\n+    return_trace (true);\n+  }\n+\n+  private:\n+  HBUINT16      lookupType;             \/* Different enumerations for GSUB and GPOS *\/\n+  HBUINT16      lookupFlag;             \/* Lookup qualifiers *\/\n+  ArrayOf<Offset16>\n+                subTable;               \/* Array of SubTables *\/\n+\/*HBUINT16      markFilteringSetX[VAR];*\/\/* Index (base 0) into GDEF mark glyph sets\n+                                         * structure. This field is only present if bit\n+                                         * UseMarkFilteringSet of lookup flags is set. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, subTable);\n+};\n+\n+typedef OffsetListOf<Lookup> LookupList;\n+\n+\n+\/*\n+ * Coverage Table\n+ *\/\n+\n+struct CoverageFormat1\n+{\n+  friend struct Coverage;\n+\n+  private:\n+  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  {\n+    unsigned int i;\n+    glyphArray.bfind (glyph_id, &i, HB_BFIND_NOT_FOUND_STORE, NOT_COVERED);\n+    return i;\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (glyphArray.serialize (c, glyphs));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (glyphArray.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    \/* TODO Speed up, using hb_set_next() and bsearch()? *\/\n+    unsigned int count = glyphArray.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (glyphs->has (glyphArray[i]))\n+        return true;\n+    return false;\n+  }\n+  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+  { return glyphs->has (glyphArray[index]); }\n+\n+  template <typename set_t>\n+  bool add_coverage (set_t *glyphs) const\n+  {\n+    return glyphs->add_sorted_array (glyphArray.arrayZ, glyphArray.len);\n+  }\n+\n+  public:\n+  \/* Older compilers need this to be public. *\/\n+  struct Iter {\n+    void init (const struct CoverageFormat1 &c_) { c = &c_; i = 0; }\n+    void fini () {}\n+    bool more () { return i < c->glyphArray.len; }\n+    void next () { i++; }\n+    hb_codepoint_t get_glyph () { return c->glyphArray[i]; }\n+    unsigned int get_coverage () { return i; }\n+\n+    private:\n+    const struct CoverageFormat1 *c;\n+    unsigned int i;\n+  };\n+  private:\n+\n+  protected:\n+  HBUINT16      coverageFormat; \/* Format identifier--format = 1 *\/\n+  SortedArrayOf<GlyphID>\n+                glyphArray;     \/* Array of GlyphIDs--in numerical order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, glyphArray);\n+};\n+\n+struct CoverageFormat2\n+{\n+  friend struct Coverage;\n+\n+  private:\n+  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  {\n+    const RangeRecord &range = rangeRecord.bsearch (glyph_id);\n+    return likely (range.start <= range.end) ?\n+           (unsigned int) range.value + (glyph_id - range.start) :\n+           NOT_COVERED;\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+\n+    if (unlikely (!glyphs.length))\n+    {\n+      rangeRecord.len.set (0);\n+      return_trace (true);\n+    }\n+\n+    unsigned int num_ranges = 1;\n+    for (unsigned int i = 1; i < glyphs.length; i++)\n+      if (glyphs[i - 1] + 1 != glyphs[i])\n+        num_ranges++;\n+    rangeRecord.len.set (num_ranges);\n+    if (unlikely (!c->extend (rangeRecord))) return_trace (false);\n+\n+    unsigned int range = 0;\n+    rangeRecord[range].start = glyphs[0];\n+    rangeRecord[range].value.set (0);\n+    for (unsigned int i = 1; i < glyphs.length; i++)\n+    {\n+      if (glyphs[i - 1] + 1 != glyphs[i])\n+      {\n+        range++;\n+        rangeRecord[range].start = glyphs[i];\n+        rangeRecord[range].value.set (i);\n+      }\n+      rangeRecord[range].end = glyphs[i];\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (rangeRecord.sanitize (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    \/* TODO Speed up, using hb_set_next() and bsearch()? *\/\n+    unsigned int count = rangeRecord.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (rangeRecord[i].intersects (glyphs))\n+        return true;\n+    return false;\n+  }\n+  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+  {\n+    unsigned int i;\n+    unsigned int count = rangeRecord.len;\n+    for (i = 0; i < count; i++) {\n+      const RangeRecord &range = rangeRecord[i];\n+      if (range.value <= index &&\n+          index < (unsigned int) range.value + (range.end - range.start) &&\n+          range.intersects (glyphs))\n+        return true;\n+      else if (index < range.value)\n+        return false;\n+    }\n+    return false;\n+  }\n+\n+  template <typename set_t>\n+  bool add_coverage (set_t *glyphs) const\n+  {\n+    unsigned int count = rangeRecord.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!rangeRecord[i].add_coverage (glyphs)))\n+        return false;\n+    return true;\n+  }\n+\n+  public:\n+  \/* Older compilers need this to be public. *\/\n+  struct Iter\n+  {\n+    void init (const CoverageFormat2 &c_)\n+    {\n+      c = &c_;\n+      coverage = 0;\n+      i = 0;\n+      j = c->rangeRecord.len ? c->rangeRecord[0].start : 0;\n+      if (unlikely (c->rangeRecord[0].start > c->rangeRecord[0].end))\n+      {\n+        \/* Broken table. Skip. *\/\n+        i = c->rangeRecord.len;\n+      }\n+    }\n+    void fini () {}\n+    bool more () { return i < c->rangeRecord.len; }\n+    void next ()\n+    {\n+      if (j >= c->rangeRecord[i].end)\n+      {\n+        i++;\n+        if (more ())\n+        {\n+          hb_codepoint_t old = j;\n+          j = c->rangeRecord[i].start;\n+          if (unlikely (j <= old))\n+          {\n+            \/* Broken table. Skip. Important to avoid DoS. *\/\n+           i = c->rangeRecord.len;\n+           return;\n+          }\n+          coverage = c->rangeRecord[i].value;\n+        }\n+        return;\n+      }\n+      coverage++;\n+      j++;\n+    }\n+    hb_codepoint_t get_glyph () { return j; }\n+    unsigned int get_coverage () { return coverage; }\n+\n+    private:\n+    const struct CoverageFormat2 *c;\n+    unsigned int i, coverage;\n+    hb_codepoint_t j;\n+  };\n+  private:\n+\n+  protected:\n+  HBUINT16      coverageFormat; \/* Format identifier--format = 2 *\/\n+  SortedArrayOf<RangeRecord>\n+                rangeRecord;    \/* Array of glyph ranges--ordered by\n+                                 * Start GlyphID. rangeCount entries\n+                                 * long *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, rangeRecord);\n+};\n+\n+struct Coverage\n+{\n+  unsigned int get_coverage (hb_codepoint_t glyph_id) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_coverage (glyph_id);\n+    case 2: return u.format2.get_coverage (glyph_id);\n+    default:return NOT_COVERED;\n+    }\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+\n+    unsigned int num_ranges = 1;\n+    for (unsigned int i = 1; i < glyphs.length; i++)\n+      if (glyphs[i - 1] + 1 != glyphs[i])\n+        num_ranges++;\n+    u.format.set (glyphs.length * 2 < num_ranges * 3 ? 1 : 2);\n+\n+    switch (u.format)\n+    {\n+    case 1: return_trace (u.format1.serialize (c, glyphs));\n+    case 2: return_trace (u.format2.serialize (c, glyphs));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format)\n+    {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.intersects (glyphs);\n+    case 2: return u.format2.intersects (glyphs);\n+    default:return false;\n+    }\n+  }\n+  bool intersects_coverage (const hb_set_t *glyphs, unsigned int index) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.intersects_coverage (glyphs, index);\n+    case 2: return u.format2.intersects_coverage (glyphs, index);\n+    default:return false;\n+    }\n+  }\n+\n+  \/* Might return false if array looks unsorted.\n+   * Used for faster rejection of corrupt data. *\/\n+  template <typename set_t>\n+  bool add_coverage (set_t *glyphs) const\n+  {\n+    switch (u.format)\n+    {\n+    case 1: return u.format1.add_coverage (glyphs);\n+    case 2: return u.format2.add_coverage (glyphs);\n+    default:return false;\n+    }\n+  }\n+\n+  struct Iter\n+  {\n+    Iter (const Coverage &c_)\n+    {\n+      memset (this, 0, sizeof (*this));\n+      format = c_.u.format;\n+      switch (format)\n+      {\n+      case 1: u.format1.init (c_.u.format1); return;\n+      case 2: u.format2.init (c_.u.format2); return;\n+      default:                               return;\n+      }\n+    }\n+    bool more ()\n+    {\n+      switch (format)\n+      {\n+      case 1: return u.format1.more ();\n+      case 2: return u.format2.more ();\n+      default:return false;\n+      }\n+    }\n+    void next ()\n+    {\n+      switch (format)\n+      {\n+      case 1: u.format1.next (); break;\n+      case 2: u.format2.next (); break;\n+      default:                   break;\n+      }\n+    }\n+    hb_codepoint_t get_glyph ()\n+    {\n+      switch (format)\n+      {\n+      case 1: return u.format1.get_glyph ();\n+      case 2: return u.format2.get_glyph ();\n+      default:return 0;\n+      }\n+    }\n+    unsigned int get_coverage ()\n+    {\n+      switch (format)\n+      {\n+      case 1: return u.format1.get_coverage ();\n+      case 2: return u.format2.get_coverage ();\n+      default:return -1;\n+      }\n+    }\n+\n+    private:\n+    unsigned int format;\n+    union {\n+    CoverageFormat2::Iter       format2; \/* Put this one first since it's larger; helps shut up compiler. *\/\n+    CoverageFormat1::Iter       format1;\n+    } u;\n+  };\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  CoverageFormat1       format1;\n+  CoverageFormat2       format2;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+\n+\/*\n+ * Class Definition Table\n+ *\/\n+\n+static inline void ClassDef_serialize (hb_serialize_context_t *c,\n+                                       hb_array_t<const GlyphID> glyphs,\n+                                       hb_array_t<const HBUINT16> klasses);\n+\n+struct ClassDefFormat1\n+{\n+  friend struct ClassDef;\n+\n+  private:\n+  unsigned int get_class (hb_codepoint_t glyph_id) const\n+  {\n+    return classValue[(unsigned int) (glyph_id - startGlyph)];\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const HBUINT16> glyphs,\n+                  hb_array_t<const HBUINT16> klasses)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+\n+    if (unlikely (!glyphs.length))\n+    {\n+      startGlyph.set (0);\n+      classValue.len.set (0);\n+      return_trace (true);\n+    }\n+\n+    hb_codepoint_t glyph_min = glyphs[0];\n+    hb_codepoint_t glyph_max = glyphs[glyphs.length - 1];\n+\n+    startGlyph.set (glyph_min);\n+    classValue.len.set (glyph_max - glyph_min + 1);\n+    if (unlikely (!c->extend (classValue))) return_trace (false);\n+\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+      classValue[glyphs[i] - glyph_min] = klasses[i];\n+\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+    hb_vector_t<GlyphID> glyphs;\n+    hb_vector_t<HBUINT16> klasses;\n+\n+    hb_codepoint_t start = startGlyph;\n+    hb_codepoint_t end   = start + classValue.len;\n+    for (hb_codepoint_t g = start; g < end; g++)\n+    {\n+      unsigned int value = classValue[g - start];\n+      if (!value) continue;\n+      if (!glyphset.has (g)) continue;\n+      glyphs.push()->set (glyph_map[g]);\n+      klasses.push()->set (value);\n+    }\n+    c->serializer->propagate_error (glyphs, klasses);\n+    ClassDef_serialize (c->serializer, glyphs, klasses);\n+    return_trace (glyphs.length);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && classValue.sanitize (c));\n+  }\n+\n+  template <typename set_t>\n+  bool add_coverage (set_t *glyphs) const\n+  {\n+    unsigned int start = 0;\n+    unsigned int count = classValue.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (classValue[i])\n+        continue;\n+\n+      if (start != i)\n+        if (unlikely (!glyphs->add_range (startGlyph + start, startGlyph + i)))\n+          return false;\n+\n+      start = i + 1;\n+    }\n+    if (start != count)\n+      if (unlikely (!glyphs->add_range (startGlyph + start, startGlyph + count)))\n+        return false;\n+\n+    return true;\n+  }\n+\n+  template <typename set_t>\n+  bool add_class (set_t *glyphs, unsigned int klass) const\n+  {\n+    unsigned int count = classValue.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (classValue[i] == klass) glyphs->add (startGlyph + i);\n+    return true;\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    \/* TODO Speed up, using hb_set_next()? *\/\n+    hb_codepoint_t start = startGlyph;\n+    hb_codepoint_t end = startGlyph + classValue.len;\n+    for (hb_codepoint_t iter = startGlyph - 1;\n+         hb_set_next (glyphs, &iter) && iter < end;)\n+      if (classValue[iter - start]) return true;\n+    return false;\n+  }\n+  bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const\n+  {\n+    unsigned int count = classValue.len;\n+    if (klass == 0)\n+    {\n+      \/* Match if there's any glyph that is not listed! *\/\n+      hb_codepoint_t g = HB_SET_VALUE_INVALID;\n+      if (!hb_set_next (glyphs, &g)) return false;\n+      if (g < startGlyph) return true;\n+      g = startGlyph + count - 1;\n+      if (hb_set_next (glyphs, &g)) return true;\n+      \/* Fall through. *\/\n+    }\n+    for (unsigned int i = 0; i < count; i++)\n+      if (classValue[i] == klass && glyphs->has (startGlyph + i))\n+        return true;\n+    return false;\n+  }\n+\n+  protected:\n+  HBUINT16      classFormat;    \/* Format identifier--format = 1 *\/\n+  GlyphID       startGlyph;     \/* First GlyphID of the classValueArray *\/\n+  ArrayOf<HBUINT16>\n+                classValue;     \/* Array of Class Values--one per GlyphID *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, classValue);\n+};\n+\n+struct ClassDefFormat2\n+{\n+  friend struct ClassDef;\n+\n+  private:\n+  unsigned int get_class (hb_codepoint_t glyph_id) const\n+  {\n+    return rangeRecord.bsearch (glyph_id).value;\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const HBUINT16> glyphs,\n+                  hb_array_t<const HBUINT16> klasses)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+\n+    if (unlikely (!glyphs.length))\n+    {\n+      rangeRecord.len.set (0);\n+      return_trace (true);\n+    }\n+\n+    unsigned int num_ranges = 1;\n+    for (unsigned int i = 1; i < glyphs.length; i++)\n+      if (glyphs[i - 1] + 1 != glyphs[i] ||\n+          klasses[i - 1] != klasses[i])\n+        num_ranges++;\n+    rangeRecord.len.set (num_ranges);\n+    if (unlikely (!c->extend (rangeRecord))) return_trace (false);\n+\n+    unsigned int range = 0;\n+    rangeRecord[range].start = glyphs[0];\n+    rangeRecord[range].value.set (klasses[0]);\n+    for (unsigned int i = 1; i < glyphs.length; i++)\n+    {\n+      if (glyphs[i - 1] + 1 != glyphs[i] ||\n+          klasses[i - 1] != klasses[i])\n+      {\n+        range++;\n+        rangeRecord[range].start = glyphs[i];\n+        rangeRecord[range].value = klasses[i];\n+      }\n+      rangeRecord[range].end = glyphs[i];\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+    hb_vector_t<GlyphID> glyphs;\n+    hb_vector_t<HBUINT16> klasses;\n+\n+    unsigned int count = rangeRecord.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      unsigned int value = rangeRecord[i].value;\n+      if (!value) continue;\n+      hb_codepoint_t start = rangeRecord[i].start;\n+      hb_codepoint_t end   = rangeRecord[i].end + 1;\n+      for (hb_codepoint_t g = start; g < end; g++)\n+      {\n+        if (!glyphset.has (g)) continue;\n+        glyphs.push ()->set (glyph_map[g]);\n+        klasses.push ()->set (value);\n+      }\n+    }\n+    c->serializer->propagate_error (glyphs, klasses);\n+    ClassDef_serialize (c->serializer, glyphs, klasses);\n+    return_trace (glyphs.length);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (rangeRecord.sanitize (c));\n+  }\n+\n+  template <typename set_t>\n+  bool add_coverage (set_t *glyphs) const\n+  {\n+    unsigned int count = rangeRecord.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (rangeRecord[i].value)\n+        if (unlikely (!rangeRecord[i].add_coverage (glyphs)))\n+          return false;\n+    return true;\n+  }\n+\n+  template <typename set_t>\n+  bool add_class (set_t *glyphs, unsigned int klass) const\n+  {\n+    unsigned int count = rangeRecord.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (rangeRecord[i].value == klass)\n+        if (unlikely (!rangeRecord[i].add_coverage (glyphs)))\n+          return false;\n+    }\n+    return true;\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    \/* TODO Speed up, using hb_set_next() and bsearch()? *\/\n+    unsigned int count = rangeRecord.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (rangeRecord[i].intersects (glyphs))\n+        return true;\n+    return false;\n+  }\n+  bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const\n+  {\n+    unsigned int count = rangeRecord.len;\n+    if (klass == 0)\n+    {\n+      \/* Match if there's any glyph that is not listed! *\/\n+      hb_codepoint_t g = HB_SET_VALUE_INVALID;\n+      for (unsigned int i = 0; i < count; i++)\n+      {\n+        if (!hb_set_next (glyphs, &g))\n+          break;\n+        if (g < rangeRecord[i].start)\n+          return true;\n+        g = rangeRecord[i].end;\n+      }\n+      if (g != HB_SET_VALUE_INVALID && hb_set_next (glyphs, &g))\n+        return true;\n+      \/* Fall through. *\/\n+    }\n+    for (unsigned int i = 0; i < count; i++)\n+      if (rangeRecord[i].value == klass && rangeRecord[i].intersects (glyphs))\n+        return true;\n+    return false;\n+  }\n+\n+  protected:\n+  HBUINT16      classFormat;    \/* Format identifier--format = 2 *\/\n+  SortedArrayOf<RangeRecord>\n+                rangeRecord;    \/* Array of glyph ranges--ordered by\n+                                 * Start GlyphID *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, rangeRecord);\n+};\n+\n+struct ClassDef\n+{\n+  unsigned int get_class (hb_codepoint_t glyph_id) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_class (glyph_id);\n+    case 2: return u.format2.get_class (glyph_id);\n+    default:return 0;\n+    }\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  hb_array_t<const HBUINT16> klasses)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+\n+    unsigned int format = 2;\n+    if (glyphs.length)\n+    {\n+      hb_codepoint_t glyph_min = glyphs[0];\n+      hb_codepoint_t glyph_max = glyphs[glyphs.length - 1];\n+\n+      unsigned int num_ranges = 1;\n+      for (unsigned int i = 1; i < glyphs.length; i++)\n+        if (glyphs[i - 1] + 1 != glyphs[i] ||\n+            klasses[i - 1] != klasses[i])\n+          num_ranges++;\n+\n+      if (1 + (glyph_max - glyph_min + 1) < num_ranges * 3)\n+        format = 1;\n+    }\n+    u.format.set (format);\n+\n+    switch (u.format)\n+    {\n+    case 1: return_trace (u.format1.serialize (c, glyphs, klasses));\n+    case 2: return_trace (u.format2.serialize (c, glyphs, klasses));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.subset (c));\n+    case 2: return_trace (u.format2.subset (c));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  \/* Might return false if array looks unsorted.\n+   * Used for faster rejection of corrupt data. *\/\n+  template <typename set_t>\n+  bool add_coverage (set_t *glyphs) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.add_coverage (glyphs);\n+    case 2: return u.format2.add_coverage (glyphs);\n+    default:return false;\n+    }\n+  }\n+\n+  \/* Might return false if array looks unsorted.\n+   * Used for faster rejection of corrupt data. *\/\n+  template <typename set_t>\n+  bool add_class (set_t *glyphs, unsigned int klass) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.add_class (glyphs, klass);\n+    case 2: return u.format2.add_class (glyphs, klass);\n+    default:return false;\n+    }\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.intersects (glyphs);\n+    case 2: return u.format2.intersects (glyphs);\n+    default:return false;\n+    }\n+  }\n+  bool intersects_class (const hb_set_t *glyphs, unsigned int klass) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.intersects_class (glyphs, klass);\n+    case 2: return u.format2.intersects_class (glyphs, klass);\n+    default:return false;\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  ClassDefFormat1       format1;\n+  ClassDefFormat2       format2;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+static inline void ClassDef_serialize (hb_serialize_context_t *c,\n+                                       hb_array_t<const GlyphID> glyphs,\n+                                       hb_array_t<const HBUINT16> klasses)\n+{ c->start_embed<ClassDef> ()->serialize (c, glyphs, klasses); }\n+\n+\n+\/*\n+ * Item Variation Store\n+ *\/\n+\n+struct VarRegionAxis\n+{\n+  float evaluate (int coord) const\n+  {\n+    int start = startCoord, peak = peakCoord, end = endCoord;\n+\n+    \/* TODO Move these to sanitize(). *\/\n+    if (unlikely (start > peak || peak > end))\n+      return 1.;\n+    if (unlikely (start < 0 && end > 0 && peak != 0))\n+      return 1.;\n+\n+    if (peak == 0 || coord == peak)\n+      return 1.;\n+\n+    if (coord <= start || end <= coord)\n+      return 0.;\n+\n+    \/* Interpolate *\/\n+    if (coord < peak)\n+      return float (coord - start) \/ (peak - start);\n+    else\n+      return float (end - coord) \/ (end - peak);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+    \/* TODO Handle invalid start\/peak\/end configs, so we don't\n+     * have to do that at runtime. *\/\n+  }\n+\n+  public:\n+  F2DOT14       startCoord;\n+  F2DOT14       peakCoord;\n+  F2DOT14       endCoord;\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct VarRegionList\n+{\n+  float evaluate (unsigned int region_index,\n+                         const int *coords, unsigned int coord_len) const\n+  {\n+    if (unlikely (region_index >= regionCount))\n+      return 0.;\n+\n+    const VarRegionAxis *axes = axesZ.arrayZ + (region_index * axisCount);\n+\n+    float v = 1.;\n+    unsigned int count = axisCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      int coord = i < coord_len ? coords[i] : 0;\n+      float factor = axes[i].evaluate (coord);\n+      if (factor == 0.f)\n+        return 0.;\n+      v *= factor;\n+    }\n+    return v;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  axesZ.sanitize (c, (unsigned int) axisCount * (unsigned int) regionCount));\n+  }\n+\n+  unsigned int get_region_count () const { return regionCount; }\n+\n+  protected:\n+  HBUINT16      axisCount;\n+  HBUINT16      regionCount;\n+  UnsizedArrayOf<VarRegionAxis>\n+                axesZ;\n+  public:\n+  DEFINE_SIZE_ARRAY (4, axesZ);\n+};\n+\n+struct VarData\n+{\n+  unsigned int get_region_index_count () const\n+  { return regionIndices.len; }\n+\n+  unsigned int get_row_size () const\n+  { return shortCount + regionIndices.len; }\n+\n+  unsigned int get_size () const\n+  { return itemCount * get_row_size (); }\n+\n+  float get_delta (unsigned int inner,\n+                          const int *coords, unsigned int coord_count,\n+                          const VarRegionList &regions) const\n+  {\n+    if (unlikely (inner >= itemCount))\n+      return 0.;\n+\n+   unsigned int count = regionIndices.len;\n+   unsigned int scount = shortCount;\n+\n+   const HBUINT8 *bytes = &StructAfter<HBUINT8> (regionIndices);\n+   const HBUINT8 *row = bytes + inner * (scount + count);\n+\n+   float delta = 0.;\n+   unsigned int i = 0;\n+\n+   const HBINT16 *scursor = reinterpret_cast<const HBINT16 *> (row);\n+   for (; i < scount; i++)\n+   {\n+     float scalar = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count);\n+     delta += scalar * *scursor++;\n+   }\n+   const HBINT8 *bcursor = reinterpret_cast<const HBINT8 *> (scursor);\n+   for (; i < count; i++)\n+   {\n+     float scalar = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count);\n+     delta += scalar * *bcursor++;\n+   }\n+\n+   return delta;\n+  }\n+\n+  void get_scalars (int *coords, unsigned int coord_count,\n+                    const VarRegionList &regions,\n+                    float *scalars \/*OUT *\/,\n+                    unsigned int num_scalars) const\n+  {\n+    assert (num_scalars == regionIndices.len);\n+   for (unsigned int i = 0; i < num_scalars; i++)\n+   {\n+     scalars[i] = regions.evaluate (regionIndices.arrayZ[i], coords, coord_count);\n+   }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  regionIndices.sanitize (c) &&\n+                  shortCount <= regionIndices.len &&\n+                  c->check_range (&StructAfter<HBUINT8> (regionIndices),\n+                                  itemCount,\n+                                  get_row_size ()));\n+  }\n+\n+  protected:\n+  HBUINT16              itemCount;\n+  HBUINT16              shortCount;\n+  ArrayOf<HBUINT16>     regionIndices;\n+\/*UnsizedArrayOf<HBUINT8>bytesX;*\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, regionIndices);\n+};\n+\n+struct VariationStore\n+{\n+  float get_delta (unsigned int outer, unsigned int inner,\n+                   const int *coords, unsigned int coord_count) const\n+  {\n+    if (unlikely (outer >= dataSets.len))\n+      return 0.;\n+\n+    return (this+dataSets[outer]).get_delta (inner,\n+                                             coords, coord_count,\n+                                             this+regions);\n+  }\n+\n+  float get_delta (unsigned int index,\n+                   const int *coords, unsigned int coord_count) const\n+  {\n+    unsigned int outer = index >> 16;\n+    unsigned int inner = index & 0xFFFF;\n+    return get_delta (outer, inner, coords, coord_count);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  format == 1 &&\n+                  regions.sanitize (c, this) &&\n+                  dataSets.sanitize (c, this));\n+  }\n+\n+  unsigned int get_region_index_count (unsigned int ivs) const\n+  { return (this+dataSets[ivs]).get_region_index_count (); }\n+\n+  void get_scalars (unsigned int ivs,\n+                    int *coords, unsigned int coord_count,\n+                    float *scalars \/*OUT*\/,\n+                    unsigned int num_scalars) const\n+  {\n+    (this+dataSets[ivs]).get_scalars (coords, coord_count, this+regions,\n+                                      &scalars[0], num_scalars);\n+  }\n+\n+  protected:\n+  HBUINT16                              format;\n+  LOffsetTo<VarRegionList>              regions;\n+  LOffsetArrayOf<VarData>               dataSets;\n+  public:\n+  DEFINE_SIZE_ARRAY (8, dataSets);\n+};\n+\n+\/*\n+ * Feature Variations\n+ *\/\n+\n+struct ConditionFormat1\n+{\n+  friend struct Condition;\n+\n+  private:\n+  bool evaluate (const int *coords, unsigned int coord_len) const\n+  {\n+    int coord = axisIndex < coord_len ? coords[axisIndex] : 0;\n+    return filterRangeMinValue <= coord && coord <= filterRangeMaxValue;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier--format = 1 *\/\n+  HBUINT16      axisIndex;\n+  F2DOT14       filterRangeMinValue;\n+  F2DOT14       filterRangeMaxValue;\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct Condition\n+{\n+  bool evaluate (const int *coords, unsigned int coord_len) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.evaluate (coords, coord_len);\n+    default:return false;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  ConditionFormat1      format1;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+struct ConditionSet\n+{\n+  bool evaluate (const int *coords, unsigned int coord_len) const\n+  {\n+    unsigned int count = conditions.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!(this+conditions.arrayZ[i]).evaluate (coords, coord_len))\n+        return false;\n+    return true;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (conditions.sanitize (c, this));\n+  }\n+\n+  protected:\n+  LOffsetArrayOf<Condition>     conditions;\n+  public:\n+  DEFINE_SIZE_ARRAY (2, conditions);\n+};\n+\n+struct FeatureTableSubstitutionRecord\n+{\n+  friend struct FeatureTableSubstitution;\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && feature.sanitize (c, base));\n+  }\n+\n+  protected:\n+  HBUINT16              featureIndex;\n+  LOffsetTo<Feature>    feature;\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct FeatureTableSubstitution\n+{\n+  const Feature *find_substitute (unsigned int feature_index) const\n+  {\n+    unsigned int count = substitutions.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      const FeatureTableSubstitutionRecord &record = substitutions.arrayZ[i];\n+      if (record.featureIndex == feature_index)\n+        return &(this+record.feature);\n+    }\n+    return nullptr;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  substitutions.sanitize (c, this));\n+  }\n+\n+  protected:\n+  FixedVersion<>        version;        \/* Version--0x00010000u *\/\n+  ArrayOf<FeatureTableSubstitutionRecord>\n+                        substitutions;\n+  public:\n+  DEFINE_SIZE_ARRAY (6, substitutions);\n+};\n+\n+struct FeatureVariationRecord\n+{\n+  friend struct FeatureVariations;\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (conditions.sanitize (c, base) &&\n+                  substitutions.sanitize (c, base));\n+  }\n+\n+  protected:\n+  LOffsetTo<ConditionSet>\n+                        conditions;\n+  LOffsetTo<FeatureTableSubstitution>\n+                        substitutions;\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct FeatureVariations\n+{\n+  static constexpr unsigned NOT_FOUND_INDEX = 0xFFFFFFFFu;\n+\n+  bool find_index (const int *coords, unsigned int coord_len,\n+                          unsigned int *index) const\n+  {\n+    unsigned int count = varRecords.len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      const FeatureVariationRecord &record = varRecords.arrayZ[i];\n+      if ((this+record.conditions).evaluate (coords, coord_len))\n+      {\n+        *index = i;\n+        return true;\n+      }\n+    }\n+    *index = NOT_FOUND_INDEX;\n+    return false;\n+  }\n+\n+  const Feature *find_substitute (unsigned int variations_index,\n+                                  unsigned int feature_index) const\n+  {\n+    const FeatureVariationRecord &record = varRecords[variations_index];\n+    return (this+record.substitutions).find_substitute (feature_index);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    return_trace (c->serializer->embed (*this));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  varRecords.sanitize (c, this));\n+  }\n+\n+  protected:\n+  FixedVersion<>        version;        \/* Version--0x00010000u *\/\n+  LArrayOf<FeatureVariationRecord>\n+                        varRecords;\n+  public:\n+  DEFINE_SIZE_ARRAY_SIZED (8, varRecords);\n+};\n+\n+\n+\/*\n+ * Device Tables\n+ *\/\n+\n+struct HintingDevice\n+{\n+  friend struct Device;\n+\n+  private:\n+\n+  hb_position_t get_x_delta (hb_font_t *font) const\n+  { return get_delta (font->x_ppem, font->x_scale); }\n+\n+  hb_position_t get_y_delta (hb_font_t *font) const\n+  { return get_delta (font->y_ppem, font->y_scale); }\n+\n+  unsigned int get_size () const\n+  {\n+    unsigned int f = deltaFormat;\n+    if (unlikely (f < 1 || f > 3 || startSize > endSize)) return 3 * HBUINT16::static_size;\n+    return HBUINT16::static_size * (4 + ((endSize - startSize) >> (4 - f)));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && c->check_range (this, this->get_size ()));\n+  }\n+\n+  private:\n+\n+  int get_delta (unsigned int ppem, int scale) const\n+  {\n+    if (!ppem) return 0;\n+\n+    int pixels = get_delta_pixels (ppem);\n+\n+    if (!pixels) return 0;\n+\n+    return (int) (pixels * (int64_t) scale \/ ppem);\n+  }\n+  int get_delta_pixels (unsigned int ppem_size) const\n+  {\n+    unsigned int f = deltaFormat;\n+    if (unlikely (f < 1 || f > 3))\n+      return 0;\n+\n+    if (ppem_size < startSize || ppem_size > endSize)\n+      return 0;\n+\n+    unsigned int s = ppem_size - startSize;\n+\n+    unsigned int byte = deltaValueZ[s >> (4 - f)];\n+    unsigned int bits = (byte >> (16 - (((s & ((1 << (4 - f)) - 1)) + 1) << f)));\n+    unsigned int mask = (0xFFFFu >> (16 - (1 << f)));\n+\n+    int delta = bits & mask;\n+\n+    if ((unsigned int) delta >= ((mask + 1) >> 1))\n+      delta -= mask + 1;\n+\n+    return delta;\n+  }\n+\n+  protected:\n+  HBUINT16      startSize;              \/* Smallest size to correct--in ppem *\/\n+  HBUINT16      endSize;                \/* Largest size to correct--in ppem *\/\n+  HBUINT16      deltaFormat;            \/* Format of DeltaValue array data: 1, 2, or 3\n+                                         * 1    Signed 2-bit value, 8 values per uint16\n+                                         * 2    Signed 4-bit value, 4 values per uint16\n+                                         * 3    Signed 8-bit value, 2 values per uint16\n+                                         *\/\n+  UnsizedArrayOf<HBUINT16>\n+                deltaValueZ;            \/* Array of compressed data *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, deltaValueZ);\n+};\n+\n+struct VariationDevice\n+{\n+  friend struct Device;\n+\n+  private:\n+\n+  hb_position_t get_x_delta (hb_font_t *font, const VariationStore &store) const\n+  { return font->em_scalef_x (get_delta (font, store)); }\n+\n+  hb_position_t get_y_delta (hb_font_t *font, const VariationStore &store) const\n+  { return font->em_scalef_y (get_delta (font, store)); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  private:\n+\n+  float get_delta (hb_font_t *font, const VariationStore &store) const\n+  {\n+    return store.get_delta (outerIndex, innerIndex, font->coords, font->num_coords);\n+  }\n+\n+  protected:\n+  HBUINT16      outerIndex;\n+  HBUINT16      innerIndex;\n+  HBUINT16      deltaFormat;    \/* Format identifier for this table: 0x0x8000 *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct DeviceHeader\n+{\n+  protected:\n+  HBUINT16              reserved1;\n+  HBUINT16              reserved2;\n+  public:\n+  HBUINT16              format;         \/* Format identifier *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct Device\n+{\n+  hb_position_t get_x_delta (hb_font_t *font, const VariationStore &store=Null (VariationStore)) const\n+  {\n+    switch (u.b.format)\n+    {\n+    case 1: case 2: case 3:\n+      return u.hinting.get_x_delta (font);\n+    case 0x8000:\n+      return u.variation.get_x_delta (font, store);\n+    default:\n+      return 0;\n+    }\n+  }\n+  hb_position_t get_y_delta (hb_font_t *font, const VariationStore &store=Null (VariationStore)) const\n+  {\n+    switch (u.b.format)\n+    {\n+    case 1: case 2: case 3:\n+      return u.hinting.get_y_delta (font);\n+    case 0x8000:\n+      return u.variation.get_y_delta (font, store);\n+    default:\n+      return 0;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.b.format.sanitize (c)) return_trace (false);\n+    switch (u.b.format) {\n+    case 1: case 2: case 3:\n+      return_trace (u.hinting.sanitize (c));\n+    case 0x8000:\n+      return_trace (u.variation.sanitize (c));\n+    default:\n+      return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  DeviceHeader          b;\n+  HintingDevice         hinting;\n+  VariationDevice       variation;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (6, b);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_LAYOUT_COMMON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout-common.hh","additions":2178,"deletions":0,"binary":false,"changes":2178,"status":"added"},{"patch":"@@ -0,0 +1,510 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2010,2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_GDEF_TABLE_HH\n+#define HB_OT_LAYOUT_GDEF_TABLE_HH\n+\n+#include \"hb-ot-layout-common.hh\"\n+\n+#include \"hb-font.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/*\n+ * Attachment List Table\n+ *\/\n+\n+typedef ArrayOf<HBUINT16> AttachPoint;  \/* Array of contour point indices--in\n+                                         * increasing numerical order *\/\n+\n+struct AttachList\n+{\n+  unsigned int get_attach_points (hb_codepoint_t glyph_id,\n+                                  unsigned int start_offset,\n+                                  unsigned int *point_count \/* IN\/OUT *\/,\n+                                  unsigned int *point_array \/* OUT *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (index == NOT_COVERED)\n+    {\n+      if (point_count)\n+        *point_count = 0;\n+      return 0;\n+    }\n+\n+    const AttachPoint &points = this+attachPoint[index];\n+\n+    if (point_count)\n+    {\n+      hb_array_t<const HBUINT16> array = points.sub_array (start_offset, point_count);\n+      unsigned int count = array.length;\n+      for (unsigned int i = 0; i < count; i++)\n+        point_array[i] = array[i];\n+    }\n+\n+    return points.len;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && attachPoint.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table -- from\n+                                         * beginning of AttachList table *\/\n+  OffsetArrayOf<AttachPoint>\n+                attachPoint;            \/* Array of AttachPoint tables\n+                                         * in Coverage Index order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, attachPoint);\n+};\n+\n+\/*\n+ * Ligature Caret Table\n+ *\/\n+\n+struct CaretValueFormat1\n+{\n+  friend struct CaretValue;\n+\n+  private:\n+  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction) const\n+  {\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ? font->em_scale_x (coordinate) : font->em_scale_y (coordinate);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      caretValueFormat;       \/* Format identifier--format = 1 *\/\n+  FWORD         coordinate;             \/* X or Y value, in design units *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct CaretValueFormat2\n+{\n+  friend struct CaretValue;\n+\n+  private:\n+  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction, hb_codepoint_t glyph_id) const\n+  {\n+    hb_position_t x, y;\n+    font->get_glyph_contour_point_for_origin (glyph_id, caretValuePoint, direction, &x, &y);\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ? x : y;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      caretValueFormat;       \/* Format identifier--format = 2 *\/\n+  HBUINT16      caretValuePoint;        \/* Contour point index on glyph *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct CaretValueFormat3\n+{\n+  friend struct CaretValue;\n+\n+  hb_position_t get_caret_value (hb_font_t *font, hb_direction_t direction,\n+                                 const VariationStore &var_store) const\n+  {\n+    return HB_DIRECTION_IS_HORIZONTAL (direction) ?\n+           font->em_scale_x (coordinate) + (this+deviceTable).get_x_delta (font, var_store) :\n+           font->em_scale_y (coordinate) + (this+deviceTable).get_y_delta (font, var_store);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && deviceTable.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      caretValueFormat;       \/* Format identifier--format = 3 *\/\n+  FWORD         coordinate;             \/* X or Y value, in design units *\/\n+  OffsetTo<Device>\n+                deviceTable;            \/* Offset to Device table for X or Y\n+                                         * value--from beginning of CaretValue\n+                                         * table *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct CaretValue\n+{\n+  hb_position_t get_caret_value (hb_font_t *font,\n+                                        hb_direction_t direction,\n+                                        hb_codepoint_t glyph_id,\n+                                        const VariationStore &var_store) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_caret_value (font, direction);\n+    case 2: return u.format2.get_caret_value (font, direction, glyph_id);\n+    case 3: return u.format3.get_caret_value (font, direction, var_store);\n+    default:return 0;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    case 3: return_trace (u.format3.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  CaretValueFormat1     format1;\n+  CaretValueFormat2     format2;\n+  CaretValueFormat3     format3;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+struct LigGlyph\n+{\n+  unsigned int get_lig_carets (hb_font_t *font,\n+                               hb_direction_t direction,\n+                               hb_codepoint_t glyph_id,\n+                               const VariationStore &var_store,\n+                               unsigned int start_offset,\n+                               unsigned int *caret_count \/* IN\/OUT *\/,\n+                               hb_position_t *caret_array \/* OUT *\/) const\n+  {\n+    if (caret_count)\n+    {\n+      hb_array_t <const OffsetTo<CaretValue> > array = carets.sub_array (start_offset, caret_count);\n+      unsigned int count = array.length;\n+      for (unsigned int i = 0; i < count; i++)\n+        caret_array[i] = (this+array[i]).get_caret_value (font, direction, glyph_id, var_store);\n+    }\n+\n+    return carets.len;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (carets.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetArrayOf<CaretValue>\n+                carets;                 \/* Offset array of CaretValue tables\n+                                         * --from beginning of LigGlyph table\n+                                         * --in increasing coordinate order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, carets);\n+};\n+\n+struct LigCaretList\n+{\n+  unsigned int get_lig_carets (hb_font_t *font,\n+                               hb_direction_t direction,\n+                               hb_codepoint_t glyph_id,\n+                               const VariationStore &var_store,\n+                               unsigned int start_offset,\n+                               unsigned int *caret_count \/* IN\/OUT *\/,\n+                               hb_position_t *caret_array \/* OUT *\/) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (index == NOT_COVERED)\n+    {\n+      if (caret_count)\n+        *caret_count = 0;\n+      return 0;\n+    }\n+    const LigGlyph &lig_glyph = this+ligGlyph[index];\n+    return lig_glyph.get_lig_carets (font, direction, glyph_id, var_store, start_offset, caret_count, caret_array);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && ligGlyph.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of LigCaretList table *\/\n+  OffsetArrayOf<LigGlyph>\n+                ligGlyph;               \/* Array of LigGlyph tables\n+                                         * in Coverage Index order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, ligGlyph);\n+};\n+\n+\n+struct MarkGlyphSetsFormat1\n+{\n+  bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n+  { return (this+coverage[set_index]).get_coverage (glyph_id) != NOT_COVERED; }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  ArrayOf<LOffsetTo<Coverage> >\n+                coverage;               \/* Array of long offsets to mark set\n+                                         * coverage tables *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, coverage);\n+};\n+\n+struct MarkGlyphSets\n+{\n+  bool covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.covers (set_index, glyph_id);\n+    default:return false;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkGlyphSetsFormat1  format1;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+\n+\/*\n+ * GDEF -- Glyph Definition\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gdef\n+ *\/\n+\n+\n+struct GDEF\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_GDEF;\n+\n+  enum GlyphClasses {\n+    UnclassifiedGlyph   = 0,\n+    BaseGlyph           = 1,\n+    LigatureGlyph       = 2,\n+    MarkGlyph           = 3,\n+    ComponentGlyph      = 4\n+  };\n+\n+  bool has_data () const { return version.to_int (); }\n+  bool has_glyph_classes () const { return glyphClassDef != 0; }\n+  unsigned int get_glyph_class (hb_codepoint_t glyph) const\n+  { return (this+glyphClassDef).get_class (glyph); }\n+  void get_glyphs_in_class (unsigned int klass, hb_set_t *glyphs) const\n+  { (this+glyphClassDef).add_class (glyphs, klass); }\n+\n+  bool has_mark_attachment_types () const { return markAttachClassDef != 0; }\n+  unsigned int get_mark_attachment_type (hb_codepoint_t glyph) const\n+  { return (this+markAttachClassDef).get_class (glyph); }\n+\n+  bool has_attach_points () const { return attachList != 0; }\n+  unsigned int get_attach_points (hb_codepoint_t glyph_id,\n+                                  unsigned int start_offset,\n+                                  unsigned int *point_count \/* IN\/OUT *\/,\n+                                  unsigned int *point_array \/* OUT *\/) const\n+  { return (this+attachList).get_attach_points (glyph_id, start_offset, point_count, point_array); }\n+\n+  bool has_lig_carets () const { return ligCaretList != 0; }\n+  unsigned int get_lig_carets (hb_font_t *font,\n+                               hb_direction_t direction,\n+                               hb_codepoint_t glyph_id,\n+                               unsigned int start_offset,\n+                               unsigned int *caret_count \/* IN\/OUT *\/,\n+                               hb_position_t *caret_array \/* OUT *\/) const\n+  { return (this+ligCaretList).get_lig_carets (font,\n+                                               direction, glyph_id, get_var_store(),\n+                                               start_offset, caret_count, caret_array); }\n+\n+  bool has_mark_sets () const { return version.to_int () >= 0x00010002u && markGlyphSetsDef != 0; }\n+  bool mark_set_covers (unsigned int set_index, hb_codepoint_t glyph_id) const\n+  { return version.to_int () >= 0x00010002u && (this+markGlyphSetsDef).covers (set_index, glyph_id); }\n+\n+  bool has_var_store () const { return version.to_int () >= 0x00010003u && varStore != 0; }\n+  const VariationStore &get_var_store () const\n+  { return version.to_int () >= 0x00010003u ? this+varStore : Null(VariationStore); }\n+\n+  \/* glyph_props is a 16-bit integer where the lower 8-bit have bits representing\n+   * glyph class and other bits, and high 8-bit the mark attachment type (if any).\n+   * Not to be confused with lookup_props which is very similar. *\/\n+  unsigned int get_glyph_props (hb_codepoint_t glyph) const\n+  {\n+    unsigned int klass = get_glyph_class (glyph);\n+\n+    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH == (unsigned int) LookupFlag::IgnoreBaseGlyphs), \"\");\n+    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE == (unsigned int) LookupFlag::IgnoreLigatures), \"\");\n+    static_assert (((unsigned int) HB_OT_LAYOUT_GLYPH_PROPS_MARK == (unsigned int) LookupFlag::IgnoreMarks), \"\");\n+\n+    switch (klass) {\n+    default:                    return 0;\n+    case BaseGlyph:             return HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH;\n+    case LigatureGlyph:         return HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE;\n+    case MarkGlyph:\n+          klass = get_mark_attachment_type (glyph);\n+          return HB_OT_LAYOUT_GLYPH_PROPS_MARK | (klass << 8);\n+    }\n+  }\n+\n+  HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,\n+                                   hb_face_t *face) const;\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      this->table = hb_sanitize_context_t().reference_table<GDEF> (face);\n+      if (unlikely (this->table->is_blacklisted (this->table.get_blob (), face)))\n+      {\n+        hb_blob_destroy (this->table.get_blob ());\n+        this->table = hb_blob_get_empty ();\n+      }\n+    }\n+\n+    void fini () { this->table.destroy (); }\n+\n+    hb_blob_ptr_t<GDEF> table;\n+  };\n+\n+  unsigned int get_size () const\n+  {\n+    return min_size +\n+           (version.to_int () >= 0x00010002u ? markGlyphSetsDef.static_size : 0) +\n+           (version.to_int () >= 0x00010003u ? varStore.static_size : 0);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    struct GDEF *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    out->glyphClassDef.serialize_subset (c, this+glyphClassDef, out);\n+    out->attachList.set (0);\/\/TODO(subset) serialize_subset (c, this+attachList, out);\n+    out->ligCaretList.set (0);\/\/TODO(subset) serialize_subset (c, this+ligCaretList, out);\n+    out->markAttachClassDef.serialize_subset (c, this+markAttachClassDef, out);\n+\n+    if (version.to_int () >= 0x00010002u)\n+      out->markGlyphSetsDef.set (0);\/\/ TODO(subset) serialize_subset (c, this+markGlyphSetsDef, out);\n+\n+    if (version.to_int () >= 0x00010003u)\n+      out->varStore.set (0);\/\/ TODO(subset) serialize_subset (c, this+varStore, out);\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  glyphClassDef.sanitize (c, this) &&\n+                  attachList.sanitize (c, this) &&\n+                  ligCaretList.sanitize (c, this) &&\n+                  markAttachClassDef.sanitize (c, this) &&\n+                  (version.to_int () < 0x00010002u || markGlyphSetsDef.sanitize (c, this)) &&\n+                  (version.to_int () < 0x00010003u || varStore.sanitize (c, this)));\n+  }\n+\n+  protected:\n+  FixedVersion<>version;                \/* Version of the GDEF table--currently\n+                                         * 0x00010003u *\/\n+  OffsetTo<ClassDef>\n+                glyphClassDef;          \/* Offset to class definition table\n+                                         * for glyph type--from beginning of\n+                                         * GDEF header (may be Null) *\/\n+  OffsetTo<AttachList>\n+                attachList;             \/* Offset to list of glyphs with\n+                                         * attachment points--from beginning\n+                                         * of GDEF header (may be Null) *\/\n+  OffsetTo<LigCaretList>\n+                ligCaretList;           \/* Offset to list of positioning points\n+                                         * for ligature carets--from beginning\n+                                         * of GDEF header (may be Null) *\/\n+  OffsetTo<ClassDef>\n+                markAttachClassDef;     \/* Offset to class definition table for\n+                                         * mark attachment type--from beginning\n+                                         * of GDEF header (may be Null) *\/\n+  OffsetTo<MarkGlyphSets>\n+                markGlyphSetsDef;       \/* Offset to the table of mark set\n+                                         * definitions--from beginning of GDEF\n+                                         * header (may be NULL).  Introduced\n+                                         * in version 0x00010002. *\/\n+  LOffsetTo<VariationStore>\n+                varStore;               \/* Offset to the table of Item Variation\n+                                         * Store--from beginning of GDEF\n+                                         * header (may be NULL).  Introduced\n+                                         * in version 0x00010003. *\/\n+  public:\n+  DEFINE_SIZE_MIN (12);\n+};\n+\n+struct GDEF_accelerator_t : GDEF::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_LAYOUT_GDEF_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout-gdef-table.hh","additions":510,"deletions":0,"binary":false,"changes":510,"status":"added"},{"patch":"@@ -0,0 +1,1759 @@\n+\/*\n+ * Copyright © 2007,2008,2009,2010  Red Hat, Inc.\n+ * Copyright © 2010,2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_GPOS_TABLE_HH\n+#define HB_OT_LAYOUT_GPOS_TABLE_HH\n+\n+#include \"hb-ot-layout-gsubgpos.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/* buffer **position** var allocations *\/\n+#define attach_chain() var.i16[0] \/* glyph to which this attaches to, relative to current glyphs; negative for going back, positive for forward. *\/\n+#define attach_type() var.u8[2] \/* attachment type *\/\n+\/* Note! if attach_chain() is zero, the value of attach_type() is irrelevant. *\/\n+\n+enum attach_type_t {\n+  ATTACH_TYPE_NONE      = 0X00,\n+\n+  \/* Each attachment should be either a mark or a cursive; can't be both. *\/\n+  ATTACH_TYPE_MARK      = 0X01,\n+  ATTACH_TYPE_CURSIVE   = 0X02,\n+};\n+\n+\n+\/* Shared Tables: ValueRecord, Anchor Table, and MarkArray *\/\n+\n+typedef HBUINT16 Value;\n+\n+typedef UnsizedArrayOf<Value> ValueRecord;\n+\n+struct ValueFormat : HBUINT16\n+{\n+  enum Flags {\n+    xPlacement  = 0x0001u,      \/* Includes horizontal adjustment for placement *\/\n+    yPlacement  = 0x0002u,      \/* Includes vertical adjustment for placement *\/\n+    xAdvance    = 0x0004u,      \/* Includes horizontal adjustment for advance *\/\n+    yAdvance    = 0x0008u,      \/* Includes vertical adjustment for advance *\/\n+    xPlaDevice  = 0x0010u,      \/* Includes horizontal Device table for placement *\/\n+    yPlaDevice  = 0x0020u,      \/* Includes vertical Device table for placement *\/\n+    xAdvDevice  = 0x0040u,      \/* Includes horizontal Device table for advance *\/\n+    yAdvDevice  = 0x0080u,      \/* Includes vertical Device table for advance *\/\n+    ignored     = 0x0F00u,      \/* Was used in TrueType Open for MM fonts *\/\n+    reserved    = 0xF000u,      \/* For future use *\/\n+\n+    devices     = 0x00F0u       \/* Mask for having any Device table *\/\n+  };\n+\n+\/* All fields are options.  Only those available advance the value pointer. *\/\n+#if 0\n+  HBINT16               xPlacement;             \/* Horizontal adjustment for\n+                                         * placement--in design units *\/\n+  HBINT16               yPlacement;             \/* Vertical adjustment for\n+                                         * placement--in design units *\/\n+  HBINT16               xAdvance;               \/* Horizontal adjustment for\n+                                         * advance--in design units (only used\n+                                         * for horizontal writing) *\/\n+  HBINT16               yAdvance;               \/* Vertical adjustment for advance--in\n+                                         * design units (only used for vertical\n+                                         * writing) *\/\n+  OffsetTo<Device>      xPlaDevice;     \/* Offset to Device table for\n+                                         * horizontal placement--measured from\n+                                         * beginning of PosTable (may be NULL) *\/\n+  OffsetTo<Device>      yPlaDevice;     \/* Offset to Device table for vertical\n+                                         * placement--measured from beginning\n+                                         * of PosTable (may be NULL) *\/\n+  OffsetTo<Device>      xAdvDevice;     \/* Offset to Device table for\n+                                         * horizontal advance--measured from\n+                                         * beginning of PosTable (may be NULL) *\/\n+  OffsetTo<Device>      yAdvDevice;     \/* Offset to Device table for vertical\n+                                         * advance--measured from beginning of\n+                                         * PosTable (may be NULL) *\/\n+#endif\n+\n+  unsigned int get_len () const  { return hb_popcount ((unsigned int) *this); }\n+  unsigned int get_size () const { return get_len () * Value::static_size; }\n+\n+  bool apply_value (hb_ot_apply_context_t   *c,\n+                    const void           *base,\n+                    const Value          *values,\n+                    hb_glyph_position_t  &glyph_pos) const\n+  {\n+    bool ret = false;\n+    unsigned int format = *this;\n+    if (!format) return ret;\n+\n+    hb_font_t *font = c->font;\n+    bool horizontal = HB_DIRECTION_IS_HORIZONTAL (c->direction);\n+\n+    if (format & xPlacement) glyph_pos.x_offset  += font->em_scale_x (get_short (values++, &ret));\n+    if (format & yPlacement) glyph_pos.y_offset  += font->em_scale_y (get_short (values++, &ret));\n+    if (format & xAdvance) {\n+      if (likely (horizontal)) glyph_pos.x_advance += font->em_scale_x (get_short (values, &ret));\n+      values++;\n+    }\n+    \/* y_advance values grow downward but font-space grows upward, hence negation *\/\n+    if (format & yAdvance) {\n+      if (unlikely (!horizontal)) glyph_pos.y_advance -= font->em_scale_y (get_short (values, &ret));\n+      values++;\n+    }\n+\n+    if (!has_device ()) return ret;\n+\n+    bool use_x_device = font->x_ppem || font->num_coords;\n+    bool use_y_device = font->y_ppem || font->num_coords;\n+\n+    if (!use_x_device && !use_y_device) return ret;\n+\n+    const VariationStore &store = c->var_store;\n+\n+    \/* pixel -> fractional pixel *\/\n+    if (format & xPlaDevice) {\n+      if (use_x_device) glyph_pos.x_offset  += (base + get_device (values, &ret)).get_x_delta (font, store);\n+      values++;\n+    }\n+    if (format & yPlaDevice) {\n+      if (use_y_device) glyph_pos.y_offset  += (base + get_device (values, &ret)).get_y_delta (font, store);\n+      values++;\n+    }\n+    if (format & xAdvDevice) {\n+      if (horizontal && use_x_device) glyph_pos.x_advance += (base + get_device (values, &ret)).get_x_delta (font, store);\n+      values++;\n+    }\n+    if (format & yAdvDevice) {\n+      \/* y_advance values grow downward but font-space grows upward, hence negation *\/\n+      if (!horizontal && use_y_device) glyph_pos.y_advance -= (base + get_device (values, &ret)).get_y_delta (font, store);\n+      values++;\n+    }\n+    return ret;\n+  }\n+\n+  private:\n+  bool sanitize_value_devices (hb_sanitize_context_t *c, const void *base, const Value *values) const\n+  {\n+    unsigned int format = *this;\n+\n+    if (format & xPlacement) values++;\n+    if (format & yPlacement) values++;\n+    if (format & xAdvance)   values++;\n+    if (format & yAdvance)   values++;\n+\n+    if ((format & xPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n+    if ((format & yPlaDevice) && !get_device (values++).sanitize (c, base)) return false;\n+    if ((format & xAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n+    if ((format & yAdvDevice) && !get_device (values++).sanitize (c, base)) return false;\n+\n+    return true;\n+  }\n+\n+  static OffsetTo<Device>& get_device (Value* value)\n+  { return *CastP<OffsetTo<Device> > (value); }\n+  static const OffsetTo<Device>& get_device (const Value* value, bool *worked=nullptr)\n+  {\n+    if (worked) *worked |= bool (*value);\n+    return *CastP<OffsetTo<Device> > (value);\n+  }\n+\n+  static const HBINT16& get_short (const Value* value, bool *worked=nullptr)\n+  {\n+    if (worked) *worked |= bool (*value);\n+    return *CastP<HBINT16> (value);\n+  }\n+\n+  public:\n+\n+  bool has_device () const\n+  {\n+    unsigned int format = *this;\n+    return (format & devices) != 0;\n+  }\n+\n+  bool sanitize_value (hb_sanitize_context_t *c, const void *base, const Value *values) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_range (values, get_size ()) && (!has_device () || sanitize_value_devices (c, base, values)));\n+  }\n+\n+  bool sanitize_values (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    unsigned int len = get_len ();\n+\n+    if (!c->check_range (values, count, get_size ())) return_trace (false);\n+\n+    if (!has_device ()) return_trace (true);\n+\n+    for (unsigned int i = 0; i < count; i++) {\n+      if (!sanitize_value_devices (c, base, values))\n+        return_trace (false);\n+      values += len;\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  \/* Just sanitize referenced Device tables.  Doesn't check the values themselves. *\/\n+  bool sanitize_values_stride_unsafe (hb_sanitize_context_t *c, const void *base, const Value *values, unsigned int count, unsigned int stride) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (!has_device ()) return_trace (true);\n+\n+    for (unsigned int i = 0; i < count; i++) {\n+      if (!sanitize_value_devices (c, base, values))\n+        return_trace (false);\n+      values += stride;\n+    }\n+\n+    return_trace (true);\n+  }\n+};\n+\n+\n+struct AnchorFormat1\n+{\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,\n+                   float *x, float *y) const\n+  {\n+    hb_font_t *font = c->font;\n+    *x = font->em_fscale_x (xCoordinate);\n+    *y = font->em_fscale_y (yCoordinate);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n+  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct AnchorFormat2\n+{\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,\n+                   float *x, float *y) const\n+  {\n+    hb_font_t *font = c->font;\n+    unsigned int x_ppem = font->x_ppem;\n+    unsigned int y_ppem = font->y_ppem;\n+    hb_position_t cx = 0, cy = 0;\n+    bool ret;\n+\n+    ret = (x_ppem || y_ppem) &&\n+          font->get_glyph_contour_point_for_origin (glyph_id, anchorPoint, HB_DIRECTION_LTR, &cx, &cy);\n+    *x = ret && x_ppem ? cx : font->em_fscale_x (xCoordinate);\n+    *y = ret && y_ppem ? cy : font->em_fscale_y (yCoordinate);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n+  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n+  HBUINT16      anchorPoint;            \/* Index to glyph contour point *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct AnchorFormat3\n+{\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id HB_UNUSED,\n+                   float *x, float *y) const\n+  {\n+    hb_font_t *font = c->font;\n+    *x = font->em_fscale_x (xCoordinate);\n+    *y = font->em_fscale_y (yCoordinate);\n+\n+    if (font->x_ppem || font->num_coords)\n+      *x += (this+xDeviceTable).get_x_delta (font, c->var_store);\n+    if (font->y_ppem || font->num_coords)\n+      *y += (this+yDeviceTable).get_y_delta (font, c->var_store);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && xDeviceTable.sanitize (c, this) && yDeviceTable.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 3 *\/\n+  FWORD         xCoordinate;            \/* Horizontal value--in design units *\/\n+  FWORD         yCoordinate;            \/* Vertical value--in design units *\/\n+  OffsetTo<Device>\n+                xDeviceTable;           \/* Offset to Device table for X\n+                                         * coordinate-- from beginning of\n+                                         * Anchor table (may be NULL) *\/\n+  OffsetTo<Device>\n+                yDeviceTable;           \/* Offset to Device table for Y\n+                                         * coordinate-- from beginning of\n+                                         * Anchor table (may be NULL) *\/\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+struct Anchor\n+{\n+  void get_anchor (hb_ot_apply_context_t *c, hb_codepoint_t glyph_id,\n+                   float *x, float *y) const\n+  {\n+    *x = *y = 0;\n+    switch (u.format) {\n+    case 1: u.format1.get_anchor (c, glyph_id, x, y); return;\n+    case 2: u.format2.get_anchor (c, glyph_id, x, y); return;\n+    case 3: u.format3.get_anchor (c, glyph_id, x, y); return;\n+    default:                                          return;\n+    }\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!u.format.sanitize (c)) return_trace (false);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.sanitize (c));\n+    case 2: return_trace (u.format2.sanitize (c));\n+    case 3: return_trace (u.format3.sanitize (c));\n+    default:return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  AnchorFormat1         format1;\n+  AnchorFormat2         format2;\n+  AnchorFormat3         format3;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+\n+struct AnchorMatrix\n+{\n+  const Anchor& get_anchor (unsigned int row, unsigned int col,\n+                            unsigned int cols, bool *found) const\n+  {\n+    *found = false;\n+    if (unlikely (row >= rows || col >= cols)) return Null(Anchor);\n+    *found = !matrixZ[row * cols + col].is_null ();\n+    return this+matrixZ[row * cols + col];\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int cols) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!c->check_struct (this)) return_trace (false);\n+    if (unlikely (hb_unsigned_mul_overflows (rows, cols))) return_trace (false);\n+    unsigned int count = rows * cols;\n+    if (!c->check_array (matrixZ.arrayZ, count)) return_trace (false);\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!matrixZ[i].sanitize (c, this)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  HBUINT16      rows;                   \/* Number of rows *\/\n+  protected:\n+  UnsizedArrayOf<OffsetTo<Anchor> >\n+                matrixZ;                \/* Matrix of offsets to Anchor tables--\n+                                         * from beginning of AnchorMatrix table *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, matrixZ);\n+};\n+\n+\n+struct MarkRecord\n+{\n+  friend struct MarkArray;\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && markAnchor.sanitize (c, base));\n+  }\n+\n+  protected:\n+  HBUINT16      klass;                  \/* Class defined for this mark *\/\n+  OffsetTo<Anchor>\n+                markAnchor;             \/* Offset to Anchor table--from\n+                                         * beginning of MarkArray table *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct MarkArray : ArrayOf<MarkRecord>  \/* Array of MarkRecords--in Coverage order *\/\n+{\n+  bool apply (hb_ot_apply_context_t *c,\n+              unsigned int mark_index, unsigned int glyph_index,\n+              const AnchorMatrix &anchors, unsigned int class_count,\n+              unsigned int glyph_pos) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    const MarkRecord &record = ArrayOf<MarkRecord>::operator[](mark_index);\n+    unsigned int mark_class = record.klass;\n+\n+    const Anchor& mark_anchor = this + record.markAnchor;\n+    bool found;\n+    const Anchor& glyph_anchor = anchors.get_anchor (glyph_index, mark_class, class_count, &found);\n+    \/* If this subtable doesn't have an anchor for this base and this class,\n+     * return false such that the subsequent subtables have a chance at it. *\/\n+    if (unlikely (!found)) return_trace (false);\n+\n+    float mark_x, mark_y, base_x, base_y;\n+\n+    buffer->unsafe_to_break (glyph_pos, buffer->idx);\n+    mark_anchor.get_anchor (c, buffer->cur().codepoint, &mark_x, &mark_y);\n+    glyph_anchor.get_anchor (c, buffer->info[glyph_pos].codepoint, &base_x, &base_y);\n+\n+    hb_glyph_position_t &o = buffer->cur_pos();\n+    o.x_offset = round (base_x - mark_x);\n+    o.y_offset = round (base_y - mark_y);\n+    o.attach_type() = ATTACH_TYPE_MARK;\n+    o.attach_chain() = (int) glyph_pos - (int) buffer->idx;\n+    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (ArrayOf<MarkRecord>::sanitize (c, this));\n+  }\n+};\n+\n+\n+\/* Lookups *\/\n+\n+struct SinglePosFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { if (unlikely (!(this+coverage).add_coverage (c->input))) return; }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    valueFormat.apply_value (c, this, values, buffer->cur_pos());\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  coverage.sanitize (c, this) &&\n+                  valueFormat.sanitize_value (c, this, values));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat;            \/* Defines the types of data in the\n+                                         * ValueRecord *\/\n+  ValueRecord   values;                 \/* Defines positioning\n+                                         * value(s)--applied to all glyphs in\n+                                         * the Coverage table *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, values);\n+};\n+\n+struct SinglePosFormat2\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { if (unlikely (!(this+coverage).add_coverage (c->input))) return; }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    if (likely (index >= valueCount)) return_trace (false);\n+\n+    valueFormat.apply_value (c, this,\n+                             &values[index * valueFormat.get_len ()],\n+                             buffer->cur_pos());\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  coverage.sanitize (c, this) &&\n+                  valueFormat.sanitize_values (c, this, values, valueCount));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat;            \/* Defines the types of data in the\n+                                         * ValueRecord *\/\n+  HBUINT16      valueCount;             \/* Number of ValueRecords *\/\n+  ValueRecord   values;                 \/* Array of ValueRecords--positioning\n+                                         * values applied to glyphs *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, values);\n+};\n+\n+struct SinglePos\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    case 2: return_trace (c->dispatch (u.format2));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  SinglePosFormat1      format1;\n+  SinglePosFormat2      format2;\n+  } u;\n+};\n+\n+\n+struct PairValueRecord\n+{\n+  friend struct PairSet;\n+\n+  protected:\n+  GlyphID       secondGlyph;            \/* GlyphID of second glyph in the\n+                                         * pair--first glyph is listed in the\n+                                         * Coverage table *\/\n+  ValueRecord   values;                 \/* Positioning data for the first glyph\n+                                         * followed by for second glyph *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, values);\n+};\n+\n+struct PairSet\n+{\n+  friend struct PairPosFormat1;\n+\n+  bool intersects (const hb_set_t *glyphs,\n+                          const ValueFormat *valueFormats) const\n+  {\n+    unsigned int len1 = valueFormats[0].get_len ();\n+    unsigned int len2 = valueFormats[1].get_len ();\n+    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    unsigned int count = len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (glyphs->has (record->secondGlyph))\n+        return true;\n+      record = &StructAtOffset<const PairValueRecord> (record, record_size);\n+    }\n+    return false;\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c,\n+                              const ValueFormat *valueFormats) const\n+  {\n+    unsigned int len1 = valueFormats[0].get_len ();\n+    unsigned int len2 = valueFormats[1].get_len ();\n+    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n+\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    c->input->add_array (&record->secondGlyph, len, record_size);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c,\n+                     const ValueFormat *valueFormats,\n+                     unsigned int pos) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int len1 = valueFormats[0].get_len ();\n+    unsigned int len2 = valueFormats[1].get_len ();\n+    unsigned int record_size = HBUINT16::static_size * (1 + len1 + len2);\n+\n+    unsigned int count = len;\n+\n+    \/* Hand-coded bsearch. *\/\n+    if (unlikely (!count))\n+      return_trace (false);\n+    hb_codepoint_t x = buffer->info[pos].codepoint;\n+    int min = 0, max = (int) count - 1;\n+    while (min <= max)\n+    {\n+      int mid = ((unsigned int) min + (unsigned int) max) \/ 2;\n+      const PairValueRecord *record = &StructAtOffset<PairValueRecord> (&firstPairValueRecord, record_size * mid);\n+      hb_codepoint_t mid_x = record->secondGlyph;\n+      if (x < mid_x)\n+        max = mid - 1;\n+      else if (x > mid_x)\n+        min = mid + 1;\n+      else\n+      {\n+        \/* Note the intentional use of \"|\" instead of short-circuit \"||\". *\/\n+        if (valueFormats[0].apply_value (c, this, &record->values[0], buffer->cur_pos()) |\n+            valueFormats[1].apply_value (c, this, &record->values[len1], buffer->pos[pos]))\n+          buffer->unsafe_to_break (buffer->idx, pos + 1);\n+        if (len2)\n+          pos++;\n+        buffer->idx = pos;\n+        return_trace (true);\n+      }\n+    }\n+\n+    return_trace (false);\n+  }\n+\n+  struct sanitize_closure_t\n+  {\n+    const void *base;\n+    const ValueFormat *valueFormats;\n+    unsigned int len1; \/* valueFormats[0].get_len() *\/\n+    unsigned int stride; \/* 1 + len1 + len2 *\/\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c, const sanitize_closure_t *closure) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(c->check_struct (this)\n+       && c->check_range (&firstPairValueRecord,\n+                          len,\n+                          HBUINT16::static_size,\n+                          closure->stride))) return_trace (false);\n+\n+    unsigned int count = len;\n+    const PairValueRecord *record = &firstPairValueRecord;\n+    return_trace (closure->valueFormats[0].sanitize_values_stride_unsafe (c, closure->base, &record->values[0], count, closure->stride) &&\n+                  closure->valueFormats[1].sanitize_values_stride_unsafe (c, closure->base, &record->values[closure->len1], count, closure->stride));\n+  }\n+\n+  protected:\n+  HBUINT16              len;    \/* Number of PairValueRecords *\/\n+  PairValueRecord       firstPairValueRecord;\n+                                \/* Array of PairValueRecords--ordered\n+                                 * by GlyphID of the second glyph *\/\n+  public:\n+  DEFINE_SIZE_MIN (2);\n+};\n+\n+struct PairPosFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    unsigned int count = pairSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (glyphs->has (iter.get_glyph ()) &&\n+          (this+pairSet[iter.get_coverage ()]).intersects (glyphs, valueFormat))\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+    unsigned int count = pairSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      (this+pairSet[i]).collect_glyphs (c, valueFormat);\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    if (!skippy_iter.next ()) return_trace (false);\n+\n+    return_trace ((this+pairSet[index]).apply (c, valueFormat, skippy_iter.idx));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    if (!c->check_struct (this)) return_trace (false);\n+\n+    unsigned int len1 = valueFormat[0].get_len ();\n+    unsigned int len2 = valueFormat[1].get_len ();\n+    PairSet::sanitize_closure_t closure =\n+    {\n+      this,\n+      valueFormat,\n+      len1,\n+      1 + len1 + len2\n+    };\n+\n+    return_trace (coverage.sanitize (c, this) && pairSet.sanitize (c, this, &closure));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat[2];         \/* [0] Defines the types of data in\n+                                         * ValueRecord1--for the first glyph\n+                                         * in the pair--may be zero (0) *\/\n+                                        \/* [1] Defines the types of data in\n+                                         * ValueRecord2--for the second glyph\n+                                         * in the pair--may be zero (0) *\/\n+  OffsetArrayOf<PairSet>\n+                pairSet;                \/* Array of PairSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (10, pairSet);\n+};\n+\n+struct PairPosFormat2\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    return (this+coverage).intersects (glyphs) &&\n+           (this+classDef2).intersects (glyphs);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+    if (unlikely (!(this+classDef2).add_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int index = (this+coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    if (!skippy_iter.next ()) return_trace (false);\n+\n+    unsigned int len1 = valueFormat1.get_len ();\n+    unsigned int len2 = valueFormat2.get_len ();\n+    unsigned int record_len = len1 + len2;\n+\n+    unsigned int klass1 = (this+classDef1).get_class (buffer->cur().codepoint);\n+    unsigned int klass2 = (this+classDef2).get_class (buffer->info[skippy_iter.idx].codepoint);\n+    if (unlikely (klass1 >= class1Count || klass2 >= class2Count)) return_trace (false);\n+\n+    const Value *v = &values[record_len * (klass1 * class2Count + klass2)];\n+    \/* Note the intentional use of \"|\" instead of short-circuit \"||\". *\/\n+    if (valueFormat1.apply_value (c, this, v, buffer->cur_pos()) |\n+        valueFormat2.apply_value (c, this, v + len1, buffer->pos[skippy_iter.idx]))\n+      buffer->unsafe_to_break (buffer->idx, skippy_iter.idx + 1);\n+\n+    buffer->idx = skippy_iter.idx;\n+    if (len2)\n+      buffer->idx++;\n+\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(c->check_struct (this)\n+       && coverage.sanitize (c, this)\n+       && classDef1.sanitize (c, this)\n+       && classDef2.sanitize (c, this))) return_trace (false);\n+\n+    unsigned int len1 = valueFormat1.get_len ();\n+    unsigned int len2 = valueFormat2.get_len ();\n+    unsigned int stride = len1 + len2;\n+    unsigned int record_size = valueFormat1.get_size () + valueFormat2.get_size ();\n+    unsigned int count = (unsigned int) class1Count * (unsigned int) class2Count;\n+    return_trace (c->check_range ((const void *) values,\n+                                  count,\n+                                  record_size) &&\n+                  valueFormat1.sanitize_values_stride_unsafe (c, this, &values[0], count, stride) &&\n+                  valueFormat2.sanitize_values_stride_unsafe (c, this, &values[len1], count, stride));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ValueFormat   valueFormat1;           \/* ValueRecord definition--for the\n+                                         * first glyph of the pair--may be zero\n+                                         * (0) *\/\n+  ValueFormat   valueFormat2;           \/* ValueRecord definition--for the\n+                                         * second glyph of the pair--may be\n+                                         * zero (0) *\/\n+  OffsetTo<ClassDef>\n+                classDef1;              \/* Offset to ClassDef table--from\n+                                         * beginning of PairPos subtable--for\n+                                         * the first glyph of the pair *\/\n+  OffsetTo<ClassDef>\n+                classDef2;              \/* Offset to ClassDef table--from\n+                                         * beginning of PairPos subtable--for\n+                                         * the second glyph of the pair *\/\n+  HBUINT16      class1Count;            \/* Number of classes in ClassDef1\n+                                         * table--includes Class0 *\/\n+  HBUINT16      class2Count;            \/* Number of classes in ClassDef2\n+                                         * table--includes Class0 *\/\n+  ValueRecord   values;                 \/* Matrix of value pairs:\n+                                         * class1-major, class2-minor,\n+                                         * Each entry has value1 and value2 *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (16, values);\n+};\n+\n+struct PairPos\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    case 2: return_trace (c->dispatch (u.format2));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  PairPosFormat1        format1;\n+  PairPosFormat2        format2;\n+  } u;\n+};\n+\n+\n+struct EntryExitRecord\n+{\n+  friend struct CursivePosFormat1;\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (entryAnchor.sanitize (c, base) && exitAnchor.sanitize (c, base));\n+  }\n+\n+  protected:\n+  OffsetTo<Anchor>\n+                entryAnchor;            \/* Offset to EntryAnchor table--from\n+                                         * beginning of CursivePos\n+                                         * subtable--may be NULL *\/\n+  OffsetTo<Anchor>\n+                exitAnchor;             \/* Offset to ExitAnchor table--from\n+                                         * beginning of CursivePos\n+                                         * subtable--may be NULL *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+static void\n+reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent);\n+\n+struct CursivePosFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { if (unlikely (!(this+coverage).add_coverage (c->input))) return; }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+\n+    const EntryExitRecord &this_record = entryExitRecord[(this+coverage).get_coverage  (buffer->cur().codepoint)];\n+    if (!this_record.entryAnchor) return_trace (false);\n+\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    if (!skippy_iter.prev ()) return_trace (false);\n+\n+    const EntryExitRecord &prev_record = entryExitRecord[(this+coverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint)];\n+    if (!prev_record.exitAnchor) return_trace (false);\n+\n+    unsigned int i = skippy_iter.idx;\n+    unsigned int j = buffer->idx;\n+\n+    buffer->unsafe_to_break (i, j);\n+    float entry_x, entry_y, exit_x, exit_y;\n+    (this+prev_record.exitAnchor).get_anchor (c, buffer->info[i].codepoint, &exit_x, &exit_y);\n+    (this+this_record.entryAnchor).get_anchor (c, buffer->info[j].codepoint, &entry_x, &entry_y);\n+\n+    hb_glyph_position_t *pos = buffer->pos;\n+\n+    hb_position_t d;\n+    \/* Main-direction adjustment *\/\n+    switch (c->direction) {\n+      case HB_DIRECTION_LTR:\n+        pos[i].x_advance  = round (exit_x) + pos[i].x_offset;\n+\n+        d = round (entry_x) + pos[j].x_offset;\n+        pos[j].x_advance -= d;\n+        pos[j].x_offset  -= d;\n+        break;\n+      case HB_DIRECTION_RTL:\n+        d = round (exit_x) + pos[i].x_offset;\n+        pos[i].x_advance -= d;\n+        pos[i].x_offset  -= d;\n+\n+        pos[j].x_advance  = round (entry_x) + pos[j].x_offset;\n+        break;\n+      case HB_DIRECTION_TTB:\n+        pos[i].y_advance  = round (exit_y) + pos[i].y_offset;\n+\n+        d = round (entry_y) + pos[j].y_offset;\n+        pos[j].y_advance -= d;\n+        pos[j].y_offset  -= d;\n+        break;\n+      case HB_DIRECTION_BTT:\n+        d = round (exit_y) + pos[i].y_offset;\n+        pos[i].y_advance -= d;\n+        pos[i].y_offset  -= d;\n+\n+        pos[j].y_advance  = round (entry_y);\n+        break;\n+      case HB_DIRECTION_INVALID:\n+      default:\n+        break;\n+    }\n+\n+    \/* Cross-direction adjustment *\/\n+\n+    \/* We attach child to parent (think graph theory and rooted trees whereas\n+     * the root stays on baseline and each node aligns itself against its\n+     * parent.\n+     *\n+     * Optimize things for the case of RightToLeft, as that's most common in\n+     * Arabic. *\/\n+    unsigned int child  = i;\n+    unsigned int parent = j;\n+    hb_position_t x_offset = entry_x - exit_x;\n+    hb_position_t y_offset = entry_y - exit_y;\n+    if  (!(c->lookup_props & LookupFlag::RightToLeft))\n+    {\n+      unsigned int k = child;\n+      child = parent;\n+      parent = k;\n+      x_offset = -x_offset;\n+      y_offset = -y_offset;\n+    }\n+\n+    \/* If child was already connected to someone else, walk through its old\n+     * chain and reverse the link direction, such that the whole tree of its\n+     * previous connection now attaches to new parent.  Watch out for case\n+     * where new parent is on the path from old chain...\n+     *\/\n+    reverse_cursive_minor_offset (pos, child, c->direction, parent);\n+\n+    pos[child].attach_type() = ATTACH_TYPE_CURSIVE;\n+    pos[child].attach_chain() = (int) parent - (int) child;\n+    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT;\n+    if (likely (HB_DIRECTION_IS_HORIZONTAL (c->direction)))\n+      pos[child].y_offset = y_offset;\n+    else\n+      pos[child].x_offset = x_offset;\n+\n+    buffer->idx++;\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && entryExitRecord.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of subtable *\/\n+  ArrayOf<EntryExitRecord>\n+                entryExitRecord;        \/* Array of EntryExit records--in\n+                                         * Coverage Index order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, entryExitRecord);\n+};\n+\n+struct CursivePos\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  CursivePosFormat1     format1;\n+  } u;\n+};\n+\n+\n+typedef AnchorMatrix BaseArray;         \/* base-major--\n+                                         * in order of BaseCoverage Index--,\n+                                         * mark-minor--\n+                                         * ordered by class--zero-based. *\/\n+\n+struct MarkBasePosFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+markCoverage).intersects (glyphs) &&\n+           (this+baseCoverage).intersects (glyphs); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+markCoverage).add_coverage (c->input))) return;\n+    if (unlikely (!(this+baseCoverage).add_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+markCoverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (mark_index == NOT_COVERED)) return_trace (false);\n+\n+    \/* Now we search backwards for a non-mark glyph *\/\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n+    do {\n+      if (!skippy_iter.prev ()) return_trace (false);\n+      \/* We only want to attach to the first of a MultipleSubst sequence.\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/740\n+       * Reject others...\n+       * ...but stop if we find a mark in the MultipleSubst sequence:\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1020 *\/\n+      if (!_hb_glyph_info_multiplied (&buffer->info[skippy_iter.idx]) ||\n+          0 == _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) ||\n+          (skippy_iter.idx == 0 ||\n+           _hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx - 1]) ||\n+           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx]) !=\n+           _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx - 1]) ||\n+           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]) !=\n+           _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx - 1]) + 1\n+           ))\n+        break;\n+      skippy_iter.reject ();\n+    } while (true);\n+\n+    \/* Checking that matched glyph is actually a base glyph by GDEF is too strong; disabled *\/\n+    \/\/if (!_hb_glyph_info_is_base_glyph (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n+\n+    unsigned int base_index = (this+baseCoverage).get_coverage  (buffer->info[skippy_iter.idx].codepoint);\n+    if (base_index == NOT_COVERED) return_trace (false);\n+\n+    return_trace ((this+markArray).apply (c, mark_index, base_index, this+baseArray, classCount, skippy_iter.idx));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  markCoverage.sanitize (c, this) &&\n+                  baseCoverage.sanitize (c, this) &&\n+                  markArray.sanitize (c, this) &&\n+                  baseArray.sanitize (c, this, (unsigned int) classCount));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                markCoverage;           \/* Offset to MarkCoverage table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+  OffsetTo<Coverage>\n+                baseCoverage;           \/* Offset to BaseCoverage table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+  HBUINT16      classCount;             \/* Number of classes defined for marks *\/\n+  OffsetTo<MarkArray>\n+                markArray;              \/* Offset to MarkArray table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+  OffsetTo<BaseArray>\n+                baseArray;              \/* Offset to BaseArray table--from\n+                                         * beginning of MarkBasePos subtable *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct MarkBasePos\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkBasePosFormat1    format1;\n+  } u;\n+};\n+\n+\n+typedef AnchorMatrix LigatureAttach;    \/* component-major--\n+                                         * in order of writing direction--,\n+                                         * mark-minor--\n+                                         * ordered by class--zero-based. *\/\n+\n+typedef OffsetListOf<LigatureAttach> LigatureArray;\n+                                        \/* Array of LigatureAttach\n+                                         * tables ordered by\n+                                         * LigatureCoverage Index *\/\n+\n+struct MarkLigPosFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+markCoverage).intersects (glyphs) &&\n+           (this+ligatureCoverage).intersects (glyphs); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+markCoverage).add_coverage (c->input))) return;\n+    if (unlikely (!(this+ligatureCoverage).add_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+markCoverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int mark_index = (this+markCoverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (mark_index == NOT_COVERED)) return_trace (false);\n+\n+    \/* Now we search backwards for a non-mark glyph *\/\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    skippy_iter.set_lookup_props (LookupFlag::IgnoreMarks);\n+    if (!skippy_iter.prev ()) return_trace (false);\n+\n+    \/* Checking that matched glyph is actually a ligature by GDEF is too strong; disabled *\/\n+    \/\/if (!_hb_glyph_info_is_ligature (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n+\n+    unsigned int j = skippy_iter.idx;\n+    unsigned int lig_index = (this+ligatureCoverage).get_coverage  (buffer->info[j].codepoint);\n+    if (lig_index == NOT_COVERED) return_trace (false);\n+\n+    const LigatureArray& lig_array = this+ligatureArray;\n+    const LigatureAttach& lig_attach = lig_array[lig_index];\n+\n+    \/* Find component to attach to *\/\n+    unsigned int comp_count = lig_attach.rows;\n+    if (unlikely (!comp_count)) return_trace (false);\n+\n+    \/* We must now check whether the ligature ID of the current mark glyph\n+     * is identical to the ligature ID of the found ligature.  If yes, we\n+     * can directly use the component index.  If not, we attach the mark\n+     * glyph to the last component of the ligature. *\/\n+    unsigned int comp_index;\n+    unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n+    unsigned int mark_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n+    unsigned int mark_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n+    if (lig_id && lig_id == mark_id && mark_comp > 0)\n+      comp_index = MIN (comp_count, _hb_glyph_info_get_lig_comp (&buffer->cur())) - 1;\n+    else\n+      comp_index = comp_count - 1;\n+\n+    return_trace ((this+markArray).apply (c, mark_index, comp_index, lig_attach, classCount, j));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  markCoverage.sanitize (c, this) &&\n+                  ligatureCoverage.sanitize (c, this) &&\n+                  markArray.sanitize (c, this) &&\n+                  ligatureArray.sanitize (c, this, (unsigned int) classCount));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                markCoverage;           \/* Offset to Mark Coverage table--from\n+                                         * beginning of MarkLigPos subtable *\/\n+  OffsetTo<Coverage>\n+                ligatureCoverage;       \/* Offset to Ligature Coverage\n+                                         * table--from beginning of MarkLigPos\n+                                         * subtable *\/\n+  HBUINT16      classCount;             \/* Number of defined mark classes *\/\n+  OffsetTo<MarkArray>\n+                markArray;              \/* Offset to MarkArray table--from\n+                                         * beginning of MarkLigPos subtable *\/\n+  OffsetTo<LigatureArray>\n+                ligatureArray;          \/* Offset to LigatureArray table--from\n+                                         * beginning of MarkLigPos subtable *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct MarkLigPos\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkLigPosFormat1     format1;\n+  } u;\n+};\n+\n+\n+typedef AnchorMatrix Mark2Array;        \/* mark2-major--\n+                                         * in order of Mark2Coverage Index--,\n+                                         * mark1-minor--\n+                                         * ordered by class--zero-based. *\/\n+\n+struct MarkMarkPosFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+mark1Coverage).intersects (glyphs) &&\n+           (this+mark2Coverage).intersects (glyphs); }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+mark1Coverage).add_coverage (c->input))) return;\n+    if (unlikely (!(this+mark2Coverage).add_coverage (c->input))) return;\n+  }\n+\n+  const Coverage &get_coverage () const { return this+mark1Coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_buffer_t *buffer = c->buffer;\n+    unsigned int mark1_index = (this+mark1Coverage).get_coverage  (buffer->cur().codepoint);\n+    if (likely (mark1_index == NOT_COVERED)) return_trace (false);\n+\n+    \/* now we search backwards for a suitable mark glyph until a non-mark glyph *\/\n+    hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+    skippy_iter.reset (buffer->idx, 1);\n+    skippy_iter.set_lookup_props (c->lookup_props & ~LookupFlag::IgnoreFlags);\n+    if (!skippy_iter.prev ()) return_trace (false);\n+\n+    if (!_hb_glyph_info_is_mark (&buffer->info[skippy_iter.idx])) { return_trace (false); }\n+\n+    unsigned int j = skippy_iter.idx;\n+\n+    unsigned int id1 = _hb_glyph_info_get_lig_id (&buffer->cur());\n+    unsigned int id2 = _hb_glyph_info_get_lig_id (&buffer->info[j]);\n+    unsigned int comp1 = _hb_glyph_info_get_lig_comp (&buffer->cur());\n+    unsigned int comp2 = _hb_glyph_info_get_lig_comp (&buffer->info[j]);\n+\n+    if (likely (id1 == id2)) {\n+      if (id1 == 0) \/* Marks belonging to the same base. *\/\n+        goto good;\n+      else if (comp1 == comp2) \/* Marks belonging to the same ligature component. *\/\n+        goto good;\n+    } else {\n+      \/* If ligature ids don't match, it may be the case that one of the marks\n+       * itself is a ligature.  In which case match. *\/\n+      if ((id1 > 0 && !comp1) || (id2 > 0 && !comp2))\n+        goto good;\n+    }\n+\n+    \/* Didn't match. *\/\n+    return_trace (false);\n+\n+    good:\n+    unsigned int mark2_index = (this+mark2Coverage).get_coverage  (buffer->info[j].codepoint);\n+    if (mark2_index == NOT_COVERED) return_trace (false);\n+\n+    return_trace ((this+mark1Array).apply (c, mark1_index, mark2_index, this+mark2Array, classCount, j));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  mark1Coverage.sanitize (c, this) &&\n+                  mark2Coverage.sanitize (c, this) &&\n+                  mark1Array.sanitize (c, this) &&\n+                  mark2Array.sanitize (c, this, (unsigned int) classCount));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                mark1Coverage;          \/* Offset to Combining Mark1 Coverage\n+                                         * table--from beginning of MarkMarkPos\n+                                         * subtable *\/\n+  OffsetTo<Coverage>\n+                mark2Coverage;          \/* Offset to Combining Mark2 Coverage\n+                                         * table--from beginning of MarkMarkPos\n+                                         * subtable *\/\n+  HBUINT16      classCount;             \/* Number of defined mark classes *\/\n+  OffsetTo<MarkArray>\n+                mark1Array;             \/* Offset to Mark1Array table--from\n+                                         * beginning of MarkMarkPos subtable *\/\n+  OffsetTo<Mark2Array>\n+                mark2Array;             \/* Offset to Mark2Array table--from\n+                                         * beginning of MarkMarkPos subtable *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct MarkMarkPos\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MarkMarkPosFormat1    format1;\n+  } u;\n+};\n+\n+\n+struct ContextPos : Context {};\n+\n+struct ChainContextPos : ChainContext {};\n+\n+struct ExtensionPos : Extension<ExtensionPos>\n+{\n+  typedef struct PosLookupSubTable SubTable;\n+};\n+\n+\n+\n+\/*\n+ * PosLookup\n+ *\/\n+\n+\n+struct PosLookupSubTable\n+{\n+  friend struct Lookup;\n+  friend struct PosLookup;\n+\n+  enum Type {\n+    Single              = 1,\n+    Pair                = 2,\n+    Cursive             = 3,\n+    MarkBase            = 4,\n+    MarkLig             = 5,\n+    MarkMark            = 6,\n+    Context             = 7,\n+    ChainContext        = 8,\n+    Extension           = 9\n+  };\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const\n+  {\n+    TRACE_DISPATCH (this, lookup_type);\n+    switch (lookup_type) {\n+    case Single:                return_trace (u.single.dispatch (c));\n+    case Pair:                  return_trace (u.pair.dispatch (c));\n+    case Cursive:               return_trace (u.cursive.dispatch (c));\n+    case MarkBase:              return_trace (u.markBase.dispatch (c));\n+    case MarkLig:               return_trace (u.markLig.dispatch (c));\n+    case MarkMark:              return_trace (u.markMark.dispatch (c));\n+    case Context:               return_trace (u.context.dispatch (c));\n+    case ChainContext:          return_trace (u.chainContext.dispatch (c));\n+    case Extension:             return_trace (u.extension.dispatch (c));\n+    default:                    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  SinglePos             single;\n+  PairPos               pair;\n+  CursivePos            cursive;\n+  MarkBasePos           markBase;\n+  MarkLigPos            markLig;\n+  MarkMarkPos           markMark;\n+  ContextPos            context;\n+  ChainContextPos       chainContext;\n+  ExtensionPos          extension;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (0);\n+};\n+\n+\n+struct PosLookup : Lookup\n+{\n+  typedef struct PosLookupSubTable SubTable;\n+\n+  const SubTable& get_subtable (unsigned int i) const\n+  { return Lookup::get_subtable<SubTable> (i); }\n+\n+  bool is_reverse () const\n+  {\n+    return false;\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    return_trace (dispatch (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    hb_intersects_context_t c (glyphs);\n+    return dispatch (&c);\n+  }\n+\n+  hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { return dispatch (c); }\n+\n+  template <typename set_t>\n+  void add_coverage (set_t *glyphs) const\n+  {\n+    hb_add_coverage_context_t<set_t> c (glyphs);\n+    dispatch (&c);\n+  }\n+\n+  static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);\n+\n+  template <typename context_t>\n+  static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  { return Lookup::dispatch<SubTable> (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  { return Lookup::subset<SubTable> (c); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return Lookup::sanitize<SubTable> (c); }\n+};\n+\n+\/*\n+ * GPOS -- Glyph Positioning\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gpos\n+ *\/\n+\n+struct GPOS : GSUBGPOS\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_GPOS;\n+\n+  const PosLookup& get_lookup (unsigned int i) const\n+  { return CastR<PosLookup> (GSUBGPOS::get_lookup (i)); }\n+\n+  static inline void position_start (hb_font_t *font, hb_buffer_t *buffer);\n+  static inline void position_finish_advances (hb_font_t *font, hb_buffer_t *buffer);\n+  static inline void position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer);\n+\n+  bool subset (hb_subset_context_t *c) const\n+  { return GSUBGPOS::subset<PosLookup> (c); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return GSUBGPOS::sanitize<PosLookup> (c); }\n+\n+  HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,\n+                                   hb_face_t *face) const;\n+\n+  typedef GSUBGPOS::accelerator_t<GPOS> accelerator_t;\n+};\n+\n+\n+static void\n+reverse_cursive_minor_offset (hb_glyph_position_t *pos, unsigned int i, hb_direction_t direction, unsigned int new_parent)\n+{\n+  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n+  if (likely (!chain || 0 == (type & ATTACH_TYPE_CURSIVE)))\n+    return;\n+\n+  pos[i].attach_chain() = 0;\n+\n+  unsigned int j = (int) i + chain;\n+\n+  \/* Stop if we see new parent in the chain. *\/\n+  if (j == new_parent)\n+    return;\n+\n+  reverse_cursive_minor_offset (pos, j, direction, new_parent);\n+\n+  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n+    pos[j].y_offset = -pos[i].y_offset;\n+  else\n+    pos[j].x_offset = -pos[i].x_offset;\n+\n+  pos[j].attach_chain() = -chain;\n+  pos[j].attach_type() = type;\n+}\n+static void\n+propagate_attachment_offsets (hb_glyph_position_t *pos,\n+                              unsigned int len,\n+                              unsigned int i,\n+                              hb_direction_t direction)\n+{\n+  \/* Adjusts offsets of attached glyphs (both cursive and mark) to accumulate\n+   * offset of glyph they are attached to. *\/\n+  int chain = pos[i].attach_chain(), type = pos[i].attach_type();\n+  if (likely (!chain))\n+    return;\n+\n+  pos[i].attach_chain() = 0;\n+\n+  unsigned int j = (int) i + chain;\n+\n+  if (unlikely (j >= len))\n+    return;\n+\n+  propagate_attachment_offsets (pos, len, j, direction);\n+\n+  assert (!!(type & ATTACH_TYPE_MARK) ^ !!(type & ATTACH_TYPE_CURSIVE));\n+\n+  if (type & ATTACH_TYPE_CURSIVE)\n+  {\n+    if (HB_DIRECTION_IS_HORIZONTAL (direction))\n+      pos[i].y_offset += pos[j].y_offset;\n+    else\n+      pos[i].x_offset += pos[j].x_offset;\n+  }\n+  else \/*if (type & ATTACH_TYPE_MARK)*\/\n+  {\n+    pos[i].x_offset += pos[j].x_offset;\n+    pos[i].y_offset += pos[j].y_offset;\n+\n+    assert (j < i);\n+    if (HB_DIRECTION_IS_FORWARD (direction))\n+      for (unsigned int k = j; k < i; k++) {\n+        pos[i].x_offset -= pos[k].x_advance;\n+        pos[i].y_offset -= pos[k].y_advance;\n+      }\n+    else\n+      for (unsigned int k = j + 1; k < i + 1; k++) {\n+        pos[i].x_offset += pos[k].x_advance;\n+        pos[i].y_offset += pos[k].y_advance;\n+      }\n+  }\n+}\n+\n+void\n+GPOS::position_start (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    buffer->pos[i].attach_chain() = buffer->pos[i].attach_type() = 0;\n+}\n+\n+void\n+GPOS::position_finish_advances (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer HB_UNUSED)\n+{\n+  \/\/_hb_buffer_assert_gsubgpos_vars (buffer);\n+}\n+\n+void\n+GPOS::position_finish_offsets (hb_font_t *font HB_UNUSED, hb_buffer_t *buffer)\n+{\n+  _hb_buffer_assert_gsubgpos_vars (buffer);\n+\n+  unsigned int len;\n+  hb_glyph_position_t *pos = hb_buffer_get_glyph_positions (buffer, &len);\n+  hb_direction_t direction = buffer->props.direction;\n+\n+  \/* Handle attachments *\/\n+  if (buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_GPOS_ATTACHMENT)\n+    for (unsigned int i = 0; i < len; i++)\n+      propagate_attachment_offsets (pos, len, i, direction);\n+}\n+\n+\n+struct GPOS_accelerator_t : GPOS::accelerator_t {};\n+\n+\n+\/* Out-of-class implementation for methods recursing *\/\n+\n+template <typename context_t>\n+\/*static*\/ inline typename context_t::return_t PosLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)\n+{\n+  const PosLookup &l = c->face->table.GPOS.get_relaxed ()->table->get_lookup (lookup_index);\n+  return l.dispatch (c);\n+}\n+\n+\/*static*\/ inline bool PosLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)\n+{\n+  const PosLookup &l = c->face->table.GPOS.get_relaxed ()->table->get_lookup (lookup_index);\n+  unsigned int saved_lookup_props = c->lookup_props;\n+  unsigned int saved_lookup_index = c->lookup_index;\n+  c->set_lookup_index (lookup_index);\n+  c->set_lookup_props (l.get_props ());\n+  bool ret = l.dispatch (c);\n+  c->set_lookup_index (saved_lookup_index);\n+  c->set_lookup_props (saved_lookup_props);\n+  return ret;\n+}\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_LAYOUT_GPOS_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout-gpos-table.hh","additions":1759,"deletions":0,"binary":false,"changes":1759,"status":"added"},{"patch":"@@ -0,0 +1,1467 @@\n+\/*\n+ * Copyright © 2007,2008,2009,2010  Red Hat, Inc.\n+ * Copyright © 2010,2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_GSUB_TABLE_HH\n+#define HB_OT_LAYOUT_GSUB_TABLE_HH\n+\n+#include \"hb-ot-layout-gsubgpos.hh\"\n+\n+\n+namespace OT {\n+\n+\n+static inline void SingleSubst_serialize (hb_serialize_context_t *c,\n+                                          hb_array_t<const GlyphID> glyphs,\n+                                          hb_array_t<const GlyphID> substitutes);\n+\n+struct SingleSubstFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      \/* TODO Switch to range-based API to work around malicious fonts.\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      hb_codepoint_t glyph_id = iter.get_glyph ();\n+      if (c->glyphs->has (glyph_id))\n+        c->out->add ((glyph_id + deltaGlyphID) & 0xFFFFu);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      \/* TODO Switch to range-based API to work around malicious fonts.\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      hb_codepoint_t glyph_id = iter.get_glyph ();\n+      c->output->add ((glyph_id + deltaGlyphID) & 0xFFFFu);\n+    }\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    return_trace (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    hb_codepoint_t glyph_id = c->buffer->cur().codepoint;\n+    unsigned int index = (this+coverage).get_coverage (glyph_id);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    \/* According to the Adobe Annotated OpenType Suite, result is always\n+     * limited to 16bit. *\/\n+    glyph_id = (glyph_id + deltaGlyphID) & 0xFFFFu;\n+    c->replace_glyph (glyph_id);\n+\n+    return_trace (true);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  int delta)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);\n+    deltaGlyphID.set (delta); \/* TODO(serialize) overflow? *\/\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+    hb_vector_t<GlyphID> from;\n+    hb_vector_t<GlyphID> to;\n+    hb_codepoint_t delta = deltaGlyphID;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (!glyphset.has (iter.get_glyph ())) continue;\n+      from.push ()->set (glyph_map[iter.get_glyph ()]);\n+      to.push ()->set (glyph_map[(iter.get_glyph () + delta) & 0xFFFF]);\n+    }\n+    c->serializer->propagate_error (from, to);\n+    SingleSubst_serialize (c->serializer, from, to);\n+    return_trace (from.length);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && deltaGlyphID.sanitize (c));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  HBINT16       deltaGlyphID;           \/* Add to original GlyphID to get\n+                                         * substitute GlyphID *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct SingleSubstFormat2\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int count = substitute.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (c->glyphs->has (iter.get_glyph ()))\n+        c->out->add (substitute[iter.get_coverage ()]);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+    unsigned int count = substitute.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      c->output->add (substitute[iter.get_coverage ()]);\n+    }\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    return_trace (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    if (unlikely (index >= substitute.len)) return_trace (false);\n+\n+    c->replace_glyph (substitute[index]);\n+\n+    return_trace (true);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  hb_array_t<const GlyphID> substitutes)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!substitute.serialize (c, substitutes))) return_trace (false);\n+    if (unlikely (!coverage.serialize (c, this).serialize (c, glyphs))) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    const hb_set_t &glyphset = *c->plan->glyphset;\n+    const hb_map_t &glyph_map = *c->plan->glyph_map;\n+    hb_vector_t<GlyphID> from;\n+    hb_vector_t<GlyphID> to;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (!glyphset.has (iter.get_glyph ())) continue;\n+      from.push ()->set (glyph_map[iter.get_glyph ()]);\n+      to.push ()->set (glyph_map[substitute[iter.get_coverage ()]]);\n+    }\n+    c->serializer->propagate_error (from, to);\n+    SingleSubst_serialize (c->serializer, from, to);\n+    return_trace (from.length);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && substitute.sanitize (c));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  ArrayOf<GlyphID>\n+                substitute;             \/* Array of substitute\n+                                         * GlyphIDs--ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, substitute);\n+};\n+\n+struct SingleSubst\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  hb_array_t<const GlyphID> substitutes)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned int format = 2;\n+    int delta = 0;\n+    if (glyphs.length)\n+    {\n+      format = 1;\n+      \/* TODO(serialize) check for wrap-around *\/\n+      delta = substitutes[0] - glyphs[0];\n+      for (unsigned int i = 1; i < glyphs.length; i++)\n+        if (delta != (int) (substitutes[i] - glyphs[i])) {\n+          format = 2;\n+          break;\n+        }\n+    }\n+    u.format.set (format);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c, glyphs, delta));\n+    case 2: return_trace (u.format2.serialize (c, glyphs, substitutes));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    case 2: return_trace (c->dispatch (u.format2));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  SingleSubstFormat1    format1;\n+  SingleSubstFormat2    format2;\n+  } u;\n+};\n+\n+static inline void\n+SingleSubst_serialize (hb_serialize_context_t *c,\n+                       hb_array_t<const GlyphID> glyphs,\n+                       hb_array_t<const GlyphID> substitutes)\n+{ c->start_embed<SingleSubst> ()->serialize (c, glyphs, substitutes); }\n+\n+struct Sequence\n+{\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int count = substitute.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      c->out->add (substitute[i]);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { c->output->add_array (substitute.arrayZ, substitute.len); }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int count = substitute.len;\n+\n+    \/* Special-case to make it in-place and not consider this\n+     * as a \"multiplied\" substitution. *\/\n+    if (unlikely (count == 1))\n+    {\n+      c->replace_glyph (substitute.arrayZ[0]);\n+      return_trace (true);\n+    }\n+    \/* Spec disallows this, but Uniscribe allows it.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/253 *\/\n+    else if (unlikely (count == 0))\n+    {\n+      c->buffer->delete_glyph ();\n+      return_trace (true);\n+    }\n+\n+    unsigned int klass = _hb_glyph_info_is_ligature (&c->buffer->cur()) ?\n+                         HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH : 0;\n+\n+    for (unsigned int i = 0; i < count; i++) {\n+      _hb_glyph_info_set_lig_props_for_component (&c->buffer->cur(), i);\n+      c->output_glyph_for_component (substitute.arrayZ[i], klass);\n+    }\n+    c->buffer->skip_glyph ();\n+\n+    return_trace (true);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (substitute.serialize (c, glyphs));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (substitute.sanitize (c));\n+  }\n+\n+  protected:\n+  ArrayOf<GlyphID>\n+                substitute;             \/* String of GlyphIDs to substitute *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, substitute);\n+};\n+\n+struct MultipleSubstFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int count = sequence.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (c->glyphs->has (iter.get_glyph ()))\n+        (this+sequence[iter.get_coverage ()]).closure (c);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+    unsigned int count = sequence.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      (this+sequence[i]).collect_glyphs (c);\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    return_trace (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    return_trace ((this+sequence[index]).apply (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  hb_array_t<const unsigned int> substitute_len_list,\n+                  hb_array_t<const GlyphID> substitute_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!sequence.serialize (c, glyphs.length))) return_trace (false);\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+    {\n+      unsigned int substitute_len = substitute_len_list[i];\n+      if (unlikely (!sequence[i].serialize (c, this)\n+                                .serialize (c, substitute_glyphs_list.sub_array (0, substitute_len))))\n+        return_trace (false);\n+      substitute_glyphs_list += substitute_len;\n+    }\n+    return_trace (coverage.serialize (c, this).serialize (c, glyphs));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && sequence.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  OffsetArrayOf<Sequence>\n+                sequence;               \/* Array of Sequence tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, sequence);\n+};\n+\n+struct MultipleSubst\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  hb_array_t<const unsigned int> substitute_len_list,\n+                  hb_array_t<const GlyphID> substitute_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned int format = 1;\n+    u.format.set (format);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c, glyphs, substitute_len_list, substitute_glyphs_list));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  MultipleSubstFormat1  format1;\n+  } u;\n+};\n+\n+struct AlternateSet\n+{\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int count = alternates.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      c->out->add (alternates[i]);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  { c->output->add_array (alternates.arrayZ, alternates.len); }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int count = alternates.len;\n+\n+    if (unlikely (!count)) return_trace (false);\n+\n+    hb_mask_t glyph_mask = c->buffer->cur().mask;\n+    hb_mask_t lookup_mask = c->lookup_mask;\n+\n+    \/* Note: This breaks badly if two features enabled this lookup together. *\/\n+    unsigned int shift = hb_ctz (lookup_mask);\n+    unsigned int alt_index = ((lookup_mask & glyph_mask) >> shift);\n+\n+    \/* If alt_index is MAX, randomize feature if it is the rand feature. *\/\n+    if (alt_index == HB_OT_MAP_MAX_VALUE && c->random)\n+      alt_index = c->random_number () % count + 1;\n+\n+    if (unlikely (alt_index > count || alt_index == 0)) return_trace (false);\n+\n+    c->replace_glyph (alternates[alt_index - 1]);\n+\n+    return_trace (true);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs)\n+  {\n+    TRACE_SERIALIZE (this);\n+    return_trace (alternates.serialize (c, glyphs));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (alternates.sanitize (c));\n+  }\n+\n+  protected:\n+  ArrayOf<GlyphID>\n+                alternates;             \/* Array of alternate GlyphIDs--in\n+                                         * arbitrary order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, alternates);\n+};\n+\n+struct AlternateSubstFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  { return (this+coverage).intersects (glyphs); }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int count = alternateSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (c->glyphs->has (iter.get_glyph ()))\n+        (this+alternateSet[iter.get_coverage ()]).closure (c);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+    unsigned int count = alternateSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      (this+alternateSet[iter.get_coverage ()]).collect_glyphs (c);\n+    }\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    return_trace (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    return_trace ((this+alternateSet[index]).apply (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  hb_array_t<const unsigned int> alternate_len_list,\n+                  hb_array_t<const GlyphID> alternate_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!alternateSet.serialize (c, glyphs.length))) return_trace (false);\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+    {\n+      unsigned int alternate_len = alternate_len_list[i];\n+      if (unlikely (!alternateSet[i].serialize (c, this)\n+                                    .serialize (c, alternate_glyphs_list.sub_array (0, alternate_len))))\n+        return_trace (false);\n+      alternate_glyphs_list += alternate_len;\n+    }\n+    return_trace (coverage.serialize (c, this).serialize (c, glyphs));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && alternateSet.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  OffsetArrayOf<AlternateSet>\n+                alternateSet;           \/* Array of AlternateSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, alternateSet);\n+};\n+\n+struct AlternateSubst\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> glyphs,\n+                  hb_array_t<const unsigned int> alternate_len_list,\n+                  hb_array_t<const GlyphID> alternate_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned int format = 1;\n+    u.format.set (format);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c, glyphs, alternate_len_list, alternate_glyphs_list));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  AlternateSubstFormat1 format1;\n+  } u;\n+};\n+\n+\n+struct Ligature\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    unsigned int count = component.lenP1;\n+    for (unsigned int i = 1; i < count; i++)\n+      if (!glyphs->has (component[i]))\n+        return false;\n+    return true;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int count = component.lenP1;\n+    for (unsigned int i = 1; i < count; i++)\n+      if (!c->glyphs->has (component[i]))\n+        return;\n+    c->out->add (ligGlyph);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    c->input->add_array (component.arrayZ, component.lenP1 ? component.lenP1 - 1 : 0);\n+    c->output->add (ligGlyph);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    if (c->len != component.lenP1)\n+      return_trace (false);\n+\n+    for (unsigned int i = 1; i < c->len; i++)\n+      if (likely (c->glyphs[i] != component[i]))\n+        return_trace (false);\n+\n+    return_trace (true);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int count = component.lenP1;\n+\n+    if (unlikely (!count)) return_trace (false);\n+\n+    \/* Special-case to make it in-place and not consider this\n+     * as a \"ligated\" substitution. *\/\n+    if (unlikely (count == 1))\n+    {\n+      c->replace_glyph (ligGlyph);\n+      return_trace (true);\n+    }\n+\n+    unsigned int total_component_count = 0;\n+\n+    unsigned int match_length = 0;\n+    unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n+\n+    if (likely (!match_input (c, count,\n+                              &component[1],\n+                              match_glyph,\n+                              nullptr,\n+                              &match_length,\n+                              match_positions,\n+                              &total_component_count)))\n+      return_trace (false);\n+\n+    ligate_input (c,\n+                  count,\n+                  match_positions,\n+                  match_length,\n+                  ligGlyph,\n+                  total_component_count);\n+\n+    return_trace (true);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  GlyphID ligature,\n+                  hb_array_t<const GlyphID> components \/* Starting from second *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    ligGlyph = ligature;\n+    if (unlikely (!component.serialize (c, components))) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  public:\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (ligGlyph.sanitize (c) && component.sanitize (c));\n+  }\n+\n+  protected:\n+  GlyphID       ligGlyph;               \/* GlyphID of ligature to substitute *\/\n+  HeadlessArrayOf<GlyphID>\n+                component;              \/* Array of component GlyphIDs--start\n+                                         * with the second  component--ordered\n+                                         * in writing direction *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, component);\n+};\n+\n+struct LigatureSet\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    unsigned int num_ligs = ligature.len;\n+    for (unsigned int i = 0; i < num_ligs; i++)\n+      if ((this+ligature[i]).intersects (glyphs))\n+        return true;\n+    return false;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int num_ligs = ligature.len;\n+    for (unsigned int i = 0; i < num_ligs; i++)\n+      (this+ligature[i]).closure (c);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    unsigned int num_ligs = ligature.len;\n+    for (unsigned int i = 0; i < num_ligs; i++)\n+      (this+ligature[i]).collect_glyphs (c);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    unsigned int num_ligs = ligature.len;\n+    for (unsigned int i = 0; i < num_ligs; i++)\n+    {\n+      const Ligature &lig = this+ligature[i];\n+      if (lig.would_apply (c))\n+        return_trace (true);\n+    }\n+    return_trace (false);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int num_ligs = ligature.len;\n+    for (unsigned int i = 0; i < num_ligs; i++)\n+    {\n+      const Ligature &lig = this+ligature[i];\n+      if (lig.apply (c)) return_trace (true);\n+    }\n+\n+    return_trace (false);\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> ligatures,\n+                  hb_array_t<const unsigned int> component_count_list,\n+                  hb_array_t<const GlyphID> &component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!ligature.serialize (c, ligatures.length))) return_trace (false);\n+    for (unsigned int i = 0; i < ligatures.length; i++)\n+    {\n+      unsigned int component_count = MAX<int> (component_count_list[i] - 1, 0);\n+      if (unlikely (!ligature[i].serialize (c, this)\n+                                .serialize (c,\n+                                            ligatures[i],\n+                                            component_list.sub_array (0, component_count))))\n+        return_trace (false);\n+      component_list += component_count;\n+    }\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (ligature.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetArrayOf<Ligature>\n+                ligature;               \/* Array LigatureSet tables\n+                                         * ordered by preference *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, ligature);\n+};\n+\n+struct LigatureSubstFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    unsigned int count = ligatureSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (glyphs->has (iter.get_glyph ()) &&\n+          (this+ligatureSet[iter.get_coverage ()]).intersects (glyphs))\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    unsigned int count = ligatureSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (c->glyphs->has (iter.get_glyph ()))\n+        (this+ligatureSet[iter.get_coverage ()]).closure (c);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+    unsigned int count = ligatureSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      (this+ligatureSet[iter.get_coverage ()]).collect_glyphs (c);\n+    }\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    unsigned int index = (this+coverage).get_coverage (c->glyphs[0]);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const LigatureSet &lig_set = this+ligatureSet[index];\n+    return_trace (lig_set.would_apply (c));\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const LigatureSet &lig_set = this+ligatureSet[index];\n+    return_trace (lig_set.apply (c));\n+  }\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> first_glyphs,\n+                  hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n+                  hb_array_t<const GlyphID> ligatures_list,\n+                  hb_array_t<const unsigned int> component_count_list,\n+                  hb_array_t<const GlyphID> component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (*this))) return_trace (false);\n+    if (unlikely (!ligatureSet.serialize (c, first_glyphs.length))) return_trace (false);\n+    for (unsigned int i = 0; i < first_glyphs.length; i++)\n+    {\n+      unsigned int ligature_count = ligature_per_first_glyph_count_list[i];\n+      if (unlikely (!ligatureSet[i].serialize (c, this)\n+                                   .serialize (c,\n+                                               ligatures_list.sub_array (0, ligature_count),\n+                                               component_count_list.sub_array (0, ligature_count),\n+                                               component_list))) return_trace (false);\n+      ligatures_list += ligature_count;\n+      component_count_list += ligature_count;\n+    }\n+    return_trace (coverage.serialize (c, this).serialize (c, first_glyphs));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && ligatureSet.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of Substitution table *\/\n+  OffsetArrayOf<LigatureSet>\n+                ligatureSet;            \/* Array LigatureSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, ligatureSet);\n+};\n+\n+struct LigatureSubst\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  hb_array_t<const GlyphID> first_glyphs,\n+                  hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n+                  hb_array_t<const GlyphID> ligatures_list,\n+                  hb_array_t<const unsigned int> component_count_list,\n+                  hb_array_t<const GlyphID> component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!c->extend_min (u.format))) return_trace (false);\n+    unsigned int format = 1;\n+    u.format.set (format);\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.serialize (c,\n+                                               first_glyphs,\n+                                               ligature_per_first_glyph_count_list,\n+                                               ligatures_list,\n+                                               component_count_list,\n+                                               component_list));\n+    default:return_trace (false);\n+    }\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  LigatureSubstFormat1  format1;\n+  } u;\n+};\n+\n+\n+struct ContextSubst : Context {};\n+\n+struct ChainContextSubst : ChainContext {};\n+\n+struct ExtensionSubst : Extension<ExtensionSubst>\n+{\n+  typedef struct SubstLookupSubTable SubTable;\n+\n+  bool is_reverse () const;\n+};\n+\n+\n+struct ReverseChainSingleSubstFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    if (!(this+coverage).intersects (glyphs))\n+      return false;\n+\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+\n+    unsigned int count;\n+\n+    count = backtrack.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!(this+backtrack[i]).intersects (glyphs))\n+        return false;\n+\n+    count = lookahead.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!(this+lookahead[i]).intersects (glyphs))\n+        return false;\n+\n+    return true;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+\n+    unsigned int count;\n+\n+    count = backtrack.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!(this+backtrack[i]).intersects (c->glyphs))\n+        return;\n+\n+    count = lookahead.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!(this+lookahead[i]).intersects (c->glyphs))\n+        return;\n+\n+    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n+    count = substitute.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (c->glyphs->has (iter.get_glyph ()))\n+        c->out->add (substitute[iter.get_coverage ()]);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    if (unlikely (!(this+coverage).add_coverage (c->input))) return;\n+\n+    unsigned int count;\n+\n+    count = backtrack.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!(this+backtrack[i]).add_coverage (c->before))) return;\n+\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+    count = lookahead.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!(this+lookahead[i]).add_coverage (c->after))) return;\n+\n+    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n+    count = substitute.len;\n+    c->output->add_array (substitute.arrayZ, substitute.len);\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    return_trace (c->len == 1 && (this+coverage).get_coverage (c->glyphs[0]) != NOT_COVERED);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    if (unlikely (c->nesting_level_left != HB_MAX_NESTING_LEVEL))\n+      return_trace (false); \/* No chaining to this type *\/\n+\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n+\n+  unsigned int start_index = 0, end_index = 0;\n+    if (match_backtrack (c,\n+                         backtrack.len, (HBUINT16 *) backtrack.arrayZ,\n+                         match_coverage, this,\n+                         &start_index) &&\n+        match_lookahead (c,\n+                         lookahead.len, (HBUINT16 *) lookahead.arrayZ,\n+                         match_coverage, this,\n+                         1, &end_index))\n+    {\n+      c->buffer->unsafe_to_break_from_outbuffer (start_index, end_index);\n+      c->replace_glyph_inplace (substitute[index]);\n+      \/* Note: We DON'T decrease buffer->idx.  The main loop does it\n+       * for us.  This is useful for preventing surprises if someone\n+       * calls us through a Context lookup. *\/\n+      return_trace (true);\n+    }\n+\n+    return_trace (false);\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!(coverage.sanitize (c, this) && backtrack.sanitize (c, this)))\n+      return_trace (false);\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+    if (!lookahead.sanitize (c, this))\n+      return_trace (false);\n+    const ArrayOf<GlyphID> &substitute = StructAfter<ArrayOf<GlyphID> > (lookahead);\n+    return_trace (substitute.sanitize (c));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of table *\/\n+  OffsetArrayOf<Coverage>\n+                backtrack;              \/* Array of coverage tables\n+                                         * in backtracking sequence, in glyph\n+                                         * sequence order *\/\n+  OffsetArrayOf<Coverage>\n+                lookaheadX;             \/* Array of coverage tables\n+                                         * in lookahead sequence, in glyph\n+                                         * sequence order *\/\n+  ArrayOf<GlyphID>\n+                substituteX;            \/* Array of substitute\n+                                         * GlyphIDs--ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_MIN (10);\n+};\n+\n+struct ReverseChainSingleSubst\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16                              format;         \/* Format identifier *\/\n+  ReverseChainSingleSubstFormat1        format1;\n+  } u;\n+};\n+\n+\n+\n+\/*\n+ * SubstLookup\n+ *\/\n+\n+struct SubstLookupSubTable\n+{\n+  friend struct Lookup;\n+  friend struct SubstLookup;\n+\n+  enum Type {\n+    Single              = 1,\n+    Multiple            = 2,\n+    Alternate           = 3,\n+    Ligature            = 4,\n+    Context             = 5,\n+    ChainContext        = 6,\n+    Extension           = 7,\n+    ReverseChainSingle  = 8\n+  };\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c, unsigned int lookup_type) const\n+  {\n+    TRACE_DISPATCH (this, lookup_type);\n+    switch (lookup_type) {\n+    case Single:                return_trace (u.single.dispatch (c));\n+    case Multiple:              return_trace (u.multiple.dispatch (c));\n+    case Alternate:             return_trace (u.alternate.dispatch (c));\n+    case Ligature:              return_trace (u.ligature.dispatch (c));\n+    case Context:               return_trace (u.context.dispatch (c));\n+    case ChainContext:          return_trace (u.chainContext.dispatch (c));\n+    case Extension:             return_trace (u.extension.dispatch (c));\n+    case ReverseChainSingle:    return_trace (u.reverseChainContextSingle.dispatch (c));\n+    default:                    return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  SingleSubst                   single;\n+  MultipleSubst                 multiple;\n+  AlternateSubst                alternate;\n+  LigatureSubst                 ligature;\n+  ContextSubst                  context;\n+  ChainContextSubst             chainContext;\n+  ExtensionSubst                extension;\n+  ReverseChainSingleSubst       reverseChainContextSingle;\n+  } u;\n+  public:\n+  DEFINE_SIZE_MIN (0);\n+};\n+\n+\n+struct SubstLookup : Lookup\n+{\n+  typedef SubstLookupSubTable SubTable;\n+\n+  const SubTable& get_subtable (unsigned int i) const\n+  { return Lookup::get_subtable<SubTable> (i); }\n+\n+  static bool lookup_type_is_reverse (unsigned int lookup_type)\n+  { return lookup_type == SubTable::ReverseChainSingle; }\n+\n+  bool is_reverse () const\n+  {\n+    unsigned int type = get_type ();\n+    if (unlikely (type == SubTable::Extension))\n+      return CastR<ExtensionSubst> (get_subtable(0)).is_reverse ();\n+    return lookup_type_is_reverse (type);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    return_trace (dispatch (c));\n+  }\n+\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    hb_intersects_context_t c (glyphs);\n+    return dispatch (&c);\n+  }\n+\n+  hb_closure_context_t::return_t closure (hb_closure_context_t *c, unsigned int this_index) const\n+  {\n+    if (!c->should_visit_lookup (this_index))\n+      return hb_closure_context_t::default_return_value ();\n+\n+    c->set_recurse_func (dispatch_closure_recurse_func);\n+\n+    hb_closure_context_t::return_t ret = dispatch (c);\n+\n+    c->flush ();\n+\n+    return ret;\n+  }\n+\n+  hb_collect_glyphs_context_t::return_t collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    c->set_recurse_func (dispatch_recurse_func<hb_collect_glyphs_context_t>);\n+    return dispatch (c);\n+  }\n+\n+  template <typename set_t>\n+  void add_coverage (set_t *glyphs) const\n+  {\n+    hb_add_coverage_context_t<set_t> c (glyphs);\n+    dispatch (&c);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c,\n+                    const hb_ot_layout_lookup_accelerator_t *accel) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    if (unlikely (!c->len))  return_trace (false);\n+    if (!accel->may_have (c->glyphs[0]))  return_trace (false);\n+      return_trace (dispatch (c));\n+  }\n+\n+  static bool apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index);\n+\n+  SubTable& serialize_subtable (hb_serialize_context_t *c,\n+                                       unsigned int i)\n+  { return get_subtables<SubTable> ()[i].serialize (c, this); }\n+\n+  bool serialize_single (hb_serialize_context_t *c,\n+                         uint32_t lookup_props,\n+                         hb_array_t<const GlyphID> glyphs,\n+                         hb_array_t<const GlyphID> substitutes)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Single, lookup_props, 1))) return_trace (false);\n+    return_trace (serialize_subtable (c, 0).u.single.serialize (c, glyphs, substitutes));\n+  }\n+\n+  bool serialize_multiple (hb_serialize_context_t *c,\n+                           uint32_t lookup_props,\n+                           hb_array_t<const GlyphID> glyphs,\n+                           hb_array_t<const unsigned int> substitute_len_list,\n+                           hb_array_t<const GlyphID> substitute_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Multiple, lookup_props, 1))) return_trace (false);\n+    return_trace (serialize_subtable (c, 0).u.multiple.serialize (c,\n+                                                                  glyphs,\n+                                                                  substitute_len_list,\n+                                                                  substitute_glyphs_list));\n+  }\n+\n+  bool serialize_alternate (hb_serialize_context_t *c,\n+                            uint32_t lookup_props,\n+                            hb_array_t<const GlyphID> glyphs,\n+                            hb_array_t<const unsigned int> alternate_len_list,\n+                            hb_array_t<const GlyphID> alternate_glyphs_list)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Alternate, lookup_props, 1))) return_trace (false);\n+    return_trace (serialize_subtable (c, 0).u.alternate.serialize (c,\n+                                                                   glyphs,\n+                                                                   alternate_len_list,\n+                                                                   alternate_glyphs_list));\n+  }\n+\n+  bool serialize_ligature (hb_serialize_context_t *c,\n+                           uint32_t lookup_props,\n+                           hb_array_t<const GlyphID> first_glyphs,\n+                           hb_array_t<const unsigned int> ligature_per_first_glyph_count_list,\n+                           hb_array_t<const GlyphID> ligatures_list,\n+                           hb_array_t<const unsigned int> component_count_list,\n+                           hb_array_t<const GlyphID> component_list \/* Starting from second for each ligature *\/)\n+  {\n+    TRACE_SERIALIZE (this);\n+    if (unlikely (!Lookup::serialize (c, SubTable::Ligature, lookup_props, 1))) return_trace (false);\n+    return_trace (serialize_subtable (c, 0).u.ligature.serialize (c,\n+                                                                  first_glyphs,\n+                                                                  ligature_per_first_glyph_count_list,\n+                                                                  ligatures_list,\n+                                                                  component_count_list,\n+                                                                  component_list));\n+  }\n+\n+  template <typename context_t>\n+  static typename context_t::return_t dispatch_recurse_func (context_t *c, unsigned int lookup_index);\n+\n+  static hb_closure_context_t::return_t dispatch_closure_recurse_func (hb_closure_context_t *c, unsigned int lookup_index)\n+  {\n+    if (!c->should_visit_lookup (lookup_index))\n+      return HB_VOID;\n+\n+    hb_closure_context_t::return_t ret = dispatch_recurse_func (c, lookup_index);\n+\n+    \/* While in theory we should flush here, it will cause timeouts because a recursive\n+     * lookup can keep growing the glyph set.  Skip, and outer loop will retry up to\n+     * HB_CLOSURE_MAX_STAGES time, which should be enough for every realistic font. *\/\n+    \/\/c->flush ();\n+\n+    return ret;\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  { return Lookup::dispatch<SubTable> (c); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  { return Lookup::subset<SubTable> (c); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return Lookup::sanitize<SubTable> (c); }\n+};\n+\n+\/*\n+ * GSUB -- Glyph Substitution\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/gsub\n+ *\/\n+\n+struct GSUB : GSUBGPOS\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_GSUB;\n+\n+  const SubstLookup& get_lookup (unsigned int i) const\n+  { return CastR<SubstLookup> (GSUBGPOS::get_lookup (i)); }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  { return GSUBGPOS::subset<SubstLookup> (c); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  { return GSUBGPOS::sanitize<SubstLookup> (c); }\n+\n+  HB_INTERNAL bool is_blacklisted (hb_blob_t *blob,\n+                                   hb_face_t *face) const;\n+\n+  typedef GSUBGPOS::accelerator_t<GSUB> accelerator_t;\n+};\n+\n+\n+struct GSUB_accelerator_t : GSUB::accelerator_t {};\n+\n+\n+\/* Out-of-class implementation for methods recursing *\/\n+\n+\/*static*\/ inline bool ExtensionSubst::is_reverse () const\n+{\n+  unsigned int type = get_type ();\n+  if (unlikely (type == SubTable::Extension))\n+    return CastR<ExtensionSubst> (get_subtable<SubTable>()).is_reverse ();\n+  return SubstLookup::lookup_type_is_reverse (type);\n+}\n+\n+template <typename context_t>\n+\/*static*\/ inline typename context_t::return_t SubstLookup::dispatch_recurse_func (context_t *c, unsigned int lookup_index)\n+{\n+  const SubstLookup &l = c->face->table.GSUB.get_relaxed ()->table->get_lookup (lookup_index);\n+  return l.dispatch (c);\n+}\n+\n+\/*static*\/ inline bool SubstLookup::apply_recurse_func (hb_ot_apply_context_t *c, unsigned int lookup_index)\n+{\n+  const SubstLookup &l = c->face->table.GSUB.get_relaxed ()->table->get_lookup (lookup_index);\n+  unsigned int saved_lookup_props = c->lookup_props;\n+  unsigned int saved_lookup_index = c->lookup_index;\n+  c->set_lookup_index (lookup_index);\n+  c->set_lookup_props (l.get_props ());\n+  bool ret = l.dispatch (c);\n+  c->set_lookup_index (saved_lookup_index);\n+  c->set_lookup_props (saved_lookup_props);\n+  return ret;\n+}\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_LAYOUT_GSUB_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout-gsub-table.hh","additions":1467,"deletions":0,"binary":false,"changes":1467,"status":"added"},{"patch":"@@ -0,0 +1,2779 @@\n+\/*\n+ * Copyright © 2007,2008,2009,2010  Red Hat, Inc.\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_GSUBGPOS_HH\n+#define HB_OT_LAYOUT_GSUBGPOS_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-buffer.hh\"\n+#include \"hb-map.hh\"\n+#include \"hb-set.hh\"\n+#include \"hb-ot-map.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-ot-layout-gdef-table.hh\"\n+\n+\n+namespace OT {\n+\n+\n+struct hb_intersects_context_t :\n+       hb_dispatch_context_t<hb_intersects_context_t, bool, 0>\n+{\n+  const char *get_name () { return \"INTERSECTS\"; }\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.intersects (this->glyphs); }\n+  static return_t default_return_value () { return false; }\n+  bool stop_sublookup_iteration (return_t r) const { return r; }\n+\n+  const hb_set_t *glyphs;\n+  unsigned int debug_depth;\n+\n+  hb_intersects_context_t (const hb_set_t *glyphs_) :\n+                             glyphs (glyphs_),\n+                             debug_depth (0) {}\n+};\n+\n+struct hb_closure_context_t :\n+       hb_dispatch_context_t<hb_closure_context_t, hb_void_t, 0>\n+{\n+  const char *get_name () { return \"CLOSURE\"; }\n+  typedef return_t (*recurse_func_t) (hb_closure_context_t *c, unsigned int lookup_index);\n+  template <typename T>\n+  return_t dispatch (const T &obj) { obj.closure (this); return HB_VOID; }\n+  static return_t default_return_value () { return HB_VOID; }\n+  void recurse (unsigned int lookup_index)\n+  {\n+    if (unlikely (nesting_level_left == 0 || !recurse_func))\n+      return;\n+\n+    nesting_level_left--;\n+    recurse_func (this, lookup_index);\n+    nesting_level_left++;\n+  }\n+\n+  bool should_visit_lookup (unsigned int lookup_index)\n+  {\n+    if (is_lookup_done (lookup_index))\n+      return false;\n+    done_lookups->set (lookup_index, glyphs->get_population ());\n+    return true;\n+  }\n+\n+  bool is_lookup_done (unsigned int lookup_index)\n+  {\n+    \/* Have we visited this lookup with the current set of glyphs? *\/\n+    return done_lookups->get (lookup_index) == glyphs->get_population ();\n+  }\n+\n+  hb_face_t *face;\n+  hb_set_t *glyphs;\n+  hb_set_t out[1];\n+  recurse_func_t recurse_func;\n+  unsigned int nesting_level_left;\n+  unsigned int debug_depth;\n+\n+  hb_closure_context_t (hb_face_t *face_,\n+                        hb_set_t *glyphs_,\n+                        hb_map_t *done_lookups_,\n+                        unsigned int nesting_level_left_ = HB_MAX_NESTING_LEVEL) :\n+                          face (face_),\n+                          glyphs (glyphs_),\n+                          recurse_func (nullptr),\n+                          nesting_level_left (nesting_level_left_),\n+                          debug_depth (0),\n+                          done_lookups (done_lookups_) {}\n+\n+  ~hb_closure_context_t () { flush (); }\n+\n+  void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n+\n+  void flush ()\n+  {\n+    hb_set_union (glyphs, out);\n+    hb_set_clear (out);\n+  }\n+\n+  private:\n+  hb_map_t *done_lookups;\n+};\n+\n+\n+struct hb_would_apply_context_t :\n+       hb_dispatch_context_t<hb_would_apply_context_t, bool, HB_DEBUG_WOULD_APPLY>\n+{\n+  const char *get_name () { return \"WOULD_APPLY\"; }\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.would_apply (this); }\n+  static return_t default_return_value () { return false; }\n+  bool stop_sublookup_iteration (return_t r) const { return r; }\n+\n+  hb_face_t *face;\n+  const hb_codepoint_t *glyphs;\n+  unsigned int len;\n+  bool zero_context;\n+  unsigned int debug_depth;\n+\n+  hb_would_apply_context_t (hb_face_t *face_,\n+                            const hb_codepoint_t *glyphs_,\n+                            unsigned int len_,\n+                            bool zero_context_) :\n+                              face (face_),\n+                              glyphs (glyphs_),\n+                              len (len_),\n+                              zero_context (zero_context_),\n+                              debug_depth (0) {}\n+};\n+\n+\n+struct hb_collect_glyphs_context_t :\n+       hb_dispatch_context_t<hb_collect_glyphs_context_t, hb_void_t, 0>\n+{\n+  const char *get_name () { return \"COLLECT_GLYPHS\"; }\n+  typedef return_t (*recurse_func_t) (hb_collect_glyphs_context_t *c, unsigned int lookup_index);\n+  template <typename T>\n+  return_t dispatch (const T &obj) { obj.collect_glyphs (this); return HB_VOID; }\n+  static return_t default_return_value () { return HB_VOID; }\n+  void recurse (unsigned int lookup_index)\n+  {\n+    if (unlikely (nesting_level_left == 0 || !recurse_func))\n+      return;\n+\n+    \/* Note that GPOS sets recurse_func to nullptr already, so it doesn't get\n+     * past the previous check.  For GSUB, we only want to collect the output\n+     * glyphs in the recursion.  If output is not requested, we can go home now.\n+     *\n+     * Note further, that the above is not exactly correct.  A recursed lookup\n+     * is allowed to match input that is not matched in the context, but that's\n+     * not how most fonts are built.  It's possible to relax that and recurse\n+     * with all sets here if it proves to be an issue.\n+     *\/\n+\n+    if (output == hb_set_get_empty ())\n+      return;\n+\n+    \/* Return if new lookup was recursed to before. *\/\n+    if (recursed_lookups->has (lookup_index))\n+      return;\n+\n+    hb_set_t *old_before = before;\n+    hb_set_t *old_input  = input;\n+    hb_set_t *old_after  = after;\n+    before = input = after = hb_set_get_empty ();\n+\n+    nesting_level_left--;\n+    recurse_func (this, lookup_index);\n+    nesting_level_left++;\n+\n+    before = old_before;\n+    input  = old_input;\n+    after  = old_after;\n+\n+    recursed_lookups->add (lookup_index);\n+  }\n+\n+  hb_face_t *face;\n+  hb_set_t *before;\n+  hb_set_t *input;\n+  hb_set_t *after;\n+  hb_set_t *output;\n+  recurse_func_t recurse_func;\n+  hb_set_t *recursed_lookups;\n+  unsigned int nesting_level_left;\n+  unsigned int debug_depth;\n+\n+  hb_collect_glyphs_context_t (hb_face_t *face_,\n+                               hb_set_t  *glyphs_before, \/* OUT.  May be NULL *\/\n+                               hb_set_t  *glyphs_input,  \/* OUT.  May be NULL *\/\n+                               hb_set_t  *glyphs_after,  \/* OUT.  May be NULL *\/\n+                               hb_set_t  *glyphs_output, \/* OUT.  May be NULL *\/\n+                               unsigned int nesting_level_left_ = HB_MAX_NESTING_LEVEL) :\n+                              face (face_),\n+                              before (glyphs_before ? glyphs_before : hb_set_get_empty ()),\n+                              input  (glyphs_input  ? glyphs_input  : hb_set_get_empty ()),\n+                              after  (glyphs_after  ? glyphs_after  : hb_set_get_empty ()),\n+                              output (glyphs_output ? glyphs_output : hb_set_get_empty ()),\n+                              recurse_func (nullptr),\n+                              recursed_lookups (hb_set_create ()),\n+                              nesting_level_left (nesting_level_left_),\n+                              debug_depth (0) {}\n+  ~hb_collect_glyphs_context_t () { hb_set_destroy (recursed_lookups); }\n+\n+  void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n+};\n+\n+\n+\n+template <typename set_t>\n+struct hb_add_coverage_context_t :\n+       hb_dispatch_context_t<hb_add_coverage_context_t<set_t>, const Coverage &, HB_DEBUG_GET_COVERAGE>\n+{\n+  const char *get_name () { return \"GET_COVERAGE\"; }\n+  typedef const Coverage &return_t;\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.get_coverage (); }\n+  static return_t default_return_value () { return Null(Coverage); }\n+  bool stop_sublookup_iteration (return_t r) const\n+  {\n+    r.add_coverage (set);\n+    return false;\n+  }\n+\n+  hb_add_coverage_context_t (set_t *set_) :\n+                            set (set_),\n+                            debug_depth (0) {}\n+\n+  set_t *set;\n+  unsigned int debug_depth;\n+};\n+\n+\n+struct hb_ot_apply_context_t :\n+       hb_dispatch_context_t<hb_ot_apply_context_t, bool, HB_DEBUG_APPLY>\n+{\n+  struct matcher_t\n+  {\n+    matcher_t () :\n+             lookup_props (0),\n+             ignore_zwnj (false),\n+             ignore_zwj (false),\n+             mask (-1),\n+#define arg1(arg) (arg) \/* Remove the macro to see why it's needed! *\/\n+             syllable arg1(0),\n+#undef arg1\n+             match_func (nullptr),\n+             match_data (nullptr) {}\n+\n+    typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data);\n+\n+    void set_ignore_zwnj (bool ignore_zwnj_) { ignore_zwnj = ignore_zwnj_; }\n+    void set_ignore_zwj (bool ignore_zwj_) { ignore_zwj = ignore_zwj_; }\n+    void set_lookup_props (unsigned int lookup_props_) { lookup_props = lookup_props_; }\n+    void set_mask (hb_mask_t mask_) { mask = mask_; }\n+    void set_syllable (uint8_t syllable_)  { syllable = syllable_; }\n+    void set_match_func (match_func_t match_func_,\n+                                const void *match_data_)\n+    { match_func = match_func_; match_data = match_data_; }\n+\n+    enum may_match_t {\n+      MATCH_NO,\n+      MATCH_YES,\n+      MATCH_MAYBE\n+    };\n+\n+    may_match_t may_match (const hb_glyph_info_t &info,\n+                                  const HBUINT16        *glyph_data) const\n+    {\n+      if (!(info.mask & mask) ||\n+          (syllable && syllable != info.syllable ()))\n+        return MATCH_NO;\n+\n+      if (match_func)\n+        return match_func (info.codepoint, *glyph_data, match_data) ? MATCH_YES : MATCH_NO;\n+\n+      return MATCH_MAYBE;\n+    }\n+\n+    enum may_skip_t {\n+      SKIP_NO,\n+      SKIP_YES,\n+      SKIP_MAYBE\n+    };\n+\n+    may_skip_t may_skip (const hb_ot_apply_context_t *c,\n+                         const hb_glyph_info_t       &info) const\n+    {\n+      if (!c->check_glyph_property (&info, lookup_props))\n+        return SKIP_YES;\n+\n+      if (unlikely (_hb_glyph_info_is_default_ignorable_and_not_hidden (&info) &&\n+                    (ignore_zwnj || !_hb_glyph_info_is_zwnj (&info)) &&\n+                    (ignore_zwj || !_hb_glyph_info_is_zwj (&info))))\n+        return SKIP_MAYBE;\n+\n+      return SKIP_NO;\n+    }\n+\n+    protected:\n+    unsigned int lookup_props;\n+    bool ignore_zwnj;\n+    bool ignore_zwj;\n+    hb_mask_t mask;\n+    uint8_t syllable;\n+    match_func_t match_func;\n+    const void *match_data;\n+  };\n+\n+  struct skipping_iterator_t\n+  {\n+    void init (hb_ot_apply_context_t *c_, bool context_match = false)\n+    {\n+      c = c_;\n+      match_glyph_data = nullptr;\n+      matcher.set_match_func (nullptr, nullptr);\n+      matcher.set_lookup_props (c->lookup_props);\n+      \/* Ignore ZWNJ if we are matching GPOS, or matching GSUB context and asked to. *\/\n+      matcher.set_ignore_zwnj (c->table_index == 1 || (context_match && c->auto_zwnj));\n+      \/* Ignore ZWJ if we are matching context, or asked to. *\/\n+      matcher.set_ignore_zwj  (context_match || c->auto_zwj);\n+      matcher.set_mask (context_match ? -1 : c->lookup_mask);\n+    }\n+    void set_lookup_props (unsigned int lookup_props)\n+    {\n+      matcher.set_lookup_props (lookup_props);\n+    }\n+    void set_match_func (matcher_t::match_func_t match_func_,\n+                         const void *match_data_,\n+                         const HBUINT16 glyph_data[])\n+    {\n+      matcher.set_match_func (match_func_, match_data_);\n+      match_glyph_data = glyph_data;\n+    }\n+\n+    void reset (unsigned int start_index_,\n+                       unsigned int num_items_)\n+    {\n+      idx = start_index_;\n+      num_items = num_items_;\n+      end = c->buffer->len;\n+      matcher.set_syllable (start_index_ == c->buffer->idx ? c->buffer->cur().syllable () : 0);\n+    }\n+\n+    void reject () { num_items++; match_glyph_data--; }\n+\n+    matcher_t::may_skip_t\n+    may_skip (const hb_glyph_info_t &info) const\n+    { return matcher.may_skip (c, info); }\n+\n+    bool next ()\n+    {\n+      assert (num_items > 0);\n+      while (idx + num_items < end)\n+      {\n+        idx++;\n+        const hb_glyph_info_t &info = c->buffer->info[idx];\n+\n+        matcher_t::may_skip_t skip = matcher.may_skip (c, info);\n+        if (unlikely (skip == matcher_t::SKIP_YES))\n+          continue;\n+\n+        matcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n+        if (match == matcher_t::MATCH_YES ||\n+            (match == matcher_t::MATCH_MAYBE &&\n+             skip == matcher_t::SKIP_NO))\n+        {\n+          num_items--;\n+          match_glyph_data++;\n+          return true;\n+        }\n+\n+        if (skip == matcher_t::SKIP_NO)\n+          return false;\n+      }\n+      return false;\n+    }\n+    bool prev ()\n+    {\n+      assert (num_items > 0);\n+      while (idx > num_items - 1)\n+      {\n+        idx--;\n+        const hb_glyph_info_t &info = c->buffer->out_info[idx];\n+\n+        matcher_t::may_skip_t skip = matcher.may_skip (c, info);\n+        if (unlikely (skip == matcher_t::SKIP_YES))\n+          continue;\n+\n+        matcher_t::may_match_t match = matcher.may_match (info, match_glyph_data);\n+        if (match == matcher_t::MATCH_YES ||\n+            (match == matcher_t::MATCH_MAYBE &&\n+             skip == matcher_t::SKIP_NO))\n+        {\n+          num_items--;\n+          match_glyph_data++;\n+          return true;\n+        }\n+\n+        if (skip == matcher_t::SKIP_NO)\n+          return false;\n+      }\n+      return false;\n+    }\n+\n+    unsigned int idx;\n+    protected:\n+    hb_ot_apply_context_t *c;\n+    matcher_t matcher;\n+    const HBUINT16 *match_glyph_data;\n+\n+    unsigned int num_items;\n+    unsigned int end;\n+  };\n+\n+\n+  const char *get_name () { return \"APPLY\"; }\n+  typedef return_t (*recurse_func_t) (hb_ot_apply_context_t *c, unsigned int lookup_index);\n+  template <typename T>\n+  return_t dispatch (const T &obj) { return obj.apply (this); }\n+  static return_t default_return_value () { return false; }\n+  bool stop_sublookup_iteration (return_t r) const { return r; }\n+  return_t recurse (unsigned int sub_lookup_index)\n+  {\n+    if (unlikely (nesting_level_left == 0 || !recurse_func || buffer->max_ops-- <= 0))\n+      return default_return_value ();\n+\n+    nesting_level_left--;\n+    bool ret = recurse_func (this, sub_lookup_index);\n+    nesting_level_left++;\n+    return ret;\n+  }\n+\n+  skipping_iterator_t iter_input, iter_context;\n+\n+  hb_font_t *font;\n+  hb_face_t *face;\n+  hb_buffer_t *buffer;\n+  recurse_func_t recurse_func;\n+  const GDEF &gdef;\n+  const VariationStore &var_store;\n+\n+  hb_direction_t direction;\n+  hb_mask_t lookup_mask;\n+  unsigned int table_index; \/* GSUB\/GPOS *\/\n+  unsigned int lookup_index;\n+  unsigned int lookup_props;\n+  unsigned int nesting_level_left;\n+  unsigned int debug_depth;\n+\n+  bool has_glyph_classes;\n+  bool auto_zwnj;\n+  bool auto_zwj;\n+  bool random;\n+\n+  uint32_t random_state;\n+\n+\n+  hb_ot_apply_context_t (unsigned int table_index_,\n+                      hb_font_t *font_,\n+                      hb_buffer_t *buffer_) :\n+                        iter_input (), iter_context (),\n+                        font (font_), face (font->face), buffer (buffer_),\n+                        recurse_func (nullptr),\n+                        gdef (*face->table.GDEF->table),\n+                        var_store (gdef.get_var_store ()),\n+                        direction (buffer_->props.direction),\n+                        lookup_mask (1),\n+                        table_index (table_index_),\n+                        lookup_index ((unsigned int) -1),\n+                        lookup_props (0),\n+                        nesting_level_left (HB_MAX_NESTING_LEVEL),\n+                        debug_depth (0),\n+                        has_glyph_classes (gdef.has_glyph_classes ()),\n+                        auto_zwnj (true),\n+                        auto_zwj (true),\n+                        random (false),\n+                        random_state (1) { init_iters (); }\n+\n+  void init_iters ()\n+  {\n+    iter_input.init (this, false);\n+    iter_context.init (this, true);\n+  }\n+\n+  void set_lookup_mask (hb_mask_t mask) { lookup_mask = mask; init_iters (); }\n+  void set_auto_zwj (bool auto_zwj_) { auto_zwj = auto_zwj_; init_iters (); }\n+  void set_auto_zwnj (bool auto_zwnj_) { auto_zwnj = auto_zwnj_; init_iters (); }\n+  void set_random (bool random_) { random = random_; }\n+  void set_recurse_func (recurse_func_t func) { recurse_func = func; }\n+  void set_lookup_index (unsigned int lookup_index_) { lookup_index = lookup_index_; }\n+  void set_lookup_props (unsigned int lookup_props_) { lookup_props = lookup_props_; init_iters (); }\n+\n+  uint32_t random_number ()\n+  {\n+    \/* http:\/\/www.cplusplus.com\/reference\/random\/minstd_rand\/ *\/\n+    random_state = random_state * 48271 % 2147483647;\n+    return random_state;\n+  }\n+\n+  bool match_properties_mark (hb_codepoint_t  glyph,\n+                              unsigned int    glyph_props,\n+                              unsigned int    match_props) const\n+  {\n+    \/* If using mark filtering sets, the high short of\n+     * match_props has the set index.\n+     *\/\n+    if (match_props & LookupFlag::UseMarkFilteringSet)\n+      return gdef.mark_set_covers (match_props >> 16, glyph);\n+\n+    \/* The second byte of match_props has the meaning\n+     * \"ignore marks of attachment type different than\n+     * the attachment type specified.\"\n+     *\/\n+    if (match_props & LookupFlag::MarkAttachmentType)\n+      return (match_props & LookupFlag::MarkAttachmentType) == (glyph_props & LookupFlag::MarkAttachmentType);\n+\n+    return true;\n+  }\n+\n+  bool check_glyph_property (const hb_glyph_info_t *info,\n+                             unsigned int  match_props) const\n+  {\n+    hb_codepoint_t glyph = info->codepoint;\n+    unsigned int glyph_props = _hb_glyph_info_get_glyph_props (info);\n+\n+    \/* Not covered, if, for example, glyph class is ligature and\n+     * match_props includes LookupFlags::IgnoreLigatures\n+     *\/\n+    if (glyph_props & match_props & LookupFlag::IgnoreFlags)\n+      return false;\n+\n+    if (unlikely (glyph_props & HB_OT_LAYOUT_GLYPH_PROPS_MARK))\n+      return match_properties_mark (glyph, glyph_props, match_props);\n+\n+    return true;\n+  }\n+\n+  void _set_glyph_props (hb_codepoint_t glyph_index,\n+                          unsigned int class_guess = 0,\n+                          bool ligature = false,\n+                          bool component = false) const\n+  {\n+    unsigned int add_in = _hb_glyph_info_get_glyph_props (&buffer->cur()) &\n+                          HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE;\n+    add_in |= HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED;\n+    if (ligature)\n+    {\n+      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_LIGATED;\n+      \/* In the only place that the MULTIPLIED bit is used, Uniscribe\n+       * seems to only care about the \"last\" transformation between\n+       * Ligature and Multiple substitutions.  Ie. if you ligate, expand,\n+       * and ligate again, it forgives the multiplication and acts as\n+       * if only ligation happened.  As such, clear MULTIPLIED bit.\n+       *\/\n+      add_in &= ~HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n+    }\n+    if (component)\n+      add_in |= HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED;\n+    if (likely (has_glyph_classes))\n+      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | gdef.get_glyph_props (glyph_index));\n+    else if (class_guess)\n+      _hb_glyph_info_set_glyph_props (&buffer->cur(), add_in | class_guess);\n+  }\n+\n+  void replace_glyph (hb_codepoint_t glyph_index) const\n+  {\n+    _set_glyph_props (glyph_index);\n+    buffer->replace_glyph (glyph_index);\n+  }\n+  void replace_glyph_inplace (hb_codepoint_t glyph_index) const\n+  {\n+    _set_glyph_props (glyph_index);\n+    buffer->cur().codepoint = glyph_index;\n+  }\n+  void replace_glyph_with_ligature (hb_codepoint_t glyph_index,\n+                                           unsigned int class_guess) const\n+  {\n+    _set_glyph_props (glyph_index, class_guess, true);\n+    buffer->replace_glyph (glyph_index);\n+  }\n+  void output_glyph_for_component (hb_codepoint_t glyph_index,\n+                                          unsigned int class_guess) const\n+  {\n+    _set_glyph_props (glyph_index, class_guess, false, true);\n+    buffer->output_glyph (glyph_index);\n+  }\n+};\n+\n+\n+struct hb_get_subtables_context_t :\n+       hb_dispatch_context_t<hb_get_subtables_context_t, hb_void_t, HB_DEBUG_APPLY>\n+{\n+  template <typename Type>\n+  static bool apply_to (const void *obj, OT::hb_ot_apply_context_t *c)\n+  {\n+    const Type *typed_obj = (const Type *) obj;\n+    return typed_obj->apply (c);\n+  }\n+\n+  typedef bool (*hb_apply_func_t) (const void *obj, OT::hb_ot_apply_context_t *c);\n+\n+  struct hb_applicable_t\n+  {\n+    template <typename T>\n+    void init (const T &obj_, hb_apply_func_t apply_func_)\n+    {\n+      obj = &obj_;\n+      apply_func = apply_func_;\n+      digest.init ();\n+      obj_.get_coverage ().add_coverage (&digest);\n+    }\n+\n+    bool apply (OT::hb_ot_apply_context_t *c) const\n+    {\n+      return digest.may_have (c->buffer->cur().codepoint) && apply_func (obj, c);\n+    }\n+\n+    private:\n+    const void *obj;\n+    hb_apply_func_t apply_func;\n+    hb_set_digest_t digest;\n+  };\n+\n+  typedef hb_vector_t<hb_applicable_t> array_t;\n+\n+  \/* Dispatch interface. *\/\n+  const char *get_name () { return \"GET_SUBTABLES\"; }\n+  template <typename T>\n+  return_t dispatch (const T &obj)\n+  {\n+    hb_applicable_t *entry = array.push();\n+    entry->init (obj, apply_to<T>);\n+    return HB_VOID;\n+  }\n+  static return_t default_return_value () { return HB_VOID; }\n+\n+  hb_get_subtables_context_t (array_t &array_) :\n+                              array (array_),\n+                              debug_depth (0) {}\n+\n+  array_t &array;\n+  unsigned int debug_depth;\n+};\n+\n+\n+\n+\n+typedef bool (*intersects_func_t) (const hb_set_t *glyphs, const HBUINT16 &value, const void *data);\n+typedef void (*collect_glyphs_func_t) (hb_set_t *glyphs, const HBUINT16 &value, const void *data);\n+typedef bool (*match_func_t) (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data);\n+\n+struct ContextClosureFuncs\n+{\n+  intersects_func_t intersects;\n+};\n+struct ContextCollectGlyphsFuncs\n+{\n+  collect_glyphs_func_t collect;\n+};\n+struct ContextApplyFuncs\n+{\n+  match_func_t match;\n+};\n+\n+\n+static inline bool intersects_glyph (const hb_set_t *glyphs, const HBUINT16 &value, const void *data HB_UNUSED)\n+{\n+  return glyphs->has (value);\n+}\n+static inline bool intersects_class (const hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+{\n+  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n+  return class_def.intersects_class (glyphs, value);\n+}\n+static inline bool intersects_coverage (const hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+{\n+  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n+  return (data+coverage).intersects (glyphs);\n+}\n+\n+static inline bool intersects_array (const hb_set_t *glyphs,\n+                                     unsigned int count,\n+                                     const HBUINT16 values[],\n+                                     intersects_func_t intersects_func,\n+                                     const void *intersects_data)\n+{\n+  for (unsigned int i = 0; i < count; i++)\n+    if (likely (!intersects_func (glyphs, values[i], intersects_data)))\n+      return false;\n+  return true;\n+}\n+\n+\n+static inline void collect_glyph (hb_set_t *glyphs, const HBUINT16 &value, const void *data HB_UNUSED)\n+{\n+  glyphs->add (value);\n+}\n+static inline void collect_class (hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+{\n+  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n+  class_def.add_class (glyphs, value);\n+}\n+static inline void collect_coverage (hb_set_t *glyphs, const HBUINT16 &value, const void *data)\n+{\n+  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n+  (data+coverage).add_coverage (glyphs);\n+}\n+static inline void collect_array (hb_collect_glyphs_context_t *c HB_UNUSED,\n+                                  hb_set_t *glyphs,\n+                                  unsigned int count,\n+                                  const HBUINT16 values[],\n+                                  collect_glyphs_func_t collect_func,\n+                                  const void *collect_data)\n+{\n+  for (unsigned int i = 0; i < count; i++)\n+    collect_func (glyphs, values[i], collect_data);\n+}\n+\n+\n+static inline bool match_glyph (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data HB_UNUSED)\n+{\n+  return glyph_id == value;\n+}\n+static inline bool match_class (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data)\n+{\n+  const ClassDef &class_def = *reinterpret_cast<const ClassDef *>(data);\n+  return class_def.get_class (glyph_id) == value;\n+}\n+static inline bool match_coverage (hb_codepoint_t glyph_id, const HBUINT16 &value, const void *data)\n+{\n+  const OffsetTo<Coverage> &coverage = (const OffsetTo<Coverage>&)value;\n+  return (data+coverage).get_coverage (glyph_id) != NOT_COVERED;\n+}\n+\n+static inline bool would_match_input (hb_would_apply_context_t *c,\n+                                      unsigned int count, \/* Including the first glyph (not matched) *\/\n+                                      const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                      match_func_t match_func,\n+                                      const void *match_data)\n+{\n+  if (count != c->len)\n+    return false;\n+\n+  for (unsigned int i = 1; i < count; i++)\n+    if (likely (!match_func (c->glyphs[i], input[i - 1], match_data)))\n+      return false;\n+\n+  return true;\n+}\n+static inline bool match_input (hb_ot_apply_context_t *c,\n+                                unsigned int count, \/* Including the first glyph (not matched) *\/\n+                                const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                match_func_t match_func,\n+                                const void *match_data,\n+                                unsigned int *end_offset,\n+                                unsigned int match_positions[HB_MAX_CONTEXT_LENGTH],\n+                                unsigned int *p_total_component_count = nullptr)\n+{\n+  TRACE_APPLY (nullptr);\n+\n+  if (unlikely (count > HB_MAX_CONTEXT_LENGTH)) return_trace (false);\n+\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_input;\n+  skippy_iter.reset (buffer->idx, count - 1);\n+  skippy_iter.set_match_func (match_func, match_data, input);\n+\n+  \/*\n+   * This is perhaps the trickiest part of OpenType...  Remarks:\n+   *\n+   * - If all components of the ligature were marks, we call this a mark ligature.\n+   *\n+   * - If there is no GDEF, and the ligature is NOT a mark ligature, we categorize\n+   *   it as a ligature glyph.\n+   *\n+   * - Ligatures cannot be formed across glyphs attached to different components\n+   *   of previous ligatures.  Eg. the sequence is LAM,SHADDA,LAM,FATHA,HEH, and\n+   *   LAM,LAM,HEH form a ligature, leaving SHADDA,FATHA next to eachother.\n+   *   However, it would be wrong to ligate that SHADDA,FATHA sequence.\n+   *   There are a couple of exceptions to this:\n+   *\n+   *   o If a ligature tries ligating with marks that belong to it itself, go ahead,\n+   *     assuming that the font designer knows what they are doing (otherwise it can\n+   *     break Indic stuff when a matra wants to ligate with a conjunct,\n+   *\n+   *   o If two marks want to ligate and they belong to different components of the\n+   *     same ligature glyph, and said ligature glyph is to be ignored according to\n+   *     mark-filtering rules, then allow.\n+   *     https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/545\n+   *\/\n+\n+  unsigned int total_component_count = 0;\n+  total_component_count += _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n+\n+  unsigned int first_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n+  unsigned int first_lig_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n+\n+  enum {\n+    LIGBASE_NOT_CHECKED,\n+    LIGBASE_MAY_NOT_SKIP,\n+    LIGBASE_MAY_SKIP\n+  } ligbase = LIGBASE_NOT_CHECKED;\n+\n+  match_positions[0] = buffer->idx;\n+  for (unsigned int i = 1; i < count; i++)\n+  {\n+    if (!skippy_iter.next ()) return_trace (false);\n+\n+    match_positions[i] = skippy_iter.idx;\n+\n+    unsigned int this_lig_id = _hb_glyph_info_get_lig_id (&buffer->info[skippy_iter.idx]);\n+    unsigned int this_lig_comp = _hb_glyph_info_get_lig_comp (&buffer->info[skippy_iter.idx]);\n+\n+    if (first_lig_id && first_lig_comp)\n+    {\n+      \/* If first component was attached to a previous ligature component,\n+       * all subsequent components should be attached to the same ligature\n+       * component, otherwise we shouldn't ligate them... *\/\n+      if (first_lig_id != this_lig_id || first_lig_comp != this_lig_comp)\n+      {\n+        \/* ...unless, we are attached to a base ligature and that base\n+         * ligature is ignorable. *\/\n+        if (ligbase == LIGBASE_NOT_CHECKED)\n+        {\n+          bool found = false;\n+          const hb_glyph_info_t *out = buffer->out_info;\n+          unsigned int j = buffer->out_len;\n+          while (j && _hb_glyph_info_get_lig_id (&out[j - 1]) == first_lig_id)\n+          {\n+            if (_hb_glyph_info_get_lig_comp (&out[j - 1]) == 0)\n+            {\n+              j--;\n+              found = true;\n+              break;\n+            }\n+            j--;\n+          }\n+\n+          if (found && skippy_iter.may_skip (out[j]) == hb_ot_apply_context_t::matcher_t::SKIP_YES)\n+            ligbase = LIGBASE_MAY_SKIP;\n+          else\n+            ligbase = LIGBASE_MAY_NOT_SKIP;\n+        }\n+\n+        if (ligbase == LIGBASE_MAY_NOT_SKIP)\n+          return_trace (false);\n+      }\n+    }\n+    else\n+    {\n+      \/* If first component was NOT attached to a previous ligature component,\n+       * all subsequent components should also NOT be attached to any ligature\n+       * component, unless they are attached to the first component itself! *\/\n+      if (this_lig_id && this_lig_comp && (this_lig_id != first_lig_id))\n+        return_trace (false);\n+    }\n+\n+    total_component_count += _hb_glyph_info_get_lig_num_comps (&buffer->info[skippy_iter.idx]);\n+  }\n+\n+  *end_offset = skippy_iter.idx - buffer->idx + 1;\n+\n+  if (p_total_component_count)\n+    *p_total_component_count = total_component_count;\n+\n+  return_trace (true);\n+}\n+static inline bool ligate_input (hb_ot_apply_context_t *c,\n+                                 unsigned int count, \/* Including the first glyph *\/\n+                                 const unsigned int match_positions[HB_MAX_CONTEXT_LENGTH], \/* Including the first glyph *\/\n+                                 unsigned int match_length,\n+                                 hb_codepoint_t lig_glyph,\n+                                 unsigned int total_component_count)\n+{\n+  TRACE_APPLY (nullptr);\n+\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  buffer->merge_clusters (buffer->idx, buffer->idx + match_length);\n+\n+  \/* - If a base and one or more marks ligate, consider that as a base, NOT\n+   *   ligature, such that all following marks can still attach to it.\n+   *   https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1109\n+   *\n+   * - If all components of the ligature were marks, we call this a mark ligature.\n+   *   If it *is* a mark ligature, we don't allocate a new ligature id, and leave\n+   *   the ligature to keep its old ligature id.  This will allow it to attach to\n+   *   a base ligature in GPOS.  Eg. if the sequence is: LAM,LAM,SHADDA,FATHA,HEH,\n+   *   and LAM,LAM,HEH for a ligature, they will leave SHADDA and FATHA with a\n+   *   ligature id and component value of 2.  Then if SHADDA,FATHA form a ligature\n+   *   later, we don't want them to lose their ligature id\/component, otherwise\n+   *   GPOS will fail to correctly position the mark ligature on top of the\n+   *   LAM,LAM,HEH ligature.  See:\n+   *     https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=676343\n+   *\n+   * - If a ligature is formed of components that some of which are also ligatures\n+   *   themselves, and those ligature components had marks attached to *their*\n+   *   components, we have to attach the marks to the new ligature component\n+   *   positions!  Now *that*'s tricky!  And these marks may be following the\n+   *   last component of the whole sequence, so we should loop forward looking\n+   *   for them and update them.\n+   *\n+   *   Eg. the sequence is LAM,LAM,SHADDA,FATHA,HEH, and the font first forms a\n+   *   'calt' ligature of LAM,HEH, leaving the SHADDA and FATHA with a ligature\n+   *   id and component == 1.  Now, during 'liga', the LAM and the LAM-HEH ligature\n+   *   form a LAM-LAM-HEH ligature.  We need to reassign the SHADDA and FATHA to\n+   *   the new ligature with a component value of 2.\n+   *\n+   *   This in fact happened to a font...  See:\n+   *   https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=437633\n+   *\/\n+\n+  bool is_base_ligature = _hb_glyph_info_is_base_glyph (&buffer->info[match_positions[0]]);\n+  bool is_mark_ligature = _hb_glyph_info_is_mark (&buffer->info[match_positions[0]]);\n+  for (unsigned int i = 1; i < count; i++)\n+    if (!_hb_glyph_info_is_mark (&buffer->info[match_positions[i]]))\n+    {\n+      is_base_ligature = false;\n+      is_mark_ligature = false;\n+      break;\n+    }\n+  bool is_ligature = !is_base_ligature && !is_mark_ligature;\n+\n+  unsigned int klass = is_ligature ? HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE : 0;\n+  unsigned int lig_id = is_ligature ? _hb_allocate_lig_id (buffer) : 0;\n+  unsigned int last_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n+  unsigned int last_num_components = _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n+  unsigned int components_so_far = last_num_components;\n+\n+  if (is_ligature)\n+  {\n+    _hb_glyph_info_set_lig_props_for_ligature (&buffer->cur(), lig_id, total_component_count);\n+    if (_hb_glyph_info_get_general_category (&buffer->cur()) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)\n+    {\n+      _hb_glyph_info_set_general_category (&buffer->cur(), HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER);\n+    }\n+  }\n+  c->replace_glyph_with_ligature (lig_glyph, klass);\n+\n+  for (unsigned int i = 1; i < count; i++)\n+  {\n+    while (buffer->idx < match_positions[i] && buffer->successful)\n+    {\n+      if (is_ligature)\n+      {\n+        unsigned int this_comp = _hb_glyph_info_get_lig_comp (&buffer->cur());\n+        if (this_comp == 0)\n+          this_comp = last_num_components;\n+        unsigned int new_lig_comp = components_so_far - last_num_components +\n+                                    MIN (this_comp, last_num_components);\n+          _hb_glyph_info_set_lig_props_for_mark (&buffer->cur(), lig_id, new_lig_comp);\n+      }\n+      buffer->next_glyph ();\n+    }\n+\n+    last_lig_id = _hb_glyph_info_get_lig_id (&buffer->cur());\n+    last_num_components = _hb_glyph_info_get_lig_num_comps (&buffer->cur());\n+    components_so_far += last_num_components;\n+\n+    \/* Skip the base glyph *\/\n+    buffer->idx++;\n+  }\n+\n+  if (!is_mark_ligature && last_lig_id) {\n+    \/* Re-adjust components for any marks following. *\/\n+    for (unsigned int i = buffer->idx; i < buffer->len; i++) {\n+      if (last_lig_id == _hb_glyph_info_get_lig_id (&buffer->info[i])) {\n+        unsigned int this_comp = _hb_glyph_info_get_lig_comp (&buffer->info[i]);\n+        if (!this_comp)\n+          break;\n+        unsigned int new_lig_comp = components_so_far - last_num_components +\n+                                    MIN (this_comp, last_num_components);\n+        _hb_glyph_info_set_lig_props_for_mark (&buffer->info[i], lig_id, new_lig_comp);\n+      } else\n+        break;\n+    }\n+  }\n+  return_trace (true);\n+}\n+\n+static inline bool match_backtrack (hb_ot_apply_context_t *c,\n+                                    unsigned int count,\n+                                    const HBUINT16 backtrack[],\n+                                    match_func_t match_func,\n+                                    const void *match_data,\n+                                    unsigned int *match_start)\n+{\n+  TRACE_APPLY (nullptr);\n+\n+  hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_context;\n+  skippy_iter.reset (c->buffer->backtrack_len (), count);\n+  skippy_iter.set_match_func (match_func, match_data, backtrack);\n+\n+  for (unsigned int i = 0; i < count; i++)\n+    if (!skippy_iter.prev ())\n+      return_trace (false);\n+\n+  *match_start = skippy_iter.idx;\n+\n+  return_trace (true);\n+}\n+\n+static inline bool match_lookahead (hb_ot_apply_context_t *c,\n+                                    unsigned int count,\n+                                    const HBUINT16 lookahead[],\n+                                    match_func_t match_func,\n+                                    const void *match_data,\n+                                    unsigned int offset,\n+                                    unsigned int *end_index)\n+{\n+  TRACE_APPLY (nullptr);\n+\n+  hb_ot_apply_context_t::skipping_iterator_t &skippy_iter = c->iter_context;\n+  skippy_iter.reset (c->buffer->idx + offset - 1, count);\n+  skippy_iter.set_match_func (match_func, match_data, lookahead);\n+\n+  for (unsigned int i = 0; i < count; i++)\n+    if (!skippy_iter.next ())\n+      return_trace (false);\n+\n+  *end_index = skippy_iter.idx + 1;\n+\n+  return_trace (true);\n+}\n+\n+\n+\n+struct LookupRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT16      sequenceIndex;          \/* Index into current glyph\n+                                         * sequence--first glyph = 0 *\/\n+  HBUINT16      lookupListIndex;        \/* Lookup to apply to that\n+                                         * position--zero--based *\/\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+template <typename context_t>\n+static inline void recurse_lookups (context_t *c,\n+                                    unsigned int lookupCount,\n+                                    const LookupRecord lookupRecord[] \/* Array of LookupRecords--in design order *\/)\n+{\n+  for (unsigned int i = 0; i < lookupCount; i++)\n+    c->recurse (lookupRecord[i].lookupListIndex);\n+}\n+\n+static inline bool apply_lookup (hb_ot_apply_context_t *c,\n+                                 unsigned int count, \/* Including the first glyph *\/\n+                                 unsigned int match_positions[HB_MAX_CONTEXT_LENGTH], \/* Including the first glyph *\/\n+                                 unsigned int lookupCount,\n+                                 const LookupRecord lookupRecord[], \/* Array of LookupRecords--in design order *\/\n+                                 unsigned int match_length)\n+{\n+  TRACE_APPLY (nullptr);\n+\n+  hb_buffer_t *buffer = c->buffer;\n+  int end;\n+\n+  \/* All positions are distance from beginning of *output* buffer.\n+   * Adjust. *\/\n+  {\n+    unsigned int bl = buffer->backtrack_len ();\n+    end = bl + match_length;\n+\n+    int delta = bl - buffer->idx;\n+    \/* Convert positions to new indexing. *\/\n+    for (unsigned int j = 0; j < count; j++)\n+      match_positions[j] += delta;\n+  }\n+\n+  for (unsigned int i = 0; i < lookupCount && buffer->successful; i++)\n+  {\n+    unsigned int idx = lookupRecord[i].sequenceIndex;\n+    if (idx >= count)\n+      continue;\n+\n+    \/* Don't recurse to ourself at same position.\n+     * Note that this test is too naive, it doesn't catch longer loops. *\/\n+    if (idx == 0 && lookupRecord[i].lookupListIndex == c->lookup_index)\n+      continue;\n+\n+    if (unlikely (!buffer->move_to (match_positions[idx])))\n+      break;\n+\n+    if (unlikely (buffer->max_ops <= 0))\n+      break;\n+\n+    unsigned int orig_len = buffer->backtrack_len () + buffer->lookahead_len ();\n+    if (!c->recurse (lookupRecord[i].lookupListIndex))\n+      continue;\n+\n+    unsigned int new_len = buffer->backtrack_len () + buffer->lookahead_len ();\n+    int delta = new_len - orig_len;\n+\n+    if (!delta)\n+      continue;\n+\n+    \/* Recursed lookup changed buffer len.  Adjust.\n+     *\n+     * TODO:\n+     *\n+     * Right now, if buffer length increased by n, we assume n new glyphs\n+     * were added right after the current position, and if buffer length\n+     * was decreased by n, we assume n match positions after the current\n+     * one where removed.  The former (buffer length increased) case is\n+     * fine, but the decrease case can be improved in at least two ways,\n+     * both of which are significant:\n+     *\n+     *   - If recursed-to lookup is MultipleSubst and buffer length\n+     *     decreased, then it's current match position that was deleted,\n+     *     NOT the one after it.\n+     *\n+     *   - If buffer length was decreased by n, it does not necessarily\n+     *     mean that n match positions where removed, as there might\n+     *     have been marks and default-ignorables in the sequence.  We\n+     *     should instead drop match positions between current-position\n+     *     and current-position + n instead.\n+     *\n+     * It should be possible to construct tests for both of these cases.\n+     *\/\n+\n+    end += delta;\n+    if (end <= int (match_positions[idx]))\n+    {\n+      \/* End might end up being smaller than match_positions[idx] if the recursed\n+       * lookup ended up removing many items, more than we have had matched.\n+       * Just never rewind end back and get out of here.\n+       * https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=659496 *\/\n+      end = match_positions[idx];\n+      \/* There can't be any further changes. *\/\n+      break;\n+    }\n+\n+    unsigned int next = idx + 1; \/* next now is the position after the recursed lookup. *\/\n+\n+    if (delta > 0)\n+    {\n+      if (unlikely (delta + count > HB_MAX_CONTEXT_LENGTH))\n+        break;\n+    }\n+    else\n+    {\n+      \/* NOTE: delta is negative. *\/\n+      delta = MAX (delta, (int) next - (int) count);\n+      next -= delta;\n+    }\n+\n+    \/* Shift! *\/\n+    memmove (match_positions + next + delta, match_positions + next,\n+             (count - next) * sizeof (match_positions[0]));\n+    next += delta;\n+    count += delta;\n+\n+    \/* Fill in new entries. *\/\n+    for (unsigned int j = idx + 1; j < next; j++)\n+      match_positions[j] = match_positions[j - 1] + 1;\n+\n+    \/* And fixup the rest. *\/\n+    for (; next < count; next++)\n+      match_positions[next] += delta;\n+  }\n+\n+  buffer->move_to (end);\n+\n+  return_trace (true);\n+}\n+\n+\n+\n+\/* Contextual lookups *\/\n+\n+struct ContextClosureLookupContext\n+{\n+  ContextClosureFuncs funcs;\n+  const void *intersects_data;\n+};\n+\n+struct ContextCollectGlyphsLookupContext\n+{\n+  ContextCollectGlyphsFuncs funcs;\n+  const void *collect_data;\n+};\n+\n+struct ContextApplyLookupContext\n+{\n+  ContextApplyFuncs funcs;\n+  const void *match_data;\n+};\n+\n+static inline bool context_intersects (const hb_set_t *glyphs,\n+                                       unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                       const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                       ContextClosureLookupContext &lookup_context)\n+{\n+  return intersects_array (glyphs,\n+                           inputCount ? inputCount - 1 : 0, input,\n+                           lookup_context.funcs.intersects, lookup_context.intersects_data);\n+}\n+\n+static inline void context_closure_lookup (hb_closure_context_t *c,\n+                                           unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                           const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                           unsigned int lookupCount,\n+                                           const LookupRecord lookupRecord[],\n+                                           ContextClosureLookupContext &lookup_context)\n+{\n+  if (context_intersects (c->glyphs,\n+                          inputCount, input,\n+                          lookup_context))\n+    recurse_lookups (c,\n+                     lookupCount, lookupRecord);\n+}\n+\n+static inline void context_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,\n+                                                  unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                                  const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                  unsigned int lookupCount,\n+                                                  const LookupRecord lookupRecord[],\n+                                                  ContextCollectGlyphsLookupContext &lookup_context)\n+{\n+  collect_array (c, c->input,\n+                 inputCount ? inputCount - 1 : 0, input,\n+                 lookup_context.funcs.collect, lookup_context.collect_data);\n+  recurse_lookups (c,\n+                   lookupCount, lookupRecord);\n+}\n+\n+static inline bool context_would_apply_lookup (hb_would_apply_context_t *c,\n+                                               unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                               const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                               unsigned int lookupCount HB_UNUSED,\n+                                               const LookupRecord lookupRecord[] HB_UNUSED,\n+                                               ContextApplyLookupContext &lookup_context)\n+{\n+  return would_match_input (c,\n+                            inputCount, input,\n+                            lookup_context.funcs.match, lookup_context.match_data);\n+}\n+static inline bool context_apply_lookup (hb_ot_apply_context_t *c,\n+                                         unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                         const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                         unsigned int lookupCount,\n+                                         const LookupRecord lookupRecord[],\n+                                         ContextApplyLookupContext &lookup_context)\n+{\n+  unsigned int match_length = 0;\n+  unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n+  return match_input (c,\n+                      inputCount, input,\n+                      lookup_context.funcs.match, lookup_context.match_data,\n+                      &match_length, match_positions)\n+      && (c->buffer->unsafe_to_break (c->buffer->idx, c->buffer->idx + match_length),\n+          apply_lookup (c,\n+                       inputCount, match_positions,\n+                       lookupCount, lookupRecord,\n+                       match_length));\n+}\n+\n+struct Rule\n+{\n+  bool intersects (const hb_set_t *glyphs, ContextClosureLookupContext &lookup_context) const\n+  {\n+    return context_intersects (glyphs,\n+                               inputCount, inputZ.arrayZ,\n+                               lookup_context);\n+  }\n+\n+  void closure (hb_closure_context_t *c, ContextClosureLookupContext &lookup_context) const\n+  {\n+    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord> >\n+                                                       (inputZ.as_array ((inputCount ? inputCount - 1 : 0)));\n+    context_closure_lookup (c,\n+                            inputCount, inputZ.arrayZ,\n+                            lookupCount, lookupRecord.arrayZ,\n+                            lookup_context);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c,\n+                       ContextCollectGlyphsLookupContext &lookup_context) const\n+  {\n+    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord> >\n+                                                       (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n+    context_collect_glyphs_lookup (c,\n+                                   inputCount, inputZ.arrayZ,\n+                                   lookupCount, lookupRecord.arrayZ,\n+                                   lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c,\n+                    ContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord> >\n+                                                       (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n+    return_trace (context_would_apply_lookup (c, inputCount, inputZ.arrayZ, lookupCount, lookupRecord.arrayZ, lookup_context));\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c,\n+              ContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_APPLY (this);\n+    const UnsizedArrayOf<LookupRecord> &lookupRecord = StructAfter<UnsizedArrayOf<LookupRecord> >\n+                                                       (inputZ.as_array (inputCount ? inputCount - 1 : 0));\n+    return_trace (context_apply_lookup (c, inputCount, inputZ.arrayZ, lookupCount, lookupRecord.arrayZ, lookup_context));\n+  }\n+\n+  public:\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (inputCount.sanitize (c) &&\n+                  lookupCount.sanitize (c) &&\n+                  c->check_range (inputZ.arrayZ,\n+                                  inputZ.item_size * (inputCount ? inputCount - 1 : 0) +\n+                                  LookupRecord::static_size * lookupCount));\n+  }\n+\n+  protected:\n+  HBUINT16      inputCount;             \/* Total number of glyphs in input\n+                                         * glyph sequence--includes the first\n+                                         * glyph *\/\n+  HBUINT16      lookupCount;            \/* Number of LookupRecords *\/\n+  UnsizedArrayOf<HBUINT16>\n+                inputZ;                 \/* Array of match inputs--start with\n+                                         * second glyph *\/\n+\/*UnsizedArrayOf<LookupRecord>\n+                lookupRecordX;*\/        \/* Array of LookupRecords--in\n+                                         * design order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (4, inputZ);\n+};\n+\n+struct RuleSet\n+{\n+  bool intersects (const hb_set_t *glyphs,\n+                   ContextClosureLookupContext &lookup_context) const\n+  {\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      if ((this+rule[i]).intersects (glyphs, lookup_context))\n+        return true;\n+    return false;\n+  }\n+\n+  void closure (hb_closure_context_t *c,\n+                ContextClosureLookupContext &lookup_context) const\n+  {\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      (this+rule[i]).closure (c, lookup_context);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c,\n+                       ContextCollectGlyphsLookupContext &lookup_context) const\n+  {\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      (this+rule[i]).collect_glyphs (c, lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c,\n+                    ContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+    {\n+      if ((this+rule[i]).would_apply (c, lookup_context))\n+        return_trace (true);\n+    }\n+    return_trace (false);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c,\n+              ContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+    {\n+      if ((this+rule[i]).apply (c, lookup_context))\n+        return_trace (true);\n+    }\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (rule.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetArrayOf<Rule>\n+                rule;                   \/* Array of Rule tables\n+                                         * ordered by preference *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, rule);\n+};\n+\n+\n+struct ContextFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    struct ContextClosureLookupContext lookup_context = {\n+      {intersects_glyph},\n+      nullptr\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (glyphs->has (iter.get_glyph ()) &&\n+          (this+ruleSet[iter.get_coverage ()]).intersects (glyphs, lookup_context))\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    struct ContextClosureLookupContext lookup_context = {\n+      {intersects_glyph},\n+      nullptr\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (c->glyphs->has (iter.get_glyph ()))\n+        (this+ruleSet[iter.get_coverage ()]).closure (c, lookup_context);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    (this+coverage).add_coverage (c->input);\n+\n+    struct ContextCollectGlyphsLookupContext lookup_context = {\n+      {collect_glyph},\n+      nullptr\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+\n+    const RuleSet &rule_set = this+ruleSet[(this+coverage).get_coverage (c->glyphs[0])];\n+    struct ContextApplyLookupContext lookup_context = {\n+      {match_glyph},\n+      nullptr\n+    };\n+    return_trace (rule_set.would_apply (c, lookup_context));\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED))\n+      return_trace (false);\n+\n+    const RuleSet &rule_set = this+ruleSet[index];\n+    struct ContextApplyLookupContext lookup_context = {\n+      {match_glyph},\n+      nullptr\n+    };\n+    return_trace (rule_set.apply (c, lookup_context));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of table *\/\n+  OffsetArrayOf<RuleSet>\n+                ruleSet;                \/* Array of RuleSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, ruleSet);\n+};\n+\n+\n+struct ContextFormat2\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    if (!(this+coverage).intersects (glyphs))\n+      return false;\n+\n+    const ClassDef &class_def = this+classDef;\n+\n+    struct ContextClosureLookupContext lookup_context = {\n+      {intersects_class},\n+      &class_def\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (class_def.intersects_class (glyphs, i) &&\n+          (this+ruleSet[i]).intersects (glyphs, lookup_context))\n+        return true;\n+\n+    return false;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    if (!(this+coverage).intersects (c->glyphs))\n+      return;\n+\n+    const ClassDef &class_def = this+classDef;\n+\n+    struct ContextClosureLookupContext lookup_context = {\n+      {intersects_class},\n+      &class_def\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (class_def.intersects_class (c->glyphs, i)) {\n+        const RuleSet &rule_set = this+ruleSet[i];\n+        rule_set.closure (c, lookup_context);\n+      }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    (this+coverage).add_coverage (c->input);\n+\n+    const ClassDef &class_def = this+classDef;\n+    struct ContextCollectGlyphsLookupContext lookup_context = {\n+      {collect_class},\n+      &class_def\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+\n+    const ClassDef &class_def = this+classDef;\n+    unsigned int index = class_def.get_class (c->glyphs[0]);\n+    const RuleSet &rule_set = this+ruleSet[index];\n+    struct ContextApplyLookupContext lookup_context = {\n+      {match_class},\n+      &class_def\n+    };\n+    return_trace (rule_set.would_apply (c, lookup_context));\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const ClassDef &class_def = this+classDef;\n+    index = class_def.get_class (c->buffer->cur().codepoint);\n+    const RuleSet &rule_set = this+ruleSet[index];\n+    struct ContextApplyLookupContext lookup_context = {\n+      {match_class},\n+      &class_def\n+    };\n+    return_trace (rule_set.apply (c, lookup_context));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && classDef.sanitize (c, this) && ruleSet.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of table *\/\n+  OffsetTo<ClassDef>\n+                classDef;               \/* Offset to glyph ClassDef table--from\n+                                         * beginning of table *\/\n+  OffsetArrayOf<RuleSet>\n+                ruleSet;                \/* Array of RuleSet tables\n+                                         * ordered by class *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, ruleSet);\n+};\n+\n+\n+struct ContextFormat3\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    if (!(this+coverageZ[0]).intersects (glyphs))\n+      return false;\n+\n+    struct ContextClosureLookupContext lookup_context = {\n+      {intersects_coverage},\n+      this\n+    };\n+    return context_intersects (glyphs,\n+                               glyphCount, (const HBUINT16 *) (coverageZ.arrayZ + 1),\n+                               lookup_context);\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    if (!(this+coverageZ[0]).intersects (c->glyphs))\n+      return;\n+\n+    const LookupRecord *lookupRecord = &StructAfter<LookupRecord> (coverageZ.as_array (glyphCount));\n+    struct ContextClosureLookupContext lookup_context = {\n+      {intersects_coverage},\n+      this\n+    };\n+    context_closure_lookup (c,\n+                            glyphCount, (const HBUINT16 *) (coverageZ.arrayZ + 1),\n+                            lookupCount, lookupRecord,\n+                            lookup_context);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    (this+coverageZ[0]).add_coverage (c->input);\n+\n+    const LookupRecord *lookupRecord = &StructAfter<LookupRecord> (coverageZ.as_array (glyphCount));\n+    struct ContextCollectGlyphsLookupContext lookup_context = {\n+      {collect_coverage},\n+      this\n+    };\n+\n+    context_collect_glyphs_lookup (c,\n+                                   glyphCount, (const HBUINT16 *) (coverageZ.arrayZ + 1),\n+                                   lookupCount, lookupRecord,\n+                                   lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+\n+    const LookupRecord *lookupRecord = &StructAfter<LookupRecord> (coverageZ.as_array (glyphCount));\n+    struct ContextApplyLookupContext lookup_context = {\n+      {match_coverage},\n+      this\n+    };\n+    return_trace (context_would_apply_lookup (c, glyphCount, (const HBUINT16 *) (coverageZ.arrayZ + 1), lookupCount, lookupRecord, lookup_context));\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverageZ[0]; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int index = (this+coverageZ[0]).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const LookupRecord *lookupRecord = &StructAfter<LookupRecord> (coverageZ.as_array (glyphCount));\n+    struct ContextApplyLookupContext lookup_context = {\n+      {match_coverage},\n+      this\n+    };\n+    return_trace (context_apply_lookup (c, glyphCount, (const HBUINT16 *) (coverageZ.arrayZ + 1), lookupCount, lookupRecord, lookup_context));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!c->check_struct (this)) return_trace (false);\n+    unsigned int count = glyphCount;\n+    if (!count) return_trace (false); \/* We want to access coverageZ[0] freely. *\/\n+    if (!c->check_array (coverageZ.arrayZ, count)) return_trace (false);\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!coverageZ[i].sanitize (c, this)) return_trace (false);\n+    const LookupRecord *lookupRecord = &StructAfter<LookupRecord> (coverageZ.as_array (glyphCount));\n+    return_trace (c->check_array (lookupRecord, lookupCount));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 3 *\/\n+  HBUINT16      glyphCount;             \/* Number of glyphs in the input glyph\n+                                         * sequence *\/\n+  HBUINT16      lookupCount;            \/* Number of LookupRecords *\/\n+  UnsizedArrayOf<OffsetTo<Coverage> >\n+                coverageZ;              \/* Array of offsets to Coverage\n+                                         * table in glyph sequence order *\/\n+\/*UnsizedArrayOf<LookupRecord>\n+                lookupRecordX;*\/        \/* Array of LookupRecords--in\n+                                         * design order *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, coverageZ);\n+};\n+\n+struct Context\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    case 2: return_trace (c->dispatch (u.format2));\n+    case 3: return_trace (c->dispatch (u.format3));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  ContextFormat1        format1;\n+  ContextFormat2        format2;\n+  ContextFormat3        format3;\n+  } u;\n+};\n+\n+\n+\/* Chaining Contextual lookups *\/\n+\n+struct ChainContextClosureLookupContext\n+{\n+  ContextClosureFuncs funcs;\n+  const void *intersects_data[3];\n+};\n+\n+struct ChainContextCollectGlyphsLookupContext\n+{\n+  ContextCollectGlyphsFuncs funcs;\n+  const void *collect_data[3];\n+};\n+\n+struct ChainContextApplyLookupContext\n+{\n+  ContextApplyFuncs funcs;\n+  const void *match_data[3];\n+};\n+\n+static inline bool chain_context_intersects (const hb_set_t *glyphs,\n+                                             unsigned int backtrackCount,\n+                                             const HBUINT16 backtrack[],\n+                                             unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                             const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                             unsigned int lookaheadCount,\n+                                             const HBUINT16 lookahead[],\n+                                             ChainContextClosureLookupContext &lookup_context)\n+{\n+  return intersects_array (glyphs,\n+                           backtrackCount, backtrack,\n+                           lookup_context.funcs.intersects, lookup_context.intersects_data[0])\n+      && intersects_array (glyphs,\n+                           inputCount ? inputCount - 1 : 0, input,\n+                           lookup_context.funcs.intersects, lookup_context.intersects_data[1])\n+      && intersects_array (glyphs,\n+                          lookaheadCount, lookahead,\n+                          lookup_context.funcs.intersects, lookup_context.intersects_data[2]);\n+}\n+\n+static inline void chain_context_closure_lookup (hb_closure_context_t *c,\n+                                                 unsigned int backtrackCount,\n+                                                 const HBUINT16 backtrack[],\n+                                                 unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                                 const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                 unsigned int lookaheadCount,\n+                                                 const HBUINT16 lookahead[],\n+                                                 unsigned int lookupCount,\n+                                                 const LookupRecord lookupRecord[],\n+                                                 ChainContextClosureLookupContext &lookup_context)\n+{\n+  if (chain_context_intersects (c->glyphs,\n+                                backtrackCount, backtrack,\n+                                inputCount, input,\n+                                lookaheadCount, lookahead,\n+                                lookup_context))\n+    recurse_lookups (c,\n+                     lookupCount, lookupRecord);\n+}\n+\n+static inline void chain_context_collect_glyphs_lookup (hb_collect_glyphs_context_t *c,\n+                                                        unsigned int backtrackCount,\n+                                                        const HBUINT16 backtrack[],\n+                                                        unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                                        const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                        unsigned int lookaheadCount,\n+                                                        const HBUINT16 lookahead[],\n+                                                        unsigned int lookupCount,\n+                                                        const LookupRecord lookupRecord[],\n+                                                        ChainContextCollectGlyphsLookupContext &lookup_context)\n+{\n+  collect_array (c, c->before,\n+                 backtrackCount, backtrack,\n+                 lookup_context.funcs.collect, lookup_context.collect_data[0]);\n+  collect_array (c, c->input,\n+                 inputCount ? inputCount - 1 : 0, input,\n+                 lookup_context.funcs.collect, lookup_context.collect_data[1]);\n+  collect_array (c, c->after,\n+                 lookaheadCount, lookahead,\n+                 lookup_context.funcs.collect, lookup_context.collect_data[2]);\n+  recurse_lookups (c,\n+                   lookupCount, lookupRecord);\n+}\n+\n+static inline bool chain_context_would_apply_lookup (hb_would_apply_context_t *c,\n+                                                     unsigned int backtrackCount,\n+                                                     const HBUINT16 backtrack[] HB_UNUSED,\n+                                                     unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                                     const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                                     unsigned int lookaheadCount,\n+                                                     const HBUINT16 lookahead[] HB_UNUSED,\n+                                                     unsigned int lookupCount HB_UNUSED,\n+                                                     const LookupRecord lookupRecord[] HB_UNUSED,\n+                                                     ChainContextApplyLookupContext &lookup_context)\n+{\n+  return (c->zero_context ? !backtrackCount && !lookaheadCount : true)\n+      && would_match_input (c,\n+                            inputCount, input,\n+                            lookup_context.funcs.match, lookup_context.match_data[1]);\n+}\n+\n+static inline bool chain_context_apply_lookup (hb_ot_apply_context_t *c,\n+                                               unsigned int backtrackCount,\n+                                               const HBUINT16 backtrack[],\n+                                               unsigned int inputCount, \/* Including the first glyph (not matched) *\/\n+                                               const HBUINT16 input[], \/* Array of input values--start with second glyph *\/\n+                                               unsigned int lookaheadCount,\n+                                               const HBUINT16 lookahead[],\n+                                               unsigned int lookupCount,\n+                                               const LookupRecord lookupRecord[],\n+                                               ChainContextApplyLookupContext &lookup_context)\n+{\n+  unsigned int start_index = 0, match_length = 0, end_index = 0;\n+  unsigned int match_positions[HB_MAX_CONTEXT_LENGTH];\n+  return match_input (c,\n+                      inputCount, input,\n+                      lookup_context.funcs.match, lookup_context.match_data[1],\n+                      &match_length, match_positions)\n+      && match_backtrack (c,\n+                          backtrackCount, backtrack,\n+                          lookup_context.funcs.match, lookup_context.match_data[0],\n+                          &start_index)\n+      && match_lookahead (c,\n+                          lookaheadCount, lookahead,\n+                          lookup_context.funcs.match, lookup_context.match_data[2],\n+                          match_length, &end_index)\n+      && (c->buffer->unsafe_to_break_from_outbuffer (start_index, end_index),\n+          apply_lookup (c,\n+                        inputCount, match_positions,\n+                        lookupCount, lookupRecord,\n+                        match_length));\n+}\n+\n+struct ChainRule\n+{\n+  bool intersects (const hb_set_t *glyphs, ChainContextClosureLookupContext &lookup_context) const\n+  {\n+    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16> > (backtrack);\n+    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16> > (input);\n+    return chain_context_intersects (glyphs,\n+                                     backtrack.len, backtrack.arrayZ,\n+                                     input.lenP1, input.arrayZ,\n+                                     lookahead.len, lookahead.arrayZ,\n+                                     lookup_context);\n+  }\n+\n+  void closure (hb_closure_context_t *c,\n+                ChainContextClosureLookupContext &lookup_context) const\n+  {\n+    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16> > (backtrack);\n+    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    chain_context_closure_lookup (c,\n+                                  backtrack.len, backtrack.arrayZ,\n+                                  input.lenP1, input.arrayZ,\n+                                  lookahead.len, lookahead.arrayZ,\n+                                  lookup.len, lookup.arrayZ,\n+                                  lookup_context);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c,\n+                       ChainContextCollectGlyphsLookupContext &lookup_context) const\n+  {\n+    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16> > (backtrack);\n+    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    chain_context_collect_glyphs_lookup (c,\n+                                         backtrack.len, backtrack.arrayZ,\n+                                         input.lenP1, input.arrayZ,\n+                                         lookahead.len, lookahead.arrayZ,\n+                                         lookup.len, lookup.arrayZ,\n+                                         lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c,\n+                    ChainContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16> > (backtrack);\n+    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    return_trace (chain_context_would_apply_lookup (c,\n+                                                    backtrack.len, backtrack.arrayZ,\n+                                                    input.lenP1, input.arrayZ,\n+                                                    lookahead.len, lookahead.arrayZ, lookup.len,\n+                                                    lookup.arrayZ, lookup_context));\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_APPLY (this);\n+    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16> > (backtrack);\n+    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    return_trace (chain_context_apply_lookup (c,\n+                                              backtrack.len, backtrack.arrayZ,\n+                                              input.lenP1, input.arrayZ,\n+                                              lookahead.len, lookahead.arrayZ, lookup.len,\n+                                              lookup.arrayZ, lookup_context));\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!backtrack.sanitize (c)) return_trace (false);\n+    const HeadlessArrayOf<HBUINT16> &input = StructAfter<HeadlessArrayOf<HBUINT16> > (backtrack);\n+    if (!input.sanitize (c)) return_trace (false);\n+    const ArrayOf<HBUINT16> &lookahead = StructAfter<ArrayOf<HBUINT16> > (input);\n+    if (!lookahead.sanitize (c)) return_trace (false);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    return_trace (lookup.sanitize (c));\n+  }\n+\n+  protected:\n+  ArrayOf<HBUINT16>\n+                backtrack;              \/* Array of backtracking values\n+                                         * (to be matched before the input\n+                                         * sequence) *\/\n+  HeadlessArrayOf<HBUINT16>\n+                inputX;                 \/* Array of input values (start with\n+                                         * second glyph) *\/\n+  ArrayOf<HBUINT16>\n+                lookaheadX;             \/* Array of lookahead values's (to be\n+                                         * matched after the input sequence) *\/\n+  ArrayOf<LookupRecord>\n+                lookupX;                \/* Array of LookupRecords--in\n+                                         * design order) *\/\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+struct ChainRuleSet\n+{\n+  bool intersects (const hb_set_t *glyphs, ChainContextClosureLookupContext &lookup_context) const\n+  {\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      if ((this+rule[i]).intersects (glyphs, lookup_context))\n+        return true;\n+    return false;\n+  }\n+  void closure (hb_closure_context_t *c, ChainContextClosureLookupContext &lookup_context) const\n+  {\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      (this+rule[i]).closure (c, lookup_context);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c, ChainContextCollectGlyphsLookupContext &lookup_context) const\n+  {\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      (this+rule[i]).collect_glyphs (c, lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      if ((this+rule[i]).would_apply (c, lookup_context))\n+        return_trace (true);\n+\n+    return_trace (false);\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c, ChainContextApplyLookupContext &lookup_context) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int num_rules = rule.len;\n+    for (unsigned int i = 0; i < num_rules; i++)\n+      if ((this+rule[i]).apply (c, lookup_context))\n+        return_trace (true);\n+\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (rule.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetArrayOf<ChainRule>\n+                rule;                   \/* Array of ChainRule tables\n+                                         * ordered by preference *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (2, rule);\n+};\n+\n+struct ChainContextFormat1\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    struct ChainContextClosureLookupContext lookup_context = {\n+      {intersects_glyph},\n+      {nullptr, nullptr, nullptr}\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (glyphs->has (iter.get_glyph ()) &&\n+          (this+ruleSet[iter.get_coverage ()]).intersects (glyphs, lookup_context))\n+        return true;\n+    }\n+    return false;\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    struct ChainContextClosureLookupContext lookup_context = {\n+      {intersects_glyph},\n+      {nullptr, nullptr, nullptr}\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (Coverage::Iter iter (this+coverage); iter.more (); iter.next ())\n+    {\n+      if (unlikely (iter.get_coverage () >= count))\n+        break; \/* Work around malicious fonts. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/363 *\/\n+      if (c->glyphs->has (iter.get_glyph ()))\n+        (this+ruleSet[iter.get_coverage ()]).closure (c, lookup_context);\n+    }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    (this+coverage).add_coverage (c->input);\n+\n+    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n+      {collect_glyph},\n+      {nullptr, nullptr, nullptr}\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+\n+    const ChainRuleSet &rule_set = this+ruleSet[(this+coverage).get_coverage (c->glyphs[0])];\n+    struct ChainContextApplyLookupContext lookup_context = {\n+      {match_glyph},\n+      {nullptr, nullptr, nullptr}\n+    };\n+    return_trace (rule_set.would_apply (c, lookup_context));\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const ChainRuleSet &rule_set = this+ruleSet[index];\n+    struct ChainContextApplyLookupContext lookup_context = {\n+      {match_glyph},\n+      {nullptr, nullptr, nullptr}\n+    };\n+    return_trace (rule_set.apply (c, lookup_context));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) && ruleSet.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 1 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of table *\/\n+  OffsetArrayOf<ChainRuleSet>\n+                ruleSet;                \/* Array of ChainRuleSet tables\n+                                         * ordered by Coverage Index *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, ruleSet);\n+};\n+\n+struct ChainContextFormat2\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    if (!(this+coverage).intersects (glyphs))\n+      return false;\n+\n+    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n+    const ClassDef &input_class_def = this+inputClassDef;\n+    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n+\n+    struct ChainContextClosureLookupContext lookup_context = {\n+      {intersects_class},\n+      {&backtrack_class_def,\n+       &input_class_def,\n+       &lookahead_class_def}\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (input_class_def.intersects_class (glyphs, i) &&\n+          (this+ruleSet[i]).intersects (glyphs, lookup_context))\n+        return true;\n+\n+    return false;\n+  }\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    if (!(this+coverage).intersects (c->glyphs))\n+      return;\n+\n+    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n+    const ClassDef &input_class_def = this+inputClassDef;\n+    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n+\n+    struct ChainContextClosureLookupContext lookup_context = {\n+      {intersects_class},\n+      {&backtrack_class_def,\n+       &input_class_def,\n+       &lookahead_class_def}\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (input_class_def.intersects_class (c->glyphs, i)) {\n+        const ChainRuleSet &rule_set = this+ruleSet[i];\n+        rule_set.closure (c, lookup_context);\n+      }\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    (this+coverage).add_coverage (c->input);\n+\n+    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n+    const ClassDef &input_class_def = this+inputClassDef;\n+    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n+\n+    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n+      {collect_class},\n+      {&backtrack_class_def,\n+       &input_class_def,\n+       &lookahead_class_def}\n+    };\n+\n+    unsigned int count = ruleSet.len;\n+    for (unsigned int i = 0; i < count; i++)\n+      (this+ruleSet[i]).collect_glyphs (c, lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+\n+    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n+    const ClassDef &input_class_def = this+inputClassDef;\n+    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n+\n+    unsigned int index = input_class_def.get_class (c->glyphs[0]);\n+    const ChainRuleSet &rule_set = this+ruleSet[index];\n+    struct ChainContextApplyLookupContext lookup_context = {\n+      {match_class},\n+      {&backtrack_class_def,\n+       &input_class_def,\n+       &lookahead_class_def}\n+    };\n+    return_trace (rule_set.would_apply (c, lookup_context));\n+  }\n+\n+  const Coverage &get_coverage () const { return this+coverage; }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    unsigned int index = (this+coverage).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const ClassDef &backtrack_class_def = this+backtrackClassDef;\n+    const ClassDef &input_class_def = this+inputClassDef;\n+    const ClassDef &lookahead_class_def = this+lookaheadClassDef;\n+\n+    index = input_class_def.get_class (c->buffer->cur().codepoint);\n+    const ChainRuleSet &rule_set = this+ruleSet[index];\n+    struct ChainContextApplyLookupContext lookup_context = {\n+      {match_class},\n+      {&backtrack_class_def,\n+       &input_class_def,\n+       &lookahead_class_def}\n+    };\n+    return_trace (rule_set.apply (c, lookup_context));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (coverage.sanitize (c, this) &&\n+                  backtrackClassDef.sanitize (c, this) &&\n+                  inputClassDef.sanitize (c, this) &&\n+                  lookaheadClassDef.sanitize (c, this) &&\n+                  ruleSet.sanitize (c, this));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 2 *\/\n+  OffsetTo<Coverage>\n+                coverage;               \/* Offset to Coverage table--from\n+                                         * beginning of table *\/\n+  OffsetTo<ClassDef>\n+                backtrackClassDef;      \/* Offset to glyph ClassDef table\n+                                         * containing backtrack sequence\n+                                         * data--from beginning of table *\/\n+  OffsetTo<ClassDef>\n+                inputClassDef;          \/* Offset to glyph ClassDef\n+                                         * table containing input sequence\n+                                         * data--from beginning of table *\/\n+  OffsetTo<ClassDef>\n+                lookaheadClassDef;      \/* Offset to glyph ClassDef table\n+                                         * containing lookahead sequence\n+                                         * data--from beginning of table *\/\n+  OffsetArrayOf<ChainRuleSet>\n+                ruleSet;                \/* Array of ChainRuleSet tables\n+                                         * ordered by class *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (12, ruleSet);\n+};\n+\n+struct ChainContextFormat3\n+{\n+  bool intersects (const hb_set_t *glyphs) const\n+  {\n+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+\n+    if (!(this+input[0]).intersects (glyphs))\n+      return false;\n+\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n+    struct ChainContextClosureLookupContext lookup_context = {\n+      {intersects_coverage},\n+      {this, this, this}\n+    };\n+    return chain_context_intersects (glyphs,\n+                                     backtrack.len, (const HBUINT16 *) backtrack.arrayZ,\n+                                     input.len, (const HBUINT16 *) input.arrayZ + 1,\n+                                     lookahead.len, (const HBUINT16 *) lookahead.arrayZ,\n+                                     lookup_context);\n+  }\n+\n+  void closure (hb_closure_context_t *c) const\n+  {\n+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+\n+    if (!(this+input[0]).intersects (c->glyphs))\n+      return;\n+\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    struct ChainContextClosureLookupContext lookup_context = {\n+      {intersects_coverage},\n+      {this, this, this}\n+    };\n+    chain_context_closure_lookup (c,\n+                                  backtrack.len, (const HBUINT16 *) backtrack.arrayZ,\n+                                  input.len, (const HBUINT16 *) input.arrayZ + 1,\n+                                  lookahead.len, (const HBUINT16 *) lookahead.arrayZ,\n+                                  lookup.len, lookup.arrayZ,\n+                                  lookup_context);\n+  }\n+\n+  void collect_glyphs (hb_collect_glyphs_context_t *c) const\n+  {\n+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+\n+    (this+input[0]).add_coverage (c->input);\n+\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    struct ChainContextCollectGlyphsLookupContext lookup_context = {\n+      {collect_coverage},\n+      {this, this, this}\n+    };\n+    chain_context_collect_glyphs_lookup (c,\n+                                         backtrack.len, (const HBUINT16 *) backtrack.arrayZ,\n+                                         input.len, (const HBUINT16 *) input.arrayZ + 1,\n+                                         lookahead.len, (const HBUINT16 *) lookahead.arrayZ,\n+                                         lookup.len, lookup.arrayZ,\n+                                         lookup_context);\n+  }\n+\n+  bool would_apply (hb_would_apply_context_t *c) const\n+  {\n+    TRACE_WOULD_APPLY (this);\n+\n+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    struct ChainContextApplyLookupContext lookup_context = {\n+      {match_coverage},\n+      {this, this, this}\n+    };\n+    return_trace (chain_context_would_apply_lookup (c,\n+                                                    backtrack.len, (const HBUINT16 *) backtrack.arrayZ,\n+                                                    input.len, (const HBUINT16 *) input.arrayZ + 1,\n+                                                    lookahead.len, (const HBUINT16 *) lookahead.arrayZ,\n+                                                    lookup.len, lookup.arrayZ, lookup_context));\n+  }\n+\n+  const Coverage &get_coverage () const\n+  {\n+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+    return this+input[0];\n+  }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    TRACE_APPLY (this);\n+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+\n+    unsigned int index = (this+input[0]).get_coverage (c->buffer->cur().codepoint);\n+    if (likely (index == NOT_COVERED)) return_trace (false);\n+\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    struct ChainContextApplyLookupContext lookup_context = {\n+      {match_coverage},\n+      {this, this, this}\n+    };\n+    return_trace (chain_context_apply_lookup (c,\n+                                              backtrack.len, (const HBUINT16 *) backtrack.arrayZ,\n+                                              input.len, (const HBUINT16 *) input.arrayZ + 1,\n+                                              lookahead.len, (const HBUINT16 *) lookahead.arrayZ,\n+                                              lookup.len, lookup.arrayZ, lookup_context));\n+  }\n+\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    \/\/ TODO(subset)\n+    return_trace (false);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (!backtrack.sanitize (c, this)) return_trace (false);\n+    const OffsetArrayOf<Coverage> &input = StructAfter<OffsetArrayOf<Coverage> > (backtrack);\n+    if (!input.sanitize (c, this)) return_trace (false);\n+    if (!input.len) return_trace (false); \/* To be consistent with Context. *\/\n+    const OffsetArrayOf<Coverage> &lookahead = StructAfter<OffsetArrayOf<Coverage> > (input);\n+    if (!lookahead.sanitize (c, this)) return_trace (false);\n+    const ArrayOf<LookupRecord> &lookup = StructAfter<ArrayOf<LookupRecord> > (lookahead);\n+    return_trace (lookup.sanitize (c));\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier--format = 3 *\/\n+  OffsetArrayOf<Coverage>\n+                backtrack;              \/* Array of coverage tables\n+                                         * in backtracking sequence, in  glyph\n+                                         * sequence order *\/\n+  OffsetArrayOf<Coverage>\n+                inputX          ;       \/* Array of coverage\n+                                         * tables in input sequence, in glyph\n+                                         * sequence order *\/\n+  OffsetArrayOf<Coverage>\n+                lookaheadX;             \/* Array of coverage tables\n+                                         * in lookahead sequence, in glyph\n+                                         * sequence order *\/\n+  ArrayOf<LookupRecord>\n+                lookupX;                \/* Array of LookupRecords--in\n+                                         * design order) *\/\n+  public:\n+  DEFINE_SIZE_MIN (10);\n+};\n+\n+struct ChainContext\n+{\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (c->dispatch (u.format1));\n+    case 2: return_trace (c->dispatch (u.format2));\n+    case 3: return_trace (c->dispatch (u.format3));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format; \/* Format identifier *\/\n+  ChainContextFormat1   format1;\n+  ChainContextFormat2   format2;\n+  ChainContextFormat3   format3;\n+  } u;\n+};\n+\n+\n+template <typename T>\n+struct ExtensionFormat1\n+{\n+  unsigned int get_type () const { return extensionLookupType; }\n+\n+  template <typename X>\n+  const X& get_subtable () const\n+  {\n+    unsigned int offset = extensionOffset;\n+    if (unlikely (!offset)) return Null(typename T::SubTable);\n+    return StructAtOffset<typename T::SubTable> (this, offset);\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, format);\n+    if (unlikely (!c->may_dispatch (this, this))) return_trace (c->no_dispatch_return_value ());\n+    return_trace (get_subtable<typename T::SubTable> ().dispatch (c, get_type ()));\n+  }\n+\n+  \/* This is called from may_dispatch() above with hb_sanitize_context_t. *\/\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  extensionOffset != 0 &&\n+                  extensionLookupType != T::SubTable::Extension);\n+  }\n+\n+  protected:\n+  HBUINT16      format;                 \/* Format identifier. Set to 1. *\/\n+  HBUINT16      extensionLookupType;    \/* Lookup type of subtable referenced\n+                                         * by ExtensionOffset (i.e. the\n+                                         * extension subtable). *\/\n+  HBUINT32      extensionOffset;        \/* Offset to the extension subtable,\n+                                         * of lookup type subtable. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+template <typename T>\n+struct Extension\n+{\n+  unsigned int get_type () const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.get_type ();\n+    default:return 0;\n+    }\n+  }\n+  template <typename X>\n+  const X& get_subtable () const\n+  {\n+    switch (u.format) {\n+    case 1: return u.format1.template get_subtable<typename T::SubTable> ();\n+    default:return Null(typename T::SubTable);\n+    }\n+  }\n+\n+  template <typename context_t>\n+  typename context_t::return_t dispatch (context_t *c) const\n+  {\n+    TRACE_DISPATCH (this, u.format);\n+    if (unlikely (!c->may_dispatch (this, &u.format))) return_trace (c->no_dispatch_return_value ());\n+    switch (u.format) {\n+    case 1: return_trace (u.format1.dispatch (c));\n+    default:return_trace (c->default_return_value ());\n+    }\n+  }\n+\n+  protected:\n+  union {\n+  HBUINT16              format;         \/* Format identifier *\/\n+  ExtensionFormat1<T>   format1;\n+  } u;\n+};\n+\n+\n+\/*\n+ * GSUB\/GPOS Common\n+ *\/\n+\n+struct hb_ot_layout_lookup_accelerator_t\n+{\n+  template <typename TLookup>\n+  void init (const TLookup &lookup)\n+  {\n+    digest.init ();\n+    lookup.add_coverage (&digest);\n+\n+    subtables.init ();\n+    OT::hb_get_subtables_context_t c_get_subtables (subtables);\n+    lookup.dispatch (&c_get_subtables);\n+  }\n+  void fini () { subtables.fini (); }\n+\n+  bool may_have (hb_codepoint_t g) const\n+  { return digest.may_have (g); }\n+\n+  bool apply (hb_ot_apply_context_t *c) const\n+  {\n+    for (unsigned int i = 0; i < subtables.length; i++)\n+      if (subtables[i].apply (c))\n+        return true;\n+    return false;\n+  }\n+\n+  private:\n+  hb_set_digest_t digest;\n+  hb_get_subtables_context_t::array_t subtables;\n+};\n+\n+struct GSUBGPOS\n+{\n+  bool has_data () const { return version.to_int (); }\n+  unsigned int get_script_count () const\n+  { return (this+scriptList).len; }\n+  const Tag& get_script_tag (unsigned int i) const\n+  { return (this+scriptList).get_tag (i); }\n+  unsigned int get_script_tags (unsigned int start_offset,\n+                                unsigned int *script_count \/* IN\/OUT *\/,\n+                                hb_tag_t     *script_tags \/* OUT *\/) const\n+  { return (this+scriptList).get_tags (start_offset, script_count, script_tags); }\n+  const Script& get_script (unsigned int i) const\n+  { return (this+scriptList)[i]; }\n+  bool find_script_index (hb_tag_t tag, unsigned int *index) const\n+  { return (this+scriptList).find_index (tag, index); }\n+\n+  unsigned int get_feature_count () const\n+  { return (this+featureList).len; }\n+  hb_tag_t get_feature_tag (unsigned int i) const\n+  { return i == Index::NOT_FOUND_INDEX ? HB_TAG_NONE : (this+featureList).get_tag (i); }\n+  unsigned int get_feature_tags (unsigned int start_offset,\n+                                 unsigned int *feature_count \/* IN\/OUT *\/,\n+                                 hb_tag_t     *feature_tags \/* OUT *\/) const\n+  { return (this+featureList).get_tags (start_offset, feature_count, feature_tags); }\n+  const Feature& get_feature (unsigned int i) const\n+  { return (this+featureList)[i]; }\n+  bool find_feature_index (hb_tag_t tag, unsigned int *index) const\n+  { return (this+featureList).find_index (tag, index); }\n+\n+  unsigned int get_lookup_count () const\n+  { return (this+lookupList).len; }\n+  const Lookup& get_lookup (unsigned int i) const\n+  { return (this+lookupList)[i]; }\n+\n+  bool find_variations_index (const int *coords, unsigned int num_coords,\n+                              unsigned int *index) const\n+  { return (version.to_int () >= 0x00010001u ? this+featureVars : Null(FeatureVariations))\n+           .find_index (coords, num_coords, index); }\n+  const Feature& get_feature_variation (unsigned int feature_index,\n+                                        unsigned int variations_index) const\n+  {\n+    if (FeatureVariations::NOT_FOUND_INDEX != variations_index &&\n+        version.to_int () >= 0x00010001u)\n+    {\n+      const Feature *feature = (this+featureVars).find_substitute (variations_index,\n+                                                                   feature_index);\n+      if (feature)\n+        return *feature;\n+    }\n+    return get_feature (feature_index);\n+  }\n+\n+  template <typename TLookup>\n+  bool subset (hb_subset_context_t *c) const\n+  {\n+    TRACE_SUBSET (this);\n+    struct GSUBGPOS *out = c->serializer->embed (*this);\n+    if (unlikely (!out)) return_trace (false);\n+\n+    out->scriptList.serialize_subset (c, this+scriptList, out);\n+    out->featureList.serialize_subset (c, this+featureList, out);\n+\n+    typedef OffsetListOf<TLookup> TLookupList;\n+    \/* TODO Use intersects() to count how many subtables survive? *\/\n+    CastR<OffsetTo<TLookupList> > (out->lookupList)\n+      .serialize_subset (c,\n+                         this+CastR<const OffsetTo<TLookupList> > (lookupList),\n+                         out);\n+\n+    if (version.to_int () >= 0x00010001u)\n+     out->featureVars.serialize_subset (c, this+featureVars, out);\n+\n+    return_trace (true);\n+  }\n+\n+  unsigned int get_size () const\n+  {\n+    return min_size +\n+           (version.to_int () >= 0x00010001u ? featureVars.static_size : 0);\n+  }\n+\n+  template <typename TLookup>\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    typedef OffsetListOf<TLookup> TLookupList;\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  scriptList.sanitize (c, this) &&\n+                  featureList.sanitize (c, this) &&\n+                  CastR<OffsetTo<TLookupList> > (lookupList).sanitize (c, this) &&\n+                  (version.to_int () < 0x00010001u || featureVars.sanitize (c, this)));\n+  }\n+\n+  template <typename T>\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      this->table = hb_sanitize_context_t().reference_table<T> (face);\n+      if (unlikely (this->table->is_blacklisted (this->table.get_blob (), face)))\n+      {\n+        hb_blob_destroy (this->table.get_blob ());\n+        this->table = hb_blob_get_empty ();\n+      }\n+\n+      this->lookup_count = table->get_lookup_count ();\n+\n+      this->accels = (hb_ot_layout_lookup_accelerator_t *) calloc (this->lookup_count, sizeof (hb_ot_layout_lookup_accelerator_t));\n+      if (unlikely (!this->accels))\n+        this->lookup_count = 0;\n+\n+      for (unsigned int i = 0; i < this->lookup_count; i++)\n+        this->accels[i].init (table->get_lookup (i));\n+    }\n+\n+    void fini ()\n+    {\n+      for (unsigned int i = 0; i < this->lookup_count; i++)\n+        this->accels[i].fini ();\n+      free (this->accels);\n+      this->table.destroy ();\n+    }\n+\n+    hb_blob_ptr_t<T> table;\n+    unsigned int lookup_count;\n+    hb_ot_layout_lookup_accelerator_t *accels;\n+  };\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the GSUB\/GPOS table--initially set\n+                                 * to 0x00010000u *\/\n+  OffsetTo<ScriptList>\n+                scriptList;     \/* ScriptList table *\/\n+  OffsetTo<FeatureList>\n+                featureList;    \/* FeatureList table *\/\n+  OffsetTo<LookupList>\n+                lookupList;     \/* LookupList table *\/\n+  LOffsetTo<FeatureVariations>\n+                featureVars;    \/* Offset to Feature Variations\n+                                   table--from beginning of table\n+                                 * (may be NULL).  Introduced\n+                                 * in version 0x00010001. *\/\n+  public:\n+  DEFINE_SIZE_MIN (10);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_LAYOUT_GSUBGPOS_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout-gsubgpos.hh","additions":2779,"deletions":0,"binary":false,"changes":2779,"status":"added"},{"patch":"@@ -0,0 +1,235 @@\n+\/*\n+ * Copyright © 2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_JSTF_TABLE_HH\n+#define HB_OT_LAYOUT_JSTF_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-layout-gpos-table.hh\"\n+\n+\n+namespace OT {\n+\n+\n+\/*\n+ * JstfModList -- Justification Modification List Tables\n+ *\/\n+\n+typedef IndexArray JstfModList;\n+\n+\n+\/*\n+ * JstfMax -- Justification Maximum Table\n+ *\/\n+\n+typedef OffsetListOf<PosLookup> JstfMax;\n+\n+\n+\/*\n+ * JstfPriority -- Justification Priority Table\n+ *\/\n+\n+struct JstfPriority\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  shrinkageEnableGSUB.sanitize (c, this) &&\n+                  shrinkageDisableGSUB.sanitize (c, this) &&\n+                  shrinkageEnableGPOS.sanitize (c, this) &&\n+                  shrinkageDisableGPOS.sanitize (c, this) &&\n+                  shrinkageJstfMax.sanitize (c, this) &&\n+                  extensionEnableGSUB.sanitize (c, this) &&\n+                  extensionDisableGSUB.sanitize (c, this) &&\n+                  extensionEnableGPOS.sanitize (c, this) &&\n+                  extensionDisableGPOS.sanitize (c, this) &&\n+                  extensionJstfMax.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetTo<JstfModList>\n+                shrinkageEnableGSUB;    \/* Offset to Shrinkage Enable GSUB\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfModList>\n+                shrinkageDisableGSUB;   \/* Offset to Shrinkage Disable GSUB\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfModList>\n+                shrinkageEnableGPOS;    \/* Offset to Shrinkage Enable GPOS\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfModList>\n+                shrinkageDisableGPOS;   \/* Offset to Shrinkage Disable GPOS\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfMax>\n+                shrinkageJstfMax;       \/* Offset to Shrinkage JstfMax table--\n+                                         * from beginning of JstfPriority table\n+                                         * --may be NULL *\/\n+  OffsetTo<JstfModList>\n+                extensionEnableGSUB;    \/* Offset to Extension Enable GSUB\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfModList>\n+                extensionDisableGSUB;   \/* Offset to Extension Disable GSUB\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfModList>\n+                extensionEnableGPOS;    \/* Offset to Extension Enable GPOS\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfModList>\n+                extensionDisableGPOS;   \/* Offset to Extension Disable GPOS\n+                                         * JstfModList table--from beginning of\n+                                         * JstfPriority table--may be NULL *\/\n+  OffsetTo<JstfMax>\n+                extensionJstfMax;       \/* Offset to Extension JstfMax table--\n+                                         * from beginning of JstfPriority table\n+                                         * --may be NULL *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+\n+\/*\n+ * JstfLangSys -- Justification Language System Table\n+ *\/\n+\n+struct JstfLangSys : OffsetListOf<JstfPriority>\n+{\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const Record_sanitize_closure_t * = nullptr) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (OffsetListOf<JstfPriority>::sanitize (c));\n+  }\n+};\n+\n+\n+\/*\n+ * ExtenderGlyphs -- Extender Glyph Table\n+ *\/\n+\n+typedef SortedArrayOf<GlyphID> ExtenderGlyphs;\n+\n+\n+\/*\n+ * JstfScript -- The Justification Table\n+ *\/\n+\n+struct JstfScript\n+{\n+  unsigned int get_lang_sys_count () const\n+  { return langSys.len; }\n+  const Tag& get_lang_sys_tag (unsigned int i) const\n+  { return langSys.get_tag (i); }\n+  unsigned int get_lang_sys_tags (unsigned int start_offset,\n+                                  unsigned int *lang_sys_count \/* IN\/OUT *\/,\n+                                  hb_tag_t     *lang_sys_tags \/* OUT *\/) const\n+  { return langSys.get_tags (start_offset, lang_sys_count, lang_sys_tags); }\n+  const JstfLangSys& get_lang_sys (unsigned int i) const\n+  {\n+    if (i == Index::NOT_FOUND_INDEX) return get_default_lang_sys ();\n+    return this+langSys[i].offset;\n+  }\n+  bool find_lang_sys_index (hb_tag_t tag, unsigned int *index) const\n+  { return langSys.find_index (tag, index); }\n+\n+  bool has_default_lang_sys () const               { return defaultLangSys != 0; }\n+  const JstfLangSys& get_default_lang_sys () const { return this+defaultLangSys; }\n+\n+  bool sanitize (hb_sanitize_context_t *c,\n+                 const Record_sanitize_closure_t * = nullptr) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (extenderGlyphs.sanitize (c, this) &&\n+                  defaultLangSys.sanitize (c, this) &&\n+                  langSys.sanitize (c, this));\n+  }\n+\n+  protected:\n+  OffsetTo<ExtenderGlyphs>\n+                extenderGlyphs; \/* Offset to ExtenderGlyph table--from beginning\n+                                 * of JstfScript table-may be NULL *\/\n+  OffsetTo<JstfLangSys>\n+                defaultLangSys; \/* Offset to DefaultJstfLangSys table--from\n+                                 * beginning of JstfScript table--may be Null *\/\n+  RecordArrayOf<JstfLangSys>\n+                langSys;        \/* Array of JstfLangSysRecords--listed\n+                                 * alphabetically by LangSysTag *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, langSys);\n+};\n+\n+\n+\/*\n+ * JSTF -- Justification\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/jstf\n+ *\/\n+\n+struct JSTF\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_JSTF;\n+\n+  unsigned int get_script_count () const\n+  { return scriptList.len; }\n+  const Tag& get_script_tag (unsigned int i) const\n+  { return scriptList.get_tag (i); }\n+  unsigned int get_script_tags (unsigned int start_offset,\n+                                unsigned int *script_count \/* IN\/OUT *\/,\n+                                hb_tag_t     *script_tags \/* OUT *\/) const\n+  { return scriptList.get_tags (start_offset, script_count, script_tags); }\n+  const JstfScript& get_script (unsigned int i) const\n+  { return this+scriptList[i].offset; }\n+  bool find_script_index (hb_tag_t tag, unsigned int *index) const\n+  { return scriptList.find_index (tag, index); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  scriptList.sanitize (c, this));\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the JSTF table--initially set\n+                                 * to 0x00010000u *\/\n+  RecordArrayOf<JstfScript>\n+                scriptList;     \/* Array of JstfScripts--listed\n+                                 * alphabetically by ScriptTag *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, scriptList);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_LAYOUT_JSTF_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout-jstf-table.hh","additions":235,"deletions":0,"binary":false,"changes":235,"status":"added"},{"patch":"@@ -0,0 +1,1531 @@\n+\/*\n+ * Copyright © 1998-2004  David Turner and Werner Lemberg\n+ * Copyright © 2006  Behdad Esfahbod\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-ot-face.hh\"\n+#include \"hb-ot-map.hh\"\n+#include \"hb-map.hh\"\n+\n+#include \"hb-ot-kern-table.hh\"\n+#include \"hb-ot-gasp-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-ot-layout-gdef-table.hh\"\n+#include \"hb-ot-layout-gsub-table.hh\"\n+#include \"hb-ot-layout-gpos-table.hh\"\n+#include \"hb-ot-layout-base-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-ot-layout-jstf-table.hh\" \/\/ Just so we compile it; unused otherwise.\n+#include \"hb-ot-name-table.hh\"\n+#include \"hb-ot-os2-table.hh\"\n+\n+#include \"hb-aat-layout-lcar-table.hh\"\n+#include \"hb-aat-layout-morx-table.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-ot-layout\n+ * @title: hb-ot-layout\n+ * @short_description: OpenType Layout\n+ * @include: hb-ot.h\n+ *\n+ * Functions for querying OpenType Layout features in the font face.\n+ **\/\n+\n+\n+\/*\n+ * kern\n+ *\/\n+\n+bool\n+hb_ot_layout_has_kerning (hb_face_t *face)\n+{\n+  return face->table.kern->has_data ();\n+}\n+\n+bool\n+hb_ot_layout_has_machine_kerning (hb_face_t *face)\n+{\n+  return face->table.kern->has_state_machine ();\n+}\n+\n+bool\n+hb_ot_layout_has_cross_kerning (hb_face_t *face)\n+{\n+  return face->table.kern->has_cross_stream ();\n+}\n+\n+void\n+hb_ot_layout_kern (const hb_ot_shape_plan_t *plan,\n+                   hb_font_t *font,\n+                   hb_buffer_t  *buffer)\n+{\n+  hb_blob_t *blob = font->face->table.kern.get_blob ();\n+  const AAT::kern& kern = *blob->as<AAT::kern> ();\n+\n+  AAT::hb_aat_apply_context_t c (plan, font, buffer, blob);\n+\n+  kern.apply (&c);\n+}\n+\n+\n+\/*\n+ * GDEF\n+ *\/\n+\n+bool\n+OT::GDEF::is_blacklisted (hb_blob_t *blob,\n+                          hb_face_t *face) const\n+{\n+  \/* The ugly business of blacklisting individual fonts' tables happen here!\n+   * See this thread for why we finally had to bend in and do this:\n+   * https:\/\/lists.freedesktop.org\/archives\/harfbuzz\/2016-February\/005489.html\n+   *\n+   * In certain versions of Times New Roman Italic and Bold Italic,\n+   * ASCII double quotation mark U+0022 has wrong glyph class 3 (mark)\n+   * in GDEF.  Many versions of Tahoma have bad GDEF tables that\n+   * incorrectly classify some spacing marks such as certain IPA\n+   * symbols as glyph class 3. So do older versions of Microsoft\n+   * Himalaya, and the version of Cantarell shipped by Ubuntu 16.04.\n+   *\n+   * Nuke the GDEF tables of to avoid unwanted width-zeroing.\n+   *\n+   * See https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1279925\n+   *     https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1279693\n+   *     https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1279875\n+   *\/\n+#define ENCODE(x,y,z) (((uint64_t) (x) << 48) | ((uint64_t) (y) << 24) | (uint64_t) (z))\n+  switch ENCODE(blob->length,\n+                face->table.GSUB->table.get_length (),\n+                face->table.GPOS->table.get_length ())\n+  {\n+    \/* sha1sum:c5ee92f0bca4bfb7d06c4d03e8cf9f9cf75d2e8a Windows 7? timesi.ttf *\/\n+    case ENCODE (442, 2874, 42038):\n+    \/* sha1sum:37fc8c16a0894ab7b749e35579856c73c840867b Windows 7? timesbi.ttf *\/\n+    case ENCODE (430, 2874, 40662):\n+    \/* sha1sum:19fc45110ea6cd3cdd0a5faca256a3797a069a80 Windows 7 timesi.ttf *\/\n+    case ENCODE (442, 2874, 39116):\n+    \/* sha1sum:6d2d3c9ed5b7de87bc84eae0df95ee5232ecde26 Windows 7 timesbi.ttf *\/\n+    case ENCODE (430, 2874, 39374):\n+    \/* sha1sum:8583225a8b49667c077b3525333f84af08c6bcd8 OS X 10.11.3 Times New Roman Italic.ttf *\/\n+    case ENCODE (490, 3046, 41638):\n+    \/* sha1sum:ec0f5a8751845355b7c3271d11f9918a966cb8c9 OS X 10.11.3 Times New Roman Bold Italic.ttf *\/\n+    case ENCODE (478, 3046, 41902):\n+    \/* sha1sum:96eda93f7d33e79962451c6c39a6b51ee893ce8c  tahoma.ttf from Windows 8 *\/\n+    case ENCODE (898, 12554, 46470):\n+    \/* sha1sum:20928dc06014e0cd120b6fc942d0c3b1a46ac2bc  tahomabd.ttf from Windows 8 *\/\n+    case ENCODE (910, 12566, 47732):\n+    \/* sha1sum:4f95b7e4878f60fa3a39ca269618dfde9721a79e  tahoma.ttf from Windows 8.1 *\/\n+    case ENCODE (928, 23298, 59332):\n+    \/* sha1sum:6d400781948517c3c0441ba42acb309584b73033  tahomabd.ttf from Windows 8.1 *\/\n+    case ENCODE (940, 23310, 60732):\n+    \/* tahoma.ttf v6.04 from Windows 8.1 x64, see https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1279925 *\/\n+    case ENCODE (964, 23836, 60072):\n+    \/* tahomabd.ttf v6.04 from Windows 8.1 x64, see https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1279925 *\/\n+    case ENCODE (976, 23832, 61456):\n+    \/* sha1sum:e55fa2dfe957a9f7ec26be516a0e30b0c925f846  tahoma.ttf from Windows 10 *\/\n+    case ENCODE (994, 24474, 60336):\n+    \/* sha1sum:7199385abb4c2cc81c83a151a7599b6368e92343  tahomabd.ttf from Windows 10 *\/\n+    case ENCODE (1006, 24470, 61740):\n+    \/* tahoma.ttf v6.91 from Windows 10 x64, see https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1279925 *\/\n+    case ENCODE (1006, 24576, 61346):\n+    \/* tahomabd.ttf v6.91 from Windows 10 x64, see https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1279925 *\/\n+    case ENCODE (1018, 24572, 62828):\n+    \/* sha1sum:b9c84d820c49850d3d27ec498be93955b82772b5  tahoma.ttf from Windows 10 AU *\/\n+    case ENCODE (1006, 24576, 61352):\n+    \/* sha1sum:2bdfaab28174bdadd2f3d4200a30a7ae31db79d2  tahomabd.ttf from Windows 10 AU *\/\n+    case ENCODE (1018, 24572, 62834):\n+    \/* sha1sum:b0d36cf5a2fbe746a3dd277bffc6756a820807a7  Tahoma.ttf from Mac OS X 10.9 *\/\n+    case ENCODE (832, 7324, 47162):\n+    \/* sha1sum:12fc4538e84d461771b30c18b5eb6bd434e30fba  Tahoma Bold.ttf from Mac OS X 10.9 *\/\n+    case ENCODE (844, 7302, 45474):\n+    \/* sha1sum:eb8afadd28e9cf963e886b23a30b44ab4fd83acc  himalaya.ttf from Windows 7 *\/\n+    case ENCODE (180, 13054, 7254):\n+    \/* sha1sum:73da7f025b238a3f737aa1fde22577a6370f77b0  himalaya.ttf from Windows 8 *\/\n+    case ENCODE (192, 12638, 7254):\n+    \/* sha1sum:6e80fd1c0b059bbee49272401583160dc1e6a427  himalaya.ttf from Windows 8.1 *\/\n+    case ENCODE (192, 12690, 7254):\n+    \/* 8d9267aea9cd2c852ecfb9f12a6e834bfaeafe44  cantarell-fonts-0.0.21\/otf\/Cantarell-Regular.otf *\/\n+    \/* 983988ff7b47439ab79aeaf9a45bd4a2c5b9d371  cantarell-fonts-0.0.21\/otf\/Cantarell-Oblique.otf *\/\n+    case ENCODE (188, 248, 3852):\n+    \/* 2c0c90c6f6087ffbfea76589c93113a9cbb0e75f  cantarell-fonts-0.0.21\/otf\/Cantarell-Bold.otf *\/\n+    \/* 55461f5b853c6da88069ffcdf7f4dd3f8d7e3e6b  cantarell-fonts-0.0.21\/otf\/Cantarell-Bold-Oblique.otf *\/\n+    case ENCODE (188, 264, 3426):\n+    \/* d125afa82a77a6475ac0e74e7c207914af84b37a padauk-2.80\/Padauk.ttf RHEL 7.2 *\/\n+    case ENCODE (1058, 47032, 11818):\n+    \/* 0f7b80437227b90a577cc078c0216160ae61b031 padauk-2.80\/Padauk-Bold.ttf RHEL 7.2*\/\n+    case ENCODE (1046, 47030, 12600):\n+    \/* d3dde9aa0a6b7f8f6a89ef1002e9aaa11b882290 padauk-2.80\/Padauk.ttf Ubuntu 16.04 *\/\n+    case ENCODE (1058, 71796, 16770):\n+    \/* 5f3c98ccccae8a953be2d122c1b3a77fd805093f padauk-2.80\/Padauk-Bold.ttf Ubuntu 16.04 *\/\n+    case ENCODE (1046, 71790, 17862):\n+    \/* 6c93b63b64e8b2c93f5e824e78caca555dc887c7 padauk-2.80\/Padauk-book.ttf *\/\n+    case ENCODE (1046, 71788, 17112):\n+    \/* d89b1664058359b8ec82e35d3531931125991fb9 padauk-2.80\/Padauk-bookbold.ttf *\/\n+    case ENCODE (1058, 71794, 17514):\n+    \/* 824cfd193aaf6234b2b4dc0cf3c6ef576c0d00ef padauk-3.0\/Padauk-book.ttf *\/\n+    case ENCODE (1330, 109904, 57938):\n+    \/* 91fcc10cf15e012d27571e075b3b4dfe31754a8a padauk-3.0\/Padauk-bookbold.ttf *\/\n+    case ENCODE (1330, 109904, 58972):\n+    \/* sha1sum: c26e41d567ed821bed997e937bc0c41435689e85  Padauk.ttf\n+     *  \"Padauk Regular\" \"Version 2.5\", see https:\/\/crbug.com\/681813 *\/\n+    case ENCODE (1004, 59092, 14836):\n+      return true;\n+#undef ENCODE\n+  }\n+  return false;\n+}\n+\n+static void\n+_hb_ot_layout_set_glyph_props (hb_font_t *font,\n+                               hb_buffer_t *buffer)\n+{\n+  _hb_buffer_assert_gsubgpos_vars (buffer);\n+\n+  const OT::GDEF &gdef = *font->face->table.GDEF->table;\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    _hb_glyph_info_set_glyph_props (&buffer->info[i], gdef.get_glyph_props (buffer->info[i].codepoint));\n+    _hb_glyph_info_clear_lig_props (&buffer->info[i]);\n+    buffer->info[i].syllable() = 0;\n+  }\n+}\n+\n+\/* Public API *\/\n+\n+hb_bool_t\n+hb_ot_layout_has_glyph_classes (hb_face_t *face)\n+{\n+  return face->table.GDEF->table->has_glyph_classes ();\n+}\n+\n+\/**\n+ * hb_ot_layout_get_glyph_class:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_ot_layout_glyph_class_t\n+hb_ot_layout_get_glyph_class (hb_face_t      *face,\n+                              hb_codepoint_t  glyph)\n+{\n+  return (hb_ot_layout_glyph_class_t) face->table.GDEF->table->get_glyph_class (glyph);\n+}\n+\n+\/**\n+ * hb_ot_layout_get_glyphs_in_class:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,\n+                                  hb_ot_layout_glyph_class_t  klass,\n+                                  hb_set_t                   *glyphs \/* OUT *\/)\n+{\n+  return face->table.GDEF->table->get_glyphs_in_class (klass, glyphs);\n+}\n+\n+unsigned int\n+hb_ot_layout_get_attach_points (hb_face_t      *face,\n+                                hb_codepoint_t  glyph,\n+                                unsigned int    start_offset,\n+                                unsigned int   *point_count \/* IN\/OUT *\/,\n+                                unsigned int   *point_array \/* OUT *\/)\n+{\n+  return face->table.GDEF->table->get_attach_points (glyph,\n+                                                     start_offset,\n+                                                     point_count,\n+                                                     point_array);\n+}\n+\n+unsigned int\n+hb_ot_layout_get_ligature_carets (hb_font_t      *font,\n+                                  hb_direction_t  direction,\n+                                  hb_codepoint_t  glyph,\n+                                  unsigned int    start_offset,\n+                                  unsigned int   *caret_count \/* IN\/OUT *\/,\n+                                  hb_position_t  *caret_array \/* OUT *\/)\n+{\n+  unsigned int result_caret_count = 0;\n+  unsigned int result = font->face->table.GDEF->table->get_lig_carets (font, direction, glyph, start_offset, &result_caret_count, caret_array);\n+  if (result)\n+  {\n+    if (caret_count) *caret_count = result_caret_count;\n+  }\n+  else\n+    result = font->face->table.lcar->get_lig_carets (font, direction, glyph, start_offset, caret_count, caret_array);\n+  return result;\n+}\n+\n+\n+\/*\n+ * GSUB\/GPOS\n+ *\/\n+\n+bool\n+OT::GSUB::is_blacklisted (hb_blob_t *blob HB_UNUSED,\n+                          hb_face_t *face) const\n+{\n+  \/* Mac OS X prefers morx over GSUB.  It also ships with various Indic fonts,\n+   * all by 'MUTF' foundry (Tamil MN, Tamil Sangam MN, etc.), that have broken\n+   * GSUB\/GPOS tables.  Some have GSUB with zero scripts, those are ignored by\n+   * our morx\/GSUB preference code.  But if GSUB has non-zero scripts, we tend\n+   * to prefer it over morx because we want to be consistent with other OpenType\n+   * shapers.\n+   *\n+   * To work around broken Indic Mac system fonts, we ignore GSUB table if\n+   * OS\/2 VendorId is 'MUTF' and font has morx table as well.\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1410\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1348\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1391\n+   *\/\n+  if (unlikely (face->table.OS2->achVendID == HB_TAG ('M','U','T','F') &&\n+                face->table.morx->has_data ()))\n+    return true;\n+\n+  return false;\n+}\n+\n+bool\n+OT::GPOS::is_blacklisted (hb_blob_t *blob HB_UNUSED,\n+                          hb_face_t *face HB_UNUSED) const\n+{\n+  return false;\n+}\n+\n+static const OT::GSUBGPOS&\n+get_gsubgpos_table (hb_face_t *face,\n+                    hb_tag_t   table_tag)\n+{\n+  switch (table_tag) {\n+    case HB_OT_TAG_GSUB: return *face->table.GSUB->table;\n+    case HB_OT_TAG_GPOS: return *face->table.GPOS->table;\n+    default:             return Null(OT::GSUBGPOS);\n+  }\n+}\n+\n+\n+unsigned int\n+hb_ot_layout_table_get_script_tags (hb_face_t    *face,\n+                                    hb_tag_t      table_tag,\n+                                    unsigned int  start_offset,\n+                                    unsigned int *script_count \/* IN\/OUT *\/,\n+                                    hb_tag_t     *script_tags  \/* OUT *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  return g.get_script_tags (start_offset, script_count, script_tags);\n+}\n+\n+#define HB_OT_TAG_LATIN_SCRIPT          HB_TAG ('l', 'a', 't', 'n')\n+\n+hb_bool_t\n+hb_ot_layout_table_find_script (hb_face_t    *face,\n+                                hb_tag_t      table_tag,\n+                                hb_tag_t      script_tag,\n+                                unsigned int *script_index)\n+{\n+  static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), \"\");\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  if (g.find_script_index (script_tag, script_index))\n+    return true;\n+\n+  \/* try finding 'DFLT' *\/\n+  if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index))\n+    return false;\n+\n+  \/* try with 'dflt'; MS site has had typos and many fonts use it now :(.\n+   * including many versions of DejaVu Sans Mono! *\/\n+  if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index))\n+    return false;\n+\n+  \/* try with 'latn'; some old fonts put their features there even though\n+     they're really trying to support Thai, for example :( *\/\n+  if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index))\n+    return false;\n+\n+  if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;\n+  return false;\n+}\n+\n+hb_bool_t\n+hb_ot_layout_table_choose_script (hb_face_t      *face,\n+                                  hb_tag_t        table_tag,\n+                                  const hb_tag_t *script_tags,\n+                                  unsigned int   *script_index,\n+                                  hb_tag_t       *chosen_script)\n+{\n+  const hb_tag_t *t;\n+  for (t = script_tags; *t; t++);\n+  return hb_ot_layout_table_select_script (face, table_tag, t - script_tags, script_tags, script_index, chosen_script);\n+}\n+\n+\/**\n+ * hb_ot_layout_table_select_script:\n+ *\n+ * Since: 2.0.0\n+ **\/\n+hb_bool_t\n+hb_ot_layout_table_select_script (hb_face_t      *face,\n+                                  hb_tag_t        table_tag,\n+                                  unsigned int    script_count,\n+                                  const hb_tag_t *script_tags,\n+                                  unsigned int   *script_index  \/* OUT *\/,\n+                                  hb_tag_t       *chosen_script \/* OUT *\/)\n+{\n+  static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_SCRIPT_INDEX), \"\");\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+  unsigned int i;\n+\n+  for (i = 0; i < script_count; i++)\n+  {\n+    if (g.find_script_index (script_tags[i], script_index))\n+    {\n+      if (chosen_script)\n+        *chosen_script = script_tags[i];\n+      return true;\n+    }\n+  }\n+\n+  \/* try finding 'DFLT' *\/\n+  if (g.find_script_index (HB_OT_TAG_DEFAULT_SCRIPT, script_index)) {\n+    if (chosen_script)\n+      *chosen_script = HB_OT_TAG_DEFAULT_SCRIPT;\n+    return false;\n+  }\n+\n+  \/* try with 'dflt'; MS site has had typos and many fonts use it now :( *\/\n+  if (g.find_script_index (HB_OT_TAG_DEFAULT_LANGUAGE, script_index)) {\n+    if (chosen_script)\n+      *chosen_script = HB_OT_TAG_DEFAULT_LANGUAGE;\n+    return false;\n+  }\n+\n+  \/* try with 'latn'; some old fonts put their features there even though\n+     they're really trying to support Thai, for example :( *\/\n+  if (g.find_script_index (HB_OT_TAG_LATIN_SCRIPT, script_index)) {\n+    if (chosen_script)\n+      *chosen_script = HB_OT_TAG_LATIN_SCRIPT;\n+    return false;\n+  }\n+\n+  if (script_index) *script_index = HB_OT_LAYOUT_NO_SCRIPT_INDEX;\n+  if (chosen_script)\n+    *chosen_script = HB_OT_LAYOUT_NO_SCRIPT_INDEX;\n+  return false;\n+}\n+\n+unsigned int\n+hb_ot_layout_table_get_feature_tags (hb_face_t    *face,\n+                                     hb_tag_t      table_tag,\n+                                     unsigned int  start_offset,\n+                                     unsigned int *feature_count \/* IN\/OUT *\/,\n+                                     hb_tag_t     *feature_tags  \/* OUT *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  return g.get_feature_tags (start_offset, feature_count, feature_tags);\n+}\n+\n+bool\n+hb_ot_layout_table_find_feature (hb_face_t    *face,\n+                                 hb_tag_t      table_tag,\n+                                 hb_tag_t      feature_tag,\n+                                 unsigned int *feature_index)\n+{\n+  static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), \"\");\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  unsigned int num_features = g.get_feature_count ();\n+  for (unsigned int i = 0; i < num_features; i++)\n+  {\n+    if (feature_tag == g.get_feature_tag (i)) {\n+      if (feature_index) *feature_index = i;\n+      return true;\n+    }\n+  }\n+\n+  if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;\n+  return false;\n+}\n+\n+\n+unsigned int\n+hb_ot_layout_script_get_language_tags (hb_face_t    *face,\n+                                       hb_tag_t      table_tag,\n+                                       unsigned int  script_index,\n+                                       unsigned int  start_offset,\n+                                       unsigned int *language_count \/* IN\/OUT *\/,\n+                                       hb_tag_t     *language_tags  \/* OUT *\/)\n+{\n+  const OT::Script &s = get_gsubgpos_table (face, table_tag).get_script (script_index);\n+\n+  return s.get_lang_sys_tags (start_offset, language_count, language_tags);\n+}\n+\n+hb_bool_t\n+hb_ot_layout_script_find_language (hb_face_t    *face,\n+                                   hb_tag_t      table_tag,\n+                                   unsigned int  script_index,\n+                                   hb_tag_t      language_tag,\n+                                   unsigned int *language_index)\n+{\n+  return hb_ot_layout_script_select_language (face,\n+                                              table_tag,\n+                                              script_index,\n+                                              1,\n+                                              &language_tag,\n+                                              language_index);\n+}\n+\n+\/**\n+ * hb_ot_layout_script_select_language:\n+ *\n+ * Since: 2.0.0\n+ **\/\n+hb_bool_t\n+hb_ot_layout_script_select_language (hb_face_t      *face,\n+                                     hb_tag_t        table_tag,\n+                                     unsigned int    script_index,\n+                                     unsigned int    language_count,\n+                                     const hb_tag_t *language_tags,\n+                                     unsigned int   *language_index \/* OUT *\/)\n+{\n+  static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX), \"\");\n+  const OT::Script &s = get_gsubgpos_table (face, table_tag).get_script (script_index);\n+  unsigned int i;\n+\n+  for (i = 0; i < language_count; i++)\n+  {\n+    if (s.find_lang_sys_index (language_tags[i], language_index))\n+      return true;\n+  }\n+\n+  \/* try finding 'dflt' *\/\n+  if (s.find_lang_sys_index (HB_OT_TAG_DEFAULT_LANGUAGE, language_index))\n+    return false;\n+\n+  if (language_index) *language_index = HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX;\n+  return false;\n+}\n+\n+hb_bool_t\n+hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,\n+                                                  hb_tag_t      table_tag,\n+                                                  unsigned int  script_index,\n+                                                  unsigned int  language_index,\n+                                                  unsigned int *feature_index)\n+{\n+  return hb_ot_layout_language_get_required_feature (face,\n+                                                     table_tag,\n+                                                     script_index,\n+                                                     language_index,\n+                                                     feature_index,\n+                                                     nullptr);\n+}\n+\n+\/**\n+ * hb_ot_layout_language_get_required_feature:\n+ *\n+ * Since: 0.9.30\n+ **\/\n+hb_bool_t\n+hb_ot_layout_language_get_required_feature (hb_face_t    *face,\n+                                            hb_tag_t      table_tag,\n+                                            unsigned int  script_index,\n+                                            unsigned int  language_index,\n+                                            unsigned int *feature_index,\n+                                            hb_tag_t     *feature_tag)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+  const OT::LangSys &l = g.get_script (script_index).get_lang_sys (language_index);\n+\n+  unsigned int index = l.get_required_feature_index ();\n+  if (feature_index) *feature_index = index;\n+  if (feature_tag) *feature_tag = g.get_feature_tag (index);\n+\n+  return l.has_required_feature ();\n+}\n+\n+unsigned int\n+hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,\n+                                           hb_tag_t      table_tag,\n+                                           unsigned int  script_index,\n+                                           unsigned int  language_index,\n+                                           unsigned int  start_offset,\n+                                           unsigned int *feature_count   \/* IN\/OUT *\/,\n+                                           unsigned int *feature_indexes \/* OUT *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+  const OT::LangSys &l = g.get_script (script_index).get_lang_sys (language_index);\n+\n+  return l.get_feature_indexes (start_offset, feature_count, feature_indexes);\n+}\n+\n+unsigned int\n+hb_ot_layout_language_get_feature_tags (hb_face_t    *face,\n+                                        hb_tag_t      table_tag,\n+                                        unsigned int  script_index,\n+                                        unsigned int  language_index,\n+                                        unsigned int  start_offset,\n+                                        unsigned int *feature_count \/* IN\/OUT *\/,\n+                                        hb_tag_t     *feature_tags  \/* OUT *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+  const OT::LangSys &l = g.get_script (script_index).get_lang_sys (language_index);\n+\n+  static_assert ((sizeof (unsigned int) == sizeof (hb_tag_t)), \"\");\n+  unsigned int ret = l.get_feature_indexes (start_offset, feature_count, (unsigned int *) feature_tags);\n+\n+  if (feature_tags) {\n+    unsigned int count = *feature_count;\n+    for (unsigned int i = 0; i < count; i++)\n+      feature_tags[i] = g.get_feature_tag ((unsigned int) feature_tags[i]);\n+  }\n+\n+  return ret;\n+}\n+\n+\n+hb_bool_t\n+hb_ot_layout_language_find_feature (hb_face_t    *face,\n+                                    hb_tag_t      table_tag,\n+                                    unsigned int  script_index,\n+                                    unsigned int  language_index,\n+                                    hb_tag_t      feature_tag,\n+                                    unsigned int *feature_index)\n+{\n+  static_assert ((OT::Index::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_FEATURE_INDEX), \"\");\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+  const OT::LangSys &l = g.get_script (script_index).get_lang_sys (language_index);\n+\n+  unsigned int num_features = l.get_feature_count ();\n+  for (unsigned int i = 0; i < num_features; i++) {\n+    unsigned int f_index = l.get_feature_index (i);\n+\n+    if (feature_tag == g.get_feature_tag (f_index)) {\n+      if (feature_index) *feature_index = f_index;\n+      return true;\n+    }\n+  }\n+\n+  if (feature_index) *feature_index = HB_OT_LAYOUT_NO_FEATURE_INDEX;\n+  return false;\n+}\n+\n+\/**\n+ * hb_ot_layout_feature_get_lookups:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+unsigned int\n+hb_ot_layout_feature_get_lookups (hb_face_t    *face,\n+                                  hb_tag_t      table_tag,\n+                                  unsigned int  feature_index,\n+                                  unsigned int  start_offset,\n+                                  unsigned int *lookup_count   \/* IN\/OUT *\/,\n+                                  unsigned int *lookup_indexes \/* OUT *\/)\n+{\n+  return hb_ot_layout_feature_with_variations_get_lookups (face,\n+                                                           table_tag,\n+                                                           feature_index,\n+                                                           HB_OT_LAYOUT_NO_VARIATIONS_INDEX,\n+                                                           start_offset,\n+                                                           lookup_count,\n+                                                           lookup_indexes);\n+}\n+\n+\/**\n+ * hb_ot_layout_table_get_lookup_count:\n+ *\n+ * Since: 0.9.22\n+ **\/\n+unsigned int\n+hb_ot_layout_table_get_lookup_count (hb_face_t    *face,\n+                                     hb_tag_t      table_tag)\n+{\n+  return get_gsubgpos_table (face, table_tag).get_lookup_count ();\n+}\n+\n+\n+struct hb_collect_features_context_t\n+{\n+  hb_collect_features_context_t (hb_face_t       *face,\n+                                 hb_tag_t         table_tag,\n+                                 hb_set_t        *feature_indexes_)\n+    : g (get_gsubgpos_table (face, table_tag)),\n+      feature_indexes (feature_indexes_),\n+      script_count(0),langsys_count(0) {}\n+\n+  bool visited (const OT::Script &s)\n+  {\n+    \/* We might have Null() object here.  Don't want to involve\n+     * that in the memoize.  So, detect empty objects and return. *\/\n+    if (unlikely (!s.has_default_lang_sys () &&\n+                  !s.get_lang_sys_count ()))\n+      return true;\n+\n+    if (script_count++ > HB_MAX_SCRIPTS)\n+      return true;\n+\n+    return visited (s, visited_script);\n+  }\n+  bool visited (const OT::LangSys &l)\n+  {\n+    \/* We might have Null() object here.  Don't want to involve\n+     * that in the memoize.  So, detect empty objects and return. *\/\n+    if (unlikely (!l.has_required_feature () &&\n+                  !l.get_feature_count ()))\n+      return true;\n+\n+    if (langsys_count++ > HB_MAX_LANGSYS)\n+      return true;\n+\n+    return visited (l, visited_langsys);\n+  }\n+\n+  private:\n+  template <typename T>\n+  bool visited (const T &p, hb_set_t &visited_set)\n+  {\n+    hb_codepoint_t delta = (hb_codepoint_t) ((uintptr_t) &p - (uintptr_t) &g);\n+     if (visited_set.has (delta))\n+      return true;\n+\n+    visited_set.add (delta);\n+    return false;\n+  }\n+\n+  public:\n+  const OT::GSUBGPOS &g;\n+  hb_set_t           *feature_indexes;\n+\n+  private:\n+  hb_set_t visited_script;\n+  hb_set_t visited_langsys;\n+  unsigned int script_count;\n+  unsigned int langsys_count;\n+};\n+\n+static void\n+langsys_collect_features (hb_collect_features_context_t *c,\n+                          const OT::LangSys  &l,\n+                          const hb_tag_t     *features)\n+{\n+  if (c->visited (l)) return;\n+\n+  if (!features)\n+  {\n+    \/* All features. *\/\n+    if (l.has_required_feature ())\n+      c->feature_indexes->add (l.get_required_feature_index ());\n+\n+    l.add_feature_indexes_to (c->feature_indexes);\n+  }\n+  else\n+  {\n+    \/* Ugh. Any faster way? *\/\n+    for (; *features; features++)\n+    {\n+      hb_tag_t feature_tag = *features;\n+      unsigned int num_features = l.get_feature_count ();\n+      for (unsigned int i = 0; i < num_features; i++)\n+      {\n+        unsigned int feature_index = l.get_feature_index (i);\n+\n+        if (feature_tag == c->g.get_feature_tag (feature_index))\n+        {\n+          c->feature_indexes->add (feature_index);\n+          break;\n+        }\n+      }\n+    }\n+  }\n+}\n+\n+static void\n+script_collect_features (hb_collect_features_context_t *c,\n+                         const OT::Script   &s,\n+                         const hb_tag_t *languages,\n+                         const hb_tag_t *features)\n+{\n+  if (c->visited (s)) return;\n+\n+  if (!languages)\n+  {\n+    \/* All languages. *\/\n+    if (s.has_default_lang_sys ())\n+      langsys_collect_features (c,\n+                                s.get_default_lang_sys (),\n+                                features);\n+\n+    unsigned int count = s.get_lang_sys_count ();\n+    for (unsigned int language_index = 0; language_index < count; language_index++)\n+      langsys_collect_features (c,\n+                                s.get_lang_sys (language_index),\n+                                features);\n+  }\n+  else\n+  {\n+    for (; *languages; languages++)\n+    {\n+      unsigned int language_index;\n+      if (s.find_lang_sys_index (*languages, &language_index))\n+        langsys_collect_features (c,\n+                                  s.get_lang_sys (language_index),\n+                                  features);\n+    }\n+  }\n+}\n+\n+\/**\n+ * hb_ot_layout_collect_features:\n+ *\n+ * Since: 1.8.5\n+ **\/\n+void\n+hb_ot_layout_collect_features (hb_face_t      *face,\n+                               hb_tag_t        table_tag,\n+                               const hb_tag_t *scripts,\n+                               const hb_tag_t *languages,\n+                               const hb_tag_t *features,\n+                               hb_set_t       *feature_indexes \/* OUT *\/)\n+{\n+  hb_collect_features_context_t c (face, table_tag, feature_indexes);\n+  if (!scripts)\n+  {\n+    \/* All scripts. *\/\n+    unsigned int count = c.g.get_script_count ();\n+    for (unsigned int script_index = 0; script_index < count; script_index++)\n+      script_collect_features (&c,\n+                               c.g.get_script (script_index),\n+                               languages,\n+                               features);\n+  }\n+  else\n+  {\n+    for (; *scripts; scripts++)\n+    {\n+      unsigned int script_index;\n+      if (c.g.find_script_index (*scripts, &script_index))\n+        script_collect_features (&c,\n+                                 c.g.get_script (script_index),\n+                                 languages,\n+                                 features);\n+    }\n+  }\n+}\n+\n+\/**\n+ * hb_ot_layout_collect_lookups:\n+ *\n+ * Since: 0.9.8\n+ **\/\n+void\n+hb_ot_layout_collect_lookups (hb_face_t      *face,\n+                              hb_tag_t        table_tag,\n+                              const hb_tag_t *scripts,\n+                              const hb_tag_t *languages,\n+                              const hb_tag_t *features,\n+                              hb_set_t       *lookup_indexes \/* OUT *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  hb_set_t feature_indexes;\n+  hb_ot_layout_collect_features (face, table_tag, scripts, languages, features, &feature_indexes);\n+\n+  for (hb_codepoint_t feature_index = HB_SET_VALUE_INVALID;\n+       hb_set_next (&feature_indexes, &feature_index);)\n+    g.get_feature (feature_index).add_lookup_indexes_to (lookup_indexes);\n+}\n+\n+\/**\n+ * hb_ot_layout_lookup_collect_glyphs:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,\n+                                    hb_tag_t      table_tag,\n+                                    unsigned int  lookup_index,\n+                                    hb_set_t     *glyphs_before, \/* OUT.  May be NULL *\/\n+                                    hb_set_t     *glyphs_input,  \/* OUT.  May be NULL *\/\n+                                    hb_set_t     *glyphs_after,  \/* OUT.  May be NULL *\/\n+                                    hb_set_t     *glyphs_output  \/* OUT.  May be NULL *\/)\n+{\n+  OT::hb_collect_glyphs_context_t c (face,\n+                                     glyphs_before,\n+                                     glyphs_input,\n+                                     glyphs_after,\n+                                     glyphs_output);\n+\n+  switch (table_tag)\n+  {\n+    case HB_OT_TAG_GSUB:\n+    {\n+      const OT::SubstLookup& l = face->table.GSUB->table->get_lookup (lookup_index);\n+      l.collect_glyphs (&c);\n+      return;\n+    }\n+    case HB_OT_TAG_GPOS:\n+    {\n+      const OT::PosLookup& l = face->table.GPOS->table->get_lookup (lookup_index);\n+      l.collect_glyphs (&c);\n+      return;\n+    }\n+  }\n+}\n+\n+\n+\/* Variations support *\/\n+\n+hb_bool_t\n+hb_ot_layout_table_find_feature_variations (hb_face_t    *face,\n+                                            hb_tag_t      table_tag,\n+                                            const int    *coords,\n+                                            unsigned int  num_coords,\n+                                            unsigned int *variations_index \/* out *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  return g.find_variations_index (coords, num_coords, variations_index);\n+}\n+\n+unsigned int\n+hb_ot_layout_feature_with_variations_get_lookups (hb_face_t    *face,\n+                                                  hb_tag_t      table_tag,\n+                                                  unsigned int  feature_index,\n+                                                  unsigned int  variations_index,\n+                                                  unsigned int  start_offset,\n+                                                  unsigned int *lookup_count \/* IN\/OUT *\/,\n+                                                  unsigned int *lookup_indexes \/* OUT *\/)\n+{\n+  static_assert ((OT::FeatureVariations::NOT_FOUND_INDEX == HB_OT_LAYOUT_NO_VARIATIONS_INDEX), \"\");\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  const OT::Feature &f = g.get_feature_variation (feature_index, variations_index);\n+\n+  return f.get_lookup_indexes (start_offset, lookup_count, lookup_indexes);\n+}\n+\n+\n+\/*\n+ * OT::GSUB\n+ *\/\n+\n+hb_bool_t\n+hb_ot_layout_has_substitution (hb_face_t *face)\n+{\n+  return face->table.GSUB->table->has_data ();\n+}\n+\n+\/**\n+ * hb_ot_layout_lookup_would_substitute:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_ot_layout_lookup_would_substitute (hb_face_t            *face,\n+                                      unsigned int          lookup_index,\n+                                      const hb_codepoint_t *glyphs,\n+                                      unsigned int          glyphs_length,\n+                                      hb_bool_t             zero_context)\n+{\n+  return hb_ot_layout_lookup_would_substitute_fast (face,\n+                                                    lookup_index,\n+                                                    glyphs, glyphs_length,\n+                                                    zero_context);\n+}\n+\n+bool\n+hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,\n+                                           unsigned int          lookup_index,\n+                                           const hb_codepoint_t *glyphs,\n+                                           unsigned int          glyphs_length,\n+                                           bool                  zero_context)\n+{\n+  if (unlikely (lookup_index >= face->table.GSUB->lookup_count)) return false;\n+  OT::hb_would_apply_context_t c (face, glyphs, glyphs_length, (bool) zero_context);\n+\n+  const OT::SubstLookup& l = face->table.GSUB->table->get_lookup (lookup_index);\n+\n+  return l.would_apply (&c, &face->table.GSUB->accels[lookup_index]);\n+}\n+\n+void\n+hb_ot_layout_substitute_start (hb_font_t    *font,\n+                               hb_buffer_t  *buffer)\n+{\n+_hb_ot_layout_set_glyph_props (font, buffer);\n+}\n+\n+void\n+hb_ot_layout_delete_glyphs_inplace (hb_buffer_t *buffer,\n+                                    bool (*filter) (const hb_glyph_info_t *info))\n+{\n+  \/* Merge clusters and delete filtered glyphs.\n+   * NOTE! We can't use out-buffer as we have positioning data. *\/\n+  unsigned int j = 0;\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  hb_glyph_position_t *pos = buffer->pos;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    if (filter (&info[i]))\n+    {\n+      \/* Merge clusters.\n+       * Same logic as buffer->delete_glyph(), but for in-place removal. *\/\n+\n+      unsigned int cluster = info[i].cluster;\n+      if (i + 1 < count && cluster == info[i + 1].cluster)\n+        continue; \/* Cluster survives; do nothing. *\/\n+\n+      if (j)\n+      {\n+        \/* Merge cluster backward. *\/\n+        if (cluster < info[j - 1].cluster)\n+        {\n+          unsigned int mask = info[i].mask;\n+          unsigned int old_cluster = info[j - 1].cluster;\n+          for (unsigned k = j; k && info[k - 1].cluster == old_cluster; k--)\n+            buffer->set_cluster (info[k - 1], cluster, mask);\n+        }\n+        continue;\n+      }\n+\n+      if (i + 1 < count)\n+        buffer->merge_clusters (i, i + 2); \/* Merge cluster forward. *\/\n+\n+      continue;\n+    }\n+\n+    if (j != i)\n+    {\n+      info[j] = info[i];\n+      pos[j] = pos[i];\n+    }\n+    j++;\n+  }\n+  buffer->len = j;\n+}\n+\n+\/**\n+ * hb_ot_layout_lookup_substitute_closure:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,\n+                                        unsigned int  lookup_index,\n+                                        hb_set_t     *glyphs)\n+{\n+  hb_map_t done_lookups;\n+  OT::hb_closure_context_t c (face, glyphs, &done_lookups);\n+\n+  const OT::SubstLookup& l = face->table.GSUB->table->get_lookup (lookup_index);\n+\n+  l.closure (&c, lookup_index);\n+}\n+\n+\/**\n+ * hb_ot_layout_lookups_substitute_closure:\n+ *\n+ * Compute the transitive closure of glyphs needed for all of the\n+ * provided lookups.\n+ *\n+ * Since: 1.8.1\n+ **\/\n+void\n+hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,\n+                                         const hb_set_t *lookups,\n+                                         hb_set_t       *glyphs)\n+{\n+  hb_map_t done_lookups;\n+  OT::hb_closure_context_t c (face, glyphs, &done_lookups);\n+  const OT::GSUB& gsub = *face->table.GSUB->table;\n+\n+  unsigned int iteration_count = 0;\n+  unsigned int glyphs_length;\n+  do\n+  {\n+    glyphs_length = glyphs->get_population ();\n+    if (lookups != nullptr)\n+    {\n+      for (hb_codepoint_t lookup_index = HB_SET_VALUE_INVALID; hb_set_next (lookups, &lookup_index);)\n+        gsub.get_lookup (lookup_index).closure (&c, lookup_index);\n+    }\n+    else\n+    {\n+      for (unsigned int i = 0; i < gsub.get_lookup_count (); i++)\n+        gsub.get_lookup (i).closure (&c, i);\n+    }\n+  } while (iteration_count++ <= HB_CLOSURE_MAX_STAGES &&\n+           glyphs_length != glyphs->get_population ());\n+}\n+\n+\/*\n+ * OT::GPOS\n+ *\/\n+\n+hb_bool_t\n+hb_ot_layout_has_positioning (hb_face_t *face)\n+{\n+  return face->table.GPOS->table->has_data ();\n+}\n+\n+void\n+hb_ot_layout_position_start (hb_font_t *font, hb_buffer_t *buffer)\n+{\n+  OT::GPOS::position_start (font, buffer);\n+}\n+\n+void\n+hb_ot_layout_position_finish_advances (hb_font_t *font, hb_buffer_t *buffer)\n+{\n+  OT::GPOS::position_finish_advances (font, buffer);\n+}\n+\n+void\n+hb_ot_layout_position_finish_offsets (hb_font_t *font, hb_buffer_t *buffer)\n+{\n+  OT::GPOS::position_finish_offsets (font, buffer);\n+}\n+\n+\/**\n+ * hb_ot_layout_get_size_params:\n+ *\n+ * Since: 0.9.10\n+ **\/\n+hb_bool_t\n+hb_ot_layout_get_size_params (hb_face_t       *face,\n+                              unsigned int    *design_size,       \/* OUT.  May be NULL *\/\n+                              unsigned int    *subfamily_id,      \/* OUT.  May be NULL *\/\n+                              hb_ot_name_id_t *subfamily_name_id, \/* OUT.  May be NULL *\/\n+                              unsigned int    *range_start,       \/* OUT.  May be NULL *\/\n+                              unsigned int    *range_end          \/* OUT.  May be NULL *\/)\n+{\n+  const OT::GPOS &gpos = *face->table.GPOS->table;\n+  const hb_tag_t tag = HB_TAG ('s','i','z','e');\n+\n+  unsigned int num_features = gpos.get_feature_count ();\n+  for (unsigned int i = 0; i < num_features; i++)\n+  {\n+    if (tag == gpos.get_feature_tag (i))\n+    {\n+      const OT::Feature &f = gpos.get_feature (i);\n+      const OT::FeatureParamsSize &params = f.get_feature_params ().get_size_params (tag);\n+\n+      if (params.designSize)\n+      {\n+        if (design_size) *design_size = params.designSize;\n+        if (subfamily_id) *subfamily_id = params.subfamilyID;\n+        if (subfamily_name_id) *subfamily_name_id = params.subfamilyNameID;\n+        if (range_start) *range_start = params.rangeStart;\n+        if (range_end) *range_end = params.rangeEnd;\n+\n+        return true;\n+      }\n+    }\n+  }\n+\n+  if (design_size) *design_size = 0;\n+  if (subfamily_id) *subfamily_id = 0;\n+  if (subfamily_name_id) *subfamily_name_id = HB_OT_NAME_ID_INVALID;\n+  if (range_start) *range_start = 0;\n+  if (range_end) *range_end = 0;\n+\n+  return false;\n+}\n+\n+\/**\n+ * hb_ot_layout_feature_get_name_ids:\n+ * @face: #hb_face_t to work upon\n+ * @table_tag: table tag to query, \"GSUB\" or \"GPOS\".\n+ * @feature_index: index of feature to query.\n+ * @label_id: (out) (allow-none): The ‘name’ table name ID that specifies a string\n+ *            for a user-interface label for this feature. (May be NULL.)\n+ * @tooltip_id: (out) (allow-none): The ‘name’ table name ID that specifies a string\n+ *              that an application can use for tooltip text for this\n+ *              feature. (May be NULL.)\n+ * @sample_id: (out) (allow-none): The ‘name’ table name ID that specifies sample text\n+ *             that illustrates the effect of this feature. (May be NULL.)\n+ * @num_named_parameters: (out) (allow-none):  Number of named parameters. (May be zero.)\n+ * @first_param_id: (out) (allow-none): The first ‘name’ table name ID used to specify\n+ *                  strings for user-interface labels for the feature\n+ *                  parameters. (Must be zero if numParameters is zero.)\n+ *\n+ * Fetches name indices from feature parameters for \"Stylistic Set\" ('ssXX') or\n+ * \"Character Variant\" ('cvXX') features.\n+ *\n+ * Return value: true if data found, false otherwise\n+ *\n+ * Since: 2.0.0\n+ **\/\n+hb_bool_t\n+hb_ot_layout_feature_get_name_ids (hb_face_t       *face,\n+                                   hb_tag_t         table_tag,\n+                                   unsigned int     feature_index,\n+                                   hb_ot_name_id_t *label_id,             \/* OUT.  May be NULL *\/\n+                                   hb_ot_name_id_t *tooltip_id,           \/* OUT.  May be NULL *\/\n+                                   hb_ot_name_id_t *sample_id,            \/* OUT.  May be NULL *\/\n+                                   unsigned int    *num_named_parameters, \/* OUT.  May be NULL *\/\n+                                   hb_ot_name_id_t *first_param_id        \/* OUT.  May be NULL *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  hb_tag_t feature_tag = g.get_feature_tag (feature_index);\n+  const OT::Feature &f = g.get_feature (feature_index);\n+\n+  const OT::FeatureParams &feature_params = f.get_feature_params ();\n+  if (&feature_params != &Null (OT::FeatureParams))\n+  {\n+    const OT::FeatureParamsStylisticSet& ss_params =\n+      feature_params.get_stylistic_set_params (feature_tag);\n+    if (&ss_params != &Null (OT::FeatureParamsStylisticSet)) \/* ssXX *\/\n+    {\n+      if (label_id) *label_id = ss_params.uiNameID;\n+      \/\/ ssXX features don't have the rest\n+      if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;\n+      if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;\n+      if (num_named_parameters) *num_named_parameters = 0;\n+      if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;\n+      return true;\n+    }\n+    const OT::FeatureParamsCharacterVariants& cv_params =\n+      feature_params.get_character_variants_params (feature_tag);\n+    if (&cv_params != &Null (OT::FeatureParamsCharacterVariants)) \/* cvXX *\/\n+    {\n+      if (label_id) *label_id = cv_params.featUILableNameID;\n+      if (tooltip_id) *tooltip_id = cv_params.featUITooltipTextNameID;\n+      if (sample_id) *sample_id = cv_params.sampleTextNameID;\n+      if (num_named_parameters) *num_named_parameters = cv_params.numNamedParameters;\n+      if (first_param_id) *first_param_id = cv_params.firstParamUILabelNameID;\n+      return true;\n+    }\n+  }\n+\n+  if (label_id) *label_id = HB_OT_NAME_ID_INVALID;\n+  if (tooltip_id) *tooltip_id = HB_OT_NAME_ID_INVALID;\n+  if (sample_id) *sample_id = HB_OT_NAME_ID_INVALID;\n+  if (num_named_parameters) *num_named_parameters = 0;\n+  if (first_param_id) *first_param_id = HB_OT_NAME_ID_INVALID;\n+  return false;\n+}\n+\n+\/**\n+ * hb_ot_layout_feature_get_characters:\n+ * @face: #hb_face_t to work upon\n+ * @table_tag: table tag to query, \"GSUB\" or \"GPOS\".\n+ * @feature_index: index of feature to query.\n+ * @start_offset: In case the resulting char_count was equal to its input value, there\n+ *                is a chance there were more characters on the tag so this API can be\n+ *                called with an offset till resulting char_count gets to a number\n+ *                lower than input buffer (or consider using just a bigger buffer for\n+ *                one shot copying).\n+ * @char_count: (inout) (allow-none): The count of characters for which this feature\n+ *              provides glyph variants. (May be zero.)\n+ * @characters: (out caller-allocates) (array length=char_count): A buffer pointer. The Unicode codepoints\n+ *              of the characters for which this feature provides glyph variants.\n+ *\n+ * Fetches characters listed by designer under feature parameters for \"Character\n+ * Variant\" (\"cvXX\") features.\n+ *\n+ * Return value: Number of total sample characters in the cvXX feature.\n+ *\n+ * Since: 2.0.0\n+ **\/\n+unsigned int\n+hb_ot_layout_feature_get_characters (hb_face_t      *face,\n+                                     hb_tag_t        table_tag,\n+                                     unsigned int    feature_index,\n+                                     unsigned int    start_offset,\n+                                     unsigned int   *char_count, \/* IN\/OUT.  May be NULL *\/\n+                                     hb_codepoint_t *characters  \/* OUT.     May be NULL *\/)\n+{\n+  const OT::GSUBGPOS &g = get_gsubgpos_table (face, table_tag);\n+\n+  hb_tag_t feature_tag = g.get_feature_tag (feature_index);\n+  const OT::Feature &f = g.get_feature (feature_index);\n+\n+  const OT::FeatureParams &feature_params = f.get_feature_params ();\n+\n+  const OT::FeatureParamsCharacterVariants& cv_params =\n+    feature_params.get_character_variants_params(feature_tag);\n+\n+  unsigned int len = 0;\n+  if (char_count && characters && start_offset < cv_params.characters.len)\n+  {\n+    len = MIN (cv_params.characters.len - start_offset, *char_count);\n+    for (unsigned int i = 0; i < len; ++i)\n+      characters[i] = cv_params.characters[start_offset + i];\n+  }\n+  if (char_count) *char_count = len;\n+  return cv_params.characters.len;\n+}\n+\n+\n+\/*\n+ * Parts of different types are implemented here such that they have direct\n+ * access to GSUB\/GPOS lookups.\n+ *\/\n+\n+\n+struct GSUBProxy\n+{\n+  static constexpr unsigned table_index = 0u;\n+  static constexpr bool inplace = false;\n+  typedef OT::SubstLookup Lookup;\n+\n+  GSUBProxy (hb_face_t *face) :\n+    table (*face->table.GSUB->table),\n+    accels (face->table.GSUB->accels) {}\n+\n+  const OT::GSUB &table;\n+  const OT::hb_ot_layout_lookup_accelerator_t *accels;\n+};\n+\n+struct GPOSProxy\n+{\n+  static constexpr unsigned table_index = 1u;\n+  static constexpr bool inplace = true;\n+  typedef OT::PosLookup Lookup;\n+\n+  GPOSProxy (hb_face_t *face) :\n+    table (*face->table.GPOS->table),\n+    accels (face->table.GPOS->accels) {}\n+\n+  const OT::GPOS &table;\n+  const OT::hb_ot_layout_lookup_accelerator_t *accels;\n+};\n+\n+\n+static inline bool\n+apply_forward (OT::hb_ot_apply_context_t *c,\n+               const OT::hb_ot_layout_lookup_accelerator_t &accel)\n+{\n+  bool ret = false;\n+  hb_buffer_t *buffer = c->buffer;\n+  while (buffer->idx < buffer->len && buffer->successful)\n+  {\n+    bool applied = false;\n+    if (accel.may_have (buffer->cur().codepoint) &&\n+        (buffer->cur().mask & c->lookup_mask) &&\n+        c->check_glyph_property (&buffer->cur(), c->lookup_props))\n+     {\n+       applied = accel.apply (c);\n+     }\n+\n+    if (applied)\n+      ret = true;\n+    else\n+      buffer->next_glyph ();\n+  }\n+  return ret;\n+}\n+\n+static inline bool\n+apply_backward (OT::hb_ot_apply_context_t *c,\n+               const OT::hb_ot_layout_lookup_accelerator_t &accel)\n+{\n+  bool ret = false;\n+  hb_buffer_t *buffer = c->buffer;\n+  do\n+  {\n+    if (accel.may_have (buffer->cur().codepoint) &&\n+        (buffer->cur().mask & c->lookup_mask) &&\n+        c->check_glyph_property (&buffer->cur(), c->lookup_props))\n+     ret |= accel.apply (c);\n+\n+    \/* The reverse lookup doesn't \"advance\" cursor (for good reason). *\/\n+    buffer->idx--;\n+\n+  }\n+  while ((int) buffer->idx >= 0);\n+  return ret;\n+}\n+\n+template <typename Proxy>\n+static inline void\n+apply_string (OT::hb_ot_apply_context_t *c,\n+              const typename Proxy::Lookup &lookup,\n+              const OT::hb_ot_layout_lookup_accelerator_t &accel)\n+{\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  if (unlikely (!buffer->len || !c->lookup_mask))\n+    return;\n+\n+  c->set_lookup_props (lookup.get_props ());\n+\n+  if (likely (!lookup.is_reverse ()))\n+  {\n+    \/* in\/out forward substitution\/positioning *\/\n+    if (Proxy::table_index == 0u)\n+      buffer->clear_output ();\n+    buffer->idx = 0;\n+\n+    bool ret;\n+    ret = apply_forward (c, accel);\n+    if (ret)\n+    {\n+      if (!Proxy::inplace)\n+        buffer->swap_buffers ();\n+      else\n+        assert (!buffer->has_separate_output ());\n+    }\n+  }\n+  else\n+  {\n+    \/* in-place backward substitution\/positioning *\/\n+    if (Proxy::table_index == 0u)\n+      buffer->remove_output ();\n+    buffer->idx = buffer->len - 1;\n+\n+    apply_backward (c, accel);\n+  }\n+}\n+\n+template <typename Proxy>\n+inline void hb_ot_map_t::apply (const Proxy &proxy,\n+                                const hb_ot_shape_plan_t *plan,\n+                                hb_font_t *font,\n+                                hb_buffer_t *buffer) const\n+{\n+  const unsigned int table_index = proxy.table_index;\n+  unsigned int i = 0;\n+  OT::hb_ot_apply_context_t c (table_index, font, buffer);\n+  c.set_recurse_func (Proxy::Lookup::apply_recurse_func);\n+\n+  for (unsigned int stage_index = 0; stage_index < stages[table_index].length; stage_index++) {\n+    const stage_map_t *stage = &stages[table_index][stage_index];\n+    for (; i < stage->last_lookup; i++)\n+    {\n+      unsigned int lookup_index = lookups[table_index][i].index;\n+      if (!buffer->message (font, \"start lookup %d\", lookup_index)) continue;\n+      c.set_lookup_index (lookup_index);\n+      c.set_lookup_mask (lookups[table_index][i].mask);\n+      c.set_auto_zwj (lookups[table_index][i].auto_zwj);\n+      c.set_auto_zwnj (lookups[table_index][i].auto_zwnj);\n+      if (lookups[table_index][i].random)\n+      {\n+        c.set_random (true);\n+        buffer->unsafe_to_break_all ();\n+      }\n+      apply_string<Proxy> (&c,\n+                           proxy.table.get_lookup (lookup_index),\n+                           proxy.accels[lookup_index]);\n+      (void) buffer->message (font, \"end lookup %d\", lookup_index);\n+    }\n+\n+    if (stage->pause_func)\n+    {\n+      buffer->clear_output ();\n+      stage->pause_func (plan, font, buffer);\n+    }\n+  }\n+}\n+\n+void hb_ot_map_t::substitute (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const\n+{\n+  GSUBProxy proxy (font->face);\n+  apply (proxy, plan, font, buffer);\n+}\n+\n+void hb_ot_map_t::position (const hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const\n+{\n+  GPOSProxy proxy (font->face);\n+  apply (proxy, plan, font, buffer);\n+}\n+\n+void\n+hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,\n+                                const OT::SubstLookup &lookup,\n+                                const OT::hb_ot_layout_lookup_accelerator_t &accel)\n+{\n+  apply_string<GSUBProxy> (c, lookup, accel);\n+}\n+\n+#if 0\n+static const OT::BASE& _get_base (hb_face_t *face)\n+{\n+  return *face->table.BASE;\n+}\n+\n+hb_bool_t\n+hb_ot_layout_get_baseline (hb_font_t               *font,\n+                           hb_ot_layout_baseline_t  baseline,\n+                           hb_direction_t           direction,\n+                           hb_tag_t                 script_tag,\n+                           hb_tag_t                 language_tag,\n+                           hb_position_t           *coord        \/* OUT.  May be NULL. *\/)\n+{\n+  const OT::BASE &base = _get_base (font->face);\n+  bool result = base.get_baseline (font, baseline, direction, script_tag,\n+                                   language_tag, coord);\n+\n+  \/* TODO: Simulate https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/baselinetags#ideographic-em-box *\/\n+  if (!result && coord) *coord = 0;\n+\n+  if (coord) *coord = font->em_scale_dir (*coord, direction);\n+\n+  return result;\n+}\n+\n+\/* To be moved to public header *\/\n+\/*\n+ * BASE\n+ *\/\n+\n+\/**\n+ * hb_ot_layout_baseline_t:\n+ *\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/baselinetags\n+ *\n+ * Since: DONTREPLACEME\n+ *\/\n+typedef enum {\n+  HB_OT_LAYOUT_BASELINE_HANG = HB_TAG('h','a','n','g'),\n+  HB_OT_LAYOUT_BASELINE_ICFB = HB_TAG('i','c','f','b'),\n+  HB_OT_LAYOUT_BASELINE_ICFT = HB_TAG('i','c','f','t'),\n+  HB_OT_LAYOUT_BASELINE_IDEO = HB_TAG('i','d','e','o'),\n+  HB_OT_LAYOUT_BASELINE_IDTB = HB_TAG('i','d','t','b'),\n+  HB_OT_LAYOUT_BASELINE_MATH = HB_TAG('m','a','t','h'),\n+  HB_OT_LAYOUT_BASELINE_ROMN = HB_TAG('r','o','m','n')\n+} hb_ot_layout_baseline_t;\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_get_baseline (hb_font_t               *font,\n+                           hb_ot_layout_baseline_t  baseline,\n+                           hb_direction_t           direction,\n+                           hb_tag_t                 script_tag,\n+                           hb_tag_t                 language_tag,\n+                           hb_position_t           *coord        \/* OUT.  May be NULL. *\/);\n+\n+#endif\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout.cc","additions":1531,"deletions":0,"binary":false,"changes":1531,"status":"added"},{"patch":"@@ -0,0 +1,396 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_LAYOUT_H\n+#define HB_OT_LAYOUT_H\n+\n+#include \"hb.h\"\n+\n+#include \"hb-ot-name.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+#define HB_OT_TAG_BASE HB_TAG('B','A','S','E')\n+#define HB_OT_TAG_GDEF HB_TAG('G','D','E','F')\n+#define HB_OT_TAG_GSUB HB_TAG('G','S','U','B')\n+#define HB_OT_TAG_GPOS HB_TAG('G','P','O','S')\n+#define HB_OT_TAG_JSTF HB_TAG('J','S','T','F')\n+\n+\n+\/*\n+ * Script & Language tags.\n+ *\/\n+\n+#define HB_OT_TAG_DEFAULT_SCRIPT        HB_TAG ('D', 'F', 'L', 'T')\n+#define HB_OT_TAG_DEFAULT_LANGUAGE      HB_TAG ('d', 'f', 'l', 't')\n+\n+\/**\n+ * HB_OT_MAX_TAGS_PER_SCRIPT:\n+ *\n+ * Since: 2.0.0\n+ **\/\n+#define HB_OT_MAX_TAGS_PER_SCRIPT       3u\n+\/**\n+ * HB_OT_MAX_TAGS_PER_LANGUAGE:\n+ *\n+ * Since: 2.0.0\n+ **\/\n+#define HB_OT_MAX_TAGS_PER_LANGUAGE     3u\n+\n+HB_EXTERN void\n+hb_ot_tags_from_script_and_language (hb_script_t   script,\n+                                     hb_language_t language,\n+                                     unsigned int *script_count \/* IN\/OUT *\/,\n+                                     hb_tag_t     *script_tags \/* OUT *\/,\n+                                     unsigned int *language_count \/* IN\/OUT *\/,\n+                                     hb_tag_t     *language_tags \/* OUT *\/);\n+\n+HB_EXTERN hb_script_t\n+hb_ot_tag_to_script (hb_tag_t tag);\n+\n+HB_EXTERN hb_language_t\n+hb_ot_tag_to_language (hb_tag_t tag);\n+\n+HB_EXTERN void\n+hb_ot_tags_to_script_and_language (hb_tag_t       script_tag,\n+                                   hb_tag_t       language_tag,\n+                                   hb_script_t   *script \/* OUT *\/,\n+                                   hb_language_t *language \/* OUT *\/);\n+\n+\n+\/*\n+ * GDEF\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_has_glyph_classes (hb_face_t *face);\n+\n+typedef enum {\n+  HB_OT_LAYOUT_GLYPH_CLASS_UNCLASSIFIED = 0,\n+  HB_OT_LAYOUT_GLYPH_CLASS_BASE_GLYPH   = 1,\n+  HB_OT_LAYOUT_GLYPH_CLASS_LIGATURE     = 2,\n+  HB_OT_LAYOUT_GLYPH_CLASS_MARK         = 3,\n+  HB_OT_LAYOUT_GLYPH_CLASS_COMPONENT    = 4\n+} hb_ot_layout_glyph_class_t;\n+\n+HB_EXTERN hb_ot_layout_glyph_class_t\n+hb_ot_layout_get_glyph_class (hb_face_t      *face,\n+                              hb_codepoint_t  glyph);\n+\n+HB_EXTERN void\n+hb_ot_layout_get_glyphs_in_class (hb_face_t                  *face,\n+                                  hb_ot_layout_glyph_class_t  klass,\n+                                  hb_set_t                   *glyphs \/* OUT *\/);\n+\n+\n+\/* Not that useful.  Provides list of attach points for a glyph that a\n+ * client may want to cache *\/\n+HB_EXTERN unsigned int\n+hb_ot_layout_get_attach_points (hb_face_t      *face,\n+                                hb_codepoint_t  glyph,\n+                                unsigned int    start_offset,\n+                                unsigned int   *point_count \/* IN\/OUT *\/,\n+                                unsigned int   *point_array \/* OUT *\/);\n+\n+\/* Ligature caret positions *\/\n+HB_EXTERN unsigned int\n+hb_ot_layout_get_ligature_carets (hb_font_t      *font,\n+                                  hb_direction_t  direction,\n+                                  hb_codepoint_t  glyph,\n+                                  unsigned int    start_offset,\n+                                  unsigned int   *caret_count \/* IN\/OUT *\/,\n+                                  hb_position_t  *caret_array \/* OUT *\/);\n+\n+\n+\/*\n+ * GSUB\/GPOS feature query and enumeration interface\n+ *\/\n+\n+#define HB_OT_LAYOUT_NO_SCRIPT_INDEX            0xFFFFu\n+#define HB_OT_LAYOUT_NO_FEATURE_INDEX           0xFFFFu\n+#define HB_OT_LAYOUT_DEFAULT_LANGUAGE_INDEX     0xFFFFu\n+#define HB_OT_LAYOUT_NO_VARIATIONS_INDEX        0xFFFFFFFFu\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_table_get_script_tags (hb_face_t    *face,\n+                                    hb_tag_t      table_tag,\n+                                    unsigned int  start_offset,\n+                                    unsigned int *script_count \/* IN\/OUT *\/,\n+                                    hb_tag_t     *script_tags \/* OUT *\/);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_table_find_script (hb_face_t    *face,\n+                                hb_tag_t      table_tag,\n+                                hb_tag_t      script_tag,\n+                                unsigned int *script_index);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_table_select_script (hb_face_t      *face,\n+                                  hb_tag_t        table_tag,\n+                                  unsigned int    script_count,\n+                                  const hb_tag_t *script_tags,\n+                                  unsigned int   *script_index \/* OUT *\/,\n+                                  hb_tag_t       *chosen_script \/* OUT *\/);\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_table_get_feature_tags (hb_face_t    *face,\n+                                     hb_tag_t      table_tag,\n+                                     unsigned int  start_offset,\n+                                     unsigned int *feature_count \/* IN\/OUT *\/,\n+                                     hb_tag_t     *feature_tags \/* OUT *\/);\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_script_get_language_tags (hb_face_t    *face,\n+                                       hb_tag_t      table_tag,\n+                                       unsigned int  script_index,\n+                                       unsigned int  start_offset,\n+                                       unsigned int *language_count \/* IN\/OUT *\/,\n+                                       hb_tag_t     *language_tags \/* OUT *\/);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_script_select_language (hb_face_t      *face,\n+                                     hb_tag_t        table_tag,\n+                                     unsigned int    script_index,\n+                                     unsigned int    language_count,\n+                                     const hb_tag_t *language_tags,\n+                                     unsigned int   *language_index \/* OUT *\/);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_language_get_required_feature_index (hb_face_t    *face,\n+                                                  hb_tag_t      table_tag,\n+                                                  unsigned int  script_index,\n+                                                  unsigned int  language_index,\n+                                                  unsigned int *feature_index);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_language_get_required_feature (hb_face_t    *face,\n+                                            hb_tag_t      table_tag,\n+                                            unsigned int  script_index,\n+                                            unsigned int  language_index,\n+                                            unsigned int *feature_index,\n+                                            hb_tag_t     *feature_tag);\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_language_get_feature_indexes (hb_face_t    *face,\n+                                           hb_tag_t      table_tag,\n+                                           unsigned int  script_index,\n+                                           unsigned int  language_index,\n+                                           unsigned int  start_offset,\n+                                           unsigned int *feature_count \/* IN\/OUT *\/,\n+                                           unsigned int *feature_indexes \/* OUT *\/);\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_language_get_feature_tags (hb_face_t    *face,\n+                                        hb_tag_t      table_tag,\n+                                        unsigned int  script_index,\n+                                        unsigned int  language_index,\n+                                        unsigned int  start_offset,\n+                                        unsigned int *feature_count \/* IN\/OUT *\/,\n+                                        hb_tag_t     *feature_tags \/* OUT *\/);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_language_find_feature (hb_face_t    *face,\n+                                    hb_tag_t      table_tag,\n+                                    unsigned int  script_index,\n+                                    unsigned int  language_index,\n+                                    hb_tag_t      feature_tag,\n+                                    unsigned int *feature_index);\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_feature_get_lookups (hb_face_t    *face,\n+                                  hb_tag_t      table_tag,\n+                                  unsigned int  feature_index,\n+                                  unsigned int  start_offset,\n+                                  unsigned int *lookup_count \/* IN\/OUT *\/,\n+                                  unsigned int *lookup_indexes \/* OUT *\/);\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_table_get_lookup_count (hb_face_t    *face,\n+                                     hb_tag_t      table_tag);\n+\n+HB_EXTERN void\n+hb_ot_layout_collect_features (hb_face_t      *face,\n+                               hb_tag_t        table_tag,\n+                               const hb_tag_t *scripts,\n+                               const hb_tag_t *languages,\n+                               const hb_tag_t *features,\n+                               hb_set_t       *feature_indexes \/* OUT *\/);\n+\n+HB_EXTERN void\n+hb_ot_layout_collect_lookups (hb_face_t      *face,\n+                              hb_tag_t        table_tag,\n+                              const hb_tag_t *scripts,\n+                              const hb_tag_t *languages,\n+                              const hb_tag_t *features,\n+                              hb_set_t       *lookup_indexes \/* OUT *\/);\n+\n+HB_EXTERN void\n+hb_ot_layout_lookup_collect_glyphs (hb_face_t    *face,\n+                                    hb_tag_t      table_tag,\n+                                    unsigned int  lookup_index,\n+                                    hb_set_t     *glyphs_before, \/* OUT.  May be NULL *\/\n+                                    hb_set_t     *glyphs_input,  \/* OUT.  May be NULL *\/\n+                                    hb_set_t     *glyphs_after,  \/* OUT.  May be NULL *\/\n+                                    hb_set_t     *glyphs_output  \/* OUT.  May be NULL *\/);\n+\n+#ifdef HB_NOT_IMPLEMENTED\n+typedef struct\n+{\n+  const hb_codepoint_t *before,\n+  unsigned int          before_length,\n+  const hb_codepoint_t *input,\n+  unsigned int          input_length,\n+  const hb_codepoint_t *after,\n+  unsigned int          after_length,\n+} hb_ot_layout_glyph_sequence_t;\n+\n+typedef hb_bool_t\n+(*hb_ot_layout_glyph_sequence_func_t) (hb_font_t    *font,\n+                                       hb_tag_t      table_tag,\n+                                       unsigned int  lookup_index,\n+                                       const hb_ot_layout_glyph_sequence_t *sequence,\n+                                       void         *user_data);\n+\n+HB_EXTERN void\n+Xhb_ot_layout_lookup_enumerate_sequences (hb_face_t    *face,\n+                                         hb_tag_t      table_tag,\n+                                         unsigned int  lookup_index,\n+                                         hb_ot_layout_glyph_sequence_func_t callback,\n+                                         void         *user_data);\n+#endif\n+\n+\/* Variations support *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_table_find_feature_variations (hb_face_t    *face,\n+                                            hb_tag_t      table_tag,\n+                                            const int    *coords,\n+                                            unsigned int  num_coords,\n+                                            unsigned int *variations_index \/* out *\/);\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_feature_with_variations_get_lookups (hb_face_t    *face,\n+                                                  hb_tag_t      table_tag,\n+                                                  unsigned int  feature_index,\n+                                                  unsigned int  variations_index,\n+                                                  unsigned int  start_offset,\n+                                                  unsigned int *lookup_count \/* IN\/OUT *\/,\n+                                                  unsigned int *lookup_indexes \/* OUT *\/);\n+\n+\n+\/*\n+ * GSUB\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_has_substitution (hb_face_t *face);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_lookup_would_substitute (hb_face_t            *face,\n+                                      unsigned int          lookup_index,\n+                                      const hb_codepoint_t *glyphs,\n+                                      unsigned int          glyphs_length,\n+                                      hb_bool_t             zero_context);\n+\n+HB_EXTERN void\n+hb_ot_layout_lookup_substitute_closure (hb_face_t    *face,\n+                                        unsigned int  lookup_index,\n+                                        hb_set_t     *glyphs\n+                                        \/*TODO , hb_bool_t  inclusive *\/);\n+\n+HB_EXTERN void\n+hb_ot_layout_lookups_substitute_closure (hb_face_t      *face,\n+                                         const hb_set_t *lookups,\n+                                         hb_set_t       *glyphs);\n+\n+\n+#ifdef HB_NOT_IMPLEMENTED\n+\/* Note: You better have GDEF when using this API, or marks won't do much. *\/\n+HB_EXTERN hb_bool_t\n+Xhb_ot_layout_lookup_substitute (hb_font_t            *font,\n+                                unsigned int          lookup_index,\n+                                const hb_ot_layout_glyph_sequence_t *sequence,\n+                                unsigned int          out_size,\n+                                hb_codepoint_t       *glyphs_out,   \/* OUT *\/\n+                                unsigned int         *clusters_out, \/* OUT *\/\n+                                unsigned int         *out_length    \/* OUT *\/);\n+#endif\n+\n+\n+\/*\n+ * GPOS\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_has_positioning (hb_face_t *face);\n+\n+#ifdef HB_NOT_IMPLEMENTED\n+\/* Note: You better have GDEF when using this API, or marks won't do much. *\/\n+HB_EXTERN hb_bool_t\n+Xhb_ot_layout_lookup_position (hb_font_t            *font,\n+                              unsigned int          lookup_index,\n+                              const hb_ot_layout_glyph_sequence_t *sequence,\n+                              hb_glyph_position_t  *positions \/* IN \/ OUT *\/);\n+#endif\n+\n+\/* Optical 'size' feature info.  Returns true if found.\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/features_pt#size *\/\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_get_size_params (hb_face_t       *face,\n+                              unsigned int    *design_size,       \/* OUT.  May be NULL *\/\n+                              unsigned int    *subfamily_id,      \/* OUT.  May be NULL *\/\n+                              hb_ot_name_id_t *subfamily_name_id, \/* OUT.  May be NULL *\/\n+                              unsigned int    *range_start,       \/* OUT.  May be NULL *\/\n+                              unsigned int    *range_end          \/* OUT.  May be NULL *\/);\n+\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_layout_feature_get_name_ids (hb_face_t       *face,\n+                                   hb_tag_t         table_tag,\n+                                   unsigned int     feature_index,\n+                                   hb_ot_name_id_t *label_id             \/* OUT.  May be NULL *\/,\n+                                   hb_ot_name_id_t *tooltip_id           \/* OUT.  May be NULL *\/,\n+                                   hb_ot_name_id_t *sample_id            \/* OUT.  May be NULL *\/,\n+                                   unsigned int    *num_named_parameters \/* OUT.  May be NULL *\/,\n+                                   hb_ot_name_id_t *first_param_id       \/* OUT.  May be NULL *\/);\n+\n+\n+HB_EXTERN unsigned int\n+hb_ot_layout_feature_get_characters (hb_face_t      *face,\n+                                     hb_tag_t        table_tag,\n+                                     unsigned int    feature_index,\n+                                     unsigned int    start_offset,\n+                                     unsigned int   *char_count    \/* IN\/OUT.  May be NULL *\/,\n+                                     hb_codepoint_t *characters    \/* OUT.     May be NULL *\/);\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_LAYOUT_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout.h","additions":396,"deletions":0,"binary":false,"changes":396,"status":"added"},{"patch":"@@ -0,0 +1,612 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_LAYOUT_HH\n+#define HB_OT_LAYOUT_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-font.hh\"\n+#include \"hb-buffer.hh\"\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-shape.hh\"\n+#include \"hb-set-digest.hh\"\n+\n+\n+struct hb_ot_shape_plan_t;\n+\n+\n+\/*\n+ * kern\n+ *\/\n+\n+HB_INTERNAL bool\n+hb_ot_layout_has_kerning (hb_face_t *face);\n+\n+HB_INTERNAL bool\n+hb_ot_layout_has_machine_kerning (hb_face_t *face);\n+\n+HB_INTERNAL bool\n+hb_ot_layout_has_cross_kerning (hb_face_t *face);\n+\n+HB_INTERNAL void\n+hb_ot_layout_kern (const hb_ot_shape_plan_t *plan,\n+                   hb_font_t *font,\n+                   hb_buffer_t  *buffer);\n+\n+\n+\/* Private API corresponding to hb-ot-layout.h: *\/\n+\n+HB_INTERNAL bool\n+hb_ot_layout_table_find_feature (hb_face_t    *face,\n+                                 hb_tag_t      table_tag,\n+                                 hb_tag_t      feature_tag,\n+                                 unsigned int *feature_index);\n+\n+\n+\/*\n+ * GDEF\n+ *\/\n+\n+enum hb_ot_layout_glyph_props_flags_t\n+{\n+  \/* The following three match LookupFlags::Ignore* numbers. *\/\n+  HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH   = 0x02u,\n+  HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE     = 0x04u,\n+  HB_OT_LAYOUT_GLYPH_PROPS_MARK         = 0x08u,\n+\n+  \/* The following are used internally; not derived from GDEF. *\/\n+  HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED  = 0x10u,\n+  HB_OT_LAYOUT_GLYPH_PROPS_LIGATED      = 0x20u,\n+  HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED   = 0x40u,\n+\n+  HB_OT_LAYOUT_GLYPH_PROPS_PRESERVE     = HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED |\n+                                          HB_OT_LAYOUT_GLYPH_PROPS_LIGATED |\n+                                          HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED\n+};\n+HB_MARK_AS_FLAG_T (hb_ot_layout_glyph_props_flags_t);\n+\n+\n+\/*\n+ * GSUB\/GPOS\n+ *\/\n+\n+HB_INTERNAL bool\n+hb_ot_layout_lookup_would_substitute_fast (hb_face_t            *face,\n+                                           unsigned int          lookup_index,\n+                                           const hb_codepoint_t *glyphs,\n+                                           unsigned int          glyphs_length,\n+                                           bool                  zero_context);\n+\n+\n+\/* Should be called before all the substitute_lookup's are done. *\/\n+HB_INTERNAL void\n+hb_ot_layout_substitute_start (hb_font_t    *font,\n+                               hb_buffer_t  *buffer);\n+\n+HB_INTERNAL void\n+hb_ot_layout_delete_glyphs_inplace (hb_buffer_t *buffer,\n+                                    bool (*filter) (const hb_glyph_info_t *info));\n+\n+namespace OT {\n+  struct hb_ot_apply_context_t;\n+  struct SubstLookup;\n+  struct hb_ot_layout_lookup_accelerator_t;\n+}\n+\n+HB_INTERNAL void\n+hb_ot_layout_substitute_lookup (OT::hb_ot_apply_context_t *c,\n+                                const OT::SubstLookup &lookup,\n+                                const OT::hb_ot_layout_lookup_accelerator_t &accel);\n+\n+\n+\/* Should be called before all the position_lookup's are done. *\/\n+HB_INTERNAL void\n+hb_ot_layout_position_start (hb_font_t    *font,\n+                             hb_buffer_t  *buffer);\n+\n+\/* Should be called after all the position_lookup's are done, to fini advances. *\/\n+HB_INTERNAL void\n+hb_ot_layout_position_finish_advances (hb_font_t    *font,\n+                                       hb_buffer_t  *buffer);\n+\n+\/* Should be called after hb_ot_layout_position_finish_advances, to fini offsets. *\/\n+HB_INTERNAL void\n+hb_ot_layout_position_finish_offsets (hb_font_t    *font,\n+                                      hb_buffer_t  *buffer);\n+\n+\n+\/*\n+ * Buffer var routines.\n+ *\/\n+\n+\/* buffer var allocations, used during the entire shaping process *\/\n+#define unicode_props()         var2.u16[0]\n+\n+\/* buffer var allocations, used during the GSUB\/GPOS processing *\/\n+#define glyph_props()           var1.u16[0] \/* GDEF glyph properties *\/\n+#define lig_props()             var1.u8[2] \/* GSUB\/GPOS ligature tracking *\/\n+#define syllable()              var1.u8[3] \/* GSUB\/GPOS shaping boundaries *\/\n+\n+\n+\/* Loop over syllables. Based on foreach_cluster(). *\/\n+#define foreach_syllable(buffer, start, end) \\\n+  for (unsigned int \\\n+       _count = buffer->len, \\\n+       start = 0, end = _count ? _hb_next_syllable (buffer, 0) : 0; \\\n+       start < _count; \\\n+       start = end, end = _hb_next_syllable (buffer, start))\n+\n+static inline unsigned int\n+_hb_next_syllable (hb_buffer_t *buffer, unsigned int start)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+\n+  unsigned int syllable = info[start].syllable();\n+  while (++start < count && syllable == info[start].syllable())\n+    ;\n+\n+  return start;\n+}\n+\n+\n+\/* unicode_props *\/\n+\n+\/* Design:\n+ * unicode_props() is a two-byte number.  The low byte includes:\n+ * - General_Category: 5 bits.\n+ * - A bit each for:\n+ *   * Is it Default_Ignorable(); we have a modified Default_Ignorable().\n+ *   * Whether it's one of the three Mongolian Free Variation Selectors,\n+ *     CGJ, or other characters that are hidden but should not be ignored\n+ *     like most other Default_Ignorable()s do during matching.\n+ *   * Whether it's a grapheme continuation.\n+ *\n+ * The high-byte has different meanings, switched by the Gen-Cat:\n+ * - For Mn,Mc,Me: the modified Combining_Class.\n+ * - For Cf: whether it's ZWJ, ZWNJ, or something else.\n+ * - For Ws: index of which space character this is, if space fallback\n+ *   is needed, ie. we don't set this by default, only if asked to.\n+ *\/\n+\n+enum hb_unicode_props_flags_t {\n+  UPROPS_MASK_GEN_CAT   = 0x001Fu,\n+  UPROPS_MASK_IGNORABLE = 0x0020u,\n+  UPROPS_MASK_HIDDEN    = 0x0040u, \/* MONGOLIAN FREE VARIATION SELECTOR 1..3, or TAG characters *\/\n+  UPROPS_MASK_CONTINUATION=0x0080u,\n+\n+  \/* If GEN_CAT=FORMAT, top byte masks: *\/\n+  UPROPS_MASK_Cf_ZWJ    = 0x0100u,\n+  UPROPS_MASK_Cf_ZWNJ   = 0x0200u\n+};\n+HB_MARK_AS_FLAG_T (hb_unicode_props_flags_t);\n+\n+static inline void\n+_hb_glyph_info_set_unicode_props (hb_glyph_info_t *info, hb_buffer_t *buffer)\n+{\n+  hb_unicode_funcs_t *unicode = buffer->unicode;\n+  unsigned int u = info->codepoint;\n+  unsigned int gen_cat = (unsigned int) unicode->general_category (u);\n+  unsigned int props = gen_cat;\n+\n+  if (u >= 0x80)\n+  {\n+    buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII;\n+\n+    if (unlikely (unicode->is_default_ignorable (u)))\n+    {\n+      buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES;\n+      props |=  UPROPS_MASK_IGNORABLE;\n+      if (u == 0x200Cu) props |= UPROPS_MASK_Cf_ZWNJ;\n+      else if (u == 0x200Du) props |= UPROPS_MASK_Cf_ZWJ;\n+      \/* Mongolian Free Variation Selectors need to be remembered\n+       * because although we need to hide them like default-ignorables,\n+       * they need to non-ignorable during shaping.  This is similar to\n+       * what we do for joiners in Indic-like shapers, but since the\n+       * FVSes are GC=Mn, we have use a separate bit to remember them.\n+       * Fixes:\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/234 *\/\n+      else if (unlikely (hb_in_range (u, 0x180Bu, 0x180Du))) props |= UPROPS_MASK_HIDDEN;\n+      \/* TAG characters need similar treatment. Fixes:\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/463 *\/\n+      else if (unlikely (hb_in_range (u, 0xE0020u, 0xE007Fu))) props |= UPROPS_MASK_HIDDEN;\n+      \/* COMBINING GRAPHEME JOINER should not be skipped; at least some times.\n+       * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/554 *\/\n+      else if (unlikely (u == 0x034Fu))\n+      {\n+        buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_CGJ;\n+        props |= UPROPS_MASK_HIDDEN;\n+      }\n+    }\n+\n+    if (unlikely (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (gen_cat)))\n+    {\n+      props |= UPROPS_MASK_CONTINUATION;\n+      props |= unicode->modified_combining_class (u)<<8;\n+    }\n+  }\n+\n+  info->unicode_props() = props;\n+}\n+\n+static inline void\n+_hb_glyph_info_set_general_category (hb_glyph_info_t *info,\n+                                     hb_unicode_general_category_t gen_cat)\n+{\n+  \/* Clears top-byte. *\/\n+  info->unicode_props() = (unsigned int) gen_cat | (info->unicode_props() & (0xFF & ~UPROPS_MASK_GEN_CAT));\n+}\n+\n+static inline hb_unicode_general_category_t\n+_hb_glyph_info_get_general_category (const hb_glyph_info_t *info)\n+{\n+  return (hb_unicode_general_category_t) (info->unicode_props() & UPROPS_MASK_GEN_CAT);\n+}\n+\n+static inline bool\n+_hb_glyph_info_is_unicode_mark (const hb_glyph_info_t *info)\n+{\n+  return HB_UNICODE_GENERAL_CATEGORY_IS_MARK (info->unicode_props() & UPROPS_MASK_GEN_CAT);\n+}\n+static inline void\n+_hb_glyph_info_set_modified_combining_class (hb_glyph_info_t *info,\n+                                             unsigned int modified_class)\n+{\n+  if (unlikely (!_hb_glyph_info_is_unicode_mark (info)))\n+    return;\n+  info->unicode_props() = (modified_class<<8) | (info->unicode_props() & 0xFF);\n+}\n+static inline unsigned int\n+_hb_glyph_info_get_modified_combining_class (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_is_unicode_mark (info) ? info->unicode_props()>>8 : 0;\n+}\n+#define info_cc(info) (_hb_glyph_info_get_modified_combining_class (&(info)))\n+\n+static inline bool\n+_hb_glyph_info_is_unicode_space (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_get_general_category (info) ==\n+         HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR;\n+}\n+static inline void\n+_hb_glyph_info_set_unicode_space_fallback_type (hb_glyph_info_t *info, hb_unicode_funcs_t::space_t s)\n+{\n+  if (unlikely (!_hb_glyph_info_is_unicode_space (info)))\n+    return;\n+  info->unicode_props() = (((unsigned int) s)<<8) | (info->unicode_props() & 0xFF);\n+}\n+static inline hb_unicode_funcs_t::space_t\n+_hb_glyph_info_get_unicode_space_fallback_type (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_is_unicode_space (info) ?\n+         (hb_unicode_funcs_t::space_t) (info->unicode_props()>>8) :\n+         hb_unicode_funcs_t::NOT_SPACE;\n+}\n+\n+static inline bool _hb_glyph_info_ligated (const hb_glyph_info_t *info);\n+\n+static inline bool\n+_hb_glyph_info_is_default_ignorable (const hb_glyph_info_t *info)\n+{\n+  return (info->unicode_props() & UPROPS_MASK_IGNORABLE) &&\n+         !_hb_glyph_info_ligated (info);\n+}\n+static inline bool\n+_hb_glyph_info_is_default_ignorable_and_not_hidden (const hb_glyph_info_t *info)\n+{\n+  return ((info->unicode_props() & (UPROPS_MASK_IGNORABLE|UPROPS_MASK_HIDDEN))\n+          == UPROPS_MASK_IGNORABLE) &&\n+         !_hb_glyph_info_ligated (info);\n+}\n+static inline void\n+_hb_glyph_info_unhide (hb_glyph_info_t *info)\n+{\n+  info->unicode_props() &= ~ UPROPS_MASK_HIDDEN;\n+}\n+\n+static inline void\n+_hb_glyph_info_set_continuation (hb_glyph_info_t *info)\n+{\n+  info->unicode_props() |= UPROPS_MASK_CONTINUATION;\n+}\n+static inline void\n+_hb_glyph_info_reset_continuation (hb_glyph_info_t *info)\n+{\n+  info->unicode_props() &= ~ UPROPS_MASK_CONTINUATION;\n+}\n+static inline bool\n+_hb_glyph_info_is_continuation (const hb_glyph_info_t *info)\n+{\n+  return info->unicode_props() & UPROPS_MASK_CONTINUATION;\n+}\n+\/* Loop over grapheme. Based on foreach_cluster(). *\/\n+#define foreach_grapheme(buffer, start, end) \\\n+  for (unsigned int \\\n+       _count = buffer->len, \\\n+       start = 0, end = _count ? _hb_next_grapheme (buffer, 0) : 0; \\\n+       start < _count; \\\n+       start = end, end = _hb_next_grapheme (buffer, start))\n+\n+static inline unsigned int\n+_hb_next_grapheme (hb_buffer_t *buffer, unsigned int start)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+\n+  while (++start < count && _hb_glyph_info_is_continuation (&info[start]))\n+    ;\n+\n+  return start;\n+}\n+\n+static inline bool\n+_hb_glyph_info_is_unicode_format (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_get_general_category (info) ==\n+         HB_UNICODE_GENERAL_CATEGORY_FORMAT;\n+}\n+static inline bool\n+_hb_glyph_info_is_zwnj (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_is_unicode_format (info) && (info->unicode_props() & UPROPS_MASK_Cf_ZWNJ);\n+}\n+static inline bool\n+_hb_glyph_info_is_zwj (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_is_unicode_format (info) && (info->unicode_props() & UPROPS_MASK_Cf_ZWJ);\n+}\n+static inline bool\n+_hb_glyph_info_is_joiner (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_is_unicode_format (info) && (info->unicode_props() & (UPROPS_MASK_Cf_ZWNJ|UPROPS_MASK_Cf_ZWJ));\n+}\n+static inline void\n+_hb_glyph_info_flip_joiners (hb_glyph_info_t *info)\n+{\n+  if (!_hb_glyph_info_is_unicode_format (info))\n+    return;\n+  info->unicode_props() ^= UPROPS_MASK_Cf_ZWNJ | UPROPS_MASK_Cf_ZWJ;\n+}\n+\n+\/* lig_props: aka lig_id \/ lig_comp\n+ *\n+ * When a ligature is formed:\n+ *\n+ *   - The ligature glyph and any marks in between all the same newly allocated\n+ *     lig_id,\n+ *   - The ligature glyph will get lig_num_comps set to the number of components\n+ *   - The marks get lig_comp > 0, reflecting which component of the ligature\n+ *     they were applied to.\n+ *   - This is used in GPOS to attach marks to the right component of a ligature\n+ *     in MarkLigPos,\n+ *   - Note that when marks are ligated together, much of the above is skipped\n+ *     and the current lig_id reused.\n+ *\n+ * When a multiple-substitution is done:\n+ *\n+ *   - All resulting glyphs will have lig_id = 0,\n+ *   - The resulting glyphs will have lig_comp = 0, 1, 2, ... respectively.\n+ *   - This is used in GPOS to attach marks to the first component of a\n+ *     multiple substitution in MarkBasePos.\n+ *\n+ * The numbers are also used in GPOS to do mark-to-mark positioning only\n+ * to marks that belong to the same component of the same ligature.\n+ *\/\n+\n+static inline void\n+_hb_glyph_info_clear_lig_props (hb_glyph_info_t *info)\n+{\n+  info->lig_props() = 0;\n+}\n+\n+#define IS_LIG_BASE 0x10\n+\n+static inline void\n+_hb_glyph_info_set_lig_props_for_ligature (hb_glyph_info_t *info,\n+                                           unsigned int lig_id,\n+                                           unsigned int lig_num_comps)\n+{\n+  info->lig_props() = (lig_id << 5) | IS_LIG_BASE | (lig_num_comps & 0x0F);\n+}\n+\n+static inline void\n+_hb_glyph_info_set_lig_props_for_mark (hb_glyph_info_t *info,\n+                                       unsigned int lig_id,\n+                                       unsigned int lig_comp)\n+{\n+  info->lig_props() = (lig_id << 5) | (lig_comp & 0x0F);\n+}\n+\n+static inline void\n+_hb_glyph_info_set_lig_props_for_component (hb_glyph_info_t *info, unsigned int comp)\n+{\n+  _hb_glyph_info_set_lig_props_for_mark (info, 0, comp);\n+}\n+\n+static inline unsigned int\n+_hb_glyph_info_get_lig_id (const hb_glyph_info_t *info)\n+{\n+  return info->lig_props() >> 5;\n+}\n+\n+static inline bool\n+_hb_glyph_info_ligated_internal (const hb_glyph_info_t *info)\n+{\n+  return !!(info->lig_props() & IS_LIG_BASE);\n+}\n+\n+static inline unsigned int\n+_hb_glyph_info_get_lig_comp (const hb_glyph_info_t *info)\n+{\n+  if (_hb_glyph_info_ligated_internal (info))\n+    return 0;\n+  else\n+    return info->lig_props() & 0x0F;\n+}\n+\n+static inline unsigned int\n+_hb_glyph_info_get_lig_num_comps (const hb_glyph_info_t *info)\n+{\n+  if ((info->glyph_props() & HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE) &&\n+      _hb_glyph_info_ligated_internal (info))\n+    return info->lig_props() & 0x0F;\n+  else\n+    return 1;\n+}\n+\n+static inline uint8_t\n+_hb_allocate_lig_id (hb_buffer_t *buffer) {\n+  uint8_t lig_id = buffer->next_serial () & 0x07;\n+  if (unlikely (!lig_id))\n+    lig_id = _hb_allocate_lig_id (buffer); \/* in case of overflow *\/\n+  return lig_id;\n+}\n+\n+\/* glyph_props: *\/\n+\n+static inline void\n+_hb_glyph_info_set_glyph_props (hb_glyph_info_t *info, unsigned int props)\n+{\n+  info->glyph_props() = props;\n+}\n+\n+static inline unsigned int\n+_hb_glyph_info_get_glyph_props (const hb_glyph_info_t *info)\n+{\n+  return info->glyph_props();\n+}\n+\n+static inline bool\n+_hb_glyph_info_is_base_glyph (const hb_glyph_info_t *info)\n+{\n+  return !!(info->glyph_props() & HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH);\n+}\n+\n+static inline bool\n+_hb_glyph_info_is_ligature (const hb_glyph_info_t *info)\n+{\n+  return !!(info->glyph_props() & HB_OT_LAYOUT_GLYPH_PROPS_LIGATURE);\n+}\n+\n+static inline bool\n+_hb_glyph_info_is_mark (const hb_glyph_info_t *info)\n+{\n+  return !!(info->glyph_props() & HB_OT_LAYOUT_GLYPH_PROPS_MARK);\n+}\n+\n+static inline bool\n+_hb_glyph_info_substituted (const hb_glyph_info_t *info)\n+{\n+  return !!(info->glyph_props() & HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED);\n+}\n+\n+static inline bool\n+_hb_glyph_info_ligated (const hb_glyph_info_t *info)\n+{\n+  return !!(info->glyph_props() & HB_OT_LAYOUT_GLYPH_PROPS_LIGATED);\n+}\n+\n+static inline bool\n+_hb_glyph_info_multiplied (const hb_glyph_info_t *info)\n+{\n+  return !!(info->glyph_props() & HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED);\n+}\n+\n+static inline bool\n+_hb_glyph_info_ligated_and_didnt_multiply (const hb_glyph_info_t *info)\n+{\n+  return _hb_glyph_info_ligated (info) && !_hb_glyph_info_multiplied (info);\n+}\n+\n+static inline void\n+_hb_glyph_info_clear_ligated_and_multiplied (hb_glyph_info_t *info)\n+{\n+  info->glyph_props() &= ~(HB_OT_LAYOUT_GLYPH_PROPS_LIGATED |\n+                           HB_OT_LAYOUT_GLYPH_PROPS_MULTIPLIED);\n+}\n+\n+static inline void\n+_hb_glyph_info_clear_substituted (hb_glyph_info_t *info)\n+{\n+  info->glyph_props() &= ~(HB_OT_LAYOUT_GLYPH_PROPS_SUBSTITUTED);\n+}\n+\n+\n+\/* Allocation \/ deallocation. *\/\n+\n+static inline void\n+_hb_buffer_allocate_unicode_vars (hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, unicode_props);\n+}\n+\n+static inline void\n+_hb_buffer_deallocate_unicode_vars (hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, unicode_props);\n+}\n+\n+static inline void\n+_hb_buffer_assert_unicode_vars (hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_ASSERT_VAR (buffer, unicode_props);\n+}\n+\n+static inline void\n+_hb_buffer_allocate_gsubgpos_vars (hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, glyph_props);\n+  HB_BUFFER_ALLOCATE_VAR (buffer, lig_props);\n+  HB_BUFFER_ALLOCATE_VAR (buffer, syllable);\n+}\n+\n+static inline void\n+_hb_buffer_deallocate_gsubgpos_vars (hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, syllable);\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, lig_props);\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_props);\n+}\n+\n+static inline void\n+_hb_buffer_assert_gsubgpos_vars (hb_buffer_t *buffer)\n+{\n+  HB_BUFFER_ASSERT_VAR (buffer, glyph_props);\n+  HB_BUFFER_ASSERT_VAR (buffer, lig_props);\n+  HB_BUFFER_ASSERT_VAR (buffer, syllable);\n+}\n+\n+\/* Make sure no one directly touches our props... *\/\n+#undef unicode_props0\n+#undef unicode_props1\n+#undef lig_props\n+#undef glyph_props\n+\n+#endif \/* HB_OT_LAYOUT_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-layout.hh","additions":612,"deletions":0,"binary":false,"changes":612,"status":"added"},{"patch":"@@ -0,0 +1,334 @@\n+\/*\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2010,2011,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-map.hh\"\n+#include \"hb-ot-shape.hh\"\n+#include \"hb-ot-layout.hh\"\n+\n+\n+void hb_ot_map_t::collect_lookups (unsigned int table_index, hb_set_t *lookups_out) const\n+{\n+  for (unsigned int i = 0; i < lookups[table_index].length; i++)\n+    hb_set_add (lookups_out, lookups[table_index][i].index);\n+}\n+\n+\n+hb_ot_map_builder_t::hb_ot_map_builder_t (hb_face_t *face_,\n+                                          const hb_segment_properties_t *props_)\n+{\n+  memset (this, 0, sizeof (*this));\n+\n+  feature_infos.init ();\n+  for (unsigned int table_index = 0; table_index < 2; table_index++)\n+    stages[table_index].init ();\n+\n+  face = face_;\n+  props = *props_;\n+\n+\n+  \/* Fetch script\/language indices for GSUB\/GPOS.  We need these later to skip\n+   * features not available in either table and not waste precious bits for them. *\/\n+\n+  unsigned int script_count = HB_OT_MAX_TAGS_PER_SCRIPT;\n+  unsigned int language_count = HB_OT_MAX_TAGS_PER_LANGUAGE;\n+  hb_tag_t script_tags[HB_OT_MAX_TAGS_PER_SCRIPT];\n+  hb_tag_t language_tags[HB_OT_MAX_TAGS_PER_LANGUAGE];\n+\n+  hb_ot_tags_from_script_and_language (props.script, props.language, &script_count, script_tags, &language_count, language_tags);\n+\n+  for (unsigned int table_index = 0; table_index < 2; table_index++) {\n+    hb_tag_t table_tag = table_tags[table_index];\n+    found_script[table_index] = (bool) hb_ot_layout_table_select_script (face, table_tag, script_count, script_tags, &script_index[table_index], &chosen_script[table_index]);\n+    hb_ot_layout_script_select_language (face, table_tag, script_index[table_index], language_count, language_tags, &language_index[table_index]);\n+  }\n+}\n+\n+hb_ot_map_builder_t::~hb_ot_map_builder_t ()\n+{\n+  feature_infos.fini ();\n+  for (unsigned int table_index = 0; table_index < 2; table_index++)\n+    stages[table_index].fini ();\n+}\n+\n+void hb_ot_map_builder_t::add_feature (hb_tag_t tag,\n+                                       hb_ot_map_feature_flags_t flags,\n+                                       unsigned int value)\n+{\n+  if (unlikely (!tag)) return;\n+  feature_info_t *info = feature_infos.push();\n+  info->tag = tag;\n+  info->seq = feature_infos.length;\n+  info->max_value = value;\n+  info->flags = flags;\n+  info->default_value = (flags & F_GLOBAL) ? value : 0;\n+  info->stage[0] = current_stage[0];\n+  info->stage[1] = current_stage[1];\n+}\n+\n+void\n+hb_ot_map_builder_t::add_lookups (hb_ot_map_t  &m,\n+                                  unsigned int  table_index,\n+                                  unsigned int  feature_index,\n+                                  unsigned int  variations_index,\n+                                  hb_mask_t     mask,\n+                                  bool          auto_zwnj,\n+                                  bool          auto_zwj,\n+                                  bool          random)\n+{\n+  unsigned int lookup_indices[32];\n+  unsigned int offset, len;\n+  unsigned int table_lookup_count;\n+\n+  table_lookup_count = hb_ot_layout_table_get_lookup_count (face, table_tags[table_index]);\n+\n+  offset = 0;\n+  do {\n+    len = ARRAY_LENGTH (lookup_indices);\n+    hb_ot_layout_feature_with_variations_get_lookups (face,\n+                                                      table_tags[table_index],\n+                                                      feature_index,\n+                                                      variations_index,\n+                                                      offset, &len,\n+                                                      lookup_indices);\n+\n+    for (unsigned int i = 0; i < len; i++)\n+    {\n+      if (lookup_indices[i] >= table_lookup_count)\n+        continue;\n+      hb_ot_map_t::lookup_map_t *lookup = m.lookups[table_index].push ();\n+      lookup->mask = mask;\n+      lookup->index = lookup_indices[i];\n+      lookup->auto_zwnj = auto_zwnj;\n+      lookup->auto_zwj = auto_zwj;\n+      lookup->random = random;\n+    }\n+\n+    offset += len;\n+  } while (len == ARRAY_LENGTH (lookup_indices));\n+}\n+\n+\n+void hb_ot_map_builder_t::add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func)\n+{\n+  stage_info_t *s = stages[table_index].push ();\n+  s->index = current_stage[table_index];\n+  s->pause_func = pause_func;\n+\n+  current_stage[table_index]++;\n+}\n+\n+void\n+hb_ot_map_builder_t::compile (hb_ot_map_t                  &m,\n+                              const hb_ot_shape_plan_key_t &key)\n+{\n+  static_assert ((!(HB_GLYPH_FLAG_DEFINED & (HB_GLYPH_FLAG_DEFINED + 1))), \"\");\n+  unsigned int global_bit_mask = HB_GLYPH_FLAG_DEFINED + 1;\n+  unsigned int global_bit_shift = hb_popcount (HB_GLYPH_FLAG_DEFINED);\n+\n+  m.global_mask = global_bit_mask;\n+\n+  unsigned int required_feature_index[2];\n+  hb_tag_t required_feature_tag[2];\n+  \/* We default to applying required feature in stage 0.  If the required\n+   * feature has a tag that is known to the shaper, we apply required feature\n+   * in the stage for that tag.\n+   *\/\n+  unsigned int required_feature_stage[2] = {0, 0};\n+\n+  for (unsigned int table_index = 0; table_index < 2; table_index++)\n+  {\n+    m.chosen_script[table_index] = chosen_script[table_index];\n+    m.found_script[table_index] = found_script[table_index];\n+\n+    hb_ot_layout_language_get_required_feature (face,\n+                                                table_tags[table_index],\n+                                                script_index[table_index],\n+                                                language_index[table_index],\n+                                                &required_feature_index[table_index],\n+                                                &required_feature_tag[table_index]);\n+  }\n+\n+  \/* Sort features and merge duplicates *\/\n+  if (feature_infos.length)\n+  {\n+    feature_infos.qsort ();\n+    unsigned int j = 0;\n+    for (unsigned int i = 1; i < feature_infos.length; i++)\n+      if (feature_infos[i].tag != feature_infos[j].tag)\n+        feature_infos[++j] = feature_infos[i];\n+      else {\n+        if (feature_infos[i].flags & F_GLOBAL) {\n+          feature_infos[j].flags |= F_GLOBAL;\n+          feature_infos[j].max_value = feature_infos[i].max_value;\n+          feature_infos[j].default_value = feature_infos[i].default_value;\n+        } else {\n+          feature_infos[j].flags &= ~F_GLOBAL;\n+          feature_infos[j].max_value = MAX (feature_infos[j].max_value, feature_infos[i].max_value);\n+          \/* Inherit default_value from j *\/\n+        }\n+        feature_infos[j].flags |= (feature_infos[i].flags & F_HAS_FALLBACK);\n+        feature_infos[j].stage[0] = MIN (feature_infos[j].stage[0], feature_infos[i].stage[0]);\n+        feature_infos[j].stage[1] = MIN (feature_infos[j].stage[1], feature_infos[i].stage[1]);\n+      }\n+    feature_infos.shrink (j + 1);\n+  }\n+\n+\n+  \/* Allocate bits now *\/\n+  unsigned int next_bit = global_bit_shift + 1;\n+\n+  for (unsigned int i = 0; i < feature_infos.length; i++)\n+  {\n+    const feature_info_t *info = &feature_infos[i];\n+\n+    unsigned int bits_needed;\n+\n+    if ((info->flags & F_GLOBAL) && info->max_value == 1)\n+      \/* Uses the global bit *\/\n+      bits_needed = 0;\n+    else\n+      \/* Limit bits per feature. *\/\n+      bits_needed = MIN(HB_OT_MAP_MAX_BITS, hb_bit_storage (info->max_value));\n+\n+    if (!info->max_value || next_bit + bits_needed > 8 * sizeof (hb_mask_t))\n+      continue; \/* Feature disabled, or not enough bits. *\/\n+\n+\n+    hb_bool_t found = false;\n+    unsigned int feature_index[2];\n+    for (unsigned int table_index = 0; table_index < 2; table_index++)\n+    {\n+      if (required_feature_tag[table_index] == info->tag)\n+        required_feature_stage[table_index] = info->stage[table_index];\n+\n+      found |= hb_ot_layout_language_find_feature (face,\n+                                                   table_tags[table_index],\n+                                                   script_index[table_index],\n+                                                   language_index[table_index],\n+                                                   info->tag,\n+                                                   &feature_index[table_index]);\n+    }\n+    if (!found && (info->flags & F_GLOBAL_SEARCH))\n+    {\n+      for (unsigned int table_index = 0; table_index < 2; table_index++)\n+      {\n+        found |= hb_ot_layout_table_find_feature (face,\n+                                                  table_tags[table_index],\n+                                                  info->tag,\n+                                                  &feature_index[table_index]);\n+      }\n+    }\n+    if (!found && !(info->flags & F_HAS_FALLBACK))\n+      continue;\n+\n+\n+    hb_ot_map_t::feature_map_t *map = m.features.push ();\n+\n+    map->tag = info->tag;\n+    map->index[0] = feature_index[0];\n+    map->index[1] = feature_index[1];\n+    map->stage[0] = info->stage[0];\n+    map->stage[1] = info->stage[1];\n+    map->auto_zwnj = !(info->flags & F_MANUAL_ZWNJ);\n+    map->auto_zwj = !(info->flags & F_MANUAL_ZWJ);\n+    map->random = !!(info->flags & F_RANDOM);\n+    if ((info->flags & F_GLOBAL) && info->max_value == 1) {\n+      \/* Uses the global bit *\/\n+      map->shift = global_bit_shift;\n+      map->mask = global_bit_mask;\n+    } else {\n+      map->shift = next_bit;\n+      map->mask = (1u << (next_bit + bits_needed)) - (1u << next_bit);\n+      next_bit += bits_needed;\n+      m.global_mask |= (info->default_value << map->shift) & map->mask;\n+    }\n+    map->_1_mask = (1u << map->shift) & map->mask;\n+    map->needs_fallback = !found;\n+\n+  }\n+  feature_infos.shrink (0); \/* Done with these *\/\n+\n+\n+  add_gsub_pause (nullptr);\n+  add_gpos_pause (nullptr);\n+\n+  for (unsigned int table_index = 0; table_index < 2; table_index++)\n+  {\n+    \/* Collect lookup indices for features *\/\n+\n+    unsigned int stage_index = 0;\n+    unsigned int last_num_lookups = 0;\n+    for (unsigned stage = 0; stage < current_stage[table_index]; stage++)\n+    {\n+      if (required_feature_index[table_index] != HB_OT_LAYOUT_NO_FEATURE_INDEX &&\n+          required_feature_stage[table_index] == stage)\n+        add_lookups (m, table_index,\n+                     required_feature_index[table_index],\n+                     key.variations_index[table_index],\n+                     global_bit_mask);\n+\n+      for (unsigned i = 0; i < m.features.length; i++)\n+        if (m.features[i].stage[table_index] == stage)\n+          add_lookups (m, table_index,\n+                       m.features[i].index[table_index],\n+                       key.variations_index[table_index],\n+                       m.features[i].mask,\n+                       m.features[i].auto_zwnj,\n+                       m.features[i].auto_zwj,\n+                       m.features[i].random);\n+\n+      \/* Sort lookups and merge duplicates *\/\n+      if (last_num_lookups < m.lookups[table_index].length)\n+      {\n+        m.lookups[table_index].qsort (last_num_lookups, m.lookups[table_index].length);\n+\n+        unsigned int j = last_num_lookups;\n+        for (unsigned int i = j + 1; i < m.lookups[table_index].length; i++)\n+          if (m.lookups[table_index][i].index != m.lookups[table_index][j].index)\n+            m.lookups[table_index][++j] = m.lookups[table_index][i];\n+          else\n+          {\n+            m.lookups[table_index][j].mask |= m.lookups[table_index][i].mask;\n+            m.lookups[table_index][j].auto_zwnj &= m.lookups[table_index][i].auto_zwnj;\n+            m.lookups[table_index][j].auto_zwj &= m.lookups[table_index][i].auto_zwj;\n+          }\n+        m.lookups[table_index].shrink (j + 1);\n+      }\n+\n+      last_num_lookups = m.lookups[table_index].length;\n+\n+      if (stage_index < stages[table_index].length && stages[table_index][stage_index].index == stage) {\n+        hb_ot_map_t::stage_map_t *stage_map = m.stages[table_index].push ();\n+        stage_map->last_lookup = last_num_lookups;\n+        stage_map->pause_func = stages[table_index][stage_index].pause_func;\n+\n+        stage_index++;\n+      }\n+    }\n+  }\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-map.cc","additions":334,"deletions":0,"binary":false,"changes":334,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2010,2011,2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_MAP_HH\n+#define HB_OT_MAP_HH\n+\n+#include \"hb-buffer.hh\"\n+\n+\n+#define HB_OT_MAP_MAX_BITS 8u\n+#define HB_OT_MAP_MAX_VALUE ((1u << HB_OT_MAP_MAX_BITS) - 1u)\n+\n+struct hb_ot_shape_plan_t;\n+\n+static const hb_tag_t table_tags[2] = {HB_OT_TAG_GSUB, HB_OT_TAG_GPOS};\n+\n+struct hb_ot_map_t\n+{\n+  friend struct hb_ot_map_builder_t;\n+\n+  public:\n+\n+  struct feature_map_t {\n+    hb_tag_t tag; \/* should be first for our bsearch to work *\/\n+    unsigned int index[2]; \/* GSUB\/GPOS *\/\n+    unsigned int stage[2]; \/* GSUB\/GPOS *\/\n+    unsigned int shift;\n+    hb_mask_t mask;\n+    hb_mask_t _1_mask; \/* mask for value=1, for quick access *\/\n+    unsigned int needs_fallback : 1;\n+    unsigned int auto_zwnj : 1;\n+    unsigned int auto_zwj : 1;\n+    unsigned int random : 1;\n+\n+    int cmp (const hb_tag_t tag_) const\n+    { return tag_ < tag ? -1 : tag_ > tag ? 1 : 0; }\n+  };\n+\n+  struct lookup_map_t {\n+    unsigned short index;\n+    unsigned short auto_zwnj : 1;\n+    unsigned short auto_zwj : 1;\n+    unsigned short random : 1;\n+    hb_mask_t mask;\n+\n+    static int cmp (const void *pa, const void *pb)\n+    {\n+      const lookup_map_t *a = (const lookup_map_t *) pa;\n+      const lookup_map_t *b = (const lookup_map_t *) pb;\n+      return a->index < b->index ? -1 : a->index > b->index ? 1 : 0;\n+    }\n+  };\n+\n+  typedef void (*pause_func_t) (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer);\n+\n+  struct stage_map_t {\n+    unsigned int last_lookup; \/* Cumulative *\/\n+    pause_func_t pause_func;\n+  };\n+\n+  void init ()\n+  {\n+    memset (this, 0, sizeof (*this));\n+\n+    features.init ();\n+    for (unsigned int table_index = 0; table_index < 2; table_index++)\n+    {\n+      lookups[table_index].init ();\n+      stages[table_index].init ();\n+    }\n+  }\n+  void fini ()\n+  {\n+    features.fini ();\n+    for (unsigned int table_index = 0; table_index < 2; table_index++)\n+    {\n+      lookups[table_index].fini ();\n+      stages[table_index].fini ();\n+    }\n+  }\n+\n+  hb_mask_t get_global_mask () const { return global_mask; }\n+\n+  hb_mask_t get_mask (hb_tag_t feature_tag, unsigned int *shift = nullptr) const\n+  {\n+    const feature_map_t *map = features.bsearch (feature_tag);\n+    if (shift) *shift = map ? map->shift : 0;\n+    return map ? map->mask : 0;\n+  }\n+\n+  bool needs_fallback (hb_tag_t feature_tag) const\n+  {\n+    const feature_map_t *map = features.bsearch (feature_tag);\n+    return map ? map->needs_fallback : false;\n+  }\n+\n+  hb_mask_t get_1_mask (hb_tag_t feature_tag) const\n+  {\n+    const feature_map_t *map = features.bsearch (feature_tag);\n+    return map ? map->_1_mask : 0;\n+  }\n+\n+  unsigned int get_feature_index (unsigned int table_index, hb_tag_t feature_tag) const\n+  {\n+    const feature_map_t *map = features.bsearch (feature_tag);\n+    return map ? map->index[table_index] : HB_OT_LAYOUT_NO_FEATURE_INDEX;\n+  }\n+\n+  unsigned int get_feature_stage (unsigned int table_index, hb_tag_t feature_tag) const\n+  {\n+    const feature_map_t *map = features.bsearch (feature_tag);\n+    return map ? map->stage[table_index] : (unsigned int) -1;\n+  }\n+\n+  void get_stage_lookups (unsigned int table_index, unsigned int stage,\n+                          const struct lookup_map_t **plookups, unsigned int *lookup_count) const\n+  {\n+    if (unlikely (stage == (unsigned int) -1)) {\n+      *plookups = nullptr;\n+      *lookup_count = 0;\n+      return;\n+    }\n+    assert (stage <= stages[table_index].length);\n+    unsigned int start = stage ? stages[table_index][stage - 1].last_lookup : 0;\n+    unsigned int end   = stage < stages[table_index].length ? stages[table_index][stage].last_lookup : lookups[table_index].length;\n+    *plookups = end == start ? nullptr : &lookups[table_index][start];\n+    *lookup_count = end - start;\n+  }\n+\n+  HB_INTERNAL void collect_lookups (unsigned int table_index, hb_set_t *lookups) const;\n+  template <typename Proxy>\n+  HB_INTERNAL inline void apply (const Proxy &proxy,\n+                                 const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;\n+  HB_INTERNAL void substitute (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;\n+  HB_INTERNAL void position (const struct hb_ot_shape_plan_t *plan, hb_font_t *font, hb_buffer_t *buffer) const;\n+\n+  public:\n+  hb_tag_t chosen_script[2];\n+  bool found_script[2];\n+\n+  private:\n+\n+  hb_mask_t global_mask;\n+\n+  hb_vector_t<feature_map_t> features;\n+  hb_vector_t<lookup_map_t> lookups[2]; \/* GSUB\/GPOS *\/\n+  hb_vector_t<stage_map_t> stages[2]; \/* GSUB\/GPOS *\/\n+};\n+\n+enum hb_ot_map_feature_flags_t\n+{\n+  F_NONE                = 0x0000u,\n+  F_GLOBAL              = 0x0001u, \/* Feature applies to all characters; results in no mask allocated for it. *\/\n+  F_HAS_FALLBACK        = 0x0002u, \/* Has fallback implementation, so include mask bit even if feature not found. *\/\n+  F_MANUAL_ZWNJ         = 0x0004u, \/* Don't skip over ZWNJ when matching **context**. *\/\n+  F_MANUAL_ZWJ          = 0x0008u, \/* Don't skip over ZWJ when matching **input**. *\/\n+  F_MANUAL_JOINERS      = F_MANUAL_ZWNJ | F_MANUAL_ZWJ,\n+  F_GLOBAL_MANUAL_JOINERS= F_GLOBAL | F_MANUAL_JOINERS,\n+  F_GLOBAL_HAS_FALLBACK = F_GLOBAL | F_HAS_FALLBACK,\n+  F_GLOBAL_SEARCH       = 0x0010u, \/* If feature not found in LangSys, look for it in global feature list and pick one. *\/\n+  F_RANDOM              = 0x0020u  \/* Randomly select a glyph from an AlternateSubstFormat1 subtable. *\/\n+};\n+HB_MARK_AS_FLAG_T (hb_ot_map_feature_flags_t);\n+\n+\n+struct hb_ot_map_feature_t\n+{\n+  hb_tag_t tag;\n+  hb_ot_map_feature_flags_t flags;\n+};\n+\n+struct hb_ot_shape_plan_key_t;\n+\n+struct hb_ot_map_builder_t\n+{\n+  public:\n+\n+  HB_INTERNAL hb_ot_map_builder_t (hb_face_t *face_,\n+                                   const hb_segment_properties_t *props_);\n+\n+  HB_INTERNAL ~hb_ot_map_builder_t ();\n+\n+  HB_INTERNAL void add_feature (hb_tag_t tag,\n+                                hb_ot_map_feature_flags_t flags=F_NONE,\n+                                unsigned int value=1);\n+\n+  void add_feature (const hb_ot_map_feature_t &feat)\n+  { add_feature (feat.tag, feat.flags); }\n+\n+  void enable_feature (hb_tag_t tag,\n+                              hb_ot_map_feature_flags_t flags=F_NONE,\n+                              unsigned int value=1)\n+  { add_feature (tag, F_GLOBAL | flags, value); }\n+\n+  void disable_feature (hb_tag_t tag)\n+  { add_feature (tag, F_GLOBAL, 0); }\n+\n+  void add_gsub_pause (hb_ot_map_t::pause_func_t pause_func)\n+  { add_pause (0, pause_func); }\n+  void add_gpos_pause (hb_ot_map_t::pause_func_t pause_func)\n+  { add_pause (1, pause_func); }\n+\n+  HB_INTERNAL void compile (hb_ot_map_t                  &m,\n+                            const hb_ot_shape_plan_key_t &key);\n+\n+  private:\n+\n+  HB_INTERNAL void add_lookups (hb_ot_map_t  &m,\n+                                unsigned int  table_index,\n+                                unsigned int  feature_index,\n+                                unsigned int  variations_index,\n+                                hb_mask_t     mask,\n+                                bool          auto_zwnj = true,\n+                                bool          auto_zwj = true,\n+                                bool          random = false);\n+\n+  struct feature_info_t {\n+    hb_tag_t tag;\n+    unsigned int seq; \/* sequence#, used for stable sorting only *\/\n+    unsigned int max_value;\n+    hb_ot_map_feature_flags_t flags;\n+    unsigned int default_value; \/* for non-global features, what should the unset glyphs take *\/\n+    unsigned int stage[2]; \/* GSUB\/GPOS *\/\n+\n+    static int cmp (const void *pa, const void *pb)\n+    {\n+      const feature_info_t *a = (const feature_info_t *) pa;\n+      const feature_info_t *b = (const feature_info_t *) pb;\n+      return (a->tag != b->tag) ?  (a->tag < b->tag ? -1 : 1) :\n+             (a->seq < b->seq ? -1 : a->seq > b->seq ? 1 : 0);\n+    }\n+  };\n+\n+  struct stage_info_t {\n+    unsigned int index;\n+    hb_ot_map_t::pause_func_t pause_func;\n+  };\n+\n+  HB_INTERNAL void add_pause (unsigned int table_index, hb_ot_map_t::pause_func_t pause_func);\n+\n+  public:\n+\n+  hb_face_t *face;\n+  hb_segment_properties_t props;\n+\n+  hb_tag_t chosen_script[2];\n+  bool found_script[2];\n+  unsigned int script_index[2], language_index[2];\n+\n+  private:\n+\n+  unsigned int current_stage[2]; \/* GSUB\/GPOS *\/\n+  hb_vector_t<feature_info_t> feature_infos;\n+  hb_vector_t<stage_info_t> stages[2]; \/* GSUB\/GPOS *\/\n+};\n+\n+\n+\n+#endif \/* HB_OT_MAP_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-map.hh","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -0,0 +1,718 @@\n+\/*\n+ * Copyright © 2016  Igalia S.L.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Igalia Author(s): Frédéric Wang\n+ *\/\n+\n+#ifndef HB_OT_MATH_TABLE_HH\n+#define HB_OT_MATH_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-ot-math.h\"\n+\n+namespace OT {\n+\n+\n+struct MathValueRecord\n+{\n+  hb_position_t get_x_value (hb_font_t *font, const void *base) const\n+  { return font->em_scale_x (value) + (base+deviceTable).get_x_delta (font); }\n+  hb_position_t get_y_value (hb_font_t *font, const void *base) const\n+  { return font->em_scale_y (value) + (base+deviceTable).get_y_delta (font); }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && deviceTable.sanitize (c, base));\n+  }\n+\n+  protected:\n+  HBINT16                       value;          \/* The X or Y value in design units *\/\n+  OffsetTo<Device>      deviceTable;    \/* Offset to the device table - from the\n+                                         * beginning of parent table.  May be NULL.\n+                                         * Suggested format for device table is 1. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct MathConstants\n+{\n+  bool sanitize_math_value_records (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    unsigned int count = ARRAY_LENGTH (mathValueRecords);\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!mathValueRecords[i].sanitize (c, this))\n+        return_trace (false);\n+\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) && sanitize_math_value_records (c));\n+  }\n+\n+  hb_position_t get_value (hb_ot_math_constant_t constant,\n+                                  hb_font_t *font) const\n+  {\n+    switch (constant) {\n+\n+    case HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN:\n+    case HB_OT_MATH_CONSTANT_SCRIPT_SCRIPT_PERCENT_SCALE_DOWN:\n+      return percentScaleDown[constant - HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN];\n+\n+    case HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT:\n+    case HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT:\n+      return font->em_scale_y (minHeight[constant - HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT]);\n+\n+    case HB_OT_MATH_CONSTANT_RADICAL_KERN_AFTER_DEGREE:\n+    case HB_OT_MATH_CONSTANT_RADICAL_KERN_BEFORE_DEGREE:\n+    case HB_OT_MATH_CONSTANT_SKEWED_FRACTION_HORIZONTAL_GAP:\n+    case HB_OT_MATH_CONSTANT_SPACE_AFTER_SCRIPT:\n+      return mathValueRecords[constant - HB_OT_MATH_CONSTANT_MATH_LEADING].get_x_value (font, this);\n+\n+    case HB_OT_MATH_CONSTANT_ACCENT_BASE_HEIGHT:\n+    case HB_OT_MATH_CONSTANT_AXIS_HEIGHT:\n+    case HB_OT_MATH_CONSTANT_FLATTENED_ACCENT_BASE_HEIGHT:\n+    case HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_DISPLAY_STYLE_SHIFT_DOWN:\n+    case HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_SHIFT_DOWN:\n+    case HB_OT_MATH_CONSTANT_FRACTION_DENOM_DISPLAY_STYLE_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_DISPLAY_STYLE_SHIFT_UP:\n+    case HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_SHIFT_UP:\n+    case HB_OT_MATH_CONSTANT_FRACTION_NUM_DISPLAY_STYLE_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_FRACTION_RULE_THICKNESS:\n+    case HB_OT_MATH_CONSTANT_LOWER_LIMIT_BASELINE_DROP_MIN:\n+    case HB_OT_MATH_CONSTANT_LOWER_LIMIT_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_MATH_LEADING:\n+    case HB_OT_MATH_CONSTANT_OVERBAR_EXTRA_ASCENDER:\n+    case HB_OT_MATH_CONSTANT_OVERBAR_RULE_THICKNESS:\n+    case HB_OT_MATH_CONSTANT_OVERBAR_VERTICAL_GAP:\n+    case HB_OT_MATH_CONSTANT_RADICAL_DISPLAY_STYLE_VERTICAL_GAP:\n+    case HB_OT_MATH_CONSTANT_RADICAL_EXTRA_ASCENDER:\n+    case HB_OT_MATH_CONSTANT_RADICAL_RULE_THICKNESS:\n+    case HB_OT_MATH_CONSTANT_RADICAL_VERTICAL_GAP:\n+    case HB_OT_MATH_CONSTANT_SKEWED_FRACTION_VERTICAL_GAP:\n+    case HB_OT_MATH_CONSTANT_STACK_BOTTOM_DISPLAY_STYLE_SHIFT_DOWN:\n+    case HB_OT_MATH_CONSTANT_STACK_BOTTOM_SHIFT_DOWN:\n+    case HB_OT_MATH_CONSTANT_STACK_DISPLAY_STYLE_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_STACK_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_STACK_TOP_DISPLAY_STYLE_SHIFT_UP:\n+    case HB_OT_MATH_CONSTANT_STACK_TOP_SHIFT_UP:\n+    case HB_OT_MATH_CONSTANT_STRETCH_STACK_BOTTOM_SHIFT_DOWN:\n+    case HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_ABOVE_MIN:\n+    case HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_BELOW_MIN:\n+    case HB_OT_MATH_CONSTANT_STRETCH_STACK_TOP_SHIFT_UP:\n+    case HB_OT_MATH_CONSTANT_SUBSCRIPT_BASELINE_DROP_MIN:\n+    case HB_OT_MATH_CONSTANT_SUBSCRIPT_SHIFT_DOWN:\n+    case HB_OT_MATH_CONSTANT_SUBSCRIPT_TOP_MAX:\n+    case HB_OT_MATH_CONSTANT_SUB_SUPERSCRIPT_GAP_MIN:\n+    case HB_OT_MATH_CONSTANT_SUPERSCRIPT_BASELINE_DROP_MAX:\n+    case HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MAX_WITH_SUBSCRIPT:\n+    case HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MIN:\n+    case HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP:\n+    case HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP_CRAMPED:\n+    case HB_OT_MATH_CONSTANT_UNDERBAR_EXTRA_DESCENDER:\n+    case HB_OT_MATH_CONSTANT_UNDERBAR_RULE_THICKNESS:\n+    case HB_OT_MATH_CONSTANT_UNDERBAR_VERTICAL_GAP:\n+    case HB_OT_MATH_CONSTANT_UPPER_LIMIT_BASELINE_RISE_MIN:\n+    case HB_OT_MATH_CONSTANT_UPPER_LIMIT_GAP_MIN:\n+      return mathValueRecords[constant - HB_OT_MATH_CONSTANT_MATH_LEADING].get_y_value (font, this);\n+\n+    case HB_OT_MATH_CONSTANT_RADICAL_DEGREE_BOTTOM_RAISE_PERCENT:\n+      return radicalDegreeBottomRaisePercent;\n+\n+    default:\n+      return 0;\n+    }\n+  }\n+\n+  protected:\n+  HBINT16 percentScaleDown[2];\n+  HBUINT16 minHeight[2];\n+  MathValueRecord mathValueRecords[51];\n+  HBINT16 radicalDegreeBottomRaisePercent;\n+\n+  public:\n+  DEFINE_SIZE_STATIC (214);\n+};\n+\n+struct MathItalicsCorrectionInfo\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  coverage.sanitize (c, this) &&\n+                  italicsCorrection.sanitize (c, this));\n+  }\n+\n+  hb_position_t get_value (hb_codepoint_t glyph,\n+                           hb_font_t *font) const\n+  {\n+    unsigned int index = (this+coverage).get_coverage (glyph);\n+    return italicsCorrection[index].get_x_value (font, this);\n+  }\n+\n+  protected:\n+  OffsetTo<Coverage>       coverage;            \/* Offset to Coverage table -\n+                                                 * from the beginning of\n+                                                 * MathItalicsCorrectionInfo\n+                                                 * table. *\/\n+  ArrayOf<MathValueRecord> italicsCorrection;   \/* Array of MathValueRecords\n+                                                 * defining italics correction\n+                                                 * values for each\n+                                                 * covered glyph. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (4, italicsCorrection);\n+};\n+\n+struct MathTopAccentAttachment\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  topAccentCoverage.sanitize (c, this) &&\n+                  topAccentAttachment.sanitize (c, this));\n+  }\n+\n+  hb_position_t get_value (hb_codepoint_t glyph,\n+                           hb_font_t *font) const\n+  {\n+    unsigned int index = (this+topAccentCoverage).get_coverage (glyph);\n+    if (index == NOT_COVERED)\n+      return font->get_glyph_h_advance (glyph) \/ 2;\n+    return topAccentAttachment[index].get_x_value (font, this);\n+  }\n+\n+  protected:\n+  OffsetTo<Coverage>       topAccentCoverage;   \/* Offset to Coverage table -\n+                                                 * from the beginning of\n+                                                 * MathTopAccentAttachment\n+                                                 * table. *\/\n+  ArrayOf<MathValueRecord> topAccentAttachment; \/* Array of MathValueRecords\n+                                                 * defining top accent\n+                                                 * attachment points for each\n+                                                 * covered glyph. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (2 + 2, topAccentAttachment);\n+};\n+\n+struct MathKern\n+{\n+  bool sanitize_math_value_records (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    unsigned int count = 2 * heightCount + 1;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!mathValueRecordsZ.arrayZ[i].sanitize (c, this)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  c->check_array (mathValueRecordsZ.arrayZ, 2 * heightCount + 1) &&\n+                  sanitize_math_value_records (c));\n+  }\n+\n+  hb_position_t get_value (hb_position_t correction_height, hb_font_t *font) const\n+  {\n+    const MathValueRecord* correctionHeight = mathValueRecordsZ.arrayZ;\n+    const MathValueRecord* kernValue = mathValueRecordsZ.arrayZ + heightCount;\n+    int sign = font->y_scale < 0 ? -1 : +1;\n+\n+    \/* The description of the MathKern table is a ambiguous, but interpreting\n+     * \"between the two heights found at those indexes\" for 0 < i < len as\n+     *\n+     *   correctionHeight[i-1] < correction_height <= correctionHeight[i]\n+     *\n+     * makes the result consistent with the limit cases and we can just use the\n+     * binary search algorithm of std::upper_bound:\n+     *\/\n+    unsigned int i = 0;\n+    unsigned int count = heightCount;\n+    while (count > 0)\n+    {\n+      unsigned int half = count \/ 2;\n+      hb_position_t height = correctionHeight[i + half].get_y_value (font, this);\n+      if (sign * height < sign * correction_height)\n+      {\n+        i += half + 1;\n+        count -= half + 1;\n+      } else\n+        count = half;\n+    }\n+    return kernValue[i].get_x_value (font, this);\n+  }\n+\n+  protected:\n+  HBUINT16      heightCount;\n+  UnsizedArrayOf<MathValueRecord>\n+                mathValueRecordsZ;      \/* Array of correction heights at\n+                                         * which the kern value changes.\n+                                         * Sorted by the height value in\n+                                         * design units (heightCount entries),\n+                                         * Followed by:\n+                                         * Array of kern values corresponding\n+                                         * to heights. (heightCount+1 entries).\n+                                         *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (2, mathValueRecordsZ);\n+};\n+\n+struct MathKernInfoRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+\n+    unsigned int count = ARRAY_LENGTH (mathKern);\n+    for (unsigned int i = 0; i < count; i++)\n+      if (unlikely (!mathKern[i].sanitize (c, base)))\n+        return_trace (false);\n+\n+    return_trace (true);\n+  }\n+\n+  hb_position_t get_kerning (hb_ot_math_kern_t kern,\n+                             hb_position_t correction_height,\n+                             hb_font_t *font,\n+                             const void *base) const\n+  {\n+    unsigned int idx = kern;\n+    if (unlikely (idx >= ARRAY_LENGTH (mathKern))) return 0;\n+    return (base+mathKern[idx]).get_value (correction_height, font);\n+  }\n+\n+  protected:\n+  \/* Offset to MathKern table for each corner -\n+   * from the beginning of MathKernInfo table.  May be NULL. *\/\n+  OffsetTo<MathKern> mathKern[4];\n+\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct MathKernInfo\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  mathKernCoverage.sanitize (c, this) &&\n+                  mathKernInfoRecords.sanitize (c, this));\n+  }\n+\n+  hb_position_t get_kerning (hb_codepoint_t glyph,\n+                             hb_ot_math_kern_t kern,\n+                             hb_position_t correction_height,\n+                             hb_font_t *font) const\n+  {\n+    unsigned int index = (this+mathKernCoverage).get_coverage (glyph);\n+    return mathKernInfoRecords[index].get_kerning (kern, correction_height, font, this);\n+  }\n+\n+  protected:\n+  OffsetTo<Coverage>            mathKernCoverage;    \/* Offset to Coverage table -\n+                                                      * from the beginning of the\n+                                                      * MathKernInfo table. *\/\n+  ArrayOf<MathKernInfoRecord>   mathKernInfoRecords; \/* Array of\n+                                                      * MathKernInfoRecords,\n+                                                      * per-glyph information for\n+                                                      * mathematical positioning\n+                                                      * of subscripts and\n+                                                      * superscripts. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (4, mathKernInfoRecords);\n+};\n+\n+struct MathGlyphInfo\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  mathItalicsCorrectionInfo.sanitize (c, this) &&\n+                  mathTopAccentAttachment.sanitize (c, this) &&\n+                  extendedShapeCoverage.sanitize (c, this) &&\n+                  mathKernInfo.sanitize (c, this));\n+  }\n+\n+  hb_position_t\n+  get_italics_correction (hb_codepoint_t  glyph, hb_font_t *font) const\n+  { return (this+mathItalicsCorrectionInfo).get_value (glyph, font); }\n+\n+  hb_position_t\n+  get_top_accent_attachment (hb_codepoint_t  glyph, hb_font_t *font) const\n+  { return (this+mathTopAccentAttachment).get_value (glyph, font); }\n+\n+  bool is_extended_shape (hb_codepoint_t glyph) const\n+  { return (this+extendedShapeCoverage).get_coverage (glyph) != NOT_COVERED; }\n+\n+  hb_position_t get_kerning (hb_codepoint_t glyph,\n+                             hb_ot_math_kern_t kern,\n+                             hb_position_t correction_height,\n+                             hb_font_t *font) const\n+  { return (this+mathKernInfo).get_kerning (glyph, kern, correction_height, font); }\n+\n+  protected:\n+  \/* Offset to MathItalicsCorrectionInfo table -\n+   * from the beginning of MathGlyphInfo table. *\/\n+  OffsetTo<MathItalicsCorrectionInfo> mathItalicsCorrectionInfo;\n+\n+  \/* Offset to MathTopAccentAttachment table -\n+   * from the beginning of MathGlyphInfo table. *\/\n+  OffsetTo<MathTopAccentAttachment> mathTopAccentAttachment;\n+\n+  \/* Offset to coverage table for Extended Shape glyphs -\n+   * from the beginning of MathGlyphInfo table. When the left or right glyph of\n+   * a box is an extended shape variant, the (ink) box (and not the default\n+   * position defined by values in MathConstants table) should be used for\n+   * vertical positioning purposes.  May be NULL.. *\/\n+  OffsetTo<Coverage> extendedShapeCoverage;\n+\n+   \/* Offset to MathKernInfo table -\n+    * from the beginning of MathGlyphInfo table. *\/\n+  OffsetTo<MathKernInfo> mathKernInfo;\n+\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct MathGlyphVariantRecord\n+{\n+  friend struct MathGlyphConstruction;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  protected:\n+  GlyphID variantGlyph;       \/* Glyph ID for the variant. *\/\n+  HBUINT16  advanceMeasurement; \/* Advance width\/height, in design units, of the\n+                                 * variant, in the direction of requested\n+                                 * glyph extension. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct PartFlags : HBUINT16\n+{\n+  enum Flags {\n+    Extender    = 0x0001u, \/* If set, the part can be skipped or repeated. *\/\n+\n+    Defined     = 0x0001u, \/* All defined flags. *\/\n+  };\n+\n+  public:\n+  DEFINE_SIZE_STATIC (2);\n+};\n+\n+struct MathGlyphPartRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  void extract (hb_ot_math_glyph_part_t &out,\n+                int scale,\n+                hb_font_t *font) const\n+  {\n+    out.glyph                   = glyph;\n+\n+    out.start_connector_length  = font->em_scale (startConnectorLength, scale);\n+    out.end_connector_length    = font->em_scale (endConnectorLength, scale);\n+    out.full_advance            = font->em_scale (fullAdvance, scale);\n+\n+    static_assert ((unsigned int) HB_MATH_GLYPH_PART_FLAG_EXTENDER ==\n+                   (unsigned int) PartFlags::Extender, \"\");\n+\n+    out.flags = (hb_ot_math_glyph_part_flags_t)\n+                (unsigned int)\n+                (partFlags & PartFlags::Defined);\n+  }\n+\n+  protected:\n+  GlyphID   glyph;                \/* Glyph ID for the part. *\/\n+  HBUINT16    startConnectorLength; \/* Advance width\/ height of the straight bar\n+                                   * connector material, in design units, is at\n+                                   * the beginning of the glyph, in the\n+                                   * direction of the extension. *\/\n+  HBUINT16    endConnectorLength;   \/* Advance width\/ height of the straight bar\n+                                   * connector material, in design units, is at\n+                                   * the end of the glyph, in the direction of\n+                                   * the extension. *\/\n+  HBUINT16    fullAdvance;        \/* Full advance width\/height for this part,\n+                                   * in the direction of the extension.\n+                                   * In design units. *\/\n+  PartFlags partFlags;            \/* Part qualifiers. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+struct MathGlyphAssembly\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  italicsCorrection.sanitize (c, this) &&\n+                  partRecords.sanitize (c));\n+  }\n+\n+  unsigned int get_parts (hb_direction_t direction,\n+                          hb_font_t *font,\n+                          unsigned int start_offset,\n+                          unsigned int *parts_count, \/* IN\/OUT *\/\n+                          hb_ot_math_glyph_part_t *parts \/* OUT *\/,\n+                          hb_position_t *italics_correction \/* OUT *\/) const\n+  {\n+    if (parts_count)\n+    {\n+      int scale = font->dir_scale (direction);\n+      hb_array_t<const MathGlyphPartRecord> arr = partRecords.sub_array (start_offset, parts_count);\n+      unsigned int count = arr.length;\n+      for (unsigned int i = 0; i < count; i++)\n+        arr[i].extract (parts[i], scale, font);\n+    }\n+\n+    if (italics_correction)\n+      *italics_correction = italicsCorrection.get_x_value (font, this);\n+\n+    return partRecords.len;\n+  }\n+\n+  protected:\n+  MathValueRecord          italicsCorrection; \/* Italics correction of this\n+                                               * MathGlyphAssembly. Should not\n+                                               * depend on the assembly size. *\/\n+  ArrayOf<MathGlyphPartRecord> partRecords;   \/* Array of part records, from\n+                                               * left to right and bottom to\n+                                               * top. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (6, partRecords);\n+};\n+\n+struct MathGlyphConstruction\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  glyphAssembly.sanitize (c, this) &&\n+                  mathGlyphVariantRecord.sanitize (c));\n+  }\n+\n+  const MathGlyphAssembly &get_assembly () const { return this+glyphAssembly; }\n+\n+  unsigned int get_variants (hb_direction_t direction,\n+                             hb_font_t *font,\n+                             unsigned int start_offset,\n+                             unsigned int *variants_count, \/* IN\/OUT *\/\n+                             hb_ot_math_glyph_variant_t *variants \/* OUT *\/) const\n+  {\n+    if (variants_count)\n+    {\n+      int scale = font->dir_scale (direction);\n+      hb_array_t<const MathGlyphVariantRecord> arr = mathGlyphVariantRecord.sub_array (start_offset, variants_count);\n+      unsigned int count = arr.length;\n+      for (unsigned int i = 0; i < count; i++)\n+      {\n+        variants[i].glyph = arr[i].variantGlyph;\n+        variants[i].advance = font->em_scale (arr[i].advanceMeasurement, scale);\n+      }\n+    }\n+    return mathGlyphVariantRecord.len;\n+  }\n+\n+  protected:\n+  \/* Offset to MathGlyphAssembly table for this shape - from the beginning of\n+     MathGlyphConstruction table.  May be NULL. *\/\n+  OffsetTo<MathGlyphAssembly>     glyphAssembly;\n+\n+  \/* MathGlyphVariantRecords for alternative variants of the glyphs. *\/\n+  ArrayOf<MathGlyphVariantRecord> mathGlyphVariantRecord;\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (4, mathGlyphVariantRecord);\n+};\n+\n+struct MathVariants\n+{\n+  bool sanitize_offsets (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    unsigned int count = vertGlyphCount + horizGlyphCount;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!glyphConstruction.arrayZ[i].sanitize (c, this)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  vertGlyphCoverage.sanitize (c, this) &&\n+                  horizGlyphCoverage.sanitize (c, this) &&\n+                  c->check_array (glyphConstruction.arrayZ, vertGlyphCount + horizGlyphCount) &&\n+                  sanitize_offsets (c));\n+  }\n+\n+  hb_position_t get_min_connector_overlap (hb_direction_t direction,\n+                                                  hb_font_t *font) const\n+  { return font->em_scale_dir (minConnectorOverlap, direction); }\n+\n+  unsigned int get_glyph_variants (hb_codepoint_t glyph,\n+                                   hb_direction_t direction,\n+                                   hb_font_t *font,\n+                                   unsigned int start_offset,\n+                                   unsigned int *variants_count, \/* IN\/OUT *\/\n+                                   hb_ot_math_glyph_variant_t *variants \/* OUT *\/) const\n+  { return get_glyph_construction (glyph, direction, font)\n+           .get_variants (direction, font, start_offset, variants_count, variants); }\n+\n+  unsigned int get_glyph_parts (hb_codepoint_t glyph,\n+                                       hb_direction_t direction,\n+                                       hb_font_t *font,\n+                                       unsigned int start_offset,\n+                                       unsigned int *parts_count, \/* IN\/OUT *\/\n+                                       hb_ot_math_glyph_part_t *parts \/* OUT *\/,\n+                                       hb_position_t *italics_correction \/* OUT *\/) const\n+  { return get_glyph_construction (glyph, direction, font)\n+           .get_assembly ()\n+           .get_parts (direction, font,\n+                       start_offset, parts_count, parts,\n+                       italics_correction); }\n+\n+  private:\n+  const MathGlyphConstruction &\n+  get_glyph_construction (hb_codepoint_t glyph,\n+                          hb_direction_t direction,\n+                          hb_font_t *font HB_UNUSED) const\n+  {\n+    bool vertical = HB_DIRECTION_IS_VERTICAL (direction);\n+    unsigned int count = vertical ? vertGlyphCount : horizGlyphCount;\n+    const OffsetTo<Coverage> &coverage = vertical ? vertGlyphCoverage\n+                                                  : horizGlyphCoverage;\n+\n+    unsigned int index = (this+coverage).get_coverage (glyph);\n+    if (unlikely (index >= count)) return Null (MathGlyphConstruction);\n+\n+    if (!vertical)\n+      index += vertGlyphCount;\n+\n+    return this+glyphConstruction[index];\n+  }\n+\n+  protected:\n+  HBUINT16           minConnectorOverlap; \/* Minimum overlap of connecting\n+                                           * glyphs during glyph construction,\n+                                           * in design units. *\/\n+  OffsetTo<Coverage> vertGlyphCoverage;   \/* Offset to Coverage table -\n+                                           * from the beginning of MathVariants\n+                                           * table. *\/\n+  OffsetTo<Coverage> horizGlyphCoverage;  \/* Offset to Coverage table -\n+                                           * from the beginning of MathVariants\n+                                           * table. *\/\n+  HBUINT16           vertGlyphCount;      \/* Number of glyphs for which\n+                                           * information is provided for\n+                                           * vertically growing variants. *\/\n+  HBUINT16           horizGlyphCount;     \/* Number of glyphs for which\n+                                           * information is provided for\n+                                           * horizontally growing variants. *\/\n+\n+  \/* Array of offsets to MathGlyphConstruction tables - from the beginning of\n+     the MathVariants table, for shapes growing in vertical\/horizontal\n+     direction. *\/\n+  UnsizedArrayOf<OffsetTo<MathGlyphConstruction> >\n+                        glyphConstruction;\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (10, glyphConstruction);\n+};\n+\n+\n+\/*\n+ * MATH -- Mathematical typesetting\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/math\n+ *\/\n+\n+struct MATH\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_MATH;\n+\n+  bool has_data () const { return version.to_int (); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  mathConstants.sanitize (c, this) &&\n+                  mathGlyphInfo.sanitize (c, this) &&\n+                  mathVariants.sanitize (c, this));\n+  }\n+\n+  hb_position_t get_constant (hb_ot_math_constant_t  constant,\n+                                     hb_font_t             *font) const\n+  { return (this+mathConstants).get_value (constant, font); }\n+\n+  const MathGlyphInfo &get_glyph_info () const { return this+mathGlyphInfo; }\n+\n+  const MathVariants &get_variants () const    { return this+mathVariants; }\n+\n+  protected:\n+  FixedVersion<>version;                \/* Version of the MATH table\n+                                         * initially set to 0x00010000u *\/\n+  OffsetTo<MathConstants> mathConstants;\/* MathConstants table *\/\n+  OffsetTo<MathGlyphInfo> mathGlyphInfo;\/* MathGlyphInfo table *\/\n+  OffsetTo<MathVariants>  mathVariants; \/* MathVariants table *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_MATH_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-math-table.hh","additions":718,"deletions":0,"binary":false,"changes":718,"status":"added"},{"patch":"@@ -0,0 +1,253 @@\n+\/*\n+ * Copyright © 2016  Igalia S.L.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Igalia Author(s): Frédéric Wang\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+\n+#include \"hb-ot-face.hh\"\n+#include \"hb-ot-math-table.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-ot-math\n+ * @title: hb-ot-math\n+ * @short_description: OpenType Math information\n+ * @include: hb-ot.h\n+ *\n+ * Functions for fetching mathematics layout data from OpenType fonts.\n+ **\/\n+\n+\n+\/*\n+ * OT::MATH\n+ *\/\n+\n+\/**\n+ * hb_ot_math_has_data:\n+ * @face: #hb_face_t to test\n+ *\n+ * This function allows to verify the presence of an OpenType MATH table on the\n+ * face.\n+ *\n+ * Return value: true if face has a MATH table, false otherwise\n+ *\n+ * Since: 1.3.3\n+ **\/\n+hb_bool_t\n+hb_ot_math_has_data (hb_face_t *face)\n+{\n+  return face->table.MATH->has_data ();\n+}\n+\n+\/**\n+ * hb_ot_math_get_constant:\n+ * @font: #hb_font_t from which to retrieve the value\n+ * @constant: #hb_ot_math_constant_t the constant to retrieve\n+ *\n+ * This function returns the requested math constants as a #hb_position_t.\n+ * If the request constant is HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN,\n+ * HB_OT_MATH_CONSTANT_SCRIPT_SCRIPT_PERCENT_SCALE_DOWN or\n+ * HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN then the return value is\n+ * actually an integer between 0 and 100 representing that percentage.\n+ *\n+ * Return value: the requested constant or 0\n+ *\n+ * Since: 1.3.3\n+ **\/\n+hb_position_t\n+hb_ot_math_get_constant (hb_font_t *font,\n+                         hb_ot_math_constant_t constant)\n+{\n+  return font->face->table.MATH->get_constant(constant, font);\n+}\n+\n+\/**\n+ * hb_ot_math_get_glyph_italics_correction:\n+ * @font: #hb_font_t from which to retrieve the value\n+ * @glyph: glyph index from which to retrieve the value\n+ *\n+ * Return value: the italics correction of the glyph or 0\n+ *\n+ * Since: 1.3.3\n+ **\/\n+hb_position_t\n+hb_ot_math_get_glyph_italics_correction (hb_font_t *font,\n+                                         hb_codepoint_t glyph)\n+{\n+  return font->face->table.MATH->get_glyph_info().get_italics_correction (glyph, font);\n+}\n+\n+\/**\n+ * hb_ot_math_get_glyph_top_accent_attachment:\n+ * @font: #hb_font_t from which to retrieve the value\n+ * @glyph: glyph index from which to retrieve the value\n+ *\n+ * Return value: the top accent attachment of the glyph or 0\n+ *\n+ * Since: 1.3.3\n+ **\/\n+hb_position_t\n+hb_ot_math_get_glyph_top_accent_attachment (hb_font_t *font,\n+                                            hb_codepoint_t glyph)\n+{\n+  return font->face->table.MATH->get_glyph_info().get_top_accent_attachment (glyph, font);\n+}\n+\n+\/**\n+ * hb_ot_math_is_glyph_extended_shape:\n+ * @face: a #hb_face_t to test\n+ * @glyph: a glyph index to test\n+ *\n+ * Return value: true if the glyph is an extended shape, false otherwise\n+ *\n+ * Since: 1.3.3\n+ **\/\n+hb_bool_t\n+hb_ot_math_is_glyph_extended_shape (hb_face_t *face,\n+                                    hb_codepoint_t glyph)\n+{\n+  return face->table.MATH->get_glyph_info().is_extended_shape (glyph);\n+}\n+\n+\/**\n+ * hb_ot_math_get_glyph_kerning:\n+ * @font: #hb_font_t from which to retrieve the value\n+ * @glyph: glyph index from which to retrieve the value\n+ * @kern: the #hb_ot_math_kern_t from which to retrieve the value\n+ * @correction_height: the correction height to use to determine the kerning.\n+ *\n+ * This function tries to retrieve the MathKern table for the specified font,\n+ * glyph and #hb_ot_math_kern_t. Then it browses the list of heights from the\n+ * MathKern table to find one value that is greater or equal to specified\n+ * correction_height. If one is found the corresponding value from the list of\n+ * kerns is returned and otherwise the last kern value is returned.\n+ *\n+ * Return value: requested kerning or 0\n+ *\n+ * Since: 1.3.3\n+ **\/\n+hb_position_t\n+hb_ot_math_get_glyph_kerning (hb_font_t *font,\n+                              hb_codepoint_t glyph,\n+                              hb_ot_math_kern_t kern,\n+                              hb_position_t correction_height)\n+{\n+  return font->face->table.MATH->get_glyph_info().get_kerning (glyph,\n+                                                               kern,\n+                                                               correction_height,\n+                                                               font);\n+}\n+\n+\/**\n+ * hb_ot_math_get_glyph_variants:\n+ * @font: #hb_font_t from which to retrieve the values\n+ * @glyph: index of the glyph to stretch\n+ * @direction: direction of the stretching\n+ * @start_offset: offset of the first variant to retrieve\n+ * @variants_count: maximum number of variants to retrieve after start_offset\n+ * (IN) and actual number of variants retrieved (OUT)\n+ * @variants: array of size at least @variants_count to store the result\n+ *\n+ * This function tries to retrieve the MathGlyphConstruction for the specified\n+ * font, glyph and direction. Note that only the value of\n+ * #HB_DIRECTION_IS_HORIZONTAL is considered. It provides the corresponding list\n+ * of size variants as an array of hb_ot_math_glyph_variant_t structs.\n+ *\n+ * Return value: the total number of size variants available or 0\n+ *\n+ * Since: 1.3.3\n+ **\/\n+unsigned int\n+hb_ot_math_get_glyph_variants (hb_font_t *font,\n+                               hb_codepoint_t glyph,\n+                               hb_direction_t direction,\n+                               unsigned int start_offset,\n+                               unsigned int *variants_count, \/* IN\/OUT *\/\n+                               hb_ot_math_glyph_variant_t *variants \/* OUT *\/)\n+{\n+  return font->face->table.MATH->get_variants().get_glyph_variants (glyph, direction, font,\n+                                                                    start_offset,\n+                                                                    variants_count,\n+                                                                    variants);\n+}\n+\n+\/**\n+ * hb_ot_math_get_min_connector_overlap:\n+ * @font: #hb_font_t from which to retrieve the value\n+ * @direction: direction of the stretching\n+ *\n+ * This function tries to retrieve the MathVariants table for the specified\n+ * font and returns the minimum overlap of connecting glyphs to draw a glyph\n+ * assembly in the specified direction. Note that only the value of\n+ * #HB_DIRECTION_IS_HORIZONTAL is considered.\n+ *\n+ * Return value: requested min connector overlap or 0\n+ *\n+ * Since: 1.3.3\n+ **\/\n+hb_position_t\n+hb_ot_math_get_min_connector_overlap (hb_font_t *font,\n+                                      hb_direction_t direction)\n+{\n+  return font->face->table.MATH->get_variants().get_min_connector_overlap (direction, font);\n+}\n+\n+\/**\n+ * hb_ot_math_get_glyph_assembly:\n+ * @font: #hb_font_t from which to retrieve the values\n+ * @glyph: index of the glyph to stretch\n+ * @direction: direction of the stretching\n+ * @start_offset: offset of the first glyph part to retrieve\n+ * @parts_count: maximum number of glyph parts to retrieve after start_offset\n+ * (IN) and actual number of parts retrieved (OUT)\n+ * @parts: array of size at least @parts_count to store the result\n+ * @italics_correction: italic correction of the glyph assembly\n+ *\n+ * This function tries to retrieve the GlyphAssembly for the specified font,\n+ * glyph and direction. Note that only the value of #HB_DIRECTION_IS_HORIZONTAL\n+ * is considered. It provides the information necessary to draw the glyph\n+ * assembly as an array of #hb_ot_math_glyph_part_t.\n+ *\n+ * Return value: the total number of parts in the glyph assembly\n+ *\n+ * Since: 1.3.3\n+ **\/\n+unsigned int\n+hb_ot_math_get_glyph_assembly (hb_font_t *font,\n+                               hb_codepoint_t glyph,\n+                               hb_direction_t direction,\n+                               unsigned int start_offset,\n+                               unsigned int *parts_count, \/* IN\/OUT *\/\n+                               hb_ot_math_glyph_part_t *parts, \/* OUT *\/\n+                               hb_position_t *italics_correction \/* OUT *\/)\n+{\n+  return font->face->table.MATH->get_variants().get_glyph_parts (glyph,\n+                                                                 direction,\n+                                                                 font,\n+                                                                 start_offset,\n+                                                                 parts_count,\n+                                                                 parts,\n+                                                                 italics_correction);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-math.cc","additions":253,"deletions":0,"binary":false,"changes":253,"status":"added"},{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright © 2016  Igalia S.L.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Igalia Author(s): Frédéric Wang\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_MATH_H\n+#define HB_OT_MATH_H\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/*\n+ * MATH\n+ *\/\n+\n+#define HB_OT_TAG_MATH HB_TAG('M','A','T','H')\n+\n+\/* Use with hb_buffer_set_script() for math shaping. *\/\n+#define HB_OT_MATH_SCRIPT HB_TAG('m','a','t','h')\n+\n+\/* Types *\/\n+\n+\/**\n+ * hb_ot_math_constant_t:\n+ *\n+ * Since: 1.3.3\n+ *\/\n+typedef enum {\n+  HB_OT_MATH_CONSTANT_SCRIPT_PERCENT_SCALE_DOWN = 0,\n+  HB_OT_MATH_CONSTANT_SCRIPT_SCRIPT_PERCENT_SCALE_DOWN = 1,\n+  HB_OT_MATH_CONSTANT_DELIMITED_SUB_FORMULA_MIN_HEIGHT = 2,\n+  HB_OT_MATH_CONSTANT_DISPLAY_OPERATOR_MIN_HEIGHT = 3,\n+  HB_OT_MATH_CONSTANT_MATH_LEADING = 4,\n+  HB_OT_MATH_CONSTANT_AXIS_HEIGHT = 5,\n+  HB_OT_MATH_CONSTANT_ACCENT_BASE_HEIGHT = 6,\n+  HB_OT_MATH_CONSTANT_FLATTENED_ACCENT_BASE_HEIGHT = 7,\n+  HB_OT_MATH_CONSTANT_SUBSCRIPT_SHIFT_DOWN = 8,\n+  HB_OT_MATH_CONSTANT_SUBSCRIPT_TOP_MAX = 9,\n+  HB_OT_MATH_CONSTANT_SUBSCRIPT_BASELINE_DROP_MIN = 10,\n+  HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP = 11,\n+  HB_OT_MATH_CONSTANT_SUPERSCRIPT_SHIFT_UP_CRAMPED = 12,\n+  HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MIN = 13,\n+  HB_OT_MATH_CONSTANT_SUPERSCRIPT_BASELINE_DROP_MAX = 14,\n+  HB_OT_MATH_CONSTANT_SUB_SUPERSCRIPT_GAP_MIN = 15,\n+  HB_OT_MATH_CONSTANT_SUPERSCRIPT_BOTTOM_MAX_WITH_SUBSCRIPT = 16,\n+  HB_OT_MATH_CONSTANT_SPACE_AFTER_SCRIPT = 17,\n+  HB_OT_MATH_CONSTANT_UPPER_LIMIT_GAP_MIN = 18,\n+  HB_OT_MATH_CONSTANT_UPPER_LIMIT_BASELINE_RISE_MIN = 19,\n+  HB_OT_MATH_CONSTANT_LOWER_LIMIT_GAP_MIN = 20,\n+  HB_OT_MATH_CONSTANT_LOWER_LIMIT_BASELINE_DROP_MIN = 21,\n+  HB_OT_MATH_CONSTANT_STACK_TOP_SHIFT_UP = 22,\n+  HB_OT_MATH_CONSTANT_STACK_TOP_DISPLAY_STYLE_SHIFT_UP = 23,\n+  HB_OT_MATH_CONSTANT_STACK_BOTTOM_SHIFT_DOWN = 24,\n+  HB_OT_MATH_CONSTANT_STACK_BOTTOM_DISPLAY_STYLE_SHIFT_DOWN = 25,\n+  HB_OT_MATH_CONSTANT_STACK_GAP_MIN = 26,\n+  HB_OT_MATH_CONSTANT_STACK_DISPLAY_STYLE_GAP_MIN = 27,\n+  HB_OT_MATH_CONSTANT_STRETCH_STACK_TOP_SHIFT_UP = 28,\n+  HB_OT_MATH_CONSTANT_STRETCH_STACK_BOTTOM_SHIFT_DOWN = 29,\n+  HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_ABOVE_MIN = 30,\n+  HB_OT_MATH_CONSTANT_STRETCH_STACK_GAP_BELOW_MIN = 31,\n+  HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_SHIFT_UP = 32,\n+  HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_DISPLAY_STYLE_SHIFT_UP = 33,\n+  HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_SHIFT_DOWN = 34,\n+  HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_DISPLAY_STYLE_SHIFT_DOWN = 35,\n+  HB_OT_MATH_CONSTANT_FRACTION_NUMERATOR_GAP_MIN = 36,\n+  HB_OT_MATH_CONSTANT_FRACTION_NUM_DISPLAY_STYLE_GAP_MIN = 37,\n+  HB_OT_MATH_CONSTANT_FRACTION_RULE_THICKNESS = 38,\n+  HB_OT_MATH_CONSTANT_FRACTION_DENOMINATOR_GAP_MIN = 39,\n+  HB_OT_MATH_CONSTANT_FRACTION_DENOM_DISPLAY_STYLE_GAP_MIN = 40,\n+  HB_OT_MATH_CONSTANT_SKEWED_FRACTION_HORIZONTAL_GAP = 41,\n+  HB_OT_MATH_CONSTANT_SKEWED_FRACTION_VERTICAL_GAP = 42,\n+  HB_OT_MATH_CONSTANT_OVERBAR_VERTICAL_GAP = 43,\n+  HB_OT_MATH_CONSTANT_OVERBAR_RULE_THICKNESS = 44,\n+  HB_OT_MATH_CONSTANT_OVERBAR_EXTRA_ASCENDER = 45,\n+  HB_OT_MATH_CONSTANT_UNDERBAR_VERTICAL_GAP = 46,\n+  HB_OT_MATH_CONSTANT_UNDERBAR_RULE_THICKNESS = 47,\n+  HB_OT_MATH_CONSTANT_UNDERBAR_EXTRA_DESCENDER = 48,\n+  HB_OT_MATH_CONSTANT_RADICAL_VERTICAL_GAP = 49,\n+  HB_OT_MATH_CONSTANT_RADICAL_DISPLAY_STYLE_VERTICAL_GAP = 50,\n+  HB_OT_MATH_CONSTANT_RADICAL_RULE_THICKNESS = 51,\n+  HB_OT_MATH_CONSTANT_RADICAL_EXTRA_ASCENDER = 52,\n+  HB_OT_MATH_CONSTANT_RADICAL_KERN_BEFORE_DEGREE = 53,\n+  HB_OT_MATH_CONSTANT_RADICAL_KERN_AFTER_DEGREE = 54,\n+  HB_OT_MATH_CONSTANT_RADICAL_DEGREE_BOTTOM_RAISE_PERCENT = 55\n+} hb_ot_math_constant_t;\n+\n+\/**\n+ * hb_ot_math_kern_t:\n+ *\n+ * Since: 1.3.3\n+ *\/\n+typedef enum {\n+  HB_OT_MATH_KERN_TOP_RIGHT = 0,\n+  HB_OT_MATH_KERN_TOP_LEFT = 1,\n+  HB_OT_MATH_KERN_BOTTOM_RIGHT = 2,\n+  HB_OT_MATH_KERN_BOTTOM_LEFT = 3\n+} hb_ot_math_kern_t;\n+\n+\/**\n+ * hb_ot_math_glyph_variant_t:\n+ *\n+ * Since: 1.3.3\n+ *\/\n+typedef struct hb_ot_math_glyph_variant_t {\n+  hb_codepoint_t glyph;\n+  hb_position_t advance;\n+} hb_ot_math_glyph_variant_t;\n+\n+\/**\n+ * hb_ot_math_glyph_part_flags_t:\n+ *\n+ * Since: 1.3.3\n+ *\/\n+typedef enum { \/*< flags >*\/\n+  HB_MATH_GLYPH_PART_FLAG_EXTENDER      = 0x00000001u  \/* Extender glyph *\/\n+} hb_ot_math_glyph_part_flags_t;\n+\n+\/**\n+ * hb_ot_math_glyph_part_t:\n+ *\n+ * Since: 1.3.3\n+ *\/\n+typedef struct hb_ot_math_glyph_part_t {\n+  hb_codepoint_t glyph;\n+  hb_position_t start_connector_length;\n+  hb_position_t end_connector_length;\n+  hb_position_t full_advance;\n+  hb_ot_math_glyph_part_flags_t flags;\n+} hb_ot_math_glyph_part_t;\n+\n+\/* Methods *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_math_has_data (hb_face_t *face);\n+\n+HB_EXTERN hb_position_t\n+hb_ot_math_get_constant (hb_font_t *font,\n+                         hb_ot_math_constant_t constant);\n+\n+HB_EXTERN hb_position_t\n+hb_ot_math_get_glyph_italics_correction (hb_font_t *font,\n+                                         hb_codepoint_t glyph);\n+\n+HB_EXTERN hb_position_t\n+hb_ot_math_get_glyph_top_accent_attachment (hb_font_t *font,\n+                                            hb_codepoint_t glyph);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_math_is_glyph_extended_shape (hb_face_t *face,\n+                                    hb_codepoint_t glyph);\n+\n+HB_EXTERN hb_position_t\n+hb_ot_math_get_glyph_kerning (hb_font_t *font,\n+                              hb_codepoint_t glyph,\n+                              hb_ot_math_kern_t kern,\n+                              hb_position_t correction_height);\n+\n+HB_EXTERN unsigned int\n+hb_ot_math_get_glyph_variants (hb_font_t *font,\n+                               hb_codepoint_t glyph,\n+                               hb_direction_t direction,\n+                               unsigned int start_offset,\n+                               unsigned int *variants_count, \/* IN\/OUT *\/\n+                               hb_ot_math_glyph_variant_t *variants \/* OUT *\/);\n+\n+HB_EXTERN hb_position_t\n+hb_ot_math_get_min_connector_overlap (hb_font_t *font,\n+                                      hb_direction_t direction);\n+\n+HB_EXTERN unsigned int\n+hb_ot_math_get_glyph_assembly (hb_font_t *font,\n+                               hb_codepoint_t glyph,\n+                               hb_direction_t direction,\n+                               unsigned int start_offset,\n+                               unsigned int *parts_count, \/* IN\/OUT *\/\n+                               hb_ot_math_glyph_part_t *parts, \/* OUT *\/\n+                               hb_position_t *italics_correction \/* OUT *\/);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_MATH_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-math.h","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_MAXP_TABLE_HH\n+#define HB_OT_MAXP_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+namespace OT {\n+\n+\n+\/*\n+ * maxp -- Maximum Profile\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/maxp\n+ *\/\n+\n+#define HB_OT_TAG_maxp HB_TAG('m','a','x','p')\n+\n+struct maxpV1Tail\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  HBUINT16 maxPoints;             \/* Maximum points in a non-composite glyph. *\/\n+  HBUINT16 maxContours;           \/* Maximum contours in a non-composite glyph. *\/\n+  HBUINT16 maxCompositePoints;    \/* Maximum points in a composite glyph. *\/\n+  HBUINT16 maxCompositeContours;  \/* Maximum contours in a composite glyph. *\/\n+  HBUINT16 maxZones;              \/* 1 if instructions do not use the twilight zone (Z0),\n+                                   * or 2 if instructions do use Z0; should be set to 2 in\n+                                   * most cases. *\/\n+  HBUINT16 maxTwilightPoints;     \/* Maximum points used in Z0. *\/\n+  HBUINT16 maxStorage;            \/* Number of Storage Area locations. *\/\n+  HBUINT16 maxFunctionDefs;       \/* Number of FDEFs, equal to the highest function number + 1. *\/\n+  HBUINT16 maxInstructionDefs;    \/* Number of IDEFs. *\/\n+  HBUINT16 maxStackElements;      \/* Maximum stack depth. (This includes Font and CVT\n+                                   * Programs, as well as the instructions for each glyph.) *\/\n+  HBUINT16 maxSizeOfInstructions; \/* Maximum byte count for glyph instructions. *\/\n+  HBUINT16 maxComponentElements;  \/* Maximum number of components referenced at\n+                                   * \"top level\" for any composite glyph. *\/\n+  HBUINT16 maxComponentDepth;     \/* Maximum levels of recursion; 1 for simple components. *\/\n+ public:\n+  DEFINE_SIZE_STATIC (26);\n+};\n+\n+\n+struct maxp\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_maxp;\n+\n+  unsigned int get_num_glyphs () const { return numGlyphs; }\n+\n+  void set_num_glyphs (unsigned int count)\n+  {\n+    numGlyphs.set (count);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+\n+    if (version.major == 1)\n+    {\n+      const maxpV1Tail &v1 = StructAfter<maxpV1Tail> (*this);\n+      return_trace (v1.sanitize (c));\n+    }\n+    return_trace (likely (version.major == 0 && version.minor == 0x5000u));\n+  }\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    hb_blob_t *maxp_blob = hb_sanitize_context_t().reference_table<maxp> (plan->source);\n+    hb_blob_t *maxp_prime_blob = hb_blob_copy_writable_or_fail (maxp_blob);\n+    hb_blob_destroy (maxp_blob);\n+\n+    if (unlikely (!maxp_prime_blob)) {\n+      return false;\n+    }\n+    maxp *maxp_prime = (maxp *) hb_blob_get_data (maxp_prime_blob, nullptr);\n+\n+    maxp_prime->set_num_glyphs (plan->glyphs.length);\n+    if (plan->drop_hints)\n+      drop_hint_fields (plan, maxp_prime);\n+\n+    bool result = plan->add_table (HB_OT_TAG_maxp, maxp_prime_blob);\n+    hb_blob_destroy (maxp_prime_blob);\n+    return result;\n+  }\n+\n+  static void drop_hint_fields (hb_subset_plan_t *plan HB_UNUSED, maxp *maxp_prime)\n+  {\n+    if (maxp_prime->version.major == 1)\n+    {\n+      maxpV1Tail &v1 = StructAfter<maxpV1Tail> (*maxp_prime);\n+      v1.maxZones.set (1);\n+      v1.maxTwilightPoints.set (0);\n+      v1.maxStorage.set (0);\n+      v1.maxFunctionDefs.set (0);\n+      v1.maxInstructionDefs.set (0);\n+      v1.maxStackElements.set (0);\n+      v1.maxSizeOfInstructions.set (0);\n+    }\n+  }\n+\n+  protected:\n+  FixedVersion<>version;                \/* Version of the maxp table (0.5 or 1.0),\n+                                         * 0x00005000u or 0x00010000u. *\/\n+  HBUINT16      numGlyphs;              \/* The number of glyphs in the font. *\/\n+\/*maxpV1Tail    v1Tail[VAR]; *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_MAXP_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-maxp-table.hh","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,457 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-name-language.hh\"\n+\n+\/* Following two tables were generated by joining FreeType, FontConfig,\n+ * and OpenType specification language lists, then filled in missing\n+ * entries using:\n+ * https:\/\/docs.microsoft.com\/en-us\/windows\/desktop\/intl\/language-identifier-constants-and-strings\n+ *\/\n+\n+struct hb_ot_language_map_t\n+{\n+  static int cmp (const void *key, const void *item)\n+  {\n+    unsigned int a = * (unsigned int *) key;\n+    unsigned int b = ((const hb_ot_language_map_t *) item)->code;\n+    return a < b ? -1 : a > b ? +1 : 0;\n+  }\n+\n+  uint16_t      code;\n+  char          lang[6];\n+};\n+\n+static const hb_ot_language_map_t\n+hb_ms_language_map[] =\n+{\n+  {0x0001,      \"ar\"},  \/* ??? *\/\n+  {0x0004,      \"zh\"},  \/* ??? *\/\n+  {0x0009,      \"en\"},  \/* ??? *\/\n+  {0x0401,      \"ar\"},  \/* Arabic (Saudi Arabia) *\/\n+  {0x0402,      \"bg\"},  \/* Bulgarian (Bulgaria) *\/\n+  {0x0403,      \"ca\"},  \/* Catalan (Catalan) *\/\n+  {0x0404,      \"zh-tw\"},       \/* Chinese (Taiwan) *\/\n+  {0x0405,      \"cs\"},  \/* Czech (Czech Republic) *\/\n+  {0x0406,      \"da\"},  \/* Danish (Denmark) *\/\n+  {0x0407,      \"de\"},  \/* German (Germany) *\/\n+  {0x0408,      \"el\"},  \/* Greek (Greece) *\/\n+  {0x0409,      \"en\"},  \/* English (United States) *\/\n+  {0x040A,      \"es\"},  \/* Spanish (Traditional Sort) (Spain) *\/\n+  {0x040B,      \"fi\"},  \/* Finnish (Finland) *\/\n+  {0x040C,      \"fr\"},  \/* French (France) *\/\n+  {0x040D,      \"he\"},  \/* Hebrew (Israel) *\/\n+  {0x040E,      \"hu\"},  \/* Hungarian (Hungary) *\/\n+  {0x040F,      \"is\"},  \/* Icelandic (Iceland) *\/\n+  {0x0410,      \"it\"},  \/* Italian (Italy) *\/\n+  {0x0411,      \"ja\"},  \/* Japanese (Japan) *\/\n+  {0x0412,      \"ko\"},  \/* Korean (Korea) *\/\n+  {0x0413,      \"nl\"},  \/* Dutch (Netherlands) *\/\n+  {0x0414,      \"no\"},  \/* Norwegian (Bokmal) (Norway) *\/\n+  {0x0415,      \"pl\"},  \/* Polish (Poland) *\/\n+  {0x0416,      \"pt\"},  \/* Portuguese (Brazil) *\/\n+  {0x0417,      \"rm\"},  \/* Romansh (Switzerland) *\/\n+  {0x0418,      \"ro\"},  \/* Romanian (Romania) *\/\n+  {0x0419,      \"ru\"},  \/* Russian (Russia) *\/\n+  {0x041A,      \"hr\"},  \/* Croatian (Croatia) *\/\n+  {0x041B,      \"sk\"},  \/* Slovak (Slovakia) *\/\n+  {0x041C,      \"sq\"},  \/* Albanian (Albania) *\/\n+  {0x041D,      \"sv\"},  \/* Swedish (Sweden) *\/\n+  {0x041E,      \"th\"},  \/* Thai (Thailand) *\/\n+  {0x041F,      \"tr\"},  \/* Turkish (Turkey) *\/\n+  {0x0420,      \"ur\"},  \/* Urdu (Islamic Republic of Pakistan) *\/\n+  {0x0421,      \"id\"},  \/* Indonesian (Indonesia) *\/\n+  {0x0422,      \"uk\"},  \/* Ukrainian (Ukraine) *\/\n+  {0x0423,      \"be\"},  \/* Belarusian (Belarus) *\/\n+  {0x0424,      \"sl\"},  \/* Slovenian (Slovenia) *\/\n+  {0x0425,      \"et\"},  \/* Estonian (Estonia) *\/\n+  {0x0426,      \"lv\"},  \/* Latvian (Latvia) *\/\n+  {0x0427,      \"lt\"},  \/* Lithuanian (Lithuania) *\/\n+  {0x0428,      \"tg\"},  \/* Tajik (Cyrillic) (Tajikistan) *\/\n+  {0x0429,      \"fa\"},  \/* Persian (Iran) *\/\n+  {0x042A,      \"vi\"},  \/* Vietnamese (Vietnam) *\/\n+  {0x042B,      \"hy\"},  \/* Armenian (Armenia) *\/\n+  {0x042C,      \"az\"},  \/* Azeri (Latin) (Azerbaijan) *\/\n+  {0x042D,      \"eu\"},  \/* Basque (Basque) *\/\n+  {0x042E,      \"hsb\"}, \/* Upper Sorbian (Germany) *\/\n+  {0x042F,      \"mk\"},  \/* Macedonian (FYROM) (Former Yugoslav Republic of Macedonia) *\/\n+  {0x0430,      \"st\"},  \/* ??? *\/\n+  {0x0431,      \"ts\"},  \/* ??? *\/\n+  {0x0432,      \"tn\"},  \/* Setswana (South Africa) *\/\n+  {0x0433,      \"ven\"}, \/* ??? *\/\n+  {0x0434,      \"xh\"},  \/* isiXhosa (South Africa) *\/\n+  {0x0435,      \"zu\"},  \/* isiZulu (South Africa) *\/\n+  {0x0436,      \"af\"},  \/* Afrikaans (South Africa) *\/\n+  {0x0437,      \"ka\"},  \/* Georgian (Georgia) *\/\n+  {0x0438,      \"fo\"},  \/* Faroese (Faroe Islands) *\/\n+  {0x0439,      \"hi\"},  \/* Hindi (India) *\/\n+  {0x043A,      \"mt\"},  \/* Maltese (Malta) *\/\n+  {0x043B,      \"se\"},  \/* Sami (Northern) (Norway) *\/\n+  {0x043C,      \"ga\"},  \/* ??? *\/\n+  {0x043D,      \"yi\"},  \/* ??? *\/\n+  {0x043E,      \"ms\"},  \/* Malay (Malaysia) *\/\n+  {0x043F,      \"kk\"},  \/* Kazakh (Kazakhstan) *\/\n+  {0x0440,      \"ky\"},  \/* Kyrgyz (Kyrgyzstan) *\/\n+  {0x0441,      \"sw\"},  \/* Kiswahili (Kenya) *\/\n+  {0x0442,      \"tk\"},  \/* Turkmen (Turkmenistan) *\/\n+  {0x0443,      \"uz\"},  \/* Uzbek (Latin) (Uzbekistan) *\/\n+  {0x0444,      \"tt\"},  \/* Tatar (Russia) *\/\n+  {0x0445,      \"bn\"},  \/* Bengali (India) *\/\n+  {0x0446,      \"pa\"},  \/* Punjabi (India) *\/\n+  {0x0447,      \"gu\"},  \/* Gujarati (India) *\/\n+  {0x0448,      \"or\"},  \/* Odia (formerly Oriya) (India) *\/\n+  {0x0449,      \"ta\"},  \/* Tamil (India) *\/\n+  {0x044A,      \"te\"},  \/* Telugu (India) *\/\n+  {0x044B,      \"kn\"},  \/* Kannada (India) *\/\n+  {0x044C,      \"ml\"},  \/* Malayalam (India) *\/\n+  {0x044D,      \"as\"},  \/* Assamese (India) *\/\n+  {0x044E,      \"mr\"},  \/* Marathi (India) *\/\n+  {0x044F,      \"sa\"},  \/* Sanskrit (India) *\/\n+  {0x0450,      \"mn\"},  \/* Mongolian (Cyrillic) (Mongolia) *\/\n+  {0x0451,      \"bo\"},  \/* Tibetan (PRC) *\/\n+  {0x0452,      \"cy\"},  \/* Welsh (United Kingdom) *\/\n+  {0x0453,      \"km\"},  \/* Khmer (Cambodia) *\/\n+  {0x0454,      \"lo\"},  \/* Lao (Lao P.D.R.) *\/\n+  {0x0455,      \"my\"},  \/* ??? *\/\n+  {0x0456,      \"gl\"},  \/* Galician (Galician) *\/\n+  {0x0457,      \"kok\"}, \/* Konkani (India) *\/\n+  {0x0458,      \"mni\"}, \/* ??? *\/\n+  {0x0459,      \"sd\"},  \/* ??? *\/\n+  {0x045A,      \"syr\"}, \/* Syriac (Syria) *\/\n+  {0x045B,      \"si\"},  \/* Sinhala (Sri Lanka) *\/\n+  {0x045C,      \"chr\"}, \/* ??? *\/\n+  {0x045D,      \"iu\"},  \/* Inuktitut (Canada) *\/\n+  {0x045E,      \"am\"},  \/* Amharic (Ethiopia) *\/\n+  {0x0460,      \"ks\"},  \/* ??? *\/\n+  {0x0461,      \"ne\"},  \/* Nepali (Nepal) *\/\n+  {0x0462,      \"fy\"},  \/* Frisian (Netherlands) *\/\n+  {0x0463,      \"ps\"},  \/* Pashto (Afghanistan) *\/\n+  {0x0464,      \"phi\"}, \/* Filipino (Philippines) *\/\n+  {0x0465,      \"div\"}, \/* Divehi (Maldives) *\/\n+  {0x0468,      \"ha\"},  \/* Hausa (Latin) (Nigeria) *\/\n+  {0x046A,      \"yo\"},  \/* Yoruba (Nigeria) *\/\n+  {0x046B,      \"quz\"}, \/* Quechua (Bolivia) *\/\n+  {0x046C,      \"nso\"}, \/* Sesotho sa Leboa (South Africa) *\/\n+  {0x046D,      \"ba\"},  \/* Bashkir (Russia) *\/\n+  {0x046E,      \"lb\"},  \/* Luxembourgish (Luxembourg) *\/\n+  {0x046F,      \"kl\"},  \/* Greenlandic (Greenland) *\/\n+  {0x0470,      \"ibo\"}, \/* Igbo (Nigeria) *\/\n+  {0x0471,      \"kau\"}, \/* ??? *\/\n+  {0x0472,      \"om\"},  \/* ??? *\/\n+  {0x0473,      \"ti\"},  \/* ??? *\/\n+  {0x0474,      \"gn\"},  \/* ??? *\/\n+  {0x0475,      \"haw\"}, \/* ??? *\/\n+  {0x0476,      \"la\"},  \/* ??? *\/\n+  {0x0477,      \"so\"},  \/* ??? *\/\n+  {0x0478,      \"ii\"},  \/* Yi (PRC) *\/\n+  {0x0479,      \"pap\"}, \/* ??? *\/\n+  {0x047A,      \"arn\"}, \/* Mapudungun (Chile) *\/\n+  {0x047C,      \"moh\"}, \/* Mohawk (Mohawk) *\/\n+  {0x047E,      \"br\"},  \/* Breton (France) *\/\n+  {0x0480,      \"ug\"},  \/* Uighur (PRC) *\/\n+  {0x0481,      \"mi\"},  \/* Maori (New Zealand) *\/\n+  {0x0482,      \"oc\"},  \/* Occitan (France) *\/\n+  {0x0483,      \"co\"},  \/* Corsican (France) *\/\n+  {0x0484,      \"gsw\"}, \/* Alsatian (France) *\/\n+  {0x0485,      \"sah\"}, \/* Yakut (Russia) *\/\n+  {0x0486,      \"qut\"}, \/* K'iche (Guatemala) *\/\n+  {0x0487,      \"rw\"},  \/* Kinyarwanda (Rwanda) *\/\n+  {0x0488,      \"wo\"},  \/* Wolof (Senegal) *\/\n+  {0x048C,      \"fa\"},  \/* Dari (Afghanistan) *\/\n+  {0x0801,      \"ar\"},  \/* Arabic (Iraq) *\/\n+  {0x0804,      \"zh-cn\"},       \/* Chinese (People’s Republic of China) *\/\n+  {0x0807,      \"de\"},  \/* German (Switzerland) *\/\n+  {0x0809,      \"en\"},  \/* English (United Kingdom) *\/\n+  {0x080A,      \"es\"},  \/* Spanish (Mexico) *\/\n+  {0x080C,      \"fr\"},  \/* French (Belgium) *\/\n+  {0x0810,      \"it\"},  \/* Italian (Switzerland) *\/\n+  {0x0812,      \"ko\"},  \/* ??? *\/\n+  {0x0813,      \"nl\"},  \/* Dutch (Belgium) *\/\n+  {0x0814,      \"nn\"},  \/* Norwegian (Nynorsk) (Norway) *\/\n+  {0x0816,      \"pt\"},  \/* Portuguese (Portugal) *\/\n+  {0x0818,      \"mo\"},  \/* ??? *\/\n+  {0x0819,      \"ru\"},  \/* ??? *\/\n+  {0x081A,      \"sr\"},  \/* Serbian (Latin) (Serbia) *\/\n+  {0x081D,      \"sv\"},  \/* Sweden (Finland) *\/\n+  {0x0820,      \"ur\"},  \/* ??? *\/\n+  {0x0827,      \"lt\"},  \/* ??? *\/\n+  {0x082C,      \"az\"},  \/* Azeri (Cyrillic) (Azerbaijan) *\/\n+  {0x082E,      \"dsb\"}, \/* Lower Sorbian (Germany) *\/\n+\/\/{0x083B,      \"\"},    \/* Sami (Northern) (Sweden) *\/\n+  {0x083C,      \"gd\"},  \/* Irish (Ireland) *\/\n+  {0x083E,      \"ms\"},  \/* Malay (Brunei Darussalam) *\/\n+  {0x0843,      \"uz\"},  \/* Uzbek (Cyrillic) (Uzbekistan) *\/\n+  {0x0845,      \"bn\"},  \/* Bengali (Bangladesh) *\/\n+  {0x0846,      \"ar\"},  \/* ??? *\/\n+  {0x0850,      \"mn\"},  \/* Mongolian (Traditional) (People’s Republic of China) *\/\n+  {0x0851,      \"dz\"},  \/* ??? *\/\n+  {0x085D,      \"iu\"},  \/* Inuktitut (Latin) (Canada) *\/\n+  {0x085F,      \"tzm\"}, \/* Tamazight (Latin) (Algeria) *\/\n+  {0x0861,      \"ne\"},  \/* ??? *\/\n+\/\/{0x086B,      \"\"},    \/* Quechua (Ecuador) *\/\n+  {0x0873,      \"ti\"},  \/* ??? *\/\n+  {0x0C01,      \"ar\"},  \/* Arabic (Egypt) *\/\n+  {0x0C04,      \"zh-hk\"},       \/* Chinese (Hong Kong S.A.R.) *\/\n+  {0x0C07,      \"de\"},  \/* German (Austria) *\/\n+  {0x0C09,      \"en\"},  \/* English (Australia) *\/\n+  {0x0C0A,      \"es\"},  \/* Spanish (Modern Sort) (Spain) *\/\n+  {0x0C0C,      \"fr\"},  \/* French (Canada) *\/\n+  {0x0C1A,      \"sr\"},  \/* Serbian (Cyrillic) (Serbia) *\/\n+  {0x0C3B,      \"se\"},  \/* Sami (Northern) (Finland) *\/\n+\/\/{0x0C6B,      \"\"},    \/* Quechua (Peru) *\/\n+  {0x1001,      \"ar\"},  \/* Arabic (Libya) *\/\n+  {0x1004,      \"zh-sg\"},       \/* Chinese (Singapore) *\/\n+  {0x1007,      \"de\"},  \/* German (Luxembourg) *\/\n+  {0x1009,      \"en\"},  \/* English (Canada) *\/\n+  {0x100A,      \"es\"},  \/* Spanish (Guatemala) *\/\n+  {0x100C,      \"fr\"},  \/* French (Switzerland) *\/\n+  {0x101A,      \"hr\"},  \/* Croatian (Latin) (Bosnia and Herzegovina) *\/\n+  {0x103B,      \"smj\"}, \/* Sami (Lule) (Norway) *\/\n+  {0x1401,      \"ar\"},  \/* Arabic (Algeria) *\/\n+\/\/{0x1404,      \"\"},    \/* Chinese (Macao S.A.R.) *\/\n+  {0x1407,      \"de\"},  \/* German (Liechtenstein) *\/\n+  {0x1409,      \"en\"},  \/* English (New Zealand) *\/\n+  {0x140A,      \"es\"},  \/* Spanish (Costa Rica) *\/\n+  {0x140C,      \"fr\"},  \/* French (Luxembourg) *\/\n+  {0x141A,      \"bs\"},  \/* Bosnian (Latin) (Bosnia and Herzegovina) *\/\n+\/\/{0x143B,      \"\"},    \/* Sami (Lule) (Sweden) *\/\n+  {0x1801,      \"ar\"},  \/* Arabic (Morocco) *\/\n+  {0x1809,      \"en\"},  \/* English (Ireland) *\/\n+  {0x180A,      \"es\"},  \/* Spanish (Panama) *\/\n+  {0x180C,      \"fr\"},  \/* French (Principality of Monaco) *\/\n+\/\/{0x181A,      \"\"},    \/* Serbian (Latin) (Bosnia and Herzegovina) *\/\n+  {0x183B,      \"sma\"}, \/* Sami (Southern) (Norway) *\/\n+  {0x1C01,      \"ar\"},  \/* Arabic (Tunisia) *\/\n+  {0x1C09,      \"en\"},  \/* English (South Africa) *\/\n+  {0x1C0A,      \"es\"},  \/* Spanish (Dominican Republic) *\/\n+  {0x1C0C,      \"fr\"},  \/* ??? *\/\n+\/\/{0x1C1A,      \"\"},    \/* Serbian (Cyrillic) (Bosnia and Herzegovina) *\/\n+\/\/{0x1C3B,      \"\"},    \/* Sami (Southern) (Sweden) *\/\n+  {0x2001,      \"ar\"},  \/* Arabic (Oman) *\/\n+  {0x2009,      \"en\"},  \/* English (Jamaica) *\/\n+  {0x200A,      \"es\"},  \/* Spanish (Venezuela) *\/\n+  {0x200C,      \"fr\"},  \/* ??? *\/\n+  {0x201A,      \"bs\"},  \/* Bosnian (Cyrillic) (Bosnia and Herzegovina) *\/\n+  {0x203B,      \"sms\"}, \/* Sami (Skolt) (Finland) *\/\n+  {0x2401,      \"ar\"},  \/* Arabic (Yemen) *\/\n+  {0x2409,      \"en\"},  \/* English (Caribbean) *\/\n+  {0x240A,      \"es\"},  \/* Spanish (Colombia) *\/\n+  {0x240C,      \"fr\"},  \/* ??? *\/\n+  {0x243B,      \"smn\"}, \/* Sami (Inari) (Finland) *\/\n+  {0x2801,      \"ar\"},  \/* Arabic (Syria) *\/\n+  {0x2809,      \"en\"},  \/* English (Belize) *\/\n+  {0x280A,      \"es\"},  \/* Spanish (Peru) *\/\n+  {0x280C,      \"fr\"},  \/* ??? *\/\n+  {0x2C01,      \"ar\"},  \/* Arabic (Jordan) *\/\n+  {0x2C09,      \"en\"},  \/* English (Trinidad and Tobago) *\/\n+  {0x2C0A,      \"es\"},  \/* Spanish (Argentina) *\/\n+  {0x2C0C,      \"fr\"},  \/* ??? *\/\n+  {0x3001,      \"ar\"},  \/* Arabic (Lebanon) *\/\n+  {0x3009,      \"en\"},  \/* English (Zimbabwe) *\/\n+  {0x300A,      \"es\"},  \/* Spanish (Ecuador) *\/\n+  {0x300C,      \"fr\"},  \/* ??? *\/\n+  {0x3401,      \"ar\"},  \/* Arabic (Kuwait) *\/\n+  {0x3409,      \"en\"},  \/* English (Republic of the Philippines) *\/\n+  {0x340A,      \"es\"},  \/* Spanish (Chile) *\/\n+  {0x340C,      \"fr\"},  \/* ??? *\/\n+  {0x3801,      \"ar\"},  \/* Arabic (U.A.E.) *\/\n+  {0x380A,      \"es\"},  \/* Spanish (Uruguay) *\/\n+  {0x380C,      \"fr\"},  \/* ??? *\/\n+  {0x3C01,      \"ar\"},  \/* Arabic (Bahrain) *\/\n+  {0x3C09,      \"en\"},  \/* ??? *\/\n+  {0x3C0A,      \"es\"},  \/* Spanish (Paraguay) *\/\n+  {0x3C0C,      \"fr\"},  \/* ??? *\/\n+  {0x4001,      \"ar\"},  \/* Arabic (Qatar) *\/\n+  {0x4009,      \"en\"},  \/* English (India) *\/\n+  {0x400A,      \"es\"},  \/* Spanish (Bolivia) *\/\n+  {0x4409,      \"en\"},  \/* English (Malaysia) *\/\n+  {0x440A,      \"es\"},  \/* Spanish (El Salvador) *\/\n+  {0x4809,      \"en\"},  \/* English (Singapore) *\/\n+  {0x480A,      \"es\"},  \/* Spanish (Honduras) *\/\n+  {0x4C0A,      \"es\"},  \/* Spanish (Nicaragua) *\/\n+  {0x500A,      \"es\"},  \/* Spanish (Puerto Rico) *\/\n+  {0x540A,      \"es\"},  \/* Spanish (United States) *\/\n+  {0xE40A,      \"es\"},  \/* ??? *\/\n+  {0xE40C,      \"fr\"},  \/* ??? *\/\n+};\n+\n+static const hb_ot_language_map_t\n+hb_mac_language_map[] =\n+{\n+  {  0, \"en\"},  \/* English *\/\n+  {  1, \"fr\"},  \/* French *\/\n+  {  2, \"de\"},  \/* German *\/\n+  {  3, \"it\"},  \/* Italian *\/\n+  {  4, \"nl\"},  \/* Dutch *\/\n+  {  5, \"sv\"},  \/* Swedish *\/\n+  {  6, \"es\"},  \/* Spanish *\/\n+  {  7, \"da\"},  \/* Danish *\/\n+  {  8, \"pt\"},  \/* Portuguese *\/\n+  {  9, \"no\"},  \/* Norwegian *\/\n+  { 10, \"he\"},  \/* Hebrew *\/\n+  { 11, \"ja\"},  \/* Japanese *\/\n+  { 12, \"ar\"},  \/* Arabic *\/\n+  { 13, \"fi\"},  \/* Finnish *\/\n+  { 14, \"el\"},  \/* Greek *\/\n+  { 15, \"is\"},  \/* Icelandic *\/\n+  { 16, \"mt\"},  \/* Maltese *\/\n+  { 17, \"tr\"},  \/* Turkish *\/\n+  { 18, \"hr\"},  \/* Croatian *\/\n+  { 19, \"zh-tw\"},       \/* Chinese (Traditional) *\/\n+  { 20, \"ur\"},  \/* Urdu *\/\n+  { 21, \"hi\"},  \/* Hindi *\/\n+  { 22, \"th\"},  \/* Thai *\/\n+  { 23, \"ko\"},  \/* Korean *\/\n+  { 24, \"lt\"},  \/* Lithuanian *\/\n+  { 25, \"pl\"},  \/* Polish *\/\n+  { 26, \"hu\"},  \/* Hungarian *\/\n+  { 27, \"et\"},  \/* Estonian *\/\n+  { 28, \"lv\"},  \/* Latvian *\/\n+\/\/{ 29, \"\"},    \/* Sami *\/\n+  { 30, \"fo\"},  \/* Faroese *\/\n+  { 31, \"fa\"},  \/* Farsi\/Persian *\/\n+  { 32, \"ru\"},  \/* Russian *\/\n+  { 33, \"zh-cn\"},       \/* Chinese (Simplified) *\/\n+  { 34, \"nl\"},  \/* Flemish *\/\n+  { 35, \"ga\"},  \/* Irish Gaelic *\/\n+  { 36, \"sq\"},  \/* Albanian *\/\n+  { 37, \"ro\"},  \/* Romanian *\/\n+  { 38, \"cs\"},  \/* Czech *\/\n+  { 39, \"sk\"},  \/* Slovak *\/\n+  { 40, \"sl\"},  \/* Slovenian *\/\n+  { 41, \"yi\"},  \/* Yiddish *\/\n+  { 42, \"sr\"},  \/* Serbian *\/\n+  { 43, \"mk\"},  \/* Macedonian *\/\n+  { 44, \"bg\"},  \/* Bulgarian *\/\n+  { 45, \"uk\"},  \/* Ukrainian *\/\n+  { 46, \"be\"},  \/* Byelorussian *\/\n+  { 47, \"uz\"},  \/* Uzbek *\/\n+  { 48, \"kk\"},  \/* Kazakh *\/\n+  { 49, \"az\"},  \/* Azerbaijani (Cyrillic script) *\/\n+  { 50, \"az\"},  \/* Azerbaijani (Arabic script) *\/\n+  { 51, \"hy\"},  \/* Armenian *\/\n+  { 52, \"ka\"},  \/* Georgian *\/\n+  { 53, \"mo\"},  \/* Moldavian *\/\n+  { 54, \"ky\"},  \/* Kirghiz *\/\n+  { 55, \"tg\"},  \/* Tajiki *\/\n+  { 56, \"tk\"},  \/* Turkmen *\/\n+  { 57, \"mn\"},  \/* Mongolian (Mongolian script) *\/\n+  { 58, \"mn\"},  \/* Mongolian (Cyrillic script) *\/\n+  { 59, \"ps\"},  \/* Pashto *\/\n+  { 60, \"ku\"},  \/* Kurdish *\/\n+  { 61, \"ks\"},  \/* Kashmiri *\/\n+  { 62, \"sd\"},  \/* Sindhi *\/\n+  { 63, \"bo\"},  \/* Tibetan *\/\n+  { 64, \"ne\"},  \/* Nepali *\/\n+  { 65, \"sa\"},  \/* Sanskrit *\/\n+  { 66, \"mr\"},  \/* Marathi *\/\n+  { 67, \"bn\"},  \/* Bengali *\/\n+  { 68, \"as\"},  \/* Assamese *\/\n+  { 69, \"gu\"},  \/* Gujarati *\/\n+  { 70, \"pa\"},  \/* Punjabi *\/\n+  { 71, \"or\"},  \/* Oriya *\/\n+  { 72, \"ml\"},  \/* Malayalam *\/\n+  { 73, \"kn\"},  \/* Kannada *\/\n+  { 74, \"ta\"},  \/* Tamil *\/\n+  { 75, \"te\"},  \/* Telugu *\/\n+  { 76, \"si\"},  \/* Sinhalese *\/\n+  { 77, \"my\"},  \/* Burmese *\/\n+  { 78, \"km\"},  \/* Khmer *\/\n+  { 79, \"lo\"},  \/* Lao *\/\n+  { 80, \"vi\"},  \/* Vietnamese *\/\n+  { 81, \"id\"},  \/* Indonesian *\/\n+  { 82, \"tl\"},  \/* Tagalog *\/\n+  { 83, \"ms\"},  \/* Malay (Roman script) *\/\n+  { 84, \"ms\"},  \/* Malay (Arabic script) *\/\n+  { 85, \"am\"},  \/* Amharic *\/\n+  { 86, \"ti\"},  \/* Tigrinya *\/\n+  { 87, \"om\"},  \/* Galla *\/\n+  { 88, \"so\"},  \/* Somali *\/\n+  { 89, \"sw\"},  \/* Swahili *\/\n+  { 90, \"rw\"},  \/* Kinyarwanda\/Ruanda *\/\n+  { 91, \"rn\"},  \/* Rundi *\/\n+  { 92, \"ny\"},  \/* Nyanja\/Chewa *\/\n+  { 93, \"mg\"},  \/* Malagasy *\/\n+  { 94, \"eo\"},  \/* Esperanto *\/\n+  {128, \"cy\"},  \/* Welsh *\/\n+  {129, \"eu\"},  \/* Basque *\/\n+  {130, \"ca\"},  \/* Catalan *\/\n+  {131, \"la\"},  \/* Latin *\/\n+  {132, \"qu\"},  \/* Quechua *\/\n+  {133, \"gn\"},  \/* Guarani *\/\n+  {134, \"ay\"},  \/* Aymara *\/\n+  {135, \"tt\"},  \/* Tatar *\/\n+  {136, \"ug\"},  \/* Uighur *\/\n+  {137, \"dz\"},  \/* Dzongkha *\/\n+  {138, \"jw\"},  \/* Javanese (Roman script) *\/\n+  {139, \"su\"},  \/* Sundanese (Roman script) *\/\n+  {140, \"gl\"},  \/* Galician *\/\n+  {141, \"af\"},  \/* Afrikaans *\/\n+  {142, \"br\"},  \/* Breton *\/\n+  {143, \"iu\"},  \/* Inuktitut *\/\n+  {144, \"gd\"},  \/* Scottish Gaelic *\/\n+  {145, \"gv\"},  \/* Manx Gaelic *\/\n+  {146, \"ga\"},  \/* Irish Gaelic (with dot above) *\/\n+  {147, \"to\"},  \/* Tongan *\/\n+  {148, \"el\"},  \/* Greek (polytonic) *\/\n+  {149, \"ik\"},  \/* Greenlandic *\/\n+  {150, \"az\"},  \/* Azerbaijani (Roman script) *\/\n+};\n+\n+\n+static hb_language_t\n+_hb_ot_name_language_for (unsigned int code,\n+                          const hb_ot_language_map_t *array,\n+                          unsigned int len)\n+{\n+  const hb_ot_language_map_t *entry = (const hb_ot_language_map_t *)\n+                                      hb_bsearch (&code,\n+                                                  array,\n+                                                  len,\n+                                                  sizeof (array[0]),\n+                                                  hb_ot_language_map_t::cmp);\n+\n+  if (entry)\n+    return hb_language_from_string (entry->lang, -1);\n+\n+  return HB_LANGUAGE_INVALID;\n+}\n+\n+hb_language_t\n+_hb_ot_name_language_for_ms_code (unsigned int code)\n+{\n+  return _hb_ot_name_language_for (code,\n+                                   hb_ms_language_map,\n+                                   ARRAY_LENGTH (hb_ms_language_map));\n+}\n+\n+hb_language_t\n+_hb_ot_name_language_for_mac_code (unsigned int code)\n+{\n+  return _hb_ot_name_language_for (code,\n+                                   hb_mac_language_map,\n+                                   ARRAY_LENGTH (hb_mac_language_map));\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-name-language.cc","additions":457,"deletions":0,"binary":false,"changes":457,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-name-language.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-name-language.hh","status":"copied"},{"patch":"@@ -0,0 +1,279 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_NAME_TABLE_HH\n+#define HB_OT_NAME_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-name-language.hh\"\n+#include \"hb-aat-layout.hh\"\n+\n+\n+namespace OT {\n+\n+\n+#define entry_score var.u16[0]\n+#define entry_index var.u16[1]\n+\n+\n+\/*\n+ * name -- Naming\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/name\n+ *\/\n+#define HB_OT_TAG_name HB_TAG('n','a','m','e')\n+\n+#define UNSUPPORTED     42\n+\n+struct NameRecord\n+{\n+  hb_language_t language (hb_face_t *face) const\n+  {\n+    unsigned int p = platformID;\n+    unsigned int l = languageID;\n+\n+    if (p == 3)\n+      return _hb_ot_name_language_for_ms_code (l);\n+\n+    if (p == 1)\n+      return _hb_ot_name_language_for_mac_code (l);\n+\n+    if (p == 0)\n+      return _hb_aat_language_get (face, l);\n+\n+    return HB_LANGUAGE_INVALID;\n+  }\n+\n+  uint16_t score () const\n+  {\n+    \/* Same order as in cmap::find_best_subtable(). *\/\n+    unsigned int p = platformID;\n+    unsigned int e = encodingID;\n+\n+    \/* 32-bit. *\/\n+    if (p == 3 && e == 10) return 0;\n+    if (p == 0 && e ==  6) return 1;\n+    if (p == 0 && e ==  4) return 2;\n+\n+    \/* 16-bit. *\/\n+    if (p == 3 && e ==  1) return 3;\n+    if (p == 0 && e ==  3) return 4;\n+    if (p == 0 && e ==  2) return 5;\n+    if (p == 0 && e ==  1) return 6;\n+    if (p == 0 && e ==  0) return 7;\n+\n+    \/* Symbol. *\/\n+    if (p == 3 && e ==  0) return 8;\n+\n+    \/* We treat all Mac Latin names as ASCII only. *\/\n+    if (p == 1 && e ==  0) return 10; \/* 10 is magic number :| *\/\n+\n+    return UNSUPPORTED;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c, const void *base) const\n+  {\n+    TRACE_SANITIZE (this);\n+    \/* We can check from base all the way up to the end of string... *\/\n+    return_trace (c->check_struct (this) && c->check_range ((char *) base, (unsigned int) length + offset));\n+  }\n+\n+  HBUINT16      platformID;     \/* Platform ID. *\/\n+  HBUINT16      encodingID;     \/* Platform-specific encoding ID. *\/\n+  HBUINT16      languageID;     \/* Language ID. *\/\n+  HBUINT16      nameID;         \/* Name ID. *\/\n+  HBUINT16      length;         \/* String length (in bytes). *\/\n+  HBUINT16      offset;         \/* String offset from start of storage area (in bytes). *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+static int\n+_hb_ot_name_entry_cmp_key (const void *pa, const void *pb)\n+{\n+  const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;\n+  const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;\n+\n+  \/* Compare by name_id, then language. *\/\n+\n+  if (a->name_id != b->name_id)\n+    return a->name_id < b->name_id ? -1 : +1;\n+\n+  if (a->language == b->language) return 0;\n+  if (!a->language) return -1;\n+  if (!b->language) return +1;\n+  return strcmp (hb_language_to_string (a->language),\n+                 hb_language_to_string (b->language));\n+}\n+\n+static int\n+_hb_ot_name_entry_cmp (const void *pa, const void *pb)\n+{\n+  \/* Compare by name_id, then language, then score, then index. *\/\n+\n+  int v = _hb_ot_name_entry_cmp_key (pa, pb);\n+  if (v)\n+    return v;\n+\n+  const hb_ot_name_entry_t *a = (const hb_ot_name_entry_t *) pa;\n+  const hb_ot_name_entry_t *b = (const hb_ot_name_entry_t *) pb;\n+\n+  if (a->entry_score != b->entry_score)\n+    return a->entry_score < b->entry_score ? -1 : +1;\n+\n+  if (a->entry_index != b->entry_index)\n+    return a->entry_index < b->entry_index ? -1 : +1;\n+\n+  return 0;\n+}\n+\n+struct name\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_name;\n+\n+  unsigned int get_size () const\n+  { return min_size + count * nameRecordZ.item_size; }\n+\n+  bool sanitize_records (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    const void *string_pool = (this+stringOffset).arrayZ;\n+    unsigned int _count = count;\n+    \/* Move to run-time?! *\/\n+    for (unsigned int i = 0; i < _count; i++)\n+      if (!nameRecordZ[i].sanitize (c, string_pool)) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  likely (format == 0 || format == 1) &&\n+                  c->check_array (nameRecordZ.arrayZ, count) &&\n+                  c->check_range (this, stringOffset));\n+  }\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      this->table = hb_sanitize_context_t().reference_table<name> (face);\n+      assert (this->table.get_length () >= this->table->stringOffset);\n+      this->pool = (const char *) (const void *) (this->table+this->table->stringOffset);\n+      this->pool_len = this->table.get_length () - this->table->stringOffset;\n+      const hb_array_t<const NameRecord> all_names (this->table->nameRecordZ.arrayZ,\n+                                                    this->table->count);\n+\n+      this->names.init ();\n+      this->names.alloc (all_names.length);\n+\n+      for (unsigned int i = 0; i < all_names.length; i++)\n+      {\n+        hb_ot_name_entry_t *entry = this->names.push ();\n+\n+        entry->name_id = all_names[i].nameID;\n+        entry->language = all_names[i].language (face);\n+        entry->entry_score =  all_names[i].score ();\n+        entry->entry_index = i;\n+      }\n+\n+      this->names.qsort (_hb_ot_name_entry_cmp);\n+      \/* Walk and pick best only for each name_id,language pair,\n+       * while dropping unsupported encodings. *\/\n+      unsigned int j = 0;\n+      for (unsigned int i = 0; i < this->names.length; i++)\n+      {\n+        if (this->names[i].entry_score == UNSUPPORTED ||\n+            this->names[i].language == HB_LANGUAGE_INVALID)\n+          continue;\n+        if (i &&\n+            this->names[i - 1].name_id  == this->names[i].name_id &&\n+            this->names[i - 1].language == this->names[i].language)\n+          continue;\n+        this->names[j++] = this->names[i];\n+      }\n+      this->names.resize (j);\n+    }\n+\n+    void fini ()\n+    {\n+      this->names.fini ();\n+      this->table.destroy ();\n+    }\n+\n+    int get_index (hb_ot_name_id_t   name_id,\n+                          hb_language_t     language,\n+                          unsigned int     *width=nullptr) const\n+    {\n+      const hb_ot_name_entry_t key = {name_id, {0}, language};\n+      const hb_ot_name_entry_t *entry = (const hb_ot_name_entry_t *)\n+                                        hb_bsearch (&key,\n+                                                    (const hb_ot_name_entry_t *) this->names,\n+                                                    this->names.length,\n+                                                    sizeof (key),\n+                                                    _hb_ot_name_entry_cmp_key);\n+      if (!entry)\n+        return -1;\n+\n+      if (width)\n+        *width = entry->entry_score < 10 ? 2 : 1;\n+\n+      return entry->entry_index;\n+    }\n+\n+    hb_bytes_t get_name (unsigned int idx) const\n+    {\n+      const hb_array_t<const NameRecord> all_names (table->nameRecordZ.arrayZ, table->count);\n+      const NameRecord &record = all_names[idx];\n+      const hb_bytes_t string_pool (pool, pool_len);\n+      return string_pool.sub_array (record.offset, record.length);\n+    }\n+\n+    private:\n+    const char *pool;\n+    unsigned int pool_len;\n+    public:\n+    hb_blob_ptr_t<name> table;\n+    hb_vector_t<hb_ot_name_entry_t> names;\n+  };\n+\n+  \/* We only implement format 0 for now. *\/\n+  HBUINT16      format;                 \/* Format selector (=0\/1). *\/\n+  HBUINT16      count;                  \/* Number of name records. *\/\n+  NNOffsetTo<UnsizedArrayOf<HBUINT8> >\n+                stringOffset;           \/* Offset to start of string storage (from start of table). *\/\n+  UnsizedArrayOf<NameRecord>\n+                nameRecordZ;            \/* The name records where count is the number of records. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (6, nameRecordZ);\n+};\n+\n+struct name_accelerator_t : name::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_NAME_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-name-table.hh","additions":279,"deletions":0,"binary":false,"changes":279,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-name-table.hh\"\n+\n+#include \"hb-ot-face.hh\"\n+#include \"hb-utf.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-ot-name\n+ * @title: hb-ot-name\n+ * @short_description: OpenType font name information\n+ * @include: hb-ot.h\n+ *\n+ * Functions for fetching name strings from OpenType fonts.\n+ **\/\n+\n+\n+\/**\n+ * hb_ot_name_list_names:\n+ * @face: font face.\n+ * @num_entries: (out) (allow-none): number of returned entries.\n+ *\n+ * Enumerates all available name IDs and language combinations. Returned\n+ * array is owned by the @face and should not be modified.  It can be\n+ * used as long as @face is alive.\n+ *\n+ * Returns: (out) (transfer none) (array length=num_entries): Array of available name entries.\n+ * Since: 2.1.0\n+ **\/\n+const hb_ot_name_entry_t *\n+hb_ot_name_list_names (hb_face_t    *face,\n+                       unsigned int *num_entries \/* OUT *\/)\n+{\n+  const OT::name_accelerator_t &name = *face->table.name;\n+  if (num_entries) *num_entries = name.names.length;\n+  return (const hb_ot_name_entry_t *) name.names;\n+}\n+\n+\n+template <typename in_utf_t, typename out_utf_t>\n+static inline unsigned int\n+hb_ot_name_convert_utf (hb_bytes_t                       bytes,\n+                        unsigned int                    *text_size \/* IN\/OUT *\/,\n+                        typename out_utf_t::codepoint_t *text \/* OUT *\/)\n+{\n+  unsigned int src_len = bytes.length \/ sizeof (typename in_utf_t::codepoint_t);\n+  const typename in_utf_t::codepoint_t *src = (const typename in_utf_t::codepoint_t *) bytes.arrayZ;\n+  const typename in_utf_t::codepoint_t *src_end = src + src_len;\n+\n+  typename out_utf_t::codepoint_t *dst = text;\n+\n+  hb_codepoint_t unicode;\n+  const hb_codepoint_t replacement = HB_BUFFER_REPLACEMENT_CODEPOINT_DEFAULT;\n+\n+  if (text_size && *text_size)\n+  {\n+    (*text_size)--; \/* Same room for NUL-termination. *\/\n+    const typename out_utf_t::codepoint_t *dst_end = text + *text_size;\n+\n+    while (src < src_end && dst < dst_end)\n+    {\n+      const typename in_utf_t::codepoint_t *src_next = in_utf_t::next (src, src_end, &unicode, replacement);\n+      typename out_utf_t::codepoint_t *dst_next = out_utf_t::encode (dst, dst_end, unicode);\n+      if (dst_next == dst)\n+        break; \/* Out-of-room. *\/\n+\n+      dst = dst_next;\n+      src = src_next;\n+    };\n+\n+    *text_size = dst - text;\n+    *dst = 0; \/* NUL-terminate. *\/\n+  }\n+\n+  \/* Accumulate length of rest. *\/\n+  unsigned int dst_len = dst - text;\n+  while (src < src_end)\n+  {\n+    src = in_utf_t::next (src, src_end, &unicode, replacement);\n+    dst_len += out_utf_t::encode_len (unicode);\n+  };\n+  return dst_len;\n+}\n+\n+template <typename utf_t>\n+static inline unsigned int\n+hb_ot_name_get_utf (hb_face_t       *face,\n+                    hb_ot_name_id_t  name_id,\n+                    hb_language_t    language,\n+                    unsigned int    *text_size \/* IN\/OUT *\/,\n+                    typename utf_t::codepoint_t *text \/* OUT *\/)\n+{\n+  const OT::name_accelerator_t &name = *face->table.name;\n+\n+  if (!language)\n+    language = hb_language_from_string (\"en\", 2);\n+\n+  unsigned int width;\n+  int idx = name.get_index (name_id, language, &width);\n+  if (idx != -1)\n+  {\n+    hb_bytes_t bytes = name.get_name (idx);\n+\n+    if (width == 2) \/* UTF16-BE *\/\n+      return hb_ot_name_convert_utf<hb_utf16_be_t, utf_t> (bytes, text_size, text);\n+\n+    if (width == 1) \/* ASCII *\/\n+      return hb_ot_name_convert_utf<hb_ascii_t, utf_t> (bytes, text_size, text);\n+  }\n+\n+  if (text_size)\n+  {\n+    if (*text_size)\n+      *text = 0;\n+    *text_size = 0;\n+  }\n+  return 0;\n+}\n+\n+\/**\n+ * hb_ot_name_get_utf8:\n+ * @face: font face.\n+ * @name_id: OpenType name identifier to fetch.\n+ * @language: language to fetch the name for.\n+ * @text_size: (inout) (allow-none): input size of @text buffer, and output size of\n+ *                                   text written to buffer.\n+ * @text: (out caller-allocates) (array length=text_size): buffer to write fetched name into.\n+ *\n+ * Fetches a font name from the OpenType 'name' table.\n+ * If @language is #HB_LANGUAGE_INVALID, English (\"en\") is assumed.\n+ * Returns string in UTF-8 encoding.\n+ *\n+ * Returns: full length of the requested string, or 0 if not found.\n+ * Since: 2.1.0\n+ **\/\n+unsigned int\n+hb_ot_name_get_utf8 (hb_face_t       *face,\n+                     hb_ot_name_id_t  name_id,\n+                     hb_language_t    language,\n+                     unsigned int    *text_size \/* IN\/OUT *\/,\n+                     char            *text      \/* OUT *\/)\n+{\n+  return hb_ot_name_get_utf<hb_utf8_t> (face, name_id, language, text_size,\n+                                        (hb_utf8_t::codepoint_t *) text);\n+}\n+\n+\/**\n+ * hb_ot_name_get_utf16:\n+ * @face: font face.\n+ * @name_id: OpenType name identifier to fetch.\n+ * @language: language to fetch the name for.\n+ * @text_size: (inout) (allow-none): input size of @text buffer, and output size of\n+ *                                   text written to buffer.\n+ * @text: (out caller-allocates) (array length=text_size): buffer to write fetched name into.\n+ *\n+ * Fetches a font name from the OpenType 'name' table.\n+ * If @language is #HB_LANGUAGE_INVALID, English (\"en\") is assumed.\n+ * Returns string in UTF-16 encoding.\n+ *\n+ * Returns: full length of the requested string, or 0 if not found.\n+ * Since: 2.1.0\n+ **\/\n+unsigned int\n+hb_ot_name_get_utf16 (hb_face_t       *face,\n+                      hb_ot_name_id_t  name_id,\n+                      hb_language_t    language,\n+                      unsigned int    *text_size \/* IN\/OUT *\/,\n+                      uint16_t        *text      \/* OUT *\/)\n+{\n+  return hb_ot_name_get_utf<hb_utf16_t> (face, name_id, language, text_size, text);\n+}\n+\n+\/**\n+ * hb_ot_name_get_utf32:\n+ * @face: font face.\n+ * @name_id: OpenType name identifier to fetch.\n+ * @language: language to fetch the name for.\n+ * @text_size: (inout) (allow-none): input size of @text buffer, and output size of\n+ *                                   text written to buffer.\n+ * @text: (out caller-allocates) (array length=text_size): buffer to write fetched name into.\n+ *\n+ * Fetches a font name from the OpenType 'name' table.\n+ * If @language is #HB_LANGUAGE_INVALID, English (\"en\") is assumed.\n+ * Returns string in UTF-32 encoding.\n+ *\n+ * Returns: full length of the requested string, or 0 if not found.\n+ * Since: 2.1.0\n+ **\/\n+unsigned int\n+hb_ot_name_get_utf32 (hb_face_t       *face,\n+                      hb_ot_name_id_t  name_id,\n+                      hb_language_t    language,\n+                      unsigned int    *text_size \/* IN\/OUT *\/,\n+                      uint32_t        *text      \/* OUT *\/)\n+{\n+  return hb_ot_name_get_utf<hb_utf32_t> (face, name_id, language, text_size, text);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-name.cc","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_NAME_H\n+#define HB_OT_NAME_H\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/**\n+ * hb_ot_name_id_t:\n+ * @HB_OT_NAME_ID_INVALID: Value to represent a nonexistent name ID.\n+ *\n+ * An integral type representing an OpenType 'name' table name identifier.\n+ * There are predefined name IDs, as well as name IDs return from other\n+ * API.  These can be used to fetch name strings from a font face.\n+ *\n+ * Since: 2.0.0\n+ **\/\n+enum\n+{\n+  HB_OT_NAME_ID_COPYRIGHT               = 0,\n+  HB_OT_NAME_ID_FONT_FAMILY             = 1,\n+  HB_OT_NAME_ID_FONT_SUBFAMILY          = 2,\n+  HB_OT_NAME_ID_UNIQUE_ID               = 3,\n+  HB_OT_NAME_ID_FULL_NAME               = 4,\n+  HB_OT_NAME_ID_VERSION_STRING          = 5,\n+  HB_OT_NAME_ID_POSTSCRIPT_NAME         = 6,\n+  HB_OT_NAME_ID_TRADEMARK               = 7,\n+  HB_OT_NAME_ID_MANUFACTURER            = 8,\n+  HB_OT_NAME_ID_DESIGNER                = 9,\n+  HB_OT_NAME_ID_DESCRIPTION             = 10,\n+  HB_OT_NAME_ID_VENDOR_URL              = 11,\n+  HB_OT_NAME_ID_DESIGNER_URL            = 12,\n+  HB_OT_NAME_ID_LICENSE                 = 13,\n+  HB_OT_NAME_ID_LICENSE_URL             = 14,\n+\/*HB_OT_NAME_ID_RESERVED                = 15,*\/\n+  HB_OT_NAME_ID_TYPOGRAPHIC_FAMILY      = 16,\n+  HB_OT_NAME_ID_TYPOGRAPHIC_SUBFAMILY   = 17,\n+  HB_OT_NAME_ID_MAC_FULL_NAME           = 18,\n+  HB_OT_NAME_ID_SAMPLE_TEXT             = 19,\n+  HB_OT_NAME_ID_CID_FINDFONT_NAME       = 20,\n+  HB_OT_NAME_ID_WWS_FAMILY              = 21,\n+  HB_OT_NAME_ID_WWS_SUBFAMILY           = 22,\n+  HB_OT_NAME_ID_LIGHT_BACKGROUND        = 23,\n+  HB_OT_NAME_ID_DARK_BACKGROUND         = 24,\n+  HB_OT_NAME_ID_VARIATIONS_PS_PREFIX    = 25,\n+\n+  HB_OT_NAME_ID_INVALID                 = 0xFFFF\n+};\n+\n+typedef unsigned int hb_ot_name_id_t;\n+\n+\n+\/**\n+ * hb_ot_name_entry_t:\n+ * @name_id: name ID\n+ * @language: language\n+ *\n+ * Structure representing a name ID in a particular language.\n+ *\n+ * Since: 2.1.0\n+ **\/\n+typedef struct hb_ot_name_entry_t\n+{\n+  hb_ot_name_id_t name_id;\n+  \/*< private >*\/\n+  hb_var_int_t    var;\n+  \/*< public >*\/\n+  hb_language_t   language;\n+} hb_ot_name_entry_t;\n+\n+HB_EXTERN const hb_ot_name_entry_t *\n+hb_ot_name_list_names (hb_face_t    *face,\n+                       unsigned int *num_entries \/* OUT *\/);\n+\n+\n+HB_EXTERN unsigned int\n+hb_ot_name_get_utf8 (hb_face_t       *face,\n+                     hb_ot_name_id_t  name_id,\n+                     hb_language_t    language,\n+                     unsigned int    *text_size \/* IN\/OUT *\/,\n+                     char            *text      \/* OUT *\/);\n+\n+HB_EXTERN unsigned int\n+hb_ot_name_get_utf16 (hb_face_t       *face,\n+                      hb_ot_name_id_t  name_id,\n+                      hb_language_t    language,\n+                      unsigned int    *text_size \/* IN\/OUT *\/,\n+                      uint16_t        *text      \/* OUT *\/);\n+\n+HB_EXTERN unsigned int\n+hb_ot_name_get_utf32 (hb_face_t       *face,\n+                      hb_ot_name_id_t  name_id,\n+                      hb_language_t    language,\n+                      unsigned int    *text_size \/* IN\/OUT *\/,\n+                      uint32_t        *text      \/* OUT *\/);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_NAME_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-name.h","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_OS2_TABLE_HH\n+#define HB_OT_OS2_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-os2-unicode-ranges.hh\"\n+\n+#include \"hb-set.hh\"\n+\n+\/*\n+ * OS\/2 and Windows Metrics\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/os2\n+ *\/\n+#define HB_OT_TAG_OS2 HB_TAG('O','S','\/','2')\n+\n+\n+namespace OT {\n+\n+struct OS2V1Tail\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBUINT32      ulCodePageRange1;\n+  HBUINT32      ulCodePageRange2;\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct OS2V2Tail\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBINT16       sxHeight;\n+  HBINT16       sCapHeight;\n+  HBUINT16      usDefaultChar;\n+  HBUINT16      usBreakChar;\n+  HBUINT16      usMaxContext;\n+  public:\n+  DEFINE_SIZE_STATIC (10);\n+};\n+\n+struct OS2V5Tail\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  HBUINT16      usLowerOpticalPointSize;\n+  HBUINT16      usUpperOpticalPointSize;\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct OS2\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_OS2;\n+\n+  bool has_data () const { return this != &Null (OS2); }\n+\n+  const OS2V1Tail &v1 () const { return version >= 1 ? v1X : Null (OS2V1Tail); }\n+  const OS2V2Tail &v2 () const { return version >= 2 ? v2X : Null (OS2V2Tail); }\n+  const OS2V5Tail &v5 () const { return version >= 5 ? v5X : Null (OS2V5Tail); }\n+\n+  enum selection_flag_t {\n+    ITALIC              = 1u<<0,\n+    UNDERSCORE          = 1u<<1,\n+    NEGATIVE            = 1u<<2,\n+    OUTLINED            = 1u<<3,\n+    STRIKEOUT           = 1u<<4,\n+    BOLD                = 1u<<5,\n+    REGULAR             = 1u<<6,\n+    USE_TYPO_METRICS    = 1u<<7,\n+    WWS                 = 1u<<8,\n+    OBLIQUE             = 1u<<9\n+  };\n+\n+  bool is_italic () const       { return fsSelection & ITALIC; }\n+  bool is_oblique () const      { return fsSelection & OBLIQUE; }\n+  bool is_typo_metrics () const { return fsSelection & USE_TYPO_METRICS; }\n+\n+  enum width_class_t {\n+    FWIDTH_ULTRA_CONDENSED      = 1, \/* 50% *\/\n+    FWIDTH_EXTRA_CONDENSED      = 2, \/* 62.5% *\/\n+    FWIDTH_CONDENSED            = 3, \/* 75% *\/\n+    FWIDTH_SEMI_CONDENSED       = 4, \/* 87.5% *\/\n+    FWIDTH_NORMAL               = 5, \/* 100% *\/\n+    FWIDTH_SEMI_EXPANDED        = 6, \/* 112.5% *\/\n+    FWIDTH_EXPANDED             = 7, \/* 125% *\/\n+    FWIDTH_EXTRA_EXPANDED       = 8, \/* 150% *\/\n+    FWIDTH_ULTRA_EXPANDED       = 9  \/* 200% *\/\n+  };\n+\n+  float get_width () const\n+  {\n+    switch (usWidthClass) {\n+    case FWIDTH_ULTRA_CONDENSED:return 50.f;\n+    case FWIDTH_EXTRA_CONDENSED:return 62.5f;\n+    case FWIDTH_CONDENSED:      return 75.f;\n+    case FWIDTH_SEMI_CONDENSED: return 87.5f;\n+    default:\n+    case FWIDTH_NORMAL:         return 100.f;\n+    case FWIDTH_SEMI_EXPANDED:  return 112.5f;\n+    case FWIDTH_EXPANDED:       return 125.f;\n+    case FWIDTH_EXTRA_EXPANDED: return 150.f;\n+    case FWIDTH_ULTRA_EXPANDED: return 200.f;\n+    }\n+  }\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    hb_blob_t *os2_blob = hb_sanitize_context_t ().reference_table<OS2> (plan->source);\n+    hb_blob_t *os2_prime_blob = hb_blob_create_sub_blob (os2_blob, 0, -1);\n+    \/\/ TODO(grieger): move to hb_blob_copy_writable_or_fail\n+    hb_blob_destroy (os2_blob);\n+\n+    OS2 *os2_prime = (OS2 *) hb_blob_get_data_writable (os2_prime_blob, nullptr);\n+    if (unlikely (!os2_prime)) {\n+      hb_blob_destroy (os2_prime_blob);\n+      return false;\n+    }\n+\n+    uint16_t min_cp, max_cp;\n+    find_min_and_max_codepoint (plan->unicodes, &min_cp, &max_cp);\n+    os2_prime->usFirstCharIndex.set (min_cp);\n+    os2_prime->usLastCharIndex.set (max_cp);\n+\n+    _update_unicode_ranges (plan->unicodes, os2_prime->ulUnicodeRange);\n+    bool result = plan->add_table (HB_OT_TAG_OS2, os2_prime_blob);\n+\n+    hb_blob_destroy (os2_prime_blob);\n+    return result;\n+  }\n+\n+  void _update_unicode_ranges (const hb_set_t *codepoints,\n+                               HBUINT32 ulUnicodeRange[4]) const\n+  {\n+    for (unsigned int i = 0; i < 4; i++)\n+      ulUnicodeRange[i].set (0);\n+\n+    hb_codepoint_t cp = HB_SET_VALUE_INVALID;\n+    while (codepoints->next (&cp)) {\n+      unsigned int bit = _hb_ot_os2_get_unicode_range_bit (cp);\n+      if (bit < 128)\n+      {\n+        unsigned int block = bit \/ 32;\n+        unsigned int bit_in_block = bit % 32;\n+        unsigned int mask = 1 << bit_in_block;\n+        ulUnicodeRange[block].set (ulUnicodeRange[block] | mask);\n+      }\n+      if (cp >= 0x10000 && cp <= 0x110000)\n+      {\n+        \/* the spec says that bit 57 (\"Non Plane 0\") implies that there's\n+           at least one codepoint beyond the BMP; so I also include all\n+           the non-BMP codepoints here *\/\n+        ulUnicodeRange[1].set (ulUnicodeRange[1] | (1 << 25));\n+      }\n+    }\n+  }\n+\n+  static void find_min_and_max_codepoint (const hb_set_t *codepoints,\n+                                                 uint16_t *min_cp, \/* OUT *\/\n+                                                 uint16_t *max_cp  \/* OUT *\/)\n+  {\n+    *min_cp = codepoints->get_min ();\n+    *max_cp = codepoints->get_max ();\n+  }\n+\n+  enum font_page_t {\n+    HEBREW_FONT_PAGE            = 0xB100, \/\/ Hebrew Windows 3.1 font page\n+    SIMP_ARABIC_FONT_PAGE       = 0xB200, \/\/ Simplified Arabic Windows 3.1 font page\n+    TRAD_ARABIC_FONT_PAGE       = 0xB300, \/\/ Traditional Arabic Windows 3.1 font page\n+    OEM_ARABIC_FONT_PAGE        = 0xB400, \/\/ OEM Arabic Windows 3.1 font page\n+    SIMP_FARSI_FONT_PAGE        = 0xBA00, \/\/ Simplified Farsi Windows 3.1 font page\n+    TRAD_FARSI_FONT_PAGE        = 0xBB00, \/\/ Traditional Farsi Windows 3.1 font page\n+    THAI_FONT_PAGE              = 0xDE00  \/\/ Thai Windows 3.1 font page\n+  };\n+\n+  \/\/ https:\/\/github.com\/Microsoft\/Font-Validator\/blob\/520aaae\/OTFontFileVal\/val_OS2.cs#L644-L681\n+  font_page_t get_font_page () const\n+  { return (font_page_t) (version == 0 ? fsSelection & 0xFF00 : 0); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this))) return_trace (false);\n+    if (unlikely (version >= 1 && !v1X.sanitize (c))) return_trace (false);\n+    if (unlikely (version >= 2 && !v2X.sanitize (c))) return_trace (false);\n+    if (unlikely (version >= 5 && !v5X.sanitize (c))) return_trace (false);\n+    return_trace (true);\n+  }\n+\n+  public:\n+  HBUINT16      version;\n+  HBINT16       xAvgCharWidth;\n+  HBUINT16      usWeightClass;\n+  HBUINT16      usWidthClass;\n+  HBUINT16      fsType;\n+  HBINT16       ySubscriptXSize;\n+  HBINT16       ySubscriptYSize;\n+  HBINT16       ySubscriptXOffset;\n+  HBINT16       ySubscriptYOffset;\n+  HBINT16       ySuperscriptXSize;\n+  HBINT16       ySuperscriptYSize;\n+  HBINT16       ySuperscriptXOffset;\n+  HBINT16       ySuperscriptYOffset;\n+  HBINT16       yStrikeoutSize;\n+  HBINT16       yStrikeoutPosition;\n+  HBINT16       sFamilyClass;\n+  HBUINT8       panose[10];\n+  HBUINT32      ulUnicodeRange[4];\n+  Tag           achVendID;\n+  HBUINT16      fsSelection;\n+  HBUINT16      usFirstCharIndex;\n+  HBUINT16      usLastCharIndex;\n+  HBINT16       sTypoAscender;\n+  HBINT16       sTypoDescender;\n+  HBINT16       sTypoLineGap;\n+  HBUINT16      usWinAscent;\n+  HBUINT16      usWinDescent;\n+  OS2V1Tail     v1X;\n+  OS2V2Tail     v2X;\n+  OS2V5Tail     v5X;\n+  public:\n+  DEFINE_SIZE_MIN (78);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_OS2_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-os2-table.hh","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -0,0 +1,247 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef HB_OT_OS2_UNICODE_RANGES_HH\n+#define HB_OT_OS2_UNICODE_RANGES_HH\n+\n+#include \"hb.hh\"\n+\n+namespace OT {\n+\n+struct OS2Range\n+{\n+  static int\n+  cmp (const void *_key, const void *_item)\n+  {\n+    hb_codepoint_t cp = *((hb_codepoint_t *) _key);\n+    const OS2Range *range = (OS2Range *) _item;\n+\n+    if (cp < range->start)\n+      return -1;\n+    else if (cp <= range->end)\n+      return 0;\n+    else\n+      return +1;\n+  }\n+\n+  hb_codepoint_t start;\n+  hb_codepoint_t end;\n+  unsigned int bit;\n+};\n+\n+\/* Note: The contents of this array was generated using gen-os2-unicode-ranges.py. *\/\n+static const OS2Range _hb_os2_unicode_ranges[] =\n+{\n+  {     0x0,     0x7F,   0}, \/\/ Basic Latin\n+  {    0x80,     0xFF,   1}, \/\/ Latin-1 Supplement\n+  {   0x100,    0x17F,   2}, \/\/ Latin Extended-A\n+  {   0x180,    0x24F,   3}, \/\/ Latin Extended-B\n+  {   0x250,    0x2AF,   4}, \/\/ IPA Extensions\n+  {   0x2B0,    0x2FF,   5}, \/\/ Spacing Modifier Letters\n+  {   0x300,    0x36F,   6}, \/\/ Combining Diacritical Marks\n+  {   0x370,    0x3FF,   7}, \/\/ Greek and Coptic\n+  {   0x400,    0x4FF,   9}, \/\/ Cyrillic\n+  {   0x500,    0x52F,   9}, \/\/ Cyrillic Supplement\n+  {   0x530,    0x58F,  10}, \/\/ Armenian\n+  {   0x590,    0x5FF,  11}, \/\/ Hebrew\n+  {   0x600,    0x6FF,  13}, \/\/ Arabic\n+  {   0x700,    0x74F,  71}, \/\/ Syriac\n+  {   0x750,    0x77F,  13}, \/\/ Arabic Supplement\n+  {   0x780,    0x7BF,  72}, \/\/ Thaana\n+  {   0x7C0,    0x7FF,  14}, \/\/ NKo\n+  {   0x900,    0x97F,  15}, \/\/ Devanagari\n+  {   0x980,    0x9FF,  16}, \/\/ Bengali\n+  {   0xA00,    0xA7F,  17}, \/\/ Gurmukhi\n+  {   0xA80,    0xAFF,  18}, \/\/ Gujarati\n+  {   0xB00,    0xB7F,  19}, \/\/ Oriya\n+  {   0xB80,    0xBFF,  20}, \/\/ Tamil\n+  {   0xC00,    0xC7F,  21}, \/\/ Telugu\n+  {   0xC80,    0xCFF,  22}, \/\/ Kannada\n+  {   0xD00,    0xD7F,  23}, \/\/ Malayalam\n+  {   0xD80,    0xDFF,  73}, \/\/ Sinhala\n+  {   0xE00,    0xE7F,  24}, \/\/ Thai\n+  {   0xE80,    0xEFF,  25}, \/\/ Lao\n+  {   0xF00,    0xFFF,  70}, \/\/ Tibetan\n+  {  0x1000,   0x109F,  74}, \/\/ Myanmar\n+  {  0x10A0,   0x10FF,  26}, \/\/ Georgian\n+  {  0x1100,   0x11FF,  28}, \/\/ Hangul Jamo\n+  {  0x1200,   0x137F,  75}, \/\/ Ethiopic\n+  {  0x1380,   0x139F,  75}, \/\/ Ethiopic Supplement\n+  {  0x13A0,   0x13FF,  76}, \/\/ Cherokee\n+  {  0x1400,   0x167F,  77}, \/\/ Unified Canadian Aboriginal Syllabics\n+  {  0x1680,   0x169F,  78}, \/\/ Ogham\n+  {  0x16A0,   0x16FF,  79}, \/\/ Runic\n+  {  0x1700,   0x171F,  84}, \/\/ Tagalog\n+  {  0x1720,   0x173F,  84}, \/\/ Hanunoo\n+  {  0x1740,   0x175F,  84}, \/\/ Buhid\n+  {  0x1760,   0x177F,  84}, \/\/ Tagbanwa\n+  {  0x1780,   0x17FF,  80}, \/\/ Khmer\n+  {  0x1800,   0x18AF,  81}, \/\/ Mongolian\n+  {  0x1900,   0x194F,  93}, \/\/ Limbu\n+  {  0x1950,   0x197F,  94}, \/\/ Tai Le\n+  {  0x1980,   0x19DF,  95}, \/\/ New Tai Lue\n+  {  0x19E0,   0x19FF,  80}, \/\/ Khmer Symbols\n+  {  0x1A00,   0x1A1F,  96}, \/\/ Buginese\n+  {  0x1B00,   0x1B7F,  27}, \/\/ Balinese\n+  {  0x1B80,   0x1BBF, 112}, \/\/ Sundanese\n+  {  0x1C00,   0x1C4F, 113}, \/\/ Lepcha\n+  {  0x1C50,   0x1C7F, 114}, \/\/ Ol Chiki\n+  {  0x1D00,   0x1D7F,   4}, \/\/ Phonetic Extensions\n+  {  0x1D80,   0x1DBF,   4}, \/\/ Phonetic Extensions Supplement\n+  {  0x1DC0,   0x1DFF,   6}, \/\/ Combining Diacritical Marks Supplement\n+  {  0x1E00,   0x1EFF,  29}, \/\/ Latin Extended Additional\n+  {  0x1F00,   0x1FFF,  30}, \/\/ Greek Extended\n+  {  0x2000,   0x206F,  31}, \/\/ General Punctuation\n+  {  0x2070,   0x209F,  32}, \/\/ Superscripts And Subscripts\n+  {  0x20A0,   0x20CF,  33}, \/\/ Currency Symbols\n+  {  0x20D0,   0x20FF,  34}, \/\/ Combining Diacritical Marks For Symbols\n+  {  0x2100,   0x214F,  35}, \/\/ Letterlike Symbols\n+  {  0x2150,   0x218F,  36}, \/\/ Number Forms\n+  {  0x2190,   0x21FF,  37}, \/\/ Arrows\n+  {  0x2200,   0x22FF,  38}, \/\/ Mathematical Operators\n+  {  0x2300,   0x23FF,  39}, \/\/ Miscellaneous Technical\n+  {  0x2400,   0x243F,  40}, \/\/ Control Pictures\n+  {  0x2440,   0x245F,  41}, \/\/ Optical Character Recognition\n+  {  0x2460,   0x24FF,  42}, \/\/ Enclosed Alphanumerics\n+  {  0x2500,   0x257F,  43}, \/\/ Box Drawing\n+  {  0x2580,   0x259F,  44}, \/\/ Block Elements\n+  {  0x25A0,   0x25FF,  45}, \/\/ Geometric Shapes\n+  {  0x2600,   0x26FF,  46}, \/\/ Miscellaneous Symbols\n+  {  0x2700,   0x27BF,  47}, \/\/ Dingbats\n+  {  0x27C0,   0x27EF,  38}, \/\/ Miscellaneous Mathematical Symbols-A\n+  {  0x27F0,   0x27FF,  37}, \/\/ Supplemental Arrows-A\n+  {  0x2800,   0x28FF,  82}, \/\/ Braille Patterns\n+  {  0x2900,   0x297F,  37}, \/\/ Supplemental Arrows-B\n+  {  0x2980,   0x29FF,  38}, \/\/ Miscellaneous Mathematical Symbols-B\n+  {  0x2A00,   0x2AFF,  38}, \/\/ Supplemental Mathematical Operators\n+  {  0x2B00,   0x2BFF,  37}, \/\/ Miscellaneous Symbols and Arrows\n+  {  0x2C00,   0x2C5F,  97}, \/\/ Glagolitic\n+  {  0x2C60,   0x2C7F,  29}, \/\/ Latin Extended-C\n+  {  0x2C80,   0x2CFF,   8}, \/\/ Coptic\n+  {  0x2D00,   0x2D2F,  26}, \/\/ Georgian Supplement\n+  {  0x2D30,   0x2D7F,  98}, \/\/ Tifinagh\n+  {  0x2D80,   0x2DDF,  75}, \/\/ Ethiopic Extended\n+  {  0x2DE0,   0x2DFF,   9}, \/\/ Cyrillic Extended-A\n+  {  0x2E00,   0x2E7F,  31}, \/\/ Supplemental Punctuation\n+  {  0x2E80,   0x2EFF,  59}, \/\/ CJK Radicals Supplement\n+  {  0x2F00,   0x2FDF,  59}, \/\/ Kangxi Radicals\n+  {  0x2FF0,   0x2FFF,  59}, \/\/ Ideographic Description Characters\n+  {  0x3000,   0x303F,  48}, \/\/ CJK Symbols And Punctuation\n+  {  0x3040,   0x309F,  49}, \/\/ Hiragana\n+  {  0x30A0,   0x30FF,  50}, \/\/ Katakana\n+  {  0x3100,   0x312F,  51}, \/\/ Bopomofo\n+  {  0x3130,   0x318F,  52}, \/\/ Hangul Compatibility Jamo\n+  {  0x3190,   0x319F,  59}, \/\/ Kanbun\n+  {  0x31A0,   0x31BF,  51}, \/\/ Bopomofo Extended\n+  {  0x31C0,   0x31EF,  61}, \/\/ CJK Strokes\n+  {  0x31F0,   0x31FF,  50}, \/\/ Katakana Phonetic Extensions\n+  {  0x3200,   0x32FF,  54}, \/\/ Enclosed CJK Letters And Months\n+  {  0x3300,   0x33FF,  55}, \/\/ CJK Compatibility\n+  {  0x3400,   0x4DBF,  59}, \/\/ CJK Unified Ideographs Extension A\n+  {  0x4DC0,   0x4DFF,  99}, \/\/ Yijing Hexagram Symbols\n+  {  0x4E00,   0x9FFF,  59}, \/\/ CJK Unified Ideographs\n+  {  0xA000,   0xA48F,  83}, \/\/ Yi Syllables\n+  {  0xA490,   0xA4CF,  83}, \/\/ Yi Radicals\n+  {  0xA500,   0xA63F,  12}, \/\/ Vai\n+  {  0xA640,   0xA69F,   9}, \/\/ Cyrillic Extended-B\n+  {  0xA700,   0xA71F,   5}, \/\/ Modifier Tone Letters\n+  {  0xA720,   0xA7FF,  29}, \/\/ Latin Extended-D\n+  {  0xA800,   0xA82F, 100}, \/\/ Syloti Nagri\n+  {  0xA840,   0xA87F,  53}, \/\/ Phags-pa\n+  {  0xA880,   0xA8DF, 115}, \/\/ Saurashtra\n+  {  0xA900,   0xA92F, 116}, \/\/ Kayah Li\n+  {  0xA930,   0xA95F, 117}, \/\/ Rejang\n+  {  0xAA00,   0xAA5F, 118}, \/\/ Cham\n+  {  0xAC00,   0xD7AF,  56}, \/\/ Hangul Syllables\n+  {  0xD800,   0xDFFF,  57}, \/\/ Non-Plane 0 *\n+  {  0xE000,   0xF8FF,  60}, \/\/ Private Use Area (plane 0)\n+  {  0xF900,   0xFAFF,  61}, \/\/ CJK Compatibility Ideographs\n+  {  0xFB00,   0xFB4F,  62}, \/\/ Alphabetic Presentation Forms\n+  {  0xFB50,   0xFDFF,  63}, \/\/ Arabic Presentation Forms-A\n+  {  0xFE00,   0xFE0F,  91}, \/\/ Variation Selectors\n+  {  0xFE10,   0xFE1F,  65}, \/\/ Vertical Forms\n+  {  0xFE20,   0xFE2F,  64}, \/\/ Combining Half Marks\n+  {  0xFE30,   0xFE4F,  65}, \/\/ CJK Compatibility Forms\n+  {  0xFE50,   0xFE6F,  66}, \/\/ Small Form Variants\n+  {  0xFE70,   0xFEFF,  67}, \/\/ Arabic Presentation Forms-B\n+  {  0xFF00,   0xFFEF,  68}, \/\/ Halfwidth And Fullwidth Forms\n+  {  0xFFF0,   0xFFFF,  69}, \/\/ Specials\n+  { 0x10000,  0x1007F, 101}, \/\/ Linear B Syllabary\n+  { 0x10080,  0x100FF, 101}, \/\/ Linear B Ideograms\n+  { 0x10100,  0x1013F, 101}, \/\/ Aegean Numbers\n+  { 0x10140,  0x1018F, 102}, \/\/ Ancient Greek Numbers\n+  { 0x10190,  0x101CF, 119}, \/\/ Ancient Symbols\n+  { 0x101D0,  0x101FF, 120}, \/\/ Phaistos Disc\n+  { 0x10280,  0x1029F, 121}, \/\/ Lycian\n+  { 0x102A0,  0x102DF, 121}, \/\/ Carian\n+  { 0x10300,  0x1032F,  85}, \/\/ Old Italic\n+  { 0x10330,  0x1034F,  86}, \/\/ Gothic\n+  { 0x10380,  0x1039F, 103}, \/\/ Ugaritic\n+  { 0x103A0,  0x103DF, 104}, \/\/ Old Persian\n+  { 0x10400,  0x1044F,  87}, \/\/ Deseret\n+  { 0x10450,  0x1047F, 105}, \/\/ Shavian\n+  { 0x10480,  0x104AF, 106}, \/\/ Osmanya\n+  { 0x10800,  0x1083F, 107}, \/\/ Cypriot Syllabary\n+  { 0x10900,  0x1091F,  58}, \/\/ Phoenician\n+  { 0x10920,  0x1093F, 121}, \/\/ Lydian\n+  { 0x10A00,  0x10A5F, 108}, \/\/ Kharoshthi\n+  { 0x12000,  0x123FF, 110}, \/\/ Cuneiform\n+  { 0x12400,  0x1247F, 110}, \/\/ Cuneiform Numbers and Punctuation\n+  { 0x1D000,  0x1D0FF,  88}, \/\/ Byzantine Musical Symbols\n+  { 0x1D100,  0x1D1FF,  88}, \/\/ Musical Symbols\n+  { 0x1D200,  0x1D24F,  88}, \/\/ Ancient Greek Musical Notation\n+  { 0x1D300,  0x1D35F, 109}, \/\/ Tai Xuan Jing Symbols\n+  { 0x1D360,  0x1D37F, 111}, \/\/ Counting Rod Numerals\n+  { 0x1D400,  0x1D7FF,  89}, \/\/ Mathematical Alphanumeric Symbols\n+  { 0x1F000,  0x1F02F, 122}, \/\/ Mahjong Tiles\n+  { 0x1F030,  0x1F09F, 122}, \/\/ Domino Tiles\n+  { 0x20000,  0x2A6DF,  59}, \/\/ CJK Unified Ideographs Extension B\n+  { 0x2F800,  0x2FA1F,  61}, \/\/ CJK Compatibility Ideographs Supplement\n+  { 0xE0000,  0xE007F,  92}, \/\/ Tags\n+  { 0xE0100,  0xE01EF,  91}, \/\/ Variation Selectors Supplement\n+  { 0xF0000,  0xFFFFD,  90}, \/\/ Private Use (plane 15)\n+  {0x100000, 0x10FFFD,  90}, \/\/ Private Use (plane 16)\n+};\n+\n+\/**\n+ * _hb_ot_os2_get_unicode_range_bit:\n+ * Returns the bit to be set in os\/2 ulUnicodeOS2Range for a given codepoint.\n+ **\/\n+static unsigned int\n+_hb_ot_os2_get_unicode_range_bit (hb_codepoint_t cp)\n+{\n+  OS2Range *range = (OS2Range*) hb_bsearch (&cp, _hb_os2_unicode_ranges,\n+                                            ARRAY_LENGTH (_hb_os2_unicode_ranges),\n+                                            sizeof (OS2Range),\n+                                            OS2Range::cmp);\n+  if (range != nullptr)\n+    return range->bit;\n+  return -1;\n+}\n+\n+} \/* namespace OT *\/\n+\n+#endif \/* HB_OT_OS2_UNICODE_RANGES_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-os2-unicode-ranges.hh","additions":247,"deletions":0,"binary":false,"changes":247,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-post-macroman.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-post-macroman.hh","status":"copied"},{"patch":"@@ -0,0 +1,299 @@\n+\/*\n+ * Copyright © 2016  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_POST_TABLE_HH\n+#define HB_OT_POST_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+#define HB_STRING_ARRAY_NAME format1_names\n+#define HB_STRING_ARRAY_LIST \"hb-ot-post-macroman.hh\"\n+#include \"hb-string-array.hh\"\n+#undef HB_STRING_ARRAY_LIST\n+#undef HB_STRING_ARRAY_NAME\n+\n+#define NUM_FORMAT1_NAMES 258\n+\n+\/*\n+ * post -- PostScript\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/post\n+ *\/\n+#define HB_OT_TAG_post HB_TAG('p','o','s','t')\n+\n+\n+namespace OT {\n+\n+\n+struct postV2Tail\n+{\n+  friend struct post;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (glyphNameIndex.sanitize (c));\n+  }\n+\n+  protected:\n+  ArrayOf<HBUINT16>     glyphNameIndex; \/* This is not an offset, but is the\n+                                         * ordinal number of the glyph in 'post'\n+                                         * string tables. *\/\n+\/*UnsizedArrayOf<HBUINT8>\n+                        namesX;*\/       \/* Glyph names with length bytes [variable]\n+                                         * (a Pascal string). *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (2, glyphNameIndex);\n+};\n+\n+struct post\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_post;\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    unsigned int post_prime_length;\n+    hb_blob_t *post_blob = hb_sanitize_context_t ().reference_table<post>(plan->source);\n+    hb_blob_t *post_prime_blob = hb_blob_create_sub_blob (post_blob, 0, post::min_size);\n+    post *post_prime = (post *) hb_blob_get_data_writable (post_prime_blob, &post_prime_length);\n+    hb_blob_destroy (post_blob);\n+\n+    if (unlikely (!post_prime || post_prime_length != post::min_size))\n+    {\n+      hb_blob_destroy (post_prime_blob);\n+      DEBUG_MSG(SUBSET, nullptr, \"Invalid source post table with length %d.\", post_prime_length);\n+      return false;\n+    }\n+\n+    post_prime->version.major.set (3); \/\/ Version 3 does not have any glyph names.\n+    bool result = plan->add_table (HB_OT_TAG_post, post_prime_blob);\n+    hb_blob_destroy (post_prime_blob);\n+\n+    return result;\n+  }\n+\n+  struct accelerator_t\n+  {\n+    void init (hb_face_t *face)\n+    {\n+      index_to_offset.init ();\n+\n+      table = hb_sanitize_context_t ().reference_table<post> (face);\n+      unsigned int table_length = table.get_length ();\n+\n+      version = table->version.to_int ();\n+      if (version != 0x00020000) return;\n+\n+      const postV2Tail &v2 = table->v2X;\n+\n+      glyphNameIndex = &v2.glyphNameIndex;\n+      pool = &StructAfter<uint8_t> (v2.glyphNameIndex);\n+\n+      const uint8_t *end = (const uint8_t *) (const void *) table + table_length;\n+      for (const uint8_t *data = pool;\n+           index_to_offset.length < 65535 && data < end && data + *data < end;\n+           data += 1 + *data)\n+        index_to_offset.push (data - pool);\n+    }\n+    void fini ()\n+    {\n+      index_to_offset.fini ();\n+      free (gids_sorted_by_name.get ());\n+      table.destroy ();\n+    }\n+\n+    bool get_glyph_name (hb_codepoint_t glyph,\n+                         char *buf, unsigned int buf_len) const\n+    {\n+      hb_bytes_t s = find_glyph_name (glyph);\n+      if (!s.length) return false;\n+      if (!buf_len) return true;\n+      unsigned int len = MIN (buf_len - 1, s.length);\n+      strncpy (buf, s.arrayZ, len);\n+      buf[len] = '\\0';\n+      return true;\n+    }\n+\n+    bool get_glyph_from_name (const char *name, int len,\n+                              hb_codepoint_t *glyph) const\n+    {\n+      unsigned int count = get_glyph_count ();\n+      if (unlikely (!count)) return false;\n+\n+      if (len < 0) len = strlen (name);\n+\n+      if (unlikely (!len)) return false;\n+\n+    retry:\n+      uint16_t *gids = gids_sorted_by_name.get ();\n+\n+      if (unlikely (!gids))\n+      {\n+        gids = (uint16_t *) malloc (count * sizeof (gids[0]));\n+        if (unlikely (!gids))\n+          return false; \/* Anything better?! *\/\n+\n+        for (unsigned int i = 0; i < count; i++)\n+          gids[i] = i;\n+        hb_sort_r (gids, count, sizeof (gids[0]), cmp_gids, (void *) this);\n+\n+        if (unlikely (!gids_sorted_by_name.cmpexch (nullptr, gids)))\n+        {\n+          free (gids);\n+          goto retry;\n+        }\n+      }\n+\n+      hb_bytes_t st (name, len);\n+      const uint16_t *gid = (const uint16_t *) hb_bsearch_r (hb_addressof (st), gids, count,\n+                                                             sizeof (gids[0]), cmp_key, (void *) this);\n+      if (gid)\n+      {\n+        *glyph = *gid;\n+        return true;\n+      }\n+\n+      return false;\n+    }\n+\n+    protected:\n+\n+    unsigned int get_glyph_count () const\n+    {\n+      if (version == 0x00010000)\n+        return NUM_FORMAT1_NAMES;\n+\n+      if (version == 0x00020000)\n+        return glyphNameIndex->len;\n+\n+      return 0;\n+    }\n+\n+    static int cmp_gids (const void *pa, const void *pb, void *arg)\n+    {\n+      const accelerator_t *thiz = (const accelerator_t *) arg;\n+      uint16_t a = * (const uint16_t *) pa;\n+      uint16_t b = * (const uint16_t *) pb;\n+      return thiz->find_glyph_name (b).cmp (thiz->find_glyph_name (a));\n+    }\n+\n+    static int cmp_key (const void *pk, const void *po, void *arg)\n+    {\n+      const accelerator_t *thiz = (const accelerator_t *) arg;\n+      const hb_bytes_t *key = (const hb_bytes_t *) pk;\n+      uint16_t o = * (const uint16_t *) po;\n+      return thiz->find_glyph_name (o).cmp (*key);\n+    }\n+\n+    hb_bytes_t find_glyph_name (hb_codepoint_t glyph) const\n+    {\n+      if (version == 0x00010000)\n+      {\n+        if (glyph >= NUM_FORMAT1_NAMES)\n+          return hb_bytes_t ();\n+\n+        return format1_names (glyph);\n+      }\n+\n+      if (version != 0x00020000 || glyph >= glyphNameIndex->len)\n+        return hb_bytes_t ();\n+\n+      unsigned int index = glyphNameIndex->arrayZ[glyph];\n+      if (index < NUM_FORMAT1_NAMES)\n+        return format1_names (index);\n+      index -= NUM_FORMAT1_NAMES;\n+\n+      if (index >= index_to_offset.length)\n+        return hb_bytes_t ();\n+      unsigned int offset = index_to_offset[index];\n+\n+      const uint8_t *data = pool + offset;\n+      unsigned int name_length = *data;\n+      data++;\n+\n+      return hb_bytes_t ((const char *) data, name_length);\n+    }\n+\n+    private:\n+    hb_blob_ptr_t<post> table;\n+    uint32_t version;\n+    const ArrayOf<HBUINT16> *glyphNameIndex;\n+    hb_vector_t<uint32_t> index_to_offset;\n+    const uint8_t *pool;\n+    hb_atomic_ptr_t<uint16_t *> gids_sorted_by_name;\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          (version.to_int () == 0x00010000 ||\n+                           (version.to_int () == 0x00020000 && v2X.sanitize (c)) ||\n+                           version.to_int () == 0x00030000)));\n+  }\n+\n+  public:\n+  FixedVersion<>version;                \/* 0x00010000 for version 1.0\n+                                         * 0x00020000 for version 2.0\n+                                         * 0x00025000 for version 2.5 (deprecated)\n+                                         * 0x00030000 for version 3.0 *\/\n+  Fixed         italicAngle;            \/* Italic angle in counter-clockwise degrees\n+                                         * from the vertical. Zero for upright text,\n+                                         * negative for text that leans to the right\n+                                         * (forward). *\/\n+  FWORD         underlinePosition;      \/* This is the suggested distance of the top\n+                                         * of the underline from the baseline\n+                                         * (negative values indicate below baseline).\n+                                         * The PostScript definition of this FontInfo\n+                                         * dictionary key (the y coordinate of the\n+                                         * center of the stroke) is not used for\n+                                         * historical reasons. The value of the\n+                                         * PostScript key may be calculated by\n+                                         * subtracting half the underlineThickness\n+                                         * from the value of this field. *\/\n+  FWORD         underlineThickness;     \/* Suggested values for the underline\n+                                           thickness. *\/\n+  HBUINT32      isFixedPitch;           \/* Set to 0 if the font is proportionally\n+                                         * spaced, non-zero if the font is not\n+                                         * proportionally spaced (i.e. monospaced). *\/\n+  HBUINT32      minMemType42;           \/* Minimum memory usage when an OpenType font\n+                                         * is downloaded. *\/\n+  HBUINT32      maxMemType42;           \/* Maximum memory usage when an OpenType font\n+                                         * is downloaded. *\/\n+  HBUINT32      minMemType1;            \/* Minimum memory usage when an OpenType font\n+                                         * is downloaded as a Type 1 font. *\/\n+  HBUINT32      maxMemType1;            \/* Maximum memory usage when an OpenType font\n+                                         * is downloaded as a Type 1 font. *\/\n+  postV2Tail    v2X;\n+  DEFINE_SIZE_MIN (32);\n+};\n+\n+struct post_accelerator_t : post::accelerator_t {};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_POST_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-post-table.hh","additions":299,"deletions":0,"binary":false,"changes":299,"status":"added"},{"patch":"@@ -0,0 +1,345 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH\n+#define HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shape.hh\"\n+#include \"hb-ot-layout-gsub-table.hh\"\n+\n+\n+\/* Features ordered the same as the entries in shaping_table rows,\n+ * followed by rlig.  Don't change. *\/\n+static const hb_tag_t arabic_fallback_features[] =\n+{\n+  HB_TAG('i','n','i','t'),\n+  HB_TAG('m','e','d','i'),\n+  HB_TAG('f','i','n','a'),\n+  HB_TAG('i','s','o','l'),\n+  HB_TAG('r','l','i','g'),\n+};\n+\n+static OT::SubstLookup *\n+arabic_fallback_synthesize_lookup_single (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                          hb_font_t *font,\n+                                          unsigned int feature_index)\n+{\n+  OT::GlyphID glyphs[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];\n+  OT::GlyphID substitutes[SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1];\n+  unsigned int num_glyphs = 0;\n+\n+  \/* Populate arrays *\/\n+  for (hb_codepoint_t u = SHAPING_TABLE_FIRST; u < SHAPING_TABLE_LAST + 1; u++)\n+  {\n+    hb_codepoint_t s = shaping_table[u - SHAPING_TABLE_FIRST][feature_index];\n+    hb_codepoint_t u_glyph, s_glyph;\n+\n+    if (!s ||\n+        !hb_font_get_glyph (font, u, 0, &u_glyph) ||\n+        !hb_font_get_glyph (font, s, 0, &s_glyph) ||\n+        u_glyph == s_glyph ||\n+        u_glyph > 0xFFFFu || s_glyph > 0xFFFFu)\n+      continue;\n+\n+    glyphs[num_glyphs].set (u_glyph);\n+    substitutes[num_glyphs].set (s_glyph);\n+\n+    num_glyphs++;\n+  }\n+\n+  if (!num_glyphs)\n+    return nullptr;\n+\n+  \/* Bubble-sort or something equally good!\n+   * May not be good-enough for presidential candidate interviews, but good-enough for us... *\/\n+  hb_stable_sort (&glyphs[0], num_glyphs, (int(*)(const OT::GlyphID*, const OT::GlyphID *)) OT::GlyphID::cmp, &substitutes[0]);\n+\n+\n+  \/* Each glyph takes four bytes max, and there's some overhead. *\/\n+  char buf[(SHAPING_TABLE_LAST - SHAPING_TABLE_FIRST + 1) * 4 + 128];\n+  hb_serialize_context_t c (buf, sizeof (buf));\n+  OT::SubstLookup *lookup = c.start_serialize<OT::SubstLookup> ();\n+  bool ret = lookup->serialize_single (&c,\n+                                       OT::LookupFlag::IgnoreMarks,\n+                                       hb_array (glyphs, num_glyphs),\n+                                       hb_array (substitutes, num_glyphs));\n+  c.end_serialize ();\n+  \/* TODO sanitize the results? *\/\n+\n+  return ret ? c.copy<OT::SubstLookup> () : nullptr;\n+}\n+\n+static OT::SubstLookup *\n+arabic_fallback_synthesize_lookup_ligature (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                            hb_font_t *font)\n+{\n+  OT::GlyphID first_glyphs[ARRAY_LENGTH_CONST (ligature_table)];\n+  unsigned int first_glyphs_indirection[ARRAY_LENGTH_CONST (ligature_table)];\n+  unsigned int ligature_per_first_glyph_count_list[ARRAY_LENGTH_CONST (first_glyphs)];\n+  unsigned int num_first_glyphs = 0;\n+\n+  \/* We know that all our ligatures are 2-component *\/\n+  OT::GlyphID ligature_list[ARRAY_LENGTH_CONST (first_glyphs) * ARRAY_LENGTH_CONST(ligature_table[0].ligatures)];\n+  unsigned int component_count_list[ARRAY_LENGTH_CONST (ligature_list)];\n+  OT::GlyphID component_list[ARRAY_LENGTH_CONST (ligature_list) * 1\/* One extra component per ligature *\/];\n+  unsigned int num_ligatures = 0;\n+\n+  \/* Populate arrays *\/\n+\n+  \/* Sort out the first-glyphs *\/\n+  for (unsigned int first_glyph_idx = 0; first_glyph_idx < ARRAY_LENGTH (first_glyphs); first_glyph_idx++)\n+  {\n+    hb_codepoint_t first_u = ligature_table[first_glyph_idx].first;\n+    hb_codepoint_t first_glyph;\n+    if (!hb_font_get_glyph (font, first_u, 0, &first_glyph))\n+      continue;\n+    first_glyphs[num_first_glyphs].set (first_glyph);\n+    ligature_per_first_glyph_count_list[num_first_glyphs] = 0;\n+    first_glyphs_indirection[num_first_glyphs] = first_glyph_idx;\n+    num_first_glyphs++;\n+  }\n+  hb_stable_sort (&first_glyphs[0], num_first_glyphs, (int(*)(const OT::GlyphID*, const OT::GlyphID *)) OT::GlyphID::cmp, &first_glyphs_indirection[0]);\n+\n+  \/* Now that the first-glyphs are sorted, walk again, populate ligatures. *\/\n+  for (unsigned int i = 0; i < num_first_glyphs; i++)\n+  {\n+    unsigned int first_glyph_idx = first_glyphs_indirection[i];\n+\n+    for (unsigned int second_glyph_idx = 0; second_glyph_idx < ARRAY_LENGTH (ligature_table[0].ligatures); second_glyph_idx++)\n+    {\n+      hb_codepoint_t second_u   = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].second;\n+      hb_codepoint_t ligature_u = ligature_table[first_glyph_idx].ligatures[second_glyph_idx].ligature;\n+      hb_codepoint_t second_glyph, ligature_glyph;\n+      if (!second_u ||\n+          !hb_font_get_glyph (font, second_u,   0, &second_glyph) ||\n+          !hb_font_get_glyph (font, ligature_u, 0, &ligature_glyph))\n+        continue;\n+\n+      ligature_per_first_glyph_count_list[i]++;\n+\n+      ligature_list[num_ligatures].set (ligature_glyph);\n+      component_count_list[num_ligatures] = 2;\n+      component_list[num_ligatures].set (second_glyph);\n+      num_ligatures++;\n+    }\n+  }\n+\n+  if (!num_ligatures)\n+    return nullptr;\n+\n+\n+  \/* 16 bytes per ligature ought to be enough... *\/\n+  char buf[ARRAY_LENGTH_CONST (ligature_list) * 16 + 128];\n+  hb_serialize_context_t c (buf, sizeof (buf));\n+  OT::SubstLookup *lookup = c.start_serialize<OT::SubstLookup> ();\n+  bool ret = lookup->serialize_ligature (&c,\n+                                         OT::LookupFlag::IgnoreMarks,\n+                                         hb_array (first_glyphs, num_first_glyphs),\n+                                         hb_array (ligature_per_first_glyph_count_list, num_first_glyphs),\n+                                         hb_array (ligature_list, num_ligatures),\n+                                         hb_array (component_count_list, num_ligatures),\n+                                         hb_array (component_list, num_ligatures));\n+  c.end_serialize ();\n+  \/* TODO sanitize the results? *\/\n+\n+  return ret ? c.copy<OT::SubstLookup> () : nullptr;\n+}\n+\n+static OT::SubstLookup *\n+arabic_fallback_synthesize_lookup (const hb_ot_shape_plan_t *plan,\n+                                   hb_font_t *font,\n+                                   unsigned int feature_index)\n+{\n+  if (feature_index < 4)\n+    return arabic_fallback_synthesize_lookup_single (plan, font, feature_index);\n+  else\n+    return arabic_fallback_synthesize_lookup_ligature (plan, font);\n+}\n+\n+#define ARABIC_FALLBACK_MAX_LOOKUPS 5\n+\n+struct arabic_fallback_plan_t\n+{\n+  unsigned int num_lookups;\n+  bool free_lookups;\n+\n+  hb_mask_t mask_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n+  OT::SubstLookup *lookup_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n+  OT::hb_ot_layout_lookup_accelerator_t accel_array[ARABIC_FALLBACK_MAX_LOOKUPS];\n+};\n+\n+#if defined(_WIN32) && !defined(HB_NO_WIN1256)\n+#define HB_WITH_WIN1256\n+#endif\n+\n+#ifdef HB_WITH_WIN1256\n+#include \"hb-ot-shape-complex-arabic-win1256.hh\"\n+#endif\n+\n+struct ManifestLookup\n+{\n+  public:\n+  OT::Tag tag;\n+  OT::OffsetTo<OT::SubstLookup> lookupOffset;\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+typedef OT::ArrayOf<ManifestLookup> Manifest;\n+\n+static bool\n+arabic_fallback_plan_init_win1256 (arabic_fallback_plan_t *fallback_plan HB_UNUSED,\n+                                   const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                   hb_font_t *font HB_UNUSED)\n+{\n+#ifdef HB_WITH_WIN1256\n+  \/* Does this font look like it's Windows-1256-encoded? *\/\n+  hb_codepoint_t g;\n+  if (!(hb_font_get_glyph (font, 0x0627u, 0, &g) && g == 199 \/* ALEF *\/ &&\n+        hb_font_get_glyph (font, 0x0644u, 0, &g) && g == 225 \/* LAM *\/ &&\n+        hb_font_get_glyph (font, 0x0649u, 0, &g) && g == 236 \/* ALEF MAKSURA *\/ &&\n+        hb_font_get_glyph (font, 0x064Au, 0, &g) && g == 237 \/* YEH *\/ &&\n+        hb_font_get_glyph (font, 0x0652u, 0, &g) && g == 250 \/* SUKUN *\/))\n+    return false;\n+\n+  const Manifest &manifest = reinterpret_cast<const Manifest&> (arabic_win1256_gsub_lookups.manifest);\n+  static_assert (sizeof (arabic_win1256_gsub_lookups.manifestData) \/ sizeof (ManifestLookup)\n+                 <= ARABIC_FALLBACK_MAX_LOOKUPS, \"\");\n+  \/* TODO sanitize the table? *\/\n+\n+  unsigned j = 0;\n+  unsigned int count = manifest.len;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    fallback_plan->mask_array[j] = plan->map.get_1_mask (manifest[i].tag);\n+    if (fallback_plan->mask_array[j])\n+    {\n+      fallback_plan->lookup_array[j] = const_cast<OT::SubstLookup*> (&(&manifest+manifest[i].lookupOffset));\n+      if (fallback_plan->lookup_array[j])\n+      {\n+        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n+        j++;\n+      }\n+    }\n+  }\n+\n+  fallback_plan->num_lookups = j;\n+  fallback_plan->free_lookups = false;\n+\n+  return j > 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+static bool\n+arabic_fallback_plan_init_unicode (arabic_fallback_plan_t *fallback_plan,\n+                                   const hb_ot_shape_plan_t *plan,\n+                                   hb_font_t *font)\n+{\n+  static_assert ((ARRAY_LENGTH_CONST(arabic_fallback_features) <= ARABIC_FALLBACK_MAX_LOOKUPS), \"\");\n+  unsigned int j = 0;\n+  for (unsigned int i = 0; i < ARRAY_LENGTH(arabic_fallback_features) ; i++)\n+  {\n+    fallback_plan->mask_array[j] = plan->map.get_1_mask (arabic_fallback_features[i]);\n+    if (fallback_plan->mask_array[j])\n+    {\n+      fallback_plan->lookup_array[j] = arabic_fallback_synthesize_lookup (plan, font, i);\n+      if (fallback_plan->lookup_array[j])\n+      {\n+        fallback_plan->accel_array[j].init (*fallback_plan->lookup_array[j]);\n+        j++;\n+      }\n+    }\n+  }\n+\n+  fallback_plan->num_lookups = j;\n+  fallback_plan->free_lookups = true;\n+\n+  return j > 0;\n+}\n+\n+static arabic_fallback_plan_t *\n+arabic_fallback_plan_create (const hb_ot_shape_plan_t *plan,\n+                             hb_font_t *font)\n+{\n+  arabic_fallback_plan_t *fallback_plan = (arabic_fallback_plan_t *) calloc (1, sizeof (arabic_fallback_plan_t));\n+  if (unlikely (!fallback_plan))\n+    return const_cast<arabic_fallback_plan_t *> (&Null(arabic_fallback_plan_t));\n+\n+  fallback_plan->num_lookups = 0;\n+  fallback_plan->free_lookups = false;\n+\n+  \/* Try synthesizing GSUB table using Unicode Arabic Presentation Forms,\n+   * in case the font has cmap entries for the presentation-forms characters. *\/\n+  if (arabic_fallback_plan_init_unicode (fallback_plan, plan, font))\n+    return fallback_plan;\n+\n+  \/* See if this looks like a Windows-1256-encoded font.  If it does, use a\n+   * hand-coded GSUB table. *\/\n+  if (arabic_fallback_plan_init_win1256 (fallback_plan, plan, font))\n+    return fallback_plan;\n+\n+  assert (fallback_plan->num_lookups == 0);\n+  free (fallback_plan);\n+  return const_cast<arabic_fallback_plan_t *> (&Null(arabic_fallback_plan_t));\n+}\n+\n+static void\n+arabic_fallback_plan_destroy (arabic_fallback_plan_t *fallback_plan)\n+{\n+  if (!fallback_plan || fallback_plan->num_lookups == 0)\n+    return;\n+\n+  for (unsigned int i = 0; i < fallback_plan->num_lookups; i++)\n+    if (fallback_plan->lookup_array[i])\n+    {\n+      fallback_plan->accel_array[i].fini ();\n+      if (fallback_plan->free_lookups)\n+        free (fallback_plan->lookup_array[i]);\n+    }\n+\n+  free (fallback_plan);\n+}\n+\n+static void\n+arabic_fallback_plan_shape (arabic_fallback_plan_t *fallback_plan,\n+                            hb_font_t *font,\n+                            hb_buffer_t *buffer)\n+{\n+  OT::hb_ot_apply_context_t c (0, font, buffer);\n+  for (unsigned int i = 0; i < fallback_plan->num_lookups; i++)\n+    if (fallback_plan->lookup_array[i]) {\n+      c.set_lookup_mask (fallback_plan->mask_array[i]);\n+      hb_ot_layout_substitute_lookup (&c,\n+                                      *fallback_plan->lookup_array[i],\n+                                      fallback_plan->accel_array[i]);\n+    }\n+}\n+\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_FALLBACK_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-arabic-fallback.hh","additions":345,"deletions":0,"binary":false,"changes":345,"status":"added"},{"patch":"@@ -0,0 +1,425 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-arabic-table.py ArabicShaping.txt UnicodeData.txt Blocks.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # ArabicShaping-11.0.0.txt\n+ * # Date: 2018-02-21, 14:50:00 GMT [KW, RP]\n+ * # Blocks-11.0.0.txt\n+ * # Date: 2017-10-16, 24:39:00 GMT [KW]\n+ * UnicodeData.txt does not have a header.\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH\n+#define HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH\n+\n+\n+#define X       JOINING_TYPE_X\n+#define R       JOINING_TYPE_R\n+#define T       JOINING_TYPE_T\n+#define U       JOINING_TYPE_U\n+#define A       JOINING_GROUP_ALAPH\n+#define DR      JOINING_GROUP_DALATH_RISH\n+#define L       JOINING_TYPE_L\n+#define C       JOINING_TYPE_C\n+#define D       JOINING_TYPE_D\n+\n+static const uint8_t joining_table[] =\n+{\n+\n+#define joining_offset_0x0600u 0\n+\n+  \/* Arabic *\/\n+\n+  \/* 0600 *\/ U,U,U,U,U,U,X,X,U,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0620 *\/ D,U,R,R,R,R,D,R,D,R,D,D,D,D,D,R,R,R,R,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 0640 *\/ C,D,D,D,D,D,D,D,R,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0660 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,D,D,X,R,R,R,U,R,R,R,D,D,D,D,D,D,D,D,\n+  \/* 0680 *\/ D,D,D,D,D,D,D,D,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,R,D,D,D,D,D,D,\n+  \/* 06A0 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 06C0 *\/ R,D,D,R,R,R,R,R,R,R,R,R,D,R,D,R,D,D,R,R,X,R,X,X,X,X,X,X,X,U,X,X,\n+  \/* 06E0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,R,R,X,X,X,X,X,X,X,X,X,X,D,D,D,X,X,D,\n+\n+  \/* Syriac *\/\n+\n+  \/* 0700 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,T,A,X,D,D,D,DR,DR,R,R,R,D,D,D,D,R,D,\n+  \/* 0720 *\/ D,D,D,D,D,D,D,D,R,D,DR,D,R,D,D,DR,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0740 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,R,D,D,\n+\n+  \/* Arabic Supplement *\/\n+\n+  \/* 0740 *\/                                 D,D,D,D,D,D,D,D,D,R,R,R,D,D,D,D,\n+  \/* 0760 *\/ D,D,D,D,D,D,D,D,D,D,D,R,R,D,D,D,D,R,D,R,R,D,D,D,R,R,D,D,D,D,D,D,\n+\n+  \/* FILLER *\/\n+\n+  \/* 0780 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 07A0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* NKo *\/\n+\n+  \/* 07C0 *\/ X,X,X,X,X,X,X,X,X,X,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 07E0 *\/ D,D,D,D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,C,X,X,X,X,X,\n+\n+  \/* FILLER *\/\n+\n+  \/* 0800 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0820 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* Mandaic *\/\n+\n+  \/* 0840 *\/ R,D,D,D,D,D,R,R,D,R,D,D,D,D,D,D,D,D,D,D,R,D,U,U,U,X,X,X,X,X,X,X,\n+\n+  \/* Syriac Supplement *\/\n+\n+  \/* 0860 *\/ D,U,D,D,D,D,U,R,D,R,R,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 0880 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+\n+  \/* Arabic Extended-A *\/\n+\n+  \/* 08A0 *\/ D,D,D,D,D,D,D,D,D,D,R,R,R,U,R,D,D,R,R,D,D,X,D,D,D,R,D,D,D,D,X,X,\n+  \/* 08C0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 08E0 *\/ X,X,U,\n+\n+#define joining_offset_0x1806u 739\n+\n+  \/* Mongolian *\/\n+\n+  \/* 1800 *\/             U,D,X,X,C,X,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 1820 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1840 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1860 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,X,X,X,X,X,X,X,\n+  \/* 1880 *\/ U,U,U,U,U,T,T,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 18A0 *\/ D,D,D,D,D,D,D,D,D,X,D,\n+\n+#define joining_offset_0x200cu 904\n+\n+  \/* General Punctuation *\/\n+\n+  \/* 2000 *\/                         U,C,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 2020 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,U,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 2040 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 2060 *\/ X,X,X,X,X,X,U,U,U,U,\n+\n+#define joining_offset_0xa840u 998\n+\n+  \/* Phags-pa *\/\n+\n+  \/* A840 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* A860 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,L,U,\n+\n+#define joining_offset_0x10ac0u 1050\n+\n+  \/* Manichaean *\/\n+\n+  \/* 10AC0 *\/ D,D,D,D,D,R,U,R,U,R,R,U,U,L,R,R,R,R,R,D,D,D,D,L,D,D,D,D,D,R,D,D,\n+  \/* 10AE0 *\/ D,R,U,U,R,X,X,X,X,X,X,D,D,D,D,R,\n+\n+#define joining_offset_0x10b80u 1098\n+\n+  \/* Psalter Pahlavi *\/\n+\n+  \/* 10B80 *\/ D,R,D,R,R,R,D,D,D,R,D,D,R,D,R,R,D,R,X,X,X,X,X,X,X,X,X,X,X,X,X,X,\n+  \/* 10BA0 *\/ X,X,X,X,X,X,X,X,X,R,R,R,R,D,D,U,\n+\n+#define joining_offset_0x10d00u 1146\n+\n+  \/* Hanifi Rohingya *\/\n+\n+  \/* 10D00 *\/ L,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 10D20 *\/ D,D,R,D,\n+\n+#define joining_offset_0x10f30u 1182\n+\n+  \/* Sogdian *\/\n+\n+  \/* 10F20 *\/                                 D,D,D,R,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 10F40 *\/ D,D,D,D,D,U,X,X,X,X,X,X,X,X,X,X,X,D,D,D,R,\n+\n+#define joining_offset_0x110bdu 1219\n+\n+  \/* Kaithi *\/\n+\n+  \/* 110A0 *\/                                                           U,X,X,\n+  \/* 110C0 *\/ X,X,X,X,X,X,X,X,X,X,X,X,X,U,\n+\n+#define joining_offset_0x1e900u 1236\n+\n+  \/* Adlam *\/\n+\n+  \/* 1E900 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1E920 *\/ D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,D,\n+  \/* 1E940 *\/ D,D,D,D,\n+\n+}; \/* Table items: 1304; occupancy: 56% *\/\n+\n+\n+static unsigned int\n+joining_type (hb_codepoint_t u)\n+{\n+  switch (u >> 12)\n+  {\n+    case 0x0u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0600u, 0x08E2u)) return joining_table[u - 0x0600u + joining_offset_0x0600u];\n+      break;\n+\n+    case 0x1u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1806u, 0x18AAu)) return joining_table[u - 0x1806u + joining_offset_0x1806u];\n+      break;\n+\n+    case 0x2u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x200Cu, 0x2069u)) return joining_table[u - 0x200Cu + joining_offset_0x200cu];\n+      break;\n+\n+    case 0xAu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA840u, 0xA873u)) return joining_table[u - 0xA840u + joining_offset_0xa840u];\n+      break;\n+\n+    case 0x10u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10AC0u, 0x10AEFu)) return joining_table[u - 0x10AC0u + joining_offset_0x10ac0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10B80u, 0x10BAFu)) return joining_table[u - 0x10B80u + joining_offset_0x10b80u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10D00u, 0x10D23u)) return joining_table[u - 0x10D00u + joining_offset_0x10d00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10F30u, 0x10F54u)) return joining_table[u - 0x10F30u + joining_offset_0x10f30u];\n+      break;\n+\n+    case 0x11u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x110BDu, 0x110CDu)) return joining_table[u - 0x110BDu + joining_offset_0x110bdu];\n+      break;\n+\n+    case 0x1Eu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1E900u, 0x1E943u)) return joining_table[u - 0x1E900u + joining_offset_0x1e900u];\n+      break;\n+\n+    default:\n+      break;\n+  }\n+  return X;\n+}\n+\n+#undef X\n+#undef R\n+#undef T\n+#undef U\n+#undef A\n+#undef DR\n+#undef L\n+#undef C\n+#undef D\n+\n+\n+static const uint16_t shaping_table[][4] =\n+{\n+  {0x0000u, 0x0000u, 0x0000u, 0xFE80u}, \/* U+0621 ARABIC LETTER HAMZA ISOLATED FORM *\/\n+  {0x0000u, 0x0000u, 0xFE82u, 0xFE81u}, \/* U+0622 ARABIC LETTER ALEF WITH MADDA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE84u, 0xFE83u}, \/* U+0623 ARABIC LETTER ALEF WITH HAMZA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE86u, 0xFE85u}, \/* U+0624 ARABIC LETTER WAW WITH HAMZA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE88u, 0xFE87u}, \/* U+0625 ARABIC LETTER ALEF WITH HAMZA BELOW *\/\n+  {0xFE8Bu, 0xFE8Cu, 0xFE8Au, 0xFE89u}, \/* U+0626 ARABIC LETTER YEH WITH HAMZA ABOVE *\/\n+  {0x0000u, 0x0000u, 0xFE8Eu, 0xFE8Du}, \/* U+0627 ARABIC LETTER ALEF *\/\n+  {0xFE91u, 0xFE92u, 0xFE90u, 0xFE8Fu}, \/* U+0628 ARABIC LETTER BEH *\/\n+  {0x0000u, 0x0000u, 0xFE94u, 0xFE93u}, \/* U+0629 ARABIC LETTER TEH MARBUTA *\/\n+  {0xFE97u, 0xFE98u, 0xFE96u, 0xFE95u}, \/* U+062A ARABIC LETTER TEH *\/\n+  {0xFE9Bu, 0xFE9Cu, 0xFE9Au, 0xFE99u}, \/* U+062B ARABIC LETTER THEH *\/\n+  {0xFE9Fu, 0xFEA0u, 0xFE9Eu, 0xFE9Du}, \/* U+062C ARABIC LETTER JEEM *\/\n+  {0xFEA3u, 0xFEA4u, 0xFEA2u, 0xFEA1u}, \/* U+062D ARABIC LETTER HAH *\/\n+  {0xFEA7u, 0xFEA8u, 0xFEA6u, 0xFEA5u}, \/* U+062E ARABIC LETTER KHAH *\/\n+  {0x0000u, 0x0000u, 0xFEAAu, 0xFEA9u}, \/* U+062F ARABIC LETTER DAL *\/\n+  {0x0000u, 0x0000u, 0xFEACu, 0xFEABu}, \/* U+0630 ARABIC LETTER THAL *\/\n+  {0x0000u, 0x0000u, 0xFEAEu, 0xFEADu}, \/* U+0631 ARABIC LETTER REH *\/\n+  {0x0000u, 0x0000u, 0xFEB0u, 0xFEAFu}, \/* U+0632 ARABIC LETTER ZAIN *\/\n+  {0xFEB3u, 0xFEB4u, 0xFEB2u, 0xFEB1u}, \/* U+0633 ARABIC LETTER SEEN *\/\n+  {0xFEB7u, 0xFEB8u, 0xFEB6u, 0xFEB5u}, \/* U+0634 ARABIC LETTER SHEEN *\/\n+  {0xFEBBu, 0xFEBCu, 0xFEBAu, 0xFEB9u}, \/* U+0635 ARABIC LETTER SAD *\/\n+  {0xFEBFu, 0xFEC0u, 0xFEBEu, 0xFEBDu}, \/* U+0636 ARABIC LETTER DAD *\/\n+  {0xFEC3u, 0xFEC4u, 0xFEC2u, 0xFEC1u}, \/* U+0637 ARABIC LETTER TAH *\/\n+  {0xFEC7u, 0xFEC8u, 0xFEC6u, 0xFEC5u}, \/* U+0638 ARABIC LETTER ZAH *\/\n+  {0xFECBu, 0xFECCu, 0xFECAu, 0xFEC9u}, \/* U+0639 ARABIC LETTER AIN *\/\n+  {0xFECFu, 0xFED0u, 0xFECEu, 0xFECDu}, \/* U+063A ARABIC LETTER GHAIN *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+063F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0640  *\/\n+  {0xFED3u, 0xFED4u, 0xFED2u, 0xFED1u}, \/* U+0641 ARABIC LETTER FEH *\/\n+  {0xFED7u, 0xFED8u, 0xFED6u, 0xFED5u}, \/* U+0642 ARABIC LETTER QAF *\/\n+  {0xFEDBu, 0xFEDCu, 0xFEDAu, 0xFED9u}, \/* U+0643 ARABIC LETTER KAF *\/\n+  {0xFEDFu, 0xFEE0u, 0xFEDEu, 0xFEDDu}, \/* U+0644 ARABIC LETTER LAM *\/\n+  {0xFEE3u, 0xFEE4u, 0xFEE2u, 0xFEE1u}, \/* U+0645 ARABIC LETTER MEEM *\/\n+  {0xFEE7u, 0xFEE8u, 0xFEE6u, 0xFEE5u}, \/* U+0646 ARABIC LETTER NOON *\/\n+  {0xFEEBu, 0xFEECu, 0xFEEAu, 0xFEE9u}, \/* U+0647 ARABIC LETTER HEH *\/\n+  {0x0000u, 0x0000u, 0xFEEEu, 0xFEEDu}, \/* U+0648 ARABIC LETTER WAW *\/\n+  {0xFBE8u, 0xFBE9u, 0xFEF0u, 0xFEEFu}, \/* U+0649 ARABIC LETTER *\/\n+  {0xFEF3u, 0xFEF4u, 0xFEF2u, 0xFEF1u}, \/* U+064A ARABIC LETTER YEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+064F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0650  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0651  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0652  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0653  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0654  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0655  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0656  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0657  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0658  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0659  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+065F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0660  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0661  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0662  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0663  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0664  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0665  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0666  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0667  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0668  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0669  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+066F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0670  *\/\n+  {0x0000u, 0x0000u, 0xFB51u, 0xFB50u}, \/* U+0671 ARABIC LETTER ALEF WASLA *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0672  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0673  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0674  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0675  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0676  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0xFBDDu}, \/* U+0677 ARABIC LETTER U WITH HAMZA ABOVE ISOLATED FORM *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0678  *\/\n+  {0xFB68u, 0xFB69u, 0xFB67u, 0xFB66u}, \/* U+0679 ARABIC LETTER TTEH *\/\n+  {0xFB60u, 0xFB61u, 0xFB5Fu, 0xFB5Eu}, \/* U+067A ARABIC LETTER TTEHEH *\/\n+  {0xFB54u, 0xFB55u, 0xFB53u, 0xFB52u}, \/* U+067B ARABIC LETTER BEEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+067C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+067D  *\/\n+  {0xFB58u, 0xFB59u, 0xFB57u, 0xFB56u}, \/* U+067E ARABIC LETTER PEH *\/\n+  {0xFB64u, 0xFB65u, 0xFB63u, 0xFB62u}, \/* U+067F ARABIC LETTER TEHEH *\/\n+  {0xFB5Cu, 0xFB5Du, 0xFB5Bu, 0xFB5Au}, \/* U+0680 ARABIC LETTER BEHEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0681  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0682  *\/\n+  {0xFB78u, 0xFB79u, 0xFB77u, 0xFB76u}, \/* U+0683 ARABIC LETTER NYEH *\/\n+  {0xFB74u, 0xFB75u, 0xFB73u, 0xFB72u}, \/* U+0684 ARABIC LETTER DYEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0685  *\/\n+  {0xFB7Cu, 0xFB7Du, 0xFB7Bu, 0xFB7Au}, \/* U+0686 ARABIC LETTER TCHEH *\/\n+  {0xFB80u, 0xFB81u, 0xFB7Fu, 0xFB7Eu}, \/* U+0687 ARABIC LETTER TCHEHEH *\/\n+  {0x0000u, 0x0000u, 0xFB89u, 0xFB88u}, \/* U+0688 ARABIC LETTER DDAL *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0689  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068B  *\/\n+  {0x0000u, 0x0000u, 0xFB85u, 0xFB84u}, \/* U+068C ARABIC LETTER DAHAL *\/\n+  {0x0000u, 0x0000u, 0xFB83u, 0xFB82u}, \/* U+068D ARABIC LETTER DDAHAL *\/\n+  {0x0000u, 0x0000u, 0xFB87u, 0xFB86u}, \/* U+068E ARABIC LETTER DUL *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+068F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0690  *\/\n+  {0x0000u, 0x0000u, 0xFB8Du, 0xFB8Cu}, \/* U+0691 ARABIC LETTER RREH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0692  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0693  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0694  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0695  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0696  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0697  *\/\n+  {0x0000u, 0x0000u, 0xFB8Bu, 0xFB8Au}, \/* U+0698 ARABIC LETTER JEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+0699  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069A  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069B  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069C  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069D  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069E  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+069F  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A0  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A1  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A2  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A3  *\/\n+  {0xFB6Cu, 0xFB6Du, 0xFB6Bu, 0xFB6Au}, \/* U+06A4 ARABIC LETTER VEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A5  *\/\n+  {0xFB70u, 0xFB71u, 0xFB6Fu, 0xFB6Eu}, \/* U+06A6 ARABIC LETTER PEHEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A7  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06A8  *\/\n+  {0xFB90u, 0xFB91u, 0xFB8Fu, 0xFB8Eu}, \/* U+06A9 ARABIC LETTER KEHEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AA  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AB  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AC  *\/\n+  {0xFBD5u, 0xFBD6u, 0xFBD4u, 0xFBD3u}, \/* U+06AD ARABIC LETTER NG *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06AE  *\/\n+  {0xFB94u, 0xFB95u, 0xFB93u, 0xFB92u}, \/* U+06AF ARABIC LETTER GAF *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B0  *\/\n+  {0xFB9Cu, 0xFB9Du, 0xFB9Bu, 0xFB9Au}, \/* U+06B1 ARABIC LETTER NGOEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B2  *\/\n+  {0xFB98u, 0xFB99u, 0xFB97u, 0xFB96u}, \/* U+06B3 ARABIC LETTER GUEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B4  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B5  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B6  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B7  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B8  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06B9  *\/\n+  {0x0000u, 0x0000u, 0xFB9Fu, 0xFB9Eu}, \/* U+06BA ARABIC LETTER NOON GHUNNA *\/\n+  {0xFBA2u, 0xFBA3u, 0xFBA1u, 0xFBA0u}, \/* U+06BB ARABIC LETTER RNOON *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BC  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BD  *\/\n+  {0xFBACu, 0xFBADu, 0xFBABu, 0xFBAAu}, \/* U+06BE ARABIC LETTER HEH DOACHASHMEE *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06BF  *\/\n+  {0x0000u, 0x0000u, 0xFBA5u, 0xFBA4u}, \/* U+06C0 ARABIC LETTER HEH WITH YEH ABOVE *\/\n+  {0xFBA8u, 0xFBA9u, 0xFBA7u, 0xFBA6u}, \/* U+06C1 ARABIC LETTER HEH GOAL *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C2  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C3  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06C4  *\/\n+  {0x0000u, 0x0000u, 0xFBE1u, 0xFBE0u}, \/* U+06C5 ARABIC LETTER KIRGHIZ OE *\/\n+  {0x0000u, 0x0000u, 0xFBDAu, 0xFBD9u}, \/* U+06C6 ARABIC LETTER OE *\/\n+  {0x0000u, 0x0000u, 0xFBD8u, 0xFBD7u}, \/* U+06C7 ARABIC LETTER U *\/\n+  {0x0000u, 0x0000u, 0xFBDCu, 0xFBDBu}, \/* U+06C8 ARABIC LETTER YU *\/\n+  {0x0000u, 0x0000u, 0xFBE3u, 0xFBE2u}, \/* U+06C9 ARABIC LETTER KIRGHIZ YU *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CA  *\/\n+  {0x0000u, 0x0000u, 0xFBDFu, 0xFBDEu}, \/* U+06CB ARABIC LETTER VE *\/\n+  {0xFBFEu, 0xFBFFu, 0xFBFDu, 0xFBFCu}, \/* U+06CC ARABIC LETTER FARSI YEH *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CD  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CE  *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06CF  *\/\n+  {0xFBE6u, 0xFBE7u, 0xFBE5u, 0xFBE4u}, \/* U+06D0 ARABIC LETTER E *\/\n+  {0x0000u, 0x0000u, 0x0000u, 0x0000u}, \/* U+06D1  *\/\n+  {0x0000u, 0x0000u, 0xFBAFu, 0xFBAEu}, \/* U+06D2 ARABIC LETTER YEH BARREE *\/\n+  {0x0000u, 0x0000u, 0xFBB1u, 0xFBB0u}, \/* U+06D3 ARABIC LETTER YEH BARREE WITH HAMZA ABOVE *\/\n+};\n+\n+#define SHAPING_TABLE_FIRST     0x0621u\n+#define SHAPING_TABLE_LAST      0x06D3u\n+\n+\n+static const struct ligature_set_t {\n+ uint16_t first;\n+ struct ligature_pairs_t {\n+   uint16_t second;\n+   uint16_t ligature;\n+ } ligatures[4];\n+} ligature_table[] =\n+{\n+  { 0xFEDFu, {\n+    { 0xFE88u, 0xFEF9u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW ISOLATED FORM *\/\n+    { 0xFE82u, 0xFEF5u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE ISOLATED FORM *\/\n+    { 0xFE8Eu, 0xFEFBu }, \/* ARABIC LIGATURE LAM WITH ALEF ISOLATED FORM *\/\n+    { 0xFE84u, 0xFEF7u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE ISOLATED FORM *\/\n+  }},\n+  { 0xFEE0u, {\n+    { 0xFE88u, 0xFEFAu }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA BELOW FINAL FORM *\/\n+    { 0xFE82u, 0xFEF6u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH MADDA ABOVE FINAL FORM *\/\n+    { 0xFE8Eu, 0xFEFCu }, \/* ARABIC LIGATURE LAM WITH ALEF FINAL FORM *\/\n+    { 0xFE84u, 0xFEF8u }, \/* ARABIC LIGATURE LAM WITH ALEF WITH HAMZA ABOVE FINAL FORM *\/\n+  }},\n+};\n+\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_TABLE_HH *\/\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-arabic-table.hh","additions":425,"deletions":0,"binary":false,"changes":425,"status":"added"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright © 2014  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_ARABIC_WIN1256_HH\n+\n+\n+\/*\n+ * The macros in the first part of this file are generic macros that can\n+ * be used to define the bytes for OpenType table data in code in a\n+ * readable manner.  We can move the macros to reside with their respective\n+ * struct types, but since we only use these to define one data table, the\n+ * Windows-1256 Arabic shaping table in this file, we keep them here.\n+ *\/\n+\n+\n+\/* First we measure, then we cut. *\/\n+#ifndef OT_MEASURE\n+#define OT_MEASURE\n+#define OT_TABLE_START                  static const struct TABLE_NAME {\n+#define OT_TABLE_END                    }\n+#define OT_LABEL_START(Name)            unsigned char Name[\n+#define OT_LABEL_END                    ];\n+#define OT_UINT8(u8)                    +1\/*byte*\/\n+#define OT_UINT16(u16)                  +2\/*bytes*\/\n+#else\n+#undef  OT_MEASURE\n+#define OT_TABLE_START                  TABLE_NAME = {\n+#define OT_TABLE_END                    };\n+#define OT_LABEL_START(Name)            {\n+#define OT_LABEL_END                    },\n+#define OT_UINT8(u8)                    (u8),\n+#define OT_UINT16(u16)                  (unsigned char)((u16)>>8), (unsigned char)((u16)&0xFFu),\n+#define OT_COUNT(Name, ItemSize)        ((unsigned int) sizeof(((struct TABLE_NAME*)0)->Name) \\\n+                                         \/ (unsigned int)(ItemSize) \\\n+                                         \/* OT_ASSERT it's divisible (and positive). *\/)\n+#define OT_DISTANCE(From,To)            ((unsigned int) \\\n+                                         ((char*)(&((struct TABLE_NAME*)0)->To) - \\\n+                                          (char*)(&((struct TABLE_NAME*)0)->From)) \\\n+                                         \/* OT_ASSERT it's positive. *\/)\n+#endif\n+\n+\n+#define OT_LABEL(Name) \\\n+        OT_LABEL_END \\\n+        OT_LABEL_START(Name)\n+\n+\/* Whenever we receive an argument that is a list, it will expand to\n+ * contain commas.  That cannot be passed to another macro because the\n+ * commas will throw off the preprocessor.  The solution is to wrap\n+ * the passed-in argument in OT_LIST() before passing to the next macro.\n+ * Unfortunately this trick requires vararg macros. *\/\n+#define OT_LIST(...) __VA_ARGS__\n+\n+\n+\/*\n+ * Basic Types\n+ *\/\n+\n+#define OT_TAG(a,b,c,d) \\\n+        OT_UINT8(a) OT_UINT8(b) OT_UINT8(c) OT_UINT8(d)\n+\n+#define OT_OFFSET(From, To) \/* Offset from From to To in bytes *\/ \\\n+        OT_UINT16(OT_DISTANCE(From, To))\n+\n+#define OT_GLYPHID \/* GlyphID *\/ \\\n+        OT_UINT16\n+\n+#define OT_UARRAY(Name, Items) \\\n+        OT_LABEL_START(Name) \\\n+        OT_UINT16(OT_COUNT(Name##Data, 2)) \\\n+        OT_LABEL(Name##Data) \\\n+        Items \\\n+        OT_LABEL_END\n+\n+#define OT_UHEADLESSARRAY(Name, Items) \\\n+        OT_LABEL_START(Name) \\\n+        OT_UINT16(OT_COUNT(Name##Data, 2) + 1) \\\n+        OT_LABEL(Name##Data) \\\n+        Items \\\n+        OT_LABEL_END\n+\n+\n+\/*\n+ * Common Types\n+ *\/\n+\n+#define OT_LOOKUP_FLAG_IGNORE_MARKS     0x08u\n+\n+#define OT_LOOKUP(Name, LookupType, LookupFlag, SubLookupOffsets) \\\n+        OT_LABEL_START(Name) \\\n+        OT_UINT16(LookupType) \\\n+        OT_UINT16(LookupFlag) \\\n+        OT_LABEL_END \\\n+        OT_UARRAY(Name##SubLookupOffsetsArray, OT_LIST(SubLookupOffsets))\n+\n+#define OT_SUBLOOKUP(Name, SubFormat, Items) \\\n+        OT_LABEL_START(Name) \\\n+        OT_UINT16(SubFormat) \\\n+        Items\n+\n+#define OT_COVERAGE1(Name, Items) \\\n+        OT_LABEL_START(Name) \\\n+        OT_UINT16(1) \\\n+        OT_LABEL_END \\\n+        OT_UARRAY(Name##Glyphs, OT_LIST(Items))\n+\n+\n+\/*\n+ * GSUB\n+ *\/\n+\n+#define OT_LOOKUP_TYPE_SUBST_SINGLE     1u\n+#define OT_LOOKUP_TYPE_SUBST_LIGATURE   4u\n+\n+#define OT_SUBLOOKUP_SINGLE_SUBST_FORMAT2(Name, FromGlyphs, ToGlyphs) \\\n+        OT_SUBLOOKUP(Name, 2, \\\n+                OT_OFFSET(Name, Name##Coverage) \\\n+                OT_LABEL_END \\\n+                OT_UARRAY(Name##Substitute, OT_LIST(ToGlyphs)) \\\n+        ) \\\n+        OT_COVERAGE1(Name##Coverage, OT_LIST(FromGlyphs)) \\\n+        \/* ASSERT_STATIC_EXPR_ZERO (len(FromGlyphs) == len(ToGlyphs)) *\/\n+\n+#define OT_SUBLOOKUP_LIGATURE_SUBST_FORMAT1(Name, FirstGlyphs, LigatureSetOffsets) \\\n+        OT_SUBLOOKUP(Name, 1, \\\n+                OT_OFFSET(Name, Name##Coverage) \\\n+                OT_LABEL_END \\\n+                OT_UARRAY(Name##LigatureSetOffsetsArray, OT_LIST(LigatureSetOffsets)) \\\n+        ) \\\n+        OT_COVERAGE1(Name##Coverage, OT_LIST(FirstGlyphs)) \\\n+        \/* ASSERT_STATIC_EXPR_ZERO (len(FirstGlyphs) == len(LigatureSetOffsets)) *\/\n+\n+#define OT_LIGATURE_SET(Name, LigatureSetOffsets) \\\n+        OT_UARRAY(Name, OT_LIST(LigatureSetOffsets))\n+\n+#define OT_LIGATURE(Name, Components, LigGlyph) \\\n+        OT_LABEL_START(Name) \\\n+        LigGlyph \\\n+        OT_LABEL_END \\\n+        OT_UHEADLESSARRAY(Name##ComponentsArray, OT_LIST(Components))\n+\n+\/*\n+ *\n+ * Start of Windows-1256 shaping table.\n+ *\n+ *\/\n+\n+\/* Table name. *\/\n+#define TABLE_NAME arabic_win1256_gsub_lookups\n+\n+\/* Table manifest. *\/\n+#define MANIFEST(Items) \\\n+        OT_LABEL_START(manifest) \\\n+        OT_UINT16(OT_COUNT(manifestData, 6)) \\\n+        OT_LABEL(manifestData) \\\n+        Items \\\n+        OT_LABEL_END\n+\n+#define MANIFEST_LOOKUP(Tag, Name) \\\n+        Tag \\\n+        OT_OFFSET(manifest, Name)\n+\n+\/* Shorthand. *\/\n+#define G       OT_GLYPHID\n+\n+\/*\n+ * Table Start\n+ *\/\n+OT_TABLE_START\n+\n+\n+\/*\n+ * Manifest\n+ *\/\n+MANIFEST(\n+        MANIFEST_LOOKUP(OT_TAG('r','l','i','g'), rligLookup)\n+        MANIFEST_LOOKUP(OT_TAG('i','n','i','t'), initLookup)\n+        MANIFEST_LOOKUP(OT_TAG('m','e','d','i'), mediLookup)\n+        MANIFEST_LOOKUP(OT_TAG('f','i','n','a'), finaLookup)\n+        MANIFEST_LOOKUP(OT_TAG('r','l','i','g'), rligMarksLookup)\n+)\n+\n+\/*\n+ * Lookups\n+ *\/\n+OT_LOOKUP(initLookup, OT_LOOKUP_TYPE_SUBST_SINGLE, OT_LOOKUP_FLAG_IGNORE_MARKS,\n+        OT_OFFSET(initLookup, initmediSubLookup)\n+        OT_OFFSET(initLookup, initSubLookup)\n+)\n+OT_LOOKUP(mediLookup, OT_LOOKUP_TYPE_SUBST_SINGLE, OT_LOOKUP_FLAG_IGNORE_MARKS,\n+        OT_OFFSET(mediLookup, initmediSubLookup)\n+        OT_OFFSET(mediLookup, mediSubLookup)\n+        OT_OFFSET(mediLookup, medifinaLamAlefSubLookup)\n+)\n+OT_LOOKUP(finaLookup, OT_LOOKUP_TYPE_SUBST_SINGLE, OT_LOOKUP_FLAG_IGNORE_MARKS,\n+        OT_OFFSET(finaLookup, finaSubLookup)\n+        \/* We don't need this one currently as the sequence inherits masks\n+         * from the first item.  Just in case we change that in the future\n+         * to be smart about Arabic masks when ligating... *\/\n+        OT_OFFSET(finaLookup, medifinaLamAlefSubLookup)\n+)\n+OT_LOOKUP(rligLookup, OT_LOOKUP_TYPE_SUBST_LIGATURE, OT_LOOKUP_FLAG_IGNORE_MARKS,\n+        OT_OFFSET(rligLookup, lamAlefLigaturesSubLookup)\n+)\n+OT_LOOKUP(rligMarksLookup, OT_LOOKUP_TYPE_SUBST_LIGATURE, 0,\n+        OT_OFFSET(rligMarksLookup, shaddaLigaturesSubLookup)\n+)\n+\n+\/*\n+ * init\/medi\/fina forms\n+ *\/\n+OT_SUBLOOKUP_SINGLE_SUBST_FORMAT2(initmediSubLookup,\n+        G(198)  G(200)  G(201)  G(202)  G(203)  G(204)  G(205)  G(206)  G(211)\n+        G(212)  G(213)  G(214)  G(223)  G(225)  G(227)  G(228)  G(236)  G(237),\n+        G(162)  G(4)    G(5)    G(5)    G(6)    G(7)    G(9)    G(11)   G(13)\n+        G(14)   G(15)   G(26)   G(140)  G(141)  G(142)  G(143)  G(154)  G(154)\n+)\n+OT_SUBLOOKUP_SINGLE_SUBST_FORMAT2(initSubLookup,\n+        G(218)  G(219)  G(221)  G(222)  G(229),\n+        G(27)   G(30)   G(128)  G(131)  G(144)\n+)\n+OT_SUBLOOKUP_SINGLE_SUBST_FORMAT2(mediSubLookup,\n+        G(218)  G(219)  G(221)  G(222)  G(229),\n+        G(28)   G(31)   G(129)  G(138)  G(149)\n+)\n+OT_SUBLOOKUP_SINGLE_SUBST_FORMAT2(finaSubLookup,\n+        G(194)  G(195)  G(197)  G(198)  G(199)  G(201)  G(204)  G(205)  G(206)\n+        G(218)  G(219)  G(229)  G(236)  G(237),\n+        G(2)    G(1)    G(3)    G(181)  G(0)    G(159)  G(8)    G(10)   G(12)\n+        G(29)   G(127)  G(152) G(160)   G(156)\n+)\n+OT_SUBLOOKUP_SINGLE_SUBST_FORMAT2(medifinaLamAlefSubLookup,\n+        G(165)  G(178)  G(180)  G(252),\n+        G(170)  G(179)  G(185)  G(255)\n+)\n+\n+\/*\n+ * Lam+Alef ligatures\n+ *\/\n+OT_SUBLOOKUP_LIGATURE_SUBST_FORMAT1(lamAlefLigaturesSubLookup,\n+        G(225),\n+        OT_OFFSET(lamAlefLigaturesSubLookup, lamLigatureSet)\n+)\n+OT_LIGATURE_SET(lamLigatureSet,\n+        OT_OFFSET(lamLigatureSet, lamInitLigature1)\n+        OT_OFFSET(lamLigatureSet, lamInitLigature2)\n+        OT_OFFSET(lamLigatureSet, lamInitLigature3)\n+        OT_OFFSET(lamLigatureSet, lamInitLigature4)\n+)\n+OT_LIGATURE(lamInitLigature1, G(199), G(165))\n+OT_LIGATURE(lamInitLigature2, G(195), G(178))\n+OT_LIGATURE(lamInitLigature3, G(194), G(180))\n+OT_LIGATURE(lamInitLigature4, G(197), G(252))\n+\n+\/*\n+ * Shadda ligatures\n+ *\/\n+OT_SUBLOOKUP_LIGATURE_SUBST_FORMAT1(shaddaLigaturesSubLookup,\n+        G(248),\n+        OT_OFFSET(shaddaLigaturesSubLookup, shaddaLigatureSet)\n+)\n+OT_LIGATURE_SET(shaddaLigatureSet,\n+        OT_OFFSET(shaddaLigatureSet, shaddaLigature1)\n+        OT_OFFSET(shaddaLigatureSet, shaddaLigature2)\n+        OT_OFFSET(shaddaLigatureSet, shaddaLigature3)\n+)\n+OT_LIGATURE(shaddaLigature1, G(243), G(172))\n+OT_LIGATURE(shaddaLigature2, G(245), G(173))\n+OT_LIGATURE(shaddaLigature3, G(246), G(175))\n+\n+\/*\n+ * Table end\n+ *\/\n+OT_TABLE_END\n+\n+\n+\/*\n+ * Clean up\n+ *\/\n+#undef OT_TABLE_START\n+#undef OT_TABLE_END\n+#undef OT_LABEL_START\n+#undef OT_LABEL_END\n+#undef OT_UINT8\n+#undef OT_UINT16\n+#undef OT_DISTANCE\n+#undef OT_COUNT\n+\n+\/*\n+ * Include a second time to get the table data...\n+ *\/\n+#if 0\n+#include \"hb.hh\" \/* Make check-includes.sh happy. *\/\n+#endif\n+#ifdef OT_MEASURE\n+#include \"hb-ot-shape-complex-arabic-win1256.hh\"\n+#endif\n+\n+#define HB_OT_SHAPE_COMPLEX_ARABIC_WIN1256_HH\n+#endif \/* HB_OT_SHAPE_COMPLEX_ARABIC_WIN1256_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-arabic-win1256.hh","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,708 @@\n+\/*\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+#include \"hb-ot-shape-complex-arabic.hh\"\n+#include \"hb-ot-shape.hh\"\n+\n+\n+\/* buffer var allocations *\/\n+#define arabic_shaping_action() complex_var_u8_0() \/* arabic shaping action *\/\n+\n+#define HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH HB_BUFFER_SCRATCH_FLAG_COMPLEX0\n+\n+\/* See:\n+ * https:\/\/github.com\/harfbuzz\/harfbuzz\/commit\/6e6f82b6f3dde0fc6c3c7d991d9ec6cfff57823d#commitcomment-14248516 *\/\n+#define HB_ARABIC_GENERAL_CATEGORY_IS_WORD(gen_cat) \\\n+        (FLAG_UNSAFE (gen_cat) & \\\n+         (FLAG (HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE) | \\\n+          \/*FLAG (HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER) |*\/ \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER) | \\\n+          \/*FLAG (HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER) |*\/ \\\n+          \/*FLAG (HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER) |*\/ \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL)))\n+\n+\n+\/*\n+ * Joining types:\n+ *\/\n+\n+\/*\n+ * Bits used in the joining tables\n+ *\/\n+enum hb_arabic_joining_type_t {\n+  JOINING_TYPE_U                = 0,\n+  JOINING_TYPE_L                = 1,\n+  JOINING_TYPE_R                = 2,\n+  JOINING_TYPE_D                = 3,\n+  JOINING_TYPE_C                = JOINING_TYPE_D,\n+  JOINING_GROUP_ALAPH           = 4,\n+  JOINING_GROUP_DALATH_RISH     = 5,\n+  NUM_STATE_MACHINE_COLS        = 6,\n+\n+  JOINING_TYPE_T = 7,\n+  JOINING_TYPE_X = 8  \/* means: use general-category to choose between U or T. *\/\n+};\n+\n+#include \"hb-ot-shape-complex-arabic-table.hh\"\n+\n+static unsigned int get_joining_type (hb_codepoint_t u, hb_unicode_general_category_t gen_cat)\n+{\n+  unsigned int j_type = joining_type(u);\n+  if (likely (j_type != JOINING_TYPE_X))\n+    return j_type;\n+\n+  return (FLAG_UNSAFE(gen_cat) &\n+          (FLAG(HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) |\n+           FLAG(HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) |\n+           FLAG(HB_UNICODE_GENERAL_CATEGORY_FORMAT))\n+         ) ?  JOINING_TYPE_T : JOINING_TYPE_U;\n+}\n+\n+#define FEATURE_IS_SYRIAC(tag) hb_in_range<unsigned char> ((unsigned char) (tag), '2', '3')\n+\n+static const hb_tag_t arabic_features[] =\n+{\n+  HB_TAG('i','s','o','l'),\n+  HB_TAG('f','i','n','a'),\n+  HB_TAG('f','i','n','2'),\n+  HB_TAG('f','i','n','3'),\n+  HB_TAG('m','e','d','i'),\n+  HB_TAG('m','e','d','2'),\n+  HB_TAG('i','n','i','t'),\n+  HB_TAG_NONE\n+};\n+\n+\n+\/* Same order as the feature array *\/\n+enum arabic_action_t {\n+  ISOL,\n+  FINA,\n+  FIN2,\n+  FIN3,\n+  MEDI,\n+  MED2,\n+  INIT,\n+\n+  NONE,\n+\n+  ARABIC_NUM_FEATURES = NONE,\n+\n+  \/* We abuse the same byte for other things... *\/\n+  STCH_FIXED,\n+  STCH_REPEATING,\n+};\n+\n+static const struct arabic_state_table_entry {\n+        uint8_t prev_action;\n+        uint8_t curr_action;\n+        uint16_t next_state;\n+} arabic_state_table[][NUM_STATE_MACHINE_COLS] =\n+{\n+  \/*   jt_U,          jt_L,          jt_R,          jt_D,          jg_ALAPH,      jg_DALATH_RISH *\/\n+\n+  \/* State 0: prev was U, not willing to join. *\/\n+  { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,6}, },\n+\n+  \/* State 1: prev was R or ISOL\/ALAPH, not willing to join. *\/\n+  { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN2,5}, {NONE,ISOL,6}, },\n+\n+  \/* State 2: prev was D\/L in ISOL form, willing to join. *\/\n+  { {NONE,NONE,0}, {NONE,ISOL,2}, {INIT,FINA,1}, {INIT,FINA,3}, {INIT,FINA,4}, {INIT,FINA,6}, },\n+\n+  \/* State 3: prev was D in FINA form, willing to join. *\/\n+  { {NONE,NONE,0}, {NONE,ISOL,2}, {MEDI,FINA,1}, {MEDI,FINA,3}, {MEDI,FINA,4}, {MEDI,FINA,6}, },\n+\n+  \/* State 4: prev was FINA ALAPH, not willing to join. *\/\n+  { {NONE,NONE,0}, {NONE,ISOL,2}, {MED2,ISOL,1}, {MED2,ISOL,2}, {MED2,FIN2,5}, {MED2,ISOL,6}, },\n+\n+  \/* State 5: prev was FIN2\/FIN3 ALAPH, not willing to join. *\/\n+  { {NONE,NONE,0}, {NONE,ISOL,2}, {ISOL,ISOL,1}, {ISOL,ISOL,2}, {ISOL,FIN2,5}, {ISOL,ISOL,6}, },\n+\n+  \/* State 6: prev was DALATH\/RISH, not willing to join. *\/\n+  { {NONE,NONE,0}, {NONE,ISOL,2}, {NONE,ISOL,1}, {NONE,ISOL,2}, {NONE,FIN3,5}, {NONE,ISOL,6}, }\n+};\n+\n+\n+static void\n+arabic_fallback_shape (const hb_ot_shape_plan_t *plan,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer);\n+\n+static void\n+record_stch (const hb_ot_shape_plan_t *plan,\n+             hb_font_t *font,\n+             hb_buffer_t *buffer);\n+\n+static void\n+collect_features_arabic (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* We apply features according to the Arabic spec, with pauses\n+   * in between most.\n+   *\n+   * The pause between init\/medi\/... and rlig is required.  See eg:\n+   * https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=644184\n+   *\n+   * The pauses between init\/medi\/... themselves are not necessarily\n+   * needed as only one of those features is applied to any character.\n+   * The only difference it makes is when fonts have contextual\n+   * substitutions.  We now follow the order of the spec, which makes\n+   * for better experience if that's what Uniscribe is doing.\n+   *\n+   * At least for Arabic, looks like Uniscribe has a pause between\n+   * rlig and calt.  Otherwise the IranNastaliq's ALLAH ligature won't\n+   * work.  However, testing shows that rlig and calt are applied\n+   * together for Mongolian in Uniscribe.  As such, we only add a\n+   * pause for Arabic, not other scripts.\n+   *\n+   * A pause after calt is required to make KFGQPC Uthmanic Script HAFS\n+   * work correctly.  See https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/505\n+   *\/\n+\n+\n+  map->enable_feature (HB_TAG('s','t','c','h'));\n+  map->add_gsub_pause (record_stch);\n+\n+  map->enable_feature (HB_TAG('c','c','m','p'));\n+  map->enable_feature (HB_TAG('l','o','c','l'));\n+\n+  map->add_gsub_pause (nullptr);\n+\n+  for (unsigned int i = 0; i < ARABIC_NUM_FEATURES; i++)\n+  {\n+    bool has_fallback = plan->props.script == HB_SCRIPT_ARABIC && !FEATURE_IS_SYRIAC (arabic_features[i]);\n+    map->add_feature (arabic_features[i], has_fallback ? F_HAS_FALLBACK : F_NONE);\n+    map->add_gsub_pause (nullptr);\n+  }\n+\n+  \/* Normally, Unicode says a ZWNJ means \"don't ligate\".  In Arabic script\n+   * however, it says a ZWJ should also mean \"don't ligate\".  So we run\n+   * the main ligating features as MANUAL_ZWJ. *\/\n+\n+  map->enable_feature (HB_TAG('r','l','i','g'), F_MANUAL_ZWJ | F_HAS_FALLBACK);\n+\n+  if (plan->props.script == HB_SCRIPT_ARABIC)\n+    map->add_gsub_pause (arabic_fallback_shape);\n+\n+  \/* No pause after rclt.  See 98460779bae19e4d64d29461ff154b3527bf8420. *\/\n+  map->enable_feature (HB_TAG('r','c','l','t'), F_MANUAL_ZWJ);\n+  map->enable_feature (HB_TAG('c','a','l','t'), F_MANUAL_ZWJ);\n+  map->add_gsub_pause (nullptr);\n+\n+  \/* And undo here. *\/\n+\n+  \/* The spec includes 'cswh'.  Earlier versions of Windows\n+   * used to enable this by default, but testing suggests\n+   * that Windows 8 and later do not enable it by default,\n+   * and spec now says 'Off by default'.\n+   * We disabled this in ae23c24c32.\n+   * Note that IranNastaliq uses this feature extensively\n+   * to fixup broken glyph sequences.  Oh well...\n+   * Test case: U+0643,U+0640,U+0631. *\/\n+  \/\/map->enable_feature (HB_TAG('c','s','w','h'));\n+  map->enable_feature (HB_TAG('m','s','e','t'));\n+}\n+\n+#include \"hb-ot-shape-complex-arabic-fallback.hh\"\n+\n+struct arabic_shape_plan_t\n+{\n+  \/* The \"+ 1\" in the next array is to accommodate for the \"NONE\" command,\n+   * which is not an OpenType feature, but this simplifies the code by not\n+   * having to do a \"if (... < NONE) ...\" and just rely on the fact that\n+   * mask_array[NONE] == 0. *\/\n+  hb_mask_t mask_array[ARABIC_NUM_FEATURES + 1];\n+\n+  hb_atomic_ptr_t<arabic_fallback_plan_t> fallback_plan;\n+\n+  unsigned int do_fallback : 1;\n+  unsigned int has_stch : 1;\n+};\n+\n+void *\n+data_create_arabic (const hb_ot_shape_plan_t *plan)\n+{\n+  arabic_shape_plan_t *arabic_plan = (arabic_shape_plan_t *) calloc (1, sizeof (arabic_shape_plan_t));\n+  if (unlikely (!arabic_plan))\n+    return nullptr;\n+\n+  arabic_plan->do_fallback = plan->props.script == HB_SCRIPT_ARABIC;\n+  arabic_plan->has_stch = !!plan->map.get_1_mask (HB_TAG ('s','t','c','h'));\n+  for (unsigned int i = 0; i < ARABIC_NUM_FEATURES; i++) {\n+    arabic_plan->mask_array[i] = plan->map.get_1_mask (arabic_features[i]);\n+    arabic_plan->do_fallback = arabic_plan->do_fallback &&\n+                               (FEATURE_IS_SYRIAC (arabic_features[i]) ||\n+                                plan->map.needs_fallback (arabic_features[i]));\n+  }\n+\n+  return arabic_plan;\n+}\n+\n+void\n+data_destroy_arabic (void *data)\n+{\n+  arabic_shape_plan_t *arabic_plan = (arabic_shape_plan_t *) data;\n+\n+  arabic_fallback_plan_destroy (arabic_plan->fallback_plan);\n+\n+  free (data);\n+}\n+\n+static void\n+arabic_joining (hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int prev = (unsigned int) -1, state = 0;\n+\n+  \/* Check pre-context *\/\n+  for (unsigned int i = 0; i < buffer->context_len[0]; i++)\n+  {\n+    unsigned int this_type = get_joining_type (buffer->context[0][i], buffer->unicode->general_category (buffer->context[0][i]));\n+\n+    if (unlikely (this_type == JOINING_TYPE_T))\n+      continue;\n+\n+    const arabic_state_table_entry *entry = &arabic_state_table[state][this_type];\n+    state = entry->next_state;\n+    break;\n+  }\n+\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    unsigned int this_type = get_joining_type (info[i].codepoint, _hb_glyph_info_get_general_category (&info[i]));\n+\n+    if (unlikely (this_type == JOINING_TYPE_T)) {\n+      info[i].arabic_shaping_action() = NONE;\n+      continue;\n+    }\n+\n+    const arabic_state_table_entry *entry = &arabic_state_table[state][this_type];\n+\n+    if (entry->prev_action != NONE && prev != (unsigned int) -1)\n+    {\n+      info[prev].arabic_shaping_action() = entry->prev_action;\n+      buffer->unsafe_to_break (prev, i + 1);\n+    }\n+\n+    info[i].arabic_shaping_action() = entry->curr_action;\n+\n+    prev = i;\n+    state = entry->next_state;\n+  }\n+\n+  for (unsigned int i = 0; i < buffer->context_len[1]; i++)\n+  {\n+    unsigned int this_type = get_joining_type (buffer->context[1][i], buffer->unicode->general_category (buffer->context[1][i]));\n+\n+    if (unlikely (this_type == JOINING_TYPE_T))\n+      continue;\n+\n+    const arabic_state_table_entry *entry = &arabic_state_table[state][this_type];\n+    if (entry->prev_action != NONE && prev != (unsigned int) -1)\n+      info[prev].arabic_shaping_action() = entry->prev_action;\n+    break;\n+  }\n+}\n+\n+static void\n+mongolian_variation_selectors (hb_buffer_t *buffer)\n+{\n+  \/* Copy arabic_shaping_action() from base to Mongolian variation selectors. *\/\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 1; i < count; i++)\n+    if (unlikely (hb_in_range<hb_codepoint_t> (info[i].codepoint, 0x180Bu, 0x180Du)))\n+      info[i].arabic_shaping_action() = info[i - 1].arabic_shaping_action();\n+}\n+\n+void\n+setup_masks_arabic_plan (const arabic_shape_plan_t *arabic_plan,\n+                         hb_buffer_t               *buffer,\n+                         hb_script_t                script)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, arabic_shaping_action);\n+\n+  arabic_joining (buffer);\n+  if (script == HB_SCRIPT_MONGOLIAN)\n+    mongolian_variation_selectors (buffer);\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    info[i].mask |= arabic_plan->mask_array[info[i].arabic_shaping_action()];\n+}\n+\n+static void\n+setup_masks_arabic (const hb_ot_shape_plan_t *plan,\n+                    hb_buffer_t              *buffer,\n+                    hb_font_t                *font HB_UNUSED)\n+{\n+  const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan->data;\n+  setup_masks_arabic_plan (arabic_plan, buffer, plan->props.script);\n+}\n+\n+static void\n+arabic_fallback_shape (const hb_ot_shape_plan_t *plan,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer)\n+{\n+  const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan->data;\n+\n+  if (!arabic_plan->do_fallback)\n+    return;\n+\n+retry:\n+  arabic_fallback_plan_t *fallback_plan = arabic_plan->fallback_plan;\n+  if (unlikely (!fallback_plan))\n+  {\n+    \/* This sucks.  We need a font to build the fallback plan... *\/\n+    fallback_plan = arabic_fallback_plan_create (plan, font);\n+    if (unlikely (!arabic_plan->fallback_plan.cmpexch (nullptr, fallback_plan)))\n+    {\n+      arabic_fallback_plan_destroy (fallback_plan);\n+      goto retry;\n+    }\n+  }\n+\n+  arabic_fallback_plan_shape (fallback_plan, font, buffer);\n+}\n+\n+\/*\n+ * Stretch feature: \"stch\".\n+ * See example here:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/syriac\n+ * We implement this in a generic way, such that the Arabic subtending\n+ * marks can use it as well.\n+ *\/\n+\n+static void\n+record_stch (const hb_ot_shape_plan_t *plan,\n+             hb_font_t *font HB_UNUSED,\n+             hb_buffer_t *buffer)\n+{\n+  const arabic_shape_plan_t *arabic_plan = (const arabic_shape_plan_t *) plan->data;\n+  if (!arabic_plan->has_stch)\n+    return;\n+\n+  \/* 'stch' feature was just applied.  Look for anything that multiplied,\n+   * and record it for stch treatment later.  Note that rtlm, frac, etc\n+   * are applied before stch, but we assume that they didn't result in\n+   * anything multiplying into 5 pieces, so it's safe-ish... *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    if (unlikely (_hb_glyph_info_multiplied (&info[i])))\n+    {\n+      unsigned int comp = _hb_glyph_info_get_lig_comp (&info[i]);\n+      info[i].arabic_shaping_action() = comp % 2 ? STCH_REPEATING : STCH_FIXED;\n+      buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH;\n+    }\n+}\n+\n+static void\n+apply_stch (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+            hb_buffer_t              *buffer,\n+            hb_font_t                *font)\n+{\n+  if (likely (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_ARABIC_HAS_STCH)))\n+    return;\n+\n+  \/* The Arabic shaper currently always processes in RTL mode, so we should\n+   * stretch \/ position the stretched pieces to the left \/ preceding glyphs. *\/\n+\n+  \/* We do a two pass implementation:\n+   * First pass calculates the exact number of extra glyphs we need,\n+   * We then enlarge buffer to have that much room,\n+   * Second pass applies the stretch, copying things to the end of buffer.\n+   *\/\n+\n+  int sign = font->x_scale < 0 ? -1 : +1;\n+  unsigned int extra_glyphs_needed = 0; \/\/ Set during MEASURE, used during CUT\n+  enum { MEASURE, CUT } \/* step_t *\/;\n+\n+  for (unsigned int step = MEASURE; step <= CUT; step = step + 1)\n+  {\n+    unsigned int count = buffer->len;\n+    hb_glyph_info_t *info = buffer->info;\n+    hb_glyph_position_t *pos = buffer->pos;\n+    unsigned int new_len = count + extra_glyphs_needed; \/\/ write head during CUT\n+    unsigned int j = new_len;\n+    for (unsigned int i = count; i; i--)\n+    {\n+      if (!hb_in_range<unsigned> (info[i - 1].arabic_shaping_action(), STCH_FIXED, STCH_REPEATING))\n+      {\n+        if (step == CUT)\n+        {\n+          --j;\n+          info[j] = info[i - 1];\n+          pos[j] = pos[i - 1];\n+        }\n+        continue;\n+      }\n+\n+      \/* Yay, justification! *\/\n+\n+      hb_position_t w_total = 0; \/\/ Total to be filled\n+      hb_position_t w_fixed = 0; \/\/ Sum of fixed tiles\n+      hb_position_t w_repeating = 0; \/\/ Sum of repeating tiles\n+      int n_fixed = 0;\n+      int n_repeating = 0;\n+\n+      unsigned int end = i;\n+      while (i &&\n+             hb_in_range<unsigned> (info[i - 1].arabic_shaping_action(), STCH_FIXED, STCH_REPEATING))\n+      {\n+        i--;\n+        hb_position_t width = font->get_glyph_h_advance (info[i].codepoint);\n+        if (info[i].arabic_shaping_action() == STCH_FIXED)\n+        {\n+          w_fixed += width;\n+          n_fixed++;\n+        }\n+        else\n+        {\n+          w_repeating += width;\n+          n_repeating++;\n+        }\n+      }\n+      unsigned int start = i;\n+      unsigned int context = i;\n+      while (context &&\n+             !hb_in_range<unsigned> (info[context - 1].arabic_shaping_action(), STCH_FIXED, STCH_REPEATING) &&\n+             (_hb_glyph_info_is_default_ignorable (&info[context - 1]) ||\n+              HB_ARABIC_GENERAL_CATEGORY_IS_WORD (_hb_glyph_info_get_general_category (&info[context - 1]))))\n+      {\n+        context--;\n+        w_total += pos[context].x_advance;\n+      }\n+      i++; \/\/ Don't touch i again.\n+\n+      DEBUG_MSG (ARABIC, nullptr, \"%s stretch at (%d,%d,%d)\",\n+                 step == MEASURE ? \"measuring\" : \"cutting\", context, start, end);\n+      DEBUG_MSG (ARABIC, nullptr, \"rest of word:    count=%d width %d\", start - context, w_total);\n+      DEBUG_MSG (ARABIC, nullptr, \"fixed tiles:     count=%d width=%d\", n_fixed, w_fixed);\n+      DEBUG_MSG (ARABIC, nullptr, \"repeating tiles: count=%d width=%d\", n_repeating, w_repeating);\n+\n+      \/* Number of additional times to repeat each repeating tile. *\/\n+      int n_copies = 0;\n+\n+      hb_position_t w_remaining = w_total - w_fixed;\n+      if (sign * w_remaining > sign * w_repeating && sign * w_repeating > 0)\n+        n_copies = (sign * w_remaining) \/ (sign * w_repeating) - 1;\n+\n+      \/* See if we can improve the fit by adding an extra repeat and squeezing them together a bit. *\/\n+      hb_position_t extra_repeat_overlap = 0;\n+      hb_position_t shortfall = sign * w_remaining - sign * w_repeating * (n_copies + 1);\n+      if (shortfall > 0 && n_repeating > 0)\n+      {\n+        ++n_copies;\n+        hb_position_t excess = (n_copies + 1) * sign * w_repeating - sign * w_remaining;\n+        if (excess > 0)\n+          extra_repeat_overlap = excess \/ (n_copies * n_repeating);\n+      }\n+\n+      if (step == MEASURE)\n+      {\n+        extra_glyphs_needed += n_copies * n_repeating;\n+        DEBUG_MSG (ARABIC, nullptr, \"will add extra %d copies of repeating tiles\", n_copies);\n+      }\n+      else\n+      {\n+        buffer->unsafe_to_break (context, end);\n+        hb_position_t x_offset = 0;\n+        for (unsigned int k = end; k > start; k--)\n+        {\n+          hb_position_t width = font->get_glyph_h_advance (info[k - 1].codepoint);\n+\n+          unsigned int repeat = 1;\n+          if (info[k - 1].arabic_shaping_action() == STCH_REPEATING)\n+            repeat += n_copies;\n+\n+          DEBUG_MSG (ARABIC, nullptr, \"appending %d copies of glyph %d; j=%d\",\n+                     repeat, info[k - 1].codepoint, j);\n+          for (unsigned int n = 0; n < repeat; n++)\n+          {\n+            x_offset -= width;\n+            if (n > 0)\n+              x_offset += extra_repeat_overlap;\n+            pos[k - 1].x_offset = x_offset;\n+            \/* Append copy. *\/\n+            --j;\n+            info[j] = info[k - 1];\n+            pos[j] = pos[k - 1];\n+          }\n+        }\n+      }\n+    }\n+\n+    if (step == MEASURE)\n+    {\n+      if (unlikely (!buffer->ensure (count + extra_glyphs_needed)))\n+        break;\n+    }\n+    else\n+    {\n+      assert (j == 0);\n+      buffer->len = new_len;\n+    }\n+  }\n+}\n+\n+\n+static void\n+postprocess_glyphs_arabic (const hb_ot_shape_plan_t *plan,\n+                           hb_buffer_t              *buffer,\n+                           hb_font_t                *font)\n+{\n+  apply_stch (plan, buffer, font);\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, arabic_shaping_action);\n+}\n+\n+\/* http:\/\/www.unicode.org\/reports\/tr53\/ *\/\n+\n+static hb_codepoint_t\n+modifier_combining_marks[] =\n+{\n+  0x0654u, \/* ARABIC HAMZA ABOVE *\/\n+  0x0655u, \/* ARABIC HAMZA BELOW *\/\n+  0x0658u, \/* ARABIC MARK NOON GHUNNA *\/\n+  0x06DCu, \/* ARABIC SMALL HIGH SEEN *\/\n+  0x06E3u, \/* ARABIC SMALL LOW SEEN *\/\n+  0x06E7u, \/* ARABIC SMALL HIGH YEH *\/\n+  0x06E8u, \/* ARABIC SMALL HIGH NOON *\/\n+  0x08D3u, \/* ARABIC SMALL LOW WAW *\/\n+  0x08F3u, \/* ARABIC SMALL HIGH WAW *\/\n+};\n+\n+static inline bool\n+info_is_mcm (const hb_glyph_info_t &info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (modifier_combining_marks); i++)\n+    if (u == modifier_combining_marks[i])\n+      return true;\n+  return false;\n+}\n+\n+static void\n+reorder_marks_arabic (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                      hb_buffer_t              *buffer,\n+                      unsigned int              start,\n+                      unsigned int              end)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  DEBUG_MSG (ARABIC, buffer, \"Reordering marks from %d to %d\", start, end);\n+\n+  unsigned int i = start;\n+  for (unsigned int cc = 220; cc <= 230; cc += 10)\n+  {\n+    DEBUG_MSG (ARABIC, buffer, \"Looking for %d's starting at %d\", cc, i);\n+    while (i < end && info_cc(info[i]) < cc)\n+      i++;\n+    DEBUG_MSG (ARABIC, buffer, \"Looking for %d's stopped at %d\", cc, i);\n+\n+    if (i == end)\n+      break;\n+\n+    if (info_cc(info[i]) > cc)\n+      continue;\n+\n+    unsigned int j = i;\n+    while (j < end && info_cc(info[j]) == cc && info_is_mcm (info[j]))\n+      j++;\n+\n+    if (i == j)\n+      continue;\n+\n+    DEBUG_MSG (ARABIC, buffer, \"Found %d's from %d to %d\", cc, i, j);\n+\n+    \/* Shift it! *\/\n+    DEBUG_MSG (ARABIC, buffer, \"Shifting %d's: %d %d\", cc, i, j);\n+    hb_glyph_info_t temp[HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS];\n+    assert (j - i <= ARRAY_LENGTH (temp));\n+    buffer->merge_clusters (start, j);\n+    memmove (temp, &info[i], (j - i) * sizeof (hb_glyph_info_t));\n+    memmove (&info[start + j - i], &info[start], (i - start) * sizeof (hb_glyph_info_t));\n+    memmove (&info[start], temp, (j - i) * sizeof (hb_glyph_info_t));\n+\n+    \/* Renumber CC such that the reordered sequence is still sorted.\n+     * 22 and 26 are chosen because they are smaller than all Arabic categories,\n+     * and are folded back to 220\/230 respectively during fallback mark positioning.\n+     *\n+     * We do this because the CGJ-handling logic in the normalizer relies on\n+     * mark sequences having an increasing order even after this reordering.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/554\n+     * This, however, does break some obscure sequences, where the normalizer\n+     * might compose a sequence that it should not.  For example, in the seequence\n+     * ALEF, HAMZAH, MADDAH, we should NOT try to compose ALEF+MADDAH, but with this\n+     * renumbering, we will.\n+     *\/\n+    unsigned int new_start = start + j - i;\n+    unsigned int new_cc = cc == 220 ? HB_MODIFIED_COMBINING_CLASS_CCC22 : HB_MODIFIED_COMBINING_CLASS_CCC26;\n+    while (start < new_start)\n+    {\n+      _hb_glyph_info_set_modified_combining_class (&info[start], new_cc);\n+      start++;\n+    }\n+\n+    i = j;\n+  }\n+}\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_arabic =\n+{\n+  collect_features_arabic,\n+  nullptr, \/* override_features *\/\n+  data_create_arabic,\n+  data_destroy_arabic,\n+  nullptr, \/* preprocess_text *\/\n+  postprocess_glyphs_arabic,\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  setup_masks_arabic,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  reorder_marks_arabic,\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,\n+  true, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-arabic.cc","additions":708,"deletions":0,"binary":false,"changes":708,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-arabic.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-arabic.hh","status":"copied"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex.hh\"\n+\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_default =\n+{\n+  nullptr, \/* collect_features *\/\n+  nullptr, \/* override_features *\/\n+  nullptr, \/* data_create *\/\n+  nullptr, \/* data_destroy *\/\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  nullptr, \/* setup_masks *\/\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,\n+  true, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-default.cc","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,431 @@\n+\/*\n+ * Copyright © 2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex.hh\"\n+\n+\n+\/* Hangul shaper *\/\n+\n+\n+\/* Same order as the feature array below *\/\n+enum {\n+  _JMO,\n+\n+  LJMO,\n+  VJMO,\n+  TJMO,\n+\n+  FIRST_HANGUL_FEATURE = LJMO,\n+  HANGUL_FEATURE_COUNT = TJMO + 1\n+};\n+\n+static const hb_tag_t hangul_features[HANGUL_FEATURE_COUNT] =\n+{\n+  HB_TAG_NONE,\n+  HB_TAG('l','j','m','o'),\n+  HB_TAG('v','j','m','o'),\n+  HB_TAG('t','j','m','o')\n+};\n+\n+static void\n+collect_features_hangul (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  for (unsigned int i = FIRST_HANGUL_FEATURE; i < HANGUL_FEATURE_COUNT; i++)\n+    map->add_feature (hangul_features[i]);\n+}\n+\n+static void\n+override_features_hangul (hb_ot_shape_planner_t *plan)\n+{\n+  \/* Uniscribe does not apply 'calt' for Hangul, and certain fonts\n+   * (Noto Sans CJK, Source Sans Han, etc) apply all of jamo lookups\n+   * in calt, which is not desirable. *\/\n+  plan->map.disable_feature (HB_TAG('c','a','l','t'));\n+}\n+\n+struct hangul_shape_plan_t\n+{\n+  hb_mask_t mask_array[HANGUL_FEATURE_COUNT];\n+};\n+\n+static void *\n+data_create_hangul (const hb_ot_shape_plan_t *plan)\n+{\n+  hangul_shape_plan_t *hangul_plan = (hangul_shape_plan_t *) calloc (1, sizeof (hangul_shape_plan_t));\n+  if (unlikely (!hangul_plan))\n+    return nullptr;\n+\n+  for (unsigned int i = 0; i < HANGUL_FEATURE_COUNT; i++)\n+    hangul_plan->mask_array[i] = plan->map.get_1_mask (hangul_features[i]);\n+\n+  return hangul_plan;\n+}\n+\n+static void\n+data_destroy_hangul (void *data)\n+{\n+  free (data);\n+}\n+\n+\/* Constants for algorithmic hangul syllable [de]composition. *\/\n+#define LBase 0x1100u\n+#define VBase 0x1161u\n+#define TBase 0x11A7u\n+#define LCount 19u\n+#define VCount 21u\n+#define TCount 28u\n+#define SBase 0xAC00u\n+#define NCount (VCount * TCount)\n+#define SCount (LCount * NCount)\n+\n+#define isCombiningL(u) (hb_in_range<hb_codepoint_t> ((u), LBase, LBase+LCount-1))\n+#define isCombiningV(u) (hb_in_range<hb_codepoint_t> ((u), VBase, VBase+VCount-1))\n+#define isCombiningT(u) (hb_in_range<hb_codepoint_t> ((u), TBase+1, TBase+TCount-1))\n+#define isCombinedS(u) (hb_in_range<hb_codepoint_t> ((u), SBase, SBase+SCount-1))\n+\n+#define isL(u) (hb_in_ranges<hb_codepoint_t> ((u), 0x1100u, 0x115Fu, 0xA960u, 0xA97Cu))\n+#define isV(u) (hb_in_ranges<hb_codepoint_t> ((u), 0x1160u, 0x11A7u, 0xD7B0u, 0xD7C6u))\n+#define isT(u) (hb_in_ranges<hb_codepoint_t> ((u), 0x11A8u, 0x11FFu, 0xD7CBu, 0xD7FBu))\n+\n+#define isHangulTone(u) (hb_in_range<hb_codepoint_t> ((u), 0x302Eu, 0x302Fu))\n+\n+\/* buffer var allocations *\/\n+#define hangul_shaping_feature() complex_var_u8_0() \/* hangul jamo shaping feature *\/\n+\n+static bool\n+is_zero_width_char (hb_font_t *font,\n+                    hb_codepoint_t unicode)\n+{\n+  hb_codepoint_t glyph;\n+  return hb_font_get_glyph (font, unicode, 0, &glyph) && hb_font_get_glyph_h_advance (font, glyph) == 0;\n+}\n+\n+static void\n+preprocess_text_hangul (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                        hb_buffer_t              *buffer,\n+                        hb_font_t                *font)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, hangul_shaping_feature);\n+\n+  \/* Hangul syllables come in two shapes: LV, and LVT.  Of those:\n+   *\n+   *   - LV can be precomposed, or decomposed.  Lets call those\n+   *     <LV> and <L,V>,\n+   *   - LVT can be fully precomposed, partically precomposed, or\n+   *     fully decomposed.  Ie. <LVT>, <LV,T>, or <L,V,T>.\n+   *\n+   * The composition \/ decomposition is mechanical.  However, not\n+   * all <L,V> sequences compose, and not all <LV,T> sequences\n+   * compose.\n+   *\n+   * Here are the specifics:\n+   *\n+   *   - <L>: U+1100..115F, U+A960..A97F\n+   *   - <V>: U+1160..11A7, U+D7B0..D7C7\n+   *   - <T>: U+11A8..11FF, U+D7CB..D7FB\n+   *\n+   *   - Only the <L,V> sequences for some of the U+11xx ranges combine.\n+   *   - Only <LV,T> sequences for some of the Ts in U+11xx range combine.\n+   *\n+   * Here is what we want to accomplish in this shaper:\n+   *\n+   *   - If the whole syllable can be precomposed, do that,\n+   *   - Otherwise, fully decompose and apply ljmo\/vjmo\/tjmo features.\n+   *   - If a valid syllable is followed by a Hangul tone mark, reorder the tone\n+   *     mark to precede the whole syllable - unless it is a zero-width glyph, in\n+   *     which case we leave it untouched, assuming it's designed to overstrike.\n+   *\n+   * That is, of the different possible syllables:\n+   *\n+   *   <L>\n+   *   <L,V>\n+   *   <L,V,T>\n+   *   <LV>\n+   *   <LVT>\n+   *   <LV, T>\n+   *\n+   * - <L> needs no work.\n+   *\n+   * - <LV> and <LVT> can stay the way they are if the font supports them, otherwise we\n+   *   should fully decompose them if font supports.\n+   *\n+   * - <L,V> and <L,V,T> we should compose if the whole thing can be composed.\n+   *\n+   * - <LV,T> we should compose if the whole thing can be composed, otherwise we should\n+   *   decompose.\n+   *\/\n+\n+  buffer->clear_output ();\n+  unsigned int start = 0, end = 0; \/* Extent of most recently seen syllable;\n+                                    * valid only if start < end\n+                                    *\/\n+  unsigned int count = buffer->len;\n+\n+  for (buffer->idx = 0; buffer->idx < count && buffer->successful;)\n+  {\n+    hb_codepoint_t u = buffer->cur().codepoint;\n+\n+    if (isHangulTone (u))\n+    {\n+      \/*\n+       * We could cache the width of the tone marks and the existence of dotted-circle,\n+       * but the use of the Hangul tone mark characters seems to be rare enough that\n+       * I didn't bother for now.\n+       *\/\n+      if (start < end && end == buffer->out_len)\n+      {\n+        \/* Tone mark follows a valid syllable; move it in front, unless it's zero width. *\/\n+        buffer->unsafe_to_break_from_outbuffer (start, buffer->idx);\n+        buffer->next_glyph ();\n+        if (!is_zero_width_char (font, u))\n+        {\n+          buffer->merge_out_clusters (start, end + 1);\n+          hb_glyph_info_t *info = buffer->out_info;\n+          hb_glyph_info_t tone = info[end];\n+          memmove (&info[start + 1], &info[start], (end - start) * sizeof (hb_glyph_info_t));\n+          info[start] = tone;\n+        }\n+      }\n+      else\n+      {\n+        \/* No valid syllable as base for tone mark; try to insert dotted circle. *\/\n+        if (font->has_glyph (0x25CCu))\n+        {\n+          hb_codepoint_t chars[2];\n+          if (!is_zero_width_char (font, u)) {\n+            chars[0] = u;\n+            chars[1] = 0x25CCu;\n+          } else {\n+            chars[0] = 0x25CCu;\n+            chars[1] = u;\n+          }\n+          buffer->replace_glyphs (1, 2, chars);\n+        }\n+        else\n+        {\n+          \/* No dotted circle available in the font; just leave tone mark untouched. *\/\n+          buffer->next_glyph ();\n+        }\n+      }\n+      start = end = buffer->out_len;\n+      continue;\n+    }\n+\n+    start = buffer->out_len; \/* Remember current position as a potential syllable start;\n+                              * will only be used if we set end to a later position.\n+                              *\/\n+\n+    if (isL (u) && buffer->idx + 1 < count)\n+    {\n+      hb_codepoint_t l = u;\n+      hb_codepoint_t v = buffer->cur(+1).codepoint;\n+      if (isV (v))\n+      {\n+        \/* Have <L,V> or <L,V,T>. *\/\n+        hb_codepoint_t t = 0;\n+        unsigned int tindex = 0;\n+        if (buffer->idx + 2 < count)\n+        {\n+          t = buffer->cur(+2).codepoint;\n+          if (isT (t))\n+            tindex = t - TBase; \/* Only used if isCombiningT (t); otherwise invalid. *\/\n+          else\n+            t = 0; \/* The next character was not a trailing jamo. *\/\n+        }\n+        buffer->unsafe_to_break (buffer->idx, buffer->idx + (t ? 3 : 2));\n+\n+        \/* We've got a syllable <L,V,T?>; see if it can potentially be composed. *\/\n+        if (isCombiningL (l) && isCombiningV (v) && (t == 0 || isCombiningT (t)))\n+        {\n+          \/* Try to compose; if this succeeds, end is set to start+1. *\/\n+          hb_codepoint_t s = SBase + (l - LBase) * NCount + (v - VBase) * TCount + tindex;\n+          if (font->has_glyph (s))\n+          {\n+            buffer->replace_glyphs (t ? 3 : 2, 1, &s);\n+            if (unlikely (!buffer->successful))\n+              return;\n+            end = start + 1;\n+            continue;\n+          }\n+        }\n+\n+        \/* We didn't compose, either because it's an Old Hangul syllable without a\n+         * precomposed character in Unicode, or because the font didn't support the\n+         * necessary precomposed glyph.\n+         * Set jamo features on the individual glyphs, and advance past them.\n+         *\/\n+        buffer->cur().hangul_shaping_feature() = LJMO;\n+        buffer->next_glyph ();\n+        buffer->cur().hangul_shaping_feature() = VJMO;\n+        buffer->next_glyph ();\n+        if (t)\n+        {\n+          buffer->cur().hangul_shaping_feature() = TJMO;\n+          buffer->next_glyph ();\n+          end = start + 3;\n+        }\n+        else\n+          end = start + 2;\n+        if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n+          buffer->merge_out_clusters (start, end);\n+        continue;\n+      }\n+    }\n+\n+    else if (isCombinedS (u))\n+    {\n+      \/* Have <LV>, <LVT>, or <LV,T> *\/\n+      hb_codepoint_t s = u;\n+      bool has_glyph = font->has_glyph (s);\n+      unsigned int lindex = (s - SBase) \/ NCount;\n+      unsigned int nindex = (s - SBase) % NCount;\n+      unsigned int vindex = nindex \/ TCount;\n+      unsigned int tindex = nindex % TCount;\n+\n+      if (!tindex &&\n+          buffer->idx + 1 < count &&\n+          isCombiningT (buffer->cur(+1).codepoint))\n+      {\n+        \/* <LV,T>, try to combine. *\/\n+        unsigned int new_tindex = buffer->cur(+1).codepoint - TBase;\n+        hb_codepoint_t new_s = s + new_tindex;\n+        if (font->has_glyph (new_s))\n+        {\n+          buffer->replace_glyphs (2, 1, &new_s);\n+          if (unlikely (!buffer->successful))\n+            return;\n+          end = start + 1;\n+          continue;\n+        }\n+        else\n+          buffer->unsafe_to_break (buffer->idx, buffer->idx + 2); \/* Mark unsafe between LV and T. *\/\n+      }\n+\n+      \/* Otherwise, decompose if font doesn't support <LV> or <LVT>,\n+       * or if having non-combining <LV,T>.  Note that we already handled\n+       * combining <LV,T> above. *\/\n+      if (!has_glyph ||\n+          (!tindex &&\n+           buffer->idx + 1 < count &&\n+           isT (buffer->cur(+1).codepoint)))\n+      {\n+        hb_codepoint_t decomposed[3] = {LBase + lindex,\n+                                        VBase + vindex,\n+                                        TBase + tindex};\n+        if (font->has_glyph (decomposed[0]) &&\n+            font->has_glyph (decomposed[1]) &&\n+            (!tindex || font->has_glyph (decomposed[2])))\n+        {\n+          unsigned int s_len = tindex ? 3 : 2;\n+          buffer->replace_glyphs (1, s_len, decomposed);\n+\n+          \/* If we decomposed an LV because of a non-combining T following,\n+           * we want to include this T in the syllable.\n+           *\/\n+          if (has_glyph && !tindex)\n+          {\n+            buffer->next_glyph ();\n+            s_len++;\n+          }\n+\n+          if (unlikely (!buffer->successful))\n+            return;\n+\n+          \/* We decomposed S: apply jamo features to the individual glyphs\n+           * that are now in buffer->out_info.\n+           *\/\n+          hb_glyph_info_t *info = buffer->out_info;\n+          end = start + s_len;\n+\n+          unsigned int i = start;\n+          info[i++].hangul_shaping_feature() = LJMO;\n+          info[i++].hangul_shaping_feature() = VJMO;\n+          if (i < end)\n+            info[i++].hangul_shaping_feature() = TJMO;\n+\n+          if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n+            buffer->merge_out_clusters (start, end);\n+          continue;\n+        }\n+        else if ((!tindex && buffer->idx + 1 < count && isT (buffer->cur(+1).codepoint)))\n+          buffer->unsafe_to_break (buffer->idx, buffer->idx + 2); \/* Mark unsafe between LV and T. *\/\n+      }\n+\n+      if (has_glyph)\n+      {\n+        \/* We didn't decompose the S, so just advance past it. *\/\n+        end = start + 1;\n+        buffer->next_glyph ();\n+        continue;\n+      }\n+    }\n+\n+    \/* Didn't find a recognizable syllable, so we leave end <= start;\n+     * this will prevent tone-mark reordering happening.\n+     *\/\n+    buffer->next_glyph ();\n+  }\n+  buffer->swap_buffers ();\n+}\n+\n+static void\n+setup_masks_hangul (const hb_ot_shape_plan_t *plan,\n+                    hb_buffer_t              *buffer,\n+                    hb_font_t                *font HB_UNUSED)\n+{\n+  const hangul_shape_plan_t *hangul_plan = (const hangul_shape_plan_t *) plan->data;\n+\n+  if (likely (hangul_plan))\n+  {\n+    unsigned int count = buffer->len;\n+    hb_glyph_info_t *info = buffer->info;\n+    for (unsigned int i = 0; i < count; i++, info++)\n+      info->mask |= hangul_plan->mask_array[info->hangul_shaping_feature()];\n+  }\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, hangul_shaping_feature);\n+}\n+\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_hangul =\n+{\n+  collect_features_hangul,\n+  override_features_hangul,\n+  data_create_hangul,\n+  data_destroy_hangul,\n+  preprocess_text_hangul,\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  setup_masks_hangul,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  false, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-hangul.cc","additions":431,"deletions":0,"binary":false,"changes":431,"status":"added"},{"patch":"@@ -0,0 +1,174 @@\n+\/*\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex.hh\"\n+\n+\n+static bool\n+compose_hebrew (const hb_ot_shape_normalize_context_t *c,\n+                hb_codepoint_t  a,\n+                hb_codepoint_t  b,\n+                hb_codepoint_t *ab)\n+{\n+  \/* Hebrew presentation-form shaping.\n+   * https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=728866\n+   * Hebrew presentation forms with dagesh, for characters U+05D0..05EA;\n+   * Note that some letters do not have a dagesh presForm encoded.\n+   *\/\n+  static const hb_codepoint_t sDageshForms[0x05EAu - 0x05D0u + 1] = {\n+    0xFB30u, \/* ALEF *\/\n+    0xFB31u, \/* BET *\/\n+    0xFB32u, \/* GIMEL *\/\n+    0xFB33u, \/* DALET *\/\n+    0xFB34u, \/* HE *\/\n+    0xFB35u, \/* VAV *\/\n+    0xFB36u, \/* ZAYIN *\/\n+    0x0000u, \/* HET *\/\n+    0xFB38u, \/* TET *\/\n+    0xFB39u, \/* YOD *\/\n+    0xFB3Au, \/* FINAL KAF *\/\n+    0xFB3Bu, \/* KAF *\/\n+    0xFB3Cu, \/* LAMED *\/\n+    0x0000u, \/* FINAL MEM *\/\n+    0xFB3Eu, \/* MEM *\/\n+    0x0000u, \/* FINAL NUN *\/\n+    0xFB40u, \/* NUN *\/\n+    0xFB41u, \/* SAMEKH *\/\n+    0x0000u, \/* AYIN *\/\n+    0xFB43u, \/* FINAL PE *\/\n+    0xFB44u, \/* PE *\/\n+    0x0000u, \/* FINAL TSADI *\/\n+    0xFB46u, \/* TSADI *\/\n+    0xFB47u, \/* QOF *\/\n+    0xFB48u, \/* RESH *\/\n+    0xFB49u, \/* SHIN *\/\n+    0xFB4Au \/* TAV *\/\n+  };\n+\n+  bool found = (bool) c->unicode->compose (a, b, ab);\n+\n+  if (!found && !c->plan->has_gpos_mark)\n+  {\n+      \/* Special-case Hebrew presentation forms that are excluded from\n+       * standard normalization, but wanted for old fonts. *\/\n+      switch (b) {\n+      case 0x05B4u: \/* HIRIQ *\/\n+          if (a == 0x05D9u) { \/* YOD *\/\n+              *ab = 0xFB1Du;\n+              found = true;\n+          }\n+          break;\n+      case 0x05B7u: \/* patah *\/\n+          if (a == 0x05F2u) { \/* YIDDISH YOD YOD *\/\n+              *ab = 0xFB1Fu;\n+              found = true;\n+          } else if (a == 0x05D0u) { \/* ALEF *\/\n+              *ab = 0xFB2Eu;\n+              found = true;\n+          }\n+          break;\n+      case 0x05B8u: \/* QAMATS *\/\n+          if (a == 0x05D0u) { \/* ALEF *\/\n+              *ab = 0xFB2Fu;\n+              found = true;\n+          }\n+          break;\n+      case 0x05B9u: \/* HOLAM *\/\n+          if (a == 0x05D5u) { \/* VAV *\/\n+              *ab = 0xFB4Bu;\n+              found = true;\n+          }\n+          break;\n+      case 0x05BCu: \/* DAGESH *\/\n+          if (a >= 0x05D0u && a <= 0x05EAu) {\n+              *ab = sDageshForms[a - 0x05D0u];\n+              found = (*ab != 0);\n+          } else if (a == 0xFB2Au) { \/* SHIN WITH SHIN DOT *\/\n+              *ab = 0xFB2Cu;\n+              found = true;\n+          } else if (a == 0xFB2Bu) { \/* SHIN WITH SIN DOT *\/\n+              *ab = 0xFB2Du;\n+              found = true;\n+          }\n+          break;\n+      case 0x05BFu: \/* RAFE *\/\n+          switch (a) {\n+          case 0x05D1u: \/* BET *\/\n+              *ab = 0xFB4Cu;\n+              found = true;\n+              break;\n+          case 0x05DBu: \/* KAF *\/\n+              *ab = 0xFB4Du;\n+              found = true;\n+              break;\n+          case 0x05E4u: \/* PE *\/\n+              *ab = 0xFB4Eu;\n+              found = true;\n+              break;\n+          }\n+          break;\n+      case 0x05C1u: \/* SHIN DOT *\/\n+          if (a == 0x05E9u) { \/* SHIN *\/\n+              *ab = 0xFB2Au;\n+              found = true;\n+          } else if (a == 0xFB49u) { \/* SHIN WITH DAGESH *\/\n+              *ab = 0xFB2Cu;\n+              found = true;\n+          }\n+          break;\n+      case 0x05C2u: \/* SIN DOT *\/\n+          if (a == 0x05E9u) { \/* SHIN *\/\n+              *ab = 0xFB2Bu;\n+              found = true;\n+          } else if (a == 0xFB49u) { \/* SHIN WITH DAGESH *\/\n+              *ab = 0xFB2Du;\n+              found = true;\n+          }\n+          break;\n+      }\n+  }\n+\n+  return found;\n+}\n+\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_hebrew =\n+{\n+  nullptr, \/* collect_features *\/\n+  nullptr, \/* override_features *\/\n+  nullptr, \/* data_create *\/\n+  nullptr, \/* data_destroy *\/\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n+  nullptr, \/* decompose *\/\n+  compose_hebrew,\n+  nullptr, \/* setup_masks *\/\n+  HB_TAG ('h','e','b','r'), \/* gpos_tag. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/347#issuecomment-267838368 *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,\n+  true, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-hebrew.cc","additions":174,"deletions":0,"binary":false,"changes":174,"status":"added"},{"patch":"@@ -0,0 +1,1115 @@\n+\n+#line 1 \"hb-ot-shape-complex-indic-machine.rl\"\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH\n+#define HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 36 \"hb-ot-shape-complex-indic-machine.hh\"\n+static const unsigned char _indic_syllable_machine_trans_keys[] = {\n+        8u, 8u, 4u, 8u, 5u, 7u, 7u, 7u, 5u, 8u, 5u, 7u, 7u, 7u, 5u, 8u,\n+        5u, 7u, 7u, 7u, 5u, 8u, 5u, 7u, 7u, 7u, 4u, 8u, 6u, 6u, 16u, 16u,\n+        4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u,\n+        16u, 16u, 4u, 13u, 4u, 8u, 4u, 13u, 4u, 8u, 4u, 13u, 4u, 8u, 4u, 13u,\n+        4u, 8u, 4u, 13u, 8u, 8u, 4u, 8u, 5u, 7u, 7u, 7u, 5u, 8u, 5u, 7u,\n+        7u, 7u, 5u, 8u, 5u, 7u, 7u, 7u, 5u, 8u, 5u, 7u, 7u, 7u, 4u, 8u,\n+        6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u, 16u, 16u,\n+        4u, 8u, 6u, 6u, 16u, 16u, 4u, 13u, 4u, 8u, 4u, 13u, 4u, 8u, 4u, 13u,\n+        4u, 8u, 4u, 13u, 4u, 8u, 4u, 13u, 8u, 8u, 4u, 8u, 5u, 7u, 7u, 7u,\n+        5u, 8u, 5u, 7u, 7u, 7u, 5u, 8u, 5u, 7u, 7u, 7u, 5u, 8u, 5u, 7u,\n+        7u, 7u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u,\n+        6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 13u, 4u, 8u, 4u, 13u,\n+        4u, 8u, 4u, 13u, 4u, 8u, 4u, 13u, 4u, 8u, 8u, 8u, 4u, 8u, 5u, 7u,\n+        7u, 7u, 5u, 8u, 5u, 7u, 7u, 7u, 5u, 8u, 5u, 7u, 7u, 7u, 5u, 8u,\n+        5u, 7u, 7u, 7u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u, 16u, 16u,\n+        4u, 8u, 6u, 6u, 16u, 16u, 4u, 8u, 6u, 6u, 16u, 16u, 4u, 13u, 4u, 8u,\n+        4u, 13u, 4u, 8u, 4u, 13u, 4u, 8u, 4u, 13u, 4u, 8u, 4u, 13u, 4u, 13u,\n+        5u, 8u, 8u, 8u, 1u, 19u, 3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u,\n+        3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u,\n+        3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 5u, 10u, 5u, 10u,\n+        5u, 10u, 10u, 10u, 10u, 10u, 10u, 10u, 5u, 10u, 3u, 10u, 5u, 10u, 3u, 10u,\n+        4u, 10u, 5u, 10u, 3u, 10u, 4u, 10u, 5u, 10u, 3u, 10u, 4u, 10u, 5u, 10u,\n+        3u, 10u, 4u, 10u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u,\n+        3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u,\n+        1u, 16u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u,\n+        3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u,\n+        3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u,\n+        3u, 13u, 3u, 10u, 4u, 10u, 5u, 10u, 5u, 10u, 5u, 10u, 10u, 10u, 10u, 10u,\n+        10u, 10u, 5u, 10u, 3u, 10u, 5u, 10u, 3u, 10u, 4u, 10u, 5u, 10u, 3u, 10u,\n+        4u, 10u, 5u, 10u, 3u, 10u, 4u, 10u, 5u, 10u, 3u, 10u, 4u, 10u, 3u, 10u,\n+        3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u,\n+        1u, 16u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u,\n+        1u, 16u, 1u, 16u, 1u, 16u, 4u, 8u, 3u, 10u, 3u, 10u, 4u, 10u, 1u, 16u,\n+        3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u,\n+        3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 5u, 10u,\n+        5u, 10u, 5u, 10u, 10u, 10u, 10u, 10u, 10u, 10u, 5u, 10u, 3u, 10u, 5u, 10u,\n+        3u, 10u, 4u, 10u, 5u, 10u, 3u, 10u, 4u, 10u, 5u, 10u, 3u, 10u, 4u, 10u,\n+        5u, 10u, 3u, 10u, 4u, 10u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u,\n+        3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u, 1u, 16u,\n+        1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 4u, 13u,\n+        3u, 10u, 4u, 8u, 3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u,\n+        4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u,\n+        4u, 10u, 1u, 16u, 3u, 13u, 3u, 10u, 4u, 10u, 5u, 10u, 5u, 10u, 5u, 10u,\n+        10u, 10u, 10u, 10u, 10u, 10u, 5u, 10u, 3u, 10u, 5u, 10u, 3u, 10u, 4u, 10u,\n+        5u, 10u, 3u, 10u, 4u, 10u, 5u, 10u, 3u, 10u, 4u, 10u, 5u, 10u, 3u, 10u,\n+        4u, 10u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u,\n+        1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u,\n+        3u, 10u, 3u, 13u, 1u, 16u, 1u, 16u, 1u, 16u, 3u, 10u, 1u, 16u, 3u, 13u,\n+        1u, 16u, 4u, 13u, 5u, 10u, 10u, 10u, 10u, 10u, 10u, 10u, 5u, 10u, 1u, 16u,\n+        3u, 10u, 5u, 10u, 5u, 10u, 10u, 10u, 10u, 10u, 10u, 10u, 5u, 10u, 1u, 16u,\n+        0\n+};\n+\n+static const char _indic_syllable_machine_key_spans[] = {\n+        1, 5, 3, 1, 4, 3, 1, 4,\n+        3, 1, 4, 3, 1, 5, 1, 1,\n+        5, 1, 1, 5, 1, 1, 5, 1,\n+        1, 10, 5, 10, 5, 10, 5, 10,\n+        5, 10, 1, 5, 3, 1, 4, 3,\n+        1, 4, 3, 1, 4, 3, 1, 5,\n+        1, 1, 5, 1, 1, 5, 1, 1,\n+        5, 1, 1, 10, 5, 10, 5, 10,\n+        5, 10, 5, 10, 1, 5, 3, 1,\n+        4, 3, 1, 4, 3, 1, 4, 3,\n+        1, 5, 1, 1, 5, 1, 1, 5,\n+        1, 1, 5, 1, 1, 10, 5, 10,\n+        5, 10, 5, 10, 5, 1, 5, 3,\n+        1, 4, 3, 1, 4, 3, 1, 4,\n+        3, 1, 5, 1, 1, 5, 1, 1,\n+        5, 1, 1, 5, 1, 1, 10, 5,\n+        10, 5, 10, 5, 10, 5, 10, 10,\n+        4, 1, 19, 11, 8, 7, 16, 11,\n+        8, 7, 16, 11, 8, 7, 16, 11,\n+        8, 7, 16, 11, 8, 7, 6, 6,\n+        6, 1, 1, 1, 6, 8, 6, 8,\n+        7, 6, 8, 7, 6, 8, 7, 6,\n+        8, 7, 8, 11, 16, 16, 16, 8,\n+        11, 16, 16, 16, 8, 11, 16, 16,\n+        16, 8, 11, 16, 16, 16, 8, 11,\n+        11, 8, 7, 16, 11, 8, 7, 16,\n+        11, 8, 7, 16, 11, 8, 7, 16,\n+        11, 8, 7, 6, 6, 6, 1, 1,\n+        1, 6, 8, 6, 8, 7, 6, 8,\n+        7, 6, 8, 7, 6, 8, 7, 8,\n+        11, 16, 16, 16, 8, 11, 16, 16,\n+        16, 8, 11, 16, 16, 16, 8, 11,\n+        16, 16, 16, 5, 8, 8, 7, 16,\n+        11, 8, 7, 16, 11, 8, 7, 16,\n+        11, 8, 7, 16, 11, 8, 7, 6,\n+        6, 6, 1, 1, 1, 6, 8, 6,\n+        8, 7, 6, 8, 7, 6, 8, 7,\n+        6, 8, 7, 8, 11, 16, 16, 16,\n+        8, 11, 16, 16, 16, 8, 11, 16,\n+        16, 16, 8, 11, 16, 16, 16, 10,\n+        8, 5, 11, 8, 7, 16, 11, 8,\n+        7, 16, 11, 8, 7, 16, 11, 8,\n+        7, 16, 11, 8, 7, 6, 6, 6,\n+        1, 1, 1, 6, 8, 6, 8, 7,\n+        6, 8, 7, 6, 8, 7, 6, 8,\n+        7, 8, 11, 16, 16, 16, 8, 11,\n+        16, 16, 16, 8, 11, 16, 16, 16,\n+        8, 11, 16, 16, 16, 8, 16, 11,\n+        16, 10, 6, 1, 1, 1, 6, 16,\n+        8, 6, 6, 1, 1, 1, 6, 16\n+};\n+\n+static const short _indic_syllable_machine_index_offsets[] = {\n+        0, 2, 8, 12, 14, 19, 23, 25,\n+        30, 34, 36, 41, 45, 47, 53, 55,\n+        57, 63, 65, 67, 73, 75, 77, 83,\n+        85, 87, 98, 104, 115, 121, 132, 138,\n+        149, 155, 166, 168, 174, 178, 180, 185,\n+        189, 191, 196, 200, 202, 207, 211, 213,\n+        219, 221, 223, 229, 231, 233, 239, 241,\n+        243, 249, 251, 253, 264, 270, 281, 287,\n+        298, 304, 315, 321, 332, 334, 340, 344,\n+        346, 351, 355, 357, 362, 366, 368, 373,\n+        377, 379, 385, 387, 389, 395, 397, 399,\n+        405, 407, 409, 415, 417, 419, 430, 436,\n+        447, 453, 464, 470, 481, 487, 489, 495,\n+        499, 501, 506, 510, 512, 517, 521, 523,\n+        528, 532, 534, 540, 542, 544, 550, 552,\n+        554, 560, 562, 564, 570, 572, 574, 585,\n+        591, 602, 608, 619, 625, 636, 642, 653,\n+        664, 669, 671, 691, 703, 712, 720, 737,\n+        749, 758, 766, 783, 795, 804, 812, 829,\n+        841, 850, 858, 875, 887, 896, 904, 911,\n+        918, 925, 927, 929, 931, 938, 947, 954,\n+        963, 971, 978, 987, 995, 1002, 1011, 1019,\n+        1026, 1035, 1043, 1052, 1064, 1081, 1098, 1115,\n+        1124, 1136, 1153, 1170, 1187, 1196, 1208, 1225,\n+        1242, 1259, 1268, 1280, 1297, 1314, 1331, 1340,\n+        1352, 1364, 1373, 1381, 1398, 1410, 1419, 1427,\n+        1444, 1456, 1465, 1473, 1490, 1502, 1511, 1519,\n+        1536, 1548, 1557, 1565, 1572, 1579, 1586, 1588,\n+        1590, 1592, 1599, 1608, 1615, 1624, 1632, 1639,\n+        1648, 1656, 1663, 1672, 1680, 1687, 1696, 1704,\n+        1713, 1725, 1742, 1759, 1776, 1785, 1797, 1814,\n+        1831, 1848, 1857, 1869, 1886, 1903, 1920, 1929,\n+        1941, 1958, 1975, 1992, 1998, 2007, 2016, 2024,\n+        2041, 2053, 2062, 2070, 2087, 2099, 2108, 2116,\n+        2133, 2145, 2154, 2162, 2179, 2191, 2200, 2208,\n+        2215, 2222, 2229, 2231, 2233, 2235, 2242, 2251,\n+        2258, 2267, 2275, 2282, 2291, 2299, 2306, 2315,\n+        2323, 2330, 2339, 2347, 2356, 2368, 2385, 2402,\n+        2419, 2428, 2440, 2457, 2474, 2491, 2500, 2512,\n+        2529, 2546, 2563, 2572, 2584, 2601, 2618, 2635,\n+        2646, 2655, 2661, 2673, 2682, 2690, 2707, 2719,\n+        2728, 2736, 2753, 2765, 2774, 2782, 2799, 2811,\n+        2820, 2828, 2845, 2857, 2866, 2874, 2881, 2888,\n+        2895, 2897, 2899, 2901, 2908, 2917, 2924, 2933,\n+        2941, 2948, 2957, 2965, 2972, 2981, 2989, 2996,\n+        3005, 3013, 3022, 3034, 3051, 3068, 3085, 3094,\n+        3106, 3123, 3140, 3157, 3166, 3178, 3195, 3212,\n+        3229, 3238, 3250, 3267, 3284, 3301, 3310, 3327,\n+        3339, 3356, 3367, 3374, 3376, 3378, 3380, 3387,\n+        3404, 3413, 3420, 3427, 3429, 3431, 3433, 3440\n+};\n+\n+static const short _indic_syllable_machine_indicies[] = {\n+        1, 0, 2, 3, 3, 4, 1, 0,\n+        5, 5, 4, 0, 4, 0, 6, 6,\n+        7, 1, 0, 8, 8, 7, 0, 7,\n+        0, 9, 9, 10, 1, 0, 11, 11,\n+        10, 0, 10, 0, 12, 12, 13, 1,\n+        0, 14, 14, 13, 0, 13, 0, 15,\n+        0, 0, 0, 1, 0, 16, 0, 17,\n+        0, 18, 12, 12, 13, 1, 0, 19,\n+        0, 20, 0, 21, 9, 9, 10, 1,\n+        0, 22, 0, 23, 0, 24, 6, 6,\n+        7, 1, 0, 25, 0, 26, 0, 2,\n+        3, 3, 4, 1, 0, 0, 0, 0,\n+        27, 0, 28, 3, 3, 4, 1, 0,\n+        28, 3, 3, 4, 1, 0, 0, 0,\n+        0, 29, 0, 30, 3, 3, 4, 1,\n+        0, 30, 3, 3, 4, 1, 0, 0,\n+        0, 0, 31, 0, 32, 3, 3, 4,\n+        1, 0, 32, 3, 3, 4, 1, 0,\n+        0, 0, 0, 33, 0, 34, 3, 3,\n+        4, 1, 0, 34, 3, 3, 4, 1,\n+        0, 0, 0, 0, 35, 0, 37, 36,\n+        38, 39, 39, 40, 37, 36, 41, 41,\n+        40, 36, 40, 36, 42, 42, 43, 37,\n+        36, 44, 44, 43, 36, 43, 36, 45,\n+        45, 46, 37, 36, 47, 47, 46, 36,\n+        46, 36, 48, 48, 49, 37, 36, 50,\n+        50, 49, 36, 49, 36, 51, 36, 36,\n+        36, 37, 36, 52, 36, 53, 36, 54,\n+        48, 48, 49, 37, 36, 55, 36, 56,\n+        36, 57, 45, 45, 46, 37, 36, 58,\n+        36, 59, 36, 60, 42, 42, 43, 37,\n+        36, 61, 36, 62, 36, 38, 39, 39,\n+        40, 37, 36, 36, 36, 36, 63, 36,\n+        64, 39, 39, 40, 37, 36, 64, 39,\n+        39, 40, 37, 36, 36, 36, 36, 65,\n+        36, 66, 39, 39, 40, 37, 36, 66,\n+        39, 39, 40, 37, 36, 36, 36, 36,\n+        67, 36, 68, 39, 39, 40, 37, 36,\n+        68, 39, 39, 40, 37, 36, 36, 36,\n+        36, 69, 36, 70, 39, 39, 40, 37,\n+        36, 70, 39, 39, 40, 37, 36, 36,\n+        36, 36, 71, 36, 73, 72, 74, 75,\n+        75, 76, 73, 72, 78, 78, 76, 77,\n+        76, 77, 79, 79, 80, 73, 72, 81,\n+        81, 80, 72, 80, 72, 82, 82, 83,\n+        73, 72, 84, 84, 83, 72, 83, 72,\n+        85, 85, 86, 73, 72, 87, 87, 86,\n+        72, 86, 72, 88, 72, 72, 72, 73,\n+        72, 89, 72, 90, 72, 91, 85, 85,\n+        86, 73, 72, 92, 72, 93, 72, 94,\n+        82, 82, 83, 73, 72, 95, 72, 96,\n+        72, 97, 79, 79, 80, 73, 72, 98,\n+        72, 99, 72, 74, 75, 75, 76, 73,\n+        72, 72, 72, 72, 100, 72, 101, 75,\n+        75, 76, 73, 72, 101, 75, 75, 76,\n+        73, 72, 72, 72, 72, 102, 72, 103,\n+        75, 75, 76, 73, 72, 103, 75, 75,\n+        76, 73, 72, 72, 72, 72, 104, 72,\n+        105, 75, 75, 76, 73, 72, 105, 75,\n+        75, 76, 73, 72, 72, 72, 72, 106,\n+        72, 107, 75, 75, 76, 73, 72, 109,\n+        108, 110, 111, 111, 112, 109, 108, 113,\n+        113, 112, 108, 112, 108, 114, 114, 115,\n+        109, 108, 116, 116, 115, 108, 115, 108,\n+        117, 117, 118, 109, 108, 119, 119, 118,\n+        108, 118, 108, 120, 120, 121, 109, 108,\n+        122, 122, 121, 108, 121, 108, 123, 108,\n+        108, 108, 109, 108, 124, 108, 125, 108,\n+        126, 120, 120, 121, 109, 108, 127, 108,\n+        128, 108, 129, 117, 117, 118, 109, 108,\n+        130, 108, 131, 108, 132, 114, 114, 115,\n+        109, 108, 133, 108, 134, 108, 110, 111,\n+        111, 112, 109, 108, 108, 108, 108, 135,\n+        108, 136, 111, 111, 112, 109, 108, 136,\n+        111, 111, 112, 109, 108, 108, 108, 108,\n+        137, 108, 138, 111, 111, 112, 109, 108,\n+        138, 111, 111, 112, 109, 108, 108, 108,\n+        108, 139, 108, 140, 111, 111, 112, 109,\n+        108, 140, 111, 111, 112, 109, 108, 108,\n+        108, 108, 141, 108, 142, 111, 111, 112,\n+        109, 108, 142, 111, 111, 112, 109, 108,\n+        108, 108, 108, 143, 108, 107, 75, 75,\n+        76, 73, 72, 72, 72, 72, 144, 72,\n+        78, 78, 76, 1, 0, 146, 145, 148,\n+        149, 150, 151, 152, 153, 76, 73, 147,\n+        154, 155, 155, 144, 147, 156, 157, 147,\n+        158, 159, 147, 161, 162, 163, 164, 4,\n+        1, 160, 165, 160, 160, 35, 160, 166,\n+        162, 167, 167, 4, 1, 160, 165, 160,\n+        162, 167, 167, 4, 1, 160, 165, 160,\n+        168, 160, 160, 160, 17, 169, 160, 1,\n+        160, 165, 160, 160, 160, 160, 160, 168,\n+        160, 170, 171, 172, 173, 4, 1, 160,\n+        165, 160, 160, 33, 160, 174, 171, 175,\n+        175, 4, 1, 160, 165, 160, 171, 175,\n+        175, 4, 1, 160, 165, 160, 176, 160,\n+        160, 160, 17, 177, 160, 1, 160, 165,\n+        160, 160, 160, 160, 160, 176, 160, 178,\n+        179, 180, 181, 4, 1, 160, 165, 160,\n+        160, 31, 160, 182, 179, 183, 183, 4,\n+        1, 160, 165, 160, 179, 183, 183, 4,\n+        1, 160, 165, 160, 184, 160, 160, 160,\n+        17, 185, 160, 1, 160, 165, 160, 160,\n+        160, 160, 160, 184, 160, 186, 187, 188,\n+        189, 4, 1, 160, 165, 160, 160, 29,\n+        160, 190, 187, 191, 191, 4, 1, 160,\n+        165, 160, 187, 191, 191, 4, 1, 160,\n+        165, 160, 192, 160, 160, 160, 17, 193,\n+        160, 1, 160, 165, 160, 160, 160, 160,\n+        160, 192, 160, 194, 195, 196, 197, 4,\n+        1, 160, 165, 160, 160, 27, 160, 198,\n+        195, 199, 199, 4, 1, 160, 165, 160,\n+        195, 199, 199, 4, 1, 160, 165, 160,\n+        17, 200, 160, 1, 160, 165, 160, 201,\n+        201, 160, 1, 160, 165, 160, 202, 160,\n+        160, 203, 160, 165, 160, 165, 160, 204,\n+        160, 205, 160, 202, 160, 160, 160, 160,\n+        165, 160, 17, 160, 201, 201, 160, 1,\n+        160, 165, 160, 201, 200, 160, 1, 160,\n+        165, 160, 206, 26, 207, 208, 7, 1,\n+        160, 165, 160, 26, 207, 208, 7, 1,\n+        160, 165, 160, 207, 207, 7, 1, 160,\n+        165, 160, 209, 23, 210, 211, 10, 1,\n+        160, 165, 160, 23, 210, 211, 10, 1,\n+        160, 165, 160, 210, 210, 10, 1, 160,\n+        165, 160, 212, 20, 213, 214, 13, 1,\n+        160, 165, 160, 20, 213, 214, 13, 1,\n+        160, 165, 160, 213, 213, 13, 1, 160,\n+        165, 160, 215, 17, 201, 216, 160, 1,\n+        160, 165, 160, 17, 201, 216, 160, 1,\n+        160, 165, 160, 194, 195, 199, 199, 4,\n+        1, 160, 165, 160, 194, 195, 196, 199,\n+        4, 1, 160, 165, 160, 160, 27, 160,\n+        192, 160, 217, 160, 201, 201, 160, 1,\n+        160, 165, 160, 160, 160, 160, 160, 192,\n+        160, 192, 160, 160, 160, 201, 201, 160,\n+        1, 160, 165, 160, 160, 160, 160, 160,\n+        192, 160, 192, 160, 160, 160, 201, 193,\n+        160, 1, 160, 165, 160, 160, 160, 160,\n+        160, 192, 160, 186, 187, 191, 191, 4,\n+        1, 160, 165, 160, 186, 187, 188, 191,\n+        4, 1, 160, 165, 160, 160, 29, 160,\n+        184, 160, 218, 160, 201, 201, 160, 1,\n+        160, 165, 160, 160, 160, 160, 160, 184,\n+        160, 184, 160, 160, 160, 201, 201, 160,\n+        1, 160, 165, 160, 160, 160, 160, 160,\n+        184, 160, 184, 160, 160, 160, 201, 185,\n+        160, 1, 160, 165, 160, 160, 160, 160,\n+        160, 184, 160, 178, 179, 183, 183, 4,\n+        1, 160, 165, 160, 178, 179, 180, 183,\n+        4, 1, 160, 165, 160, 160, 31, 160,\n+        176, 160, 219, 160, 201, 201, 160, 1,\n+        160, 165, 160, 160, 160, 160, 160, 176,\n+        160, 176, 160, 160, 160, 201, 201, 160,\n+        1, 160, 165, 160, 160, 160, 160, 160,\n+        176, 160, 176, 160, 160, 160, 201, 177,\n+        160, 1, 160, 165, 160, 160, 160, 160,\n+        160, 176, 160, 170, 171, 175, 175, 4,\n+        1, 160, 165, 160, 170, 171, 172, 175,\n+        4, 1, 160, 165, 160, 160, 33, 160,\n+        168, 160, 220, 160, 201, 201, 160, 1,\n+        160, 165, 160, 160, 160, 160, 160, 168,\n+        160, 168, 160, 160, 160, 201, 201, 160,\n+        1, 160, 165, 160, 160, 160, 160, 160,\n+        168, 160, 168, 160, 160, 160, 201, 169,\n+        160, 1, 160, 165, 160, 160, 160, 160,\n+        160, 168, 160, 161, 162, 167, 167, 4,\n+        1, 160, 165, 160, 161, 162, 163, 167,\n+        4, 1, 160, 165, 160, 160, 35, 160,\n+        222, 223, 224, 225, 40, 37, 221, 226,\n+        221, 221, 71, 221, 227, 223, 228, 225,\n+        40, 37, 221, 226, 221, 223, 228, 225,\n+        40, 37, 221, 226, 221, 229, 221, 221,\n+        221, 53, 230, 221, 37, 221, 226, 221,\n+        221, 221, 221, 221, 229, 221, 231, 232,\n+        233, 234, 40, 37, 221, 226, 221, 221,\n+        69, 221, 235, 232, 236, 236, 40, 37,\n+        221, 226, 221, 232, 236, 236, 40, 37,\n+        221, 226, 221, 237, 221, 221, 221, 53,\n+        238, 221, 37, 221, 226, 221, 221, 221,\n+        221, 221, 237, 221, 239, 240, 241, 242,\n+        40, 37, 221, 226, 221, 221, 67, 221,\n+        243, 240, 244, 244, 40, 37, 221, 226,\n+        221, 240, 244, 244, 40, 37, 221, 226,\n+        221, 245, 221, 221, 221, 53, 246, 221,\n+        37, 221, 226, 221, 221, 221, 221, 221,\n+        245, 221, 247, 248, 249, 250, 40, 37,\n+        221, 226, 221, 221, 65, 221, 251, 248,\n+        252, 252, 40, 37, 221, 226, 221, 248,\n+        252, 252, 40, 37, 221, 226, 221, 253,\n+        221, 221, 221, 53, 254, 221, 37, 221,\n+        226, 221, 221, 221, 221, 221, 253, 221,\n+        255, 256, 257, 258, 40, 37, 221, 226,\n+        221, 221, 63, 221, 259, 256, 260, 260,\n+        40, 37, 221, 226, 221, 256, 260, 260,\n+        40, 37, 221, 226, 221, 53, 261, 221,\n+        37, 221, 226, 221, 262, 262, 221, 37,\n+        221, 226, 221, 263, 221, 221, 264, 221,\n+        226, 221, 226, 221, 265, 221, 266, 221,\n+        263, 221, 221, 221, 221, 226, 221, 53,\n+        221, 262, 262, 221, 37, 221, 226, 221,\n+        262, 261, 221, 37, 221, 226, 221, 267,\n+        62, 268, 269, 43, 37, 221, 226, 221,\n+        62, 268, 269, 43, 37, 221, 226, 221,\n+        268, 268, 43, 37, 221, 226, 221, 270,\n+        59, 271, 272, 46, 37, 221, 226, 221,\n+        59, 271, 272, 46, 37, 221, 226, 221,\n+        271, 271, 46, 37, 221, 226, 221, 273,\n+        56, 274, 275, 49, 37, 221, 226, 221,\n+        56, 274, 275, 49, 37, 221, 226, 221,\n+        274, 274, 49, 37, 221, 226, 221, 276,\n+        53, 262, 277, 221, 37, 221, 226, 221,\n+        53, 262, 277, 221, 37, 221, 226, 221,\n+        255, 256, 260, 260, 40, 37, 221, 226,\n+        221, 255, 256, 257, 260, 40, 37, 221,\n+        226, 221, 221, 63, 221, 253, 221, 278,\n+        221, 262, 262, 221, 37, 221, 226, 221,\n+        221, 221, 221, 221, 253, 221, 253, 221,\n+        221, 221, 262, 262, 221, 37, 221, 226,\n+        221, 221, 221, 221, 221, 253, 221, 253,\n+        221, 221, 221, 262, 254, 221, 37, 221,\n+        226, 221, 221, 221, 221, 221, 253, 221,\n+        247, 248, 252, 252, 40, 37, 221, 226,\n+        221, 247, 248, 249, 252, 40, 37, 221,\n+        226, 221, 221, 65, 221, 245, 221, 279,\n+        221, 262, 262, 221, 37, 221, 226, 221,\n+        221, 221, 221, 221, 245, 221, 245, 221,\n+        221, 221, 262, 262, 221, 37, 221, 226,\n+        221, 221, 221, 221, 221, 245, 221, 245,\n+        221, 221, 221, 262, 246, 221, 37, 221,\n+        226, 221, 221, 221, 221, 221, 245, 221,\n+        239, 240, 244, 244, 40, 37, 221, 226,\n+        221, 239, 240, 241, 244, 40, 37, 221,\n+        226, 221, 221, 67, 221, 237, 221, 280,\n+        221, 262, 262, 221, 37, 221, 226, 221,\n+        221, 221, 221, 221, 237, 221, 237, 221,\n+        221, 221, 262, 262, 221, 37, 221, 226,\n+        221, 221, 221, 221, 221, 237, 221, 237,\n+        221, 221, 221, 262, 238, 221, 37, 221,\n+        226, 221, 221, 221, 221, 221, 237, 221,\n+        231, 232, 236, 236, 40, 37, 221, 226,\n+        221, 231, 232, 233, 236, 40, 37, 221,\n+        226, 221, 221, 69, 221, 229, 221, 281,\n+        221, 262, 262, 221, 37, 221, 226, 221,\n+        221, 221, 221, 221, 229, 221, 229, 221,\n+        221, 221, 262, 262, 221, 37, 221, 226,\n+        221, 221, 221, 221, 221, 229, 221, 229,\n+        221, 221, 221, 262, 230, 221, 37, 221,\n+        226, 221, 221, 221, 221, 221, 229, 221,\n+        70, 39, 39, 40, 37, 221, 222, 223,\n+        228, 225, 40, 37, 221, 226, 221, 283,\n+        151, 284, 284, 76, 73, 282, 154, 282,\n+        151, 284, 284, 76, 73, 282, 154, 282,\n+        285, 282, 282, 282, 90, 286, 282, 73,\n+        282, 154, 282, 282, 282, 282, 282, 285,\n+        282, 287, 288, 289, 290, 76, 73, 282,\n+        154, 282, 282, 106, 282, 291, 288, 292,\n+        292, 76, 73, 282, 154, 282, 288, 292,\n+        292, 76, 73, 282, 154, 282, 293, 282,\n+        282, 282, 90, 294, 282, 73, 282, 154,\n+        282, 282, 282, 282, 282, 293, 282, 295,\n+        296, 297, 298, 76, 73, 282, 154, 282,\n+        282, 104, 282, 299, 296, 300, 300, 76,\n+        73, 282, 154, 282, 296, 300, 300, 76,\n+        73, 282, 154, 282, 301, 282, 282, 282,\n+        90, 302, 282, 73, 282, 154, 282, 282,\n+        282, 282, 282, 301, 282, 303, 304, 305,\n+        306, 76, 73, 282, 154, 282, 282, 102,\n+        282, 307, 304, 308, 308, 76, 73, 282,\n+        154, 282, 304, 308, 308, 76, 73, 282,\n+        154, 282, 309, 282, 282, 282, 90, 310,\n+        282, 73, 282, 154, 282, 282, 282, 282,\n+        282, 309, 282, 311, 312, 313, 314, 76,\n+        73, 282, 154, 282, 282, 100, 282, 315,\n+        312, 316, 316, 76, 73, 282, 154, 282,\n+        312, 316, 316, 76, 73, 282, 154, 282,\n+        90, 317, 282, 73, 282, 154, 282, 318,\n+        318, 282, 73, 282, 154, 282, 319, 282,\n+        282, 320, 282, 154, 282, 154, 282, 321,\n+        282, 322, 282, 319, 282, 282, 282, 282,\n+        154, 282, 90, 282, 318, 318, 282, 73,\n+        282, 154, 282, 318, 317, 282, 73, 282,\n+        154, 282, 323, 99, 324, 325, 80, 73,\n+        282, 154, 282, 99, 324, 325, 80, 73,\n+        282, 154, 282, 324, 324, 80, 73, 282,\n+        154, 282, 326, 96, 327, 328, 83, 73,\n+        282, 154, 282, 96, 327, 328, 83, 73,\n+        282, 154, 282, 327, 327, 83, 73, 282,\n+        154, 282, 329, 93, 330, 331, 86, 73,\n+        282, 154, 282, 93, 330, 331, 86, 73,\n+        282, 154, 282, 330, 330, 86, 73, 282,\n+        154, 282, 332, 90, 318, 333, 282, 73,\n+        282, 154, 282, 90, 318, 333, 282, 73,\n+        282, 154, 282, 311, 312, 316, 316, 76,\n+        73, 282, 154, 282, 311, 312, 313, 316,\n+        76, 73, 282, 154, 282, 282, 100, 282,\n+        309, 282, 334, 282, 318, 318, 282, 73,\n+        282, 154, 282, 282, 282, 282, 282, 309,\n+        282, 309, 282, 282, 282, 318, 318, 282,\n+        73, 282, 154, 282, 282, 282, 282, 282,\n+        309, 282, 309, 282, 282, 282, 318, 310,\n+        282, 73, 282, 154, 282, 282, 282, 282,\n+        282, 309, 282, 303, 304, 308, 308, 76,\n+        73, 282, 154, 282, 303, 304, 305, 308,\n+        76, 73, 282, 154, 282, 282, 102, 282,\n+        301, 282, 335, 282, 318, 318, 282, 73,\n+        282, 154, 282, 282, 282, 282, 282, 301,\n+        282, 301, 282, 282, 282, 318, 318, 282,\n+        73, 282, 154, 282, 282, 282, 282, 282,\n+        301, 282, 301, 282, 282, 282, 318, 302,\n+        282, 73, 282, 154, 282, 282, 282, 282,\n+        282, 301, 282, 295, 296, 300, 300, 76,\n+        73, 282, 154, 282, 295, 296, 297, 300,\n+        76, 73, 282, 154, 282, 282, 104, 282,\n+        293, 282, 336, 282, 318, 318, 282, 73,\n+        282, 154, 282, 282, 282, 282, 282, 293,\n+        282, 293, 282, 282, 282, 318, 318, 282,\n+        73, 282, 154, 282, 282, 282, 282, 282,\n+        293, 282, 293, 282, 282, 282, 318, 294,\n+        282, 73, 282, 154, 282, 282, 282, 282,\n+        282, 293, 282, 287, 288, 292, 292, 76,\n+        73, 282, 154, 282, 287, 288, 289, 292,\n+        76, 73, 282, 154, 282, 282, 106, 282,\n+        285, 282, 337, 282, 318, 318, 282, 73,\n+        282, 154, 282, 282, 282, 282, 282, 285,\n+        282, 285, 282, 282, 282, 318, 318, 282,\n+        73, 282, 154, 282, 282, 282, 282, 282,\n+        285, 282, 285, 282, 282, 282, 318, 286,\n+        282, 73, 282, 154, 282, 282, 282, 282,\n+        282, 285, 282, 107, 75, 75, 76, 73,\n+        338, 338, 338, 338, 144, 338, 150, 151,\n+        284, 284, 76, 73, 282, 154, 282, 107,\n+        75, 75, 76, 73, 338, 340, 341, 342,\n+        343, 112, 109, 339, 344, 339, 339, 143,\n+        339, 345, 341, 343, 343, 112, 109, 339,\n+        344, 339, 341, 343, 343, 112, 109, 339,\n+        344, 339, 346, 339, 339, 339, 125, 347,\n+        339, 109, 339, 344, 339, 339, 339, 339,\n+        339, 346, 339, 348, 349, 350, 351, 112,\n+        109, 339, 344, 339, 339, 141, 339, 352,\n+        349, 353, 353, 112, 109, 339, 344, 339,\n+        349, 353, 353, 112, 109, 339, 344, 339,\n+        354, 339, 339, 339, 125, 355, 339, 109,\n+        339, 344, 339, 339, 339, 339, 339, 354,\n+        339, 356, 357, 358, 359, 112, 109, 339,\n+        344, 339, 339, 139, 339, 360, 357, 361,\n+        361, 112, 109, 339, 344, 339, 357, 361,\n+        361, 112, 109, 339, 344, 339, 362, 339,\n+        339, 339, 125, 363, 339, 109, 339, 344,\n+        339, 339, 339, 339, 339, 362, 339, 364,\n+        365, 366, 367, 112, 109, 339, 344, 339,\n+        339, 137, 339, 368, 365, 369, 369, 112,\n+        109, 339, 344, 339, 365, 369, 369, 112,\n+        109, 339, 344, 339, 370, 339, 339, 339,\n+        125, 371, 339, 109, 339, 344, 339, 339,\n+        339, 339, 339, 370, 339, 372, 373, 374,\n+        375, 112, 109, 339, 344, 339, 339, 135,\n+        339, 376, 373, 377, 377, 112, 109, 339,\n+        344, 339, 373, 377, 377, 112, 109, 339,\n+        344, 339, 125, 378, 339, 109, 339, 344,\n+        339, 379, 379, 339, 109, 339, 344, 339,\n+        380, 339, 339, 381, 339, 344, 339, 344,\n+        339, 382, 339, 383, 339, 380, 339, 339,\n+        339, 339, 344, 339, 125, 339, 379, 379,\n+        339, 109, 339, 344, 339, 379, 378, 339,\n+        109, 339, 344, 339, 384, 134, 385, 386,\n+        115, 109, 339, 344, 339, 134, 385, 386,\n+        115, 109, 339, 344, 339, 385, 385, 115,\n+        109, 339, 344, 339, 387, 131, 388, 389,\n+        118, 109, 339, 344, 339, 131, 388, 389,\n+        118, 109, 339, 344, 339, 388, 388, 118,\n+        109, 339, 344, 339, 390, 128, 391, 392,\n+        121, 109, 339, 344, 339, 128, 391, 392,\n+        121, 109, 339, 344, 339, 391, 391, 121,\n+        109, 339, 344, 339, 393, 125, 379, 394,\n+        339, 109, 339, 344, 339, 125, 379, 394,\n+        339, 109, 339, 344, 339, 372, 373, 377,\n+        377, 112, 109, 339, 344, 339, 372, 373,\n+        374, 377, 112, 109, 339, 344, 339, 339,\n+        135, 339, 370, 339, 395, 339, 379, 379,\n+        339, 109, 339, 344, 339, 339, 339, 339,\n+        339, 370, 339, 370, 339, 339, 339, 379,\n+        379, 339, 109, 339, 344, 339, 339, 339,\n+        339, 339, 370, 339, 370, 339, 339, 339,\n+        379, 371, 339, 109, 339, 344, 339, 339,\n+        339, 339, 339, 370, 339, 364, 365, 369,\n+        369, 112, 109, 339, 344, 339, 364, 365,\n+        366, 369, 112, 109, 339, 344, 339, 339,\n+        137, 339, 362, 339, 396, 339, 379, 379,\n+        339, 109, 339, 344, 339, 339, 339, 339,\n+        339, 362, 339, 362, 339, 339, 339, 379,\n+        379, 339, 109, 339, 344, 339, 339, 339,\n+        339, 339, 362, 339, 362, 339, 339, 339,\n+        379, 363, 339, 109, 339, 344, 339, 339,\n+        339, 339, 339, 362, 339, 356, 357, 361,\n+        361, 112, 109, 339, 344, 339, 356, 357,\n+        358, 361, 112, 109, 339, 344, 339, 339,\n+        139, 339, 354, 339, 397, 339, 379, 379,\n+        339, 109, 339, 344, 339, 339, 339, 339,\n+        339, 354, 339, 354, 339, 339, 339, 379,\n+        379, 339, 109, 339, 344, 339, 339, 339,\n+        339, 339, 354, 339, 354, 339, 339, 339,\n+        379, 355, 339, 109, 339, 344, 339, 339,\n+        339, 339, 339, 354, 339, 348, 349, 353,\n+        353, 112, 109, 339, 344, 339, 348, 349,\n+        350, 353, 112, 109, 339, 344, 339, 339,\n+        141, 339, 346, 339, 398, 339, 379, 379,\n+        339, 109, 339, 344, 339, 339, 339, 339,\n+        339, 346, 339, 346, 339, 339, 339, 379,\n+        379, 339, 109, 339, 344, 339, 339, 339,\n+        339, 339, 346, 339, 346, 339, 339, 339,\n+        379, 347, 339, 109, 339, 344, 339, 339,\n+        339, 339, 339, 346, 339, 340, 341, 343,\n+        343, 112, 109, 339, 344, 339, 148, 149,\n+        150, 151, 399, 284, 76, 73, 282, 154,\n+        155, 155, 144, 282, 282, 148, 282, 161,\n+        400, 163, 164, 4, 1, 160, 165, 160,\n+        160, 35, 160, 168, 149, 150, 151, 401,\n+        402, 76, 403, 160, 404, 160, 155, 144,\n+        160, 160, 168, 160, 107, 405, 405, 76,\n+        403, 160, 165, 160, 160, 144, 160, 406,\n+        160, 160, 407, 160, 404, 160, 404, 160,\n+        408, 160, 205, 160, 406, 160, 160, 160,\n+        160, 404, 160, 168, 160, 220, 107, 405,\n+        405, 76, 403, 160, 165, 160, 160, 160,\n+        160, 160, 168, 160, 410, 409, 411, 411,\n+        409, 146, 409, 412, 409, 411, 411, 409,\n+        146, 409, 412, 409, 413, 409, 409, 414,\n+        409, 412, 409, 412, 409, 415, 409, 416,\n+        409, 413, 409, 409, 409, 409, 412, 409,\n+        148, 338, 338, 338, 338, 338, 338, 338,\n+        338, 338, 155, 338, 338, 338, 338, 148,\n+        338, 0\n+};\n+\n+static const short _indic_syllable_machine_trans_targs[] = {\n+        138, 160, 166, 2, 167, 3, 5, 170,\n+        6, 8, 173, 9, 11, 176, 12, 14,\n+        15, 159, 17, 18, 175, 20, 21, 172,\n+        23, 24, 169, 178, 182, 183, 187, 188,\n+        192, 193, 197, 198, 138, 221, 227, 36,\n+        228, 37, 39, 231, 40, 42, 234, 43,\n+        45, 237, 46, 48, 49, 220, 51, 52,\n+        236, 54, 55, 233, 57, 58, 230, 239,\n+        243, 244, 248, 249, 253, 254, 258, 260,\n+        138, 281, 287, 70, 288, 138, 71, 73,\n+        291, 74, 76, 294, 77, 79, 297, 80,\n+        82, 83, 280, 85, 86, 296, 88, 89,\n+        293, 91, 92, 290, 299, 303, 304, 308,\n+        309, 313, 314, 318, 138, 343, 349, 103,\n+        350, 104, 106, 353, 107, 109, 356, 110,\n+        112, 359, 113, 115, 116, 342, 118, 119,\n+        358, 121, 122, 355, 124, 125, 352, 361,\n+        365, 366, 370, 371, 375, 376, 380, 381,\n+        320, 138, 394, 138, 139, 200, 261, 263,\n+        319, 321, 283, 322, 382, 383, 392, 399,\n+        138, 140, 142, 33, 199, 162, 141, 32,\n+        143, 195, 144, 146, 31, 194, 145, 30,\n+        147, 190, 148, 150, 29, 189, 149, 28,\n+        151, 185, 152, 154, 27, 184, 153, 26,\n+        155, 180, 156, 158, 25, 179, 157, 1,\n+        165, 0, 161, 164, 163, 138, 168, 4,\n+        22, 171, 7, 19, 174, 10, 16, 177,\n+        13, 181, 186, 191, 196, 138, 201, 203,\n+        67, 259, 223, 202, 66, 204, 256, 205,\n+        207, 65, 255, 206, 64, 208, 251, 209,\n+        211, 63, 250, 210, 62, 212, 246, 213,\n+        215, 61, 245, 214, 60, 216, 241, 217,\n+        219, 59, 240, 218, 35, 226, 34, 222,\n+        225, 224, 138, 229, 38, 56, 232, 41,\n+        53, 235, 44, 50, 238, 47, 242, 247,\n+        252, 257, 138, 262, 100, 264, 316, 265,\n+        267, 99, 315, 266, 98, 268, 311, 269,\n+        271, 97, 310, 270, 96, 272, 306, 273,\n+        275, 95, 305, 274, 94, 276, 301, 277,\n+        279, 93, 300, 278, 69, 286, 68, 282,\n+        285, 284, 138, 289, 72, 90, 292, 75,\n+        87, 295, 78, 84, 298, 81, 302, 307,\n+        312, 317, 138, 138, 323, 325, 134, 133,\n+        345, 324, 326, 378, 327, 329, 132, 377,\n+        328, 131, 330, 373, 331, 333, 130, 372,\n+        332, 129, 334, 368, 335, 337, 128, 367,\n+        336, 127, 338, 363, 339, 341, 126, 362,\n+        340, 102, 348, 101, 344, 347, 346, 138,\n+        351, 105, 123, 354, 108, 120, 357, 111,\n+        117, 360, 114, 364, 369, 374, 379, 135,\n+        384, 385, 391, 386, 388, 136, 387, 390,\n+        389, 138, 393, 137, 396, 395, 398, 397,\n+        138\n+};\n+\n+static const char _indic_syllable_machine_trans_actions[] = {\n+        1, 0, 2, 0, 2, 0, 0, 2,\n+        0, 0, 2, 0, 0, 2, 0, 0,\n+        0, 2, 0, 0, 2, 0, 0, 2,\n+        0, 0, 2, 2, 2, 2, 2, 2,\n+        2, 2, 2, 2, 3, 0, 2, 0,\n+        2, 0, 0, 2, 0, 0, 2, 0,\n+        0, 2, 0, 0, 0, 2, 0, 0,\n+        2, 0, 0, 2, 0, 0, 2, 2,\n+        2, 2, 2, 2, 2, 2, 2, 2,\n+        4, 0, 2, 0, 2, 5, 0, 0,\n+        2, 0, 0, 2, 0, 0, 2, 0,\n+        0, 0, 2, 0, 0, 2, 0, 0,\n+        2, 0, 0, 2, 6, 2, 6, 2,\n+        6, 2, 6, 2, 7, 0, 2, 0,\n+        2, 0, 0, 2, 0, 0, 2, 0,\n+        0, 2, 0, 0, 0, 2, 0, 0,\n+        2, 0, 0, 2, 0, 0, 2, 2,\n+        2, 2, 2, 2, 2, 2, 2, 2,\n+        6, 8, 0, 11, 2, 2, 6, 0,\n+        12, 12, 0, 2, 6, 2, 2, 0,\n+        13, 2, 0, 0, 2, 0, 2, 0,\n+        2, 2, 2, 0, 0, 2, 2, 0,\n+        2, 2, 2, 0, 0, 2, 2, 0,\n+        2, 2, 2, 0, 0, 2, 2, 0,\n+        2, 2, 2, 0, 0, 2, 2, 0,\n+        2, 0, 0, 0, 0, 14, 2, 0,\n+        0, 2, 0, 0, 2, 0, 0, 2,\n+        0, 2, 2, 2, 2, 15, 2, 0,\n+        0, 2, 0, 2, 0, 2, 2, 2,\n+        0, 0, 2, 2, 0, 2, 2, 2,\n+        0, 0, 2, 2, 0, 2, 2, 2,\n+        0, 0, 2, 2, 0, 2, 2, 2,\n+        0, 0, 2, 2, 0, 2, 0, 0,\n+        0, 0, 16, 2, 0, 0, 2, 0,\n+        0, 2, 0, 0, 2, 0, 2, 2,\n+        2, 2, 17, 6, 0, 6, 2, 6,\n+        0, 0, 6, 6, 0, 6, 2, 6,\n+        0, 0, 6, 6, 0, 6, 2, 6,\n+        0, 0, 6, 6, 0, 6, 2, 6,\n+        0, 0, 6, 6, 0, 2, 0, 0,\n+        0, 0, 18, 2, 0, 0, 2, 0,\n+        0, 2, 0, 0, 2, 0, 2, 2,\n+        2, 2, 19, 20, 2, 0, 0, 0,\n+        0, 2, 2, 2, 2, 0, 0, 2,\n+        2, 0, 2, 2, 2, 0, 0, 2,\n+        2, 0, 2, 2, 2, 0, 0, 2,\n+        2, 0, 2, 2, 2, 0, 0, 2,\n+        2, 0, 2, 0, 0, 0, 0, 21,\n+        2, 0, 0, 2, 0, 0, 2, 0,\n+        0, 2, 0, 2, 2, 2, 2, 0,\n+        0, 22, 22, 0, 0, 0, 0, 0,\n+        0, 23, 2, 0, 0, 0, 0, 0,\n+        24\n+};\n+\n+static const char _indic_syllable_machine_to_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 9, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const char _indic_syllable_machine_from_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 10, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const short _indic_syllable_machine_eof_trans[] = {\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 73, 73, 78, 78,\n+        73, 73, 73, 73, 73, 73, 73, 73,\n+        73, 73, 73, 73, 73, 73, 73, 73,\n+        73, 73, 73, 73, 73, 73, 73, 73,\n+        73, 73, 73, 73, 73, 109, 109, 109,\n+        109, 109, 109, 109, 109, 109, 109, 109,\n+        109, 109, 109, 109, 109, 109, 109, 109,\n+        109, 109, 109, 109, 109, 109, 109, 109,\n+        109, 109, 109, 109, 109, 109, 109, 73,\n+        1, 146, 0, 161, 161, 161, 161, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        222, 222, 222, 222, 222, 222, 222, 222,\n+        222, 222, 222, 222, 222, 222, 222, 222,\n+        222, 222, 222, 222, 222, 222, 222, 222,\n+        222, 222, 222, 222, 222, 222, 222, 222,\n+        222, 222, 222, 222, 222, 222, 222, 222,\n+        222, 222, 222, 222, 222, 222, 222, 222,\n+        222, 222, 222, 222, 222, 222, 222, 222,\n+        222, 222, 222, 222, 222, 283, 283, 283,\n+        283, 283, 283, 283, 283, 283, 283, 283,\n+        283, 283, 283, 283, 283, 283, 283, 283,\n+        283, 283, 283, 283, 283, 283, 283, 283,\n+        283, 283, 283, 283, 283, 283, 283, 283,\n+        283, 283, 283, 283, 283, 283, 283, 283,\n+        283, 283, 283, 283, 283, 283, 283, 283,\n+        283, 283, 283, 283, 283, 283, 283, 339,\n+        283, 339, 340, 340, 340, 340, 340, 340,\n+        340, 340, 340, 340, 340, 340, 340, 340,\n+        340, 340, 340, 340, 340, 340, 340, 340,\n+        340, 340, 340, 340, 340, 340, 340, 340,\n+        340, 340, 340, 340, 340, 340, 340, 340,\n+        340, 340, 340, 340, 340, 340, 340, 340,\n+        340, 340, 340, 340, 340, 340, 340, 340,\n+        340, 340, 340, 340, 340, 340, 283, 161,\n+        161, 161, 161, 161, 161, 161, 161, 161,\n+        410, 410, 410, 410, 410, 410, 410, 339\n+};\n+\n+static const int indic_syllable_machine_start = 138;\n+static const int indic_syllable_machine_first_final = 138;\n+static const int indic_syllable_machine_error = -1;\n+\n+static const int indic_syllable_machine_en_main = 138;\n+\n+\n+#line 36 \"hb-ot-shape-complex-indic-machine.rl\"\n+\n+\n+\n+#line 92 \"hb-ot-shape-complex-indic-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    for (unsigned int i = ts; i < te; i++) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+static void\n+find_syllables (hb_buffer_t *buffer)\n+{\n+  unsigned int p, pe, eof, ts, te, act;\n+  int cs;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#line 934 \"hb-ot-shape-complex-indic-machine.hh\"\n+        {\n+        cs = indic_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 112 \"hb-ot-shape-complex-indic-machine.rl\"\n+\n+\n+  p = 0;\n+  pe = eof = buffer->len;\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 950 \"hb-ot-shape-complex-indic-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const short *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _indic_syllable_machine_from_state_actions[cs] ) {\n+        case 10:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 964 \"hb-ot-shape-complex-indic-machine.hh\"\n+        }\n+\n+        _keys = _indic_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _indic_syllable_machine_indicies + _indic_syllable_machine_index_offsets[cs];\n+\n+        _slen = _indic_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].indic_category()) &&\n+                ( info[p].indic_category()) <= _keys[1] ?\n+                ( info[p].indic_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _indic_syllable_machine_trans_targs[_trans];\n+\n+        if ( _indic_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _indic_syllable_machine_trans_actions[_trans] ) {\n+        case 2:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+        break;\n+        case 14:\n+#line 83 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p+1;{ found_syllable (consonant_syllable); }}\n+        break;\n+        case 16:\n+#line 84 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p+1;{ found_syllable (vowel_syllable); }}\n+        break;\n+        case 21:\n+#line 85 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p+1;{ found_syllable (standalone_cluster); }}\n+        break;\n+        case 24:\n+#line 86 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p+1;{ found_syllable (symbol_cluster); }}\n+        break;\n+        case 18:\n+#line 87 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p+1;{ found_syllable (broken_cluster); }}\n+        break;\n+        case 11:\n+#line 88 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p+1;{ found_syllable (non_indic_cluster); }}\n+        break;\n+        case 13:\n+#line 83 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (consonant_syllable); }}\n+        break;\n+        case 15:\n+#line 84 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (vowel_syllable); }}\n+        break;\n+        case 20:\n+#line 85 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (standalone_cluster); }}\n+        break;\n+        case 23:\n+#line 86 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (symbol_cluster); }}\n+        break;\n+        case 17:\n+#line 87 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (broken_cluster); }}\n+        break;\n+        case 19:\n+#line 88 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {te = p;p--;{ found_syllable (non_indic_cluster); }}\n+        break;\n+        case 1:\n+#line 83 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (consonant_syllable); }}\n+        break;\n+        case 3:\n+#line 84 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (vowel_syllable); }}\n+        break;\n+        case 7:\n+#line 85 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (standalone_cluster); }}\n+        break;\n+        case 8:\n+#line 86 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (symbol_cluster); }}\n+        break;\n+        case 4:\n+#line 87 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (broken_cluster); }}\n+        break;\n+        case 5:\n+#line 1 \"NONE\"\n+        {       switch( act ) {\n+        case 1:\n+        {{p = ((te))-1;} found_syllable (consonant_syllable); }\n+        break;\n+        case 5:\n+        {{p = ((te))-1;} found_syllable (broken_cluster); }\n+        break;\n+        case 6:\n+        {{p = ((te))-1;} found_syllable (non_indic_cluster); }\n+        break;\n+        }\n+        }\n+        break;\n+        case 22:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 83 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {act = 1;}\n+        break;\n+        case 6:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 87 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {act = 5;}\n+        break;\n+        case 12:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 88 \"hb-ot-shape-complex-indic-machine.rl\"\n+        {act = 6;}\n+        break;\n+#line 1087 \"hb-ot-shape-complex-indic-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _indic_syllable_machine_to_state_actions[cs] ) {\n+        case 9:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 1096 \"hb-ot-shape-complex-indic-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _indic_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _indic_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 120 \"hb-ot-shape-complex-indic-machine.rl\"\n+\n+}\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_INDIC_MACHINE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-indic-machine.hh","additions":1115,"deletions":0,"binary":false,"changes":1115,"status":"added"},{"patch":"@@ -0,0 +1,490 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-indic-table.py IndicSyllabicCategory.txt IndicPositionalCategory.txt Blocks.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # IndicSyllabicCategory-11.0.0.txt\n+ * # Date: 2018-05-21, 18:33:00 GMT [KW, RP]\n+ * # IndicPositionalCategory-11.0.0.txt\n+ * # Date: 2018-02-05, 16:21:00 GMT [KW, RP]\n+ * # Blocks-11.0.0.txt\n+ * # Date: 2017-10-16, 24:39:00 GMT [KW]\n+ *\/\n+\n+#include \"hb-ot-shape-complex-indic.hh\"\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-macros\"\n+\n+#define ISC_A   INDIC_SYLLABIC_CATEGORY_AVAGRAHA                \/*  16 chars; Avagraha *\/\n+#define ISC_Bi  INDIC_SYLLABIC_CATEGORY_BINDU                   \/*  83 chars; Bindu *\/\n+#define ISC_BJN INDIC_SYLLABIC_CATEGORY_BRAHMI_JOINING_NUMBER   \/*  20 chars; Brahmi_Joining_Number *\/\n+#define ISC_Ca  INDIC_SYLLABIC_CATEGORY_CANTILLATION_MARK       \/*  58 chars; Cantillation_Mark *\/\n+#define ISC_C   INDIC_SYLLABIC_CATEGORY_CONSONANT               \/* 2110 chars; Consonant *\/\n+#define ISC_CD  INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD          \/*  10 chars; Consonant_Dead *\/\n+#define ISC_CF  INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL         \/*  67 chars; Consonant_Final *\/\n+#define ISC_CHL INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER   \/*   5 chars; Consonant_Head_Letter *\/\n+#define ISC_CIP INDIC_SYLLABIC_CATEGORY_CONSONANT_INITIAL_POSTFIXED     \/*   1 chars; Consonant_Initial_Postfixed *\/\n+#define ISC_CK  INDIC_SYLLABIC_CATEGORY_CONSONANT_KILLER        \/*   2 chars; Consonant_Killer *\/\n+#define ISC_CM  INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL        \/*  28 chars; Consonant_Medial *\/\n+#define ISC_CP  INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER   \/*  21 chars; Consonant_Placeholder *\/\n+#define ISC_CPR INDIC_SYLLABIC_CATEGORY_CONSONANT_PRECEDING_REPHA       \/*   2 chars; Consonant_Preceding_Repha *\/\n+#define ISC_CPrf        INDIC_SYLLABIC_CATEGORY_CONSONANT_PREFIXED      \/*   7 chars; Consonant_Prefixed *\/\n+#define ISC_CS  INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED     \/*  95 chars; Consonant_Subjoined *\/\n+#define ISC_CSR INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA      \/*   4 chars; Consonant_Succeeding_Repha *\/\n+#define ISC_CWS INDIC_SYLLABIC_CATEGORY_CONSONANT_WITH_STACKER  \/*   6 chars; Consonant_With_Stacker *\/\n+#define ISC_GM  INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK         \/*   3 chars; Gemination_Mark *\/\n+#define ISC_IS  INDIC_SYLLABIC_CATEGORY_INVISIBLE_STACKER       \/*  11 chars; Invisible_Stacker *\/\n+#define ISC_ZWJ INDIC_SYLLABIC_CATEGORY_JOINER                  \/*   1 chars; Joiner *\/\n+#define ISC_ML  INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER        \/*   1 chars; Modifying_Letter *\/\n+#define ISC_ZWNJ        INDIC_SYLLABIC_CATEGORY_NON_JOINER              \/*   1 chars; Non_Joiner *\/\n+#define ISC_N   INDIC_SYLLABIC_CATEGORY_NUKTA                   \/*  30 chars; Nukta *\/\n+#define ISC_Nd  INDIC_SYLLABIC_CATEGORY_NUMBER                  \/* 480 chars; Number *\/\n+#define ISC_NJ  INDIC_SYLLABIC_CATEGORY_NUMBER_JOINER           \/*   1 chars; Number_Joiner *\/\n+#define ISC_x   INDIC_SYLLABIC_CATEGORY_OTHER                   \/*   1 chars; Other *\/\n+#define ISC_PK  INDIC_SYLLABIC_CATEGORY_PURE_KILLER             \/*  21 chars; Pure_Killer *\/\n+#define ISC_RS  INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER        \/*   2 chars; Register_Shifter *\/\n+#define ISC_SM  INDIC_SYLLABIC_CATEGORY_SYLLABLE_MODIFIER       \/*  25 chars; Syllable_Modifier *\/\n+#define ISC_TL  INDIC_SYLLABIC_CATEGORY_TONE_LETTER             \/*   7 chars; Tone_Letter *\/\n+#define ISC_TM  INDIC_SYLLABIC_CATEGORY_TONE_MARK               \/*  42 chars; Tone_Mark *\/\n+#define ISC_V   INDIC_SYLLABIC_CATEGORY_VIRAMA                  \/*  25 chars; Virama *\/\n+#define ISC_Vs  INDIC_SYLLABIC_CATEGORY_VISARGA                 \/*  36 chars; Visarga *\/\n+#define ISC_Vo  INDIC_SYLLABIC_CATEGORY_VOWEL                   \/*  30 chars; Vowel *\/\n+#define ISC_M   INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT         \/* 660 chars; Vowel_Dependent *\/\n+#define ISC_VI  INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT       \/* 464 chars; Vowel_Independent *\/\n+\n+#define IMC_B   INDIC_MATRA_CATEGORY_BOTTOM                     \/* 340 chars; Bottom *\/\n+#define IMC_BL  INDIC_MATRA_CATEGORY_BOTTOM_AND_LEFT            \/*   1 chars; Bottom_And_Left *\/\n+#define IMC_BR  INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT           \/*   2 chars; Bottom_And_Right *\/\n+#define IMC_L   INDIC_MATRA_CATEGORY_LEFT                       \/*  59 chars; Left *\/\n+#define IMC_LR  INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT             \/*  21 chars; Left_And_Right *\/\n+#define IMC_x   INDIC_MATRA_CATEGORY_NOT_APPLICABLE             \/*   1 chars; Not_Applicable *\/\n+#define IMC_O   INDIC_MATRA_CATEGORY_OVERSTRUCK                 \/*  10 chars; Overstruck *\/\n+#define IMC_R   INDIC_MATRA_CATEGORY_RIGHT                      \/* 276 chars; Right *\/\n+#define IMC_T   INDIC_MATRA_CATEGORY_TOP                        \/* 393 chars; Top *\/\n+#define IMC_TB  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM             \/*  10 chars; Top_And_Bottom *\/\n+#define IMC_TBR INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT   \/*   1 chars; Top_And_Bottom_And_Right *\/\n+#define IMC_TL  INDIC_MATRA_CATEGORY_TOP_AND_LEFT               \/*   6 chars; Top_And_Left *\/\n+#define IMC_TLR INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT     \/*   4 chars; Top_And_Left_And_Right *\/\n+#define IMC_TR  INDIC_MATRA_CATEGORY_TOP_AND_RIGHT              \/*  13 chars; Top_And_Right *\/\n+#define IMC_VOL INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT          \/*  19 chars; Visual_Order_Left *\/\n+#pragma GCC diagnostic pop\n+\n+#define _(S,M) INDIC_COMBINE_CATEGORIES (ISC_##S, IMC_##M)\n+\n+\n+static const INDIC_TABLE_ELEMENT_TYPE indic_table[] = {\n+\n+\n+#define indic_offset_0x0028u 0\n+\n+\n+  \/* Basic Latin *\/\n+\n+  \/* 0028 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(CP,x),  _(x,x),  _(x,x),\n+  \/* 0030 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0038 *\/ _(Nd,x), _(Nd,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+#define indic_offset_0x00b0u 24\n+\n+\n+  \/* Latin-1 Supplement *\/\n+\n+  \/* 00B0 *\/  _(x,x),  _(x,x), _(SM,x), _(SM,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 00B8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 00C0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 00C8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 00D0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(CP,x),\n+\n+#define indic_offset_0x0900u 64\n+\n+\n+  \/* Devanagari *\/\n+\n+  \/* 0900 *\/ _(Bi,T), _(Bi,T), _(Bi,T), _(Vs,R), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0908 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0910 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0918 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0920 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0928 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0930 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0938 *\/  _(C,x),  _(C,x),  _(M,T),  _(M,R),  _(N,B),  _(A,x),  _(M,R),  _(M,L),\n+  \/* 0940 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(M,T),  _(M,T),  _(M,T),\n+  \/* 0948 *\/  _(M,T),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(V,B),  _(M,L),  _(M,R),\n+  \/* 0950 *\/  _(x,x), _(Ca,T), _(Ca,B),  _(x,T),  _(x,T),  _(M,T),  _(M,B),  _(M,B),\n+  \/* 0958 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0960 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0968 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0970 *\/  _(x,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0978 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+\n+  \/* Bengali *\/\n+\n+  \/* 0980 *\/ _(CP,x), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0988 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x), _(VI,x),\n+  \/* 0990 *\/ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0998 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 09A0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 09A8 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 09B0 *\/  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),\n+  \/* 09B8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,L),\n+  \/* 09C0 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(M,L),\n+  \/* 09C8 *\/  _(M,L),  _(x,x),  _(x,x), _(M,LR), _(M,LR),  _(V,B), _(CD,x),  _(x,x),\n+  \/* 09D0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),\n+  \/* 09D8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),\n+  \/* 09E0 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 09E8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 09F0 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 09F8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Bi,x),  _(x,x), _(SM,T),  _(x,x),\n+\n+  \/* Gurmukhi *\/\n+\n+  \/* 0A00 *\/  _(x,x), _(Bi,T), _(Bi,T), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0A08 *\/ _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x),\n+  \/* 0A10 *\/ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0A18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0A20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0A28 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0A30 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),\n+  \/* 0A38 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(x,x),  _(M,R),  _(M,L),\n+  \/* 0A40 *\/  _(M,R),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),\n+  \/* 0A48 *\/  _(M,T),  _(x,x),  _(x,x),  _(M,T),  _(M,T),  _(V,B),  _(x,x),  _(x,x),\n+  \/* 0A50 *\/  _(x,x), _(Ca,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0A58 *\/  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),\n+  \/* 0A60 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0A68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0A70 *\/ _(Bi,T), _(GM,T), _(CP,x), _(CP,x),  _(x,x), _(CM,B),  _(x,x),  _(x,x),\n+  \/* 0A78 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+  \/* Gujarati *\/\n+\n+  \/* 0A80 *\/  _(x,x), _(Bi,T), _(Bi,T), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0A88 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x),\n+  \/* 0A90 *\/ _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0A98 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0AA0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0AA8 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0AB0 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0AB8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,L),\n+  \/* 0AC0 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(M,T),  _(x,x),  _(M,T),\n+  \/* 0AC8 *\/  _(M,T), _(M,TR),  _(x,x),  _(M,R),  _(M,R),  _(V,B),  _(x,x),  _(x,x),\n+  \/* 0AD0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0AD8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0AE0 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0AE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0AF0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0AF8 *\/  _(x,x),  _(C,x), _(Ca,T), _(Ca,T), _(Ca,T),  _(N,T),  _(N,T),  _(N,T),\n+\n+  \/* Oriya *\/\n+\n+  \/* 0B00 *\/  _(x,x), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0B08 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x), _(VI,x),\n+  \/* 0B10 *\/ _(VI,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0B18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0B20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0B28 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0B30 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0B38 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,T),\n+  \/* 0B40 *\/  _(M,R),  _(M,B),  _(M,B),  _(M,B),  _(M,B),  _(x,x),  _(x,x),  _(M,L),\n+  \/* 0B48 *\/ _(M,TL),  _(x,x),  _(x,x), _(M,LR),_(M,TLR),  _(V,B),  _(x,x),  _(x,x),\n+  \/* 0B50 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T), _(M,TR),\n+  \/* 0B58 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),\n+  \/* 0B60 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0B68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0B70 *\/  _(x,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0B78 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+  \/* Tamil *\/\n+\n+  \/* 0B80 *\/  _(x,x),  _(x,x), _(Bi,T), _(ML,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0B88 *\/ _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x), _(VI,x),\n+  \/* 0B90 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(x,x),  _(x,x),\n+  \/* 0B98 *\/  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),\n+  \/* 0BA0 *\/  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0BA8 *\/  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(C,x),\n+  \/* 0BB0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0BB8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),  _(M,R),\n+  \/* 0BC0 *\/  _(M,T),  _(M,R),  _(M,R),  _(x,x),  _(x,x),  _(x,x),  _(M,L),  _(M,L),\n+  \/* 0BC8 *\/  _(M,L),  _(x,x), _(M,LR), _(M,LR), _(M,LR),  _(V,T),  _(x,x),  _(x,x),\n+  \/* 0BD0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),\n+  \/* 0BD8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0BE0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0BE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0BF0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0BF8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+  \/* Telugu *\/\n+\n+  \/* 0C00 *\/ _(Bi,T), _(Bi,R), _(Bi,R), _(Vs,R), _(Bi,T), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0C08 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),\n+  \/* 0C10 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0C18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0C20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0C28 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0C30 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0C38 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(A,x),  _(M,T),  _(M,T),\n+  \/* 0C40 *\/  _(M,T),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(x,x),  _(M,T),  _(M,T),\n+  \/* 0C48 *\/ _(M,TB),  _(x,x),  _(M,T),  _(M,T),  _(M,T),  _(V,T),  _(x,x),  _(x,x),\n+  \/* 0C50 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,T),  _(M,B),  _(x,x),\n+  \/* 0C58 *\/  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0C60 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0C68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0C70 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0C78 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+  \/* Kannada *\/\n+\n+  \/* 0C80 *\/  _(x,x), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0C88 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),\n+  \/* 0C90 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0C98 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0CA0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0CA8 *\/  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0CB0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0CB8 *\/  _(C,x),  _(C,x),  _(x,x),  _(x,x),  _(N,B),  _(A,x),  _(M,R),  _(M,T),\n+  \/* 0CC0 *\/ _(M,TR),  _(M,R),  _(M,R),  _(M,R),  _(M,R),  _(x,x),  _(M,T), _(M,TR),\n+  \/* 0CC8 *\/ _(M,TR),  _(x,x), _(M,TR), _(M,TR),  _(M,T),  _(V,T),  _(x,x),  _(x,x),\n+  \/* 0CD0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),  _(M,R),  _(x,x),\n+  \/* 0CD8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(C,x),  _(x,x),\n+  \/* 0CE0 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0CE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0CF0 *\/  _(x,x),_(CWS,x),_(CWS,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0CF8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+  \/* Malayalam *\/\n+\n+  \/* 0D00 *\/ _(Bi,T), _(Bi,T), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0D08 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x), _(VI,x), _(VI,x),\n+  \/* 0D10 *\/ _(VI,x),  _(x,x), _(VI,x), _(VI,x), _(VI,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0D18 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0D20 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0D28 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0D30 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0D38 *\/  _(C,x),  _(C,x),  _(C,x), _(PK,T), _(PK,T),  _(A,x),  _(M,R),  _(M,R),\n+  \/* 0D40 *\/  _(M,R),  _(M,R),  _(M,R),  _(M,B),  _(M,B),  _(x,x),  _(M,L),  _(M,L),\n+  \/* 0D48 *\/  _(M,L),  _(x,x), _(M,LR), _(M,LR), _(M,LR),  _(V,T),_(CPR,x),  _(x,x),\n+  \/* 0D50 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(CD,x), _(CD,x), _(CD,x),  _(M,R),\n+  \/* 0D58 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x),\n+  \/* 0D60 *\/ _(VI,x), _(VI,x),  _(M,B),  _(M,B),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0D68 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0D70 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 0D78 *\/  _(x,x),  _(x,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x), _(CD,x),\n+\n+  \/* Sinhala *\/\n+\n+  \/* 0D80 *\/  _(x,x),  _(x,x), _(Bi,R), _(Vs,R),  _(x,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0D88 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 0D90 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),\n+  \/* 0D98 *\/  _(x,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0DA0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0DA8 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0DB0 *\/  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 0DB8 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),  _(C,x),  _(x,x),  _(x,x),\n+  \/* 0DC0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),\n+  \/* 0DC8 *\/  _(x,x),  _(x,x),  _(V,T),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(M,R),\n+  \/* 0DD0 *\/  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,B),  _(x,x),  _(M,B),  _(x,x),\n+  \/* 0DD8 *\/  _(M,R),  _(M,L), _(M,TL),  _(M,L), _(M,LR),_(M,TLR), _(M,LR),  _(M,R),\n+  \/* 0DE0 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(Nd,x), _(Nd,x),\n+  \/* 0DE8 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 0DF0 *\/  _(x,x),  _(x,x),  _(M,R),  _(M,R),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+#define indic_offset_0x1000u 1336\n+\n+\n+  \/* Myanmar *\/\n+\n+  \/* 1000 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1008 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1010 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1018 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1020 *\/  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 1028 *\/ _(VI,x), _(VI,x), _(VI,x),  _(M,R),  _(M,R),  _(M,T),  _(M,T),  _(M,B),\n+  \/* 1030 *\/  _(M,B),  _(M,L),  _(M,T),  _(M,T),  _(M,T),  _(M,T), _(Bi,T), _(TM,B),\n+  \/* 1038 *\/ _(Vs,R), _(IS,x), _(PK,T), _(CM,R), _(CM,x), _(CM,B), _(CM,B),  _(C,x),\n+  \/* 1040 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 1048 *\/ _(Nd,x), _(Nd,x),  _(x,x), _(CP,x),  _(x,x),  _(x,x), _(CP,x),  _(x,x),\n+  \/* 1050 *\/  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(M,R),  _(M,R),\n+  \/* 1058 *\/  _(M,B),  _(M,B),  _(C,x),  _(C,x),  _(C,x),  _(C,x), _(CM,B), _(CM,B),\n+  \/* 1060 *\/ _(CM,B),  _(C,x),  _(M,R), _(TM,R), _(TM,R),  _(C,x),  _(C,x),  _(M,R),\n+  \/* 1068 *\/  _(M,R), _(TM,R), _(TM,R), _(TM,R), _(TM,R), _(TM,R),  _(C,x),  _(C,x),\n+  \/* 1070 *\/  _(C,x),  _(M,T),  _(M,T),  _(M,T),  _(M,T),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1078 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1080 *\/  _(C,x),  _(C,x), _(CM,B),  _(M,R),  _(M,L),  _(M,T),  _(M,T), _(TM,R),\n+  \/* 1088 *\/ _(TM,R), _(TM,R), _(TM,R), _(TM,R), _(TM,R), _(TM,B),  _(C,x), _(TM,R),\n+  \/* 1090 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 1098 *\/ _(Nd,x), _(Nd,x), _(TM,R), _(TM,R),  _(M,R),  _(M,T),  _(x,x),  _(x,x),\n+\n+#define indic_offset_0x1780u 1496\n+\n+\n+  \/* Khmer *\/\n+\n+  \/* 1780 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1788 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1790 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 1798 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* 17A0 *\/  _(C,x),  _(C,x),  _(C,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 17A8 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x), _(VI,x),\n+  \/* 17B0 *\/ _(VI,x), _(VI,x), _(VI,x), _(VI,x),  _(x,x),  _(x,x),  _(M,R),  _(M,T),\n+  \/* 17B8 *\/  _(M,T),  _(M,T),  _(M,T),  _(M,B),  _(M,B),  _(M,B), _(M,TL),_(M,TLR),\n+  \/* 17C0 *\/ _(M,LR),  _(M,L),  _(M,L),  _(M,L), _(M,LR), _(M,LR), _(Bi,T), _(Vs,R),\n+  \/* 17C8 *\/  _(M,R), _(RS,T), _(RS,T), _(SM,T),_(CSR,T), _(CK,T), _(SM,T), _(SM,T),\n+  \/* 17D0 *\/ _(SM,T), _(PK,T), _(IS,x), _(SM,T),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 17D8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(A,x), _(SM,T),  _(x,x),  _(x,x),\n+  \/* 17E0 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* 17E8 *\/ _(Nd,x), _(Nd,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+#define indic_offset_0x1cd0u 1608\n+\n+\n+  \/* Vedic Extensions *\/\n+\n+  \/* 1CD0 *\/ _(Ca,T), _(Ca,T), _(Ca,T),  _(x,x), _(Ca,O), _(Ca,B), _(Ca,B), _(Ca,B),\n+  \/* 1CD8 *\/ _(Ca,B), _(Ca,B), _(Ca,T), _(Ca,T), _(Ca,B), _(Ca,B), _(Ca,B), _(Ca,B),\n+  \/* 1CE0 *\/ _(Ca,T), _(Ca,R),  _(x,O),  _(x,O),  _(x,O),  _(x,O),  _(x,O),  _(x,O),\n+  \/* 1CE8 *\/  _(x,O),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,B),  _(x,x),  _(x,x),\n+  \/* 1CF0 *\/  _(x,x),  _(x,x), _(Vs,x), _(Vs,x), _(Ca,T),_(CWS,x),_(CWS,x), _(Ca,R),\n+  \/* 1CF8 *\/ _(Ca,x), _(Ca,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+#define indic_offset_0x2008u 1656\n+\n+\n+  \/* General Punctuation *\/\n+\n+  \/* 2008 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),_(ZWNJ,x),_(ZWJ,x),  _(x,x),  _(x,x),\n+  \/* 2010 *\/ _(CP,x), _(CP,x), _(CP,x), _(CP,x), _(CP,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+#define indic_offset_0x2070u 1672\n+\n+\n+  \/* Superscripts and Subscripts *\/\n+\n+  \/* 2070 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(SM,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 2078 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* 2080 *\/  _(x,x),  _(x,x), _(SM,x), _(SM,x), _(SM,x),  _(x,x),  _(x,x),  _(x,x),\n+\n+#define indic_offset_0xa8e0u 1696\n+\n+\n+  \/* Devanagari Extended *\/\n+\n+  \/* A8E0 *\/ _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T),\n+  \/* A8E8 *\/ _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T), _(Ca,T),\n+  \/* A8F0 *\/ _(Ca,T), _(Ca,T), _(Bi,x), _(Bi,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),\n+  \/* A8F8 *\/  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x),  _(x,x), _(VI,x),  _(M,T),\n+\n+#define indic_offset_0xa9e0u 1728\n+\n+\n+  \/* Myanmar Extended-B *\/\n+\n+  \/* A9E0 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(M,T),  _(x,x),  _(C,x),\n+  \/* A9E8 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* A9F0 *\/ _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x), _(Nd,x),\n+  \/* A9F8 *\/ _(Nd,x), _(Nd,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(x,x),\n+\n+#define indic_offset_0xaa60u 1760\n+\n+\n+  \/* Myanmar Extended-A *\/\n+\n+  \/* AA60 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* AA68 *\/  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),  _(C,x),\n+  \/* AA70 *\/  _(x,x),  _(C,x),  _(C,x),  _(C,x), _(CP,x), _(CP,x), _(CP,x),  _(x,x),\n+  \/* AA78 *\/  _(x,x),  _(x,x),  _(C,x), _(TM,R), _(TM,T), _(TM,R),  _(C,x),  _(C,x),\n+\n+}; \/* Table items: 1792; occupancy: 70% *\/\n+\n+INDIC_TABLE_ELEMENT_TYPE\n+hb_indic_get_categories (hb_codepoint_t u)\n+{\n+  switch (u >> 12)\n+  {\n+    case 0x0u:\n+      if (unlikely (u == 0x00A0u)) return _(CP,x);\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0028u, 0x003Fu)) return indic_table[u - 0x0028u + indic_offset_0x0028u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x00B0u, 0x00D7u)) return indic_table[u - 0x00B0u + indic_offset_0x00b0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0900u, 0x0DF7u)) return indic_table[u - 0x0900u + indic_offset_0x0900u];\n+      break;\n+\n+    case 0x1u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1000u, 0x109Fu)) return indic_table[u - 0x1000u + indic_offset_0x1000u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1780u, 0x17EFu)) return indic_table[u - 0x1780u + indic_offset_0x1780u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1CD0u, 0x1CFFu)) return indic_table[u - 0x1CD0u + indic_offset_0x1cd0u];\n+      break;\n+\n+    case 0x2u:\n+      if (unlikely (u == 0x25CCu)) return _(CP,x);\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2008u, 0x2017u)) return indic_table[u - 0x2008u + indic_offset_0x2008u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2070u, 0x2087u)) return indic_table[u - 0x2070u + indic_offset_0x2070u];\n+      break;\n+\n+    case 0xAu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA8E0u, 0xA8FFu)) return indic_table[u - 0xA8E0u + indic_offset_0xa8e0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA9E0u, 0xA9FFu)) return indic_table[u - 0xA9E0u + indic_offset_0xa9e0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xAA60u, 0xAA7Fu)) return indic_table[u - 0xAA60u + indic_offset_0xaa60u];\n+      break;\n+\n+    default:\n+      break;\n+  }\n+  return _(x,x);\n+}\n+\n+#undef _\n+#undef ISC_A\n+#undef ISC_Bi\n+#undef ISC_BJN\n+#undef ISC_Ca\n+#undef ISC_C\n+#undef ISC_CD\n+#undef ISC_CF\n+#undef ISC_CHL\n+#undef ISC_CIP\n+#undef ISC_CK\n+#undef ISC_CM\n+#undef ISC_CP\n+#undef ISC_CPR\n+#undef ISC_CPrf\n+#undef ISC_CS\n+#undef ISC_CSR\n+#undef ISC_CWS\n+#undef ISC_GM\n+#undef ISC_IS\n+#undef ISC_ZWJ\n+#undef ISC_ML\n+#undef ISC_ZWNJ\n+#undef ISC_N\n+#undef ISC_Nd\n+#undef ISC_NJ\n+#undef ISC_x\n+#undef ISC_PK\n+#undef ISC_RS\n+#undef ISC_SM\n+#undef ISC_TL\n+#undef ISC_TM\n+#undef ISC_V\n+#undef ISC_Vs\n+#undef ISC_Vo\n+#undef ISC_M\n+#undef ISC_VI\n+#undef IMC_B\n+#undef IMC_BL\n+#undef IMC_BR\n+#undef IMC_L\n+#undef IMC_LR\n+#undef IMC_x\n+#undef IMC_O\n+#undef IMC_R\n+#undef IMC_T\n+#undef IMC_TB\n+#undef IMC_TBR\n+#undef IMC_TL\n+#undef IMC_TLR\n+#undef IMC_TR\n+#undef IMC_VOL\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-indic-table.cc","additions":490,"deletions":0,"binary":false,"changes":490,"status":"added"},{"patch":"@@ -0,0 +1,1637 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex-indic.hh\"\n+#include \"hb-ot-shape-complex-vowel-constraints.hh\"\n+#include \"hb-ot-layout.hh\"\n+\n+\n+\/*\n+ * Indic shaper.\n+ *\/\n+\n+\n+\/*\n+ * Indic configurations.  Note that we do not want to keep every single script-specific\n+ * behavior in these tables necessarily.  This should mainly be used for per-script\n+ * properties that are cheaper keeping here, than in the code.  Ie. if, say, one and\n+ * only one script has an exception, that one script can be if'ed directly in the code,\n+ * instead of adding a new flag in these structs.\n+ *\/\n+\n+enum base_position_t {\n+  BASE_POS_LAST_SINHALA,\n+  BASE_POS_LAST\n+};\n+enum reph_position_t {\n+  REPH_POS_AFTER_MAIN  = POS_AFTER_MAIN,\n+  REPH_POS_BEFORE_SUB  = POS_BEFORE_SUB,\n+  REPH_POS_AFTER_SUB   = POS_AFTER_SUB,\n+  REPH_POS_BEFORE_POST = POS_BEFORE_POST,\n+  REPH_POS_AFTER_POST  = POS_AFTER_POST\n+};\n+enum reph_mode_t {\n+  REPH_MODE_IMPLICIT,  \/* Reph formed out of initial Ra,H sequence. *\/\n+  REPH_MODE_EXPLICIT,  \/* Reph formed out of initial Ra,H,ZWJ sequence. *\/\n+  REPH_MODE_LOG_REPHA  \/* Encoded Repha character, needs reordering. *\/\n+};\n+enum blwf_mode_t {\n+  BLWF_MODE_PRE_AND_POST, \/* Below-forms feature applied to pre-base and post-base. *\/\n+  BLWF_MODE_POST_ONLY     \/* Below-forms feature applied to post-base only. *\/\n+};\n+struct indic_config_t\n+{\n+  hb_script_t     script;\n+  bool            has_old_spec;\n+  hb_codepoint_t  virama;\n+  base_position_t base_pos;\n+  reph_position_t reph_pos;\n+  reph_mode_t     reph_mode;\n+  blwf_mode_t     blwf_mode;\n+};\n+\n+static const indic_config_t indic_configs[] =\n+{\n+  \/* Default.  Should be first. *\/\n+  {HB_SCRIPT_INVALID,   false,      0,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_DEVANAGARI,true, 0x094Du,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_BENGALI,   true, 0x09CDu,BASE_POS_LAST, REPH_POS_AFTER_SUB,  REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_GURMUKHI,  true, 0x0A4Du,BASE_POS_LAST, REPH_POS_BEFORE_SUB, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_GUJARATI,  true, 0x0ACDu,BASE_POS_LAST, REPH_POS_BEFORE_POST,REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_ORIYA,     true, 0x0B4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_TAMIL,     true, 0x0BCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_TELUGU,    true, 0x0C4Du,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_POST_ONLY},\n+  {HB_SCRIPT_KANNADA,   true, 0x0CCDu,BASE_POS_LAST, REPH_POS_AFTER_POST, REPH_MODE_IMPLICIT, BLWF_MODE_POST_ONLY},\n+  {HB_SCRIPT_MALAYALAM, true, 0x0D4Du,BASE_POS_LAST, REPH_POS_AFTER_MAIN, REPH_MODE_LOG_REPHA,BLWF_MODE_PRE_AND_POST},\n+  {HB_SCRIPT_SINHALA,   false,0x0DCAu,BASE_POS_LAST_SINHALA,\n+                                                     REPH_POS_AFTER_POST, REPH_MODE_EXPLICIT, BLWF_MODE_PRE_AND_POST},\n+};\n+\n+\n+\n+\/*\n+ * Indic shaper.\n+ *\/\n+\n+static const hb_ot_map_feature_t\n+indic_features[] =\n+{\n+  \/*\n+   * Basic features.\n+   * These features are applied in order, one at a time, after initial_reordering.\n+   *\/\n+  {HB_TAG('n','u','k','t'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('a','k','h','n'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('r','p','h','f'),        F_MANUAL_JOINERS},\n+  {HB_TAG('r','k','r','f'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('p','r','e','f'),        F_MANUAL_JOINERS},\n+  {HB_TAG('b','l','w','f'),        F_MANUAL_JOINERS},\n+  {HB_TAG('a','b','v','f'),        F_MANUAL_JOINERS},\n+  {HB_TAG('h','a','l','f'),        F_MANUAL_JOINERS},\n+  {HB_TAG('p','s','t','f'),        F_MANUAL_JOINERS},\n+  {HB_TAG('v','a','t','u'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('c','j','c','t'), F_GLOBAL_MANUAL_JOINERS},\n+  \/*\n+   * Other features.\n+   * These features are applied all at once, after final_reordering\n+   * but before clearing syllables.\n+   * Default Bengali font in Windows for example has intermixed\n+   * lookups for init,pres,abvs,blws features.\n+   *\/\n+  {HB_TAG('i','n','i','t'),        F_MANUAL_JOINERS},\n+  {HB_TAG('p','r','e','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('a','b','v','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('b','l','w','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('p','s','t','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('h','a','l','n'), F_GLOBAL_MANUAL_JOINERS},\n+  \/*\n+   * Positioning features.\n+   * We don't care about the types.\n+   *\/\n+  {HB_TAG('d','i','s','t'), F_GLOBAL},\n+  {HB_TAG('a','b','v','m'), F_GLOBAL},\n+  {HB_TAG('b','l','w','m'), F_GLOBAL},\n+};\n+\n+\/*\n+ * Must be in the same order as the indic_features array.\n+ *\/\n+enum {\n+  _NUKT,\n+  _AKHN,\n+  RPHF,\n+  _RKRF,\n+  PREF,\n+  BLWF,\n+  ABVF,\n+  HALF,\n+  PSTF,\n+  _VATU,\n+  _CJCT,\n+\n+  INIT,\n+  _PRES,\n+  _ABVS,\n+  _BLWS,\n+  _PSTS,\n+  _HALN,\n+\n+  _DIST,\n+  _ABVM,\n+  _BLWM,\n+\n+  INDIC_NUM_FEATURES,\n+  INDIC_BASIC_FEATURES = INIT, \/* Don't forget to update this! *\/\n+};\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+static void\n+initial_reordering (const hb_ot_shape_plan_t *plan,\n+                    hb_font_t *font,\n+                    hb_buffer_t *buffer);\n+static void\n+final_reordering (const hb_ot_shape_plan_t *plan,\n+                  hb_font_t *font,\n+                  hb_buffer_t *buffer);\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+\n+static void\n+collect_features_indic (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Do this before any lookups have been applied. *\/\n+  map->add_gsub_pause (setup_syllables);\n+\n+  map->enable_feature (HB_TAG('l','o','c','l'));\n+  \/* The Indic specs do not require ccmp, but we apply it here since if\n+   * there is a use of it, it's typically at the beginning. *\/\n+  map->enable_feature (HB_TAG('c','c','m','p'));\n+\n+\n+  unsigned int i = 0;\n+  map->add_gsub_pause (initial_reordering);\n+\n+  for (; i < INDIC_BASIC_FEATURES; i++) {\n+    map->add_feature (indic_features[i]);\n+    map->add_gsub_pause (nullptr);\n+  }\n+\n+  map->add_gsub_pause (final_reordering);\n+\n+  for (; i < INDIC_NUM_FEATURES; i++)\n+    map->add_feature (indic_features[i]);\n+\n+  map->enable_feature (HB_TAG('c','a','l','t'));\n+  map->enable_feature (HB_TAG('c','l','i','g'));\n+\n+  map->add_gsub_pause (clear_syllables);\n+}\n+\n+static void\n+override_features_indic (hb_ot_shape_planner_t *plan)\n+{\n+  plan->map.disable_feature (HB_TAG('l','i','g','a'));\n+}\n+\n+\n+struct would_substitute_feature_t\n+{\n+  void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)\n+  {\n+    zero_context = zero_context_;\n+    map->get_stage_lookups (0\/*GSUB*\/,\n+                            map->get_feature_stage (0\/*GSUB*\/, feature_tag),\n+                            &lookups, &count);\n+  }\n+\n+  bool would_substitute (const hb_codepoint_t *glyphs,\n+                         unsigned int          glyphs_count,\n+                         hb_face_t            *face) const\n+  {\n+    for (unsigned int i = 0; i < count; i++)\n+      if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))\n+        return true;\n+    return false;\n+  }\n+\n+  private:\n+  const hb_ot_map_t::lookup_map_t *lookups;\n+  unsigned int count;\n+  bool zero_context;\n+};\n+\n+struct indic_shape_plan_t\n+{\n+  bool load_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const\n+  {\n+    hb_codepoint_t glyph = virama_glyph.get_relaxed ();\n+    if (unlikely (glyph == (hb_codepoint_t) -1))\n+    {\n+      if (!config->virama || !font->get_nominal_glyph (config->virama, &glyph))\n+        glyph = 0;\n+      \/* Technically speaking, the spec says we should apply 'locl' to virama too.\n+       * Maybe one day... *\/\n+\n+      \/* Our get_nominal_glyph() function needs a font, so we can't get the virama glyph\n+       * during shape planning...  Instead, overwrite it here. *\/\n+      virama_glyph.set_relaxed ((int) glyph);\n+    }\n+\n+    *pglyph = glyph;\n+    return glyph != 0;\n+  }\n+\n+  const indic_config_t *config;\n+\n+  bool is_old_spec;\n+  bool uniscribe_bug_compatible;\n+  mutable hb_atomic_int_t virama_glyph;\n+\n+  would_substitute_feature_t rphf;\n+  would_substitute_feature_t pref;\n+  would_substitute_feature_t blwf;\n+  would_substitute_feature_t pstf;\n+\n+  hb_mask_t mask_array[INDIC_NUM_FEATURES];\n+};\n+\n+static void *\n+data_create_indic (const hb_ot_shape_plan_t *plan)\n+{\n+  indic_shape_plan_t *indic_plan = (indic_shape_plan_t *) calloc (1, sizeof (indic_shape_plan_t));\n+  if (unlikely (!indic_plan))\n+    return nullptr;\n+\n+  indic_plan->config = &indic_configs[0];\n+  for (unsigned int i = 1; i < ARRAY_LENGTH (indic_configs); i++)\n+    if (plan->props.script == indic_configs[i].script) {\n+      indic_plan->config = &indic_configs[i];\n+      break;\n+    }\n+\n+  indic_plan->is_old_spec = indic_plan->config->has_old_spec && ((plan->map.chosen_script[0] & 0x000000FFu) != '2');\n+  indic_plan->uniscribe_bug_compatible = hb_options ().uniscribe_bug_compatible;\n+  indic_plan->virama_glyph.set_relaxed (-1);\n+\n+  \/* Use zero-context would_substitute() matching for new-spec of the main\n+   * Indic scripts, and scripts with one spec only, but not for old-specs.\n+   * The new-spec for all dual-spec scripts says zero-context matching happens.\n+   *\n+   * However, testing with Malayalam shows that old and new spec both allow\n+   * context.  Testing with Bengali new-spec however shows that it doesn't.\n+   * So, the heuristic here is the way it is.  It should *only* be changed,\n+   * as we discover more cases of what Windows does.  DON'T TOUCH OTHERWISE.\n+   *\/\n+  bool zero_context = !indic_plan->is_old_spec && plan->props.script != HB_SCRIPT_MALAYALAM;\n+  indic_plan->rphf.init (&plan->map, HB_TAG('r','p','h','f'), zero_context);\n+  indic_plan->pref.init (&plan->map, HB_TAG('p','r','e','f'), zero_context);\n+  indic_plan->blwf.init (&plan->map, HB_TAG('b','l','w','f'), zero_context);\n+  indic_plan->pstf.init (&plan->map, HB_TAG('p','s','t','f'), zero_context);\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (indic_plan->mask_array); i++)\n+    indic_plan->mask_array[i] = (indic_features[i].flags & F_GLOBAL) ?\n+                                 0 : plan->map.get_1_mask (indic_features[i].tag);\n+\n+  return indic_plan;\n+}\n+\n+static void\n+data_destroy_indic (void *data)\n+{\n+  free (data);\n+}\n+\n+static indic_position_t\n+consonant_position_from_face (const indic_shape_plan_t *indic_plan,\n+                              const hb_codepoint_t consonant,\n+                              const hb_codepoint_t virama,\n+                              hb_face_t *face)\n+{\n+  \/* For old-spec, the order of glyphs is Consonant,Virama,\n+   * whereas for new-spec, it's Virama,Consonant.  However,\n+   * some broken fonts (like Free Sans) simply copied lookups\n+   * from old-spec to new-spec without modification.\n+   * And oddly enough, Uniscribe seems to respect those lookups.\n+   * Eg. in the sequence U+0924,U+094D,U+0930, Uniscribe finds\n+   * base at 0.  The font however, only has lookups matching\n+   * 930,94D in 'blwf', not the expected 94D,930 (with new-spec\n+   * table).  As such, we simply match both sequences.  Seems\n+   * to work. *\/\n+  hb_codepoint_t glyphs[3] = {virama, consonant, virama};\n+  if (indic_plan->blwf.would_substitute (glyphs  , 2, face) ||\n+      indic_plan->blwf.would_substitute (glyphs+1, 2, face))\n+    return POS_BELOW_C;\n+  if (indic_plan->pstf.would_substitute (glyphs  , 2, face) ||\n+      indic_plan->pstf.would_substitute (glyphs+1, 2, face))\n+    return POS_POST_C;\n+  if (indic_plan->pref.would_substitute (glyphs  , 2, face) ||\n+      indic_plan->pref.would_substitute (glyphs+1, 2, face))\n+    return POS_POST_C;\n+  return POS_BASE_C;\n+}\n+\n+\n+enum syllable_type_t {\n+  consonant_syllable,\n+  vowel_syllable,\n+  standalone_cluster,\n+  symbol_cluster,\n+  broken_cluster,\n+  non_indic_cluster,\n+};\n+\n+#include \"hb-ot-shape-complex-indic-machine.hh\"\n+\n+\n+static void\n+setup_masks_indic (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                   hb_buffer_t              *buffer,\n+                   hb_font_t                *font HB_UNUSED)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, indic_category);\n+  HB_BUFFER_ALLOCATE_VAR (buffer, indic_position);\n+\n+  \/* We cannot setup masks here.  We save information about characters\n+   * and setup masks later on in a pause-callback. *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    set_indic_properties (info[i]);\n+}\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  find_syllables (buffer);\n+  foreach_syllable (buffer, start, end)\n+    buffer->unsafe_to_break (start, end);\n+}\n+\n+static int\n+compare_indic_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)\n+{\n+  int a = pa->indic_position();\n+  int b = pb->indic_position();\n+\n+  return a < b ? -1 : a == b ? 0 : +1;\n+}\n+\n+\n+\n+static void\n+update_consonant_positions (const hb_ot_shape_plan_t *plan,\n+                            hb_font_t         *font,\n+                            hb_buffer_t       *buffer)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+\n+  if (indic_plan->config->base_pos != BASE_POS_LAST)\n+    return;\n+\n+  hb_codepoint_t virama;\n+  if (indic_plan->load_virama_glyph (font, &virama))\n+  {\n+    hb_face_t *face = font->face;\n+    unsigned int count = buffer->len;\n+    hb_glyph_info_t *info = buffer->info;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (info[i].indic_position() == POS_BASE_C)\n+      {\n+        hb_codepoint_t consonant = info[i].codepoint;\n+        info[i].indic_position() = consonant_position_from_face (indic_plan, consonant, virama, face);\n+      }\n+  }\n+}\n+\n+\n+\/* Rules from:\n+ * https:\/\/docs.microsqoft.com\/en-us\/typography\/script-development\/devanagari *\/\n+\n+static void\n+initial_reordering_consonant_syllable (const hb_ot_shape_plan_t *plan,\n+                                       hb_face_t *face,\n+                                       hb_buffer_t *buffer,\n+                                       unsigned int start, unsigned int end)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/435#issuecomment-335560167\n+   * \/\/ For compatibility with legacy usage in Kannada,\n+   * \/\/ Ra+h+ZWJ must behave like Ra+ZWJ+h...\n+   *\/\n+  if (buffer->props.script == HB_SCRIPT_KANNADA &&\n+      start + 3 <= end &&\n+      is_one_of (info[start  ], FLAG (OT_Ra)) &&\n+      is_one_of (info[start+1], FLAG (OT_H)) &&\n+      is_one_of (info[start+2], FLAG (OT_ZWJ)))\n+  {\n+    buffer->merge_clusters (start+1, start+3);\n+    hb_glyph_info_t tmp = info[start+1];\n+    info[start+1] = info[start+2];\n+    info[start+2] = tmp;\n+  }\n+\n+  \/* 1. Find base consonant:\n+   *\n+   * The shaping engine finds the base consonant of the syllable, using the\n+   * following algorithm: starting from the end of the syllable, move backwards\n+   * until a consonant is found that does not have a below-base or post-base\n+   * form (post-base forms have to follow below-base forms), or that is not a\n+   * pre-base-reordering Ra, or arrive at the first consonant. The consonant\n+   * stopped at will be the base.\n+   *\n+   *   o If the syllable starts with Ra + Halant (in a script that has Reph)\n+   *     and has more than one consonant, Ra is excluded from candidates for\n+   *     base consonants.\n+   *\/\n+\n+  unsigned int base = end;\n+  bool has_reph = false;\n+\n+  {\n+    \/* -> If the syllable starts with Ra + Halant (in a script that has Reph)\n+     *    and has more than one consonant, Ra is excluded from candidates for\n+     *    base consonants. *\/\n+    unsigned int limit = start;\n+    if (indic_plan->mask_array[RPHF] &&\n+        start + 3 <= end &&\n+        (\n+         (indic_plan->config->reph_mode == REPH_MODE_IMPLICIT && !is_joiner (info[start + 2])) ||\n+         (indic_plan->config->reph_mode == REPH_MODE_EXPLICIT && info[start + 2].indic_category() == OT_ZWJ)\n+        ))\n+    {\n+      \/* See if it matches the 'rphf' feature. *\/\n+      hb_codepoint_t glyphs[3] = {info[start].codepoint,\n+                                  info[start + 1].codepoint,\n+                                  indic_plan->config->reph_mode == REPH_MODE_EXPLICIT ?\n+                                    info[start + 2].codepoint : 0};\n+      if (indic_plan->rphf.would_substitute (glyphs, 2, face) ||\n+          (indic_plan->config->reph_mode == REPH_MODE_EXPLICIT &&\n+           indic_plan->rphf.would_substitute (glyphs, 3, face)))\n+      {\n+        limit += 2;\n+        while (limit < end && is_joiner (info[limit]))\n+          limit++;\n+        base = start;\n+        has_reph = true;\n+      }\n+    } else if (indic_plan->config->reph_mode == REPH_MODE_LOG_REPHA && info[start].indic_category() == OT_Repha)\n+    {\n+        limit += 1;\n+        while (limit < end && is_joiner (info[limit]))\n+          limit++;\n+        base = start;\n+        has_reph = true;\n+    }\n+\n+    switch (indic_plan->config->base_pos)\n+    {\n+      case BASE_POS_LAST:\n+      {\n+        \/* -> starting from the end of the syllable, move backwards *\/\n+        unsigned int i = end;\n+        bool seen_below = false;\n+        do {\n+          i--;\n+          \/* -> until a consonant is found *\/\n+          if (is_consonant (info[i]))\n+          {\n+            \/* -> that does not have a below-base or post-base form\n+             * (post-base forms have to follow below-base forms), *\/\n+            if (info[i].indic_position() != POS_BELOW_C &&\n+                (info[i].indic_position() != POS_POST_C || seen_below))\n+            {\n+              base = i;\n+              break;\n+            }\n+            if (info[i].indic_position() == POS_BELOW_C)\n+              seen_below = true;\n+\n+            \/* -> or that is not a pre-base-reordering Ra,\n+             *\n+             * IMPLEMENTATION NOTES:\n+             *\n+             * Our pre-base-reordering Ra's are marked POS_POST_C, so will be skipped\n+             * by the logic above already.\n+             *\/\n+\n+            \/* -> or arrive at the first consonant. The consonant stopped at will\n+             * be the base. *\/\n+            base = i;\n+          }\n+          else\n+          {\n+            \/* A ZWJ after a Halant stops the base search, and requests an explicit\n+             * half form.\n+             * A ZWJ before a Halant, requests a subjoined form instead, and hence\n+             * search continues.  This is particularly important for Bengali\n+             * sequence Ra,H,Ya that should form Ya-Phalaa by subjoining Ya. *\/\n+            if (start < i &&\n+                info[i].indic_category() == OT_ZWJ &&\n+                info[i - 1].indic_category() == OT_H)\n+              break;\n+          }\n+        } while (i > limit);\n+      }\n+      break;\n+\n+      case BASE_POS_LAST_SINHALA:\n+      {\n+        \/* Sinhala base positioning is slightly different from main Indic, in that:\n+         * 1. Its ZWJ behavior is different,\n+         * 2. We don't need to look into the font for consonant positions.\n+         *\/\n+\n+        if (!has_reph)\n+          base = limit;\n+\n+        \/* Find the last base consonant that is not blocked by ZWJ.  If there is\n+         * a ZWJ right before a base consonant, that would request a subjoined form. *\/\n+        for (unsigned int i = limit; i < end; i++)\n+          if (is_consonant (info[i]))\n+          {\n+            if (limit < i && info[i - 1].indic_category() == OT_ZWJ)\n+              break;\n+            else\n+              base = i;\n+          }\n+\n+        \/* Mark all subsequent consonants as below. *\/\n+        for (unsigned int i = base + 1; i < end; i++)\n+          if (is_consonant (info[i]))\n+            info[i].indic_position() = POS_BELOW_C;\n+      }\n+      break;\n+    }\n+\n+    \/* -> If the syllable starts with Ra + Halant (in a script that has Reph)\n+     *    and has more than one consonant, Ra is excluded from candidates for\n+     *    base consonants.\n+     *\n+     *  Only do this for unforced Reph. (ie. not for Ra,H,ZWJ. *\/\n+    if (has_reph && base == start && limit - base <= 2) {\n+      \/* Have no other consonant, so Reph is not formed and Ra becomes base. *\/\n+      has_reph = false;\n+    }\n+  }\n+\n+\n+  \/* 2. Decompose and reorder Matras:\n+   *\n+   * Each matra and any syllable modifier sign in the syllable are moved to the\n+   * appropriate position relative to the consonant(s) in the syllable. The\n+   * shaping engine decomposes two- or three-part matras into their constituent\n+   * parts before any repositioning. Matra characters are classified by which\n+   * consonant in a conjunct they have affinity for and are reordered to the\n+   * following positions:\n+   *\n+   *   o Before first half form in the syllable\n+   *   o After subjoined consonants\n+   *   o After post-form consonant\n+   *   o After main consonant (for above marks)\n+   *\n+   * IMPLEMENTATION NOTES:\n+   *\n+   * The normalize() routine has already decomposed matras for us, so we don't\n+   * need to worry about that.\n+   *\/\n+\n+\n+  \/* 3.  Reorder marks to canonical order:\n+   *\n+   * Adjacent nukta and halant or nukta and vedic sign are always repositioned\n+   * if necessary, so that the nukta is first.\n+   *\n+   * IMPLEMENTATION NOTES:\n+   *\n+   * We don't need to do this: the normalize() routine already did this for us.\n+   *\/\n+\n+\n+  \/* Reorder characters *\/\n+\n+  for (unsigned int i = start; i < base; i++)\n+    info[i].indic_position() = MIN (POS_PRE_C, (indic_position_t) info[i].indic_position());\n+\n+  if (base < end)\n+    info[base].indic_position() = POS_BASE_C;\n+\n+  \/* Mark final consonants.  A final consonant is one appearing after a matra.\n+   * Happens in Sinhala. *\/\n+  for (unsigned int i = base + 1; i < end; i++)\n+    if (info[i].indic_category() == OT_M) {\n+      for (unsigned int j = i + 1; j < end; j++)\n+        if (is_consonant (info[j])) {\n+         info[j].indic_position() = POS_FINAL_C;\n+         break;\n+       }\n+      break;\n+    }\n+\n+  \/* Handle beginning Ra *\/\n+  if (has_reph)\n+    info[start].indic_position() = POS_RA_TO_BECOME_REPH;\n+\n+  \/* For old-style Indic script tags, move the first post-base Halant after\n+   * last consonant.\n+   *\n+   * Reports suggest that in some scripts Uniscribe does this only if there\n+   * is *not* a Halant after last consonant already.  We know that is the\n+   * case for Kannada, while it reorders unconditionally in other scripts,\n+   * eg. Malayalam, Bengali, and Devanagari.  We don't currently know about\n+   * other scripts, so we blacklist Kannada.\n+   *\n+   * Kannada test case:\n+   * U+0C9A,U+0CCD,U+0C9A,U+0CCD\n+   * With some versions of Lohit Kannada.\n+   * https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=59118\n+   *\n+   * Malayalam test case:\n+   * U+0D38,U+0D4D,U+0D31,U+0D4D,U+0D31,U+0D4D\n+   * With lohit-ttf-20121122\/Lohit-Malayalam.ttf\n+   *\n+   * Bengali test case:\n+   * U+0998,U+09CD,U+09AF,U+09CD\n+   * With Windows XP vrinda.ttf\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1073\n+   *\n+   * Devanagari test case:\n+   * U+091F,U+094D,U+0930,U+094D\n+   * With chandas.ttf\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1071\n+   *\/\n+  if (indic_plan->is_old_spec)\n+  {\n+    bool disallow_double_halants = buffer->props.script == HB_SCRIPT_KANNADA;\n+    for (unsigned int i = base + 1; i < end; i++)\n+      if (info[i].indic_category() == OT_H)\n+      {\n+        unsigned int j;\n+        for (j = end - 1; j > i; j--)\n+          if (is_consonant (info[j]) ||\n+              (disallow_double_halants && info[j].indic_category() == OT_H))\n+            break;\n+        if (info[j].indic_category() != OT_H && j > i) {\n+          \/* Move Halant to after last consonant. *\/\n+          hb_glyph_info_t t = info[i];\n+          memmove (&info[i], &info[i + 1], (j - i) * sizeof (info[0]));\n+          info[j] = t;\n+        }\n+        break;\n+      }\n+  }\n+\n+  \/* Attach misc marks to previous char to move with them. *\/\n+  {\n+    indic_position_t last_pos = POS_START;\n+    for (unsigned int i = start; i < end; i++)\n+    {\n+      if ((FLAG_UNSAFE (info[i].indic_category()) & (JOINER_FLAGS | FLAG (OT_N) | FLAG (OT_RS) | FLAG (OT_H))))\n+      {\n+        info[i].indic_position() = last_pos;\n+        if (unlikely (info[i].indic_category() == OT_H &&\n+                      info[i].indic_position() == POS_PRE_M))\n+        {\n+          \/*\n+           * Uniscribe doesn't move the Halant with Left Matra.\n+           * TEST: U+092B,U+093F,U+094DE\n+           * We follow.  This is important for the Sinhala\n+           * U+0DDA split matra since it decomposes to U+0DD9,U+0DCA\n+           * where U+0DD9 is a left matra and U+0DCA is the virama.\n+           * We don't want to move the virama with the left matra.\n+           * TEST: U+0D9A,U+0DDA\n+           *\/\n+          for (unsigned int j = i; j > start; j--)\n+            if (info[j - 1].indic_position() != POS_PRE_M) {\n+              info[i].indic_position() = info[j - 1].indic_position();\n+              break;\n+            }\n+        }\n+      } else if (info[i].indic_position() != POS_SMVD) {\n+        last_pos = (indic_position_t) info[i].indic_position();\n+      }\n+    }\n+  }\n+  \/* For post-base consonants let them own anything before them\n+   * since the last consonant or matra. *\/\n+  {\n+    unsigned int last = base;\n+    for (unsigned int i = base + 1; i < end; i++)\n+      if (is_consonant (info[i]))\n+      {\n+        for (unsigned int j = last + 1; j < i; j++)\n+          if (info[j].indic_position() < POS_SMVD)\n+            info[j].indic_position() = info[i].indic_position();\n+        last = i;\n+      } else if (info[i].indic_category() == OT_M)\n+        last = i;\n+  }\n+\n+\n+  {\n+    \/* Use syllable() for sort accounting temporarily. *\/\n+    unsigned int syllable = info[start].syllable();\n+    for (unsigned int i = start; i < end; i++)\n+      info[i].syllable() = i - start;\n+\n+    \/* Sit tight, rock 'n roll! *\/\n+    hb_stable_sort (info + start, end - start, compare_indic_order);\n+    \/* Find base again *\/\n+    base = end;\n+    for (unsigned int i = start; i < end; i++)\n+      if (info[i].indic_position() == POS_BASE_C)\n+      {\n+        base = i;\n+        break;\n+      }\n+    \/* Things are out-of-control for post base positions, they may shuffle\n+     * around like crazy.  In old-spec mode, we move halants around, so in\n+     * that case merge all clusters after base.  Otherwise, check the sort\n+     * order and merge as needed.\n+     * For pre-base stuff, we handle cluster issues in final reordering.\n+     *\n+     * We could use buffer->sort() for this, if there was no special\n+     * reordering of pre-base stuff happening later...\n+     * We don't want to merge_clusters all of that, which buffer->sort()\n+     * would.\n+     *\/\n+    if (indic_plan->is_old_spec || end - start > 127)\n+      buffer->merge_clusters (base, end);\n+    else\n+    {\n+      \/* Note!  syllable() is a one-byte field. *\/\n+      for (unsigned int i = base; i < end; i++)\n+        if (info[i].syllable() != 255)\n+        {\n+          unsigned int max = i;\n+          unsigned int j = start + info[i].syllable();\n+          while (j != i)\n+          {\n+            max = MAX (max, j);\n+            unsigned int next = start + info[j].syllable();\n+            info[j].syllable() = 255; \/* So we don't process j later again. *\/\n+            j = next;\n+          }\n+          if (i != max)\n+            buffer->merge_clusters (i, max + 1);\n+        }\n+    }\n+\n+    \/* Put syllable back in. *\/\n+    for (unsigned int i = start; i < end; i++)\n+      info[i].syllable() = syllable;\n+  }\n+\n+  \/* Setup masks now *\/\n+\n+  {\n+    hb_mask_t mask;\n+\n+    \/* Reph *\/\n+    for (unsigned int i = start; i < end && info[i].indic_position() == POS_RA_TO_BECOME_REPH; i++)\n+      info[i].mask |= indic_plan->mask_array[RPHF];\n+\n+    \/* Pre-base *\/\n+    mask = indic_plan->mask_array[HALF];\n+    if (!indic_plan->is_old_spec &&\n+        indic_plan->config->blwf_mode == BLWF_MODE_PRE_AND_POST)\n+      mask |= indic_plan->mask_array[BLWF];\n+    for (unsigned int i = start; i < base; i++)\n+      info[i].mask  |= mask;\n+    \/* Base *\/\n+    mask = 0;\n+    if (base < end)\n+      info[base].mask |= mask;\n+    \/* Post-base *\/\n+    mask = indic_plan->mask_array[BLWF] | indic_plan->mask_array[ABVF] | indic_plan->mask_array[PSTF];\n+    for (unsigned int i = base + 1; i < end; i++)\n+      info[i].mask  |= mask;\n+  }\n+\n+  if (indic_plan->is_old_spec &&\n+      buffer->props.script == HB_SCRIPT_DEVANAGARI)\n+  {\n+    \/* Old-spec eye-lash Ra needs special handling.  From the\n+     * spec:\n+     *\n+     * \"The feature 'below-base form' is applied to consonants\n+     * having below-base forms and following the base consonant.\n+     * The exception is vattu, which may appear below half forms\n+     * as well as below the base glyph. The feature 'below-base\n+     * form' will be applied to all such occurrences of Ra as well.\"\n+     *\n+     * Test case: U+0924,U+094D,U+0930,U+094d,U+0915\n+     * with Sanskrit 2003 font.\n+     *\n+     * However, note that Ra,Halant,ZWJ is the correct way to\n+     * request eyelash form of Ra, so we wouldbn't inhibit it\n+     * in that sequence.\n+     *\n+     * Test case: U+0924,U+094D,U+0930,U+094d,U+200D,U+0915\n+     *\/\n+    for (unsigned int i = start; i + 1 < base; i++)\n+      if (info[i  ].indic_category() == OT_Ra &&\n+          info[i+1].indic_category() == OT_H  &&\n+          (i + 2 == base ||\n+           info[i+2].indic_category() != OT_ZWJ))\n+      {\n+        info[i  ].mask |= indic_plan->mask_array[BLWF];\n+        info[i+1].mask |= indic_plan->mask_array[BLWF];\n+      }\n+  }\n+\n+  unsigned int pref_len = 2;\n+  if (indic_plan->mask_array[PREF] && base + pref_len < end)\n+  {\n+    \/* Find a Halant,Ra sequence and mark it for pre-base-reordering processing. *\/\n+    for (unsigned int i = base + 1; i + pref_len - 1 < end; i++) {\n+      hb_codepoint_t glyphs[2];\n+      for (unsigned int j = 0; j < pref_len; j++)\n+        glyphs[j] = info[i + j].codepoint;\n+      if (indic_plan->pref.would_substitute (glyphs, pref_len, face))\n+      {\n+        for (unsigned int j = 0; j < pref_len; j++)\n+          info[i++].mask |= indic_plan->mask_array[PREF];\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/* Apply ZWJ\/ZWNJ effects *\/\n+  for (unsigned int i = start + 1; i < end; i++)\n+    if (is_joiner (info[i])) {\n+      bool non_joiner = info[i].indic_category() == OT_ZWNJ;\n+      unsigned int j = i;\n+\n+      do {\n+        j--;\n+\n+        \/* ZWJ\/ZWNJ should disable CJCT.  They do that by simply\n+         * being there, since we don't skip them for the CJCT\n+         * feature (ie. F_MANUAL_ZWJ) *\/\n+\n+        \/* A ZWNJ disables HALF. *\/\n+        if (non_joiner)\n+          info[j].mask &= ~indic_plan->mask_array[HALF];\n+\n+      } while (j > start && !is_consonant (info[j]));\n+    }\n+}\n+\n+static void\n+initial_reordering_standalone_cluster (const hb_ot_shape_plan_t *plan,\n+                                       hb_face_t *face,\n+                                       hb_buffer_t *buffer,\n+                                       unsigned int start, unsigned int end)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+\n+  \/* We treat placeholder\/dotted-circle as if they are consonants, so we\n+   * should just chain.  Only if not in compatibility mode that is... *\/\n+\n+  if (indic_plan->uniscribe_bug_compatible)\n+  {\n+    \/* For dotted-circle, this is what Uniscribe does:\n+     * If dotted-circle is the last glyph, it just does nothing.\n+     * Ie. It doesn't form Reph. *\/\n+    if (buffer->info[end - 1].indic_category() == OT_DOTTEDCIRCLE)\n+      return;\n+  }\n+\n+  initial_reordering_consonant_syllable (plan, face, buffer, start, end);\n+}\n+\n+static void\n+initial_reordering_syllable (const hb_ot_shape_plan_t *plan,\n+                             hb_face_t *face,\n+                             hb_buffer_t *buffer,\n+                             unsigned int start, unsigned int end)\n+{\n+  syllable_type_t syllable_type = (syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n+  switch (syllable_type)\n+  {\n+    case vowel_syllable: \/* We made the vowels look like consonants.  So let's call the consonant logic! *\/\n+    case consonant_syllable:\n+     initial_reordering_consonant_syllable (plan, face, buffer, start, end);\n+     break;\n+\n+    case broken_cluster: \/* We already inserted dotted-circles, so just call the standalone_cluster. *\/\n+    case standalone_cluster:\n+     initial_reordering_standalone_cluster (plan, face, buffer, start, end);\n+     break;\n+\n+    case symbol_cluster:\n+    case non_indic_cluster:\n+      break;\n+  }\n+}\n+\n+static inline void\n+insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer)\n+{\n+  \/* Note: This loop is extra overhead, but should not be measurable.\n+   * TODO Use a buffer scratch flag to remove the loop. *\/\n+  bool has_broken_syllables = false;\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    if ((info[i].syllable() & 0x0F) == broken_cluster)\n+    {\n+      has_broken_syllables = true;\n+      break;\n+    }\n+  if (likely (!has_broken_syllables))\n+    return;\n+\n+\n+  hb_codepoint_t dottedcircle_glyph;\n+  if (!font->get_nominal_glyph (0x25CCu, &dottedcircle_glyph))\n+    return;\n+\n+  hb_glyph_info_t dottedcircle = {0};\n+  dottedcircle.codepoint = 0x25CCu;\n+  set_indic_properties (dottedcircle);\n+  dottedcircle.codepoint = dottedcircle_glyph;\n+\n+  buffer->clear_output ();\n+\n+  buffer->idx = 0;\n+  unsigned int last_syllable = 0;\n+  while (buffer->idx < buffer->len && buffer->successful)\n+  {\n+    unsigned int syllable = buffer->cur().syllable();\n+    syllable_type_t syllable_type = (syllable_type_t) (syllable & 0x0F);\n+    if (unlikely (last_syllable != syllable && syllable_type == broken_cluster))\n+    {\n+      last_syllable = syllable;\n+\n+      hb_glyph_info_t ginfo = dottedcircle;\n+      ginfo.cluster = buffer->cur().cluster;\n+      ginfo.mask = buffer->cur().mask;\n+      ginfo.syllable() = buffer->cur().syllable();\n+      \/* TODO Set glyph_props? *\/\n+\n+      \/* Insert dottedcircle after possible Repha. *\/\n+      while (buffer->idx < buffer->len && buffer->successful &&\n+             last_syllable == buffer->cur().syllable() &&\n+             buffer->cur().indic_category() == OT_Repha)\n+        buffer->next_glyph ();\n+\n+      buffer->output_info (ginfo);\n+    }\n+    else\n+      buffer->next_glyph ();\n+  }\n+  buffer->swap_buffers ();\n+}\n+\n+static void\n+initial_reordering (const hb_ot_shape_plan_t *plan,\n+                    hb_font_t *font,\n+                    hb_buffer_t *buffer)\n+{\n+  update_consonant_positions (plan, font, buffer);\n+  insert_dotted_circles (plan, font, buffer);\n+\n+  foreach_syllable (buffer, start, end)\n+    initial_reordering_syllable (plan, font->face, buffer, start, end);\n+}\n+\n+static void\n+final_reordering_syllable (const hb_ot_shape_plan_t *plan,\n+                           hb_buffer_t *buffer,\n+                           unsigned int start, unsigned int end)\n+{\n+  const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) plan->data;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+\n+  \/* This function relies heavily on halant glyphs.  Lots of ligation\n+   * and possibly multiple substitutions happened prior to this\n+   * phase, and that might have messed up our properties.  Recover\n+   * from a particular case of that where we're fairly sure that a\n+   * class of OT_H is desired but has been lost. *\/\n+  \/* We don't call load_virama_glyph(), since we know it's already\n+   * loaded. *\/\n+  hb_codepoint_t virama_glyph = indic_plan->virama_glyph.get_relaxed ();\n+  if (virama_glyph)\n+  {\n+    for (unsigned int i = start; i < end; i++)\n+      if (info[i].codepoint == virama_glyph &&\n+          _hb_glyph_info_ligated (&info[i]) &&\n+          _hb_glyph_info_multiplied (&info[i]))\n+      {\n+        \/* This will make sure that this glyph passes is_halant() test. *\/\n+        info[i].indic_category() = OT_H;\n+        _hb_glyph_info_clear_ligated_and_multiplied (&info[i]);\n+      }\n+  }\n+\n+\n+  \/* 4. Final reordering:\n+   *\n+   * After the localized forms and basic shaping forms GSUB features have been\n+   * applied (see below), the shaping engine performs some final glyph\n+   * reordering before applying all the remaining font features to the entire\n+   * syllable.\n+   *\/\n+\n+  bool try_pref = !!indic_plan->mask_array[PREF];\n+\n+  \/* Find base again *\/\n+  unsigned int base;\n+  for (base = start; base < end; base++)\n+    if (info[base].indic_position() >= POS_BASE_C)\n+    {\n+      if (try_pref && base + 1 < end)\n+      {\n+        for (unsigned int i = base + 1; i < end; i++)\n+          if ((info[i].mask & indic_plan->mask_array[PREF]) != 0)\n+          {\n+            if (!(_hb_glyph_info_substituted (&info[i]) &&\n+                  _hb_glyph_info_ligated_and_didnt_multiply (&info[i])))\n+            {\n+              \/* Ok, this was a 'pref' candidate but didn't form any.\n+               * Base is around here... *\/\n+              base = i;\n+              while (base < end && is_halant (info[base]))\n+                base++;\n+              info[base].indic_position() = POS_BASE_C;\n+\n+              try_pref = false;\n+            }\n+            break;\n+          }\n+      }\n+      \/* For Malayalam, skip over unformed below- (but NOT post-) forms. *\/\n+      if (buffer->props.script == HB_SCRIPT_MALAYALAM)\n+      {\n+        for (unsigned int i = base + 1; i < end; i++)\n+        {\n+          while (i < end && is_joiner (info[i]))\n+            i++;\n+          if (i == end || !is_halant (info[i]))\n+            break;\n+          i++; \/* Skip halant. *\/\n+          while (i < end && is_joiner (info[i]))\n+            i++;\n+          if (i < end && is_consonant (info[i]) && info[i].indic_position() == POS_BELOW_C)\n+          {\n+            base = i;\n+            info[base].indic_position() = POS_BASE_C;\n+          }\n+        }\n+      }\n+\n+      if (start < base && info[base].indic_position() > POS_BASE_C)\n+        base--;\n+      break;\n+    }\n+  if (base == end && start < base &&\n+      is_one_of (info[base - 1], FLAG (OT_ZWJ)))\n+    base--;\n+  if (base < end)\n+    while (start < base &&\n+           is_one_of (info[base], (FLAG (OT_N) | FLAG (OT_H))))\n+      base--;\n+\n+\n+  \/*   o Reorder matras:\n+   *\n+   *     If a pre-base matra character had been reordered before applying basic\n+   *     features, the glyph can be moved closer to the main consonant based on\n+   *     whether half-forms had been formed. Actual position for the matra is\n+   *     defined as “after last standalone halant glyph, after initial matra\n+   *     position and before the main consonant”. If ZWJ or ZWNJ follow this\n+   *     halant, position is moved after it.\n+   *\n+   * IMPLEMENTATION NOTES:\n+   *\n+   * It looks like the last sentence is wrong.  Testing, with Windows 7 Uniscribe\n+   * and Devanagari shows that the behavior is best described as:\n+   *\n+   * \"If ZWJ follows this halant, matra is NOT repositioned after this halant.\n+   *  If ZWNJ follows this halant, position is moved after it.\"\n+   *\n+   * Test case, with Adobe Devanagari or Nirmala UI:\n+   *\n+   *   U+091F,U+094D,U+200C,U+092F,U+093F\n+   *   (Matra moves to the middle, after ZWNJ.)\n+   *\n+   *   U+091F,U+094D,U+200D,U+092F,U+093F\n+   *   (Matra does NOT move, stays to the left.)\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1070\n+   *\/\n+\n+  if (start + 1 < end && start < base) \/* Otherwise there can't be any pre-base matra characters. *\/\n+  {\n+    \/* If we lost track of base, alas, position before last thingy. *\/\n+    unsigned int new_pos = base == end ? base - 2 : base - 1;\n+\n+    \/* Malayalam \/ Tamil do not have \"half\" forms or explicit virama forms.\n+     * The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n+     * We want to position matra after them.\n+     *\/\n+    if (buffer->props.script != HB_SCRIPT_MALAYALAM && buffer->props.script != HB_SCRIPT_TAMIL)\n+    {\n+    search:\n+      while (new_pos > start &&\n+             !(is_one_of (info[new_pos], (FLAG (OT_M) | FLAG (OT_H)))))\n+        new_pos--;\n+\n+      \/* If we found no Halant we are done.\n+       * Otherwise only proceed if the Halant does\n+       * not belong to the Matra itself! *\/\n+      if (is_halant (info[new_pos]) &&\n+          info[new_pos].indic_position() != POS_PRE_M)\n+      {\n+#if 0 \/\/ See comment above\n+        \/* -> If ZWJ or ZWNJ follow this halant, position is moved after it. *\/\n+        if (new_pos + 1 < end && is_joiner (info[new_pos + 1]))\n+          new_pos++;\n+#endif\n+        if (new_pos + 1 < end)\n+        {\n+          \/* -> If ZWJ follows this halant, matra is NOT repositioned after this halant. *\/\n+          if (info[new_pos + 1].indic_category() == OT_ZWJ)\n+          {\n+            \/* Keep searching. *\/\n+            if (new_pos > start)\n+            {\n+              new_pos--;\n+              goto search;\n+            }\n+          }\n+          \/* -> If ZWNJ follows this halant, position is moved after it. *\/\n+          if (info[new_pos + 1].indic_category() == OT_ZWNJ)\n+            new_pos++;\n+        }\n+      }\n+      else\n+        new_pos = start; \/* No move. *\/\n+    }\n+\n+    if (start < new_pos && info[new_pos].indic_position () != POS_PRE_M)\n+    {\n+      \/* Now go see if there's actually any matras... *\/\n+      for (unsigned int i = new_pos; i > start; i--)\n+        if (info[i - 1].indic_position () == POS_PRE_M)\n+        {\n+          unsigned int old_pos = i - 1;\n+          if (old_pos < base && base <= new_pos) \/* Shouldn't actually happen. *\/\n+            base--;\n+\n+          hb_glyph_info_t tmp = info[old_pos];\n+          memmove (&info[old_pos], &info[old_pos + 1], (new_pos - old_pos) * sizeof (info[0]));\n+          info[new_pos] = tmp;\n+\n+          \/* Note: this merge_clusters() is intentionally *after* the reordering.\n+           * Indic matra reordering is special and tricky... *\/\n+          buffer->merge_clusters (new_pos, MIN (end, base + 1));\n+\n+          new_pos--;\n+        }\n+    } else {\n+      for (unsigned int i = start; i < base; i++)\n+        if (info[i].indic_position () == POS_PRE_M) {\n+          buffer->merge_clusters (i, MIN (end, base + 1));\n+          break;\n+        }\n+    }\n+  }\n+\n+\n+  \/*   o Reorder reph:\n+   *\n+   *     Reph’s original position is always at the beginning of the syllable,\n+   *     (i.e. it is not reordered at the character reordering stage). However,\n+   *     it will be reordered according to the basic-forms shaping results.\n+   *     Possible positions for reph, depending on the script, are; after main,\n+   *     before post-base consonant forms, and after post-base consonant forms.\n+   *\/\n+\n+  \/* Two cases:\n+   *\n+   * - If repha is encoded as a sequence of characters (Ra,H or Ra,H,ZWJ), then\n+   *   we should only move it if the sequence ligated to the repha form.\n+   *\n+   * - If repha is encoded separately and in the logical position, we should only\n+   *   move it if it did NOT ligate.  If it ligated, it's probably the font trying\n+   *   to make it work without the reordering.\n+   *\/\n+  if (start + 1 < end &&\n+      info[start].indic_position() == POS_RA_TO_BECOME_REPH &&\n+      ((info[start].indic_category() == OT_Repha) ^\n+       _hb_glyph_info_ligated_and_didnt_multiply (&info[start])))\n+  {\n+    unsigned int new_reph_pos;\n+    reph_position_t reph_pos = indic_plan->config->reph_pos;\n+\n+    \/*       1. If reph should be positioned after post-base consonant forms,\n+     *          proceed to step 5.\n+     *\/\n+    if (reph_pos == REPH_POS_AFTER_POST)\n+    {\n+      goto reph_step_5;\n+    }\n+\n+    \/*       2. If the reph repositioning class is not after post-base: target\n+     *          position is after the first explicit halant glyph between the\n+     *          first post-reph consonant and last main consonant. If ZWJ or ZWNJ\n+     *          are following this halant, position is moved after it. If such\n+     *          position is found, this is the target position. Otherwise,\n+     *          proceed to the next step.\n+     *\n+     *          Note: in old-implementation fonts, where classifications were\n+     *          fixed in shaping engine, there was no case where reph position\n+     *          will be found on this step.\n+     *\/\n+    {\n+      new_reph_pos = start + 1;\n+      while (new_reph_pos < base && !is_halant (info[new_reph_pos]))\n+        new_reph_pos++;\n+\n+      if (new_reph_pos < base && is_halant (info[new_reph_pos]))\n+      {\n+        \/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. *\/\n+        if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))\n+          new_reph_pos++;\n+        goto reph_move;\n+      }\n+    }\n+\n+    \/*       3. If reph should be repositioned after the main consonant: find the\n+     *          first consonant not ligated with main, or find the first\n+     *          consonant that is not a potential pre-base-reordering Ra.\n+     *\/\n+    if (reph_pos == REPH_POS_AFTER_MAIN)\n+    {\n+      new_reph_pos = base;\n+      while (new_reph_pos + 1 < end && info[new_reph_pos + 1].indic_position() <= POS_AFTER_MAIN)\n+        new_reph_pos++;\n+      if (new_reph_pos < end)\n+        goto reph_move;\n+    }\n+\n+    \/*       4. If reph should be positioned before post-base consonant, find\n+     *          first post-base classified consonant not ligated with main. If no\n+     *          consonant is found, the target position should be before the\n+     *          first matra, syllable modifier sign or vedic sign.\n+     *\/\n+    \/* This is our take on what step 4 is trying to say (and failing, BADLY). *\/\n+    if (reph_pos == REPH_POS_AFTER_SUB)\n+    {\n+      new_reph_pos = base;\n+      while (new_reph_pos + 1 < end &&\n+             !( FLAG_UNSAFE (info[new_reph_pos + 1].indic_position()) & (FLAG (POS_POST_C) | FLAG (POS_AFTER_POST) | FLAG (POS_SMVD))))\n+        new_reph_pos++;\n+      if (new_reph_pos < end)\n+        goto reph_move;\n+    }\n+\n+    \/*       5. If no consonant is found in steps 3 or 4, move reph to a position\n+     *          immediately before the first post-base matra, syllable modifier\n+     *          sign or vedic sign that has a reordering class after the intended\n+     *          reph position. For example, if the reordering position for reph\n+     *          is post-main, it will skip above-base matras that also have a\n+     *          post-main position.\n+     *\/\n+    reph_step_5:\n+    {\n+      \/* Copied from step 2. *\/\n+      new_reph_pos = start + 1;\n+      while (new_reph_pos < base && !is_halant (info[new_reph_pos]))\n+        new_reph_pos++;\n+\n+      if (new_reph_pos < base && is_halant (info[new_reph_pos]))\n+      {\n+        \/* ->If ZWJ or ZWNJ are following this halant, position is moved after it. *\/\n+        if (new_reph_pos + 1 < base && is_joiner (info[new_reph_pos + 1]))\n+          new_reph_pos++;\n+        goto reph_move;\n+      }\n+    }\n+\n+    \/*       6. Otherwise, reorder reph to the end of the syllable.\n+     *\/\n+    {\n+      new_reph_pos = end - 1;\n+      while (new_reph_pos > start && info[new_reph_pos].indic_position() == POS_SMVD)\n+        new_reph_pos--;\n+\n+      \/*\n+       * If the Reph is to be ending up after a Matra,Halant sequence,\n+       * position it before that Halant so it can interact with the Matra.\n+       * However, if it's a plain Consonant,Halant we shouldn't do that.\n+       * Uniscribe doesn't do this.\n+       * TEST: U+0930,U+094D,U+0915,U+094B,U+094D\n+       *\/\n+      if (!indic_plan->uniscribe_bug_compatible &&\n+          unlikely (is_halant (info[new_reph_pos]))) {\n+        for (unsigned int i = base + 1; i < new_reph_pos; i++)\n+          if (info[i].indic_category() == OT_M) {\n+            \/* Ok, got it. *\/\n+            new_reph_pos--;\n+          }\n+      }\n+      goto reph_move;\n+    }\n+\n+    reph_move:\n+    {\n+      \/* Move *\/\n+      buffer->merge_clusters (start, new_reph_pos + 1);\n+      hb_glyph_info_t reph = info[start];\n+      memmove (&info[start], &info[start + 1], (new_reph_pos - start) * sizeof (info[0]));\n+      info[new_reph_pos] = reph;\n+\n+      if (start < base && base <= new_reph_pos)\n+        base--;\n+    }\n+  }\n+\n+\n+  \/*   o Reorder pre-base-reordering consonants:\n+   *\n+   *     If a pre-base-reordering consonant is found, reorder it according to\n+   *     the following rules:\n+   *\/\n+\n+  if (try_pref && base + 1 < end) \/* Otherwise there can't be any pre-base-reordering Ra. *\/\n+  {\n+    for (unsigned int i = base + 1; i < end; i++)\n+      if ((info[i].mask & indic_plan->mask_array[PREF]) != 0)\n+      {\n+        \/*       1. Only reorder a glyph produced by substitution during application\n+         *          of the <pref> feature. (Note that a font may shape a Ra consonant with\n+         *          the feature generally but block it in certain contexts.)\n+         *\/\n+        \/* Note: We just check that something got substituted.  We don't check that\n+         * the <pref> feature actually did it...\n+         *\n+         * Reorder pref only if it ligated. *\/\n+        if (_hb_glyph_info_ligated_and_didnt_multiply (&info[i]))\n+        {\n+          \/*\n+           *       2. Try to find a target position the same way as for pre-base matra.\n+           *          If it is found, reorder pre-base consonant glyph.\n+           *\n+           *       3. If position is not found, reorder immediately before main\n+           *          consonant.\n+           *\/\n+\n+          unsigned int new_pos = base;\n+          \/* Malayalam \/ Tamil do not have \"half\" forms or explicit virama forms.\n+           * The glyphs formed by 'half' are Chillus or ligated explicit viramas.\n+           * We want to position matra after them.\n+           *\/\n+          if (buffer->props.script != HB_SCRIPT_MALAYALAM && buffer->props.script != HB_SCRIPT_TAMIL)\n+          {\n+            while (new_pos > start &&\n+                   !(is_one_of (info[new_pos - 1], FLAG(OT_M) | FLAG (OT_H))))\n+              new_pos--;\n+          }\n+\n+          if (new_pos > start && is_halant (info[new_pos - 1]))\n+          {\n+            \/* -> If ZWJ or ZWNJ follow this halant, position is moved after it. *\/\n+            if (new_pos < end && is_joiner (info[new_pos]))\n+              new_pos++;\n+          }\n+\n+          {\n+            unsigned int old_pos = i;\n+\n+            buffer->merge_clusters (new_pos, old_pos + 1);\n+            hb_glyph_info_t tmp = info[old_pos];\n+            memmove (&info[new_pos + 1], &info[new_pos], (old_pos - new_pos) * sizeof (info[0]));\n+            info[new_pos] = tmp;\n+\n+            if (new_pos <= base && base < old_pos)\n+              base++;\n+          }\n+        }\n+\n+        break;\n+      }\n+  }\n+\n+\n+  \/* Apply 'init' to the Left Matra if it's a word start. *\/\n+  if (info[start].indic_position () == POS_PRE_M)\n+  {\n+    if (!start ||\n+        !(FLAG_UNSAFE (_hb_glyph_info_get_general_category (&info[start - 1])) &\n+         FLAG_RANGE (HB_UNICODE_GENERAL_CATEGORY_FORMAT, HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))\n+      info[start].mask |= indic_plan->mask_array[INIT];\n+    else\n+      buffer->unsafe_to_break (start - 1, start + 1);\n+  }\n+\n+\n+  \/*\n+   * Finish off the clusters and go home!\n+   *\/\n+  if (indic_plan->uniscribe_bug_compatible)\n+  {\n+    switch ((hb_tag_t) plan->props.script)\n+    {\n+      case HB_SCRIPT_TAMIL:\n+      case HB_SCRIPT_SINHALA:\n+        break;\n+\n+      default:\n+        \/* Uniscribe merges the entire syllable into a single cluster... Except for Tamil & Sinhala.\n+         * This means, half forms are submerged into the main consonant's cluster.\n+         * This is unnecessary, and makes cursor positioning harder, but that's what\n+         * Uniscribe does. *\/\n+        buffer->merge_clusters (start, end);\n+        break;\n+    }\n+  }\n+}\n+\n+\n+static void\n+final_reordering (const hb_ot_shape_plan_t *plan,\n+                  hb_font_t *font HB_UNUSED,\n+                  hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  if (unlikely (!count)) return;\n+\n+  foreach_syllable (buffer, start, end)\n+    final_reordering_syllable (plan, buffer, start, end);\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_category);\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, indic_position);\n+}\n+\n+\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    info[i].syllable() = 0;\n+}\n+\n+\n+static void\n+preprocess_text_indic (const hb_ot_shape_plan_t *plan,\n+                       hb_buffer_t              *buffer,\n+                       hb_font_t                *font)\n+{\n+  _hb_preprocess_text_vowel_constraints (plan, buffer, font);\n+}\n+\n+static bool\n+decompose_indic (const hb_ot_shape_normalize_context_t *c,\n+                 hb_codepoint_t  ab,\n+                 hb_codepoint_t *a,\n+                 hb_codepoint_t *b)\n+{\n+  switch (ab)\n+  {\n+    \/* Don't decompose these. *\/\n+    case 0x0931u  : return false; \/* DEVANAGARI LETTER RRA *\/\n+    \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/779\n+    case 0x09DCu  : return false; \/* BENGALI LETTER RRA *\/\n+    case 0x09DDu  : return false; \/* BENGALI LETTER RHA *\/\n+    case 0x0B94u  : return false; \/* TAMIL LETTER AU *\/\n+\n+\n+    \/*\n+     * Decompose split matras that don't have Unicode decompositions.\n+     *\/\n+\n+#if 0\n+    \/* Gujarati *\/\n+    \/* This one has no decomposition in Unicode, but needs no decomposition either. *\/\n+    \/* case 0x0AC9u  : return false; *\/\n+\n+    \/* Oriya *\/\n+    case 0x0B57u  : *a = no decomp, -> RIGHT; return true;\n+#endif\n+  }\n+\n+  if ((ab == 0x0DDAu || hb_in_range<hb_codepoint_t> (ab, 0x0DDCu, 0x0DDEu)))\n+  {\n+    \/*\n+     * Sinhala split matras...  Let the fun begin.\n+     *\n+     * These four characters have Unicode decompositions.  However, Uniscribe\n+     * decomposes them \"Khmer-style\", that is, it uses the character itself to\n+     * get the second half.  The first half of all four decompositions is always\n+     * U+0DD9.\n+     *\n+     * Now, there are buggy fonts, namely, the widely used lklug.ttf, that are\n+     * broken with Uniscribe.  But we need to support them.  As such, we only\n+     * do the Uniscribe-style decomposition if the character is transformed into\n+     * its \"sec.half\" form by the 'pstf' feature.  Otherwise, we fall back to\n+     * Unicode decomposition.\n+     *\n+     * Note that we can't unconditionally use Unicode decomposition.  That would\n+     * break some other fonts, that are designed to work with Uniscribe, and\n+     * don't have positioning features for the Unicode-style decomposition.\n+     *\n+     * Argh...\n+     *\n+     * The Uniscribe behavior is now documented in the newly published Sinhala\n+     * spec in 2012:\n+     *\n+     *   https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/sinhala#shaping\n+     *\/\n+\n+    const indic_shape_plan_t *indic_plan = (const indic_shape_plan_t *) c->plan->data;\n+\n+    hb_codepoint_t glyph;\n+\n+    if (hb_options ().uniscribe_bug_compatible ||\n+        (c->font->get_nominal_glyph (ab, &glyph) &&\n+         indic_plan->pstf.would_substitute (&glyph, 1, c->font->face)))\n+    {\n+      \/* Ok, safe to use Uniscribe-style decomposition. *\/\n+      *a = 0x0DD9u;\n+      *b = ab;\n+      return true;\n+    }\n+  }\n+\n+  return (bool) c->unicode->decompose (ab, a, b);\n+}\n+\n+static bool\n+compose_indic (const hb_ot_shape_normalize_context_t *c,\n+               hb_codepoint_t  a,\n+               hb_codepoint_t  b,\n+               hb_codepoint_t *ab)\n+{\n+  \/* Avoid recomposing split matras. *\/\n+  if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c->unicode->general_category (a)))\n+    return false;\n+\n+  \/* Composition-exclusion exceptions that we want to recompose. *\/\n+  if (a == 0x09AFu && b == 0x09BCu) { *ab = 0x09DFu; return true; }\n+\n+  return (bool) c->unicode->compose (a, b, ab);\n+}\n+\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_indic =\n+{\n+  collect_features_indic,\n+  override_features_indic,\n+  data_create_indic,\n+  data_destroy_indic,\n+  preprocess_text_indic,\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n+  decompose_indic,\n+  compose_indic,\n+  setup_masks_indic,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  false, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-indic.cc","additions":1637,"deletions":0,"binary":false,"changes":1637,"status":"added"},{"patch":"@@ -0,0 +1,399 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_INDIC_HH\n+#define HB_OT_SHAPE_COMPLEX_INDIC_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shape-complex.hh\"\n+\n+\n+\/* buffer var allocations *\/\n+#define indic_category() complex_var_u8_0() \/* indic_category_t *\/\n+#define indic_position() complex_var_u8_1() \/* indic_position_t *\/\n+\n+\n+#define INDIC_TABLE_ELEMENT_TYPE uint16_t\n+\n+\/* Cateories used in the OpenType spec:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/devanagari\n+ *\/\n+\/* Note: This enum is duplicated in the -machine.rl source file.\n+ * Not sure how to avoid duplication. *\/\n+enum indic_category_t {\n+  OT_X = 0,\n+  OT_C = 1,\n+  OT_V = 2,\n+  OT_N = 3,\n+  OT_H = 4,\n+  OT_ZWNJ = 5,\n+  OT_ZWJ = 6,\n+  OT_M = 7,\n+  OT_SM = 8,\n+  \/* OT_VD = 9, UNUSED; we use OT_A instead. *\/\n+  OT_A = 10,\n+  OT_PLACEHOLDER = 11,\n+  OT_DOTTEDCIRCLE = 12,\n+  OT_RS = 13, \/* Register Shifter, used in Khmer OT spec. *\/\n+  OT_Coeng = 14, \/* Khmer-style Virama. *\/\n+  OT_Repha = 15, \/* Atomically-encoded logical or visual repha. *\/\n+  OT_Ra = 16,\n+  OT_CM = 17,  \/* Consonant-Medial; Unused by Indic shaper. *\/\n+  OT_Symbol = 18, \/* Avagraha, etc that take marks (SM,A,VD). *\/\n+  OT_CS = 19\n+};\n+\n+\/* Note:\n+ *\n+ * We treat Vowels and placeholders as if they were consonants.  This is safe because Vowels\n+ * cannot happen in a consonant syllable.  The plus side however is, we can call the\n+ * consonant syllable logic from the vowel syllable function and get it all right! *\/\n+#define CONSONANT_FLAGS (FLAG (OT_C) | FLAG (OT_CS) | FLAG (OT_Ra) | FLAG (OT_V) | FLAG (OT_PLACEHOLDER) | FLAG (OT_DOTTEDCIRCLE))\n+#define JOINER_FLAGS (FLAG (OT_ZWJ) | FLAG (OT_ZWNJ))\n+\n+\n+\/* Visual positions in a syllable from left to right. *\/\n+enum indic_position_t {\n+  POS_START = 0,\n+\n+  POS_RA_TO_BECOME_REPH = 1,\n+  POS_PRE_M = 2,\n+  POS_PRE_C = 3,\n+\n+  POS_BASE_C = 4,\n+  POS_AFTER_MAIN = 5,\n+\n+  POS_ABOVE_C = 6,\n+\n+  POS_BEFORE_SUB = 7,\n+  POS_BELOW_C = 8,\n+  POS_AFTER_SUB = 9,\n+\n+  POS_BEFORE_POST = 10,\n+  POS_POST_C = 11,\n+  POS_AFTER_POST = 12,\n+\n+  POS_FINAL_C = 13,\n+  POS_SMVD = 14,\n+\n+  POS_END = 15\n+};\n+\n+\/* Categories used in IndicSyllabicCategory.txt from UCD. *\/\n+enum indic_syllabic_category_t {\n+  INDIC_SYLLABIC_CATEGORY_OTHER                         = OT_X,\n+\n+  INDIC_SYLLABIC_CATEGORY_AVAGRAHA                      = OT_Symbol,\n+  INDIC_SYLLABIC_CATEGORY_BINDU                         = OT_SM,\n+  INDIC_SYLLABIC_CATEGORY_BRAHMI_JOINING_NUMBER         = OT_PLACEHOLDER, \/* Don't care. *\/\n+  INDIC_SYLLABIC_CATEGORY_CANTILLATION_MARK             = OT_A,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT                     = OT_C,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_DEAD                = OT_C,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_FINAL               = OT_CM,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_HEAD_LETTER         = OT_C,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_KILLER              = OT_M, \/* U+17CD only. *\/\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL              = OT_CM,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_PLACEHOLDER         = OT_PLACEHOLDER,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_PRECEDING_REPHA     = OT_Repha,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_PREFIXED            = OT_X, \/* Don't care. *\/\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_SUBJOINED           = OT_CM,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA    = OT_CM,\n+  INDIC_SYLLABIC_CATEGORY_CONSONANT_WITH_STACKER        = OT_CS,\n+  INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK               = OT_SM, \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/552 *\/\n+  INDIC_SYLLABIC_CATEGORY_INVISIBLE_STACKER             = OT_Coeng,\n+  INDIC_SYLLABIC_CATEGORY_JOINER                        = OT_ZWJ,\n+  INDIC_SYLLABIC_CATEGORY_MODIFYING_LETTER              = OT_X,\n+  INDIC_SYLLABIC_CATEGORY_NON_JOINER                    = OT_ZWNJ,\n+  INDIC_SYLLABIC_CATEGORY_NUKTA                         = OT_N,\n+  INDIC_SYLLABIC_CATEGORY_NUMBER                        = OT_PLACEHOLDER,\n+  INDIC_SYLLABIC_CATEGORY_NUMBER_JOINER                 = OT_PLACEHOLDER, \/* Don't care. *\/\n+  INDIC_SYLLABIC_CATEGORY_PURE_KILLER                   = OT_M, \/* Is like a vowel matra. *\/\n+  INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER              = OT_RS,\n+  INDIC_SYLLABIC_CATEGORY_SYLLABLE_MODIFIER             = OT_SM,\n+  INDIC_SYLLABIC_CATEGORY_TONE_LETTER                   = OT_X,\n+  INDIC_SYLLABIC_CATEGORY_TONE_MARK                     = OT_N,\n+  INDIC_SYLLABIC_CATEGORY_VIRAMA                        = OT_H,\n+  INDIC_SYLLABIC_CATEGORY_VISARGA                       = OT_SM,\n+  INDIC_SYLLABIC_CATEGORY_VOWEL                         = OT_V,\n+  INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT               = OT_M,\n+  INDIC_SYLLABIC_CATEGORY_VOWEL_INDEPENDENT             = OT_V\n+};\n+\n+\/* Categories used in IndicSMatraCategory.txt from UCD *\/\n+enum indic_matra_category_t {\n+  INDIC_MATRA_CATEGORY_NOT_APPLICABLE                   = POS_END,\n+\n+  INDIC_MATRA_CATEGORY_LEFT                             = POS_PRE_C,\n+  INDIC_MATRA_CATEGORY_TOP                              = POS_ABOVE_C,\n+  INDIC_MATRA_CATEGORY_BOTTOM                           = POS_BELOW_C,\n+  INDIC_MATRA_CATEGORY_RIGHT                            = POS_POST_C,\n+\n+  \/* These should resolve to the position of the last part of the split sequence. *\/\n+  INDIC_MATRA_CATEGORY_BOTTOM_AND_RIGHT                 = INDIC_MATRA_CATEGORY_RIGHT,\n+  INDIC_MATRA_CATEGORY_LEFT_AND_RIGHT                   = INDIC_MATRA_CATEGORY_RIGHT,\n+  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM                   = INDIC_MATRA_CATEGORY_BOTTOM,\n+  INDIC_MATRA_CATEGORY_TOP_AND_BOTTOM_AND_RIGHT         = INDIC_MATRA_CATEGORY_RIGHT,\n+  INDIC_MATRA_CATEGORY_TOP_AND_LEFT                     = INDIC_MATRA_CATEGORY_TOP,\n+  INDIC_MATRA_CATEGORY_TOP_AND_LEFT_AND_RIGHT           = INDIC_MATRA_CATEGORY_RIGHT,\n+  INDIC_MATRA_CATEGORY_TOP_AND_RIGHT                    = INDIC_MATRA_CATEGORY_RIGHT,\n+\n+  INDIC_MATRA_CATEGORY_OVERSTRUCK                       = POS_AFTER_MAIN,\n+  INDIC_MATRA_CATEGORY_VISUAL_ORDER_LEFT                = POS_PRE_M\n+};\n+\n+#define INDIC_COMBINE_CATEGORIES(S,M) \\\n+  ( \\\n+    ASSERT_STATIC_EXPR_ZERO (S < 255 && M < 255) + \\\n+    ( S | \\\n+     ( \\\n+      ( \\\n+       S == INDIC_SYLLABIC_CATEGORY_CONSONANT_MEDIAL || \\\n+       S == INDIC_SYLLABIC_CATEGORY_GEMINATION_MARK || \\\n+       S == INDIC_SYLLABIC_CATEGORY_REGISTER_SHIFTER || \\\n+       S == INDIC_SYLLABIC_CATEGORY_CONSONANT_SUCCEEDING_REPHA || \\\n+       S == INDIC_SYLLABIC_CATEGORY_VIRAMA || \\\n+       S == INDIC_SYLLABIC_CATEGORY_VOWEL_DEPENDENT || \\\n+       false \\\n+       ? M : INDIC_MATRA_CATEGORY_NOT_APPLICABLE \\\n+      ) << 8 \\\n+     ) \\\n+    ) \\\n+   )\n+\n+HB_INTERNAL INDIC_TABLE_ELEMENT_TYPE\n+hb_indic_get_categories (hb_codepoint_t u);\n+\n+\n+static inline bool\n+is_one_of (const hb_glyph_info_t &info, unsigned int flags)\n+{\n+  \/* If it ligated, all bets are off. *\/\n+  if (_hb_glyph_info_ligated (&info)) return false;\n+  return !!(FLAG_UNSAFE (info.indic_category()) & flags);\n+}\n+\n+static inline bool\n+is_joiner (const hb_glyph_info_t &info)\n+{\n+  return is_one_of (info, JOINER_FLAGS);\n+}\n+\n+static inline bool\n+is_consonant (const hb_glyph_info_t &info)\n+{\n+  return is_one_of (info, CONSONANT_FLAGS);\n+}\n+\n+static inline bool\n+is_halant (const hb_glyph_info_t &info)\n+{\n+  return is_one_of (info, FLAG (OT_H));\n+}\n+\n+#define IN_HALF_BLOCK(u, Base) (((u) & ~0x7Fu) == (Base))\n+\n+#define IS_DEVA(u) (IN_HALF_BLOCK (u, 0x0900u))\n+#define IS_BENG(u) (IN_HALF_BLOCK (u, 0x0980u))\n+#define IS_GURU(u) (IN_HALF_BLOCK (u, 0x0A00u))\n+#define IS_GUJR(u) (IN_HALF_BLOCK (u, 0x0A80u))\n+#define IS_ORYA(u) (IN_HALF_BLOCK (u, 0x0B00u))\n+#define IS_TAML(u) (IN_HALF_BLOCK (u, 0x0B80u))\n+#define IS_TELU(u) (IN_HALF_BLOCK (u, 0x0C00u))\n+#define IS_KNDA(u) (IN_HALF_BLOCK (u, 0x0C80u))\n+#define IS_MLYM(u) (IN_HALF_BLOCK (u, 0x0D00u))\n+#define IS_SINH(u) (IN_HALF_BLOCK (u, 0x0D80u))\n+\n+\n+#define MATRA_POS_LEFT(u)       POS_PRE_M\n+#define MATRA_POS_RIGHT(u)      ( \\\n+                                  IS_DEVA(u) ? POS_AFTER_SUB  : \\\n+                                  IS_BENG(u) ? POS_AFTER_POST : \\\n+                                  IS_GURU(u) ? POS_AFTER_POST : \\\n+                                  IS_GUJR(u) ? POS_AFTER_POST : \\\n+                                  IS_ORYA(u) ? POS_AFTER_POST : \\\n+                                  IS_TAML(u) ? POS_AFTER_POST : \\\n+                                  IS_TELU(u) ? (u <= 0x0C42u ? POS_BEFORE_SUB : POS_AFTER_SUB) : \\\n+                                  IS_KNDA(u) ? (u < 0x0CC3u || u > 0xCD6u ? POS_BEFORE_SUB : POS_AFTER_SUB) : \\\n+                                  IS_MLYM(u) ? POS_AFTER_POST : \\\n+                                  IS_SINH(u) ? POS_AFTER_SUB  : \\\n+                                  \/*default*\/  POS_AFTER_SUB    \\\n+                                )\n+#define MATRA_POS_TOP(u)        ( \/* BENG and MLYM don't have top matras. *\/ \\\n+                                  IS_DEVA(u) ? POS_AFTER_SUB  : \\\n+                                  IS_GURU(u) ? POS_AFTER_POST : \/* Deviate from spec *\/ \\\n+                                  IS_GUJR(u) ? POS_AFTER_SUB  : \\\n+                                  IS_ORYA(u) ? POS_AFTER_MAIN : \\\n+                                  IS_TAML(u) ? POS_AFTER_SUB  : \\\n+                                  IS_TELU(u) ? POS_BEFORE_SUB : \\\n+                                  IS_KNDA(u) ? POS_BEFORE_SUB : \\\n+                                  IS_SINH(u) ? POS_AFTER_SUB  : \\\n+                                  \/*default*\/  POS_AFTER_SUB    \\\n+                                )\n+#define MATRA_POS_BOTTOM(u)     ( \\\n+                                  IS_DEVA(u) ? POS_AFTER_SUB  : \\\n+                                  IS_BENG(u) ? POS_AFTER_SUB  : \\\n+                                  IS_GURU(u) ? POS_AFTER_POST : \\\n+                                  IS_GUJR(u) ? POS_AFTER_POST : \\\n+                                  IS_ORYA(u) ? POS_AFTER_SUB  : \\\n+                                  IS_TAML(u) ? POS_AFTER_POST : \\\n+                                  IS_TELU(u) ? POS_BEFORE_SUB : \\\n+                                  IS_KNDA(u) ? POS_BEFORE_SUB : \\\n+                                  IS_MLYM(u) ? POS_AFTER_POST : \\\n+                                  IS_SINH(u) ? POS_AFTER_SUB  : \\\n+                                  \/*default*\/  POS_AFTER_SUB    \\\n+                                )\n+\n+static inline indic_position_t\n+matra_position_indic (hb_codepoint_t u, indic_position_t side)\n+{\n+  switch ((int) side)\n+  {\n+    case POS_PRE_C:     return MATRA_POS_LEFT (u);\n+    case POS_POST_C:    return MATRA_POS_RIGHT (u);\n+    case POS_ABOVE_C:   return MATRA_POS_TOP (u);\n+    case POS_BELOW_C:   return MATRA_POS_BOTTOM (u);\n+  };\n+  return side;\n+}\n+\n+\/* XXX\n+ * This is a hack for now.  We should move this data into the main Indic table.\n+ * Or completely remove it and just check in the tables.\n+ *\/\n+static const hb_codepoint_t ra_chars[] = {\n+  0x0930u, \/* Devanagari *\/\n+  0x09B0u, \/* Bengali *\/\n+  0x09F0u, \/* Bengali *\/\n+  0x0A30u, \/* Gurmukhi *\/       \/* No Reph *\/\n+  0x0AB0u, \/* Gujarati *\/\n+  0x0B30u, \/* Oriya *\/\n+  0x0BB0u, \/* Tamil *\/          \/* No Reph *\/\n+  0x0C30u, \/* Telugu *\/         \/* Reph formed only with ZWJ *\/\n+  0x0CB0u, \/* Kannada *\/\n+  0x0D30u, \/* Malayalam *\/      \/* No Reph, Logical Repha *\/\n+\n+  0x0DBBu, \/* Sinhala *\/        \/* Reph formed only with ZWJ *\/\n+\n+  0x179Au, \/* Khmer *\/\n+};\n+\n+static inline bool\n+is_ra (hb_codepoint_t u)\n+{\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (ra_chars); i++)\n+    if (u == ra_chars[i])\n+      return true;\n+  return false;\n+}\n+\n+static inline void\n+set_indic_properties (hb_glyph_info_t &info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  unsigned int type = hb_indic_get_categories (u);\n+  indic_category_t cat = (indic_category_t) (type & 0x7Fu);\n+  indic_position_t pos = (indic_position_t) (type >> 8);\n+\n+\n+  \/*\n+   * Re-assign category\n+   *\/\n+\n+  \/* The following act more like the Bindus. *\/\n+  if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x0953u, 0x0954u)))\n+    cat = OT_SM;\n+  \/* The following act like consonants. *\/\n+  else if (unlikely (hb_in_ranges<hb_codepoint_t> (u, 0x0A72u, 0x0A73u,\n+                                      0x1CF5u, 0x1CF6u)))\n+    cat = OT_C;\n+  \/* TODO: The following should only be allowed after a Visarga.\n+   * For now, just treat them like regular tone marks. *\/\n+  else if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x1CE2u, 0x1CE8u)))\n+    cat = OT_A;\n+  \/* TODO: The following should only be allowed after some of\n+   * the nasalization marks, maybe only for U+1CE9..U+1CF1.\n+   * For now, just treat them like tone marks. *\/\n+  else if (unlikely (u == 0x1CEDu))\n+    cat = OT_A;\n+  \/* The following take marks in standalone clusters, similar to Avagraha. *\/\n+  else if (unlikely (hb_in_ranges<hb_codepoint_t> (u, 0xA8F2u, 0xA8F7u,\n+                                      0x1CE9u, 0x1CECu,\n+                                      0x1CEEu, 0x1CF1u)))\n+  {\n+    cat = OT_Symbol;\n+    static_assert (((int) INDIC_SYLLABIC_CATEGORY_AVAGRAHA == OT_Symbol), \"\");\n+  }\n+  else if (unlikely (u == 0x0A51u))\n+  {\n+    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/524 *\/\n+    cat = OT_M;\n+    pos = POS_BELOW_C;\n+  }\n+\n+  \/* According to ScriptExtensions.txt, these Grantha marks may also be used in Tamil,\n+   * so the Indic shaper needs to know their categories. *\/\n+  else if (unlikely (u == 0x11301u || u == 0x11303u)) cat = OT_SM;\n+  else if (unlikely (u == 0x1133cu)) cat = OT_N;\n+\n+  else if (unlikely (u == 0x0AFBu)) cat = OT_N; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/552 *\/\n+\n+  else if (unlikely (u == 0x0980u)) cat = OT_PLACEHOLDER; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/538 *\/\n+  else if (unlikely (u == 0x0C80u)) cat = OT_PLACEHOLDER; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/623 *\/\n+  else if (unlikely (hb_in_range<hb_codepoint_t> (u, 0x2010u, 0x2011u)))\n+                                    cat = OT_PLACEHOLDER;\n+  else if (unlikely (u == 0x25CCu)) cat = OT_DOTTEDCIRCLE;\n+\n+\n+  \/*\n+   * Re-assign position.\n+   *\/\n+\n+  if ((FLAG_UNSAFE (cat) & CONSONANT_FLAGS))\n+  {\n+    pos = POS_BASE_C;\n+    if (is_ra (u))\n+      cat = OT_Ra;\n+  }\n+  else if (cat == OT_M)\n+  {\n+    pos = matra_position_indic (u, pos);\n+  }\n+  else if ((FLAG_UNSAFE (cat) & (FLAG (OT_SM) \/* | FLAG (OT_VD) *\/ | FLAG (OT_A) | FLAG (OT_Symbol))))\n+  {\n+    pos = POS_SMVD;\n+  }\n+\n+  if (unlikely (u == 0x0B01u)) pos = POS_BEFORE_SUB; \/* Oriya Bindu is BeforeSub in the spec. *\/\n+\n+\n+\n+  info.indic_category() = cat;\n+  info.indic_position() = pos;\n+}\n+\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_INDIC_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-indic.hh","additions":399,"deletions":0,"binary":false,"changes":399,"status":"added"},{"patch":"@@ -0,0 +1,378 @@\n+\n+#line 1 \"hb-ot-shape-complex-khmer-machine.rl\"\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_KHMER_MACHINE_HH\n+#define HB_OT_SHAPE_COMPLEX_KHMER_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 36 \"hb-ot-shape-complex-khmer-machine.hh\"\n+static const unsigned char _khmer_syllable_machine_trans_keys[] = {\n+        5u, 26u, 5u, 21u, 5u, 26u, 5u, 21u, 1u, 16u, 5u, 21u, 5u, 26u, 5u, 21u,\n+        5u, 26u, 5u, 21u, 1u, 16u, 5u, 21u, 5u, 26u, 5u, 21u, 1u, 16u, 5u, 21u,\n+        5u, 26u, 5u, 21u, 5u, 26u, 5u, 21u, 5u, 26u, 1u, 16u, 1u, 29u, 5u, 29u,\n+        5u, 29u, 5u, 29u, 22u, 22u, 5u, 22u, 5u, 29u, 5u, 29u, 5u, 29u, 5u, 26u,\n+        5u, 29u, 5u, 29u, 22u, 22u, 5u, 22u, 5u, 29u, 5u, 29u, 1u, 16u, 5u, 29u,\n+        5u, 29u, 0\n+};\n+\n+static const char _khmer_syllable_machine_key_spans[] = {\n+        22, 17, 22, 17, 16, 17, 22, 17,\n+        22, 17, 16, 17, 22, 17, 16, 17,\n+        22, 17, 22, 17, 22, 16, 29, 25,\n+        25, 25, 1, 18, 25, 25, 25, 22,\n+        25, 25, 1, 18, 25, 25, 16, 25,\n+        25\n+};\n+\n+static const short _khmer_syllable_machine_index_offsets[] = {\n+        0, 23, 41, 64, 82, 99, 117, 140,\n+        158, 181, 199, 216, 234, 257, 275, 292,\n+        310, 333, 351, 374, 392, 415, 432, 462,\n+        488, 514, 540, 542, 561, 587, 613, 639,\n+        662, 688, 714, 716, 735, 761, 787, 804,\n+        830\n+};\n+\n+static const char _khmer_syllable_machine_indicies[] = {\n+        1, 1, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 2,\n+        3, 0, 0, 0, 0, 4, 0, 1,\n+        1, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 3,\n+        0, 1, 1, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 3, 0, 0, 0, 0, 4, 0,\n+        5, 5, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        4, 0, 6, 6, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 6, 0, 7, 7, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 8, 0, 9, 9, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 10, 0, 0,\n+        0, 0, 4, 0, 9, 9, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 10, 0, 11, 11,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 12, 0,\n+        0, 0, 0, 4, 0, 11, 11, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 12, 0, 13,\n+        13, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 13, 0,\n+        15, 15, 14, 14, 14, 14, 14, 14,\n+        14, 14, 14, 14, 14, 14, 14, 14,\n+        16, 14, 15, 15, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 16, 17, 17, 17, 17, 18,\n+        17, 19, 19, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 18, 17, 20, 20, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 20, 17, 21, 21, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 22, 17, 23, 23,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 24, 17,\n+        17, 17, 17, 18, 17, 23, 23, 17,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 24, 17, 25,\n+        25, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 26,\n+        17, 17, 17, 17, 18, 17, 25, 25,\n+        17, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 26, 17,\n+        15, 15, 17, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 17, 27,\n+        16, 17, 17, 17, 17, 18, 17, 28,\n+        28, 17, 17, 17, 17, 17, 17, 17,\n+        17, 17, 17, 17, 17, 17, 28, 17,\n+        13, 13, 29, 29, 30, 30, 29, 29,\n+        29, 29, 2, 2, 29, 31, 29, 13,\n+        29, 29, 29, 29, 16, 20, 29, 29,\n+        29, 18, 24, 26, 22, 29, 33, 33,\n+        32, 32, 32, 32, 32, 32, 32, 34,\n+        32, 32, 32, 32, 32, 2, 3, 6,\n+        32, 32, 32, 4, 10, 12, 8, 32,\n+        35, 35, 32, 32, 32, 32, 32, 32,\n+        32, 36, 32, 32, 32, 32, 32, 32,\n+        3, 6, 32, 32, 32, 4, 10, 12,\n+        8, 32, 5, 5, 32, 32, 32, 32,\n+        32, 32, 32, 36, 32, 32, 32, 32,\n+        32, 32, 4, 6, 32, 32, 32, 32,\n+        32, 32, 8, 32, 6, 32, 7, 7,\n+        32, 32, 32, 32, 32, 32, 32, 36,\n+        32, 32, 32, 32, 32, 32, 8, 6,\n+        32, 37, 37, 32, 32, 32, 32, 32,\n+        32, 32, 36, 32, 32, 32, 32, 32,\n+        32, 10, 6, 32, 32, 32, 4, 32,\n+        32, 8, 32, 38, 38, 32, 32, 32,\n+        32, 32, 32, 32, 36, 32, 32, 32,\n+        32, 32, 32, 12, 6, 32, 32, 32,\n+        4, 10, 32, 8, 32, 35, 35, 32,\n+        32, 32, 32, 32, 32, 32, 34, 32,\n+        32, 32, 32, 32, 32, 3, 6, 32,\n+        32, 32, 4, 10, 12, 8, 32, 15,\n+        15, 39, 39, 39, 39, 39, 39, 39,\n+        39, 39, 39, 39, 39, 39, 39, 16,\n+        39, 39, 39, 39, 18, 39, 41, 41,\n+        40, 40, 40, 40, 40, 40, 40, 42,\n+        40, 40, 40, 40, 40, 40, 16, 20,\n+        40, 40, 40, 18, 24, 26, 22, 40,\n+        19, 19, 40, 40, 40, 40, 40, 40,\n+        40, 42, 40, 40, 40, 40, 40, 40,\n+        18, 20, 40, 40, 40, 40, 40, 40,\n+        22, 40, 20, 40, 21, 21, 40, 40,\n+        40, 40, 40, 40, 40, 42, 40, 40,\n+        40, 40, 40, 40, 22, 20, 40, 43,\n+        43, 40, 40, 40, 40, 40, 40, 40,\n+        42, 40, 40, 40, 40, 40, 40, 24,\n+        20, 40, 40, 40, 18, 40, 40, 22,\n+        40, 44, 44, 40, 40, 40, 40, 40,\n+        40, 40, 42, 40, 40, 40, 40, 40,\n+        40, 26, 20, 40, 40, 40, 18, 24,\n+        40, 22, 40, 28, 28, 39, 39, 39,\n+        39, 39, 39, 39, 39, 39, 39, 39,\n+        39, 39, 28, 39, 45, 45, 40, 40,\n+        40, 40, 40, 40, 40, 46, 40, 40,\n+        40, 40, 40, 27, 16, 20, 40, 40,\n+        40, 18, 24, 26, 22, 40, 41, 41,\n+        40, 40, 40, 40, 40, 40, 40, 46,\n+        40, 40, 40, 40, 40, 40, 16, 20,\n+        40, 40, 40, 18, 24, 26, 22, 40,\n+        0\n+};\n+\n+static const char _khmer_syllable_machine_trans_targs[] = {\n+        22, 1, 30, 24, 25, 3, 26, 5,\n+        27, 7, 28, 9, 29, 23, 22, 11,\n+        32, 22, 33, 13, 34, 15, 35, 17,\n+        36, 19, 37, 40, 39, 22, 31, 38,\n+        22, 0, 10, 2, 4, 6, 8, 22,\n+        22, 12, 14, 16, 18, 20, 21\n+};\n+\n+static const char _khmer_syllable_machine_trans_actions[] = {\n+        1, 0, 2, 2, 2, 0, 0, 0,\n+        2, 0, 2, 0, 2, 2, 3, 0,\n+        4, 5, 2, 0, 0, 0, 2, 0,\n+        2, 0, 2, 4, 4, 8, 9, 0,\n+        10, 0, 0, 0, 0, 0, 0, 11,\n+        12, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const char _khmer_syllable_machine_to_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 6, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0\n+};\n+\n+static const char _khmer_syllable_machine_from_state_actions[] = {\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 7, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0\n+};\n+\n+static const unsigned char _khmer_syllable_machine_eof_trans[] = {\n+        1, 1, 1, 1, 1, 1, 1, 1,\n+        1, 1, 1, 15, 18, 18, 18, 18,\n+        18, 18, 18, 18, 18, 18, 0, 33,\n+        33, 33, 33, 33, 33, 33, 33, 40,\n+        41, 41, 41, 41, 41, 41, 40, 41,\n+        41\n+};\n+\n+static const int khmer_syllable_machine_start = 22;\n+static const int khmer_syllable_machine_first_final = 22;\n+static const int khmer_syllable_machine_error = -1;\n+\n+static const int khmer_syllable_machine_en_main = 22;\n+\n+\n+#line 36 \"hb-ot-shape-complex-khmer-machine.rl\"\n+\n+\n+\n+#line 80 \"hb-ot-shape-complex-khmer-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    for (unsigned int i = ts; i < te; i++) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+static void\n+find_syllables (hb_buffer_t *buffer)\n+{\n+  unsigned int p, pe, eof, ts, te, act HB_UNUSED;\n+  int cs;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#line 250 \"hb-ot-shape-complex-khmer-machine.hh\"\n+        {\n+        cs = khmer_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 100 \"hb-ot-shape-complex-khmer-machine.rl\"\n+\n+\n+  p = 0;\n+  pe = eof = buffer->len;\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 266 \"hb-ot-shape-complex-khmer-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _khmer_syllable_machine_from_state_actions[cs] ) {\n+        case 7:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 280 \"hb-ot-shape-complex-khmer-machine.hh\"\n+        }\n+\n+        _keys = _khmer_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _khmer_syllable_machine_indicies + _khmer_syllable_machine_index_offsets[cs];\n+\n+        _slen = _khmer_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].khmer_category()) &&\n+                ( info[p].khmer_category()) <= _keys[1] ?\n+                ( info[p].khmer_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _khmer_syllable_machine_trans_targs[_trans];\n+\n+        if ( _khmer_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _khmer_syllable_machine_trans_actions[_trans] ) {\n+        case 2:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+        break;\n+        case 8:\n+#line 76 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {te = p+1;{ found_syllable (non_khmer_cluster); }}\n+        break;\n+        case 10:\n+#line 74 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {te = p;p--;{ found_syllable (consonant_syllable); }}\n+        break;\n+        case 12:\n+#line 75 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {te = p;p--;{ found_syllable (broken_cluster); }}\n+        break;\n+        case 11:\n+#line 76 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {te = p;p--;{ found_syllable (non_khmer_cluster); }}\n+        break;\n+        case 1:\n+#line 74 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (consonant_syllable); }}\n+        break;\n+        case 5:\n+#line 75 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (broken_cluster); }}\n+        break;\n+        case 3:\n+#line 1 \"NONE\"\n+        {       switch( act ) {\n+        case 2:\n+        {{p = ((te))-1;} found_syllable (broken_cluster); }\n+        break;\n+        case 3:\n+        {{p = ((te))-1;} found_syllable (non_khmer_cluster); }\n+        break;\n+        }\n+        }\n+        break;\n+        case 4:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 75 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {act = 2;}\n+        break;\n+        case 9:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 76 \"hb-ot-shape-complex-khmer-machine.rl\"\n+        {act = 3;}\n+        break;\n+#line 350 \"hb-ot-shape-complex-khmer-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _khmer_syllable_machine_to_state_actions[cs] ) {\n+        case 6:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 359 \"hb-ot-shape-complex-khmer-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _khmer_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _khmer_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 108 \"hb-ot-shape-complex-khmer-machine.rl\"\n+\n+}\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_KHMER_MACHINE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-khmer-machine.hh","additions":378,"deletions":0,"binary":false,"changes":378,"status":"added"},{"patch":"@@ -0,0 +1,501 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex-khmer.hh\"\n+#include \"hb-ot-layout.hh\"\n+\n+\n+\/*\n+ * Khmer shaper.\n+ *\/\n+\n+static const hb_ot_map_feature_t\n+khmer_features[] =\n+{\n+  \/*\n+   * Basic features.\n+   * These features are applied in order, one at a time, after reordering.\n+   *\/\n+  {HB_TAG('p','r','e','f'), F_MANUAL_JOINERS},\n+  {HB_TAG('b','l','w','f'), F_MANUAL_JOINERS},\n+  {HB_TAG('a','b','v','f'), F_MANUAL_JOINERS},\n+  {HB_TAG('p','s','t','f'), F_MANUAL_JOINERS},\n+  {HB_TAG('c','f','a','r'), F_MANUAL_JOINERS},\n+  \/*\n+   * Other features.\n+   * These features are applied all at once after clearing syllables.\n+   *\/\n+  {HB_TAG('p','r','e','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('a','b','v','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('b','l','w','s'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('p','s','t','s'), F_GLOBAL_MANUAL_JOINERS},\n+  \/*\n+   * Positioning features.\n+   * We don't care about the types.\n+   *\/\n+  {HB_TAG('d','i','s','t'), F_GLOBAL},\n+  {HB_TAG('a','b','v','m'), F_GLOBAL},\n+  {HB_TAG('b','l','w','m'), F_GLOBAL},\n+};\n+\n+\/*\n+ * Must be in the same order as the khmer_features array.\n+ *\/\n+enum {\n+  PREF,\n+  BLWF,\n+  ABVF,\n+  PSTF,\n+  CFAR,\n+\n+  _PRES,\n+  _ABVS,\n+  _BLWS,\n+  _PSTS,\n+\n+  _DIST,\n+  _ABVM,\n+  _BLWM,\n+\n+  KHMER_NUM_FEATURES,\n+  KHMER_BASIC_FEATURES = _PRES, \/* Don't forget to update this! *\/\n+};\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+static void\n+reorder (const hb_ot_shape_plan_t *plan,\n+         hb_font_t *font,\n+         hb_buffer_t *buffer);\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+\n+static void\n+collect_features_khmer (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Do this before any lookups have been applied. *\/\n+  map->add_gsub_pause (setup_syllables);\n+  map->add_gsub_pause (reorder);\n+\n+  \/* Testing suggests that Uniscribe does NOT pause between basic\n+   * features.  Test with KhmerUI.ttf and the following three\n+   * sequences:\n+   *\n+   *   U+1789,U+17BC\n+   *   U+1789,U+17D2,U+1789\n+   *   U+1789,U+17D2,U+1789,U+17BC\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/974\n+   *\/\n+  map->enable_feature (HB_TAG('l','o','c','l'));\n+  map->enable_feature (HB_TAG('c','c','m','p'));\n+\n+  unsigned int i = 0;\n+  for (; i < KHMER_BASIC_FEATURES; i++)\n+    map->add_feature (khmer_features[i]);\n+\n+  map->add_gsub_pause (clear_syllables);\n+\n+  for (; i < KHMER_NUM_FEATURES; i++)\n+    map->add_feature (khmer_features[i]);\n+}\n+\n+static void\n+override_features_khmer (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Khmer spec has 'clig' as part of required shaping features:\n+   * \"Apply feature 'clig' to form ligatures that are desired for\n+   * typographical correctness.\", hence in overrides... *\/\n+  map->enable_feature (HB_TAG('c','l','i','g'));\n+\n+  \/* Uniscribe does not apply 'kern' in Khmer. *\/\n+  if (hb_options ().uniscribe_bug_compatible)\n+  {\n+    map->disable_feature (HB_TAG('k','e','r','n'));\n+  }\n+\n+  map->disable_feature (HB_TAG('l','i','g','a'));\n+}\n+\n+\n+struct would_substitute_feature_t\n+{\n+  void init (const hb_ot_map_t *map, hb_tag_t feature_tag, bool zero_context_)\n+  {\n+    zero_context = zero_context_;\n+    map->get_stage_lookups (0\/*GSUB*\/,\n+                            map->get_feature_stage (0\/*GSUB*\/, feature_tag),\n+                            &lookups, &count);\n+  }\n+\n+  bool would_substitute (const hb_codepoint_t *glyphs,\n+                         unsigned int          glyphs_count,\n+                         hb_face_t            *face) const\n+  {\n+    for (unsigned int i = 0; i < count; i++)\n+      if (hb_ot_layout_lookup_would_substitute_fast (face, lookups[i].index, glyphs, glyphs_count, zero_context))\n+        return true;\n+    return false;\n+  }\n+\n+  private:\n+  const hb_ot_map_t::lookup_map_t *lookups;\n+  unsigned int count;\n+  bool zero_context;\n+};\n+\n+struct khmer_shape_plan_t\n+{\n+  bool get_virama_glyph (hb_font_t *font, hb_codepoint_t *pglyph) const\n+  {\n+    hb_codepoint_t glyph = virama_glyph;\n+    if (unlikely (virama_glyph == (hb_codepoint_t) -1))\n+    {\n+      if (!font->get_nominal_glyph (0x17D2u, &glyph))\n+        glyph = 0;\n+      \/* Technically speaking, the spec says we should apply 'locl' to virama too.\n+       * Maybe one day... *\/\n+\n+      \/* Our get_nominal_glyph() function needs a font, so we can't get the virama glyph\n+       * during shape planning...  Instead, overwrite it here.  It's safe.  Don't worry! *\/\n+      virama_glyph = glyph;\n+    }\n+\n+    *pglyph = glyph;\n+    return glyph != 0;\n+  }\n+\n+  mutable hb_codepoint_t virama_glyph;\n+\n+  would_substitute_feature_t pref;\n+\n+  hb_mask_t mask_array[KHMER_NUM_FEATURES];\n+};\n+\n+static void *\n+data_create_khmer (const hb_ot_shape_plan_t *plan)\n+{\n+  khmer_shape_plan_t *khmer_plan = (khmer_shape_plan_t *) calloc (1, sizeof (khmer_shape_plan_t));\n+  if (unlikely (!khmer_plan))\n+    return nullptr;\n+\n+  khmer_plan->virama_glyph = (hb_codepoint_t) -1;\n+\n+  khmer_plan->pref.init (&plan->map, HB_TAG('p','r','e','f'), true);\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (khmer_plan->mask_array); i++)\n+    khmer_plan->mask_array[i] = (khmer_features[i].flags & F_GLOBAL) ?\n+                                 0 : plan->map.get_1_mask (khmer_features[i].tag);\n+\n+  return khmer_plan;\n+}\n+\n+static void\n+data_destroy_khmer (void *data)\n+{\n+  free (data);\n+}\n+\n+\n+enum syllable_type_t {\n+  consonant_syllable,\n+  broken_cluster,\n+  non_khmer_cluster,\n+};\n+\n+#include \"hb-ot-shape-complex-khmer-machine.hh\"\n+\n+static void\n+setup_masks_khmer (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                   hb_buffer_t              *buffer,\n+                   hb_font_t                *font HB_UNUSED)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, khmer_category);\n+\n+  \/* We cannot setup masks here.  We save information about characters\n+   * and setup masks later on in a pause-callback. *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    set_khmer_properties (info[i]);\n+}\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  find_syllables (buffer);\n+  foreach_syllable (buffer, start, end)\n+    buffer->unsafe_to_break (start, end);\n+}\n+\n+\n+\/* Rules from:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/devanagari *\/\n+\n+static void\n+reorder_consonant_syllable (const hb_ot_shape_plan_t *plan,\n+                            hb_face_t *face HB_UNUSED,\n+                            hb_buffer_t *buffer,\n+                            unsigned int start, unsigned int end)\n+{\n+  const khmer_shape_plan_t *khmer_plan = (const khmer_shape_plan_t *) plan->data;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  \/* Setup masks. *\/\n+  {\n+    \/* Post-base *\/\n+    hb_mask_t mask = khmer_plan->mask_array[BLWF] | khmer_plan->mask_array[ABVF] | khmer_plan->mask_array[PSTF];\n+    for (unsigned int i = start + 1; i < end; i++)\n+      info[i].mask  |= mask;\n+  }\n+\n+  unsigned int num_coengs = 0;\n+  for (unsigned int i = start + 1; i < end; i++)\n+  {\n+    \/* \"\"\"\n+     * When a COENG + (Cons | IndV) combination are found (and subscript count\n+     * is less than two) the character combination is handled according to the\n+     * subscript type of the character following the COENG.\n+     *\n+     * ...\n+     *\n+     * Subscript Type 2 - The COENG + RO characters are reordered to immediately\n+     * before the base glyph. Then the COENG + RO characters are assigned to have\n+     * the 'pref' OpenType feature applied to them.\n+     * \"\"\"\n+     *\/\n+    if (info[i].khmer_category() == OT_Coeng && num_coengs <= 2 && i + 1 < end)\n+    {\n+      num_coengs++;\n+\n+      if (info[i + 1].khmer_category() == OT_Ra)\n+      {\n+        for (unsigned int j = 0; j < 2; j++)\n+          info[i + j].mask |= khmer_plan->mask_array[PREF];\n+\n+        \/* Move the Coeng,Ro sequence to the start. *\/\n+        buffer->merge_clusters (start, i + 2);\n+        hb_glyph_info_t t0 = info[i];\n+        hb_glyph_info_t t1 = info[i + 1];\n+        memmove (&info[start + 2], &info[start], (i - start) * sizeof (info[0]));\n+        info[start] = t0;\n+        info[start + 1] = t1;\n+\n+        \/* Mark the subsequent stuff with 'cfar'.  Used in Khmer.\n+         * Read the feature spec.\n+         * This allows distinguishing the following cases with MS Khmer fonts:\n+         * U+1784,U+17D2,U+179A,U+17D2,U+1782\n+         * U+1784,U+17D2,U+1782,U+17D2,U+179A\n+         *\/\n+        if (khmer_plan->mask_array[CFAR])\n+          for (unsigned int j = i + 2; j < end; j++)\n+            info[j].mask |= khmer_plan->mask_array[CFAR];\n+\n+        num_coengs = 2; \/* Done. *\/\n+      }\n+    }\n+\n+    \/* Reorder left matra piece. *\/\n+    else if (info[i].khmer_category() == OT_VPre)\n+    {\n+      \/* Move to the start. *\/\n+      buffer->merge_clusters (start, i + 1);\n+      hb_glyph_info_t t = info[i];\n+      memmove (&info[start + 1], &info[start], (i - start) * sizeof (info[0]));\n+      info[start] = t;\n+    }\n+  }\n+}\n+\n+static void\n+initial_reordering_syllable (const hb_ot_shape_plan_t *plan,\n+                             hb_face_t *face,\n+                             hb_buffer_t *buffer,\n+                             unsigned int start, unsigned int end)\n+{\n+  syllable_type_t syllable_type = (syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n+  switch (syllable_type)\n+  {\n+    case broken_cluster: \/* We already inserted dotted-circles, so just call the consonant_syllable. *\/\n+    case consonant_syllable:\n+     reorder_consonant_syllable (plan, face, buffer, start, end);\n+     break;\n+\n+    case non_khmer_cluster:\n+      break;\n+  }\n+}\n+\n+static inline void\n+insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer)\n+{\n+  \/* Note: This loop is extra overhead, but should not be measurable. *\/\n+  bool has_broken_syllables = false;\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    if ((info[i].syllable() & 0x0F) == broken_cluster)\n+    {\n+      has_broken_syllables = true;\n+      break;\n+    }\n+  if (likely (!has_broken_syllables))\n+    return;\n+\n+\n+  hb_codepoint_t dottedcircle_glyph;\n+  if (!font->get_nominal_glyph (0x25CCu, &dottedcircle_glyph))\n+    return;\n+\n+  hb_glyph_info_t dottedcircle = {0};\n+  dottedcircle.codepoint = 0x25CCu;\n+  set_khmer_properties (dottedcircle);\n+  dottedcircle.codepoint = dottedcircle_glyph;\n+\n+  buffer->clear_output ();\n+\n+  buffer->idx = 0;\n+  unsigned int last_syllable = 0;\n+  while (buffer->idx < buffer->len && buffer->successful)\n+  {\n+    unsigned int syllable = buffer->cur().syllable();\n+    syllable_type_t syllable_type = (syllable_type_t) (syllable & 0x0F);\n+    if (unlikely (last_syllable != syllable && syllable_type == broken_cluster))\n+    {\n+      last_syllable = syllable;\n+\n+      hb_glyph_info_t ginfo = dottedcircle;\n+      ginfo.cluster = buffer->cur().cluster;\n+      ginfo.mask = buffer->cur().mask;\n+      ginfo.syllable() = buffer->cur().syllable();\n+      \/* TODO Set glyph_props? *\/\n+\n+      \/* Insert dottedcircle after possible Repha. *\/\n+      while (buffer->idx < buffer->len && buffer->successful &&\n+             last_syllable == buffer->cur().syllable() &&\n+             buffer->cur().khmer_category() == OT_Repha)\n+        buffer->next_glyph ();\n+\n+      buffer->output_info (ginfo);\n+    }\n+    else\n+      buffer->next_glyph ();\n+  }\n+  buffer->swap_buffers ();\n+}\n+\n+static void\n+reorder (const hb_ot_shape_plan_t *plan,\n+         hb_font_t *font,\n+         hb_buffer_t *buffer)\n+{\n+  insert_dotted_circles (plan, font, buffer);\n+\n+  foreach_syllable (buffer, start, end)\n+    initial_reordering_syllable (plan, font->face, buffer, start, end);\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, khmer_category);\n+}\n+\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    info[i].syllable() = 0;\n+}\n+\n+\n+static bool\n+decompose_khmer (const hb_ot_shape_normalize_context_t *c,\n+                 hb_codepoint_t  ab,\n+                 hb_codepoint_t *a,\n+                 hb_codepoint_t *b)\n+{\n+  switch (ab)\n+  {\n+    \/*\n+     * Decompose split matras that don't have Unicode decompositions.\n+     *\/\n+\n+    \/* Khmer *\/\n+    case 0x17BEu  : *a = 0x17C1u; *b= 0x17BEu; return true;\n+    case 0x17BFu  : *a = 0x17C1u; *b= 0x17BFu; return true;\n+    case 0x17C0u  : *a = 0x17C1u; *b= 0x17C0u; return true;\n+    case 0x17C4u  : *a = 0x17C1u; *b= 0x17C4u; return true;\n+    case 0x17C5u  : *a = 0x17C1u; *b= 0x17C5u; return true;\n+  }\n+\n+  return (bool) c->unicode->decompose (ab, a, b);\n+}\n+\n+static bool\n+compose_khmer (const hb_ot_shape_normalize_context_t *c,\n+               hb_codepoint_t  a,\n+               hb_codepoint_t  b,\n+               hb_codepoint_t *ab)\n+{\n+  \/* Avoid recomposing split matras. *\/\n+  if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c->unicode->general_category (a)))\n+    return false;\n+\n+  return (bool) c->unicode->compose (a, b, ab);\n+}\n+\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_khmer =\n+{\n+  collect_features_khmer,\n+  override_features_khmer,\n+  data_create_khmer,\n+  data_destroy_khmer,\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n+  decompose_khmer,\n+  compose_khmer,\n+  setup_masks_khmer,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  false, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-khmer.cc","additions":501,"deletions":0,"binary":false,"changes":501,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_KHMER_HH\n+#define HB_OT_SHAPE_COMPLEX_KHMER_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shape-complex-indic.hh\"\n+\n+\n+\/* buffer var allocations *\/\n+#define khmer_category() indic_category() \/* khmer_category_t *\/\n+\n+\n+\/* Note: This enum is duplicated in the -machine.rl source file.\n+ * Not sure how to avoid duplication. *\/\n+enum khmer_category_t\n+{\n+  OT_Robatic = 20,\n+  OT_Xgroup  = 21,\n+  OT_Ygroup  = 22,\n+\n+  OT_VAbv    = 26,\n+  OT_VBlw    = 27,\n+  OT_VPre    = 28,\n+  OT_VPst    = 29,\n+};\n+\n+static inline void\n+set_khmer_properties (hb_glyph_info_t &info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  unsigned int type = hb_indic_get_categories (u);\n+  khmer_category_t cat = (khmer_category_t) (type & 0x7Fu);\n+  indic_position_t pos = (indic_position_t) (type >> 8);\n+\n+\n+  \/*\n+   * Re-assign category\n+   *\n+   * These categories are experimentally extracted from what Uniscribe allows.\n+   *\/\n+  switch (u)\n+  {\n+    case 0x179Au:\n+      cat = (khmer_category_t) OT_Ra;\n+      break;\n+\n+    case 0x17CCu:\n+    case 0x17C9u:\n+    case 0x17CAu:\n+      cat = OT_Robatic;\n+      break;\n+\n+    case 0x17C6u:\n+    case 0x17CBu:\n+    case 0x17CDu:\n+    case 0x17CEu:\n+    case 0x17CFu:\n+    case 0x17D0u:\n+    case 0x17D1u:\n+      cat = OT_Xgroup;\n+      break;\n+\n+    case 0x17C7u:\n+    case 0x17C8u:\n+    case 0x17DDu:\n+    case 0x17D3u: \/* Just guessing. Uniscribe doesn't categorize it. *\/\n+      cat = OT_Ygroup;\n+      break;\n+  }\n+\n+  \/*\n+   * Re-assign position.\n+   *\/\n+  if (cat == (khmer_category_t) OT_M)\n+    switch ((int) pos)\n+    {\n+      case POS_PRE_C:   cat = OT_VPre; break;\n+      case POS_BELOW_C: cat = OT_VBlw; break;\n+      case POS_ABOVE_C: cat = OT_VAbv; break;\n+      case POS_POST_C:  cat = OT_VPst; break;\n+      default: assert (0);\n+    };\n+\n+  info.khmer_category() = cat;\n+}\n+\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_KHMER_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-khmer.hh","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,411 @@\n+\n+#line 1 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_MYANMAR_MACHINE_HH\n+#define HB_OT_SHAPE_COMPLEX_MYANMAR_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 36 \"hb-ot-shape-complex-myanmar-machine.hh\"\n+static const unsigned char _myanmar_syllable_machine_trans_keys[] = {\n+        1u, 32u, 3u, 30u, 5u, 29u, 5u, 8u, 5u, 29u, 3u, 25u, 5u, 25u, 5u, 25u,\n+        3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u, 1u, 16u, 3u, 29u, 3u, 29u, 3u, 29u,\n+        3u, 29u, 3u, 29u, 3u, 30u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u, 5u, 29u,\n+        5u, 8u, 5u, 29u, 3u, 25u, 5u, 25u, 5u, 25u, 3u, 29u, 3u, 29u, 3u, 29u,\n+        3u, 29u, 3u, 30u, 3u, 29u, 1u, 32u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u,\n+        3u, 29u, 3u, 30u, 3u, 29u, 3u, 29u, 3u, 29u, 3u, 29u, 1u, 32u, 8u, 8u,\n+        0\n+};\n+\n+static const char _myanmar_syllable_machine_key_spans[] = {\n+        32, 28, 25, 4, 25, 23, 21, 21,\n+        27, 27, 27, 27, 16, 27, 27, 27,\n+        27, 27, 28, 27, 27, 27, 27, 25,\n+        4, 25, 23, 21, 21, 27, 27, 27,\n+        27, 28, 27, 32, 27, 27, 27, 27,\n+        27, 28, 27, 27, 27, 27, 32, 1\n+};\n+\n+static const short _myanmar_syllable_machine_index_offsets[] = {\n+        0, 33, 62, 88, 93, 119, 143, 165,\n+        187, 215, 243, 271, 299, 316, 344, 372,\n+        400, 428, 456, 485, 513, 541, 569, 597,\n+        623, 628, 654, 678, 700, 722, 750, 778,\n+        806, 834, 863, 891, 924, 952, 980, 1008,\n+        1036, 1064, 1093, 1121, 1149, 1177, 1205, 1238\n+};\n+\n+static const char _myanmar_syllable_machine_indicies[] = {\n+        1, 1, 2, 3, 4, 4, 0, 5,\n+        0, 6, 1, 0, 0, 0, 0, 7,\n+        0, 8, 9, 0, 10, 11, 12, 13,\n+        14, 15, 16, 17, 18, 19, 20, 1,\n+        0, 22, 23, 24, 24, 21, 25, 21,\n+        26, 21, 21, 21, 21, 21, 21, 21,\n+        27, 21, 21, 28, 29, 30, 31, 32,\n+        33, 34, 35, 36, 37, 21, 24, 24,\n+        21, 25, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 38, 21, 21, 21, 21,\n+        21, 21, 32, 21, 21, 21, 36, 21,\n+        24, 24, 21, 25, 21, 24, 24, 21,\n+        25, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 32, 21, 21, 21, 36, 21, 39,\n+        21, 24, 24, 21, 25, 21, 32, 21,\n+        21, 21, 21, 21, 21, 21, 40, 21,\n+        21, 21, 21, 21, 21, 32, 21, 24,\n+        24, 21, 25, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 40, 21, 21, 21,\n+        21, 21, 21, 32, 21, 24, 24, 21,\n+        25, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 32, 21, 22, 21, 24, 24, 21,\n+        25, 21, 26, 21, 21, 21, 21, 21,\n+        21, 21, 41, 21, 21, 41, 21, 21,\n+        21, 32, 42, 21, 21, 36, 21, 22,\n+        21, 24, 24, 21, 25, 21, 26, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 32, 21, 21,\n+        21, 36, 21, 22, 21, 24, 24, 21,\n+        25, 21, 26, 21, 21, 21, 21, 21,\n+        21, 21, 41, 21, 21, 21, 21, 21,\n+        21, 32, 42, 21, 21, 36, 21, 22,\n+        21, 24, 24, 21, 25, 21, 26, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 32, 42, 21,\n+        21, 36, 21, 1, 1, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 1, 21, 22, 21, 24, 24,\n+        21, 25, 21, 26, 21, 21, 21, 21,\n+        21, 21, 21, 27, 21, 21, 28, 29,\n+        30, 31, 32, 33, 34, 35, 36, 21,\n+        22, 21, 24, 24, 21, 25, 21, 26,\n+        21, 21, 21, 21, 21, 21, 21, 43,\n+        21, 21, 21, 21, 21, 21, 32, 33,\n+        34, 35, 36, 21, 22, 21, 24, 24,\n+        21, 25, 21, 26, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 32, 33, 34, 35, 36, 21,\n+        22, 21, 24, 24, 21, 25, 21, 26,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 32, 33,\n+        34, 21, 36, 21, 22, 21, 24, 24,\n+        21, 25, 21, 26, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 32, 21, 34, 21, 36, 21,\n+        22, 21, 24, 24, 21, 25, 21, 26,\n+        21, 21, 21, 21, 21, 21, 21, 21,\n+        21, 21, 21, 21, 21, 21, 32, 33,\n+        34, 35, 36, 43, 21, 22, 21, 24,\n+        24, 21, 25, 21, 26, 21, 21, 21,\n+        21, 21, 21, 21, 43, 21, 21, 28,\n+        21, 30, 21, 32, 33, 34, 35, 36,\n+        21, 22, 21, 24, 24, 21, 25, 21,\n+        26, 21, 21, 21, 21, 21, 21, 21,\n+        43, 21, 21, 28, 21, 21, 21, 32,\n+        33, 34, 35, 36, 21, 22, 21, 24,\n+        24, 21, 25, 21, 26, 21, 21, 21,\n+        21, 21, 21, 21, 43, 21, 21, 28,\n+        29, 30, 21, 32, 33, 34, 35, 36,\n+        21, 22, 23, 24, 24, 21, 25, 21,\n+        26, 21, 21, 21, 21, 21, 21, 21,\n+        27, 21, 21, 28, 29, 30, 31, 32,\n+        33, 34, 35, 36, 21, 3, 3, 44,\n+        5, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 45, 44, 44, 44, 44, 44,\n+        44, 14, 44, 44, 44, 18, 44, 3,\n+        3, 44, 5, 44, 3, 3, 44, 5,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        14, 44, 44, 44, 18, 44, 46, 44,\n+        3, 3, 44, 5, 44, 14, 44, 44,\n+        44, 44, 44, 44, 44, 47, 44, 44,\n+        44, 44, 44, 44, 14, 44, 3, 3,\n+        44, 5, 44, 44, 44, 44, 44, 44,\n+        44, 44, 44, 47, 44, 44, 44, 44,\n+        44, 44, 14, 44, 3, 3, 44, 5,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        14, 44, 2, 44, 3, 3, 44, 5,\n+        44, 6, 44, 44, 44, 44, 44, 44,\n+        44, 48, 44, 44, 48, 44, 44, 44,\n+        14, 49, 44, 44, 18, 44, 2, 44,\n+        3, 3, 44, 5, 44, 6, 44, 44,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 44, 44, 14, 44, 44, 44,\n+        18, 44, 2, 44, 3, 3, 44, 5,\n+        44, 6, 44, 44, 44, 44, 44, 44,\n+        44, 48, 44, 44, 44, 44, 44, 44,\n+        14, 49, 44, 44, 18, 44, 2, 44,\n+        3, 3, 44, 5, 44, 6, 44, 44,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 44, 44, 14, 49, 44, 44,\n+        18, 44, 22, 23, 24, 24, 21, 25,\n+        21, 26, 21, 21, 21, 21, 21, 21,\n+        21, 50, 21, 21, 28, 29, 30, 31,\n+        32, 33, 34, 35, 36, 37, 21, 22,\n+        51, 24, 24, 21, 25, 21, 26, 21,\n+        21, 21, 21, 21, 21, 21, 27, 21,\n+        21, 28, 29, 30, 31, 32, 33, 34,\n+        35, 36, 21, 1, 1, 2, 3, 3,\n+        3, 44, 5, 44, 6, 1, 44, 44,\n+        44, 44, 1, 44, 8, 44, 44, 10,\n+        11, 12, 13, 14, 15, 16, 17, 18,\n+        19, 44, 1, 44, 2, 44, 3, 3,\n+        44, 5, 44, 6, 44, 44, 44, 44,\n+        44, 44, 44, 8, 44, 44, 10, 11,\n+        12, 13, 14, 15, 16, 17, 18, 44,\n+        2, 44, 3, 3, 44, 5, 44, 6,\n+        44, 44, 44, 44, 44, 44, 44, 52,\n+        44, 44, 44, 44, 44, 44, 14, 15,\n+        16, 17, 18, 44, 2, 44, 3, 3,\n+        44, 5, 44, 6, 44, 44, 44, 44,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 14, 15, 16, 17, 18, 44,\n+        2, 44, 3, 3, 44, 5, 44, 6,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 44, 44, 44, 44, 14, 15,\n+        16, 44, 18, 44, 2, 44, 3, 3,\n+        44, 5, 44, 6, 44, 44, 44, 44,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 14, 44, 16, 44, 18, 44,\n+        2, 44, 3, 3, 44, 5, 44, 6,\n+        44, 44, 44, 44, 44, 44, 44, 44,\n+        44, 44, 44, 44, 44, 44, 14, 15,\n+        16, 17, 18, 52, 44, 2, 44, 3,\n+        3, 44, 5, 44, 6, 44, 44, 44,\n+        44, 44, 44, 44, 52, 44, 44, 10,\n+        44, 12, 44, 14, 15, 16, 17, 18,\n+        44, 2, 44, 3, 3, 44, 5, 44,\n+        6, 44, 44, 44, 44, 44, 44, 44,\n+        52, 44, 44, 10, 44, 44, 44, 14,\n+        15, 16, 17, 18, 44, 2, 44, 3,\n+        3, 44, 5, 44, 6, 44, 44, 44,\n+        44, 44, 44, 44, 52, 44, 44, 10,\n+        11, 12, 44, 14, 15, 16, 17, 18,\n+        44, 2, 3, 3, 3, 44, 5, 44,\n+        6, 44, 44, 44, 44, 44, 44, 44,\n+        8, 44, 44, 10, 11, 12, 13, 14,\n+        15, 16, 17, 18, 44, 1, 1, 53,\n+        53, 53, 53, 53, 53, 53, 53, 1,\n+        53, 53, 53, 53, 1, 53, 53, 53,\n+        53, 53, 53, 53, 53, 53, 53, 53,\n+        53, 53, 53, 53, 1, 53, 54, 53,\n+        0\n+};\n+\n+static const char _myanmar_syllable_machine_trans_targs[] = {\n+        0, 1, 23, 0, 0, 24, 30, 33,\n+        36, 46, 37, 42, 43, 44, 26, 39,\n+        40, 41, 29, 45, 47, 0, 2, 12,\n+        0, 3, 9, 13, 14, 19, 20, 21,\n+        5, 16, 17, 18, 8, 22, 4, 6,\n+        7, 10, 11, 15, 0, 25, 27, 28,\n+        31, 32, 34, 35, 38, 0, 0\n+};\n+\n+static const char _myanmar_syllable_machine_trans_actions[] = {\n+        3, 0, 0, 4, 5, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 6, 0, 0,\n+        7, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 8, 0, 0, 0,\n+        0, 0, 0, 0, 0, 9, 10\n+};\n+\n+static const char _myanmar_syllable_machine_to_state_actions[] = {\n+        1, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const char _myanmar_syllable_machine_from_state_actions[] = {\n+        2, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0\n+};\n+\n+static const short _myanmar_syllable_machine_eof_trans[] = {\n+        0, 22, 22, 22, 22, 22, 22, 22,\n+        22, 22, 22, 22, 22, 22, 22, 22,\n+        22, 22, 22, 22, 22, 22, 22, 45,\n+        45, 45, 45, 45, 45, 45, 45, 45,\n+        45, 22, 22, 45, 45, 45, 45, 45,\n+        45, 45, 45, 45, 45, 45, 54, 54\n+};\n+\n+static const int myanmar_syllable_machine_start = 0;\n+static const int myanmar_syllable_machine_first_final = 0;\n+static const int myanmar_syllable_machine_error = -1;\n+\n+static const int myanmar_syllable_machine_en_main = 0;\n+\n+\n+#line 36 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+\n+\n+\n+#line 94 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    for (unsigned int i = ts; i < te; i++) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+static void\n+find_syllables (hb_buffer_t *buffer)\n+{\n+  unsigned int p, pe, eof, ts, te, act HB_UNUSED;\n+  int cs;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#line 301 \"hb-ot-shape-complex-myanmar-machine.hh\"\n+        {\n+        cs = myanmar_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 114 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+\n+\n+  p = 0;\n+  pe = eof = buffer->len;\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 317 \"hb-ot-shape-complex-myanmar-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _myanmar_syllable_machine_from_state_actions[cs] ) {\n+        case 2:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 331 \"hb-ot-shape-complex-myanmar-machine.hh\"\n+        }\n+\n+        _keys = _myanmar_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _myanmar_syllable_machine_indicies + _myanmar_syllable_machine_index_offsets[cs];\n+\n+        _slen = _myanmar_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].myanmar_category()) &&\n+                ( info[p].myanmar_category()) <= _keys[1] ?\n+                ( info[p].myanmar_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _myanmar_syllable_machine_trans_targs[_trans];\n+\n+        if ( _myanmar_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _myanmar_syllable_machine_trans_actions[_trans] ) {\n+        case 7:\n+#line 86 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (consonant_syllable); }}\n+        break;\n+        case 5:\n+#line 87 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (non_myanmar_cluster); }}\n+        break;\n+        case 10:\n+#line 88 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (punctuation_cluster); }}\n+        break;\n+        case 4:\n+#line 89 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (broken_cluster); }}\n+        break;\n+        case 3:\n+#line 90 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p+1;{ found_syllable (non_myanmar_cluster); }}\n+        break;\n+        case 6:\n+#line 86 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p;p--;{ found_syllable (consonant_syllable); }}\n+        break;\n+        case 8:\n+#line 89 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p;p--;{ found_syllable (broken_cluster); }}\n+        break;\n+        case 9:\n+#line 90 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+        {te = p;p--;{ found_syllable (non_myanmar_cluster); }}\n+        break;\n+#line 381 \"hb-ot-shape-complex-myanmar-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _myanmar_syllable_machine_to_state_actions[cs] ) {\n+        case 1:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 390 \"hb-ot-shape-complex-myanmar-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _myanmar_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _myanmar_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 122 \"hb-ot-shape-complex-myanmar-machine.rl\"\n+\n+}\n+\n+#undef found_syllable\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_MYANMAR_MACHINE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-myanmar-machine.hh","additions":411,"deletions":0,"binary":false,"changes":411,"status":"added"},{"patch":"@@ -0,0 +1,413 @@\n+\/*\n+ * Copyright © 2011,2012,2013  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex-myanmar.hh\"\n+\n+\n+\/*\n+ * Myanmar shaper.\n+ *\/\n+\n+static const hb_tag_t\n+basic_features[] =\n+{\n+  \/*\n+   * Basic features.\n+   * These features are applied in order, one at a time, after reordering.\n+   *\/\n+  HB_TAG('r','p','h','f'),\n+  HB_TAG('p','r','e','f'),\n+  HB_TAG('b','l','w','f'),\n+  HB_TAG('p','s','t','f'),\n+};\n+static const hb_tag_t\n+other_features[] =\n+{\n+  \/*\n+   * Other features.\n+   * These features are applied all at once, after clearing syllables.\n+   *\/\n+  HB_TAG('p','r','e','s'),\n+  HB_TAG('a','b','v','s'),\n+  HB_TAG('b','l','w','s'),\n+  HB_TAG('p','s','t','s'),\n+};\n+static const hb_tag_t\n+positioning_features[] =\n+{\n+  \/*\n+   * Positioning features.\n+   * We don't care about the types.\n+   *\/\n+  HB_TAG('d','i','s','t'),\n+  \/* Pre-release version of Windows 8 Myanmar font had abvm,blwm\n+   * features.  The released Windows 8 version of the font (as well\n+   * as the released spec) used 'mark' instead.  The Windows 8\n+   * shaper however didn't apply 'mark' but did apply 'mkmk'.\n+   * Perhaps it applied abvm\/blwm.  This was fixed in a Windows 8\n+   * update, so now it applies mark\/mkmk.  We are guessing that\n+   * it still applies abvm\/blwm too.\n+   *\/\n+  HB_TAG('a','b','v','m'),\n+  HB_TAG('b','l','w','m'),\n+};\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+static void\n+reorder (const hb_ot_shape_plan_t *plan,\n+         hb_font_t *font,\n+         hb_buffer_t *buffer);\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+\n+static void\n+collect_features_myanmar (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Do this before any lookups have been applied. *\/\n+  map->add_gsub_pause (setup_syllables);\n+\n+  map->enable_feature (HB_TAG('l','o','c','l'));\n+  \/* The Indic specs do not require ccmp, but we apply it here since if\n+   * there is a use of it, it's typically at the beginning. *\/\n+  map->enable_feature (HB_TAG('c','c','m','p'));\n+\n+\n+  map->add_gsub_pause (reorder);\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (basic_features); i++)\n+  {\n+    map->enable_feature (basic_features[i], F_MANUAL_ZWJ);\n+    map->add_gsub_pause (nullptr);\n+  }\n+\n+  map->add_gsub_pause (clear_syllables);\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (other_features); i++)\n+    map->enable_feature (other_features[i], F_MANUAL_ZWJ);\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (positioning_features); i++)\n+    map->enable_feature (positioning_features[i]);\n+}\n+\n+static void\n+override_features_myanmar (hb_ot_shape_planner_t *plan)\n+{\n+  plan->map.disable_feature (HB_TAG('l','i','g','a'));\n+}\n+\n+\n+enum syllable_type_t {\n+  consonant_syllable,\n+  punctuation_cluster,\n+  broken_cluster,\n+  non_myanmar_cluster,\n+};\n+\n+#include \"hb-ot-shape-complex-myanmar-machine.hh\"\n+\n+\n+static void\n+setup_masks_myanmar (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                   hb_buffer_t              *buffer,\n+                   hb_font_t                *font HB_UNUSED)\n+{\n+  HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_category);\n+  HB_BUFFER_ALLOCATE_VAR (buffer, myanmar_position);\n+\n+  \/* We cannot setup masks here.  We save information about characters\n+   * and setup masks later on in a pause-callback. *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    set_myanmar_properties (info[i]);\n+}\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  find_syllables (buffer);\n+  foreach_syllable (buffer, start, end)\n+    buffer->unsafe_to_break (start, end);\n+}\n+\n+static int\n+compare_myanmar_order (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)\n+{\n+  int a = pa->myanmar_position();\n+  int b = pb->myanmar_position();\n+\n+  return a < b ? -1 : a == b ? 0 : +1;\n+}\n+\n+\n+\/* Rules from:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/myanmar *\/\n+\n+static void\n+initial_reordering_consonant_syllable (hb_buffer_t *buffer,\n+                                       unsigned int start, unsigned int end)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  unsigned int base = end;\n+  bool has_reph = false;\n+\n+  {\n+    unsigned int limit = start;\n+    if (start + 3 <= end &&\n+        info[start  ].myanmar_category() == OT_Ra &&\n+        info[start+1].myanmar_category() == OT_As &&\n+        info[start+2].myanmar_category() == OT_H)\n+    {\n+      limit += 3;\n+      base = start;\n+      has_reph = true;\n+    }\n+\n+    {\n+      if (!has_reph)\n+        base = limit;\n+\n+      for (unsigned int i = limit; i < end; i++)\n+        if (is_consonant (info[i]))\n+        {\n+          base = i;\n+          break;\n+        }\n+    }\n+  }\n+\n+  \/* Reorder! *\/\n+  {\n+    unsigned int i = start;\n+    for (; i < start + (has_reph ? 3 : 0); i++)\n+      info[i].myanmar_position() = POS_AFTER_MAIN;\n+    for (; i < base; i++)\n+      info[i].myanmar_position() = POS_PRE_C;\n+    if (i < end)\n+    {\n+      info[i].myanmar_position() = POS_BASE_C;\n+      i++;\n+    }\n+    indic_position_t pos = POS_AFTER_MAIN;\n+    \/* The following loop may be ugly, but it implements all of\n+     * Myanmar reordering! *\/\n+    for (; i < end; i++)\n+    {\n+      if (info[i].myanmar_category() == OT_MR) \/* Pre-base reordering *\/\n+      {\n+        info[i].myanmar_position() = POS_PRE_C;\n+        continue;\n+      }\n+      if (info[i].myanmar_position() < POS_BASE_C) \/* Left matra *\/\n+      {\n+        continue;\n+      }\n+      if (info[i].myanmar_category() == OT_VS)\n+      {\n+        info[i].myanmar_position() = info[i - 1].myanmar_position();\n+        continue;\n+      }\n+\n+      if (pos == POS_AFTER_MAIN && info[i].myanmar_category() == OT_VBlw)\n+      {\n+        pos = POS_BELOW_C;\n+        info[i].myanmar_position() = pos;\n+        continue;\n+      }\n+\n+      if (pos == POS_BELOW_C && info[i].myanmar_category() == OT_A)\n+      {\n+        info[i].myanmar_position() = POS_BEFORE_SUB;\n+        continue;\n+      }\n+      if (pos == POS_BELOW_C && info[i].myanmar_category() == OT_VBlw)\n+      {\n+        info[i].myanmar_position() = pos;\n+        continue;\n+      }\n+      if (pos == POS_BELOW_C && info[i].myanmar_category() != OT_A)\n+      {\n+        pos = POS_AFTER_SUB;\n+        info[i].myanmar_position() = pos;\n+        continue;\n+      }\n+      info[i].myanmar_position() = pos;\n+    }\n+  }\n+\n+  \/* Sit tight, rock 'n roll! *\/\n+  buffer->sort (start, end, compare_myanmar_order);\n+}\n+\n+static void\n+initial_reordering_syllable (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                             hb_face_t *face HB_UNUSED,\n+                             hb_buffer_t *buffer,\n+                             unsigned int start, unsigned int end)\n+{\n+  syllable_type_t syllable_type = (syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n+  switch (syllable_type) {\n+\n+    case broken_cluster: \/* We already inserted dotted-circles, so just call the consonant_syllable. *\/\n+    case consonant_syllable:\n+      initial_reordering_consonant_syllable  (buffer, start, end);\n+      break;\n+\n+    case punctuation_cluster:\n+    case non_myanmar_cluster:\n+      break;\n+  }\n+}\n+\n+static inline void\n+insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer)\n+{\n+  \/* Note: This loop is extra overhead, but should not be measurable. *\/\n+  bool has_broken_syllables = false;\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    if ((info[i].syllable() & 0x0F) == broken_cluster)\n+    {\n+      has_broken_syllables = true;\n+      break;\n+    }\n+  if (likely (!has_broken_syllables))\n+    return;\n+\n+\n+  hb_codepoint_t dottedcircle_glyph;\n+  if (!font->get_nominal_glyph (0x25CCu, &dottedcircle_glyph))\n+    return;\n+\n+  hb_glyph_info_t dottedcircle = {0};\n+  dottedcircle.codepoint = 0x25CCu;\n+  set_myanmar_properties (dottedcircle);\n+  dottedcircle.codepoint = dottedcircle_glyph;\n+\n+  buffer->clear_output ();\n+\n+  buffer->idx = 0;\n+  unsigned int last_syllable = 0;\n+  while (buffer->idx < buffer->len && buffer->successful)\n+  {\n+    unsigned int syllable = buffer->cur().syllable();\n+    syllable_type_t syllable_type = (syllable_type_t) (syllable & 0x0F);\n+    if (unlikely (last_syllable != syllable && syllable_type == broken_cluster))\n+    {\n+      last_syllable = syllable;\n+\n+      hb_glyph_info_t ginfo = dottedcircle;\n+      ginfo.cluster = buffer->cur().cluster;\n+      ginfo.mask = buffer->cur().mask;\n+      ginfo.syllable() = buffer->cur().syllable();\n+\n+      buffer->output_info (ginfo);\n+    }\n+    else\n+      buffer->next_glyph ();\n+  }\n+  buffer->swap_buffers ();\n+}\n+\n+static void\n+reorder (const hb_ot_shape_plan_t *plan,\n+         hb_font_t *font,\n+         hb_buffer_t *buffer)\n+{\n+  insert_dotted_circles (plan, font, buffer);\n+\n+  foreach_syllable (buffer, start, end)\n+    initial_reordering_syllable (plan, font->face, buffer, start, end);\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_category);\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, myanmar_position);\n+}\n+\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    info[i].syllable() = 0;\n+}\n+\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar =\n+{\n+  collect_features_myanmar,\n+  override_features_myanmar,\n+  nullptr, \/* data_create *\/\n+  nullptr, \/* data_destroy *\/\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  setup_masks_myanmar,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,\n+  false, \/* fallback_position *\/\n+};\n+\n+\n+\/* Ugly Zawgyi encoding.\n+ * Disable all auto processing.\n+ * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1162 *\/\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_myanmar_zawgyi =\n+{\n+  nullptr, \/* collect_features *\/\n+  nullptr, \/* override_features *\/\n+  nullptr, \/* data_create *\/\n+  nullptr, \/* data_destroy *\/\n+  nullptr, \/* preprocess_text *\/\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_NONE,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  nullptr, \/* setup_masks *\/\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  false, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-myanmar.cc","additions":413,"deletions":0,"binary":false,"changes":413,"status":"added"},{"patch":"@@ -0,0 +1,171 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_MYANMAR_HH\n+#define HB_OT_SHAPE_COMPLEX_MYANMAR_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-shape-complex-indic.hh\"\n+\n+\n+\/* buffer var allocations *\/\n+#define myanmar_category() indic_category() \/* myanmar_category_t *\/\n+#define myanmar_position() indic_position() \/* myanmar_position_t *\/\n+\n+\n+\/* Note: This enum is duplicated in the -machine.rl source file.\n+ * Not sure how to avoid duplication. *\/\n+enum myanmar_category_t {\n+  OT_As  = 18,  \/* Asat *\/\n+  OT_D0  = 20, \/* Digit zero *\/\n+  OT_DB  = OT_N, \/* Dot below *\/\n+  OT_GB  = OT_PLACEHOLDER,\n+  OT_MH  = 21, \/* Various consonant medial types *\/\n+  OT_MR  = 22, \/* Various consonant medial types *\/\n+  OT_MW  = 23, \/* Various consonant medial types *\/\n+  OT_MY  = 24, \/* Various consonant medial types *\/\n+  OT_PT  = 25, \/* Pwo and other tones *\/\n+  OT_VAbv = 26,\n+  OT_VBlw = 27,\n+  OT_VPre = 28,\n+  OT_VPst = 29,\n+  OT_VS   = 30, \/* Variation selectors *\/\n+  OT_P    = 31, \/* Punctuation *\/\n+  OT_D    = 32, \/* Digits except zero *\/\n+};\n+\n+\n+static inline void\n+set_myanmar_properties (hb_glyph_info_t &info)\n+{\n+  hb_codepoint_t u = info.codepoint;\n+  unsigned int type = hb_indic_get_categories (u);\n+  unsigned int cat = type & 0x7Fu;\n+  indic_position_t pos = (indic_position_t) (type >> 8);\n+\n+  \/* Myanmar\n+   * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/myanmar#analyze\n+   *\/\n+  if (unlikely (hb_in_range<hb_codepoint_t> (u, 0xFE00u, 0xFE0Fu)))\n+    cat = OT_VS;\n+\n+  switch (u)\n+  {\n+    case 0x104Eu:\n+      cat = OT_C; \/* The spec says C, IndicSyllableCategory doesn't have. *\/\n+      break;\n+\n+    case 0x002Du: case 0x00A0u: case 0x00D7u: case 0x2012u:\n+    case 0x2013u: case 0x2014u: case 0x2015u: case 0x2022u:\n+    case 0x25CCu: case 0x25FBu: case 0x25FCu: case 0x25FDu:\n+    case 0x25FEu:\n+      cat = OT_GB;\n+      break;\n+\n+    case 0x1004u: case 0x101Bu: case 0x105Au:\n+      cat = OT_Ra;\n+      break;\n+\n+    case 0x1032u: case 0x1036u:\n+      cat = OT_A;\n+      break;\n+\n+    case 0x1039u:\n+      cat = OT_H;\n+      break;\n+\n+    case 0x103Au:\n+      cat = OT_As;\n+      break;\n+\n+    case 0x1041u: case 0x1042u: case 0x1043u: case 0x1044u:\n+    case 0x1045u: case 0x1046u: case 0x1047u: case 0x1048u:\n+    case 0x1049u: case 0x1090u: case 0x1091u: case 0x1092u:\n+    case 0x1093u: case 0x1094u: case 0x1095u: case 0x1096u:\n+    case 0x1097u: case 0x1098u: case 0x1099u:\n+      cat = OT_D;\n+      break;\n+\n+    case 0x1040u:\n+      cat = OT_D; \/* XXX The spec says D0, but Uniscribe doesn't seem to do. *\/\n+      break;\n+\n+    case 0x103Eu: case 0x1060u:\n+      cat = OT_MH;\n+      break;\n+\n+    case 0x103Cu:\n+      cat = OT_MR;\n+      break;\n+\n+    case 0x103Du: case 0x1082u:\n+      cat = OT_MW;\n+      break;\n+\n+    case 0x103Bu: case 0x105Eu: case 0x105Fu:\n+      cat = OT_MY;\n+      break;\n+\n+    case 0x1063u: case 0x1064u: case 0x1069u: case 0x106Au:\n+    case 0x106Bu: case 0x106Cu: case 0x106Du: case 0xAA7Bu:\n+      cat = OT_PT;\n+      break;\n+\n+    case 0x1038u: case 0x1087u: case 0x1088u: case 0x1089u:\n+    case 0x108Au: case 0x108Bu: case 0x108Cu: case 0x108Du:\n+    case 0x108Fu: case 0x109Au: case 0x109Bu: case 0x109Cu:\n+      cat = OT_SM;\n+      break;\n+\n+    case 0x104Au: case 0x104Bu:\n+      cat = OT_P;\n+      break;\n+\n+    case 0xAA74u: case 0xAA75u: case 0xAA76u:\n+      \/* https:\/\/github.com\/roozbehp\/unicode-data\/issues\/3 *\/\n+      cat = OT_C;\n+      break;\n+  }\n+\n+  if (cat == OT_M)\n+  {\n+    switch ((int) pos)\n+    {\n+      case POS_PRE_C:   cat = OT_VPre;\n+                        pos = POS_PRE_M; break;\n+      case POS_ABOVE_C: cat = OT_VAbv;   break;\n+      case POS_BELOW_C: cat = OT_VBlw;   break;\n+      case POS_POST_C:  cat = OT_VPst;   break;\n+    }\n+  }\n+\n+  info.myanmar_category() = cat;\n+  info.myanmar_position() = pos;\n+}\n+\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_MYANMAR_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-myanmar.hh","additions":171,"deletions":0,"binary":false,"changes":171,"status":"added"},{"patch":"@@ -0,0 +1,383 @@\n+\/*\n+ * Copyright © 2010,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex.hh\"\n+\n+\n+\/* Thai \/ Lao shaper *\/\n+\n+\n+\/* PUA shaping *\/\n+\n+\n+enum thai_consonant_type_t\n+{\n+  NC,\n+  AC,\n+  RC,\n+  DC,\n+  NOT_CONSONANT,\n+  NUM_CONSONANT_TYPES = NOT_CONSONANT\n+};\n+\n+static thai_consonant_type_t\n+get_consonant_type (hb_codepoint_t u)\n+{\n+  if (u == 0x0E1Bu || u == 0x0E1Du || u == 0x0E1Fu\/* || u == 0x0E2Cu*\/)\n+    return AC;\n+  if (u == 0x0E0Du || u == 0x0E10u)\n+    return RC;\n+  if (u == 0x0E0Eu || u == 0x0E0Fu)\n+    return DC;\n+  if (hb_in_range<hb_codepoint_t> (u, 0x0E01u, 0x0E2Eu))\n+    return NC;\n+  return NOT_CONSONANT;\n+}\n+\n+\n+enum thai_mark_type_t\n+{\n+  AV,\n+  BV,\n+  T,\n+  NOT_MARK,\n+  NUM_MARK_TYPES = NOT_MARK\n+};\n+\n+static thai_mark_type_t\n+get_mark_type (hb_codepoint_t u)\n+{\n+  if (u == 0x0E31u || hb_in_range<hb_codepoint_t> (u, 0x0E34u, 0x0E37u) ||\n+      u == 0x0E47u || hb_in_range<hb_codepoint_t> (u, 0x0E4Du, 0x0E4Eu))\n+    return AV;\n+  if (hb_in_range<hb_codepoint_t> (u, 0x0E38u, 0x0E3Au))\n+    return BV;\n+  if (hb_in_range<hb_codepoint_t> (u, 0x0E48u, 0x0E4Cu))\n+    return T;\n+  return NOT_MARK;\n+}\n+\n+\n+enum thai_action_t\n+{\n+  NOP,\n+  SD,  \/* Shift combining-mark down *\/\n+  SL,  \/* Shift combining-mark left *\/\n+  SDL, \/* Shift combining-mark down-left *\/\n+  RD   \/* Remove descender from base *\/\n+};\n+\n+static hb_codepoint_t\n+thai_pua_shape (hb_codepoint_t u, thai_action_t action, hb_font_t *font)\n+{\n+  struct thai_pua_mapping_t {\n+    hb_codepoint_t u;\n+    hb_codepoint_t win_pua;\n+    hb_codepoint_t mac_pua;\n+  } const *pua_mappings = nullptr;\n+  static const thai_pua_mapping_t SD_mappings[] = {\n+    {0x0E48u, 0xF70Au, 0xF88Bu}, \/* MAI EK *\/\n+    {0x0E49u, 0xF70Bu, 0xF88Eu}, \/* MAI THO *\/\n+    {0x0E4Au, 0xF70Cu, 0xF891u}, \/* MAI TRI *\/\n+    {0x0E4Bu, 0xF70Du, 0xF894u}, \/* MAI CHATTAWA *\/\n+    {0x0E4Cu, 0xF70Eu, 0xF897u}, \/* THANTHAKHAT *\/\n+    {0x0E38u, 0xF718u, 0xF89Bu}, \/* SARA U *\/\n+    {0x0E39u, 0xF719u, 0xF89Cu}, \/* SARA UU *\/\n+    {0x0E3Au, 0xF71Au, 0xF89Du}, \/* PHINTHU *\/\n+    {0x0000u, 0x0000u, 0x0000u}\n+  };\n+  static const thai_pua_mapping_t SDL_mappings[] = {\n+    {0x0E48u, 0xF705u, 0xF88Cu}, \/* MAI EK *\/\n+    {0x0E49u, 0xF706u, 0xF88Fu}, \/* MAI THO *\/\n+    {0x0E4Au, 0xF707u, 0xF892u}, \/* MAI TRI *\/\n+    {0x0E4Bu, 0xF708u, 0xF895u}, \/* MAI CHATTAWA *\/\n+    {0x0E4Cu, 0xF709u, 0xF898u}, \/* THANTHAKHAT *\/\n+    {0x0000u, 0x0000u, 0x0000u}\n+  };\n+  static const thai_pua_mapping_t SL_mappings[] = {\n+    {0x0E48u, 0xF713u, 0xF88Au}, \/* MAI EK *\/\n+    {0x0E49u, 0xF714u, 0xF88Du}, \/* MAI THO *\/\n+    {0x0E4Au, 0xF715u, 0xF890u}, \/* MAI TRI *\/\n+    {0x0E4Bu, 0xF716u, 0xF893u}, \/* MAI CHATTAWA *\/\n+    {0x0E4Cu, 0xF717u, 0xF896u}, \/* THANTHAKHAT *\/\n+    {0x0E31u, 0xF710u, 0xF884u}, \/* MAI HAN-AKAT *\/\n+    {0x0E34u, 0xF701u, 0xF885u}, \/* SARA I *\/\n+    {0x0E35u, 0xF702u, 0xF886u}, \/* SARA II *\/\n+    {0x0E36u, 0xF703u, 0xF887u}, \/* SARA UE *\/\n+    {0x0E37u, 0xF704u, 0xF888u}, \/* SARA UEE *\/\n+    {0x0E47u, 0xF712u, 0xF889u}, \/* MAITAIKHU *\/\n+    {0x0E4Du, 0xF711u, 0xF899u}, \/* NIKHAHIT *\/\n+    {0x0000u, 0x0000u, 0x0000u}\n+  };\n+  static const thai_pua_mapping_t RD_mappings[] = {\n+    {0x0E0Du, 0xF70Fu, 0xF89Au}, \/* YO YING *\/\n+    {0x0E10u, 0xF700u, 0xF89Eu}, \/* THO THAN *\/\n+    {0x0000u, 0x0000u, 0x0000u}\n+  };\n+\n+  switch (action) {\n+    case NOP: return u;\n+    case SD:  pua_mappings = SD_mappings; break;\n+    case SDL: pua_mappings = SDL_mappings; break;\n+    case SL:  pua_mappings = SL_mappings; break;\n+    case RD:  pua_mappings = RD_mappings; break;\n+  }\n+  for (; pua_mappings->u; pua_mappings++)\n+    if (pua_mappings->u == u)\n+    {\n+      hb_codepoint_t glyph;\n+      if (hb_font_get_glyph (font, pua_mappings->win_pua, 0, &glyph))\n+        return pua_mappings->win_pua;\n+      if (hb_font_get_glyph (font, pua_mappings->mac_pua, 0, &glyph))\n+        return pua_mappings->mac_pua;\n+      break;\n+    }\n+  return u;\n+}\n+\n+\n+static enum thai_above_state_t\n+{     \/* Cluster above looks like: *\/\n+  T0, \/*  ⣤                      *\/\n+  T1, \/*     ⣼                   *\/\n+  T2, \/*        ⣾                *\/\n+  T3, \/*           ⣿             *\/\n+  NUM_ABOVE_STATES\n+} thai_above_start_state[NUM_CONSONANT_TYPES + 1\/* For NOT_CONSONANT *\/] =\n+{\n+  T0, \/* NC *\/\n+  T1, \/* AC *\/\n+  T0, \/* RC *\/\n+  T0, \/* DC *\/\n+  T3, \/* NOT_CONSONANT *\/\n+};\n+\n+static const struct thai_above_state_machine_edge_t {\n+  thai_action_t action;\n+  thai_above_state_t next_state;\n+} thai_above_state_machine[NUM_ABOVE_STATES][NUM_MARK_TYPES] =\n+{        \/*AV*\/    \/*BV*\/    \/*T*\/\n+\/*T0*\/ {{NOP,T3}, {NOP,T0}, {SD, T3}},\n+\/*T1*\/ {{SL, T2}, {NOP,T1}, {SDL,T2}},\n+\/*T2*\/ {{NOP,T3}, {NOP,T2}, {SL, T3}},\n+\/*T3*\/ {{NOP,T3}, {NOP,T3}, {NOP,T3}},\n+};\n+\n+\n+static enum thai_below_state_t\n+{\n+  B0, \/* No descender *\/\n+  B1, \/* Removable descender *\/\n+  B2, \/* Strict descender *\/\n+  NUM_BELOW_STATES\n+} thai_below_start_state[NUM_CONSONANT_TYPES + 1\/* For NOT_CONSONANT *\/] =\n+{\n+  B0, \/* NC *\/\n+  B0, \/* AC *\/\n+  B1, \/* RC *\/\n+  B2, \/* DC *\/\n+  B2, \/* NOT_CONSONANT *\/\n+};\n+\n+static const struct thai_below_state_machine_edge_t {\n+  thai_action_t action;\n+  thai_below_state_t next_state;\n+} thai_below_state_machine[NUM_BELOW_STATES][NUM_MARK_TYPES] =\n+{        \/*AV*\/    \/*BV*\/    \/*T*\/\n+\/*B0*\/ {{NOP,B0}, {NOP,B2}, {NOP, B0}},\n+\/*B1*\/ {{NOP,B1}, {RD, B2}, {NOP, B1}},\n+\/*B2*\/ {{NOP,B2}, {SD, B2}, {NOP, B2}},\n+};\n+\n+\n+static void\n+do_thai_pua_shaping (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                     hb_buffer_t              *buffer,\n+                     hb_font_t                *font)\n+{\n+  thai_above_state_t above_state = thai_above_start_state[NOT_CONSONANT];\n+  thai_below_state_t below_state = thai_below_start_state[NOT_CONSONANT];\n+  unsigned int base = 0;\n+\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    thai_mark_type_t mt = get_mark_type (info[i].codepoint);\n+\n+    if (mt == NOT_MARK) {\n+      thai_consonant_type_t ct = get_consonant_type (info[i].codepoint);\n+      above_state = thai_above_start_state[ct];\n+      below_state = thai_below_start_state[ct];\n+      base = i;\n+      continue;\n+    }\n+\n+    const thai_above_state_machine_edge_t &above_edge = thai_above_state_machine[above_state][mt];\n+    const thai_below_state_machine_edge_t &below_edge = thai_below_state_machine[below_state][mt];\n+    above_state = above_edge.next_state;\n+    below_state = below_edge.next_state;\n+\n+    \/* At least one of the above\/below actions is NOP. *\/\n+    thai_action_t action = above_edge.action != NOP ? above_edge.action : below_edge.action;\n+\n+    buffer->unsafe_to_break (base, i);\n+    if (action == RD)\n+      info[base].codepoint = thai_pua_shape (info[base].codepoint, action, font);\n+    else\n+      info[i].codepoint = thai_pua_shape (info[i].codepoint, action, font);\n+  }\n+}\n+\n+\n+static void\n+preprocess_text_thai (const hb_ot_shape_plan_t *plan,\n+                      hb_buffer_t              *buffer,\n+                      hb_font_t                *font)\n+{\n+  \/* This function implements the shaping logic documented here:\n+   *\n+   *   https:\/\/linux.thai.net\/~thep\/th-otf\/shaping.html\n+   *\n+   * The first shaping rule listed there is needed even if the font has Thai\n+   * OpenType tables.  The rest do fallback positioning based on PUA codepoints.\n+   * We implement that only if there exist no Thai GSUB in the font.\n+   *\/\n+\n+  \/* The following is NOT specified in the MS OT Thai spec, however, it seems\n+   * to be what Uniscribe and other engines implement.  According to Eric Muller:\n+   *\n+   * When you have a SARA AM, decompose it in NIKHAHIT + SARA AA, *and* move the\n+   * NIKHAHIT backwards over any tone mark (0E48-0E4B).\n+   *\n+   * <0E14, 0E4B, 0E33> -> <0E14, 0E4D, 0E4B, 0E32>\n+   *\n+   * This reordering is legit only when the NIKHAHIT comes from a SARA AM, not\n+   * when it's there to start with. The string <0E14, 0E4B, 0E4D> is probably\n+   * not what a user wanted, but the rendering is nevertheless nikhahit above\n+   * chattawa.\n+   *\n+   * Same for Lao.\n+   *\n+   * Note:\n+   *\n+   * Uniscribe also does some below-marks reordering.  Namely, it positions U+0E3A\n+   * after U+0E38 and U+0E39.  We do that by modifying the ccc for U+0E3A.\n+   * See unicode->modified_combining_class ().  Lao does NOT have a U+0E3A\n+   * equivalent.\n+   *\/\n+\n+\n+  \/*\n+   * Here are the characters of significance:\n+   *\n+   *                    Thai    Lao\n+   * SARA AM:           U+0E33  U+0EB3\n+   * SARA AA:           U+0E32  U+0EB2\n+   * Nikhahit:          U+0E4D  U+0ECD\n+   *\n+   * Testing shows that Uniscribe reorder the following marks:\n+   * Thai:      <0E31,0E34..0E37,0E47..0E4E>\n+   * Lao:       <0EB1,0EB4..0EB7,0EC7..0ECE>\n+   *\n+   * Note how the Lao versions are the same as Thai + 0x80.\n+   *\/\n+\n+  \/* We only get one script at a time, so a script-agnostic implementation\n+   * is adequate here. *\/\n+#define IS_SARA_AM(x) (((x) & ~0x0080u) == 0x0E33u)\n+#define NIKHAHIT_FROM_SARA_AM(x) ((x) - 0x0E33u + 0x0E4Du)\n+#define SARA_AA_FROM_SARA_AM(x) ((x) - 1)\n+#define IS_TONE_MARK(x) (hb_in_ranges<hb_codepoint_t> ((x) & ~0x0080u, 0x0E34u, 0x0E37u, 0x0E47u, 0x0E4Eu, 0x0E31u, 0x0E31u))\n+\n+  buffer->clear_output ();\n+  unsigned int count = buffer->len;\n+  for (buffer->idx = 0; buffer->idx < count && buffer->successful;)\n+  {\n+    hb_codepoint_t u = buffer->cur().codepoint;\n+    if (likely (!IS_SARA_AM (u))) {\n+      buffer->next_glyph ();\n+      continue;\n+    }\n+\n+    \/* Is SARA AM. Decompose and reorder. *\/\n+    hb_glyph_info_t &nikhahit = buffer->output_glyph (NIKHAHIT_FROM_SARA_AM (u));\n+    _hb_glyph_info_set_continuation (&nikhahit);\n+    buffer->replace_glyph (SARA_AA_FROM_SARA_AM (u));\n+    if (unlikely (!buffer->successful))\n+      return;\n+\n+    \/* Make Nikhahit be recognized as a ccc=0 mark when zeroing widths. *\/\n+    unsigned int end = buffer->out_len;\n+    _hb_glyph_info_set_general_category (&buffer->out_info[end - 2], HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK);\n+\n+    \/* Ok, let's see... *\/\n+    unsigned int start = end - 2;\n+    while (start > 0 && IS_TONE_MARK (buffer->out_info[start - 1].codepoint))\n+      start--;\n+\n+    if (start + 2 < end)\n+    {\n+      \/* Move Nikhahit (end-2) to the beginning *\/\n+      buffer->merge_out_clusters (start, end);\n+      hb_glyph_info_t t = buffer->out_info[end - 2];\n+      memmove (buffer->out_info + start + 1,\n+               buffer->out_info + start,\n+               sizeof (buffer->out_info[0]) * (end - start - 2));\n+      buffer->out_info[start] = t;\n+    }\n+    else\n+    {\n+      \/* Since we decomposed, and NIKHAHIT is combining, merge clusters with the\n+       * previous cluster. *\/\n+      if (start && buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n+        buffer->merge_out_clusters (start - 1, end);\n+    }\n+  }\n+  buffer->swap_buffers ();\n+\n+  \/* If font has Thai GSUB, we are done. *\/\n+  if (plan->props.script == HB_SCRIPT_THAI && !plan->map.found_script[0])\n+    do_thai_pua_shaping (plan, buffer, font);\n+}\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_thai =\n+{\n+  nullptr, \/* collect_features *\/\n+  nullptr, \/* override_features *\/\n+  nullptr, \/* data_create *\/\n+  nullptr, \/* data_destroy *\/\n+  preprocess_text_thai,\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_DEFAULT,\n+  nullptr, \/* decompose *\/\n+  nullptr, \/* compose *\/\n+  nullptr, \/* setup_masks *\/\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE,\n+  false,\/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-thai.cc","additions":383,"deletions":0,"binary":false,"changes":383,"status":"added"},{"patch":"@@ -0,0 +1,540 @@\n+\n+#line 1 \"hb-ot-shape-complex-use-machine.rl\"\n+\/*\n+ * Copyright © 2015  Mozilla Foundation.\n+ * Copyright © 2015  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Mozilla Author(s): Jonathan Kew\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_USE_MACHINE_HH\n+#define HB_OT_SHAPE_COMPLEX_USE_MACHINE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#line 38 \"hb-ot-shape-complex-use-machine.hh\"\n+static const unsigned char _use_syllable_machine_trans_keys[] = {\n+        12u, 44u, 1u, 15u, 1u, 1u, 12u, 44u, 0u, 44u, 21u, 21u, 8u, 44u, 8u, 44u,\n+        1u, 15u, 1u, 1u, 8u, 44u, 8u, 44u, 8u, 39u, 8u, 26u, 8u, 26u, 8u, 26u,\n+        8u, 39u, 8u, 39u, 8u, 39u, 8u, 44u, 8u, 44u, 8u, 44u, 8u, 44u, 8u, 44u,\n+        8u, 44u, 8u, 44u, 8u, 44u, 1u, 39u, 8u, 44u, 13u, 21u, 4u, 4u, 13u, 13u,\n+        8u, 44u, 8u, 44u, 8u, 44u, 8u, 39u, 8u, 26u, 8u, 26u, 8u, 26u, 8u, 39u,\n+        8u, 39u, 8u, 39u, 8u, 44u, 8u, 44u, 8u, 44u, 8u, 44u, 8u, 44u, 8u, 44u,\n+        8u, 44u, 8u, 44u, 1u, 39u, 1u, 15u, 12u, 44u, 1u, 44u, 8u, 44u, 21u, 42u,\n+        41u, 42u, 42u, 42u, 1u, 5u, 0\n+};\n+\n+static const char _use_syllable_machine_key_spans[] = {\n+        33, 15, 1, 33, 45, 1, 37, 37,\n+        15, 1, 37, 37, 32, 19, 19, 19,\n+        32, 32, 32, 37, 37, 37, 37, 37,\n+        37, 37, 37, 39, 37, 9, 1, 1,\n+        37, 37, 37, 32, 19, 19, 19, 32,\n+        32, 32, 37, 37, 37, 37, 37, 37,\n+        37, 37, 39, 15, 33, 44, 37, 22,\n+        2, 1, 5\n+};\n+\n+static const short _use_syllable_machine_index_offsets[] = {\n+        0, 34, 50, 52, 86, 132, 134, 172,\n+        210, 226, 228, 266, 304, 337, 357, 377,\n+        397, 430, 463, 496, 534, 572, 610, 648,\n+        686, 724, 762, 800, 840, 878, 888, 890,\n+        892, 930, 968, 1006, 1039, 1059, 1079, 1099,\n+        1132, 1165, 1198, 1236, 1274, 1312, 1350, 1388,\n+        1426, 1464, 1502, 1542, 1558, 1592, 1637, 1675,\n+        1698, 1701, 1703\n+};\n+\n+static const char _use_syllable_machine_indicies[] = {\n+        1, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        1, 0, 3, 2, 2, 2, 2, 2,\n+        2, 2, 2, 2, 2, 2, 2, 2,\n+        4, 2, 3, 2, 6, 5, 5, 5,\n+        5, 5, 5, 5, 5, 5, 5, 5,\n+        5, 5, 5, 5, 5, 5, 5, 5,\n+        5, 5, 5, 5, 5, 5, 5, 5,\n+        5, 5, 5, 5, 6, 5, 7, 8,\n+        9, 7, 10, 8, 9, 9, 11, 9,\n+        9, 3, 12, 9, 9, 13, 7, 7,\n+        14, 15, 9, 9, 16, 17, 18, 19,\n+        20, 21, 22, 16, 23, 24, 25, 26,\n+        27, 28, 9, 29, 30, 31, 9, 9,\n+        9, 32, 33, 9, 35, 34, 37, 36,\n+        36, 38, 1, 36, 36, 39, 36, 36,\n+        36, 36, 36, 40, 41, 42, 43, 44,\n+        45, 46, 47, 41, 48, 40, 49, 50,\n+        51, 52, 36, 53, 54, 55, 36, 36,\n+        36, 36, 56, 36, 37, 36, 36, 38,\n+        1, 36, 36, 39, 36, 36, 36, 36,\n+        36, 57, 41, 42, 43, 44, 45, 46,\n+        47, 41, 48, 49, 49, 50, 51, 52,\n+        36, 53, 54, 55, 36, 36, 36, 36,\n+        56, 36, 38, 58, 58, 58, 58, 58,\n+        58, 58, 58, 58, 58, 58, 58, 58,\n+        59, 58, 38, 58, 37, 36, 36, 38,\n+        1, 36, 36, 39, 36, 36, 36, 36,\n+        36, 36, 41, 42, 43, 44, 45, 46,\n+        47, 41, 48, 49, 49, 50, 51, 52,\n+        36, 53, 54, 55, 36, 36, 36, 36,\n+        56, 36, 37, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        41, 42, 43, 44, 45, 36, 36, 36,\n+        36, 36, 36, 50, 51, 52, 36, 53,\n+        54, 55, 36, 36, 36, 36, 42, 36,\n+        37, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 42,\n+        43, 44, 45, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 53, 54, 55,\n+        36, 37, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 43, 44, 45, 36, 37, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 44, 45,\n+        36, 37, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 45, 36, 37, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 43, 44, 45,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 53, 54, 55, 36, 37, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 43, 44,\n+        45, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 54, 55, 36, 37,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 43,\n+        44, 45, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 55, 36,\n+        37, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 42,\n+        43, 44, 45, 36, 36, 36, 36, 36,\n+        36, 50, 51, 52, 36, 53, 54, 55,\n+        36, 36, 36, 36, 42, 36, 37, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 42, 43, 44,\n+        45, 36, 36, 36, 36, 36, 36, 36,\n+        51, 52, 36, 53, 54, 55, 36, 36,\n+        36, 36, 42, 36, 37, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 42, 43, 44, 45, 36,\n+        36, 36, 36, 36, 36, 36, 36, 52,\n+        36, 53, 54, 55, 36, 36, 36, 36,\n+        42, 36, 37, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        41, 42, 43, 44, 45, 36, 47, 41,\n+        36, 36, 36, 50, 51, 52, 36, 53,\n+        54, 55, 36, 36, 36, 36, 42, 36,\n+        37, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 41, 42,\n+        43, 44, 45, 36, 60, 41, 36, 36,\n+        36, 50, 51, 52, 36, 53, 54, 55,\n+        36, 36, 36, 36, 42, 36, 37, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 36, 36, 41, 42, 43, 44,\n+        45, 36, 36, 41, 36, 36, 36, 50,\n+        51, 52, 36, 53, 54, 55, 36, 36,\n+        36, 36, 42, 36, 37, 36, 36, 36,\n+        36, 36, 36, 36, 36, 36, 36, 36,\n+        36, 36, 41, 42, 43, 44, 45, 46,\n+        47, 41, 36, 36, 36, 50, 51, 52,\n+        36, 53, 54, 55, 36, 36, 36, 36,\n+        42, 36, 37, 36, 36, 38, 1, 36,\n+        36, 39, 36, 36, 36, 36, 36, 36,\n+        41, 42, 43, 44, 45, 46, 47, 41,\n+        48, 36, 49, 50, 51, 52, 36, 53,\n+        54, 55, 36, 36, 36, 36, 56, 36,\n+        38, 58, 58, 58, 58, 58, 58, 37,\n+        58, 58, 58, 58, 58, 58, 59, 58,\n+        58, 58, 58, 58, 58, 58, 42, 43,\n+        44, 45, 58, 58, 58, 58, 58, 58,\n+        58, 58, 58, 58, 53, 54, 55, 58,\n+        37, 36, 36, 38, 1, 36, 36, 39,\n+        36, 36, 36, 36, 36, 36, 41, 42,\n+        43, 44, 45, 46, 47, 41, 48, 40,\n+        49, 50, 51, 52, 36, 53, 54, 55,\n+        36, 36, 36, 36, 56, 36, 62, 61,\n+        61, 61, 61, 61, 61, 61, 63, 61,\n+        10, 64, 62, 61, 11, 65, 65, 3,\n+        6, 65, 65, 66, 65, 65, 65, 65,\n+        65, 67, 16, 17, 18, 19, 20, 21,\n+        22, 16, 23, 25, 25, 26, 27, 28,\n+        65, 29, 30, 31, 65, 65, 65, 65,\n+        33, 65, 11, 65, 65, 3, 6, 65,\n+        65, 66, 65, 65, 65, 65, 65, 65,\n+        16, 17, 18, 19, 20, 21, 22, 16,\n+        23, 25, 25, 26, 27, 28, 65, 29,\n+        30, 31, 65, 65, 65, 65, 33, 65,\n+        11, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 16, 17,\n+        18, 19, 20, 65, 65, 65, 65, 65,\n+        65, 26, 27, 28, 65, 29, 30, 31,\n+        65, 65, 65, 65, 17, 65, 11, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 17, 18, 19,\n+        20, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 29, 30, 31, 65, 11,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 18,\n+        19, 20, 65, 11, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 19, 20, 65, 11,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 20, 65, 11, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 18, 19, 20, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        29, 30, 31, 65, 11, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 18, 19, 20, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 30, 31, 65, 11, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 18, 19, 20,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 31, 65, 11, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 17, 18, 19,\n+        20, 65, 65, 65, 65, 65, 65, 26,\n+        27, 28, 65, 29, 30, 31, 65, 65,\n+        65, 65, 17, 65, 11, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 17, 18, 19, 20, 65,\n+        65, 65, 65, 65, 65, 65, 27, 28,\n+        65, 29, 30, 31, 65, 65, 65, 65,\n+        17, 65, 11, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 17, 18, 19, 20, 65, 65, 65,\n+        65, 65, 65, 65, 65, 28, 65, 29,\n+        30, 31, 65, 65, 65, 65, 17, 65,\n+        11, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 16, 17,\n+        18, 19, 20, 65, 22, 16, 65, 65,\n+        65, 26, 27, 28, 65, 29, 30, 31,\n+        65, 65, 65, 65, 17, 65, 11, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 16, 17, 18, 19,\n+        20, 65, 68, 16, 65, 65, 65, 26,\n+        27, 28, 65, 29, 30, 31, 65, 65,\n+        65, 65, 17, 65, 11, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 16, 17, 18, 19, 20, 65,\n+        65, 16, 65, 65, 65, 26, 27, 28,\n+        65, 29, 30, 31, 65, 65, 65, 65,\n+        17, 65, 11, 65, 65, 65, 65, 65,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        16, 17, 18, 19, 20, 21, 22, 16,\n+        65, 65, 65, 26, 27, 28, 65, 29,\n+        30, 31, 65, 65, 65, 65, 17, 65,\n+        11, 65, 65, 3, 6, 65, 65, 66,\n+        65, 65, 65, 65, 65, 65, 16, 17,\n+        18, 19, 20, 21, 22, 16, 23, 65,\n+        25, 26, 27, 28, 65, 29, 30, 31,\n+        65, 65, 65, 65, 33, 65, 3, 65,\n+        65, 65, 65, 65, 65, 11, 65, 65,\n+        65, 65, 65, 65, 4, 65, 65, 65,\n+        65, 65, 65, 65, 17, 18, 19, 20,\n+        65, 65, 65, 65, 65, 65, 65, 65,\n+        65, 65, 29, 30, 31, 65, 3, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 4, 69, 6, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 69, 69,\n+        69, 69, 69, 69, 69, 69, 6, 69,\n+        8, 65, 65, 65, 8, 65, 65, 11,\n+        65, 65, 3, 6, 65, 65, 66, 65,\n+        65, 65, 65, 65, 65, 16, 17, 18,\n+        19, 20, 21, 22, 16, 23, 24, 25,\n+        26, 27, 28, 65, 29, 30, 31, 65,\n+        65, 65, 65, 33, 65, 11, 65, 65,\n+        3, 6, 65, 65, 66, 65, 65, 65,\n+        65, 65, 65, 16, 17, 18, 19, 20,\n+        21, 22, 16, 23, 24, 25, 26, 27,\n+        28, 65, 29, 30, 31, 65, 65, 65,\n+        65, 33, 65, 71, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 70,\n+        70, 70, 70, 70, 70, 70, 70, 71,\n+        72, 70, 71, 72, 70, 72, 70, 8,\n+        69, 69, 69, 8, 69, 0\n+};\n+\n+static const char _use_syllable_machine_trans_targs[] = {\n+        4, 8, 4, 32, 2, 4, 1, 5,\n+        6, 4, 29, 4, 51, 52, 53, 55,\n+        34, 35, 36, 37, 38, 45, 46, 48,\n+        54, 49, 42, 43, 44, 39, 40, 41,\n+        58, 50, 4, 4, 4, 4, 7, 0,\n+        28, 11, 12, 13, 14, 15, 22, 23,\n+        25, 26, 19, 20, 21, 16, 17, 18,\n+        27, 10, 4, 9, 24, 4, 30, 31,\n+        4, 4, 3, 33, 47, 4, 4, 56,\n+        57\n+};\n+\n+static const char _use_syllable_machine_trans_actions[] = {\n+        1, 0, 2, 3, 0, 4, 0, 0,\n+        7, 8, 0, 9, 10, 10, 3, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        3, 3, 0, 0, 0, 0, 0, 0,\n+        0, 3, 11, 12, 13, 14, 7, 0,\n+        7, 0, 0, 0, 0, 0, 0, 0,\n+        0, 7, 0, 0, 0, 0, 0, 0,\n+        0, 7, 15, 0, 0, 16, 0, 0,\n+        17, 18, 0, 3, 0, 19, 20, 0,\n+        0\n+};\n+\n+static const char _use_syllable_machine_to_state_actions[] = {\n+        0, 0, 0, 0, 5, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0\n+};\n+\n+static const char _use_syllable_machine_from_state_actions[] = {\n+        0, 0, 0, 0, 6, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0, 0, 0, 0, 0, 0,\n+        0, 0, 0\n+};\n+\n+static const short _use_syllable_machine_eof_trans[] = {\n+        1, 3, 3, 6, 0, 35, 37, 37,\n+        59, 59, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 37, 37, 37, 37, 37,\n+        37, 37, 37, 59, 37, 62, 65, 62,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 66, 66, 66, 66, 66,\n+        66, 66, 66, 70, 70, 66, 66, 71,\n+        71, 71, 70\n+};\n+\n+static const int use_syllable_machine_start = 4;\n+static const int use_syllable_machine_first_final = 4;\n+static const int use_syllable_machine_error = -1;\n+\n+static const int use_syllable_machine_en_main = 4;\n+\n+\n+#line 38 \"hb-ot-shape-complex-use-machine.rl\"\n+\n+\n+\n+#line 143 \"hb-ot-shape-complex-use-machine.rl\"\n+\n+\n+#define found_syllable(syllable_type) \\\n+  HB_STMT_START { \\\n+    if (0) fprintf (stderr, \"syllable %d..%d %s\\n\", ts, te, #syllable_type); \\\n+    for (unsigned int i = ts; i < te; i++) \\\n+      info[i].syllable() = (syllable_serial << 4) | syllable_type; \\\n+    syllable_serial++; \\\n+    if (unlikely (syllable_serial == 16)) syllable_serial = 1; \\\n+  } HB_STMT_END\n+\n+static void\n+find_syllables (hb_buffer_t *buffer)\n+{\n+  unsigned int p, pe, eof, ts, te, act;\n+  int cs;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#line 378 \"hb-ot-shape-complex-use-machine.hh\"\n+        {\n+        cs = use_syllable_machine_start;\n+        ts = 0;\n+        te = 0;\n+        act = 0;\n+        }\n+\n+#line 163 \"hb-ot-shape-complex-use-machine.rl\"\n+\n+\n+  p = 0;\n+  pe = eof = buffer->len;\n+\n+  unsigned int syllable_serial = 1;\n+\n+#line 394 \"hb-ot-shape-complex-use-machine.hh\"\n+        {\n+        int _slen;\n+        int _trans;\n+        const unsigned char *_keys;\n+        const char *_inds;\n+        if ( p == pe )\n+                goto _test_eof;\n+_resume:\n+        switch ( _use_syllable_machine_from_state_actions[cs] ) {\n+        case 6:\n+#line 1 \"NONE\"\n+        {ts = p;}\n+        break;\n+#line 408 \"hb-ot-shape-complex-use-machine.hh\"\n+        }\n+\n+        _keys = _use_syllable_machine_trans_keys + (cs<<1);\n+        _inds = _use_syllable_machine_indicies + _use_syllable_machine_index_offsets[cs];\n+\n+        _slen = _use_syllable_machine_key_spans[cs];\n+        _trans = _inds[ _slen > 0 && _keys[0] <=( info[p].use_category()) &&\n+                ( info[p].use_category()) <= _keys[1] ?\n+                ( info[p].use_category()) - _keys[0] : _slen ];\n+\n+_eof_trans:\n+        cs = _use_syllable_machine_trans_targs[_trans];\n+\n+        if ( _use_syllable_machine_trans_actions[_trans] == 0 )\n+                goto _again;\n+\n+        switch ( _use_syllable_machine_trans_actions[_trans] ) {\n+        case 7:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+        break;\n+        case 12:\n+#line 132 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p+1;{ found_syllable (independent_cluster); }}\n+        break;\n+        case 14:\n+#line 134 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p+1;{ found_syllable (standard_cluster); }}\n+        break;\n+        case 9:\n+#line 138 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p+1;{ found_syllable (broken_cluster); }}\n+        break;\n+        case 8:\n+#line 139 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p+1;{ found_syllable (non_cluster); }}\n+        break;\n+        case 11:\n+#line 132 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (independent_cluster); }}\n+        break;\n+        case 15:\n+#line 133 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (virama_terminated_cluster); }}\n+        break;\n+        case 13:\n+#line 134 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (standard_cluster); }}\n+        break;\n+        case 17:\n+#line 135 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (number_joiner_terminated_cluster); }}\n+        break;\n+        case 16:\n+#line 136 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (numeral_cluster); }}\n+        break;\n+        case 20:\n+#line 137 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (symbol_cluster); }}\n+        break;\n+        case 18:\n+#line 138 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (broken_cluster); }}\n+        break;\n+        case 19:\n+#line 139 \"hb-ot-shape-complex-use-machine.rl\"\n+        {te = p;p--;{ found_syllable (non_cluster); }}\n+        break;\n+        case 1:\n+#line 134 \"hb-ot-shape-complex-use-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (standard_cluster); }}\n+        break;\n+        case 4:\n+#line 138 \"hb-ot-shape-complex-use-machine.rl\"\n+        {{p = ((te))-1;}{ found_syllable (broken_cluster); }}\n+        break;\n+        case 2:\n+#line 1 \"NONE\"\n+        {       switch( act ) {\n+        case 7:\n+        {{p = ((te))-1;} found_syllable (broken_cluster); }\n+        break;\n+        case 8:\n+        {{p = ((te))-1;} found_syllable (non_cluster); }\n+        break;\n+        }\n+        }\n+        break;\n+        case 3:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 138 \"hb-ot-shape-complex-use-machine.rl\"\n+        {act = 7;}\n+        break;\n+        case 10:\n+#line 1 \"NONE\"\n+        {te = p+1;}\n+#line 139 \"hb-ot-shape-complex-use-machine.rl\"\n+        {act = 8;}\n+        break;\n+#line 510 \"hb-ot-shape-complex-use-machine.hh\"\n+        }\n+\n+_again:\n+        switch ( _use_syllable_machine_to_state_actions[cs] ) {\n+        case 5:\n+#line 1 \"NONE\"\n+        {ts = 0;}\n+        break;\n+#line 519 \"hb-ot-shape-complex-use-machine.hh\"\n+        }\n+\n+        if ( ++p != pe )\n+                goto _resume;\n+        _test_eof: {}\n+        if ( p == eof )\n+        {\n+        if ( _use_syllable_machine_eof_trans[cs] > 0 ) {\n+                _trans = _use_syllable_machine_eof_trans[cs] - 1;\n+                goto _eof_trans;\n+        }\n+        }\n+\n+        }\n+\n+#line 171 \"hb-ot-shape-complex-use-machine.rl\"\n+\n+}\n+\n+#undef found_syllable\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_USE_MACHINE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-use-machine.hh","additions":540,"deletions":0,"binary":false,"changes":540,"status":"added"},{"patch":"@@ -0,0 +1,839 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-use-table.py IndicSyllabicCategory.txt IndicPositionalCategory.txt UnicodeData.txt Blocks.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # IndicSyllabicCategory-11.0.0.txt\n+ * # Date: 2018-05-21, 18:33:00 GMT [KW, RP]\n+ * # IndicPositionalCategory-11.0.0.txt\n+ * # Date: 2018-02-05, 16:21:00 GMT [KW, RP]\n+ * # Blocks-11.0.0.txt\n+ * # Date: 2017-10-16, 24:39:00 GMT [KW]\n+ * UnicodeData.txt does not have a header.\n+ *\/\n+\n+#include \"hb-ot-shape-complex-use.hh\"\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-macros\"\n+#define B       USE_B   \/* BASE *\/\n+#define CGJ     USE_CGJ \/* CGJ *\/\n+#define CS      USE_CS  \/* CONS_WITH_STACKER *\/\n+#define FM      USE_FM  \/* CONS_FINAL_MOD *\/\n+#define GB      USE_GB  \/* BASE_OTHER *\/\n+#define H       USE_H   \/* HALANT *\/\n+#define HN      USE_HN  \/* HALANT_NUM *\/\n+#define HVM     USE_HVM \/* HALANT_OR_VOWEL_MODIFIER *\/\n+#define IND     USE_IND \/* BASE_IND *\/\n+#define N       USE_N   \/* BASE_NUM *\/\n+#define O       USE_O   \/* OTHER *\/\n+#define R       USE_R   \/* REPHA *\/\n+#define Rsv     USE_Rsv \/* Reserved *\/\n+#define S       USE_S   \/* SYM *\/\n+#define SUB     USE_SUB \/* CONS_SUB *\/\n+#define VS      USE_VS  \/* VARIATION_SELECTOR *\/\n+#define WJ      USE_WJ  \/* Word_Joiner *\/\n+#define ZWJ     USE_ZWJ \/* ZWJ *\/\n+#define ZWNJ    USE_ZWNJ        \/* ZWNJ *\/\n+#define CMBlw   USE_CMBlw\n+#define CMAbv   USE_CMAbv\n+#define FBlw    USE_FBlw\n+#define FPst    USE_FPst\n+#define FAbv    USE_FAbv\n+#define MPre    USE_MPre\n+#define MBlw    USE_MBlw\n+#define MPst    USE_MPst\n+#define MAbv    USE_MAbv\n+#define SMBlw   USE_SMBlw\n+#define SMAbv   USE_SMAbv\n+#define VPre    USE_VPre\n+#define VBlw    USE_VBlw\n+#define VPst    USE_VPst\n+#define VAbv    USE_VAbv\n+#define VMPre   USE_VMPre\n+#define VMBlw   USE_VMBlw\n+#define VMPst   USE_VMPst\n+#define VMAbv   USE_VMAbv\n+#pragma GCC diagnostic pop\n+\n+static const USE_TABLE_ELEMENT_TYPE use_table[] = {\n+\n+\n+#define use_offset_0x0028u 0\n+\n+\n+  \/* Basic Latin *\/\n+                                                                         O,     O,     O,     O,     O,    GB,     O,     O,\n+  \/* 0030 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x00a0u 24\n+\n+\n+  \/* Latin-1 Supplement *\/\n+\n+  \/* 00A0 *\/    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 00B0 *\/     O,     O,    FM,    FM,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 00C0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 00D0 *\/     O,     O,     O,     O,     O,     O,     O,    GB,\n+\n+#define use_offset_0x0348u 80\n+\n+\n+  \/* Combining Diacritical Marks *\/\n+                                                                         O,     O,     O,     O,     O,     O,     O,   CGJ,\n+\n+#define use_offset_0x0900u 88\n+\n+\n+  \/* Devanagari *\/\n+\n+  \/* 0900 *\/ VMAbv, VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0920 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VPst, CMBlw,     B,  VPst,  VPre,\n+  \/* 0940 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VPst,     H,  VPre,  VPst,\n+  \/* 0950 *\/     O, VMAbv, VMBlw,     O,     O,  VAbv,  VBlw,  VBlw,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0960 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0970 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+\n+  \/* Bengali *\/\n+\n+  \/* 0980 *\/    GB, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,\n+  \/* 0990 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 09A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 09B0 *\/     B,     O,     B,     O,     O,     O,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VPre,\n+  \/* 09C0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,  VPre,  VPre,     O,     O,  VPst,  VPst,     H,   IND,     O,\n+  \/* 09D0 *\/     O,     O,     O,     O,     O,     O,     O,  VPst,     O,     O,     O,     O,     B,     B,     O,     B,\n+  \/* 09E0 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 09F0 *\/     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,     O,    FM,     O,\n+\n+  \/* Gurmukhi *\/\n+\n+  \/* 0A00 *\/     O, VMAbv, VMAbv, VMPst,     O,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     B,\n+  \/* 0A10 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 0A30 *\/     B,     O,     B,     B,     O,     B,     B,     O,     B,     B,     O,     O, CMBlw,     O,  VPst,  VPre,\n+  \/* 0A40 *\/  VPst,  VBlw,  VBlw,     O,     O,     O,     O,  VAbv,  VAbv,     O,     O,  VAbv,  VAbv,     H,     O,     O,\n+  \/* 0A50 *\/     O, VMBlw,     O,     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     O,     B,     O,\n+  \/* 0A60 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0A70 *\/ VMAbv, CMAbv,    GB,    GB,     O,  MBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Gujarati *\/\n+\n+  \/* 0A80 *\/     O, VMAbv, VMAbv, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,\n+  \/* 0A90 *\/     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0AA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 0AB0 *\/     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VPre,\n+  \/* 0AC0 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,     O,  VAbv,  VAbv,  VAbv,     O,  VPst,  VPst,     H,     O,     O,\n+  \/* 0AD0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 0AE0 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0AF0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     B, VMAbv, VMAbv, VMAbv, CMAbv, CMAbv, CMAbv,\n+\n+  \/* Oriya *\/\n+\n+  \/* 0B00 *\/     O, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,\n+  \/* 0B10 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 0B30 *\/     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VAbv,\n+  \/* 0B40 *\/  VPst,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,  VPre,  VPst,     O,     O,  VPst,  VPst,     H,     O,     O,\n+  \/* 0B50 *\/     O,     O,     O,     O,     O,     O,  VAbv,  VAbv,     O,     O,     O,     O,     B,     B,     O,     B,\n+  \/* 0B60 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0B70 *\/     O,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Tamil *\/\n+\n+  \/* 0B80 *\/     O,     O, VMAbv,   IND,     O,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,     B,\n+  \/* 0B90 *\/     B,     O,     B,     B,     B,     B,     O,     O,     O,     B,     B,     O,     B,     O,     B,     B,\n+  \/* 0BA0 *\/     O,     O,     O,     B,     B,     O,     O,     O,     B,     B,     B,     O,     O,     O,     B,     B,\n+  \/* 0BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,  VPst,  VPst,\n+  \/* 0BC0 *\/  VAbv,  VPst,  VPst,     O,     O,     O,  VPre,  VPre,  VPre,     O,  VPst,  VPst,  VPst,     H,     O,     O,\n+  \/* 0BD0 *\/     O,     O,     O,     O,     O,     O,     O,  VPst,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 0BE0 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0BF0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Telugu *\/\n+\n+  \/* 0C00 *\/ VMAbv, VMPst, VMPst, VMPst, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n+  \/* 0C10 *\/     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 0C30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,  VAbv,  VAbv,\n+  \/* 0C40 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,     O,  VAbv,  VAbv,  VAbv,     O,  VAbv,  VAbv,  VAbv,     H,     O,     O,\n+  \/* 0C50 *\/     O,     O,     O,     O,     O,  VAbv,  VBlw,     O,     B,     B,     B,     O,     O,     O,     O,     O,\n+  \/* 0C60 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0C70 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Kannada *\/\n+\n+  \/* 0C80 *\/     O, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n+  \/* 0C90 *\/     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0CA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 0CB0 *\/     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     O,     O, CMBlw,     B,  VPst,  VAbv,\n+  \/* 0CC0 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,     O,  VAbv,  VAbv,  VAbv,     O,  VAbv,  VAbv,  VAbv,     H,     O,     O,\n+  \/* 0CD0 *\/     O,     O,     O,     O,     O,  VPst,  VPst,     O,     O,     O,     O,     O,     O,     O,     B,     O,\n+  \/* 0CE0 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0CF0 *\/     O,    CS,    CS,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Malayalam *\/\n+\n+  \/* 0D00 *\/ VMAbv, VMAbv, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n+  \/* 0D10 *\/     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,     B,  VPst,  VPst,\n+  \/* 0D40 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,     O,  VPre,  VPre,  VPre,     O,  VPst,  VPst,  VPst,     H,     R,     O,\n+  \/* 0D50 *\/     O,     O,     O,     O,   IND,   IND,   IND,  VPst,     O,     O,     O,     O,     O,     O,     O,     B,\n+  \/* 0D60 *\/     B,     B,  VBlw,  VBlw,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D70 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,   IND,   IND,   IND,   IND,   IND,   IND,\n+\n+  \/* Sinhala *\/\n+\n+  \/* 0D80 *\/     O,     O, VMPst, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0D90 *\/     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 0DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0DB0 *\/     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     O,     O,\n+  \/* 0DC0 *\/     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     H,     O,     O,     O,     O,  VPst,\n+  \/* 0DD0 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,     O,  VBlw,     O,  VPst,  VPre,  VPst,  VPre,  VPst,  VPst,  VPst,  VPst,\n+  \/* 0DE0 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0DF0 *\/     O,     O,  VPst,  VPst,     O,     O,     O,     O,\n+\n+#define use_offset_0x0f18u 1360\n+\n+\n+  \/* Tibetan *\/\n+                                                                      VBlw,  VBlw,     O,     O,     O,     O,     O,     O,\n+  \/* 0F20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0F30 *\/     B,     B,     B,     B,     O,    FM,     O,    FM,     O, CMAbv,     O,     O,     O,     O,  VPst,  VPre,\n+  \/* 0F40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0F50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 0F60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,\n+  \/* 0F70 *\/     O,  VBlw,  VBlw,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw, VMAbv, VMPst,\n+  \/* 0F80 *\/  VBlw,  VAbv, VMAbv, VMAbv,  VBlw,   IND, VMAbv, VMAbv,     B,     B,     B,     B,     B,   SUB,   SUB,   SUB,\n+  \/* 0F90 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,     O,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 0FA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 0FB0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,     O,     O,     O,\n+  \/* 0FC0 *\/     O,     O,     O,     O,     O,     O,    FM,     O,\n+\n+#define use_offset_0x1000u 1536\n+\n+\n+  \/* Myanmar *\/\n+\n+  \/* 1000 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VAbv,  VAbv,  VBlw,\n+  \/* 1030 *\/  VBlw,  VPre,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMBlw, VMPst,     H,  VAbv,  MPst,  MPre,  MBlw,  MBlw,     B,\n+  \/* 1040 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,    GB,     O,     O,    GB,     O,\n+  \/* 1050 *\/     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VBlw,  VBlw,     B,     B,     B,     B,  MBlw,  MBlw,\n+  \/* 1060 *\/  MBlw,     B,  VPst, VMPst, VMPst,     B,     B,  VPst,  VPst, VMPst, VMPst, VMPst, VMPst, VMPst,     B,     B,\n+  \/* 1070 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1080 *\/     B,     B,  MBlw,  VPst,  VPre,  VAbv,  VAbv, VMPst, VMPst, VMPst, VMPst, VMPst, VMPst, VMBlw,     B, VMPst,\n+  \/* 1090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,  VPst,  VAbv,     O,     O,\n+\n+#define use_offset_0x1700u 1696\n+\n+\n+  \/* Tagalog *\/\n+\n+  \/* 1700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n+  \/* 1710 *\/     B,     B,  VAbv,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Hanunoo *\/\n+\n+  \/* 1720 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1730 *\/     B,     B,  VAbv,  VBlw,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Buhid *\/\n+\n+  \/* 1740 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1750 *\/     B,     B,  VAbv,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Tagbanwa *\/\n+\n+  \/* 1760 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,\n+  \/* 1770 *\/     B,     O,  VAbv,  VBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Khmer *\/\n+\n+  \/* 1780 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1790 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 17A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 17B0 *\/     B,     B,     B,     B,     O,     O,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VPst,  VPst,\n+  \/* 17C0 *\/  VPst,  VPre,  VPre,  VPre,  VPst,  VPst, VMAbv, VMPst,  VPst, VMAbv, VMAbv,    FM,  FAbv, CMAbv,    FM,    FM,\n+  \/* 17D0 *\/    FM,  VAbv,     H,    FM,     O,     O,     O,     O,     O,     O,     O,     O,     B,  VAbv,     O,     O,\n+  \/* 17E0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x1900u 1936\n+\n+\n+  \/* Limbu *\/\n+\n+  \/* 1900 *\/    GB,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,\n+  \/* 1920 *\/  VAbv,  VAbv,  VBlw,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,   SUB,   SUB,   SUB,     O,     O,     O,     O,\n+  \/* 1930 *\/  FPst,  FPst, VMBlw,  FPst,  FPst,  FPst,  FPst,  FPst,  FPst,  FBlw,  VAbv,    FM,     O,     O,     O,     O,\n+  \/* 1940 *\/     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+\n+  \/* Tai Le *\/\n+\n+  \/* 1950 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1960 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,\n+  \/* 1970 *\/     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* New Tai Lue *\/\n+\n+  \/* 1980 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 19A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n+  \/* 19B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 19C0 *\/     B,     B,     B,     B,     B,     B,     B,     B, VMPst, VMPst,     O,     O,     O,     O,     O,     O,\n+  \/* 19D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+  \/* 19E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 19F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Buginese *\/\n+\n+  \/* 1A00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A10 *\/     B,     B,     B,     B,     B,     B,     B,  VAbv,  VBlw,  VPre,  VPst,  VAbv,     O,     O,     O,     O,\n+\n+  \/* Tai Tham *\/\n+\n+  \/* 1A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A30 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1A50 *\/     B,     B,     B,     B,     B,  MPre,  MBlw,   SUB,  FAbv,  FAbv,  FAbv,   SUB,   SUB,   SUB,   SUB,     O,\n+  \/* 1A60 *\/     H,  VPst,  VAbv,  VPst,  VPst,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VAbv,  VBlw,  VPst,  VPre,  VPre,\n+  \/* 1A70 *\/  VPre,  VPre,  VPre,  VAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,  VAbv,    FM,    FM,     O,     O,  FBlw,\n+  \/* 1A80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+  \/* 1A90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x1b00u 2352\n+\n+\n+  \/* Balinese *\/\n+\n+  \/* 1B00 *\/ VMAbv, VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B30 *\/     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VPre,\n+  \/* 1B40 *\/  VPst,  VPst,  VAbv,  VAbv,     H,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n+  \/* 1B50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+  \/* 1B60 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O, SMAbv, SMBlw, SMAbv, SMAbv, SMAbv,\n+  \/* 1B70 *\/ SMAbv, SMAbv, SMAbv, SMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Sundanese *\/\n+\n+  \/* 1B80 *\/ VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1B90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BA0 *\/     B,   SUB,   SUB,   SUB,  VAbv,  VBlw,  VPre,  VPst,  VAbv,  VAbv,  VPst,     H,   SUB,   SUB,     B,     B,\n+  \/* 1BB0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+\n+  \/* Batak *\/\n+\n+  \/* 1BC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1BE0 *\/     B,     B,     B,     B,     B,     B, CMAbv,  VPst,  VAbv,  VAbv,  VPst,  VPst,  VPst,  VAbv,  VPst,  VAbv,\n+  \/* 1BF0 *\/  FAbv,  FAbv, CMBlw, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Lepcha *\/\n+\n+  \/* 1C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 1C20 *\/     B,     B,     B,     B,   SUB,   SUB,  VPst,  VPre,  VPre,  VPst,  VPst,  VPst,  VBlw,  FAbv,  FAbv,  FAbv,\n+  \/* 1C30 *\/  FAbv,  FAbv,  FAbv,  FAbv, VMPre, VMPre,    FM, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 1C40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     B,     B,     B,\n+\n+#define use_offset_0x1cd0u 2688\n+\n+\n+  \/* Vedic Extensions *\/\n+\n+  \/* 1CD0 *\/ VMAbv, VMAbv, VMAbv,     O, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMAbv, VMAbv, VMBlw, VMBlw, VMBlw, VMBlw,\n+  \/* 1CE0 *\/ VMAbv, VMPst, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw, VMBlw,     O,     O,     O,     O, VMBlw,     O,     O,\n+  \/* 1CF0 *\/     O,     O, VMPst, VMPst, VMAbv,    CS,    CS, VMPst, VMAbv, VMAbv,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x1df8u 2736\n+\n+\n+  \/* Combining Diacritical Marks Supplement *\/\n+                                                                         O,     O,     O,    FM,     O,     O,     O,     O,\n+\n+#define use_offset_0x2008u 2744\n+\n+\n+  \/* General Punctuation *\/\n+                                                                         O,     O,     O,     O,  ZWNJ,   ZWJ,     O,     O,\n+  \/* 2010 *\/    GB,    GB,    GB,    GB,    GB,     O,     O,     O,\n+\n+#define use_offset_0x2060u 2760\n+\n+  \/* 2060 *\/    WJ,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Superscripts and Subscripts *\/\n+\n+  \/* 2070 *\/     O,     O,     O,     O,    FM,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 2080 *\/     O,     O,    FM,    FM,    FM,     O,     O,     O,\n+\n+#define use_offset_0x20f0u 2800\n+\n+\n+  \/* Combining Diacritical Marks for Symbols *\/\n+\n+  \/* 20F0 *\/ VMAbv,     O,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x25c8u 2808\n+\n+\n+  \/* Geometric Shapes *\/\n+                                                                         O,     O,     O,     O,    GB,     O,     O,     O,\n+\n+#define use_offset_0xa800u 2816\n+\n+\n+  \/* Syloti Nagri *\/\n+\n+  \/* A800 *\/     B,     B,     O,     B,     B,     B,  VAbv,     B,     B,     B,     B, VMAbv,     B,     B,     B,     B,\n+  \/* A810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A820 *\/     B,     B,     B,  VPst,  VPst,  VBlw,  VAbv,  VPst,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* A830 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Phags-pa *\/\n+\n+  \/* A840 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A850 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A860 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A870 *\/     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Saurashtra *\/\n+\n+  \/* A880 *\/ VMPst, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A890 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A8A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A8B0 *\/     B,     B,     B,     B,  MPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,  VPst,\n+  \/* A8C0 *\/  VPst,  VPst,  VPst,  VPst,     H, VMAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* A8D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Devanagari Extended *\/\n+\n+  \/* A8E0 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,\n+  \/* A8F0 *\/ VMAbv, VMAbv,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     B,  VAbv,\n+\n+  \/* Kayah Li *\/\n+\n+  \/* A900 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A910 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A920 *\/     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv, VMBlw, VMBlw, VMBlw,     O,     O,\n+\n+  \/* Rejang *\/\n+\n+  \/* A930 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A940 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  FAbv,\n+  \/* A950 *\/  FAbv,  FAbv,  FPst,  VPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* A960 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* A970 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Javanese *\/\n+\n+  \/* A980 *\/ VMAbv, VMAbv,  FAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A990 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A9A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A9B0 *\/     B,     B,     B, CMAbv,  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VPre,  VAbv,   SUB,  MPst,  MBlw,\n+  \/* A9C0 *\/     H,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* A9D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Myanmar Extended-B *\/\n+\n+  \/* A9E0 *\/     B,     B,     B,     B,     B,  VAbv,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* A9F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,\n+\n+  \/* Cham *\/\n+\n+  \/* AA00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VAbv,  VPre,\n+  \/* AA30 *\/  VPre,  VAbv,  VBlw,  MPst,  MPre,  MBlw,  MBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* AA40 *\/     B,     B,     B,  FAbv,     B,     B,     B,     B,     B,     B,     B,     B,  FAbv,  FPst,     O,     O,\n+  \/* AA50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Myanmar Extended-A *\/\n+\n+  \/* AA60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA70 *\/     O,     B,     B,     B,    GB,    GB,    GB,     O,     O,     O,     B, VMPst, VMAbv, VMPst,     B,     B,\n+\n+  \/* Tai Viet *\/\n+\n+  \/* AA80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AA90 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AAA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* AAB0 *\/  VAbv,     B,  VAbv,  VAbv,  VBlw,     B,     B,  VAbv,  VAbv,     B,     B,     B,     B,     B,  VAbv, VMAbv,\n+  \/* AAC0 *\/     B, VMAbv,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* AAD0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Meetei Mayek Extensions *\/\n+\n+  \/* AAE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPre,  VBlw,  VAbv,  VPre,  VPst,\n+  \/* AAF0 *\/     O,     O,     O,     O,     O, VMPst,     H,     O,\n+\n+#define use_offset_0xabc0u 3576\n+\n+\n+  \/* Meetei Mayek *\/\n+\n+  \/* ABC0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* ABD0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* ABE0 *\/     B,     B,     B,  VPst,  VPst,  VAbv,  VPst,  VPst,  VBlw,  VPst,  VPst,     O, VMPst,  VBlw,     O,     O,\n+  \/* ABF0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0xfe00u 3640\n+\n+\n+  \/* Variation Selectors *\/\n+\n+  \/* FE00 *\/    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,    VS,\n+\n+#define use_offset_0x10a00u 3656\n+\n+\n+  \/* Kharoshthi *\/\n+\n+  \/* 10A00 *\/     B,  VBlw,  VBlw,  VBlw,     O,  VAbv,  VBlw,     O,     O,     O,     O,     O,  VBlw,  VBlw, VMBlw, VMAbv,\n+  \/* 10A10 *\/     B,     B,     B,     B,     O,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 10A30 *\/     B,     B,     B,     B,     B,     B,     O,     O, CMAbv, CMBlw, CMBlw,     O,     O,     O,     O,     H,\n+  \/* 10A40 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x11000u 3736\n+\n+\n+  \/* Brahmi *\/\n+\n+  \/* 11000 *\/ VMPst, VMAbv, VMPst,    CS,    CS,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11010 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11020 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11030 *\/     B,     B,     B,     B,     B,     B,     B,     B,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,\n+  \/* 11040 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,   HVM,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11050 *\/     O,     O,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,     N,\n+  \/* 11060 *\/     N,     N,     N,     N,     N,     N,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11070 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,    HN,\n+\n+  \/* Kaithi *\/\n+\n+  \/* 11080 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11090 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 110A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 110B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst,     H, CMBlw,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x11100u 3928\n+\n+\n+  \/* Chakma *\/\n+\n+  \/* 11100 *\/ VMAbv, VMAbv, VMAbv,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11110 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11120 *\/     B,     B,     B,     B,     B,     B,     B,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPre,  VBlw,  VAbv,  VAbv,\n+  \/* 11130 *\/  VBlw,  VAbv,  VAbv,     H, CMBlw,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11140 *\/     O,     O,     O,     O,     B,  VPst,  VPst,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Mahajani *\/\n+\n+  \/* 11150 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11160 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11170 *\/     B,     B,     B, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Sharada *\/\n+\n+  \/* 11180 *\/ VMAbv, VMAbv, VMPst,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11190 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 111A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 111B0 *\/     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,\n+  \/* 111C0 *\/     H,     B,     R,     R,     O,     O,     O,     O,    GB,  FBlw, CMBlw,  VAbv,  VBlw,     O,     O,     O,\n+  \/* 111D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Sinhala Archaic Numbers *\/\n+\n+  \/* 111E0 *\/     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 111F0 *\/     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Khojki *\/\n+\n+  \/* 11200 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11210 *\/     B,     B,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11220 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VBlw,\n+  \/* 11230 *\/  VAbv,  VAbv,  VAbv,  VAbv, VMAbv,     H, CMAbv, CMAbv,     O,     O,     O,     O,     O,     O, VMAbv,     O,\n+\n+#define use_offset_0x11280u 4248\n+\n+\n+  \/* Multani *\/\n+\n+  \/* 11280 *\/     B,     B,     B,     B,     B,     B,     B,     O,     B,     O,     B,     B,     B,     B,     O,     B,\n+  \/* 11290 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,\n+  \/* 112A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Khudawadi *\/\n+\n+  \/* 112B0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 112C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 112D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv,\n+  \/* 112E0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, CMBlw,  VBlw,     O,     O,     O,     O,     O,\n+  \/* 112F0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Grantha *\/\n+\n+  \/* 11300 *\/ VMAbv, VMAbv, VMAbv, VMPst,     O,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     B,\n+  \/* 11310 *\/     B,     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11320 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 11330 *\/     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     O, CMBlw, CMBlw,     B,  VPst,  VPst,\n+  \/* 11340 *\/  VAbv,  VPst,  VPst,  VPst,  VPst,     O,     O,  VPre,  VPre,     O,     O,  VPst,  VPst,   HVM,     O,     O,\n+  \/* 11350 *\/     O,     O,     O,     O,     O,     O,     O,  VPst,     O,     O,     O,     O,     O,     O,     B,     B,\n+  \/* 11360 *\/     B,     B,  VPst,  VPst,     O,     O, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     O,     O,     O,\n+  \/* 11370 *\/ VMAbv, VMAbv, VMAbv, VMAbv, VMAbv,     O,     O,     O,\n+\n+#define use_offset_0x11400u 4496\n+\n+\n+  \/* Newa *\/\n+\n+  \/* 11400 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11410 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11420 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11430 *\/     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,\n+  \/* 11440 *\/  VPst,  VPst,     H, VMAbv, VMAbv, VMPst, CMBlw,     B,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11450 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,    FM,     O,\n+  \/* 11460 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11470 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Tirhuta *\/\n+\n+  \/* 11480 *\/     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11490 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 114A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 114B0 *\/  VPst,  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VPre,  VAbv,  VPst,  VPst,  VPst,  VPst, VMAbv,\n+  \/* 114C0 *\/ VMAbv, VMPst,     H, CMBlw,     B,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 114D0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x11580u 4720\n+\n+\n+  \/* Siddham *\/\n+\n+  \/* 11580 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11590 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 115A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n+  \/* 115B0 *\/  VPre,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,     O,     O,  VPre,  VPst,  VPst,  VPst, VMAbv, VMAbv, VMPst,     H,\n+  \/* 115C0 *\/ CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 115D0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     B,     B,     B,     B,  VBlw,  VBlw,     O,     O,\n+  \/* 115E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 115F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Modi *\/\n+\n+  \/* 11600 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11610 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11620 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11630 *\/  VPst,  VPst,  VPst,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VPst,  VPst, VMAbv, VMPst,     H,\n+  \/* 11640 *\/  VAbv,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11650 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+  \/* 11660 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11670 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Takri *\/\n+\n+  \/* 11680 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11690 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 116A0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B, VMAbv, VMPst,  VAbv,  VPre,  VPst,\n+  \/* 116B0 *\/  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,     H, CMBlw,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 116C0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+  \/* 116D0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 116E0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 116F0 *\/     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Ahom *\/\n+\n+  \/* 11700 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11710 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,  MBlw,  MPre,  MAbv,\n+  \/* 11720 *\/  VPst,  VPst,  VAbv,  VAbv,  VBlw,  VBlw,  VPre,  VAbv,  VBlw,  VAbv,  VAbv,  VAbv,     O,     O,     O,     O,\n+  \/* 11730 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,\n+\n+#define use_offset_0x11800u 5168\n+\n+\n+  \/* Dogra *\/\n+\n+  \/* 11800 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11810 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11820 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPre,  VPst,  VBlw,\n+  \/* 11830 *\/  VBlw,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMPst,     H, CMBlw,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x11a00u 5232\n+\n+\n+  \/* Zanabazar Square *\/\n+\n+  \/* 11A00 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,     B,     B,     B,     B,     B,\n+  \/* 11A10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A30 *\/     B,     B,     B,    FM,  VBlw, VMAbv, VMAbv, VMAbv, VMAbv, VMPst,     R,  MBlw,  MBlw,  MBlw,  MBlw,    GB,\n+  \/* 11A40 *\/     O,     O,     O,     O,     O,    GB,     O,     H,     O,     O,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Soyombo *\/\n+\n+  \/* 11A50 *\/     B,  VAbv,  VBlw,  VBlw,  VAbv,  VAbv,  VAbv,  VPst,  VPst,  VBlw,  VBlw,  VBlw,     B,     B,     B,     B,\n+  \/* 11A60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11A80 *\/     B,     B,     B,     B,     O,     O,     R,     R,     R,     R,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,\n+  \/* 11A90 *\/  FBlw,  FBlw,  FBlw,  FBlw,  FBlw,  FBlw, VMAbv, VMPst, CMAbv,     H,     O,     O,     O,     B,     O,     O,\n+\n+#define use_offset_0x11c00u 5392\n+\n+\n+  \/* Bhaiksuki *\/\n+\n+  \/* 11C00 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 11C10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,\n+  \/* 11C30 *\/  VAbv,  VAbv,  VBlw,  VBlw,  VBlw,  VBlw,  VBlw,     O,  VAbv,  VAbv,  VAbv,  VAbv, VMAbv, VMAbv, VMPst,     H,\n+  \/* 11C40 *\/     B,     O,     O,     O,    GB,    GB,     O,     O,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11C50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C60 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,\n+\n+  \/* Marchen *\/\n+\n+  \/* 11C70 *\/     O,     O,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11C90 *\/     O,     O,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 11CA0 *\/   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,     O,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,   SUB,\n+  \/* 11CB0 *\/  VBlw,  VPre,  VBlw,  VAbv,  VPst, VMAbv, VMAbv,     O,\n+\n+#define use_offset_0x11d00u 5576\n+\n+\n+  \/* Masaram Gondi *\/\n+\n+  \/* 11D00 *\/     B,     B,     B,     B,     B,     B,     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,\n+  \/* 11D10 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11D20 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11D30 *\/     B,  VAbv,  VAbv,  VAbv,  VAbv,  VAbv,  VBlw,     O,     O,     O,  VAbv,     O,  VAbv,  VAbv,     O,  VAbv,\n+  \/* 11D40 *\/ VMAbv, VMAbv, CMBlw,  VAbv,  VBlw,     H,     R,  MBlw,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11D50 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+  \/* Gunjala Gondi *\/\n+\n+  \/* 11D60 *\/     B,     B,     B,     B,     B,     B,     O,     B,     B,     O,     B,     B,     B,     B,     B,     B,\n+  \/* 11D70 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11D80 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,  VPst,  VPst,  VPst,  VPst,  VPst,     O,\n+  \/* 11D90 *\/  VAbv,  VAbv,     O,  VPst,  VPst, VMAbv, VMPst,     H,     O,     O,     O,     O,     O,     O,     O,     O,\n+  \/* 11DA0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     O,     O,     O,     O,     O,     O,\n+\n+#define use_offset_0x11ee0u 5752\n+\n+\n+  \/* Makasar *\/\n+\n+  \/* 11EE0 *\/     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,     B,\n+  \/* 11EF0 *\/     B,     B,    GB,  VAbv,  VBlw,  VPre,  VPst,     O,\n+\n+}; \/* Table items: 5776; occupancy: 74% *\/\n+\n+USE_TABLE_ELEMENT_TYPE\n+hb_use_get_category (hb_codepoint_t u)\n+{\n+  switch (u >> 12)\n+  {\n+    case 0x0u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0028u, 0x003Fu)) return use_table[u - 0x0028u + use_offset_0x0028u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x00A0u, 0x00D7u)) return use_table[u - 0x00A0u + use_offset_0x00a0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0348u, 0x034Fu)) return use_table[u - 0x0348u + use_offset_0x0348u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0900u, 0x0DF7u)) return use_table[u - 0x0900u + use_offset_0x0900u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x0F18u, 0x0FC7u)) return use_table[u - 0x0F18u + use_offset_0x0f18u];\n+      break;\n+\n+    case 0x1u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1000u, 0x109Fu)) return use_table[u - 0x1000u + use_offset_0x1000u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1700u, 0x17EFu)) return use_table[u - 0x1700u + use_offset_0x1700u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1900u, 0x1A9Fu)) return use_table[u - 0x1900u + use_offset_0x1900u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1B00u, 0x1C4Fu)) return use_table[u - 0x1B00u + use_offset_0x1b00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1CD0u, 0x1CFFu)) return use_table[u - 0x1CD0u + use_offset_0x1cd0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x1DF8u, 0x1DFFu)) return use_table[u - 0x1DF8u + use_offset_0x1df8u];\n+      break;\n+\n+    case 0x2u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2008u, 0x2017u)) return use_table[u - 0x2008u + use_offset_0x2008u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x2060u, 0x2087u)) return use_table[u - 0x2060u + use_offset_0x2060u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x20F0u, 0x20F7u)) return use_table[u - 0x20F0u + use_offset_0x20f0u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x25C8u, 0x25CFu)) return use_table[u - 0x25C8u + use_offset_0x25c8u];\n+      break;\n+\n+    case 0xAu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xA800u, 0xAAF7u)) return use_table[u - 0xA800u + use_offset_0xa800u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0xABC0u, 0xABFFu)) return use_table[u - 0xABC0u + use_offset_0xabc0u];\n+      break;\n+\n+    case 0xFu:\n+      if (hb_in_range<hb_codepoint_t> (u, 0xFE00u, 0xFE0Fu)) return use_table[u - 0xFE00u + use_offset_0xfe00u];\n+      break;\n+\n+    case 0x10u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x10A00u, 0x10A4Fu)) return use_table[u - 0x10A00u + use_offset_0x10a00u];\n+      break;\n+\n+    case 0x11u:\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11000u, 0x110BFu)) return use_table[u - 0x11000u + use_offset_0x11000u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11100u, 0x1123Fu)) return use_table[u - 0x11100u + use_offset_0x11100u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11280u, 0x11377u)) return use_table[u - 0x11280u + use_offset_0x11280u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11400u, 0x114DFu)) return use_table[u - 0x11400u + use_offset_0x11400u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11580u, 0x1173Fu)) return use_table[u - 0x11580u + use_offset_0x11580u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11800u, 0x1183Fu)) return use_table[u - 0x11800u + use_offset_0x11800u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11A00u, 0x11A9Fu)) return use_table[u - 0x11A00u + use_offset_0x11a00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11C00u, 0x11CB7u)) return use_table[u - 0x11C00u + use_offset_0x11c00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11D00u, 0x11DAFu)) return use_table[u - 0x11D00u + use_offset_0x11d00u];\n+      if (hb_in_range<hb_codepoint_t> (u, 0x11EE0u, 0x11EF7u)) return use_table[u - 0x11EE0u + use_offset_0x11ee0u];\n+      break;\n+\n+    default:\n+      break;\n+  }\n+  return USE_O;\n+}\n+\n+#undef B\n+#undef CGJ\n+#undef CS\n+#undef FM\n+#undef GB\n+#undef H\n+#undef HN\n+#undef HVM\n+#undef IND\n+#undef N\n+#undef O\n+#undef R\n+#undef Rsv\n+#undef S\n+#undef SUB\n+#undef VS\n+#undef WJ\n+#undef ZWJ\n+#undef ZWNJ\n+#undef CMBlw\n+#undef CMAbv\n+#undef FBlw\n+#undef FPst\n+#undef FAbv\n+#undef MPre\n+#undef MBlw\n+#undef MPst\n+#undef MAbv\n+#undef SMBlw\n+#undef SMAbv\n+#undef VPre\n+#undef VBlw\n+#undef VPst\n+#undef VAbv\n+#undef VMPre\n+#undef VMBlw\n+#undef VMPst\n+#undef VMAbv\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-use-table.cc","additions":839,"deletions":0,"binary":false,"changes":839,"status":"added"},{"patch":"@@ -0,0 +1,639 @@\n+\/*\n+ * Copyright © 2015  Mozilla Foundation.\n+ * Copyright © 2015  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Mozilla Author(s): Jonathan Kew\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-complex-use.hh\"\n+#include \"hb-ot-shape-complex-arabic.hh\"\n+#include \"hb-ot-shape-complex-vowel-constraints.hh\"\n+\n+\/* buffer var allocations *\/\n+#define use_category() complex_var_u8_0()\n+\n+\n+\/*\n+ * Universal Shaping Engine.\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/use\n+ *\/\n+\n+static const hb_tag_t\n+basic_features[] =\n+{\n+  \/*\n+   * Basic features.\n+   * These features are applied all at once, before reordering.\n+   *\/\n+  HB_TAG('r','k','r','f'),\n+  HB_TAG('a','b','v','f'),\n+  HB_TAG('b','l','w','f'),\n+  HB_TAG('h','a','l','f'),\n+  HB_TAG('p','s','t','f'),\n+  HB_TAG('v','a','t','u'),\n+  HB_TAG('c','j','c','t'),\n+};\n+static const hb_tag_t\n+arabic_features[] =\n+{\n+  HB_TAG('i','s','o','l'),\n+  HB_TAG('i','n','i','t'),\n+  HB_TAG('m','e','d','i'),\n+  HB_TAG('f','i','n','a'),\n+  \/* The spec doesn't specify these but we apply anyway, since our Arabic shaper\n+   * does.  These are only used in Syriac spec. *\/\n+  HB_TAG('m','e','d','2'),\n+  HB_TAG('f','i','n','2'),\n+  HB_TAG('f','i','n','3'),\n+};\n+\/* Same order as arabic_features.  Don't need Syriac stuff.*\/\n+enum joining_form_t {\n+  ISOL,\n+  INIT,\n+  MEDI,\n+  FINA,\n+  _NONE\n+};\n+static const hb_tag_t\n+other_features[] =\n+{\n+  \/*\n+   * Other features.\n+   * These features are applied all at once, after reordering and\n+   * clearing syllables.\n+   *\/\n+  HB_TAG('a','b','v','s'),\n+  HB_TAG('b','l','w','s'),\n+  HB_TAG('h','a','l','n'),\n+  HB_TAG('p','r','e','s'),\n+  HB_TAG('p','s','t','s'),\n+};\n+static const hb_tag_t\n+positioning_features[] =\n+{\n+  \/*\n+   * Positioning features.\n+   * We don't care about the types.\n+   *\/\n+  HB_TAG('d','i','s','t'),\n+  HB_TAG('a','b','v','m'),\n+  HB_TAG('b','l','w','m'),\n+};\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+static void\n+clear_substitution_flags (const hb_ot_shape_plan_t *plan,\n+                          hb_font_t *font,\n+                          hb_buffer_t *buffer);\n+static void\n+record_rphf (const hb_ot_shape_plan_t *plan,\n+             hb_font_t *font,\n+             hb_buffer_t *buffer);\n+static void\n+record_pref (const hb_ot_shape_plan_t *plan,\n+             hb_font_t *font,\n+             hb_buffer_t *buffer);\n+static void\n+reorder (const hb_ot_shape_plan_t *plan,\n+         hb_font_t *font,\n+         hb_buffer_t *buffer);\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font,\n+                 hb_buffer_t *buffer);\n+\n+static void\n+collect_features_use (hb_ot_shape_planner_t *plan)\n+{\n+  hb_ot_map_builder_t *map = &plan->map;\n+\n+  \/* Do this before any lookups have been applied. *\/\n+  map->add_gsub_pause (setup_syllables);\n+\n+  \/* \"Default glyph pre-processing group\" *\/\n+  map->enable_feature (HB_TAG('l','o','c','l'));\n+  map->enable_feature (HB_TAG('c','c','m','p'));\n+  map->enable_feature (HB_TAG('n','u','k','t'));\n+  map->enable_feature (HB_TAG('a','k','h','n'), F_MANUAL_ZWJ);\n+\n+  \/* \"Reordering group\" *\/\n+  map->add_gsub_pause (clear_substitution_flags);\n+  map->add_feature (HB_TAG('r','p','h','f'), F_MANUAL_ZWJ);\n+  map->add_gsub_pause (record_rphf);\n+  map->add_gsub_pause (clear_substitution_flags);\n+  map->enable_feature (HB_TAG('p','r','e','f'), F_MANUAL_ZWJ);\n+  map->add_gsub_pause (record_pref);\n+\n+  \/* \"Orthographic unit shaping group\" *\/\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (basic_features); i++)\n+    map->enable_feature (basic_features[i], F_MANUAL_ZWJ);\n+\n+  map->add_gsub_pause (reorder);\n+  map->add_gsub_pause (clear_syllables);\n+\n+  \/* \"Topographical features\" *\/\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (arabic_features); i++)\n+    map->add_feature (arabic_features[i]);\n+  map->add_gsub_pause (nullptr);\n+\n+  \/* \"Standard typographic presentation\" *\/\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (other_features); i++)\n+    map->enable_feature (other_features[i], F_MANUAL_ZWJ);\n+\n+  \/* \"Positional feature application\" *\/\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (positioning_features); i++)\n+    map->enable_feature (positioning_features[i]);\n+}\n+\n+struct use_shape_plan_t\n+{\n+  hb_mask_t rphf_mask;\n+\n+  arabic_shape_plan_t *arabic_plan;\n+};\n+\n+static bool\n+has_arabic_joining (hb_script_t script)\n+{\n+  \/* List of scripts that have data in arabic-table. *\/\n+  switch ((int) script)\n+  {\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_ARABIC:\n+\n+    \/* Unicode-3.0 additions *\/\n+    case HB_SCRIPT_MONGOLIAN:\n+    case HB_SCRIPT_SYRIAC:\n+\n+    \/* Unicode-5.0 additions *\/\n+    case HB_SCRIPT_NKO:\n+    case HB_SCRIPT_PHAGS_PA:\n+\n+    \/* Unicode-6.0 additions *\/\n+    case HB_SCRIPT_MANDAIC:\n+\n+    \/* Unicode-7.0 additions *\/\n+    case HB_SCRIPT_MANICHAEAN:\n+    case HB_SCRIPT_PSALTER_PAHLAVI:\n+\n+    \/* Unicode-9.0 additions *\/\n+    case HB_SCRIPT_ADLAM:\n+\n+      return true;\n+\n+    default:\n+      return false;\n+  }\n+}\n+\n+static void *\n+data_create_use (const hb_ot_shape_plan_t *plan)\n+{\n+  use_shape_plan_t *use_plan = (use_shape_plan_t *) calloc (1, sizeof (use_shape_plan_t));\n+  if (unlikely (!use_plan))\n+    return nullptr;\n+\n+  use_plan->rphf_mask = plan->map.get_1_mask (HB_TAG('r','p','h','f'));\n+\n+  if (has_arabic_joining (plan->props.script))\n+  {\n+    use_plan->arabic_plan = (arabic_shape_plan_t *) data_create_arabic (plan);\n+    if (unlikely (!use_plan->arabic_plan))\n+    {\n+      free (use_plan);\n+      return nullptr;\n+    }\n+  }\n+\n+  return use_plan;\n+}\n+\n+static void\n+data_destroy_use (void *data)\n+{\n+  use_shape_plan_t *use_plan = (use_shape_plan_t *) data;\n+\n+  if (use_plan->arabic_plan)\n+    data_destroy_arabic (use_plan->arabic_plan);\n+\n+  free (data);\n+}\n+\n+enum syllable_type_t {\n+  independent_cluster,\n+  virama_terminated_cluster,\n+  standard_cluster,\n+  number_joiner_terminated_cluster,\n+  numeral_cluster,\n+  symbol_cluster,\n+  broken_cluster,\n+  non_cluster,\n+};\n+\n+#include \"hb-ot-shape-complex-use-machine.hh\"\n+\n+\n+static void\n+setup_masks_use (const hb_ot_shape_plan_t *plan,\n+                 hb_buffer_t              *buffer,\n+                 hb_font_t                *font HB_UNUSED)\n+{\n+  const use_shape_plan_t *use_plan = (const use_shape_plan_t *) plan->data;\n+\n+  \/* Do this before allocating use_category(). *\/\n+  if (use_plan->arabic_plan)\n+  {\n+    setup_masks_arabic_plan (use_plan->arabic_plan, buffer, plan->props.script);\n+  }\n+\n+  HB_BUFFER_ALLOCATE_VAR (buffer, use_category);\n+\n+  \/* We cannot setup masks here.  We save information about characters\n+   * and setup masks later on in a pause-callback. *\/\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    info[i].use_category() = hb_use_get_category (info[i].codepoint);\n+}\n+\n+static void\n+setup_rphf_mask (const hb_ot_shape_plan_t *plan,\n+                 hb_buffer_t *buffer)\n+{\n+  const use_shape_plan_t *use_plan = (const use_shape_plan_t *) plan->data;\n+\n+  hb_mask_t mask = use_plan->rphf_mask;\n+  if (!mask) return;\n+\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  foreach_syllable (buffer, start, end)\n+  {\n+    unsigned int limit = info[start].use_category() == USE_R ? 1 : MIN (3u, end - start);\n+    for (unsigned int i = start; i < start + limit; i++)\n+      info[i].mask |= mask;\n+  }\n+}\n+\n+static void\n+setup_topographical_masks (const hb_ot_shape_plan_t *plan,\n+                           hb_buffer_t *buffer)\n+{\n+  const use_shape_plan_t *use_plan = (const use_shape_plan_t *) plan->data;\n+  if (use_plan->arabic_plan)\n+    return;\n+\n+  static_assert ((INIT < 4 && ISOL < 4 && MEDI < 4 && FINA < 4), \"\");\n+  hb_mask_t masks[4], all_masks = 0;\n+  for (unsigned int i = 0; i < 4; i++)\n+  {\n+    masks[i] = plan->map.get_1_mask (arabic_features[i]);\n+    if (masks[i] == plan->map.get_global_mask ())\n+      masks[i] = 0;\n+    all_masks |= masks[i];\n+  }\n+  if (!all_masks)\n+    return;\n+  hb_mask_t other_masks = ~all_masks;\n+\n+  unsigned int last_start = 0;\n+  joining_form_t last_form = _NONE;\n+  hb_glyph_info_t *info = buffer->info;\n+  foreach_syllable (buffer, start, end)\n+  {\n+    syllable_type_t syllable_type = (syllable_type_t) (info[start].syllable() & 0x0F);\n+    switch (syllable_type)\n+    {\n+      case independent_cluster:\n+      case symbol_cluster:\n+      case non_cluster:\n+        \/* These don't join.  Nothing to do. *\/\n+        last_form = _NONE;\n+        break;\n+\n+      case virama_terminated_cluster:\n+      case standard_cluster:\n+      case number_joiner_terminated_cluster:\n+      case numeral_cluster:\n+      case broken_cluster:\n+\n+        bool join = last_form == FINA || last_form == ISOL;\n+\n+        if (join)\n+        {\n+          \/* Fixup previous syllable's form. *\/\n+          last_form = last_form == FINA ? MEDI : INIT;\n+          for (unsigned int i = last_start; i < start; i++)\n+            info[i].mask = (info[i].mask & other_masks) | masks[last_form];\n+        }\n+\n+        \/* Form for this syllable. *\/\n+        last_form = join ? FINA : ISOL;\n+        for (unsigned int i = start; i < end; i++)\n+          info[i].mask = (info[i].mask & other_masks) | masks[last_form];\n+\n+        break;\n+    }\n+\n+    last_start = start;\n+  }\n+}\n+\n+static void\n+setup_syllables (const hb_ot_shape_plan_t *plan,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  find_syllables (buffer);\n+  foreach_syllable (buffer, start, end)\n+    buffer->unsafe_to_break (start, end);\n+  setup_rphf_mask (plan, buffer);\n+  setup_topographical_masks (plan, buffer);\n+}\n+\n+static void\n+clear_substitution_flags (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                          hb_font_t *font HB_UNUSED,\n+                          hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    _hb_glyph_info_clear_substituted (&info[i]);\n+}\n+\n+static void\n+record_rphf (const hb_ot_shape_plan_t *plan,\n+             hb_font_t *font HB_UNUSED,\n+             hb_buffer_t *buffer)\n+{\n+  const use_shape_plan_t *use_plan = (const use_shape_plan_t *) plan->data;\n+\n+  hb_mask_t mask = use_plan->rphf_mask;\n+  if (!mask) return;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  foreach_syllable (buffer, start, end)\n+  {\n+    \/* Mark a substituted repha as USE_R. *\/\n+    for (unsigned int i = start; i < end && (info[i].mask & mask); i++)\n+      if (_hb_glyph_info_substituted (&info[i]))\n+      {\n+        info[i].use_category() = USE_R;\n+        break;\n+      }\n+  }\n+}\n+\n+static void\n+record_pref (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+             hb_font_t *font HB_UNUSED,\n+             hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  foreach_syllable (buffer, start, end)\n+  {\n+    \/* Mark a substituted pref as VPre, as they behave the same way. *\/\n+    for (unsigned int i = start; i < end; i++)\n+      if (_hb_glyph_info_substituted (&info[i]))\n+      {\n+        info[i].use_category() = USE_VPre;\n+        break;\n+      }\n+  }\n+}\n+\n+static inline bool\n+is_halant (const hb_glyph_info_t &info)\n+{\n+  return (info.use_category() == USE_H || info.use_category() == USE_HVM) &&\n+         !_hb_glyph_info_ligated (&info);\n+}\n+\n+static void\n+reorder_syllable (hb_buffer_t *buffer, unsigned int start, unsigned int end)\n+{\n+  syllable_type_t syllable_type = (syllable_type_t) (buffer->info[start].syllable() & 0x0F);\n+  \/* Only a few syllable types need reordering. *\/\n+  if (unlikely (!(FLAG_UNSAFE (syllable_type) &\n+                  (FLAG (virama_terminated_cluster) |\n+                   FLAG (standard_cluster) |\n+                   FLAG (broken_cluster) |\n+                   0))))\n+    return;\n+\n+  hb_glyph_info_t *info = buffer->info;\n+\n+#define POST_BASE_FLAGS64 (FLAG64 (USE_FM) | \\\n+                           FLAG64 (USE_FAbv) | \\\n+                           FLAG64 (USE_FBlw) | \\\n+                           FLAG64 (USE_FPst) | \\\n+                           FLAG64 (USE_MAbv) | \\\n+                           FLAG64 (USE_MBlw) | \\\n+                           FLAG64 (USE_MPst) | \\\n+                           FLAG64 (USE_MPre) | \\\n+                           FLAG64 (USE_VAbv) | \\\n+                           FLAG64 (USE_VBlw) | \\\n+                           FLAG64 (USE_VPst) | \\\n+                           FLAG64 (USE_VPre) | \\\n+                           FLAG64 (USE_VMAbv) | \\\n+                           FLAG64 (USE_VMBlw) | \\\n+                           FLAG64 (USE_VMPst) | \\\n+                           FLAG64 (USE_VMPre))\n+\n+  \/* Move things forward. *\/\n+  if (info[start].use_category() == USE_R && end - start > 1)\n+  {\n+    \/* Got a repha.  Reorder it towards the end, but before the first post-base\n+     * glyph. *\/\n+    for (unsigned int i = start + 1; i < end; i++)\n+    {\n+      bool is_post_base_glyph = (FLAG64_UNSAFE (info[i].use_category()) & POST_BASE_FLAGS64) ||\n+                                is_halant (info[i]);\n+      if (is_post_base_glyph || i == end - 1)\n+      {\n+        \/* If we hit a post-base glyph, move before it; otherwise move to the\n+         * end. Shift things in between backward. *\/\n+\n+        if (is_post_base_glyph)\n+          i--;\n+\n+        buffer->merge_clusters (start, i + 1);\n+        hb_glyph_info_t t = info[start];\n+        memmove (&info[start], &info[start + 1], (i - start) * sizeof (info[0]));\n+        info[i] = t;\n+\n+        break;\n+      }\n+    }\n+  }\n+\n+  \/* Move things back. *\/\n+  unsigned int j = start;\n+  for (unsigned int i = start; i < end; i++)\n+  {\n+    uint32_t flag = FLAG_UNSAFE (info[i].use_category());\n+    if (is_halant (info[i]))\n+    {\n+      \/* If we hit a halant, move after it; otherwise move to the beginning, and\n+       * shift things in between forward. *\/\n+      j = i + 1;\n+    }\n+    else if (((flag) & (FLAG (USE_VPre) | FLAG (USE_VMPre))) &&\n+             \/* Only move the first component of a MultipleSubst. *\/\n+             0 == _hb_glyph_info_get_lig_comp (&info[i]) &&\n+             j < i)\n+    {\n+      buffer->merge_clusters (j, i + 1);\n+      hb_glyph_info_t t = info[i];\n+      memmove (&info[j + 1], &info[j], (i - j) * sizeof (info[0]));\n+      info[j] = t;\n+    }\n+  }\n+}\n+\n+static inline void\n+insert_dotted_circles (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                       hb_font_t *font,\n+                       hb_buffer_t *buffer)\n+{\n+  \/* Note: This loop is extra overhead, but should not be measurable. *\/\n+  bool has_broken_syllables = false;\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    if ((info[i].syllable() & 0x0F) == broken_cluster)\n+    {\n+      has_broken_syllables = true;\n+      break;\n+    }\n+  if (likely (!has_broken_syllables))\n+    return;\n+\n+  hb_glyph_info_t dottedcircle = {0};\n+  if (!font->get_nominal_glyph (0x25CCu, &dottedcircle.codepoint))\n+    return;\n+  dottedcircle.use_category() = hb_use_get_category (0x25CC);\n+\n+  buffer->clear_output ();\n+\n+  buffer->idx = 0;\n+  unsigned int last_syllable = 0;\n+  while (buffer->idx < buffer->len && buffer->successful)\n+  {\n+    unsigned int syllable = buffer->cur().syllable();\n+    syllable_type_t syllable_type = (syllable_type_t) (syllable & 0x0F);\n+    if (unlikely (last_syllable != syllable && syllable_type == broken_cluster))\n+    {\n+      last_syllable = syllable;\n+\n+      hb_glyph_info_t ginfo = dottedcircle;\n+      ginfo.cluster = buffer->cur().cluster;\n+      ginfo.mask = buffer->cur().mask;\n+      ginfo.syllable() = buffer->cur().syllable();\n+      \/* TODO Set glyph_props? *\/\n+\n+      \/* Insert dottedcircle after possible Repha. *\/\n+      while (buffer->idx < buffer->len && buffer->successful &&\n+             last_syllable == buffer->cur().syllable() &&\n+             buffer->cur().use_category() == USE_R)\n+        buffer->next_glyph ();\n+\n+      buffer->output_info (ginfo);\n+    }\n+    else\n+      buffer->next_glyph ();\n+  }\n+  buffer->swap_buffers ();\n+}\n+\n+static void\n+reorder (const hb_ot_shape_plan_t *plan,\n+         hb_font_t *font,\n+         hb_buffer_t *buffer)\n+{\n+  insert_dotted_circles (plan, font, buffer);\n+\n+  foreach_syllable (buffer, start, end)\n+    reorder_syllable (buffer, start, end);\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, use_category);\n+}\n+\n+static void\n+clear_syllables (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                 hb_font_t *font HB_UNUSED,\n+                 hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    info[i].syllable() = 0;\n+}\n+\n+\n+static void\n+preprocess_text_use (const hb_ot_shape_plan_t *plan,\n+                     hb_buffer_t              *buffer,\n+                     hb_font_t                *font)\n+{\n+  _hb_preprocess_text_vowel_constraints (plan, buffer, font);\n+}\n+\n+static bool\n+compose_use (const hb_ot_shape_normalize_context_t *c,\n+             hb_codepoint_t  a,\n+             hb_codepoint_t  b,\n+             hb_codepoint_t *ab)\n+{\n+  \/* Avoid recomposing split matras. *\/\n+  if (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (c->unicode->general_category (a)))\n+    return false;\n+\n+  return (bool)c->unicode->compose (a, b, ab);\n+}\n+\n+\n+const hb_ot_complex_shaper_t _hb_ot_complex_shaper_use =\n+{\n+  collect_features_use,\n+  nullptr, \/* override_features *\/\n+  data_create_use,\n+  data_destroy_use,\n+  preprocess_text_use,\n+  nullptr, \/* postprocess_glyphs *\/\n+  HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT,\n+  nullptr, \/* decompose *\/\n+  compose_use,\n+  setup_masks_use,\n+  HB_TAG_NONE, \/* gpos_tag *\/\n+  nullptr, \/* reorder_marks *\/\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,\n+  false, \/* fallback_position *\/\n+};\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-use.cc","additions":639,"deletions":0,"binary":false,"changes":639,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright © 2015  Mozilla Foundation.\n+ * Copyright © 2015  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Mozilla Author(s): Jonathan Kew\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_USE_HH\n+#define HB_OT_SHAPE_COMPLEX_USE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+#include \"hb-ot-shape-complex.hh\"\n+\n+\n+#define USE_TABLE_ELEMENT_TYPE uint8_t\n+\n+\/* Cateories used in the Universal Shaping Engine spec:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/use\n+ *\/\n+\/* Note: This enum is duplicated in the -machine.rl source file.\n+ * Not sure how to avoid duplication. *\/\n+enum use_category_t {\n+  USE_O         = 0,    \/* OTHER *\/\n+\n+  USE_B         = 1,    \/* BASE *\/\n+  USE_IND       = 3,    \/* BASE_IND *\/\n+  USE_N         = 4,    \/* BASE_NUM *\/\n+  USE_GB        = 5,    \/* BASE_OTHER *\/\n+  USE_CGJ       = 6,    \/* CGJ *\/\n+\/\/  USE_F               = 7,    \/* CONS_FINAL *\/\n+  USE_FM        = 8,    \/* CONS_FINAL_MOD *\/\n+\/\/  USE_M               = 9,    \/* CONS_MED *\/\n+\/\/  USE_CM      = 10,   \/* CONS_MOD *\/\n+  USE_SUB       = 11,   \/* CONS_SUB *\/\n+  USE_H         = 12,   \/* HALANT *\/\n+\n+  USE_HN        = 13,   \/* HALANT_NUM *\/\n+  USE_ZWNJ      = 14,   \/* Zero width non-joiner *\/\n+  USE_ZWJ       = 15,   \/* Zero width joiner *\/\n+  USE_WJ        = 16,   \/* Word joiner *\/\n+  USE_Rsv       = 17,   \/* Reserved characters *\/\n+  USE_R         = 18,   \/* REPHA *\/\n+  USE_S         = 19,   \/* SYM *\/\n+\/\/  USE_SM      = 20,   \/* SYM_MOD *\/\n+  USE_VS        = 21,   \/* VARIATION_SELECTOR *\/\n+\/\/  USE_V       = 36,   \/* VOWEL *\/\n+\/\/  USE_VM      = 40,   \/* VOWEL_MOD *\/\n+\n+  USE_FAbv      = 24,   \/* CONS_FINAL_ABOVE *\/\n+  USE_FBlw      = 25,   \/* CONS_FINAL_BELOW *\/\n+  USE_FPst      = 26,   \/* CONS_FINAL_POST *\/\n+  USE_MAbv      = 27,   \/* CONS_MED_ABOVE *\/\n+  USE_MBlw      = 28,   \/* CONS_MED_BELOW *\/\n+  USE_MPst      = 29,   \/* CONS_MED_POST *\/\n+  USE_MPre      = 30,   \/* CONS_MED_PRE *\/\n+  USE_CMAbv     = 31,   \/* CONS_MOD_ABOVE *\/\n+  USE_CMBlw     = 32,   \/* CONS_MOD_BELOW *\/\n+  USE_VAbv      = 33,   \/* VOWEL_ABOVE \/ VOWEL_ABOVE_BELOW \/ VOWEL_ABOVE_BELOW_POST \/ VOWEL_ABOVE_POST *\/\n+  USE_VBlw      = 34,   \/* VOWEL_BELOW \/ VOWEL_BELOW_POST *\/\n+  USE_VPst      = 35,   \/* VOWEL_POST   UIPC = Right *\/\n+  USE_VPre      = 22,   \/* VOWEL_PRE \/ VOWEL_PRE_ABOVE \/ VOWEL_PRE_ABOVE_POST \/ VOWEL_PRE_POST *\/\n+  USE_VMAbv     = 37,   \/* VOWEL_MOD_ABOVE *\/\n+  USE_VMBlw     = 38,   \/* VOWEL_MOD_BELOW *\/\n+  USE_VMPst     = 39,   \/* VOWEL_MOD_POST *\/\n+  USE_VMPre     = 23,   \/* VOWEL_MOD_PRE *\/\n+  USE_SMAbv     = 41,   \/* SYM_MOD_ABOVE *\/\n+  USE_SMBlw     = 42,   \/* SYM_MOD_BELOW *\/\n+  USE_CS        = 43,   \/* CONS_WITH_STACKER *\/\n+\n+  \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1102 *\/\n+  USE_HVM       = 44,   \/* HALANT_OR_VOWEL_MODIFIER *\/\n+};\n+\n+HB_INTERNAL USE_TABLE_ELEMENT_TYPE\n+hb_use_get_category (hb_codepoint_t u);\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_USE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-use.hh","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,437 @@\n+\/* == Start of generated functions == *\/\n+\/*\n+ * The following functions are generated by running:\n+ *\n+ *   .\/gen-vowel-constraints.py use Scripts.txt\n+ *\n+ * on files with these headers:\n+ *\n+ * # Copied from https:\/\/docs.microsoft.com\/en-us\/typography\/script-development\/use\n+ * # On October 23, 2018; with documentd dated 02\/07\/2018.\n+ *\n+ * # Scripts-11.0.0.txt\n+ * # Date: 2018-02-21, 05:34:31 GMT\n+ *\/\n+\n+#include \"hb-ot-shape-complex-vowel-constraints.hh\"\n+\n+static void\n+_output_dotted_circle (hb_buffer_t *buffer)\n+{\n+  hb_glyph_info_t &dottedcircle = buffer->output_glyph (0x25CCu);\n+  _hb_glyph_info_reset_continuation (&dottedcircle);\n+}\n+\n+static void\n+_output_with_dotted_circle (hb_buffer_t *buffer)\n+{\n+  _output_dotted_circle (buffer);\n+  buffer->next_glyph ();\n+}\n+\n+void\n+_hb_preprocess_text_vowel_constraints (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                       hb_buffer_t              *buffer,\n+                                       hb_font_t                *font HB_UNUSED)\n+{\n+  \/* UGLY UGLY UGLY business of adding dotted-circle in the middle of\n+   * vowel-sequences that look like another vowel.  Data for each script\n+   * collected from the USE script development spec.\n+   *\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1019\n+   *\/\n+  bool processed = false;\n+  buffer->clear_output ();\n+  unsigned int count = buffer->len;\n+  switch ((unsigned) buffer->props.script)\n+  {\n+    case HB_SCRIPT_DEVANAGARI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0905u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x093Au: case 0x093Bu: case 0x093Eu: case 0x0945u:\n+              case 0x0946u: case 0x0949u: case 0x094Au: case 0x094Bu:\n+              case 0x094Cu: case 0x094Fu: case 0x0956u: case 0x0957u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0906u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x093Au: case 0x0945u: case 0x0946u: case 0x0947u:\n+              case 0x0948u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0909u:\n+            matched = 0x0941u == buffer->cur (1).codepoint;\n+            break;\n+          case 0x090Fu:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0945u: case 0x0946u: case 0x0947u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0930u:\n+            if (0x094Du == buffer->cur (1).codepoint &&\n+                buffer->idx + 2 < count &&\n+                0x0907u == buffer->cur (2).codepoint)\n+            {\n+              buffer->next_glyph ();\n+              buffer->next_glyph ();\n+              _output_dotted_circle (buffer);\n+            }\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_BENGALI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0985u:\n+            matched = 0x09BEu == buffer->cur (1).codepoint;\n+            break;\n+          case 0x098Bu:\n+            matched = 0x09C3u == buffer->cur (1).codepoint;\n+            break;\n+          case 0x098Cu:\n+            matched = 0x09E2u == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_GURMUKHI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0A05u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0A3Eu: case 0x0A48u: case 0x0A4Cu:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0A72u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0A3Fu: case 0x0A40u: case 0x0A47u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0A73u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0A41u: case 0x0A42u: case 0x0A4Bu:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_GUJARATI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0A85u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0ABEu: case 0x0AC5u: case 0x0AC7u: case 0x0AC8u:\n+              case 0x0AC9u: case 0x0ACBu: case 0x0ACCu:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0AC5u:\n+            matched = 0x0ABEu == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_ORIYA:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0B05u:\n+            matched = 0x0B3Eu == buffer->cur (1).codepoint;\n+            break;\n+          case 0x0B0Fu: case 0x0B13u:\n+            matched = 0x0B57u == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_TELUGU:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0C12u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0C4Cu: case 0x0C55u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0C3Fu: case 0x0C46u: case 0x0C4Au:\n+            matched = 0x0C55u == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_KANNADA:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0C89u: case 0x0C8Bu:\n+            matched = 0x0CBEu == buffer->cur (1).codepoint;\n+            break;\n+          case 0x0C92u:\n+            matched = 0x0CCCu == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_MALAYALAM:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0D07u: case 0x0D09u:\n+            matched = 0x0D57u == buffer->cur (1).codepoint;\n+            break;\n+          case 0x0D0Eu:\n+            matched = 0x0D46u == buffer->cur (1).codepoint;\n+            break;\n+          case 0x0D12u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0D3Eu: case 0x0D57u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_SINHALA:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x0D85u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0DCFu: case 0x0DD0u: case 0x0DD1u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x0D8Bu: case 0x0D8Fu: case 0x0D94u:\n+            matched = 0x0DDFu == buffer->cur (1).codepoint;\n+            break;\n+          case 0x0D8Du:\n+            matched = 0x0DD8u == buffer->cur (1).codepoint;\n+            break;\n+          case 0x0D91u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x0DCAu: case 0x0DD9u: case 0x0DDAu: case 0x0DDCu:\n+              case 0x0DDDu:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_BRAHMI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x11005u:\n+            matched = 0x11038u == buffer->cur (1).codepoint;\n+            break;\n+          case 0x1100Bu:\n+            matched = 0x1103Eu == buffer->cur (1).codepoint;\n+            break;\n+          case 0x1100Fu:\n+            matched = 0x11042u == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_KHUDAWADI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x112B0u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x112E0u: case 0x112E5u: case 0x112E6u: case 0x112E7u:\n+              case 0x112E8u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_TIRHUTA:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x11481u:\n+            matched = 0x114B0u == buffer->cur (1).codepoint;\n+            break;\n+          case 0x1148Bu: case 0x1148Du:\n+            matched = 0x114BAu == buffer->cur (1).codepoint;\n+            break;\n+          case 0x114AAu:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x114B5u: case 0x114B6u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_MODI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x11600u: case 0x11601u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x11639u: case 0x1163Au:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    case HB_SCRIPT_TAKRI:\n+      for (buffer->idx = 0; buffer->idx + 1 < count && buffer->successful;)\n+      {\n+        bool matched = false;\n+        switch (buffer->cur ().codepoint)\n+        {\n+          case 0x11680u:\n+            switch (buffer->cur (1).codepoint)\n+            {\n+              case 0x116ADu: case 0x116B4u: case 0x116B5u:\n+                matched = true;\n+                break;\n+            }\n+            break;\n+          case 0x11686u:\n+            matched = 0x116B2u == buffer->cur (1).codepoint;\n+            break;\n+        }\n+        buffer->next_glyph ();\n+        if (matched) _output_with_dotted_circle (buffer);\n+      }\n+      processed = true;\n+      break;\n+\n+    default:\n+      break;\n+  }\n+  if (processed)\n+  {\n+    if (buffer->idx < count)\n+      buffer->next_glyph ();\n+    buffer->swap_buffers ();\n+  }\n+}\n+\n+\/* == End of generated functions == *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-vowel-constraints.cc","additions":437,"deletions":0,"binary":false,"changes":437,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex-vowel-constraints.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-complex-vowel-constraints.hh","status":"copied"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright © 2010,2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_COMPLEX_HH\n+#define HB_OT_SHAPE_COMPLEX_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-layout.hh\"\n+#include \"hb-ot-shape.hh\"\n+#include \"hb-ot-shape-normalize.hh\"\n+\n+\n+\/* buffer var allocations, used by complex shapers *\/\n+#define complex_var_u8_0()      var2.u8[2]\n+#define complex_var_u8_1()      var2.u8[3]\n+\n+\n+#define HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS 32\n+\n+enum hb_ot_shape_zero_width_marks_type_t {\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE,\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY,\n+  HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE\n+};\n+\n+\n+\/* Master OT shaper list *\/\n+#define HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (default) \/* should be first *\/ \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (arabic) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (hangul) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (hebrew) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (indic) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (khmer) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (myanmar) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (myanmar_zawgyi) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (thai) \\\n+  HB_COMPLEX_SHAPER_IMPLEMENT (use) \\\n+  \/* ^--- Add new shapers here *\/\n+\n+\n+struct hb_ot_complex_shaper_t\n+{\n+  \/* collect_features()\n+   * Called during shape_plan().\n+   * Shapers should use plan->map to add their features and callbacks.\n+   * May be NULL.\n+   *\/\n+  void (*collect_features) (hb_ot_shape_planner_t *plan);\n+\n+  \/* override_features()\n+   * Called during shape_plan().\n+   * Shapers should use plan->map to override features and add callbacks after\n+   * common features are added.\n+   * May be NULL.\n+   *\/\n+  void (*override_features) (hb_ot_shape_planner_t *plan);\n+\n+\n+  \/* data_create()\n+   * Called at the end of shape_plan().\n+   * Whatever shapers return will be accessible through plan->data later.\n+   * If nullptr is returned, means a plan failure.\n+   *\/\n+  void *(*data_create) (const hb_ot_shape_plan_t *plan);\n+\n+  \/* data_destroy()\n+   * Called when the shape_plan is being destroyed.\n+   * plan->data is passed here for destruction.\n+   * If nullptr is returned, means a plan failure.\n+   * May be NULL.\n+   *\/\n+  void (*data_destroy) (void *data);\n+\n+\n+  \/* preprocess_text()\n+   * Called during shape().\n+   * Shapers can use to modify text before shaping starts.\n+   * May be NULL.\n+   *\/\n+  void (*preprocess_text) (const hb_ot_shape_plan_t *plan,\n+                           hb_buffer_t              *buffer,\n+                           hb_font_t                *font);\n+\n+  \/* postprocess_glyphs()\n+   * Called during shape().\n+   * Shapers can use to modify glyphs after shaping ends.\n+   * May be NULL.\n+   *\/\n+  void (*postprocess_glyphs) (const hb_ot_shape_plan_t *plan,\n+                              hb_buffer_t              *buffer,\n+                              hb_font_t                *font);\n+\n+\n+  hb_ot_shape_normalization_mode_t normalization_preference;\n+\n+  \/* decompose()\n+   * Called during shape()'s normalization.\n+   * May be NULL.\n+   *\/\n+  bool (*decompose) (const hb_ot_shape_normalize_context_t *c,\n+                     hb_codepoint_t  ab,\n+                     hb_codepoint_t *a,\n+                     hb_codepoint_t *b);\n+\n+  \/* compose()\n+   * Called during shape()'s normalization.\n+   * May be NULL.\n+   *\/\n+  bool (*compose) (const hb_ot_shape_normalize_context_t *c,\n+                   hb_codepoint_t  a,\n+                   hb_codepoint_t  b,\n+                   hb_codepoint_t *ab);\n+\n+  \/* setup_masks()\n+   * Called during shape().\n+   * Shapers should use map to get feature masks and set on buffer.\n+   * Shapers may NOT modify characters.\n+   * May be NULL.\n+   *\/\n+  void (*setup_masks) (const hb_ot_shape_plan_t *plan,\n+                       hb_buffer_t              *buffer,\n+                       hb_font_t                *font);\n+\n+  \/* gpos_tag()\n+   * If not HB_TAG_NONE, then must match found GPOS script tag for\n+   * GPOS to be applied.  Otherwise, fallback positioning will be used.\n+   *\/\n+  hb_tag_t gpos_tag;\n+\n+  \/* reorder_marks()\n+   * Called during shape().\n+   * Shapers can use to modify ordering of combining marks.\n+   * May be NULL.\n+   *\/\n+  void (*reorder_marks) (const hb_ot_shape_plan_t *plan,\n+                         hb_buffer_t              *buffer,\n+                         unsigned int              start,\n+                         unsigned int              end);\n+\n+  hb_ot_shape_zero_width_marks_type_t zero_width_marks;\n+\n+  bool fallback_position;\n+};\n+\n+#define HB_COMPLEX_SHAPER_IMPLEMENT(name) extern HB_INTERNAL const hb_ot_complex_shaper_t _hb_ot_complex_shaper_##name;\n+HB_COMPLEX_SHAPERS_IMPLEMENT_SHAPERS\n+#undef HB_COMPLEX_SHAPER_IMPLEMENT\n+\n+\n+static inline const hb_ot_complex_shaper_t *\n+hb_ot_shape_complex_categorize (const hb_ot_shape_planner_t *planner)\n+{\n+  switch ((hb_tag_t) planner->props.script)\n+  {\n+    default:\n+      return &_hb_ot_complex_shaper_default;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_ARABIC:\n+\n+    \/* Unicode-3.0 additions *\/\n+    case HB_SCRIPT_MONGOLIAN:\n+    case HB_SCRIPT_SYRIAC:\n+\n+    \/* Unicode-5.0 additions *\/\n+    case HB_SCRIPT_NKO:\n+    case HB_SCRIPT_PHAGS_PA:\n+\n+    \/* Unicode-6.0 additions *\/\n+    case HB_SCRIPT_MANDAIC:\n+\n+    \/* Unicode-7.0 additions *\/\n+    case HB_SCRIPT_MANICHAEAN:\n+    case HB_SCRIPT_PSALTER_PAHLAVI:\n+\n+    \/* Unicode-9.0 additions *\/\n+    case HB_SCRIPT_ADLAM:\n+\n+    \/* Unicode-11.0 additions *\/\n+    case HB_SCRIPT_HANIFI_ROHINGYA:\n+    case HB_SCRIPT_SOGDIAN:\n+\n+      \/* For Arabic script, use the Arabic shaper even if no OT script tag was found.\n+       * This is because we do fallback shaping for Arabic script (and not others).\n+       * But note that Arabic shaping is applicable only to horizontal layout; for\n+       * vertical text, just use the generic shaper instead. *\/\n+      if ((planner->map.chosen_script[0] != HB_OT_TAG_DEFAULT_SCRIPT ||\n+           planner->props.script == HB_SCRIPT_ARABIC) &&\n+          HB_DIRECTION_IS_HORIZONTAL(planner->props.direction))\n+        return &_hb_ot_complex_shaper_arabic;\n+      else\n+        return &_hb_ot_complex_shaper_default;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_THAI:\n+    case HB_SCRIPT_LAO:\n+\n+      return &_hb_ot_complex_shaper_thai;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_HANGUL:\n+\n+      return &_hb_ot_complex_shaper_hangul;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_HEBREW:\n+\n+      return &_hb_ot_complex_shaper_hebrew;\n+\n+\n+    \/* Unicode-1.1 additions *\/\n+    case HB_SCRIPT_BENGALI:\n+    case HB_SCRIPT_DEVANAGARI:\n+    case HB_SCRIPT_GUJARATI:\n+    case HB_SCRIPT_GURMUKHI:\n+    case HB_SCRIPT_KANNADA:\n+    case HB_SCRIPT_MALAYALAM:\n+    case HB_SCRIPT_ORIYA:\n+    case HB_SCRIPT_TAMIL:\n+    case HB_SCRIPT_TELUGU:\n+\n+    \/* Unicode-3.0 additions *\/\n+    case HB_SCRIPT_SINHALA:\n+\n+      \/* If the designer designed the font for the 'DFLT' script,\n+       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n+       * Otherwise, use the specific shaper.\n+       *\n+       * If it's indy3 tag, send to USE. *\/\n+      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n+          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n'))\n+        return &_hb_ot_complex_shaper_default;\n+      else if ((planner->map.chosen_script[0] & 0x000000FF) == '3')\n+        return &_hb_ot_complex_shaper_use;\n+      else\n+        return &_hb_ot_complex_shaper_indic;\n+\n+    case HB_SCRIPT_KHMER:\n+        return &_hb_ot_complex_shaper_khmer;\n+\n+    case HB_SCRIPT_MYANMAR:\n+      \/* If the designer designed the font for the 'DFLT' script,\n+       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n+       * Otherwise, use the specific shaper.\n+       *\n+       * If designer designed for 'mymr' tag, also send to default\n+       * shaper.  That's tag used from before Myanmar shaping spec\n+       * was developed.  The shaping spec uses 'mym2' tag. *\/\n+      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n+          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n') ||\n+          planner->map.chosen_script[0] == HB_TAG ('m','y','m','r'))\n+        return &_hb_ot_complex_shaper_default;\n+      else\n+        return &_hb_ot_complex_shaper_myanmar;\n+\n+\n+    \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1162 *\/\n+    case HB_SCRIPT_MYANMAR_ZAWGYI:\n+\n+      return &_hb_ot_complex_shaper_myanmar_zawgyi;\n+\n+\n+    \/* Unicode-2.0 additions *\/\n+    case HB_SCRIPT_TIBETAN:\n+\n+    \/* Unicode-3.0 additions *\/\n+    \/\/case HB_SCRIPT_MONGOLIAN:\n+    \/\/case HB_SCRIPT_SINHALA:\n+\n+    \/* Unicode-3.2 additions *\/\n+    case HB_SCRIPT_BUHID:\n+    case HB_SCRIPT_HANUNOO:\n+    case HB_SCRIPT_TAGALOG:\n+    case HB_SCRIPT_TAGBANWA:\n+\n+    \/* Unicode-4.0 additions *\/\n+    case HB_SCRIPT_LIMBU:\n+    case HB_SCRIPT_TAI_LE:\n+\n+    \/* Unicode-4.1 additions *\/\n+    case HB_SCRIPT_BUGINESE:\n+    case HB_SCRIPT_KHAROSHTHI:\n+    case HB_SCRIPT_SYLOTI_NAGRI:\n+    case HB_SCRIPT_TIFINAGH:\n+\n+    \/* Unicode-5.0 additions *\/\n+    case HB_SCRIPT_BALINESE:\n+    \/\/case HB_SCRIPT_NKO:\n+    \/\/case HB_SCRIPT_PHAGS_PA:\n+\n+    \/* Unicode-5.1 additions *\/\n+    case HB_SCRIPT_CHAM:\n+    case HB_SCRIPT_KAYAH_LI:\n+    case HB_SCRIPT_LEPCHA:\n+    case HB_SCRIPT_REJANG:\n+    case HB_SCRIPT_SAURASHTRA:\n+    case HB_SCRIPT_SUNDANESE:\n+\n+    \/* Unicode-5.2 additions *\/\n+    case HB_SCRIPT_EGYPTIAN_HIEROGLYPHS:\n+    case HB_SCRIPT_JAVANESE:\n+    case HB_SCRIPT_KAITHI:\n+    case HB_SCRIPT_MEETEI_MAYEK:\n+    case HB_SCRIPT_TAI_THAM:\n+    case HB_SCRIPT_TAI_VIET:\n+\n+    \/* Unicode-6.0 additions *\/\n+    case HB_SCRIPT_BATAK:\n+    case HB_SCRIPT_BRAHMI:\n+    \/\/case HB_SCRIPT_MANDAIC:\n+\n+    \/* Unicode-6.1 additions *\/\n+    case HB_SCRIPT_CHAKMA:\n+    case HB_SCRIPT_SHARADA:\n+    case HB_SCRIPT_TAKRI:\n+\n+    \/* Unicode-7.0 additions *\/\n+    case HB_SCRIPT_DUPLOYAN:\n+    case HB_SCRIPT_GRANTHA:\n+    case HB_SCRIPT_KHOJKI:\n+    case HB_SCRIPT_KHUDAWADI:\n+    case HB_SCRIPT_MAHAJANI:\n+    \/\/case HB_SCRIPT_MANICHAEAN:\n+    case HB_SCRIPT_MODI:\n+    case HB_SCRIPT_PAHAWH_HMONG:\n+    \/\/case HB_SCRIPT_PSALTER_PAHLAVI:\n+    case HB_SCRIPT_SIDDHAM:\n+    case HB_SCRIPT_TIRHUTA:\n+\n+    \/* Unicode-8.0 additions *\/\n+    case HB_SCRIPT_AHOM:\n+\n+    \/* Unicode-9.0 additions *\/\n+    \/\/case HB_SCRIPT_ADLAM:\n+    case HB_SCRIPT_BHAIKSUKI:\n+    case HB_SCRIPT_MARCHEN:\n+    case HB_SCRIPT_NEWA:\n+\n+    \/* Unicode-10.0 additions *\/\n+    case HB_SCRIPT_MASARAM_GONDI:\n+    case HB_SCRIPT_SOYOMBO:\n+    case HB_SCRIPT_ZANABAZAR_SQUARE:\n+\n+    \/* Unicode-11.0 additions *\/\n+    case HB_SCRIPT_DOGRA:\n+    case HB_SCRIPT_GUNJALA_GONDI:\n+    \/\/case HB_SCRIPT_HANIFI_ROHINGYA:\n+    case HB_SCRIPT_MAKASAR:\n+    \/\/case HB_SCRIPT_SOGDIAN:\n+\n+      \/* If the designer designed the font for the 'DFLT' script,\n+       * (or we ended up arbitrarily pick 'latn'), use the default shaper.\n+       * Otherwise, use the specific shaper.\n+       * Note that for some simple scripts, there may not be *any*\n+       * GSUB\/GPOS needed, so there may be no scripts found! *\/\n+      if (planner->map.chosen_script[0] == HB_TAG ('D','F','L','T') ||\n+          planner->map.chosen_script[0] == HB_TAG ('l','a','t','n'))\n+        return &_hb_ot_complex_shaper_default;\n+      else\n+        return &_hb_ot_complex_shaper_use;\n+  }\n+}\n+\n+\n+#endif \/* HB_OT_SHAPE_COMPLEX_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-complex.hh","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"@@ -0,0 +1,573 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-fallback.hh\"\n+#include \"hb-kern.hh\"\n+\n+static unsigned int\n+recategorize_combining_class (hb_codepoint_t u,\n+                              unsigned int klass)\n+{\n+  if (klass >= 200)\n+    return klass;\n+\n+  \/* Thai \/ Lao need some per-character work. *\/\n+  if ((u & ~0xFF) == 0x0E00u)\n+  {\n+    if (unlikely (klass == 0))\n+    {\n+      switch (u)\n+      {\n+        case 0x0E31u:\n+        case 0x0E34u:\n+        case 0x0E35u:\n+        case 0x0E36u:\n+        case 0x0E37u:\n+        case 0x0E47u:\n+        case 0x0E4Cu:\n+        case 0x0E4Du:\n+        case 0x0E4Eu:\n+          klass = HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT;\n+          break;\n+\n+        case 0x0EB1u:\n+        case 0x0EB4u:\n+        case 0x0EB5u:\n+        case 0x0EB6u:\n+        case 0x0EB7u:\n+        case 0x0EBBu:\n+        case 0x0ECCu:\n+        case 0x0ECDu:\n+          klass = HB_UNICODE_COMBINING_CLASS_ABOVE;\n+          break;\n+\n+        case 0x0EBCu:\n+          klass = HB_UNICODE_COMBINING_CLASS_BELOW;\n+          break;\n+      }\n+    } else {\n+      \/* Thai virama is below-right *\/\n+      if (u == 0x0E3Au)\n+        klass = HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT;\n+    }\n+  }\n+\n+  switch (klass)\n+  {\n+\n+    \/* Hebrew *\/\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC10: \/* sheva *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC11: \/* hataf segol *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC12: \/* hataf patah *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC13: \/* hataf qamats *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC14: \/* hiriq *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC15: \/* tsere *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC16: \/* segol *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC17: \/* patah *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC18: \/* qamats *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC20: \/* qubuts *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC22: \/* meteg *\/\n+      return HB_UNICODE_COMBINING_CLASS_BELOW;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC23: \/* rafe *\/\n+      return HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC24: \/* shin dot *\/\n+      return HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC25: \/* sin dot *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC19: \/* holam *\/\n+      return HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC26: \/* point varika *\/\n+      return HB_UNICODE_COMBINING_CLASS_ABOVE;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC21: \/* dagesh *\/\n+      break;\n+\n+\n+    \/* Arabic and Syriac *\/\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC27: \/* fathatan *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC28: \/* dammatan *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC30: \/* fatha *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC31: \/* damma *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC33: \/* shadda *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC34: \/* sukun *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC35: \/* superscript alef *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC36: \/* superscript alaph *\/\n+      return HB_UNICODE_COMBINING_CLASS_ABOVE;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC29: \/* kasratan *\/\n+    case HB_MODIFIED_COMBINING_CLASS_CCC32: \/* kasra *\/\n+      return HB_UNICODE_COMBINING_CLASS_BELOW;\n+\n+\n+    \/* Thai *\/\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC103: \/* sara u \/ sara uu *\/\n+      return HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC107: \/* mai *\/\n+      return HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT;\n+\n+\n+    \/* Lao *\/\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC118: \/* sign u \/ sign uu *\/\n+      return HB_UNICODE_COMBINING_CLASS_BELOW;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC122: \/* mai *\/\n+      return HB_UNICODE_COMBINING_CLASS_ABOVE;\n+\n+\n+    \/* Tibetan *\/\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC129: \/* sign aa *\/\n+      return HB_UNICODE_COMBINING_CLASS_BELOW;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC130: \/* sign i*\/\n+      return HB_UNICODE_COMBINING_CLASS_ABOVE;\n+\n+    case HB_MODIFIED_COMBINING_CLASS_CCC132: \/* sign u *\/\n+      return HB_UNICODE_COMBINING_CLASS_BELOW;\n+\n+  }\n+\n+  return klass;\n+}\n+\n+void\n+_hb_ot_shape_fallback_mark_position_recategorize_marks (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                                                        hb_font_t *font HB_UNUSED,\n+                                                        hb_buffer_t  *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    if (_hb_glyph_info_get_general_category (&info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK) {\n+      unsigned int combining_class = _hb_glyph_info_get_modified_combining_class (&info[i]);\n+      combining_class = recategorize_combining_class (info[i].codepoint, combining_class);\n+      _hb_glyph_info_set_modified_combining_class (&info[i], combining_class);\n+    }\n+}\n+\n+\n+static void\n+zero_mark_advances (hb_buffer_t *buffer,\n+                    unsigned int start,\n+                    unsigned int end,\n+                    bool adjust_offsets_when_zeroing)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = start; i < end; i++)\n+    if (_hb_glyph_info_get_general_category (&info[i]) == HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)\n+    {\n+      if (adjust_offsets_when_zeroing)\n+      {\n+        buffer->pos[i].x_offset -= buffer->pos[i].x_advance;\n+        buffer->pos[i].y_offset -= buffer->pos[i].y_advance;\n+      }\n+      buffer->pos[i].x_advance = 0;\n+      buffer->pos[i].y_advance = 0;\n+    }\n+}\n+\n+static inline void\n+position_mark (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+               hb_font_t *font,\n+               hb_buffer_t  *buffer,\n+               hb_glyph_extents_t &base_extents,\n+               unsigned int i,\n+               unsigned int combining_class)\n+{\n+  hb_glyph_extents_t mark_extents;\n+  if (!font->get_glyph_extents (buffer->info[i].codepoint, &mark_extents))\n+    return;\n+\n+  hb_position_t y_gap = font->y_scale \/ 16;\n+\n+  hb_glyph_position_t &pos = buffer->pos[i];\n+  pos.x_offset = pos.y_offset = 0;\n+\n+\n+  \/* We don't position LEFT and RIGHT marks. *\/\n+\n+  \/* X positioning *\/\n+  switch (combining_class)\n+  {\n+    case HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW:\n+    case HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE:\n+      if (buffer->props.direction == HB_DIRECTION_LTR) {\n+        pos.x_offset += base_extents.x_bearing + base_extents.width - mark_extents.width \/ 2 - mark_extents.x_bearing;\n+        break;\n+      } else if (buffer->props.direction == HB_DIRECTION_RTL) {\n+        pos.x_offset += base_extents.x_bearing - mark_extents.width \/ 2 - mark_extents.x_bearing;\n+        break;\n+      }\n+      HB_FALLTHROUGH;\n+\n+    default:\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW:\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE:\n+    case HB_UNICODE_COMBINING_CLASS_BELOW:\n+    case HB_UNICODE_COMBINING_CLASS_ABOVE:\n+      \/* Center align. *\/\n+      pos.x_offset += base_extents.x_bearing + (base_extents.width - mark_extents.width) \/ 2 - mark_extents.x_bearing;\n+      break;\n+\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT:\n+    case HB_UNICODE_COMBINING_CLASS_BELOW_LEFT:\n+    case HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT:\n+      \/* Left align. *\/\n+      pos.x_offset += base_extents.x_bearing - mark_extents.x_bearing;\n+      break;\n+\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT:\n+    case HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT:\n+    case HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT:\n+      \/* Right align. *\/\n+      pos.x_offset += base_extents.x_bearing + base_extents.width - mark_extents.width - mark_extents.x_bearing;\n+      break;\n+  }\n+\n+  \/* Y positioning *\/\n+  switch (combining_class)\n+  {\n+    case HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW:\n+    case HB_UNICODE_COMBINING_CLASS_BELOW_LEFT:\n+    case HB_UNICODE_COMBINING_CLASS_BELOW:\n+    case HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT:\n+      \/* Add gap, fall-through. *\/\n+      base_extents.height -= y_gap;\n+      HB_FALLTHROUGH;\n+\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT:\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW:\n+      pos.y_offset = base_extents.y_bearing + base_extents.height - mark_extents.y_bearing;\n+      \/* Never shift up \"below\" marks. *\/\n+      if ((y_gap > 0) == (pos.y_offset > 0))\n+      {\n+        base_extents.height -= pos.y_offset;\n+        pos.y_offset = 0;\n+      }\n+      base_extents.height += mark_extents.height;\n+      break;\n+\n+    case HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE:\n+    case HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT:\n+    case HB_UNICODE_COMBINING_CLASS_ABOVE:\n+    case HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT:\n+      \/* Add gap, fall-through. *\/\n+      base_extents.y_bearing += y_gap;\n+      base_extents.height -= y_gap;\n+      HB_FALLTHROUGH;\n+\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE:\n+    case HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT:\n+      pos.y_offset = base_extents.y_bearing - (mark_extents.y_bearing + mark_extents.height);\n+      \/* Don't shift down \"above\" marks too much. *\/\n+      if ((y_gap > 0) != (pos.y_offset > 0))\n+      {\n+        unsigned int correction = -pos.y_offset \/ 2;\n+        base_extents.y_bearing += correction;\n+        base_extents.height -= correction;\n+        pos.y_offset += correction;\n+      }\n+      base_extents.y_bearing -= mark_extents.height;\n+      base_extents.height += mark_extents.height;\n+      break;\n+  }\n+}\n+\n+static inline void\n+position_around_base (const hb_ot_shape_plan_t *plan,\n+                      hb_font_t *font,\n+                      hb_buffer_t  *buffer,\n+                      unsigned int base,\n+                      unsigned int end,\n+                      bool adjust_offsets_when_zeroing)\n+{\n+  hb_direction_t horiz_dir = HB_DIRECTION_INVALID;\n+\n+  buffer->unsafe_to_break (base, end);\n+\n+  hb_glyph_extents_t base_extents;\n+  if (!font->get_glyph_extents (buffer->info[base].codepoint,\n+                                &base_extents))\n+  {\n+    \/* If extents don't work, zero marks and go home. *\/\n+    zero_mark_advances (buffer, base + 1, end, adjust_offsets_when_zeroing);\n+    return;\n+  }\n+  base_extents.y_bearing += buffer->pos[base].y_offset;\n+  \/* Use horizontal advance for horizontal positioning.\n+   * Generally a better idea.  Also works for zero-ink glyphs.  See:\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1532 *\/\n+  base_extents.x_bearing = 0;\n+  base_extents.width = font->get_glyph_h_advance (buffer->info[base].codepoint);\n+\n+  unsigned int lig_id = _hb_glyph_info_get_lig_id (&buffer->info[base]);\n+  \/* Use integer for num_lig_components such that it doesn't convert to unsigned\n+   * when we divide or multiply by it. *\/\n+  int num_lig_components = _hb_glyph_info_get_lig_num_comps (&buffer->info[base]);\n+\n+  hb_position_t x_offset = 0, y_offset = 0;\n+  if (HB_DIRECTION_IS_FORWARD (buffer->props.direction)) {\n+    x_offset -= buffer->pos[base].x_advance;\n+    y_offset -= buffer->pos[base].y_advance;\n+  }\n+\n+  hb_glyph_extents_t component_extents = base_extents;\n+  int last_lig_component = -1;\n+  unsigned int last_combining_class = 255;\n+  hb_glyph_extents_t cluster_extents = base_extents; \/* Initialization is just to shut gcc up. *\/\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = base + 1; i < end; i++)\n+    if (_hb_glyph_info_get_modified_combining_class (&info[i]))\n+    {\n+      if (num_lig_components > 1) {\n+        unsigned int this_lig_id = _hb_glyph_info_get_lig_id (&info[i]);\n+        int this_lig_component = _hb_glyph_info_get_lig_comp (&info[i]) - 1;\n+        \/* Conditions for attaching to the last component. *\/\n+        if (!lig_id || lig_id != this_lig_id || this_lig_component >= num_lig_components)\n+          this_lig_component = num_lig_components - 1;\n+        if (last_lig_component != this_lig_component)\n+        {\n+          last_lig_component = this_lig_component;\n+          last_combining_class = 255;\n+          component_extents = base_extents;\n+          if (unlikely (horiz_dir == HB_DIRECTION_INVALID)) {\n+            if (HB_DIRECTION_IS_HORIZONTAL (plan->props.direction))\n+              horiz_dir = plan->props.direction;\n+            else\n+              horiz_dir = hb_script_get_horizontal_direction (plan->props.script);\n+          }\n+          if (horiz_dir == HB_DIRECTION_LTR)\n+            component_extents.x_bearing += (this_lig_component * component_extents.width) \/ num_lig_components;\n+          else\n+            component_extents.x_bearing += ((num_lig_components - 1 - this_lig_component) * component_extents.width) \/ num_lig_components;\n+          component_extents.width \/= num_lig_components;\n+        }\n+      }\n+\n+      unsigned int this_combining_class = _hb_glyph_info_get_modified_combining_class (&info[i]);\n+      if (last_combining_class != this_combining_class)\n+      {\n+        last_combining_class = this_combining_class;\n+        cluster_extents = component_extents;\n+      }\n+\n+      position_mark (plan, font, buffer, cluster_extents, i, this_combining_class);\n+\n+      buffer->pos[i].x_advance = 0;\n+      buffer->pos[i].y_advance = 0;\n+      buffer->pos[i].x_offset += x_offset;\n+      buffer->pos[i].y_offset += y_offset;\n+\n+    } else {\n+      if (HB_DIRECTION_IS_FORWARD (buffer->props.direction)) {\n+        x_offset -= buffer->pos[i].x_advance;\n+        y_offset -= buffer->pos[i].y_advance;\n+      } else {\n+        x_offset += buffer->pos[i].x_advance;\n+        y_offset += buffer->pos[i].y_advance;\n+      }\n+    }\n+}\n+\n+static inline void\n+position_cluster (const hb_ot_shape_plan_t *plan,\n+                  hb_font_t *font,\n+                  hb_buffer_t  *buffer,\n+                  unsigned int start,\n+                  unsigned int end,\n+                  bool adjust_offsets_when_zeroing)\n+{\n+  if (end - start < 2)\n+    return;\n+\n+  \/* Find the base glyph *\/\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = start; i < end; i++)\n+    if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&info[i])))\n+    {\n+      \/* Find mark glyphs *\/\n+      unsigned int j;\n+      for (j = i + 1; j < end; j++)\n+        if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&info[j])))\n+          break;\n+\n+      position_around_base (plan, font, buffer, i, j, adjust_offsets_when_zeroing);\n+\n+      i = j - 1;\n+    }\n+}\n+\n+void\n+_hb_ot_shape_fallback_mark_position (const hb_ot_shape_plan_t *plan,\n+                                     hb_font_t *font,\n+                                     hb_buffer_t  *buffer,\n+                                     bool adjust_offsets_when_zeroing)\n+{\n+  _hb_buffer_assert_gsubgpos_vars (buffer);\n+\n+  unsigned int start = 0;\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 1; i < count; i++)\n+    if (likely (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&info[i])))) {\n+      position_cluster (plan, font, buffer, start, i, adjust_offsets_when_zeroing);\n+      start = i;\n+    }\n+  position_cluster (plan, font, buffer, start, count, adjust_offsets_when_zeroing);\n+}\n+\n+\n+struct hb_ot_shape_fallback_kern_driver_t\n+{\n+  hb_ot_shape_fallback_kern_driver_t (hb_font_t   *font_,\n+                                      hb_buffer_t *buffer) :\n+    font (font_), direction (buffer->props.direction) {}\n+\n+  hb_position_t get_kerning (hb_codepoint_t first, hb_codepoint_t second) const\n+  {\n+    hb_position_t kern = 0;\n+    font->get_glyph_kerning_for_direction (first, second,\n+                                           direction,\n+                                           &kern, &kern);\n+    return kern;\n+  }\n+\n+  hb_font_t *font;\n+  hb_direction_t direction;\n+};\n+\n+\/* Performs font-assisted kerning. *\/\n+void\n+_hb_ot_shape_fallback_kern (const hb_ot_shape_plan_t *plan,\n+                            hb_font_t *font,\n+                            hb_buffer_t *buffer)\n+{\n+  if (HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction) ?\n+      !font->has_glyph_h_kerning_func () :\n+      !font->has_glyph_v_kerning_func ())\n+    return;\n+\n+  bool reverse = HB_DIRECTION_IS_BACKWARD (buffer->props.direction);\n+\n+  if (reverse)\n+    buffer->reverse ();\n+\n+  hb_ot_shape_fallback_kern_driver_t driver (font, buffer);\n+  OT::hb_kern_machine_t<hb_ot_shape_fallback_kern_driver_t> machine (driver);\n+  machine.kern (font, buffer, plan->kern_mask, false);\n+\n+  if (reverse)\n+    buffer->reverse ();\n+}\n+\n+\n+\/* Adjusts width of various spaces. *\/\n+void\n+_hb_ot_shape_fallback_spaces (const hb_ot_shape_plan_t *plan HB_UNUSED,\n+                              hb_font_t *font,\n+                              hb_buffer_t  *buffer)\n+{\n+  hb_glyph_info_t *info = buffer->info;\n+  hb_glyph_position_t *pos = buffer->pos;\n+  bool horizontal = HB_DIRECTION_IS_HORIZONTAL (buffer->props.direction);\n+  unsigned int count = buffer->len;\n+  for (unsigned int i = 0; i < count; i++)\n+    if (_hb_glyph_info_is_unicode_space (&info[i]) && !_hb_glyph_info_ligated (&info[i]))\n+    {\n+      hb_unicode_funcs_t::space_t space_type = _hb_glyph_info_get_unicode_space_fallback_type (&info[i]);\n+      hb_codepoint_t glyph;\n+      typedef hb_unicode_funcs_t t;\n+      switch (space_type)\n+      {\n+        case t::NOT_SPACE: \/* Shouldn't happen. *\/\n+        case t::SPACE:\n+          break;\n+\n+        case t::SPACE_EM:\n+        case t::SPACE_EM_2:\n+        case t::SPACE_EM_3:\n+        case t::SPACE_EM_4:\n+        case t::SPACE_EM_5:\n+        case t::SPACE_EM_6:\n+        case t::SPACE_EM_16:\n+          if (horizontal)\n+            pos[i].x_advance = +(font->x_scale + ((int) space_type)\/2) \/ (int) space_type;\n+          else\n+            pos[i].y_advance = -(font->y_scale + ((int) space_type)\/2) \/ (int) space_type;\n+          break;\n+\n+        case t::SPACE_4_EM_18:\n+          if (horizontal)\n+            pos[i].x_advance = (int64_t) +font->x_scale * 4 \/ 18;\n+          else\n+            pos[i].y_advance = (int64_t) -font->y_scale * 4 \/ 18;\n+          break;\n+\n+        case t::SPACE_FIGURE:\n+          for (char u = '0'; u <= '9'; u++)\n+            if (font->get_nominal_glyph (u, &glyph))\n+            {\n+              if (horizontal)\n+                pos[i].x_advance = font->get_glyph_h_advance (glyph);\n+              else\n+                pos[i].y_advance = font->get_glyph_v_advance (glyph);\n+              break;\n+            }\n+          break;\n+\n+        case t::SPACE_PUNCTUATION:\n+          if (font->get_nominal_glyph ('.', &glyph) ||\n+              font->get_nominal_glyph (',', &glyph))\n+          {\n+            if (horizontal)\n+              pos[i].x_advance = font->get_glyph_h_advance (glyph);\n+            else\n+              pos[i].y_advance = font->get_glyph_v_advance (glyph);\n+          }\n+          break;\n+\n+        case t::SPACE_NARROW:\n+          \/* Half-space?\n+           * Unicode doc https:\/\/unicode.org\/charts\/PDF\/U2000.pdf says ~1\/4 or 1\/5 of EM.\n+           * However, in my testing, many fonts have their regular space being about that\n+           * size.  To me, a percentage of the space width makes more sense.  Half is as\n+           * good as any. *\/\n+          if (horizontal)\n+            pos[i].x_advance \/= 2;\n+          else\n+            pos[i].y_advance \/= 2;\n+          break;\n+      }\n+    }\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-fallback.cc","additions":573,"deletions":0,"binary":false,"changes":573,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-fallback.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-fallback.hh","status":"copied"},{"patch":"@@ -0,0 +1,471 @@\n+\/*\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-ot-shape-normalize.hh\"\n+#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shape.hh\"\n+\n+\n+\/*\n+ * HIGHLEVEL DESIGN:\n+ *\n+ * This file exports one main function: _hb_ot_shape_normalize().\n+ *\n+ * This function closely reflects the Unicode Normalization Algorithm,\n+ * yet it's different.\n+ *\n+ * Each shaper specifies whether it prefers decomposed (NFD) or composed (NFC).\n+ * The logic however tries to use whatever the font can support.\n+ *\n+ * In general what happens is that: each grapheme is decomposed in a chain\n+ * of 1:2 decompositions, marks reordered, and then recomposed if desired,\n+ * so far it's like Unicode Normalization.  However, the decomposition and\n+ * recomposition only happens if the font supports the resulting characters.\n+ *\n+ * The goals are:\n+ *\n+ *   - Try to render all canonically equivalent strings similarly.  To really\n+ *     achieve this we have to always do the full decomposition and then\n+ *     selectively recompose from there.  It's kinda too expensive though, so\n+ *     we skip some cases.  For example, if composed is desired, we simply\n+ *     don't touch 1-character clusters that are supported by the font, even\n+ *     though their NFC may be different.\n+ *\n+ *   - When a font has a precomposed character for a sequence but the 'ccmp'\n+ *     feature in the font is not adequate, use the precomposed character\n+ *     which typically has better mark positioning.\n+ *\n+ *   - When a font does not support a combining mark, but supports it precomposed\n+ *     with previous base, use that.  This needs the itemizer to have this\n+ *     knowledge too.  We need to provide assistance to the itemizer.\n+ *\n+ *   - When a font does not support a character but supports its canonical\n+ *     decomposition, well, use the decomposition.\n+ *\n+ *   - The complex shapers can customize the compose and decompose functions to\n+ *     offload some of their requirements to the normalizer.  For example, the\n+ *     Indic shaper may want to disallow recomposing of two matras.\n+ *\/\n+\n+static bool\n+decompose_unicode (const hb_ot_shape_normalize_context_t *c,\n+                   hb_codepoint_t  ab,\n+                   hb_codepoint_t *a,\n+                   hb_codepoint_t *b)\n+{\n+  return (bool) c->unicode->decompose (ab, a, b);\n+}\n+\n+static bool\n+compose_unicode (const hb_ot_shape_normalize_context_t *c,\n+                 hb_codepoint_t  a,\n+                 hb_codepoint_t  b,\n+                 hb_codepoint_t *ab)\n+{\n+  return (bool) c->unicode->compose (a, b, ab);\n+}\n+\n+static inline void\n+set_glyph (hb_glyph_info_t &info, hb_font_t *font)\n+{\n+  (void) font->get_nominal_glyph (info.codepoint, &info.glyph_index());\n+}\n+\n+static inline void\n+output_char (hb_buffer_t *buffer, hb_codepoint_t unichar, hb_codepoint_t glyph)\n+{\n+  buffer->cur().glyph_index() = glyph;\n+  buffer->output_glyph (unichar); \/* This is very confusing indeed. *\/\n+  _hb_glyph_info_set_unicode_props (&buffer->prev(), buffer);\n+}\n+\n+static inline void\n+next_char (hb_buffer_t *buffer, hb_codepoint_t glyph)\n+{\n+  buffer->cur().glyph_index() = glyph;\n+  buffer->next_glyph ();\n+}\n+\n+static inline void\n+skip_char (hb_buffer_t *buffer)\n+{\n+  buffer->skip_glyph ();\n+}\n+\n+\/* Returns 0 if didn't decompose, number of resulting characters otherwise. *\/\n+static inline unsigned int\n+decompose (const hb_ot_shape_normalize_context_t *c, bool shortest, hb_codepoint_t ab)\n+{\n+  hb_codepoint_t a = 0, b = 0, a_glyph = 0, b_glyph = 0;\n+  hb_buffer_t * const buffer = c->buffer;\n+  hb_font_t * const font = c->font;\n+\n+  if (!c->decompose (c, ab, &a, &b) ||\n+      (b && !font->get_nominal_glyph (b, &b_glyph)))\n+    return 0;\n+\n+  bool has_a = (bool) font->get_nominal_glyph (a, &a_glyph);\n+  if (shortest && has_a) {\n+    \/* Output a and b *\/\n+    output_char (buffer, a, a_glyph);\n+    if (likely (b)) {\n+      output_char (buffer, b, b_glyph);\n+      return 2;\n+    }\n+    return 1;\n+  }\n+\n+  unsigned int ret;\n+  if ((ret = decompose (c, shortest, a))) {\n+    if (b) {\n+      output_char (buffer, b, b_glyph);\n+      return ret + 1;\n+    }\n+    return ret;\n+  }\n+\n+  if (has_a) {\n+    output_char (buffer, a, a_glyph);\n+    if (likely (b)) {\n+      output_char (buffer, b, b_glyph);\n+      return 2;\n+    }\n+    return 1;\n+  }\n+\n+  return 0;\n+}\n+\n+static inline void\n+decompose_current_character (const hb_ot_shape_normalize_context_t *c, bool shortest)\n+{\n+  hb_buffer_t * const buffer = c->buffer;\n+  hb_codepoint_t u = buffer->cur().codepoint;\n+  hb_codepoint_t glyph = 0;\n+\n+  if (shortest && c->font->get_nominal_glyph (u, &glyph))\n+  {\n+    next_char (buffer, glyph);\n+    return;\n+  }\n+\n+  if (decompose (c, shortest, u))\n+  {\n+    skip_char (buffer);\n+    return;\n+  }\n+\n+  if (!shortest && c->font->get_nominal_glyph (u, &glyph))\n+  {\n+    next_char (buffer, glyph);\n+    return;\n+  }\n+\n+  if (_hb_glyph_info_is_unicode_space (&buffer->cur()))\n+  {\n+    hb_codepoint_t space_glyph;\n+    hb_unicode_funcs_t::space_t space_type = buffer->unicode->space_fallback_type (u);\n+    if (space_type != hb_unicode_funcs_t::NOT_SPACE && c->font->get_nominal_glyph (0x0020u, &space_glyph))\n+    {\n+      _hb_glyph_info_set_unicode_space_fallback_type (&buffer->cur(), space_type);\n+      next_char (buffer, space_glyph);\n+      buffer->scratch_flags |= HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK;\n+      return;\n+    }\n+  }\n+\n+  if (u == 0x2011u)\n+  {\n+    \/* U+2011 is the only sensible character that is a no-break version of another character\n+     * and not a space.  The space ones are handled already.  Handle this lone one. *\/\n+    hb_codepoint_t other_glyph;\n+    if (c->font->get_nominal_glyph (0x2010u, &other_glyph))\n+    {\n+      next_char (buffer, other_glyph);\n+      return;\n+    }\n+  }\n+\n+  next_char (buffer, glyph); \/* glyph is initialized in earlier branches. *\/\n+}\n+\n+static inline void\n+handle_variation_selector_cluster (const hb_ot_shape_normalize_context_t *c,\n+                                   unsigned int end,\n+                                   bool short_circuit HB_UNUSED)\n+{\n+  \/* TODO Currently if there's a variation-selector we give-up, it's just too hard. *\/\n+  hb_buffer_t * const buffer = c->buffer;\n+  hb_font_t * const font = c->font;\n+  for (; buffer->idx < end - 1 && buffer->successful;) {\n+    if (unlikely (buffer->unicode->is_variation_selector (buffer->cur(+1).codepoint))) {\n+      if (font->get_variation_glyph (buffer->cur().codepoint, buffer->cur(+1).codepoint, &buffer->cur().glyph_index()))\n+      {\n+        hb_codepoint_t unicode = buffer->cur().codepoint;\n+        buffer->replace_glyphs (2, 1, &unicode);\n+      }\n+      else\n+      {\n+        \/* Just pass on the two characters separately, let GSUB do its magic. *\/\n+        set_glyph (buffer->cur(), font);\n+        buffer->next_glyph ();\n+        set_glyph (buffer->cur(), font);\n+        buffer->next_glyph ();\n+      }\n+      \/* Skip any further variation selectors. *\/\n+      while (buffer->idx < end && unlikely (buffer->unicode->is_variation_selector (buffer->cur().codepoint)))\n+      {\n+        set_glyph (buffer->cur(), font);\n+        buffer->next_glyph ();\n+      }\n+    } else {\n+      set_glyph (buffer->cur(), font);\n+      buffer->next_glyph ();\n+    }\n+  }\n+  if (likely (buffer->idx < end)) {\n+    set_glyph (buffer->cur(), font);\n+    buffer->next_glyph ();\n+  }\n+}\n+\n+static inline void\n+decompose_multi_char_cluster (const hb_ot_shape_normalize_context_t *c, unsigned int end, bool short_circuit)\n+{\n+  hb_buffer_t * const buffer = c->buffer;\n+  for (unsigned int i = buffer->idx; i < end && buffer->successful; i++)\n+    if (unlikely (buffer->unicode->is_variation_selector (buffer->info[i].codepoint))) {\n+      handle_variation_selector_cluster (c, end, short_circuit);\n+      return;\n+    }\n+\n+  while (buffer->idx < end && buffer->successful)\n+    decompose_current_character (c, short_circuit);\n+}\n+\n+\n+static int\n+compare_combining_class (const hb_glyph_info_t *pa, const hb_glyph_info_t *pb)\n+{\n+  unsigned int a = _hb_glyph_info_get_modified_combining_class (pa);\n+  unsigned int b = _hb_glyph_info_get_modified_combining_class (pb);\n+\n+  return a < b ? -1 : a == b ? 0 : +1;\n+}\n+\n+\n+void\n+_hb_ot_shape_normalize (const hb_ot_shape_plan_t *plan,\n+                        hb_buffer_t *buffer,\n+                        hb_font_t *font)\n+{\n+  if (unlikely (!buffer->len)) return;\n+\n+  _hb_buffer_assert_unicode_vars (buffer);\n+\n+  hb_ot_shape_normalization_mode_t mode = plan->shaper->normalization_preference;\n+  if (mode == HB_OT_SHAPE_NORMALIZATION_MODE_AUTO)\n+  {\n+    if (plan->has_gpos_mark)\n+      \/\/ https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/653#issuecomment-423905920\n+      \/\/mode = HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED;\n+      mode = HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;\n+    else\n+      mode = HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS;\n+  }\n+\n+  const hb_ot_shape_normalize_context_t c = {\n+    plan,\n+    buffer,\n+    font,\n+    buffer->unicode,\n+    plan->shaper->decompose ? plan->shaper->decompose : decompose_unicode,\n+    plan->shaper->compose   ? plan->shaper->compose   : compose_unicode\n+  };\n+\n+  bool always_short_circuit = mode == HB_OT_SHAPE_NORMALIZATION_MODE_NONE;\n+  bool might_short_circuit = always_short_circuit ||\n+                             (mode != HB_OT_SHAPE_NORMALIZATION_MODE_DECOMPOSED &&\n+                              mode != HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT);\n+  unsigned int count;\n+\n+  \/* We do a fairly straightforward yet custom normalization process in three\n+   * separate rounds: decompose, reorder, recompose (if desired).  Currently\n+   * this makes two buffer swaps.  We can make it faster by moving the last\n+   * two rounds into the inner loop for the first round, but it's more readable\n+   * this way. *\/\n+\n+\n+  \/* First round, decompose *\/\n+\n+  bool all_simple = true;\n+  {\n+    buffer->clear_output ();\n+    count = buffer->len;\n+    buffer->idx = 0;\n+    do\n+    {\n+      unsigned int end;\n+      for (end = buffer->idx + 1; end < count; end++)\n+        if (unlikely (HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&buffer->info[end]))))\n+          break;\n+\n+      if (end < count)\n+        end--; \/* Leave one base for the marks to cluster with. *\/\n+\n+      \/* From idx to end are simple clusters. *\/\n+      if (might_short_circuit)\n+      {\n+        unsigned int done = font->get_nominal_glyphs (end - buffer->idx,\n+                                                      &buffer->cur().codepoint,\n+                                                      sizeof (buffer->info[0]),\n+                                                      &buffer->cur().glyph_index(),\n+                                                      sizeof (buffer->info[0]));\n+        buffer->next_glyphs (done);\n+      }\n+      while (buffer->idx < end && buffer->successful)\n+        decompose_current_character (&c, might_short_circuit);\n+\n+      if (buffer->idx == count || !buffer->successful)\n+        break;\n+\n+      all_simple = false;\n+\n+      \/* Find all the marks now. *\/\n+      for (end = buffer->idx + 1; end < count; end++)\n+        if (!HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&buffer->info[end])))\n+          break;\n+\n+      \/* idx to end is one non-simple cluster. *\/\n+      decompose_multi_char_cluster (&c, end, always_short_circuit);\n+    }\n+    while (buffer->idx < count && buffer->successful);\n+    buffer->swap_buffers ();\n+  }\n+\n+\n+  \/* Second round, reorder (inplace) *\/\n+\n+  if (!all_simple)\n+  {\n+    count = buffer->len;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (_hb_glyph_info_get_modified_combining_class (&buffer->info[i]) == 0)\n+        continue;\n+\n+      unsigned int end;\n+      for (end = i + 1; end < count; end++)\n+        if (_hb_glyph_info_get_modified_combining_class (&buffer->info[end]) == 0)\n+          break;\n+\n+      \/* We are going to do a O(n^2).  Only do this if the sequence is short. *\/\n+      if (end - i > HB_OT_SHAPE_COMPLEX_MAX_COMBINING_MARKS) {\n+        i = end;\n+        continue;\n+      }\n+\n+      buffer->sort (i, end, compare_combining_class);\n+\n+      if (plan->shaper->reorder_marks)\n+        plan->shaper->reorder_marks (plan, buffer, i, end);\n+\n+      i = end;\n+    }\n+  }\n+  if (buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_CGJ)\n+  {\n+    \/* For all CGJ, check if it prevented any reordering at all.\n+     * If it did NOT, then make it skippable.\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/554\n+     *\/\n+    for (unsigned int i = 1; i + 1 < buffer->len; i++)\n+      if (buffer->info[i].codepoint == 0x034Fu\/*CGJ*\/ &&\n+          info_cc(buffer->info[i-1]) <= info_cc(buffer->info[i+1]))\n+      {\n+        _hb_glyph_info_unhide (&buffer->info[i]);\n+      }\n+  }\n+\n+\n+  \/* Third round, recompose *\/\n+\n+  if (!all_simple &&\n+      (mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS ||\n+       mode == HB_OT_SHAPE_NORMALIZATION_MODE_COMPOSED_DIACRITICS_NO_SHORT_CIRCUIT))\n+  {\n+    \/* As noted in the comment earlier, we don't try to combine\n+     * ccc=0 chars with their previous Starter. *\/\n+\n+    buffer->clear_output ();\n+    count = buffer->len;\n+    unsigned int starter = 0;\n+    buffer->next_glyph ();\n+    while (buffer->idx < count && buffer->successful)\n+    {\n+      hb_codepoint_t composed, glyph;\n+      if (\/* We don't try to compose a non-mark character with it's preceding starter.\n+           * This is both an optimization to avoid trying to compose every two neighboring\n+           * glyphs in most scripts AND a desired feature for Hangul.  Apparently Hangul\n+           * fonts are not designed to mix-and-match pre-composed syllables and Jamo. *\/\n+          HB_UNICODE_GENERAL_CATEGORY_IS_MARK (_hb_glyph_info_get_general_category (&buffer->cur())))\n+      {\n+        if (\/* If there's anything between the starter and this char, they should have CCC\n+             * smaller than this character's. *\/\n+            (starter == buffer->out_len - 1 ||\n+             info_cc (buffer->prev()) < info_cc (buffer->cur())) &&\n+            \/* And compose. *\/\n+            c.compose (&c,\n+                       buffer->out_info[starter].codepoint,\n+                       buffer->cur().codepoint,\n+                       &composed) &&\n+            \/* And the font has glyph for the composite. *\/\n+            font->get_nominal_glyph (composed, &glyph))\n+        {\n+          \/* Composes. *\/\n+          buffer->next_glyph (); \/* Copy to out-buffer. *\/\n+          if (unlikely (!buffer->successful))\n+            return;\n+          buffer->merge_out_clusters (starter, buffer->out_len);\n+          buffer->out_len--; \/* Remove the second composable. *\/\n+          \/* Modify starter and carry on. *\/\n+          buffer->out_info[starter].codepoint = composed;\n+          buffer->out_info[starter].glyph_index() = glyph;\n+          _hb_glyph_info_set_unicode_props (&buffer->out_info[starter], buffer);\n+\n+          continue;\n+        }\n+      }\n+\n+      \/* Blocked, or doesn't compose. *\/\n+      buffer->next_glyph ();\n+\n+      if (info_cc (buffer->prev()) == 0)\n+        starter = buffer->out_len - 1;\n+    }\n+    buffer->swap_buffers ();\n+  }\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-normalize.cc","additions":471,"deletions":0,"binary":false,"changes":471,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape-normalize.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-ot-shape-normalize.hh","status":"copied"},{"patch":"@@ -0,0 +1,1083 @@\n+\/*\n+ * Copyright © 2009,2010  Red Hat, Inc.\n+ * Copyright © 2010,2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-shaper-impl.hh\"\n+\n+#include \"hb-ot-shape.hh\"\n+#include \"hb-ot-shape-complex.hh\"\n+#include \"hb-ot-shape-fallback.hh\"\n+#include \"hb-ot-shape-normalize.hh\"\n+\n+#include \"hb-ot-face.hh\"\n+\n+#include \"hb-set.hh\"\n+\n+#include \"hb-aat-layout.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-ot-shape\n+ * @title: hb-ot-shape\n+ * @short_description: OpenType shaping support\n+ * @include: hb-ot.h\n+ *\n+ * Support functions for OpenType shaping related queries.\n+ **\/\n+\n+\n+static void\n+hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,\n+                              const hb_feature_t             *user_features,\n+                              unsigned int                    num_user_features);\n+\n+static bool\n+_hb_apply_morx (hb_face_t *face)\n+{\n+  if (hb_options ().aat &&\n+      hb_aat_layout_has_substitution (face))\n+    return true;\n+\n+  \/* Ignore empty GSUB tables. *\/\n+  return (!hb_ot_layout_has_substitution (face) ||\n+          !hb_ot_layout_table_get_script_tags (face,\n+                                               HB_OT_TAG_GSUB,\n+                                               0, nullptr, nullptr)) &&\n+         hb_aat_layout_has_substitution (face);\n+}\n+\n+hb_ot_shape_planner_t::hb_ot_shape_planner_t (hb_face_t                     *face,\n+                                              const hb_segment_properties_t *props) :\n+                                                face (face),\n+                                                props (*props),\n+                                                map (face, props),\n+                                                aat_map (face, props),\n+                                                apply_morx (_hb_apply_morx (face))\n+{\n+  shaper = hb_ot_shape_complex_categorize (this);\n+\n+  script_zero_marks = shaper->zero_width_marks != HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE;\n+  script_fallback_mark_positioning = shaper->fallback_position;\n+\n+  if (apply_morx)\n+    shaper = &_hb_ot_complex_shaper_default;\n+}\n+\n+void\n+hb_ot_shape_planner_t::compile (hb_ot_shape_plan_t           &plan,\n+                                const hb_ot_shape_plan_key_t &key)\n+{\n+  plan.props = props;\n+  plan.shaper = shaper;\n+  map.compile (plan.map, key);\n+  if (apply_morx)\n+    aat_map.compile (plan.aat_map);\n+\n+  plan.frac_mask = plan.map.get_1_mask (HB_TAG ('f','r','a','c'));\n+  plan.numr_mask = plan.map.get_1_mask (HB_TAG ('n','u','m','r'));\n+  plan.dnom_mask = plan.map.get_1_mask (HB_TAG ('d','n','o','m'));\n+  plan.has_frac = plan.frac_mask || (plan.numr_mask && plan.dnom_mask);\n+  plan.rtlm_mask = plan.map.get_1_mask (HB_TAG ('r','t','l','m'));\n+  hb_tag_t kern_tag = HB_DIRECTION_IS_HORIZONTAL (props.direction) ?\n+                      HB_TAG ('k','e','r','n') : HB_TAG ('v','k','r','n');\n+  plan.kern_mask = plan.map.get_mask (kern_tag);\n+  plan.trak_mask = plan.map.get_mask (HB_TAG ('t','r','a','k'));\n+\n+  plan.requested_kerning = !!plan.kern_mask;\n+  plan.requested_tracking = !!plan.trak_mask;\n+  bool has_gpos_kern = plan.map.get_feature_index (1, kern_tag) != HB_OT_LAYOUT_NO_FEATURE_INDEX;\n+  bool disable_gpos = plan.shaper->gpos_tag &&\n+                      plan.shaper->gpos_tag != plan.map.chosen_script[1];\n+\n+  \/*\n+   * Decide who provides glyph classes. GDEF or Unicode.\n+   *\/\n+\n+  if (!hb_ot_layout_has_glyph_classes (face))\n+    plan.fallback_glyph_classes = true;\n+\n+  \/*\n+   * Decide who does substitutions. GSUB, morx, or fallback.\n+   *\/\n+\n+  plan.apply_morx = apply_morx;\n+\n+  \/*\n+   * Decide who does positioning. GPOS, kerx, kern, or fallback.\n+   *\/\n+\n+  if (hb_options ().aat && hb_aat_layout_has_positioning (face))\n+    plan.apply_kerx = true;\n+  else if (!apply_morx && !disable_gpos && hb_ot_layout_has_positioning (face))\n+    plan.apply_gpos = true;\n+  else if (hb_aat_layout_has_positioning (face))\n+    plan.apply_kerx = true;\n+\n+  if (!plan.apply_kerx && !has_gpos_kern)\n+  {\n+    \/* Apparently Apple applies kerx if GPOS kern was not applied. *\/\n+    if (hb_aat_layout_has_positioning (face))\n+      plan.apply_kerx = true;\n+    else if (hb_ot_layout_has_kerning (face))\n+      plan.apply_kern = true;\n+  }\n+\n+  plan.zero_marks = script_zero_marks &&\n+                    !plan.apply_kerx &&\n+                    (!plan.apply_kern || !hb_ot_layout_has_machine_kerning (face));\n+  plan.has_gpos_mark = !!plan.map.get_1_mask (HB_TAG ('m','a','r','k'));\n+\n+  plan.adjust_mark_positioning_when_zeroing = !plan.apply_gpos &&\n+                                              !plan.apply_kerx &&\n+                                              (!plan.apply_kern || !hb_ot_layout_has_cross_kerning (face));\n+\n+  plan.fallback_mark_positioning = plan.adjust_mark_positioning_when_zeroing &&\n+                                   script_fallback_mark_positioning;\n+\n+  \/* Currently we always apply trak. *\/\n+  plan.apply_trak = plan.requested_tracking && hb_aat_layout_has_tracking (face);\n+}\n+\n+bool\n+hb_ot_shape_plan_t::init0 (hb_face_t                     *face,\n+                           const hb_shape_plan_key_t     *key)\n+{\n+  map.init ();\n+  aat_map.init ();\n+\n+  hb_ot_shape_planner_t planner (face,\n+                                 &key->props);\n+\n+  hb_ot_shape_collect_features (&planner,\n+                                key->user_features,\n+                                key->num_user_features);\n+\n+  planner.compile (*this, key->ot);\n+\n+  if (shaper->data_create)\n+  {\n+    data = shaper->data_create (this);\n+    if (unlikely (!data))\n+      return false;\n+  }\n+\n+  return true;\n+}\n+\n+void\n+hb_ot_shape_plan_t::fini ()\n+{\n+  if (shaper->data_destroy)\n+    shaper->data_destroy (const_cast<void *> (data));\n+\n+  map.fini ();\n+  aat_map.fini ();\n+}\n+\n+void\n+hb_ot_shape_plan_t::substitute (hb_font_t   *font,\n+                                hb_buffer_t *buffer) const\n+{\n+  if (unlikely (apply_morx))\n+    hb_aat_layout_substitute (this, font, buffer);\n+  else\n+    map.substitute (this, font, buffer);\n+}\n+\n+void\n+hb_ot_shape_plan_t::position (hb_font_t   *font,\n+                              hb_buffer_t *buffer) const\n+{\n+  if (this->apply_gpos)\n+    map.position (this, font, buffer);\n+  else if (this->apply_kerx)\n+    hb_aat_layout_position (this, font, buffer);\n+  else if (this->apply_kern)\n+    hb_ot_layout_kern (this, font, buffer);\n+  else\n+    _hb_ot_shape_fallback_kern (this, font, buffer);\n+\n+  if (this->apply_trak)\n+    hb_aat_layout_track (this, font, buffer);\n+}\n+\n+\n+static const hb_ot_map_feature_t\n+common_features[] =\n+{\n+  {HB_TAG('c','c','m','p'), F_GLOBAL},\n+  {HB_TAG('l','o','c','l'), F_GLOBAL},\n+  {HB_TAG('m','a','r','k'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('m','k','m','k'), F_GLOBAL_MANUAL_JOINERS},\n+  {HB_TAG('r','l','i','g'), F_GLOBAL},\n+};\n+\n+\n+static const hb_ot_map_feature_t\n+horizontal_features[] =\n+{\n+  {HB_TAG('c','a','l','t'), F_GLOBAL},\n+  {HB_TAG('c','l','i','g'), F_GLOBAL},\n+  {HB_TAG('c','u','r','s'), F_GLOBAL},\n+  {HB_TAG('k','e','r','n'), F_GLOBAL_HAS_FALLBACK},\n+  {HB_TAG('l','i','g','a'), F_GLOBAL},\n+  {HB_TAG('r','c','l','t'), F_GLOBAL},\n+};\n+\n+static void\n+hb_ot_shape_collect_features (hb_ot_shape_planner_t          *planner,\n+                              const hb_feature_t             *user_features,\n+                              unsigned int                    num_user_features)\n+{\n+  hb_ot_map_builder_t *map = &planner->map;\n+\n+  map->enable_feature (HB_TAG('r','v','r','n'));\n+  map->add_gsub_pause (nullptr);\n+\n+  switch (planner->props.direction) {\n+    case HB_DIRECTION_LTR:\n+      map->enable_feature (HB_TAG ('l','t','r','a'));\n+      map->enable_feature (HB_TAG ('l','t','r','m'));\n+      break;\n+    case HB_DIRECTION_RTL:\n+      map->enable_feature (HB_TAG ('r','t','l','a'));\n+      map->add_feature (HB_TAG ('r','t','l','m'));\n+      break;\n+    case HB_DIRECTION_TTB:\n+    case HB_DIRECTION_BTT:\n+    case HB_DIRECTION_INVALID:\n+    default:\n+      break;\n+  }\n+\n+  \/* Automatic fractions. *\/\n+  map->add_feature (HB_TAG ('f','r','a','c'));\n+  map->add_feature (HB_TAG ('n','u','m','r'));\n+  map->add_feature (HB_TAG ('d','n','o','m'));\n+\n+  \/* Random! *\/\n+  map->enable_feature (HB_TAG ('r','a','n','d'), F_RANDOM, HB_OT_MAP_MAX_VALUE);\n+\n+  \/* Tracking.  We enable dummy feature here just to allow disabling\n+   * AAT 'trak' table using features.\n+   * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1303 *\/\n+  map->enable_feature (HB_TAG ('t','r','a','k'), F_HAS_FALLBACK);\n+\n+  map->enable_feature (HB_TAG ('H','A','R','F'));\n+\n+  if (planner->shaper->collect_features)\n+    planner->shaper->collect_features (planner);\n+\n+  map->enable_feature (HB_TAG ('B','U','Z','Z'));\n+\n+  for (unsigned int i = 0; i < ARRAY_LENGTH (common_features); i++)\n+    map->add_feature (common_features[i]);\n+\n+  if (HB_DIRECTION_IS_HORIZONTAL (planner->props.direction))\n+    for (unsigned int i = 0; i < ARRAY_LENGTH (horizontal_features); i++)\n+      map->add_feature (horizontal_features[i]);\n+  else\n+  {\n+    \/* We really want to find a 'vert' feature if there's any in the font, no\n+     * matter which script\/langsys it is listed (or not) under.\n+     * See various bugs referenced from:\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/63 *\/\n+    map->enable_feature (HB_TAG ('v','e','r','t'), F_GLOBAL_SEARCH);\n+  }\n+\n+  for (unsigned int i = 0; i < num_user_features; i++)\n+  {\n+    const hb_feature_t *feature = &user_features[i];\n+    map->add_feature (feature->tag,\n+                      (feature->start == HB_FEATURE_GLOBAL_START &&\n+                       feature->end == HB_FEATURE_GLOBAL_END) ?  F_GLOBAL : F_NONE,\n+                      feature->value);\n+  }\n+\n+  if (planner->apply_morx)\n+  {\n+    hb_aat_map_builder_t *aat_map = &planner->aat_map;\n+    for (unsigned int i = 0; i < num_user_features; i++)\n+    {\n+      const hb_feature_t *feature = &user_features[i];\n+      aat_map->add_feature (feature->tag, feature->value);\n+    }\n+  }\n+\n+  if (planner->shaper->override_features)\n+    planner->shaper->override_features (planner);\n+}\n+\n+\n+\/*\n+ * shaper face data\n+ *\/\n+\n+struct hb_ot_face_data_t {};\n+\n+hb_ot_face_data_t *\n+_hb_ot_shaper_face_data_create (hb_face_t *face)\n+{\n+  return (hb_ot_face_data_t *) HB_SHAPER_DATA_SUCCEEDED;\n+}\n+\n+void\n+_hb_ot_shaper_face_data_destroy (hb_ot_face_data_t *data)\n+{\n+}\n+\n+\n+\/*\n+ * shaper font data\n+ *\/\n+\n+struct hb_ot_font_data_t {};\n+\n+hb_ot_font_data_t *\n+_hb_ot_shaper_font_data_create (hb_font_t *font HB_UNUSED)\n+{\n+  return (hb_ot_font_data_t *) HB_SHAPER_DATA_SUCCEEDED;\n+}\n+\n+void\n+_hb_ot_shaper_font_data_destroy (hb_ot_font_data_t *data HB_UNUSED)\n+{\n+}\n+\n+\n+\/*\n+ * shaper\n+ *\/\n+\n+struct hb_ot_shape_context_t\n+{\n+  hb_ot_shape_plan_t *plan;\n+  hb_font_t *font;\n+  hb_face_t *face;\n+  hb_buffer_t  *buffer;\n+  const hb_feature_t *user_features;\n+  unsigned int        num_user_features;\n+\n+  \/* Transient stuff *\/\n+  hb_direction_t target_direction;\n+};\n+\n+\n+\n+\/* Main shaper *\/\n+\n+\n+\/* Prepare *\/\n+\n+static void\n+hb_set_unicode_props (hb_buffer_t *buffer)\n+{\n+  \/* Implement enough of Unicode Graphemes here that shaping\n+   * in reverse-direction wouldn't break graphemes.  Namely,\n+   * we mark all marks and ZWJ and ZWJ,Extended_Pictographic\n+   * sequences as continuations.  The foreach_grapheme()\n+   * macro uses this bit.\n+   *\n+   * https:\/\/www.unicode.org\/reports\/tr29\/#Regex_Definitions\n+   *\/\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    _hb_glyph_info_set_unicode_props (&info[i], buffer);\n+\n+    \/* Marks are already set as continuation by the above line.\n+     * Handle Emoji_Modifier and ZWJ-continuation. *\/\n+    if (unlikely (_hb_glyph_info_get_general_category (&info[i]) == HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL &&\n+                  hb_in_range<hb_codepoint_t> (info[i].codepoint, 0x1F3FBu, 0x1F3FFu)))\n+    {\n+        _hb_glyph_info_set_continuation (&info[i]);\n+    }\n+    else if (unlikely (_hb_glyph_info_is_zwj (&info[i])))\n+    {\n+      _hb_glyph_info_set_continuation (&info[i]);\n+      if (i + 1 < count &&\n+          _hb_unicode_is_emoji_Extended_Pictographic (info[i + 1].codepoint))\n+      {\n+        i++;\n+        _hb_glyph_info_set_unicode_props (&info[i], buffer);\n+        _hb_glyph_info_set_continuation (&info[i]);\n+      }\n+    }\n+    \/* Or part of the Other_Grapheme_Extend that is not marks.\n+     * As of Unicode 11 that is just:\n+     *\n+     * 200C          ; Other_Grapheme_Extend # Cf       ZERO WIDTH NON-JOINER\n+     * FF9E..FF9F    ; Other_Grapheme_Extend # Lm   [2] HALFWIDTH KATAKANA VOICED SOUND MARK..HALFWIDTH KATAKANA SEMI-VOICED SOUND MARK\n+     * E0020..E007F  ; Other_Grapheme_Extend # Cf  [96] TAG SPACE..CANCEL TAG\n+     *\n+     * ZWNJ is special, we don't want to merge it as there's no need, and keeping\n+     * it separate results in more granular clusters.  Ignore Katakana for now.\n+     * Tags are used for Emoji sub-region flag sequences:\n+     * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1556\n+     *\/\n+    else if (unlikely (hb_in_range<hb_codepoint_t> (info[i].codepoint, 0xE0020u, 0xE007Fu)))\n+      _hb_glyph_info_set_continuation (&info[i]);\n+  }\n+}\n+\n+static void\n+hb_insert_dotted_circle (hb_buffer_t *buffer, hb_font_t *font)\n+{\n+  if (!(buffer->flags & HB_BUFFER_FLAG_BOT) ||\n+      buffer->context_len[0] ||\n+      !_hb_glyph_info_is_unicode_mark (&buffer->info[0]))\n+    return;\n+\n+  if (!font->has_glyph (0x25CCu))\n+    return;\n+\n+  hb_glyph_info_t dottedcircle = {0};\n+  dottedcircle.codepoint = 0x25CCu;\n+  _hb_glyph_info_set_unicode_props (&dottedcircle, buffer);\n+\n+  buffer->clear_output ();\n+\n+  buffer->idx = 0;\n+  hb_glyph_info_t info = dottedcircle;\n+  info.cluster = buffer->cur().cluster;\n+  info.mask = buffer->cur().mask;\n+  buffer->output_info (info);\n+  while (buffer->idx < buffer->len && buffer->successful)\n+    buffer->next_glyph ();\n+  buffer->swap_buffers ();\n+}\n+\n+static void\n+hb_form_clusters (hb_buffer_t *buffer)\n+{\n+  if (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII))\n+    return;\n+\n+  if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_GRAPHEMES)\n+    foreach_grapheme (buffer, start, end)\n+      buffer->merge_clusters (start, end);\n+  else\n+    foreach_grapheme (buffer, start, end)\n+      buffer->unsafe_to_break (start, end);\n+}\n+\n+static void\n+hb_ensure_native_direction (hb_buffer_t *buffer)\n+{\n+  hb_direction_t direction = buffer->props.direction;\n+  hb_direction_t horiz_dir = hb_script_get_horizontal_direction (buffer->props.script);\n+\n+  \/* TODO vertical:\n+   * The only BTT vertical script is Ogham, but it's not clear to me whether OpenType\n+   * Ogham fonts are supposed to be implemented BTT or not.  Need to research that\n+   * first. *\/\n+  if ((HB_DIRECTION_IS_HORIZONTAL (direction) &&\n+       direction != horiz_dir && horiz_dir != HB_DIRECTION_INVALID) ||\n+      (HB_DIRECTION_IS_VERTICAL   (direction) &&\n+       direction != HB_DIRECTION_TTB))\n+  {\n+\n+    if (buffer->cluster_level == HB_BUFFER_CLUSTER_LEVEL_MONOTONE_CHARACTERS)\n+      foreach_grapheme (buffer, start, end)\n+      {\n+        buffer->merge_clusters (start, end);\n+        buffer->reverse_range (start, end);\n+      }\n+    else\n+      foreach_grapheme (buffer, start, end)\n+        \/* form_clusters() merged clusters already, we don't merge. *\/\n+        buffer->reverse_range (start, end);\n+\n+    buffer->reverse ();\n+\n+    buffer->props.direction = HB_DIRECTION_REVERSE (buffer->props.direction);\n+  }\n+}\n+\n+\n+\/*\n+ * Substitute\n+ *\/\n+\n+static inline void\n+hb_ot_mirror_chars (const hb_ot_shape_context_t *c)\n+{\n+  if (HB_DIRECTION_IS_FORWARD (c->target_direction))\n+    return;\n+\n+  hb_buffer_t *buffer = c->buffer;\n+  hb_unicode_funcs_t *unicode = buffer->unicode;\n+  hb_mask_t rtlm_mask = c->plan->rtlm_mask;\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++) {\n+    hb_codepoint_t codepoint = unicode->mirroring (info[i].codepoint);\n+    if (likely (codepoint == info[i].codepoint || !c->font->has_glyph (codepoint)))\n+      info[i].mask |= rtlm_mask;\n+    else\n+      info[i].codepoint = codepoint;\n+  }\n+}\n+\n+static inline void\n+hb_ot_shape_setup_masks_fraction (const hb_ot_shape_context_t *c)\n+{\n+  if (!(c->buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_NON_ASCII) ||\n+      !c->plan->has_frac)\n+    return;\n+\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  hb_mask_t pre_mask, post_mask;\n+  if (HB_DIRECTION_IS_FORWARD (buffer->props.direction))\n+  {\n+    pre_mask = c->plan->numr_mask | c->plan->frac_mask;\n+    post_mask = c->plan->frac_mask | c->plan->dnom_mask;\n+  }\n+  else\n+  {\n+    pre_mask = c->plan->frac_mask | c->plan->dnom_mask;\n+    post_mask = c->plan->numr_mask | c->plan->frac_mask;\n+  }\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    if (info[i].codepoint == 0x2044u) \/* FRACTION SLASH *\/\n+    {\n+      unsigned int start = i, end = i + 1;\n+      while (start &&\n+             _hb_glyph_info_get_general_category (&info[start - 1]) ==\n+             HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)\n+        start--;\n+      while (end < count &&\n+             _hb_glyph_info_get_general_category (&info[end]) ==\n+             HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER)\n+        end++;\n+\n+      buffer->unsafe_to_break (start, end);\n+\n+      for (unsigned int j = start; j < i; j++)\n+        info[j].mask |= pre_mask;\n+      info[i].mask |= c->plan->frac_mask;\n+      for (unsigned int j = i + 1; j < end; j++)\n+        info[j].mask |= post_mask;\n+\n+      i = end - 1;\n+    }\n+  }\n+}\n+\n+static inline void\n+hb_ot_shape_initialize_masks (const hb_ot_shape_context_t *c)\n+{\n+  hb_ot_map_t *map = &c->plan->map;\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  hb_mask_t global_mask = map->get_global_mask ();\n+  buffer->reset_masks (global_mask);\n+}\n+\n+static inline void\n+hb_ot_shape_setup_masks (const hb_ot_shape_context_t *c)\n+{\n+  hb_ot_map_t *map = &c->plan->map;\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  hb_ot_shape_setup_masks_fraction (c);\n+\n+  if (c->plan->shaper->setup_masks)\n+    c->plan->shaper->setup_masks (c->plan, buffer, c->font);\n+\n+  for (unsigned int i = 0; i < c->num_user_features; i++)\n+  {\n+    const hb_feature_t *feature = &c->user_features[i];\n+    if (!(feature->start == 0 && feature->end == (unsigned int)-1)) {\n+      unsigned int shift;\n+      hb_mask_t mask = map->get_mask (feature->tag, &shift);\n+      buffer->set_masks (feature->value << shift, mask, feature->start, feature->end);\n+    }\n+  }\n+}\n+\n+static void\n+hb_ot_zero_width_default_ignorables (const hb_buffer_t *buffer)\n+{\n+  if (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||\n+      (buffer->flags & HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES) ||\n+      (buffer->flags & HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES))\n+    return;\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  hb_glyph_position_t *pos = buffer->pos;\n+  unsigned int i = 0;\n+  for (i = 0; i < count; i++)\n+    if (unlikely (_hb_glyph_info_is_default_ignorable (&info[i])))\n+      pos[i].x_advance = pos[i].y_advance = pos[i].x_offset = pos[i].y_offset = 0;\n+}\n+\n+static void\n+hb_ot_hide_default_ignorables (hb_buffer_t *buffer,\n+                               hb_font_t   *font)\n+{\n+  if (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_DEFAULT_IGNORABLES) ||\n+      (buffer->flags & HB_BUFFER_FLAG_PRESERVE_DEFAULT_IGNORABLES))\n+    return;\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  hb_codepoint_t invisible = buffer->invisible;\n+  if (!(buffer->flags & HB_BUFFER_FLAG_REMOVE_DEFAULT_IGNORABLES) &&\n+      (invisible || font->get_nominal_glyph (' ', &invisible)))\n+  {\n+    \/* Replace default-ignorables with a zero-advance invisible glyph. *\/\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (_hb_glyph_info_is_default_ignorable (&info[i]))\n+        info[i].codepoint = invisible;\n+    }\n+  }\n+  else\n+    hb_ot_layout_delete_glyphs_inplace (buffer, _hb_glyph_info_is_default_ignorable);\n+}\n+\n+\n+static inline void\n+hb_ot_map_glyphs_fast (hb_buffer_t  *buffer)\n+{\n+  \/* Normalization process sets up glyph_index(), we just copy it. *\/\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    info[i].codepoint = info[i].glyph_index();\n+\n+  buffer->content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;\n+}\n+\n+static inline void\n+hb_synthesize_glyph_classes (hb_buffer_t *buffer)\n+{\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+  {\n+    hb_ot_layout_glyph_props_flags_t klass;\n+\n+    \/* Never mark default-ignorables as marks.\n+     * They won't get in the way of lookups anyway,\n+     * but having them as mark will cause them to be skipped\n+     * over if the lookup-flag says so, but at least for the\n+     * Mongolian variation selectors, looks like Uniscribe\n+     * marks them as non-mark.  Some Mongolian fonts without\n+     * GDEF rely on this.  Another notable character that\n+     * this applies to is COMBINING GRAPHEME JOINER. *\/\n+    klass = (_hb_glyph_info_get_general_category (&info[i]) !=\n+             HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK ||\n+             _hb_glyph_info_is_default_ignorable (&info[i])) ?\n+            HB_OT_LAYOUT_GLYPH_PROPS_BASE_GLYPH :\n+            HB_OT_LAYOUT_GLYPH_PROPS_MARK;\n+    _hb_glyph_info_set_glyph_props (&info[i], klass);\n+  }\n+}\n+\n+static inline void\n+hb_ot_substitute_default (const hb_ot_shape_context_t *c)\n+{\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  hb_ot_mirror_chars (c);\n+\n+  HB_BUFFER_ALLOCATE_VAR (buffer, glyph_index);\n+\n+  _hb_ot_shape_normalize (c->plan, buffer, c->font);\n+\n+  hb_ot_shape_setup_masks (c);\n+\n+  \/* This is unfortunate to go here, but necessary... *\/\n+  if (c->plan->fallback_mark_positioning)\n+    _hb_ot_shape_fallback_mark_position_recategorize_marks (c->plan, c->font, buffer);\n+\n+  hb_ot_map_glyphs_fast (buffer);\n+\n+  HB_BUFFER_DEALLOCATE_VAR (buffer, glyph_index);\n+}\n+\n+static inline void\n+hb_ot_substitute_complex (const hb_ot_shape_context_t *c)\n+{\n+  hb_buffer_t *buffer = c->buffer;\n+\n+  hb_ot_layout_substitute_start (c->font, buffer);\n+\n+  if (c->plan->fallback_glyph_classes)\n+    hb_synthesize_glyph_classes (c->buffer);\n+\n+  c->plan->substitute (c->font, buffer);\n+}\n+\n+static inline void\n+hb_ot_substitute_pre (const hb_ot_shape_context_t *c)\n+{\n+  hb_ot_substitute_default (c);\n+\n+  _hb_buffer_allocate_gsubgpos_vars (c->buffer);\n+\n+  hb_ot_substitute_complex (c);\n+}\n+\n+static inline void\n+hb_ot_substitute_post (const hb_ot_shape_context_t *c)\n+{\n+  hb_ot_hide_default_ignorables (c->buffer, c->font);\n+  if (c->plan->apply_morx)\n+    hb_aat_layout_remove_deleted_glyphs (c->buffer);\n+\n+  if (c->plan->shaper->postprocess_glyphs)\n+    c->plan->shaper->postprocess_glyphs (c->plan, c->buffer, c->font);\n+}\n+\n+\n+\/*\n+ * Position\n+ *\/\n+\n+static inline void\n+adjust_mark_offsets (hb_glyph_position_t *pos)\n+{\n+  pos->x_offset -= pos->x_advance;\n+  pos->y_offset -= pos->y_advance;\n+}\n+\n+static inline void\n+zero_mark_width (hb_glyph_position_t *pos)\n+{\n+  pos->x_advance = 0;\n+  pos->y_advance = 0;\n+}\n+\n+static inline void\n+zero_mark_widths_by_gdef (hb_buffer_t *buffer, bool adjust_offsets)\n+{\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    if (_hb_glyph_info_is_mark (&info[i]))\n+    {\n+      if (adjust_offsets)\n+        adjust_mark_offsets (&buffer->pos[i]);\n+      zero_mark_width (&buffer->pos[i]);\n+    }\n+}\n+\n+static inline void\n+hb_ot_position_default (const hb_ot_shape_context_t *c)\n+{\n+  hb_direction_t direction = c->buffer->props.direction;\n+  unsigned int count = c->buffer->len;\n+  hb_glyph_info_t *info = c->buffer->info;\n+  hb_glyph_position_t *pos = c->buffer->pos;\n+\n+  if (HB_DIRECTION_IS_HORIZONTAL (direction))\n+  {\n+    c->font->get_glyph_h_advances (count, &info[0].codepoint, sizeof(info[0]),\n+                                   &pos[0].x_advance, sizeof(pos[0]));\n+    \/* The nil glyph_h_origin() func returns 0, so no need to apply it. *\/\n+    if (c->font->has_glyph_h_origin_func ())\n+      for (unsigned int i = 0; i < count; i++)\n+        c->font->subtract_glyph_h_origin (info[i].codepoint,\n+                                          &pos[i].x_offset,\n+                                          &pos[i].y_offset);\n+  }\n+  else\n+  {\n+    c->font->get_glyph_v_advances (count, &info[0].codepoint, sizeof(info[0]),\n+                                   &pos[0].y_advance, sizeof(pos[0]));\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      c->font->subtract_glyph_v_origin (info[i].codepoint,\n+                                        &pos[i].x_offset,\n+                                        &pos[i].y_offset);\n+    }\n+  }\n+  if (c->buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_SPACE_FALLBACK)\n+    _hb_ot_shape_fallback_spaces (c->plan, c->font, c->buffer);\n+}\n+\n+static inline void\n+hb_ot_position_complex (const hb_ot_shape_context_t *c)\n+{\n+  unsigned int count = c->buffer->len;\n+  hb_glyph_info_t *info = c->buffer->info;\n+  hb_glyph_position_t *pos = c->buffer->pos;\n+\n+  \/* If the font has no GPOS and direction is forward, then when\n+   * zeroing mark widths, we shift the mark with it, such that the\n+   * mark is positioned hanging over the previous glyph.  When\n+   * direction is backward we don't shift and it will end up\n+   * hanging over the next glyph after the final reordering.\n+   *\n+   * Note: If fallback positinoing happens, we don't care about\n+   * this as it will be overriden.\n+   *\/\n+  bool adjust_offsets_when_zeroing = c->plan->adjust_mark_positioning_when_zeroing &&\n+                                     HB_DIRECTION_IS_FORWARD (c->buffer->props.direction);\n+\n+  \/* We change glyph origin to what GPOS expects (horizontal), apply GPOS, change it back. *\/\n+\n+  \/* The nil glyph_h_origin() func returns 0, so no need to apply it. *\/\n+  if (c->font->has_glyph_h_origin_func ())\n+    for (unsigned int i = 0; i < count; i++)\n+      c->font->add_glyph_h_origin (info[i].codepoint,\n+                                   &pos[i].x_offset,\n+                                   &pos[i].y_offset);\n+\n+  hb_ot_layout_position_start (c->font, c->buffer);\n+\n+  if (c->plan->zero_marks)\n+    switch (c->plan->shaper->zero_width_marks)\n+    {\n+      case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:\n+        zero_mark_widths_by_gdef (c->buffer, adjust_offsets_when_zeroing);\n+        break;\n+\n+      default:\n+      case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:\n+      case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:\n+        break;\n+    }\n+\n+  c->plan->position (c->font, c->buffer);\n+\n+  if (c->plan->zero_marks)\n+    switch (c->plan->shaper->zero_width_marks)\n+    {\n+      case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_LATE:\n+        zero_mark_widths_by_gdef (c->buffer, adjust_offsets_when_zeroing);\n+        break;\n+\n+      default:\n+      case HB_OT_SHAPE_ZERO_WIDTH_MARKS_NONE:\n+      case HB_OT_SHAPE_ZERO_WIDTH_MARKS_BY_GDEF_EARLY:\n+        break;\n+    }\n+\n+  \/* Finish off.  Has to follow a certain order. *\/\n+  hb_ot_layout_position_finish_advances (c->font, c->buffer);\n+  hb_ot_zero_width_default_ignorables (c->buffer);\n+  if (c->plan->apply_morx)\n+    hb_aat_layout_zero_width_deleted_glyphs (c->buffer);\n+  hb_ot_layout_position_finish_offsets (c->font, c->buffer);\n+\n+  \/* The nil glyph_h_origin() func returns 0, so no need to apply it. *\/\n+  if (c->font->has_glyph_h_origin_func ())\n+    for (unsigned int i = 0; i < count; i++)\n+      c->font->subtract_glyph_h_origin (info[i].codepoint,\n+                                        &pos[i].x_offset,\n+                                        &pos[i].y_offset);\n+\n+  if (c->plan->fallback_mark_positioning)\n+    _hb_ot_shape_fallback_mark_position (c->plan, c->font, c->buffer,\n+                                         adjust_offsets_when_zeroing);\n+}\n+\n+static inline void\n+hb_ot_position (const hb_ot_shape_context_t *c)\n+{\n+  c->buffer->clear_positions ();\n+\n+  hb_ot_position_default (c);\n+\n+  hb_ot_position_complex (c);\n+\n+  if (HB_DIRECTION_IS_BACKWARD (c->buffer->props.direction))\n+    hb_buffer_reverse (c->buffer);\n+\n+  _hb_buffer_deallocate_gsubgpos_vars (c->buffer);\n+}\n+\n+static inline void\n+hb_propagate_flags (hb_buffer_t *buffer)\n+{\n+  \/* Propagate cluster-level glyph flags to be the same on all cluster glyphs.\n+   * Simplifies using them. *\/\n+\n+  if (!(buffer->scratch_flags & HB_BUFFER_SCRATCH_FLAG_HAS_UNSAFE_TO_BREAK))\n+    return;\n+\n+  hb_glyph_info_t *info = buffer->info;\n+\n+  foreach_cluster (buffer, start, end)\n+  {\n+    unsigned int mask = 0;\n+    for (unsigned int i = start; i < end; i++)\n+      if (info[i].mask & HB_GLYPH_FLAG_UNSAFE_TO_BREAK)\n+      {\n+         mask = HB_GLYPH_FLAG_UNSAFE_TO_BREAK;\n+         break;\n+      }\n+    if (mask)\n+      for (unsigned int i = start; i < end; i++)\n+        info[i].mask |= mask;\n+  }\n+}\n+\n+\/* Pull it all together! *\/\n+\n+static void\n+hb_ot_shape_internal (hb_ot_shape_context_t *c)\n+{\n+  c->buffer->deallocate_var_all ();\n+  c->buffer->scratch_flags = HB_BUFFER_SCRATCH_FLAG_DEFAULT;\n+  if (likely (!hb_unsigned_mul_overflows (c->buffer->len, HB_BUFFER_MAX_LEN_FACTOR)))\n+  {\n+    c->buffer->max_len = MAX (c->buffer->len * HB_BUFFER_MAX_LEN_FACTOR,\n+                              (unsigned) HB_BUFFER_MAX_LEN_MIN);\n+  }\n+  if (likely (!hb_unsigned_mul_overflows (c->buffer->len, HB_BUFFER_MAX_OPS_FACTOR)))\n+  {\n+    c->buffer->max_ops = MAX (c->buffer->len * HB_BUFFER_MAX_OPS_FACTOR,\n+                              (unsigned) HB_BUFFER_MAX_OPS_MIN);\n+  }\n+\n+  \/* Save the original direction, we use it later. *\/\n+  c->target_direction = c->buffer->props.direction;\n+\n+  _hb_buffer_allocate_unicode_vars (c->buffer);\n+\n+  c->buffer->clear_output ();\n+\n+  hb_ot_shape_initialize_masks (c);\n+  hb_set_unicode_props (c->buffer);\n+  hb_insert_dotted_circle (c->buffer, c->font);\n+\n+  hb_form_clusters (c->buffer);\n+\n+  hb_ensure_native_direction (c->buffer);\n+\n+  if (c->plan->shaper->preprocess_text)\n+    c->plan->shaper->preprocess_text (c->plan, c->buffer, c->font);\n+\n+  hb_ot_substitute_pre (c);\n+  hb_ot_position (c);\n+  hb_ot_substitute_post (c);\n+\n+  hb_propagate_flags (c->buffer);\n+\n+  _hb_buffer_deallocate_unicode_vars (c->buffer);\n+\n+  c->buffer->props.direction = c->target_direction;\n+\n+  c->buffer->max_len = HB_BUFFER_MAX_LEN_DEFAULT;\n+  c->buffer->max_ops = HB_BUFFER_MAX_OPS_DEFAULT;\n+  c->buffer->deallocate_var_all ();\n+}\n+\n+\n+hb_bool_t\n+_hb_ot_shape (hb_shape_plan_t    *shape_plan,\n+              hb_font_t          *font,\n+              hb_buffer_t        *buffer,\n+              const hb_feature_t *features,\n+              unsigned int        num_features)\n+{\n+  hb_ot_shape_context_t c = {&shape_plan->ot, font, font->face, buffer, features, num_features};\n+  hb_ot_shape_internal (&c);\n+\n+  return true;\n+}\n+\n+\n+\/**\n+ * hb_ot_shape_plan_collect_lookups:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,\n+                                  hb_tag_t         table_tag,\n+                                  hb_set_t        *lookup_indexes \/* OUT *\/)\n+{\n+  shape_plan->ot.collect_lookups (table_tag, lookup_indexes);\n+}\n+\n+\n+\/* TODO Move this to hb-ot-shape-normalize, make it do decompose, and make it public. *\/\n+static void\n+add_char (hb_font_t          *font,\n+          hb_unicode_funcs_t *unicode,\n+          hb_bool_t           mirror,\n+          hb_codepoint_t      u,\n+          hb_set_t           *glyphs)\n+{\n+  hb_codepoint_t glyph;\n+  if (font->get_nominal_glyph (u, &glyph))\n+    glyphs->add (glyph);\n+  if (mirror)\n+  {\n+    hb_codepoint_t m = unicode->mirroring (u);\n+    if (m != u && font->get_nominal_glyph (m, &glyph))\n+      glyphs->add (glyph);\n+  }\n+}\n+\n+\n+\/**\n+ * hb_ot_shape_glyphs_closure:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_ot_shape_glyphs_closure (hb_font_t          *font,\n+                            hb_buffer_t        *buffer,\n+                            const hb_feature_t *features,\n+                            unsigned int        num_features,\n+                            hb_set_t           *glyphs)\n+{\n+  const char *shapers[] = {\"ot\", nullptr};\n+  hb_shape_plan_t *shape_plan = hb_shape_plan_create_cached (font->face, &buffer->props,\n+                                                             features, num_features, shapers);\n+\n+  bool mirror = hb_script_get_horizontal_direction (buffer->props.script) == HB_DIRECTION_RTL;\n+\n+  unsigned int count = buffer->len;\n+  hb_glyph_info_t *info = buffer->info;\n+  for (unsigned int i = 0; i < count; i++)\n+    add_char (font, buffer->unicode, mirror, info[i].codepoint, glyphs);\n+\n+  hb_set_t *lookups = hb_set_create ();\n+  hb_ot_shape_plan_collect_lookups (shape_plan, HB_OT_TAG_GSUB, lookups);\n+  hb_ot_layout_lookups_substitute_closure (font->face, lookups, glyphs);\n+\n+  hb_set_destroy (lookups);\n+\n+  hb_shape_plan_destroy (shape_plan);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape.cc","additions":1083,"deletions":0,"binary":false,"changes":1083,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright © 2013  Red Hat, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_SHAPE_H\n+#define HB_OT_SHAPE_H\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\/* TODO port to shape-plan \/ set. *\/\n+HB_EXTERN void\n+hb_ot_shape_glyphs_closure (hb_font_t          *font,\n+                            hb_buffer_t        *buffer,\n+                            const hb_feature_t *features,\n+                            unsigned int        num_features,\n+                            hb_set_t           *glyphs);\n+\n+HB_EXTERN void\n+hb_ot_shape_plan_collect_lookups (hb_shape_plan_t *shape_plan,\n+                                  hb_tag_t         table_tag,\n+                                  hb_set_t        *lookup_indexes \/* OUT *\/);\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_SHAPE_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape.h","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,129 @@\n+\/*\n+ * Copyright © 2010  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_SHAPE_HH\n+#define HB_OT_SHAPE_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-ot-map.hh\"\n+#include \"hb-aat-map.hh\"\n+\n+\n+struct hb_ot_shape_plan_key_t\n+{\n+  unsigned int variations_index[2];\n+\n+  void init (hb_face_t   *face,\n+                    const int   *coords,\n+                    unsigned int num_coords)\n+  {\n+    for (unsigned int table_index = 0; table_index < 2; table_index++)\n+      hb_ot_layout_table_find_feature_variations (face,\n+                                                  table_tags[table_index],\n+                                                  coords,\n+                                                  num_coords,\n+                                                  &variations_index[table_index]);\n+  }\n+\n+  bool equal (const hb_ot_shape_plan_key_t *other)\n+  {\n+    return 0 == memcmp (this, other, sizeof (*this));\n+  }\n+};\n+\n+\n+struct hb_shape_plan_key_t;\n+\n+struct hb_ot_shape_plan_t\n+{\n+  hb_segment_properties_t props;\n+  const struct hb_ot_complex_shaper_t *shaper;\n+  hb_ot_map_t map;\n+  hb_aat_map_t aat_map;\n+  const void *data;\n+  hb_mask_t frac_mask, numr_mask, dnom_mask;\n+  hb_mask_t rtlm_mask;\n+  hb_mask_t kern_mask;\n+  hb_mask_t trak_mask;\n+\n+  bool requested_kerning : 1;\n+  bool requested_tracking : 1;\n+  bool has_frac : 1;\n+  bool has_gpos_mark : 1;\n+  bool zero_marks : 1;\n+  bool fallback_glyph_classes : 1;\n+  bool fallback_mark_positioning : 1;\n+  bool adjust_mark_positioning_when_zeroing : 1;\n+\n+  bool apply_gpos : 1;\n+  bool apply_kerx : 1;\n+  bool apply_kern : 1;\n+  bool apply_morx : 1;\n+  bool apply_trak : 1;\n+\n+  void collect_lookups (hb_tag_t table_tag, hb_set_t *lookups) const\n+  {\n+    unsigned int table_index;\n+    switch (table_tag) {\n+      case HB_OT_TAG_GSUB: table_index = 0; break;\n+      case HB_OT_TAG_GPOS: table_index = 1; break;\n+      default: return;\n+    }\n+    map.collect_lookups (table_index, lookups);\n+  }\n+\n+  HB_INTERNAL bool init0 (hb_face_t                     *face,\n+                          const hb_shape_plan_key_t     *key);\n+  HB_INTERNAL void fini ();\n+\n+  HB_INTERNAL void substitute (hb_font_t *font, hb_buffer_t *buffer) const;\n+  HB_INTERNAL void position (hb_font_t *font, hb_buffer_t *buffer) const;\n+};\n+\n+struct hb_shape_plan_t;\n+\n+struct hb_ot_shape_planner_t\n+{\n+  \/* In the order that they are filled in. *\/\n+  hb_face_t *face;\n+  hb_segment_properties_t props;\n+  hb_ot_map_builder_t map;\n+  hb_aat_map_builder_t aat_map;\n+  bool apply_morx : 1;\n+  bool script_zero_marks : 1;\n+  bool script_fallback_mark_positioning : 1;\n+  const struct hb_ot_complex_shaper_t *shaper;\n+\n+  HB_INTERNAL hb_ot_shape_planner_t (hb_face_t                     *face,\n+                                     const hb_segment_properties_t *props);\n+\n+  HB_INTERNAL void compile (hb_ot_shape_plan_t           &plan,\n+                            const hb_ot_shape_plan_key_t &key);\n+};\n+\n+\n+#endif \/* HB_OT_SHAPE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-shape.hh","additions":129,"deletions":0,"binary":false,"changes":129,"status":"added"},{"patch":"@@ -0,0 +1,280 @@\n+\/*\n+ * Copyright © 2018  Ebrahim Byagowi\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\/\n+\n+#ifndef HB_OT_STAT_TABLE_HH\n+#define HB_OT_STAT_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+\n+\/*\n+ * STAT -- Style Attributes\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/stat\n+ *\/\n+#define HB_OT_TAG_STAT HB_TAG('S','T','A','T')\n+\n+\n+namespace OT {\n+\n+enum\n+{\n+  OLDER_SIBLING_FONT_ATTRIBUTE = 0x0001,        \/* If set, this axis value table\n+                                                 * provides axis value information\n+                                                 * that is applicable to other fonts\n+                                                 * within the same font family. This\n+                                                 * is used if the other fonts were\n+                                                 * released earlier and did not include\n+                                                 * information about values for some axis.\n+                                                 * If newer versions of the other\n+                                                 * fonts include the information\n+                                                 * themselves and are present,\n+                                                 * then this record is ignored. *\/\n+  ELIDABLE_AXIS_VALUE_NAME = 0x0002             \/* If set, it indicates that the axis\n+                                                 * value represents the “normal” value\n+                                                 * for the axis and may be omitted when\n+                                                 * composing name strings. *\/\n+  \/\/ Reserved = 0xFFFC                          \/* Reserved for future use — set to zero. *\/\n+};\n+\n+struct AxisValueFormat1\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier — set to 1. *\/\n+  HBUINT16      axisIndex;      \/* Zero-base index into the axis record array\n+                                 * identifying the axis of design variation\n+                                 * to which the axis value record applies.\n+                                 * Must be less than designAxisCount. *\/\n+  HBUINT16      flags;          \/* Flags — see below for details. *\/\n+  NameID        valueNameID;    \/* The name ID for entries in the 'name' table\n+                                 * that provide a display string for this\n+                                 * attribute value. *\/\n+  Fixed         value;          \/* A numeric value for this attribute value. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (12);\n+};\n+\n+struct AxisValueFormat2\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier — set to 2. *\/\n+  HBUINT16      axisIndex;      \/* Zero-base index into the axis record array\n+                                 * identifying the axis of design variation\n+                                 * to which the axis value record applies.\n+                                 * Must be less than designAxisCount. *\/\n+  HBUINT16      flags;          \/* Flags — see below for details. *\/\n+  NameID        valueNameID;    \/* The name ID for entries in the 'name' table\n+                                 * that provide a display string for this\n+                                 * attribute value. *\/\n+  Fixed         nominalValue;   \/* A numeric value for this attribute value. *\/\n+  Fixed         rangeMinValue;  \/* The minimum value for a range associated\n+                                 * with the specified name ID. *\/\n+  Fixed         rangeMaxValue;  \/* The maximum value for a range associated\n+                                 * with the specified name ID. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+struct AxisValueFormat3\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier — set to 3. *\/\n+  HBUINT16      axisIndex;      \/* Zero-base index into the axis record array\n+                                 * identifying the axis of design variation\n+                                 * to which the axis value record applies.\n+                                 * Must be less than designAxisCount. *\/\n+  HBUINT16      flags;          \/* Flags — see below for details. *\/\n+  NameID        valueNameID;    \/* The name ID for entries in the 'name' table\n+                                 * that provide a display string for this\n+                                 * attribute value. *\/\n+  Fixed         value;          \/* A numeric value for this attribute value. *\/\n+  Fixed         linkedValue;    \/* The numeric value for a style-linked mapping\n+                                 * from this value. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (16);\n+};\n+\n+struct AxisValueRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT16      axisIndex;      \/* Zero-base index into the axis record array\n+                                 * identifying the axis to which this value\n+                                 * applies. Must be less than designAxisCount. *\/\n+  Fixed         value;          \/* A numeric value for this attribute value. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (6);\n+};\n+\n+struct AxisValueFormat4\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  HBUINT16      format;         \/* Format identifier — set to 4. *\/\n+  HBUINT16      axisCount;      \/* The total number of axes contributing to\n+                                 * this axis-values combination. *\/\n+  HBUINT16      flags;          \/* Flags — see below for details. *\/\n+  NameID        valueNameID;    \/* The name ID for entries in the 'name' table\n+                                 * that provide a display string for this\n+                                 * attribute value. *\/\n+  UnsizedArrayOf<AxisValueRecord>\n+                axisValues;     \/* Array of AxisValue records that provide the\n+                                 * combination of axis values, one for each\n+                                 * contributing axis. *\/\n+  public:\n+  DEFINE_SIZE_ARRAY (8, axisValues);\n+};\n+\n+struct AxisValue\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!c->check_struct (this)))\n+      return_trace (false);\n+\n+    switch (u.format)\n+    {\n+    case 1:  return_trace (likely (u.format1.sanitize (c)));\n+    case 2:  return_trace (likely (u.format2.sanitize (c)));\n+    case 3:  return_trace (likely (u.format3.sanitize (c)));\n+    case 4:  return_trace (likely (u.format4.sanitize (c)));\n+    default: return_trace (true);\n+    }\n+  }\n+\n+  protected:\n+  union\n+  {\n+  HBUINT16              format;\n+  AxisValueFormat1      format1;\n+  AxisValueFormat2      format2;\n+  AxisValueFormat3      format3;\n+  AxisValueFormat4      format4;\n+  } u;\n+  public:\n+  DEFINE_SIZE_UNION (2, format);\n+};\n+\n+struct StatAxisRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this)));\n+  }\n+\n+  protected:\n+  Tag           tag;            \/* A tag identifying the axis of design variation. *\/\n+  NameID        nameID;         \/* The name ID for entries in the 'name' table that\n+                                 * provide a display string for this axis. *\/\n+  HBUINT16      ordering;       \/* A value that applications can use to determine\n+                                 * primary sorting of face names, or for ordering\n+                                 * of descriptors when composing family or face names. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+struct STAT\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_STAT;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (likely (c->check_struct (this) &&\n+                          majorVersion == 1 &&\n+                          minorVersion > 0 &&\n+                          designAxesOffset.sanitize (c, this, designAxisCount) &&\n+                          offsetToAxisValueOffsets.sanitize (c, this, axisValueCount, &(this+offsetToAxisValueOffsets))));\n+  }\n+\n+  protected:\n+  HBUINT16      majorVersion;   \/* Major version number of the style attributes\n+                                 * table — set to 1. *\/\n+  HBUINT16      minorVersion;   \/* Minor version number of the style attributes\n+                                 * table — set to 2. *\/\n+  HBUINT16      designAxisSize; \/* The size in bytes of each axis record. *\/\n+  HBUINT16      designAxisCount;\/* The number of design axis records. In a\n+                                 * font with an 'fvar' table, this value must be\n+                                 * greater than or equal to the axisCount value\n+                                 * in the 'fvar' table. In all fonts, must\n+                                 * be greater than zero if axisValueCount\n+                                 * is greater than zero. *\/\n+  LNNOffsetTo<UnsizedArrayOf<StatAxisRecord> >\n+                designAxesOffset;\n+                                \/* Offset in bytes from the beginning of\n+                                 * the STAT table to the start of the design\n+                                 * axes array. If designAxisCount is zero,\n+                                 * set to zero; if designAxisCount is greater\n+                                 * than zero, must be greater than zero. *\/\n+  HBUINT16      axisValueCount; \/* The number of axis value tables. *\/\n+  LNNOffsetTo<UnsizedArrayOf<OffsetTo<AxisValue> > >\n+                offsetToAxisValueOffsets;\n+                                \/* Offset in bytes from the beginning of\n+                                 * the STAT table to the start of the design\n+                                 * axes value offsets array. If axisValueCount\n+                                 * is zero, set to zero; if axisValueCount is\n+                                 * greater than zero, must be greater than zero. *\/\n+  NameID        elidedFallbackNameID;\n+                                \/* Name ID used as fallback when projection of\n+                                 * names into a particular font model produces\n+                                 * a subfamily name containing only elidable\n+                                 * elements. *\/\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_STAT_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-stat-table.hh","additions":280,"deletions":0,"binary":false,"changes":280,"status":"added"},{"patch":"@@ -0,0 +1,2064 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following table is generated by running:\n+ *\n+ *   .\/gen-tag-table.py languagetags language-subtag-registry\n+ *\n+ * on files with these headers:\n+ *\n+ * <meta name=\"updated_at\" content=\"2018-09-07 07:45 PM\" \/>\n+ * File-Date: 2018-08-08\n+ *\/\n+\n+#ifndef HB_OT_TAG_TABLE_HH\n+#define HB_OT_TAG_TABLE_HH\n+\n+static const LangTag ot_languages[] = {\n+  {\"aa\",        {HB_TAG('A','F','R',' ')}},     \/* Afar *\/\n+  {\"aae\",       {HB_TAG('S','Q','I',' ')}},     \/* Arbëreshë Albanian -> Albanian *\/\n+  {\"aao\",       {HB_TAG('A','R','A',' ')}},     \/* Algerian Saharan Arabic -> Arabic *\/\n+  {\"aat\",       {HB_TAG('S','Q','I',' ')}},     \/* Arvanitika Albanian -> Albanian *\/\n+  {\"ab\",        {HB_TAG('A','B','K',' ')}},     \/* Abkhazian *\/\n+  {\"abh\",       {HB_TAG('A','R','A',' ')}},     \/* Tajiki Arabic -> Arabic *\/\n+  {\"abq\",       {HB_TAG('A','B','A',' ')}},     \/* Abaza *\/\n+  {\"abv\",       {HB_TAG('A','R','A',' ')}},     \/* Baharna Arabic -> Arabic *\/\n+  {\"acf\",       {HB_TAG('F','A','N',' ')}},     \/* Saint Lucian Creole French -> French Antillean *\/\n+  {\"ach\",       {HB_TAG('A','C','H',' ')}},     \/* Acoli -> Acholi *\/\n+  {\"acm\",       {HB_TAG('A','R','A',' ')}},     \/* Mesopotamian Arabic -> Arabic *\/\n+  {\"acq\",       {HB_TAG('A','R','A',' ')}},     \/* Ta'izzi-Adeni Arabic -> Arabic *\/\n+  {\"acr\",       {HB_TAG('A','C','R',' ')}},     \/* Achi *\/\n+  {\"acw\",       {HB_TAG('A','R','A',' ')}},     \/* Hijazi Arabic -> Arabic *\/\n+  {\"acx\",       {HB_TAG('A','R','A',' ')}},     \/* Omani Arabic -> Arabic *\/\n+  {\"acy\",       {HB_TAG('A','R','A',' ')}},     \/* Cypriot Arabic -> Arabic *\/\n+  {\"ada\",       {HB_TAG('D','N','G',' ')}},     \/* Adangme -> Dangme *\/\n+  {\"adf\",       {HB_TAG('A','R','A',' ')}},     \/* Dhofari Arabic -> Arabic *\/\n+  {\"adp\",       {HB_TAG('D','Z','N',' ')}},     \/* Adap (retired code) -> Dzongkha *\/\n+  {\"ady\",       {HB_TAG('A','D','Y',' ')}},     \/* Adyghe *\/\n+  {\"aeb\",       {HB_TAG('A','R','A',' ')}},     \/* Tunisian Arabic -> Arabic *\/\n+  {\"aec\",       {HB_TAG('A','R','A',' ')}},     \/* Saidi Arabic -> Arabic *\/\n+  {\"af\",        {HB_TAG('A','F','K',' ')}},     \/* Afrikaans *\/\n+  {\"afb\",       {HB_TAG('A','R','A',' ')}},     \/* Gulf Arabic -> Arabic *\/\n+  {\"ahg\",       {HB_TAG('A','G','W',' ')}},     \/* Qimant -> Agaw *\/\n+  {\"aht\",       {HB_TAG('A','T','H',' ')}},     \/* Ahtena -> Athapaskan *\/\n+  {\"aii\",       {HB_TAG('S','W','A',' '),       \/* Assyrian Neo-Aramaic -> Swadaya Aramaic *\/\n+                 HB_TAG('S','Y','R',' ')}},     \/* Assyrian Neo-Aramaic -> Syriac *\/\n+  {\"aio\",       {HB_TAG('A','I','O',' ')}},     \/* Aiton *\/\n+  {\"aiw\",       {HB_TAG('A','R','I',' ')}},     \/* Aari *\/\n+  {\"ajp\",       {HB_TAG('A','R','A',' ')}},     \/* South Levantine Arabic -> Arabic *\/\n+  {\"ak\",        {HB_TAG('A','K','A',' '),       \/* Akan [macrolanguage] *\/\n+                 HB_TAG('T','W','I',' ')}},     \/* Akan [macrolanguage] -> Twi *\/\n+  {\"aln\",       {HB_TAG('S','Q','I',' ')}},     \/* Gheg Albanian -> Albanian *\/\n+  {\"als\",       {HB_TAG('S','Q','I',' ')}},     \/* Tosk Albanian -> Albanian *\/\n+  {\"alt\",       {HB_TAG('A','L','T',' ')}},     \/* Southern Altai -> Altai *\/\n+  {\"am\",        {HB_TAG('A','M','H',' ')}},     \/* Amharic *\/\n+  {\"amf\",       {HB_TAG('H','B','N',' ')}},     \/* Hamer-Banna -> Hammer-Banna *\/\n+  {\"amw\",       {HB_TAG('S','Y','R',' ')}},     \/* Western Neo-Aramaic -> Syriac *\/\n+  {\"an\",        {HB_TAG('A','R','G',' ')}},     \/* Aragonese *\/\n+  {\"ang\",       {HB_TAG('A','N','G',' ')}},     \/* Old English (ca. 450-1100) -> Anglo-Saxon *\/\n+  {\"apc\",       {HB_TAG('A','R','A',' ')}},     \/* North Levantine Arabic -> Arabic *\/\n+  {\"apd\",       {HB_TAG('A','R','A',' ')}},     \/* Sudanese Arabic -> Arabic *\/\n+  {\"apj\",       {HB_TAG('A','T','H',' ')}},     \/* Jicarilla Apache -> Athapaskan *\/\n+  {\"apk\",       {HB_TAG('A','T','H',' ')}},     \/* Kiowa Apache -> Athapaskan *\/\n+  {\"apl\",       {HB_TAG('A','T','H',' ')}},     \/* Lipan Apache -> Athapaskan *\/\n+  {\"apm\",       {HB_TAG('A','T','H',' ')}},     \/* Mescalero-Chiricahua Apache -> Athapaskan *\/\n+  {\"apw\",       {HB_TAG('A','T','H',' ')}},     \/* Western Apache -> Athapaskan *\/\n+  {\"ar\",        {HB_TAG('A','R','A',' ')}},     \/* Arabic [macrolanguage] *\/\n+  {\"arb\",       {HB_TAG('A','R','A',' ')}},     \/* Standard Arabic -> Arabic *\/\n+  {\"arn\",       {HB_TAG('M','A','P',' ')}},     \/* Mapudungun *\/\n+  {\"arq\",       {HB_TAG('A','R','A',' ')}},     \/* Algerian Arabic -> Arabic *\/\n+  {\"ars\",       {HB_TAG('A','R','A',' ')}},     \/* Najdi Arabic -> Arabic *\/\n+  {\"ary\",       {HB_TAG('M','O','R',' ')}},     \/* Moroccan Arabic -> Moroccan *\/\n+  {\"arz\",       {HB_TAG('A','R','A',' ')}},     \/* Egyptian Arabic -> Arabic *\/\n+  {\"as\",        {HB_TAG('A','S','M',' ')}},     \/* Assamese *\/\n+  {\"ast\",       {HB_TAG('A','S','T',' ')}},     \/* Asturian *\/\n+  {\"ath\",       {HB_TAG('A','T','H',' ')}},     \/* Athapascan [family] -> Athapaskan *\/\n+  {\"atj\",       {HB_TAG('R','C','R',' ')}},     \/* Atikamekw -> R-Cree *\/\n+  {\"atv\",       {HB_TAG('A','L','T',' ')}},     \/* Northern Altai -> Altai *\/\n+  {\"auz\",       {HB_TAG('A','R','A',' ')}},     \/* Uzbeki Arabic -> Arabic *\/\n+  {\"av\",        {HB_TAG('A','V','R',' ')}},     \/* Avaric -> Avar *\/\n+  {\"avl\",       {HB_TAG('A','R','A',' ')}},     \/* Eastern Egyptian Bedawi Arabic -> Arabic *\/\n+  {\"awa\",       {HB_TAG('A','W','A',' ')}},     \/* Awadhi *\/\n+  {\"ay\",        {HB_TAG('A','Y','M',' ')}},     \/* Aymara [macrolanguage] *\/\n+  {\"ayc\",       {HB_TAG('A','Y','M',' ')}},     \/* Southern Aymara -> Aymara *\/\n+  {\"ayh\",       {HB_TAG('A','R','A',' ')}},     \/* Hadrami Arabic -> Arabic *\/\n+  {\"ayl\",       {HB_TAG('A','R','A',' ')}},     \/* Libyan Arabic -> Arabic *\/\n+  {\"ayn\",       {HB_TAG('A','R','A',' ')}},     \/* Sanaani Arabic -> Arabic *\/\n+  {\"ayp\",       {HB_TAG('A','R','A',' ')}},     \/* North Mesopotamian Arabic -> Arabic *\/\n+  {\"ayr\",       {HB_TAG('A','Y','M',' ')}},     \/* Central Aymara -> Aymara *\/\n+  {\"az\",        {HB_TAG('A','Z','E',' ')}},     \/* Azerbaijani [macrolanguage] *\/\n+  {\"azb\",       {HB_TAG('A','Z','B',' ')}},     \/* South Azerbaijani -> Torki *\/\n+  {\"azj\",       {HB_TAG('A','Z','E',' ')}},     \/* North Azerbaijani -> Azerbaijani *\/\n+  {\"ba\",        {HB_TAG('B','S','H',' ')}},     \/* Bashkir *\/\n+  {\"bad\",       {HB_TAG('B','A','D','0')}},     \/* Banda [family] *\/\n+  {\"bai\",       {HB_TAG('B','M','L',' ')}},     \/* Bamileke [family] *\/\n+  {\"bal\",       {HB_TAG('B','L','I',' ')}},     \/* Baluchi [macrolanguage] *\/\n+  {\"ban\",       {HB_TAG('B','A','N',' ')}},     \/* Balinese *\/\n+  {\"bar\",       {HB_TAG('B','A','R',' ')}},     \/* Bavarian *\/\n+  {\"bbc\",       {HB_TAG('B','B','C',' ')}},     \/* Batak Toba *\/\n+  {\"bbz\",       {HB_TAG('A','R','A',' ')}},     \/* Babalia Creole Arabic -> Arabic *\/\n+  {\"bcc\",       {HB_TAG('B','L','I',' ')}},     \/* Southern Balochi -> Baluchi *\/\n+  {\"bci\",       {HB_TAG('B','A','U',' ')}},     \/* Baoulé -> Baulé *\/\n+  {\"bcl\",       {HB_TAG('B','I','K',' ')}},     \/* Central Bikol -> Bikol *\/\n+  {\"bcq\",       {HB_TAG('B','C','H',' ')}},     \/* Bench *\/\n+  {\"bcr\",       {HB_TAG('A','T','H',' ')}},     \/* Babine -> Athapaskan *\/\n+  {\"bdy\",       {HB_TAG('B','D','Y',' ')}},     \/* Bandjalang *\/\n+  {\"be\",        {HB_TAG('B','E','L',' ')}},     \/* Belarusian -> Belarussian *\/\n+  {\"bea\",       {HB_TAG('A','T','H',' ')}},     \/* Beaver -> Athapaskan *\/\n+  {\"beb\",       {HB_TAG('B','T','I',' ')}},     \/* Bebele -> Beti *\/\n+  {\"bem\",       {HB_TAG('B','E','M',' ')}},     \/* Bemba (Zambia) *\/\n+  {\"ber\",       {HB_TAG('B','B','R',' ')}},     \/* Berber [family] *\/\n+  {\"bfq\",       {HB_TAG('B','A','D',' ')}},     \/* Badaga *\/\n+  {\"bft\",       {HB_TAG('B','L','T',' ')}},     \/* Balti *\/\n+  {\"bfu\",       {HB_TAG('L','A','H',' ')}},     \/* Gahri -> Lahuli *\/\n+  {\"bfy\",       {HB_TAG('B','A','G',' ')}},     \/* Bagheli -> Baghelkhandi *\/\n+  {\"bg\",        {HB_TAG('B','G','R',' ')}},     \/* Bulgarian *\/\n+  {\"bgc\",       {HB_TAG('B','G','C',' ')}},     \/* Haryanvi *\/\n+  {\"bgn\",       {HB_TAG('B','L','I',' ')}},     \/* Western Balochi -> Baluchi *\/\n+  {\"bgp\",       {HB_TAG('B','L','I',' ')}},     \/* Eastern Balochi -> Baluchi *\/\n+  {\"bgq\",       {HB_TAG('B','G','Q',' ')}},     \/* Bagri *\/\n+  {\"bgr\",       {HB_TAG('Q','I','N',' ')}},     \/* Bawm Chin -> Chin *\/\n+  {\"bhb\",       {HB_TAG('B','H','I',' ')}},     \/* Bhili *\/\n+  {\"bhi\",       {HB_TAG('B','H','I',' ')}},     \/* Bhilali -> Bhili *\/\n+  {\"bhk\",       {HB_TAG('B','I','K',' ')}},     \/* Albay Bicolano (retired code) -> Bikol *\/\n+  {\"bho\",       {HB_TAG('B','H','O',' ')}},     \/* Bhojpuri *\/\n+  {\"bhr\",       {HB_TAG('M','L','G',' ')}},     \/* Bara Malagasy -> Malagasy *\/\n+  {\"bi\",        {HB_TAG('B','I','S',' ')}},     \/* Bislama *\/\n+  {\"bik\",       {HB_TAG('B','I','K',' ')}},     \/* Bikol [macrolanguage] *\/\n+  {\"bin\",       {HB_TAG('E','D','O',' ')}},     \/* Edo *\/\n+  {\"bjj\",       {HB_TAG('B','J','J',' ')}},     \/* Kanauji *\/\n+  {\"bjn\",       {HB_TAG('M','L','Y',' ')}},     \/* Banjar -> Malay *\/\n+  {\"bjq\",       {HB_TAG('M','L','G',' ')}},     \/* Southern Betsimisaraka Malagasy (retired code) -> Malagasy *\/\n+  {\"bjt\",       {HB_TAG('B','L','N',' ')}},     \/* Balanta-Ganja -> Balante *\/\n+  {\"bla\",       {HB_TAG('B','K','F',' ')}},     \/* Siksika -> Blackfoot *\/\n+  {\"ble\",       {HB_TAG('B','L','N',' ')}},     \/* Balanta-Kentohe -> Balante *\/\n+  {\"blk\",       {HB_TAG('B','L','K',' ')}},     \/* Pa'o Karen *\/\n+  {\"bln\",       {HB_TAG('B','I','K',' ')}},     \/* Southern Catanduanes Bikol -> Bikol *\/\n+  {\"bm\",        {HB_TAG('B','M','B',' ')}},     \/* Bambara (Bamanankan) *\/\n+  {\"bmm\",       {HB_TAG('M','L','G',' ')}},     \/* Northern Betsimisaraka Malagasy -> Malagasy *\/\n+  {\"bn\",        {HB_TAG('B','E','N',' ')}},     \/* Bengali *\/\n+  {\"bo\",        {HB_TAG('T','I','B',' ')}},     \/* Tibetan *\/\n+  {\"bpy\",       {HB_TAG('B','P','Y',' ')}},     \/* Bishnupriya -> Bishnupriya Manipuri *\/\n+  {\"bqi\",       {HB_TAG('L','R','C',' ')}},     \/* Bakhtiari -> Luri *\/\n+  {\"br\",        {HB_TAG('B','R','E',' ')}},     \/* Breton *\/\n+  {\"bra\",       {HB_TAG('B','R','I',' ')}},     \/* Braj -> Braj Bhasha *\/\n+  {\"brh\",       {HB_TAG('B','R','H',' ')}},     \/* Brahui *\/\n+  {\"brx\",       {HB_TAG('B','R','X',' ')}},     \/* Bodo (India) *\/\n+  {\"bs\",        {HB_TAG('B','O','S',' ')}},     \/* Bosnian *\/\n+  {\"bsk\",       {HB_TAG('B','S','K',' ')}},     \/* Burushaski *\/\n+  {\"btb\",       {HB_TAG('B','T','I',' ')}},     \/* Beti (Cameroon) (retired code) *\/\n+  {\"btj\",       {HB_TAG('M','L','Y',' ')}},     \/* Bacanese Malay -> Malay *\/\n+  {\"bto\",       {HB_TAG('B','I','K',' ')}},     \/* Rinconada Bikol -> Bikol *\/\n+  {\"bts\",       {HB_TAG('B','T','S',' ')}},     \/* Batak Simalungun *\/\n+  {\"bug\",       {HB_TAG('B','U','G',' ')}},     \/* Buginese -> Bugis *\/\n+  {\"bum\",       {HB_TAG('B','T','I',' ')}},     \/* Bulu (Cameroon) -> Beti *\/\n+  {\"bve\",       {HB_TAG('M','L','Y',' ')}},     \/* Berau Malay -> Malay *\/\n+  {\"bvu\",       {HB_TAG('M','L','Y',' ')}},     \/* Bukit Malay -> Malay *\/\n+  {\"bxk\",       {HB_TAG('L','U','H',' ')}},     \/* Bukusu -> Luyia *\/\n+  {\"bxp\",       {HB_TAG('B','T','I',' ')}},     \/* Bebil -> Beti *\/\n+  {\"bxr\",       {HB_TAG('R','B','U',' ')}},     \/* Russia Buriat -> Russian Buriat *\/\n+  {\"byn\",       {HB_TAG('B','I','L',' ')}},     \/* Bilin -> Bilen *\/\n+  {\"byv\",       {HB_TAG('B','Y','V',' ')}},     \/* Medumba *\/\n+  {\"bzc\",       {HB_TAG('M','L','G',' ')}},     \/* Southern Betsimisaraka Malagasy -> Malagasy *\/\n+  {\"ca\",        {HB_TAG('C','A','T',' ')}},     \/* Catalan *\/\n+  {\"caf\",       {HB_TAG('C','R','R',' '),       \/* Southern Carrier -> Carrier *\/\n+                 HB_TAG('A','T','H',' ')}},     \/* Southern Carrier -> Athapaskan *\/\n+  {\"cak\",       {HB_TAG('C','A','K',' ')}},     \/* Kaqchikel *\/\n+  {\"cbk\",       {HB_TAG('C','B','K',' ')}},     \/* Chavacano -> Zamboanga Chavacano *\/\n+  {\"cbl\",       {HB_TAG('Q','I','N',' ')}},     \/* Bualkhaw Chin -> Chin *\/\n+  {\"cco\",       {HB_TAG('C','C','H','N')}},     \/* Comaltepec Chinantec -> Chinantec *\/\n+  {\"ccq\",       {HB_TAG('A','R','K',' ')}},     \/* Chaungtha (retired code) -> Rakhine *\/\n+  {\"cdo\",       {HB_TAG('Z','H','S',' ')}},     \/* Min Dong Chinese -> Chinese Simplified *\/\n+  {\"ce\",        {HB_TAG('C','H','E',' ')}},     \/* Chechen *\/\n+  {\"ceb\",       {HB_TAG('C','E','B',' ')}},     \/* Cebuano *\/\n+  {\"cfm\",       {HB_TAG('H','A','L',' ')}},     \/* Halam (Falam Chin) *\/\n+  {\"cgg\",       {HB_TAG('C','G','G',' ')}},     \/* Chiga *\/\n+  {\"ch\",        {HB_TAG('C','H','A',' ')}},     \/* Chamorro *\/\n+  {\"chj\",       {HB_TAG('C','C','H','N')}},     \/* Ojitlán Chinantec -> Chinantec *\/\n+  {\"chk\",       {HB_TAG('C','H','K','0')}},     \/* Chuukese *\/\n+  {\"cho\",       {HB_TAG('C','H','O',' ')}},     \/* Choctaw *\/\n+  {\"chp\",       {HB_TAG('C','H','P',' '),       \/* Chipewyan *\/\n+                 HB_TAG('S','A','Y',' '),       \/* Chipewyan -> Sayisi *\/\n+                 HB_TAG('A','T','H',' ')}},     \/* Chipewyan -> Athapaskan *\/\n+  {\"chq\",       {HB_TAG('C','C','H','N')}},     \/* Quiotepec Chinantec -> Chinantec *\/\n+  {\"chr\",       {HB_TAG('C','H','R',' ')}},     \/* Cherokee *\/\n+  {\"chy\",       {HB_TAG('C','H','Y',' ')}},     \/* Cheyenne *\/\n+  {\"chz\",       {HB_TAG('C','C','H','N')}},     \/* Ozumacín Chinantec -> Chinantec *\/\n+  {\"ciw\",       {HB_TAG('O','J','B',' ')}},     \/* Chippewa -> Ojibway *\/\n+  {\"cja\",       {HB_TAG('C','J','A',' ')}},     \/* Western Cham *\/\n+  {\"cjm\",       {HB_TAG('C','J','M',' ')}},     \/* Eastern Cham *\/\n+  {\"cjy\",       {HB_TAG('Z','H','S',' ')}},     \/* Jinyu Chinese -> Chinese Simplified *\/\n+  {\"cka\",       {HB_TAG('Q','I','N',' ')}},     \/* Khumi Awa Chin (retired code) -> Chin *\/\n+  {\"ckb\",       {HB_TAG('K','U','R',' ')}},     \/* Central Kurdish -> Kurdish *\/\n+  {\"ckt\",       {HB_TAG('C','H','K',' ')}},     \/* Chukot -> Chukchi *\/\n+  {\"clc\",       {HB_TAG('A','T','H',' ')}},     \/* Chilcotin -> Athapaskan *\/\n+  {\"cld\",       {HB_TAG('S','Y','R',' ')}},     \/* Chaldean Neo-Aramaic -> Syriac *\/\n+  {\"cle\",       {HB_TAG('C','C','H','N')}},     \/* Lealao Chinantec -> Chinantec *\/\n+  {\"cmn\",       {HB_TAG('Z','H','S',' ')}},     \/* Mandarin Chinese -> Chinese Simplified *\/\n+  {\"cmr\",       {HB_TAG('Q','I','N',' ')}},     \/* Mro-Khimi Chin -> Chin *\/\n+  {\"cnb\",       {HB_TAG('Q','I','N',' ')}},     \/* Chinbon Chin -> Chin *\/\n+  {\"cnh\",       {HB_TAG('Q','I','N',' ')}},     \/* Hakha Chin -> Chin *\/\n+  {\"cnk\",       {HB_TAG('Q','I','N',' ')}},     \/* Khumi Chin -> Chin *\/\n+  {\"cnl\",       {HB_TAG('C','C','H','N')}},     \/* Lalana Chinantec -> Chinantec *\/\n+  {\"cnt\",       {HB_TAG('C','C','H','N')}},     \/* Tepetotutla Chinantec -> Chinantec *\/\n+  {\"cnw\",       {HB_TAG('Q','I','N',' ')}},     \/* Ngawn Chin -> Chin *\/\n+  {\"co\",        {HB_TAG('C','O','S',' ')}},     \/* Corsican *\/\n+  {\"coa\",       {HB_TAG('M','L','Y',' ')}},     \/* Cocos Islands Malay -> Malay *\/\n+  {\"cop\",       {HB_TAG('C','O','P',' ')}},     \/* Coptic *\/\n+  {\"coq\",       {HB_TAG('A','T','H',' ')}},     \/* Coquille -> Athapaskan *\/\n+  {\"cpa\",       {HB_TAG('C','C','H','N')}},     \/* Palantla Chinantec -> Chinantec *\/\n+  {\"cpe\",       {HB_TAG('C','P','P',' ')}},     \/* English-based creoles and pidgins [family] -> Creoles *\/\n+  {\"cpf\",       {HB_TAG('C','P','P',' ')}},     \/* French-based creoles and pidgins [family] -> Creoles *\/\n+  {\"cpp\",       {HB_TAG('C','P','P',' ')}},     \/* Portuguese-based creoles and pidgins [family] -> Creoles *\/\n+  {\"cpx\",       {HB_TAG('Z','H','S',' ')}},     \/* Pu-Xian Chinese -> Chinese Simplified *\/\n+  {\"cqd\",       {HB_TAG('H','M','N',' ')}},     \/* Chuanqiandian Cluster Miao -> Hmong *\/\n+  {\"cqu\",       {HB_TAG('Q','U','H',' ')}},     \/* Chilean Quechua (retired code) -> Quechua (Bolivia) *\/\n+  {\"cr\",        {HB_TAG('C','R','E',' '),       \/* Cree [macrolanguage] *\/\n+                 HB_TAG('Y','C','R',' ')}},     \/* Cree [macrolanguage] -> Y-Cree *\/\n+  {\"crh\",       {HB_TAG('C','R','T',' ')}},     \/* Crimean Tatar *\/\n+  {\"crj\",       {HB_TAG('E','C','R',' ')}},     \/* Southern East Cree -> Eastern Cree *\/\n+  {\"crk\",       {HB_TAG('W','C','R',' ')}},     \/* Plains Cree -> West-Cree *\/\n+  {\"crl\",       {HB_TAG('E','C','R',' ')}},     \/* Northern East Cree -> Eastern Cree *\/\n+  {\"crm\",       {HB_TAG('M','C','R',' '),       \/* Moose Cree *\/\n+                 HB_TAG('L','C','R',' ')}},     \/* Moose Cree -> L-Cree *\/\n+  {\"crp\",       {HB_TAG('C','P','P',' ')}},     \/* Creoles and pidgins [family] -> Creoles *\/\n+  {\"crx\",       {HB_TAG('C','R','R',' '),       \/* Carrier *\/\n+                 HB_TAG('A','T','H',' ')}},     \/* Carrier -> Athapaskan *\/\n+  {\"cs\",        {HB_TAG('C','S','Y',' ')}},     \/* Czech *\/\n+  {\"csa\",       {HB_TAG('C','C','H','N')}},     \/* Chiltepec Chinantec -> Chinantec *\/\n+  {\"csb\",       {HB_TAG('C','S','B',' ')}},     \/* Kashubian *\/\n+  {\"csh\",       {HB_TAG('Q','I','N',' ')}},     \/* Asho Chin -> Chin *\/\n+  {\"cso\",       {HB_TAG('C','C','H','N')}},     \/* Sochiapam Chinantec -> Chinantec *\/\n+  {\"csw\",       {HB_TAG('N','C','R',' '),       \/* Swampy Cree -> N-Cree *\/\n+                 HB_TAG('N','H','C',' ')}},     \/* Swampy Cree -> Norway House Cree *\/\n+  {\"csy\",       {HB_TAG('Q','I','N',' ')}},     \/* Siyin Chin -> Chin *\/\n+  {\"ctc\",       {HB_TAG('A','T','H',' ')}},     \/* Chetco -> Athapaskan *\/\n+  {\"ctd\",       {HB_TAG('Q','I','N',' ')}},     \/* Tedim Chin -> Chin *\/\n+  {\"cte\",       {HB_TAG('C','C','H','N')}},     \/* Tepinapa Chinantec -> Chinantec *\/\n+  {\"ctg\",       {HB_TAG('C','T','G',' ')}},     \/* Chittagonian *\/\n+  {\"ctl\",       {HB_TAG('C','C','H','N')}},     \/* Tlacoatzintepec Chinantec -> Chinantec *\/\n+  {\"cts\",       {HB_TAG('B','I','K',' ')}},     \/* Northern Catanduanes Bikol -> Bikol *\/\n+  {\"cu\",        {HB_TAG('C','S','L',' ')}},     \/* Church Slavonic *\/\n+  {\"cuc\",       {HB_TAG('C','C','H','N')}},     \/* Usila Chinantec -> Chinantec *\/\n+  {\"cuk\",       {HB_TAG('C','U','K',' ')}},     \/* San Blas Kuna *\/\n+  {\"cv\",        {HB_TAG('C','H','U',' ')}},     \/* Chuvash *\/\n+  {\"cvn\",       {HB_TAG('C','C','H','N')}},     \/* Valle Nacional Chinantec -> Chinantec *\/\n+  {\"cwd\",       {HB_TAG('D','C','R',' '),       \/* Woods Cree *\/\n+                 HB_TAG('T','C','R',' ')}},     \/* Woods Cree -> TH-Cree *\/\n+  {\"cy\",        {HB_TAG('W','E','L',' ')}},     \/* Welsh *\/\n+  {\"czh\",       {HB_TAG('Z','H','S',' ')}},     \/* Huizhou Chinese -> Chinese Simplified *\/\n+  {\"czo\",       {HB_TAG('Z','H','S',' ')}},     \/* Min Zhong Chinese -> Chinese Simplified *\/\n+  {\"czt\",       {HB_TAG('Q','I','N',' ')}},     \/* Zotung Chin -> Chin *\/\n+  {\"da\",        {HB_TAG('D','A','N',' ')}},     \/* Danish *\/\n+  {\"dao\",       {HB_TAG('Q','I','N',' ')}},     \/* Daai Chin -> Chin *\/\n+  {\"dap\",       {HB_TAG('N','I','S',' ')}},     \/* Nisi (India) (retired code) *\/\n+  {\"dar\",       {HB_TAG('D','A','R',' ')}},     \/* Dargwa *\/\n+  {\"dax\",       {HB_TAG('D','A','X',' ')}},     \/* Dayi *\/\n+  {\"de\",        {HB_TAG('D','E','U',' ')}},     \/* German *\/\n+  {\"den\",       {HB_TAG('S','L','A',' '),       \/* Slave (Athapascan) [macrolanguage] -> Slavey *\/\n+                 HB_TAG('A','T','H',' ')}},     \/* Slave (Athapascan) [macrolanguage] -> Athapaskan *\/\n+  {\"dgo\",       {HB_TAG('D','G','O',' ')}},     \/* Dogri *\/\n+  {\"dgr\",       {HB_TAG('A','T','H',' ')}},     \/* Dogrib -> Athapaskan *\/\n+  {\"dhd\",       {HB_TAG('M','A','W',' ')}},     \/* Dhundari -> Marwari *\/\n+  {\"dhg\",       {HB_TAG('D','H','G',' ')}},     \/* Dhangu *\/\n+  {\"dib\",       {HB_TAG('D','N','K',' ')}},     \/* South Central Dinka -> Dinka *\/\n+  {\"dik\",       {HB_TAG('D','N','K',' ')}},     \/* Southwestern Dinka -> Dinka *\/\n+  {\"din\",       {HB_TAG('D','N','K',' ')}},     \/* Dinka [macrolanguage] *\/\n+  {\"dip\",       {HB_TAG('D','N','K',' ')}},     \/* Northeastern Dinka -> Dinka *\/\n+  {\"diq\",       {HB_TAG('D','I','Q',' ')}},     \/* Dimli *\/\n+  {\"diw\",       {HB_TAG('D','N','K',' ')}},     \/* Northwestern Dinka -> Dinka *\/\n+  {\"dje\",       {HB_TAG('D','J','R',' ')}},     \/* Zarma *\/\n+  {\"djr\",       {HB_TAG('D','J','R','0')}},     \/* Djambarrpuyngu *\/\n+  {\"dks\",       {HB_TAG('D','N','K',' ')}},     \/* Southeastern Dinka -> Dinka *\/\n+  {\"dng\",       {HB_TAG('D','U','N',' ')}},     \/* Dungan *\/\n+  {\"dnj\",       {HB_TAG('D','N','J',' ')}},     \/* Dan *\/\n+  {\"doi\",       {HB_TAG('D','G','R',' ')}},     \/* Dogri [macrolanguage] *\/\n+  {\"drh\",       {HB_TAG('M','N','G',' ')}},     \/* Darkhat (retired code) -> Mongolian *\/\n+  {\"drw\",       {HB_TAG('D','R','I',' ')}},     \/* Darwazi (retired code) -> Dari *\/\n+  {\"dsb\",       {HB_TAG('L','S','B',' ')}},     \/* Lower Sorbian *\/\n+  {\"dty\",       {HB_TAG('N','E','P',' ')}},     \/* Dotyali -> Nepali *\/\n+  {\"duj\",       {HB_TAG('D','U','J',' ')}},     \/* Dhuwal (retired code) *\/\n+  {\"dup\",       {HB_TAG('M','L','Y',' ')}},     \/* Duano -> Malay *\/\n+  {\"dv\",        {HB_TAG('D','I','V',' '),       \/* Divehi (Dhivehi, Maldivian) *\/\n+                 HB_TAG('D','H','V',' ')}},     \/* Divehi (Dhivehi, Maldivian) (deprecated) *\/\n+  {\"dwu\",       {HB_TAG('D','U','J',' ')}},     \/* Dhuwal *\/\n+  {\"dwy\",       {HB_TAG('D','U','J',' ')}},     \/* Dhuwaya -> Dhuwal *\/\n+  {\"dyu\",       {HB_TAG('J','U','L',' ')}},     \/* Dyula -> Jula *\/\n+  {\"dz\",        {HB_TAG('D','Z','N',' ')}},     \/* Dzongkha *\/\n+  {\"ee\",        {HB_TAG('E','W','E',' ')}},     \/* Ewe *\/\n+  {\"efi\",       {HB_TAG('E','F','I',' ')}},     \/* Efik *\/\n+  {\"ekk\",       {HB_TAG('E','T','I',' ')}},     \/* Standard Estonian -> Estonian *\/\n+  {\"el\",        {HB_TAG('E','L','L',' ')}},     \/* Modern Greek (1453-) -> Greek *\/\n+  {\"emk\",       {HB_TAG('E','M','K',' '),       \/* Eastern Maninkakan *\/\n+                 HB_TAG('M','N','K',' ')}},     \/* Eastern Maninkakan -> Maninka *\/\n+  {\"en\",        {HB_TAG('E','N','G',' ')}},     \/* English *\/\n+  {\"enb\",       {HB_TAG('K','A','L',' ')}},     \/* Markweeta -> Kalenjin *\/\n+  {\"enf\",       {HB_TAG('F','N','E',' ')}},     \/* Forest Enets -> Forest Nenets *\/\n+  {\"enh\",       {HB_TAG('T','N','E',' ')}},     \/* Tundra Enets -> Tundra Nenets *\/\n+  {\"eo\",        {HB_TAG('N','T','O',' ')}},     \/* Esperanto *\/\n+  {\"es\",        {HB_TAG('E','S','P',' ')}},     \/* Spanish *\/\n+  {\"esg\",       {HB_TAG('G','O','N',' ')}},     \/* Aheri Gondi -> Gondi *\/\n+  {\"esi\",       {HB_TAG('I','P','K',' ')}},     \/* North Alaskan Inupiatun -> Inupiat *\/\n+  {\"esk\",       {HB_TAG('I','P','K',' ')}},     \/* Northwest Alaska Inupiatun -> Inupiat *\/\n+  {\"esu\",       {HB_TAG('E','S','U',' ')}},     \/* Central Yupik *\/\n+  {\"et\",        {HB_TAG('E','T','I',' ')}},     \/* Estonian [macrolanguage] *\/\n+  {\"eto\",       {HB_TAG('B','T','I',' ')}},     \/* Eton (Cameroon) -> Beti *\/\n+  {\"eu\",        {HB_TAG('E','U','Q',' ')}},     \/* Basque *\/\n+  {\"eve\",       {HB_TAG('E','V','N',' ')}},     \/* Even *\/\n+  {\"evn\",       {HB_TAG('E','V','K',' ')}},     \/* Evenki *\/\n+  {\"ewo\",       {HB_TAG('B','T','I',' ')}},     \/* Ewondo -> Beti *\/\n+  {\"eyo\",       {HB_TAG('K','A','L',' ')}},     \/* Keiyo -> Kalenjin *\/\n+  {\"fa\",        {HB_TAG('F','A','R',' ')}},     \/* Persian [macrolanguage] *\/\n+  {\"fan\",       {HB_TAG('F','A','N','0')}},     \/* Fang (Equatorial Guinea) *\/\n+  {\"fat\",       {HB_TAG('F','A','T',' ')}},     \/* Fanti *\/\n+  {\"fbl\",       {HB_TAG('B','I','K',' ')}},     \/* West Albay Bikol -> Bikol *\/\n+  {\"ff\",        {HB_TAG('F','U','L',' ')}},     \/* Fulah [macrolanguage] *\/\n+  {\"ffm\",       {HB_TAG('F','U','L',' ')}},     \/* Maasina Fulfulde -> Fulah *\/\n+  {\"fi\",        {HB_TAG('F','I','N',' ')}},     \/* Finnish *\/\n+  {\"fil\",       {HB_TAG('P','I','L',' ')}},     \/* Filipino *\/\n+  {\"fj\",        {HB_TAG('F','J','I',' ')}},     \/* Fijian *\/\n+  {\"flm\",       {HB_TAG('H','A','L',' '),       \/* Halam (Falam Chin) (retired code) *\/\n+                 HB_TAG('Q','I','N',' ')}},     \/* Falam Chin (retired code) -> Chin *\/\n+  {\"fmp\",       {HB_TAG('F','M','P',' ')}},     \/* Fe'fe' *\/\n+  {\"fo\",        {HB_TAG('F','O','S',' ')}},     \/* Faroese *\/\n+  {\"fon\",       {HB_TAG('F','O','N',' ')}},     \/* Fon *\/\n+  {\"fr\",        {HB_TAG('F','R','A',' ')}},     \/* French *\/\n+  {\"frc\",       {HB_TAG('F','R','C',' ')}},     \/* Cajun French *\/\n+  {\"frp\",       {HB_TAG('F','R','P',' ')}},     \/* Arpitan *\/\n+  {\"fub\",       {HB_TAG('F','U','L',' ')}},     \/* Adamawa Fulfulde -> Fulah *\/\n+  {\"fuc\",       {HB_TAG('F','U','L',' ')}},     \/* Pulaar -> Fulah *\/\n+  {\"fue\",       {HB_TAG('F','U','L',' ')}},     \/* Borgu Fulfulde -> Fulah *\/\n+  {\"fuf\",       {HB_TAG('F','T','A',' ')}},     \/* Pular -> Futa *\/\n+  {\"fuh\",       {HB_TAG('F','U','L',' ')}},     \/* Western Niger Fulfulde -> Fulah *\/\n+  {\"fui\",       {HB_TAG('F','U','L',' ')}},     \/* Bagirmi Fulfulde -> Fulah *\/\n+  {\"fuq\",       {HB_TAG('F','U','L',' ')}},     \/* Central-Eastern Niger Fulfulde -> Fulah *\/\n+  {\"fur\",       {HB_TAG('F','R','L',' ')}},     \/* Friulian *\/\n+  {\"fuv\",       {HB_TAG('F','U','V',' ')}},     \/* Nigerian Fulfulde *\/\n+  {\"fy\",        {HB_TAG('F','R','I',' ')}},     \/* Western Frisian -> Frisian *\/\n+  {\"ga\",        {HB_TAG('I','R','I',' ')}},     \/* Irish *\/\n+  {\"gaa\",       {HB_TAG('G','A','D',' ')}},     \/* Ga *\/\n+  {\"gag\",       {HB_TAG('G','A','G',' ')}},     \/* Gagauz *\/\n+  {\"gan\",       {HB_TAG('Z','H','S',' ')}},     \/* Gan Chinese -> Chinese Simplified *\/\n+  {\"gax\",       {HB_TAG('O','R','O',' ')}},     \/* Borana-Arsi-Guji Oromo -> Oromo *\/\n+  {\"gaz\",       {HB_TAG('O','R','O',' ')}},     \/* West Central Oromo -> Oromo *\/\n+  {\"gbm\",       {HB_TAG('G','A','W',' ')}},     \/* Garhwali *\/\n+  {\"gce\",       {HB_TAG('A','T','H',' ')}},     \/* Galice -> Athapaskan *\/\n+  {\"gd\",        {HB_TAG('G','A','E',' ')}},     \/* Scottish Gaelic (Gaelic) *\/\n+  {\"gda\",       {HB_TAG('R','A','J',' ')}},     \/* Gade Lohar -> Rajasthani *\/\n+  {\"gez\",       {HB_TAG('G','E','Z',' ')}},     \/* Geez *\/\n+  {\"ggo\",       {HB_TAG('G','O','N',' ')}},     \/* Southern Gondi (retired code) -> Gondi *\/\n+  {\"gih\",       {HB_TAG('G','I','H',' ')}},     \/* Githabul *\/\n+  {\"gil\",       {HB_TAG('G','I','L','0')}},     \/* Kiribati (Gilbertese) *\/\n+  {\"gju\",       {HB_TAG('R','A','J',' ')}},     \/* Gujari -> Rajasthani *\/\n+  {\"gkp\",       {HB_TAG('G','K','P',' ')}},     \/* Guinea Kpelle -> Kpelle (Guinea) *\/\n+  {\"gl\",        {HB_TAG('G','A','L',' ')}},     \/* Galician *\/\n+  {\"gld\",       {HB_TAG('N','A','N',' ')}},     \/* Nanai *\/\n+  {\"glk\",       {HB_TAG('G','L','K',' ')}},     \/* Gilaki *\/\n+  {\"gn\",        {HB_TAG('G','U','A',' ')}},     \/* Guarani [macrolanguage] *\/\n+  {\"gnn\",       {HB_TAG('G','N','N',' ')}},     \/* Gumatj *\/\n+  {\"gno\",       {HB_TAG('G','O','N',' ')}},     \/* Northern Gondi -> Gondi *\/\n+  {\"gnw\",       {HB_TAG('G','U','A',' ')}},     \/* Western Bolivian Guaraní -> Guarani *\/\n+  {\"gog\",       {HB_TAG('G','O','G',' ')}},     \/* Gogo *\/\n+  {\"gom\",       {HB_TAG('K','O','K',' ')}},     \/* Goan Konkani -> Konkani *\/\n+  {\"gon\",       {HB_TAG('G','O','N',' ')}},     \/* Gondi [macrolanguage] *\/\n+  {\"grt\",       {HB_TAG('G','R','O',' ')}},     \/* Garo *\/\n+  {\"gru\",       {HB_TAG('S','O','G',' ')}},     \/* Kistane -> Sodo Gurage *\/\n+  {\"gsw\",       {HB_TAG('A','L','S',' ')}},     \/* Alsatian *\/\n+  {\"gu\",        {HB_TAG('G','U','J',' ')}},     \/* Gujarati *\/\n+  {\"guc\",       {HB_TAG('G','U','C',' ')}},     \/* Wayuu *\/\n+  {\"guf\",       {HB_TAG('G','U','F',' ')}},     \/* Gupapuyngu *\/\n+  {\"gug\",       {HB_TAG('G','U','A',' ')}},     \/* Paraguayan Guaraní -> Guarani *\/\n+  {\"gui\",       {HB_TAG('G','U','A',' ')}},     \/* Eastern Bolivian Guaraní -> Guarani *\/\n+  {\"guk\",       {HB_TAG('G','M','Z',' '),       \/* Gumuz *\/\n+                 HB_TAG('G','U','K',' ')}},     \/* Gumuz (SIL fonts) *\/\n+  {\"gun\",       {HB_TAG('G','U','A',' ')}},     \/* Mbyá Guaraní -> Guarani *\/\n+  {\"guz\",       {HB_TAG('G','U','Z',' ')}},     \/* Gusii *\/\n+  {\"gv\",        {HB_TAG('M','N','X',' ')}},     \/* Manx *\/\n+  {\"gwi\",       {HB_TAG('A','T','H',' ')}},     \/* Gwichʼin -> Athapaskan *\/\n+  {\"ha\",        {HB_TAG('H','A','U',' ')}},     \/* Hausa *\/\n+  {\"haa\",       {HB_TAG('A','T','H',' ')}},     \/* Han -> Athapaskan *\/\n+  {\"hae\",       {HB_TAG('O','R','O',' ')}},     \/* Eastern Oromo -> Oromo *\/\n+  {\"hak\",       {HB_TAG('Z','H','S',' ')}},     \/* Hakka Chinese -> Chinese Simplified *\/\n+  {\"har\",       {HB_TAG('H','R','I',' ')}},     \/* Harari *\/\n+  {\"haw\",       {HB_TAG('H','A','W',' ')}},     \/* Hawaiian *\/\n+  {\"hay\",       {HB_TAG('H','A','Y',' ')}},     \/* Haya *\/\n+  {\"haz\",       {HB_TAG('H','A','Z',' ')}},     \/* Hazaragi *\/\n+  {\"he\",        {HB_TAG('I','W','R',' ')}},     \/* Hebrew *\/\n+  {\"hea\",       {HB_TAG('H','M','N',' ')}},     \/* Northern Qiandong Miao -> Hmong *\/\n+  {\"hi\",        {HB_TAG('H','I','N',' ')}},     \/* Hindi *\/\n+  {\"hil\",       {HB_TAG('H','I','L',' ')}},     \/* Hiligaynon *\/\n+  {\"hji\",       {HB_TAG('M','L','Y',' ')}},     \/* Haji -> Malay *\/\n+  {\"hlt\",       {HB_TAG('Q','I','N',' ')}},     \/* Matu Chin -> Chin *\/\n+  {\"hma\",       {HB_TAG('H','M','N',' ')}},     \/* Southern Mashan Hmong -> Hmong *\/\n+  {\"hmc\",       {HB_TAG('H','M','N',' ')}},     \/* Central Huishui Hmong -> Hmong *\/\n+  {\"hmd\",       {HB_TAG('H','M','N',' ')}},     \/* Large Flowery Miao -> Hmong *\/\n+  {\"hme\",       {HB_TAG('H','M','N',' ')}},     \/* Eastern Huishui Hmong -> Hmong *\/\n+  {\"hmg\",       {HB_TAG('H','M','N',' ')}},     \/* Southwestern Guiyang Hmong -> Hmong *\/\n+  {\"hmh\",       {HB_TAG('H','M','N',' ')}},     \/* Southwestern Huishui Hmong -> Hmong *\/\n+  {\"hmi\",       {HB_TAG('H','M','N',' ')}},     \/* Northern Huishui Hmong -> Hmong *\/\n+  {\"hmj\",       {HB_TAG('H','M','N',' ')}},     \/* Ge -> Hmong *\/\n+  {\"hml\",       {HB_TAG('H','M','N',' ')}},     \/* Luopohe Hmong -> Hmong *\/\n+  {\"hmm\",       {HB_TAG('H','M','N',' ')}},     \/* Central Mashan Hmong -> Hmong *\/\n+  {\"hmn\",       {HB_TAG('H','M','N',' ')}},     \/* Hmong [macrolanguage] *\/\n+  {\"hmp\",       {HB_TAG('H','M','N',' ')}},     \/* Northern Mashan Hmong -> Hmong *\/\n+  {\"hmq\",       {HB_TAG('H','M','N',' ')}},     \/* Eastern Qiandong Miao -> Hmong *\/\n+  {\"hms\",       {HB_TAG('H','M','N',' ')}},     \/* Southern Qiandong Miao -> Hmong *\/\n+  {\"hmw\",       {HB_TAG('H','M','N',' ')}},     \/* Western Mashan Hmong -> Hmong *\/\n+  {\"hmy\",       {HB_TAG('H','M','N',' ')}},     \/* Southern Guiyang Hmong -> Hmong *\/\n+  {\"hmz\",       {HB_TAG('H','M','N',' ')}},     \/* Hmong Shua -> Hmong *\/\n+  {\"hnd\",       {HB_TAG('H','N','D',' ')}},     \/* Southern Hindko -> Hindko *\/\n+  {\"hne\",       {HB_TAG('C','H','H',' ')}},     \/* Chhattisgarhi -> Chattisgarhi *\/\n+  {\"hnj\",       {HB_TAG('H','M','N',' ')}},     \/* Hmong Njua -> Hmong *\/\n+  {\"hno\",       {HB_TAG('H','N','D',' ')}},     \/* Northern Hindko -> Hindko *\/\n+  {\"ho\",        {HB_TAG('H','M','O',' ')}},     \/* Hiri Motu *\/\n+  {\"hoc\",       {HB_TAG('H','O',' ',' ')}},     \/* Ho *\/\n+  {\"hoi\",       {HB_TAG('A','T','H',' ')}},     \/* Holikachuk -> Athapaskan *\/\n+  {\"hoj\",       {HB_TAG('H','A','R',' ')}},     \/* Hadothi -> Harauti *\/\n+  {\"hr\",        {HB_TAG('H','R','V',' ')}},     \/* Croatian *\/\n+  {\"hrm\",       {HB_TAG('H','M','N',' ')}},     \/* Horned Miao -> Hmong *\/\n+  {\"hsb\",       {HB_TAG('U','S','B',' ')}},     \/* Upper Sorbian *\/\n+  {\"hsn\",       {HB_TAG('Z','H','S',' ')}},     \/* Xiang Chinese -> Chinese Simplified *\/\n+  {\"ht\",        {HB_TAG('H','A','I',' ')}},     \/* Haitian (Haitian Creole) *\/\n+  {\"hu\",        {HB_TAG('H','U','N',' ')}},     \/* Hungarian *\/\n+  {\"huj\",       {HB_TAG('H','M','N',' ')}},     \/* Northern Guiyang Hmong -> Hmong *\/\n+  {\"hup\",       {HB_TAG('A','T','H',' ')}},     \/* Hupa -> Athapaskan *\/\n+  {\"hy\",        {HB_TAG('H','Y','E','0'),       \/* Armenian -> Armenian East *\/\n+                 HB_TAG('H','Y','E',' ')}},     \/* Armenian *\/\n+  {\"hyw\",       {HB_TAG('H','Y','E',' ')}},     \/* Western Armenian -> Armenian *\/\n+  {\"hz\",        {HB_TAG('H','E','R',' ')}},     \/* Herero *\/\n+  {\"ia\",        {HB_TAG('I','N','A',' ')}},     \/* Interlingua (International Auxiliary Language Association) *\/\n+  {\"iba\",       {HB_TAG('I','B','A',' ')}},     \/* Iban *\/\n+  {\"ibb\",       {HB_TAG('I','B','B',' ')}},     \/* Ibibio *\/\n+  {\"id\",        {HB_TAG('I','N','D',' ')}},     \/* Indonesian *\/\n+  {\"ida\",       {HB_TAG('L','U','H',' ')}},     \/* Idakho-Isukha-Tiriki -> Luyia *\/\n+  {\"ie\",        {HB_TAG('I','L','E',' ')}},     \/* Interlingue *\/\n+  {\"ig\",        {HB_TAG('I','B','O',' ')}},     \/* Igbo *\/\n+  {\"igb\",       {HB_TAG('E','B','I',' ')}},     \/* Ebira *\/\n+  {\"ii\",        {HB_TAG('Y','I','M',' ')}},     \/* Sichuan Yi -> Yi Modern *\/\n+  {\"ijc\",       {HB_TAG('I','J','O',' ')}},     \/* Izon -> Ijo *\/\n+  {\"ijo\",       {HB_TAG('I','J','O',' ')}},     \/* Ijo [family] *\/\n+  {\"ik\",        {HB_TAG('I','P','K',' ')}},     \/* Inupiaq [macrolanguage] -> Inupiat *\/\n+  {\"ike\",       {HB_TAG('I','N','U',' ')}},     \/* Eastern Canadian Inuktitut -> Inuktitut *\/\n+  {\"ikt\",       {HB_TAG('I','N','U',' ')}},     \/* Inuinnaqtun -> Inuktitut *\/\n+  {\"ilo\",       {HB_TAG('I','L','O',' ')}},     \/* Iloko -> Ilokano *\/\n+  {\"in\",        {HB_TAG('I','N','D',' ')}},     \/* Indonesian (retired code) *\/\n+  {\"ing\",       {HB_TAG('A','T','H',' ')}},     \/* Degexit'an -> Athapaskan *\/\n+  {\"inh\",       {HB_TAG('I','N','G',' ')}},     \/* Ingush *\/\n+  {\"io\",        {HB_TAG('I','D','O',' ')}},     \/* Ido *\/\n+  {\"is\",        {HB_TAG('I','S','L',' ')}},     \/* Icelandic *\/\n+  {\"it\",        {HB_TAG('I','T','A',' ')}},     \/* Italian *\/\n+  {\"iu\",        {HB_TAG('I','N','U',' ')}},     \/* Inuktitut [macrolanguage] *\/\n+  {\"iw\",        {HB_TAG('I','W','R',' ')}},     \/* Hebrew (retired code) *\/\n+  {\"ja\",        {HB_TAG('J','A','N',' ')}},     \/* Japanese *\/\n+  {\"jak\",       {HB_TAG('M','L','Y',' ')}},     \/* Jakun -> Malay *\/\n+  {\"jam\",       {HB_TAG('J','A','M',' ')}},     \/* Jamaican Creole English -> Jamaican Creole *\/\n+  {\"jax\",       {HB_TAG('M','L','Y',' ')}},     \/* Jambi Malay -> Malay *\/\n+  {\"jbo\",       {HB_TAG('J','B','O',' ')}},     \/* Lojban *\/\n+  {\"jct\",       {HB_TAG('J','C','T',' ')}},     \/* Krymchak *\/\n+  {\"ji\",        {HB_TAG('J','I','I',' ')}},     \/* Yiddish (retired code) *\/\n+  {\"jv\",        {HB_TAG('J','A','V',' ')}},     \/* Javanese *\/\n+  {\"jw\",        {HB_TAG('J','A','V',' ')}},     \/* Javanese (retired code) *\/\n+  {\"ka\",        {HB_TAG('K','A','T',' ')}},     \/* Georgian *\/\n+  {\"kaa\",       {HB_TAG('K','R','K',' ')}},     \/* Kara-Kalpak -> Karakalpak *\/\n+  {\"kab\",       {HB_TAG('K','A','B','0')}},     \/* Kabyle *\/\n+  {\"kam\",       {HB_TAG('K','M','B',' ')}},     \/* Kamba (Kenya) *\/\n+  {\"kar\",       {HB_TAG('K','R','N',' ')}},     \/* Karen [family] *\/\n+  {\"kbd\",       {HB_TAG('K','A','B',' ')}},     \/* Kabardian *\/\n+  {\"kby\",       {HB_TAG('K','N','R',' ')}},     \/* Manga Kanuri -> Kanuri *\/\n+  {\"kca\",       {HB_TAG('K','H','K',' '),       \/* Khanty -> Khanty-Kazim *\/\n+                 HB_TAG('K','H','S',' '),       \/* Khanty -> Khanty-Shurishkar *\/\n+                 HB_TAG('K','H','V',' ')}},     \/* Khanty -> Khanty-Vakhi *\/\n+  {\"kde\",       {HB_TAG('K','D','E',' ')}},     \/* Makonde *\/\n+  {\"kdr\",       {HB_TAG('K','R','M',' ')}},     \/* Karaim *\/\n+  {\"kdt\",       {HB_TAG('K','U','Y',' ')}},     \/* Kuy *\/\n+  {\"kea\",       {HB_TAG('K','E','A',' ')}},     \/* Kabuverdianu (Crioulo) *\/\n+  {\"kek\",       {HB_TAG('K','E','K',' ')}},     \/* Kekchi *\/\n+  {\"kex\",       {HB_TAG('K','K','N',' ')}},     \/* Kukna -> Kokni *\/\n+  {\"kfa\",       {HB_TAG('K','O','D',' ')}},     \/* Kodava -> Kodagu *\/\n+  {\"kfr\",       {HB_TAG('K','A','C',' ')}},     \/* Kachhi -> Kachchi *\/\n+  {\"kfx\",       {HB_TAG('K','U','L',' ')}},     \/* Kullu Pahari -> Kulvi *\/\n+  {\"kfy\",       {HB_TAG('K','M','N',' ')}},     \/* Kumaoni *\/\n+  {\"kg\",        {HB_TAG('K','O','N','0')}},     \/* Kongo [macrolanguage] *\/\n+  {\"kha\",       {HB_TAG('K','S','I',' ')}},     \/* Khasi *\/\n+  {\"khb\",       {HB_TAG('X','B','D',' ')}},     \/* Lü *\/\n+  {\"khk\",       {HB_TAG('M','N','G',' ')}},     \/* Halh Mongolian -> Mongolian *\/\n+  {\"kht\",       {HB_TAG('K','H','N',' '),       \/* Khamti -> Khamti Shan (Microsoft fonts) *\/\n+                 HB_TAG('K','H','T',' ')}},     \/* Khamti -> Khamti Shan (OpenType spec and SIL fonts) *\/\n+  {\"khw\",       {HB_TAG('K','H','W',' ')}},     \/* Khowar *\/\n+  {\"ki\",        {HB_TAG('K','I','K',' ')}},     \/* Kikuyu (Gikuyu) *\/\n+  {\"kiu\",       {HB_TAG('K','I','U',' ')}},     \/* Kirmanjki *\/\n+  {\"kj\",        {HB_TAG('K','U','A',' ')}},     \/* Kuanyama *\/\n+  {\"kjd\",       {HB_TAG('K','J','D',' ')}},     \/* Southern Kiwai *\/\n+  {\"kjh\",       {HB_TAG('K','H','A',' ')}},     \/* Khakas -> Khakass *\/\n+  {\"kjp\",       {HB_TAG('K','J','P',' ')}},     \/* Pwo Eastern Karen -> Eastern Pwo Karen *\/\n+  {\"kjz\",       {HB_TAG('K','J','Z',' ')}},     \/* Bumthangkha *\/\n+  {\"kk\",        {HB_TAG('K','A','Z',' ')}},     \/* Kazakh *\/\n+  {\"kkz\",       {HB_TAG('A','T','H',' ')}},     \/* Kaska -> Athapaskan *\/\n+  {\"kl\",        {HB_TAG('G','R','N',' ')}},     \/* Greenlandic *\/\n+  {\"kln\",       {HB_TAG('K','A','L',' ')}},     \/* Kalenjin [macrolanguage] *\/\n+  {\"km\",        {HB_TAG('K','H','M',' ')}},     \/* Khmer *\/\n+  {\"kmb\",       {HB_TAG('M','B','N',' ')}},     \/* Kimbundu -> Mbundu *\/\n+  {\"kmr\",       {HB_TAG('K','U','R',' ')}},     \/* Northern Kurdish -> Kurdish *\/\n+  {\"kmw\",       {HB_TAG('K','M','O',' ')}},     \/* Komo (Democratic Republic of Congo) *\/\n+  {\"kmz\",       {HB_TAG('K','M','Z',' ')}},     \/* Khorasani Turkish -> Khorasani Turkic *\/\n+  {\"kn\",        {HB_TAG('K','A','N',' ')}},     \/* Kannada *\/\n+  {\"knc\",       {HB_TAG('K','N','R',' ')}},     \/* Central Kanuri -> Kanuri *\/\n+  {\"kng\",       {HB_TAG('K','O','N','0')}},     \/* Koongo -> Kongo *\/\n+  {\"knn\",       {HB_TAG('K','O','K',' ')}},     \/* Konkani *\/\n+  {\"ko\",        {HB_TAG('K','O','R',' ')}},     \/* Korean *\/\n+  {\"koi\",       {HB_TAG('K','O','P',' ')}},     \/* Komi-Permyak *\/\n+  {\"kok\",       {HB_TAG('K','O','K',' ')}},     \/* Konkani [macrolanguage] *\/\n+  {\"kos\",       {HB_TAG('K','O','S',' ')}},     \/* Kosraean *\/\n+  {\"koy\",       {HB_TAG('A','T','H',' ')}},     \/* Koyukon -> Athapaskan *\/\n+  {\"kpe\",       {HB_TAG('K','P','L',' ')}},     \/* Kpelle [macrolanguage] *\/\n+  {\"kpv\",       {HB_TAG('K','O','Z',' ')}},     \/* Komi-Zyrian *\/\n+  {\"kpy\",       {HB_TAG('K','Y','K',' ')}},     \/* Koryak *\/\n+  {\"kqs\",       {HB_TAG('K','I','S',' ')}},     \/* Northern Kissi -> Kisii *\/\n+  {\"kqy\",       {HB_TAG('K','R','T',' ')}},     \/* Koorete *\/\n+  {\"kr\",        {HB_TAG('K','N','R',' ')}},     \/* Kanuri [macrolanguage] *\/\n+  {\"krc\",       {HB_TAG('K','A','R',' '),       \/* Karachay-Balkar -> Karachay *\/\n+                 HB_TAG('B','A','L',' ')}},     \/* Karachay-Balkar -> Balkar *\/\n+  {\"kri\",       {HB_TAG('K','R','I',' ')}},     \/* Krio *\/\n+  {\"krl\",       {HB_TAG('K','R','L',' ')}},     \/* Karelian *\/\n+  {\"krt\",       {HB_TAG('K','N','R',' ')}},     \/* Tumari Kanuri -> Kanuri *\/\n+  {\"kru\",       {HB_TAG('K','U','U',' ')}},     \/* Kurukh *\/\n+  {\"ks\",        {HB_TAG('K','S','H',' ')}},     \/* Kashmiri *\/\n+  {\"ksh\",       {HB_TAG('K','S','H','0')}},     \/* Kölsch -> Ripuarian *\/\n+  {\"kss\",       {HB_TAG('K','I','S',' ')}},     \/* Southern Kisi -> Kisii *\/\n+  {\"ksw\",       {HB_TAG('K','S','W',' ')}},     \/* S’gaw Karen *\/\n+  {\"ktb\",       {HB_TAG('K','E','B',' ')}},     \/* Kambaata -> Kebena *\/\n+  {\"ktu\",       {HB_TAG('K','O','N',' ')}},     \/* Kituba (Democratic Republic of Congo) -> Kikongo *\/\n+  {\"ktw\",       {HB_TAG('A','T','H',' ')}},     \/* Kato -> Athapaskan *\/\n+  {\"ku\",        {HB_TAG('K','U','R',' ')}},     \/* Kurdish [macrolanguage] *\/\n+  {\"kum\",       {HB_TAG('K','U','M',' ')}},     \/* Kumyk *\/\n+  {\"kuu\",       {HB_TAG('A','T','H',' ')}},     \/* Upper Kuskokwim -> Athapaskan *\/\n+  {\"kv\",        {HB_TAG('K','O','M',' ')}},     \/* Komi [macrolanguage] *\/\n+  {\"kvb\",       {HB_TAG('M','L','Y',' ')}},     \/* Kubu -> Malay *\/\n+  {\"kvr\",       {HB_TAG('M','L','Y',' ')}},     \/* Kerinci -> Malay *\/\n+  {\"kw\",        {HB_TAG('C','O','R',' ')}},     \/* Cornish *\/\n+  {\"kwy\",       {HB_TAG('K','O','N','0')}},     \/* San Salvador Kongo -> Kongo *\/\n+  {\"kxc\",       {HB_TAG('K','M','S',' ')}},     \/* Konso -> Komso *\/\n+  {\"kxd\",       {HB_TAG('M','L','Y',' ')}},     \/* Brunei -> Malay *\/\n+  {\"kxu\",       {HB_TAG('K','U','I',' ')}},     \/* Kui (India) *\/\n+  {\"ky\",        {HB_TAG('K','I','R',' ')}},     \/* Kirghiz (Kyrgyz) *\/\n+  {\"kyu\",       {HB_TAG('K','Y','U',' ')}},     \/* Western Kayah *\/\n+  {\"la\",        {HB_TAG('L','A','T',' ')}},     \/* Latin *\/\n+  {\"lad\",       {HB_TAG('J','U','D',' ')}},     \/* Ladino *\/\n+  {\"lb\",        {HB_TAG('L','T','Z',' ')}},     \/* Luxembourgish *\/\n+  {\"lbe\",       {HB_TAG('L','A','K',' ')}},     \/* Lak *\/\n+  {\"lbj\",       {HB_TAG('L','D','K',' ')}},     \/* Ladakhi *\/\n+  {\"lbl\",       {HB_TAG('B','I','K',' ')}},     \/* Libon Bikol -> Bikol *\/\n+  {\"lce\",       {HB_TAG('M','L','Y',' ')}},     \/* Loncong -> Malay *\/\n+  {\"lcf\",       {HB_TAG('M','L','Y',' ')}},     \/* Lubu -> Malay *\/\n+  {\"ldi\",       {HB_TAG('K','O','N','0')}},     \/* Laari -> Kongo *\/\n+  {\"lez\",       {HB_TAG('L','E','Z',' ')}},     \/* Lezghian -> Lezgi *\/\n+  {\"lg\",        {HB_TAG('L','U','G',' ')}},     \/* Ganda *\/\n+  {\"li\",        {HB_TAG('L','I','M',' ')}},     \/* Limburgish *\/\n+  {\"lif\",       {HB_TAG('L','M','B',' ')}},     \/* Limbu *\/\n+  {\"lij\",       {HB_TAG('L','I','J',' ')}},     \/* Ligurian *\/\n+  {\"lis\",       {HB_TAG('L','I','S',' ')}},     \/* Lisu *\/\n+  {\"liw\",       {HB_TAG('M','L','Y',' ')}},     \/* Col -> Malay *\/\n+  {\"ljp\",       {HB_TAG('L','J','P',' ')}},     \/* Lampung Api -> Lampung *\/\n+  {\"lkb\",       {HB_TAG('L','U','H',' ')}},     \/* Kabras -> Luyia *\/\n+  {\"lki\",       {HB_TAG('L','K','I',' ')}},     \/* Laki *\/\n+  {\"lko\",       {HB_TAG('L','U','H',' ')}},     \/* Khayo -> Luyia *\/\n+  {\"lks\",       {HB_TAG('L','U','H',' ')}},     \/* Kisa -> Luyia *\/\n+  {\"lld\",       {HB_TAG('L','A','D',' ')}},     \/* Ladin *\/\n+  {\"lmn\",       {HB_TAG('L','A','M',' ')}},     \/* Lambadi -> Lambani *\/\n+  {\"lmo\",       {HB_TAG('L','M','O',' ')}},     \/* Lombard *\/\n+  {\"ln\",        {HB_TAG('L','I','N',' ')}},     \/* Lingala *\/\n+  {\"lo\",        {HB_TAG('L','A','O',' ')}},     \/* Lao *\/\n+  {\"lom\",       {HB_TAG('L','O','M',' ')}},     \/* Loma (Liberia) *\/\n+  {\"lrc\",       {HB_TAG('L','R','C',' ')}},     \/* Northern Luri -> Luri *\/\n+  {\"lri\",       {HB_TAG('L','U','H',' ')}},     \/* Marachi -> Luyia *\/\n+  {\"lrm\",       {HB_TAG('L','U','H',' ')}},     \/* Marama -> Luyia *\/\n+  {\"lsm\",       {HB_TAG('L','U','H',' ')}},     \/* Saamia -> Luyia *\/\n+  {\"lt\",        {HB_TAG('L','T','H',' ')}},     \/* Lithuanian *\/\n+  {\"ltg\",       {HB_TAG('L','V','I',' ')}},     \/* Latgalian -> Latvian *\/\n+  {\"lto\",       {HB_TAG('L','U','H',' ')}},     \/* Tsotso -> Luyia *\/\n+  {\"lts\",       {HB_TAG('L','U','H',' ')}},     \/* Tachoni -> Luyia *\/\n+  {\"lu\",        {HB_TAG('L','U','B',' ')}},     \/* Luba-Katanga *\/\n+  {\"lua\",       {HB_TAG('L','U','A',' ')}},     \/* Luba-Lulua *\/\n+  {\"luo\",       {HB_TAG('L','U','O',' ')}},     \/* Luo (Kenya and Tanzania) *\/\n+  {\"lus\",       {HB_TAG('M','I','Z',' ')}},     \/* Lushai -> Mizo *\/\n+  {\"luy\",       {HB_TAG('L','U','H',' ')}},     \/* Luyia [macrolanguage] *\/\n+  {\"luz\",       {HB_TAG('L','R','C',' ')}},     \/* Southern Luri -> Luri *\/\n+  {\"lv\",        {HB_TAG('L','V','I',' ')}},     \/* Latvian [macrolanguage] *\/\n+  {\"lvs\",       {HB_TAG('L','V','I',' ')}},     \/* Standard Latvian -> Latvian *\/\n+  {\"lwg\",       {HB_TAG('L','U','H',' ')}},     \/* Wanga -> Luyia *\/\n+  {\"lzh\",       {HB_TAG('Z','H','T',' ')}},     \/* Literary Chinese -> Chinese Traditional *\/\n+  {\"lzz\",       {HB_TAG('L','A','Z',' ')}},     \/* Laz *\/\n+  {\"mad\",       {HB_TAG('M','A','D',' ')}},     \/* Madurese -> Madura *\/\n+  {\"mag\",       {HB_TAG('M','A','G',' ')}},     \/* Magahi *\/\n+  {\"mai\",       {HB_TAG('M','T','H',' ')}},     \/* Maithili *\/\n+  {\"mak\",       {HB_TAG('M','K','R',' ')}},     \/* Makasar *\/\n+  {\"mam\",       {HB_TAG('M','A','M',' ')}},     \/* Mam *\/\n+  {\"man\",       {HB_TAG('M','N','K',' ')}},     \/* Mandingo [macrolanguage] -> Maninka *\/\n+  {\"max\",       {HB_TAG('M','L','Y',' ')}},     \/* North Moluccan Malay -> Malay *\/\n+  {\"mbo\",       {HB_TAG('M','B','O',' ')}},     \/* Mbo (Cameroon) *\/\n+  {\"mct\",       {HB_TAG('B','T','I',' ')}},     \/* Mengisa -> Beti *\/\n+  {\"mdf\",       {HB_TAG('M','O','K',' ')}},     \/* Moksha *\/\n+  {\"mdr\",       {HB_TAG('M','D','R',' ')}},     \/* Mandar *\/\n+  {\"mdy\",       {HB_TAG('M','L','E',' ')}},     \/* Male (Ethiopia) *\/\n+  {\"men\",       {HB_TAG('M','D','E',' ')}},     \/* Mende (Sierra Leone) *\/\n+  {\"meo\",       {HB_TAG('M','L','Y',' ')}},     \/* Kedah Malay -> Malay *\/\n+  {\"mer\",       {HB_TAG('M','E','R',' ')}},     \/* Meru *\/\n+  {\"mfa\",       {HB_TAG('M','F','A',' ')}},     \/* Pattani Malay *\/\n+  {\"mfb\",       {HB_TAG('M','L','Y',' ')}},     \/* Bangka -> Malay *\/\n+  {\"mfe\",       {HB_TAG('M','F','E',' ')}},     \/* Morisyen *\/\n+  {\"mg\",        {HB_TAG('M','L','G',' ')}},     \/* Malagasy [macrolanguage] *\/\n+  {\"mh\",        {HB_TAG('M','A','H',' ')}},     \/* Marshallese *\/\n+  {\"mhr\",       {HB_TAG('L','M','A',' ')}},     \/* Eastern Mari -> Low Mari *\/\n+  {\"mhv\",       {HB_TAG('A','R','K',' ')}},     \/* Arakanese (retired code) -> Rakhine *\/\n+  {\"mi\",        {HB_TAG('M','R','I',' ')}},     \/* Maori *\/\n+  {\"min\",       {HB_TAG('M','I','N',' ')}},     \/* Minangkabau *\/\n+  {\"mk\",        {HB_TAG('M','K','D',' ')}},     \/* Macedonian *\/\n+  {\"mku\",       {HB_TAG('M','N','K',' ')}},     \/* Konyanka Maninka -> Maninka *\/\n+  {\"mkw\",       {HB_TAG('M','K','W',' ')}},     \/* Kituba (Congo) *\/\n+  {\"ml\",        {HB_TAG('M','A','L',' '),       \/* Malayalam -> Malayalam Traditional *\/\n+                 HB_TAG('M','L','R',' ')}},     \/* Malayalam -> Malayalam Reformed *\/\n+  {\"mlq\",       {HB_TAG('M','L','N',' '),       \/* Western Maninkakan -> Malinke *\/\n+                 HB_TAG('M','N','K',' ')}},     \/* Western Maninkakan -> Maninka *\/\n+  {\"mmr\",       {HB_TAG('H','M','N',' ')}},     \/* Western Xiangxi Miao -> Hmong *\/\n+  {\"mn\",        {HB_TAG('M','N','G',' ')}},     \/* Mongolian [macrolanguage] *\/\n+  {\"mnc\",       {HB_TAG('M','C','H',' ')}},     \/* Manchu *\/\n+  {\"mni\",       {HB_TAG('M','N','I',' ')}},     \/* Manipuri *\/\n+  {\"mnk\",       {HB_TAG('M','N','D',' '),       \/* Mandinka *\/\n+                 HB_TAG('M','N','K',' ')}},     \/* Mandinka -> Maninka *\/\n+  {\"mnp\",       {HB_TAG('Z','H','S',' ')}},     \/* Min Bei Chinese -> Chinese Simplified *\/\n+  {\"mns\",       {HB_TAG('M','A','N',' ')}},     \/* Mansi *\/\n+  {\"mnw\",       {HB_TAG('M','O','N',' ')}},     \/* Mon *\/\n+  {\"mo\",        {HB_TAG('M','O','L',' ')}},     \/* Moldavian (retired code) *\/\n+  {\"moh\",       {HB_TAG('M','O','H',' ')}},     \/* Mohawk *\/\n+  {\"mos\",       {HB_TAG('M','O','S',' ')}},     \/* Mossi *\/\n+  {\"mpe\",       {HB_TAG('M','A','J',' ')}},     \/* Majang *\/\n+  {\"mqg\",       {HB_TAG('M','L','Y',' ')}},     \/* Kota Bangun Kutai Malay -> Malay *\/\n+  {\"mr\",        {HB_TAG('M','A','R',' ')}},     \/* Marathi *\/\n+  {\"mrh\",       {HB_TAG('Q','I','N',' ')}},     \/* Mara Chin -> Chin *\/\n+  {\"mrj\",       {HB_TAG('H','M','A',' ')}},     \/* Western Mari -> High Mari *\/\n+  {\"ms\",        {HB_TAG('M','L','Y',' ')}},     \/* Malay [macrolanguage] *\/\n+  {\"msc\",       {HB_TAG('M','N','K',' ')}},     \/* Sankaran Maninka -> Maninka *\/\n+  {\"msh\",       {HB_TAG('M','L','G',' ')}},     \/* Masikoro Malagasy -> Malagasy *\/\n+  {\"msi\",       {HB_TAG('M','L','Y',' ')}},     \/* Sabah Malay -> Malay *\/\n+  {\"mt\",        {HB_TAG('M','T','S',' ')}},     \/* Maltese *\/\n+  {\"mtr\",       {HB_TAG('M','A','W',' ')}},     \/* Mewari -> Marwari *\/\n+  {\"mui\",       {HB_TAG('M','L','Y',' ')}},     \/* Musi -> Malay *\/\n+  {\"mup\",       {HB_TAG('R','A','J',' ')}},     \/* Malvi -> Rajasthani *\/\n+  {\"muq\",       {HB_TAG('H','M','N',' ')}},     \/* Eastern Xiangxi Miao -> Hmong *\/\n+  {\"mus\",       {HB_TAG('M','U','S',' ')}},     \/* Creek -> Muscogee *\/\n+  {\"mvb\",       {HB_TAG('A','T','H',' ')}},     \/* Mattole -> Athapaskan *\/\n+  {\"mve\",       {HB_TAG('M','A','W',' ')}},     \/* Marwari (Pakistan) *\/\n+  {\"mvf\",       {HB_TAG('M','N','G',' ')}},     \/* Peripheral Mongolian -> Mongolian *\/\n+  {\"mwk\",       {HB_TAG('M','N','K',' ')}},     \/* Kita Maninkakan -> Maninka *\/\n+  {\"mwl\",       {HB_TAG('M','W','L',' ')}},     \/* Mirandese *\/\n+  {\"mwr\",       {HB_TAG('M','A','W',' ')}},     \/* Marwari [macrolanguage] *\/\n+  {\"mww\",       {HB_TAG('M','W','W',' ')}},     \/* Hmong Daw *\/\n+  {\"my\",        {HB_TAG('B','R','M',' ')}},     \/* Burmese *\/\n+  {\"mym\",       {HB_TAG('M','E','N',' ')}},     \/* Me'en *\/\n+  {\"myn\",       {HB_TAG('M','Y','N',' ')}},     \/* Mayan [family] *\/\n+  {\"myq\",       {HB_TAG('M','N','K',' ')}},     \/* Forest Maninka (retired code) -> Maninka *\/\n+  {\"myv\",       {HB_TAG('E','R','Z',' ')}},     \/* Erzya *\/\n+  {\"mzn\",       {HB_TAG('M','Z','N',' ')}},     \/* Mazanderani *\/\n+  {\"na\",        {HB_TAG('N','A','U',' ')}},     \/* Nauru -> Nauruan *\/\n+  {\"nag\",       {HB_TAG('N','A','G',' ')}},     \/* Naga Pidgin -> Naga-Assamese *\/\n+  {\"nah\",       {HB_TAG('N','A','H',' ')}},     \/* Nahuatl [family] *\/\n+  {\"nan\",       {HB_TAG('Z','H','S',' ')}},     \/* Min Nan Chinese -> Chinese Simplified *\/\n+  {\"nap\",       {HB_TAG('N','A','P',' ')}},     \/* Neapolitan *\/\n+  {\"nb\",        {HB_TAG('N','O','R',' ')}},     \/* Norwegian Bokmål -> Norwegian *\/\n+  {\"nd\",        {HB_TAG('N','D','B',' ')}},     \/* North Ndebele -> Ndebele *\/\n+  {\"ndc\",       {HB_TAG('N','D','C',' ')}},     \/* Ndau *\/\n+  {\"nds\",       {HB_TAG('N','D','S',' ')}},     \/* Low Saxon *\/\n+  {\"ne\",        {HB_TAG('N','E','P',' ')}},     \/* Nepali [macrolanguage] *\/\n+  {\"new\",       {HB_TAG('N','E','W',' ')}},     \/* Newari *\/\n+  {\"ng\",        {HB_TAG('N','D','G',' ')}},     \/* Ndonga *\/\n+  {\"nga\",       {HB_TAG('N','G','A',' ')}},     \/* Ngbaka *\/\n+  {\"ngl\",       {HB_TAG('L','M','W',' ')}},     \/* Lomwe *\/\n+  {\"ngo\",       {HB_TAG('S','X','T',' ')}},     \/* Ngoni -> Sutu *\/\n+  {\"nhd\",       {HB_TAG('G','U','A',' ')}},     \/* Chiripá -> Guarani *\/\n+  {\"niq\",       {HB_TAG('K','A','L',' ')}},     \/* Nandi -> Kalenjin *\/\n+  {\"niu\",       {HB_TAG('N','I','U',' ')}},     \/* Niuean *\/\n+  {\"niv\",       {HB_TAG('G','I','L',' ')}},     \/* Gilyak *\/\n+  {\"njz\",       {HB_TAG('N','I','S',' ')}},     \/* Nyishi -> Nisi *\/\n+  {\"nl\",        {HB_TAG('N','L','D',' ')}},     \/* Dutch *\/\n+  {\"nle\",       {HB_TAG('L','U','H',' ')}},     \/* East Nyala -> Luyia *\/\n+  {\"nn\",        {HB_TAG('N','Y','N',' ')}},     \/* Norwegian Nynorsk (Nynorsk, Norwegian) *\/\n+  {\"no\",        {HB_TAG('N','O','R',' ')}},     \/* Norwegian [macrolanguage] *\/\n+  {\"nod\",       {HB_TAG('N','T','A',' ')}},     \/* Northern Thai -> Northern Tai *\/\n+  {\"noe\",       {HB_TAG('N','O','E',' ')}},     \/* Nimadi *\/\n+  {\"nog\",       {HB_TAG('N','O','G',' ')}},     \/* Nogai *\/\n+  {\"nov\",       {HB_TAG('N','O','V',' ')}},     \/* Novial *\/\n+  {\"npi\",       {HB_TAG('N','E','P',' ')}},     \/* Nepali *\/\n+  {\"nqo\",       {HB_TAG('N','K','O',' ')}},     \/* N'Ko *\/\n+  {\"nr\",        {HB_TAG('N','D','B',' ')}},     \/* South Ndebele -> Ndebele *\/\n+  {\"nsk\",       {HB_TAG('N','A','S',' ')}},     \/* Naskapi *\/\n+  {\"nso\",       {HB_TAG('N','S','O',' ')}},     \/* Pedi -> Sotho, Northern *\/\n+  {\"nv\",        {HB_TAG('N','A','V',' '),       \/* Navajo *\/\n+                 HB_TAG('A','T','H',' ')}},     \/* Navajo -> Athapaskan *\/\n+  {\"ny\",        {HB_TAG('C','H','I',' ')}},     \/* Chichewa (Chewa, Nyanja) *\/\n+  {\"nyd\",       {HB_TAG('L','U','H',' ')}},     \/* Nyore -> Luyia *\/\n+  {\"nym\",       {HB_TAG('N','Y','M',' ')}},     \/* Nyamwezi *\/\n+  {\"nyn\",       {HB_TAG('N','K','L',' ')}},     \/* Nyankole *\/\n+  {\"nza\",       {HB_TAG('N','Z','A',' ')}},     \/* Tigon Mbembe -> Mbembe Tigon *\/\n+  {\"oc\",        {HB_TAG('O','C','I',' ')}},     \/* Occitan (post 1500) *\/\n+  {\"oj\",        {HB_TAG('O','J','B',' ')}},     \/* Ojibwa [macrolanguage] -> Ojibway *\/\n+  {\"ojb\",       {HB_TAG('O','J','B',' ')}},     \/* Northwestern Ojibwa -> Ojibway *\/\n+  {\"ojc\",       {HB_TAG('O','J','B',' ')}},     \/* Central Ojibwa -> Ojibway *\/\n+  {\"ojg\",       {HB_TAG('O','J','B',' ')}},     \/* Eastern Ojibwa -> Ojibway *\/\n+  {\"ojs\",       {HB_TAG('O','C','R',' ')}},     \/* Severn Ojibwa -> Oji-Cree *\/\n+  {\"ojw\",       {HB_TAG('O','J','B',' ')}},     \/* Western Ojibwa -> Ojibway *\/\n+  {\"oki\",       {HB_TAG('K','A','L',' ')}},     \/* Okiek -> Kalenjin *\/\n+  {\"okm\",       {HB_TAG('K','O','H',' ')}},     \/* Middle Korean (10th-16th cent.) -> Korean Old Hangul *\/\n+  {\"om\",        {HB_TAG('O','R','O',' ')}},     \/* Oromo [macrolanguage] *\/\n+  {\"or\",        {HB_TAG('O','R','I',' ')}},     \/* Odia (formerly Oriya) [macrolanguage] *\/\n+  {\"orc\",       {HB_TAG('O','R','O',' ')}},     \/* Orma -> Oromo *\/\n+  {\"orn\",       {HB_TAG('M','L','Y',' ')}},     \/* Orang Kanaq -> Malay *\/\n+  {\"ors\",       {HB_TAG('M','L','Y',' ')}},     \/* Orang Seletar -> Malay *\/\n+  {\"ory\",       {HB_TAG('O','R','I',' ')}},     \/* Odia (formerly Oriya) *\/\n+  {\"os\",        {HB_TAG('O','S','S',' ')}},     \/* Ossetian *\/\n+  {\"otw\",       {HB_TAG('O','J','B',' ')}},     \/* Ottawa -> Ojibway *\/\n+  {\"pa\",        {HB_TAG('P','A','N',' ')}},     \/* Punjabi *\/\n+  {\"pag\",       {HB_TAG('P','A','G',' ')}},     \/* Pangasinan *\/\n+  {\"pam\",       {HB_TAG('P','A','M',' ')}},     \/* Pampanga -> Pampangan *\/\n+  {\"pap\",       {HB_TAG('P','A','P','0')}},     \/* Papiamento -> Papiamentu *\/\n+  {\"pau\",       {HB_TAG('P','A','U',' ')}},     \/* Palauan *\/\n+  {\"pbt\",       {HB_TAG('P','A','S',' ')}},     \/* Southern Pashto -> Pashto *\/\n+  {\"pbu\",       {HB_TAG('P','A','S',' ')}},     \/* Northern Pashto -> Pashto *\/\n+  {\"pcc\",       {HB_TAG('P','C','C',' ')}},     \/* Bouyei *\/\n+  {\"pcd\",       {HB_TAG('P','C','D',' ')}},     \/* Picard *\/\n+  {\"pce\",       {HB_TAG('P','L','G',' ')}},     \/* Ruching Palaung -> Palaung *\/\n+  {\"pck\",       {HB_TAG('Q','I','N',' ')}},     \/* Paite Chin -> Chin *\/\n+  {\"pdc\",       {HB_TAG('P','D','C',' ')}},     \/* Pennsylvania German *\/\n+  {\"pel\",       {HB_TAG('M','L','Y',' ')}},     \/* Pekal -> Malay *\/\n+  {\"pes\",       {HB_TAG('F','A','R',' ')}},     \/* Iranian Persian -> Persian *\/\n+  {\"pga\",       {HB_TAG('A','R','A',' ')}},     \/* Sudanese Creole Arabic -> Arabic *\/\n+  {\"phk\",       {HB_TAG('P','H','K',' ')}},     \/* Phake *\/\n+  {\"pi\",        {HB_TAG('P','A','L',' ')}},     \/* Pali *\/\n+  {\"pih\",       {HB_TAG('P','I','H',' ')}},     \/* Pitcairn-Norfolk -> Norfolk *\/\n+  {\"pko\",       {HB_TAG('K','A','L',' ')}},     \/* Pökoot -> Kalenjin *\/\n+  {\"pl\",        {HB_TAG('P','L','K',' ')}},     \/* Polish *\/\n+  {\"pll\",       {HB_TAG('P','L','G',' ')}},     \/* Shwe Palaung -> Palaung *\/\n+  {\"plp\",       {HB_TAG('P','A','P',' ')}},     \/* Palpa *\/\n+  {\"plt\",       {HB_TAG('M','L','G',' ')}},     \/* Plateau Malagasy -> Malagasy *\/\n+  {\"pms\",       {HB_TAG('P','M','S',' ')}},     \/* Piemontese *\/\n+  {\"pnb\",       {HB_TAG('P','N','B',' ')}},     \/* Western Panjabi *\/\n+  {\"poh\",       {HB_TAG('P','O','H',' ')}},     \/* Poqomchi' -> Pocomchi *\/\n+  {\"pon\",       {HB_TAG('P','O','N',' ')}},     \/* Pohnpeian *\/\n+  {\"ppa\",       {HB_TAG('B','A','G',' ')}},     \/* Pao (retired code) -> Baghelkhandi *\/\n+  {\"pro\",       {HB_TAG('P','R','O',' ')}},     \/* Old Provençal (to 1500) -> Provençal \/ Old Provençal *\/\n+  {\"prs\",       {HB_TAG('D','R','I',' ')}},     \/* Dari *\/\n+  {\"ps\",        {HB_TAG('P','A','S',' ')}},     \/* Pashto [macrolanguage] *\/\n+  {\"pse\",       {HB_TAG('M','L','Y',' ')}},     \/* Central Malay -> Malay *\/\n+  {\"pst\",       {HB_TAG('P','A','S',' ')}},     \/* Central Pashto -> Pashto *\/\n+  {\"pt\",        {HB_TAG('P','T','G',' ')}},     \/* Portuguese *\/\n+  {\"pwo\",       {HB_TAG('P','W','O',' ')}},     \/* Pwo Western Karen -> Western Pwo Karen *\/\n+  {\"qu\",        {HB_TAG('Q','U','Z',' ')}},     \/* Quechua [macrolanguage] *\/\n+  {\"qub\",       {HB_TAG('Q','W','H',' ')}},     \/* Huallaga Huánuco Quechua -> Quechua (Peru) *\/\n+  {\"quc\",       {HB_TAG('Q','U','C',' ')}},     \/* K’iche’ *\/\n+  {\"qud\",       {HB_TAG('Q','V','I',' ')}},     \/* Calderón Highland Quichua -> Quechua (Ecuador) *\/\n+  {\"quf\",       {HB_TAG('Q','U','Z',' ')}},     \/* Lambayeque Quechua -> Quechua *\/\n+  {\"qug\",       {HB_TAG('Q','V','I',' ')}},     \/* Chimborazo Highland Quichua -> Quechua (Ecuador) *\/\n+  {\"quh\",       {HB_TAG('Q','U','H',' ')}},     \/* South Bolivian Quechua -> Quechua (Bolivia) *\/\n+  {\"quk\",       {HB_TAG('Q','U','Z',' ')}},     \/* Chachapoyas Quechua -> Quechua *\/\n+  {\"qul\",       {HB_TAG('Q','U','Z',' ')}},     \/* North Bolivian Quechua -> Quechua *\/\n+  {\"qup\",       {HB_TAG('Q','V','I',' ')}},     \/* Southern Pastaza Quechua -> Quechua (Ecuador) *\/\n+  {\"qur\",       {HB_TAG('Q','W','H',' ')}},     \/* Yanahuanca Pasco Quechua -> Quechua (Peru) *\/\n+  {\"qus\",       {HB_TAG('Q','U','H',' ')}},     \/* Santiago del Estero Quichua -> Quechua (Bolivia) *\/\n+  {\"quw\",       {HB_TAG('Q','V','I',' ')}},     \/* Tena Lowland Quichua -> Quechua (Ecuador) *\/\n+  {\"qux\",       {HB_TAG('Q','W','H',' ')}},     \/* Yauyos Quechua -> Quechua (Peru) *\/\n+  {\"quy\",       {HB_TAG('Q','U','Z',' ')}},     \/* Ayacucho Quechua -> Quechua *\/\n+  {\"quz\",       {HB_TAG('Q','U','Z',' ')}},     \/* Cusco Quechua -> Quechua *\/\n+  {\"qva\",       {HB_TAG('Q','W','H',' ')}},     \/* Ambo-Pasco Quechua -> Quechua (Peru) *\/\n+  {\"qvc\",       {HB_TAG('Q','U','Z',' ')}},     \/* Cajamarca Quechua -> Quechua *\/\n+  {\"qve\",       {HB_TAG('Q','U','Z',' ')}},     \/* Eastern Apurímac Quechua -> Quechua *\/\n+  {\"qvh\",       {HB_TAG('Q','W','H',' ')}},     \/* Huamalíes-Dos de Mayo Huánuco Quechua -> Quechua (Peru) *\/\n+  {\"qvi\",       {HB_TAG('Q','V','I',' ')}},     \/* Imbabura Highland Quichua -> Quechua (Ecuador) *\/\n+  {\"qvj\",       {HB_TAG('Q','V','I',' ')}},     \/* Loja Highland Quichua -> Quechua (Ecuador) *\/\n+  {\"qvl\",       {HB_TAG('Q','W','H',' ')}},     \/* Cajatambo North Lima Quechua -> Quechua (Peru) *\/\n+  {\"qvm\",       {HB_TAG('Q','W','H',' ')}},     \/* Margos-Yarowilca-Lauricocha Quechua -> Quechua (Peru) *\/\n+  {\"qvn\",       {HB_TAG('Q','W','H',' ')}},     \/* North Junín Quechua -> Quechua (Peru) *\/\n+  {\"qvo\",       {HB_TAG('Q','V','I',' ')}},     \/* Napo Lowland Quechua -> Quechua (Ecuador) *\/\n+  {\"qvp\",       {HB_TAG('Q','W','H',' ')}},     \/* Pacaraos Quechua -> Quechua (Peru) *\/\n+  {\"qvs\",       {HB_TAG('Q','U','Z',' ')}},     \/* San Martín Quechua -> Quechua *\/\n+  {\"qvw\",       {HB_TAG('Q','W','H',' ')}},     \/* Huaylla Wanca Quechua -> Quechua (Peru) *\/\n+  {\"qvz\",       {HB_TAG('Q','V','I',' ')}},     \/* Northern Pastaza Quichua -> Quechua (Ecuador) *\/\n+  {\"qwa\",       {HB_TAG('Q','W','H',' ')}},     \/* Corongo Ancash Quechua -> Quechua (Peru) *\/\n+  {\"qwc\",       {HB_TAG('Q','U','Z',' ')}},     \/* Classical Quechua -> Quechua *\/\n+  {\"qwh\",       {HB_TAG('Q','W','H',' ')}},     \/* Huaylas Ancash Quechua -> Quechua (Peru) *\/\n+  {\"qws\",       {HB_TAG('Q','W','H',' ')}},     \/* Sihuas Ancash Quechua -> Quechua (Peru) *\/\n+  {\"qxa\",       {HB_TAG('Q','W','H',' ')}},     \/* Chiquián Ancash Quechua -> Quechua (Peru) *\/\n+  {\"qxc\",       {HB_TAG('Q','W','H',' ')}},     \/* Chincha Quechua -> Quechua (Peru) *\/\n+  {\"qxh\",       {HB_TAG('Q','W','H',' ')}},     \/* Panao Huánuco Quechua -> Quechua (Peru) *\/\n+  {\"qxl\",       {HB_TAG('Q','V','I',' ')}},     \/* Salasaca Highland Quichua -> Quechua (Ecuador) *\/\n+  {\"qxn\",       {HB_TAG('Q','W','H',' ')}},     \/* Northern Conchucos Ancash Quechua -> Quechua (Peru) *\/\n+  {\"qxo\",       {HB_TAG('Q','W','H',' ')}},     \/* Southern Conchucos Ancash Quechua -> Quechua (Peru) *\/\n+  {\"qxp\",       {HB_TAG('Q','U','Z',' ')}},     \/* Puno Quechua -> Quechua *\/\n+  {\"qxr\",       {HB_TAG('Q','V','I',' ')}},     \/* Cañar Highland Quichua -> Quechua (Ecuador) *\/\n+  {\"qxt\",       {HB_TAG('Q','W','H',' ')}},     \/* Santa Ana de Tusi Pasco Quechua -> Quechua (Peru) *\/\n+  {\"qxu\",       {HB_TAG('Q','U','Z',' ')}},     \/* Arequipa-La Unión Quechua -> Quechua *\/\n+  {\"qxw\",       {HB_TAG('Q','W','H',' ')}},     \/* Jauja Wanca Quechua -> Quechua (Peru) *\/\n+  {\"rag\",       {HB_TAG('L','U','H',' ')}},     \/* Logooli -> Luyia *\/\n+  {\"raj\",       {HB_TAG('R','A','J',' ')}},     \/* Rajasthani [macrolanguage] *\/\n+  {\"rar\",       {HB_TAG('R','A','R',' ')}},     \/* Rarotongan *\/\n+  {\"rbb\",       {HB_TAG('P','L','G',' ')}},     \/* Rumai Palaung -> Palaung *\/\n+  {\"rbl\",       {HB_TAG('B','I','K',' ')}},     \/* Miraya Bikol -> Bikol *\/\n+  {\"rej\",       {HB_TAG('R','E','J',' ')}},     \/* Rejang *\/\n+  {\"ria\",       {HB_TAG('R','I','A',' ')}},     \/* Riang (India) *\/\n+  {\"rif\",       {HB_TAG('R','I','F',' ')}},     \/* Tarifit *\/\n+  {\"rit\",       {HB_TAG('R','I','T',' ')}},     \/* Ritarungo *\/\n+  {\"rki\",       {HB_TAG('A','R','K',' ')}},     \/* Rakhine *\/\n+  {\"rkw\",       {HB_TAG('R','K','W',' ')}},     \/* Arakwal *\/\n+  {\"rm\",        {HB_TAG('R','M','S',' ')}},     \/* Romansh *\/\n+  {\"rmc\",       {HB_TAG('R','O','Y',' ')}},     \/* Carpathian Romani -> Romany *\/\n+  {\"rmf\",       {HB_TAG('R','O','Y',' ')}},     \/* Kalo Finnish Romani -> Romany *\/\n+  {\"rml\",       {HB_TAG('R','O','Y',' ')}},     \/* Baltic Romani -> Romany *\/\n+  {\"rmn\",       {HB_TAG('R','O','Y',' ')}},     \/* Balkan Romani -> Romany *\/\n+  {\"rmo\",       {HB_TAG('R','O','Y',' ')}},     \/* Sinte Romani -> Romany *\/\n+  {\"rmw\",       {HB_TAG('R','O','Y',' ')}},     \/* Welsh Romani -> Romany *\/\n+  {\"rmy\",       {HB_TAG('R','M','Y',' ')}},     \/* Vlax Romani *\/\n+  {\"rmz\",       {HB_TAG('A','R','K',' ')}},     \/* Marma -> Rakhine *\/\n+  {\"rn\",        {HB_TAG('R','U','N',' ')}},     \/* Rundi *\/\n+  {\"rnl\",       {HB_TAG('H','A','L',' ')}},     \/* Ranglong -> Halam (Falam Chin) *\/\n+  {\"ro\",        {HB_TAG('R','O','M',' ')}},     \/* Romanian *\/\n+  {\"rom\",       {HB_TAG('R','O','Y',' ')}},     \/* Romany [macrolanguage] *\/\n+  {\"rtm\",       {HB_TAG('R','T','M',' ')}},     \/* Rotuman *\/\n+  {\"ru\",        {HB_TAG('R','U','S',' ')}},     \/* Russian *\/\n+  {\"rue\",       {HB_TAG('R','S','Y',' ')}},     \/* Rusyn *\/\n+  {\"rup\",       {HB_TAG('R','U','P',' ')}},     \/* Aromanian *\/\n+  {\"rw\",        {HB_TAG('R','U','A',' ')}},     \/* Kinyarwanda *\/\n+  {\"rwr\",       {HB_TAG('M','A','W',' ')}},     \/* Marwari (India) *\/\n+  {\"sa\",        {HB_TAG('S','A','N',' ')}},     \/* Sanskrit *\/\n+  {\"sah\",       {HB_TAG('Y','A','K',' ')}},     \/* Yakut -> Sakha *\/\n+  {\"sam\",       {HB_TAG('P','A','A',' ')}},     \/* Samaritan Aramaic -> Palestinian Aramaic *\/\n+  {\"sas\",       {HB_TAG('S','A','S',' ')}},     \/* Sasak *\/\n+  {\"sat\",       {HB_TAG('S','A','T',' ')}},     \/* Santali *\/\n+  {\"sc\",        {HB_TAG('S','R','D',' ')}},     \/* Sardinian [macrolanguage] *\/\n+  {\"sck\",       {HB_TAG('S','A','D',' ')}},     \/* Sadri *\/\n+  {\"scn\",       {HB_TAG('S','C','N',' ')}},     \/* Sicilian *\/\n+  {\"sco\",       {HB_TAG('S','C','O',' ')}},     \/* Scots *\/\n+  {\"scs\",       {HB_TAG('S','C','S',' '),       \/* North Slavey *\/\n+                 HB_TAG('S','L','A',' '),       \/* North Slavey -> Slavey *\/\n+                 HB_TAG('A','T','H',' ')}},     \/* North Slavey -> Athapaskan *\/\n+  {\"sd\",        {HB_TAG('S','N','D',' ')}},     \/* Sindhi *\/\n+  {\"sdc\",       {HB_TAG('S','R','D',' ')}},     \/* Sassarese Sardinian -> Sardinian *\/\n+  {\"sdh\",       {HB_TAG('K','U','R',' ')}},     \/* Southern Kurdish -> Kurdish *\/\n+  {\"sdn\",       {HB_TAG('S','R','D',' ')}},     \/* Gallurese Sardinian -> Sardinian *\/\n+  {\"se\",        {HB_TAG('N','S','M',' ')}},     \/* Northern Sami *\/\n+  {\"seh\",       {HB_TAG('S','N','A',' ')}},     \/* Sena *\/\n+  {\"sek\",       {HB_TAG('A','T','H',' ')}},     \/* Sekani -> Athapaskan *\/\n+  {\"sel\",       {HB_TAG('S','E','L',' ')}},     \/* Selkup *\/\n+  {\"sez\",       {HB_TAG('Q','I','N',' ')}},     \/* Senthang Chin -> Chin *\/\n+  {\"sfm\",       {HB_TAG('H','M','N',' ')}},     \/* Small Flowery Miao -> Hmong *\/\n+  {\"sg\",        {HB_TAG('S','G','O',' ')}},     \/* Sango *\/\n+  {\"sga\",       {HB_TAG('S','G','A',' ')}},     \/* Old Irish (to 900) *\/\n+  {\"sgc\",       {HB_TAG('K','A','L',' ')}},     \/* Kipsigis -> Kalenjin *\/\n+  {\"sgs\",       {HB_TAG('S','G','S',' ')}},     \/* Samogitian *\/\n+  {\"sgw\",       {HB_TAG('C','H','G',' '),       \/* Sebat Bet Gurage -> Chaha Gurage *\/\n+                 HB_TAG('S','G','W',' ')}},     \/* Sebat Bet Gurage -> Chaha Gurage (SIL fonts) *\/\n+  {\"shi\",       {HB_TAG('S','H','I',' ')}},     \/* Tachelhit *\/\n+  {\"shn\",       {HB_TAG('S','H','N',' ')}},     \/* Shan *\/\n+  {\"shu\",       {HB_TAG('A','R','A',' ')}},     \/* Chadian Arabic -> Arabic *\/\n+  {\"si\",        {HB_TAG('S','N','H',' ')}},     \/* Sinhala (Sinhalese) *\/\n+  {\"sid\",       {HB_TAG('S','I','D',' ')}},     \/* Sidamo *\/\n+  {\"sjd\",       {HB_TAG('K','S','M',' ')}},     \/* Kildin Sami *\/\n+  {\"sjo\",       {HB_TAG('S','I','B',' ')}},     \/* Xibe -> Sibe *\/\n+  {\"sk\",        {HB_TAG('S','K','Y',' ')}},     \/* Slovak *\/\n+  {\"skg\",       {HB_TAG('M','L','G',' ')}},     \/* Sakalava Malagasy -> Malagasy *\/\n+  {\"skr\",       {HB_TAG('S','R','K',' ')}},     \/* Saraiki *\/\n+  {\"sl\",        {HB_TAG('S','L','V',' ')}},     \/* Slovenian *\/\n+  {\"sm\",        {HB_TAG('S','M','O',' ')}},     \/* Samoan *\/\n+  {\"sma\",       {HB_TAG('S','S','M',' ')}},     \/* Southern Sami *\/\n+  {\"smj\",       {HB_TAG('L','S','M',' ')}},     \/* Lule Sami *\/\n+  {\"smn\",       {HB_TAG('I','S','M',' ')}},     \/* Inari Sami *\/\n+  {\"sms\",       {HB_TAG('S','K','S',' ')}},     \/* Skolt Sami *\/\n+  {\"sn\",        {HB_TAG('S','N','A','0')}},     \/* Shona *\/\n+  {\"snk\",       {HB_TAG('S','N','K',' ')}},     \/* Soninke *\/\n+  {\"so\",        {HB_TAG('S','M','L',' ')}},     \/* Somali *\/\n+  {\"sop\",       {HB_TAG('S','O','P',' ')}},     \/* Songe *\/\n+  {\"spv\",       {HB_TAG('O','R','I',' ')}},     \/* Sambalpuri -> Odia (formerly Oriya) *\/\n+  {\"spy\",       {HB_TAG('K','A','L',' ')}},     \/* Sabaot -> Kalenjin *\/\n+  {\"sq\",        {HB_TAG('S','Q','I',' ')}},     \/* Albanian [macrolanguage] *\/\n+  {\"sr\",        {HB_TAG('S','R','B',' ')}},     \/* Serbian *\/\n+  {\"src\",       {HB_TAG('S','R','D',' ')}},     \/* Logudorese Sardinian -> Sardinian *\/\n+  {\"sro\",       {HB_TAG('S','R','D',' ')}},     \/* Campidanese Sardinian -> Sardinian *\/\n+  {\"srr\",       {HB_TAG('S','R','R',' ')}},     \/* Serer *\/\n+  {\"srs\",       {HB_TAG('A','T','H',' ')}},     \/* Sarsi -> Athapaskan *\/\n+  {\"ss\",        {HB_TAG('S','W','Z',' ')}},     \/* Swati *\/\n+  {\"ssh\",       {HB_TAG('A','R','A',' ')}},     \/* Shihhi Arabic -> Arabic *\/\n+  {\"st\",        {HB_TAG('S','O','T',' ')}},     \/* Southern Sotho -> Sotho, Southern *\/\n+  {\"stq\",       {HB_TAG('S','T','Q',' ')}},     \/* Saterfriesisch -> Saterland Frisian *\/\n+  {\"stv\",       {HB_TAG('S','I','G',' ')}},     \/* Silt'e -> Silte Gurage *\/\n+  {\"su\",        {HB_TAG('S','U','N',' ')}},     \/* Sundanese *\/\n+  {\"suk\",       {HB_TAG('S','U','K',' ')}},     \/* Sukuma *\/\n+  {\"suq\",       {HB_TAG('S','U','R',' ')}},     \/* Suri *\/\n+  {\"sv\",        {HB_TAG('S','V','E',' ')}},     \/* Swedish *\/\n+  {\"sva\",       {HB_TAG('S','V','A',' ')}},     \/* Svan *\/\n+  {\"sw\",        {HB_TAG('S','W','K',' ')}},     \/* Swahili [macrolanguage] *\/\n+  {\"swb\",       {HB_TAG('C','M','R',' ')}},     \/* Maore Comorian -> Comorian *\/\n+  {\"swc\",       {HB_TAG('S','W','K',' ')}},     \/* Congo Swahili -> Swahili *\/\n+  {\"swh\",       {HB_TAG('S','W','K',' ')}},     \/* Swahili *\/\n+  {\"swv\",       {HB_TAG('M','A','W',' ')}},     \/* Shekhawati -> Marwari *\/\n+  {\"sxu\",       {HB_TAG('S','X','U',' ')}},     \/* Upper Saxon *\/\n+  {\"syc\",       {HB_TAG('S','Y','R',' ')}},     \/* Classical Syriac -> Syriac *\/\n+  {\"syl\",       {HB_TAG('S','Y','L',' ')}},     \/* Sylheti *\/\n+  {\"syr\",       {HB_TAG('S','Y','R',' ')}},     \/* Syriac [macrolanguage] *\/\n+  {\"szl\",       {HB_TAG('S','Z','L',' ')}},     \/* Silesian *\/\n+  {\"ta\",        {HB_TAG('T','A','M',' ')}},     \/* Tamil *\/\n+  {\"taa\",       {HB_TAG('A','T','H',' ')}},     \/* Lower Tanana -> Athapaskan *\/\n+  {\"tab\",       {HB_TAG('T','A','B',' ')}},     \/* Tabassaran -> Tabasaran *\/\n+  {\"taq\",       {HB_TAG('T','M','H',' ')}},     \/* Tamasheq -> Tamashek *\/\n+  {\"tau\",       {HB_TAG('A','T','H',' ')}},     \/* Upper Tanana -> Athapaskan *\/\n+  {\"tcb\",       {HB_TAG('A','T','H',' ')}},     \/* Tanacross -> Athapaskan *\/\n+  {\"tce\",       {HB_TAG('A','T','H',' ')}},     \/* Southern Tutchone -> Athapaskan *\/\n+  {\"tcp\",       {HB_TAG('Q','I','N',' ')}},     \/* Tawr Chin -> Chin *\/\n+  {\"tcy\",       {HB_TAG('T','U','L',' ')}},     \/* Tulu -> Tumbuka *\/\n+  {\"tcz\",       {HB_TAG('Q','I','N',' ')}},     \/* Thado Chin -> Chin *\/\n+  {\"tdd\",       {HB_TAG('T','D','D',' ')}},     \/* Tai Nüa -> Dehong Dai *\/\n+  {\"tdx\",       {HB_TAG('M','L','G',' ')}},     \/* Tandroy-Mahafaly Malagasy -> Malagasy *\/\n+  {\"te\",        {HB_TAG('T','E','L',' ')}},     \/* Telugu *\/\n+  {\"tec\",       {HB_TAG('K','A','L',' ')}},     \/* Terik -> Kalenjin *\/\n+  {\"tem\",       {HB_TAG('T','M','N',' ')}},     \/* Timne -> Temne *\/\n+  {\"tet\",       {HB_TAG('T','E','T',' ')}},     \/* Tetum *\/\n+  {\"tfn\",       {HB_TAG('A','T','H',' ')}},     \/* Tanaina -> Athapaskan *\/\n+  {\"tg\",        {HB_TAG('T','A','J',' ')}},     \/* Tajik -> Tajiki *\/\n+  {\"tgj\",       {HB_TAG('N','I','S',' ')}},     \/* Tagin -> Nisi *\/\n+  {\"tgx\",       {HB_TAG('A','T','H',' ')}},     \/* Tagish -> Athapaskan *\/\n+  {\"th\",        {HB_TAG('T','H','A',' ')}},     \/* Thai *\/\n+  {\"tht\",       {HB_TAG('A','T','H',' ')}},     \/* Tahltan -> Athapaskan *\/\n+  {\"thv\",       {HB_TAG('T','M','H',' ')}},     \/* Tahaggart Tamahaq -> Tamashek *\/\n+  {\"thz\",       {HB_TAG('T','M','H',' ')}},     \/* Tayart Tamajeq -> Tamashek *\/\n+  {\"ti\",        {HB_TAG('T','G','Y',' ')}},     \/* Tigrinya *\/\n+  {\"tig\",       {HB_TAG('T','G','R',' ')}},     \/* Tigre *\/\n+  {\"tiv\",       {HB_TAG('T','I','V',' ')}},     \/* Tiv *\/\n+  {\"tk\",        {HB_TAG('T','K','M',' ')}},     \/* Turkmen *\/\n+  {\"tkg\",       {HB_TAG('M','L','G',' ')}},     \/* Tesaka Malagasy -> Malagasy *\/\n+  {\"tl\",        {HB_TAG('T','G','L',' ')}},     \/* Tagalog *\/\n+  {\"tmh\",       {HB_TAG('T','M','H',' ')}},     \/* Tamashek [macrolanguage] *\/\n+  {\"tmw\",       {HB_TAG('M','L','Y',' ')}},     \/* Temuan -> Malay *\/\n+  {\"tn\",        {HB_TAG('T','N','A',' ')}},     \/* Tswana *\/\n+  {\"tnf\",       {HB_TAG('D','R','I',' ')}},     \/* Tangshewi (retired code) -> Dari *\/\n+  {\"to\",        {HB_TAG('T','G','N',' ')}},     \/* Tonga (Tonga Islands) -> Tongan *\/\n+  {\"tod\",       {HB_TAG('T','O','D','0')}},     \/* Toma *\/\n+  {\"toi\",       {HB_TAG('T','N','G',' ')}},     \/* Tonga (Zambia) *\/\n+  {\"tol\",       {HB_TAG('A','T','H',' ')}},     \/* Tolowa -> Athapaskan *\/\n+  {\"tpi\",       {HB_TAG('T','P','I',' ')}},     \/* Tok Pisin *\/\n+  {\"tr\",        {HB_TAG('T','R','K',' ')}},     \/* Turkish *\/\n+  {\"tru\",       {HB_TAG('T','U','A',' '),       \/* Turoyo -> Turoyo Aramaic *\/\n+                 HB_TAG('S','Y','R',' ')}},     \/* Turoyo -> Syriac *\/\n+  {\"ts\",        {HB_TAG('T','S','G',' ')}},     \/* Tsonga *\/\n+  {\"tsj\",       {HB_TAG('T','S','J',' ')}},     \/* Tshangla *\/\n+  {\"tt\",        {HB_TAG('T','A','T',' ')}},     \/* Tatar *\/\n+  {\"ttm\",       {HB_TAG('A','T','H',' ')}},     \/* Northern Tutchone -> Athapaskan *\/\n+  {\"ttq\",       {HB_TAG('T','M','H',' ')}},     \/* Tawallammat Tamajaq -> Tamashek *\/\n+  {\"tum\",       {HB_TAG('T','U','M',' ')}},     \/* Tumbuka -> Tulu *\/\n+  {\"tuu\",       {HB_TAG('A','T','H',' ')}},     \/* Tututni -> Athapaskan *\/\n+  {\"tuy\",       {HB_TAG('K','A','L',' ')}},     \/* Tugen -> Kalenjin *\/\n+  {\"tvl\",       {HB_TAG('T','V','L',' ')}},     \/* Tuvalu *\/\n+  {\"tw\",        {HB_TAG('T','W','I',' '),       \/* Twi *\/\n+                 HB_TAG('A','K','A',' ')}},     \/* Twi -> Akan *\/\n+  {\"txc\",       {HB_TAG('A','T','H',' ')}},     \/* Tsetsaut -> Athapaskan *\/\n+  {\"txy\",       {HB_TAG('M','L','G',' ')}},     \/* Tanosy Malagasy -> Malagasy *\/\n+  {\"ty\",        {HB_TAG('T','H','T',' ')}},     \/* Tahitian *\/\n+  {\"tyv\",       {HB_TAG('T','U','V',' ')}},     \/* Tuvinian -> Tuvin *\/\n+  {\"tyz\",       {HB_TAG('T','Y','Z',' ')}},     \/* Tày *\/\n+  {\"tzm\",       {HB_TAG('T','Z','M',' ')}},     \/* Central Atlas Tamazight -> Tamazight *\/\n+  {\"tzo\",       {HB_TAG('T','Z','O',' ')}},     \/* Tzotzil *\/\n+  {\"ubl\",       {HB_TAG('B','I','K',' ')}},     \/* Buhi'non Bikol -> Bikol *\/\n+  {\"udm\",       {HB_TAG('U','D','M',' ')}},     \/* Udmurt *\/\n+  {\"ug\",        {HB_TAG('U','Y','G',' ')}},     \/* Uyghur *\/\n+  {\"uk\",        {HB_TAG('U','K','R',' ')}},     \/* Ukrainian *\/\n+  {\"umb\",       {HB_TAG('U','M','B',' ')}},     \/* Umbundu *\/\n+  {\"unr\",       {HB_TAG('M','U','N',' ')}},     \/* Mundari *\/\n+  {\"ur\",        {HB_TAG('U','R','D',' ')}},     \/* Urdu *\/\n+  {\"urk\",       {HB_TAG('M','L','Y',' ')}},     \/* Urak Lawoi' -> Malay *\/\n+  {\"uz\",        {HB_TAG('U','Z','B',' ')}},     \/* Uzbek [macrolanguage] *\/\n+  {\"uzn\",       {HB_TAG('U','Z','B',' ')}},     \/* Northern Uzbek -> Uzbek *\/\n+  {\"uzs\",       {HB_TAG('U','Z','B',' ')}},     \/* Southern Uzbek -> Uzbek *\/\n+  {\"ve\",        {HB_TAG('V','E','N',' ')}},     \/* Venda *\/\n+  {\"vec\",       {HB_TAG('V','E','C',' ')}},     \/* Venetian *\/\n+  {\"vi\",        {HB_TAG('V','I','T',' ')}},     \/* Vietnamese *\/\n+  {\"vkk\",       {HB_TAG('M','L','Y',' ')}},     \/* Kaur -> Malay *\/\n+  {\"vkt\",       {HB_TAG('M','L','Y',' ')}},     \/* Tenggarong Kutai Malay -> Malay *\/\n+  {\"vls\",       {HB_TAG('F','L','E',' ')}},     \/* Vlaams -> Dutch (Flemish) *\/\n+  {\"vmw\",       {HB_TAG('M','A','K',' ')}},     \/* Makhuwa *\/\n+  {\"vo\",        {HB_TAG('V','O','L',' ')}},     \/* Volapük *\/\n+  {\"vro\",       {HB_TAG('V','R','O',' ')}},     \/* Võro *\/\n+  {\"wa\",        {HB_TAG('W','L','N',' ')}},     \/* Walloon *\/\n+  {\"war\",       {HB_TAG('W','A','R',' ')}},     \/* Waray (Philippines) -> Waray-Waray *\/\n+  {\"wbm\",       {HB_TAG('W','A',' ',' ')}},     \/* Wa *\/\n+  {\"wbr\",       {HB_TAG('W','A','G',' ')}},     \/* Wagdi *\/\n+  {\"wlc\",       {HB_TAG('C','M','R',' ')}},     \/* Mwali Comorian -> Comorian *\/\n+  {\"wle\",       {HB_TAG('S','I','G',' ')}},     \/* Wolane -> Silte Gurage *\/\n+  {\"wlk\",       {HB_TAG('A','T','H',' ')}},     \/* Wailaki -> Athapaskan *\/\n+  {\"wni\",       {HB_TAG('C','M','R',' ')}},     \/* Ndzwani Comorian -> Comorian *\/\n+  {\"wo\",        {HB_TAG('W','L','F',' ')}},     \/* Wolof *\/\n+  {\"wry\",       {HB_TAG('M','A','W',' ')}},     \/* Merwari -> Marwari *\/\n+  {\"wsg\",       {HB_TAG('G','O','N',' ')}},     \/* Adilabad Gondi -> Gondi *\/\n+  {\"wtm\",       {HB_TAG('W','T','M',' ')}},     \/* Mewati *\/\n+  {\"wuu\",       {HB_TAG('Z','H','S',' ')}},     \/* Wu Chinese -> Chinese Simplified *\/\n+  {\"xal\",       {HB_TAG('K','L','M',' '),       \/* Kalmyk *\/\n+                 HB_TAG('T','O','D',' ')}},     \/* Kalmyk -> Todo *\/\n+  {\"xan\",       {HB_TAG('S','E','K',' ')}},     \/* Xamtanga -> Sekota *\/\n+  {\"xh\",        {HB_TAG('X','H','S',' ')}},     \/* Xhosa *\/\n+  {\"xjb\",       {HB_TAG('X','J','B',' ')}},     \/* Minjungbal -> Minjangbal *\/\n+  {\"xkf\",       {HB_TAG('X','K','F',' ')}},     \/* Khengkha *\/\n+  {\"xmm\",       {HB_TAG('M','L','Y',' ')}},     \/* Manado Malay -> Malay *\/\n+  {\"xmv\",       {HB_TAG('M','L','G',' ')}},     \/* Antankarana Malagasy -> Malagasy *\/\n+  {\"xmw\",       {HB_TAG('M','L','G',' ')}},     \/* Tsimihety Malagasy -> Malagasy *\/\n+  {\"xnr\",       {HB_TAG('D','G','R',' ')}},     \/* Kangri -> Dogri *\/\n+  {\"xog\",       {HB_TAG('X','O','G',' ')}},     \/* Soga *\/\n+  {\"xpe\",       {HB_TAG('X','P','E',' ')}},     \/* Liberia Kpelle -> Kpelle (Liberia) *\/\n+  {\"xsl\",       {HB_TAG('S','S','L',' '),       \/* South Slavey *\/\n+                 HB_TAG('S','L','A',' '),       \/* South Slavey -> Slavey *\/\n+                 HB_TAG('A','T','H',' ')}},     \/* South Slavey -> Athapaskan *\/\n+  {\"xst\",       {HB_TAG('S','I','G',' ')}},     \/* Silt'e (retired code) -> Silte Gurage *\/\n+  {\"xwo\",       {HB_TAG('T','O','D',' ')}},     \/* Written Oirat -> Todo *\/\n+  {\"yao\",       {HB_TAG('Y','A','O',' ')}},     \/* Yao *\/\n+  {\"yap\",       {HB_TAG('Y','A','P',' ')}},     \/* Yapese *\/\n+  {\"ybd\",       {HB_TAG('A','R','K',' ')}},     \/* Yangbye (retired code) -> Rakhine *\/\n+  {\"ydd\",       {HB_TAG('J','I','I',' ')}},     \/* Eastern Yiddish -> Yiddish *\/\n+  {\"yi\",        {HB_TAG('J','I','I',' ')}},     \/* Yiddish [macrolanguage] *\/\n+  {\"yih\",       {HB_TAG('J','I','I',' ')}},     \/* Western Yiddish -> Yiddish *\/\n+  {\"yo\",        {HB_TAG('Y','B','A',' ')}},     \/* Yoruba *\/\n+  {\"yos\",       {HB_TAG('Q','I','N',' ')}},     \/* Yos (retired code) -> Chin *\/\n+  {\"yrk\",       {HB_TAG('T','N','E',' '),       \/* Nenets -> Tundra Nenets *\/\n+                 HB_TAG('F','N','E',' ')}},     \/* Nenets -> Forest Nenets *\/\n+  {\"yue\",       {HB_TAG('Z','H','H',' ')}},     \/* Yue Chinese -> Chinese, Hong Kong SAR *\/\n+  {\"za\",        {HB_TAG('Z','H','A',' ')}},     \/* Zhuang [macrolanguage] *\/\n+  {\"zch\",       {HB_TAG('Z','H','A',' ')}},     \/* Central Hongshuihe Zhuang -> Zhuang *\/\n+  {\"zdj\",       {HB_TAG('C','M','R',' ')}},     \/* Ngazidja Comorian -> Comorian *\/\n+  {\"zea\",       {HB_TAG('Z','E','A',' ')}},     \/* Zeeuws -> Zealandic *\/\n+  {\"zeh\",       {HB_TAG('Z','H','A',' ')}},     \/* Eastern Hongshuihe Zhuang -> Zhuang *\/\n+  {\"zgb\",       {HB_TAG('Z','H','A',' ')}},     \/* Guibei Zhuang -> Zhuang *\/\n+  {\"zgh\",       {HB_TAG('Z','G','H',' ')}},     \/* Standard Moroccan Tamazight *\/\n+  {\"zgm\",       {HB_TAG('Z','H','A',' ')}},     \/* Minz Zhuang -> Zhuang *\/\n+  {\"zgn\",       {HB_TAG('Z','H','A',' ')}},     \/* Guibian Zhuang -> Zhuang *\/\n+  {\"zh\",        {HB_TAG('Z','H','S',' ')}},     \/* Chinese [macrolanguage] -> Chinese Simplified *\/\n+  {\"zhd\",       {HB_TAG('Z','H','A',' ')}},     \/* Dai Zhuang -> Zhuang *\/\n+  {\"zhn\",       {HB_TAG('Z','H','A',' ')}},     \/* Nong Zhuang -> Zhuang *\/\n+  {\"zlj\",       {HB_TAG('Z','H','A',' ')}},     \/* Liujiang Zhuang -> Zhuang *\/\n+  {\"zlm\",       {HB_TAG('M','L','Y',' ')}},     \/* Malay *\/\n+  {\"zln\",       {HB_TAG('Z','H','A',' ')}},     \/* Lianshan Zhuang -> Zhuang *\/\n+  {\"zlq\",       {HB_TAG('Z','H','A',' ')}},     \/* Liuqian Zhuang -> Zhuang *\/\n+  {\"zmi\",       {HB_TAG('M','L','Y',' ')}},     \/* Negeri Sembilan Malay -> Malay *\/\n+  {\"zne\",       {HB_TAG('Z','N','D',' ')}},     \/* Zande *\/\n+  {\"zom\",       {HB_TAG('Q','I','N',' ')}},     \/* Zou -> Chin *\/\n+  {\"zqe\",       {HB_TAG('Z','H','A',' ')}},     \/* Qiubei Zhuang -> Zhuang *\/\n+  {\"zsm\",       {HB_TAG('M','L','Y',' ')}},     \/* Standard Malay -> Malay *\/\n+  {\"zu\",        {HB_TAG('Z','U','L',' ')}},     \/* Zulu *\/\n+  {\"zum\",       {HB_TAG('L','R','C',' ')}},     \/* Kumzari -> Luri *\/\n+  {\"zyb\",       {HB_TAG('Z','H','A',' ')}},     \/* Yongbei Zhuang -> Zhuang *\/\n+  {\"zyg\",       {HB_TAG('Z','H','A',' ')}},     \/* Yang Zhuang -> Zhuang *\/\n+  {\"zyj\",       {HB_TAG('Z','H','A',' ')}},     \/* Youjiang Zhuang -> Zhuang *\/\n+  {\"zyn\",       {HB_TAG('Z','H','A',' ')}},     \/* Yongnan Zhuang -> Zhuang *\/\n+  {\"zza\",       {HB_TAG('Z','Z','A',' ')}},     \/* Zazaki [macrolanguage] *\/\n+  {\"zzj\",       {HB_TAG('Z','H','A',' ')}},     \/* Zuojiang Zhuang -> Zhuang *\/\n+};\n+\n+static_assert (HB_OT_MAX_TAGS_PER_LANGUAGE == 3u, \"\");\n+\n+\/**\n+ * hb_ot_tags_from_complex_language:\n+ * @lang_str: a BCP 47 language tag to convert.\n+ * @limit: a pointer to the end of the substring of @lang_str to consider for\n+ * conversion.\n+ * @count: maximum number of language tags to retrieve (IN) and actual number of\n+ * language tags retrieved (OUT). If no tags are retrieved, it is not modified.\n+ * @tags: array of size at least @language_count to store the language tag\n+ * results\n+ *\n+ * Converts a multi-subtag BCP 47 language tag to language tags.\n+ *\n+ * Return value: Whether any language systems were retrieved.\n+ **\/\n+static bool\n+hb_ot_tags_from_complex_language (const char   *lang_str,\n+                                  const char   *limit,\n+                                  unsigned int *count \/* IN\/OUT *\/,\n+                                  hb_tag_t     *tags \/* OUT *\/)\n+{\n+  if (subtag_matches (lang_str, limit, \"-fonnapa\"))\n+  {\n+    \/* Undetermined; North American Phonetic Alphabet *\/\n+    tags[0] = HB_TAG('A','P','P','H');  \/* Phonetic transcription—Americanist conventions *\/\n+    *count = 1;\n+    return true;\n+  }\n+  if (subtag_matches (lang_str, limit, \"-polyton\"))\n+  {\n+    \/* Modern Greek (1453-); Polytonic Greek *\/\n+    tags[0] = HB_TAG('P','G','R',' ');  \/* Polytonic Greek *\/\n+    *count = 1;\n+    return true;\n+  }\n+  if (subtag_matches (lang_str, limit, \"-provenc\"))\n+  {\n+    \/* Occitan (post 1500); Provençal *\/\n+    tags[0] = HB_TAG('P','R','O',' ');  \/* Provençal \/ Old Provençal *\/\n+    *count = 1;\n+    return true;\n+  }\n+  if (subtag_matches (lang_str, limit, \"-fonipa\"))\n+  {\n+    \/* Undetermined; International Phonetic Alphabet *\/\n+    tags[0] = HB_TAG('I','P','P','H');  \/* Phonetic transcription—IPA conventions *\/\n+    *count = 1;\n+    return true;\n+  }\n+  if (subtag_matches (lang_str, limit, \"-geok\"))\n+  {\n+    \/* Undetermined; Khutsuri (Asomtavruli and Nuskhuri) *\/\n+    tags[0] = HB_TAG('K','G','E',' ');  \/* Khutsuri Georgian *\/\n+    *count = 1;\n+    return true;\n+  }\n+  if (subtag_matches (lang_str, limit, \"-syre\"))\n+  {\n+    \/* Undetermined; Syriac (Estrangelo variant) *\/\n+    tags[0] = HB_TAG('S','Y','R','E');  \/* Syriac, Estrangela script-variant (equivalent to ISO 15924 'Syre') *\/\n+    *count = 1;\n+    return true;\n+  }\n+  if (subtag_matches (lang_str, limit, \"-syrj\"))\n+  {\n+    \/* Undetermined; Syriac (Western variant) *\/\n+    tags[0] = HB_TAG('S','Y','R','J');  \/* Syriac, Western script-variant (equivalent to ISO 15924 'Syrj') *\/\n+    *count = 1;\n+    return true;\n+  }\n+  if (subtag_matches (lang_str, limit, \"-syrn\"))\n+  {\n+    \/* Undetermined; Syriac (Eastern variant) *\/\n+    tags[0] = HB_TAG('S','Y','R','N');  \/* Syriac, Eastern script-variant (equivalent to ISO 15924 'Syrn') *\/\n+    *count = 1;\n+    return true;\n+  }\n+  switch (lang_str[0])\n+  {\n+  case 'a':\n+    if (0 == strcmp (&lang_str[1], \"rt-lojban\"))\n+    {\n+      \/* Lojban *\/\n+      tags[0] = HB_TAG('J','B','O',' ');  \/* Lojban *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'c':\n+    if (lang_matches (&lang_str[1], \"do-hant-hk\"))\n+    {\n+      \/* Min Dong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"do-hant-mo\"))\n+    {\n+      \/* Min Dong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"jy-hant-hk\"))\n+    {\n+      \/* Jinyu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"jy-hant-mo\"))\n+    {\n+      \/* Jinyu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"mn-hant-hk\"))\n+    {\n+      \/* Mandarin Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"mn-hant-mo\"))\n+    {\n+      \/* Mandarin Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"px-hant-hk\"))\n+    {\n+      \/* Pu-Xian Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"px-hant-mo\"))\n+    {\n+      \/* Pu-Xian Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zh-hant-hk\"))\n+    {\n+      \/* Huizhou Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zh-hant-mo\"))\n+    {\n+      \/* Huizhou Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zo-hant-hk\"))\n+    {\n+      \/* Min Zhong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zo-hant-mo\"))\n+    {\n+      \/* Min Zhong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"do-hans\"))\n+    {\n+      \/* Min Dong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"do-hant\"))\n+    {\n+      \/* Min Dong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"jy-hans\"))\n+    {\n+      \/* Jinyu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"jy-hant\"))\n+    {\n+      \/* Jinyu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"mn-hans\"))\n+    {\n+      \/* Mandarin Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"mn-hant\"))\n+    {\n+      \/* Mandarin Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"px-hans\"))\n+    {\n+      \/* Pu-Xian Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"px-hant\"))\n+    {\n+      \/* Pu-Xian Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zh-hans\"))\n+    {\n+      \/* Huizhou Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zh-hant\"))\n+    {\n+      \/* Huizhou Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zo-hans\"))\n+    {\n+      \/* Min Zhong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"zo-hant\"))\n+    {\n+      \/* Min Zhong Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"do-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Min Dong Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"do-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Min Dong Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"do-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Min Dong Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"jy-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Jinyu Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"jy-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Jinyu Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"jy-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Jinyu Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"mn-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Mandarin Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"mn-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Mandarin Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"mn-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Mandarin Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"px-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Pu-Xian Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"px-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Pu-Xian Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"px-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Pu-Xian Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"zh-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Huizhou Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"zh-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Huizhou Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"zh-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Huizhou Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"zo-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Min Zhong Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"zo-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Min Zhong Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"zo-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Min Zhong Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'g':\n+    if (lang_matches (&lang_str[1], \"an-hant-hk\"))\n+    {\n+      \/* Gan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"an-hant-mo\"))\n+    {\n+      \/* Gan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"an-hans\"))\n+    {\n+      \/* Gan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"an-hant\"))\n+    {\n+      \/* Gan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"a-latg\"))\n+    {\n+      \/* Irish *\/\n+      tags[0] = HB_TAG('I','R','T',' ');  \/* Irish Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"an-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Gan Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"an-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Gan Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"an-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Gan Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'h':\n+    if (lang_matches (&lang_str[1], \"ak-hant-hk\"))\n+    {\n+      \/* Hakka Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"ak-hant-mo\"))\n+    {\n+      \/* Hakka Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"sn-hant-hk\"))\n+    {\n+      \/* Xiang Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"sn-hant-mo\"))\n+    {\n+      \/* Xiang Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"ak-hans\"))\n+    {\n+      \/* Hakka Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"ak-hant\"))\n+    {\n+      \/* Hakka Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"sn-hans\"))\n+    {\n+      \/* Xiang Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"sn-hant\"))\n+    {\n+      \/* Xiang Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"ak-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Hakka Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"ak-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Hakka Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"ak-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Hakka Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"sn-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Xiang Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"sn-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Xiang Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"sn-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Xiang Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'i':\n+    if (0 == strcmp (&lang_str[1], \"-navajo\"))\n+    {\n+      \/* Navajo *\/\n+      unsigned int i;\n+      hb_tag_t possible_tags[] = {\n+        HB_TAG('N','A','V',' '),  \/* Navajo *\/\n+        HB_TAG('A','T','H',' '),  \/* Athapaskan *\/\n+      };\n+      for (i = 0; i < 2 && i < *count; i++)\n+        tags[i] = possible_tags[i];\n+      *count = i;\n+      return true;\n+    }\n+    if (0 == strcmp (&lang_str[1], \"-hak\"))\n+    {\n+      \/* Hakka *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strcmp (&lang_str[1], \"-lux\"))\n+    {\n+      \/* Luxembourgish *\/\n+      tags[0] = HB_TAG('L','T','Z',' ');  \/* Luxembourgish *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'l':\n+    if (lang_matches (&lang_str[1], \"zh-hans\"))\n+    {\n+      \/* Literary Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'm':\n+    if (lang_matches (&lang_str[1], \"np-hant-hk\"))\n+    {\n+      \/* Min Bei Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"np-hant-mo\"))\n+    {\n+      \/* Min Bei Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"np-hans\"))\n+    {\n+      \/* Min Bei Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"np-hant\"))\n+    {\n+      \/* Min Bei Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"np-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Min Bei Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"np-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Min Bei Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"np-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Min Bei Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'n':\n+    if (lang_matches (&lang_str[1], \"an-hant-hk\"))\n+    {\n+      \/* Min Nan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"an-hant-mo\"))\n+    {\n+      \/* Min Nan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"an-hans\"))\n+    {\n+      \/* Min Nan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"an-hant\"))\n+    {\n+      \/* Min Nan Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"an-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Min Nan Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"an-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Min Nan Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"an-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Min Nan Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strcmp (&lang_str[1], \"o-bok\"))\n+    {\n+      \/* Norwegian Bokmal *\/\n+      tags[0] = HB_TAG('N','O','R',' ');  \/* Norwegian *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strcmp (&lang_str[1], \"o-nyn\"))\n+    {\n+      \/* Norwegian Nynorsk *\/\n+      tags[0] = HB_TAG('N','Y','N',' ');  \/* Norwegian Nynorsk (Nynorsk, Norwegian) *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'r':\n+    if (0 == strncmp (&lang_str[1], \"o-\", 2)\n+        && subtag_matches (lang_str, limit, \"-md\"))\n+    {\n+      \/* Romanian; Moldova *\/\n+      tags[0] = HB_TAG('M','O','L',' ');  \/* Moldavian *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'w':\n+    if (lang_matches (&lang_str[1], \"uu-hant-hk\"))\n+    {\n+      \/* Wu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"uu-hant-mo\"))\n+    {\n+      \/* Wu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"uu-hans\"))\n+    {\n+      \/* Wu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"uu-hant\"))\n+    {\n+      \/* Wu Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"uu-\", 3)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Wu Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"uu-\", 3)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Wu Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"uu-\", 3)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Wu Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'y':\n+    if (lang_matches (&lang_str[1], \"ue-hans\"))\n+    {\n+      \/* Yue Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  case 'z':\n+    if (lang_matches (&lang_str[1], \"h-hant-hk\"))\n+    {\n+      \/* Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"h-hant-mo\"))\n+    {\n+      \/* Chinese *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strcmp (&lang_str[1], \"h-min-nan\"))\n+    {\n+      \/* Minnan, Hokkien, Amoy, Taiwanese, Southern Min, Southern Fujian, Hoklo, Southern Fukien, Ho-lo *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"h-hans\"))\n+    {\n+      \/* Chinese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (lang_matches (&lang_str[1], \"h-hant\"))\n+    {\n+      \/* Chinese *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strcmp (&lang_str[1], \"h-min\"))\n+    {\n+      \/* Min, Fuzhou, Hokkien, Amoy, or Taiwanese *\/\n+      tags[0] = HB_TAG('Z','H','S',' ');  \/* Chinese Simplified *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"h-\", 2)\n+        && subtag_matches (lang_str, limit, \"-hk\"))\n+    {\n+      \/* Chinese; Hong Kong *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"h-\", 2)\n+        && subtag_matches (lang_str, limit, \"-mo\"))\n+    {\n+      \/* Chinese; Macao *\/\n+      tags[0] = HB_TAG('Z','H','H',' ');  \/* Chinese, Hong Kong SAR *\/\n+      *count = 1;\n+      return true;\n+    }\n+    if (0 == strncmp (&lang_str[1], \"h-\", 2)\n+        && subtag_matches (lang_str, limit, \"-tw\"))\n+    {\n+      \/* Chinese; Taiwan, Province of China *\/\n+      tags[0] = HB_TAG('Z','H','T',' ');  \/* Chinese Traditional *\/\n+      *count = 1;\n+      return true;\n+    }\n+    break;\n+  }\n+  return false;\n+}\n+\n+\/**\n+ * hb_ot_ambiguous_tag_to_language\n+ * @tag: A language tag.\n+ *\n+ * Converts @tag to a BCP 47 language tag if it is ambiguous (it corresponds to\n+ * many language tags) and the best tag is not the alphabetically first, or if\n+ * the best tag consists of multiple subtags.\n+ *\n+ * Return value: The #hb_language_t corresponding to the BCP 47 language tag,\n+ * or #HB_LANGUAGE_INVALID if @tag is not ambiguous.\n+ **\/\n+static hb_language_t\n+hb_ot_ambiguous_tag_to_language (hb_tag_t tag)\n+{\n+  switch (tag)\n+  {\n+  case HB_TAG('A','P','P','H'):  \/* Phonetic transcription—Americanist conventions *\/\n+    return hb_language_from_string (\"und-fonnapa\", -1);  \/* Undetermined; North American Phonetic Alphabet *\/\n+  case HB_TAG('A','R','A',' '):  \/* Arabic *\/\n+    return hb_language_from_string (\"ar\", -1);  \/* Arabic *\/\n+  case HB_TAG('A','R','K',' '):  \/* Rakhine *\/\n+    return hb_language_from_string (\"rki\", -1);  \/* Rakhine *\/\n+  case HB_TAG('A','T','H',' '):  \/* Athapaskan *\/\n+    return hb_language_from_string (\"ath\", -1);  \/* Athapascan *\/\n+  case HB_TAG('B','I','K',' '):  \/* Bikol *\/\n+    return hb_language_from_string (\"bik\", -1);  \/* Bikol *\/\n+  case HB_TAG('C','P','P',' '):  \/* Creoles *\/\n+    return hb_language_from_string (\"crp\", -1);  \/* Creoles and pidgins *\/\n+  case HB_TAG('C','R','R',' '):  \/* Carrier *\/\n+    return hb_language_from_string (\"crx\", -1);  \/* Carrier *\/\n+  case HB_TAG('D','N','K',' '):  \/* Dinka *\/\n+    return hb_language_from_string (\"din\", -1);  \/* Dinka *\/\n+  case HB_TAG('D','R','I',' '):  \/* Dari *\/\n+    return hb_language_from_string (\"prs\", -1);  \/* Dari *\/\n+  case HB_TAG('D','U','J',' '):  \/* Dhuwal *\/\n+    return hb_language_from_string (\"dwu\", -1);  \/* Dhuwal *\/\n+  case HB_TAG('D','Z','N',' '):  \/* Dzongkha *\/\n+    return hb_language_from_string (\"dz\", -1);  \/* Dzongkha *\/\n+  case HB_TAG('E','T','I',' '):  \/* Estonian *\/\n+    return hb_language_from_string (\"et\", -1);  \/* Estonian *\/\n+  case HB_TAG('G','O','N',' '):  \/* Gondi *\/\n+    return hb_language_from_string (\"gon\", -1);  \/* Gondi *\/\n+  case HB_TAG('H','M','N',' '):  \/* Hmong *\/\n+    return hb_language_from_string (\"hmn\", -1);  \/* Hmong *\/\n+  case HB_TAG('I','J','O',' '):  \/* Ijo *\/\n+    return hb_language_from_string (\"ijo\", -1);  \/* Ijo *\/\n+  case HB_TAG('I','N','U',' '):  \/* Inuktitut *\/\n+    return hb_language_from_string (\"iu\", -1);  \/* Inuktitut *\/\n+  case HB_TAG('I','P','K',' '):  \/* Inupiat *\/\n+    return hb_language_from_string (\"ik\", -1);  \/* Inupiaq *\/\n+  case HB_TAG('I','P','P','H'):  \/* Phonetic transcription—IPA conventions *\/\n+    return hb_language_from_string (\"und-fonipa\", -1);  \/* Undetermined; International Phonetic Alphabet *\/\n+  case HB_TAG('I','R','T',' '):  \/* Irish Traditional *\/\n+    return hb_language_from_string (\"ga-Latg\", -1);  \/* Irish; Latin (Gaelic variant) *\/\n+  case HB_TAG('J','I','I',' '):  \/* Yiddish *\/\n+    return hb_language_from_string (\"yi\", -1);  \/* Yiddish *\/\n+  case HB_TAG('K','A','L',' '):  \/* Kalenjin *\/\n+    return hb_language_from_string (\"kln\", -1);  \/* Kalenjin *\/\n+  case HB_TAG('K','G','E',' '):  \/* Khutsuri Georgian *\/\n+    return hb_language_from_string (\"und-Geok\", -1);  \/* Undetermined; Khutsuri (Asomtavruli and Nuskhuri) *\/\n+  case HB_TAG('K','N','R',' '):  \/* Kanuri *\/\n+    return hb_language_from_string (\"kr\", -1);  \/* Kanuri *\/\n+  case HB_TAG('K','O','K',' '):  \/* Konkani *\/\n+    return hb_language_from_string (\"kok\", -1);  \/* Konkani *\/\n+  case HB_TAG('K','U','R',' '):  \/* Kurdish *\/\n+    return hb_language_from_string (\"ku\", -1);  \/* Kurdish *\/\n+  case HB_TAG('L','U','H',' '):  \/* Luyia *\/\n+    return hb_language_from_string (\"luy\", -1);  \/* Luyia *\/\n+  case HB_TAG('L','V','I',' '):  \/* Latvian *\/\n+    return hb_language_from_string (\"lv\", -1);  \/* Latvian *\/\n+  case HB_TAG('M','A','W',' '):  \/* Marwari *\/\n+    return hb_language_from_string (\"mwr\", -1);  \/* Marwari *\/\n+  case HB_TAG('M','L','G',' '):  \/* Malagasy *\/\n+    return hb_language_from_string (\"mg\", -1);  \/* Malagasy *\/\n+  case HB_TAG('M','L','Y',' '):  \/* Malay *\/\n+    return hb_language_from_string (\"ms\", -1);  \/* Malay *\/\n+  case HB_TAG('M','N','G',' '):  \/* Mongolian *\/\n+    return hb_language_from_string (\"mn\", -1);  \/* Mongolian *\/\n+  case HB_TAG('M','O','L',' '):  \/* Moldavian *\/\n+    return hb_language_from_string (\"ro-MD\", -1);  \/* Romanian; Moldova *\/\n+  case HB_TAG('N','E','P',' '):  \/* Nepali *\/\n+    return hb_language_from_string (\"ne\", -1);  \/* Nepali *\/\n+  case HB_TAG('N','I','S',' '):  \/* Nisi *\/\n+    return hb_language_from_string (\"njz\", -1);  \/* Nyishi *\/\n+  case HB_TAG('N','O','R',' '):  \/* Norwegian *\/\n+    return hb_language_from_string (\"no\", -1);  \/* Norwegian *\/\n+  case HB_TAG('O','J','B',' '):  \/* Ojibway *\/\n+    return hb_language_from_string (\"oj\", -1);  \/* Ojibwa *\/\n+  case HB_TAG('O','R','O',' '):  \/* Oromo *\/\n+    return hb_language_from_string (\"om\", -1);  \/* Oromo *\/\n+  case HB_TAG('P','A','S',' '):  \/* Pashto *\/\n+    return hb_language_from_string (\"ps\", -1);  \/* Pashto *\/\n+  case HB_TAG('P','G','R',' '):  \/* Polytonic Greek *\/\n+    return hb_language_from_string (\"el-polyton\", -1);  \/* Modern Greek (1453-); Polytonic Greek *\/\n+  case HB_TAG('P','R','O',' '):  \/* Provençal \/ Old Provençal *\/\n+    return hb_language_from_string (\"pro\", -1);  \/* Old Provençal (to 1500) *\/\n+  case HB_TAG('Q','U','H',' '):  \/* Quechua (Bolivia) *\/\n+    return hb_language_from_string (\"quh\", -1);  \/* South Bolivian Quechua *\/\n+  case HB_TAG('Q','V','I',' '):  \/* Quechua (Ecuador) *\/\n+    return hb_language_from_string (\"qvi\", -1);  \/* Imbabura Highland Quichua *\/\n+  case HB_TAG('Q','W','H',' '):  \/* Quechua (Peru) *\/\n+    return hb_language_from_string (\"qwh\", -1);  \/* Huaylas Ancash Quechua *\/\n+  case HB_TAG('R','A','J',' '):  \/* Rajasthani *\/\n+    return hb_language_from_string (\"raj\", -1);  \/* Rajasthani *\/\n+  case HB_TAG('R','O','Y',' '):  \/* Romany *\/\n+    return hb_language_from_string (\"rom\", -1);  \/* Romany *\/\n+  case HB_TAG('S','Q','I',' '):  \/* Albanian *\/\n+    return hb_language_from_string (\"sq\", -1);  \/* Albanian *\/\n+  case HB_TAG('S','Y','R',' '):  \/* Syriac *\/\n+    return hb_language_from_string (\"syr\", -1);  \/* Syriac *\/\n+  case HB_TAG('S','Y','R','E'):  \/* Syriac, Estrangela script-variant (equivalent to ISO 15924 'Syre') *\/\n+    return hb_language_from_string (\"und-Syre\", -1);  \/* Undetermined; Syriac (Estrangelo variant) *\/\n+  case HB_TAG('S','Y','R','J'):  \/* Syriac, Western script-variant (equivalent to ISO 15924 'Syrj') *\/\n+    return hb_language_from_string (\"und-Syrj\", -1);  \/* Undetermined; Syriac (Western variant) *\/\n+  case HB_TAG('S','Y','R','N'):  \/* Syriac, Eastern script-variant (equivalent to ISO 15924 'Syrn') *\/\n+    return hb_language_from_string (\"und-Syrn\", -1);  \/* Undetermined; Syriac (Eastern variant) *\/\n+  case HB_TAG('T','M','H',' '):  \/* Tamashek *\/\n+    return hb_language_from_string (\"tmh\", -1);  \/* Tamashek *\/\n+  case HB_TAG('T','N','E',' '):  \/* Tundra Nenets *\/\n+    return hb_language_from_string (\"yrk\", -1);  \/* Nenets *\/\n+  case HB_TAG('Z','H','H',' '):  \/* Chinese, Hong Kong SAR *\/\n+    return hb_language_from_string (\"zh-HK\", -1);  \/* Chinese; Hong Kong *\/\n+  case HB_TAG('Z','H','S',' '):  \/* Chinese Simplified *\/\n+    return hb_language_from_string (\"zh-Hans\", -1);  \/* Chinese; Han (Simplified variant) *\/\n+  case HB_TAG('Z','H','T',' '):  \/* Chinese Traditional *\/\n+    return hb_language_from_string (\"zh-Hant\", -1);  \/* Chinese; Han (Traditional variant) *\/\n+  default:\n+    return HB_LANGUAGE_INVALID;\n+  }\n+}\n+\n+#endif \/* HB_OT_TAG_TABLE_HH *\/\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-tag-table.hh","additions":2064,"deletions":0,"binary":false,"changes":2064,"status":"added"},{"patch":"@@ -0,0 +1,527 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2011  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod, Roozbeh Pournader\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+\n+\/* hb_script_t *\/\n+\n+static hb_tag_t\n+hb_ot_old_tag_from_script (hb_script_t script)\n+{\n+  \/* This seems to be accurate as of end of 2012. *\/\n+\n+  switch ((hb_tag_t) script)\n+  {\n+    case HB_SCRIPT_INVALID:             return HB_OT_TAG_DEFAULT_SCRIPT;\n+\n+    \/* KATAKANA and HIRAGANA both map to 'kana' *\/\n+    case HB_SCRIPT_HIRAGANA:            return HB_TAG('k','a','n','a');\n+\n+    \/* Spaces at the end are preserved, unlike ISO 15924 *\/\n+    case HB_SCRIPT_LAO:                 return HB_TAG('l','a','o',' ');\n+    case HB_SCRIPT_YI:                  return HB_TAG('y','i',' ',' ');\n+    \/* Unicode-5.0 additions *\/\n+    case HB_SCRIPT_NKO:                 return HB_TAG('n','k','o',' ');\n+    \/* Unicode-5.1 additions *\/\n+    case HB_SCRIPT_VAI:                 return HB_TAG('v','a','i',' ');\n+  }\n+\n+  \/* Else, just change first char to lowercase and return *\/\n+  return ((hb_tag_t) script) | 0x20000000u;\n+}\n+\n+static hb_script_t\n+hb_ot_old_tag_to_script (hb_tag_t tag)\n+{\n+  if (unlikely (tag == HB_OT_TAG_DEFAULT_SCRIPT))\n+    return HB_SCRIPT_INVALID;\n+\n+  \/* This side of the conversion is fully algorithmic. *\/\n+\n+  \/* Any spaces at the end of the tag are replaced by repeating the last\n+   * letter.  Eg 'nko ' -> 'Nkoo' *\/\n+  if (unlikely ((tag & 0x0000FF00u) == 0x00002000u))\n+    tag |= (tag >> 8) & 0x0000FF00u; \/* Copy second letter to third *\/\n+  if (unlikely ((tag & 0x000000FFu) == 0x00000020u))\n+    tag |= (tag >> 8) & 0x000000FFu; \/* Copy third letter to fourth *\/\n+\n+  \/* Change first char to uppercase and return *\/\n+  return (hb_script_t) (tag & ~0x20000000u);\n+}\n+\n+static hb_tag_t\n+hb_ot_new_tag_from_script (hb_script_t script)\n+{\n+  switch ((hb_tag_t) script) {\n+    case HB_SCRIPT_BENGALI:             return HB_TAG('b','n','g','2');\n+    case HB_SCRIPT_DEVANAGARI:          return HB_TAG('d','e','v','2');\n+    case HB_SCRIPT_GUJARATI:            return HB_TAG('g','j','r','2');\n+    case HB_SCRIPT_GURMUKHI:            return HB_TAG('g','u','r','2');\n+    case HB_SCRIPT_KANNADA:             return HB_TAG('k','n','d','2');\n+    case HB_SCRIPT_MALAYALAM:           return HB_TAG('m','l','m','2');\n+    case HB_SCRIPT_ORIYA:               return HB_TAG('o','r','y','2');\n+    case HB_SCRIPT_TAMIL:               return HB_TAG('t','m','l','2');\n+    case HB_SCRIPT_TELUGU:              return HB_TAG('t','e','l','2');\n+    case HB_SCRIPT_MYANMAR:             return HB_TAG('m','y','m','2');\n+  }\n+\n+  return HB_OT_TAG_DEFAULT_SCRIPT;\n+}\n+\n+static hb_script_t\n+hb_ot_new_tag_to_script (hb_tag_t tag)\n+{\n+  switch (tag) {\n+    case HB_TAG('b','n','g','2'):       return HB_SCRIPT_BENGALI;\n+    case HB_TAG('d','e','v','2'):       return HB_SCRIPT_DEVANAGARI;\n+    case HB_TAG('g','j','r','2'):       return HB_SCRIPT_GUJARATI;\n+    case HB_TAG('g','u','r','2'):       return HB_SCRIPT_GURMUKHI;\n+    case HB_TAG('k','n','d','2'):       return HB_SCRIPT_KANNADA;\n+    case HB_TAG('m','l','m','2'):       return HB_SCRIPT_MALAYALAM;\n+    case HB_TAG('o','r','y','2'):       return HB_SCRIPT_ORIYA;\n+    case HB_TAG('t','m','l','2'):       return HB_SCRIPT_TAMIL;\n+    case HB_TAG('t','e','l','2'):       return HB_SCRIPT_TELUGU;\n+    case HB_TAG('m','y','m','2'):       return HB_SCRIPT_MYANMAR;\n+  }\n+\n+  return HB_SCRIPT_UNKNOWN;\n+}\n+\n+void\n+hb_ot_tags_from_script (hb_script_t  script,\n+                        hb_tag_t    *script_tag_1,\n+                        hb_tag_t    *script_tag_2)\n+{\n+  unsigned int count = 2;\n+  hb_tag_t tags[2];\n+  hb_ot_tags_from_script_and_language (script, HB_LANGUAGE_INVALID, &count, tags, nullptr, nullptr);\n+  *script_tag_1 = count > 0 ? tags[0] : HB_OT_TAG_DEFAULT_SCRIPT;\n+  *script_tag_2 = count > 1 ? tags[1] : HB_OT_TAG_DEFAULT_SCRIPT;\n+}\n+\n+\/*\n+ * Complete list at:\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/scripttags\n+ *\n+ * Most of the script tags are the same as the ISO 15924 tag but lowercased.\n+ * So we just do that, and handle the exceptional cases in a switch.\n+ *\/\n+\n+static void\n+hb_ot_all_tags_from_script (hb_script_t   script,\n+                            unsigned int *count \/* IN\/OUT *\/,\n+                            hb_tag_t     *tags \/* OUT *\/)\n+{\n+  unsigned int i = 0;\n+\n+  hb_tag_t new_tag = hb_ot_new_tag_from_script (script);\n+  if (unlikely (new_tag != HB_OT_TAG_DEFAULT_SCRIPT))\n+  {\n+    tags[i++] = new_tag | '3';\n+    if (*count > i)\n+      tags[i++] = new_tag;\n+  }\n+\n+  if (*count > i)\n+  {\n+    hb_tag_t old_tag = hb_ot_old_tag_from_script (script);\n+    if (old_tag != HB_OT_TAG_DEFAULT_SCRIPT)\n+      tags[i++] = old_tag;\n+  }\n+\n+  *count = i;\n+}\n+\n+hb_script_t\n+hb_ot_tag_to_script (hb_tag_t tag)\n+{\n+  unsigned char digit = tag & 0x000000FFu;\n+  if (unlikely (digit == '2' || digit == '3'))\n+    return hb_ot_new_tag_to_script (tag & 0xFFFFFF32);\n+\n+  return hb_ot_old_tag_to_script (tag);\n+}\n+\n+\n+\/* hb_language_t *\/\n+\n+static int\n+lang_compare_first_component (const void *pa,\n+                              const void *pb)\n+{\n+  const char *a = (const char *) pa;\n+  const char *b = (const char *) pb;\n+  unsigned int da, db;\n+  const char *p;\n+\n+  p = strchr (a, '-');\n+  da = p ? (unsigned int) (p - a) : strlen (a);\n+\n+  p = strchr (b, '-');\n+  db = p ? (unsigned int) (p - b) : strlen (b);\n+\n+  return strncmp (a, b, MAX (da, db));\n+}\n+\n+static bool\n+subtag_matches (const char *lang_str,\n+                const char *limit,\n+                const char *subtag)\n+{\n+  do {\n+    const char *s = strstr (lang_str, subtag);\n+    if (!s || s >= limit)\n+      return false;\n+    if (!ISALNUM (s[strlen (subtag)]))\n+      return true;\n+    lang_str = s + strlen (subtag);\n+  } while (true);\n+}\n+\n+static hb_bool_t\n+lang_matches (const char *lang_str, const char *spec)\n+{\n+  unsigned int len = strlen (spec);\n+\n+  return strncmp (lang_str, spec, len) == 0 &&\n+         (lang_str[len] == '\\0' || lang_str[len] == '-');\n+}\n+\n+typedef struct {\n+  char language[4];\n+  hb_tag_t tags[HB_OT_MAX_TAGS_PER_LANGUAGE];\n+} LangTag;\n+\n+#include \"hb-ot-tag-table.hh\"\n+\n+\/* The corresponding languages IDs for the following IDs are unclear,\n+ * overlap, or are architecturally weird. Needs more research. *\/\n+\n+\/*{\"??\",        {HB_TAG('B','C','R',' ')}},*\/   \/* Bible Cree *\/\n+\/*{\"zh?\",       {HB_TAG('C','H','N',' ')}},*\/   \/* Chinese (seen in Microsoft fonts) *\/\n+\/*{\"ar-Syrc?\",  {HB_TAG('G','A','R',' ')}},*\/   \/* Garshuni *\/\n+\/*{\"??\",        {HB_TAG('N','G','R',' ')}},*\/   \/* Nagari *\/\n+\/*{\"??\",        {HB_TAG('Y','I','C',' ')}},*\/   \/* Yi Classic *\/\n+\/*{\"zh?\",       {HB_TAG('Z','H','P',' ')}},*\/   \/* Chinese Phonetic *\/\n+\n+hb_tag_t\n+hb_ot_tag_from_language (hb_language_t language)\n+{\n+  unsigned int count = 1;\n+  hb_tag_t tags[1];\n+  hb_ot_tags_from_script_and_language (HB_SCRIPT_UNKNOWN, language, nullptr, nullptr, &count, tags);\n+  return count > 0 ? tags[0] : HB_OT_TAG_DEFAULT_LANGUAGE;\n+}\n+\n+static void\n+hb_ot_tags_from_language (const char   *lang_str,\n+                          const char   *limit,\n+                          unsigned int *count,\n+                          hb_tag_t     *tags)\n+{\n+  const char *s;\n+\n+  \/* Check for matches of multiple subtags. *\/\n+  if (hb_ot_tags_from_complex_language (lang_str, limit, count, tags))\n+    return;\n+\n+  \/* Find a language matching in the first component. *\/\n+  s = strchr (lang_str, '-');\n+  {\n+    const LangTag *lang_tag;\n+    if (s && limit - lang_str >= 6)\n+    {\n+      const char *extlang_end = strchr (s + 1, '-');\n+      \/* If there is an extended language tag, use it. *\/\n+      if (3 == (extlang_end ? extlang_end - s - 1 : strlen (s + 1)) &&\n+          ISALPHA (s[1]))\n+        lang_str = s + 1;\n+    }\n+    lang_tag = (LangTag *) bsearch (lang_str, ot_languages,\n+                                    ARRAY_LENGTH (ot_languages), sizeof (LangTag),\n+                                    lang_compare_first_component);\n+    if (lang_tag)\n+    {\n+      unsigned int i;\n+      for (i = 0; i < *count && lang_tag->tags[i] != HB_TAG_NONE; i++)\n+        tags[i] = lang_tag->tags[i];\n+      *count = i;\n+      return;\n+    }\n+  }\n+\n+  if (!s)\n+    s = lang_str + strlen (lang_str);\n+  if (s - lang_str == 3) {\n+    \/* Assume it's ISO-639-3 and upper-case and use it. *\/\n+    tags[0] = hb_tag_from_string (lang_str, s - lang_str) & ~0x20202000u;\n+    *count = 1;\n+    return;\n+  }\n+\n+  *count = 0;\n+}\n+\n+static bool\n+parse_private_use_subtag (const char     *private_use_subtag,\n+                          unsigned int   *count,\n+                          hb_tag_t       *tags,\n+                          const char     *prefix,\n+                          unsigned char (*normalize) (unsigned char))\n+{\n+  if (private_use_subtag && count && tags && *count)\n+  {\n+    const char *s = strstr (private_use_subtag, prefix);\n+    if (s)\n+    {\n+      char tag[4];\n+      int i;\n+      s += strlen (prefix);\n+      for (i = 0; i < 4 && ISALNUM (s[i]); i++)\n+        tag[i] = normalize (s[i]);\n+      if (i)\n+      {\n+        for (; i < 4; i++)\n+          tag[i] = ' ';\n+        tags[0] = HB_TAG (tag[0], tag[1], tag[2], tag[3]);\n+        if ((tags[0] & 0xDFDFDFDF) == HB_OT_TAG_DEFAULT_SCRIPT)\n+          tags[0] ^= ~0xDFDFDFDF;\n+        *count = 1;\n+        return false;\n+      }\n+    }\n+  }\n+  return true;\n+}\n+\n+\/**\n+ * hb_ot_tags_from_script_and_language:\n+ * @script: an #hb_script_t to convert.\n+ * @language: an #hb_language_t to convert.\n+ * @script_count: (allow-none): maximum number of script tags to retrieve (IN)\n+ * and actual number of script tags retrieved (OUT)\n+ * @script_tags: (out) (allow-none): array of size at least @script_count to store the\n+ * script tag results\n+ * @language_count: (allow-none): maximum number of language tags to retrieve\n+ * (IN) and actual number of language tags retrieved (OUT)\n+ * @language_tags: (out) (allow-none): array of size at least @language_count to store\n+ * the language tag results\n+ *\n+ * Converts an #hb_script_t and an #hb_language_t to script and language tags.\n+ *\n+ * Since: 2.0.0\n+ **\/\n+void\n+hb_ot_tags_from_script_and_language (hb_script_t   script,\n+                                     hb_language_t language,\n+                                     unsigned int *script_count \/* IN\/OUT *\/,\n+                                     hb_tag_t     *script_tags \/* OUT *\/,\n+                                     unsigned int *language_count \/* IN\/OUT *\/,\n+                                     hb_tag_t     *language_tags \/* OUT *\/)\n+{\n+  bool needs_script = true;\n+\n+  if (language == HB_LANGUAGE_INVALID)\n+  {\n+    if (language_count && language_tags && *language_count)\n+      *language_count = 0;\n+  }\n+  else\n+  {\n+    const char *lang_str, *s, *limit, *private_use_subtag;\n+    bool needs_language;\n+\n+    lang_str = hb_language_to_string (language);\n+    limit = nullptr;\n+    private_use_subtag = nullptr;\n+    if (lang_str[0] == 'x' && lang_str[1] == '-')\n+    {\n+      private_use_subtag = lang_str;\n+    } else {\n+      for (s = lang_str + 1; *s; s++)\n+      {\n+        if (s[-1] == '-' && s[1] == '-')\n+        {\n+          if (s[0] == 'x')\n+          {\n+            private_use_subtag = s;\n+            if (!limit)\n+              limit = s - 1;\n+            break;\n+          } else if (!limit)\n+          {\n+            limit = s - 1;\n+          }\n+        }\n+      }\n+      if (!limit)\n+        limit = s;\n+    }\n+\n+    needs_script = parse_private_use_subtag (private_use_subtag, script_count, script_tags, \"-hbsc\", TOLOWER);\n+    needs_language = parse_private_use_subtag (private_use_subtag, language_count, language_tags, \"-hbot\", TOUPPER);\n+\n+    if (needs_language && language_count && language_tags && *language_count)\n+      hb_ot_tags_from_language (lang_str, limit, language_count, language_tags);\n+  }\n+\n+  if (needs_script && script_count && script_tags && *script_count)\n+    hb_ot_all_tags_from_script (script, script_count, script_tags);\n+}\n+\n+\/**\n+ * hb_ot_tag_to_language:\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_language_t\n+hb_ot_tag_to_language (hb_tag_t tag)\n+{\n+  unsigned int i;\n+\n+  if (tag == HB_OT_TAG_DEFAULT_LANGUAGE)\n+    return nullptr;\n+\n+  {\n+    hb_language_t disambiguated_tag = hb_ot_ambiguous_tag_to_language (tag);\n+    if (disambiguated_tag != HB_LANGUAGE_INVALID)\n+      return disambiguated_tag;\n+  }\n+\n+  for (i = 0; i < ARRAY_LENGTH (ot_languages); i++)\n+    if (ot_languages[i].tags[0] == tag)\n+      return hb_language_from_string (ot_languages[i].language, -1);\n+\n+  \/* Else return a custom language in the form of \"x-hbotABCD\" *\/\n+  {\n+    unsigned char buf[11] = \"x-hbot\";\n+    buf[6] = tag >> 24;\n+    buf[7] = (tag >> 16) & 0xFF;\n+    buf[8] = (tag >> 8) & 0xFF;\n+    buf[9] = tag & 0xFF;\n+    if (buf[9] == 0x20)\n+      buf[9] = '\\0';\n+    buf[10] = '\\0';\n+    return hb_language_from_string ((char *) buf, -1);\n+  }\n+}\n+\n+\/**\n+ * hb_ot_tags_to_script_and_language:\n+ * @script_tag: a script tag\n+ * @language_tag: a language tag\n+ * @script: (allow-none): the #hb_script_t corresponding to @script_tag (OUT).\n+ * @language: (allow-none): the #hb_language_t corresponding to @script_tag and\n+ * @language_tag (OUT).\n+ *\n+ * Converts a script tag and a language tag to an #hb_script_t and an\n+ * #hb_language_t.\n+ *\n+ * Since: 2.0.0\n+ **\/\n+void\n+hb_ot_tags_to_script_and_language (hb_tag_t       script_tag,\n+                                   hb_tag_t       language_tag,\n+                                   hb_script_t   *script \/* OUT *\/,\n+                                   hb_language_t *language \/* OUT *\/)\n+{\n+  hb_script_t script_out = hb_ot_tag_to_script (script_tag);\n+  if (script)\n+    *script = script_out;\n+  if (language)\n+  {\n+    unsigned int script_count = 1;\n+    hb_tag_t primary_script_tag[1];\n+    hb_ot_tags_from_script_and_language (script_out,\n+                                         HB_LANGUAGE_INVALID,\n+                                         &script_count,\n+                                         primary_script_tag,\n+                                         nullptr, nullptr);\n+    *language = hb_ot_tag_to_language (language_tag);\n+    if (script_count == 0 || primary_script_tag[0] != script_tag)\n+    {\n+      unsigned char *buf;\n+      const char *lang_str = hb_language_to_string (*language);\n+      size_t len = strlen (lang_str);\n+      buf = (unsigned char *) malloc (len + 11);\n+      if (unlikely (!buf))\n+      {\n+        *language = nullptr;\n+      }\n+      else\n+      {\n+        memcpy (buf, lang_str, len);\n+        if (lang_str[0] != 'x' || lang_str[1] != '-') {\n+          buf[len++] = '-';\n+          buf[len++] = 'x';\n+        }\n+        buf[len++] = '-';\n+        buf[len++] = 'h';\n+        buf[len++] = 'b';\n+        buf[len++] = 's';\n+        buf[len++] = 'c';\n+        buf[len++] = script_tag >> 24;\n+        buf[len++] = (script_tag >> 16) & 0xFF;\n+        buf[len++] = (script_tag >> 8) & 0xFF;\n+        buf[len++] = script_tag & 0xFF;\n+        *language = hb_language_from_string ((char *) buf, len);\n+        free (buf);\n+      }\n+    }\n+  }\n+}\n+\n+#ifdef MAIN\n+static inline void\n+test_langs_sorted ()\n+{\n+  for (unsigned int i = 1; i < ARRAY_LENGTH (ot_languages); i++)\n+  {\n+    int c = lang_compare_first_component (ot_languages[i-1].language, ot_languages[i].language);\n+    if (c >= 0)\n+    {\n+      fprintf (stderr, \"ot_languages not sorted at index %d: %s %d %s\\n\",\n+               i, ot_languages[i-1].language, c, ot_languages[i].language);\n+      abort();\n+    }\n+  }\n+}\n+\n+int\n+main ()\n+{\n+  test_langs_sorted ();\n+  return 0;\n+}\n+\n+#endif\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-tag.cc","additions":527,"deletions":0,"binary":false,"changes":527,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_VAR_AVAR_TABLE_HH\n+#define HB_OT_VAR_AVAR_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * avar -- Axis Variations\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/avar\n+ *\/\n+\n+#define HB_OT_TAG_avar HB_TAG('a','v','a','r')\n+\n+\n+namespace OT {\n+\n+\n+struct AxisValueMap\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  F2DOT14       fromCoord;      \/* A normalized coordinate value obtained using\n+                                 * default normalization. *\/\n+  F2DOT14       toCoord;        \/* The modified, normalized coordinate value. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct SegmentMaps : ArrayOf<AxisValueMap>\n+{\n+  int map (int value) const\n+  {\n+    \/* The following special-cases are not part of OpenType, which requires\n+     * that at least -1, 0, and +1 must be mapped. But we include these as\n+     * part of a better error recovery scheme. *\/\n+\n+    if (len < 2)\n+    {\n+      if (!len)\n+        return value;\n+      else \/* len == 1*\/\n+        return value - arrayZ[0].fromCoord + arrayZ[0].toCoord;\n+    }\n+\n+    if (value <= arrayZ[0].fromCoord)\n+      return value - arrayZ[0].fromCoord + arrayZ[0].toCoord;\n+\n+    unsigned int i;\n+    unsigned int count = len - 1;\n+    for (i = 1; i < count && value > arrayZ[i].fromCoord; i++)\n+      ;\n+\n+    if (value >= arrayZ[i].fromCoord)\n+      return value - arrayZ[i].fromCoord + arrayZ[i].toCoord;\n+\n+    if (unlikely (arrayZ[i-1].fromCoord == arrayZ[i].fromCoord))\n+      return arrayZ[i-1].toCoord;\n+\n+    int denom = arrayZ[i].fromCoord - arrayZ[i-1].fromCoord;\n+    return arrayZ[i-1].toCoord +\n+           ((arrayZ[i].toCoord - arrayZ[i-1].toCoord) *\n+            (value - arrayZ[i-1].fromCoord) + denom\/2) \/ denom;\n+  }\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (2, *this);\n+};\n+\n+struct avar\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_avar;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    if (unlikely (!(version.sanitize (c) &&\n+                    version.major == 1 &&\n+                    c->check_struct (this))))\n+      return_trace (false);\n+\n+    const SegmentMaps *map = &firstAxisSegmentMaps;\n+    unsigned int count = axisCount;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      if (unlikely (!map->sanitize (c)))\n+        return_trace (false);\n+      map = &StructAfter<SegmentMaps> (*map);\n+    }\n+\n+    return_trace (true);\n+  }\n+\n+  void map_coords (int *coords, unsigned int coords_length) const\n+  {\n+    unsigned int count = MIN<unsigned int> (coords_length, axisCount);\n+\n+    const SegmentMaps *map = &firstAxisSegmentMaps;\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      coords[i] = map->map (coords[i]);\n+      map = &StructAfter<SegmentMaps> (*map);\n+    }\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the avar table\n+                                 * initially set to 0x00010000u *\/\n+  HBUINT16      reserved;       \/* This field is permanently reserved. Set to 0. *\/\n+  HBUINT16      axisCount;      \/* The number of variation axes in the font. This\n+                                 * must be the same number as axisCount in the\n+                                 * 'fvar' table. *\/\n+  SegmentMaps   firstAxisSegmentMaps;\n+\n+  public:\n+  DEFINE_SIZE_MIN (8);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_VAR_AVAR_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-var-avar-table.hh","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_VAR_FVAR_TABLE_HH\n+#define HB_OT_VAR_FVAR_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * fvar -- Font Variations\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/fvar\n+ *\/\n+\n+#define HB_OT_TAG_fvar HB_TAG('f','v','a','r')\n+\n+\n+namespace OT {\n+\n+\n+struct InstanceRecord\n+{\n+  friend struct fvar;\n+\n+  hb_array_t<const Fixed> get_coordinates (unsigned int axis_count) const\n+  { return coordinatesZ.as_array (axis_count); }\n+\n+  bool sanitize (hb_sanitize_context_t *c, unsigned int axis_count) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  c->check_array (coordinatesZ.arrayZ, axis_count));\n+  }\n+\n+  protected:\n+  NameID        subfamilyNameID;\/* The name ID for entries in the 'name' table\n+                                 * that provide subfamily names for this instance. *\/\n+  HBUINT16      flags;          \/* Reserved for future use — set to 0. *\/\n+  UnsizedArrayOf<Fixed>\n+                coordinatesZ;   \/* The coordinates array for this instance. *\/\n+  \/\/NameID      postScriptNameIDX;\/*Optional. The name ID for entries in the 'name'\n+  \/\/                              * table that provide PostScript names for this\n+  \/\/                              * instance. *\/\n+\n+  public:\n+  DEFINE_SIZE_UNBOUNDED (4);\n+};\n+\n+struct AxisRecord\n+{\n+  enum\n+  {\n+    AXIS_FLAG_HIDDEN    = 0x0001,\n+  };\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  Tag           axisTag;        \/* Tag identifying the design variation for the axis. *\/\n+  Fixed         minValue;       \/* The minimum coordinate value for the axis. *\/\n+  Fixed         defaultValue;   \/* The default coordinate value for the axis. *\/\n+  Fixed         maxValue;       \/* The maximum coordinate value for the axis. *\/\n+  HBUINT16      flags;          \/* Axis flags. *\/\n+  NameID        axisNameID;     \/* The name ID for entries in the 'name' table that\n+                                 * provide a display name for this axis. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+struct fvar\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_fvar;\n+\n+  bool has_data () const { return version.to_int (); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  c->check_struct (this) &&\n+                  axisSize == 20 && \/* Assumed in our code. *\/\n+                  instanceSize >= axisCount * 4 + 4 &&\n+                  get_axes ().sanitize (c) &&\n+                  c->check_range (get_instance (0), instanceCount, instanceSize));\n+  }\n+\n+  unsigned int get_axis_count () const { return axisCount; }\n+\n+  void get_axis_deprecated (unsigned int axis_index,\n+                                   hb_ot_var_axis_t *info) const\n+  {\n+    const AxisRecord &axis = get_axes ()[axis_index];\n+    info->tag = axis.axisTag;\n+    info->name_id =  axis.axisNameID;\n+    info->default_value = axis.defaultValue \/ 65536.;\n+    \/* Ensure order, to simplify client math. *\/\n+    info->min_value = MIN<float> (info->default_value, axis.minValue \/ 65536.);\n+    info->max_value = MAX<float> (info->default_value, axis.maxValue \/ 65536.);\n+  }\n+\n+  void get_axis_info (unsigned int axis_index,\n+                      hb_ot_var_axis_info_t *info) const\n+  {\n+    const AxisRecord &axis = get_axes ()[axis_index];\n+    info->axis_index = axis_index;\n+    info->tag = axis.axisTag;\n+    info->name_id =  axis.axisNameID;\n+    info->flags = (hb_ot_var_axis_flags_t) (unsigned int) axis.flags;\n+    info->default_value = axis.defaultValue \/ 65536.;\n+    \/* Ensure order, to simplify client math. *\/\n+    info->min_value = MIN<float> (info->default_value, axis.minValue \/ 65536.);\n+    info->max_value = MAX<float> (info->default_value, axis.maxValue \/ 65536.);\n+    info->reserved = 0;\n+  }\n+\n+  unsigned int get_axes_deprecated (unsigned int      start_offset,\n+                                    unsigned int     *axes_count \/* IN\/OUT *\/,\n+                                    hb_ot_var_axis_t *axes_array \/* OUT *\/) const\n+  {\n+    if (axes_count)\n+    {\n+      \/* TODO Rewrite as hb_array_t<>::sub-array() *\/\n+      unsigned int count = axisCount;\n+      start_offset = MIN (start_offset, count);\n+\n+      count -= start_offset;\n+      axes_array += start_offset;\n+\n+      count = MIN (count, *axes_count);\n+      *axes_count = count;\n+\n+      for (unsigned int i = 0; i < count; i++)\n+        get_axis_deprecated (start_offset + i, axes_array + i);\n+    }\n+    return axisCount;\n+  }\n+\n+  unsigned int get_axis_infos (unsigned int           start_offset,\n+                               unsigned int          *axes_count \/* IN\/OUT *\/,\n+                               hb_ot_var_axis_info_t *axes_array \/* OUT *\/) const\n+  {\n+    if (axes_count)\n+    {\n+      \/* TODO Rewrite as hb_array_t<>::sub-array() *\/\n+      unsigned int count = axisCount;\n+      start_offset = MIN (start_offset, count);\n+\n+      count -= start_offset;\n+      axes_array += start_offset;\n+\n+      count = MIN (count, *axes_count);\n+      *axes_count = count;\n+\n+      for (unsigned int i = 0; i < count; i++)\n+        get_axis_info (start_offset + i, axes_array + i);\n+    }\n+    return axisCount;\n+  }\n+\n+  bool find_axis_deprecated (hb_tag_t tag,\n+                             unsigned int *axis_index,\n+                             hb_ot_var_axis_t *info) const\n+  {\n+    const AxisRecord *axes = get_axes ();\n+    unsigned int count = get_axis_count ();\n+    for (unsigned int i = 0; i < count; i++)\n+      if (axes[i].axisTag == tag)\n+      {\n+        if (axis_index)\n+          *axis_index = i;\n+        get_axis_deprecated (i, info);\n+        return true;\n+      }\n+    if (axis_index)\n+      *axis_index = HB_OT_VAR_NO_AXIS_INDEX;\n+    return false;\n+  }\n+\n+  bool find_axis_info (hb_tag_t tag,\n+                       hb_ot_var_axis_info_t *info) const\n+  {\n+    const AxisRecord *axes = get_axes ();\n+    unsigned int count = get_axis_count ();\n+    for (unsigned int i = 0; i < count; i++)\n+      if (axes[i].axisTag == tag)\n+      {\n+        get_axis_info (i, info);\n+        return true;\n+      }\n+    return false;\n+  }\n+\n+  int normalize_axis_value (unsigned int axis_index, float v) const\n+  {\n+    hb_ot_var_axis_info_t axis;\n+    get_axis_info (axis_index, &axis);\n+\n+    v = MAX (MIN (v, axis.max_value), axis.min_value); \/* Clamp. *\/\n+\n+    if (v == axis.default_value)\n+      return 0;\n+    else if (v < axis.default_value)\n+      v = (v - axis.default_value) \/ (axis.default_value - axis.min_value);\n+    else\n+      v = (v - axis.default_value) \/ (axis.max_value - axis.default_value);\n+    return (int) (v * 16384.f + (v >= 0.f ? .5f : -.5f));\n+  }\n+\n+  unsigned int get_instance_count () const { return instanceCount; }\n+\n+  hb_ot_name_id_t get_instance_subfamily_name_id (unsigned int instance_index) const\n+  {\n+    const InstanceRecord *instance = get_instance (instance_index);\n+    if (unlikely (!instance)) return HB_OT_NAME_ID_INVALID;\n+    return instance->subfamilyNameID;\n+  }\n+\n+  hb_ot_name_id_t get_instance_postscript_name_id (unsigned int instance_index) const\n+  {\n+    const InstanceRecord *instance = get_instance (instance_index);\n+    if (unlikely (!instance)) return HB_OT_NAME_ID_INVALID;\n+    if (instanceSize >= axisCount * 4 + 6)\n+      return StructAfter<NameID> (instance->get_coordinates (axisCount));\n+    return HB_OT_NAME_ID_INVALID;\n+  }\n+\n+  unsigned int get_instance_coords (unsigned int  instance_index,\n+                                           unsigned int *coords_length, \/* IN\/OUT *\/\n+                                           float        *coords         \/* OUT *\/) const\n+  {\n+    const InstanceRecord *instance = get_instance (instance_index);\n+    if (unlikely (!instance))\n+    {\n+      if (coords_length)\n+        *coords_length = 0;\n+      return 0;\n+    }\n+\n+    if (coords_length && *coords_length)\n+    {\n+      hb_array_t<const Fixed> instanceCoords = instance->get_coordinates (axisCount)\n+                                                         .sub_array (0, *coords_length);\n+      for (unsigned int i = 0; i < instanceCoords.length; i++)\n+        coords[i] = instanceCoords.arrayZ[i].to_float ();\n+    }\n+    return axisCount;\n+  }\n+\n+  protected:\n+  hb_array_t<const AxisRecord> get_axes () const\n+  { return hb_array (&(this+firstAxis), axisCount); }\n+\n+  const InstanceRecord *get_instance (unsigned int i) const\n+  {\n+    if (unlikely (i >= instanceCount)) return nullptr;\n+   return &StructAtOffset<InstanceRecord> (&StructAfter<InstanceRecord> (get_axes ()),\n+                                           i * instanceSize);\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the fvar table\n+                                 * initially set to 0x00010000u *\/\n+  OffsetTo<AxisRecord>\n+                firstAxis;      \/* Offset in bytes from the beginning of the table\n+                                 * to the start of the AxisRecord array. *\/\n+  HBUINT16      reserved;       \/* This field is permanently reserved. Set to 2. *\/\n+  HBUINT16      axisCount;      \/* The number of variation axes in the font (the\n+                                 * number of records in the axes array). *\/\n+  HBUINT16      axisSize;       \/* The size in bytes of each VariationAxisRecord —\n+                                 * set to 20 (0x0014) for this version. *\/\n+  HBUINT16      instanceCount;  \/* The number of named instances defined in the font\n+                                 * (the number of records in the instances array). *\/\n+  HBUINT16      instanceSize;   \/* The size in bytes of each InstanceRecord — set\n+                                 * to either axisCount * sizeof(Fixed) + 4, or to\n+                                 * axisCount * sizeof(Fixed) + 6. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (16);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_VAR_FVAR_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-var-fvar-table.hh","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_VAR_HVAR_TABLE_HH\n+#define HB_OT_VAR_HVAR_TABLE_HH\n+\n+#include \"hb-ot-layout-common.hh\"\n+\n+\n+namespace OT {\n+\n+\n+struct DeltaSetIndexMap\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  c->check_range (mapDataZ.arrayZ,\n+                                  mapCount,\n+                                  get_width ()));\n+  }\n+\n+  unsigned int map (unsigned int v) const \/* Returns 16.16 outer.inner. *\/\n+  {\n+    \/* If count is zero, pass value unchanged.  This takes\n+     * care of direct mapping for advance map. *\/\n+    if (!mapCount)\n+      return v;\n+\n+    if (v >= mapCount)\n+      v = mapCount - 1;\n+\n+    unsigned int u = 0;\n+    { \/* Fetch it. *\/\n+      unsigned int w = get_width ();\n+      const HBUINT8 *p = mapDataZ.arrayZ + w * v;\n+      for (; w; w--)\n+        u = (u << 8) + *p++;\n+    }\n+\n+    { \/* Repack it. *\/\n+      unsigned int n = get_inner_bitcount ();\n+      unsigned int outer = u >> n;\n+      unsigned int inner = u & ((1 << n) - 1);\n+      u = (outer<<16) | inner;\n+    }\n+\n+    return u;\n+  }\n+\n+  protected:\n+  unsigned int get_width () const          { return ((format >> 4) & 3) + 1; }\n+\n+  unsigned int get_inner_bitcount () const { return (format & 0xF) + 1; }\n+\n+  protected:\n+  HBUINT16      format;         \/* A packed field that describes the compressed\n+                                 * representation of delta-set indices. *\/\n+  HBUINT16      mapCount;       \/* The number of mapping entries. *\/\n+  UnsizedArrayOf<HBUINT8>\n+                mapDataZ;       \/* The delta-set index mapping data. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (4, mapDataZ);\n+};\n+\n+\n+\/*\n+ * HVAR -- Horizontal Metrics Variations\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/hvar\n+ * VVAR -- Vertical Metrics Variations\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/vvar\n+ *\/\n+#define HB_OT_TAG_HVAR HB_TAG('H','V','A','R')\n+#define HB_OT_TAG_VVAR HB_TAG('V','V','A','R')\n+\n+struct HVARVVAR\n+{\n+  static constexpr hb_tag_t HVARTag = HB_OT_TAG_HVAR;\n+  static constexpr hb_tag_t VVARTag = HB_OT_TAG_VVAR;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  varStore.sanitize (c, this) &&\n+                  advMap.sanitize (c, this) &&\n+                  lsbMap.sanitize (c, this) &&\n+                  rsbMap.sanitize (c, this));\n+  }\n+\n+  float get_advance_var (hb_codepoint_t glyph,\n+                         const int *coords, unsigned int coord_count) const\n+  {\n+    unsigned int varidx = (this+advMap).map (glyph);\n+    return (this+varStore).get_delta (varidx, coords, coord_count);\n+  }\n+\n+  bool has_sidebearing_deltas () const { return lsbMap && rsbMap; }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the metrics variation table\n+                                 * initially set to 0x00010000u *\/\n+  LOffsetTo<VariationStore>\n+                varStore;       \/* Offset to item variation store table. *\/\n+  LOffsetTo<DeltaSetIndexMap>\n+                advMap;         \/* Offset to advance var-idx mapping. *\/\n+  LOffsetTo<DeltaSetIndexMap>\n+                lsbMap;         \/* Offset to lsb\/tsb var-idx mapping. *\/\n+  LOffsetTo<DeltaSetIndexMap>\n+                rsbMap;         \/* Offset to rsb\/bsb var-idx mapping. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (20);\n+};\n+\n+struct HVAR : HVARVVAR {\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_HVAR;\n+};\n+struct VVAR : HVARVVAR {\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_VVAR;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (static_cast<const HVARVVAR *> (this)->sanitize (c) &&\n+                  vorgMap.sanitize (c, this));\n+  }\n+\n+  protected:\n+  LOffsetTo<DeltaSetIndexMap>\n+                vorgMap;        \/* Offset to vertical-origin var-idx mapping. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (24);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_VAR_HVAR_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-var-hvar-table.hh","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,117 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_VAR_MVAR_TABLE_HH\n+#define HB_OT_VAR_MVAR_TABLE_HH\n+\n+#include \"hb-ot-layout-common.hh\"\n+\n+\n+namespace OT {\n+\n+\n+struct VariationValueRecord\n+{\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  Tag           valueTag;       \/* Four-byte tag identifying a font-wide measure. *\/\n+  HBUINT32              varIdx;         \/* Outer\/inner index into VariationStore item. *\/\n+\n+  public:\n+  DEFINE_SIZE_STATIC (8);\n+};\n+\n+\n+\/*\n+ * MVAR -- Metrics Variations\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/mvar\n+ *\/\n+#define HB_OT_TAG_MVAR HB_TAG('M','V','A','R')\n+\n+struct MVAR\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_MVAR;\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (version.sanitize (c) &&\n+                  likely (version.major == 1) &&\n+                  c->check_struct (this) &&\n+                  valueRecordSize >= VariationValueRecord::static_size &&\n+                  varStore.sanitize (c, this) &&\n+                  c->check_range (valuesZ.arrayZ,\n+                                  valueRecordCount,\n+                                  valueRecordSize));\n+  }\n+\n+  float get_var (hb_tag_t tag,\n+                 const int *coords, unsigned int coord_count) const\n+  {\n+    const VariationValueRecord *record;\n+    record = (VariationValueRecord *) bsearch (&tag, valuesZ.arrayZ,\n+                                               valueRecordCount, valueRecordSize,\n+                                               tag_compare);\n+    if (!record)\n+      return 0.;\n+\n+    return (this+varStore).get_delta (record->varIdx, coords, coord_count);\n+  }\n+\n+protected:\n+  static int tag_compare (const void *pa, const void *pb)\n+  {\n+    const hb_tag_t *a = (const hb_tag_t *) pa;\n+    const Tag *b = (const Tag *) pb;\n+    return b->cmp (*a);\n+  }\n+\n+  protected:\n+  FixedVersion<>version;        \/* Version of the metrics variation table\n+                                 * initially set to 0x00010000u *\/\n+  HBUINT16      reserved;       \/* Not used; set to 0. *\/\n+  HBUINT16      valueRecordSize;\/* The size in bytes of each value record —\n+                                 * must be greater than zero. *\/\n+  HBUINT16      valueRecordCount;\/* The number of value records — may be zero. *\/\n+  OffsetTo<VariationStore>\n+                varStore;       \/* Offset to item variation store table. *\/\n+  UnsizedArrayOf<HBUINT8>\n+                valuesZ;        \/* Array of value records. The records must be\n+                                 * in binary order of their valueTag field. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY (12, valuesZ);\n+};\n+\n+} \/* namespace OT *\/\n+\n+\n+#endif \/* HB_OT_VAR_MVAR_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-var-mvar-table.hh","additions":117,"deletions":0,"binary":false,"changes":117,"status":"added"},{"patch":"@@ -0,0 +1,213 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+\n+#include \"hb-ot-face.hh\"\n+#include \"hb-ot-var-avar-table.hh\"\n+#include \"hb-ot-var-fvar-table.hh\"\n+#include \"hb-ot-var-mvar-table.hh\"\n+#include \"hb-ot-var.h\"\n+\n+\n+\/**\n+ * SECTION:hb-ot-var\n+ * @title: hb-ot-var\n+ * @short_description: OpenType Font Variations\n+ * @include: hb-ot.h\n+ *\n+ * Functions for fetching information about OpenType Variable Fonts.\n+ **\/\n+\n+\n+\/*\n+ * fvar\/avar\n+ *\/\n+\n+\n+\/**\n+ * hb_ot_var_has_data:\n+ * @face: #hb_face_t to test\n+ *\n+ * This function allows to verify the presence of OpenType variation data on the face.\n+ *\n+ * Return value: true if face has a `fvar' table and false otherwise\n+ *\n+ * Since: 1.4.2\n+ **\/\n+hb_bool_t\n+hb_ot_var_has_data (hb_face_t *face)\n+{\n+  return face->table.fvar->has_data ();\n+}\n+\n+\/**\n+ * hb_ot_var_get_axis_count:\n+ *\n+ * Since: 1.4.2\n+ **\/\n+unsigned int\n+hb_ot_var_get_axis_count (hb_face_t *face)\n+{\n+  return face->table.fvar->get_axis_count ();\n+}\n+\n+\/**\n+ * hb_ot_var_get_axes:\n+ *\n+ * Since: 1.4.2\n+ * Deprecated: 2.2.0\n+ **\/\n+unsigned int\n+hb_ot_var_get_axes (hb_face_t        *face,\n+                    unsigned int      start_offset,\n+                    unsigned int     *axes_count \/* IN\/OUT *\/,\n+                    hb_ot_var_axis_t *axes_array \/* OUT *\/)\n+{\n+  return face->table.fvar->get_axes_deprecated (start_offset, axes_count, axes_array);\n+}\n+\n+\/**\n+ * hb_ot_var_find_axis:\n+ *\n+ * Since: 1.4.2\n+ * Deprecated: 2.2.0\n+ **\/\n+hb_bool_t\n+hb_ot_var_find_axis (hb_face_t        *face,\n+                     hb_tag_t          axis_tag,\n+                     unsigned int     *axis_index,\n+                     hb_ot_var_axis_t *axis_info)\n+{\n+  return face->table.fvar->find_axis_deprecated (axis_tag, axis_index, axis_info);\n+}\n+\n+\/**\n+ * hb_ot_var_get_axis_infos:\n+ *\n+ * Since: 2.2.0\n+ **\/\n+HB_EXTERN unsigned int\n+hb_ot_var_get_axis_infos (hb_face_t             *face,\n+                          unsigned int           start_offset,\n+                          unsigned int          *axes_count \/* IN\/OUT *\/,\n+                          hb_ot_var_axis_info_t *axes_array \/* OUT *\/)\n+{\n+  return face->table.fvar->get_axis_infos (start_offset, axes_count, axes_array);\n+}\n+\n+\/**\n+ * hb_ot_var_find_axis_info:\n+ *\n+ * Since: 2.2.0\n+ **\/\n+HB_EXTERN hb_bool_t\n+hb_ot_var_find_axis_info (hb_face_t             *face,\n+                          hb_tag_t               axis_tag,\n+                          hb_ot_var_axis_info_t *axis_info)\n+{\n+  return face->table.fvar->find_axis_info (axis_tag, axis_info);\n+}\n+\n+\n+\/*\n+ * Named instances.\n+ *\/\n+\n+unsigned int\n+hb_ot_var_get_named_instance_count (hb_face_t *face)\n+{\n+  return face->table.fvar->get_instance_count ();\n+}\n+\n+hb_ot_name_id_t\n+hb_ot_var_named_instance_get_subfamily_name_id (hb_face_t   *face,\n+                                                unsigned int instance_index)\n+{\n+  return face->table.fvar->get_instance_subfamily_name_id (instance_index);\n+}\n+\n+hb_ot_name_id_t\n+hb_ot_var_named_instance_get_postscript_name_id (hb_face_t  *face,\n+                                                unsigned int instance_index)\n+{\n+  return face->table.fvar->get_instance_postscript_name_id (instance_index);\n+}\n+\n+unsigned int\n+hb_ot_var_named_instance_get_design_coords (hb_face_t    *face,\n+                                            unsigned int  instance_index,\n+                                            unsigned int *coords_length, \/* IN\/OUT *\/\n+                                            float        *coords         \/* OUT *\/)\n+{\n+  return face->table.fvar->get_instance_coords (instance_index, coords_length, coords);\n+}\n+\n+\n+\/**\n+ * hb_ot_var_normalize_variations:\n+ *\n+ * Since: 1.4.2\n+ **\/\n+void\n+hb_ot_var_normalize_variations (hb_face_t            *face,\n+                                const hb_variation_t *variations, \/* IN *\/\n+                                unsigned int          variations_length,\n+                                int                  *coords, \/* OUT *\/\n+                                unsigned int          coords_length)\n+{\n+  for (unsigned int i = 0; i < coords_length; i++)\n+    coords[i] = 0;\n+\n+  const OT::fvar &fvar = *face->table.fvar;\n+  for (unsigned int i = 0; i < variations_length; i++)\n+  {\n+    hb_ot_var_axis_info_t info;\n+    if (hb_ot_var_find_axis_info (face, variations[i].tag, &info) &&\n+        info.axis_index < coords_length)\n+      coords[info.axis_index] = fvar.normalize_axis_value (info.axis_index, variations[i].value);\n+  }\n+\n+  face->table.avar->map_coords (coords, coords_length);\n+}\n+\n+\/**\n+ * hb_ot_var_normalize_coords:\n+ *\n+ * Since: 1.4.2\n+ **\/\n+void\n+hb_ot_var_normalize_coords (hb_face_t    *face,\n+                            unsigned int coords_length,\n+                            const float *design_coords, \/* IN *\/\n+                            int *normalized_coords \/* OUT *\/)\n+{\n+  const OT::fvar &fvar = *face->table.fvar;\n+  for (unsigned int i = 0; i < coords_length; i++)\n+    normalized_coords[i] = fvar.normalize_axis_value (i, design_coords[i]);\n+\n+  face->table.avar->map_coords (normalized_coords, coords_length);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-var.cc","additions":213,"deletions":0,"binary":false,"changes":213,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_H_IN\n+#error \"Include <hb-ot.h> instead.\"\n+#endif\n+\n+#ifndef HB_OT_VAR_H\n+#define HB_OT_VAR_H\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+#define HB_OT_TAG_VAR_AXIS_ITALIC       HB_TAG('i','t','a','l')\n+#define HB_OT_TAG_VAR_AXIS_OPTICAL_SIZE HB_TAG('o','p','s','z')\n+#define HB_OT_TAG_VAR_AXIS_SLANT        HB_TAG('s','l','n','t')\n+#define HB_OT_TAG_VAR_AXIS_WIDTH        HB_TAG('w','d','t','h')\n+#define HB_OT_TAG_VAR_AXIS_WEIGHT       HB_TAG('w','g','h','t')\n+\n+\n+\/*\n+ * fvar \/ avar\n+ *\/\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_var_has_data (hb_face_t *face);\n+\n+\n+\/*\n+ * Variation axes.\n+ *\/\n+\n+\n+HB_EXTERN unsigned int\n+hb_ot_var_get_axis_count (hb_face_t *face);\n+\n+\/**\n+ * hb_ot_var_axis_flags_t:\n+ * @HB_OT_VAR_AXIS_FLAG_HIDDEN: The axis should not be exposed directly in user interfaces.\n+ *\n+ * Since: 2.2.0\n+ *\/\n+typedef enum { \/*< flags >*\/\n+  HB_OT_VAR_AXIS_FLAG_HIDDEN    = 0x00000001u,\n+\n+  _HB_OT_VAR_AXIS_FLAG_MAX_VALUE= 0x7FFFFFFFu \/*< skip >*\/\n+} hb_ot_var_axis_flags_t;\n+\n+\/**\n+ * hb_ot_var_axis_info_t:\n+ *\n+ * Since: 2.2.0\n+ *\/\n+typedef struct hb_ot_var_axis_info_t\n+{\n+  unsigned int                  axis_index;\n+  hb_tag_t                      tag;\n+  hb_ot_name_id_t               name_id;\n+  hb_ot_var_axis_flags_t        flags;\n+  float                         min_value;\n+  float                         default_value;\n+  float                         max_value;\n+  \/*< private >*\/\n+  unsigned int                  reserved;\n+} hb_ot_var_axis_info_t;\n+\n+HB_EXTERN unsigned int\n+hb_ot_var_get_axis_infos (hb_face_t             *face,\n+                          unsigned int           start_offset,\n+                          unsigned int          *axes_count \/* IN\/OUT *\/,\n+                          hb_ot_var_axis_info_t *axes_array \/* OUT *\/);\n+\n+HB_EXTERN hb_bool_t\n+hb_ot_var_find_axis_info (hb_face_t             *face,\n+                          hb_tag_t               axis_tag,\n+                          hb_ot_var_axis_info_t *axis_info);\n+\n+\n+\/*\n+ * Named instances.\n+ *\/\n+\n+HB_EXTERN unsigned int\n+hb_ot_var_get_named_instance_count (hb_face_t *face);\n+\n+HB_EXTERN hb_ot_name_id_t\n+hb_ot_var_named_instance_get_subfamily_name_id (hb_face_t   *face,\n+                                                unsigned int instance_index);\n+\n+HB_EXTERN hb_ot_name_id_t\n+hb_ot_var_named_instance_get_postscript_name_id (hb_face_t  *face,\n+                                                unsigned int instance_index);\n+\n+HB_EXTERN unsigned int\n+hb_ot_var_named_instance_get_design_coords (hb_face_t    *face,\n+                                            unsigned int  instance_index,\n+                                            unsigned int *coords_length, \/* IN\/OUT *\/\n+                                            float        *coords         \/* OUT *\/);\n+\n+\n+\/*\n+ * Conversions.\n+ *\/\n+\n+HB_EXTERN void\n+hb_ot_var_normalize_variations (hb_face_t            *face,\n+                                const hb_variation_t *variations, \/* IN *\/\n+                                unsigned int          variations_length,\n+                                int                  *coords, \/* OUT *\/\n+                                unsigned int          coords_length);\n+\n+HB_EXTERN void\n+hb_ot_var_normalize_coords (hb_face_t    *face,\n+                            unsigned int coords_length,\n+                            const float *design_coords, \/* IN *\/\n+                            int *normalized_coords \/* OUT *\/);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_OT_VAR_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-var.h","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#ifndef HB_OT_VORG_TABLE_HH\n+#define HB_OT_VORG_TABLE_HH\n+\n+#include \"hb-open-type.hh\"\n+\n+\/*\n+ * VORG -- Vertical Origin Table\n+ * https:\/\/docs.microsoft.com\/en-us\/typography\/opentype\/spec\/vorg\n+ *\/\n+#define HB_OT_TAG_VORG HB_TAG('V','O','R','G')\n+\n+namespace OT {\n+\n+struct VertOriginMetric\n+{\n+  int cmp (hb_codepoint_t g) const { return glyph.cmp (g); }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this));\n+  }\n+\n+  public:\n+  GlyphID       glyph;\n+  FWORD         vertOriginY;\n+\n+  public:\n+  DEFINE_SIZE_STATIC (4);\n+};\n+\n+struct VORG\n+{\n+  static constexpr hb_tag_t tableTag = HB_OT_TAG_VORG;\n+\n+  bool has_data () const { return version.to_int (); }\n+\n+  int get_y_origin (hb_codepoint_t glyph) const\n+  {\n+    unsigned int i;\n+    if (!vertYOrigins.bfind (glyph, &i))\n+      return defaultVertOriginY;\n+    return vertYOrigins[i].vertOriginY;\n+  }\n+\n+  bool _subset (const hb_subset_plan_t *plan HB_UNUSED,\n+                const VORG *vorg_table,\n+                const hb_vector_t<VertOriginMetric> &subset_metrics,\n+                unsigned int dest_sz,\n+                void *dest) const\n+  {\n+    hb_serialize_context_t c (dest, dest_sz);\n+\n+    VORG *subset_table = c.start_serialize<VORG> ();\n+    if (unlikely (!c.extend_min (*subset_table)))\n+      return false;\n+\n+    subset_table->version.major.set (1);\n+    subset_table->version.minor.set (0);\n+\n+    subset_table->defaultVertOriginY.set (vorg_table->defaultVertOriginY);\n+    subset_table->vertYOrigins.len.set (subset_metrics.length);\n+\n+    bool success = true;\n+    if (subset_metrics.length > 0)\n+    {\n+      unsigned int  size = VertOriginMetric::static_size * subset_metrics.length;\n+      VertOriginMetric  *metrics = c.allocate_size<VertOriginMetric> (size);\n+      if (likely (metrics != nullptr))\n+        memcpy (metrics, &subset_metrics[0], size);\n+      else\n+        success = false;\n+    }\n+    c.end_serialize ();\n+\n+    return success;\n+  }\n+\n+  bool subset (hb_subset_plan_t *plan) const\n+  {\n+    hb_blob_t *vorg_blob = hb_sanitize_context_t().reference_table<VORG> (plan->source);\n+    const VORG *vorg_table = vorg_blob->as<VORG> ();\n+\n+    \/* count the number of glyphs to be included in the subset table *\/\n+    hb_vector_t<VertOriginMetric> subset_metrics;\n+    subset_metrics.init ();\n+    unsigned int glyph = 0;\n+    unsigned int i = 0;\n+    while ((glyph < plan->glyphs.length) && (i < vertYOrigins.len))\n+    {\n+      if (plan->glyphs[glyph] > vertYOrigins[i].glyph)\n+        i++;\n+      else if (plan->glyphs[glyph] < vertYOrigins[i].glyph)\n+        glyph++;\n+      else\n+      {\n+        VertOriginMetric *metrics = subset_metrics.push ();\n+        metrics->glyph.set (glyph);\n+        metrics->vertOriginY.set (vertYOrigins[i].vertOriginY);\n+        glyph++;\n+        i++;\n+      }\n+    }\n+\n+    \/* alloc the new table *\/\n+    unsigned int dest_sz = VORG::min_size + VertOriginMetric::static_size * subset_metrics.length;\n+    void *dest = (void *) malloc (dest_sz);\n+    if (unlikely (!dest))\n+    {\n+      subset_metrics.fini ();\n+      hb_blob_destroy (vorg_blob);\n+      return false;\n+    }\n+\n+    \/* serialize the new table *\/\n+    if (!_subset (plan, vorg_table, subset_metrics, dest_sz, dest))\n+    {\n+      subset_metrics.fini ();\n+      free (dest);\n+      hb_blob_destroy (vorg_blob);\n+      return false;\n+    }\n+\n+    hb_blob_t *result = hb_blob_create ((const char *)dest,\n+                                        dest_sz,\n+                                        HB_MEMORY_MODE_READONLY,\n+                                        dest,\n+                                        free);\n+    bool success = plan->add_table (HB_OT_TAG_VORG, result);\n+    hb_blob_destroy (result);\n+    subset_metrics.fini ();\n+    hb_blob_destroy (vorg_blob);\n+    return success;\n+  }\n+\n+  bool sanitize (hb_sanitize_context_t *c) const\n+  {\n+    TRACE_SANITIZE (this);\n+    return_trace (c->check_struct (this) &&\n+                  version.major == 1 &&\n+                  vertYOrigins.sanitize (c));\n+  }\n+\n+  protected:\n+  FixedVersion<>        version;                \/* Version of VORG table. Set to 0x00010000u. *\/\n+  FWORD                 defaultVertOriginY;     \/* The default vertical origin. *\/\n+  SortedArrayOf<VertOriginMetric>\n+                        vertYOrigins;           \/* The array of vertical origins. *\/\n+\n+  public:\n+  DEFINE_SIZE_ARRAY(8, vertYOrigins);\n+};\n+} \/* namespace OT *\/\n+\n+#endif \/* HB_OT_VORG_TABLE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot-vorg-table.hh","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_OT_H\n+#define HB_OT_H\n+#define HB_OT_H_IN\n+\n+#include \"hb.h\"\n+\n+#include \"hb-ot-color.h\"\n+#include \"hb-ot-deprecated.h\"\n+#include \"hb-ot-font.h\"\n+#include \"hb-ot-layout.h\"\n+#include \"hb-ot-math.h\"\n+#include \"hb-ot-name.h\"\n+#include \"hb-ot-shape.h\"\n+#include \"hb-ot-var.h\"\n+\n+HB_BEGIN_DECLS\n+\n+HB_END_DECLS\n+\n+#undef HB_OT_H_IN\n+#endif \/* HB_OT_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ot.h","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-set-digest.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-set-digest.hh","status":"copied"},{"patch":"@@ -0,0 +1,539 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-set.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-set\n+ * @title: hb-set\n+ * @short_description: Object representing a set of integers\n+ * @include: hb.h\n+ *\n+ * Set objects represent a mathematical set of integer values.  They are\n+ * used in non-shaping API to query certain set of characters or glyphs,\n+ * or other integer values.\n+ **\/\n+\n+\n+\/**\n+ * hb_set_create: (Xconstructor)\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_set_t *\n+hb_set_create ()\n+{\n+  hb_set_t *set;\n+\n+  if (!(set = hb_object_create<hb_set_t> ()))\n+    return hb_set_get_empty ();\n+\n+  set->init_shallow ();\n+\n+  return set;\n+}\n+\n+\/**\n+ * hb_set_get_empty:\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_set_t *\n+hb_set_get_empty ()\n+{\n+  return const_cast<hb_set_t *> (&Null(hb_set_t));\n+}\n+\n+\/**\n+ * hb_set_reference: (skip)\n+ * @set: a set.\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_set_t *\n+hb_set_reference (hb_set_t *set)\n+{\n+  return hb_object_reference (set);\n+}\n+\n+\/**\n+ * hb_set_destroy: (skip)\n+ * @set: a set.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_destroy (hb_set_t *set)\n+{\n+  if (!hb_object_destroy (set)) return;\n+\n+  set->fini_shallow ();\n+\n+  free (set);\n+}\n+\n+\/**\n+ * hb_set_set_user_data: (skip)\n+ * @set: a set.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_set_set_user_data (hb_set_t           *set,\n+                      hb_user_data_key_t *key,\n+                      void *              data,\n+                      hb_destroy_func_t   destroy,\n+                      hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (set, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_set_get_user_data: (skip)\n+ * @set: a set.\n+ * @key:\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void *\n+hb_set_get_user_data (hb_set_t           *set,\n+                      hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (set, key);\n+}\n+\n+\n+\/**\n+ * hb_set_allocation_successful:\n+ * @set: a set.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_set_allocation_successful (const hb_set_t  *set)\n+{\n+  return set->successful;\n+}\n+\n+\/**\n+ * hb_set_clear:\n+ * @set: a set.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_clear (hb_set_t *set)\n+{\n+  set->clear ();\n+}\n+\n+\/**\n+ * hb_set_is_empty:\n+ * @set: a set.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_set_is_empty (const hb_set_t *set)\n+{\n+  return set->is_empty ();\n+}\n+\n+\/**\n+ * hb_set_has:\n+ * @set: a set.\n+ * @codepoint:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_set_has (const hb_set_t *set,\n+            hb_codepoint_t  codepoint)\n+{\n+  return set->has (codepoint);\n+}\n+\n+\/**\n+ * hb_set_add:\n+ * @set: a set.\n+ * @codepoint:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_add (hb_set_t       *set,\n+            hb_codepoint_t  codepoint)\n+{\n+  set->add (codepoint);\n+}\n+\n+\/**\n+ * hb_set_add_range:\n+ * @set: a set.\n+ * @first:\n+ * @last:\n+ *\n+ *\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_set_add_range (hb_set_t       *set,\n+                  hb_codepoint_t  first,\n+                  hb_codepoint_t  last)\n+{\n+  set->add_range (first, last);\n+}\n+\n+\/**\n+ * hb_set_del:\n+ * @set: a set.\n+ * @codepoint:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_del (hb_set_t       *set,\n+            hb_codepoint_t  codepoint)\n+{\n+  set->del (codepoint);\n+}\n+\n+\/**\n+ * hb_set_del_range:\n+ * @set: a set.\n+ * @first:\n+ * @last:\n+ *\n+ *\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_set_del_range (hb_set_t       *set,\n+                  hb_codepoint_t  first,\n+                  hb_codepoint_t  last)\n+{\n+  set->del_range (first, last);\n+}\n+\n+\/**\n+ * hb_set_is_equal:\n+ * @set: a set.\n+ * @other: other set.\n+ *\n+ *\n+ *\n+ * Return value: %TRUE if the two sets are equal, %FALSE otherwise.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_set_is_equal (const hb_set_t *set,\n+                 const hb_set_t *other)\n+{\n+  return set->is_equal (other);\n+}\n+\n+\/**\n+ * hb_set_is_subset:\n+ * @set: a set.\n+ * @larger_set: other set.\n+ *\n+ *\n+ *\n+ * Return value: %TRUE if the @set is a subset of (or equal to) @larger_set, %FALSE otherwise.\n+ *\n+ * Since: 1.8.1\n+ **\/\n+hb_bool_t\n+hb_set_is_subset (const hb_set_t *set,\n+                  const hb_set_t *larger_set)\n+{\n+  return set->is_subset (larger_set);\n+}\n+\n+\/**\n+ * hb_set_set:\n+ * @set: a set.\n+ * @other:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_set (hb_set_t       *set,\n+            const hb_set_t *other)\n+{\n+  set->set (other);\n+}\n+\n+\/**\n+ * hb_set_union:\n+ * @set: a set.\n+ * @other:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_union (hb_set_t       *set,\n+              const hb_set_t *other)\n+{\n+  set->union_ (other);\n+}\n+\n+\/**\n+ * hb_set_intersect:\n+ * @set: a set.\n+ * @other:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_intersect (hb_set_t       *set,\n+                  const hb_set_t *other)\n+{\n+  set->intersect (other);\n+}\n+\n+\/**\n+ * hb_set_subtract:\n+ * @set: a set.\n+ * @other:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_subtract (hb_set_t       *set,\n+                 const hb_set_t *other)\n+{\n+  set->subtract (other);\n+}\n+\n+\/**\n+ * hb_set_symmetric_difference:\n+ * @set: a set.\n+ * @other:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_set_symmetric_difference (hb_set_t       *set,\n+                             const hb_set_t *other)\n+{\n+  set->symmetric_difference (other);\n+}\n+\n+\/**\n+ * hb_set_invert:\n+ * @set: a set.\n+ *\n+ *\n+ *\n+ * Since: 0.9.10\n+ *\n+ * Deprecated: 1.6.1\n+ **\/\n+void\n+hb_set_invert (hb_set_t *set HB_UNUSED)\n+{\n+}\n+\n+\/**\n+ * hb_set_get_population:\n+ * @set: a set.\n+ *\n+ * Returns the number of numbers in the set.\n+ *\n+ * Return value: set population.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+unsigned int\n+hb_set_get_population (const hb_set_t *set)\n+{\n+  return set->get_population ();\n+}\n+\n+\/**\n+ * hb_set_get_min:\n+ * @set: a set.\n+ *\n+ * Finds the minimum number in the set.\n+ *\n+ * Return value: minimum of the set, or %HB_SET_VALUE_INVALID if set is empty.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_codepoint_t\n+hb_set_get_min (const hb_set_t *set)\n+{\n+  return set->get_min ();\n+}\n+\n+\/**\n+ * hb_set_get_max:\n+ * @set: a set.\n+ *\n+ * Finds the maximum number in the set.\n+ *\n+ * Return value: minimum of the set, or %HB_SET_VALUE_INVALID if set is empty.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_codepoint_t\n+hb_set_get_max (const hb_set_t *set)\n+{\n+  return set->get_max ();\n+}\n+\n+\/**\n+ * hb_set_next:\n+ * @set: a set.\n+ * @codepoint: (inout):\n+ *\n+ * Gets the next number in @set that is greater than current value of @codepoint.\n+ *\n+ * Set @codepoint to %HB_SET_VALUE_INVALID to get started.\n+ *\n+ * Return value: whether there was a next value.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_set_next (const hb_set_t *set,\n+             hb_codepoint_t *codepoint)\n+{\n+  return set->next (codepoint);\n+}\n+\n+\/**\n+ * hb_set_previous:\n+ * @set: a set.\n+ * @codepoint: (inout):\n+ *\n+ * Gets the previous number in @set that is slower than current value of @codepoint.\n+ *\n+ * Set @codepoint to %HB_SET_VALUE_INVALID to get started.\n+ *\n+ * Return value: whether there was a previous value.\n+ *\n+ * Since: 1.8.0\n+ **\/\n+hb_bool_t\n+hb_set_previous (const hb_set_t *set,\n+                 hb_codepoint_t *codepoint)\n+{\n+  return set->previous (codepoint);\n+}\n+\n+\/**\n+ * hb_set_next_range:\n+ * @set: a set.\n+ * @first: (out): output first codepoint in the range.\n+ * @last: (inout): input current last and output last codepoint in the range.\n+ *\n+ * Gets the next consecutive range of numbers in @set that\n+ * are greater than current value of @last.\n+ *\n+ * Set @last to %HB_SET_VALUE_INVALID to get started.\n+ *\n+ * Return value: whether there was a next range.\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_set_next_range (const hb_set_t *set,\n+                   hb_codepoint_t *first,\n+                   hb_codepoint_t *last)\n+{\n+  return set->next_range (first, last);\n+}\n+\n+\/**\n+ * hb_set_previous_range:\n+ * @set: a set.\n+ * @first: (inout): input current first and output first codepoint in the range.\n+ * @last: (out): output last codepoint in the range.\n+ *\n+ * Gets the previous consecutive range of numbers in @set that\n+ * are greater than current value of @last.\n+ *\n+ * Set @first to %HB_SET_VALUE_INVALID to get started.\n+ *\n+ * Return value: whether there was a previous range.\n+ *\n+ * Since: 1.8.0\n+ **\/\n+hb_bool_t\n+hb_set_previous_range (const hb_set_t *set,\n+                       hb_codepoint_t *first,\n+                       hb_codepoint_t *last)\n+{\n+  return set->previous_range (first, last);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-set.cc","additions":539,"deletions":0,"binary":false,"changes":539,"status":"added"},{"patch":"@@ -0,0 +1,167 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_SET_H\n+#define HB_SET_H\n+\n+#include \"hb-common.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/*\n+ * Since: 0.9.21\n+ *\/\n+#define HB_SET_VALUE_INVALID ((hb_codepoint_t) -1)\n+\n+typedef struct hb_set_t hb_set_t;\n+\n+\n+HB_EXTERN hb_set_t *\n+hb_set_create (void);\n+\n+HB_EXTERN hb_set_t *\n+hb_set_get_empty (void);\n+\n+HB_EXTERN hb_set_t *\n+hb_set_reference (hb_set_t *set);\n+\n+HB_EXTERN void\n+hb_set_destroy (hb_set_t *set);\n+\n+HB_EXTERN hb_bool_t\n+hb_set_set_user_data (hb_set_t           *set,\n+                      hb_user_data_key_t *key,\n+                      void *              data,\n+                      hb_destroy_func_t   destroy,\n+                      hb_bool_t           replace);\n+\n+HB_EXTERN void *\n+hb_set_get_user_data (hb_set_t           *set,\n+                      hb_user_data_key_t *key);\n+\n+\n+\/* Returns false if allocation has failed before *\/\n+HB_EXTERN hb_bool_t\n+hb_set_allocation_successful (const hb_set_t *set);\n+\n+HB_EXTERN void\n+hb_set_clear (hb_set_t *set);\n+\n+HB_EXTERN hb_bool_t\n+hb_set_is_empty (const hb_set_t *set);\n+\n+HB_EXTERN hb_bool_t\n+hb_set_has (const hb_set_t *set,\n+            hb_codepoint_t  codepoint);\n+\n+HB_EXTERN void\n+hb_set_add (hb_set_t       *set,\n+            hb_codepoint_t  codepoint);\n+\n+HB_EXTERN void\n+hb_set_add_range (hb_set_t       *set,\n+                  hb_codepoint_t  first,\n+                  hb_codepoint_t  last);\n+\n+HB_EXTERN void\n+hb_set_del (hb_set_t       *set,\n+            hb_codepoint_t  codepoint);\n+\n+HB_EXTERN void\n+hb_set_del_range (hb_set_t       *set,\n+                  hb_codepoint_t  first,\n+                  hb_codepoint_t  last);\n+\n+HB_EXTERN hb_bool_t\n+hb_set_is_equal (const hb_set_t *set,\n+                 const hb_set_t *other);\n+\n+HB_EXTERN hb_bool_t\n+hb_set_is_subset (const hb_set_t *set,\n+                  const hb_set_t *larger_set);\n+\n+HB_EXTERN void\n+hb_set_set (hb_set_t       *set,\n+            const hb_set_t *other);\n+\n+HB_EXTERN void\n+hb_set_union (hb_set_t       *set,\n+              const hb_set_t *other);\n+\n+HB_EXTERN void\n+hb_set_intersect (hb_set_t       *set,\n+                  const hb_set_t *other);\n+\n+HB_EXTERN void\n+hb_set_subtract (hb_set_t       *set,\n+                 const hb_set_t *other);\n+\n+HB_EXTERN void\n+hb_set_symmetric_difference (hb_set_t       *set,\n+                             const hb_set_t *other);\n+\n+HB_EXTERN unsigned int\n+hb_set_get_population (const hb_set_t *set);\n+\n+\/* Returns HB_SET_VALUE_INVALID if set empty. *\/\n+HB_EXTERN hb_codepoint_t\n+hb_set_get_min (const hb_set_t *set);\n+\n+\/* Returns HB_SET_VALUE_INVALID if set empty. *\/\n+HB_EXTERN hb_codepoint_t\n+hb_set_get_max (const hb_set_t *set);\n+\n+\/* Pass HB_SET_VALUE_INVALID in to get started. *\/\n+HB_EXTERN hb_bool_t\n+hb_set_next (const hb_set_t *set,\n+             hb_codepoint_t *codepoint);\n+\n+\/* Pass HB_SET_VALUE_INVALID in to get started. *\/\n+HB_EXTERN hb_bool_t\n+hb_set_previous (const hb_set_t *set,\n+                 hb_codepoint_t *codepoint);\n+\n+\/* Pass HB_SET_VALUE_INVALID for first and last to get started. *\/\n+HB_EXTERN hb_bool_t\n+hb_set_next_range (const hb_set_t *set,\n+                   hb_codepoint_t *first,\n+                   hb_codepoint_t *last);\n+\n+\/* Pass HB_SET_VALUE_INVALID for first and last to get started. *\/\n+HB_EXTERN hb_bool_t\n+hb_set_previous_range (const hb_set_t *set,\n+                       hb_codepoint_t *first,\n+                       hb_codepoint_t *last);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_SET_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-set.h","additions":167,"deletions":0,"binary":false,"changes":167,"status":"added"},{"patch":"@@ -0,0 +1,738 @@\n+\/*\n+ * Copyright © 2012,2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_SET_HH\n+#define HB_SET_HH\n+\n+#include \"hb.hh\"\n+\n+\n+\/*\n+ * hb_set_t\n+ *\/\n+\n+\/* TODO Keep a free-list so we can free pages that are completely zeroed.  At that\n+ * point maybe also use a sentinel value for \"all-1\" pages? *\/\n+\n+struct hb_set_t\n+{\n+  HB_NO_COPY_ASSIGN (hb_set_t);\n+  hb_set_t ()  { init (); }\n+  ~hb_set_t () { fini (); }\n+\n+  struct page_map_t\n+  {\n+    int cmp (const page_map_t &o) const { return (int) o.major - (int) major; }\n+\n+    uint32_t major;\n+    uint32_t index;\n+  };\n+\n+  struct page_t\n+  {\n+    void init0 () { v.clear (); }\n+    void init1 () { v.clear (0xFF); }\n+\n+    unsigned int len () const\n+    { return ARRAY_LENGTH_CONST (v); }\n+\n+    bool is_empty () const\n+    {\n+      for (unsigned int i = 0; i < len (); i++)\n+        if (v[i])\n+          return false;\n+      return true;\n+    }\n+\n+    void add (hb_codepoint_t g) { elt (g) |= mask (g); }\n+    void del (hb_codepoint_t g) { elt (g) &= ~mask (g); }\n+    bool has (hb_codepoint_t g) const { return !!(elt (g) & mask (g)); }\n+\n+    void add_range (hb_codepoint_t a, hb_codepoint_t b)\n+    {\n+      elt_t *la = &elt (a);\n+      elt_t *lb = &elt (b);\n+      if (la == lb)\n+        *la |= (mask (b) << 1) - mask(a);\n+      else\n+      {\n+        *la |= ~(mask (a) - 1);\n+        la++;\n+\n+        memset (la, 0xff, (char *) lb - (char *) la);\n+\n+        *lb |= ((mask (b) << 1) - 1);\n+      }\n+    }\n+\n+    bool is_equal (const page_t *other) const\n+    {\n+      return 0 == hb_memcmp (&v, &other->v, sizeof (v));\n+    }\n+\n+    unsigned int get_population () const\n+    {\n+      unsigned int pop = 0;\n+      for (unsigned int i = 0; i < len (); i++)\n+        pop += hb_popcount (v[i]);\n+      return pop;\n+    }\n+\n+    bool next (hb_codepoint_t *codepoint) const\n+    {\n+      unsigned int m = (*codepoint + 1) & MASK;\n+      if (!m)\n+      {\n+        *codepoint = INVALID;\n+        return false;\n+      }\n+      unsigned int i = m \/ ELT_BITS;\n+      unsigned int j = m & ELT_MASK;\n+\n+      const elt_t vv = v[i] & ~((elt_t (1) << j) - 1);\n+      for (const elt_t *p = &vv; i < len (); p = &v[++i])\n+        if (*p)\n+        {\n+          *codepoint = i * ELT_BITS + elt_get_min (*p);\n+          return true;\n+        }\n+\n+      *codepoint = INVALID;\n+      return false;\n+    }\n+    bool previous (hb_codepoint_t *codepoint) const\n+    {\n+      unsigned int m = (*codepoint - 1) & MASK;\n+      if (m == MASK)\n+      {\n+        *codepoint = INVALID;\n+        return false;\n+      }\n+      unsigned int i = m \/ ELT_BITS;\n+      unsigned int j = m & ELT_MASK;\n+\n+      const elt_t vv = v[i] & ((elt_t (1) << (j + 1)) - 1);\n+      for (const elt_t *p = &vv; (int) i >= 0; p = &v[--i])\n+        if (*p)\n+        {\n+          *codepoint = i * ELT_BITS + elt_get_max (*p);\n+          return true;\n+        }\n+\n+      *codepoint = INVALID;\n+      return false;\n+    }\n+    hb_codepoint_t get_min () const\n+    {\n+      for (unsigned int i = 0; i < len (); i++)\n+        if (v[i])\n+          return i * ELT_BITS + elt_get_min (v[i]);\n+      return INVALID;\n+    }\n+    hb_codepoint_t get_max () const\n+    {\n+      for (int i = len () - 1; i >= 0; i--)\n+        if (v[i])\n+          return i * ELT_BITS + elt_get_max (v[i]);\n+      return 0;\n+    }\n+\n+    typedef unsigned long long elt_t;\n+    static constexpr unsigned PAGE_BITS = 512;\n+    static_assert ((PAGE_BITS & ((PAGE_BITS) - 1)) == 0, \"\");\n+\n+    static unsigned int elt_get_min (const elt_t &elt) { return hb_ctz (elt); }\n+    static unsigned int elt_get_max (const elt_t &elt) { return hb_bit_storage (elt) - 1; }\n+\n+    typedef hb_vector_size_t<elt_t, PAGE_BITS \/ 8> vector_t;\n+\n+    static constexpr unsigned ELT_BITS = sizeof (elt_t) * 8;\n+    static constexpr unsigned ELT_MASK = ELT_BITS - 1;\n+    static constexpr unsigned BITS = sizeof (vector_t) * 8;\n+    static constexpr unsigned MASK = BITS - 1;\n+    static_assert ((unsigned) PAGE_BITS == (unsigned) BITS, \"\");\n+\n+    elt_t &elt (hb_codepoint_t g) { return v[(g & MASK) \/ ELT_BITS]; }\n+    elt_t const &elt (hb_codepoint_t g) const { return v[(g & MASK) \/ ELT_BITS]; }\n+    elt_t mask (hb_codepoint_t g) const { return elt_t (1) << (g & ELT_MASK); }\n+\n+    vector_t v;\n+  };\n+  static_assert (page_t::PAGE_BITS == sizeof (page_t) * 8, \"\");\n+\n+  hb_object_header_t header;\n+  bool successful; \/* Allocations successful *\/\n+  mutable unsigned int population;\n+  hb_vector_t<page_map_t> page_map;\n+  hb_vector_t<page_t> pages;\n+\n+  void init_shallow ()\n+  {\n+    successful = true;\n+    population = 0;\n+    page_map.init ();\n+    pages.init ();\n+  }\n+  void init ()\n+  {\n+    hb_object_init (this);\n+    init_shallow ();\n+  }\n+  void fini_shallow ()\n+  {\n+    population = 0;\n+    page_map.fini ();\n+    pages.fini ();\n+  }\n+  void fini ()\n+  {\n+    hb_object_fini (this);\n+    fini_shallow ();\n+  }\n+\n+  bool in_error () const { return !successful; }\n+\n+  bool resize (unsigned int count)\n+  {\n+    if (unlikely (!successful)) return false;\n+    if (!pages.resize (count) || !page_map.resize (count))\n+    {\n+      pages.resize (page_map.length);\n+      successful = false;\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  void clear ()\n+  {\n+    if (unlikely (hb_object_is_immutable (this)))\n+      return;\n+    successful = true;\n+    population = 0;\n+    page_map.resize (0);\n+    pages.resize (0);\n+  }\n+  bool is_empty () const\n+  {\n+    unsigned int count = pages.length;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!pages[i].is_empty ())\n+        return false;\n+    return true;\n+  }\n+\n+  void dirty () { population = (unsigned int) -1; }\n+\n+  void add (hb_codepoint_t g)\n+  {\n+    if (unlikely (!successful)) return;\n+    if (unlikely (g == INVALID)) return;\n+    dirty ();\n+    page_t *page = page_for_insert (g); if (unlikely (!page)) return;\n+    page->add (g);\n+  }\n+  bool add_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    if (unlikely (!successful)) return true; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/657 *\/\n+    if (unlikely (a > b || a == INVALID || b == INVALID)) return false;\n+    dirty ();\n+    unsigned int ma = get_major (a);\n+    unsigned int mb = get_major (b);\n+    if (ma == mb)\n+    {\n+      page_t *page = page_for_insert (a); if (unlikely (!page)) return false;\n+      page->add_range (a, b);\n+    }\n+    else\n+    {\n+      page_t *page = page_for_insert (a); if (unlikely (!page)) return false;\n+      page->add_range (a, major_start (ma + 1) - 1);\n+\n+      for (unsigned int m = ma + 1; m < mb; m++)\n+      {\n+        page = page_for_insert (major_start (m)); if (unlikely (!page)) return false;\n+        page->init1 ();\n+      }\n+\n+      page = page_for_insert (b); if (unlikely (!page)) return false;\n+      page->add_range (major_start (mb), b);\n+    }\n+    return true;\n+  }\n+\n+  template <typename T>\n+  void add_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  {\n+    if (unlikely (!successful)) return;\n+    if (!count) return;\n+    dirty ();\n+    hb_codepoint_t g = *array;\n+    while (count)\n+    {\n+      unsigned int m = get_major (g);\n+      page_t *page = page_for_insert (g); if (unlikely (!page)) return;\n+      unsigned int start = major_start (m);\n+      unsigned int end = major_start (m + 1);\n+      do\n+      {\n+        page->add (g);\n+\n+        array = (const T *) ((const char *) array + stride);\n+        count--;\n+      }\n+      while (count && (g = *array, start <= g && g < end));\n+    }\n+  }\n+\n+  \/* Might return false if array looks unsorted.\n+   * Used for faster rejection of corrupt data. *\/\n+  template <typename T>\n+  bool add_sorted_array (const T *array, unsigned int count, unsigned int stride=sizeof(T))\n+  {\n+    if (unlikely (!successful)) return true; \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/657 *\/\n+    if (!count) return true;\n+    dirty ();\n+    hb_codepoint_t g = *array;\n+    hb_codepoint_t last_g = g;\n+    while (count)\n+    {\n+      unsigned int m = get_major (g);\n+      page_t *page = page_for_insert (g); if (unlikely (!page)) return false;\n+      unsigned int end = major_start (m + 1);\n+      do\n+      {\n+        \/* If we try harder we can change the following comparison to <=;\n+         * Not sure if it's worth it. *\/\n+        if (g < last_g) return false;\n+        last_g = g;\n+        page->add (g);\n+\n+        array = (const T *) ((const char *) array + stride);\n+        count--;\n+      }\n+      while (count && (g = *array, g < end));\n+    }\n+    return true;\n+  }\n+\n+  void del (hb_codepoint_t g)\n+  {\n+    \/* TODO perform op even if !successful. *\/\n+    if (unlikely (!successful)) return;\n+    page_t *page = page_for (g);\n+    if (!page)\n+      return;\n+    dirty ();\n+    page->del (g);\n+  }\n+  void del_range (hb_codepoint_t a, hb_codepoint_t b)\n+  {\n+    \/* TODO perform op even if !successful. *\/\n+    \/* TODO Optimize, like add_range(). *\/\n+    if (unlikely (!successful)) return;\n+    for (unsigned int i = a; i < b + 1; i++)\n+      del (i);\n+  }\n+  bool has (hb_codepoint_t g) const\n+  {\n+    const page_t *page = page_for (g);\n+    if (!page)\n+      return false;\n+    return page->has (g);\n+  }\n+  bool intersects (hb_codepoint_t first,\n+                          hb_codepoint_t last) const\n+  {\n+    hb_codepoint_t c = first - 1;\n+    return next (&c) && c <= last;\n+  }\n+  void set (const hb_set_t *other)\n+  {\n+    if (unlikely (!successful)) return;\n+    unsigned int count = other->pages.length;\n+    if (!resize (count))\n+      return;\n+    population = other->population;\n+    memcpy ((void *) pages, (const void *) other->pages, count * pages.item_size);\n+    memcpy ((void *) page_map, (const void *) other->page_map, count * page_map.item_size);\n+  }\n+\n+  bool is_equal (const hb_set_t *other) const\n+  {\n+    if (get_population () != other->get_population ())\n+      return false;\n+\n+    unsigned int na = pages.length;\n+    unsigned int nb = other->pages.length;\n+\n+    unsigned int a = 0, b = 0;\n+    for (; a < na && b < nb; )\n+    {\n+      if (page_at (a).is_empty ()) { a++; continue; }\n+      if (other->page_at (b).is_empty ()) { b++; continue; }\n+      if (page_map[a].major != other->page_map[b].major ||\n+          !page_at (a).is_equal (&other->page_at (b)))\n+        return false;\n+      a++;\n+      b++;\n+    }\n+    for (; a < na; a++)\n+      if (!page_at (a).is_empty ()) { return false; }\n+    for (; b < nb; b++)\n+      if (!other->page_at (b).is_empty ()) { return false; }\n+\n+    return true;\n+  }\n+\n+  bool is_subset (const hb_set_t *larger_set) const\n+  {\n+    if (get_population () > larger_set->get_population ())\n+      return false;\n+\n+    \/* TODO Optimize to use pages. *\/\n+    hb_codepoint_t c = INVALID;\n+    while (next (&c))\n+      if (!larger_set->has (c))\n+        return false;\n+\n+    return true;\n+  }\n+\n+  template <class Op>\n+  void process (const hb_set_t *other)\n+  {\n+    if (unlikely (!successful)) return;\n+\n+    dirty ();\n+\n+    unsigned int na = pages.length;\n+    unsigned int nb = other->pages.length;\n+    unsigned int next_page = na;\n+\n+    unsigned int count = 0, newCount = 0;\n+    unsigned int a = 0, b = 0;\n+    for (; a < na && b < nb; )\n+    {\n+      if (page_map[a].major == other->page_map[b].major)\n+      {\n+        count++;\n+        a++;\n+        b++;\n+      }\n+      else if (page_map[a].major < other->page_map[b].major)\n+      {\n+        if (Op::passthru_left)\n+          count++;\n+        a++;\n+      }\n+      else\n+      {\n+        if (Op::passthru_right)\n+          count++;\n+        b++;\n+      }\n+    }\n+    if (Op::passthru_left)\n+      count += na - a;\n+    if (Op::passthru_right)\n+      count += nb - b;\n+\n+    if (count > pages.length)\n+      if (!resize (count))\n+        return;\n+    newCount = count;\n+\n+    \/* Process in-place backward. *\/\n+    a = na;\n+    b = nb;\n+    for (; a && b; )\n+    {\n+      if (page_map[a - 1].major == other->page_map[b - 1].major)\n+      {\n+        a--;\n+        b--;\n+        count--;\n+        page_map[count] = page_map[a];\n+        Op::process (page_at (count).v, page_at (a).v, other->page_at (b).v);\n+      }\n+      else if (page_map[a - 1].major > other->page_map[b - 1].major)\n+      {\n+        a--;\n+        if (Op::passthru_left)\n+        {\n+          count--;\n+          page_map[count] = page_map[a];\n+        }\n+      }\n+      else\n+      {\n+        b--;\n+        if (Op::passthru_right)\n+        {\n+          count--;\n+          page_map[count].major = other->page_map[b].major;\n+          page_map[count].index = next_page++;\n+          page_at (count).v = other->page_at (b).v;\n+        }\n+      }\n+    }\n+    if (Op::passthru_left)\n+      while (a)\n+      {\n+        a--;\n+        count--;\n+        page_map[count] = page_map [a];\n+      }\n+    if (Op::passthru_right)\n+      while (b)\n+      {\n+        b--;\n+        count--;\n+        page_map[count].major = other->page_map[b].major;\n+        page_map[count].index = next_page++;\n+        page_at (count).v = other->page_at (b).v;\n+      }\n+    assert (!count);\n+    if (pages.length > newCount)\n+      resize (newCount);\n+  }\n+\n+  void union_ (const hb_set_t *other)\n+  {\n+    process<HbOpOr> (other);\n+  }\n+  void intersect (const hb_set_t *other)\n+  {\n+    process<HbOpAnd> (other);\n+  }\n+  void subtract (const hb_set_t *other)\n+  {\n+    process<HbOpMinus> (other);\n+  }\n+  void symmetric_difference (const hb_set_t *other)\n+  {\n+    process<HbOpXor> (other);\n+  }\n+  bool next (hb_codepoint_t *codepoint) const\n+  {\n+    if (unlikely (*codepoint == INVALID)) {\n+      *codepoint = get_min ();\n+      return *codepoint != INVALID;\n+    }\n+\n+    page_map_t map = {get_major (*codepoint), 0};\n+    unsigned int i;\n+    page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST);\n+    if (i < page_map.length && page_map[i].major == map.major)\n+    {\n+      if (pages[page_map[i].index].next (codepoint))\n+      {\n+        *codepoint += page_map[i].major * page_t::PAGE_BITS;\n+        return true;\n+      }\n+      i++;\n+    }\n+    for (; i < page_map.length; i++)\n+    {\n+      hb_codepoint_t m = pages[page_map[i].index].get_min ();\n+      if (m != INVALID)\n+      {\n+        *codepoint = page_map[i].major * page_t::PAGE_BITS + m;\n+        return true;\n+      }\n+    }\n+    *codepoint = INVALID;\n+    return false;\n+  }\n+  bool previous (hb_codepoint_t *codepoint) const\n+  {\n+    if (unlikely (*codepoint == INVALID)) {\n+      *codepoint = get_max ();\n+      return *codepoint != INVALID;\n+    }\n+\n+    page_map_t map = {get_major (*codepoint), 0};\n+    unsigned int i;\n+    page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST);\n+    if (i < page_map.length && page_map[i].major == map.major)\n+    {\n+      if (pages[page_map[i].index].previous (codepoint))\n+      {\n+        *codepoint += page_map[i].major * page_t::PAGE_BITS;\n+        return true;\n+      }\n+    }\n+    i--;\n+    for (; (int) i >= 0; i--)\n+    {\n+      hb_codepoint_t m = pages[page_map[i].index].get_max ();\n+      if (m != INVALID)\n+      {\n+        *codepoint = page_map[i].major * page_t::PAGE_BITS + m;\n+        return true;\n+      }\n+    }\n+    *codepoint = INVALID;\n+    return false;\n+  }\n+  bool next_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n+  {\n+    hb_codepoint_t i;\n+\n+    i = *last;\n+    if (!next (&i))\n+    {\n+      *last = *first = INVALID;\n+      return false;\n+    }\n+\n+    \/* TODO Speed up. *\/\n+    *last = *first = i;\n+    while (next (&i) && i == *last + 1)\n+      (*last)++;\n+\n+    return true;\n+  }\n+  bool previous_range (hb_codepoint_t *first, hb_codepoint_t *last) const\n+  {\n+    hb_codepoint_t i;\n+\n+    i = *first;\n+    if (!previous (&i))\n+    {\n+      *last = *first = INVALID;\n+      return false;\n+    }\n+\n+    \/* TODO Speed up. *\/\n+    *last = *first = i;\n+    while (previous (&i) && i == *first - 1)\n+      (*first)--;\n+\n+    return true;\n+  }\n+\n+  unsigned int get_population () const\n+  {\n+    if (population != (unsigned int) -1)\n+      return population;\n+\n+    unsigned int pop = 0;\n+    unsigned int count = pages.length;\n+    for (unsigned int i = 0; i < count; i++)\n+      pop += pages[i].get_population ();\n+\n+    population = pop;\n+    return pop;\n+  }\n+  hb_codepoint_t get_min () const\n+  {\n+    unsigned int count = pages.length;\n+    for (unsigned int i = 0; i < count; i++)\n+      if (!page_at (i).is_empty ())\n+        return page_map[i].major * page_t::PAGE_BITS + page_at (i).get_min ();\n+    return INVALID;\n+  }\n+  hb_codepoint_t get_max () const\n+  {\n+    unsigned int count = pages.length;\n+    for (int i = count - 1; i >= 0; i++)\n+      if (!page_at (i).is_empty ())\n+        return page_map[(unsigned) i].major * page_t::PAGE_BITS + page_at (i).get_max ();\n+    return INVALID;\n+  }\n+\n+  static constexpr hb_codepoint_t INVALID = HB_SET_VALUE_INVALID;\n+\n+  \/*\n+   * Iterator implementation.\n+   *\/\n+  struct const_iter_t : hb_sorted_iter_t<const_iter_t, const hb_codepoint_t>\n+  {\n+    const_iter_t (const hb_set_t &s_) :\n+      s (s_), v (INVALID), l (s.get_population () + 1) { __next__ (); }\n+\n+    typedef hb_codepoint_t __item_type__;\n+    hb_codepoint_t __item__ () const { return v; }\n+    bool __more__ () const { return v != INVALID; }\n+    void __next__ () { s.next (&v); if (l) l--; }\n+    void __prev__ () { s.previous (&v); }\n+    unsigned __len__ () { return l; }\n+\n+    protected:\n+    const hb_set_t &s;\n+    hb_codepoint_t v;\n+    unsigned l;\n+  };\n+  const_iter_t const_iter () const { return const_iter_t (*this); }\n+  operator const_iter_t () const { return const_iter (); }\n+  typedef const_iter_t iter_t;\n+  iter_t iter () const { return const_iter (); }\n+\n+  protected:\n+\n+  page_t *page_for_insert (hb_codepoint_t g)\n+  {\n+    page_map_t map = {get_major (g), pages.length};\n+    unsigned int i;\n+    if (!page_map.bfind (map, &i, HB_BFIND_NOT_FOUND_STORE_CLOSEST))\n+    {\n+      if (!resize (pages.length + 1))\n+        return nullptr;\n+\n+      pages[map.index].init0 ();\n+      memmove (page_map + i + 1,\n+               page_map + i,\n+               (page_map.length - 1 - i) * page_map.item_size);\n+      page_map[i] = map;\n+    }\n+    return &pages[page_map[i].index];\n+  }\n+  page_t *page_for (hb_codepoint_t g)\n+  {\n+    page_map_t key = {get_major (g)};\n+    const page_map_t *found = page_map.bsearch (key);\n+    if (found)\n+      return &pages[found->index];\n+    return nullptr;\n+  }\n+  const page_t *page_for (hb_codepoint_t g) const\n+  {\n+    page_map_t key = {get_major (g)};\n+    const page_map_t *found = page_map.bsearch (key);\n+    if (found)\n+      return &pages[found->index];\n+    return nullptr;\n+  }\n+  page_t &page_at (unsigned int i) { return pages[page_map[i].index]; }\n+  const page_t &page_at (unsigned int i) const { return pages[page_map[i].index]; }\n+  unsigned int get_major (hb_codepoint_t g) const { return g \/ page_t::PAGE_BITS; }\n+  hb_codepoint_t major_start (unsigned int major) const { return major * page_t::PAGE_BITS; }\n+};\n+\n+\n+#endif \/* HB_SET_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-set.hh","additions":738,"deletions":0,"binary":false,"changes":738,"status":"added"},{"patch":"@@ -0,0 +1,503 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+#include \"hb-shape-plan.hh\"\n+#include \"hb-shaper.hh\"\n+#include \"hb-font.hh\"\n+#include \"hb-buffer.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-shape-plan\n+ * @title: hb-shape-plan\n+ * @short_description: Object representing a shaping plan\n+ * @include: hb.h\n+ *\n+ * Shape plans are not used for shaping directly, but can be access to query\n+ * certain information about how shaping will perform given a set of input\n+ * parameters (script, language, direction, features, etc.)\n+ * Most client would not need to deal with shape plans directly.\n+ **\/\n+\n+\n+\/*\n+ * hb_shape_plan_key_t\n+ *\/\n+\n+bool\n+hb_shape_plan_key_t::init (bool                           copy,\n+                           hb_face_t                     *face,\n+                           const hb_segment_properties_t *props,\n+                           const hb_feature_t            *user_features,\n+                           unsigned int                   num_user_features,\n+                           const int                     *coords,\n+                           unsigned int                   num_coords,\n+                           const char * const            *shaper_list)\n+{\n+  hb_feature_t *features = nullptr;\n+  if (copy && num_user_features && !(features = (hb_feature_t *) calloc (num_user_features, sizeof (hb_feature_t))))\n+    goto bail;\n+\n+  this->props = *props;\n+  this->num_user_features = num_user_features;\n+  this->user_features = copy ? features : user_features;\n+  if (copy && num_user_features)\n+  {\n+    memcpy (features, user_features, num_user_features * sizeof (hb_feature_t));\n+    \/* Make start\/end uniform to easier catch bugs. *\/\n+    for (unsigned int i = 0; i < num_user_features; i++)\n+    {\n+      if (features[0].start != HB_FEATURE_GLOBAL_START)\n+        features[0].start = 1;\n+      if (features[0].end   != HB_FEATURE_GLOBAL_END)\n+        features[0].end   = 2;\n+    }\n+  }\n+  this->shaper_func = nullptr;\n+  this->shaper_name = nullptr;\n+  this->ot.init (face, coords, num_coords);\n+\n+  \/*\n+   * Choose shaper.\n+   *\/\n+\n+#define HB_SHAPER_PLAN(shaper) \\\n+        HB_STMT_START { \\\n+          if (face->data.shaper) \\\n+          { \\\n+            this->shaper_func = _hb_##shaper##_shape; \\\n+            this->shaper_name = #shaper; \\\n+            return true; \\\n+          } \\\n+        } HB_STMT_END\n+\n+  if (unlikely (shaper_list))\n+  {\n+    for (; *shaper_list; shaper_list++)\n+      if (false)\n+        ;\n+#define HB_SHAPER_IMPLEMENT(shaper) \\\n+      else if (0 == strcmp (*shaper_list, #shaper)) \\\n+        HB_SHAPER_PLAN (shaper);\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+  }\n+  else\n+  {\n+    const hb_shaper_entry_t *shapers = _hb_shapers_get ();\n+    for (unsigned int i = 0; i < HB_SHAPERS_COUNT; i++)\n+      if (false)\n+        ;\n+#define HB_SHAPER_IMPLEMENT(shaper) \\\n+      else if (shapers[i].func == _hb_##shaper##_shape) \\\n+        HB_SHAPER_PLAN (shaper);\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+  }\n+#undef HB_SHAPER_PLAN\n+\n+bail:\n+  ::free (features);\n+  return false;\n+}\n+\n+bool\n+hb_shape_plan_key_t::user_features_match (const hb_shape_plan_key_t *other)\n+{\n+  if (this->num_user_features != other->num_user_features)\n+    return false;\n+  for (unsigned int i = 0; i < num_user_features; i++)\n+  {\n+    if (this->user_features[i].tag   != other->user_features[i].tag   ||\n+        this->user_features[i].value != other->user_features[i].value ||\n+        (this->user_features[i].start == HB_FEATURE_GLOBAL_START &&\n+         this->user_features[i].end   == HB_FEATURE_GLOBAL_END) !=\n+        (other->user_features[i].start == HB_FEATURE_GLOBAL_START &&\n+         other->user_features[i].end   == HB_FEATURE_GLOBAL_END))\n+      return false;\n+  }\n+  return true;\n+}\n+\n+bool\n+hb_shape_plan_key_t::equal (const hb_shape_plan_key_t *other)\n+{\n+  return hb_segment_properties_equal (&this->props, &other->props) &&\n+         this->user_features_match (other) &&\n+         this->ot.equal (&other->ot) &&\n+         this->shaper_func == other->shaper_func;\n+}\n+\n+\n+\/*\n+ * hb_shape_plan_t\n+ *\/\n+\n+\n+\/**\n+ * hb_shape_plan_create: (Xconstructor)\n+ * @face:\n+ * @props:\n+ * @user_features: (array length=num_user_features):\n+ * @num_user_features:\n+ * @shaper_list: (array zero-terminated=1):\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_shape_plan_t *\n+hb_shape_plan_create (hb_face_t                     *face,\n+                      const hb_segment_properties_t *props,\n+                      const hb_feature_t            *user_features,\n+                      unsigned int                   num_user_features,\n+                      const char * const            *shaper_list)\n+{\n+  return hb_shape_plan_create2 (face, props,\n+                                user_features, num_user_features,\n+                                nullptr, 0,\n+                                shaper_list);\n+}\n+\n+hb_shape_plan_t *\n+hb_shape_plan_create2 (hb_face_t                     *face,\n+                       const hb_segment_properties_t *props,\n+                       const hb_feature_t            *user_features,\n+                       unsigned int                   num_user_features,\n+                       const int                     *coords,\n+                       unsigned int                   num_coords,\n+                       const char * const            *shaper_list)\n+{\n+  DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,\n+                  \"face=%p num_features=%d num_coords=%d shaper_list=%p\",\n+                  face,\n+                  num_user_features,\n+                  num_coords,\n+                  shaper_list);\n+\n+  assert (props->direction != HB_DIRECTION_INVALID);\n+\n+  hb_shape_plan_t *shape_plan;\n+\n+  if (unlikely (!props))\n+    goto bail;\n+  if (!(shape_plan = hb_object_create<hb_shape_plan_t> ()))\n+    goto bail;\n+\n+  if (unlikely (!face))\n+    face = hb_face_get_empty ();\n+  hb_face_make_immutable (face);\n+  shape_plan->face_unsafe = face;\n+\n+  if (unlikely (!shape_plan->key.init (true,\n+                                       face,\n+                                       props,\n+                                       user_features,\n+                                       num_user_features,\n+                                       coords,\n+                                       num_coords,\n+                                       shaper_list)))\n+    goto bail2;\n+  if (unlikely (!shape_plan->ot.init0 (face, &shape_plan->key)))\n+    goto bail3;\n+\n+  return shape_plan;\n+\n+bail3:\n+  shape_plan->key.free ();\n+bail2:\n+  free (shape_plan);\n+bail:\n+  return hb_shape_plan_get_empty ();\n+}\n+\n+\/**\n+ * hb_shape_plan_get_empty:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_shape_plan_t *\n+hb_shape_plan_get_empty ()\n+{\n+  return const_cast<hb_shape_plan_t *> (&Null(hb_shape_plan_t));\n+}\n+\n+\/**\n+ * hb_shape_plan_reference: (skip)\n+ * @shape_plan: a shape plan.\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_shape_plan_t *\n+hb_shape_plan_reference (hb_shape_plan_t *shape_plan)\n+{\n+  return hb_object_reference (shape_plan);\n+}\n+\n+\/**\n+ * hb_shape_plan_destroy: (skip)\n+ * @shape_plan: a shape plan.\n+ *\n+ *\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void\n+hb_shape_plan_destroy (hb_shape_plan_t *shape_plan)\n+{\n+  if (!hb_object_destroy (shape_plan)) return;\n+\n+  shape_plan->ot.fini ();\n+  shape_plan->key.free ();\n+  free (shape_plan);\n+}\n+\n+\/**\n+ * hb_shape_plan_set_user_data: (skip)\n+ * @shape_plan: a shape plan.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_shape_plan_set_user_data (hb_shape_plan_t    *shape_plan,\n+                             hb_user_data_key_t *key,\n+                             void *              data,\n+                             hb_destroy_func_t   destroy,\n+                             hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (shape_plan, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_shape_plan_get_user_data: (skip)\n+ * @shape_plan: a shape plan.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.7\n+ **\/\n+void *\n+hb_shape_plan_get_user_data (hb_shape_plan_t    *shape_plan,\n+                             hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (shape_plan, key);\n+}\n+\n+\/**\n+ * hb_shape_plan_get_shaper:\n+ * @shape_plan: a shape plan.\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.7\n+ **\/\n+const char *\n+hb_shape_plan_get_shaper (hb_shape_plan_t *shape_plan)\n+{\n+  return shape_plan->key.shaper_name;\n+}\n+\n+\n+\/**\n+ * hb_shape_plan_execute:\n+ * @shape_plan: a shape plan.\n+ * @font: a font.\n+ * @buffer: a buffer.\n+ * @features: (array length=num_features):\n+ * @num_features:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_bool_t\n+hb_shape_plan_execute (hb_shape_plan_t    *shape_plan,\n+                       hb_font_t          *font,\n+                       hb_buffer_t        *buffer,\n+                       const hb_feature_t *features,\n+                       unsigned int        num_features)\n+{\n+  DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan,\n+                  \"num_features=%d shaper_func=%p, shaper_name=%s\",\n+                  num_features,\n+                  shape_plan->key.shaper_func,\n+                  shape_plan->key.shaper_name);\n+\n+  if (unlikely (!buffer->len))\n+    return true;\n+\n+  assert (!hb_object_is_immutable (buffer));\n+  assert (buffer->content_type == HB_BUFFER_CONTENT_TYPE_UNICODE);\n+\n+  if (unlikely (hb_object_is_inert (shape_plan)))\n+    return false;\n+\n+  assert (shape_plan->face_unsafe == font->face);\n+  assert (hb_segment_properties_equal (&shape_plan->key.props, &buffer->props));\n+\n+#define HB_SHAPER_EXECUTE(shaper) \\\n+        HB_STMT_START { \\\n+          return font->data.shaper && \\\n+                 _hb_##shaper##_shape (shape_plan, font, buffer, features, num_features); \\\n+        } HB_STMT_END\n+\n+  if (false)\n+    ;\n+#define HB_SHAPER_IMPLEMENT(shaper) \\\n+  else if (shape_plan->key.shaper_func == _hb_##shaper##_shape) \\\n+    HB_SHAPER_EXECUTE (shaper);\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+\n+#undef HB_SHAPER_EXECUTE\n+\n+  return false;\n+}\n+\n+\n+\/*\n+ * Caching\n+ *\/\n+\n+\/**\n+ * hb_shape_plan_create_cached:\n+ * @face:\n+ * @props:\n+ * @user_features: (array length=num_user_features):\n+ * @num_user_features:\n+ * @shaper_list: (array zero-terminated=1):\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.7\n+ **\/\n+hb_shape_plan_t *\n+hb_shape_plan_create_cached (hb_face_t                     *face,\n+                             const hb_segment_properties_t *props,\n+                             const hb_feature_t            *user_features,\n+                             unsigned int                   num_user_features,\n+                             const char * const            *shaper_list)\n+{\n+  return hb_shape_plan_create_cached2 (face, props,\n+                                       user_features, num_user_features,\n+                                       nullptr, 0,\n+                                       shaper_list);\n+}\n+\n+hb_shape_plan_t *\n+hb_shape_plan_create_cached2 (hb_face_t                     *face,\n+                              const hb_segment_properties_t *props,\n+                              const hb_feature_t            *user_features,\n+                              unsigned int                   num_user_features,\n+                              const int                     *coords,\n+                              unsigned int                   num_coords,\n+                              const char * const            *shaper_list)\n+{\n+  DEBUG_MSG_FUNC (SHAPE_PLAN, nullptr,\n+                  \"face=%p num_features=%d shaper_list=%p\",\n+                  face,\n+                  num_user_features,\n+                  shaper_list);\n+\n+retry:\n+  hb_face_t::plan_node_t *cached_plan_nodes = face->shape_plans;\n+\n+  bool dont_cache = hb_object_is_inert (face);\n+\n+  if (likely (!dont_cache))\n+  {\n+    hb_shape_plan_key_t key;\n+    if (!key.init (false,\n+                   face,\n+                   props,\n+                   user_features,\n+                   num_user_features,\n+                   coords,\n+                   num_coords,\n+                   shaper_list))\n+      return hb_shape_plan_get_empty ();\n+\n+    for (hb_face_t::plan_node_t *node = cached_plan_nodes; node; node = node->next)\n+      if (node->shape_plan->key.equal (&key))\n+      {\n+        DEBUG_MSG_FUNC (SHAPE_PLAN, node->shape_plan, \"fulfilled from cache\");\n+        return hb_shape_plan_reference (node->shape_plan);\n+      }\n+  }\n+\n+  hb_shape_plan_t *shape_plan = hb_shape_plan_create2 (face, props,\n+                                                       user_features, num_user_features,\n+                                                       coords, num_coords,\n+                                                       shaper_list);\n+\n+  if (unlikely (dont_cache))\n+    return shape_plan;\n+\n+  hb_face_t::plan_node_t *node = (hb_face_t::plan_node_t *) calloc (1, sizeof (hb_face_t::plan_node_t));\n+  if (unlikely (!node))\n+    return shape_plan;\n+\n+  node->shape_plan = shape_plan;\n+  node->next = cached_plan_nodes;\n+\n+  if (unlikely (!face->shape_plans.cmpexch (cached_plan_nodes, node)))\n+  {\n+    hb_shape_plan_destroy (shape_plan);\n+    free (node);\n+    goto retry;\n+  }\n+  DEBUG_MSG_FUNC (SHAPE_PLAN, shape_plan, \"inserted into cache\");\n+\n+  return hb_shape_plan_reference (shape_plan);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shape-plan.cc","additions":503,"deletions":0,"binary":false,"changes":503,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_SHAPE_PLAN_H\n+#define HB_SHAPE_PLAN_H\n+\n+#include \"hb-common.h\"\n+#include \"hb-font.h\"\n+\n+HB_BEGIN_DECLS\n+\n+typedef struct hb_shape_plan_t hb_shape_plan_t;\n+\n+HB_EXTERN hb_shape_plan_t *\n+hb_shape_plan_create (hb_face_t                     *face,\n+                      const hb_segment_properties_t *props,\n+                      const hb_feature_t            *user_features,\n+                      unsigned int                   num_user_features,\n+                      const char * const            *shaper_list);\n+\n+HB_EXTERN hb_shape_plan_t *\n+hb_shape_plan_create_cached (hb_face_t                     *face,\n+                             const hb_segment_properties_t *props,\n+                             const hb_feature_t            *user_features,\n+                             unsigned int                   num_user_features,\n+                             const char * const            *shaper_list);\n+\n+HB_EXTERN hb_shape_plan_t *\n+hb_shape_plan_create2 (hb_face_t                     *face,\n+                       const hb_segment_properties_t *props,\n+                       const hb_feature_t            *user_features,\n+                       unsigned int                   num_user_features,\n+                       const int                     *coords,\n+                       unsigned int                   num_coords,\n+                       const char * const            *shaper_list);\n+\n+HB_EXTERN hb_shape_plan_t *\n+hb_shape_plan_create_cached2 (hb_face_t                     *face,\n+                              const hb_segment_properties_t *props,\n+                              const hb_feature_t            *user_features,\n+                              unsigned int                   num_user_features,\n+                              const int                     *coords,\n+                              unsigned int                   num_coords,\n+                              const char * const            *shaper_list);\n+\n+\n+HB_EXTERN hb_shape_plan_t *\n+hb_shape_plan_get_empty (void);\n+\n+HB_EXTERN hb_shape_plan_t *\n+hb_shape_plan_reference (hb_shape_plan_t *shape_plan);\n+\n+HB_EXTERN void\n+hb_shape_plan_destroy (hb_shape_plan_t *shape_plan);\n+\n+HB_EXTERN hb_bool_t\n+hb_shape_plan_set_user_data (hb_shape_plan_t    *shape_plan,\n+                             hb_user_data_key_t *key,\n+                             void *              data,\n+                             hb_destroy_func_t   destroy,\n+                             hb_bool_t           replace);\n+\n+HB_EXTERN void *\n+hb_shape_plan_get_user_data (hb_shape_plan_t    *shape_plan,\n+                             hb_user_data_key_t *key);\n+\n+\n+HB_EXTERN hb_bool_t\n+hb_shape_plan_execute (hb_shape_plan_t    *shape_plan,\n+                       hb_font_t          *font,\n+                       hb_buffer_t        *buffer,\n+                       const hb_feature_t *features,\n+                       unsigned int        num_features);\n+\n+HB_EXTERN const char *\n+hb_shape_plan_get_shaper (hb_shape_plan_t *shape_plan);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_SHAPE_PLAN_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shape-plan.h","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright © 2012,2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_SHAPE_PLAN_HH\n+#define HB_SHAPE_PLAN_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-shaper.hh\"\n+#include \"hb-ot-shape.hh\"\n+\n+\n+struct hb_shape_plan_key_t\n+{\n+  hb_segment_properties_t  props;\n+\n+  const hb_feature_t      *user_features;\n+  unsigned int             num_user_features;\n+\n+  hb_ot_shape_plan_key_t   ot;\n+\n+  hb_shape_func_t         *shaper_func;\n+  const char              *shaper_name;\n+\n+  HB_INTERNAL inline bool init (bool                           copy,\n+                                hb_face_t                     *face,\n+                                const hb_segment_properties_t *props,\n+                                const hb_feature_t            *user_features,\n+                                unsigned int                   num_user_features,\n+                                const int                     *coords,\n+                                unsigned int                   num_coords,\n+                                const char * const            *shaper_list);\n+\n+  HB_INTERNAL inline void free () { ::free ((void *) user_features); }\n+\n+  HB_INTERNAL bool user_features_match (const hb_shape_plan_key_t *other);\n+\n+  HB_INTERNAL bool equal (const hb_shape_plan_key_t *other);\n+};\n+\n+struct hb_shape_plan_t\n+{\n+  hb_object_header_t header;\n+  hb_face_t *face_unsafe; \/* We don't carry a reference to face. *\/\n+  hb_shape_plan_key_t key;\n+  hb_ot_shape_plan_t ot;\n+};\n+\n+\n+#endif \/* HB_SHAPE_PLAN_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shape-plan.hh","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-shaper.hh\"\n+#include \"hb-shape-plan.hh\"\n+#include \"hb-buffer.hh\"\n+#include \"hb-font.hh\"\n+#include \"hb-machinery.hh\"\n+\n+\n+\/**\n+ * SECTION:hb-shape\n+ * @title: hb-shape\n+ * @short_description: Conversion of text strings into positioned glyphs\n+ * @include: hb.h\n+ *\n+ * Shaping is the central operation of HarfBuzz. Shaping operates on buffers,\n+ * which are sequences of Unicode characters that use the same font and have\n+ * the same text direction, script, and language. After shaping the buffer\n+ * contains the output glyphs and their positions.\n+ **\/\n+\n+\n+#if HB_USE_ATEXIT\n+static void free_static_shaper_list ();\n+#endif\n+\n+static const char *nil_shaper_list[] = {nullptr};\n+\n+static struct hb_shaper_list_lazy_loader_t : hb_lazy_loader_t<const char *,\n+                                                              hb_shaper_list_lazy_loader_t>\n+{\n+  static const char ** create ()\n+  {\n+    const char **shaper_list = (const char **) calloc (1 + HB_SHAPERS_COUNT, sizeof (const char *));\n+    if (unlikely (!shaper_list))\n+      return nullptr;\n+\n+    const hb_shaper_entry_t *shapers = _hb_shapers_get ();\n+    unsigned int i;\n+    for (i = 0; i < HB_SHAPERS_COUNT; i++)\n+      shaper_list[i] = shapers[i].name;\n+    shaper_list[i] = nullptr;\n+\n+#if HB_USE_ATEXIT\n+    atexit (free_static_shaper_list);\n+#endif\n+\n+    return shaper_list;\n+  }\n+  static void destroy (const char **l)\n+  { free (l); }\n+  static const char ** get_null ()\n+  { return nil_shaper_list; }\n+} static_shaper_list;\n+\n+#if HB_USE_ATEXIT\n+static\n+void free_static_shaper_list ()\n+{\n+  static_shaper_list.free_instance ();\n+}\n+#endif\n+\n+\n+\/**\n+ * hb_shape_list_shapers:\n+ *\n+ * Retrieves the list of shapers supported by HarfBuzz.\n+ *\n+ * Return value: (transfer none) (array zero-terminated=1): an array of\n+ *    constant strings\n+ *\n+ * Since: 0.9.2\n+ **\/\n+const char **\n+hb_shape_list_shapers ()\n+{\n+  return static_shaper_list.get_unconst ();\n+}\n+\n+\n+\/**\n+ * hb_shape_full:\n+ * @font: an #hb_font_t to use for shaping\n+ * @buffer: an #hb_buffer_t to shape\n+ * @features: (array length=num_features) (allow-none): an array of user\n+ *    specified #hb_feature_t or %NULL\n+ * @num_features: the length of @features array\n+ * @shaper_list: (array zero-terminated=1) (allow-none): a %NULL-terminated\n+ *    array of shapers to use or %NULL\n+ *\n+ * See hb_shape() for details. If @shaper_list is not %NULL, the specified\n+ * shapers will be used in the given order, otherwise the default shapers list\n+ * will be used.\n+ *\n+ * Return value: false if all shapers failed, true otherwise\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_shape_full (hb_font_t          *font,\n+               hb_buffer_t        *buffer,\n+               const hb_feature_t *features,\n+               unsigned int        num_features,\n+               const char * const *shaper_list)\n+{\n+  hb_shape_plan_t *shape_plan = hb_shape_plan_create_cached2 (font->face, &buffer->props,\n+                                                              features, num_features,\n+                                                              font->coords, font->num_coords,\n+                                                              shaper_list);\n+  hb_bool_t res = hb_shape_plan_execute (shape_plan, font, buffer, features, num_features);\n+  hb_shape_plan_destroy (shape_plan);\n+\n+  if (res)\n+    buffer->content_type = HB_BUFFER_CONTENT_TYPE_GLYPHS;\n+  return res;\n+}\n+\n+\/**\n+ * hb_shape:\n+ * @font: an #hb_font_t to use for shaping\n+ * @buffer: an #hb_buffer_t to shape\n+ * @features: (array length=num_features) (allow-none): an array of user\n+ *    specified #hb_feature_t or %NULL\n+ * @num_features: the length of @features array\n+ *\n+ * Shapes @buffer using @font turning its Unicode characters content to\n+ * positioned glyphs. If @features is not %NULL, it will be used to control the\n+ * features applied during shaping.\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_shape (hb_font_t           *font,\n+          hb_buffer_t         *buffer,\n+          const hb_feature_t  *features,\n+          unsigned int         num_features)\n+{\n+  hb_shape_full (font, buffer, features, num_features, nullptr);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shape.cc","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_SHAPE_H\n+#define HB_SHAPE_H\n+\n+#include \"hb-common.h\"\n+#include \"hb-buffer.h\"\n+#include \"hb-font.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+HB_EXTERN void\n+hb_shape (hb_font_t           *font,\n+          hb_buffer_t         *buffer,\n+          const hb_feature_t  *features,\n+          unsigned int         num_features);\n+\n+HB_EXTERN hb_bool_t\n+hb_shape_full (hb_font_t          *font,\n+               hb_buffer_t        *buffer,\n+               const hb_feature_t *features,\n+               unsigned int        num_features,\n+               const char * const *shaper_list);\n+\n+HB_EXTERN const char **\n+hb_shape_list_shapers (void);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_SHAPE_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shape.h","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shaper-impl.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-shaper-impl.hh","status":"copied"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_SHAPER_LIST_HH\n+#define HB_SHAPER_LIST_HH\n+#endif \/* HB_SHAPER_LIST_HH *\/ \/* Dummy header guards *\/\n+\n+\/* v--- Add new shapers in the right place here. *\/\n+\n+#ifdef HAVE_GRAPHITE2\n+\/* Only picks up fonts that have a \"Silf\" table. *\/\n+HB_SHAPER_IMPLEMENT (graphite2)\n+#endif\n+\n+HB_SHAPER_IMPLEMENT (ot) \/* <--- This is our main OpenType shaper. *\/\n+\n+#ifdef HAVE_UNISCRIBE\n+HB_SHAPER_IMPLEMENT (uniscribe)\n+#endif\n+#ifdef HAVE_DIRECTWRITE\n+HB_SHAPER_IMPLEMENT (directwrite)\n+#endif\n+#ifdef HAVE_CORETEXT\n+HB_SHAPER_IMPLEMENT (coretext)\n+\n+\/* Only picks up fonts that have a \"mort\" or \"morx\" table.\n+   Probably going to be removed https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1478 *\/\n+HB_SHAPER_IMPLEMENT (coretext_aat)\n+#endif\n+\n+#ifdef HAVE_FALLBACK\n+HB_SHAPER_IMPLEMENT (fallback) \/* <--- This should be last. *\/\n+#endif\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shaper-list.hh","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+#include \"hb-shaper.hh\"\n+#include \"hb-machinery.hh\"\n+\n+\n+static const hb_shaper_entry_t all_shapers[] = {\n+#define HB_SHAPER_IMPLEMENT(name) {#name, _hb_##name##_shape},\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+};\n+\n+#if HB_USE_ATEXIT\n+static void free_static_shapers ();\n+#endif\n+\n+static struct hb_shapers_lazy_loader_t : hb_lazy_loader_t<const hb_shaper_entry_t,\n+                                                          hb_shapers_lazy_loader_t>\n+{\n+  static hb_shaper_entry_t *create ()\n+  {\n+    char *env = getenv (\"HB_SHAPER_LIST\");\n+    if (!env || !*env)\n+      return nullptr;\n+\n+    hb_shaper_entry_t *shapers = (hb_shaper_entry_t *) calloc (1, sizeof (all_shapers));\n+    if (unlikely (!shapers))\n+      return nullptr;\n+\n+    memcpy (shapers, all_shapers, sizeof (all_shapers));\n+\n+     \/* Reorder shaper list to prefer requested shapers. *\/\n+    unsigned int i = 0;\n+    char *end, *p = env;\n+    for (;;)\n+    {\n+      end = strchr (p, ',');\n+      if (!end)\n+        end = p + strlen (p);\n+\n+      for (unsigned int j = i; j < ARRAY_LENGTH (all_shapers); j++)\n+        if (end - p == (int) strlen (shapers[j].name) &&\n+            0 == strncmp (shapers[j].name, p, end - p))\n+        {\n+          \/* Reorder this shaper to position i *\/\n+         struct hb_shaper_entry_t t = shapers[j];\n+         memmove (&shapers[i + 1], &shapers[i], sizeof (shapers[i]) * (j - i));\n+         shapers[i] = t;\n+         i++;\n+        }\n+\n+      if (!*end)\n+        break;\n+      else\n+        p = end + 1;\n+    }\n+\n+#if HB_USE_ATEXIT\n+    atexit (free_static_shapers);\n+#endif\n+\n+    return shapers;\n+  }\n+  static void destroy (const hb_shaper_entry_t *p) { free ((void *) p); }\n+  static const hb_shaper_entry_t *get_null ()      { return all_shapers; }\n+} static_shapers;\n+\n+#if HB_USE_ATEXIT\n+static\n+void free_static_shapers ()\n+{\n+  static_shapers.free_instance ();\n+}\n+#endif\n+\n+const hb_shaper_entry_t *\n+_hb_shapers_get ()\n+{\n+  return static_shapers.get_unconst ();\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shaper.cc","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,134 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_SHAPER_HH\n+#define HB_SHAPER_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-machinery.hh\"\n+\n+typedef hb_bool_t hb_shape_func_t (hb_shape_plan_t    *shape_plan,\n+                                   hb_font_t          *font,\n+                                   hb_buffer_t        *buffer,\n+                                   const hb_feature_t *features,\n+                                   unsigned int        num_features);\n+\n+#define HB_SHAPER_IMPLEMENT(name) \\\n+        extern \"C\" HB_INTERNAL hb_shape_func_t _hb_##name##_shape;\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+\n+struct hb_shaper_entry_t {\n+  char name[16];\n+  hb_shape_func_t *func;\n+};\n+\n+HB_INTERNAL const hb_shaper_entry_t *\n+_hb_shapers_get ();\n+\n+\n+template <typename Data, unsigned int WheresData, typename T>\n+struct hb_shaper_lazy_loader_t;\n+\n+#define HB_SHAPER_ORDER(Shaper) \\\n+  HB_PASTE (HB_SHAPER_ORDER_, Shaper)\n+enum hb_shaper_order_t\n+{\n+  _HB_SHAPER_ORDER_ORDER_ZERO,\n+#define HB_SHAPER_IMPLEMENT(Shaper) \\\n+      HB_SHAPER_ORDER (Shaper),\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+  _HB_SHAPERS_COUNT_PLUS_ONE,\n+  HB_SHAPERS_COUNT = _HB_SHAPERS_COUNT_PLUS_ONE - 1,\n+};\n+\n+template <enum hb_shaper_order_t order, typename Object> struct hb_shaper_object_data_type_t;\n+\n+#define HB_SHAPER_DATA_SUCCEEDED ((void *) +1)\n+#define HB_SHAPER_DATA_TYPE(shaper, object)             hb_##shaper##_##object##_data_t\n+#define HB_SHAPER_DATA_CREATE_FUNC(shaper, object)      _hb_##shaper##_shaper_##object##_data_create\n+#define HB_SHAPER_DATA_DESTROY_FUNC(shaper, object)     _hb_##shaper##_shaper_##object##_data_destroy\n+\n+#define HB_SHAPER_DATA_INSTANTIATE_SHAPERS(shaper, object) \\\n+        \\\n+        struct HB_SHAPER_DATA_TYPE (shaper, object); \/* Type forward declaration. *\/ \\\n+        extern \"C\" HB_INTERNAL HB_SHAPER_DATA_TYPE (shaper, object) * \\\n+        HB_SHAPER_DATA_CREATE_FUNC (shaper, object) (hb_##object##_t *object); \\\n+        extern \"C\" HB_INTERNAL void \\\n+        HB_SHAPER_DATA_DESTROY_FUNC (shaper, object) (HB_SHAPER_DATA_TYPE (shaper, object) *shaper##_##object); \\\n+        \\\n+        template <> \\\n+        struct hb_shaper_object_data_type_t<HB_SHAPER_ORDER (shaper), hb_##object##_t> \\\n+        { \\\n+          typedef HB_SHAPER_DATA_TYPE(shaper, object) value; \\\n+        }; \\\n+        \\\n+        template <unsigned int WheresData> \\\n+        struct hb_shaper_lazy_loader_t<hb_##object##_t, WheresData, HB_SHAPER_DATA_TYPE(shaper, object)> \\\n+                : hb_lazy_loader_t<HB_SHAPER_DATA_TYPE(shaper, object), \\\n+                                   hb_shaper_lazy_loader_t<hb_##object##_t, \\\n+                                                           WheresData, \\\n+                                                           HB_SHAPER_DATA_TYPE(shaper, object)>, \\\n+                                   hb_##object##_t, WheresData> \\\n+        { \\\n+          typedef HB_SHAPER_DATA_TYPE(shaper, object) Type; \\\n+          static Type* create (hb_##object##_t *data) \\\n+          { return HB_SHAPER_DATA_CREATE_FUNC (shaper, object) (data); } \\\n+          static Type *get_null () { return nullptr; } \\\n+          static void destroy (Type *p) { HB_SHAPER_DATA_DESTROY_FUNC (shaper, object) (p); } \\\n+        }; \\\n+        \\\n+        static_assert (true, \"\") \/* Require semicolon. *\/\n+\n+\n+template <typename Object>\n+struct hb_shaper_object_dataset_t\n+{\n+  void init0 (Object *parent_data)\n+  {\n+    this->parent_data = parent_data;\n+#define HB_SHAPER_IMPLEMENT(shaper) shaper.init0 ();\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+  }\n+  void fini ()\n+  {\n+#define HB_SHAPER_IMPLEMENT(shaper) shaper.fini ();\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+  }\n+\n+  Object *parent_data; \/* MUST be JUST before the lazy loaders. *\/\n+#define HB_SHAPER_IMPLEMENT(shaper) \\\n+        hb_shaper_lazy_loader_t<Object, HB_SHAPER_ORDER(shaper), \\\n+                                typename hb_shaper_object_data_type_t<HB_SHAPER_ORDER(shaper), Object>::value \\\n+                               > shaper;\n+#include \"hb-shaper-list.hh\"\n+#undef HB_SHAPER_IMPLEMENT\n+};\n+\n+#endif \/* HB_SHAPER_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-shaper.hh","additions":134,"deletions":0,"binary":false,"changes":134,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-face.hh\"\n+\n+#include \"hb-aat-layout-common.hh\"\n+#include \"hb-aat-layout-feat-table.hh\"\n+#include \"hb-ot-layout-common.hh\"\n+#include \"hb-ot-cmap-table.hh\"\n+#include \"hb-ot-head-table.hh\"\n+#include \"hb-ot-maxp-table.hh\"\n+\n+#ifndef HB_NO_VISIBILITY\n+\n+hb_vector_size_impl_t const _hb_NullPool[(HB_NULL_POOL_SIZE + sizeof (hb_vector_size_impl_t) - 1) \/ sizeof (hb_vector_size_impl_t)] = {};\n+\/*thread_local*\/ hb_vector_size_impl_t _hb_CrapPool[(HB_NULL_POOL_SIZE + sizeof (hb_vector_size_impl_t) - 1) \/ sizeof (hb_vector_size_impl_t)] = {};\n+\n+DEFINE_NULL_NAMESPACE_BYTES (OT, Index) =  {0xFF,0xFF};\n+DEFINE_NULL_NAMESPACE_BYTES (OT, LangSys) = {0x00,0x00, 0xFF,0xFF, 0x00,0x00};\n+DEFINE_NULL_NAMESPACE_BYTES (OT, RangeRecord) = {0x00,0x01, 0x00,0x00, 0x00, 0x00};\n+DEFINE_NULL_NAMESPACE_BYTES (OT, CmapSubtableLongGroup) = {0x00,0x00,0x00,0x01, 0x00,0x00,0x00,0x00, 0x00,0x00,0x00,0x00};\n+DEFINE_NULL_NAMESPACE_BYTES (AAT, SettingName) = {0xFF,0xFF, 0xFF,0xFF};\n+\/* Hand-coded because Lookup is a template.  Sad. *\/\n+const unsigned char _hb_Null_AAT_Lookup[2] = {0xFF, 0xFF};\n+\n+\n+unsigned int\n+hb_face_t::load_num_glyphs () const\n+{\n+  hb_sanitize_context_t c = hb_sanitize_context_t ();\n+  c.set_num_glyphs (0); \/* So we don't recurse ad infinitum. *\/\n+  hb_blob_t *maxp_blob = c.reference_table<OT::maxp> (this);\n+  const OT::maxp *maxp_table = maxp_blob->as<OT::maxp> ();\n+\n+  unsigned int ret = maxp_table->get_num_glyphs ();\n+  num_glyphs.set_relaxed (ret);\n+  hb_blob_destroy (maxp_blob);\n+  return ret;\n+}\n+\n+unsigned int\n+hb_face_t::load_upem () const\n+{\n+  unsigned int ret = table.head->get_upem ();\n+  upem.set_relaxed (ret);\n+  return ret;\n+}\n+\n+#endif\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-static.cc","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright © 2017  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_STRING_ARRAY_HH\n+#if 0 \/* Make checks happy. *\/\n+#define HB_STRING_ARRAY_HH\n+#endif\n+\n+#include \"hb.hh\"\n+\n+\/* Based on Bruno Haible's code in Appendix B of Ulrich Drepper's dsohowto.pdf:\n+ * https:\/\/software.intel.com\/sites\/default\/files\/m\/a\/1\/e\/dsohowto.pdf *\/\n+\n+#define HB_STRING_ARRAY_TYPE_NAME       HB_PASTE(HB_STRING_ARRAY_NAME, _msgstr_t)\n+#define HB_STRING_ARRAY_POOL_NAME       HB_PASTE(HB_STRING_ARRAY_NAME, _msgstr)\n+#define HB_STRING_ARRAY_OFFS_NAME       HB_PASTE(HB_STRING_ARRAY_NAME, _msgidx)\n+\n+static const union HB_STRING_ARRAY_TYPE_NAME {\n+  struct {\n+\/* I like to avoid storing the nul-termination byte since we don't need it,\n+ * but C++ does not allow that.\n+ * https:\/\/stackoverflow.com\/q\/28433862\n+ *\/\n+#define _S(s) char HB_PASTE (str, __LINE__)[sizeof (s)];\n+#include HB_STRING_ARRAY_LIST\n+#undef _S\n+  } st;\n+  char str[VAR];\n+}\n+HB_STRING_ARRAY_POOL_NAME =\n+{\n+  {\n+#define _S(s) s,\n+#include HB_STRING_ARRAY_LIST\n+#undef _S\n+  }\n+};\n+static const unsigned int HB_STRING_ARRAY_OFFS_NAME[] =\n+{\n+#define _S(s) offsetof (union HB_STRING_ARRAY_TYPE_NAME, st.HB_PASTE(str, __LINE__)),\n+#include HB_STRING_ARRAY_LIST\n+#undef _S\n+  sizeof (HB_STRING_ARRAY_TYPE_NAME)\n+};\n+\n+static inline hb_bytes_t\n+HB_STRING_ARRAY_NAME (unsigned int i)\n+{\n+  assert (i < ARRAY_LENGTH (HB_STRING_ARRAY_OFFS_NAME) - 1);\n+  return hb_bytes_t (HB_STRING_ARRAY_POOL_NAME.str + HB_STRING_ARRAY_OFFS_NAME[i],\n+                     HB_STRING_ARRAY_OFFS_NAME[i + 1] - HB_STRING_ARRAY_OFFS_NAME[i] - 1);\n+}\n+\n+#undef HB_STRING_ARRAY_TYPE_NAME\n+#undef HB_STRING_ARRAY_POOL_NAME\n+#undef HB_STRING_ARRAY_OFFS_NAME\n+\n+#endif \/* HB_STRING_ARRAY_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-string-array.hh","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,226 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#include \"hb-ot-cff-common.hh\"\n+#include \"hb-ot-cff2-table.hh\"\n+#include \"hb-subset-cff-common.hh\"\n+\n+\/* Disable FDSelect format 0 for compatibility with fonttools which doesn't seem choose it.\n+ * Rarely any\/much smaller than format 3 anyway. *\/\n+#define CFF_SERIALIZE_FDSELECT_0  0\n+\n+using namespace CFF;\n+\n+\/**\n+ * hb_plan_subset_cff_fdselect\n+ * Determine an optimal FDSelect format according to a provided plan.\n+ *\n+ * Return value: FDSelect format, size, and ranges for the most compact subset FDSelect\n+ * along with a font index remapping table\n+ **\/\n+\n+bool\n+hb_plan_subset_cff_fdselect (const hb_vector_t<hb_codepoint_t> &glyphs,\n+                            unsigned int fdCount,\n+                            const FDSelect &src, \/* IN *\/\n+                            unsigned int &subset_fd_count \/* OUT *\/,\n+                            unsigned int &subset_fdselect_size \/* OUT *\/,\n+                            unsigned int &subset_fdselect_format \/* OUT *\/,\n+                            hb_vector_t<code_pair_t> &fdselect_ranges \/* OUT *\/,\n+                            remap_t &fdmap \/* OUT *\/)\n+{\n+  subset_fd_count = 0;\n+  subset_fdselect_size = 0;\n+  subset_fdselect_format = 0;\n+  unsigned int  num_ranges = 0;\n+\n+  unsigned int subset_num_glyphs = glyphs.length;\n+  if (subset_num_glyphs == 0)\n+    return true;\n+\n+  {\n+    \/* use hb_set to determine the subset of font dicts *\/\n+    hb_set_t  *set = hb_set_create ();\n+    if (set == &Null (hb_set_t))\n+      return false;\n+    hb_codepoint_t  prev_fd = CFF_UNDEF_CODE;\n+    for (hb_codepoint_t i = 0; i < subset_num_glyphs; i++)\n+    {\n+      hb_codepoint_t  fd = src.get_fd (glyphs[i]);\n+      set->add (fd);\n+\n+      if (fd != prev_fd)\n+      {\n+        num_ranges++;\n+        prev_fd = fd;\n+        code_pair_t pair = { fd, i };\n+        fdselect_ranges.push (pair);\n+      }\n+    }\n+\n+    subset_fd_count = set->get_population ();\n+    if (subset_fd_count == fdCount)\n+    {\n+      \/* all font dicts belong to the subset. no need to subset FDSelect & FDArray *\/\n+      fdmap.identity (fdCount);\n+      hb_set_destroy (set);\n+    }\n+    else\n+    {\n+      \/* create a fdmap *\/\n+      if (!fdmap.reset (fdCount))\n+      {\n+        hb_set_destroy (set);\n+        return false;\n+      }\n+\n+      hb_codepoint_t  fd = CFF_UNDEF_CODE;\n+      while (set->next (&fd))\n+        fdmap.add (fd);\n+      hb_set_destroy (set);\n+      if (unlikely (fdmap.get_count () != subset_fd_count))\n+        return false;\n+    }\n+\n+    \/* update each font dict index stored as \"code\" in fdselect_ranges *\/\n+    for (unsigned int i = 0; i < fdselect_ranges.length; i++)\n+      fdselect_ranges[i].code = fdmap[fdselect_ranges[i].code];\n+  }\n+\n+  \/* determine which FDSelect format is most compact *\/\n+  if (subset_fd_count > 0xFF)\n+  {\n+    if (unlikely (src.format != 4))\n+      return false;\n+    subset_fdselect_format = 4;\n+    subset_fdselect_size = FDSelect::min_size + FDSelect4::min_size + FDSelect4_Range::static_size * num_ranges + HBUINT32::static_size;\n+  }\n+  else\n+  {\n+#if CFF_SERIALIZE_FDSELECT_0\n+    unsigned int format0_size = FDSelect::min_size + FDSelect0::min_size + HBUINT8::static_size * subset_num_glyphs;\n+#endif\n+    unsigned int format3_size = FDSelect::min_size + FDSelect3::min_size + FDSelect3_Range::static_size * num_ranges + HBUINT16::static_size;\n+\n+#if CFF_SERIALIZE_FDSELECT_0\n+    if (format0_size <= format3_size)\n+    {\n+      \/\/ subset_fdselect_format = 0;\n+      subset_fdselect_size = format0_size;\n+    }\n+    else\n+#endif\n+    {\n+      subset_fdselect_format = 3;\n+      subset_fdselect_size = format3_size;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+template <typename FDSELECT3_4>\n+static inline bool\n+serialize_fdselect_3_4 (hb_serialize_context_t *c,\n+                          const unsigned int num_glyphs,\n+                          const FDSelect &src,\n+                          unsigned int size,\n+                          const hb_vector_t<code_pair_t> &fdselect_ranges)\n+{\n+  TRACE_SERIALIZE (this);\n+  FDSELECT3_4 *p = c->allocate_size<FDSELECT3_4> (size);\n+  if (unlikely (p == nullptr)) return_trace (false);\n+  p->nRanges ().set (fdselect_ranges.length);\n+  for (unsigned int i = 0; i < fdselect_ranges.length; i++)\n+  {\n+    p->ranges[i].first.set (fdselect_ranges[i].glyph);\n+    p->ranges[i].fd.set (fdselect_ranges[i].code);\n+  }\n+  p->sentinel().set (num_glyphs);\n+  return_trace (true);\n+}\n+\n+\/**\n+ * hb_serialize_cff_fdselect\n+ * Serialize a subset FDSelect format planned above.\n+ **\/\n+bool\n+hb_serialize_cff_fdselect (hb_serialize_context_t *c,\n+                          const unsigned int num_glyphs,\n+                          const FDSelect &src,\n+                          unsigned int fd_count,\n+                          unsigned int fdselect_format,\n+                          unsigned int size,\n+                          const hb_vector_t<code_pair_t> &fdselect_ranges)\n+{\n+  TRACE_SERIALIZE (this);\n+  FDSelect  *p = c->allocate_min<FDSelect> ();\n+  if (unlikely (p == nullptr)) return_trace (false);\n+  p->format.set (fdselect_format);\n+  size -= FDSelect::min_size;\n+\n+  switch (fdselect_format)\n+  {\n+#if CFF_SERIALIZE_FDSELECT_0\n+    case 0:\n+    {\n+      FDSelect0 *p = c->allocate_size<FDSelect0> (size);\n+      if (unlikely (p == nullptr)) return_trace (false);\n+      unsigned int range_index = 0;\n+      unsigned int  fd = fdselect_ranges[range_index++].code;\n+      for (unsigned int i = 0; i < num_glyphs; i++)\n+      {\n+        if ((range_index < fdselect_ranges.len) &&\n+            (i >= fdselect_ranges[range_index].glyph))\n+        {\n+          fd = fdselect_ranges[range_index++].code;\n+        }\n+        p->fds[i].set (fd);\n+      }\n+      break;\n+    }\n+#endif \/* CFF_SERIALIZE_FDSELECT_0 *\/\n+\n+    case 3:\n+      return serialize_fdselect_3_4<FDSelect3> (c,\n+                                                num_glyphs,\n+                                                src,\n+                                                size,\n+                                                fdselect_ranges);\n+\n+    case 4:\n+      return serialize_fdselect_3_4<FDSelect4> (c,\n+                                                num_glyphs,\n+                                                src,\n+                                                size,\n+                                                fdselect_ranges);\n+\n+    default:\n+      assert(false);\n+  }\n+\n+  return_trace (true);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-cff-common.cc","additions":226,"deletions":0,"binary":false,"changes":226,"status":"added"},{"patch":"@@ -0,0 +1,997 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#ifndef HB_SUBSET_CFF_COMMON_HH\n+#define HB_SUBSET_CFF_COMMON_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-subset-plan.hh\"\n+#include \"hb-cff-interp-cs-common.hh\"\n+\n+namespace CFF {\n+\n+\/* Used for writing a temporary charstring *\/\n+struct str_encoder_t\n+{\n+  str_encoder_t (str_buff_t &buff_)\n+    : buff (buff_), error (false) {}\n+\n+  void reset () { buff.resize (0); }\n+\n+  void encode_byte (unsigned char b)\n+  {\n+    if (unlikely (buff.push (b) == &Crap(unsigned char)))\n+      set_error ();\n+  }\n+\n+  void encode_int (int v)\n+  {\n+    if ((-1131 <= v) && (v <= 1131))\n+    {\n+      if ((-107 <= v) && (v <= 107))\n+        encode_byte (v + 139);\n+      else if (v > 0)\n+      {\n+        v -= 108;\n+        encode_byte ((v >> 8) + OpCode_TwoBytePosInt0);\n+        encode_byte (v & 0xFF);\n+      }\n+      else\n+      {\n+        v = -v - 108;\n+        encode_byte ((v >> 8) + OpCode_TwoByteNegInt0);\n+        encode_byte (v & 0xFF);\n+      }\n+    }\n+    else\n+    {\n+      if (unlikely (v < -32768))\n+        v = -32768;\n+      else if (unlikely (v > 32767))\n+        v = 32767;\n+      encode_byte (OpCode_shortint);\n+      encode_byte ((v >> 8) & 0xFF);\n+      encode_byte (v & 0xFF);\n+    }\n+  }\n+\n+  void encode_num (const number_t& n)\n+  {\n+    if (n.in_int_range ())\n+    {\n+      encode_int (n.to_int ());\n+    }\n+    else\n+    {\n+      int32_t v = n.to_fixed ();\n+      encode_byte (OpCode_fixedcs);\n+      encode_byte ((v >> 24) & 0xFF);\n+      encode_byte ((v >> 16) & 0xFF);\n+      encode_byte ((v >> 8) & 0xFF);\n+      encode_byte (v & 0xFF);\n+    }\n+  }\n+\n+  void encode_op (op_code_t op)\n+  {\n+    if (Is_OpCode_ESC (op))\n+    {\n+      encode_byte (OpCode_escape);\n+      encode_byte (Unmake_OpCode_ESC (op));\n+    }\n+    else\n+      encode_byte (op);\n+  }\n+\n+  void copy_str (const byte_str_t &str)\n+  {\n+    unsigned int  offset = buff.length;\n+    buff.resize (offset + str.length);\n+    if (unlikely (buff.length < offset + str.length))\n+    {\n+      set_error ();\n+      return;\n+    }\n+    memcpy (&buff[offset], &str[0], str.length);\n+  }\n+\n+  bool is_error () const { return error; }\n+\n+  protected:\n+  void set_error () { error = true; }\n+\n+  str_buff_t &buff;\n+  bool    error;\n+};\n+\n+struct cff_sub_table_offsets_t {\n+  cff_sub_table_offsets_t () : privateDictsOffset (0)\n+  {\n+    topDictInfo.init ();\n+    FDSelectInfo.init ();\n+    FDArrayInfo.init ();\n+    charStringsInfo.init ();\n+    globalSubrsInfo.init ();\n+    localSubrsInfos.init ();\n+  }\n+\n+  ~cff_sub_table_offsets_t () { localSubrsInfos.fini (); }\n+\n+  table_info_t     topDictInfo;\n+  table_info_t     FDSelectInfo;\n+  table_info_t     FDArrayInfo;\n+  table_info_t     charStringsInfo;\n+  unsigned int  privateDictsOffset;\n+  table_info_t     globalSubrsInfo;\n+  hb_vector_t<table_info_t>  localSubrsInfos;\n+};\n+\n+template <typename OPSTR=op_str_t>\n+struct cff_top_dict_op_serializer_t : op_serializer_t\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  const OPSTR &opstr,\n+                  const cff_sub_table_offsets_t &offsets) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    switch (opstr.op)\n+    {\n+      case OpCode_CharStrings:\n+        return_trace (FontDict::serialize_offset4_op(c, opstr.op, offsets.charStringsInfo.offset));\n+\n+      case OpCode_FDArray:\n+        return_trace (FontDict::serialize_offset4_op(c, opstr.op, offsets.FDArrayInfo.offset));\n+\n+      case OpCode_FDSelect:\n+        return_trace (FontDict::serialize_offset4_op(c, opstr.op, offsets.FDSelectInfo.offset));\n+\n+      default:\n+        return_trace (copy_opstr (c, opstr));\n+    }\n+    return_trace (true);\n+  }\n+\n+  unsigned int calculate_serialized_size (const OPSTR &opstr) const\n+  {\n+    switch (opstr.op)\n+    {\n+      case OpCode_CharStrings:\n+      case OpCode_FDArray:\n+      case OpCode_FDSelect:\n+        return OpCode_Size (OpCode_longintdict) + 4 + OpCode_Size (opstr.op);\n+\n+      default:\n+        return opstr.str.length;\n+    }\n+  }\n+};\n+\n+struct cff_font_dict_op_serializer_t : op_serializer_t\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  const op_str_t &opstr,\n+                  const table_info_t &privateDictInfo) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (opstr.op == OpCode_Private)\n+    {\n+      \/* serialize the private dict size & offset as 2-byte & 4-byte integers *\/\n+      if (unlikely (!UnsizedByteStr::serialize_int2 (c, privateDictInfo.size) ||\n+                    !UnsizedByteStr::serialize_int4 (c, privateDictInfo.offset)))\n+        return_trace (false);\n+\n+      \/* serialize the opcode *\/\n+      HBUINT8 *p = c->allocate_size<HBUINT8> (1);\n+      if (unlikely (p == nullptr)) return_trace (false);\n+      p->set (OpCode_Private);\n+\n+      return_trace (true);\n+    }\n+    else\n+    {\n+      HBUINT8 *d = c->allocate_size<HBUINT8> (opstr.str.length);\n+      if (unlikely (d == nullptr)) return_trace (false);\n+      memcpy (d, &opstr.str[0], opstr.str.length);\n+    }\n+    return_trace (true);\n+  }\n+\n+  unsigned int calculate_serialized_size (const op_str_t &opstr) const\n+  {\n+    if (opstr.op == OpCode_Private)\n+      return OpCode_Size (OpCode_longintdict) + 4 + OpCode_Size (OpCode_shortint) + 2 + OpCode_Size (OpCode_Private);\n+    else\n+      return opstr.str.length;\n+  }\n+};\n+\n+struct cff_private_dict_op_serializer_t : op_serializer_t\n+{\n+  cff_private_dict_op_serializer_t (bool desubroutinize_, bool drop_hints_)\n+    : desubroutinize (desubroutinize_), drop_hints (drop_hints_) {}\n+\n+  bool serialize (hb_serialize_context_t *c,\n+                  const op_str_t &opstr,\n+                  const unsigned int subrsOffset) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (drop_hints && dict_opset_t::is_hint_op (opstr.op))\n+      return true;\n+    if (opstr.op == OpCode_Subrs)\n+    {\n+      if (desubroutinize || (subrsOffset == 0))\n+        return_trace (true);\n+      else\n+        return_trace (FontDict::serialize_offset2_op (c, opstr.op, subrsOffset));\n+    }\n+    else\n+      return_trace (copy_opstr (c, opstr));\n+  }\n+\n+  unsigned int calculate_serialized_size (const op_str_t &opstr,\n+                                          bool has_localsubr=true) const\n+  {\n+    if (drop_hints && dict_opset_t::is_hint_op (opstr.op))\n+      return 0;\n+    if (opstr.op == OpCode_Subrs)\n+    {\n+      if (desubroutinize || !has_localsubr)\n+        return 0;\n+      else\n+        return OpCode_Size (OpCode_shortint) + 2 + OpCode_Size (opstr.op);\n+    }\n+    else\n+      return opstr.str.length;\n+  }\n+\n+  protected:\n+  const bool  desubroutinize;\n+  const bool  drop_hints;\n+};\n+\n+struct flatten_param_t\n+{\n+  str_buff_t     &flatStr;\n+  bool  drop_hints;\n+\n+  \/\/ Solaris: OS12u4 complains about \"A class with a reference member lacks a user-defined constructor\"\n+  \/\/ so provide the constructor\n+  flatten_param_t(str_buff_t& sbt, bool dh) : flatStr(sbt), drop_hints(dh) {}\n+};\n+\n+template <typename ACC, typename ENV, typename OPSET>\n+struct subr_flattener_t\n+{\n+  subr_flattener_t (const ACC &acc_,\n+                    const hb_vector_t<hb_codepoint_t> &glyphs_,\n+                    bool drop_hints_) : acc (acc_), glyphs (glyphs_),\n+                                        drop_hints (drop_hints_) {}\n+\n+  bool flatten (str_buff_vec_t &flat_charstrings)\n+  {\n+    if (!flat_charstrings.resize (glyphs.length))\n+      return false;\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+      flat_charstrings[i].init ();\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+    {\n+      hb_codepoint_t  glyph = glyphs[i];\n+      const byte_str_t str = (*acc.charStrings)[glyph];\n+      unsigned int fd = acc.fdSelect->get_fd (glyph);\n+      if (unlikely (fd >= acc.fdCount))\n+        return false;\n+      cs_interpreter_t<ENV, OPSET, flatten_param_t> interp;\n+      interp.env.init (str, acc, fd);\n+      \/\/ Solaris: OS12u4 does not like the C++11 style init\n+      \/\/ flatten_param_t  param = { flat_charstrings[i], drop_hints };\n+      flatten_param_t  param(flat_charstrings[i], drop_hints);\n+      if (unlikely (!interp.interpret (param)))\n+        return false;\n+    }\n+    return true;\n+  }\n+\n+  const ACC &acc;\n+  const hb_vector_t<hb_codepoint_t> &glyphs;\n+  bool  drop_hints;\n+};\n+\n+struct subr_closures_t\n+{\n+  subr_closures_t () : valid (false), global_closure (nullptr)\n+  { local_closures.init (); }\n+\n+  void init (unsigned int fd_count)\n+  {\n+    valid = true;\n+    global_closure = hb_set_create ();\n+    if (global_closure == hb_set_get_empty ())\n+      valid = false;\n+    if (!local_closures.resize (fd_count))\n+      valid = false;\n+\n+    for (unsigned int i = 0; i < local_closures.length; i++)\n+    {\n+      local_closures[i] = hb_set_create ();\n+      if (local_closures[i] == hb_set_get_empty ())\n+        valid = false;\n+    }\n+  }\n+\n+  void fini ()\n+  {\n+    hb_set_destroy (global_closure);\n+    for (unsigned int i = 0; i < local_closures.length; i++)\n+      hb_set_destroy (local_closures[i]);\n+    local_closures.fini ();\n+  }\n+\n+  void reset ()\n+  {\n+    hb_set_clear (global_closure);\n+    for (unsigned int i = 0; i < local_closures.length; i++)\n+      hb_set_clear (local_closures[i]);\n+  }\n+\n+  bool is_valid () const { return valid; }\n+  bool  valid;\n+  hb_set_t  *global_closure;\n+  hb_vector_t<hb_set_t *> local_closures;\n+};\n+\n+struct parsed_cs_op_t : op_str_t\n+{\n+  void init (unsigned int subr_num_ = 0)\n+  {\n+    op_str_t::init ();\n+    subr_num = subr_num_;\n+    drop_flag = false;\n+    keep_flag = false;\n+    skip_flag = false;\n+  }\n+\n+  void fini () { op_str_t::fini (); }\n+\n+  bool for_drop () const { return drop_flag; }\n+  void set_drop ()       { if (!for_keep ()) drop_flag = true; }\n+\n+  bool for_keep () const { return keep_flag; }\n+  void set_keep ()       { keep_flag = true; }\n+\n+  bool for_skip () const { return skip_flag; }\n+  void set_skip ()       { skip_flag = true; }\n+\n+  unsigned int  subr_num;\n+\n+  protected:\n+  bool    drop_flag : 1;\n+  bool    keep_flag : 1;\n+  bool    skip_flag : 1;\n+};\n+\n+struct parsed_cs_str_t : parsed_values_t<parsed_cs_op_t>\n+{\n+  void init ()\n+  {\n+    SUPER::init ();\n+    parsed = false;\n+    hint_dropped = false;\n+    has_prefix_ = false;\n+  }\n+\n+  void add_op (op_code_t op, const byte_str_ref_t& str_ref)\n+  {\n+    if (!is_parsed ())\n+      SUPER::add_op (op, str_ref);\n+  }\n+\n+  void add_call_op (op_code_t op, const byte_str_ref_t& str_ref, unsigned int subr_num)\n+  {\n+    if (!is_parsed ())\n+    {\n+      unsigned int parsed_len = get_count ();\n+      if (likely (parsed_len > 0))\n+        values[parsed_len-1].set_skip ();\n+\n+      parsed_cs_op_t val;\n+      val.init (subr_num);\n+      SUPER::add_op (op, str_ref, val);\n+    }\n+  }\n+\n+  void set_prefix (const number_t &num, op_code_t op = OpCode_Invalid)\n+  {\n+    has_prefix_ = true;\n+    prefix_op_ = op;\n+    prefix_num_ = num;\n+  }\n+\n+  bool at_end (unsigned int pos) const\n+  {\n+    return ((pos + 1 >= values.length) \/* CFF2 *\/\n+        || (values[pos + 1].op == OpCode_return));\n+  }\n+\n+  bool is_parsed () const { return parsed; }\n+  void set_parsed ()      { parsed = true; }\n+\n+  bool is_hint_dropped () const { return hint_dropped; }\n+  void set_hint_dropped ()      { hint_dropped = true; }\n+\n+  bool is_vsindex_dropped () const { return vsindex_dropped; }\n+  void set_vsindex_dropped ()      { vsindex_dropped = true; }\n+\n+  bool has_prefix () const          { return has_prefix_; }\n+  op_code_t prefix_op () const         { return prefix_op_; }\n+  const number_t &prefix_num () const { return prefix_num_; }\n+\n+  protected:\n+  bool    parsed;\n+  bool    hint_dropped;\n+  bool    vsindex_dropped;\n+  bool    has_prefix_;\n+  op_code_t     prefix_op_;\n+  number_t      prefix_num_;\n+\n+  private:\n+  typedef parsed_values_t<parsed_cs_op_t> SUPER;\n+};\n+\n+struct parsed_cs_str_vec_t : hb_vector_t<parsed_cs_str_t>\n+{\n+  void init (unsigned int len_ = 0)\n+  {\n+    SUPER::init ();\n+    resize (len_);\n+    for (unsigned int i = 0; i < length; i++)\n+      (*this)[i].init ();\n+  }\n+  void fini () { SUPER::fini_deep (); }\n+\n+  private:\n+  typedef hb_vector_t<parsed_cs_str_t> SUPER;\n+};\n+\n+struct subr_subset_param_t\n+{\n+  void init (parsed_cs_str_t *parsed_charstring_,\n+             parsed_cs_str_vec_t *parsed_global_subrs_, parsed_cs_str_vec_t *parsed_local_subrs_,\n+             hb_set_t *global_closure_, hb_set_t *local_closure_,\n+             bool drop_hints_)\n+  {\n+    parsed_charstring = parsed_charstring_;\n+    current_parsed_str = parsed_charstring;\n+    parsed_global_subrs = parsed_global_subrs_;\n+    parsed_local_subrs = parsed_local_subrs_;\n+    global_closure = global_closure_;\n+    local_closure = local_closure_;\n+    drop_hints = drop_hints_;\n+  }\n+\n+  parsed_cs_str_t *get_parsed_str_for_context (call_context_t &context)\n+  {\n+    switch (context.type)\n+    {\n+      case CSType_CharString:\n+        return parsed_charstring;\n+\n+      case CSType_LocalSubr:\n+        if (likely (context.subr_num < parsed_local_subrs->length))\n+          return &(*parsed_local_subrs)[context.subr_num];\n+        break;\n+\n+      case CSType_GlobalSubr:\n+        if (likely (context.subr_num < parsed_global_subrs->length))\n+          return &(*parsed_global_subrs)[context.subr_num];\n+        break;\n+    }\n+    return nullptr;\n+  }\n+\n+  template <typename ENV>\n+  void set_current_str (ENV &env, bool calling)\n+  {\n+    parsed_cs_str_t  *parsed_str = get_parsed_str_for_context (env.context);\n+    if (likely (parsed_str != nullptr))\n+    {\n+      \/* If the called subroutine is parsed partially but not completely yet,\n+       * it must be because we are calling it recursively.\n+       * Handle it as an error. *\/\n+      if (unlikely (calling && !parsed_str->is_parsed () && (parsed_str->values.length > 0)))\n+        env.set_error ();\n+      else\n+        current_parsed_str = parsed_str;\n+    }\n+    else\n+      env.set_error ();\n+  }\n+\n+  parsed_cs_str_t       *current_parsed_str;\n+\n+  parsed_cs_str_t       *parsed_charstring;\n+  parsed_cs_str_vec_t   *parsed_global_subrs;\n+  parsed_cs_str_vec_t   *parsed_local_subrs;\n+  hb_set_t      *global_closure;\n+  hb_set_t      *local_closure;\n+  bool    drop_hints;\n+};\n+\n+struct subr_remap_t : remap_t\n+{\n+  void create (hb_set_t *closure)\n+  {\n+    \/* create a remapping of subroutine numbers from old to new.\n+     * no optimization based on usage counts. fonttools doesn't appear doing that either.\n+     *\/\n+    reset (closure->get_max () + 1);\n+    for (hb_codepoint_t old_num = 0; old_num < length; old_num++)\n+    {\n+      if (hb_set_has (closure, old_num))\n+        add (old_num);\n+    }\n+\n+    if (get_count () < 1240)\n+      bias = 107;\n+    else if (get_count () < 33900)\n+      bias = 1131;\n+    else\n+      bias = 32768;\n+  }\n+\n+  hb_codepoint_t operator[] (unsigned int old_num) const\n+  {\n+    if (old_num >= length)\n+      return CFF_UNDEF_CODE;\n+    else\n+      return remap_t::operator[] (old_num);\n+  }\n+\n+  int biased_num (unsigned int old_num) const\n+  {\n+    hb_codepoint_t new_num = (*this)[old_num];\n+    return (int)new_num - bias;\n+  }\n+\n+  protected:\n+  int bias;\n+};\n+\n+struct subr_remap_ts\n+{\n+  subr_remap_ts ()\n+  {\n+    global_remap.init ();\n+    local_remaps.init ();\n+  }\n+\n+  ~subr_remap_ts () { fini (); }\n+\n+  void init (unsigned int fdCount)\n+  {\n+    local_remaps.resize (fdCount);\n+    for (unsigned int i = 0; i < fdCount; i++)\n+      local_remaps[i].init ();\n+  }\n+\n+  void create (subr_closures_t& closures)\n+  {\n+    global_remap.create (closures.global_closure);\n+    for (unsigned int i = 0; i < local_remaps.length; i++)\n+      local_remaps[i].create (closures.local_closures[i]);\n+  }\n+\n+  void fini ()\n+  {\n+    global_remap.fini ();\n+    local_remaps.fini_deep ();\n+  }\n+\n+  subr_remap_t         global_remap;\n+  hb_vector_t<subr_remap_t>  local_remaps;\n+};\n+\n+template <typename SUBSETTER, typename SUBRS, typename ACC, typename ENV, typename OPSET>\n+struct subr_subsetter_t\n+{\n+  subr_subsetter_t ()\n+  {\n+    parsed_charstrings.init ();\n+    parsed_global_subrs.init ();\n+    parsed_local_subrs.init ();\n+  }\n+\n+  ~subr_subsetter_t ()\n+  {\n+    closures.fini ();\n+    remaps.fini ();\n+    parsed_charstrings.fini_deep ();\n+    parsed_global_subrs.fini_deep ();\n+    parsed_local_subrs.fini_deep ();\n+  }\n+\n+  \/* Subroutine subsetting with --no-desubroutinize runs in phases:\n+   *\n+   * 1. execute charstrings\/subroutines to determine subroutine closures\n+   * 2. parse out all operators and numbers\n+   * 3. mark hint operators and operands for removal if --no-hinting\n+   * 4. re-encode all charstrings and subroutines with new subroutine numbers\n+   *\n+   * Phases #1 and #2 are done at the same time in collect_subrs ().\n+   * Phase #3 walks charstrings\/subroutines forward then backward (hence parsing required),\n+   * because we can't tell if a number belongs to a hint op until we see the first moveto.\n+   *\n+   * Assumption: a callsubr\/callgsubr operator must immediately follow a (biased) subroutine number\n+   * within the same charstring\/subroutine, e.g., not split across a charstring and a subroutine.\n+   *\/\n+  bool subset (ACC &acc, const hb_vector_t<hb_codepoint_t> &glyphs, bool drop_hints)\n+  {\n+    closures.init (acc.fdCount);\n+    remaps.init (acc.fdCount);\n+\n+    parsed_charstrings.init (glyphs.length);\n+    parsed_global_subrs.init (acc.globalSubrs->count);\n+    parsed_local_subrs.resize (acc.fdCount);\n+    for (unsigned int i = 0; i < acc.fdCount; i++)\n+    {\n+      parsed_local_subrs[i].init (acc.privateDicts[i].localSubrs->count);\n+    }\n+    if (unlikely (!closures.valid))\n+      return false;\n+\n+    \/* phase 1 & 2 *\/\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+    {\n+      hb_codepoint_t  glyph = glyphs[i];\n+      const byte_str_t str = (*acc.charStrings)[glyph];\n+      unsigned int fd = acc.fdSelect->get_fd (glyph);\n+      if (unlikely (fd >= acc.fdCount))\n+        return false;\n+\n+      cs_interpreter_t<ENV, OPSET, subr_subset_param_t> interp;\n+      interp.env.init (str, acc, fd);\n+\n+      subr_subset_param_t  param;\n+      param.init (&parsed_charstrings[i],\n+                  &parsed_global_subrs,  &parsed_local_subrs[fd],\n+                  closures.global_closure, closures.local_closures[fd],\n+                  drop_hints);\n+\n+      if (unlikely (!interp.interpret (param)))\n+        return false;\n+\n+      \/* finalize parsed string esp. copy CFF1 width or CFF2 vsindex to the parsed charstring for encoding *\/\n+      SUBSETTER::finalize_parsed_str (interp.env, param, parsed_charstrings[i]);\n+    }\n+\n+    if (drop_hints)\n+    {\n+      \/* mark hint ops and arguments for drop *\/\n+      for (unsigned int i = 0; i < glyphs.length; i++)\n+      {\n+        unsigned int fd = acc.fdSelect->get_fd (glyphs[i]);\n+        if (unlikely (fd >= acc.fdCount))\n+          return false;\n+        subr_subset_param_t  param;\n+        param.init (&parsed_charstrings[i],\n+                    &parsed_global_subrs,  &parsed_local_subrs[fd],\n+                    closures.global_closure, closures.local_closures[fd],\n+                    drop_hints);\n+\n+        drop_hints_param_t  drop;\n+        if (drop_hints_in_str (parsed_charstrings[i], param, drop))\n+        {\n+          parsed_charstrings[i].set_hint_dropped ();\n+          if (drop.vsindex_dropped)\n+            parsed_charstrings[i].set_vsindex_dropped ();\n+        }\n+      }\n+\n+      \/* after dropping hints recreate closures of actually used subrs *\/\n+      closures.reset ();\n+      for (unsigned int i = 0; i < glyphs.length; i++)\n+      {\n+        unsigned int fd = acc.fdSelect->get_fd (glyphs[i]);\n+        if (unlikely (fd >= acc.fdCount))\n+          return false;\n+        subr_subset_param_t  param;\n+        param.init (&parsed_charstrings[i],\n+                    &parsed_global_subrs,  &parsed_local_subrs[fd],\n+                    closures.global_closure, closures.local_closures[fd],\n+                    drop_hints);\n+        collect_subr_refs_in_str (parsed_charstrings[i], param);\n+      }\n+    }\n+\n+    remaps.create (closures);\n+\n+    return true;\n+  }\n+\n+  bool encode_charstrings (ACC &acc, const hb_vector_t<hb_codepoint_t> &glyphs, str_buff_vec_t &buffArray) const\n+  {\n+    if (unlikely (!buffArray.resize (glyphs.length)))\n+      return false;\n+    for (unsigned int i = 0; i < glyphs.length; i++)\n+    {\n+      unsigned int  fd = acc.fdSelect->get_fd (glyphs[i]);\n+      if (unlikely (fd >= acc.fdCount))\n+        return false;\n+      if (unlikely (!encode_str (parsed_charstrings[i], fd, buffArray[i])))\n+        return false;\n+    }\n+    return true;\n+  }\n+\n+  bool encode_subrs (const parsed_cs_str_vec_t &subrs, const subr_remap_t& remap, unsigned int fd, str_buff_vec_t &buffArray) const\n+  {\n+    unsigned int  count = remap.get_count ();\n+\n+    if (unlikely (!buffArray.resize (count)))\n+      return false;\n+    for (unsigned int old_num = 0; old_num < subrs.length; old_num++)\n+    {\n+      hb_codepoint_t new_num = remap[old_num];\n+      if (new_num != CFF_UNDEF_CODE)\n+      {\n+        if (unlikely (!encode_str (subrs[old_num], fd, buffArray[new_num])))\n+          return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  bool encode_globalsubrs (str_buff_vec_t &buffArray)\n+  {\n+    return encode_subrs (parsed_global_subrs, remaps.global_remap, 0, buffArray);\n+  }\n+\n+  bool encode_localsubrs (unsigned int fd, str_buff_vec_t &buffArray) const\n+  {\n+    return encode_subrs (parsed_local_subrs[fd], remaps.local_remaps[fd], fd, buffArray);\n+  }\n+\n+  protected:\n+  struct drop_hints_param_t\n+  {\n+    drop_hints_param_t ()\n+      : seen_moveto (false),\n+        ends_in_hint (false),\n+        vsindex_dropped (false) {}\n+\n+    bool  seen_moveto;\n+    bool  ends_in_hint;\n+    bool  vsindex_dropped;\n+  };\n+\n+  bool drop_hints_in_subr (parsed_cs_str_t &str, unsigned int pos,\n+                           parsed_cs_str_vec_t &subrs, unsigned int subr_num,\n+                           const subr_subset_param_t &param, drop_hints_param_t &drop)\n+  {\n+    drop.ends_in_hint = false;\n+    bool has_hint = drop_hints_in_str (subrs[subr_num], param, drop);\n+\n+    \/* if this subr ends with a stem hint (i.e., not a number a potential argument for moveto),\n+     * then this entire subroutine must be a hint. drop its call. *\/\n+    if (drop.ends_in_hint)\n+    {\n+      str.values[pos].set_drop ();\n+      \/* if this subr call is at the end of the parent subr, propagate the flag\n+       * otherwise reset the flag *\/\n+      if (!str.at_end (pos))\n+        drop.ends_in_hint = false;\n+    }\n+\n+    return has_hint;\n+  }\n+\n+  \/* returns true if it sees a hint op before the first moveto *\/\n+  bool drop_hints_in_str (parsed_cs_str_t &str, const subr_subset_param_t &param, drop_hints_param_t &drop)\n+  {\n+    bool  seen_hint = false;\n+\n+    for (unsigned int pos = 0; pos < str.values.length; pos++)\n+    {\n+      bool  has_hint = false;\n+      switch (str.values[pos].op)\n+      {\n+        case OpCode_callsubr:\n+          has_hint = drop_hints_in_subr (str, pos,\n+                                        *param.parsed_local_subrs, str.values[pos].subr_num,\n+                                        param, drop);\n+\n+          break;\n+\n+        case OpCode_callgsubr:\n+          has_hint = drop_hints_in_subr (str, pos,\n+                                        *param.parsed_global_subrs, str.values[pos].subr_num,\n+                                        param, drop);\n+          break;\n+\n+        case OpCode_rmoveto:\n+        case OpCode_hmoveto:\n+        case OpCode_vmoveto:\n+          drop.seen_moveto = true;\n+          break;\n+\n+        case OpCode_hintmask:\n+        case OpCode_cntrmask:\n+          if (drop.seen_moveto)\n+          {\n+            str.values[pos].set_drop ();\n+            break;\n+          }\n+          HB_FALLTHROUGH;\n+\n+        case OpCode_hstemhm:\n+        case OpCode_vstemhm:\n+        case OpCode_hstem:\n+        case OpCode_vstem:\n+          has_hint = true;\n+          str.values[pos].set_drop ();\n+          if (str.at_end (pos))\n+            drop.ends_in_hint = true;\n+          break;\n+\n+        case OpCode_dotsection:\n+          str.values[pos].set_drop ();\n+          break;\n+\n+        default:\n+          \/* NONE *\/\n+          break;\n+      }\n+      if (has_hint)\n+      {\n+        for (int i = pos - 1; i >= 0; i--)\n+        {\n+          parsed_cs_op_t  &csop = str.values[(unsigned)i];\n+          if (csop.for_drop ())\n+            break;\n+          csop.set_drop ();\n+          if (csop.op == OpCode_vsindexcs)\n+            drop.vsindex_dropped = true;\n+        }\n+        seen_hint |= has_hint;\n+      }\n+    }\n+\n+    return seen_hint;\n+  }\n+\n+  void collect_subr_refs_in_subr (parsed_cs_str_t &str, unsigned int pos,\n+                                  unsigned int subr_num, parsed_cs_str_vec_t &subrs,\n+                                  hb_set_t *closure,\n+                                  const subr_subset_param_t &param)\n+  {\n+    hb_set_add (closure, subr_num);\n+    collect_subr_refs_in_str (subrs[subr_num], param);\n+  }\n+\n+  void collect_subr_refs_in_str (parsed_cs_str_t &str, const subr_subset_param_t &param)\n+  {\n+    for (unsigned int pos = 0; pos < str.values.length; pos++)\n+    {\n+      if (!str.values[pos].for_drop ())\n+      {\n+        switch (str.values[pos].op)\n+        {\n+          case OpCode_callsubr:\n+            collect_subr_refs_in_subr (str, pos,\n+                                       str.values[pos].subr_num, *param.parsed_local_subrs,\n+                                       param.local_closure, param);\n+            break;\n+\n+          case OpCode_callgsubr:\n+            collect_subr_refs_in_subr (str, pos,\n+                                       str.values[pos].subr_num, *param.parsed_global_subrs,\n+                                       param.global_closure, param);\n+            break;\n+\n+          default: break;\n+        }\n+      }\n+    }\n+  }\n+\n+  bool encode_str (const parsed_cs_str_t &str, const unsigned int fd, str_buff_t &buff) const\n+  {\n+    buff.init ();\n+    str_encoder_t  encoder (buff);\n+    encoder.reset ();\n+    \/* if a prefix (CFF1 width or CFF2 vsindex) has been removed along with hints,\n+     * re-insert it at the beginning of charstreing *\/\n+    if (str.has_prefix () && str.is_hint_dropped ())\n+    {\n+      encoder.encode_num (str.prefix_num ());\n+      if (str.prefix_op () != OpCode_Invalid)\n+        encoder.encode_op (str.prefix_op ());\n+    }\n+    for (unsigned int i = 0; i < str.get_count(); i++)\n+    {\n+      const parsed_cs_op_t  &opstr = str.values[i];\n+      if (!opstr.for_drop () && !opstr.for_skip ())\n+      {\n+        switch (opstr.op)\n+        {\n+          case OpCode_callsubr:\n+            encoder.encode_int (remaps.local_remaps[fd].biased_num (opstr.subr_num));\n+            encoder.encode_op (OpCode_callsubr);\n+            break;\n+\n+          case OpCode_callgsubr:\n+            encoder.encode_int (remaps.global_remap.biased_num (opstr.subr_num));\n+            encoder.encode_op (OpCode_callgsubr);\n+            break;\n+\n+          default:\n+            encoder.copy_str (opstr.str);\n+            break;\n+        }\n+      }\n+    }\n+    return !encoder.is_error ();\n+  }\n+\n+  protected:\n+  subr_closures_t             closures;\n+\n+  parsed_cs_str_vec_t          parsed_charstrings;\n+  parsed_cs_str_vec_t          parsed_global_subrs;\n+  hb_vector_t<parsed_cs_str_vec_t>  parsed_local_subrs;\n+\n+  subr_remap_ts         remaps;\n+\n+  private:\n+  typedef typename SUBRS::count_type subr_count_type;\n+};\n+\n+} \/* namespace CFF *\/\n+\n+HB_INTERNAL bool\n+hb_plan_subset_cff_fdselect (const hb_vector_t<hb_codepoint_t> &glyphs,\n+                            unsigned int fdCount,\n+                            const CFF::FDSelect &src, \/* IN *\/\n+                            unsigned int &subset_fd_count \/* OUT *\/,\n+                            unsigned int &subset_fdselect_size \/* OUT *\/,\n+                            unsigned int &subset_fdselect_format \/* OUT *\/,\n+                            hb_vector_t<CFF::code_pair_t> &fdselect_ranges \/* OUT *\/,\n+                            CFF::remap_t &fdmap \/* OUT *\/);\n+\n+HB_INTERNAL bool\n+hb_serialize_cff_fdselect (hb_serialize_context_t *c,\n+                           \/\/ Solaris does not link because the implementation in .cc specifies num_glyphs as const.\n+                          const unsigned int num_glyphs,\n+                          const CFF::FDSelect &src,\n+                          unsigned int fd_count,\n+                          unsigned int fdselect_format,\n+                          unsigned int size,\n+                          const hb_vector_t<CFF::code_pair_t> &fdselect_ranges);\n+\n+#endif \/* HB_SUBSET_CFF_COMMON_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-cff-common.hh","additions":997,"deletions":0,"binary":false,"changes":997,"status":"added"},{"patch":"@@ -0,0 +1,1103 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-cff1-table.hh\"\n+#include \"hb-set.h\"\n+#include \"hb-subset-cff1.hh\"\n+#include \"hb-subset-plan.hh\"\n+#include \"hb-subset-cff-common.hh\"\n+#include \"hb-cff1-interp-cs.hh\"\n+\n+using namespace CFF;\n+\n+struct remap_sid_t : remap_t\n+{\n+  unsigned int add (unsigned int sid)\n+  {\n+    if ((sid != CFF_UNDEF_SID) && !is_std_std (sid))\n+      return offset_sid (remap_t::add (unoffset_sid (sid)));\n+    else\n+      return sid;\n+  }\n+\n+  unsigned int operator[] (unsigned int sid) const\n+  {\n+    if (is_std_std (sid) || (sid == CFF_UNDEF_SID))\n+      return sid;\n+    else\n+      return offset_sid (remap_t::operator [] (unoffset_sid (sid)));\n+  }\n+\n+  static const unsigned int num_std_strings = 391;\n+\n+  static bool is_std_std (unsigned int sid) { return sid < num_std_strings; }\n+  static unsigned int offset_sid (unsigned int sid) { return sid + num_std_strings; }\n+  static unsigned int unoffset_sid (unsigned int sid) { return sid - num_std_strings; }\n+};\n+\n+struct cff1_sub_table_offsets_t : cff_sub_table_offsets_t\n+{\n+  cff1_sub_table_offsets_t ()\n+    : cff_sub_table_offsets_t (),\n+      nameIndexOffset (0),\n+      encodingOffset (0)\n+  {\n+    stringIndexInfo.init ();\n+    charsetInfo.init ();\n+    privateDictInfo.init ();\n+  }\n+\n+  unsigned int  nameIndexOffset;\n+  table_info_t  stringIndexInfo;\n+  unsigned int  encodingOffset;\n+  table_info_t  charsetInfo;\n+  table_info_t  privateDictInfo;\n+};\n+\n+\/* a copy of a parsed out cff1_top_dict_values_t augmented with additional operators *\/\n+struct cff1_top_dict_values_mod_t : cff1_top_dict_values_t\n+{\n+  void init (const cff1_top_dict_values_t *base_= &Null(cff1_top_dict_values_t))\n+  {\n+    SUPER::init ();\n+    base = base_;\n+  }\n+\n+  void fini () { SUPER::fini (); }\n+\n+  unsigned get_count () const { return base->get_count () + SUPER::get_count (); }\n+  const cff1_top_dict_val_t &get_value (unsigned int i) const\n+  {\n+    if (i < base->get_count ())\n+      return (*base)[i];\n+    else\n+      return SUPER::values[i - base->get_count ()];\n+  }\n+  const cff1_top_dict_val_t &operator [] (unsigned int i) const { return get_value (i); }\n+\n+  void reassignSIDs (const remap_sid_t& sidmap)\n+  {\n+    for (unsigned int i = 0; i < name_dict_values_t::ValCount; i++)\n+      nameSIDs[i] = sidmap[base->nameSIDs[i]];\n+  }\n+\n+  protected:\n+  typedef cff1_top_dict_values_t SUPER;\n+  const cff1_top_dict_values_t *base;\n+};\n+\n+struct top_dict_modifiers_t\n+{\n+  top_dict_modifiers_t (const cff1_sub_table_offsets_t &offsets_,\n+                           const unsigned int (&nameSIDs_)[name_dict_values_t::ValCount])\n+    : offsets (offsets_),\n+      nameSIDs (nameSIDs_)\n+  {}\n+\n+  const cff1_sub_table_offsets_t &offsets;\n+  const unsigned int    (&nameSIDs)[name_dict_values_t::ValCount];\n+};\n+\n+struct cff1_top_dict_op_serializer_t : cff_top_dict_op_serializer_t<cff1_top_dict_val_t>\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  const cff1_top_dict_val_t &opstr,\n+                  const top_dict_modifiers_t &mod) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    op_code_t op = opstr.op;\n+    switch (op)\n+    {\n+      case OpCode_charset:\n+        return_trace (FontDict::serialize_offset4_op(c, op, mod.offsets.charsetInfo.offset));\n+\n+      case OpCode_Encoding:\n+        return_trace (FontDict::serialize_offset4_op(c, op, mod.offsets.encodingOffset));\n+\n+      case OpCode_Private:\n+        {\n+          if (unlikely (!UnsizedByteStr::serialize_int2 (c, mod.offsets.privateDictInfo.size)))\n+            return_trace (false);\n+          if (unlikely (!UnsizedByteStr::serialize_int4 (c, mod.offsets.privateDictInfo.offset)))\n+            return_trace (false);\n+          HBUINT8 *p = c->allocate_size<HBUINT8> (1);\n+          if (unlikely (p == nullptr)) return_trace (false);\n+          p->set (OpCode_Private);\n+        }\n+        break;\n+\n+      case OpCode_version:\n+      case OpCode_Notice:\n+      case OpCode_Copyright:\n+      case OpCode_FullName:\n+      case OpCode_FamilyName:\n+      case OpCode_Weight:\n+      case OpCode_PostScript:\n+      case OpCode_BaseFontName:\n+      case OpCode_FontName:\n+        return_trace (FontDict::serialize_offset2_op(c, op, mod.nameSIDs[name_dict_values_t::name_op_to_index (op)]));\n+\n+      case OpCode_ROS:\n+        {\n+          \/* for registry & ordering, reassigned SIDs are serialized\n+           * for supplement, the original byte string is copied along with the op code *\/\n+          op_str_t supp_op;\n+          supp_op.op = op;\n+          if ( unlikely (!(opstr.str.length >= opstr.last_arg_offset + 3)))\n+            return_trace (false);\n+          supp_op.str = byte_str_t (&opstr.str + opstr.last_arg_offset, opstr.str.length - opstr.last_arg_offset);\n+          return_trace (UnsizedByteStr::serialize_int2 (c, mod.nameSIDs[name_dict_values_t::registry]) &&\n+                        UnsizedByteStr::serialize_int2 (c, mod.nameSIDs[name_dict_values_t::ordering]) &&\n+                        copy_opstr (c, supp_op));\n+        }\n+      default:\n+        return_trace (cff_top_dict_op_serializer_t<cff1_top_dict_val_t>::serialize (c, opstr, mod.offsets));\n+    }\n+    return_trace (true);\n+  }\n+\n+  unsigned int calculate_serialized_size (const cff1_top_dict_val_t &opstr) const\n+  {\n+    op_code_t op = opstr.op;\n+    switch (op)\n+    {\n+      case OpCode_charset:\n+      case OpCode_Encoding:\n+        return OpCode_Size (OpCode_longintdict) + 4 + OpCode_Size (op);\n+\n+      case OpCode_Private:\n+        return OpCode_Size (OpCode_longintdict) + 4 + OpCode_Size (OpCode_shortint) + 2 + OpCode_Size (OpCode_Private);\n+\n+      case OpCode_version:\n+      case OpCode_Notice:\n+      case OpCode_Copyright:\n+      case OpCode_FullName:\n+      case OpCode_FamilyName:\n+      case OpCode_Weight:\n+      case OpCode_PostScript:\n+      case OpCode_BaseFontName:\n+      case OpCode_FontName:\n+        return OpCode_Size (OpCode_shortint) + 2 + OpCode_Size (op);\n+\n+      case OpCode_ROS:\n+        return ((OpCode_Size (OpCode_shortint) + 2) * 2) + (opstr.str.length - opstr.last_arg_offset)\/* supplement + op *\/;\n+\n+      default:\n+        return cff_top_dict_op_serializer_t<cff1_top_dict_val_t>::calculate_serialized_size (opstr);\n+    }\n+  }\n+};\n+\n+struct font_dict_values_mod_t\n+{\n+  void init (const cff1_font_dict_values_t *base_,\n+             unsigned int fontName_,\n+             const table_info_t &privateDictInfo_)\n+  {\n+    base = base_;\n+    fontName = fontName_;\n+    privateDictInfo = privateDictInfo_;\n+  }\n+\n+  unsigned get_count () const { return base->get_count (); }\n+\n+  const op_str_t &operator [] (unsigned int i) const { return (*base)[i]; }\n+\n+  const cff1_font_dict_values_t    *base;\n+  table_info_t             privateDictInfo;\n+  unsigned int          fontName;\n+};\n+\n+struct cff1_font_dict_op_serializer_t : cff_font_dict_op_serializer_t\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  const op_str_t &opstr,\n+                  const font_dict_values_mod_t &mod) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    if (opstr.op == OpCode_FontName)\n+      return_trace (FontDict::serialize_uint2_op (c, opstr.op, mod.fontName));\n+    else\n+      return_trace (SUPER::serialize (c, opstr, mod.privateDictInfo));\n+  }\n+\n+  unsigned int calculate_serialized_size (const op_str_t &opstr) const\n+  {\n+    if (opstr.op == OpCode_FontName)\n+      return OpCode_Size (OpCode_shortint) + 2 + OpCode_Size (OpCode_FontName);\n+    else\n+      return SUPER::calculate_serialized_size (opstr);\n+  }\n+\n+  private:\n+  typedef cff_font_dict_op_serializer_t SUPER;\n+};\n+\n+struct cff1_cs_opset_flatten_t : cff1_cs_opset_t<cff1_cs_opset_flatten_t, flatten_param_t>\n+{\n+  static void flush_args_and_op (op_code_t op, cff1_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    if (env.arg_start > 0)\n+      flush_width (env, param);\n+\n+    switch (op)\n+    {\n+      case OpCode_hstem:\n+      case OpCode_hstemhm:\n+      case OpCode_vstem:\n+      case OpCode_vstemhm:\n+      case OpCode_hintmask:\n+      case OpCode_cntrmask:\n+      case OpCode_dotsection:\n+        if (param.drop_hints)\n+        {\n+          env.clear_args ();\n+          return;\n+        }\n+        HB_FALLTHROUGH;\n+\n+      default:\n+        SUPER::flush_args_and_op (op, env, param);\n+        break;\n+    }\n+  }\n+  static void flush_args (cff1_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    str_encoder_t  encoder (param.flatStr);\n+    for (unsigned int i = env.arg_start; i < env.argStack.get_count (); i++)\n+      encoder.encode_num (env.eval_arg (i));\n+    SUPER::flush_args (env, param);\n+  }\n+\n+  static void flush_op (op_code_t op, cff1_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    str_encoder_t  encoder (param.flatStr);\n+    encoder.encode_op (op);\n+  }\n+\n+  static void flush_width (cff1_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    assert (env.has_width);\n+    str_encoder_t  encoder (param.flatStr);\n+    encoder.encode_num (env.width);\n+  }\n+\n+  static void flush_hintmask (op_code_t op, cff1_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    SUPER::flush_hintmask (op, env, param);\n+    if (!param.drop_hints)\n+    {\n+      str_encoder_t  encoder (param.flatStr);\n+      for (unsigned int i = 0; i < env.hintmask_size; i++)\n+        encoder.encode_byte (env.str_ref[i]);\n+    }\n+  }\n+\n+  private:\n+  typedef cff1_cs_opset_t<cff1_cs_opset_flatten_t, flatten_param_t> SUPER;\n+};\n+\n+struct range_list_t : hb_vector_t<code_pair_t>\n+{\n+  \/* replace the first glyph ID in the \"glyph\" field each range with a nLeft value *\/\n+  bool finalize (unsigned int last_glyph)\n+  {\n+    bool  two_byte = false;\n+    for (unsigned int i = (*this).length; i > 0; i--)\n+    {\n+      code_pair_t &pair = (*this)[i - 1];\n+      unsigned int  nLeft = last_glyph - pair.glyph - 1;\n+      if (nLeft >= 0x100)\n+        two_byte = true;\n+      last_glyph = pair.glyph;\n+      pair.glyph = nLeft;\n+    }\n+    return two_byte;\n+  }\n+};\n+\n+struct cff1_cs_opset_subr_subset_t : cff1_cs_opset_t<cff1_cs_opset_subr_subset_t, subr_subset_param_t>\n+{\n+  static void process_op (op_code_t op, cff1_cs_interp_env_t &env, subr_subset_param_t& param)\n+  {\n+    switch (op) {\n+\n+      case OpCode_return:\n+        param.current_parsed_str->add_op (op, env.str_ref);\n+        param.current_parsed_str->set_parsed ();\n+        env.returnFromSubr ();\n+        param.set_current_str (env, false);\n+        break;\n+\n+      case OpCode_endchar:\n+        param.current_parsed_str->add_op (op, env.str_ref);\n+        param.current_parsed_str->set_parsed ();\n+        SUPER::process_op (op, env, param);\n+        break;\n+\n+      case OpCode_callsubr:\n+        process_call_subr (op, CSType_LocalSubr, env, param, env.localSubrs, param.local_closure);\n+        break;\n+\n+      case OpCode_callgsubr:\n+        process_call_subr (op, CSType_GlobalSubr, env, param, env.globalSubrs, param.global_closure);\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env, param);\n+        param.current_parsed_str->add_op (op, env.str_ref);\n+        break;\n+    }\n+  }\n+\n+  protected:\n+  static void process_call_subr (op_code_t op, cs_type_t type,\n+                                 cff1_cs_interp_env_t &env, subr_subset_param_t& param,\n+                                 cff1_biased_subrs_t& subrs, hb_set_t *closure)\n+  {\n+    byte_str_ref_t    str_ref = env.str_ref;\n+    env.callSubr (subrs, type);\n+    param.current_parsed_str->add_call_op (op, str_ref, env.context.subr_num);\n+    hb_set_add (closure, env.context.subr_num);\n+    param.set_current_str (env, true);\n+  }\n+\n+  private:\n+  typedef cff1_cs_opset_t<cff1_cs_opset_subr_subset_t, subr_subset_param_t> SUPER;\n+};\n+\n+struct cff1_subr_subsetter_t : subr_subsetter_t<cff1_subr_subsetter_t, CFF1Subrs, const OT::cff1::accelerator_subset_t, cff1_cs_interp_env_t, cff1_cs_opset_subr_subset_t>\n+{\n+  static void finalize_parsed_str (cff1_cs_interp_env_t &env, subr_subset_param_t& param, parsed_cs_str_t &charstring)\n+  {\n+    \/* insert width at the beginning of the charstring as necessary *\/\n+    if (env.has_width)\n+      charstring.set_prefix (env.width);\n+\n+    \/* subroutines\/charstring left on the call stack are legally left unmarked\n+     * unmarked when a subroutine terminates with endchar. mark them.\n+     *\/\n+    param.current_parsed_str->set_parsed ();\n+    for (unsigned int i = 0; i < env.callStack.get_count (); i++)\n+    {\n+      parsed_cs_str_t  *parsed_str = param.get_parsed_str_for_context (env.callStack[i]);\n+      if (likely (parsed_str != nullptr))\n+        parsed_str->set_parsed ();\n+      else\n+        env.set_error ();\n+    }\n+  }\n+};\n+\n+struct cff_subset_plan {\n+  cff_subset_plan ()\n+    : final_size (0),\n+      offsets (),\n+      orig_fdcount (0),\n+      subset_fdcount (1),\n+      subset_fdselect_format (0),\n+      drop_hints (false),\n+      desubroutinize(false)\n+  {\n+    topdict_sizes.init ();\n+    topdict_sizes.resize (1);\n+    topdict_mod.init ();\n+    subset_fdselect_ranges.init ();\n+    fdmap.init ();\n+    subset_charstrings.init ();\n+    subset_globalsubrs.init ();\n+    subset_localsubrs.init ();\n+    fontdicts_mod.init ();\n+    subset_enc_code_ranges.init ();\n+    subset_enc_supp_codes.init ();\n+    subset_charset_ranges.init ();\n+    sidmap.init ();\n+    for (unsigned int i = 0; i < name_dict_values_t::ValCount; i++)\n+      topDictModSIDs[i] = CFF_UNDEF_SID;\n+  }\n+\n+  ~cff_subset_plan ()\n+  {\n+    topdict_sizes.fini ();\n+    topdict_mod.fini ();\n+    subset_fdselect_ranges.fini ();\n+    fdmap.fini ();\n+    subset_charstrings.fini_deep ();\n+    subset_globalsubrs.fini_deep ();\n+    subset_localsubrs.fini_deep ();\n+    fontdicts_mod.fini ();\n+    subset_enc_code_ranges.fini ();\n+    subset_enc_supp_codes.fini ();\n+    subset_charset_ranges.fini ();\n+    sidmap.fini ();\n+  }\n+\n+  unsigned int plan_subset_encoding (const OT::cff1::accelerator_subset_t &acc, hb_subset_plan_t *plan)\n+  {\n+    const Encoding *encoding = acc.encoding;\n+    unsigned int  size0, size1, supp_size;\n+    hb_codepoint_t  code, last_code = CFF_UNDEF_CODE;\n+    hb_vector_t<hb_codepoint_t> supp_codes;\n+\n+    subset_enc_code_ranges.resize (0);\n+    supp_size = 0;\n+    supp_codes.init ();\n+\n+    subset_enc_num_codes = plan->glyphs.length - 1;\n+    unsigned int glyph;\n+    for (glyph = 1; glyph < plan->glyphs.length; glyph++)\n+    {\n+      hb_codepoint_t  orig_glyph = plan->glyphs[glyph];\n+      code = acc.glyph_to_code (orig_glyph);\n+      if (code == CFF_UNDEF_CODE)\n+      {\n+        subset_enc_num_codes = glyph - 1;\n+        break;\n+      }\n+\n+      if (code != last_code + 1)\n+      {\n+        code_pair_t pair = { code, glyph };\n+        subset_enc_code_ranges.push (pair);\n+      }\n+      last_code = code;\n+\n+      if (encoding != &Null(Encoding))\n+      {\n+        hb_codepoint_t  sid = acc.glyph_to_sid (orig_glyph);\n+        encoding->get_supplement_codes (sid, supp_codes);\n+        for (unsigned int i = 0; i < supp_codes.length; i++)\n+        {\n+          code_pair_t pair = { supp_codes[i], sid };\n+          subset_enc_supp_codes.push (pair);\n+        }\n+        supp_size += SuppEncoding::static_size * supp_codes.length;\n+      }\n+    }\n+    supp_codes.fini ();\n+\n+    subset_enc_code_ranges.finalize (glyph);\n+\n+    assert (subset_enc_num_codes <= 0xFF);\n+    size0 = Encoding0::min_size + HBUINT8::static_size * subset_enc_num_codes;\n+    size1 = Encoding1::min_size + Encoding1_Range::static_size * subset_enc_code_ranges.length;\n+\n+    if (size0 < size1)\n+      subset_enc_format = 0;\n+    else\n+      subset_enc_format = 1;\n+\n+    return Encoding::calculate_serialized_size (\n+                        subset_enc_format,\n+                        subset_enc_format? subset_enc_code_ranges.length: subset_enc_num_codes,\n+                        subset_enc_supp_codes.length);\n+  }\n+\n+  unsigned int plan_subset_charset (const OT::cff1::accelerator_subset_t &acc, hb_subset_plan_t *plan)\n+  {\n+    unsigned int  size0, size_ranges;\n+    hb_codepoint_t  sid, last_sid = CFF_UNDEF_CODE;\n+\n+    subset_charset_ranges.resize (0);\n+    unsigned int glyph;\n+    for (glyph = 1; glyph < plan->glyphs.length; glyph++)\n+    {\n+      hb_codepoint_t  orig_glyph = plan->glyphs[glyph];\n+      sid = acc.glyph_to_sid (orig_glyph);\n+\n+      if (!acc.is_CID ())\n+        sid = sidmap.add (sid);\n+\n+      if (sid != last_sid + 1)\n+      {\n+        code_pair_t pair = { sid, glyph };\n+        subset_charset_ranges.push (pair);\n+      }\n+      last_sid = sid;\n+    }\n+\n+    bool two_byte = subset_charset_ranges.finalize (glyph);\n+\n+    size0 = Charset0::min_size + HBUINT16::static_size * (plan->glyphs.length - 1);\n+    if (!two_byte)\n+      size_ranges = Charset1::min_size + Charset1_Range::static_size * subset_charset_ranges.length;\n+    else\n+      size_ranges = Charset2::min_size + Charset2_Range::static_size * subset_charset_ranges.length;\n+\n+    if (size0 < size_ranges)\n+      subset_charset_format = 0;\n+    else if (!two_byte)\n+      subset_charset_format = 1;\n+    else\n+      subset_charset_format = 2;\n+\n+    return Charset::calculate_serialized_size (\n+                        subset_charset_format,\n+                        subset_charset_format? subset_charset_ranges.length: plan->glyphs.length);\n+  }\n+\n+  bool collect_sids_in_dicts (const OT::cff1::accelerator_subset_t &acc)\n+  {\n+    if (unlikely (!sidmap.reset (acc.stringIndex->count)))\n+      return false;\n+\n+    for (unsigned int i = 0; i < name_dict_values_t::ValCount; i++)\n+    {\n+      unsigned int sid = acc.topDict.nameSIDs[i];\n+      if (sid != CFF_UNDEF_SID)\n+      {\n+        (void)sidmap.add (sid);\n+        topDictModSIDs[i] = sidmap[sid];\n+      }\n+    }\n+\n+    if (acc.fdArray != &Null(CFF1FDArray))\n+      for (unsigned int i = 0; i < orig_fdcount; i++)\n+        if (fdmap.includes (i))\n+          (void)sidmap.add (acc.fontDicts[i].fontName);\n+\n+    return true;\n+  }\n+\n+  bool create (const OT::cff1::accelerator_subset_t &acc,\n+                      hb_subset_plan_t *plan)\n+  {\n+     \/* make sure notdef is first *\/\n+    if ((plan->glyphs.length == 0) || (plan->glyphs[0] != 0)) return false;\n+\n+    final_size = 0;\n+    num_glyphs = plan->glyphs.length;\n+    orig_fdcount = acc.fdCount;\n+    drop_hints = plan->drop_hints;\n+    desubroutinize = plan->desubroutinize;\n+\n+    \/* check whether the subset renumbers any glyph IDs *\/\n+    gid_renum = false;\n+    for (unsigned int glyph = 0; glyph < plan->glyphs.length; glyph++)\n+    {\n+      if (plan->glyphs[glyph] != glyph) {\n+        gid_renum = true;\n+        break;\n+      }\n+    }\n+\n+    subset_charset = gid_renum || !acc.is_predef_charset ();\n+    subset_encoding = !acc.is_CID() && !acc.is_predef_encoding ();\n+\n+    \/* CFF header *\/\n+    final_size += OT::cff1::static_size;\n+\n+    \/* Name INDEX *\/\n+    offsets.nameIndexOffset = final_size;\n+    final_size += acc.nameIndex->get_size ();\n+\n+    \/* top dict INDEX *\/\n+    {\n+      \/* Add encoding\/charset to a (copy of) top dict as necessary *\/\n+      topdict_mod.init (&acc.topDict);\n+      bool need_to_add_enc = (subset_encoding && !acc.topDict.has_op (OpCode_Encoding));\n+      bool need_to_add_set = (subset_charset && !acc.topDict.has_op (OpCode_charset));\n+      if (need_to_add_enc || need_to_add_set)\n+      {\n+        if (need_to_add_enc)\n+          topdict_mod.add_op (OpCode_Encoding);\n+        if (need_to_add_set)\n+          topdict_mod.add_op (OpCode_charset);\n+      }\n+      offsets.topDictInfo.offset = final_size;\n+      cff1_top_dict_op_serializer_t topSzr;\n+      unsigned int topDictSize = TopDict::calculate_serialized_size (topdict_mod, topSzr);\n+      offsets.topDictInfo.offSize = calcOffSize(topDictSize);\n+      if (unlikely (offsets.topDictInfo.offSize > 4))\n+        return false;\n+      final_size += CFF1IndexOf<TopDict>::calculate_serialized_size<cff1_top_dict_values_mod_t>\n+                                                (offsets.topDictInfo.offSize,\n+                                                 &topdict_mod, 1, topdict_sizes, topSzr);\n+    }\n+\n+    \/* Determine re-mapping of font index as fdmap among other info *\/\n+    if (acc.fdSelect != &Null(CFF1FDSelect))\n+    {\n+        if (unlikely (!hb_plan_subset_cff_fdselect (plan->glyphs,\n+                                  orig_fdcount,\n+                                  *acc.fdSelect,\n+                                  subset_fdcount,\n+                                  offsets.FDSelectInfo.size,\n+                                  subset_fdselect_format,\n+                                  subset_fdselect_ranges,\n+                                  fdmap)))\n+        return false;\n+    }\n+    else\n+      fdmap.identity (1);\n+\n+    \/* remove unused SIDs & reassign SIDs *\/\n+    {\n+      \/* SIDs for name strings in dicts are added before glyph names so they fit in 16-bit int range *\/\n+      if (unlikely (!collect_sids_in_dicts (acc)))\n+        return false;\n+      if (unlikely (sidmap.get_count () > 0x8000))      \/* assumption: a dict won't reference that many strings *\/\n+        return false;\n+      if (subset_charset)\n+        offsets.charsetInfo.size = plan_subset_charset (acc, plan);\n+\n+      topdict_mod.reassignSIDs (sidmap);\n+    }\n+\n+    \/* String INDEX *\/\n+    {\n+      offsets.stringIndexInfo.offset = final_size;\n+      offsets.stringIndexInfo.size = acc.stringIndex->calculate_serialized_size (offsets.stringIndexInfo.offSize, sidmap);\n+      final_size += offsets.stringIndexInfo.size;\n+    }\n+\n+    if (desubroutinize)\n+    {\n+      \/* Flatten global & local subrs *\/\n+      subr_flattener_t<const OT::cff1::accelerator_subset_t, cff1_cs_interp_env_t, cff1_cs_opset_flatten_t>\n+                    flattener(acc, plan->glyphs, plan->drop_hints);\n+      if (!flattener.flatten (subset_charstrings))\n+        return false;\n+\n+      \/* no global\/local subroutines *\/\n+      offsets.globalSubrsInfo.size = CFF1Subrs::calculate_serialized_size (1, 0, 0);\n+    }\n+    else\n+    {\n+      \/* Subset subrs: collect used subroutines, leaving all unused ones behind *\/\n+      if (!subr_subsetter.subset (acc, plan->glyphs, plan->drop_hints))\n+        return false;\n+\n+      \/* encode charstrings, global subrs, local subrs with new subroutine numbers *\/\n+      if (!subr_subsetter.encode_charstrings (acc, plan->glyphs, subset_charstrings))\n+        return false;\n+\n+      if (!subr_subsetter.encode_globalsubrs (subset_globalsubrs))\n+        return false;\n+\n+      \/* global subrs *\/\n+      unsigned int dataSize = subset_globalsubrs.total_size ();\n+      offsets.globalSubrsInfo.offSize = calcOffSize (dataSize);\n+      if (unlikely (offsets.globalSubrsInfo.offSize > 4))\n+        return false;\n+      offsets.globalSubrsInfo.size = CFF1Subrs::calculate_serialized_size (offsets.globalSubrsInfo.offSize, subset_globalsubrs.length, dataSize);\n+\n+      \/* local subrs *\/\n+      if (!offsets.localSubrsInfos.resize (orig_fdcount))\n+        return false;\n+      if (!subset_localsubrs.resize (orig_fdcount))\n+        return false;\n+      for (unsigned int fd = 0; fd < orig_fdcount; fd++)\n+      {\n+        subset_localsubrs[fd].init ();\n+        offsets.localSubrsInfos[fd].init ();\n+        if (fdmap.includes (fd))\n+        {\n+          if (!subr_subsetter.encode_localsubrs (fd, subset_localsubrs[fd]))\n+            return false;\n+\n+          unsigned int dataSize = subset_localsubrs[fd].total_size ();\n+          if (dataSize > 0)\n+          {\n+            offsets.localSubrsInfos[fd].offset = final_size;\n+            offsets.localSubrsInfos[fd].offSize = calcOffSize (dataSize);\n+            if (unlikely (offsets.localSubrsInfos[fd].offSize > 4))\n+              return false;\n+            offsets.localSubrsInfos[fd].size = CFF1Subrs::calculate_serialized_size (offsets.localSubrsInfos[fd].offSize, subset_localsubrs[fd].length, dataSize);\n+          }\n+        }\n+      }\n+    }\n+\n+    \/* global subrs *\/\n+    offsets.globalSubrsInfo.offset = final_size;\n+    final_size += offsets.globalSubrsInfo.size;\n+\n+    \/* Encoding *\/\n+    if (!subset_encoding)\n+      offsets.encodingOffset = acc.topDict.EncodingOffset;\n+    else\n+    {\n+      offsets.encodingOffset = final_size;\n+      final_size += plan_subset_encoding (acc, plan);\n+    }\n+\n+    \/* Charset *\/\n+    if (!subset_charset && acc.is_predef_charset ())\n+      offsets.charsetInfo.offset = acc.topDict.CharsetOffset;\n+    else\n+      offsets.charsetInfo.offset = final_size;\n+    final_size += offsets.charsetInfo.size;\n+\n+    \/* FDSelect *\/\n+    if (acc.fdSelect != &Null(CFF1FDSelect))\n+    {\n+      offsets.FDSelectInfo.offset = final_size;\n+      final_size += offsets.FDSelectInfo.size;\n+    }\n+\n+    \/* FDArray (FDIndex) *\/\n+    if (acc.fdArray != &Null(CFF1FDArray)) {\n+      offsets.FDArrayInfo.offset = final_size;\n+      cff1_font_dict_op_serializer_t fontSzr;\n+      unsigned int dictsSize = 0;\n+      for (unsigned int i = 0; i < acc.fontDicts.length; i++)\n+        if (fdmap.includes (i))\n+          dictsSize += FontDict::calculate_serialized_size (acc.fontDicts[i], fontSzr);\n+\n+      offsets.FDArrayInfo.offSize = calcOffSize (dictsSize);\n+      if (unlikely (offsets.FDArrayInfo.offSize > 4))\n+        return false;\n+      final_size += CFF1Index::calculate_serialized_size (offsets.FDArrayInfo.offSize, subset_fdcount, dictsSize);\n+    }\n+\n+    \/* CharStrings *\/\n+    {\n+      offsets.charStringsInfo.offset = final_size;\n+      unsigned int dataSize = subset_charstrings.total_size ();\n+      offsets.charStringsInfo.offSize = calcOffSize (dataSize);\n+      if (unlikely (offsets.charStringsInfo.offSize > 4))\n+        return false;\n+      final_size += CFF1CharStrings::calculate_serialized_size (offsets.charStringsInfo.offSize, plan->glyphs.length, dataSize);\n+    }\n+\n+    \/* private dicts & local subrs *\/\n+    offsets.privateDictInfo.offset = final_size;\n+    for (unsigned int i = 0; i < orig_fdcount; i++)\n+    {\n+      if (fdmap.includes (i))\n+      {\n+        bool  has_localsubrs = offsets.localSubrsInfos[i].size > 0;\n+        cff_private_dict_op_serializer_t privSzr (desubroutinize, plan->drop_hints);\n+        unsigned int  priv_size = PrivateDict::calculate_serialized_size (acc.privateDicts[i], privSzr, has_localsubrs);\n+        table_info_t  privInfo = { final_size, priv_size, 0 };\n+        font_dict_values_mod_t fontdict_mod;\n+        if (!acc.is_CID ())\n+          fontdict_mod.init ( &Null(cff1_font_dict_values_t), CFF_UNDEF_SID, privInfo );\n+        else\n+          fontdict_mod.init ( &acc.fontDicts[i], sidmap[acc.fontDicts[i].fontName], privInfo );\n+        fontdicts_mod.push (fontdict_mod);\n+        final_size += privInfo.size;\n+\n+        if (!plan->desubroutinize && has_localsubrs)\n+        {\n+          offsets.localSubrsInfos[i].offset = final_size;\n+          final_size += offsets.localSubrsInfos[i].size;\n+        }\n+      }\n+    }\n+\n+    if (!acc.is_CID ())\n+      offsets.privateDictInfo = fontdicts_mod[0].privateDictInfo;\n+\n+    return ((subset_charstrings.length == plan->glyphs.length)\n+           && (fontdicts_mod.length == subset_fdcount));\n+  }\n+\n+  unsigned int get_final_size () const  { return final_size; }\n+\n+  unsigned int        final_size;\n+  hb_vector_t<unsigned int>     topdict_sizes;\n+  cff1_top_dict_values_mod_t    topdict_mod;\n+  cff1_sub_table_offsets_t      offsets;\n+\n+  unsigned int    num_glyphs;\n+  unsigned int    orig_fdcount;\n+  unsigned int    subset_fdcount;\n+  unsigned int    subset_fdselect_format;\n+  hb_vector_t<code_pair_t>   subset_fdselect_ranges;\n+\n+  \/* font dict index remap table from fullset FDArray to subset FDArray.\n+   * set to CFF_UNDEF_CODE if excluded from subset *\/\n+  remap_t   fdmap;\n+\n+  str_buff_vec_t                subset_charstrings;\n+  str_buff_vec_t                subset_globalsubrs;\n+  hb_vector_t<str_buff_vec_t>   subset_localsubrs;\n+  hb_vector_t<font_dict_values_mod_t>  fontdicts_mod;\n+\n+  bool          drop_hints;\n+\n+  bool          gid_renum;\n+  bool          subset_encoding;\n+  uint8_t       subset_enc_format;\n+  unsigned int  subset_enc_num_codes;\n+  range_list_t  subset_enc_code_ranges;\n+  hb_vector_t<code_pair_t>  subset_enc_supp_codes;\n+\n+  uint8_t       subset_charset_format;\n+  range_list_t  subset_charset_ranges;\n+  bool          subset_charset;\n+\n+  remap_sid_t   sidmap;\n+  unsigned int  topDictModSIDs[name_dict_values_t::ValCount];\n+\n+  bool          desubroutinize;\n+  cff1_subr_subsetter_t       subr_subsetter;\n+};\n+\n+static inline bool _write_cff1 (const cff_subset_plan &plan,\n+                                const OT::cff1::accelerator_subset_t  &acc,\n+                                const hb_vector_t<hb_codepoint_t>& glyphs,\n+                                unsigned int dest_sz,\n+                                void *dest)\n+{\n+  hb_serialize_context_t c (dest, dest_sz);\n+\n+  OT::cff1 *cff = c.start_serialize<OT::cff1> ();\n+  if (unlikely (!c.extend_min (*cff)))\n+    return false;\n+\n+  \/* header *\/\n+  cff->version.major.set (0x01);\n+  cff->version.minor.set (0x00);\n+  cff->nameIndex.set (cff->min_size);\n+  cff->offSize.set (4); \/* unused? *\/\n+\n+  \/* name INDEX *\/\n+  {\n+    assert (cff->nameIndex == (unsigned) (c.head - c.start));\n+    CFF1NameIndex *dest = c.start_embed<CFF1NameIndex> ();\n+    if (unlikely (dest == nullptr)) return false;\n+    if (unlikely (!dest->serialize (&c, *acc.nameIndex)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF name INDEX\");\n+      return false;\n+    }\n+  }\n+\n+  \/* top dict INDEX *\/\n+  {\n+    assert (plan.offsets.topDictInfo.offset == (unsigned) (c.head - c.start));\n+    CFF1IndexOf<TopDict> *dest = c.start_embed< CFF1IndexOf<TopDict> > ();\n+    if (dest == nullptr) return false;\n+    cff1_top_dict_op_serializer_t topSzr;\n+    top_dict_modifiers_t  modifier (plan.offsets, plan.topDictModSIDs);\n+    if (unlikely (!dest->serialize (&c, plan.offsets.topDictInfo.offSize,\n+                                    &plan.topdict_mod, 1,\n+                                    plan.topdict_sizes, topSzr, modifier)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF top dict\");\n+      return false;\n+    }\n+  }\n+\n+  \/* String INDEX *\/\n+  {\n+    assert (plan.offsets.stringIndexInfo.offset == (unsigned) (c.head - c.start));\n+    CFF1StringIndex *dest = c.start_embed<CFF1StringIndex> ();\n+    if (unlikely (dest == nullptr)) return false;\n+    if (unlikely (!dest->serialize (&c, *acc.stringIndex, plan.offsets.stringIndexInfo.offSize, plan.sidmap)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF string INDEX\");\n+      return false;\n+    }\n+  }\n+\n+  \/* global subrs *\/\n+  {\n+    assert (plan.offsets.globalSubrsInfo.offset != 0);\n+    assert (plan.offsets.globalSubrsInfo.offset == (unsigned) (c.head - c.start));\n+\n+    CFF1Subrs *dest = c.start_embed <CFF1Subrs> ();\n+    if (unlikely (dest == nullptr)) return false;\n+    if (unlikely (!dest->serialize (&c, plan.offsets.globalSubrsInfo.offSize, plan.subset_globalsubrs)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize global subroutines\");\n+      return false;\n+    }\n+  }\n+\n+  \/* Encoding *\/\n+  if (plan.subset_encoding)\n+  {\n+    assert (plan.offsets.encodingOffset == (unsigned) (c.head - c.start));\n+    Encoding *dest = c.start_embed<Encoding> ();\n+    if (unlikely (dest == nullptr)) return false;\n+    if (unlikely (!dest->serialize (&c,\n+                                    plan.subset_enc_format,\n+                                    plan.subset_enc_num_codes,\n+                                    plan.subset_enc_code_ranges,\n+                                    plan.subset_enc_supp_codes)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize Encoding\");\n+      return false;\n+    }\n+  }\n+\n+  \/* Charset *\/\n+  if (plan.subset_charset)\n+  {\n+    assert (plan.offsets.charsetInfo.offset == (unsigned) (c.head - c.start));\n+    Charset *dest = c.start_embed<Charset> ();\n+    if (unlikely (dest == nullptr)) return false;\n+    if (unlikely (!dest->serialize (&c,\n+                                    plan.subset_charset_format,\n+                                    plan.num_glyphs,\n+                                    plan.subset_charset_ranges)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize Charset\");\n+      return false;\n+    }\n+  }\n+\n+  \/* FDSelect *\/\n+  if (acc.fdSelect != &Null(CFF1FDSelect))\n+  {\n+    assert (plan.offsets.FDSelectInfo.offset == (unsigned) (c.head - c.start));\n+\n+    if (unlikely (!hb_serialize_cff_fdselect (&c, glyphs.length, *acc.fdSelect, acc.fdCount,\n+                                              plan.subset_fdselect_format, plan.offsets.FDSelectInfo.size,\n+                                              plan.subset_fdselect_ranges)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF subset FDSelect\");\n+      return false;\n+    }\n+  }\n+\n+  \/* FDArray (FD Index) *\/\n+  if (acc.fdArray != &Null(CFF1FDArray))\n+  {\n+    assert (plan.offsets.FDArrayInfo.offset == (unsigned) (c.head - c.start));\n+    CFF1FDArray  *fda = c.start_embed<CFF1FDArray> ();\n+    if (unlikely (fda == nullptr)) return false;\n+    cff1_font_dict_op_serializer_t  fontSzr;\n+    if (unlikely (!fda->serialize (&c, plan.offsets.FDArrayInfo.offSize,\n+                                   plan.fontdicts_mod,\n+                                   fontSzr)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF FDArray\");\n+      return false;\n+    }\n+  }\n+\n+  \/* CharStrings *\/\n+  {\n+    assert (plan.offsets.charStringsInfo.offset == (unsigned) (c.head - c.start));\n+    CFF1CharStrings  *cs = c.start_embed<CFF1CharStrings> ();\n+    if (unlikely (cs == nullptr)) return false;\n+    if (unlikely (!cs->serialize (&c, plan.offsets.charStringsInfo.offSize, plan.subset_charstrings)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF CharStrings\");\n+      return false;\n+    }\n+  }\n+\n+  \/* private dicts & local subrs *\/\n+  assert (plan.offsets.privateDictInfo.offset == (unsigned) (c.head - c.start));\n+  for (unsigned int i = 0; i < acc.privateDicts.length; i++)\n+  {\n+    if (plan.fdmap.includes (i))\n+    {\n+      PrivateDict  *pd = c.start_embed<PrivateDict> ();\n+      if (unlikely (pd == nullptr)) return false;\n+      unsigned int priv_size = plan.fontdicts_mod[plan.fdmap[i]].privateDictInfo.size;\n+      bool result;\n+      cff_private_dict_op_serializer_t privSzr (plan.desubroutinize, plan.drop_hints);\n+      \/* N.B. local subrs immediately follows its corresponding private dict. i.e., subr offset == private dict size *\/\n+      unsigned int  subroffset = (plan.offsets.localSubrsInfos[i].size > 0)? priv_size: 0;\n+      result = pd->serialize (&c, acc.privateDicts[i], privSzr, subroffset);\n+      if (unlikely (!result))\n+      {\n+        DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF Private Dict[%d]\", i);\n+        return false;\n+      }\n+      if (plan.offsets.localSubrsInfos[i].size > 0)\n+      {\n+        CFF1Subrs *dest = c.start_embed <CFF1Subrs> ();\n+        if (unlikely (dest == nullptr)) return false;\n+        if (unlikely (!dest->serialize (&c, plan.offsets.localSubrsInfos[i].offSize, plan.subset_localsubrs[i])))\n+        {\n+          DEBUG_MSG (SUBSET, nullptr, \"failed to serialize local subroutines\");\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+\n+  assert (c.head == c.end);\n+  c.end_serialize ();\n+\n+  return true;\n+}\n+\n+static bool\n+_hb_subset_cff1 (const OT::cff1::accelerator_subset_t  &acc,\n+                const char              *data,\n+                hb_subset_plan_t        *plan,\n+                hb_blob_t               **prime \/* OUT *\/)\n+{\n+  cff_subset_plan cff_plan;\n+\n+  if (unlikely (!cff_plan.create (acc, plan)))\n+  {\n+    DEBUG_MSG(SUBSET, nullptr, \"Failed to generate a cff subsetting plan.\");\n+    return false;\n+  }\n+\n+  unsigned int  cff_prime_size = cff_plan.get_final_size ();\n+  char *cff_prime_data = (char *) calloc (1, cff_prime_size);\n+\n+  if (unlikely (!_write_cff1 (cff_plan, acc, plan->glyphs,\n+                              cff_prime_size, cff_prime_data))) {\n+    DEBUG_MSG(SUBSET, nullptr, \"Failed to write a subset cff.\");\n+    free (cff_prime_data);\n+    return false;\n+  }\n+\n+  *prime = hb_blob_create (cff_prime_data,\n+                           cff_prime_size,\n+                           HB_MEMORY_MODE_READONLY,\n+                           cff_prime_data,\n+                           free);\n+  return true;\n+}\n+\n+\/**\n+ * hb_subset_cff1:\n+ * Subsets the CFF table according to a provided plan.\n+ *\n+ * Return value: subsetted cff table.\n+ **\/\n+bool\n+hb_subset_cff1 (hb_subset_plan_t *plan,\n+                hb_blob_t       **prime \/* OUT *\/)\n+{\n+  hb_blob_t *cff_blob = hb_sanitize_context_t().reference_table<CFF::cff1> (plan->source);\n+  const char *data = hb_blob_get_data(cff_blob, nullptr);\n+\n+  OT::cff1::accelerator_subset_t acc;\n+  acc.init(plan->source);\n+  bool result = likely (acc.is_valid ()) &&\n+                        _hb_subset_cff1 (acc, data, plan, prime);\n+  hb_blob_destroy (cff_blob);\n+  acc.fini ();\n+\n+  return result;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-cff1.cc","additions":1103,"deletions":0,"binary":false,"changes":1103,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#ifndef HB_SUBSET_CFF1_HH\n+#define HB_SUBSET_CFF1_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-subset-plan.hh\"\n+\n+HB_INTERNAL bool\n+hb_subset_cff1 (hb_subset_plan_t *plan,\n+               hb_blob_t        **cff_prime \/* OUT *\/);\n+\n+#endif \/* HB_SUBSET_CFF1_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-cff1.hh","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,624 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-cff2-table.hh\"\n+#include \"hb-set.h\"\n+#include \"hb-subset-cff2.hh\"\n+#include \"hb-subset-plan.hh\"\n+#include \"hb-subset-cff-common.hh\"\n+#include \"hb-cff2-interp-cs.hh\"\n+\n+using namespace CFF;\n+\n+struct cff2_sub_table_offsets_t : cff_sub_table_offsets_t\n+{\n+  cff2_sub_table_offsets_t ()\n+    : cff_sub_table_offsets_t (),\n+      varStoreOffset (0)\n+  {}\n+\n+  unsigned int  varStoreOffset;\n+};\n+\n+struct cff2_top_dict_op_serializer_t : cff_top_dict_op_serializer_t<>\n+{\n+  bool serialize (hb_serialize_context_t *c,\n+                  const op_str_t &opstr,\n+                  const cff2_sub_table_offsets_t &offsets) const\n+  {\n+    TRACE_SERIALIZE (this);\n+\n+    switch (opstr.op)\n+    {\n+      case OpCode_vstore:\n+        return_trace (FontDict::serialize_offset4_op(c, opstr.op, offsets.varStoreOffset));\n+\n+      default:\n+        return_trace (cff_top_dict_op_serializer_t<>::serialize (c, opstr, offsets));\n+    }\n+  }\n+\n+  unsigned int calculate_serialized_size (const op_str_t &opstr) const\n+  {\n+    switch (opstr.op)\n+    {\n+      case OpCode_vstore:\n+        return OpCode_Size (OpCode_longintdict) + 4 + OpCode_Size (opstr.op);\n+\n+      default:\n+        return cff_top_dict_op_serializer_t<>::calculate_serialized_size (opstr);\n+    }\n+  }\n+};\n+\n+struct cff2_cs_opset_flatten_t : cff2_cs_opset_t<cff2_cs_opset_flatten_t, flatten_param_t>\n+{\n+  static void flush_args_and_op (op_code_t op, cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    switch (op)\n+    {\n+      case OpCode_return:\n+      case OpCode_endchar:\n+        \/* dummy opcodes in CFF2. ignore *\/\n+        break;\n+\n+      case OpCode_hstem:\n+      case OpCode_hstemhm:\n+      case OpCode_vstem:\n+      case OpCode_vstemhm:\n+      case OpCode_hintmask:\n+      case OpCode_cntrmask:\n+        if (param.drop_hints)\n+        {\n+          env.clear_args ();\n+          return;\n+        }\n+        HB_FALLTHROUGH;\n+\n+      default:\n+        SUPER::flush_args_and_op (op, env, param);\n+        break;\n+    }\n+  }\n+\n+  static void flush_args (cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    for (unsigned int i = 0; i < env.argStack.get_count ();)\n+    {\n+      const blend_arg_t &arg = env.argStack[i];\n+      if (arg.blending ())\n+      {\n+        if (unlikely (!((arg.numValues > 0) && (env.argStack.get_count () >= arg.numValues))))\n+        {\n+          env.set_error ();\n+          return;\n+        }\n+        flatten_blends (arg, i, env, param);\n+        i += arg.numValues;\n+      }\n+      else\n+      {\n+        str_encoder_t  encoder (param.flatStr);\n+        encoder.encode_num (arg);\n+        i++;\n+      }\n+    }\n+    SUPER::flush_args (env, param);\n+  }\n+\n+  static void flatten_blends (const blend_arg_t &arg, unsigned int i, cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    \/* flatten the default values *\/\n+    str_encoder_t  encoder (param.flatStr);\n+    for (unsigned int j = 0; j < arg.numValues; j++)\n+    {\n+      const blend_arg_t &arg1 = env.argStack[i + j];\n+      if (unlikely (!((arg1.blending () && (arg.numValues == arg1.numValues) && (arg1.valueIndex == j) &&\n+              (arg1.deltas.length == env.get_region_count ())))))\n+      {\n+        env.set_error ();\n+        return;\n+      }\n+      encoder.encode_num (arg1);\n+    }\n+    \/* flatten deltas for each value *\/\n+    for (unsigned int j = 0; j < arg.numValues; j++)\n+    {\n+      const blend_arg_t &arg1 = env.argStack[i + j];\n+      for (unsigned int k = 0; k < arg1.deltas.length; k++)\n+        encoder.encode_num (arg1.deltas[k]);\n+    }\n+    \/* flatten the number of values followed by blend operator *\/\n+    encoder.encode_int (arg.numValues);\n+    encoder.encode_op (OpCode_blendcs);\n+  }\n+\n+  static void flush_op (op_code_t op, cff2_cs_interp_env_t &env, flatten_param_t& param)\n+  {\n+    switch (op)\n+    {\n+      case OpCode_return:\n+      case OpCode_endchar:\n+        return;\n+      default:\n+        str_encoder_t  encoder (param.flatStr);\n+        encoder.encode_op (op);\n+    }\n+  }\n+\n+  private:\n+  typedef cff2_cs_opset_t<cff2_cs_opset_flatten_t, flatten_param_t> SUPER;\n+  typedef cs_opset_t<blend_arg_t, cff2_cs_opset_flatten_t, cff2_cs_opset_flatten_t, cff2_cs_interp_env_t, flatten_param_t> CSOPSET;\n+};\n+\n+struct cff2_cs_opset_subr_subset_t : cff2_cs_opset_t<cff2_cs_opset_subr_subset_t, subr_subset_param_t>\n+{\n+  static void process_op (op_code_t op, cff2_cs_interp_env_t &env, subr_subset_param_t& param)\n+  {\n+    switch (op) {\n+\n+      case OpCode_return:\n+        param.current_parsed_str->set_parsed ();\n+        env.returnFromSubr ();\n+        param.set_current_str (env, false);\n+        break;\n+\n+      case OpCode_endchar:\n+        param.current_parsed_str->set_parsed ();\n+        SUPER::process_op (op, env, param);\n+        break;\n+\n+      case OpCode_callsubr:\n+        process_call_subr (op, CSType_LocalSubr, env, param, env.localSubrs, param.local_closure);\n+        break;\n+\n+      case OpCode_callgsubr:\n+        process_call_subr (op, CSType_GlobalSubr, env, param, env.globalSubrs, param.global_closure);\n+        break;\n+\n+      default:\n+        SUPER::process_op (op, env, param);\n+        param.current_parsed_str->add_op (op, env.str_ref);\n+        break;\n+    }\n+  }\n+\n+  protected:\n+  static void process_call_subr (op_code_t op, cs_type_t type,\n+                                 cff2_cs_interp_env_t &env, subr_subset_param_t& param,\n+                                 cff2_biased_subrs_t& subrs, hb_set_t *closure)\n+  {\n+    byte_str_ref_t    str_ref = env.str_ref;\n+    env.callSubr (subrs, type);\n+    param.current_parsed_str->add_call_op (op, str_ref, env.context.subr_num);\n+    hb_set_add (closure, env.context.subr_num);\n+    param.set_current_str (env, true);\n+  }\n+\n+  private:\n+  typedef cff2_cs_opset_t<cff2_cs_opset_subr_subset_t, subr_subset_param_t> SUPER;\n+};\n+\n+struct cff2_subr_subsetter_t : subr_subsetter_t<cff2_subr_subsetter_t, CFF2Subrs, const OT::cff2::accelerator_subset_t, cff2_cs_interp_env_t, cff2_cs_opset_subr_subset_t>\n+{\n+  static void finalize_parsed_str (cff2_cs_interp_env_t &env, subr_subset_param_t& param, parsed_cs_str_t &charstring)\n+  {\n+    \/* vsindex is inserted at the beginning of the charstring as necessary *\/\n+    if (env.seen_vsindex ())\n+    {\n+      number_t  ivs;\n+      ivs.set_int ((int)env.get_ivs ());\n+      charstring.set_prefix (ivs, OpCode_vsindexcs);\n+    }\n+  }\n+};\n+\n+struct cff2_subset_plan {\n+  cff2_subset_plan ()\n+    : final_size (0),\n+      orig_fdcount (0),\n+      subset_fdcount(1),\n+      subset_fdselect_format (0),\n+      drop_hints (false),\n+      desubroutinize (false)\n+  {\n+    subset_fdselect_ranges.init ();\n+    fdmap.init ();\n+    subset_charstrings.init ();\n+    subset_globalsubrs.init ();\n+    subset_localsubrs.init ();\n+    privateDictInfos.init ();\n+  }\n+\n+  ~cff2_subset_plan ()\n+  {\n+    subset_fdselect_ranges.fini ();\n+    fdmap.fini ();\n+    subset_charstrings.fini_deep ();\n+    subset_globalsubrs.fini_deep ();\n+    subset_localsubrs.fini_deep ();\n+    privateDictInfos.fini ();\n+  }\n+\n+  bool create (const OT::cff2::accelerator_subset_t &acc,\n+              hb_subset_plan_t *plan)\n+  {\n+    final_size = 0;\n+    orig_fdcount = acc.fdArray->count;\n+\n+    drop_hints = plan->drop_hints;\n+    desubroutinize = plan->desubroutinize;\n+\n+    \/* CFF2 header *\/\n+    final_size += OT::cff2::static_size;\n+\n+    \/* top dict *\/\n+    {\n+      cff2_top_dict_op_serializer_t topSzr;\n+      offsets.topDictInfo.size = TopDict::calculate_serialized_size (acc.topDict, topSzr);\n+      final_size += offsets.topDictInfo.size;\n+    }\n+\n+    if (desubroutinize)\n+    {\n+      \/* Flatten global & local subrs *\/\n+      subr_flattener_t<const OT::cff2::accelerator_subset_t, cff2_cs_interp_env_t, cff2_cs_opset_flatten_t>\n+                    flattener(acc, plan->glyphs, plan->drop_hints);\n+      if (!flattener.flatten (subset_charstrings))\n+        return false;\n+\n+      \/* no global\/local subroutines *\/\n+      offsets.globalSubrsInfo.size = CFF2Subrs::calculate_serialized_size (1, 0, 0);\n+    }\n+    else\n+    {\n+      \/* Subset subrs: collect used subroutines, leaving all unused ones behind *\/\n+      if (!subr_subsetter.subset (acc, plan->glyphs, plan->drop_hints))\n+        return false;\n+\n+      \/* encode charstrings, global subrs, local subrs with new subroutine numbers *\/\n+      if (!subr_subsetter.encode_charstrings (acc, plan->glyphs, subset_charstrings))\n+        return false;\n+\n+      if (!subr_subsetter.encode_globalsubrs (subset_globalsubrs))\n+        return false;\n+\n+      \/* global subrs *\/\n+      unsigned int dataSize = subset_globalsubrs.total_size ();\n+      offsets.globalSubrsInfo.offSize = calcOffSize (dataSize);\n+      offsets.globalSubrsInfo.size = CFF2Subrs::calculate_serialized_size (offsets.globalSubrsInfo.offSize, subset_globalsubrs.length, dataSize);\n+\n+      \/* local subrs *\/\n+      if (!offsets.localSubrsInfos.resize (orig_fdcount))\n+        return false;\n+      if (!subset_localsubrs.resize (orig_fdcount))\n+        return false;\n+      for (unsigned int fd = 0; fd < orig_fdcount; fd++)\n+      {\n+        subset_localsubrs[fd].init ();\n+        offsets.localSubrsInfos[fd].init ();\n+        if (fdmap.includes (fd))\n+        {\n+          if (!subr_subsetter.encode_localsubrs (fd, subset_localsubrs[fd]))\n+            return false;\n+\n+          unsigned int dataSize = subset_localsubrs[fd].total_size ();\n+          if (dataSize > 0)\n+          {\n+            offsets.localSubrsInfos[fd].offset = final_size;\n+            offsets.localSubrsInfos[fd].offSize = calcOffSize (dataSize);\n+            offsets.localSubrsInfos[fd].size = CFF2Subrs::calculate_serialized_size (offsets.localSubrsInfos[fd].offSize, subset_localsubrs[fd].length, dataSize);\n+          }\n+        }\n+      }\n+    }\n+\n+    \/* global subrs *\/\n+    offsets.globalSubrsInfo.offset = final_size;\n+    final_size += offsets.globalSubrsInfo.size;\n+\n+    \/* variation store *\/\n+    if (acc.varStore != &Null(CFF2VariationStore))\n+    {\n+      offsets.varStoreOffset = final_size;\n+      final_size += acc.varStore->get_size ();\n+    }\n+\n+    \/* FDSelect *\/\n+    if (acc.fdSelect != &Null(CFF2FDSelect))\n+    {\n+      offsets.FDSelectInfo.offset = final_size;\n+      if (unlikely (!hb_plan_subset_cff_fdselect (plan->glyphs,\n+                                  orig_fdcount,\n+                                  *(const FDSelect *)acc.fdSelect,\n+                                  subset_fdcount,\n+                                  offsets.FDSelectInfo.size,\n+                                  subset_fdselect_format,\n+                                  subset_fdselect_ranges,\n+                                  fdmap)))\n+        return false;\n+\n+      final_size += offsets.FDSelectInfo.size;\n+    }\n+    else\n+      fdmap.identity (1);\n+\n+    \/* FDArray (FDIndex) *\/\n+    {\n+      offsets.FDArrayInfo.offset = final_size;\n+      cff_font_dict_op_serializer_t fontSzr;\n+      unsigned int dictsSize = 0;\n+      for (unsigned int i = 0; i < acc.fontDicts.length; i++)\n+        if (fdmap.includes (i))\n+          dictsSize += FontDict::calculate_serialized_size (acc.fontDicts[i], fontSzr);\n+\n+      offsets.FDArrayInfo.offSize = calcOffSize (dictsSize);\n+      final_size += CFF2Index::calculate_serialized_size (offsets.FDArrayInfo.offSize, subset_fdcount, dictsSize);\n+    }\n+\n+    \/* CharStrings *\/\n+    {\n+      offsets.charStringsInfo.offset = final_size;\n+      unsigned int dataSize = subset_charstrings.total_size ();\n+      offsets.charStringsInfo.offSize = calcOffSize (dataSize);\n+      final_size += CFF2CharStrings::calculate_serialized_size (offsets.charStringsInfo.offSize, plan->glyphs.length, dataSize);\n+    }\n+\n+    \/* private dicts & local subrs *\/\n+    offsets.privateDictsOffset = final_size;\n+    for (unsigned int i = 0; i < orig_fdcount; i++)\n+    {\n+      if (fdmap.includes (i))\n+      {\n+        bool  has_localsubrs = offsets.localSubrsInfos[i].size > 0;\n+        cff_private_dict_op_serializer_t privSzr (desubroutinize, drop_hints);\n+        unsigned int  priv_size = PrivateDict::calculate_serialized_size (acc.privateDicts[i], privSzr, has_localsubrs);\n+        table_info_t  privInfo = { final_size, priv_size, 0 };\n+        privateDictInfos.push (privInfo);\n+        final_size += privInfo.size;\n+\n+        if (!plan->desubroutinize && has_localsubrs)\n+        {\n+          offsets.localSubrsInfos[i].offset = final_size;\n+          final_size += offsets.localSubrsInfos[i].size;\n+        }\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  unsigned int get_final_size () const  { return final_size; }\n+\n+  unsigned int  final_size;\n+  cff2_sub_table_offsets_t offsets;\n+\n+  unsigned int    orig_fdcount;\n+  unsigned int    subset_fdcount;\n+  unsigned int    subset_fdselect_format;\n+  hb_vector_t<code_pair_t>   subset_fdselect_ranges;\n+\n+  remap_t   fdmap;\n+\n+  str_buff_vec_t            subset_charstrings;\n+  str_buff_vec_t            subset_globalsubrs;\n+  hb_vector_t<str_buff_vec_t> subset_localsubrs;\n+  hb_vector_t<table_info_t>  privateDictInfos;\n+\n+  bool      drop_hints;\n+  bool      desubroutinize;\n+  cff2_subr_subsetter_t       subr_subsetter;\n+};\n+\n+static inline bool _write_cff2 (const cff2_subset_plan &plan,\n+                                const OT::cff2::accelerator_subset_t  &acc,\n+                                const hb_vector_t<hb_codepoint_t>& glyphs,\n+                                unsigned int dest_sz,\n+                                void *dest)\n+{\n+  hb_serialize_context_t c (dest, dest_sz);\n+\n+  OT::cff2 *cff2 = c.start_serialize<OT::cff2> ();\n+  if (unlikely (!c.extend_min (*cff2)))\n+    return false;\n+\n+  \/* header *\/\n+  cff2->version.major.set (0x02);\n+  cff2->version.minor.set (0x00);\n+  cff2->topDict.set (OT::cff2::static_size);\n+\n+  \/* top dict *\/\n+  {\n+    assert (cff2->topDict == (unsigned) (c.head - c.start));\n+    cff2->topDictSize.set (plan.offsets.topDictInfo.size);\n+    TopDict &dict = cff2 + cff2->topDict;\n+    cff2_top_dict_op_serializer_t topSzr;\n+    if (unlikely (!dict.serialize (&c, acc.topDict, topSzr, plan.offsets)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF2 top dict\");\n+      return false;\n+    }\n+  }\n+\n+  \/* global subrs *\/\n+  {\n+    assert (cff2->topDict + plan.offsets.topDictInfo.size == (unsigned) (c.head - c.start));\n+    CFF2Subrs *dest = c.start_embed <CFF2Subrs> ();\n+    if (unlikely (dest == nullptr)) return false;\n+    if (unlikely (!dest->serialize (&c, plan.offsets.globalSubrsInfo.offSize, plan.subset_globalsubrs)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize global subroutines\");\n+      return false;\n+    }\n+  }\n+\n+  \/* variation store *\/\n+  if (acc.varStore != &Null(CFF2VariationStore))\n+  {\n+    assert (plan.offsets.varStoreOffset == (unsigned) (c.head - c.start));\n+    CFF2VariationStore *dest = c.start_embed<CFF2VariationStore> ();\n+    if (unlikely (!dest->serialize (&c, acc.varStore)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF2 Variation Store\");\n+      return false;\n+    }\n+  }\n+\n+  \/* FDSelect *\/\n+  if (acc.fdSelect != &Null(CFF2FDSelect))\n+  {\n+    assert (plan.offsets.FDSelectInfo.offset == (unsigned) (c.head - c.start));\n+\n+    if (unlikely (!hb_serialize_cff_fdselect (&c, glyphs.length, *(const FDSelect *)acc.fdSelect, acc.fdArray->count,\n+                                              plan.subset_fdselect_format, plan.offsets.FDSelectInfo.size,\n+                                              plan.subset_fdselect_ranges)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF2 subset FDSelect\");\n+      return false;\n+    }\n+  }\n+\n+  \/* FDArray (FD Index) *\/\n+  {\n+    assert (plan.offsets.FDArrayInfo.offset == (unsigned) (c.head - c.start));\n+    CFF2FDArray  *fda = c.start_embed<CFF2FDArray> ();\n+    if (unlikely (fda == nullptr)) return false;\n+    cff_font_dict_op_serializer_t  fontSzr;\n+    if (unlikely (!fda->serialize (&c, plan.offsets.FDArrayInfo.offSize,\n+                                   acc.fontDicts, plan.subset_fdcount, plan.fdmap,\n+                                   fontSzr, plan.privateDictInfos)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF2 FDArray\");\n+      return false;\n+    }\n+  }\n+\n+  \/* CharStrings *\/\n+  {\n+    assert (plan.offsets.charStringsInfo.offset == (unsigned) (c.head - c.start));\n+    CFF2CharStrings  *cs = c.start_embed<CFF2CharStrings> ();\n+    if (unlikely (cs == nullptr)) return false;\n+    if (unlikely (!cs->serialize (&c, plan.offsets.charStringsInfo.offSize, plan.subset_charstrings)))\n+    {\n+      DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF2 CharStrings\");\n+      return false;\n+    }\n+  }\n+\n+  \/* private dicts & local subrs *\/\n+  assert (plan.offsets.privateDictsOffset == (unsigned) (c.head - c.start));\n+  for (unsigned int i = 0; i < acc.privateDicts.length; i++)\n+  {\n+    if (plan.fdmap.includes (i))\n+    {\n+      PrivateDict  *pd = c.start_embed<PrivateDict> ();\n+      if (unlikely (pd == nullptr)) return false;\n+      unsigned int priv_size = plan.privateDictInfos[plan.fdmap[i]].size;\n+      bool result;\n+      cff_private_dict_op_serializer_t privSzr (plan.desubroutinize, plan.drop_hints);\n+      \/* N.B. local subrs immediately follows its corresponding private dict. i.e., subr offset == private dict size *\/\n+      unsigned int  subroffset = (plan.offsets.localSubrsInfos[i].size > 0)? priv_size: 0;\n+      result = pd->serialize (&c, acc.privateDicts[i], privSzr, subroffset);\n+      if (unlikely (!result))\n+      {\n+        DEBUG_MSG (SUBSET, nullptr, \"failed to serialize CFF Private Dict[%d]\", i);\n+        return false;\n+      }\n+      if (plan.offsets.localSubrsInfos[i].size > 0)\n+      {\n+        CFF2Subrs *dest = c.start_embed <CFF2Subrs> ();\n+        if (unlikely (dest == nullptr)) return false;\n+        if (unlikely (!dest->serialize (&c, plan.offsets.localSubrsInfos[i].offSize, plan.subset_localsubrs[i])))\n+        {\n+          DEBUG_MSG (SUBSET, nullptr, \"failed to serialize local subroutines\");\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+\n+  assert (c.head == c.end);\n+  c.end_serialize ();\n+\n+  return true;\n+}\n+\n+static bool\n+_hb_subset_cff2 (const OT::cff2::accelerator_subset_t  &acc,\n+                const char                    *data,\n+                hb_subset_plan_t                *plan,\n+                hb_blob_t                      **prime \/* OUT *\/)\n+{\n+  cff2_subset_plan cff2_plan;\n+\n+  if (unlikely (!cff2_plan.create (acc, plan)))\n+  {\n+    DEBUG_MSG(SUBSET, nullptr, \"Failed to generate a cff2 subsetting plan.\");\n+    return false;\n+  }\n+\n+  unsigned int  cff2_prime_size = cff2_plan.get_final_size ();\n+  char *cff2_prime_data = (char *) calloc (1, cff2_prime_size);\n+\n+  if (unlikely (!_write_cff2 (cff2_plan, acc, plan->glyphs,\n+                              cff2_prime_size, cff2_prime_data))) {\n+    DEBUG_MSG(SUBSET, nullptr, \"Failed to write a subset cff2.\");\n+    free (cff2_prime_data);\n+    return false;\n+  }\n+\n+  *prime = hb_blob_create (cff2_prime_data,\n+                                cff2_prime_size,\n+                                HB_MEMORY_MODE_READONLY,\n+                                cff2_prime_data,\n+                                free);\n+  return true;\n+}\n+\n+\/**\n+ * hb_subset_cff2:\n+ * Subsets the CFF2 table according to a provided plan.\n+ *\n+ * Return value: subsetted cff2 table.\n+ **\/\n+bool\n+hb_subset_cff2 (hb_subset_plan_t *plan,\n+                hb_blob_t       **prime \/* OUT *\/)\n+{\n+  hb_blob_t *cff2_blob = hb_sanitize_context_t().reference_table<CFF::cff2> (plan->source);\n+  const char *data = hb_blob_get_data(cff2_blob, nullptr);\n+\n+  OT::cff2::accelerator_subset_t acc;\n+  acc.init(plan->source);\n+  bool result = likely (acc.is_valid ()) &&\n+                _hb_subset_cff2 (acc, data, plan, prime);\n+\n+  hb_blob_destroy (cff2_blob);\n+  acc.fini ();\n+\n+  return result;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-cff2.cc","additions":624,"deletions":0,"binary":false,"changes":624,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright © 2018 Adobe Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Adobe Author(s): Michiharu Ariza\n+ *\/\n+\n+#ifndef HB_SUBSET_CFF2_HH\n+#define HB_SUBSET_CFF2_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-subset-plan.hh\"\n+\n+HB_INTERNAL bool\n+hb_subset_cff2 (hb_subset_plan_t *plan,\n+               hb_blob_t       **cff2_prime \/* OUT *\/);\n+\n+#endif \/* HB_SUBSET_CFF2_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-cff2.hh","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,310 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger, Roderick Sheeter\n+ *\/\n+\n+#include \"hb-open-type.hh\"\n+#include \"hb-ot-glyf-table.hh\"\n+#include \"hb-set.h\"\n+#include \"hb-subset-glyf.hh\"\n+\n+static bool\n+_calculate_glyf_and_loca_prime_size (const OT::glyf::accelerator_t &glyf,\n+                                     hb_vector_t<hb_codepoint_t> &glyph_ids,\n+                                     hb_bool_t drop_hints,\n+                                     bool *use_short_loca \/* OUT *\/,\n+                                     unsigned int *glyf_size \/* OUT *\/,\n+                                     unsigned int *loca_size \/* OUT *\/,\n+                                     hb_vector_t<unsigned int> *instruction_ranges \/* OUT *\/)\n+{\n+  unsigned int total = 0;\n+  for (unsigned int i = 0; i < glyph_ids.length; i++)\n+  {\n+    hb_codepoint_t next_glyph = glyph_ids[i];\n+    if (!instruction_ranges->resize (instruction_ranges->length + 2))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"Failed to resize instruction_ranges.\");\n+      return false;\n+    }\n+    unsigned int *instruction_start = &(*instruction_ranges)[instruction_ranges->length - 2];\n+    *instruction_start = 0;\n+    unsigned int *instruction_end = &(*instruction_ranges)[instruction_ranges->length - 1];\n+    *instruction_end = 0;\n+\n+    unsigned int start_offset, end_offset;\n+    if (unlikely (!(glyf.get_offsets (next_glyph, &start_offset, &end_offset) &&\n+                    glyf.remove_padding (start_offset, &end_offset))))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"Invalid gid %d\", next_glyph);\n+      continue;\n+    }\n+    if (end_offset - start_offset < OT::glyf::GlyphHeader::static_size)\n+      continue; \/* 0-length glyph *\/\n+\n+    if (drop_hints)\n+    {\n+      if (unlikely (!glyf.get_instruction_offsets (start_offset, end_offset,\n+                                                   instruction_start, instruction_end)))\n+      {\n+        DEBUG_MSG(SUBSET, nullptr, \"Unable to get instruction offsets for %d\", next_glyph);\n+        return false;\n+      }\n+    }\n+\n+    total += end_offset - start_offset - (*instruction_end - *instruction_start);\n+    \/* round2 so short loca will work *\/\n+    total += total % 2;\n+  }\n+\n+  *glyf_size = total;\n+  *use_short_loca = (total <= 131070);\n+  *loca_size = (glyph_ids.length + 1)\n+      * (*use_short_loca ? sizeof (OT::HBUINT16) : sizeof (OT::HBUINT32));\n+\n+  DEBUG_MSG(SUBSET, nullptr, \"preparing to subset glyf: final size %d, loca size %d, using %s loca\",\n+            total,\n+            *loca_size,\n+            *use_short_loca ? \"short\" : \"long\");\n+  return true;\n+}\n+\n+static bool\n+_write_loca_entry (unsigned int  id,\n+                   unsigned int  offset,\n+                   bool          is_short,\n+                   void         *loca_prime,\n+                   unsigned int  loca_size)\n+{\n+  unsigned int entry_size = is_short ? sizeof (OT::HBUINT16) : sizeof (OT::HBUINT32);\n+  if ((id + 1) * entry_size <= loca_size)\n+  {\n+    if (is_short) {\n+      ((OT::HBUINT16*) loca_prime) [id].set (offset \/ 2);\n+    } else {\n+      ((OT::HBUINT32*) loca_prime) [id].set (offset);\n+    }\n+    return true;\n+  }\n+\n+  \/\/ Offset was not written because the write is out of bounds.\n+  DEBUG_MSG(SUBSET,\n+            nullptr,\n+            \"WARNING: Attempted to write an out of bounds loca entry at index %d. Loca size is %d.\",\n+            id,\n+            loca_size);\n+  return false;\n+}\n+\n+static void\n+_update_components (hb_subset_plan_t * plan,\n+                    char * glyph_start,\n+                    unsigned int length)\n+{\n+  OT::glyf::CompositeGlyphHeader::Iterator iterator;\n+  if (OT::glyf::CompositeGlyphHeader::get_iterator (glyph_start,\n+                                                    length,\n+                                                    &iterator))\n+  {\n+    do\n+    {\n+      hb_codepoint_t new_gid;\n+      if (!plan->new_gid_for_old_gid (iterator.current->glyphIndex,\n+                                      &new_gid))\n+        continue;\n+\n+      ((OT::glyf::CompositeGlyphHeader *) iterator.current)->glyphIndex.set (new_gid);\n+    } while (iterator.move_to_next ());\n+  }\n+}\n+\n+static bool _remove_composite_instruction_flag (char *glyf_prime, unsigned int length)\n+{\n+  \/* remove WE_HAVE_INSTRUCTIONS from flags in dest *\/\n+  OT::glyf::CompositeGlyphHeader::Iterator composite_it;\n+  if (unlikely (!OT::glyf::CompositeGlyphHeader::get_iterator (glyf_prime, length, &composite_it))) return false;\n+  const OT::glyf::CompositeGlyphHeader *glyph;\n+  do {\n+    glyph = composite_it.current;\n+    OT::HBUINT16 *flags = const_cast<OT::HBUINT16 *> (&glyph->flags);\n+    flags->set ( (uint16_t) *flags & ~OT::glyf::CompositeGlyphHeader::WE_HAVE_INSTRUCTIONS);\n+  } while (composite_it.move_to_next ());\n+  return true;\n+}\n+\n+static bool\n+_write_glyf_and_loca_prime (hb_subset_plan_t              *plan,\n+                            const OT::glyf::accelerator_t &glyf,\n+                            const char                    *glyf_data,\n+                            bool                           use_short_loca,\n+                            hb_vector_t<unsigned int> &instruction_ranges,\n+                            unsigned int                   glyf_prime_size,\n+                            char                          *glyf_prime_data \/* OUT *\/,\n+                            unsigned int                   loca_prime_size,\n+                            char                          *loca_prime_data \/* OUT *\/)\n+{\n+  hb_vector_t<hb_codepoint_t> &glyph_ids = plan->glyphs;\n+  char *glyf_prime_data_next = glyf_prime_data;\n+\n+  bool success = true;\n+  for (unsigned int i = 0; i < glyph_ids.length; i++)\n+  {\n+    unsigned int start_offset, end_offset;\n+    if (unlikely (!(glyf.get_offsets (glyph_ids[i], &start_offset, &end_offset) &&\n+                    glyf.remove_padding (start_offset, &end_offset))))\n+      end_offset = start_offset = 0;\n+\n+    unsigned int instruction_start = instruction_ranges[i * 2];\n+    unsigned int instruction_end = instruction_ranges[i * 2 + 1];\n+\n+    int length = end_offset - start_offset - (instruction_end - instruction_start);\n+\n+    if (glyf_prime_data_next + length > glyf_prime_data + glyf_prime_size)\n+    {\n+      DEBUG_MSG(SUBSET,\n+                 nullptr,\n+                 \"WARNING: Attempted to write an out of bounds glyph entry for gid %d (length %d)\",\n+                 i, length);\n+      return false;\n+    }\n+\n+    if (instruction_start == instruction_end)\n+      memcpy (glyf_prime_data_next, glyf_data + start_offset, length);\n+    else\n+    {\n+      memcpy (glyf_prime_data_next, glyf_data + start_offset, instruction_start - start_offset);\n+      memcpy (glyf_prime_data_next + instruction_start - start_offset, glyf_data + instruction_end, end_offset - instruction_end);\n+      \/* if the instructions end at the end this was a composite glyph, else simple *\/\n+      if (instruction_end == end_offset)\n+      {\n+        if (unlikely (!_remove_composite_instruction_flag (glyf_prime_data_next, length))) return false;\n+      }\n+      else\n+        \/* zero instruction length, which is just before instruction_start *\/\n+        memset (glyf_prime_data_next + instruction_start - start_offset - 2, 0, 2);\n+    }\n+\n+    success = success && _write_loca_entry (i,\n+                                            glyf_prime_data_next - glyf_prime_data,\n+                                            use_short_loca,\n+                                            loca_prime_data,\n+                                            loca_prime_size);\n+    _update_components (plan, glyf_prime_data_next, length);\n+\n+    \/\/ TODO: don't align to two bytes if using long loca.\n+    glyf_prime_data_next += length + (length % 2); \/\/ Align to 2 bytes for short loca.\n+  }\n+\n+  success = success && _write_loca_entry (glyph_ids.length,\n+                                          glyf_prime_data_next - glyf_prime_data,\n+                                          use_short_loca,\n+                                          loca_prime_data,\n+                                          loca_prime_size);\n+  return success;\n+}\n+\n+static bool\n+_hb_subset_glyf_and_loca (const OT::glyf::accelerator_t  &glyf,\n+                          const char                     *glyf_data,\n+                          hb_subset_plan_t               *plan,\n+                          bool                           *use_short_loca,\n+                          hb_blob_t                     **glyf_prime \/* OUT *\/,\n+                          hb_blob_t                     **loca_prime \/* OUT *\/)\n+{\n+  \/\/ TODO(grieger): Sanity check allocation size for the new table.\n+  hb_vector_t<hb_codepoint_t> &glyphs_to_retain = plan->glyphs;\n+\n+  unsigned int glyf_prime_size;\n+  unsigned int loca_prime_size;\n+  hb_vector_t<unsigned int> instruction_ranges;\n+  instruction_ranges.init ();\n+\n+  if (unlikely (!_calculate_glyf_and_loca_prime_size (glyf,\n+                                                      glyphs_to_retain,\n+                                                      plan->drop_hints,\n+                                                      use_short_loca,\n+                                                      &glyf_prime_size,\n+                                                      &loca_prime_size,\n+                                                      &instruction_ranges))) {\n+    instruction_ranges.fini ();\n+    return false;\n+  }\n+\n+  char *glyf_prime_data = (char *) calloc (1, glyf_prime_size);\n+  char *loca_prime_data = (char *) calloc (1, loca_prime_size);\n+  if (unlikely (!_write_glyf_and_loca_prime (plan, glyf, glyf_data,\n+                                             *use_short_loca,\n+                                             instruction_ranges,\n+                                             glyf_prime_size, glyf_prime_data,\n+                                             loca_prime_size, loca_prime_data))) {\n+    free (glyf_prime_data);\n+    free (loca_prime_data);\n+    instruction_ranges.fini ();\n+    return false;\n+  }\n+  instruction_ranges.fini ();\n+\n+  *glyf_prime = hb_blob_create (glyf_prime_data,\n+                                glyf_prime_size,\n+                                HB_MEMORY_MODE_READONLY,\n+                                glyf_prime_data,\n+                                free);\n+  *loca_prime = hb_blob_create (loca_prime_data,\n+                                loca_prime_size,\n+                                HB_MEMORY_MODE_READONLY,\n+                                loca_prime_data,\n+                                free);\n+  return true;\n+}\n+\n+\/**\n+ * hb_subset_glyf:\n+ * Subsets the glyph table according to a provided plan.\n+ *\n+ * Return value: subsetted glyf table.\n+ *\n+ * Since: 1.7.5\n+ **\/\n+bool\n+hb_subset_glyf_and_loca (hb_subset_plan_t *plan,\n+                         bool             *use_short_loca, \/* OUT *\/\n+                         hb_blob_t       **glyf_prime, \/* OUT *\/\n+                         hb_blob_t       **loca_prime \/* OUT *\/)\n+{\n+  hb_blob_t *glyf_blob = hb_sanitize_context_t ().reference_table<OT::glyf> (plan->source);\n+  const char *glyf_data = hb_blob_get_data (glyf_blob, nullptr);\n+\n+  OT::glyf::accelerator_t glyf;\n+  glyf.init (plan->source);\n+  bool result = _hb_subset_glyf_and_loca (glyf,\n+                                          glyf_data,\n+                                          plan,\n+                                          use_short_loca,\n+                                          glyf_prime,\n+                                          loca_prime);\n+\n+  hb_blob_destroy (glyf_blob);\n+  glyf.fini ();\n+\n+  return result;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-glyf.cc","additions":310,"deletions":0,"binary":false,"changes":310,"status":"added"},{"patch":"@@ -0,0 +1,40 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger\n+ *\/\n+\n+#ifndef HB_SUBSET_GLYF_HH\n+#define HB_SUBSET_GLYF_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-subset.hh\"\n+\n+HB_INTERNAL bool\n+hb_subset_glyf_and_loca (hb_subset_plan_t *plan,\n+                         bool             *use_short_loca, \/* OUT *\/\n+                         hb_blob_t       **glyf_prime      \/* OUT *\/,\n+                         hb_blob_t       **loca_prime      \/* OUT *\/);\n+\n+#endif \/* HB_SUBSET_GLYF_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-glyf.hh","additions":40,"deletions":0,"binary":false,"changes":40,"status":"added"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger, Rod Sheeter, Behdad Esfahbod\n+ *\/\n+\n+#include \"hb-subset.hh\"\n+#include \"hb-set.hh\"\n+\n+\/**\n+ * hb_subset_input_create_or_fail:\n+ *\n+ * Return value: New subset input.\n+ *\n+ * Since: 1.8.0\n+ **\/\n+hb_subset_input_t *\n+hb_subset_input_create_or_fail ()\n+{\n+  hb_subset_input_t *input = hb_object_create<hb_subset_input_t>();\n+\n+  if (unlikely (!input))\n+    return nullptr;\n+\n+  input->unicodes = hb_set_create ();\n+  input->glyphs = hb_set_create ();\n+  input->drop_layout = true;\n+\n+  return input;\n+}\n+\n+\/**\n+ * hb_subset_input_reference: (skip)\n+ * @subset_input: a subset_input.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 1.8.0\n+ **\/\n+hb_subset_input_t *\n+hb_subset_input_reference (hb_subset_input_t *subset_input)\n+{\n+  return hb_object_reference (subset_input);\n+}\n+\n+\/**\n+ * hb_subset_input_destroy:\n+ * @subset_input: a subset_input.\n+ *\n+ * Since: 1.8.0\n+ **\/\n+void\n+hb_subset_input_destroy (hb_subset_input_t *subset_input)\n+{\n+  if (!hb_object_destroy (subset_input)) return;\n+\n+  hb_set_destroy (subset_input->unicodes);\n+  hb_set_destroy (subset_input->glyphs);\n+\n+  free (subset_input);\n+}\n+\n+\/**\n+ * hb_subset_input_unicode_set:\n+ * @subset_input: a subset_input.\n+ *\n+ * Since: 1.8.0\n+ **\/\n+HB_EXTERN hb_set_t *\n+hb_subset_input_unicode_set (hb_subset_input_t *subset_input)\n+{\n+  return subset_input->unicodes;\n+}\n+\n+\/**\n+ * hb_subset_input_glyph_set:\n+ * @subset_input: a subset_input.\n+ *\n+ * Since: 1.8.0\n+ **\/\n+HB_EXTERN hb_set_t *\n+hb_subset_input_glyph_set (hb_subset_input_t *subset_input)\n+{\n+  return subset_input->glyphs;\n+}\n+\n+HB_EXTERN void\n+hb_subset_input_set_drop_hints (hb_subset_input_t *subset_input,\n+                                hb_bool_t drop_hints)\n+{\n+  subset_input->drop_hints = drop_hints;\n+}\n+\n+HB_EXTERN hb_bool_t\n+hb_subset_input_get_drop_hints (hb_subset_input_t *subset_input)\n+{\n+  return subset_input->drop_hints;\n+}\n+\n+HB_EXTERN void\n+hb_subset_input_set_drop_layout (hb_subset_input_t *subset_input,\n+                                 hb_bool_t drop_layout)\n+{\n+  subset_input->drop_layout = drop_layout;\n+}\n+\n+HB_EXTERN hb_bool_t\n+hb_subset_input_get_drop_layout (hb_subset_input_t *subset_input)\n+{\n+  return subset_input->drop_layout;\n+}\n+\n+HB_EXTERN void\n+hb_subset_input_set_desubroutinize (hb_subset_input_t *subset_input,\n+        hb_bool_t desubroutinize)\n+{\n+  subset_input->desubroutinize = desubroutinize;\n+}\n+\n+HB_EXTERN hb_bool_t\n+hb_subset_input_get_desubroutinize (hb_subset_input_t *subset_input)\n+{\n+  return subset_input->desubroutinize;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-input.cc","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger, Roderick Sheeter\n+ *\/\n+\n+#ifndef HB_SUBSET_INPUT_HH\n+#define HB_SUBSET_INPUT_HH\n+\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-subset.h\"\n+\n+#include \"hb-font.hh\"\n+\n+struct hb_subset_input_t\n+{\n+  hb_object_header_t header;\n+\n+  hb_set_t *unicodes;\n+  hb_set_t *glyphs;\n+\n+  bool drop_hints : 1;\n+  bool drop_layout : 1;\n+  bool desubroutinize : 1;\n+  \/* TODO\n+   *\n+   * features\n+   * lookups\n+   * nameIDs\n+   * ...\n+   *\/\n+};\n+\n+\n+#endif \/* HB_SUBSET_INPUT_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-input.hh","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,223 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger, Roderick Sheeter\n+ *\/\n+\n+#include \"hb-subset-plan.hh\"\n+#include \"hb-map.hh\"\n+#include \"hb-set.hh\"\n+\n+#include \"hb-ot-cmap-table.hh\"\n+#include \"hb-ot-glyf-table.hh\"\n+#include \"hb-ot-cff1-table.hh\"\n+\n+static void\n+_add_gid_and_children (const OT::glyf::accelerator_t &glyf,\n+                       hb_codepoint_t gid,\n+                       hb_set_t *gids_to_retain)\n+{\n+  if (hb_set_has (gids_to_retain, gid))\n+    \/\/ Already visited this gid, ignore.\n+    return;\n+\n+  hb_set_add (gids_to_retain, gid);\n+\n+  OT::glyf::CompositeGlyphHeader::Iterator composite;\n+  if (glyf.get_composite (gid, &composite))\n+  {\n+    do\n+    {\n+      _add_gid_and_children (glyf, (hb_codepoint_t) composite.current->glyphIndex, gids_to_retain);\n+    } while (composite.move_to_next());\n+  }\n+}\n+\n+static void\n+_add_cff_seac_components (const OT::cff1::accelerator_t &cff,\n+           hb_codepoint_t gid,\n+           hb_set_t *gids_to_retain)\n+{\n+  hb_codepoint_t base_gid, accent_gid;\n+  if (cff.get_seac_components (gid, &base_gid, &accent_gid))\n+  {\n+    hb_set_add (gids_to_retain, base_gid);\n+    hb_set_add (gids_to_retain, accent_gid);\n+  }\n+}\n+\n+static void\n+_gsub_closure (hb_face_t *face, hb_set_t *gids_to_retain)\n+{\n+  hb_set_t lookup_indices;\n+  hb_ot_layout_collect_lookups (face,\n+                                HB_OT_TAG_GSUB,\n+                                nullptr,\n+                                nullptr,\n+                                nullptr,\n+                                &lookup_indices);\n+  hb_ot_layout_lookups_substitute_closure (face,\n+                                           &lookup_indices,\n+                                           gids_to_retain);\n+}\n+\n+static void\n+_remove_invalid_gids (hb_set_t *glyphs,\n+                      unsigned int num_glyphs)\n+{\n+  hb_codepoint_t gid = HB_SET_VALUE_INVALID;\n+  while (glyphs->next (&gid))\n+  {\n+    if (gid >= num_glyphs)\n+      glyphs->del (gid);\n+  }\n+}\n+\n+static hb_set_t *\n+_populate_gids_to_retain (hb_face_t *face,\n+                          const hb_set_t *unicodes,\n+                          bool close_over_gsub,\n+                          hb_set_t *unicodes_to_retain,\n+                          hb_map_t *codepoint_to_glyph,\n+                          hb_vector_t<hb_codepoint_t> *glyphs)\n+{\n+  OT::cmap::accelerator_t cmap;\n+  OT::glyf::accelerator_t glyf;\n+  OT::cff1::accelerator_t cff;\n+  cmap.init (face);\n+  glyf.init (face);\n+  cff.init (face);\n+\n+  hb_set_t *initial_gids_to_retain = hb_set_create ();\n+  initial_gids_to_retain->add (0); \/\/ Not-def\n+\n+  hb_codepoint_t cp = HB_SET_VALUE_INVALID;\n+  while (unicodes->next (&cp))\n+  {\n+    hb_codepoint_t gid;\n+    if (!cmap.get_nominal_glyph (cp, &gid))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"Drop U+%04X; no gid\", cp);\n+      continue;\n+    }\n+    unicodes_to_retain->add (cp);\n+    codepoint_to_glyph->set (cp, gid);\n+    initial_gids_to_retain->add (gid);\n+  }\n+\n+  if (close_over_gsub)\n+    \/\/ Add all glyphs needed for GSUB substitutions.\n+    _gsub_closure (face, initial_gids_to_retain);\n+\n+  \/\/ Populate a full set of glyphs to retain by adding all referenced\n+  \/\/ composite glyphs.\n+  hb_codepoint_t gid = HB_SET_VALUE_INVALID;\n+  hb_set_t *all_gids_to_retain = hb_set_create ();\n+  while (initial_gids_to_retain->next (&gid))\n+  {\n+    _add_gid_and_children (glyf, gid, all_gids_to_retain);\n+    if (cff.is_valid ())\n+      _add_cff_seac_components (cff, gid, all_gids_to_retain);\n+  }\n+  hb_set_destroy (initial_gids_to_retain);\n+\n+  _remove_invalid_gids (all_gids_to_retain, face->get_num_glyphs ());\n+\n+  glyphs->alloc (all_gids_to_retain->get_population ());\n+  gid = HB_SET_VALUE_INVALID;\n+  while (all_gids_to_retain->next (&gid))\n+    glyphs->push (gid);\n+\n+  cff.fini ();\n+  glyf.fini ();\n+  cmap.fini ();\n+\n+  return all_gids_to_retain;\n+}\n+\n+static void\n+_create_old_gid_to_new_gid_map (const hb_vector_t<hb_codepoint_t> &glyphs,\n+                                hb_map_t *glyph_map)\n+{\n+  for (unsigned int i = 0; i < glyphs.length; i++) {\n+    glyph_map->set (glyphs[i], i);\n+  }\n+}\n+\n+\/**\n+ * hb_subset_plan_create:\n+ * Computes a plan for subsetting the supplied face according\n+ * to a provided input. The plan describes\n+ * which tables and glyphs should be retained.\n+ *\n+ * Return value: New subset plan.\n+ *\n+ * Since: 1.7.5\n+ **\/\n+hb_subset_plan_t *\n+hb_subset_plan_create (hb_face_t           *face,\n+                       hb_subset_input_t   *input)\n+{\n+  hb_subset_plan_t *plan = hb_object_create<hb_subset_plan_t> ();\n+\n+  plan->drop_hints = input->drop_hints;\n+  plan->drop_layout = input->drop_layout;\n+  plan->desubroutinize = input->desubroutinize;\n+  plan->unicodes = hb_set_create();\n+  plan->glyphs.init();\n+  plan->source = hb_face_reference (face);\n+  plan->dest = hb_face_builder_create ();\n+  plan->codepoint_to_glyph = hb_map_create();\n+  plan->glyph_map = hb_map_create();\n+  plan->glyphset = _populate_gids_to_retain (face,\n+                                             input->unicodes,\n+                                             !plan->drop_layout,\n+                                             plan->unicodes,\n+                                             plan->codepoint_to_glyph,\n+                                             &plan->glyphs);\n+  _create_old_gid_to_new_gid_map (plan->glyphs,\n+                                  plan->glyph_map);\n+\n+  return plan;\n+}\n+\n+\/**\n+ * hb_subset_plan_destroy:\n+ *\n+ * Since: 1.7.5\n+ **\/\n+void\n+hb_subset_plan_destroy (hb_subset_plan_t *plan)\n+{\n+  if (!hb_object_destroy (plan)) return;\n+\n+  hb_set_destroy (plan->unicodes);\n+  plan->glyphs.fini ();\n+  hb_face_destroy (plan->source);\n+  hb_face_destroy (plan->dest);\n+  hb_map_destroy (plan->codepoint_to_glyph);\n+  hb_map_destroy (plan->glyph_map);\n+  hb_set_destroy (plan->glyphset);\n+\n+  free (plan);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-plan.cc","additions":223,"deletions":0,"binary":false,"changes":223,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger, Roderick Sheeter\n+ *\/\n+\n+#ifndef HB_SUBSET_PLAN_HH\n+#define HB_SUBSET_PLAN_HH\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-subset.h\"\n+#include \"hb-subset-input.hh\"\n+\n+#include \"hb-map.hh\"\n+\n+struct hb_subset_plan_t\n+{\n+  hb_object_header_t header;\n+\n+  bool drop_hints : 1;\n+  bool drop_layout : 1;\n+  bool desubroutinize : 1;\n+\n+  \/\/ For each cp that we'd like to retain maps to the corresponding gid.\n+  hb_set_t *unicodes;\n+\n+  hb_vector_t<hb_codepoint_t> glyphs;\n+  hb_set_t *glyphset;\n+\n+  hb_map_t *codepoint_to_glyph;\n+  hb_map_t *glyph_map;\n+\n+  \/\/ Plan is only good for a specific source\/dest so keep them with it\n+  hb_face_t *source;\n+  hb_face_t *dest;\n+\n+  bool new_gid_for_codepoint (hb_codepoint_t codepoint,\n+                              hb_codepoint_t *new_gid) const\n+  {\n+    hb_codepoint_t old_gid = codepoint_to_glyph->get (codepoint);\n+    if (old_gid == HB_MAP_VALUE_INVALID)\n+      return false;\n+\n+    return new_gid_for_old_gid (old_gid, new_gid);\n+  }\n+\n+  bool new_gid_for_old_gid (hb_codepoint_t old_gid,\n+                            hb_codepoint_t *new_gid) const\n+  {\n+    hb_codepoint_t gid = glyph_map->get (old_gid);\n+    if (gid == HB_MAP_VALUE_INVALID)\n+      return false;\n+\n+    *new_gid = gid;\n+    return true;\n+  }\n+\n+  bool\n+  add_table (hb_tag_t tag,\n+             hb_blob_t *contents)\n+  {\n+    hb_blob_t *source_blob = source->reference_table (tag);\n+    DEBUG_MSG(SUBSET, nullptr, \"add table %c%c%c%c, dest %d bytes, source %d bytes\",\n+              HB_UNTAG(tag),\n+              hb_blob_get_length (contents),\n+              hb_blob_get_length (source_blob));\n+    hb_blob_destroy (source_blob);\n+    return hb_face_builder_add_table (dest, tag, contents);\n+  }\n+};\n+\n+typedef struct hb_subset_plan_t hb_subset_plan_t;\n+\n+HB_INTERNAL hb_subset_plan_t *\n+hb_subset_plan_create (hb_face_t           *face,\n+                       hb_subset_input_t   *input);\n+\n+HB_INTERNAL void\n+hb_subset_plan_destroy (hb_subset_plan_t *plan);\n+\n+#endif \/* HB_SUBSET_PLAN_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset-plan.hh","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger, Rod Sheeter, Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+#include \"hb-open-type.hh\"\n+\n+#include \"hb-subset.hh\"\n+#include \"hb-subset-glyf.hh\"\n+\n+#include \"hb-open-file.hh\"\n+#include \"hb-ot-cmap-table.hh\"\n+#include \"hb-ot-glyf-table.hh\"\n+#include \"hb-ot-hdmx-table.hh\"\n+#include \"hb-ot-head-table.hh\"\n+#include \"hb-ot-hhea-table.hh\"\n+#include \"hb-ot-hmtx-table.hh\"\n+#include \"hb-ot-maxp-table.hh\"\n+#include \"hb-ot-os2-table.hh\"\n+#include \"hb-ot-post-table.hh\"\n+#include \"hb-ot-cff1-table.hh\"\n+#include \"hb-ot-cff2-table.hh\"\n+#include \"hb-ot-vorg-table.hh\"\n+#include \"hb-ot-layout-gsub-table.hh\"\n+#include \"hb-ot-layout-gpos-table.hh\"\n+\n+\n+static unsigned int\n+_plan_estimate_subset_table_size (hb_subset_plan_t *plan,\n+                                  unsigned int table_len)\n+{\n+  unsigned int src_glyphs = plan->source->get_num_glyphs ();\n+  unsigned int dst_glyphs = plan->glyphset->get_population ();\n+\n+  if (unlikely (!src_glyphs))\n+    return 512 + table_len;\n+\n+  return 512 + (unsigned int) (table_len * sqrt ((double) dst_glyphs \/ src_glyphs));\n+}\n+\n+template<typename TableType>\n+static bool\n+_subset2 (hb_subset_plan_t *plan)\n+{\n+  hb_blob_t *source_blob = hb_sanitize_context_t ().reference_table<TableType> (plan->source);\n+  const TableType *table = source_blob->as<TableType> ();\n+\n+  hb_tag_t tag = TableType::tableTag;\n+  hb_bool_t result = false;\n+  if (source_blob->data)\n+  {\n+    hb_vector_t<char> buf;\n+    unsigned int buf_size = _plan_estimate_subset_table_size (plan, source_blob->length);\n+    DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c initial estimated table size: %u bytes.\", HB_UNTAG (tag), buf_size);\n+    if (unlikely (!buf.alloc (buf_size)))\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c failed to allocate %u bytes.\", HB_UNTAG (tag), buf_size);\n+      return false;\n+    }\n+  retry:\n+    hb_serialize_context_t serializer ((void *) buf, buf_size);\n+    hb_subset_context_t c (plan, &serializer);\n+    result = table->subset (&c);\n+    if (serializer.in_error ())\n+    {\n+      buf_size += (buf_size >> 1) + 32;\n+      DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c ran out of room; reallocating to %u bytes.\", HB_UNTAG (tag), buf_size);\n+      if (unlikely (!buf.alloc (buf_size)))\n+      {\n+        DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c failed to reallocate %u bytes.\", HB_UNTAG (tag), buf_size);\n+        return false;\n+      }\n+      goto retry;\n+    }\n+    if (result)\n+    {\n+      hb_blob_t *dest_blob = serializer.copy_blob ();\n+      DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c final subset table size: %u bytes.\", HB_UNTAG (tag), dest_blob->length);\n+      result = c.plan->add_table (tag, dest_blob);\n+      hb_blob_destroy (dest_blob);\n+    }\n+    else\n+    {\n+      DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c::subset table subsetted to empty.\", HB_UNTAG (tag));\n+      result = true;\n+    }\n+  }\n+  else\n+    DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c::subset sanitize failed on source table.\", HB_UNTAG (tag));\n+\n+  hb_blob_destroy (source_blob);\n+  DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c::subset %s\", HB_UNTAG (tag), result ? \"success\" : \"FAILED!\");\n+  return result;\n+}\n+\n+template<typename TableType>\n+static bool\n+_subset (hb_subset_plan_t *plan)\n+{\n+  hb_blob_t *source_blob = hb_sanitize_context_t ().reference_table<TableType> (plan->source);\n+  const TableType *table = source_blob->as<TableType> ();\n+\n+  hb_tag_t tag = TableType::tableTag;\n+  hb_bool_t result = false;\n+  if (source_blob->data)\n+    result = table->subset (plan);\n+  else\n+    DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c::subset sanitize failed on source table.\", HB_UNTAG (tag));\n+\n+  hb_blob_destroy (source_blob);\n+  DEBUG_MSG(SUBSET, nullptr, \"OT::%c%c%c%c::subset %s\", HB_UNTAG (tag), result ? \"success\" : \"FAILED!\");\n+  return result;\n+}\n+\n+\n+static bool\n+_subset_table (hb_subset_plan_t *plan,\n+               hb_tag_t          tag)\n+{\n+  DEBUG_MSG(SUBSET, nullptr, \"begin subset %c%c%c%c\", HB_UNTAG (tag));\n+  bool result = true;\n+  switch (tag) {\n+    case HB_OT_TAG_glyf:\n+      result = _subset<const OT::glyf> (plan);\n+      break;\n+    case HB_OT_TAG_hdmx:\n+      result = _subset<const OT::hdmx> (plan);\n+      break;\n+    case HB_OT_TAG_head:\n+      \/\/ TODO that won't work well if there is no glyf\n+      DEBUG_MSG(SUBSET, nullptr, \"skip head, handled by glyf\");\n+      result = true;\n+      break;\n+    case HB_OT_TAG_hhea:\n+      DEBUG_MSG(SUBSET, nullptr, \"skip hhea handled by hmtx\");\n+      return true;\n+    case HB_OT_TAG_hmtx:\n+      result = _subset<const OT::hmtx> (plan);\n+      break;\n+    case HB_OT_TAG_vhea:\n+      DEBUG_MSG(SUBSET, nullptr, \"skip vhea handled by vmtx\");\n+      return true;\n+    case HB_OT_TAG_vmtx:\n+      result = _subset<const OT::vmtx> (plan);\n+      break;\n+    case HB_OT_TAG_maxp:\n+      result = _subset<const OT::maxp> (plan);\n+      break;\n+    case HB_OT_TAG_loca:\n+      DEBUG_MSG(SUBSET, nullptr, \"skip loca handled by glyf\");\n+      return true;\n+    case HB_OT_TAG_cmap:\n+      result = _subset<const OT::cmap> (plan);\n+      break;\n+    case HB_OT_TAG_OS2:\n+      result = _subset<const OT::OS2> (plan);\n+      break;\n+    case HB_OT_TAG_post:\n+      result = _subset<const OT::post> (plan);\n+      break;\n+    case HB_OT_TAG_cff1:\n+      result = _subset<const OT::cff1> (plan);\n+      break;\n+    case HB_OT_TAG_cff2:\n+      result = _subset<const OT::cff2> (plan);\n+      break;\n+    case HB_OT_TAG_VORG:\n+      result = _subset<const OT::VORG> (plan);\n+      break;\n+    case HB_OT_TAG_GDEF:\n+      result = _subset2<const OT::GDEF> (plan);\n+      break;\n+    case HB_OT_TAG_GSUB:\n+      result = _subset2<const OT::GSUB> (plan);\n+      break;\n+    case HB_OT_TAG_GPOS:\n+      result = _subset2<const OT::GPOS> (plan);\n+      break;\n+\n+    default:\n+      hb_blob_t *source_table = hb_face_reference_table (plan->source, tag);\n+      if (likely (source_table))\n+        result = plan->add_table (tag, source_table);\n+      else\n+        result = false;\n+      hb_blob_destroy (source_table);\n+      break;\n+  }\n+  DEBUG_MSG(SUBSET, nullptr, \"subset %c%c%c%c %s\", HB_UNTAG (tag), result ? \"ok\" : \"FAILED\");\n+  return result;\n+}\n+\n+static bool\n+_should_drop_table (hb_subset_plan_t *plan, hb_tag_t tag)\n+{\n+  switch (tag) {\n+    case HB_TAG ('c', 'v', 'a', 'r'): \/* hint table, fallthrough *\/\n+    case HB_TAG ('c', 'v', 't', ' '): \/* hint table, fallthrough *\/\n+    case HB_TAG ('f', 'p', 'g', 'm'): \/* hint table, fallthrough *\/\n+    case HB_TAG ('p', 'r', 'e', 'p'): \/* hint table, fallthrough *\/\n+    case HB_TAG ('h', 'd', 'm', 'x'): \/* hint table, fallthrough *\/\n+    case HB_TAG ('V', 'D', 'M', 'X'): \/* hint table, fallthrough *\/\n+      return plan->drop_hints;\n+    \/\/ Drop Layout Tables if requested.\n+    case HB_OT_TAG_GDEF:\n+    case HB_OT_TAG_GPOS:\n+    case HB_OT_TAG_GSUB:\n+      return plan->drop_layout;\n+    \/\/ Drop these tables below by default, list pulled\n+    \/\/ from fontTools:\n+    case HB_TAG ('B', 'A', 'S', 'E'):\n+    case HB_TAG ('J', 'S', 'T', 'F'):\n+    case HB_TAG ('D', 'S', 'I', 'G'):\n+    case HB_TAG ('E', 'B', 'D', 'T'):\n+    case HB_TAG ('E', 'B', 'L', 'C'):\n+    case HB_TAG ('E', 'B', 'S', 'C'):\n+    case HB_TAG ('S', 'V', 'G', ' '):\n+    case HB_TAG ('P', 'C', 'L', 'T'):\n+    case HB_TAG ('L', 'T', 'S', 'H'):\n+    \/\/ Graphite tables:\n+    case HB_TAG ('F', 'e', 'a', 't'):\n+    case HB_TAG ('G', 'l', 'a', 't'):\n+    case HB_TAG ('G', 'l', 'o', 'c'):\n+    case HB_TAG ('S', 'i', 'l', 'f'):\n+    case HB_TAG ('S', 'i', 'l', 'l'):\n+    \/\/ Colour\n+    case HB_TAG ('s', 'b', 'i', 'x'):\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/**\n+ * hb_subset:\n+ * @source: font face data to be subset.\n+ * @input: input to use for the subsetting.\n+ *\n+ * Subsets a font according to provided input.\n+ **\/\n+hb_face_t *\n+hb_subset (hb_face_t *source,\n+           hb_subset_input_t *input)\n+{\n+  if (unlikely (!input || !source)) return hb_face_get_empty ();\n+\n+  hb_subset_plan_t *plan = hb_subset_plan_create (source, input);\n+\n+  hb_tag_t table_tags[32];\n+  unsigned int offset = 0, count;\n+  bool success = true;\n+  do {\n+    count = ARRAY_LENGTH (table_tags);\n+    hb_face_get_table_tags (source, offset, &count, table_tags);\n+    for (unsigned int i = 0; i < count; i++)\n+    {\n+      hb_tag_t tag = table_tags[i];\n+      if (_should_drop_table (plan, tag))\n+      {\n+        DEBUG_MSG(SUBSET, nullptr, \"drop %c%c%c%c\", HB_UNTAG (tag));\n+        continue;\n+      }\n+      success = success && _subset_table (plan, tag);\n+    }\n+    offset += count;\n+  } while (success && count == ARRAY_LENGTH (table_tags));\n+\n+  hb_face_t *result = success ? hb_face_reference (plan->dest) : hb_face_get_empty ();\n+  hb_subset_plan_destroy (plan);\n+  return result;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset.cc","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Rod Sheeter\n+ *\/\n+\n+#ifndef HB_SUBSET_H\n+#define HB_SUBSET_H\n+\n+#include \"hb.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\/*\n+ * hb_subset_input_t\n+ *\n+ * Things that change based on the input. Characters to keep, etc.\n+ *\/\n+\n+typedef struct hb_subset_input_t hb_subset_input_t;\n+\n+HB_EXTERN hb_subset_input_t *\n+hb_subset_input_create_or_fail (void);\n+\n+HB_EXTERN hb_subset_input_t *\n+hb_subset_input_reference (hb_subset_input_t *subset_input);\n+\n+HB_EXTERN void\n+hb_subset_input_destroy (hb_subset_input_t *subset_input);\n+\n+HB_EXTERN hb_set_t *\n+hb_subset_input_unicode_set (hb_subset_input_t *subset_input);\n+\n+HB_EXTERN hb_set_t *\n+hb_subset_input_glyph_set (hb_subset_input_t *subset_input);\n+\n+HB_EXTERN void\n+hb_subset_input_set_drop_hints (hb_subset_input_t *subset_input,\n+                                hb_bool_t drop_hints);\n+HB_EXTERN hb_bool_t\n+hb_subset_input_get_drop_hints (hb_subset_input_t *subset_input);\n+\n+HB_EXTERN void\n+hb_subset_input_set_drop_layout (hb_subset_input_t *subset_input,\n+                                 hb_bool_t drop_layout);\n+HB_EXTERN hb_bool_t\n+hb_subset_input_get_drop_layout (hb_subset_input_t *subset_input);\n+\n+HB_EXTERN void\n+hb_subset_input_set_desubroutinize (hb_subset_input_t *subset_input,\n+        hb_bool_t desubroutinize);\n+HB_EXTERN hb_bool_t\n+hb_subset_input_get_desubroutinize (hb_subset_input_t *subset_input);\n+\n+\/* hb_subset () *\/\n+HB_EXTERN hb_face_t *\n+hb_subset (hb_face_t *source, hb_subset_input_t *input);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_SUBSET_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset.h","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright © 2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Garret Rieger, Roderick Sheeter\n+ *\/\n+\n+#ifndef HB_SUBSET_HH\n+#define HB_SUBSET_HH\n+\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-subset.h\"\n+\n+#include \"hb-machinery.hh\"\n+#include \"hb-subset-input.hh\"\n+#include \"hb-subset-plan.hh\"\n+\n+struct hb_subset_context_t :\n+       hb_dispatch_context_t<hb_subset_context_t, bool, HB_DEBUG_SUBSET>\n+{\n+  const char *get_name () { return \"SUBSET\"; }\n+  template <typename T>\n+  bool dispatch (const T &obj) { return obj.subset (this); }\n+  static bool default_return_value () { return true; }\n+\n+  hb_subset_plan_t *plan;\n+  hb_serialize_context_t *serializer;\n+  unsigned int debug_depth;\n+\n+  hb_subset_context_t (hb_subset_plan_t *plan_,\n+                       hb_serialize_context_t *serializer_) :\n+                        plan (plan_),\n+                        serializer (serializer_),\n+                        debug_depth (0) {}\n+};\n+\n+\n+#endif \/* HB_SUBSET_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-subset.hh","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -0,0 +1,268 @@\n+\/*\n+ * Copyright (C) 2012 Grigori Goronzy <greg@kinoho.net>\n+ *\n+ * Permission to use, copy, modify, and\/or distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-machinery.hh\"\n+\n+#include \"ucdn.h\"\n+\n+static const hb_script_t ucdn_script_translate[] =\n+{\n+    HB_SCRIPT_COMMON,\n+    HB_SCRIPT_LATIN,\n+    HB_SCRIPT_GREEK,\n+    HB_SCRIPT_CYRILLIC,\n+    HB_SCRIPT_ARMENIAN,\n+    HB_SCRIPT_HEBREW,\n+    HB_SCRIPT_ARABIC,\n+    HB_SCRIPT_SYRIAC,\n+    HB_SCRIPT_THAANA,\n+    HB_SCRIPT_DEVANAGARI,\n+    HB_SCRIPT_BENGALI,\n+    HB_SCRIPT_GURMUKHI,\n+    HB_SCRIPT_GUJARATI,\n+    HB_SCRIPT_ORIYA,\n+    HB_SCRIPT_TAMIL,\n+    HB_SCRIPT_TELUGU,\n+    HB_SCRIPT_KANNADA,\n+    HB_SCRIPT_MALAYALAM,\n+    HB_SCRIPT_SINHALA,\n+    HB_SCRIPT_THAI,\n+    HB_SCRIPT_LAO,\n+    HB_SCRIPT_TIBETAN,\n+    HB_SCRIPT_MYANMAR,\n+    HB_SCRIPT_GEORGIAN,\n+    HB_SCRIPT_HANGUL,\n+    HB_SCRIPT_ETHIOPIC,\n+    HB_SCRIPT_CHEROKEE,\n+    HB_SCRIPT_CANADIAN_SYLLABICS,\n+    HB_SCRIPT_OGHAM,\n+    HB_SCRIPT_RUNIC,\n+    HB_SCRIPT_KHMER,\n+    HB_SCRIPT_MONGOLIAN,\n+    HB_SCRIPT_HIRAGANA,\n+    HB_SCRIPT_KATAKANA,\n+    HB_SCRIPT_BOPOMOFO,\n+    HB_SCRIPT_HAN,\n+    HB_SCRIPT_YI,\n+    HB_SCRIPT_OLD_ITALIC,\n+    HB_SCRIPT_GOTHIC,\n+    HB_SCRIPT_DESERET,\n+    HB_SCRIPT_INHERITED,\n+    HB_SCRIPT_TAGALOG,\n+    HB_SCRIPT_HANUNOO,\n+    HB_SCRIPT_BUHID,\n+    HB_SCRIPT_TAGBANWA,\n+    HB_SCRIPT_LIMBU,\n+    HB_SCRIPT_TAI_LE,\n+    HB_SCRIPT_LINEAR_B,\n+    HB_SCRIPT_UGARITIC,\n+    HB_SCRIPT_SHAVIAN,\n+    HB_SCRIPT_OSMANYA,\n+    HB_SCRIPT_CYPRIOT,\n+    HB_SCRIPT_BRAILLE,\n+    HB_SCRIPT_BUGINESE,\n+    HB_SCRIPT_COPTIC,\n+    HB_SCRIPT_NEW_TAI_LUE,\n+    HB_SCRIPT_GLAGOLITIC,\n+    HB_SCRIPT_TIFINAGH,\n+    HB_SCRIPT_SYLOTI_NAGRI,\n+    HB_SCRIPT_OLD_PERSIAN,\n+    HB_SCRIPT_KHAROSHTHI,\n+    HB_SCRIPT_BALINESE,\n+    HB_SCRIPT_CUNEIFORM,\n+    HB_SCRIPT_PHOENICIAN,\n+    HB_SCRIPT_PHAGS_PA,\n+    HB_SCRIPT_NKO,\n+    HB_SCRIPT_SUNDANESE,\n+    HB_SCRIPT_LEPCHA,\n+    HB_SCRIPT_OL_CHIKI,\n+    HB_SCRIPT_VAI,\n+    HB_SCRIPT_SAURASHTRA,\n+    HB_SCRIPT_KAYAH_LI,\n+    HB_SCRIPT_REJANG,\n+    HB_SCRIPT_LYCIAN,\n+    HB_SCRIPT_CARIAN,\n+    HB_SCRIPT_LYDIAN,\n+    HB_SCRIPT_CHAM,\n+    HB_SCRIPT_TAI_THAM,\n+    HB_SCRIPT_TAI_VIET,\n+    HB_SCRIPT_AVESTAN,\n+    HB_SCRIPT_EGYPTIAN_HIEROGLYPHS,\n+    HB_SCRIPT_SAMARITAN,\n+    HB_SCRIPT_LISU,\n+    HB_SCRIPT_BAMUM,\n+    HB_SCRIPT_JAVANESE,\n+    HB_SCRIPT_MEETEI_MAYEK,\n+    HB_SCRIPT_IMPERIAL_ARAMAIC,\n+    HB_SCRIPT_OLD_SOUTH_ARABIAN,\n+    HB_SCRIPT_INSCRIPTIONAL_PARTHIAN,\n+    HB_SCRIPT_INSCRIPTIONAL_PAHLAVI,\n+    HB_SCRIPT_OLD_TURKIC,\n+    HB_SCRIPT_KAITHI,\n+    HB_SCRIPT_BATAK,\n+    HB_SCRIPT_BRAHMI,\n+    HB_SCRIPT_MANDAIC,\n+    HB_SCRIPT_CHAKMA,\n+    HB_SCRIPT_MEROITIC_CURSIVE,\n+    HB_SCRIPT_MEROITIC_HIEROGLYPHS,\n+    HB_SCRIPT_MIAO,\n+    HB_SCRIPT_SHARADA,\n+    HB_SCRIPT_SORA_SOMPENG,\n+    HB_SCRIPT_TAKRI,\n+    HB_SCRIPT_UNKNOWN,\n+    HB_SCRIPT_BASSA_VAH,\n+    HB_SCRIPT_CAUCASIAN_ALBANIAN,\n+    HB_SCRIPT_DUPLOYAN,\n+    HB_SCRIPT_ELBASAN,\n+    HB_SCRIPT_GRANTHA,\n+    HB_SCRIPT_KHOJKI,\n+    HB_SCRIPT_KHUDAWADI,\n+    HB_SCRIPT_LINEAR_A,\n+    HB_SCRIPT_MAHAJANI,\n+    HB_SCRIPT_MANICHAEAN,\n+    HB_SCRIPT_MENDE_KIKAKUI,\n+    HB_SCRIPT_MODI,\n+    HB_SCRIPT_MRO,\n+    HB_SCRIPT_NABATAEAN,\n+    HB_SCRIPT_OLD_NORTH_ARABIAN,\n+    HB_SCRIPT_OLD_PERMIC,\n+    HB_SCRIPT_PAHAWH_HMONG,\n+    HB_SCRIPT_PALMYRENE,\n+    HB_SCRIPT_PAU_CIN_HAU,\n+    HB_SCRIPT_PSALTER_PAHLAVI,\n+    HB_SCRIPT_SIDDHAM,\n+    HB_SCRIPT_TIRHUTA,\n+    HB_SCRIPT_WARANG_CITI,\n+    HB_SCRIPT_AHOM,\n+    HB_SCRIPT_ANATOLIAN_HIEROGLYPHS,\n+    HB_SCRIPT_HATRAN,\n+    HB_SCRIPT_MULTANI,\n+    HB_SCRIPT_OLD_HUNGARIAN,\n+    HB_SCRIPT_SIGNWRITING,\n+    HB_SCRIPT_ADLAM,\n+    HB_SCRIPT_BHAIKSUKI,\n+    HB_SCRIPT_MARCHEN,\n+    HB_SCRIPT_NEWA,\n+    HB_SCRIPT_OSAGE,\n+    HB_SCRIPT_TANGUT,\n+    HB_SCRIPT_MASARAM_GONDI,\n+    HB_SCRIPT_NUSHU,\n+    HB_SCRIPT_SOYOMBO,\n+    HB_SCRIPT_ZANABAZAR_SQUARE,\n+    HB_SCRIPT_DOGRA,\n+    HB_SCRIPT_GUNJALA_GONDI,\n+    HB_SCRIPT_HANIFI_ROHINGYA,\n+    HB_SCRIPT_MAKASAR,\n+    HB_SCRIPT_MEDEFAIDRIN,\n+    HB_SCRIPT_OLD_SOGDIAN,\n+    HB_SCRIPT_SOGDIAN,\n+};\n+\n+static hb_unicode_combining_class_t\n+hb_ucdn_combining_class(hb_unicode_funcs_t *ufuncs HB_UNUSED,\n+                        hb_codepoint_t unicode,\n+                        void *user_data HB_UNUSED)\n+{\n+    return (hb_unicode_combining_class_t) ucdn_get_combining_class(unicode);\n+}\n+\n+static hb_unicode_general_category_t\n+hb_ucdn_general_category(hb_unicode_funcs_t *ufuncs HB_UNUSED,\n+                         hb_codepoint_t unicode,\n+                         void *user_data HB_UNUSED)\n+{\n+    return (hb_unicode_general_category_t)ucdn_get_general_category(unicode);\n+}\n+\n+static hb_codepoint_t\n+hb_ucdn_mirroring(hb_unicode_funcs_t *ufuncs HB_UNUSED,\n+                  hb_codepoint_t unicode,\n+                  void *user_data HB_UNUSED)\n+{\n+    return ucdn_mirror(unicode);\n+}\n+\n+static hb_script_t\n+hb_ucdn_script(hb_unicode_funcs_t *ufuncs HB_UNUSED,\n+               hb_codepoint_t unicode,\n+               void *user_data HB_UNUSED)\n+{\n+    return ucdn_script_translate[ucdn_get_script(unicode)];\n+}\n+\n+static hb_bool_t\n+hb_ucdn_compose(hb_unicode_funcs_t *ufuncs HB_UNUSED,\n+                hb_codepoint_t a, hb_codepoint_t b, hb_codepoint_t *ab,\n+                void *user_data HB_UNUSED)\n+{\n+    return ucdn_compose(ab, a, b);\n+}\n+\n+static hb_bool_t\n+hb_ucdn_decompose(hb_unicode_funcs_t *ufuncs HB_UNUSED,\n+                  hb_codepoint_t ab, hb_codepoint_t *a, hb_codepoint_t *b,\n+                  void *user_data HB_UNUSED)\n+{\n+    return ucdn_decompose(ab, a, b);\n+}\n+\n+\n+#if HB_USE_ATEXIT\n+static void free_static_ucdn_funcs ();\n+#endif\n+\n+static struct hb_ucdn_unicode_funcs_lazy_loader_t : hb_unicode_funcs_lazy_loader_t<hb_ucdn_unicode_funcs_lazy_loader_t>\n+{\n+  static hb_unicode_funcs_t *create ()\n+  {\n+    hb_unicode_funcs_t *funcs = hb_unicode_funcs_create (nullptr);\n+\n+    hb_unicode_funcs_set_combining_class_func (funcs, hb_ucdn_combining_class, nullptr, nullptr);\n+    hb_unicode_funcs_set_general_category_func (funcs, hb_ucdn_general_category, nullptr, nullptr);\n+    hb_unicode_funcs_set_mirroring_func (funcs, hb_ucdn_mirroring, nullptr, nullptr);\n+    hb_unicode_funcs_set_script_func (funcs, hb_ucdn_script, nullptr, nullptr);\n+    hb_unicode_funcs_set_compose_func (funcs, hb_ucdn_compose, nullptr, nullptr);\n+    hb_unicode_funcs_set_decompose_func (funcs, hb_ucdn_decompose, nullptr, nullptr);\n+\n+    hb_unicode_funcs_make_immutable (funcs);\n+\n+#if HB_USE_ATEXIT\n+    atexit (free_static_ucdn_funcs);\n+#endif\n+\n+    return funcs;\n+  }\n+} static_ucdn_funcs;\n+\n+#if HB_USE_ATEXIT\n+static\n+void free_static_ucdn_funcs ()\n+{\n+  static_ucdn_funcs.free_instance ();\n+}\n+#endif\n+\n+extern \"C\" HB_INTERNAL\n+hb_unicode_funcs_t *\n+hb_ucdn_get_unicode_funcs ();\n+\n+hb_unicode_funcs_t *\n+hb_ucdn_get_unicode_funcs ()\n+{\n+  return static_ucdn_funcs.get_unconst ();\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ucdn.cc","additions":268,"deletions":0,"binary":false,"changes":268,"status":"added"},{"patch":"@@ -0,0 +1,360 @@\n+\/*\n+ * Copyright (C) 2012 Grigori Goronzy <greg@kinoho.net>\n+ *\n+ * Permission to use, copy, modify, and\/or distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ *\/\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdint.h>\n+#include \"ucdn.h\"\n+\n+typedef struct {\n+    unsigned char category;\n+    unsigned char combining;\n+    unsigned char bidi_class;\n+    unsigned char east_asian_width;\n+    unsigned char script;\n+    unsigned char linebreak_class;\n+} UCDRecord;\n+\n+typedef struct {\n+    unsigned short from, to;\n+} MirrorPair;\n+\n+typedef struct {\n+  unsigned short from, to;\n+  unsigned char type;\n+} BracketPair;\n+\n+typedef struct {\n+    unsigned int start;\n+    short count, index;\n+} Reindex;\n+\n+#include \"ucdn_db.h\"\n+\n+\/* constants required for Hangul (de)composition *\/\n+#define SBASE 0xAC00\n+#define LBASE 0x1100\n+#define VBASE 0x1161\n+#define TBASE 0x11A7\n+#define SCOUNT 11172\n+#define LCOUNT 19\n+#define VCOUNT 21\n+#define TCOUNT 28\n+#define NCOUNT (VCOUNT * TCOUNT)\n+\n+static const UCDRecord *get_ucd_record(uint32_t code)\n+{\n+    int index, offset;\n+\n+    if (code >= 0x110000)\n+        index = 0;\n+    else {\n+        index  = index0[code >> (SHIFT1+SHIFT2)] << SHIFT1;\n+        offset = (code >> SHIFT2) & ((1<<SHIFT1) - 1);\n+        index  = index1[index + offset] << SHIFT2;\n+        offset = code & ((1<<SHIFT2) - 1);\n+        index  = index2[index + offset];\n+    }\n+\n+    return &ucd_records[index];\n+}\n+\n+static const unsigned short *get_decomp_record(uint32_t code)\n+{\n+    int index, offset;\n+\n+    if (code >= 0x110000)\n+        index = 0;\n+    else {\n+        index  = decomp_index0[code >> (DECOMP_SHIFT1+DECOMP_SHIFT2)]\n+            << DECOMP_SHIFT1;\n+        offset = (code >> DECOMP_SHIFT2) & ((1<<DECOMP_SHIFT1) - 1);\n+        index  = decomp_index1[index + offset] << DECOMP_SHIFT2;\n+        offset = code & ((1<<DECOMP_SHIFT2) - 1);\n+        index  = decomp_index2[index + offset];\n+    }\n+\n+    return &decomp_data[index];\n+}\n+\n+static int compare_reindex(const void *a, const void *b)\n+{\n+    Reindex *ra = (Reindex *)a;\n+    Reindex *rb = (Reindex *)b;\n+\n+    if (ra->start < rb->start)\n+        return -1;\n+    else if (ra->start > (rb->start + rb->count))\n+        return 1;\n+    else\n+        return 0;\n+}\n+\n+static int get_comp_index(uint32_t code, const Reindex *idx, size_t len)\n+{\n+    Reindex *res;\n+    Reindex r = {0, 0, 0};\n+    r.start = code;\n+    res = (Reindex *) bsearch(&r, idx, len, sizeof(Reindex), compare_reindex);\n+\n+    if (res != NULL)\n+        return res->index + (code - res->start);\n+    else\n+        return -1;\n+}\n+\n+static int compare_mp(const void *a, const void *b)\n+{\n+    MirrorPair *mpa = (MirrorPair *)a;\n+    MirrorPair *mpb = (MirrorPair *)b;\n+    return mpa->from - mpb->from;\n+}\n+\n+static int compare_bp(const void *a, const void *b)\n+{\n+    BracketPair *bpa = (BracketPair *)a;\n+    BracketPair *bpb = (BracketPair *)b;\n+    return bpa->from - bpb->from;\n+}\n+\n+static BracketPair *search_bp(uint32_t code)\n+{\n+    BracketPair bp = {0,0,2};\n+    BracketPair *res;\n+\n+    bp.from = code;\n+    res = (BracketPair *) bsearch(&bp, bracket_pairs, BIDI_BRACKET_LEN,\n+                                 sizeof(BracketPair), compare_bp);\n+    return res;\n+}\n+\n+static int hangul_pair_decompose(uint32_t code, uint32_t *a, uint32_t *b)\n+{\n+    int si = code - SBASE;\n+\n+    if (si < 0 || si >= SCOUNT)\n+        return 0;\n+\n+    if (si % TCOUNT) {\n+        \/* LV,T *\/\n+        *a = SBASE + (si \/ TCOUNT) * TCOUNT;\n+        *b = TBASE + (si % TCOUNT);\n+        return 3;\n+    } else {\n+        \/* L,V *\/\n+        *a = LBASE + (si \/ NCOUNT);\n+        *b = VBASE + (si % NCOUNT) \/ TCOUNT;\n+        return 2;\n+    }\n+}\n+\n+static int hangul_pair_compose(uint32_t *code, uint32_t a, uint32_t b)\n+{\n+    if (a >= SBASE && a < (SBASE + SCOUNT) && b >= TBASE && b < (TBASE + TCOUNT)) {\n+        \/* LV,T *\/\n+        *code = a + (b - TBASE);\n+        return 3;\n+    } else if (a >= LBASE && a < (LBASE + LCOUNT) && b >= VBASE && b < (VBASE + VCOUNT)) {\n+        \/* L,V *\/\n+        int li = a - LBASE;\n+        int vi = b - VBASE;\n+        *code = SBASE + li * NCOUNT + vi * TCOUNT;\n+        return 2;\n+    } else {\n+        return 0;\n+    }\n+}\n+\n+static uint32_t decode_utf16(const unsigned short **code_ptr)\n+{\n+    const unsigned short *code = *code_ptr;\n+\n+    if (code[0] < 0xd800 || code[0] > 0xdc00) {\n+        *code_ptr += 1;\n+        return (uint32_t)code[0];\n+    } else {\n+        *code_ptr += 2;\n+        return 0x10000 + ((uint32_t)code[1] - 0xdc00) +\n+            (((uint32_t)code[0] - 0xd800) << 10);\n+    }\n+}\n+\n+const char *ucdn_get_unicode_version(void)\n+{\n+    return UNIDATA_VERSION;\n+}\n+\n+int ucdn_get_combining_class(uint32_t code)\n+{\n+    return get_ucd_record(code)->combining;\n+}\n+\n+int ucdn_get_east_asian_width(uint32_t code)\n+{\n+    return get_ucd_record(code)->east_asian_width;\n+}\n+\n+int ucdn_get_general_category(uint32_t code)\n+{\n+    return get_ucd_record(code)->category;\n+}\n+\n+int ucdn_get_bidi_class(uint32_t code)\n+{\n+    return get_ucd_record(code)->bidi_class;\n+}\n+\n+int ucdn_get_mirrored(uint32_t code)\n+{\n+    return ucdn_mirror(code) != code;\n+}\n+\n+int ucdn_get_script(uint32_t code)\n+{\n+    return get_ucd_record(code)->script;\n+}\n+\n+int ucdn_get_linebreak_class(uint32_t code)\n+{\n+    return get_ucd_record(code)->linebreak_class;\n+}\n+\n+int ucdn_get_resolved_linebreak_class(uint32_t code)\n+{\n+    const UCDRecord *record = get_ucd_record(code);\n+\n+    switch (record->linebreak_class)\n+    {\n+    case UCDN_LINEBREAK_CLASS_AI:\n+    case UCDN_LINEBREAK_CLASS_SG:\n+    case UCDN_LINEBREAK_CLASS_XX:\n+        return UCDN_LINEBREAK_CLASS_AL;\n+\n+    case UCDN_LINEBREAK_CLASS_SA:\n+        if (record->category == UCDN_GENERAL_CATEGORY_MC ||\n+                record->category == UCDN_GENERAL_CATEGORY_MN)\n+            return UCDN_LINEBREAK_CLASS_CM;\n+        return UCDN_LINEBREAK_CLASS_AL;\n+\n+    case UCDN_LINEBREAK_CLASS_CJ:\n+        return UCDN_LINEBREAK_CLASS_NS;\n+\n+    case UCDN_LINEBREAK_CLASS_CB:\n+        return UCDN_LINEBREAK_CLASS_B2;\n+\n+    case UCDN_LINEBREAK_CLASS_NL:\n+        return UCDN_LINEBREAK_CLASS_BK;\n+\n+    default:\n+        return record->linebreak_class;\n+    }\n+}\n+\n+uint32_t ucdn_mirror(uint32_t code)\n+{\n+    MirrorPair mp = {0};\n+    MirrorPair *res;\n+\n+    mp.from = code;\n+    res = (MirrorPair *) bsearch(&mp, mirror_pairs, BIDI_MIRROR_LEN,\n+                                sizeof(MirrorPair), compare_mp);\n+\n+    if (res == NULL)\n+        return code;\n+    else\n+        return res->to;\n+}\n+\n+uint32_t ucdn_paired_bracket(uint32_t code)\n+{\n+    BracketPair *res = search_bp(code);\n+    if (res == NULL)\n+        return code;\n+    else\n+        return res->to;\n+}\n+\n+int ucdn_paired_bracket_type(uint32_t code)\n+{\n+    BracketPair *res = search_bp(code);\n+    if (res == NULL)\n+        return UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE;\n+    else\n+        return res->type;\n+}\n+\n+int ucdn_decompose(uint32_t code, uint32_t *a, uint32_t *b)\n+{\n+    const unsigned short *rec;\n+    int len;\n+\n+    if (hangul_pair_decompose(code, a, b))\n+        return 1;\n+\n+    rec = get_decomp_record(code);\n+    len = rec[0] >> 8;\n+\n+    if ((rec[0] & 0xff) != 0 || len == 0)\n+        return 0;\n+\n+    rec++;\n+    *a = decode_utf16(&rec);\n+    if (len > 1)\n+        *b = decode_utf16(&rec);\n+    else\n+        *b = 0;\n+\n+    return 1;\n+}\n+\n+int ucdn_compose(uint32_t *code, uint32_t a, uint32_t b)\n+{\n+    int l, r, index, indexi, offset;\n+\n+    if (hangul_pair_compose(code, a, b))\n+        return 1;\n+\n+    l = get_comp_index(a, nfc_first, sizeof(nfc_first) \/ sizeof(Reindex));\n+    r = get_comp_index(b, nfc_last, sizeof(nfc_last) \/ sizeof(Reindex));\n+\n+    if (l < 0 || r < 0)\n+        return 0;\n+\n+    indexi = l * TOTAL_LAST + r;\n+    index  = comp_index0[indexi >> (COMP_SHIFT1+COMP_SHIFT2)] << COMP_SHIFT1;\n+    offset = (indexi >> COMP_SHIFT2) & ((1<<COMP_SHIFT1) - 1);\n+    index  = comp_index1[index + offset] << COMP_SHIFT2;\n+    offset = indexi & ((1<<COMP_SHIFT2) - 1);\n+    *code  = comp_data[index + offset];\n+\n+    return *code != 0;\n+}\n+\n+int ucdn_compat_decompose(uint32_t code, uint32_t *decomposed)\n+{\n+    int i, len;\n+    const unsigned short *rec = get_decomp_record(code);\n+    len = rec[0] >> 8;\n+\n+    if (len == 0)\n+        return 0;\n+\n+    rec++;\n+    for (i = 0; i < len; i++)\n+        decomposed[i] = decode_utf16(&rec);\n+\n+    return len;\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ucdn\/ucdn.c","additions":360,"deletions":0,"binary":false,"changes":360,"status":"added"},{"patch":"@@ -0,0 +1,461 @@\n+\/*\n+ * Copyright (C) 2012 Grigori Goronzy <greg@kinoho.net>\n+ *\n+ * Permission to use, copy, modify, and\/or distribute this software for any\n+ * purpose with or without fee is hereby granted, provided that the above\n+ * copyright notice and this permission notice appear in all copies.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n+ * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n+ * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n+ * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n+ * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n+ * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n+ * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n+ *\/\n+\n+#ifndef UCDN_H\n+#define UCDN_H\n+\n+\n+\n+#if defined(__GNUC__) && (__GNUC__ >= 4) && !defined(__MINGW32__)\n+# define HB_BEGIN_VISIBILITY _Pragma (\"GCC visibility push(hidden)\")\n+# define HB_END_VISIBILITY _Pragma (\"GCC visibility pop\")\n+#else\n+# define HB_BEGIN_VISIBILITY\n+# define HB_END_VISIBILITY\n+#endif\n+#ifdef __cplusplus\n+# define HB_BEGIN_HEADER  extern \"C\" { HB_BEGIN_VISIBILITY\n+# define HB_END_HEADER  HB_END_VISIBILITY }\n+#else\n+# define HB_BEGIN_HEADER  HB_BEGIN_VISIBILITY\n+# define HB_END_HEADER  HB_END_VISIBILITY\n+#endif\n+\n+HB_BEGIN_HEADER\n+\n+#if defined (_SVR4) || defined (SVR4) || defined (__OpenBSD__) || \\\n+    defined (_sgi) || defined (__sun) || defined (sun) || \\\n+    defined (__digital__) || defined (__HP_cc)\n+#  include <inttypes.h>\n+#elif defined (_AIX)\n+#  include <sys\/inttypes.h>\n+#elif defined (_MSC_VER) && _MSC_VER < 1600\n+\/* VS 2010 (_MSC_VER 1600) has stdint.h *\/\n+typedef __int8 int8_t;\n+typedef unsigned __int8 uint8_t;\n+typedef __int16 int16_t;\n+typedef unsigned __int16 uint16_t;\n+typedef __int32 int32_t;\n+typedef unsigned __int32 uint32_t;\n+typedef __int64 int64_t;\n+typedef unsigned __int64 uint64_t;\n+#else\n+#  include <stdint.h>\n+#endif\n+\n+\n+#define UCDN_EAST_ASIAN_F 0\n+#define UCDN_EAST_ASIAN_H 1\n+#define UCDN_EAST_ASIAN_W 2\n+#define UCDN_EAST_ASIAN_NA 3\n+#define UCDN_EAST_ASIAN_A 4\n+#define UCDN_EAST_ASIAN_N 5\n+\n+#define UCDN_SCRIPT_COMMON 0\n+#define UCDN_SCRIPT_LATIN 1\n+#define UCDN_SCRIPT_GREEK 2\n+#define UCDN_SCRIPT_CYRILLIC 3\n+#define UCDN_SCRIPT_ARMENIAN 4\n+#define UCDN_SCRIPT_HEBREW 5\n+#define UCDN_SCRIPT_ARABIC 6\n+#define UCDN_SCRIPT_SYRIAC 7\n+#define UCDN_SCRIPT_THAANA 8\n+#define UCDN_SCRIPT_DEVANAGARI 9\n+#define UCDN_SCRIPT_BENGALI 10\n+#define UCDN_SCRIPT_GURMUKHI 11\n+#define UCDN_SCRIPT_GUJARATI 12\n+#define UCDN_SCRIPT_ORIYA 13\n+#define UCDN_SCRIPT_TAMIL 14\n+#define UCDN_SCRIPT_TELUGU 15\n+#define UCDN_SCRIPT_KANNADA 16\n+#define UCDN_SCRIPT_MALAYALAM 17\n+#define UCDN_SCRIPT_SINHALA 18\n+#define UCDN_SCRIPT_THAI 19\n+#define UCDN_SCRIPT_LAO 20\n+#define UCDN_SCRIPT_TIBETAN 21\n+#define UCDN_SCRIPT_MYANMAR 22\n+#define UCDN_SCRIPT_GEORGIAN 23\n+#define UCDN_SCRIPT_HANGUL 24\n+#define UCDN_SCRIPT_ETHIOPIC 25\n+#define UCDN_SCRIPT_CHEROKEE 26\n+#define UCDN_SCRIPT_CANADIAN_ABORIGINAL 27\n+#define UCDN_SCRIPT_OGHAM 28\n+#define UCDN_SCRIPT_RUNIC 29\n+#define UCDN_SCRIPT_KHMER 30\n+#define UCDN_SCRIPT_MONGOLIAN 31\n+#define UCDN_SCRIPT_HIRAGANA 32\n+#define UCDN_SCRIPT_KATAKANA 33\n+#define UCDN_SCRIPT_BOPOMOFO 34\n+#define UCDN_SCRIPT_HAN 35\n+#define UCDN_SCRIPT_YI 36\n+#define UCDN_SCRIPT_OLD_ITALIC 37\n+#define UCDN_SCRIPT_GOTHIC 38\n+#define UCDN_SCRIPT_DESERET 39\n+#define UCDN_SCRIPT_INHERITED 40\n+#define UCDN_SCRIPT_TAGALOG 41\n+#define UCDN_SCRIPT_HANUNOO 42\n+#define UCDN_SCRIPT_BUHID 43\n+#define UCDN_SCRIPT_TAGBANWA 44\n+#define UCDN_SCRIPT_LIMBU 45\n+#define UCDN_SCRIPT_TAI_LE 46\n+#define UCDN_SCRIPT_LINEAR_B 47\n+#define UCDN_SCRIPT_UGARITIC 48\n+#define UCDN_SCRIPT_SHAVIAN 49\n+#define UCDN_SCRIPT_OSMANYA 50\n+#define UCDN_SCRIPT_CYPRIOT 51\n+#define UCDN_SCRIPT_BRAILLE 52\n+#define UCDN_SCRIPT_BUGINESE 53\n+#define UCDN_SCRIPT_COPTIC 54\n+#define UCDN_SCRIPT_NEW_TAI_LUE 55\n+#define UCDN_SCRIPT_GLAGOLITIC 56\n+#define UCDN_SCRIPT_TIFINAGH 57\n+#define UCDN_SCRIPT_SYLOTI_NAGRI 58\n+#define UCDN_SCRIPT_OLD_PERSIAN 59\n+#define UCDN_SCRIPT_KHAROSHTHI 60\n+#define UCDN_SCRIPT_BALINESE 61\n+#define UCDN_SCRIPT_CUNEIFORM 62\n+#define UCDN_SCRIPT_PHOENICIAN 63\n+#define UCDN_SCRIPT_PHAGS_PA 64\n+#define UCDN_SCRIPT_NKO 65\n+#define UCDN_SCRIPT_SUNDANESE 66\n+#define UCDN_SCRIPT_LEPCHA 67\n+#define UCDN_SCRIPT_OL_CHIKI 68\n+#define UCDN_SCRIPT_VAI 69\n+#define UCDN_SCRIPT_SAURASHTRA 70\n+#define UCDN_SCRIPT_KAYAH_LI 71\n+#define UCDN_SCRIPT_REJANG 72\n+#define UCDN_SCRIPT_LYCIAN 73\n+#define UCDN_SCRIPT_CARIAN 74\n+#define UCDN_SCRIPT_LYDIAN 75\n+#define UCDN_SCRIPT_CHAM 76\n+#define UCDN_SCRIPT_TAI_THAM 77\n+#define UCDN_SCRIPT_TAI_VIET 78\n+#define UCDN_SCRIPT_AVESTAN 79\n+#define UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS 80\n+#define UCDN_SCRIPT_SAMARITAN 81\n+#define UCDN_SCRIPT_LISU 82\n+#define UCDN_SCRIPT_BAMUM 83\n+#define UCDN_SCRIPT_JAVANESE 84\n+#define UCDN_SCRIPT_MEETEI_MAYEK 85\n+#define UCDN_SCRIPT_IMPERIAL_ARAMAIC 86\n+#define UCDN_SCRIPT_OLD_SOUTH_ARABIAN 87\n+#define UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN 88\n+#define UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI 89\n+#define UCDN_SCRIPT_OLD_TURKIC 90\n+#define UCDN_SCRIPT_KAITHI 91\n+#define UCDN_SCRIPT_BATAK 92\n+#define UCDN_SCRIPT_BRAHMI 93\n+#define UCDN_SCRIPT_MANDAIC 94\n+#define UCDN_SCRIPT_CHAKMA 95\n+#define UCDN_SCRIPT_MEROITIC_CURSIVE 96\n+#define UCDN_SCRIPT_MEROITIC_HIEROGLYPHS 97\n+#define UCDN_SCRIPT_MIAO 98\n+#define UCDN_SCRIPT_SHARADA 99\n+#define UCDN_SCRIPT_SORA_SOMPENG 100\n+#define UCDN_SCRIPT_TAKRI 101\n+#define UCDN_SCRIPT_UNKNOWN 102\n+#define UCDN_SCRIPT_BASSA_VAH 103\n+#define UCDN_SCRIPT_CAUCASIAN_ALBANIAN 104\n+#define UCDN_SCRIPT_DUPLOYAN 105\n+#define UCDN_SCRIPT_ELBASAN 106\n+#define UCDN_SCRIPT_GRANTHA 107\n+#define UCDN_SCRIPT_KHOJKI 108\n+#define UCDN_SCRIPT_KHUDAWADI 109\n+#define UCDN_SCRIPT_LINEAR_A 110\n+#define UCDN_SCRIPT_MAHAJANI 111\n+#define UCDN_SCRIPT_MANICHAEAN 112\n+#define UCDN_SCRIPT_MENDE_KIKAKUI 113\n+#define UCDN_SCRIPT_MODI 114\n+#define UCDN_SCRIPT_MRO 115\n+#define UCDN_SCRIPT_NABATAEAN 116\n+#define UCDN_SCRIPT_OLD_NORTH_ARABIAN 117\n+#define UCDN_SCRIPT_OLD_PERMIC 118\n+#define UCDN_SCRIPT_PAHAWH_HMONG 119\n+#define UCDN_SCRIPT_PALMYRENE 120\n+#define UCDN_SCRIPT_PAU_CIN_HAU 121\n+#define UCDN_SCRIPT_PSALTER_PAHLAVI 122\n+#define UCDN_SCRIPT_SIDDHAM 123\n+#define UCDN_SCRIPT_TIRHUTA 124\n+#define UCDN_SCRIPT_WARANG_CITI 125\n+#define UCDN_SCRIPT_AHOM 126\n+#define UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS 127\n+#define UCDN_SCRIPT_HATRAN 128\n+#define UCDN_SCRIPT_MULTANI 129\n+#define UCDN_SCRIPT_OLD_HUNGARIAN 130\n+#define UCDN_SCRIPT_SIGNWRITING 131\n+#define UCDN_SCRIPT_ADLAM 132\n+#define UCDN_SCRIPT_BHAIKSUKI 133\n+#define UCDN_SCRIPT_MARCHEN 134\n+#define UCDN_SCRIPT_NEWA 135\n+#define UCDN_SCRIPT_OSAGE 136\n+#define UCDN_SCRIPT_TANGUT 137\n+#define UCDN_SCRIPT_MASARAM_GONDI 138\n+#define UCDN_SCRIPT_NUSHU 139\n+#define UCDN_SCRIPT_SOYOMBO 140\n+#define UCDN_SCRIPT_ZANABAZAR_SQUARE 141\n+\n+#define UCDN_LINEBREAK_CLASS_OP 0\n+#define UCDN_LINEBREAK_CLASS_CL 1\n+#define UCDN_LINEBREAK_CLASS_CP 2\n+#define UCDN_LINEBREAK_CLASS_QU 3\n+#define UCDN_LINEBREAK_CLASS_GL 4\n+#define UCDN_LINEBREAK_CLASS_NS 5\n+#define UCDN_LINEBREAK_CLASS_EX 6\n+#define UCDN_LINEBREAK_CLASS_SY 7\n+#define UCDN_LINEBREAK_CLASS_IS 8\n+#define UCDN_LINEBREAK_CLASS_PR 9\n+#define UCDN_LINEBREAK_CLASS_PO 10\n+#define UCDN_LINEBREAK_CLASS_NU 11\n+#define UCDN_LINEBREAK_CLASS_AL 12\n+#define UCDN_LINEBREAK_CLASS_HL 13\n+#define UCDN_LINEBREAK_CLASS_ID 14\n+#define UCDN_LINEBREAK_CLASS_IN 15\n+#define UCDN_LINEBREAK_CLASS_HY 16\n+#define UCDN_LINEBREAK_CLASS_BA 17\n+#define UCDN_LINEBREAK_CLASS_BB 18\n+#define UCDN_LINEBREAK_CLASS_B2 19\n+#define UCDN_LINEBREAK_CLASS_ZW 20\n+#define UCDN_LINEBREAK_CLASS_CM 21\n+#define UCDN_LINEBREAK_CLASS_WJ 22\n+#define UCDN_LINEBREAK_CLASS_H2 23\n+#define UCDN_LINEBREAK_CLASS_H3 24\n+#define UCDN_LINEBREAK_CLASS_JL 25\n+#define UCDN_LINEBREAK_CLASS_JV 26\n+#define UCDN_LINEBREAK_CLASS_JT 27\n+#define UCDN_LINEBREAK_CLASS_RI 28\n+#define UCDN_LINEBREAK_CLASS_AI 29\n+#define UCDN_LINEBREAK_CLASS_BK 30\n+#define UCDN_LINEBREAK_CLASS_CB 31\n+#define UCDN_LINEBREAK_CLASS_CJ 32\n+#define UCDN_LINEBREAK_CLASS_CR 33\n+#define UCDN_LINEBREAK_CLASS_LF 34\n+#define UCDN_LINEBREAK_CLASS_NL 35\n+#define UCDN_LINEBREAK_CLASS_SA 36\n+#define UCDN_LINEBREAK_CLASS_SG 37\n+#define UCDN_LINEBREAK_CLASS_SP 38\n+#define UCDN_LINEBREAK_CLASS_XX 39\n+#define UCDN_LINEBREAK_CLASS_ZWJ 40\n+#define UCDN_LINEBREAK_CLASS_EB 41\n+#define UCDN_LINEBREAK_CLASS_EM 42\n+\n+#define UCDN_GENERAL_CATEGORY_CC 0\n+#define UCDN_GENERAL_CATEGORY_CF 1\n+#define UCDN_GENERAL_CATEGORY_CN 2\n+#define UCDN_GENERAL_CATEGORY_CO 3\n+#define UCDN_GENERAL_CATEGORY_CS 4\n+#define UCDN_GENERAL_CATEGORY_LL 5\n+#define UCDN_GENERAL_CATEGORY_LM 6\n+#define UCDN_GENERAL_CATEGORY_LO 7\n+#define UCDN_GENERAL_CATEGORY_LT 8\n+#define UCDN_GENERAL_CATEGORY_LU 9\n+#define UCDN_GENERAL_CATEGORY_MC 10\n+#define UCDN_GENERAL_CATEGORY_ME 11\n+#define UCDN_GENERAL_CATEGORY_MN 12\n+#define UCDN_GENERAL_CATEGORY_ND 13\n+#define UCDN_GENERAL_CATEGORY_NL 14\n+#define UCDN_GENERAL_CATEGORY_NO 15\n+#define UCDN_GENERAL_CATEGORY_PC 16\n+#define UCDN_GENERAL_CATEGORY_PD 17\n+#define UCDN_GENERAL_CATEGORY_PE 18\n+#define UCDN_GENERAL_CATEGORY_PF 19\n+#define UCDN_GENERAL_CATEGORY_PI 20\n+#define UCDN_GENERAL_CATEGORY_PO 21\n+#define UCDN_GENERAL_CATEGORY_PS 22\n+#define UCDN_GENERAL_CATEGORY_SC 23\n+#define UCDN_GENERAL_CATEGORY_SK 24\n+#define UCDN_GENERAL_CATEGORY_SM 25\n+#define UCDN_GENERAL_CATEGORY_SO 26\n+#define UCDN_GENERAL_CATEGORY_ZL 27\n+#define UCDN_GENERAL_CATEGORY_ZP 28\n+#define UCDN_GENERAL_CATEGORY_ZS 29\n+\n+#define UCDN_BIDI_CLASS_L 0\n+#define UCDN_BIDI_CLASS_LRE 1\n+#define UCDN_BIDI_CLASS_LRO 2\n+#define UCDN_BIDI_CLASS_R 3\n+#define UCDN_BIDI_CLASS_AL 4\n+#define UCDN_BIDI_CLASS_RLE 5\n+#define UCDN_BIDI_CLASS_RLO 6\n+#define UCDN_BIDI_CLASS_PDF 7\n+#define UCDN_BIDI_CLASS_EN 8\n+#define UCDN_BIDI_CLASS_ES 9\n+#define UCDN_BIDI_CLASS_ET 10\n+#define UCDN_BIDI_CLASS_AN 11\n+#define UCDN_BIDI_CLASS_CS 12\n+#define UCDN_BIDI_CLASS_NSM 13\n+#define UCDN_BIDI_CLASS_BN 14\n+#define UCDN_BIDI_CLASS_B 15\n+#define UCDN_BIDI_CLASS_S 16\n+#define UCDN_BIDI_CLASS_WS 17\n+#define UCDN_BIDI_CLASS_ON 18\n+#define UCDN_BIDI_CLASS_LRI 19\n+#define UCDN_BIDI_CLASS_RLI 20\n+#define UCDN_BIDI_CLASS_FSI 21\n+#define UCDN_BIDI_CLASS_PDI 22\n+\n+#define UCDN_BIDI_PAIRED_BRACKET_TYPE_OPEN 0\n+#define UCDN_BIDI_PAIRED_BRACKET_TYPE_CLOSE 1\n+#define UCDN_BIDI_PAIRED_BRACKET_TYPE_NONE 2\n+\n+\/**\n+ * Return version of the Unicode database.\n+ *\n+ * @return Unicode database version\n+ *\/\n+const char *ucdn_get_unicode_version(void);\n+\n+\/**\n+ * Get combining class of a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return combining class value, as defined in UAX#44\n+ *\/\n+int ucdn_get_combining_class(uint32_t code);\n+\n+\/**\n+ * Get east-asian width of a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return value according to UCDN_EAST_ASIAN_* and as defined in UAX#11.\n+ *\/\n+int ucdn_get_east_asian_width(uint32_t code);\n+\n+\/**\n+ * Get general category of a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return value according to UCDN_GENERAL_CATEGORY_* and as defined in\n+ * UAX#44.\n+ *\/\n+int ucdn_get_general_category(uint32_t code);\n+\n+\/**\n+ * Get bidirectional class of a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return value according to UCDN_BIDI_CLASS_* and as defined in UAX#44.\n+ *\/\n+int ucdn_get_bidi_class(uint32_t code);\n+\n+\/**\n+ * Get script of a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return value according to UCDN_SCRIPT_* and as defined in UAX#24.\n+ *\/\n+int ucdn_get_script(uint32_t code);\n+\n+\/**\n+ * Get unresolved linebreak class of a codepoint. This does not take\n+ * rule LB1 of UAX#14 into account. See ucdn_get_resolved_linebreak_class()\n+ * for resolved linebreak classes.\n+ *\n+ * @param code Unicode codepoint\n+ * @return value according to UCDN_LINEBREAK_* and as defined in UAX#14.\n+ *\/\n+int ucdn_get_linebreak_class(uint32_t code);\n+\n+\/**\n+ * Get resolved linebreak class of a codepoint. This resolves characters\n+ * in the AI, SG, XX, SA and CJ classes according to rule LB1 of UAX#14.\n+ * In addition the CB class is resolved as the equivalent B2 class and\n+ * the NL class is resolved as the equivalent BK class.\n+ *\n+ * @param code Unicode codepoint\n+ * @return value according to UCDN_LINEBREAK_* and as defined in UAX#14.\n+ *\/\n+int ucdn_get_resolved_linebreak_class(uint32_t code);\n+\n+\/**\n+ * Check if codepoint can be mirrored.\n+ *\n+ * @param code Unicode codepoint\n+ * @return 1 if mirrored character exists, otherwise 0\n+ *\/\n+int ucdn_get_mirrored(uint32_t code);\n+\n+\/**\n+ * Mirror a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return mirrored codepoint or the original codepoint if no\n+ * mirrored character exists\n+ *\/\n+uint32_t ucdn_mirror(uint32_t code);\n+\n+\/**\n+ * Get paired bracket for a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return paired bracket codepoint or the original codepoint if no\n+ * paired bracket character exists\n+ *\/\n+uint32_t ucdn_paired_bracket(uint32_t code);\n+\n+\/**\n+ * Get paired bracket type for a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @return value according to UCDN_BIDI_PAIRED_BRACKET_TYPE_* and as defined\n+ * in UAX#9.\n+ *\n+ *\/\n+int ucdn_paired_bracket_type(uint32_t code);\n+\n+\/**\n+ * Pairwise canonical decomposition of a codepoint. This includes\n+ * Hangul Jamo decomposition (see chapter 3.12 of the Unicode core\n+ * specification).\n+ *\n+ * Hangul is decomposed into L and V jamos for LV forms, and an\n+ * LV precomposed syllable and a T jamo for LVT forms.\n+ *\n+ * @param code Unicode codepoint\n+ * @param a filled with first codepoint of decomposition\n+ * @param b filled with second codepoint of decomposition, or 0\n+ * @return success\n+ *\/\n+int ucdn_decompose(uint32_t code, uint32_t *a, uint32_t *b);\n+\n+\/**\n+ * Compatibility decomposition of a codepoint.\n+ *\n+ * @param code Unicode codepoint\n+ * @param decomposed filled with decomposition, must be able to hold 18\n+ * characters\n+ * @return length of decomposition or 0 in case none exists\n+ *\/\n+int ucdn_compat_decompose(uint32_t code, uint32_t *decomposed);\n+\n+\/**\n+ * Pairwise canonical composition of two codepoints. This includes\n+ * Hangul Jamo composition (see chapter 3.12 of the Unicode core\n+ * specification).\n+ *\n+ * Hangul composition expects either L and V jamos, or an LV\n+ * precomposed syllable and a T jamo. This is exactly the inverse\n+ * of pairwise Hangul decomposition.\n+ *\n+ * @param code filled with composition\n+ * @param a first codepoint\n+ * @param b second codepoint\n+ * @return success\n+ *\/\n+int ucdn_compose(uint32_t *code, uint32_t a, uint32_t b);\n+\n+HB_END_HEADER\n+\n+#endif\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ucdn\/ucdn.h","additions":461,"deletions":0,"binary":false,"changes":461,"status":"added"},{"patch":"@@ -0,0 +1,5730 @@\n+\/* this file was generated by makeunicodedata.py 3.2 *\/\n+\n+#define UNIDATA_VERSION \"11.0.0\"\n+\/* a list of unique database records *\/\n+static const UCDRecord ucd_records[] = {\n+    {2, 0, 18, 5, 102, 39},\n+    {0, 0, 14, 5, 0, 21},\n+    {0, 0, 16, 5, 0, 17},\n+    {0, 0, 15, 5, 0, 34},\n+    {0, 0, 16, 5, 0, 30},\n+    {0, 0, 17, 5, 0, 30},\n+    {0, 0, 15, 5, 0, 33},\n+    {0, 0, 15, 5, 0, 21},\n+    {0, 0, 16, 5, 0, 21},\n+    {29, 0, 17, 3, 0, 38},\n+    {21, 0, 18, 3, 0, 6},\n+    {21, 0, 18, 3, 0, 3},\n+    {21, 0, 10, 3, 0, 12},\n+    {23, 0, 10, 3, 0, 9},\n+    {21, 0, 10, 3, 0, 10},\n+    {21, 0, 18, 3, 0, 12},\n+    {22, 0, 18, 3, 0, 0},\n+    {18, 0, 18, 3, 0, 2},\n+    {25, 0, 9, 3, 0, 9},\n+    {21, 0, 12, 3, 0, 8},\n+    {17, 0, 9, 3, 0, 16},\n+    {21, 0, 12, 3, 0, 7},\n+    {13, 0, 8, 3, 0, 11},\n+    {21, 0, 18, 3, 0, 8},\n+    {25, 0, 18, 3, 0, 12},\n+    {9, 0, 0, 3, 1, 12},\n+    {21, 0, 18, 3, 0, 9},\n+    {24, 0, 18, 3, 0, 12},\n+    {16, 0, 18, 3, 0, 12},\n+    {5, 0, 0, 3, 1, 12},\n+    {25, 0, 18, 3, 0, 17},\n+    {18, 0, 18, 3, 0, 1},\n+    {0, 0, 15, 5, 0, 35},\n+    {29, 0, 12, 5, 0, 4},\n+    {21, 0, 18, 4, 0, 0},\n+    {23, 0, 10, 3, 0, 10},\n+    {23, 0, 10, 4, 0, 9},\n+    {26, 0, 18, 3, 0, 12},\n+    {21, 0, 18, 4, 0, 29},\n+    {24, 0, 18, 4, 0, 29},\n+    {26, 0, 18, 5, 0, 12},\n+    {7, 0, 0, 4, 1, 29},\n+    {20, 0, 18, 5, 0, 3},\n+    {1, 0, 14, 4, 0, 17},\n+    {26, 0, 18, 4, 0, 12},\n+    {26, 0, 10, 4, 0, 10},\n+    {25, 0, 10, 4, 0, 9},\n+    {15, 0, 8, 4, 0, 29},\n+    {24, 0, 18, 4, 0, 18},\n+    {5, 0, 0, 5, 0, 12},\n+    {19, 0, 18, 5, 0, 3},\n+    {15, 0, 18, 4, 0, 29},\n+    {9, 0, 0, 5, 1, 12},\n+    {9, 0, 0, 4, 1, 12},\n+    {25, 0, 18, 4, 0, 29},\n+    {5, 0, 0, 4, 1, 12},\n+    {5, 0, 0, 5, 1, 12},\n+    {7, 0, 0, 5, 1, 12},\n+    {8, 0, 0, 5, 1, 12},\n+    {6, 0, 0, 5, 1, 12},\n+    {6, 0, 18, 5, 0, 12},\n+    {6, 0, 0, 5, 0, 12},\n+    {24, 0, 18, 5, 0, 12},\n+    {24, 0, 18, 4, 0, 12},\n+    {6, 0, 18, 4, 0, 29},\n+    {6, 0, 18, 5, 0, 18},\n+    {6, 0, 0, 4, 0, 29},\n+    {24, 0, 18, 5, 34, 12},\n+    {12, 230, 13, 4, 40, 21},\n+    {12, 232, 13, 4, 40, 21},\n+    {12, 220, 13, 4, 40, 21},\n+    {12, 216, 13, 4, 40, 21},\n+    {12, 202, 13, 4, 40, 21},\n+    {12, 1, 13, 4, 40, 21},\n+    {12, 240, 13, 4, 40, 21},\n+    {12, 0, 13, 4, 40, 4},\n+    {12, 233, 13, 4, 40, 4},\n+    {12, 234, 13, 4, 40, 4},\n+    {9, 0, 0, 5, 2, 12},\n+    {5, 0, 0, 5, 2, 12},\n+    {24, 0, 18, 5, 2, 12},\n+    {2, 0, 18, 5, 102, 39},\n+    {6, 0, 0, 5, 2, 12},\n+    {21, 0, 18, 5, 0, 8},\n+    {21, 0, 18, 5, 0, 12},\n+    {9, 0, 0, 4, 2, 12},\n+    {5, 0, 0, 4, 2, 12},\n+    {9, 0, 0, 5, 54, 12},\n+    {5, 0, 0, 5, 54, 12},\n+    {25, 0, 18, 5, 2, 12},\n+    {9, 0, 0, 5, 3, 12},\n+    {9, 0, 0, 4, 3, 12},\n+    {5, 0, 0, 4, 3, 12},\n+    {5, 0, 0, 5, 3, 12},\n+    {26, 0, 0, 5, 3, 12},\n+    {12, 230, 13, 5, 3, 21},\n+    {12, 230, 13, 5, 40, 21},\n+    {11, 0, 13, 5, 3, 21},\n+    {9, 0, 0, 5, 4, 12},\n+    {6, 0, 0, 5, 4, 12},\n+    {21, 0, 0, 5, 4, 12},\n+    {5, 0, 0, 5, 4, 12},\n+    {21, 0, 0, 5, 0, 8},\n+    {17, 0, 18, 5, 4, 17},\n+    {26, 0, 18, 5, 4, 12},\n+    {23, 0, 10, 5, 4, 9},\n+    {12, 220, 13, 5, 5, 21},\n+    {12, 230, 13, 5, 5, 21},\n+    {12, 222, 13, 5, 5, 21},\n+    {12, 228, 13, 5, 5, 21},\n+    {12, 10, 13, 5, 5, 21},\n+    {12, 11, 13, 5, 5, 21},\n+    {12, 12, 13, 5, 5, 21},\n+    {12, 13, 13, 5, 5, 21},\n+    {12, 14, 13, 5, 5, 21},\n+    {12, 15, 13, 5, 5, 21},\n+    {12, 16, 13, 5, 5, 21},\n+    {12, 17, 13, 5, 5, 21},\n+    {12, 18, 13, 5, 5, 21},\n+    {12, 19, 13, 5, 5, 21},\n+    {12, 20, 13, 5, 5, 21},\n+    {12, 21, 13, 5, 5, 21},\n+    {12, 22, 13, 5, 5, 21},\n+    {17, 0, 3, 5, 5, 17},\n+    {12, 23, 13, 5, 5, 21},\n+    {21, 0, 3, 5, 5, 12},\n+    {12, 24, 13, 5, 5, 21},\n+    {12, 25, 13, 5, 5, 21},\n+    {21, 0, 3, 5, 5, 6},\n+    {7, 0, 3, 5, 5, 13},\n+    {1, 0, 11, 5, 6, 12},\n+    {1, 0, 11, 5, 0, 12},\n+    {25, 0, 18, 5, 6, 12},\n+    {25, 0, 4, 5, 6, 12},\n+    {21, 0, 10, 5, 6, 10},\n+    {23, 0, 4, 5, 6, 10},\n+    {21, 0, 12, 5, 0, 8},\n+    {21, 0, 4, 5, 6, 8},\n+    {26, 0, 18, 5, 6, 12},\n+    {12, 230, 13, 5, 6, 21},\n+    {12, 30, 13, 5, 6, 21},\n+    {12, 31, 13, 5, 6, 21},\n+    {12, 32, 13, 5, 6, 21},\n+    {21, 0, 4, 5, 0, 6},\n+    {1, 0, 4, 5, 6, 21},\n+    {21, 0, 4, 5, 6, 6},\n+    {7, 0, 4, 5, 6, 12},\n+    {6, 0, 4, 5, 0, 12},\n+    {12, 27, 13, 5, 40, 21},\n+    {12, 28, 13, 5, 40, 21},\n+    {12, 29, 13, 5, 40, 21},\n+    {12, 30, 13, 5, 40, 21},\n+    {12, 31, 13, 5, 40, 21},\n+    {12, 32, 13, 5, 40, 21},\n+    {12, 33, 13, 5, 40, 21},\n+    {12, 34, 13, 5, 40, 21},\n+    {12, 220, 13, 5, 40, 21},\n+    {12, 220, 13, 5, 6, 21},\n+    {13, 0, 11, 5, 6, 11},\n+    {21, 0, 11, 5, 6, 11},\n+    {21, 0, 4, 5, 6, 12},\n+    {12, 35, 13, 5, 40, 21},\n+    {6, 0, 4, 5, 6, 12},\n+    {13, 0, 8, 5, 6, 11},\n+    {26, 0, 4, 5, 6, 12},\n+    {21, 0, 4, 5, 7, 12},\n+    {1, 0, 4, 5, 7, 12},\n+    {7, 0, 4, 5, 7, 12},\n+    {12, 36, 13, 5, 7, 21},\n+    {12, 230, 13, 5, 7, 21},\n+    {12, 220, 13, 5, 7, 21},\n+    {7, 0, 4, 5, 8, 12},\n+    {12, 0, 13, 5, 8, 21},\n+    {13, 0, 3, 5, 65, 11},\n+    {7, 0, 3, 5, 65, 12},\n+    {12, 230, 13, 5, 65, 21},\n+    {12, 220, 13, 5, 65, 21},\n+    {6, 0, 3, 5, 65, 12},\n+    {26, 0, 18, 5, 65, 12},\n+    {21, 0, 18, 5, 65, 12},\n+    {21, 0, 18, 5, 65, 8},\n+    {21, 0, 18, 5, 65, 6},\n+    {23, 0, 3, 5, 65, 9},\n+    {7, 0, 3, 5, 81, 12},\n+    {12, 230, 13, 5, 81, 21},\n+    {6, 0, 3, 5, 81, 12},\n+    {21, 0, 3, 5, 81, 12},\n+    {7, 0, 3, 5, 94, 12},\n+    {12, 220, 13, 5, 94, 21},\n+    {21, 0, 3, 5, 94, 12},\n+    {12, 27, 13, 5, 6, 21},\n+    {12, 28, 13, 5, 6, 21},\n+    {12, 29, 13, 5, 6, 21},\n+    {12, 0, 13, 5, 9, 21},\n+    {10, 0, 0, 5, 9, 21},\n+    {7, 0, 0, 5, 9, 12},\n+    {12, 7, 13, 5, 9, 21},\n+    {12, 9, 13, 5, 9, 21},\n+    {12, 230, 13, 5, 9, 21},\n+    {21, 0, 0, 5, 0, 17},\n+    {13, 0, 0, 5, 9, 11},\n+    {21, 0, 0, 5, 9, 12},\n+    {6, 0, 0, 5, 9, 12},\n+    {7, 0, 0, 5, 10, 12},\n+    {12, 0, 13, 5, 10, 21},\n+    {10, 0, 0, 5, 10, 21},\n+    {12, 7, 13, 5, 10, 21},\n+    {12, 9, 13, 5, 10, 21},\n+    {13, 0, 0, 5, 10, 11},\n+    {23, 0, 10, 5, 10, 10},\n+    {15, 0, 0, 5, 10, 12},\n+    {15, 0, 0, 5, 10, 10},\n+    {26, 0, 0, 5, 10, 12},\n+    {23, 0, 10, 5, 10, 9},\n+    {21, 0, 0, 5, 10, 12},\n+    {12, 230, 13, 5, 10, 21},\n+    {12, 0, 13, 5, 11, 21},\n+    {10, 0, 0, 5, 11, 21},\n+    {7, 0, 0, 5, 11, 12},\n+    {12, 7, 13, 5, 11, 21},\n+    {12, 9, 13, 5, 11, 21},\n+    {13, 0, 0, 5, 11, 11},\n+    {21, 0, 0, 5, 11, 12},\n+    {12, 0, 13, 5, 12, 21},\n+    {10, 0, 0, 5, 12, 21},\n+    {7, 0, 0, 5, 12, 12},\n+    {12, 7, 13, 5, 12, 21},\n+    {12, 9, 13, 5, 12, 21},\n+    {13, 0, 0, 5, 12, 11},\n+    {21, 0, 0, 5, 12, 12},\n+    {23, 0, 10, 5, 12, 9},\n+    {12, 0, 13, 5, 13, 21},\n+    {10, 0, 0, 5, 13, 21},\n+    {7, 0, 0, 5, 13, 12},\n+    {12, 7, 13, 5, 13, 21},\n+    {12, 9, 13, 5, 13, 21},\n+    {13, 0, 0, 5, 13, 11},\n+    {26, 0, 0, 5, 13, 12},\n+    {15, 0, 0, 5, 13, 12},\n+    {12, 0, 13, 5, 14, 21},\n+    {7, 0, 0, 5, 14, 12},\n+    {10, 0, 0, 5, 14, 21},\n+    {12, 9, 13, 5, 14, 21},\n+    {13, 0, 0, 5, 14, 11},\n+    {15, 0, 0, 5, 14, 12},\n+    {26, 0, 18, 5, 14, 12},\n+    {23, 0, 10, 5, 14, 9},\n+    {12, 0, 13, 5, 15, 21},\n+    {10, 0, 0, 5, 15, 21},\n+    {7, 0, 0, 5, 15, 12},\n+    {12, 9, 13, 5, 15, 21},\n+    {12, 84, 13, 5, 15, 21},\n+    {12, 91, 13, 5, 15, 21},\n+    {13, 0, 0, 5, 15, 11},\n+    {15, 0, 18, 5, 15, 12},\n+    {26, 0, 0, 5, 15, 12},\n+    {7, 0, 0, 5, 16, 12},\n+    {12, 0, 13, 5, 16, 21},\n+    {10, 0, 0, 5, 16, 21},\n+    {21, 0, 0, 5, 16, 18},\n+    {12, 7, 13, 5, 16, 21},\n+    {12, 0, 0, 5, 16, 21},\n+    {12, 9, 13, 5, 16, 21},\n+    {13, 0, 0, 5, 16, 11},\n+    {12, 0, 13, 5, 17, 21},\n+    {10, 0, 0, 5, 17, 21},\n+    {7, 0, 0, 5, 17, 12},\n+    {12, 9, 13, 5, 17, 21},\n+    {26, 0, 0, 5, 17, 12},\n+    {15, 0, 0, 5, 17, 12},\n+    {13, 0, 0, 5, 17, 11},\n+    {26, 0, 0, 5, 17, 10},\n+    {10, 0, 0, 5, 18, 21},\n+    {7, 0, 0, 5, 18, 12},\n+    {12, 9, 13, 5, 18, 21},\n+    {12, 0, 13, 5, 18, 21},\n+    {13, 0, 0, 5, 18, 11},\n+    {21, 0, 0, 5, 18, 12},\n+    {7, 0, 0, 5, 19, 36},\n+    {12, 0, 13, 5, 19, 36},\n+    {12, 103, 13, 5, 19, 36},\n+    {12, 9, 13, 5, 19, 36},\n+    {23, 0, 10, 5, 0, 9},\n+    {6, 0, 0, 5, 19, 36},\n+    {12, 107, 13, 5, 19, 36},\n+    {21, 0, 0, 5, 19, 12},\n+    {13, 0, 0, 5, 19, 11},\n+    {21, 0, 0, 5, 19, 17},\n+    {7, 0, 0, 5, 20, 36},\n+    {12, 0, 13, 5, 20, 36},\n+    {12, 118, 13, 5, 20, 36},\n+    {6, 0, 0, 5, 20, 36},\n+    {12, 122, 13, 5, 20, 36},\n+    {13, 0, 0, 5, 20, 11},\n+    {7, 0, 0, 5, 21, 12},\n+    {26, 0, 0, 5, 21, 18},\n+    {21, 0, 0, 5, 21, 18},\n+    {21, 0, 0, 5, 21, 12},\n+    {21, 0, 0, 5, 21, 4},\n+    {21, 0, 0, 5, 21, 17},\n+    {21, 0, 0, 5, 21, 6},\n+    {26, 0, 0, 5, 21, 12},\n+    {12, 220, 13, 5, 21, 21},\n+    {13, 0, 0, 5, 21, 11},\n+    {15, 0, 0, 5, 21, 12},\n+    {26, 0, 0, 5, 21, 17},\n+    {12, 216, 13, 5, 21, 21},\n+    {22, 0, 18, 5, 21, 0},\n+    {18, 0, 18, 5, 21, 1},\n+    {10, 0, 0, 5, 21, 21},\n+    {12, 129, 13, 5, 21, 21},\n+    {12, 130, 13, 5, 21, 21},\n+    {12, 0, 13, 5, 21, 21},\n+    {12, 132, 13, 5, 21, 21},\n+    {10, 0, 0, 5, 21, 17},\n+    {12, 230, 13, 5, 21, 21},\n+    {12, 9, 13, 5, 21, 21},\n+    {26, 0, 0, 5, 0, 12},\n+    {7, 0, 0, 5, 22, 36},\n+    {10, 0, 0, 5, 22, 36},\n+    {12, 0, 13, 5, 22, 36},\n+    {12, 7, 13, 5, 22, 36},\n+    {12, 9, 13, 5, 22, 36},\n+    {13, 0, 0, 5, 22, 11},\n+    {21, 0, 0, 5, 22, 17},\n+    {21, 0, 0, 5, 22, 12},\n+    {12, 220, 13, 5, 22, 36},\n+    {26, 0, 0, 5, 22, 36},\n+    {9, 0, 0, 5, 23, 12},\n+    {5, 0, 0, 5, 23, 12},\n+    {21, 0, 0, 5, 0, 12},\n+    {6, 0, 0, 5, 23, 12},\n+    {7, 0, 0, 2, 24, 25},\n+    {7, 0, 0, 5, 24, 26},\n+    {7, 0, 0, 5, 24, 27},\n+    {7, 0, 0, 5, 25, 12},\n+    {12, 230, 13, 5, 25, 21},\n+    {21, 0, 0, 5, 25, 12},\n+    {21, 0, 0, 5, 25, 17},\n+    {15, 0, 0, 5, 25, 12},\n+    {26, 0, 18, 5, 25, 12},\n+    {9, 0, 0, 5, 26, 12},\n+    {5, 0, 0, 5, 26, 12},\n+    {17, 0, 18, 5, 27, 17},\n+    {7, 0, 0, 5, 27, 12},\n+    {21, 0, 0, 5, 27, 12},\n+    {29, 0, 17, 5, 28, 17},\n+    {7, 0, 0, 5, 28, 12},\n+    {22, 0, 18, 5, 28, 0},\n+    {18, 0, 18, 5, 28, 1},\n+    {7, 0, 0, 5, 29, 12},\n+    {14, 0, 0, 5, 29, 12},\n+    {7, 0, 0, 5, 41, 12},\n+    {12, 0, 13, 5, 41, 21},\n+    {12, 9, 13, 5, 41, 21},\n+    {7, 0, 0, 5, 42, 12},\n+    {12, 0, 13, 5, 42, 21},\n+    {12, 9, 13, 5, 42, 21},\n+    {7, 0, 0, 5, 43, 12},\n+    {12, 0, 13, 5, 43, 21},\n+    {7, 0, 0, 5, 44, 12},\n+    {12, 0, 13, 5, 44, 21},\n+    {7, 0, 0, 5, 30, 36},\n+    {12, 0, 13, 5, 30, 36},\n+    {10, 0, 0, 5, 30, 36},\n+    {12, 9, 13, 5, 30, 36},\n+    {21, 0, 0, 5, 30, 17},\n+    {21, 0, 0, 5, 30, 5},\n+    {6, 0, 0, 5, 30, 36},\n+    {21, 0, 0, 5, 30, 12},\n+    {23, 0, 10, 5, 30, 9},\n+    {12, 230, 13, 5, 30, 36},\n+    {13, 0, 0, 5, 30, 11},\n+    {15, 0, 18, 5, 30, 12},\n+    {21, 0, 18, 5, 31, 12},\n+    {21, 0, 18, 5, 0, 6},\n+    {21, 0, 18, 5, 31, 17},\n+    {21, 0, 18, 5, 0, 17},\n+    {17, 0, 18, 5, 31, 18},\n+    {21, 0, 18, 5, 31, 6},\n+    {12, 0, 13, 5, 31, 21},\n+    {1, 0, 14, 5, 31, 4},\n+    {13, 0, 0, 5, 31, 11},\n+    {7, 0, 0, 5, 31, 12},\n+    {6, 0, 0, 5, 31, 12},\n+    {12, 228, 13, 5, 31, 21},\n+    {7, 0, 0, 5, 45, 12},\n+    {12, 0, 13, 5, 45, 21},\n+    {10, 0, 0, 5, 45, 21},\n+    {12, 222, 13, 5, 45, 21},\n+    {12, 230, 13, 5, 45, 21},\n+    {12, 220, 13, 5, 45, 21},\n+    {26, 0, 18, 5, 45, 12},\n+    {21, 0, 18, 5, 45, 6},\n+    {13, 0, 0, 5, 45, 11},\n+    {7, 0, 0, 5, 46, 36},\n+    {7, 0, 0, 5, 55, 36},\n+    {13, 0, 0, 5, 55, 11},\n+    {15, 0, 0, 5, 55, 36},\n+    {26, 0, 18, 5, 55, 36},\n+    {26, 0, 18, 5, 30, 12},\n+    {7, 0, 0, 5, 53, 12},\n+    {12, 230, 13, 5, 53, 21},\n+    {12, 220, 13, 5, 53, 21},\n+    {10, 0, 0, 5, 53, 21},\n+    {12, 0, 13, 5, 53, 21},\n+    {21, 0, 0, 5, 53, 12},\n+    {7, 0, 0, 5, 77, 36},\n+    {10, 0, 0, 5, 77, 36},\n+    {12, 0, 13, 5, 77, 36},\n+    {12, 9, 13, 5, 77, 36},\n+    {12, 230, 13, 5, 77, 36},\n+    {12, 220, 13, 5, 77, 21},\n+    {13, 0, 0, 5, 77, 11},\n+    {21, 0, 0, 5, 77, 36},\n+    {6, 0, 0, 5, 77, 36},\n+    {11, 0, 13, 5, 40, 21},\n+    {12, 0, 13, 5, 61, 21},\n+    {10, 0, 0, 5, 61, 21},\n+    {7, 0, 0, 5, 61, 12},\n+    {12, 7, 13, 5, 61, 21},\n+    {10, 9, 0, 5, 61, 21},\n+    {13, 0, 0, 5, 61, 11},\n+    {21, 0, 0, 5, 61, 17},\n+    {21, 0, 0, 5, 61, 12},\n+    {26, 0, 0, 5, 61, 12},\n+    {12, 230, 13, 5, 61, 21},\n+    {12, 220, 13, 5, 61, 21},\n+    {12, 0, 13, 5, 66, 21},\n+    {10, 0, 0, 5, 66, 21},\n+    {7, 0, 0, 5, 66, 12},\n+    {10, 9, 0, 5, 66, 21},\n+    {12, 9, 13, 5, 66, 21},\n+    {13, 0, 0, 5, 66, 11},\n+    {7, 0, 0, 5, 92, 12},\n+    {12, 7, 13, 5, 92, 21},\n+    {10, 0, 0, 5, 92, 21},\n+    {12, 0, 13, 5, 92, 21},\n+    {10, 9, 0, 5, 92, 21},\n+    {21, 0, 0, 5, 92, 12},\n+    {7, 0, 0, 5, 67, 12},\n+    {10, 0, 0, 5, 67, 21},\n+    {12, 0, 13, 5, 67, 21},\n+    {12, 7, 13, 5, 67, 21},\n+    {21, 0, 0, 5, 67, 17},\n+    {13, 0, 0, 5, 67, 11},\n+    {13, 0, 0, 5, 68, 11},\n+    {7, 0, 0, 5, 68, 12},\n+    {6, 0, 0, 5, 68, 12},\n+    {21, 0, 0, 5, 68, 17},\n+    {21, 0, 0, 5, 66, 12},\n+    {12, 1, 13, 5, 40, 21},\n+    {10, 0, 0, 5, 0, 21},\n+    {7, 0, 0, 5, 0, 12},\n+    {6, 0, 0, 5, 3, 12},\n+    {12, 234, 13, 5, 40, 21},\n+    {12, 214, 13, 5, 40, 21},\n+    {12, 202, 13, 5, 40, 21},\n+    {12, 232, 13, 5, 40, 21},\n+    {12, 228, 13, 5, 40, 21},\n+    {12, 233, 13, 5, 40, 21},\n+    {8, 0, 0, 5, 2, 12},\n+    {24, 0, 18, 5, 2, 18},\n+    {29, 0, 17, 5, 0, 17},\n+    {29, 0, 17, 5, 0, 4},\n+    {1, 0, 14, 5, 0, 20},\n+    {1, 0, 14, 5, 40, 21},\n+    {1, 0, 14, 5, 40, 40},\n+    {1, 0, 0, 5, 0, 21},\n+    {1, 0, 3, 5, 0, 21},\n+    {17, 0, 18, 4, 0, 17},\n+    {17, 0, 18, 5, 0, 4},\n+    {17, 0, 18, 5, 0, 17},\n+    {17, 0, 18, 4, 0, 19},\n+    {17, 0, 18, 4, 0, 29},\n+    {20, 0, 18, 4, 0, 3},\n+    {19, 0, 18, 4, 0, 3},\n+    {22, 0, 18, 5, 0, 0},\n+    {21, 0, 18, 4, 0, 12},\n+    {21, 0, 18, 4, 0, 15},\n+    {21, 0, 18, 4, 0, 17},\n+    {27, 0, 17, 5, 0, 30},\n+    {28, 0, 15, 5, 0, 30},\n+    {1, 0, 1, 5, 0, 21},\n+    {1, 0, 5, 5, 0, 21},\n+    {1, 0, 7, 5, 0, 21},\n+    {1, 0, 2, 5, 0, 21},\n+    {1, 0, 6, 5, 0, 21},\n+    {21, 0, 10, 4, 0, 10},\n+    {21, 0, 10, 5, 0, 10},\n+    {21, 0, 18, 4, 0, 10},\n+    {21, 0, 18, 5, 0, 10},\n+    {21, 0, 18, 5, 0, 5},\n+    {16, 0, 18, 5, 0, 12},\n+    {25, 0, 12, 5, 0, 8},\n+    {18, 0, 18, 5, 0, 1},\n+    {25, 0, 18, 5, 0, 12},\n+    {1, 0, 14, 5, 0, 22},\n+    {1, 0, 14, 5, 0, 12},\n+    {1, 0, 19, 5, 0, 21},\n+    {1, 0, 20, 5, 0, 21},\n+    {1, 0, 21, 5, 0, 21},\n+    {1, 0, 22, 5, 0, 21},\n+    {1, 0, 14, 5, 0, 21},\n+    {15, 0, 8, 5, 0, 12},\n+    {25, 0, 9, 5, 0, 12},\n+    {6, 0, 0, 4, 1, 29},\n+    {23, 0, 10, 5, 0, 10},\n+    {23, 0, 10, 1, 0, 9},\n+    {2, 0, 18, 5, 102, 9},\n+    {9, 0, 0, 5, 0, 12},\n+    {26, 0, 18, 4, 0, 10},\n+    {26, 0, 18, 4, 0, 29},\n+    {5, 0, 0, 4, 0, 29},\n+    {26, 0, 18, 4, 0, 9},\n+    {9, 0, 0, 4, 1, 29},\n+    {26, 0, 10, 5, 0, 12},\n+    {15, 0, 18, 5, 0, 12},\n+    {15, 0, 18, 4, 0, 12},\n+    {15, 0, 18, 5, 0, 29},\n+    {14, 0, 0, 4, 1, 29},\n+    {14, 0, 0, 5, 1, 12},\n+    {25, 0, 9, 5, 0, 9},\n+    {25, 0, 10, 5, 0, 9},\n+    {25, 0, 18, 5, 0, 15},\n+    {26, 0, 18, 2, 0, 14},\n+    {22, 0, 18, 2, 0, 0},\n+    {18, 0, 18, 2, 0, 1},\n+    {26, 0, 18, 2, 0, 12},\n+    {26, 0, 18, 5, 0, 14},\n+    {26, 0, 0, 4, 0, 29},\n+    {26, 0, 18, 5, 0, 29},\n+    {25, 0, 18, 2, 0, 12},\n+    {26, 0, 18, 4, 0, 14},\n+    {26, 0, 18, 5, 0, 41},\n+    {26, 0, 18, 4, 0, 41},\n+    {26, 0, 18, 2, 0, 41},\n+    {26, 0, 18, 2, 0, 29},\n+    {26, 0, 18, 5, 0, 3},\n+    {26, 0, 18, 5, 0, 6},\n+    {26, 0, 0, 5, 52, 12},\n+    {9, 0, 0, 5, 56, 12},\n+    {5, 0, 0, 5, 56, 12},\n+    {26, 0, 18, 5, 54, 12},\n+    {12, 230, 13, 5, 54, 21},\n+    {21, 0, 18, 5, 54, 6},\n+    {21, 0, 18, 5, 54, 17},\n+    {15, 0, 18, 5, 54, 12},\n+    {7, 0, 0, 5, 57, 12},\n+    {6, 0, 0, 5, 57, 12},\n+    {21, 0, 0, 5, 57, 17},\n+    {12, 9, 13, 5, 57, 21},\n+    {21, 0, 18, 5, 0, 3},\n+    {21, 0, 18, 5, 0, 0},\n+    {17, 0, 18, 5, 0, 12},\n+    {17, 0, 18, 5, 0, 19},\n+    {26, 0, 18, 2, 35, 14},\n+    {29, 0, 17, 0, 0, 17},\n+    {21, 0, 18, 2, 0, 1},\n+    {21, 0, 18, 2, 0, 14},\n+    {6, 0, 0, 2, 35, 5},\n+    {7, 0, 0, 2, 0, 14},\n+    {14, 0, 0, 2, 35, 14},\n+    {17, 0, 18, 2, 0, 5},\n+    {12, 218, 13, 2, 40, 21},\n+    {12, 228, 13, 2, 40, 21},\n+    {12, 232, 13, 2, 40, 21},\n+    {12, 222, 13, 2, 40, 21},\n+    {10, 224, 0, 2, 24, 21},\n+    {17, 0, 18, 2, 0, 14},\n+    {6, 0, 0, 2, 0, 14},\n+    {6, 0, 0, 2, 0, 21},\n+    {7, 0, 0, 2, 0, 5},\n+    {7, 0, 0, 2, 32, 32},\n+    {7, 0, 0, 2, 32, 14},\n+    {12, 8, 13, 2, 40, 21},\n+    {24, 0, 18, 2, 0, 5},\n+    {6, 0, 0, 2, 32, 5},\n+    {7, 0, 0, 2, 33, 32},\n+    {7, 0, 0, 2, 33, 14},\n+    {21, 0, 18, 2, 0, 5},\n+    {6, 0, 0, 2, 0, 32},\n+    {6, 0, 0, 2, 33, 5},\n+    {7, 0, 0, 2, 34, 14},\n+    {7, 0, 0, 2, 24, 14},\n+    {26, 0, 0, 2, 0, 14},\n+    {15, 0, 0, 2, 0, 14},\n+    {26, 0, 0, 2, 24, 14},\n+    {26, 0, 18, 2, 24, 14},\n+    {15, 0, 0, 4, 0, 29},\n+    {15, 0, 18, 2, 0, 14},\n+    {26, 0, 0, 2, 33, 14},\n+    {7, 0, 0, 2, 35, 14},\n+    {2, 0, 18, 2, 102, 14},\n+    {7, 0, 0, 2, 36, 14},\n+    {6, 0, 0, 2, 36, 5},\n+    {26, 0, 18, 2, 36, 14},\n+    {7, 0, 0, 5, 82, 12},\n+    {6, 0, 0, 5, 82, 12},\n+    {21, 0, 0, 5, 82, 17},\n+    {7, 0, 0, 5, 69, 12},\n+    {6, 0, 0, 5, 69, 12},\n+    {21, 0, 18, 5, 69, 17},\n+    {21, 0, 18, 5, 69, 6},\n+    {13, 0, 0, 5, 69, 11},\n+    {7, 0, 0, 5, 3, 12},\n+    {21, 0, 18, 5, 3, 12},\n+    {6, 0, 18, 5, 3, 12},\n+    {7, 0, 0, 5, 83, 12},\n+    {14, 0, 0, 5, 83, 12},\n+    {12, 230, 13, 5, 83, 21},\n+    {21, 0, 0, 5, 83, 12},\n+    {21, 0, 0, 5, 83, 17},\n+    {24, 0, 0, 5, 0, 12},\n+    {7, 0, 0, 5, 58, 12},\n+    {12, 0, 13, 5, 58, 21},\n+    {12, 9, 13, 5, 58, 21},\n+    {10, 0, 0, 5, 58, 21},\n+    {26, 0, 18, 5, 58, 12},\n+    {15, 0, 0, 5, 0, 12},\n+    {7, 0, 0, 5, 64, 12},\n+    {21, 0, 18, 5, 64, 18},\n+    {21, 0, 18, 5, 64, 6},\n+    {10, 0, 0, 5, 70, 21},\n+    {7, 0, 0, 5, 70, 12},\n+    {12, 9, 13, 5, 70, 21},\n+    {12, 0, 13, 5, 70, 21},\n+    {21, 0, 0, 5, 70, 17},\n+    {13, 0, 0, 5, 70, 11},\n+    {21, 0, 0, 5, 9, 18},\n+    {13, 0, 0, 5, 71, 11},\n+    {7, 0, 0, 5, 71, 12},\n+    {12, 0, 13, 5, 71, 21},\n+    {12, 220, 13, 5, 71, 21},\n+    {21, 0, 0, 5, 71, 17},\n+    {7, 0, 0, 5, 72, 12},\n+    {12, 0, 13, 5, 72, 21},\n+    {10, 0, 0, 5, 72, 21},\n+    {10, 9, 0, 5, 72, 21},\n+    {21, 0, 0, 5, 72, 12},\n+    {12, 0, 13, 5, 84, 21},\n+    {10, 0, 0, 5, 84, 21},\n+    {7, 0, 0, 5, 84, 12},\n+    {12, 7, 13, 5, 84, 21},\n+    {10, 9, 0, 5, 84, 21},\n+    {21, 0, 0, 5, 84, 12},\n+    {21, 0, 0, 5, 84, 17},\n+    {13, 0, 0, 5, 84, 11},\n+    {6, 0, 0, 5, 22, 36},\n+    {7, 0, 0, 5, 76, 12},\n+    {12, 0, 13, 5, 76, 21},\n+    {10, 0, 0, 5, 76, 21},\n+    {13, 0, 0, 5, 76, 11},\n+    {21, 0, 0, 5, 76, 12},\n+    {21, 0, 0, 5, 76, 17},\n+    {7, 0, 0, 5, 78, 36},\n+    {12, 230, 13, 5, 78, 36},\n+    {12, 220, 13, 5, 78, 36},\n+    {6, 0, 0, 5, 78, 36},\n+    {21, 0, 0, 5, 78, 36},\n+    {7, 0, 0, 5, 85, 12},\n+    {10, 0, 0, 5, 85, 21},\n+    {12, 0, 13, 5, 85, 21},\n+    {21, 0, 0, 5, 85, 17},\n+    {6, 0, 0, 5, 85, 12},\n+    {12, 9, 13, 5, 85, 21},\n+    {13, 0, 0, 5, 85, 11},\n+    {7, 0, 0, 2, 24, 23},\n+    {7, 0, 0, 2, 24, 24},\n+    {4, 0, 0, 5, 102, 37},\n+    {3, 0, 0, 4, 102, 39},\n+    {12, 26, 13, 5, 5, 21},\n+    {25, 0, 9, 5, 5, 12},\n+    {24, 0, 4, 5, 6, 12},\n+    {12, 0, 13, 4, 40, 21},\n+    {21, 0, 18, 2, 0, 8},\n+    {21, 0, 18, 2, 0, 6},\n+    {21, 0, 18, 2, 0, 15},\n+    {16, 0, 18, 2, 0, 14},\n+    {21, 0, 12, 2, 0, 1},\n+    {21, 0, 12, 2, 0, 5},\n+    {21, 0, 10, 2, 0, 14},\n+    {25, 0, 9, 2, 0, 14},\n+    {17, 0, 9, 2, 0, 14},\n+    {25, 0, 18, 2, 0, 14},\n+    {23, 0, 10, 2, 0, 9},\n+    {21, 0, 10, 2, 0, 10},\n+    {21, 0, 18, 0, 0, 6},\n+    {21, 0, 18, 0, 0, 14},\n+    {21, 0, 10, 0, 0, 14},\n+    {23, 0, 10, 0, 0, 9},\n+    {21, 0, 10, 0, 0, 10},\n+    {22, 0, 18, 0, 0, 0},\n+    {18, 0, 18, 0, 0, 1},\n+    {25, 0, 9, 0, 0, 14},\n+    {21, 0, 12, 0, 0, 1},\n+    {17, 0, 9, 0, 0, 14},\n+    {21, 0, 12, 0, 0, 14},\n+    {13, 0, 8, 0, 0, 14},\n+    {21, 0, 12, 0, 0, 5},\n+    {21, 0, 18, 0, 0, 5},\n+    {25, 0, 18, 0, 0, 14},\n+    {9, 0, 0, 0, 1, 14},\n+    {24, 0, 18, 0, 0, 14},\n+    {16, 0, 18, 0, 0, 14},\n+    {5, 0, 0, 0, 1, 14},\n+    {21, 0, 18, 1, 0, 1},\n+    {22, 0, 18, 1, 0, 0},\n+    {18, 0, 18, 1, 0, 1},\n+    {21, 0, 18, 1, 0, 5},\n+    {7, 0, 0, 1, 33, 14},\n+    {7, 0, 0, 1, 33, 32},\n+    {6, 0, 0, 1, 0, 32},\n+    {6, 0, 0, 1, 0, 5},\n+    {7, 0, 0, 1, 24, 14},\n+    {23, 0, 10, 0, 0, 10},\n+    {26, 0, 18, 0, 0, 14},\n+    {26, 0, 18, 1, 0, 12},\n+    {25, 0, 18, 1, 0, 12},\n+    {1, 0, 18, 5, 0, 21},\n+    {26, 0, 18, 5, 0, 31},\n+    {7, 0, 0, 5, 47, 12},\n+    {14, 0, 18, 5, 2, 12},\n+    {15, 0, 18, 5, 2, 12},\n+    {26, 0, 18, 5, 2, 12},\n+    {26, 0, 0, 5, 2, 12},\n+    {7, 0, 0, 5, 73, 12},\n+    {7, 0, 0, 5, 74, 12},\n+    {7, 0, 0, 5, 37, 12},\n+    {15, 0, 0, 5, 37, 12},\n+    {7, 0, 0, 5, 38, 12},\n+    {14, 0, 0, 5, 38, 12},\n+    {7, 0, 0, 5, 118, 12},\n+    {12, 230, 13, 5, 118, 21},\n+    {7, 0, 0, 5, 48, 12},\n+    {21, 0, 0, 5, 48, 17},\n+    {7, 0, 0, 5, 59, 12},\n+    {21, 0, 0, 5, 59, 17},\n+    {14, 0, 0, 5, 59, 12},\n+    {9, 0, 0, 5, 39, 12},\n+    {5, 0, 0, 5, 39, 12},\n+    {7, 0, 0, 5, 49, 12},\n+    {7, 0, 0, 5, 50, 12},\n+    {13, 0, 0, 5, 50, 11},\n+    {9, 0, 0, 5, 136, 12},\n+    {5, 0, 0, 5, 136, 12},\n+    {7, 0, 0, 5, 106, 12},\n+    {7, 0, 0, 5, 104, 12},\n+    {21, 0, 0, 5, 104, 12},\n+    {7, 0, 0, 5, 110, 12},\n+    {7, 0, 3, 5, 51, 12},\n+    {7, 0, 3, 5, 86, 12},\n+    {21, 0, 3, 5, 86, 17},\n+    {15, 0, 3, 5, 86, 12},\n+    {7, 0, 3, 5, 120, 12},\n+    {26, 0, 3, 5, 120, 12},\n+    {15, 0, 3, 5, 120, 12},\n+    {7, 0, 3, 5, 116, 12},\n+    {15, 0, 3, 5, 116, 12},\n+    {7, 0, 3, 5, 128, 12},\n+    {15, 0, 3, 5, 128, 12},\n+    {7, 0, 3, 5, 63, 12},\n+    {15, 0, 3, 5, 63, 12},\n+    {21, 0, 18, 5, 63, 17},\n+    {7, 0, 3, 5, 75, 12},\n+    {21, 0, 3, 5, 75, 12},\n+    {7, 0, 3, 5, 97, 12},\n+    {7, 0, 3, 5, 96, 12},\n+    {15, 0, 3, 5, 96, 12},\n+    {7, 0, 3, 5, 60, 12},\n+    {12, 0, 13, 5, 60, 21},\n+    {12, 220, 13, 5, 60, 21},\n+    {12, 230, 13, 5, 60, 21},\n+    {12, 1, 13, 5, 60, 21},\n+    {12, 9, 13, 5, 60, 21},\n+    {15, 0, 3, 5, 60, 12},\n+    {21, 0, 3, 5, 60, 17},\n+    {21, 0, 3, 5, 60, 12},\n+    {7, 0, 3, 5, 87, 12},\n+    {15, 0, 3, 5, 87, 12},\n+    {21, 0, 3, 5, 87, 12},\n+    {7, 0, 3, 5, 117, 12},\n+    {15, 0, 3, 5, 117, 12},\n+    {7, 0, 3, 5, 112, 12},\n+    {26, 0, 3, 5, 112, 12},\n+    {12, 230, 13, 5, 112, 21},\n+    {12, 220, 13, 5, 112, 21},\n+    {15, 0, 3, 5, 112, 12},\n+    {21, 0, 3, 5, 112, 17},\n+    {21, 0, 3, 5, 112, 15},\n+    {7, 0, 3, 5, 79, 12},\n+    {21, 0, 18, 5, 79, 17},\n+    {7, 0, 3, 5, 88, 12},\n+    {15, 0, 3, 5, 88, 12},\n+    {7, 0, 3, 5, 89, 12},\n+    {15, 0, 3, 5, 89, 12},\n+    {7, 0, 3, 5, 122, 12},\n+    {21, 0, 3, 5, 122, 12},\n+    {15, 0, 3, 5, 122, 12},\n+    {7, 0, 3, 5, 90, 12},\n+    {9, 0, 3, 5, 130, 12},\n+    {5, 0, 3, 5, 130, 12},\n+    {15, 0, 3, 5, 130, 12},\n+    {7, 0, 4, 5, 144, 12},\n+    {12, 230, 13, 5, 144, 21},\n+    {13, 0, 11, 5, 144, 11},\n+    {15, 0, 11, 5, 6, 12},\n+    {7, 0, 3, 5, 147, 12},\n+    {15, 0, 3, 5, 147, 12},\n+    {7, 0, 4, 5, 148, 12},\n+    {12, 220, 13, 5, 148, 21},\n+    {12, 230, 13, 5, 148, 21},\n+    {15, 0, 4, 5, 148, 12},\n+    {21, 0, 4, 5, 148, 12},\n+    {10, 0, 0, 5, 93, 21},\n+    {12, 0, 13, 5, 93, 21},\n+    {7, 0, 0, 5, 93, 12},\n+    {12, 9, 13, 5, 93, 21},\n+    {21, 0, 0, 5, 93, 17},\n+    {21, 0, 0, 5, 93, 12},\n+    {15, 0, 18, 5, 93, 12},\n+    {13, 0, 0, 5, 93, 11},\n+    {12, 0, 13, 5, 91, 21},\n+    {10, 0, 0, 5, 91, 21},\n+    {7, 0, 0, 5, 91, 12},\n+    {12, 9, 13, 5, 91, 21},\n+    {12, 7, 13, 5, 91, 21},\n+    {21, 0, 0, 5, 91, 12},\n+    {1, 0, 0, 5, 91, 12},\n+    {21, 0, 0, 5, 91, 17},\n+    {7, 0, 0, 5, 100, 12},\n+    {13, 0, 0, 5, 100, 11},\n+    {12, 230, 13, 5, 95, 21},\n+    {7, 0, 0, 5, 95, 12},\n+    {12, 0, 13, 5, 95, 21},\n+    {10, 0, 0, 5, 95, 21},\n+    {12, 9, 13, 5, 95, 21},\n+    {13, 0, 0, 5, 95, 11},\n+    {21, 0, 0, 5, 95, 17},\n+    {7, 0, 0, 5, 111, 12},\n+    {12, 7, 13, 5, 111, 21},\n+    {21, 0, 0, 5, 111, 12},\n+    {21, 0, 0, 5, 111, 18},\n+    {12, 0, 13, 5, 99, 21},\n+    {10, 0, 0, 5, 99, 21},\n+    {7, 0, 0, 5, 99, 12},\n+    {10, 9, 0, 5, 99, 21},\n+    {21, 0, 0, 5, 99, 17},\n+    {21, 0, 0, 5, 99, 12},\n+    {12, 7, 13, 5, 99, 21},\n+    {13, 0, 0, 5, 99, 11},\n+    {21, 0, 0, 5, 99, 18},\n+    {15, 0, 0, 5, 18, 12},\n+    {7, 0, 0, 5, 108, 12},\n+    {10, 0, 0, 5, 108, 21},\n+    {12, 0, 13, 5, 108, 21},\n+    {10, 9, 0, 5, 108, 21},\n+    {12, 7, 13, 5, 108, 21},\n+    {21, 0, 0, 5, 108, 17},\n+    {21, 0, 0, 5, 108, 12},\n+    {7, 0, 0, 5, 129, 12},\n+    {21, 0, 0, 5, 129, 17},\n+    {7, 0, 0, 5, 109, 12},\n+    {12, 0, 13, 5, 109, 21},\n+    {10, 0, 0, 5, 109, 21},\n+    {12, 7, 13, 5, 109, 21},\n+    {12, 9, 13, 5, 109, 21},\n+    {13, 0, 0, 5, 109, 11},\n+    {12, 0, 13, 5, 107, 21},\n+    {10, 0, 0, 5, 107, 21},\n+    {7, 0, 0, 5, 107, 12},\n+    {12, 7, 13, 5, 40, 21},\n+    {12, 7, 13, 5, 107, 21},\n+    {10, 9, 0, 5, 107, 21},\n+    {12, 230, 13, 5, 107, 21},\n+    {7, 0, 0, 5, 135, 12},\n+    {10, 0, 0, 5, 135, 21},\n+    {12, 0, 13, 5, 135, 21},\n+    {12, 9, 13, 5, 135, 21},\n+    {12, 7, 13, 5, 135, 21},\n+    {21, 0, 0, 5, 135, 17},\n+    {21, 0, 0, 5, 135, 12},\n+    {13, 0, 0, 5, 135, 11},\n+    {12, 230, 13, 5, 135, 21},\n+    {7, 0, 0, 5, 124, 12},\n+    {10, 0, 0, 5, 124, 21},\n+    {12, 0, 13, 5, 124, 21},\n+    {12, 9, 13, 5, 124, 21},\n+    {12, 7, 13, 5, 124, 21},\n+    {21, 0, 0, 5, 124, 12},\n+    {13, 0, 0, 5, 124, 11},\n+    {7, 0, 0, 5, 123, 12},\n+    {10, 0, 0, 5, 123, 21},\n+    {12, 0, 13, 5, 123, 21},\n+    {12, 9, 13, 5, 123, 21},\n+    {12, 7, 13, 5, 123, 21},\n+    {21, 0, 0, 5, 123, 18},\n+    {21, 0, 0, 5, 123, 17},\n+    {21, 0, 0, 5, 123, 6},\n+    {21, 0, 0, 5, 123, 12},\n+    {7, 0, 0, 5, 114, 12},\n+    {10, 0, 0, 5, 114, 21},\n+    {12, 0, 13, 5, 114, 21},\n+    {12, 9, 13, 5, 114, 21},\n+    {21, 0, 0, 5, 114, 17},\n+    {21, 0, 0, 5, 114, 12},\n+    {13, 0, 0, 5, 114, 11},\n+    {21, 0, 18, 5, 31, 18},\n+    {7, 0, 0, 5, 101, 12},\n+    {12, 0, 13, 5, 101, 21},\n+    {10, 0, 0, 5, 101, 21},\n+    {10, 9, 0, 5, 101, 21},\n+    {12, 7, 13, 5, 101, 21},\n+    {13, 0, 0, 5, 101, 11},\n+    {7, 0, 0, 5, 126, 36},\n+    {12, 0, 13, 5, 126, 36},\n+    {10, 0, 0, 5, 126, 36},\n+    {12, 9, 13, 5, 126, 36},\n+    {13, 0, 0, 5, 126, 11},\n+    {15, 0, 0, 5, 126, 36},\n+    {21, 0, 0, 5, 126, 17},\n+    {26, 0, 0, 5, 126, 36},\n+    {7, 0, 0, 5, 142, 12},\n+    {10, 0, 0, 5, 142, 21},\n+    {12, 0, 13, 5, 142, 21},\n+    {12, 9, 13, 5, 142, 21},\n+    {12, 7, 13, 5, 142, 21},\n+    {21, 0, 0, 5, 142, 12},\n+    {9, 0, 0, 5, 125, 12},\n+    {5, 0, 0, 5, 125, 12},\n+    {13, 0, 0, 5, 125, 11},\n+    {15, 0, 0, 5, 125, 12},\n+    {7, 0, 0, 5, 125, 12},\n+    {7, 0, 0, 5, 141, 12},\n+    {12, 0, 13, 5, 141, 21},\n+    {12, 0, 0, 5, 141, 21},\n+    {12, 9, 13, 5, 141, 21},\n+    {10, 0, 0, 5, 141, 21},\n+    {21, 0, 0, 5, 141, 18},\n+    {21, 0, 0, 5, 141, 12},\n+    {21, 0, 0, 5, 141, 17},\n+    {7, 0, 0, 5, 140, 12},\n+    {12, 0, 13, 5, 140, 21},\n+    {10, 0, 0, 5, 140, 21},\n+    {12, 9, 13, 5, 140, 21},\n+    {21, 0, 0, 5, 140, 17},\n+    {21, 0, 0, 5, 140, 18},\n+    {7, 0, 0, 5, 121, 12},\n+    {7, 0, 0, 5, 133, 12},\n+    {10, 0, 0, 5, 133, 21},\n+    {12, 0, 13, 5, 133, 21},\n+    {12, 9, 0, 5, 133, 21},\n+    {21, 0, 0, 5, 133, 17},\n+    {13, 0, 0, 5, 133, 11},\n+    {15, 0, 0, 5, 133, 12},\n+    {21, 0, 0, 5, 134, 18},\n+    {21, 0, 0, 5, 134, 6},\n+    {7, 0, 0, 5, 134, 12},\n+    {12, 0, 13, 5, 134, 21},\n+    {10, 0, 0, 5, 134, 21},\n+    {7, 0, 0, 5, 138, 12},\n+    {12, 0, 13, 5, 138, 21},\n+    {12, 7, 13, 5, 138, 21},\n+    {12, 9, 13, 5, 138, 21},\n+    {13, 0, 0, 5, 138, 11},\n+    {7, 0, 0, 5, 143, 12},\n+    {10, 0, 0, 5, 143, 21},\n+    {12, 0, 13, 5, 143, 21},\n+    {12, 9, 13, 5, 143, 21},\n+    {13, 0, 0, 5, 143, 11},\n+    {7, 0, 0, 5, 145, 12},\n+    {12, 0, 13, 5, 145, 21},\n+    {10, 0, 0, 5, 145, 21},\n+    {21, 0, 0, 5, 145, 12},\n+    {7, 0, 0, 5, 62, 12},\n+    {14, 0, 0, 5, 62, 12},\n+    {21, 0, 0, 5, 62, 17},\n+    {7, 0, 0, 5, 80, 12},\n+    {7, 0, 0, 5, 80, 0},\n+    {7, 0, 0, 5, 80, 1},\n+    {7, 0, 0, 5, 127, 12},\n+    {7, 0, 0, 5, 127, 0},\n+    {7, 0, 0, 5, 127, 1},\n+    {7, 0, 0, 5, 115, 12},\n+    {13, 0, 0, 5, 115, 11},\n+    {21, 0, 0, 5, 115, 17},\n+    {7, 0, 0, 5, 103, 12},\n+    {12, 1, 13, 5, 103, 21},\n+    {21, 0, 0, 5, 103, 17},\n+    {7, 0, 0, 5, 119, 12},\n+    {12, 230, 13, 5, 119, 21},\n+    {21, 0, 0, 5, 119, 17},\n+    {21, 0, 0, 5, 119, 12},\n+    {26, 0, 0, 5, 119, 12},\n+    {6, 0, 0, 5, 119, 12},\n+    {13, 0, 0, 5, 119, 11},\n+    {15, 0, 0, 5, 119, 12},\n+    {9, 0, 0, 5, 146, 12},\n+    {5, 0, 0, 5, 146, 12},\n+    {15, 0, 0, 5, 146, 12},\n+    {21, 0, 0, 5, 146, 17},\n+    {21, 0, 0, 5, 146, 12},\n+    {7, 0, 0, 5, 98, 12},\n+    {10, 0, 0, 5, 98, 21},\n+    {12, 0, 13, 5, 98, 21},\n+    {6, 0, 0, 5, 98, 12},\n+    {6, 0, 0, 2, 137, 5},\n+    {6, 0, 0, 2, 139, 5},\n+    {7, 0, 0, 2, 137, 14},\n+    {7, 0, 0, 2, 139, 14},\n+    {7, 0, 0, 5, 105, 12},\n+    {26, 0, 0, 5, 105, 12},\n+    {12, 0, 13, 5, 105, 21},\n+    {12, 1, 13, 5, 105, 21},\n+    {21, 0, 0, 5, 105, 17},\n+    {10, 216, 0, 5, 0, 21},\n+    {10, 226, 0, 5, 0, 21},\n+    {12, 230, 13, 5, 2, 21},\n+    {25, 0, 0, 5, 0, 12},\n+    {13, 0, 8, 5, 0, 11},\n+    {26, 0, 0, 5, 131, 12},\n+    {12, 0, 13, 5, 131, 21},\n+    {21, 0, 0, 5, 131, 17},\n+    {21, 0, 0, 5, 131, 12},\n+    {12, 230, 13, 5, 56, 21},\n+    {7, 0, 3, 5, 113, 12},\n+    {15, 0, 3, 5, 113, 12},\n+    {12, 220, 13, 5, 113, 21},\n+    {9, 0, 3, 5, 132, 12},\n+    {5, 0, 3, 5, 132, 12},\n+    {12, 230, 13, 5, 132, 21},\n+    {12, 7, 13, 5, 132, 21},\n+    {13, 0, 3, 5, 132, 11},\n+    {21, 0, 3, 5, 132, 0},\n+    {15, 0, 4, 5, 0, 12},\n+    {26, 0, 4, 5, 0, 10},\n+    {23, 0, 4, 5, 0, 10},\n+    {2, 0, 18, 5, 102, 14},\n+    {26, 0, 0, 2, 0, 29},\n+    {26, 0, 0, 5, 0, 28},\n+    {26, 0, 0, 2, 32, 14},\n+    {24, 0, 18, 2, 0, 42},\n+    {26, 0, 18, 5, 0, 5},\n+};\n+\n+#define BIDI_MIRROR_LEN 420\n+static const MirrorPair mirror_pairs[] = {\n+    {40, 41},\n+    {41, 40},\n+    {60, 62},\n+    {62, 60},\n+    {91, 93},\n+    {93, 91},\n+    {123, 125},\n+    {125, 123},\n+    {171, 187},\n+    {187, 171},\n+    {3898, 3899},\n+    {3899, 3898},\n+    {3900, 3901},\n+    {3901, 3900},\n+    {5787, 5788},\n+    {5788, 5787},\n+    {8249, 8250},\n+    {8250, 8249},\n+    {8261, 8262},\n+    {8262, 8261},\n+    {8317, 8318},\n+    {8318, 8317},\n+    {8333, 8334},\n+    {8334, 8333},\n+    {8712, 8715},\n+    {8713, 8716},\n+    {8714, 8717},\n+    {8715, 8712},\n+    {8716, 8713},\n+    {8717, 8714},\n+    {8725, 10741},\n+    {8735, 11262},\n+    {8736, 10659},\n+    {8737, 10651},\n+    {8738, 10656},\n+    {8740, 10990},\n+    {8764, 8765},\n+    {8765, 8764},\n+    {8771, 8909},\n+    {8773, 8780},\n+    {8780, 8773},\n+    {8786, 8787},\n+    {8787, 8786},\n+    {8788, 8789},\n+    {8789, 8788},\n+    {8804, 8805},\n+    {8805, 8804},\n+    {8806, 8807},\n+    {8807, 8806},\n+    {8808, 8809},\n+    {8809, 8808},\n+    {8810, 8811},\n+    {8811, 8810},\n+    {8814, 8815},\n+    {8815, 8814},\n+    {8816, 8817},\n+    {8817, 8816},\n+    {8818, 8819},\n+    {8819, 8818},\n+    {8820, 8821},\n+    {8821, 8820},\n+    {8822, 8823},\n+    {8823, 8822},\n+    {8824, 8825},\n+    {8825, 8824},\n+    {8826, 8827},\n+    {8827, 8826},\n+    {8828, 8829},\n+    {8829, 8828},\n+    {8830, 8831},\n+    {8831, 8830},\n+    {8832, 8833},\n+    {8833, 8832},\n+    {8834, 8835},\n+    {8835, 8834},\n+    {8836, 8837},\n+    {8837, 8836},\n+    {8838, 8839},\n+    {8839, 8838},\n+    {8840, 8841},\n+    {8841, 8840},\n+    {8842, 8843},\n+    {8843, 8842},\n+    {8847, 8848},\n+    {8848, 8847},\n+    {8849, 8850},\n+    {8850, 8849},\n+    {8856, 10680},\n+    {8866, 8867},\n+    {8867, 8866},\n+    {8870, 10974},\n+    {8872, 10980},\n+    {8873, 10979},\n+    {8875, 10981},\n+    {8880, 8881},\n+    {8881, 8880},\n+    {8882, 8883},\n+    {8883, 8882},\n+    {8884, 8885},\n+    {8885, 8884},\n+    {8886, 8887},\n+    {8887, 8886},\n+    {8888, 10204},\n+    {8905, 8906},\n+    {8906, 8905},\n+    {8907, 8908},\n+    {8908, 8907},\n+    {8909, 8771},\n+    {8912, 8913},\n+    {8913, 8912},\n+    {8918, 8919},\n+    {8919, 8918},\n+    {8920, 8921},\n+    {8921, 8920},\n+    {8922, 8923},\n+    {8923, 8922},\n+    {8924, 8925},\n+    {8925, 8924},\n+    {8926, 8927},\n+    {8927, 8926},\n+    {8928, 8929},\n+    {8929, 8928},\n+    {8930, 8931},\n+    {8931, 8930},\n+    {8932, 8933},\n+    {8933, 8932},\n+    {8934, 8935},\n+    {8935, 8934},\n+    {8936, 8937},\n+    {8937, 8936},\n+    {8938, 8939},\n+    {8939, 8938},\n+    {8940, 8941},\n+    {8941, 8940},\n+    {8944, 8945},\n+    {8945, 8944},\n+    {8946, 8954},\n+    {8947, 8955},\n+    {8948, 8956},\n+    {8950, 8957},\n+    {8951, 8958},\n+    {8954, 8946},\n+    {8955, 8947},\n+    {8956, 8948},\n+    {8957, 8950},\n+    {8958, 8951},\n+    {8968, 8969},\n+    {8969, 8968},\n+    {8970, 8971},\n+    {8971, 8970},\n+    {9001, 9002},\n+    {9002, 9001},\n+    {10088, 10089},\n+    {10089, 10088},\n+    {10090, 10091},\n+    {10091, 10090},\n+    {10092, 10093},\n+    {10093, 10092},\n+    {10094, 10095},\n+    {10095, 10094},\n+    {10096, 10097},\n+    {10097, 10096},\n+    {10098, 10099},\n+    {10099, 10098},\n+    {10100, 10101},\n+    {10101, 10100},\n+    {10179, 10180},\n+    {10180, 10179},\n+    {10181, 10182},\n+    {10182, 10181},\n+    {10184, 10185},\n+    {10185, 10184},\n+    {10187, 10189},\n+    {10189, 10187},\n+    {10197, 10198},\n+    {10198, 10197},\n+    {10204, 8888},\n+    {10205, 10206},\n+    {10206, 10205},\n+    {10210, 10211},\n+    {10211, 10210},\n+    {10212, 10213},\n+    {10213, 10212},\n+    {10214, 10215},\n+    {10215, 10214},\n+    {10216, 10217},\n+    {10217, 10216},\n+    {10218, 10219},\n+    {10219, 10218},\n+    {10220, 10221},\n+    {10221, 10220},\n+    {10222, 10223},\n+    {10223, 10222},\n+    {10627, 10628},\n+    {10628, 10627},\n+    {10629, 10630},\n+    {10630, 10629},\n+    {10631, 10632},\n+    {10632, 10631},\n+    {10633, 10634},\n+    {10634, 10633},\n+    {10635, 10636},\n+    {10636, 10635},\n+    {10637, 10640},\n+    {10638, 10639},\n+    {10639, 10638},\n+    {10640, 10637},\n+    {10641, 10642},\n+    {10642, 10641},\n+    {10643, 10644},\n+    {10644, 10643},\n+    {10645, 10646},\n+    {10646, 10645},\n+    {10647, 10648},\n+    {10648, 10647},\n+    {10651, 8737},\n+    {10656, 8738},\n+    {10659, 8736},\n+    {10660, 10661},\n+    {10661, 10660},\n+    {10664, 10665},\n+    {10665, 10664},\n+    {10666, 10667},\n+    {10667, 10666},\n+    {10668, 10669},\n+    {10669, 10668},\n+    {10670, 10671},\n+    {10671, 10670},\n+    {10680, 8856},\n+    {10688, 10689},\n+    {10689, 10688},\n+    {10692, 10693},\n+    {10693, 10692},\n+    {10703, 10704},\n+    {10704, 10703},\n+    {10705, 10706},\n+    {10706, 10705},\n+    {10708, 10709},\n+    {10709, 10708},\n+    {10712, 10713},\n+    {10713, 10712},\n+    {10714, 10715},\n+    {10715, 10714},\n+    {10728, 10729},\n+    {10729, 10728},\n+    {10741, 8725},\n+    {10744, 10745},\n+    {10745, 10744},\n+    {10748, 10749},\n+    {10749, 10748},\n+    {10795, 10796},\n+    {10796, 10795},\n+    {10797, 10798},\n+    {10798, 10797},\n+    {10804, 10805},\n+    {10805, 10804},\n+    {10812, 10813},\n+    {10813, 10812},\n+    {10852, 10853},\n+    {10853, 10852},\n+    {10873, 10874},\n+    {10874, 10873},\n+    {10875, 10876},\n+    {10876, 10875},\n+    {10877, 10878},\n+    {10878, 10877},\n+    {10879, 10880},\n+    {10880, 10879},\n+    {10881, 10882},\n+    {10882, 10881},\n+    {10883, 10884},\n+    {10884, 10883},\n+    {10885, 10886},\n+    {10886, 10885},\n+    {10887, 10888},\n+    {10888, 10887},\n+    {10889, 10890},\n+    {10890, 10889},\n+    {10891, 10892},\n+    {10892, 10891},\n+    {10893, 10894},\n+    {10894, 10893},\n+    {10895, 10896},\n+    {10896, 10895},\n+    {10897, 10898},\n+    {10898, 10897},\n+    {10899, 10900},\n+    {10900, 10899},\n+    {10901, 10902},\n+    {10902, 10901},\n+    {10903, 10904},\n+    {10904, 10903},\n+    {10905, 10906},\n+    {10906, 10905},\n+    {10907, 10908},\n+    {10908, 10907},\n+    {10909, 10910},\n+    {10910, 10909},\n+    {10911, 10912},\n+    {10912, 10911},\n+    {10913, 10914},\n+    {10914, 10913},\n+    {10918, 10919},\n+    {10919, 10918},\n+    {10920, 10921},\n+    {10921, 10920},\n+    {10922, 10923},\n+    {10923, 10922},\n+    {10924, 10925},\n+    {10925, 10924},\n+    {10927, 10928},\n+    {10928, 10927},\n+    {10929, 10930},\n+    {10930, 10929},\n+    {10931, 10932},\n+    {10932, 10931},\n+    {10933, 10934},\n+    {10934, 10933},\n+    {10935, 10936},\n+    {10936, 10935},\n+    {10937, 10938},\n+    {10938, 10937},\n+    {10939, 10940},\n+    {10940, 10939},\n+    {10941, 10942},\n+    {10942, 10941},\n+    {10943, 10944},\n+    {10944, 10943},\n+    {10945, 10946},\n+    {10946, 10945},\n+    {10947, 10948},\n+    {10948, 10947},\n+    {10949, 10950},\n+    {10950, 10949},\n+    {10951, 10952},\n+    {10952, 10951},\n+    {10953, 10954},\n+    {10954, 10953},\n+    {10955, 10956},\n+    {10956, 10955},\n+    {10957, 10958},\n+    {10958, 10957},\n+    {10959, 10960},\n+    {10960, 10959},\n+    {10961, 10962},\n+    {10962, 10961},\n+    {10963, 10964},\n+    {10964, 10963},\n+    {10965, 10966},\n+    {10966, 10965},\n+    {10974, 8870},\n+    {10979, 8873},\n+    {10980, 8872},\n+    {10981, 8875},\n+    {10988, 10989},\n+    {10989, 10988},\n+    {10990, 8740},\n+    {10999, 11000},\n+    {11000, 10999},\n+    {11001, 11002},\n+    {11002, 11001},\n+    {11262, 8735},\n+    {11778, 11779},\n+    {11779, 11778},\n+    {11780, 11781},\n+    {11781, 11780},\n+    {11785, 11786},\n+    {11786, 11785},\n+    {11788, 11789},\n+    {11789, 11788},\n+    {11804, 11805},\n+    {11805, 11804},\n+    {11808, 11809},\n+    {11809, 11808},\n+    {11810, 11811},\n+    {11811, 11810},\n+    {11812, 11813},\n+    {11813, 11812},\n+    {11814, 11815},\n+    {11815, 11814},\n+    {11816, 11817},\n+    {11817, 11816},\n+    {12296, 12297},\n+    {12297, 12296},\n+    {12298, 12299},\n+    {12299, 12298},\n+    {12300, 12301},\n+    {12301, 12300},\n+    {12302, 12303},\n+    {12303, 12302},\n+    {12304, 12305},\n+    {12305, 12304},\n+    {12308, 12309},\n+    {12309, 12308},\n+    {12310, 12311},\n+    {12311, 12310},\n+    {12312, 12313},\n+    {12313, 12312},\n+    {12314, 12315},\n+    {12315, 12314},\n+    {65113, 65114},\n+    {65114, 65113},\n+    {65115, 65116},\n+    {65116, 65115},\n+    {65117, 65118},\n+    {65118, 65117},\n+    {65124, 65125},\n+    {65125, 65124},\n+    {65288, 65289},\n+    {65289, 65288},\n+    {65308, 65310},\n+    {65310, 65308},\n+    {65339, 65341},\n+    {65341, 65339},\n+    {65371, 65373},\n+    {65373, 65371},\n+    {65375, 65376},\n+    {65376, 65375},\n+    {65378, 65379},\n+    {65379, 65378},\n+};\n+\n+#define BIDI_BRACKET_LEN 120\n+static const BracketPair bracket_pairs[] = {\n+    {40, 41, 0},\n+    {41, 40, 1},\n+    {91, 93, 0},\n+    {93, 91, 1},\n+    {123, 125, 0},\n+    {125, 123, 1},\n+    {3898, 3899, 0},\n+    {3899, 3898, 1},\n+    {3900, 3901, 0},\n+    {3901, 3900, 1},\n+    {5787, 5788, 0},\n+    {5788, 5787, 1},\n+    {8261, 8262, 0},\n+    {8262, 8261, 1},\n+    {8317, 8318, 0},\n+    {8318, 8317, 1},\n+    {8333, 8334, 0},\n+    {8334, 8333, 1},\n+    {8968, 8969, 0},\n+    {8969, 8968, 1},\n+    {8970, 8971, 0},\n+    {8971, 8970, 1},\n+    {9001, 9002, 0},\n+    {9002, 9001, 1},\n+    {10088, 10089, 0},\n+    {10089, 10088, 1},\n+    {10090, 10091, 0},\n+    {10091, 10090, 1},\n+    {10092, 10093, 0},\n+    {10093, 10092, 1},\n+    {10094, 10095, 0},\n+    {10095, 10094, 1},\n+    {10096, 10097, 0},\n+    {10097, 10096, 1},\n+    {10098, 10099, 0},\n+    {10099, 10098, 1},\n+    {10100, 10101, 0},\n+    {10101, 10100, 1},\n+    {10181, 10182, 0},\n+    {10182, 10181, 1},\n+    {10214, 10215, 0},\n+    {10215, 10214, 1},\n+    {10216, 10217, 0},\n+    {10217, 10216, 1},\n+    {10218, 10219, 0},\n+    {10219, 10218, 1},\n+    {10220, 10221, 0},\n+    {10221, 10220, 1},\n+    {10222, 10223, 0},\n+    {10223, 10222, 1},\n+    {10627, 10628, 0},\n+    {10628, 10627, 1},\n+    {10629, 10630, 0},\n+    {10630, 10629, 1},\n+    {10631, 10632, 0},\n+    {10632, 10631, 1},\n+    {10633, 10634, 0},\n+    {10634, 10633, 1},\n+    {10635, 10636, 0},\n+    {10636, 10635, 1},\n+    {10637, 10640, 0},\n+    {10638, 10639, 1},\n+    {10639, 10638, 0},\n+    {10640, 10637, 1},\n+    {10641, 10642, 0},\n+    {10642, 10641, 1},\n+    {10643, 10644, 0},\n+    {10644, 10643, 1},\n+    {10645, 10646, 0},\n+    {10646, 10645, 1},\n+    {10647, 10648, 0},\n+    {10648, 10647, 1},\n+    {10712, 10713, 0},\n+    {10713, 10712, 1},\n+    {10714, 10715, 0},\n+    {10715, 10714, 1},\n+    {10748, 10749, 0},\n+    {10749, 10748, 1},\n+    {11810, 11811, 0},\n+    {11811, 11810, 1},\n+    {11812, 11813, 0},\n+    {11813, 11812, 1},\n+    {11814, 11815, 0},\n+    {11815, 11814, 1},\n+    {11816, 11817, 0},\n+    {11817, 11816, 1},\n+    {12296, 12297, 0},\n+    {12297, 12296, 1},\n+    {12298, 12299, 0},\n+    {12299, 12298, 1},\n+    {12300, 12301, 0},\n+    {12301, 12300, 1},\n+    {12302, 12303, 0},\n+    {12303, 12302, 1},\n+    {12304, 12305, 0},\n+    {12305, 12304, 1},\n+    {12308, 12309, 0},\n+    {12309, 12308, 1},\n+    {12310, 12311, 0},\n+    {12311, 12310, 1},\n+    {12312, 12313, 0},\n+    {12313, 12312, 1},\n+    {12314, 12315, 0},\n+    {12315, 12314, 1},\n+    {65113, 65114, 0},\n+    {65114, 65113, 1},\n+    {65115, 65116, 0},\n+    {65116, 65115, 1},\n+    {65117, 65118, 0},\n+    {65118, 65117, 1},\n+    {65288, 65289, 0},\n+    {65289, 65288, 1},\n+    {65339, 65341, 0},\n+    {65341, 65339, 1},\n+    {65371, 65373, 0},\n+    {65373, 65371, 1},\n+    {65375, 65376, 0},\n+    {65376, 65375, 1},\n+    {65378, 65379, 0},\n+    {65379, 65378, 1},\n+};\n+\n+\/* Reindexing of NFC first characters. *\/\n+#define TOTAL_FIRST 376\n+#define TOTAL_LAST 62\n+static const Reindex nfc_first[] = {\n+  { 60, 2, 0},\n+  { 65, 15, 3},\n+  { 82, 8, 19},\n+  { 97, 15, 28},\n+  { 114, 8, 44},\n+  { 168, 0, 53},\n+  { 194, 0, 54},\n+  { 196, 3, 55},\n+  { 202, 0, 59},\n+  { 207, 0, 60},\n+  { 212, 2, 61},\n+  { 216, 0, 64},\n+  { 220, 0, 65},\n+  { 226, 0, 66},\n+  { 228, 3, 67},\n+  { 234, 0, 71},\n+  { 239, 0, 72},\n+  { 244, 2, 73},\n+  { 248, 0, 76},\n+  { 252, 0, 77},\n+  { 258, 1, 78},\n+  { 274, 1, 80},\n+  { 332, 1, 82},\n+  { 346, 1, 84},\n+  { 352, 1, 86},\n+  { 360, 3, 88},\n+  { 383, 0, 92},\n+  { 416, 1, 93},\n+  { 431, 1, 95},\n+  { 439, 0, 97},\n+  { 490, 1, 98},\n+  { 550, 3, 100},\n+  { 558, 1, 104},\n+  { 658, 0, 106},\n+  { 913, 0, 107},\n+  { 917, 0, 108},\n+  { 919, 0, 109},\n+  { 921, 0, 110},\n+  { 927, 0, 111},\n+  { 929, 0, 112},\n+  { 933, 0, 113},\n+  { 937, 0, 114},\n+  { 940, 0, 115},\n+  { 942, 0, 116},\n+  { 945, 0, 117},\n+  { 949, 0, 118},\n+  { 951, 0, 119},\n+  { 953, 0, 120},\n+  { 959, 0, 121},\n+  { 961, 0, 122},\n+  { 965, 0, 123},\n+  { 969, 2, 124},\n+  { 974, 0, 127},\n+  { 978, 0, 128},\n+  { 1030, 0, 129},\n+  { 1040, 0, 130},\n+  { 1043, 0, 131},\n+  { 1045, 3, 132},\n+  { 1050, 0, 136},\n+  { 1054, 0, 137},\n+  { 1059, 0, 138},\n+  { 1063, 0, 139},\n+  { 1067, 0, 140},\n+  { 1069, 0, 141},\n+  { 1072, 0, 142},\n+  { 1075, 0, 143},\n+  { 1077, 3, 144},\n+  { 1082, 0, 148},\n+  { 1086, 0, 149},\n+  { 1091, 0, 150},\n+  { 1095, 0, 151},\n+  { 1099, 0, 152},\n+  { 1101, 0, 153},\n+  { 1110, 0, 154},\n+  { 1140, 1, 155},\n+  { 1240, 1, 157},\n+  { 1256, 1, 159},\n+  { 1575, 0, 161},\n+  { 1608, 0, 162},\n+  { 1610, 0, 163},\n+  { 1729, 0, 164},\n+  { 1746, 0, 165},\n+  { 1749, 0, 166},\n+  { 2344, 0, 167},\n+  { 2352, 0, 168},\n+  { 2355, 0, 169},\n+  { 2503, 0, 170},\n+  { 2887, 0, 171},\n+  { 2962, 0, 172},\n+  { 3014, 1, 173},\n+  { 3142, 0, 175},\n+  { 3263, 0, 176},\n+  { 3270, 0, 177},\n+  { 3274, 0, 178},\n+  { 3398, 1, 179},\n+  { 3545, 0, 181},\n+  { 3548, 0, 182},\n+  { 4133, 0, 183},\n+  { 6917, 0, 184},\n+  { 6919, 0, 185},\n+  { 6921, 0, 186},\n+  { 6923, 0, 187},\n+  { 6925, 0, 188},\n+  { 6929, 0, 189},\n+  { 6970, 0, 190},\n+  { 6972, 0, 191},\n+  { 6974, 1, 192},\n+  { 6978, 0, 194},\n+  { 7734, 1, 195},\n+  { 7770, 1, 197},\n+  { 7778, 1, 199},\n+  { 7840, 1, 201},\n+  { 7864, 1, 203},\n+  { 7884, 1, 205},\n+  { 7936, 17, 207},\n+  { 7960, 1, 225},\n+  { 7968, 17, 227},\n+  { 7992, 1, 245},\n+  { 8000, 1, 247},\n+  { 8008, 1, 249},\n+  { 8016, 1, 251},\n+  { 8025, 0, 253},\n+  { 8032, 16, 254},\n+  { 8052, 0, 271},\n+  { 8060, 0, 272},\n+  { 8118, 0, 273},\n+  { 8127, 0, 274},\n+  { 8134, 0, 275},\n+  { 8182, 0, 276},\n+  { 8190, 0, 277},\n+  { 8592, 0, 278},\n+  { 8594, 0, 279},\n+  { 8596, 0, 280},\n+  { 8656, 0, 281},\n+  { 8658, 0, 282},\n+  { 8660, 0, 283},\n+  { 8707, 0, 284},\n+  { 8712, 0, 285},\n+  { 8715, 0, 286},\n+  { 8739, 0, 287},\n+  { 8741, 0, 288},\n+  { 8764, 0, 289},\n+  { 8771, 0, 290},\n+  { 8773, 0, 291},\n+  { 8776, 0, 292},\n+  { 8781, 0, 293},\n+  { 8801, 0, 294},\n+  { 8804, 1, 295},\n+  { 8818, 1, 297},\n+  { 8822, 1, 299},\n+  { 8826, 3, 301},\n+  { 8834, 1, 305},\n+  { 8838, 1, 307},\n+  { 8849, 1, 309},\n+  { 8866, 0, 311},\n+  { 8872, 1, 312},\n+  { 8875, 0, 314},\n+  { 8882, 3, 315},\n+  { 12358, 0, 319},\n+  { 12363, 0, 320},\n+  { 12365, 0, 321},\n+  { 12367, 0, 322},\n+  { 12369, 0, 323},\n+  { 12371, 0, 324},\n+  { 12373, 0, 325},\n+  { 12375, 0, 326},\n+  { 12377, 0, 327},\n+  { 12379, 0, 328},\n+  { 12381, 0, 329},\n+  { 12383, 0, 330},\n+  { 12385, 0, 331},\n+  { 12388, 0, 332},\n+  { 12390, 0, 333},\n+  { 12392, 0, 334},\n+  { 12399, 0, 335},\n+  { 12402, 0, 336},\n+  { 12405, 0, 337},\n+  { 12408, 0, 338},\n+  { 12411, 0, 339},\n+  { 12445, 0, 340},\n+  { 12454, 0, 341},\n+  { 12459, 0, 342},\n+  { 12461, 0, 343},\n+  { 12463, 0, 344},\n+  { 12465, 0, 345},\n+  { 12467, 0, 346},\n+  { 12469, 0, 347},\n+  { 12471, 0, 348},\n+  { 12473, 0, 349},\n+  { 12475, 0, 350},\n+  { 12477, 0, 351},\n+  { 12479, 0, 352},\n+  { 12481, 0, 353},\n+  { 12484, 0, 354},\n+  { 12486, 0, 355},\n+  { 12488, 0, 356},\n+  { 12495, 0, 357},\n+  { 12498, 0, 358},\n+  { 12501, 0, 359},\n+  { 12504, 0, 360},\n+  { 12507, 0, 361},\n+  { 12527, 3, 362},\n+  { 12541, 0, 366},\n+  { 69785, 0, 367},\n+  { 69787, 0, 368},\n+  { 69797, 0, 369},\n+  { 69937, 1, 370},\n+  { 70471, 0, 372},\n+  { 70841, 0, 373},\n+  { 71096, 1, 374},\n+  {0,0,0}\n+};\n+\n+static const Reindex nfc_last[] = {\n+  { 768, 4, 0},\n+  { 774, 6, 5},\n+  { 783, 0, 12},\n+  { 785, 0, 13},\n+  { 787, 1, 14},\n+  { 795, 0, 16},\n+  { 803, 5, 17},\n+  { 813, 1, 23},\n+  { 816, 1, 25},\n+  { 824, 0, 27},\n+  { 834, 0, 28},\n+  { 837, 0, 29},\n+  { 1619, 2, 30},\n+  { 2364, 0, 33},\n+  { 2494, 0, 34},\n+  { 2519, 0, 35},\n+  { 2878, 0, 36},\n+  { 2902, 1, 37},\n+  { 3006, 0, 39},\n+  { 3031, 0, 40},\n+  { 3158, 0, 41},\n+  { 3266, 0, 42},\n+  { 3285, 1, 43},\n+  { 3390, 0, 45},\n+  { 3415, 0, 46},\n+  { 3530, 0, 47},\n+  { 3535, 0, 48},\n+  { 3551, 0, 49},\n+  { 4142, 0, 50},\n+  { 6965, 0, 51},\n+  { 12441, 1, 52},\n+  { 69818, 0, 54},\n+  { 69927, 0, 55},\n+  { 70462, 0, 56},\n+  { 70487, 0, 57},\n+  { 70832, 0, 58},\n+  { 70842, 0, 59},\n+  { 70845, 0, 60},\n+  { 71087, 0, 61},\n+  {0,0,0}\n+};\n+\n+#define UCDN_EAST_ASIAN_F 0\n+#define UCDN_EAST_ASIAN_H 1\n+#define UCDN_EAST_ASIAN_W 2\n+#define UCDN_EAST_ASIAN_NA 3\n+#define UCDN_EAST_ASIAN_A 4\n+#define UCDN_EAST_ASIAN_N 5\n+\n+#define UCDN_SCRIPT_COMMON 0\n+#define UCDN_SCRIPT_LATIN 1\n+#define UCDN_SCRIPT_GREEK 2\n+#define UCDN_SCRIPT_CYRILLIC 3\n+#define UCDN_SCRIPT_ARMENIAN 4\n+#define UCDN_SCRIPT_HEBREW 5\n+#define UCDN_SCRIPT_ARABIC 6\n+#define UCDN_SCRIPT_SYRIAC 7\n+#define UCDN_SCRIPT_THAANA 8\n+#define UCDN_SCRIPT_DEVANAGARI 9\n+#define UCDN_SCRIPT_BENGALI 10\n+#define UCDN_SCRIPT_GURMUKHI 11\n+#define UCDN_SCRIPT_GUJARATI 12\n+#define UCDN_SCRIPT_ORIYA 13\n+#define UCDN_SCRIPT_TAMIL 14\n+#define UCDN_SCRIPT_TELUGU 15\n+#define UCDN_SCRIPT_KANNADA 16\n+#define UCDN_SCRIPT_MALAYALAM 17\n+#define UCDN_SCRIPT_SINHALA 18\n+#define UCDN_SCRIPT_THAI 19\n+#define UCDN_SCRIPT_LAO 20\n+#define UCDN_SCRIPT_TIBETAN 21\n+#define UCDN_SCRIPT_MYANMAR 22\n+#define UCDN_SCRIPT_GEORGIAN 23\n+#define UCDN_SCRIPT_HANGUL 24\n+#define UCDN_SCRIPT_ETHIOPIC 25\n+#define UCDN_SCRIPT_CHEROKEE 26\n+#define UCDN_SCRIPT_CANADIAN_ABORIGINAL 27\n+#define UCDN_SCRIPT_OGHAM 28\n+#define UCDN_SCRIPT_RUNIC 29\n+#define UCDN_SCRIPT_KHMER 30\n+#define UCDN_SCRIPT_MONGOLIAN 31\n+#define UCDN_SCRIPT_HIRAGANA 32\n+#define UCDN_SCRIPT_KATAKANA 33\n+#define UCDN_SCRIPT_BOPOMOFO 34\n+#define UCDN_SCRIPT_HAN 35\n+#define UCDN_SCRIPT_YI 36\n+#define UCDN_SCRIPT_OLD_ITALIC 37\n+#define UCDN_SCRIPT_GOTHIC 38\n+#define UCDN_SCRIPT_DESERET 39\n+#define UCDN_SCRIPT_INHERITED 40\n+#define UCDN_SCRIPT_TAGALOG 41\n+#define UCDN_SCRIPT_HANUNOO 42\n+#define UCDN_SCRIPT_BUHID 43\n+#define UCDN_SCRIPT_TAGBANWA 44\n+#define UCDN_SCRIPT_LIMBU 45\n+#define UCDN_SCRIPT_TAI_LE 46\n+#define UCDN_SCRIPT_LINEAR_B 47\n+#define UCDN_SCRIPT_UGARITIC 48\n+#define UCDN_SCRIPT_SHAVIAN 49\n+#define UCDN_SCRIPT_OSMANYA 50\n+#define UCDN_SCRIPT_CYPRIOT 51\n+#define UCDN_SCRIPT_BRAILLE 52\n+#define UCDN_SCRIPT_BUGINESE 53\n+#define UCDN_SCRIPT_COPTIC 54\n+#define UCDN_SCRIPT_NEW_TAI_LUE 55\n+#define UCDN_SCRIPT_GLAGOLITIC 56\n+#define UCDN_SCRIPT_TIFINAGH 57\n+#define UCDN_SCRIPT_SYLOTI_NAGRI 58\n+#define UCDN_SCRIPT_OLD_PERSIAN 59\n+#define UCDN_SCRIPT_KHAROSHTHI 60\n+#define UCDN_SCRIPT_BALINESE 61\n+#define UCDN_SCRIPT_CUNEIFORM 62\n+#define UCDN_SCRIPT_PHOENICIAN 63\n+#define UCDN_SCRIPT_PHAGS_PA 64\n+#define UCDN_SCRIPT_NKO 65\n+#define UCDN_SCRIPT_SUNDANESE 66\n+#define UCDN_SCRIPT_LEPCHA 67\n+#define UCDN_SCRIPT_OL_CHIKI 68\n+#define UCDN_SCRIPT_VAI 69\n+#define UCDN_SCRIPT_SAURASHTRA 70\n+#define UCDN_SCRIPT_KAYAH_LI 71\n+#define UCDN_SCRIPT_REJANG 72\n+#define UCDN_SCRIPT_LYCIAN 73\n+#define UCDN_SCRIPT_CARIAN 74\n+#define UCDN_SCRIPT_LYDIAN 75\n+#define UCDN_SCRIPT_CHAM 76\n+#define UCDN_SCRIPT_TAI_THAM 77\n+#define UCDN_SCRIPT_TAI_VIET 78\n+#define UCDN_SCRIPT_AVESTAN 79\n+#define UCDN_SCRIPT_EGYPTIAN_HIEROGLYPHS 80\n+#define UCDN_SCRIPT_SAMARITAN 81\n+#define UCDN_SCRIPT_LISU 82\n+#define UCDN_SCRIPT_BAMUM 83\n+#define UCDN_SCRIPT_JAVANESE 84\n+#define UCDN_SCRIPT_MEETEI_MAYEK 85\n+#define UCDN_SCRIPT_IMPERIAL_ARAMAIC 86\n+#define UCDN_SCRIPT_OLD_SOUTH_ARABIAN 87\n+#define UCDN_SCRIPT_INSCRIPTIONAL_PARTHIAN 88\n+#define UCDN_SCRIPT_INSCRIPTIONAL_PAHLAVI 89\n+#define UCDN_SCRIPT_OLD_TURKIC 90\n+#define UCDN_SCRIPT_KAITHI 91\n+#define UCDN_SCRIPT_BATAK 92\n+#define UCDN_SCRIPT_BRAHMI 93\n+#define UCDN_SCRIPT_MANDAIC 94\n+#define UCDN_SCRIPT_CHAKMA 95\n+#define UCDN_SCRIPT_MEROITIC_CURSIVE 96\n+#define UCDN_SCRIPT_MEROITIC_HIEROGLYPHS 97\n+#define UCDN_SCRIPT_MIAO 98\n+#define UCDN_SCRIPT_SHARADA 99\n+#define UCDN_SCRIPT_SORA_SOMPENG 100\n+#define UCDN_SCRIPT_TAKRI 101\n+#define UCDN_SCRIPT_UNKNOWN 102\n+#define UCDN_SCRIPT_BASSA_VAH 103\n+#define UCDN_SCRIPT_CAUCASIAN_ALBANIAN 104\n+#define UCDN_SCRIPT_DUPLOYAN 105\n+#define UCDN_SCRIPT_ELBASAN 106\n+#define UCDN_SCRIPT_GRANTHA 107\n+#define UCDN_SCRIPT_KHOJKI 108\n+#define UCDN_SCRIPT_KHUDAWADI 109\n+#define UCDN_SCRIPT_LINEAR_A 110\n+#define UCDN_SCRIPT_MAHAJANI 111\n+#define UCDN_SCRIPT_MANICHAEAN 112\n+#define UCDN_SCRIPT_MENDE_KIKAKUI 113\n+#define UCDN_SCRIPT_MODI 114\n+#define UCDN_SCRIPT_MRO 115\n+#define UCDN_SCRIPT_NABATAEAN 116\n+#define UCDN_SCRIPT_OLD_NORTH_ARABIAN 117\n+#define UCDN_SCRIPT_OLD_PERMIC 118\n+#define UCDN_SCRIPT_PAHAWH_HMONG 119\n+#define UCDN_SCRIPT_PALMYRENE 120\n+#define UCDN_SCRIPT_PAU_CIN_HAU 121\n+#define UCDN_SCRIPT_PSALTER_PAHLAVI 122\n+#define UCDN_SCRIPT_SIDDHAM 123\n+#define UCDN_SCRIPT_TIRHUTA 124\n+#define UCDN_SCRIPT_WARANG_CITI 125\n+#define UCDN_SCRIPT_AHOM 126\n+#define UCDN_SCRIPT_ANATOLIAN_HIEROGLYPHS 127\n+#define UCDN_SCRIPT_HATRAN 128\n+#define UCDN_SCRIPT_MULTANI 129\n+#define UCDN_SCRIPT_OLD_HUNGARIAN 130\n+#define UCDN_SCRIPT_SIGNWRITING 131\n+#define UCDN_SCRIPT_ADLAM 132\n+#define UCDN_SCRIPT_BHAIKSUKI 133\n+#define UCDN_SCRIPT_MARCHEN 134\n+#define UCDN_SCRIPT_NEWA 135\n+#define UCDN_SCRIPT_OSAGE 136\n+#define UCDN_SCRIPT_TANGUT 137\n+#define UCDN_SCRIPT_MASARAM_GONDI 138\n+#define UCDN_SCRIPT_NUSHU 139\n+#define UCDN_SCRIPT_SOYOMBO 140\n+#define UCDN_SCRIPT_ZANABAZAR_SQUARE 141\n+#define UCDN_SCRIPT_DOGRA 142\n+#define UCDN_SCRIPT_GUNJALA_GONDI 143\n+#define UCDN_SCRIPT_HANIFI_ROHINGYA 144\n+#define UCDN_SCRIPT_MAKASAR 145\n+#define UCDN_SCRIPT_MEDEFAIDRIN 146\n+#define UCDN_SCRIPT_OLD_SOGDIAN 147\n+#define UCDN_SCRIPT_SOGDIAN 148\n+\n+#define UCDN_GENERAL_CATEGORY_CC 0\n+#define UCDN_GENERAL_CATEGORY_CF 1\n+#define UCDN_GENERAL_CATEGORY_CN 2\n+#define UCDN_GENERAL_CATEGORY_CO 3\n+#define UCDN_GENERAL_CATEGORY_CS 4\n+#define UCDN_GENERAL_CATEGORY_LL 5\n+#define UCDN_GENERAL_CATEGORY_LM 6\n+#define UCDN_GENERAL_CATEGORY_LO 7\n+#define UCDN_GENERAL_CATEGORY_LT 8\n+#define UCDN_GENERAL_CATEGORY_LU 9\n+#define UCDN_GENERAL_CATEGORY_MC 10\n+#define UCDN_GENERAL_CATEGORY_ME 11\n+#define UCDN_GENERAL_CATEGORY_MN 12\n+#define UCDN_GENERAL_CATEGORY_ND 13\n+#define UCDN_GENERAL_CATEGORY_NL 14\n+#define UCDN_GENERAL_CATEGORY_NO 15\n+#define UCDN_GENERAL_CATEGORY_PC 16\n+#define UCDN_GENERAL_CATEGORY_PD 17\n+#define UCDN_GENERAL_CATEGORY_PE 18\n+#define UCDN_GENERAL_CATEGORY_PF 19\n+#define UCDN_GENERAL_CATEGORY_PI 20\n+#define UCDN_GENERAL_CATEGORY_PO 21\n+#define UCDN_GENERAL_CATEGORY_PS 22\n+#define UCDN_GENERAL_CATEGORY_SC 23\n+#define UCDN_GENERAL_CATEGORY_SK 24\n+#define UCDN_GENERAL_CATEGORY_SM 25\n+#define UCDN_GENERAL_CATEGORY_SO 26\n+#define UCDN_GENERAL_CATEGORY_ZL 27\n+#define UCDN_GENERAL_CATEGORY_ZP 28\n+#define UCDN_GENERAL_CATEGORY_ZS 29\n+\n+#define UCDN_BIDI_CLASS_L 0\n+#define UCDN_BIDI_CLASS_LRE 1\n+#define UCDN_BIDI_CLASS_LRO 2\n+#define UCDN_BIDI_CLASS_R 3\n+#define UCDN_BIDI_CLASS_AL 4\n+#define UCDN_BIDI_CLASS_RLE 5\n+#define UCDN_BIDI_CLASS_RLO 6\n+#define UCDN_BIDI_CLASS_PDF 7\n+#define UCDN_BIDI_CLASS_EN 8\n+#define UCDN_BIDI_CLASS_ES 9\n+#define UCDN_BIDI_CLASS_ET 10\n+#define UCDN_BIDI_CLASS_AN 11\n+#define UCDN_BIDI_CLASS_CS 12\n+#define UCDN_BIDI_CLASS_NSM 13\n+#define UCDN_BIDI_CLASS_BN 14\n+#define UCDN_BIDI_CLASS_B 15\n+#define UCDN_BIDI_CLASS_S 16\n+#define UCDN_BIDI_CLASS_WS 17\n+#define UCDN_BIDI_CLASS_ON 18\n+#define UCDN_BIDI_CLASS_LRI 19\n+#define UCDN_BIDI_CLASS_RLI 20\n+#define UCDN_BIDI_CLASS_FSI 21\n+#define UCDN_BIDI_CLASS_PDI 22\n+\n+\/* index tables for the database records *\/\n+#define SHIFT1 5\n+#define SHIFT2 3\n+static const unsigned char index0[] = {\n+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,\n+    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38,\n+    39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 53, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 54, 55, 56, 56, 56, 57,\n+    58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 65, 66, 67, 68,\n+    69, 70, 71, 65, 66, 67, 68, 69, 70, 71, 65, 66, 67, 68, 69, 70, 71, 65,\n+    66, 67, 68, 69, 70, 71, 65, 66, 67, 68, 69, 70, 71, 65, 72, 73, 73, 73,\n+    73, 73, 73, 73, 73, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 52, 75, 76, 77, 78, 79,\n+    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97,\n+    98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 106, 108, 109, 110, 106,\n+    111, 111, 111, 112, 113, 114, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 115, 115, 116, 117, 118, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 119, 120, 121, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 122, 122, 123, 124, 106, 106, 125, 126, 127, 127, 127, 127,\n+    127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,\n+    127, 127, 127, 127, 127, 128, 127, 127, 129, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 130, 131, 132, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 133, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 134, 135, 136, 137, 138, 139,\n+    140, 141, 142, 142, 143, 106, 106, 106, 106, 106, 144, 106, 106, 106,\n+    106, 106, 106, 106, 145, 146, 106, 106, 147, 106, 148, 106, 149, 150,\n+    151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 160, 160, 160, 161, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 162, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 163, 164, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 165, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52, 52,\n+    166, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 52, 52,\n+    168, 167, 167, 167, 167, 169, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 169, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 170, 171, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106,\n+    106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 106, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    172, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74, 74,\n+    74, 74, 74, 74, 172,\n+};\n+\n+static const unsigned short index1[] = {\n+    0, 1, 0, 2, 3, 4, 5, 6, 7, 8, 8, 9, 10, 11, 11, 12, 13, 0, 0, 0, 14, 15,\n+    16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 29, 31, 32,\n+    33, 34, 35, 27, 30, 29, 27, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46,\n+    47, 48, 27, 27, 49, 27, 27, 27, 27, 27, 27, 27, 50, 51, 52, 27, 53, 54,\n+    53, 54, 54, 54, 54, 54, 55, 54, 54, 54, 56, 57, 58, 59, 60, 61, 62, 63,\n+    64, 64, 65, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 65, 77, 78,\n+    79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96,\n+    97, 97, 97, 97, 98, 98, 98, 98, 99, 100, 101, 101, 101, 101, 102, 103,\n+    101, 101, 101, 101, 101, 101, 104, 105, 101, 101, 101, 101, 101, 101,\n+    101, 101, 101, 101, 101, 101, 106, 107, 107, 107, 108, 109, 110, 110,\n+    110, 110, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 120,\n+    120, 121, 122, 119, 123, 124, 125, 126, 127, 127, 127, 127, 128, 129,\n+    130, 131, 132, 133, 134, 127, 127, 127, 127, 127, 127, 127, 127, 127,\n+    127, 127, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 144, 144,\n+    145, 146, 147, 148, 127, 127, 127, 127, 127, 127, 149, 149, 149, 149,\n+    150, 151, 152, 119, 153, 154, 155, 155, 155, 156, 157, 158, 159, 159,\n+    160, 161, 162, 163, 164, 165, 166, 166, 166, 167, 144, 168, 119, 119,\n+    119, 119, 119, 119, 127, 127, 169, 170, 119, 119, 171, 125, 172, 173,\n+    174, 175, 176, 177, 177, 177, 177, 177, 177, 178, 179, 180, 181, 177,\n+    182, 183, 184, 177, 185, 186, 187, 188, 188, 189, 190, 191, 192, 193,\n+    194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 203, 204, 205, 206,\n+    207, 208, 209, 210, 211, 212, 213, 119, 214, 215, 216, 217, 217, 218,\n+    219, 220, 221, 222, 223, 119, 224, 225, 226, 227, 228, 229, 230, 231,\n+    231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 119, 242, 243,\n+    244, 245, 246, 243, 247, 248, 249, 250, 251, 119, 252, 253, 254, 255,\n+    256, 257, 258, 259, 259, 258, 259, 260, 261, 262, 263, 264, 265, 266,\n+    119, 267, 268, 269, 270, 271, 271, 270, 272, 273, 274, 275, 276, 277,\n+    278, 279, 280, 119, 281, 282, 283, 284, 284, 284, 284, 285, 286, 287,\n+    288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 295, 295, 298, 299,\n+    296, 300, 301, 302, 303, 304, 305, 119, 306, 307, 307, 307, 307, 307,\n+    308, 309, 310, 311, 312, 313, 119, 119, 119, 119, 314, 315, 316, 317,\n+    318, 319, 320, 321, 322, 323, 324, 325, 119, 119, 119, 119, 326, 327,\n+    328, 329, 330, 331, 332, 333, 334, 335, 334, 334, 334, 336, 337, 338,\n+    339, 340, 341, 342, 341, 341, 341, 343, 344, 345, 346, 347, 119, 119,\n+    119, 119, 348, 348, 348, 348, 348, 349, 350, 351, 352, 353, 354, 355,\n+    356, 357, 358, 348, 359, 360, 352, 361, 362, 362, 362, 362, 363, 364,\n+    365, 365, 365, 365, 365, 366, 367, 367, 367, 367, 367, 367, 367, 367,\n+    367, 367, 367, 367, 368, 368, 368, 368, 368, 368, 368, 368, 368, 369,\n+    369, 369, 369, 369, 369, 369, 369, 369, 369, 369, 370, 370, 370, 370,\n+    370, 370, 370, 370, 370, 371, 372, 371, 370, 370, 370, 370, 370, 371,\n+    370, 370, 370, 370, 371, 372, 371, 370, 372, 370, 370, 370, 370, 370,\n+    370, 370, 371, 370, 370, 370, 370, 370, 370, 370, 370, 373, 374, 375,\n+    376, 377, 370, 370, 378, 379, 380, 380, 380, 380, 380, 380, 380, 380,\n+    380, 380, 381, 382, 383, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n+    384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n+    384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n+    384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n+    384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384,\n+    384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 384, 385, 384, 384,\n+    386, 387, 387, 388, 389, 389, 389, 389, 389, 389, 389, 389, 389, 390,\n+    391, 392, 393, 394, 395, 119, 396, 396, 397, 119, 398, 398, 399, 119,\n+    400, 401, 402, 119, 403, 403, 403, 403, 403, 403, 404, 405, 406, 407,\n+    408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 418, 418, 418,\n+    419, 418, 418, 418, 418, 418, 418, 420, 421, 418, 418, 418, 418, 422,\n+    384, 384, 384, 384, 384, 384, 384, 384, 423, 119, 424, 424, 424, 425,\n+    426, 427, 428, 429, 430, 431, 432, 432, 432, 433, 434, 119, 435, 435,\n+    435, 435, 435, 436, 435, 435, 435, 437, 438, 439, 440, 440, 440, 440,\n+    441, 441, 442, 443, 444, 444, 444, 444, 444, 444, 445, 446, 447, 448,\n+    449, 450, 451, 452, 451, 452, 453, 454, 455, 456, 119, 119, 119, 119,\n+    119, 119, 119, 119, 457, 458, 458, 458, 458, 458, 459, 460, 461, 462,\n+    463, 464, 465, 466, 467, 468, 469, 470, 470, 470, 471, 472, 473, 474,\n+    475, 475, 475, 475, 476, 477, 478, 479, 480, 480, 480, 480, 481, 482,\n+    483, 484, 485, 486, 487, 488, 489, 489, 489, 490, 100, 491, 362, 362,\n+    362, 362, 362, 492, 493, 119, 494, 495, 496, 497, 498, 499, 54, 54, 54,\n+    54, 500, 501, 56, 56, 56, 56, 56, 502, 503, 504, 54, 505, 54, 54, 54,\n+    506, 56, 56, 56, 507, 508, 509, 510, 511, 511, 511, 512, 513, 27, 27, 27,\n+    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 514, 515, 27,\n+    27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 516, 517, 518, 519, 516, 517,\n+    516, 517, 518, 519, 516, 520, 516, 517, 516, 518, 516, 521, 516, 521,\n+    516, 521, 522, 523, 524, 525, 526, 527, 516, 528, 529, 530, 531, 532,\n+    533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546,\n+    547, 548, 56, 549, 550, 551, 552, 553, 554, 554, 555, 556, 557, 558, 559,\n+    119, 560, 561, 562, 563, 564, 565, 566, 567, 568, 569, 570, 571, 572,\n+    573, 572, 574, 575, 576, 577, 578, 579, 580, 581, 582, 581, 583, 584,\n+    581, 585, 581, 586, 587, 588, 589, 590, 591, 592, 593, 594, 595, 587,\n+    596, 597, 587, 598, 599, 587, 587, 599, 587, 600, 601, 600, 587, 587,\n+    602, 587, 587, 587, 587, 587, 603, 587, 587, 581, 604, 605, 606, 607,\n+    608, 609, 610, 610, 610, 610, 610, 610, 610, 610, 611, 581, 581, 612,\n+    613, 587, 587, 614, 581, 581, 581, 581, 586, 607, 615, 616, 581, 581,\n+    581, 581, 581, 617, 119, 119, 119, 581, 618, 119, 119, 619, 619, 619,\n+    619, 619, 620, 620, 621, 622, 622, 622, 622, 622, 622, 622, 622, 622,\n+    623, 619, 624, 625, 625, 625, 625, 625, 625, 625, 625, 625, 626, 625,\n+    625, 625, 625, 627, 581, 625, 625, 628, 581, 629, 630, 631, 632, 633,\n+    634, 630, 581, 628, 635, 581, 636, 637, 638, 639, 640, 581, 581, 581,\n+    641, 642, 643, 644, 581, 645, 646, 581, 647, 581, 581, 648, 649, 650,\n+    651, 581, 652, 653, 654, 655, 656, 657, 658, 659, 660, 661, 662, 581,\n+    581, 581, 663, 581, 664, 581, 665, 666, 667, 668, 669, 670, 619, 671,\n+    671, 672, 581, 581, 581, 663, 673, 674, 587, 587, 587, 675, 676, 587,\n+    587, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677,\n+    677, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677, 677,\n+    677, 677, 677, 677, 677, 587, 587, 587, 587, 587, 587, 587, 587, 587,\n+    587, 587, 587, 587, 587, 587, 587, 678, 679, 679, 680, 587, 587, 587,\n+    587, 587, 587, 587, 681, 587, 587, 587, 682, 587, 587, 587, 587, 587,\n+    587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587,\n+    587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 581,\n+    581, 581, 683, 581, 581, 587, 587, 684, 685, 686, 630, 581, 581, 687,\n+    581, 581, 581, 688, 581, 581, 581, 581, 581, 581, 689, 581, 581, 581,\n+    581, 581, 617, 690, 690, 690, 690, 690, 691, 692, 692, 692, 692, 692,\n+    693, 694, 695, 696, 697, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92, 92,\n+    698, 699, 700, 701, 365, 365, 365, 365, 702, 703, 704, 704, 704, 704,\n+    704, 704, 704, 705, 706, 707, 370, 370, 372, 119, 372, 372, 372, 372,\n+    372, 372, 372, 372, 708, 708, 708, 708, 709, 710, 711, 712, 713, 714,\n+    715, 716, 717, 718, 119, 119, 119, 119, 119, 119, 719, 719, 719, 720,\n+    719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 721, 119, 719, 719,\n+    719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 719,\n+    719, 719, 719, 719, 719, 719, 719, 719, 719, 719, 722, 119, 119, 119,\n+    723, 724, 725, 726, 727, 728, 729, 730, 731, 732, 733, 734, 735, 735,\n+    736, 735, 735, 735, 737, 738, 739, 740, 741, 742, 743, 743, 744, 743,\n+    743, 743, 745, 746, 747, 748, 749, 750, 750, 750, 750, 750, 751, 752,\n+    752, 752, 752, 752, 752, 752, 752, 752, 752, 753, 754, 755, 750, 750,\n+    750, 756, 723, 723, 723, 723, 724, 119, 757, 757, 758, 758, 758, 759,\n+    760, 761, 755, 755, 755, 762, 763, 764, 758, 758, 758, 765, 760, 761,\n+    755, 755, 755, 755, 766, 764, 755, 767, 768, 768, 768, 768, 768, 769,\n+    768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 768, 755, 755, 755,\n+    770, 771, 755, 755, 755, 755, 755, 755, 755, 755, 755, 755, 755, 772,\n+    755, 755, 755, 770, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 774, 775, 581, 581, 581, 581, 581, 581, 581, 581, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    775, 775, 776, 776, 777, 776, 776, 776, 776, 776, 776, 776, 776, 776,\n+    776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776,\n+    776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776,\n+    776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776,\n+    776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776,\n+    776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 776, 778,\n+    779, 779, 779, 779, 779, 779, 780, 119, 781, 781, 781, 781, 781, 782,\n+    783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783,\n+    783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783, 783,\n+    783, 783, 783, 783, 783, 784, 783, 783, 785, 786, 119, 119, 101, 101,\n+    101, 101, 101, 787, 788, 789, 101, 101, 101, 790, 791, 791, 791, 791,\n+    791, 791, 791, 791, 792, 793, 794, 119, 64, 64, 795, 796, 797, 27, 798,\n+    27, 27, 27, 27, 27, 27, 27, 799, 800, 27, 801, 802, 27, 27, 803, 804,\n+    805, 119, 119, 119, 119, 119, 119, 806, 807, 808, 809, 810, 810, 811,\n+    812, 813, 814, 815, 815, 815, 815, 815, 815, 816, 119, 817, 818, 818,\n+    818, 818, 818, 819, 820, 821, 822, 823, 824, 825, 825, 826, 827, 828,\n+    829, 830, 830, 831, 832, 833, 833, 834, 835, 836, 837, 367, 367, 367,\n+    838, 839, 840, 840, 840, 840, 840, 841, 842, 843, 844, 845, 846, 847,\n+    348, 352, 848, 849, 849, 849, 849, 849, 850, 851, 119, 852, 853, 854,\n+    855, 348, 348, 856, 857, 858, 858, 858, 858, 858, 858, 859, 860, 861,\n+    119, 119, 862, 863, 864, 865, 119, 866, 866, 866, 119, 372, 372, 54, 54,\n+    54, 54, 54, 867, 868, 119, 869, 869, 869, 869, 869, 869, 869, 869, 869,\n+    869, 863, 863, 863, 863, 870, 871, 872, 873, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875, 875, 876, 875,\n+    875, 875, 874, 875, 875, 876, 875, 875, 875, 875, 875, 875, 874, 875,\n+    875, 876, 875, 875, 875, 874, 875, 875, 876, 875, 875, 875, 874, 875,\n+    875, 877, 119, 368, 368, 878, 879, 369, 369, 369, 369, 369, 880, 881,\n+    881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881,\n+    881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881, 881,\n+    881, 881, 881, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882,\n+    882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882,\n+    882, 882, 882, 882, 882, 882, 882, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 774, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 883, 775, 775, 775, 775, 884, 119, 885,\n+    886, 120, 887, 888, 889, 890, 120, 127, 127, 127, 127, 127, 127, 127,\n+    127, 127, 127, 127, 127, 891, 892, 893, 119, 894, 127, 127, 127, 127,\n+    127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,\n+    127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127,\n+    127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 895, 119,\n+    119, 127, 127, 127, 127, 127, 127, 127, 127, 896, 127, 127, 127, 127,\n+    127, 127, 119, 119, 119, 119, 119, 127, 897, 898, 898, 899, 900, 901,\n+    902, 903, 904, 905, 906, 907, 908, 909, 910, 169, 127, 127, 127, 127,\n+    127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 127, 911, 912,\n+    913, 914, 915, 916, 917, 917, 918, 919, 920, 920, 921, 922, 923, 924,\n+    925, 925, 925, 925, 926, 927, 927, 927, 928, 929, 929, 929, 930, 931,\n+    932, 119, 933, 934, 935, 934, 934, 936, 934, 934, 937, 934, 938, 934,\n+    938, 119, 119, 119, 119, 934, 934, 934, 934, 934, 934, 934, 934, 934,\n+    934, 934, 934, 934, 934, 934, 939, 940, 941, 941, 941, 941, 941, 942,\n+    610, 943, 943, 943, 943, 943, 943, 944, 945, 946, 947, 581, 948, 949,\n+    119, 119, 119, 119, 119, 610, 610, 610, 610, 610, 950, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 951,\n+    951, 951, 952, 953, 953, 953, 953, 953, 953, 954, 119, 955, 956, 956,\n+    957, 958, 958, 958, 958, 959, 960, 961, 961, 962, 963, 964, 964, 964,\n+    964, 965, 966, 967, 967, 967, 968, 969, 969, 969, 969, 970, 969, 971,\n+    119, 119, 119, 119, 119, 972, 972, 972, 972, 972, 973, 973, 973, 973,\n+    973, 974, 974, 974, 974, 974, 974, 975, 975, 975, 976, 977, 978, 979,\n+    979, 979, 979, 980, 981, 981, 981, 981, 982, 983, 983, 983, 983, 983,\n+    119, 984, 984, 984, 984, 984, 984, 985, 986, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 987,\n+    987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987,\n+    987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987, 987,\n+    987, 987, 987, 987, 987, 987, 987, 987, 987, 988, 119, 987, 987, 989,\n+    119, 987, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 990, 991, 992, 992, 992, 992, 993,\n+    994, 995, 995, 996, 997, 998, 998, 999, 1000, 1001, 1001, 1001, 1002,\n+    1003, 1004, 119, 119, 119, 119, 119, 119, 1005, 1005, 1006, 1007, 1008,\n+    1008, 1009, 1010, 1011, 1011, 1011, 1012, 119, 119, 119, 119, 119, 119,\n+    119, 119, 1013, 1013, 1013, 1013, 1014, 1014, 1014, 1015, 1016, 1016,\n+    1017, 1016, 1016, 1016, 1016, 1016, 1018, 1019, 1020, 1021, 1022, 1022,\n+    1023, 1024, 1025, 1026, 1027, 1028, 1029, 1029, 1029, 1030, 1031, 1031,\n+    1031, 1032, 119, 119, 119, 119, 1033, 1034, 1033, 1033, 1035, 1036, 1037,\n+    119, 1038, 1038, 1038, 1038, 1038, 1038, 1039, 1040, 1041, 1041, 1042,\n+    1043, 1044, 1044, 1045, 1046, 1047, 1047, 1048, 1049, 119, 1050, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 1051, 1051, 1051, 1051,\n+    1051, 1051, 1051, 1051, 1051, 1052, 119, 119, 119, 119, 119, 119, 1053,\n+    1053, 1053, 1053, 1053, 1053, 1054, 119, 1055, 1055, 1055, 1055, 1055,\n+    1055, 1056, 1057, 1058, 1058, 1058, 1058, 1059, 119, 1060, 1061, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 1062, 1062, 1062, 1063, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 1064,\n+    1064, 1064, 1065, 1066, 119, 1067, 1067, 1068, 1069, 1070, 1071, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 1072, 1073, 1073, 1073, 1073, 1073, 1073, 1074,\n+    1075, 1076, 1077, 1078, 1079, 1080, 119, 1081, 1082, 1083, 1083, 1083,\n+    1083, 1083, 1084, 1085, 1086, 1087, 1088, 1088, 1088, 1089, 1090, 1091,\n+    1092, 1093, 1093, 1093, 1094, 1095, 1096, 1097, 1098, 119, 1099, 1099,\n+    1099, 1099, 1100, 119, 1101, 1102, 1102, 1102, 1102, 1102, 1103, 1104,\n+    1105, 1106, 1107, 1108, 1109, 1110, 1111, 119, 1112, 1112, 1113, 1112,\n+    1112, 1114, 1115, 1116, 119, 119, 119, 119, 119, 119, 119, 119, 1117,\n+    1118, 1119, 1120, 1119, 1121, 1122, 1122, 1122, 1122, 1122, 1123, 1124,\n+    1125, 1126, 1127, 1128, 1129, 1130, 1131, 1131, 1132, 1133, 1134, 1135,\n+    1136, 1137, 1138, 1139, 1140, 1140, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 1141, 1141, 1141, 1141,\n+    1141, 1141, 1142, 1143, 1144, 1145, 1146, 1147, 119, 119, 119, 119, 1148,\n+    1148, 1148, 1148, 1148, 1148, 1149, 1150, 1151, 119, 1152, 1153, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 1154, 1154, 1154, 1154, 1154, 1155, 1156, 1157,\n+    1158, 1159, 1160, 1161, 119, 119, 119, 119, 1162, 1162, 1162, 1162, 1162,\n+    1162, 1163, 1164, 1165, 119, 1166, 1167, 1168, 1169, 119, 119, 1170,\n+    1170, 1170, 1170, 1170, 1171, 1172, 119, 1173, 1174, 119, 119, 119, 119,\n+    119, 119, 1175, 1175, 1175, 1176, 1177, 1178, 1179, 1180, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 1181, 1181, 1181, 1181, 1181, 1182,\n+    1183, 1184, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    1185, 1185, 1185, 1185, 1186, 1186, 1186, 1186, 1187, 1188, 1189, 1190,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 1191, 1192, 1193, 1193, 1193, 1193, 1194, 1195, 1196,\n+    119, 1197, 1198, 1199, 1199, 1199, 1199, 1200, 1201, 1202, 1203, 1204,\n+    119, 119, 119, 1205, 1205, 1205, 1205, 1205, 1205, 1205, 1206, 1207,\n+    1208, 1207, 1207, 1207, 1209, 1210, 1211, 1212, 119, 1213, 1214, 1215,\n+    1216, 1217, 1218, 1218, 1218, 1219, 1220, 1220, 1221, 1222, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 1223, 1224, 1225, 1225, 1225, 1225,\n+    1226, 1227, 1228, 119, 1229, 1230, 1231, 1232, 1233, 1233, 1233, 1234,\n+    1235, 1236, 1237, 1238, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    1239, 1239, 1240, 1241, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242,\n+    1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242,\n+    1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242,\n+    1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242,\n+    1242, 1242, 1242, 1242, 1242, 1242, 1242, 1243, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 1244, 1244, 1244, 1244, 1244, 1244,\n+    1244, 1244, 1244, 1244, 1244, 1244, 1244, 1245, 1246, 119, 1242, 1242,\n+    1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242,\n+    1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1242, 1247, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 1248, 1248, 1248, 1248, 1248,\n+    1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248,\n+    1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248,\n+    1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248,\n+    1248, 1248, 1249, 1248, 1248, 1248, 1248, 1250, 1251, 1248, 1248, 1248,\n+    1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248,\n+    1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248,\n+    1248, 1248, 1252, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248,\n+    1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248, 1248,\n+    1253, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 1254,\n+    1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+    1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+    1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+    1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254,\n+    1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1255, 1254, 1254, 1254,\n+    1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1254, 1256,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 791, 791, 791, 791, 791,\n+    791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791,\n+    791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791, 791,\n+    791, 791, 791, 791, 791, 791, 1257, 1258, 1258, 1258, 1259, 1260, 1261,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 1262, 1262,\n+    1262, 1263, 1264, 119, 1265, 1265, 1265, 1265, 1265, 1265, 1266, 1267,\n+    1268, 119, 1269, 1270, 1271, 1265, 1265, 1272, 1265, 1265, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 1273, 1273, 1273, 1273, 1274, 1274, 1274, 1274,\n+    1275, 1275, 1276, 1277, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1278, 1279, 119,\n+    1280, 1281, 1281, 1281, 1281, 1282, 119, 1283, 1284, 1285, 119, 119, 119,\n+    119, 119, 119, 119, 119, 1286, 119, 119, 119, 1287, 1287, 1287, 1287,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1288, 119,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287, 1287,\n+    1287, 1287, 1287, 1287, 1287, 1287, 1289, 119, 1290, 735, 735, 735, 735,\n+    735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735,\n+    735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735, 735,\n+    735, 735, 1291, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 1292,\n+    1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292,\n+    1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292,\n+    1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292,\n+    1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292, 1292,\n+    1293, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294, 1294,\n+    1294, 1294, 1295, 1294, 1296, 1294, 1297, 1294, 1298, 1299, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 610, 610, 610, 610, 610,\n+    610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610,\n+    610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 610, 1300, 119, 610,\n+    610, 610, 610, 1301, 1302, 610, 610, 610, 610, 610, 610, 1303, 1304,\n+    1305, 1306, 1307, 1308, 610, 610, 610, 1309, 610, 610, 610, 610, 610,\n+    610, 610, 1310, 119, 119, 946, 946, 946, 946, 946, 946, 946, 946, 1311,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 941, 941, 1312, 119, 581, 581, 581, 581, 581,\n+    581, 581, 581, 581, 581, 617, 119, 941, 941, 941, 1313, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 1314,\n+    1314, 1314, 1315, 1316, 1316, 1317, 1314, 1314, 1318, 1319, 1316, 1316,\n+    1314, 1314, 1314, 1315, 1316, 1316, 1320, 1321, 1322, 1318, 1323, 1324,\n+    1316, 1314, 1314, 1314, 1315, 1316, 1316, 1325, 1326, 1327, 1328, 1316,\n+    1316, 1316, 1329, 1330, 1331, 1332, 1316, 1316, 1317, 1314, 1314, 1318,\n+    1316, 1316, 1316, 1314, 1314, 1314, 1315, 1316, 1316, 1317, 1314, 1314,\n+    1318, 1316, 1316, 1316, 1314, 1314, 1314, 1315, 1316, 1316, 1317, 1314,\n+    1314, 1318, 1316, 1316, 1316, 1314, 1314, 1314, 1315, 1316, 1316, 1333,\n+    1314, 1314, 1314, 1334, 1316, 1316, 1335, 1336, 1314, 1314, 1337, 1316,\n+    1316, 1338, 1317, 1314, 1314, 1339, 1316, 1316, 1340, 1341, 1314, 1314,\n+    1342, 1316, 1316, 1316, 1343, 1314, 1314, 1314, 1334, 1316, 1316, 1335,\n+    1344, 1345, 1345, 1345, 1345, 1345, 1345, 1346, 1346, 1346, 1346, 1346,\n+    1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346,\n+    1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346, 1346,\n+    1346, 1346, 1346, 1347, 1347, 1347, 1347, 1347, 1347, 1348, 1349, 1347,\n+    1347, 1347, 1347, 1347, 1350, 1351, 1346, 1352, 1353, 119, 1354, 1355,\n+    1347, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 1356, 1357, 1357,\n+    1358, 1359, 1360, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361,\n+    1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361, 1361,\n+    1361, 1362, 1363, 1364, 119, 119, 119, 119, 119, 1365, 1365, 1365, 1365,\n+    1366, 1367, 1367, 1367, 1368, 1369, 1370, 1371, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 1372, 1373, 1373, 1373, 1373, 1373, 1373, 1374, 1375, 119, 119, 119,\n+    119, 119, 119, 119, 119, 119, 1376, 127, 127, 127, 1377, 1378, 1379,\n+    1380, 1381, 1382, 1377, 1383, 1377, 1379, 1379, 1384, 127, 1385, 127,\n+    1386, 1387, 1385, 127, 1386, 119, 119, 119, 119, 119, 119, 1388, 119,\n+    1389, 1390, 1390, 1390, 1390, 1391, 1390, 1390, 1390, 1390, 1390, 1390,\n+    1390, 1390, 1390, 1390, 1390, 1390, 1391, 1392, 1390, 1393, 1394, 1390,\n+    1394, 1395, 1394, 1390, 1390, 1390, 1396, 1392, 620, 1397, 622, 622, 622,\n+    1398, 622, 622, 622, 622, 622, 622, 622, 1399, 622, 622, 622, 1400, 1401,\n+    1402, 622, 1403, 1392, 1392, 1392, 1392, 1392, 1392, 1404, 1405, 1405,\n+    1405, 1406, 1392, 755, 755, 755, 755, 755, 1407, 755, 1408, 1409, 1392,\n+    1410, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 723, 723, 723, 723, 1411,\n+    1412, 1413, 723, 723, 723, 723, 723, 723, 723, 723, 1414, 1415, 723,\n+    1416, 1417, 723, 723, 1418, 1419, 1420, 1421, 1416, 1390, 723, 723, 1422,\n+    1423, 723, 723, 723, 723, 723, 723, 723, 1424, 1425, 1426, 1427, 723,\n+    1428, 1429, 1426, 1430, 1431, 723, 723, 723, 1432, 1433, 1434, 723, 723,\n+    723, 723, 723, 723, 723, 723, 1435, 1436, 723, 1437, 643, 1438, 723,\n+    1439, 1440, 581, 1441, 723, 723, 723, 1390, 1442, 1443, 1390, 1390, 1444,\n+    1390, 1389, 1390, 1390, 1390, 1390, 1390, 1445, 1446, 1390, 1390, 1445,\n+    1447, 723, 723, 723, 723, 723, 723, 723, 723, 1448, 1449, 581, 581, 581,\n+    581, 1450, 1451, 723, 723, 723, 723, 1452, 723, 1453, 723, 1454, 1455,\n+    1456, 1392, 1390, 1457, 1458, 1459, 581, 581, 581, 581, 581, 581, 581,\n+    581, 581, 581, 581, 581, 581, 581, 1460, 1392, 581, 581, 581, 581, 581,\n+    581, 581, 581, 581, 581, 1461, 1462, 1392, 1392, 1392, 1392, 581, 1460,\n+    581, 581, 581, 581, 581, 581, 581, 1392, 581, 1463, 581, 581, 581, 581,\n+    581, 1392, 581, 581, 581, 1464, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 581, 1460, 723, 1465, 1466, 723, 1426, 1467, 723, 723,\n+    723, 723, 723, 723, 1468, 1469, 723, 723, 723, 723, 1470, 1392, 1471,\n+    1472, 1470, 1392, 1473, 1474, 723, 723, 723, 723, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1390, 1396, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392, 1392,\n+    1392, 1392, 1392, 1392, 1392, 1392, 1392, 1475, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 1476, 775, 775, 775, 775, 775, 773,\n+    773, 773, 773, 773, 773, 1477, 775, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 774, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 883,\n+    775, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773,\n+    773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 773, 1478, 775, 775,\n+    775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775,\n+    775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775,\n+    775, 775, 775, 775, 775, 773, 773, 773, 774, 775, 775, 775, 775, 775,\n+    775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775,\n+    775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775,\n+    775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775,\n+    775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 775, 1479, 1480,\n+    119, 119, 119, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481, 1481,\n+    1481, 1481, 1481, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119, 119,\n+    119, 119, 119, 119, 119, 898, 898, 898, 898, 898, 898, 898, 898, 898,\n+    898, 898, 898, 898, 898, 898, 898, 898, 898, 898, 898, 898, 898, 898,\n+    898, 898, 898, 898, 898, 898, 898, 119, 119, 882, 882, 882, 882, 882,\n+    882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882,\n+    882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 882, 1482,\n+};\n+\n+static const unsigned short index2[] = {\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 3, 4, 5, 6, 1, 1, 1, 1, 1, 1, 7, 7, 7, 8,\n+    9, 10, 11, 12, 13, 14, 15, 11, 16, 17, 15, 18, 19, 20, 19, 21, 22, 22,\n+    22, 22, 22, 22, 22, 22, 22, 22, 19, 23, 24, 24, 24, 10, 15, 25, 25, 25,\n+    25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 16, 26, 17,\n+    27, 28, 27, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,\n+    29, 29, 29, 16, 30, 31, 24, 1, 1, 1, 1, 1, 1, 32, 1, 1, 33, 34, 35, 13,\n+    36, 13, 37, 38, 39, 40, 41, 42, 24, 43, 44, 27, 45, 46, 47, 47, 48, 49,\n+    38, 38, 39, 47, 41, 50, 51, 51, 51, 34, 52, 52, 52, 52, 52, 52, 53, 52,\n+    52, 52, 52, 52, 52, 52, 52, 52, 53, 52, 52, 52, 52, 52, 52, 54, 53, 52,\n+    52, 52, 52, 52, 53, 55, 55, 55, 56, 56, 56, 56, 55, 56, 55, 55, 55, 56,\n+    55, 55, 56, 56, 55, 56, 55, 55, 56, 56, 56, 54, 55, 55, 55, 56, 55, 56,\n+    55, 56, 52, 55, 52, 56, 52, 56, 52, 56, 52, 56, 52, 56, 52, 56, 52, 56,\n+    52, 55, 52, 55, 52, 56, 52, 56, 52, 56, 52, 55, 52, 56, 52, 56, 52, 56,\n+    52, 56, 52, 56, 53, 55, 52, 55, 53, 55, 52, 56, 52, 56, 55, 52, 56, 52,\n+    56, 52, 56, 53, 55, 53, 55, 52, 55, 52, 56, 52, 55, 55, 53, 55, 52, 55,\n+    52, 56, 52, 56, 53, 55, 52, 56, 52, 56, 52, 52, 56, 52, 56, 52, 56, 56,\n+    56, 52, 52, 56, 52, 56, 52, 52, 56, 52, 52, 52, 56, 56, 52, 52, 52, 52,\n+    56, 52, 52, 56, 52, 52, 52, 56, 56, 56, 52, 52, 56, 52, 52, 56, 52, 56,\n+    52, 56, 52, 52, 56, 52, 56, 56, 52, 56, 52, 52, 56, 52, 52, 52, 56, 52,\n+    56, 52, 52, 56, 56, 57, 52, 56, 56, 56, 57, 57, 57, 57, 52, 58, 56, 52,\n+    58, 56, 52, 58, 56, 52, 55, 52, 55, 52, 55, 52, 55, 52, 55, 52, 55, 52,\n+    55, 52, 55, 56, 52, 56, 56, 52, 58, 56, 52, 56, 52, 52, 52, 56, 52, 56,\n+    56, 56, 56, 56, 56, 56, 52, 52, 56, 52, 52, 56, 56, 52, 56, 52, 52, 52,\n+    52, 56, 56, 55, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56, 56,\n+    56, 56, 56, 56, 57, 56, 56, 56, 59, 59, 59, 59, 59, 59, 59, 59, 59, 60,\n+    60, 61, 61, 61, 61, 61, 61, 61, 62, 62, 63, 62, 60, 64, 65, 64, 64, 64,\n+    65, 64, 60, 60, 66, 61, 62, 62, 62, 62, 62, 62, 39, 39, 39, 39, 62, 39,\n+    62, 48, 59, 59, 59, 59, 59, 62, 62, 62, 62, 62, 67, 67, 60, 62, 61, 62,\n+    62, 62, 62, 62, 62, 62, 62, 62, 68, 68, 68, 68, 68, 68, 68, 68, 68, 68,\n+    68, 68, 68, 69, 70, 70, 70, 70, 69, 71, 70, 70, 70, 70, 70, 72, 72, 70,\n+    70, 70, 70, 72, 72, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 73, 73,\n+    73, 73, 73, 70, 70, 70, 70, 68, 68, 68, 68, 68, 68, 68, 68, 74, 68, 70,\n+    70, 70, 68, 68, 68, 70, 70, 75, 68, 68, 68, 70, 70, 70, 70, 68, 69, 70,\n+    70, 68, 76, 77, 77, 76, 77, 77, 76, 68, 68, 68, 68, 68, 78, 79, 78, 79,\n+    60, 80, 78, 79, 81, 81, 82, 79, 79, 79, 83, 78, 81, 81, 81, 81, 80, 62,\n+    78, 84, 78, 78, 78, 81, 78, 81, 78, 78, 79, 85, 85, 85, 85, 85, 85, 85,\n+    85, 85, 85, 85, 85, 85, 85, 85, 85, 85, 81, 85, 85, 85, 85, 85, 85, 85,\n+    78, 78, 79, 79, 79, 79, 79, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86, 86,\n+    86, 86, 86, 86, 86, 86, 79, 86, 86, 86, 86, 86, 86, 86, 79, 79, 79, 79,\n+    79, 78, 79, 79, 78, 78, 78, 79, 79, 79, 78, 79, 78, 79, 78, 79, 78, 79,\n+    78, 79, 87, 88, 87, 88, 87, 88, 87, 88, 87, 88, 87, 88, 87, 88, 79, 79,\n+    79, 79, 78, 79, 89, 78, 79, 78, 78, 79, 79, 78, 78, 78, 90, 91, 90, 90,\n+    90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 90, 91, 91, 91, 91, 91, 91,\n+    91, 91, 92, 92, 92, 92, 92, 92, 92, 92, 93, 92, 93, 93, 93, 93, 93, 93,\n+    93, 93, 93, 93, 93, 93, 93, 93, 90, 93, 90, 93, 90, 93, 90, 93, 90, 93,\n+    94, 95, 95, 96, 96, 95, 97, 97, 90, 93, 90, 93, 90, 93, 90, 90, 93, 90,\n+    93, 90, 93, 90, 93, 90, 93, 90, 93, 90, 93, 93, 81, 98, 98, 98, 98, 98,\n+    98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 98, 81,\n+    81, 99, 100, 100, 100, 100, 100, 100, 101, 101, 101, 101, 101, 101, 101,\n+    101, 101, 102, 103, 81, 81, 104, 104, 105, 81, 106, 107, 107, 107, 107,\n+    106, 107, 107, 107, 108, 106, 107, 107, 107, 107, 107, 107, 106, 106,\n+    106, 106, 106, 106, 107, 107, 106, 107, 107, 108, 109, 107, 110, 111,\n+    112, 113, 114, 115, 116, 117, 118, 119, 119, 120, 121, 122, 123, 124,\n+    125, 126, 127, 125, 107, 106, 128, 118, 81, 81, 81, 81, 81, 81, 81, 81,\n+    129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 81, 81, 81, 81,\n+    129, 129, 129, 129, 125, 125, 81, 81, 81, 130, 130, 130, 130, 130, 131,\n+    132, 132, 133, 134, 134, 135, 136, 137, 138, 138, 139, 139, 139, 139,\n+    139, 139, 139, 139, 140, 141, 142, 143, 144, 81, 145, 143, 146, 146, 146,\n+    146, 146, 146, 146, 146, 147, 146, 146, 146, 146, 146, 146, 146, 146,\n+    146, 146, 148, 149, 150, 151, 152, 153, 154, 155, 96, 96, 156, 157, 139,\n+    139, 139, 139, 139, 157, 139, 139, 157, 158, 158, 158, 158, 158, 158,\n+    158, 158, 158, 158, 134, 159, 159, 160, 146, 146, 161, 146, 146, 146,\n+    146, 146, 146, 146, 146, 146, 146, 146, 145, 146, 139, 139, 139, 139,\n+    139, 139, 139, 131, 138, 139, 139, 139, 139, 157, 139, 162, 162, 139,\n+    139, 138, 157, 139, 139, 157, 146, 146, 163, 163, 163, 163, 163, 163,\n+    163, 163, 163, 163, 146, 146, 146, 164, 164, 146, 165, 165, 165, 165,\n+    165, 165, 165, 165, 165, 165, 165, 165, 165, 165, 81, 166, 167, 168, 167,\n+    167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 167, 169,\n+    170, 169, 169, 170, 169, 169, 170, 170, 170, 169, 170, 170, 169, 170,\n+    169, 169, 169, 170, 169, 170, 169, 170, 169, 170, 169, 169, 81, 81, 167,\n+    167, 167, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171, 171,\n+    171, 171, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 172, 171, 81,\n+    81, 81, 81, 81, 81, 173, 173, 173, 173, 173, 173, 173, 173, 173, 173,\n+    174, 174, 174, 174, 174, 174, 174, 174, 174, 174, 174, 174, 174, 174,\n+    174, 174, 174, 175, 175, 175, 175, 175, 175, 175, 176, 175, 177, 177,\n+    178, 179, 180, 181, 177, 81, 81, 176, 182, 182, 183, 183, 183, 183, 183,\n+    183, 183, 183, 183, 183, 183, 183, 183, 183, 184, 184, 184, 184, 185,\n+    184, 184, 184, 184, 184, 184, 184, 184, 184, 185, 184, 184, 184, 185,\n+    184, 184, 184, 184, 184, 81, 81, 186, 186, 186, 186, 186, 186, 186, 186,\n+    186, 186, 186, 186, 186, 186, 186, 81, 187, 187, 187, 187, 187, 187, 187,\n+    187, 187, 188, 188, 188, 81, 81, 189, 81, 167, 167, 167, 81, 81, 81, 81,\n+    81, 146, 146, 146, 146, 146, 81, 146, 146, 146, 146, 146, 146, 146, 146,\n+    81, 81, 81, 81, 81, 157, 139, 139, 139, 139, 139, 139, 131, 157, 139,\n+    139, 157, 139, 139, 157, 139, 139, 139, 157, 157, 157, 190, 191, 192,\n+    139, 139, 139, 157, 139, 139, 157, 157, 139, 139, 139, 139, 139, 193,\n+    193, 193, 194, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195, 195,\n+    195, 195, 195, 193, 194, 196, 195, 194, 194, 194, 193, 193, 193, 193,\n+    193, 193, 193, 193, 194, 194, 194, 194, 197, 194, 194, 195, 96, 156, 198,\n+    198, 193, 193, 193, 195, 195, 193, 193, 199, 199, 200, 200, 200, 200,\n+    200, 200, 200, 200, 200, 200, 201, 202, 195, 195, 195, 195, 195, 195,\n+    203, 204, 205, 205, 81, 203, 203, 203, 203, 203, 203, 203, 203, 81, 81,\n+    203, 203, 81, 81, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203, 203,\n+    203, 203, 203, 81, 203, 203, 203, 203, 203, 203, 203, 81, 203, 81, 81,\n+    81, 203, 203, 203, 203, 81, 81, 206, 203, 205, 205, 205, 204, 204, 204,\n+    204, 81, 81, 205, 205, 81, 81, 205, 205, 207, 203, 81, 81, 81, 81, 81,\n+    81, 81, 81, 205, 81, 81, 81, 81, 203, 203, 81, 203, 203, 203, 204, 204,\n+    81, 81, 208, 208, 208, 208, 208, 208, 208, 208, 208, 208, 203, 203, 209,\n+    209, 210, 210, 210, 210, 210, 211, 212, 213, 203, 214, 215, 81, 81, 216,\n+    216, 217, 81, 218, 218, 218, 218, 218, 218, 81, 81, 81, 81, 218, 218, 81,\n+    81, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218, 218,\n+    81, 218, 218, 218, 218, 218, 218, 218, 81, 218, 218, 81, 218, 218, 81,\n+    218, 218, 81, 81, 219, 81, 217, 217, 217, 216, 216, 81, 81, 81, 81, 216,\n+    216, 81, 81, 216, 216, 220, 81, 81, 81, 216, 81, 81, 81, 81, 81, 81, 81,\n+    218, 218, 218, 218, 81, 218, 81, 81, 81, 81, 81, 81, 81, 221, 221, 221,\n+    221, 221, 221, 221, 221, 221, 221, 216, 216, 218, 218, 218, 216, 222, 81,\n+    81, 223, 223, 224, 81, 225, 225, 225, 225, 225, 225, 225, 225, 225, 81,\n+    225, 225, 225, 81, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225, 225,\n+    225, 225, 225, 81, 225, 225, 225, 225, 225, 225, 225, 81, 225, 225, 81,\n+    225, 225, 225, 225, 225, 81, 81, 226, 225, 224, 224, 224, 223, 223, 223,\n+    223, 223, 81, 223, 223, 224, 81, 224, 224, 227, 81, 81, 225, 81, 81, 81,\n+    81, 81, 81, 81, 225, 225, 223, 223, 81, 81, 228, 228, 228, 228, 228, 228,\n+    228, 228, 228, 228, 229, 230, 81, 81, 81, 81, 81, 81, 81, 225, 223, 223,\n+    223, 223, 223, 223, 81, 231, 232, 232, 81, 233, 233, 233, 233, 233, 233,\n+    233, 233, 81, 81, 233, 233, 81, 81, 233, 233, 233, 233, 233, 233, 233,\n+    233, 233, 233, 233, 233, 233, 233, 81, 233, 233, 233, 233, 233, 233, 233,\n+    81, 233, 233, 81, 233, 233, 233, 233, 233, 81, 81, 234, 233, 232, 231,\n+    232, 231, 231, 231, 231, 81, 81, 232, 232, 81, 81, 232, 232, 235, 81, 81,\n+    81, 81, 81, 81, 81, 81, 231, 232, 81, 81, 81, 81, 233, 233, 81, 233, 233,\n+    233, 231, 231, 81, 81, 236, 236, 236, 236, 236, 236, 236, 236, 236, 236,\n+    237, 233, 238, 238, 238, 238, 238, 238, 81, 81, 239, 240, 81, 240, 240,\n+    240, 240, 240, 240, 81, 81, 81, 240, 240, 240, 81, 240, 240, 240, 240,\n+    81, 81, 81, 240, 240, 81, 240, 81, 240, 240, 81, 81, 81, 240, 240, 81,\n+    81, 81, 240, 240, 240, 240, 240, 240, 240, 240, 240, 240, 81, 81, 81, 81,\n+    241, 241, 239, 241, 241, 81, 81, 81, 241, 241, 241, 81, 241, 241, 241,\n+    242, 81, 81, 240, 81, 81, 81, 81, 81, 81, 241, 81, 81, 81, 81, 81, 81,\n+    243, 243, 243, 243, 243, 243, 243, 243, 243, 243, 244, 244, 244, 245,\n+    245, 245, 245, 245, 245, 246, 245, 81, 81, 81, 81, 81, 247, 248, 248,\n+    248, 247, 249, 249, 249, 249, 249, 249, 249, 249, 81, 249, 249, 249, 81,\n+    249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249, 249,\n+    249, 249, 81, 81, 81, 249, 247, 247, 247, 248, 248, 248, 248, 81, 247,\n+    247, 247, 81, 247, 247, 247, 250, 81, 81, 81, 81, 81, 81, 81, 251, 252,\n+    81, 249, 249, 249, 81, 81, 81, 81, 81, 249, 249, 247, 247, 81, 81, 253,\n+    253, 253, 253, 253, 253, 253, 253, 253, 253, 254, 254, 254, 254, 254,\n+    254, 254, 255, 256, 257, 258, 258, 259, 256, 256, 256, 256, 256, 256,\n+    256, 256, 81, 256, 256, 256, 81, 256, 256, 256, 256, 256, 256, 256, 256,\n+    256, 256, 256, 256, 256, 256, 256, 256, 256, 256, 81, 256, 256, 256, 256,\n+    256, 81, 81, 260, 256, 258, 261, 258, 258, 258, 258, 258, 81, 261, 258,\n+    258, 81, 258, 258, 257, 262, 81, 81, 81, 81, 81, 81, 81, 258, 258, 81,\n+    81, 81, 81, 81, 81, 81, 256, 81, 256, 256, 257, 257, 81, 81, 263, 263,\n+    263, 263, 263, 263, 263, 263, 263, 263, 81, 256, 256, 81, 81, 81, 81, 81,\n+    264, 264, 265, 265, 81, 266, 266, 266, 266, 266, 266, 266, 266, 81, 266,\n+    266, 266, 81, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266, 266,\n+    266, 266, 266, 266, 266, 267, 267, 266, 265, 265, 265, 264, 264, 264,\n+    264, 81, 265, 265, 265, 81, 265, 265, 265, 267, 266, 268, 81, 81, 81, 81,\n+    266, 266, 266, 265, 269, 269, 269, 269, 269, 269, 269, 266, 266, 266,\n+    264, 264, 81, 81, 270, 270, 270, 270, 270, 270, 270, 270, 270, 270, 269,\n+    269, 269, 269, 269, 269, 269, 269, 269, 271, 266, 266, 266, 266, 266,\n+    266, 81, 81, 272, 272, 81, 273, 273, 273, 273, 273, 273, 273, 273, 273,\n+    273, 273, 273, 273, 273, 273, 273, 273, 273, 81, 81, 81, 273, 273, 273,\n+    273, 273, 273, 273, 273, 81, 273, 273, 273, 273, 273, 273, 273, 273, 273,\n+    81, 273, 81, 81, 81, 81, 274, 81, 81, 81, 81, 272, 272, 272, 275, 275,\n+    275, 81, 275, 81, 272, 272, 272, 272, 272, 272, 272, 272, 81, 81, 81, 81,\n+    81, 81, 276, 276, 276, 276, 276, 276, 276, 276, 276, 276, 81, 81, 272,\n+    272, 277, 81, 81, 81, 81, 278, 278, 278, 278, 278, 278, 278, 278, 278,\n+    278, 278, 278, 278, 278, 278, 278, 279, 278, 278, 279, 279, 279, 279,\n+    280, 280, 281, 81, 81, 81, 81, 282, 278, 278, 278, 278, 278, 278, 283,\n+    279, 284, 284, 284, 284, 279, 279, 279, 285, 286, 286, 286, 286, 286,\n+    286, 286, 286, 286, 286, 287, 287, 81, 81, 81, 81, 81, 288, 288, 81, 288,\n+    81, 81, 288, 288, 81, 288, 81, 81, 288, 81, 81, 81, 81, 81, 81, 288, 288,\n+    288, 288, 81, 288, 288, 288, 288, 288, 288, 288, 81, 288, 288, 288, 81,\n+    288, 81, 288, 81, 81, 288, 288, 81, 288, 288, 288, 288, 289, 288, 288,\n+    289, 289, 289, 289, 290, 290, 81, 289, 289, 288, 81, 81, 288, 288, 288,\n+    288, 288, 81, 291, 81, 292, 292, 292, 292, 289, 289, 81, 81, 293, 293,\n+    293, 293, 293, 293, 293, 293, 293, 293, 81, 81, 288, 288, 288, 288, 294,\n+    295, 295, 295, 296, 297, 296, 296, 298, 296, 296, 299, 298, 300, 300,\n+    300, 300, 300, 298, 301, 300, 301, 301, 301, 302, 302, 301, 301, 301,\n+    301, 301, 301, 303, 303, 303, 303, 303, 303, 303, 303, 303, 303, 304,\n+    304, 304, 304, 304, 304, 304, 304, 304, 304, 305, 302, 301, 302, 301,\n+    306, 307, 308, 307, 308, 309, 309, 294, 294, 294, 294, 294, 294, 294,\n+    294, 81, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 294, 81,\n+    81, 81, 81, 310, 311, 312, 313, 312, 312, 312, 312, 312, 311, 311, 311,\n+    311, 312, 314, 311, 312, 315, 315, 316, 299, 315, 315, 294, 294, 294,\n+    294, 294, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 81, 312,\n+    312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 312, 81, 305, 305, 301,\n+    301, 301, 301, 301, 301, 302, 301, 301, 301, 301, 301, 301, 81, 301, 301,\n+    296, 296, 299, 296, 297, 317, 317, 317, 317, 298, 298, 81, 81, 81, 81,\n+    81, 318, 318, 318, 318, 318, 318, 318, 318, 318, 318, 318, 319, 319, 320,\n+    320, 320, 320, 319, 320, 320, 320, 320, 320, 321, 319, 322, 322, 319,\n+    319, 320, 320, 318, 323, 323, 323, 323, 323, 323, 323, 323, 323, 323,\n+    324, 324, 325, 325, 325, 325, 318, 318, 318, 318, 318, 318, 319, 319,\n+    320, 320, 318, 318, 318, 318, 320, 320, 320, 318, 319, 319, 319, 318,\n+    318, 319, 319, 319, 319, 319, 319, 319, 318, 318, 318, 320, 320, 320,\n+    320, 318, 318, 318, 318, 318, 320, 319, 319, 320, 320, 319, 319, 319,\n+    319, 319, 319, 326, 318, 319, 323, 323, 319, 319, 319, 320, 327, 327,\n+    328, 328, 328, 328, 328, 328, 328, 328, 328, 328, 328, 328, 328, 328, 81,\n+    328, 81, 81, 81, 81, 81, 328, 81, 81, 329, 329, 329, 329, 329, 329, 329,\n+    329, 329, 329, 329, 330, 331, 329, 329, 329, 332, 332, 332, 332, 332,\n+    332, 332, 332, 333, 333, 333, 333, 333, 333, 333, 333, 334, 334, 334,\n+    334, 334, 334, 334, 334, 335, 335, 335, 335, 335, 335, 335, 335, 335, 81,\n+    335, 335, 335, 335, 81, 81, 335, 335, 335, 335, 335, 335, 335, 81, 335,\n+    335, 335, 81, 81, 336, 336, 336, 337, 338, 337, 337, 337, 337, 337, 337,\n+    337, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339, 339,\n+    339, 339, 339, 339, 339, 339, 339, 81, 81, 81, 340, 340, 340, 340, 340,\n+    340, 340, 340, 340, 340, 81, 81, 81, 81, 81, 81, 341, 341, 341, 341, 341,\n+    341, 341, 341, 341, 341, 341, 341, 341, 341, 81, 81, 342, 342, 342, 342,\n+    342, 342, 81, 81, 343, 344, 344, 344, 344, 344, 344, 344, 344, 344, 344,\n+    344, 344, 344, 344, 344, 344, 344, 344, 344, 344, 345, 345, 344, 346,\n+    347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347, 347,\n+    347, 347, 347, 347, 348, 349, 81, 81, 81, 350, 350, 350, 350, 350, 350,\n+    350, 350, 350, 350, 350, 199, 199, 199, 351, 351, 351, 350, 350, 350,\n+    350, 350, 350, 350, 350, 81, 81, 81, 81, 81, 81, 81, 352, 352, 352, 352,\n+    352, 352, 352, 352, 352, 352, 352, 352, 352, 81, 352, 352, 352, 352, 353,\n+    353, 354, 81, 81, 81, 355, 355, 355, 355, 355, 355, 355, 355, 355, 355,\n+    356, 356, 357, 199, 199, 81, 358, 358, 358, 358, 358, 358, 358, 358, 358,\n+    358, 359, 359, 81, 81, 81, 81, 360, 360, 360, 360, 360, 360, 360, 360,\n+    360, 360, 360, 360, 360, 81, 360, 360, 360, 81, 361, 361, 81, 81, 81, 81,\n+    362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 362, 363, 363,\n+    364, 363, 363, 363, 363, 363, 363, 363, 364, 364, 364, 364, 364, 364,\n+    364, 364, 363, 364, 364, 363, 363, 363, 363, 363, 363, 363, 363, 363,\n+    365, 363, 366, 366, 367, 368, 366, 369, 366, 370, 362, 371, 81, 81, 372,\n+    372, 372, 372, 372, 372, 372, 372, 372, 372, 81, 81, 81, 81, 81, 81, 373,\n+    373, 373, 373, 373, 373, 373, 373, 373, 373, 81, 81, 81, 81, 81, 81, 374,\n+    374, 375, 375, 376, 377, 378, 374, 379, 379, 374, 380, 380, 380, 381, 81,\n+    382, 382, 382, 382, 382, 382, 382, 382, 382, 382, 81, 81, 81, 81, 81, 81,\n+    383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 383, 384, 383, 383,\n+    383, 383, 383, 81, 81, 81, 81, 81, 81, 81, 383, 383, 383, 383, 383, 380,\n+    380, 383, 383, 385, 383, 81, 81, 81, 81, 81, 344, 344, 344, 344, 344,\n+    344, 81, 81, 386, 386, 386, 386, 386, 386, 386, 386, 386, 386, 386, 386,\n+    386, 386, 386, 81, 387, 387, 387, 388, 388, 388, 388, 387, 387, 388, 388,\n+    388, 81, 81, 81, 81, 388, 388, 387, 388, 388, 388, 388, 388, 388, 389,\n+    390, 391, 81, 81, 81, 81, 392, 81, 81, 81, 393, 393, 394, 394, 394, 394,\n+    394, 394, 394, 394, 394, 394, 395, 395, 395, 395, 395, 395, 395, 395,\n+    395, 395, 395, 395, 395, 395, 81, 81, 395, 395, 395, 395, 395, 81, 81,\n+    81, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 396, 81, 81,\n+    81, 81, 396, 396, 81, 81, 81, 81, 81, 81, 397, 397, 397, 397, 397, 397,\n+    397, 397, 397, 397, 398, 81, 81, 81, 399, 399, 400, 400, 400, 400, 400,\n+    400, 400, 400, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401, 401,\n+    401, 401, 401, 401, 402, 403, 404, 404, 405, 81, 81, 406, 406, 407, 407,\n+    407, 407, 407, 407, 407, 407, 407, 407, 407, 407, 407, 408, 409, 408,\n+    409, 409, 409, 409, 409, 409, 409, 81, 410, 408, 409, 408, 408, 409, 409,\n+    409, 409, 409, 409, 409, 409, 408, 408, 408, 408, 408, 408, 409, 409,\n+    411, 411, 411, 411, 411, 411, 411, 411, 81, 81, 412, 413, 413, 413, 413,\n+    413, 413, 413, 413, 413, 413, 81, 81, 81, 81, 81, 81, 414, 414, 414, 414,\n+    414, 414, 414, 415, 414, 414, 414, 414, 414, 414, 81, 81, 96, 96, 96, 96,\n+    96, 156, 156, 156, 156, 156, 156, 96, 96, 156, 416, 81, 417, 417, 417,\n+    417, 418, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419, 419,\n+    419, 419, 419, 420, 418, 417, 417, 417, 417, 417, 418, 417, 418, 418,\n+    418, 418, 418, 417, 418, 421, 419, 419, 419, 419, 419, 419, 419, 81, 81,\n+    81, 81, 422, 422, 422, 422, 422, 422, 422, 422, 422, 422, 423, 423, 424,\n+    423, 423, 423, 423, 425, 425, 425, 425, 425, 425, 425, 425, 425, 425,\n+    426, 427, 426, 426, 426, 426, 426, 426, 426, 425, 425, 425, 425, 425,\n+    425, 425, 425, 425, 81, 81, 81, 428, 428, 429, 430, 430, 430, 430, 430,\n+    430, 430, 430, 430, 430, 430, 430, 430, 430, 429, 428, 428, 428, 428,\n+    429, 429, 428, 428, 431, 432, 428, 428, 430, 430, 433, 433, 433, 433,\n+    433, 433, 433, 433, 433, 433, 430, 430, 430, 430, 430, 430, 434, 434,\n+    434, 434, 434, 434, 434, 434, 434, 434, 434, 434, 434, 434, 435, 436,\n+    437, 437, 436, 436, 436, 437, 436, 437, 437, 437, 438, 438, 81, 81, 81,\n+    81, 81, 81, 81, 81, 439, 439, 439, 439, 440, 440, 440, 440, 440, 440,\n+    440, 440, 440, 440, 440, 440, 441, 441, 441, 441, 441, 441, 441, 441,\n+    442, 442, 442, 442, 442, 442, 442, 442, 441, 441, 442, 443, 81, 81, 81,\n+    444, 444, 444, 444, 444, 445, 445, 445, 445, 445, 445, 445, 445, 445,\n+    445, 81, 81, 81, 440, 440, 440, 446, 446, 446, 446, 446, 446, 446, 446,\n+    446, 446, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447, 447,\n+    447, 447, 448, 448, 448, 448, 448, 448, 449, 449, 93, 81, 81, 81, 81, 81,\n+    81, 81, 328, 328, 328, 81, 81, 328, 328, 328, 450, 450, 450, 450, 450,\n+    450, 450, 450, 96, 96, 96, 330, 451, 156, 156, 156, 156, 156, 96, 96,\n+    156, 156, 156, 156, 96, 452, 451, 451, 451, 451, 451, 451, 451, 453, 453,\n+    453, 453, 156, 453, 453, 453, 453, 452, 452, 96, 453, 453, 452, 96, 96,\n+    81, 81, 81, 81, 81, 81, 56, 56, 56, 56, 56, 56, 79, 79, 79, 79, 79, 93,\n+    59, 59, 59, 59, 59, 59, 59, 59, 59, 82, 82, 82, 82, 82, 59, 59, 59, 59,\n+    82, 82, 82, 82, 82, 56, 56, 56, 56, 56, 454, 56, 56, 56, 56, 56, 56, 56,\n+    56, 56, 56, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 59, 82, 96, 96,\n+    156, 96, 96, 96, 96, 96, 96, 96, 156, 96, 96, 455, 456, 156, 457, 96, 96,\n+    96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96, 96,\n+    96, 458, 459, 459, 156, 81, 96, 460, 156, 96, 156, 52, 56, 52, 56, 52,\n+    56, 56, 56, 56, 56, 56, 56, 56, 56, 52, 56, 79, 79, 79, 79, 79, 79, 79,\n+    79, 78, 78, 78, 78, 78, 78, 78, 78, 79, 79, 79, 79, 79, 79, 81, 81, 78,\n+    78, 78, 78, 78, 78, 81, 81, 81, 78, 81, 78, 81, 78, 81, 78, 461, 461,\n+    461, 461, 461, 461, 461, 461, 79, 79, 79, 79, 79, 81, 79, 79, 78, 78, 78,\n+    78, 461, 80, 79, 80, 80, 80, 79, 79, 79, 81, 79, 79, 78, 78, 78, 78, 461,\n+    80, 80, 80, 79, 79, 79, 79, 81, 81, 79, 79, 78, 78, 78, 78, 81, 80, 80,\n+    80, 78, 78, 78, 78, 78, 80, 80, 80, 81, 81, 79, 79, 79, 81, 79, 79, 78,\n+    78, 78, 78, 461, 462, 80, 81, 463, 463, 463, 463, 463, 463, 463, 464,\n+    463, 463, 463, 465, 466, 467, 468, 469, 470, 471, 472, 470, 473, 474, 38,\n+    84, 475, 476, 477, 42, 475, 476, 477, 42, 38, 38, 478, 84, 479, 479, 479,\n+    480, 481, 482, 483, 484, 485, 486, 487, 33, 488, 489, 488, 488, 489, 490,\n+    491, 491, 84, 42, 50, 38, 492, 492, 478, 493, 493, 84, 84, 84, 494, 477,\n+    495, 492, 492, 492, 84, 84, 84, 84, 84, 84, 84, 84, 496, 84, 493, 84,\n+    377, 84, 377, 377, 377, 377, 84, 377, 377, 463, 497, 498, 498, 498, 498,\n+    81, 499, 500, 501, 502, 503, 503, 503, 503, 503, 503, 504, 59, 81, 81,\n+    47, 504, 504, 504, 504, 504, 505, 505, 496, 477, 495, 506, 504, 47, 47,\n+    47, 47, 504, 504, 504, 504, 504, 505, 505, 496, 477, 495, 81, 59, 59, 59,\n+    59, 59, 81, 81, 81, 282, 282, 282, 282, 282, 282, 282, 507, 282, 508,\n+    282, 282, 36, 282, 282, 282, 282, 282, 282, 282, 282, 282, 507, 282, 282,\n+    282, 282, 507, 282, 282, 507, 282, 509, 509, 509, 509, 509, 509, 509,\n+    509, 96, 96, 451, 451, 96, 96, 96, 96, 451, 451, 451, 96, 96, 416, 416,\n+    416, 416, 96, 416, 416, 416, 451, 451, 96, 156, 96, 451, 451, 156, 156,\n+    156, 156, 96, 81, 81, 81, 81, 81, 81, 81, 40, 40, 510, 511, 40, 512, 40,\n+    510, 40, 511, 49, 510, 510, 510, 49, 49, 510, 510, 510, 513, 40, 510,\n+    514, 40, 496, 510, 510, 510, 510, 510, 40, 40, 40, 512, 512, 40, 510, 40,\n+    85, 40, 510, 40, 52, 515, 510, 510, 516, 49, 510, 510, 52, 510, 49, 453,\n+    453, 453, 453, 49, 40, 40, 49, 49, 510, 510, 496, 496, 496, 496, 496,\n+    510, 49, 49, 49, 49, 40, 496, 40, 40, 56, 317, 517, 517, 517, 518, 51,\n+    519, 517, 517, 517, 517, 517, 51, 518, 518, 51, 517, 520, 520, 520, 520,\n+    520, 520, 520, 520, 520, 520, 520, 520, 521, 521, 521, 521, 520, 520,\n+    521, 521, 521, 521, 521, 521, 521, 521, 521, 52, 56, 521, 521, 521, 521,\n+    51, 40, 40, 81, 81, 81, 81, 54, 54, 54, 54, 54, 512, 512, 512, 512, 512,\n+    496, 496, 40, 40, 40, 40, 496, 40, 40, 496, 40, 40, 496, 40, 40, 40, 40,\n+    40, 40, 40, 496, 40, 40, 40, 40, 40, 40, 40, 40, 40, 44, 44, 40, 40, 40,\n+    40, 40, 40, 40, 40, 40, 40, 40, 40, 496, 496, 40, 40, 54, 40, 54, 40, 40,\n+    40, 40, 40, 40, 40, 40, 40, 40, 44, 40, 40, 40, 40, 496, 496, 496, 496,\n+    496, 496, 496, 496, 496, 496, 496, 496, 54, 496, 54, 54, 496, 496, 496,\n+    54, 54, 496, 496, 54, 496, 496, 496, 54, 496, 54, 522, 523, 496, 54, 496,\n+    496, 496, 496, 54, 496, 496, 54, 54, 54, 54, 496, 496, 54, 496, 54, 496,\n+    54, 54, 54, 54, 54, 54, 496, 54, 496, 496, 496, 496, 496, 54, 54, 54, 54,\n+    496, 496, 496, 496, 54, 54, 496, 496, 54, 496, 496, 496, 54, 496, 496,\n+    496, 496, 496, 54, 496, 496, 496, 496, 496, 54, 54, 496, 496, 54, 54, 54,\n+    54, 496, 496, 54, 54, 496, 496, 54, 54, 496, 496, 496, 496, 496, 54, 496,\n+    496, 496, 54, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496, 496,\n+    496, 54, 496, 496, 496, 496, 496, 496, 496, 524, 477, 495, 477, 495, 40,\n+    40, 40, 40, 40, 40, 512, 40, 40, 40, 40, 40, 40, 40, 525, 525, 40, 40,\n+    40, 40, 496, 496, 40, 40, 40, 40, 40, 40, 40, 526, 527, 40, 40, 40, 40,\n+    40, 40, 40, 40, 40, 40, 40, 317, 317, 317, 317, 317, 317, 317, 317, 317,\n+    317, 317, 317, 317, 40, 496, 40, 40, 40, 40, 40, 40, 40, 40, 317, 40, 40,\n+    40, 40, 40, 496, 496, 496, 496, 496, 496, 496, 496, 496, 40, 40, 40, 40,\n+    40, 528, 528, 528, 528, 40, 40, 40, 525, 529, 529, 525, 40, 40, 40, 40,\n+    40, 40, 40, 40, 40, 40, 40, 81, 40, 40, 40, 81, 81, 81, 81, 81, 51, 51,\n+    51, 51, 51, 51, 51, 51, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47, 47,\n+    530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530,\n+    519, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 51, 518, 512, 512, 512,\n+    512, 512, 512, 512, 512, 512, 512, 512, 512, 40, 40, 40, 40, 512, 512,\n+    512, 512, 531, 40, 40, 40, 40, 40, 512, 512, 512, 512, 40, 40, 512, 512,\n+    40, 512, 512, 512, 512, 512, 512, 512, 40, 40, 40, 40, 40, 40, 40, 40,\n+    512, 512, 40, 40, 512, 54, 40, 40, 40, 40, 512, 512, 40, 40, 512, 54, 40,\n+    40, 40, 40, 512, 512, 512, 40, 40, 512, 40, 40, 512, 512, 40, 40, 40, 40,\n+    40, 40, 40, 512, 496, 496, 496, 496, 496, 532, 532, 496, 529, 529, 529,\n+    529, 40, 512, 512, 40, 40, 512, 40, 40, 40, 40, 512, 512, 40, 40, 40, 40,\n+    525, 525, 531, 531, 529, 40, 529, 529, 533, 534, 533, 529, 40, 529, 529,\n+    529, 40, 40, 40, 40, 512, 40, 512, 40, 40, 40, 40, 40, 528, 528, 528,\n+    528, 528, 528, 528, 528, 528, 528, 528, 528, 40, 40, 40, 40, 512, 512,\n+    40, 512, 512, 512, 40, 512, 533, 512, 512, 40, 512, 512, 40, 54, 40, 40,\n+    40, 40, 40, 40, 40, 525, 40, 40, 40, 528, 40, 40, 40, 40, 40, 40, 40, 40,\n+    40, 40, 512, 512, 40, 528, 40, 40, 40, 40, 40, 40, 40, 40, 528, 528, 317,\n+    40, 40, 40, 40, 40, 40, 40, 40, 525, 525, 533, 529, 529, 529, 529, 525,\n+    525, 533, 533, 533, 512, 512, 512, 512, 533, 528, 533, 533, 533, 512,\n+    533, 525, 512, 512, 512, 533, 533, 512, 512, 533, 512, 512, 533, 533,\n+    533, 40, 512, 40, 40, 40, 40, 512, 512, 525, 512, 512, 512, 512, 512,\n+    512, 533, 525, 525, 533, 525, 512, 533, 533, 535, 525, 512, 512, 525,\n+    533, 533, 529, 529, 529, 529, 529, 528, 40, 40, 529, 529, 536, 536, 534,\n+    534, 40, 40, 528, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 40, 44, 40,\n+    40, 40, 40, 40, 40, 528, 40, 528, 40, 40, 40, 40, 528, 528, 528, 40, 537,\n+    40, 40, 40, 538, 538, 538, 538, 538, 538, 40, 539, 539, 529, 40, 40, 40,\n+    477, 495, 477, 495, 477, 495, 477, 495, 477, 495, 477, 495, 477, 495, 51,\n+    51, 519, 519, 519, 519, 519, 519, 519, 519, 519, 519, 519, 519, 40, 528,\n+    528, 528, 40, 40, 40, 40, 40, 40, 40, 528, 496, 496, 496, 496, 496, 477,\n+    495, 496, 496, 496, 496, 496, 496, 496, 16, 31, 16, 31, 16, 31, 16, 31,\n+    477, 495, 540, 540, 540, 540, 540, 540, 540, 540, 496, 496, 496, 477,\n+    495, 16, 31, 477, 495, 477, 495, 477, 495, 477, 495, 477, 495, 496, 496,\n+    496, 496, 496, 496, 496, 477, 495, 477, 495, 496, 496, 496, 496, 496,\n+    496, 496, 496, 477, 495, 496, 496, 40, 40, 40, 528, 528, 40, 40, 40, 496,\n+    496, 496, 496, 496, 40, 40, 496, 496, 496, 496, 496, 496, 40, 40, 40,\n+    528, 40, 40, 40, 40, 537, 512, 512, 40, 40, 40, 40, 81, 81, 40, 40, 40,\n+    40, 40, 40, 40, 40, 81, 81, 40, 81, 40, 40, 40, 40, 40, 40, 541, 541,\n+    541, 541, 541, 541, 541, 541, 541, 541, 541, 541, 541, 541, 541, 81, 542,\n+    542, 542, 542, 542, 542, 542, 542, 542, 542, 542, 542, 542, 542, 542, 81,\n+    52, 56, 52, 52, 52, 56, 56, 52, 56, 52, 56, 52, 56, 52, 52, 52, 52, 56,\n+    52, 56, 56, 52, 56, 56, 56, 56, 56, 56, 59, 59, 52, 52, 87, 88, 87, 88,\n+    88, 543, 543, 543, 543, 543, 543, 87, 88, 87, 88, 544, 544, 544, 87, 88,\n+    81, 81, 81, 81, 81, 545, 546, 546, 546, 547, 545, 546, 329, 329, 329,\n+    329, 329, 329, 81, 329, 81, 81, 81, 81, 81, 329, 81, 81, 548, 548, 548,\n+    548, 548, 548, 548, 548, 81, 81, 81, 81, 81, 81, 81, 549, 550, 81, 81,\n+    81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 551, 95, 95, 95, 95, 95,\n+    95, 95, 95, 552, 552, 42, 50, 42, 50, 552, 552, 552, 42, 50, 552, 42, 50,\n+    377, 377, 377, 377, 377, 377, 377, 377, 84, 472, 553, 377, 554, 84, 42,\n+    50, 84, 84, 42, 50, 477, 495, 477, 495, 477, 495, 477, 495, 377, 377,\n+    377, 377, 375, 60, 377, 377, 84, 377, 377, 84, 84, 84, 84, 84, 555, 555,\n+    377, 377, 377, 84, 472, 377, 477, 377, 377, 377, 377, 377, 377, 377, 377,\n+    84, 377, 84, 377, 81, 556, 556, 556, 556, 556, 556, 556, 556, 556, 556,\n+    81, 556, 556, 556, 556, 556, 556, 556, 556, 556, 81, 81, 81, 81, 556,\n+    556, 556, 556, 556, 556, 81, 81, 525, 525, 525, 525, 525, 525, 525, 525,\n+    525, 525, 525, 525, 81, 81, 81, 81, 557, 558, 558, 559, 525, 560, 561,\n+    562, 526, 527, 526, 527, 526, 527, 526, 527, 526, 527, 525, 525, 526,\n+    527, 526, 527, 526, 527, 526, 527, 563, 526, 527, 527, 525, 562, 562,\n+    562, 562, 562, 562, 562, 562, 562, 564, 565, 566, 567, 568, 568, 569,\n+    570, 570, 570, 570, 571, 525, 525, 562, 562, 562, 560, 572, 559, 525,\n+    529, 81, 573, 574, 573, 574, 573, 574, 573, 574, 573, 574, 574, 574, 574,\n+    574, 574, 574, 574, 574, 574, 574, 574, 574, 574, 574, 574, 574, 573,\n+    574, 574, 574, 574, 574, 574, 574, 573, 574, 573, 574, 573, 574, 574,\n+    574, 574, 574, 574, 573, 574, 574, 574, 574, 574, 574, 573, 573, 81, 81,\n+    575, 575, 576, 576, 577, 577, 574, 563, 578, 579, 578, 579, 578, 579,\n+    578, 579, 578, 579, 579, 579, 579, 579, 579, 579, 579, 579, 579, 579,\n+    579, 579, 579, 579, 579, 579, 578, 579, 579, 579, 579, 579, 579, 579,\n+    578, 579, 578, 579, 578, 579, 579, 579, 579, 579, 579, 578, 579, 579,\n+    579, 579, 579, 579, 578, 578, 579, 579, 579, 579, 580, 581, 582, 582,\n+    579, 81, 81, 81, 81, 81, 583, 583, 583, 583, 583, 583, 583, 583, 583,\n+    583, 583, 81, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 584,\n+    584, 584, 584, 584, 584, 584, 584, 584, 584, 584, 81, 585, 585, 586, 586,\n+    586, 586, 585, 585, 585, 585, 585, 585, 585, 585, 585, 585, 583, 583,\n+    583, 81, 81, 81, 81, 81, 578, 578, 578, 578, 578, 578, 578, 578, 587,\n+    587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 587, 588, 588, 81,\n+    586, 586, 586, 586, 586, 586, 586, 586, 586, 586, 585, 585, 585, 585,\n+    585, 585, 589, 589, 589, 589, 589, 589, 589, 589, 525, 590, 590, 590,\n+    590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 590, 587, 587,\n+    587, 587, 588, 588, 588, 585, 585, 590, 590, 590, 590, 590, 590, 590,\n+    585, 585, 585, 585, 525, 525, 525, 525, 591, 591, 591, 591, 591, 591,\n+    591, 591, 591, 591, 591, 591, 591, 591, 591, 81, 585, 585, 585, 585, 585,\n+    585, 585, 525, 525, 525, 525, 585, 585, 585, 585, 585, 585, 585, 585,\n+    585, 585, 585, 525, 525, 592, 592, 592, 592, 592, 592, 592, 592, 592,\n+    592, 592, 592, 592, 592, 593, 593, 593, 593, 593, 593, 593, 593, 593,\n+    593, 594, 594, 594, 594, 594, 594, 594, 594, 594, 594, 594, 594, 594,\n+    595, 594, 594, 594, 594, 594, 594, 594, 81, 81, 81, 596, 596, 596, 596,\n+    596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 596, 81, 597, 597, 597,\n+    597, 597, 597, 597, 597, 598, 598, 598, 598, 598, 598, 599, 599, 600,\n+    600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 600, 601, 602, 603,\n+    602, 604, 604, 604, 604, 604, 604, 604, 604, 604, 604, 600, 600, 81, 81,\n+    81, 81, 90, 93, 90, 93, 90, 93, 605, 95, 97, 97, 97, 606, 95, 95, 95, 95,\n+    95, 95, 95, 95, 95, 95, 606, 607, 90, 93, 90, 93, 454, 454, 95, 95, 608,\n+    608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 608, 609,\n+    609, 609, 609, 609, 609, 609, 609, 609, 609, 610, 610, 611, 612, 612,\n+    612, 612, 612, 62, 62, 62, 62, 62, 62, 62, 60, 60, 60, 60, 60, 60, 60,\n+    60, 60, 62, 62, 52, 56, 52, 56, 52, 56, 56, 56, 52, 56, 52, 56, 52, 56,\n+    59, 56, 56, 56, 56, 56, 56, 56, 56, 52, 56, 52, 56, 52, 52, 56, 60, 613,\n+    613, 52, 56, 52, 56, 57, 52, 56, 52, 56, 56, 56, 52, 56, 52, 56, 52, 52,\n+    52, 52, 52, 56, 52, 52, 52, 52, 52, 56, 52, 56, 52, 56, 81, 81, 81, 81,\n+    81, 81, 81, 81, 81, 81, 81, 81, 81, 57, 59, 59, 56, 57, 57, 57, 57, 57,\n+    614, 614, 615, 614, 614, 614, 616, 614, 614, 614, 614, 615, 614, 614,\n+    614, 614, 614, 614, 614, 614, 614, 614, 614, 614, 614, 614, 614, 617,\n+    617, 615, 615, 617, 618, 618, 618, 618, 81, 81, 81, 81, 619, 619, 619,\n+    619, 619, 619, 317, 317, 507, 516, 81, 81, 81, 81, 81, 81, 620, 620, 620,\n+    620, 620, 620, 620, 620, 620, 620, 620, 620, 621, 621, 622, 622, 623,\n+    623, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624, 624,\n+    624, 624, 624, 624, 624, 623, 623, 623, 623, 623, 623, 623, 623, 623,\n+    623, 623, 623, 623, 623, 623, 623, 625, 626, 81, 81, 81, 81, 81, 81, 81,\n+    81, 627, 627, 628, 628, 628, 628, 628, 628, 628, 628, 628, 628, 81, 81,\n+    81, 81, 81, 81, 198, 198, 198, 198, 198, 198, 198, 198, 198, 198, 195,\n+    195, 195, 195, 195, 195, 201, 201, 201, 195, 629, 195, 195, 193, 630,\n+    630, 630, 630, 630, 630, 630, 630, 630, 630, 631, 631, 631, 631, 631,\n+    631, 631, 631, 631, 631, 631, 631, 631, 631, 631, 631, 631, 631, 631,\n+    631, 632, 632, 632, 632, 632, 633, 633, 633, 199, 634, 635, 635, 635,\n+    635, 635, 635, 635, 635, 635, 635, 635, 635, 635, 635, 635, 636, 636,\n+    636, 636, 636, 636, 636, 636, 636, 636, 636, 637, 638, 81, 81, 81, 81,\n+    81, 81, 81, 81, 81, 81, 81, 639, 332, 332, 332, 332, 332, 81, 81, 81,\n+    640, 640, 640, 641, 642, 642, 642, 642, 642, 642, 642, 642, 642, 642,\n+    642, 642, 642, 642, 642, 643, 641, 641, 640, 640, 640, 640, 641, 641,\n+    640, 641, 641, 641, 644, 645, 645, 645, 645, 645, 645, 646, 646, 646,\n+    645, 645, 645, 645, 81, 61, 647, 647, 647, 647, 647, 647, 647, 647, 647,\n+    647, 81, 81, 81, 81, 645, 645, 318, 318, 318, 318, 318, 320, 648, 318,\n+    323, 323, 318, 318, 318, 318, 318, 81, 649, 649, 649, 649, 649, 649, 649,\n+    649, 649, 650, 650, 650, 650, 650, 650, 651, 651, 650, 650, 651, 651,\n+    650, 650, 81, 649, 649, 649, 650, 649, 649, 649, 649, 649, 649, 649, 649,\n+    650, 651, 81, 81, 652, 652, 652, 652, 652, 652, 652, 652, 652, 652, 81,\n+    81, 653, 654, 654, 654, 648, 318, 318, 318, 318, 318, 318, 327, 327, 327,\n+    318, 319, 320, 319, 318, 318, 655, 655, 655, 655, 655, 655, 655, 655,\n+    656, 655, 656, 656, 657, 655, 655, 656, 656, 655, 655, 655, 655, 655,\n+    656, 656, 655, 656, 655, 81, 81, 81, 81, 81, 81, 81, 81, 655, 655, 658,\n+    659, 659, 660, 660, 660, 660, 660, 660, 660, 660, 660, 660, 660, 661,\n+    662, 662, 661, 661, 663, 663, 660, 664, 664, 661, 665, 81, 81, 335, 335,\n+    335, 335, 335, 335, 81, 56, 56, 56, 613, 59, 59, 59, 59, 56, 56, 56, 56,\n+    56, 79, 81, 81, 342, 342, 342, 342, 342, 342, 342, 342, 660, 660, 660,\n+    661, 661, 662, 661, 661, 662, 661, 661, 663, 661, 665, 81, 81, 666, 666,\n+    666, 666, 666, 666, 666, 666, 666, 666, 81, 81, 81, 81, 81, 81, 667, 668,\n+    668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668, 668,\n+    668, 668, 668, 668, 667, 668, 668, 668, 668, 668, 668, 668, 81, 81, 81,\n+    81, 333, 333, 333, 333, 333, 333, 333, 81, 81, 81, 81, 334, 334, 334,\n+    334, 334, 334, 334, 334, 334, 81, 81, 81, 81, 669, 669, 669, 669, 669,\n+    669, 669, 669, 670, 670, 670, 670, 670, 670, 670, 670, 592, 592, 593,\n+    593, 593, 593, 593, 593, 56, 56, 56, 56, 56, 56, 56, 81, 81, 81, 81, 101,\n+    101, 101, 101, 101, 81, 81, 81, 81, 81, 129, 671, 129, 129, 672, 129,\n+    129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 129, 81, 129, 129,\n+    129, 129, 129, 81, 129, 81, 129, 129, 81, 129, 129, 81, 129, 129, 146,\n+    146, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673, 673,\n+    673, 673, 673, 81, 81, 81, 81, 81, 81, 81, 81, 81, 146, 146, 146, 146,\n+    146, 146, 146, 146, 146, 146, 146, 495, 477, 81, 81, 146, 146, 146, 146,\n+    146, 146, 146, 146, 146, 146, 135, 138, 81, 81, 674, 674, 674, 674, 674,\n+    674, 674, 674, 675, 558, 558, 675, 675, 676, 676, 526, 527, 677, 81, 81,\n+    81, 81, 81, 81, 96, 96, 96, 96, 96, 96, 96, 156, 156, 156, 156, 156, 156,\n+    156, 95, 95, 559, 569, 569, 678, 678, 526, 527, 526, 527, 526, 527, 526,\n+    527, 526, 527, 526, 527, 526, 527, 526, 527, 559, 559, 526, 527, 559,\n+    559, 559, 559, 678, 678, 678, 679, 559, 679, 81, 580, 680, 676, 676, 569,\n+    526, 527, 526, 527, 526, 527, 681, 559, 559, 682, 683, 684, 684, 684, 81,\n+    559, 685, 686, 559, 81, 81, 81, 81, 146, 146, 146, 146, 146, 81, 81, 497,\n+    81, 687, 688, 689, 690, 691, 688, 688, 692, 693, 688, 694, 695, 696, 695,\n+    697, 698, 698, 698, 698, 698, 698, 698, 698, 698, 698, 699, 700, 701,\n+    701, 701, 687, 688, 702, 702, 702, 702, 702, 702, 702, 702, 702, 702,\n+    702, 702, 702, 702, 702, 702, 702, 702, 692, 688, 693, 703, 704, 703,\n+    705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705, 705,\n+    705, 705, 705, 705, 692, 701, 693, 701, 692, 693, 706, 707, 708, 706,\n+    709, 710, 711, 711, 711, 711, 711, 711, 711, 711, 711, 712, 710, 710,\n+    710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710, 710,\n+    710, 710, 710, 710, 710, 713, 713, 714, 714, 714, 714, 714, 714, 714,\n+    714, 714, 714, 714, 714, 714, 714, 714, 81, 81, 81, 714, 714, 714, 714,\n+    714, 714, 81, 81, 714, 714, 714, 81, 81, 81, 715, 690, 701, 703, 716,\n+    690, 690, 81, 717, 718, 718, 718, 718, 717, 717, 81, 81, 719, 719, 719,\n+    720, 512, 81, 81, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721,\n+    721, 81, 721, 721, 721, 721, 721, 721, 721, 721, 721, 721, 81, 721, 721,\n+    721, 81, 721, 721, 81, 721, 721, 721, 721, 721, 721, 721, 81, 81, 721,\n+    721, 721, 81, 81, 81, 81, 81, 199, 377, 199, 81, 81, 81, 81, 619, 619,\n+    619, 619, 619, 619, 619, 619, 619, 619, 619, 619, 619, 81, 81, 81, 317,\n+    722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 722, 723,\n+    723, 723, 723, 724, 724, 724, 724, 724, 724, 724, 724, 724, 724, 724,\n+    724, 724, 724, 724, 724, 724, 723, 723, 724, 725, 725, 81, 40, 40, 40,\n+    40, 81, 81, 81, 81, 724, 81, 81, 81, 81, 81, 81, 81, 317, 317, 317, 317,\n+    317, 156, 81, 81, 726, 726, 726, 726, 726, 726, 726, 726, 726, 726, 726,\n+    726, 726, 81, 81, 81, 727, 727, 727, 727, 727, 727, 727, 727, 727, 81,\n+    81, 81, 81, 81, 81, 81, 156, 504, 504, 504, 504, 504, 504, 504, 504, 504,\n+    504, 504, 504, 504, 504, 504, 504, 504, 504, 504, 81, 81, 81, 81, 728,\n+    728, 728, 728, 728, 728, 728, 728, 729, 729, 729, 729, 81, 81, 81, 81,\n+    81, 81, 81, 81, 81, 728, 728, 728, 730, 730, 730, 730, 730, 730, 730,\n+    730, 730, 731, 730, 730, 730, 730, 730, 730, 730, 730, 731, 81, 81, 81,\n+    81, 81, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732, 732,\n+    732, 733, 733, 733, 733, 733, 81, 81, 81, 81, 81, 734, 734, 734, 734,\n+    734, 734, 734, 734, 734, 734, 734, 734, 734, 734, 81, 735, 736, 736, 736,\n+    736, 736, 736, 736, 736, 736, 736, 736, 736, 81, 81, 81, 81, 737, 738,\n+    738, 738, 738, 738, 81, 81, 739, 739, 739, 739, 739, 739, 739, 739, 740,\n+    740, 740, 740, 740, 740, 740, 740, 741, 741, 741, 741, 741, 741, 741,\n+    741, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742, 742,\n+    742, 81, 81, 743, 743, 743, 743, 743, 743, 743, 743, 743, 743, 81, 81,\n+    81, 81, 81, 81, 744, 744, 744, 744, 744, 744, 744, 744, 744, 744, 744,\n+    744, 81, 81, 81, 81, 745, 745, 745, 745, 745, 745, 745, 745, 745, 745,\n+    745, 745, 81, 81, 81, 81, 746, 746, 746, 746, 746, 746, 746, 746, 747,\n+    747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 747, 81, 81, 81, 81,\n+    81, 81, 81, 81, 81, 81, 81, 748, 749, 749, 749, 749, 749, 749, 749, 749,\n+    749, 749, 749, 749, 749, 749, 749, 81, 749, 749, 749, 749, 749, 749, 81,\n+    81, 750, 750, 750, 750, 750, 750, 81, 81, 750, 81, 750, 750, 750, 750,\n+    750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750, 750,\n+    750, 750, 81, 750, 750, 81, 81, 81, 750, 81, 81, 750, 751, 751, 751, 751,\n+    751, 751, 751, 751, 751, 751, 751, 751, 751, 751, 81, 752, 753, 753, 753,\n+    753, 753, 753, 753, 753, 754, 754, 754, 754, 754, 754, 754, 754, 754,\n+    754, 754, 754, 754, 754, 754, 755, 755, 756, 756, 756, 756, 756, 756,\n+    756, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757, 757,\n+    757, 757, 81, 81, 81, 81, 81, 81, 81, 81, 758, 758, 758, 758, 758, 758,\n+    758, 758, 758, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 759, 81,\n+    759, 759, 81, 81, 81, 81, 81, 760, 760, 760, 760, 760, 761, 761, 761,\n+    761, 761, 761, 761, 761, 761, 761, 761, 761, 761, 761, 762, 762, 762,\n+    762, 762, 762, 81, 81, 81, 763, 764, 764, 764, 764, 764, 764, 764, 764,\n+    764, 764, 81, 81, 81, 81, 81, 765, 766, 766, 766, 766, 766, 766, 766,\n+    766, 767, 767, 767, 767, 767, 767, 767, 767, 81, 81, 81, 81, 768, 768,\n+    767, 767, 768, 768, 768, 768, 768, 768, 768, 768, 81, 81, 768, 768, 768,\n+    768, 768, 768, 769, 770, 770, 770, 81, 770, 770, 81, 81, 81, 81, 81, 770,\n+    771, 770, 772, 769, 769, 769, 769, 81, 769, 769, 769, 81, 769, 769, 769,\n+    769, 769, 769, 769, 769, 769, 769, 769, 769, 769, 769, 769, 769, 769,\n+    769, 769, 769, 769, 81, 81, 772, 773, 771, 81, 81, 81, 81, 774, 775, 775,\n+    775, 775, 775, 775, 775, 775, 775, 81, 81, 81, 81, 81, 81, 81, 776, 776,\n+    776, 776, 776, 776, 776, 776, 777, 81, 81, 81, 81, 81, 81, 81, 778, 778,\n+    778, 778, 778, 778, 778, 778, 778, 778, 778, 778, 778, 779, 779, 780,\n+    781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 781, 782,\n+    782, 782, 783, 783, 783, 783, 783, 783, 783, 783, 784, 783, 783, 783,\n+    783, 783, 783, 783, 783, 783, 783, 783, 783, 785, 786, 81, 81, 81, 81,\n+    787, 787, 787, 787, 787, 788, 788, 788, 788, 788, 788, 789, 81, 790, 790,\n+    790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 790, 81, 81, 81,\n+    791, 791, 791, 791, 791, 791, 791, 792, 792, 792, 792, 792, 792, 792,\n+    792, 792, 792, 792, 792, 792, 792, 81, 81, 793, 793, 793, 793, 793, 793,\n+    793, 793, 794, 794, 794, 794, 794, 794, 794, 794, 794, 794, 794, 81, 81,\n+    81, 81, 81, 795, 795, 795, 795, 795, 795, 795, 795, 796, 796, 796, 796,\n+    796, 796, 796, 796, 796, 796, 81, 81, 81, 81, 81, 81, 81, 797, 797, 797,\n+    797, 81, 81, 81, 81, 798, 798, 798, 798, 798, 798, 798, 799, 799, 799,\n+    799, 799, 799, 799, 799, 799, 81, 81, 81, 81, 81, 81, 81, 800, 800, 800,\n+    800, 800, 800, 800, 800, 800, 800, 800, 81, 81, 81, 81, 81, 801, 801,\n+    801, 801, 801, 801, 801, 801, 801, 801, 801, 81, 81, 81, 81, 81, 81, 81,\n+    802, 802, 802, 802, 802, 802, 803, 803, 803, 803, 803, 803, 803, 803,\n+    803, 803, 803, 803, 804, 804, 804, 804, 805, 805, 805, 805, 805, 805,\n+    805, 805, 805, 805, 81, 81, 81, 81, 81, 81, 806, 806, 806, 806, 806, 806,\n+    806, 806, 806, 806, 806, 806, 806, 806, 806, 81, 807, 807, 807, 807, 807,\n+    807, 807, 807, 807, 807, 807, 807, 807, 808, 808, 808, 808, 808, 808,\n+    808, 808, 808, 808, 807, 809, 809, 809, 809, 809, 809, 809, 809, 809,\n+    809, 809, 809, 809, 809, 810, 810, 811, 811, 811, 810, 811, 810, 810,\n+    810, 810, 812, 812, 812, 812, 813, 813, 813, 813, 813, 81, 81, 81, 81,\n+    81, 81, 814, 815, 814, 816, 816, 816, 816, 816, 816, 816, 816, 816, 816,\n+    816, 816, 816, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815, 815,\n+    815, 815, 815, 817, 818, 818, 819, 819, 819, 819, 819, 81, 81, 81, 81,\n+    820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820, 820,\n+    820, 820, 820, 820, 820, 820, 821, 821, 821, 821, 821, 821, 821, 821,\n+    821, 821, 81, 81, 81, 81, 81, 81, 81, 817, 822, 822, 823, 824, 824, 824,\n+    824, 824, 824, 824, 824, 824, 824, 824, 824, 824, 823, 823, 823, 822,\n+    822, 822, 822, 823, 823, 825, 826, 827, 827, 828, 829, 829, 829, 829, 81,\n+    81, 81, 81, 81, 81, 81, 81, 81, 81, 81, 828, 81, 81, 830, 830, 830, 830,\n+    830, 830, 830, 830, 830, 81, 81, 81, 81, 81, 81, 81, 831, 831, 831, 831,\n+    831, 831, 831, 831, 831, 831, 81, 81, 81, 81, 81, 81, 832, 832, 832, 833,\n+    833, 833, 833, 833, 833, 833, 833, 833, 833, 833, 833, 833, 833, 833,\n+    833, 833, 833, 833, 833, 834, 834, 834, 834, 834, 835, 834, 834, 834,\n+    834, 834, 834, 836, 836, 81, 837, 837, 837, 837, 837, 837, 837, 837, 837,\n+    837, 838, 838, 838, 838, 833, 835, 835, 81, 839, 839, 839, 839, 839, 839,\n+    839, 839, 839, 839, 839, 840, 841, 842, 839, 81, 843, 843, 844, 845, 845,\n+    845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845, 845,\n+    844, 844, 844, 843, 843, 843, 843, 843, 843, 843, 843, 843, 844, 846,\n+    845, 845, 845, 845, 847, 847, 848, 847, 843, 849, 843, 843, 848, 81, 81,\n+    850, 850, 850, 850, 850, 850, 850, 850, 850, 850, 845, 851, 845, 847,\n+    847, 847, 81, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852, 852,\n+    852, 852, 852, 852, 852, 852, 852, 852, 81, 81, 81, 853, 853, 853, 853,\n+    853, 853, 853, 853, 853, 853, 81, 853, 853, 853, 853, 853, 853, 853, 853,\n+    853, 854, 854, 854, 855, 855, 855, 854, 854, 855, 856, 857, 855, 858,\n+    858, 859, 858, 858, 859, 855, 81, 860, 860, 860, 860, 860, 860, 860, 81,\n+    860, 81, 860, 860, 860, 860, 81, 860, 860, 860, 860, 860, 860, 860, 860,\n+    860, 860, 860, 860, 860, 860, 860, 81, 860, 860, 861, 81, 81, 81, 81, 81,\n+    81, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862, 862,\n+    862, 863, 864, 864, 864, 863, 863, 863, 863, 863, 863, 865, 866, 81, 81,\n+    81, 81, 81, 867, 867, 867, 867, 867, 867, 867, 867, 867, 867, 81, 81, 81,\n+    81, 81, 81, 868, 868, 869, 869, 81, 870, 870, 870, 870, 870, 870, 870,\n+    870, 81, 81, 870, 870, 81, 81, 870, 870, 870, 870, 870, 870, 870, 870,\n+    870, 870, 870, 870, 870, 870, 81, 870, 870, 870, 870, 870, 870, 870, 81,\n+    870, 870, 81, 870, 870, 870, 870, 870, 81, 871, 872, 870, 869, 869, 868,\n+    869, 869, 869, 869, 81, 81, 869, 869, 81, 81, 869, 869, 873, 81, 81, 870,\n+    81, 81, 81, 81, 81, 81, 869, 81, 81, 81, 81, 81, 870, 870, 870, 870, 870,\n+    869, 869, 81, 81, 874, 874, 874, 874, 874, 874, 874, 81, 81, 81, 875,\n+    875, 875, 875, 875, 875, 875, 875, 875, 875, 875, 875, 875, 876, 876,\n+    876, 877, 877, 877, 877, 877, 877, 877, 877, 876, 876, 878, 877, 877,\n+    876, 879, 875, 875, 875, 875, 880, 880, 880, 880, 881, 882, 882, 882,\n+    882, 882, 882, 882, 882, 882, 882, 81, 880, 81, 881, 883, 81, 884, 884,\n+    884, 884, 884, 884, 884, 884, 885, 885, 885, 886, 886, 886, 886, 886,\n+    886, 885, 886, 885, 885, 885, 885, 886, 886, 885, 887, 888, 884, 884,\n+    889, 884, 890, 890, 890, 890, 890, 890, 890, 890, 890, 890, 81, 81, 81,\n+    81, 81, 81, 891, 891, 891, 891, 891, 891, 891, 891, 891, 891, 891, 891,\n+    891, 891, 891, 892, 892, 892, 893, 893, 893, 893, 81, 81, 892, 892, 892,\n+    892, 893, 893, 892, 894, 895, 896, 897, 897, 898, 898, 899, 899, 899,\n+    897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897, 897,\n+    897, 891, 891, 891, 891, 893, 893, 81, 81, 900, 900, 900, 900, 900, 900,\n+    900, 900, 901, 901, 901, 902, 902, 902, 902, 902, 902, 902, 902, 901,\n+    901, 902, 901, 903, 902, 904, 904, 905, 900, 81, 81, 81, 906, 906, 906,\n+    906, 906, 906, 906, 906, 906, 906, 81, 81, 81, 81, 81, 81, 907, 907, 907,\n+    907, 907, 907, 907, 907, 907, 907, 907, 907, 907, 81, 81, 81, 908, 908,\n+    908, 908, 908, 908, 908, 908, 908, 908, 908, 909, 910, 909, 910, 910,\n+    909, 909, 909, 909, 909, 909, 911, 912, 913, 913, 913, 913, 913, 913,\n+    913, 913, 913, 913, 81, 81, 81, 81, 81, 81, 914, 914, 914, 914, 914, 914,\n+    914, 914, 914, 914, 914, 81, 81, 915, 915, 915, 916, 916, 915, 915, 915,\n+    915, 916, 915, 915, 915, 915, 917, 81, 81, 81, 81, 918, 918, 918, 918,\n+    918, 918, 918, 918, 918, 918, 919, 919, 920, 920, 920, 921, 922, 922,\n+    922, 922, 922, 922, 922, 922, 922, 922, 922, 922, 923, 923, 923, 924,\n+    924, 924, 924, 924, 924, 924, 924, 924, 923, 925, 926, 927, 81, 81, 81,\n+    81, 928, 928, 928, 928, 928, 928, 928, 928, 929, 929, 929, 929, 929, 929,\n+    929, 929, 930, 930, 930, 930, 930, 930, 930, 930, 930, 930, 931, 931,\n+    931, 931, 931, 931, 931, 931, 931, 81, 81, 81, 81, 81, 81, 81, 81, 81,\n+    81, 81, 81, 932, 933, 934, 934, 934, 934, 934, 934, 935, 935, 934, 934,\n+    933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933, 933,\n+    933, 933, 934, 936, 934, 934, 934, 934, 937, 933, 934, 934, 934, 934,\n+    938, 939, 940, 940, 940, 940, 938, 939, 936, 941, 942, 942, 942, 942,\n+    942, 942, 943, 943, 942, 942, 942, 941, 941, 941, 941, 941, 941, 941,\n+    941, 941, 941, 941, 941, 941, 941, 941, 941, 81, 81, 941, 941, 941, 941,\n+    942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 942, 943,\n+    942, 944, 945, 945, 945, 941, 946, 946, 946, 945, 945, 81, 81, 81, 81,\n+    81, 947, 947, 947, 947, 947, 947, 947, 947, 947, 81, 81, 81, 81, 81, 81,\n+    81, 948, 948, 948, 948, 948, 948, 948, 948, 948, 81, 948, 948, 948, 948,\n+    948, 948, 948, 948, 948, 948, 948, 948, 948, 949, 950, 950, 950, 950,\n+    950, 950, 950, 81, 950, 950, 950, 950, 950, 950, 949, 951, 948, 952, 952,\n+    952, 952, 952, 81, 81, 953, 953, 953, 953, 953, 953, 953, 953, 953, 953,\n+    954, 954, 954, 954, 954, 954, 954, 954, 954, 954, 954, 954, 954, 954,\n+    954, 954, 954, 954, 954, 81, 81, 81, 955, 956, 957, 957, 957, 957, 957,\n+    957, 957, 957, 957, 957, 957, 957, 957, 957, 81, 81, 958, 958, 958, 958,\n+    958, 958, 958, 958, 958, 958, 958, 958, 958, 958, 81, 959, 958, 958, 958,\n+    958, 958, 958, 958, 959, 958, 958, 959, 958, 958, 81, 960, 960, 960, 960,\n+    960, 960, 960, 81, 960, 960, 81, 960, 960, 960, 960, 960, 960, 960, 960,\n+    960, 960, 960, 960, 960, 960, 961, 961, 961, 961, 961, 961, 81, 81, 81,\n+    961, 81, 961, 961, 81, 961, 961, 961, 962, 961, 963, 963, 960, 961, 964,\n+    964, 964, 964, 964, 964, 964, 964, 964, 964, 81, 81, 81, 81, 81, 81, 965,\n+    965, 965, 965, 965, 965, 81, 965, 965, 81, 965, 965, 965, 965, 965, 965,\n+    965, 965, 965, 965, 965, 965, 965, 965, 965, 965, 966, 966, 966, 966,\n+    966, 81, 967, 967, 81, 966, 966, 967, 966, 968, 965, 81, 81, 81, 81, 81,\n+    81, 81, 969, 969, 969, 969, 969, 969, 969, 969, 969, 969, 81, 81, 81, 81,\n+    81, 81, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 970, 971, 971,\n+    972, 972, 973, 973, 81, 81, 81, 81, 81, 81, 81, 974, 974, 974, 974, 974,\n+    974, 974, 974, 974, 974, 81, 81, 81, 81, 81, 81, 975, 975, 975, 975, 975,\n+    975, 975, 975, 975, 975, 975, 975, 975, 975, 975, 81, 976, 976, 976, 976,\n+    976, 81, 81, 81, 974, 974, 974, 974, 81, 81, 81, 81, 977, 977, 977, 977,\n+    977, 977, 977, 977, 978, 978, 978, 979, 979, 979, 977, 977, 977, 977,\n+    979, 977, 977, 977, 978, 979, 978, 979, 977, 977, 977, 977, 977, 977,\n+    977, 978, 979, 979, 977, 977, 977, 977, 977, 977, 977, 977, 977, 977,\n+    977, 81, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980, 980,\n+    980, 981, 982, 980, 980, 980, 980, 980, 980, 980, 81, 608, 81, 81, 81,\n+    81, 81, 81, 81, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983, 983,\n+    983, 983, 983, 983, 81, 984, 984, 984, 984, 984, 984, 984, 984, 984, 984,\n+    81, 81, 81, 81, 985, 985, 986, 986, 986, 986, 986, 986, 986, 986, 986,\n+    986, 986, 986, 986, 986, 81, 81, 987, 987, 987, 987, 987, 988, 81, 81,\n+    989, 989, 989, 989, 989, 989, 989, 989, 990, 990, 990, 990, 990, 990,\n+    990, 991, 991, 991, 992, 992, 993, 993, 993, 993, 994, 994, 994, 994,\n+    991, 993, 81, 81, 995, 995, 995, 995, 995, 995, 995, 995, 995, 995, 81,\n+    996, 996, 996, 996, 996, 996, 996, 81, 989, 989, 989, 989, 989, 81, 81,\n+    81, 81, 81, 989, 989, 989, 997, 997, 997, 997, 997, 997, 997, 997, 998,\n+    998, 998, 998, 998, 998, 998, 998, 999, 999, 999, 999, 999, 999, 999,\n+    999, 999, 999, 999, 999, 999, 999, 999, 1000, 1000, 1001, 1001, 81, 81,\n+    81, 81, 81, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 1002, 1002,\n+    1002, 1002, 1002, 81, 81, 81, 1002, 1003, 1003, 1003, 1003, 1003, 1003,\n+    1003, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1003, 1003,\n+    1003, 1003, 1003, 1003, 81, 81, 81, 81, 81, 81, 81, 81, 1004, 1004, 1004,\n+    1004, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1005, 1005,\n+    1005, 1005, 1006, 1007, 81, 81, 81, 81, 81, 81, 1008, 1008, 1008, 1008,\n+    1008, 1008, 1008, 1008, 1008, 1008, 81, 81, 81, 81, 81, 81, 1008, 1008,\n+    1008, 81, 81, 81, 81, 81, 579, 574, 574, 574, 574, 574, 574, 574, 574,\n+    574, 574, 574, 574, 574, 574, 81, 1009, 1009, 1009, 1009, 1009, 1009,\n+    1009, 1009, 1009, 1009, 1009, 1009, 81, 81, 81, 81, 1010, 1010, 1010,\n+    1010, 1010, 1010, 1010, 1010, 1010, 1010, 1010, 81, 81, 81, 81, 81, 1010,\n+    1010, 1010, 1010, 1010, 81, 81, 81, 1010, 81, 81, 81, 81, 81, 81, 81,\n+    1010, 1010, 81, 81, 1011, 1012, 1013, 1014, 503, 503, 503, 503, 81, 81,\n+    81, 81, 317, 317, 317, 317, 317, 317, 81, 81, 317, 317, 317, 317, 317,\n+    317, 317, 81, 81, 317, 317, 317, 317, 317, 317, 317, 317, 317, 317, 317,\n+    317, 1015, 1015, 451, 451, 451, 317, 317, 317, 1016, 1015, 1015, 1015,\n+    1015, 1015, 503, 503, 503, 503, 503, 503, 503, 503, 156, 156, 156, 156,\n+    156, 156, 156, 156, 317, 317, 96, 96, 96, 96, 96, 156, 156, 317, 317,\n+    317, 317, 317, 317, 96, 96, 96, 96, 317, 317, 317, 81, 81, 81, 81, 81,\n+    81, 81, 724, 724, 1017, 1017, 1017, 724, 81, 81, 619, 619, 619, 619, 81,\n+    81, 81, 81, 619, 81, 81, 81, 81, 81, 81, 81, 510, 510, 510, 510, 510,\n+    510, 510, 510, 510, 510, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49, 49,\n+    49, 49, 49, 49, 49, 49, 510, 510, 510, 510, 510, 510, 510, 510, 510, 510,\n+    49, 49, 49, 49, 49, 49, 49, 81, 49, 49, 49, 49, 49, 49, 510, 81, 510,\n+    510, 81, 81, 510, 81, 81, 510, 510, 81, 81, 510, 510, 510, 510, 81, 510,\n+    510, 49, 49, 81, 49, 81, 49, 49, 49, 49, 49, 49, 49, 81, 49, 49, 49, 49,\n+    49, 49, 49, 510, 510, 81, 510, 510, 510, 510, 81, 81, 510, 510, 510, 510,\n+    510, 510, 510, 510, 81, 510, 510, 510, 510, 510, 510, 510, 81, 49, 49,\n+    510, 510, 81, 510, 510, 510, 510, 81, 510, 510, 510, 510, 510, 81, 510,\n+    81, 81, 81, 510, 510, 510, 510, 510, 510, 510, 81, 49, 49, 49, 49, 49,\n+    49, 49, 49, 49, 49, 49, 49, 81, 81, 510, 1018, 49, 49, 49, 49, 49, 49,\n+    49, 49, 49, 496, 49, 49, 49, 49, 49, 49, 510, 510, 510, 510, 510, 510,\n+    510, 510, 510, 1018, 49, 49, 49, 49, 49, 49, 49, 49, 49, 496, 49, 49,\n+    510, 510, 510, 510, 510, 1018, 49, 49, 49, 49, 49, 49, 49, 49, 49, 496,\n+    49, 49, 49, 49, 49, 49, 510, 510, 510, 510, 510, 510, 510, 510, 510,\n+    1018, 49, 496, 49, 49, 49, 49, 49, 49, 49, 49, 510, 49, 81, 81, 1019,\n+    1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1019, 1020, 1020, 1020,\n+    1020, 1020, 1020, 1020, 1020, 1021, 1021, 1021, 1021, 1021, 1021, 1021,\n+    1021, 1021, 1021, 1021, 1021, 1021, 1021, 1021, 1020, 1020, 1020, 1020,\n+    1021, 1021, 1021, 1021, 1021, 1021, 1021, 1021, 1021, 1021, 1020, 1020,\n+    1020, 1020, 1020, 1020, 1020, 1020, 1021, 1020, 1020, 1020, 1020, 1020,\n+    1020, 1021, 1020, 1020, 1022, 1022, 1022, 1022, 1023, 81, 81, 81, 81, 81,\n+    81, 81, 1021, 1021, 1021, 1021, 1021, 81, 1021, 1021, 1021, 1021, 1021,\n+    1021, 1021, 1024, 1024, 1024, 1024, 1024, 1024, 1024, 81, 1024, 1024,\n+    1024, 1024, 1024, 1024, 1024, 1024, 1024, 81, 81, 1024, 1024, 1024, 1024,\n+    1024, 1024, 1024, 81, 1024, 1024, 81, 1024, 1024, 1024, 1024, 1024, 81,\n+    81, 81, 81, 81, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025, 1025,\n+    1025, 1025, 1025, 1025, 81, 81, 1026, 1026, 1026, 1026, 1026, 1026, 1026,\n+    1026, 1026, 1027, 1027, 1027, 1027, 1027, 1027, 1027, 81, 1028, 1028,\n+    1028, 1028, 1028, 1028, 1028, 1028, 1028, 1028, 1029, 1029, 1029, 1029,\n+    1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029, 1029,\n+    1029, 1029, 1030, 1030, 1030, 1030, 1030, 1030, 1031, 81, 81, 81, 81, 81,\n+    1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 1032, 81, 81, 81,\n+    81, 1033, 1033, 81, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034,\n+    1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1034, 1035, 1034,\n+    1034, 1034, 1036, 1034, 1034, 1034, 1034, 81, 81, 81, 146, 146, 146, 146,\n+    81, 146, 146, 146, 81, 146, 146, 81, 146, 81, 81, 146, 81, 146, 146, 146,\n+    146, 146, 146, 146, 146, 146, 146, 81, 146, 146, 146, 146, 81, 146, 81,\n+    146, 81, 81, 81, 81, 81, 81, 146, 81, 81, 81, 81, 146, 81, 146, 81, 146,\n+    81, 146, 146, 146, 81, 146, 81, 146, 81, 146, 81, 146, 81, 146, 146, 146,\n+    146, 81, 146, 81, 146, 146, 81, 146, 146, 146, 146, 146, 146, 146, 146,\n+    146, 81, 81, 81, 81, 81, 146, 146, 146, 81, 146, 146, 146, 132, 132, 81,\n+    81, 81, 81, 81, 81, 529, 529, 529, 529, 525, 529, 529, 529, 529, 529,\n+    529, 529, 529, 529, 529, 529, 529, 529, 529, 529, 1037, 1037, 1037, 1037,\n+    1037, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 529, 529, 529, 529, 529,\n+    529, 529, 1037, 1037, 529, 529, 529, 529, 529, 529, 529, 529, 529, 529,\n+    529, 529, 529, 529, 525, 529, 529, 529, 529, 529, 529, 1037, 1037, 47,\n+    47, 47, 519, 519, 1037, 1037, 1037, 530, 530, 530, 530, 530, 530, 317,\n+    40, 530, 530, 40, 40, 1037, 1037, 1037, 1037, 530, 530, 530, 530, 530,\n+    530, 1038, 530, 530, 1038, 1038, 1038, 1038, 1038, 1038, 1038, 1038,\n+    1038, 1038, 530, 530, 530, 530, 530, 530, 530, 530, 530, 530, 1037, 1037,\n+    1037, 1037, 1037, 1037, 1037, 1037, 1037, 1039, 1039, 1039, 1039, 1039,\n+    1039, 1039, 1039, 1039, 1039, 1040, 585, 585, 1037, 1037, 1037, 1037,\n+    1037, 585, 585, 585, 585, 1037, 1037, 1037, 1037, 585, 1037, 1037, 1037,\n+    1037, 1037, 1037, 1037, 585, 585, 1037, 1037, 1037, 1037, 1037, 1037,\n+    525, 525, 525, 525, 525, 525, 1037, 1037, 525, 529, 529, 529, 529, 529,\n+    529, 529, 529, 529, 529, 529, 529, 525, 525, 525, 525, 525, 525, 525,\n+    525, 525, 529, 525, 525, 525, 525, 525, 525, 529, 525, 525, 525, 525,\n+    525, 525, 525, 536, 525, 525, 525, 525, 525, 525, 529, 529, 529, 529,\n+    529, 529, 529, 529, 40, 40, 529, 529, 525, 525, 525, 525, 525, 528, 528,\n+    525, 525, 525, 525, 525, 528, 525, 525, 525, 525, 525, 536, 536, 536,\n+    525, 525, 536, 525, 525, 536, 534, 534, 529, 529, 525, 525, 529, 529,\n+    529, 525, 529, 529, 529, 525, 525, 525, 1041, 1041, 1041, 1041, 1041,\n+    525, 525, 525, 525, 525, 525, 525, 529, 525, 529, 536, 536, 525, 525,\n+    536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 525, 525, 525,\n+    525, 525, 525, 525, 525, 525, 525, 525, 525, 525, 536, 536, 536, 536,\n+    525, 525, 525, 525, 536, 525, 536, 525, 525, 525, 536, 525, 525, 525,\n+    525, 536, 536, 536, 525, 536, 536, 536, 528, 525, 528, 525, 528, 525,\n+    525, 525, 525, 525, 536, 525, 525, 525, 525, 528, 525, 528, 528, 525,\n+    525, 525, 525, 525, 525, 525, 525, 525, 525, 529, 529, 525, 528, 528,\n+    528, 528, 528, 528, 528, 525, 525, 525, 525, 525, 525, 525, 525, 528,\n+    528, 528, 528, 528, 528, 525, 525, 525, 525, 525, 528, 528, 528, 528,\n+    528, 528, 528, 528, 528, 528, 528, 528, 40, 40, 40, 40, 529, 525, 525,\n+    525, 525, 529, 529, 529, 529, 529, 534, 534, 529, 529, 529, 529, 536,\n+    529, 529, 529, 529, 529, 534, 529, 529, 529, 529, 536, 536, 529, 529,\n+    529, 529, 529, 40, 40, 40, 40, 40, 40, 40, 40, 529, 529, 529, 529, 40,\n+    40, 529, 525, 525, 525, 525, 525, 525, 525, 525, 525, 525, 536, 536, 536,\n+    525, 525, 525, 536, 536, 536, 536, 536, 40, 40, 40, 40, 40, 40, 538, 538,\n+    538, 1042, 1042, 1042, 40, 40, 40, 40, 525, 525, 525, 536, 525, 525, 525,\n+    525, 525, 525, 525, 525, 536, 536, 536, 525, 536, 525, 525, 525, 525,\n+    525, 529, 529, 529, 529, 529, 529, 536, 529, 529, 529, 525, 525, 525,\n+    529, 529, 1037, 1037, 1037, 529, 529, 529, 525, 525, 1037, 1037, 1037,\n+    529, 529, 529, 529, 525, 525, 525, 525, 525, 525, 1037, 1037, 1037, 1037,\n+    1037, 1037, 40, 40, 40, 40, 1037, 1037, 1037, 1037, 40, 40, 40, 40, 40,\n+    529, 529, 529, 529, 1037, 1037, 1037, 1037, 1037, 1037, 1037, 40, 40,\n+    1037, 1037, 1037, 1037, 1037, 1037, 40, 40, 40, 40, 40, 40, 1037, 1037,\n+    536, 536, 536, 536, 536, 525, 536, 536, 525, 525, 525, 525, 525, 525,\n+    536, 525, 536, 536, 525, 525, 525, 536, 536, 1037, 525, 1037, 1037, 525,\n+    525, 525, 525, 1037, 1037, 1037, 525, 1037, 525, 525, 525, 525, 525, 525,\n+    525, 1037, 1037, 1037, 1037, 1037, 525, 525, 525, 525, 525, 536, 536,\n+    525, 536, 536, 1037, 1037, 1037, 1037, 1037, 1037, 525, 536, 536, 536,\n+    536, 536, 536, 536, 536, 536, 536, 536, 536, 536, 525, 525, 1037, 1037,\n+    1037, 1037, 1037, 1037, 81, 81, 592, 592, 592, 592, 592, 592, 592, 593,\n+    592, 592, 592, 592, 592, 593, 593, 593, 592, 593, 593, 593, 593, 593,\n+    593, 593, 593, 593, 593, 593, 593, 593, 81, 81, 81, 503, 81, 81, 81, 81,\n+    81, 81, 503, 503, 503, 503, 503, 503, 503, 503, 670, 670, 670, 670, 670,\n+    670, 81, 81,\n+};\n+\n+\/* decomposition data *\/\n+static const unsigned short decomp_data[] = {\n+    0, 257, 32, 514, 32, 776, 259, 97, 514, 32, 772, 259, 50, 259, 51, 514,\n+    32, 769, 258, 956, 514, 32, 807, 259, 49, 259, 111, 772, 49, 8260, 52,\n+    772, 49, 8260, 50, 772, 51, 8260, 52, 512, 65, 768, 512, 65, 769, 512,\n+    65, 770, 512, 65, 771, 512, 65, 776, 512, 65, 778, 512, 67, 807, 512, 69,\n+    768, 512, 69, 769, 512, 69, 770, 512, 69, 776, 512, 73, 768, 512, 73,\n+    769, 512, 73, 770, 512, 73, 776, 512, 78, 771, 512, 79, 768, 512, 79,\n+    769, 512, 79, 770, 512, 79, 771, 512, 79, 776, 512, 85, 768, 512, 85,\n+    769, 512, 85, 770, 512, 85, 776, 512, 89, 769, 512, 97, 768, 512, 97,\n+    769, 512, 97, 770, 512, 97, 771, 512, 97, 776, 512, 97, 778, 512, 99,\n+    807, 512, 101, 768, 512, 101, 769, 512, 101, 770, 512, 101, 776, 512,\n+    105, 768, 512, 105, 769, 512, 105, 770, 512, 105, 776, 512, 110, 771,\n+    512, 111, 768, 512, 111, 769, 512, 111, 770, 512, 111, 771, 512, 111,\n+    776, 512, 117, 768, 512, 117, 769, 512, 117, 770, 512, 117, 776, 512,\n+    121, 769, 512, 121, 776, 512, 65, 772, 512, 97, 772, 512, 65, 774, 512,\n+    97, 774, 512, 65, 808, 512, 97, 808, 512, 67, 769, 512, 99, 769, 512, 67,\n+    770, 512, 99, 770, 512, 67, 775, 512, 99, 775, 512, 67, 780, 512, 99,\n+    780, 512, 68, 780, 512, 100, 780, 512, 69, 772, 512, 101, 772, 512, 69,\n+    774, 512, 101, 774, 512, 69, 775, 512, 101, 775, 512, 69, 808, 512, 101,\n+    808, 512, 69, 780, 512, 101, 780, 512, 71, 770, 512, 103, 770, 512, 71,\n+    774, 512, 103, 774, 512, 71, 775, 512, 103, 775, 512, 71, 807, 512, 103,\n+    807, 512, 72, 770, 512, 104, 770, 512, 73, 771, 512, 105, 771, 512, 73,\n+    772, 512, 105, 772, 512, 73, 774, 512, 105, 774, 512, 73, 808, 512, 105,\n+    808, 512, 73, 775, 514, 73, 74, 514, 105, 106, 512, 74, 770, 512, 106,\n+    770, 512, 75, 807, 512, 107, 807, 512, 76, 769, 512, 108, 769, 512, 76,\n+    807, 512, 108, 807, 512, 76, 780, 512, 108, 780, 514, 76, 183, 514, 108,\n+    183, 512, 78, 769, 512, 110, 769, 512, 78, 807, 512, 110, 807, 512, 78,\n+    780, 512, 110, 780, 514, 700, 110, 512, 79, 772, 512, 111, 772, 512, 79,\n+    774, 512, 111, 774, 512, 79, 779, 512, 111, 779, 512, 82, 769, 512, 114,\n+    769, 512, 82, 807, 512, 114, 807, 512, 82, 780, 512, 114, 780, 512, 83,\n+    769, 512, 115, 769, 512, 83, 770, 512, 115, 770, 512, 83, 807, 512, 115,\n+    807, 512, 83, 780, 512, 115, 780, 512, 84, 807, 512, 116, 807, 512, 84,\n+    780, 512, 116, 780, 512, 85, 771, 512, 117, 771, 512, 85, 772, 512, 117,\n+    772, 512, 85, 774, 512, 117, 774, 512, 85, 778, 512, 117, 778, 512, 85,\n+    779, 512, 117, 779, 512, 85, 808, 512, 117, 808, 512, 87, 770, 512, 119,\n+    770, 512, 89, 770, 512, 121, 770, 512, 89, 776, 512, 90, 769, 512, 122,\n+    769, 512, 90, 775, 512, 122, 775, 512, 90, 780, 512, 122, 780, 258, 115,\n+    512, 79, 795, 512, 111, 795, 512, 85, 795, 512, 117, 795, 514, 68, 381,\n+    514, 68, 382, 514, 100, 382, 514, 76, 74, 514, 76, 106, 514, 108, 106,\n+    514, 78, 74, 514, 78, 106, 514, 110, 106, 512, 65, 780, 512, 97, 780,\n+    512, 73, 780, 512, 105, 780, 512, 79, 780, 512, 111, 780, 512, 85, 780,\n+    512, 117, 780, 512, 220, 772, 512, 252, 772, 512, 220, 769, 512, 252,\n+    769, 512, 220, 780, 512, 252, 780, 512, 220, 768, 512, 252, 768, 512,\n+    196, 772, 512, 228, 772, 512, 550, 772, 512, 551, 772, 512, 198, 772,\n+    512, 230, 772, 512, 71, 780, 512, 103, 780, 512, 75, 780, 512, 107, 780,\n+    512, 79, 808, 512, 111, 808, 512, 490, 772, 512, 491, 772, 512, 439, 780,\n+    512, 658, 780, 512, 106, 780, 514, 68, 90, 514, 68, 122, 514, 100, 122,\n+    512, 71, 769, 512, 103, 769, 512, 78, 768, 512, 110, 768, 512, 197, 769,\n+    512, 229, 769, 512, 198, 769, 512, 230, 769, 512, 216, 769, 512, 248,\n+    769, 512, 65, 783, 512, 97, 783, 512, 65, 785, 512, 97, 785, 512, 69,\n+    783, 512, 101, 783, 512, 69, 785, 512, 101, 785, 512, 73, 783, 512, 105,\n+    783, 512, 73, 785, 512, 105, 785, 512, 79, 783, 512, 111, 783, 512, 79,\n+    785, 512, 111, 785, 512, 82, 783, 512, 114, 783, 512, 82, 785, 512, 114,\n+    785, 512, 85, 783, 512, 117, 783, 512, 85, 785, 512, 117, 785, 512, 83,\n+    806, 512, 115, 806, 512, 84, 806, 512, 116, 806, 512, 72, 780, 512, 104,\n+    780, 512, 65, 775, 512, 97, 775, 512, 69, 807, 512, 101, 807, 512, 214,\n+    772, 512, 246, 772, 512, 213, 772, 512, 245, 772, 512, 79, 775, 512, 111,\n+    775, 512, 558, 772, 512, 559, 772, 512, 89, 772, 512, 121, 772, 259, 104,\n+    259, 614, 259, 106, 259, 114, 259, 633, 259, 635, 259, 641, 259, 119,\n+    259, 121, 514, 32, 774, 514, 32, 775, 514, 32, 778, 514, 32, 808, 514,\n+    32, 771, 514, 32, 779, 259, 611, 259, 108, 259, 115, 259, 120, 259, 661,\n+    256, 768, 256, 769, 256, 787, 512, 776, 769, 256, 697, 514, 32, 837, 256,\n+    59, 514, 32, 769, 512, 168, 769, 512, 913, 769, 256, 183, 512, 917, 769,\n+    512, 919, 769, 512, 921, 769, 512, 927, 769, 512, 933, 769, 512, 937,\n+    769, 512, 970, 769, 512, 921, 776, 512, 933, 776, 512, 945, 769, 512,\n+    949, 769, 512, 951, 769, 512, 953, 769, 512, 971, 769, 512, 953, 776,\n+    512, 965, 776, 512, 959, 769, 512, 965, 769, 512, 969, 769, 258, 946,\n+    258, 952, 258, 933, 512, 978, 769, 512, 978, 776, 258, 966, 258, 960,\n+    258, 954, 258, 961, 258, 962, 258, 920, 258, 949, 258, 931, 512, 1045,\n+    768, 512, 1045, 776, 512, 1043, 769, 512, 1030, 776, 512, 1050, 769, 512,\n+    1048, 768, 512, 1059, 774, 512, 1048, 774, 512, 1080, 774, 512, 1077,\n+    768, 512, 1077, 776, 512, 1075, 769, 512, 1110, 776, 512, 1082, 769, 512,\n+    1080, 768, 512, 1091, 774, 512, 1140, 783, 512, 1141, 783, 512, 1046,\n+    774, 512, 1078, 774, 512, 1040, 774, 512, 1072, 774, 512, 1040, 776, 512,\n+    1072, 776, 512, 1045, 774, 512, 1077, 774, 512, 1240, 776, 512, 1241,\n+    776, 512, 1046, 776, 512, 1078, 776, 512, 1047, 776, 512, 1079, 776, 512,\n+    1048, 772, 512, 1080, 772, 512, 1048, 776, 512, 1080, 776, 512, 1054,\n+    776, 512, 1086, 776, 512, 1256, 776, 512, 1257, 776, 512, 1069, 776, 512,\n+    1101, 776, 512, 1059, 772, 512, 1091, 772, 512, 1059, 776, 512, 1091,\n+    776, 512, 1059, 779, 512, 1091, 779, 512, 1063, 776, 512, 1095, 776, 512,\n+    1067, 776, 512, 1099, 776, 514, 1381, 1410, 512, 1575, 1619, 512, 1575,\n+    1620, 512, 1608, 1620, 512, 1575, 1621, 512, 1610, 1620, 514, 1575, 1652,\n+    514, 1608, 1652, 514, 1735, 1652, 514, 1610, 1652, 512, 1749, 1620, 512,\n+    1729, 1620, 512, 1746, 1620, 512, 2344, 2364, 512, 2352, 2364, 512, 2355,\n+    2364, 512, 2325, 2364, 512, 2326, 2364, 512, 2327, 2364, 512, 2332, 2364,\n+    512, 2337, 2364, 512, 2338, 2364, 512, 2347, 2364, 512, 2351, 2364, 512,\n+    2503, 2494, 512, 2503, 2519, 512, 2465, 2492, 512, 2466, 2492, 512, 2479,\n+    2492, 512, 2610, 2620, 512, 2616, 2620, 512, 2582, 2620, 512, 2583, 2620,\n+    512, 2588, 2620, 512, 2603, 2620, 512, 2887, 2902, 512, 2887, 2878, 512,\n+    2887, 2903, 512, 2849, 2876, 512, 2850, 2876, 512, 2962, 3031, 512, 3014,\n+    3006, 512, 3015, 3006, 512, 3014, 3031, 512, 3142, 3158, 512, 3263, 3285,\n+    512, 3270, 3285, 512, 3270, 3286, 512, 3270, 3266, 512, 3274, 3285, 512,\n+    3398, 3390, 512, 3399, 3390, 512, 3398, 3415, 512, 3545, 3530, 512, 3545,\n+    3535, 512, 3548, 3530, 512, 3545, 3551, 514, 3661, 3634, 514, 3789, 3762,\n+    514, 3755, 3737, 514, 3755, 3745, 257, 3851, 512, 3906, 4023, 512, 3916,\n+    4023, 512, 3921, 4023, 512, 3926, 4023, 512, 3931, 4023, 512, 3904, 4021,\n+    512, 3953, 3954, 512, 3953, 3956, 512, 4018, 3968, 514, 4018, 3969, 512,\n+    4019, 3968, 514, 4019, 3969, 512, 3953, 3968, 512, 3986, 4023, 512, 3996,\n+    4023, 512, 4001, 4023, 512, 4006, 4023, 512, 4011, 4023, 512, 3984, 4021,\n+    512, 4133, 4142, 259, 4316, 512, 6917, 6965, 512, 6919, 6965, 512, 6921,\n+    6965, 512, 6923, 6965, 512, 6925, 6965, 512, 6929, 6965, 512, 6970, 6965,\n+    512, 6972, 6965, 512, 6974, 6965, 512, 6975, 6965, 512, 6978, 6965, 259,\n+    65, 259, 198, 259, 66, 259, 68, 259, 69, 259, 398, 259, 71, 259, 72, 259,\n+    73, 259, 74, 259, 75, 259, 76, 259, 77, 259, 78, 259, 79, 259, 546, 259,\n+    80, 259, 82, 259, 84, 259, 85, 259, 87, 259, 97, 259, 592, 259, 593, 259,\n+    7426, 259, 98, 259, 100, 259, 101, 259, 601, 259, 603, 259, 604, 259,\n+    103, 259, 107, 259, 109, 259, 331, 259, 111, 259, 596, 259, 7446, 259,\n+    7447, 259, 112, 259, 116, 259, 117, 259, 7453, 259, 623, 259, 118, 259,\n+    7461, 259, 946, 259, 947, 259, 948, 259, 966, 259, 967, 261, 105, 261,\n+    114, 261, 117, 261, 118, 261, 946, 261, 947, 261, 961, 261, 966, 261,\n+    967, 259, 1085, 259, 594, 259, 99, 259, 597, 259, 240, 259, 604, 259,\n+    102, 259, 607, 259, 609, 259, 613, 259, 616, 259, 617, 259, 618, 259,\n+    7547, 259, 669, 259, 621, 259, 7557, 259, 671, 259, 625, 259, 624, 259,\n+    626, 259, 627, 259, 628, 259, 629, 259, 632, 259, 642, 259, 643, 259,\n+    427, 259, 649, 259, 650, 259, 7452, 259, 651, 259, 652, 259, 122, 259,\n+    656, 259, 657, 259, 658, 259, 952, 512, 65, 805, 512, 97, 805, 512, 66,\n+    775, 512, 98, 775, 512, 66, 803, 512, 98, 803, 512, 66, 817, 512, 98,\n+    817, 512, 199, 769, 512, 231, 769, 512, 68, 775, 512, 100, 775, 512, 68,\n+    803, 512, 100, 803, 512, 68, 817, 512, 100, 817, 512, 68, 807, 512, 100,\n+    807, 512, 68, 813, 512, 100, 813, 512, 274, 768, 512, 275, 768, 512, 274,\n+    769, 512, 275, 769, 512, 69, 813, 512, 101, 813, 512, 69, 816, 512, 101,\n+    816, 512, 552, 774, 512, 553, 774, 512, 70, 775, 512, 102, 775, 512, 71,\n+    772, 512, 103, 772, 512, 72, 775, 512, 104, 775, 512, 72, 803, 512, 104,\n+    803, 512, 72, 776, 512, 104, 776, 512, 72, 807, 512, 104, 807, 512, 72,\n+    814, 512, 104, 814, 512, 73, 816, 512, 105, 816, 512, 207, 769, 512, 239,\n+    769, 512, 75, 769, 512, 107, 769, 512, 75, 803, 512, 107, 803, 512, 75,\n+    817, 512, 107, 817, 512, 76, 803, 512, 108, 803, 512, 7734, 772, 512,\n+    7735, 772, 512, 76, 817, 512, 108, 817, 512, 76, 813, 512, 108, 813, 512,\n+    77, 769, 512, 109, 769, 512, 77, 775, 512, 109, 775, 512, 77, 803, 512,\n+    109, 803, 512, 78, 775, 512, 110, 775, 512, 78, 803, 512, 110, 803, 512,\n+    78, 817, 512, 110, 817, 512, 78, 813, 512, 110, 813, 512, 213, 769, 512,\n+    245, 769, 512, 213, 776, 512, 245, 776, 512, 332, 768, 512, 333, 768,\n+    512, 332, 769, 512, 333, 769, 512, 80, 769, 512, 112, 769, 512, 80, 775,\n+    512, 112, 775, 512, 82, 775, 512, 114, 775, 512, 82, 803, 512, 114, 803,\n+    512, 7770, 772, 512, 7771, 772, 512, 82, 817, 512, 114, 817, 512, 83,\n+    775, 512, 115, 775, 512, 83, 803, 512, 115, 803, 512, 346, 775, 512, 347,\n+    775, 512, 352, 775, 512, 353, 775, 512, 7778, 775, 512, 7779, 775, 512,\n+    84, 775, 512, 116, 775, 512, 84, 803, 512, 116, 803, 512, 84, 817, 512,\n+    116, 817, 512, 84, 813, 512, 116, 813, 512, 85, 804, 512, 117, 804, 512,\n+    85, 816, 512, 117, 816, 512, 85, 813, 512, 117, 813, 512, 360, 769, 512,\n+    361, 769, 512, 362, 776, 512, 363, 776, 512, 86, 771, 512, 118, 771, 512,\n+    86, 803, 512, 118, 803, 512, 87, 768, 512, 119, 768, 512, 87, 769, 512,\n+    119, 769, 512, 87, 776, 512, 119, 776, 512, 87, 775, 512, 119, 775, 512,\n+    87, 803, 512, 119, 803, 512, 88, 775, 512, 120, 775, 512, 88, 776, 512,\n+    120, 776, 512, 89, 775, 512, 121, 775, 512, 90, 770, 512, 122, 770, 512,\n+    90, 803, 512, 122, 803, 512, 90, 817, 512, 122, 817, 512, 104, 817, 512,\n+    116, 776, 512, 119, 778, 512, 121, 778, 514, 97, 702, 512, 383, 775, 512,\n+    65, 803, 512, 97, 803, 512, 65, 777, 512, 97, 777, 512, 194, 769, 512,\n+    226, 769, 512, 194, 768, 512, 226, 768, 512, 194, 777, 512, 226, 777,\n+    512, 194, 771, 512, 226, 771, 512, 7840, 770, 512, 7841, 770, 512, 258,\n+    769, 512, 259, 769, 512, 258, 768, 512, 259, 768, 512, 258, 777, 512,\n+    259, 777, 512, 258, 771, 512, 259, 771, 512, 7840, 774, 512, 7841, 774,\n+    512, 69, 803, 512, 101, 803, 512, 69, 777, 512, 101, 777, 512, 69, 771,\n+    512, 101, 771, 512, 202, 769, 512, 234, 769, 512, 202, 768, 512, 234,\n+    768, 512, 202, 777, 512, 234, 777, 512, 202, 771, 512, 234, 771, 512,\n+    7864, 770, 512, 7865, 770, 512, 73, 777, 512, 105, 777, 512, 73, 803,\n+    512, 105, 803, 512, 79, 803, 512, 111, 803, 512, 79, 777, 512, 111, 777,\n+    512, 212, 769, 512, 244, 769, 512, 212, 768, 512, 244, 768, 512, 212,\n+    777, 512, 244, 777, 512, 212, 771, 512, 244, 771, 512, 7884, 770, 512,\n+    7885, 770, 512, 416, 769, 512, 417, 769, 512, 416, 768, 512, 417, 768,\n+    512, 416, 777, 512, 417, 777, 512, 416, 771, 512, 417, 771, 512, 416,\n+    803, 512, 417, 803, 512, 85, 803, 512, 117, 803, 512, 85, 777, 512, 117,\n+    777, 512, 431, 769, 512, 432, 769, 512, 431, 768, 512, 432, 768, 512,\n+    431, 777, 512, 432, 777, 512, 431, 771, 512, 432, 771, 512, 431, 803,\n+    512, 432, 803, 512, 89, 768, 512, 121, 768, 512, 89, 803, 512, 121, 803,\n+    512, 89, 777, 512, 121, 777, 512, 89, 771, 512, 121, 771, 512, 945, 787,\n+    512, 945, 788, 512, 7936, 768, 512, 7937, 768, 512, 7936, 769, 512, 7937,\n+    769, 512, 7936, 834, 512, 7937, 834, 512, 913, 787, 512, 913, 788, 512,\n+    7944, 768, 512, 7945, 768, 512, 7944, 769, 512, 7945, 769, 512, 7944,\n+    834, 512, 7945, 834, 512, 949, 787, 512, 949, 788, 512, 7952, 768, 512,\n+    7953, 768, 512, 7952, 769, 512, 7953, 769, 512, 917, 787, 512, 917, 788,\n+    512, 7960, 768, 512, 7961, 768, 512, 7960, 769, 512, 7961, 769, 512, 951,\n+    787, 512, 951, 788, 512, 7968, 768, 512, 7969, 768, 512, 7968, 769, 512,\n+    7969, 769, 512, 7968, 834, 512, 7969, 834, 512, 919, 787, 512, 919, 788,\n+    512, 7976, 768, 512, 7977, 768, 512, 7976, 769, 512, 7977, 769, 512,\n+    7976, 834, 512, 7977, 834, 512, 953, 787, 512, 953, 788, 512, 7984, 768,\n+    512, 7985, 768, 512, 7984, 769, 512, 7985, 769, 512, 7984, 834, 512,\n+    7985, 834, 512, 921, 787, 512, 921, 788, 512, 7992, 768, 512, 7993, 768,\n+    512, 7992, 769, 512, 7993, 769, 512, 7992, 834, 512, 7993, 834, 512, 959,\n+    787, 512, 959, 788, 512, 8000, 768, 512, 8001, 768, 512, 8000, 769, 512,\n+    8001, 769, 512, 927, 787, 512, 927, 788, 512, 8008, 768, 512, 8009, 768,\n+    512, 8008, 769, 512, 8009, 769, 512, 965, 787, 512, 965, 788, 512, 8016,\n+    768, 512, 8017, 768, 512, 8016, 769, 512, 8017, 769, 512, 8016, 834, 512,\n+    8017, 834, 512, 933, 788, 512, 8025, 768, 512, 8025, 769, 512, 8025, 834,\n+    512, 969, 787, 512, 969, 788, 512, 8032, 768, 512, 8033, 768, 512, 8032,\n+    769, 512, 8033, 769, 512, 8032, 834, 512, 8033, 834, 512, 937, 787, 512,\n+    937, 788, 512, 8040, 768, 512, 8041, 768, 512, 8040, 769, 512, 8041, 769,\n+    512, 8040, 834, 512, 8041, 834, 512, 945, 768, 256, 940, 512, 949, 768,\n+    256, 941, 512, 951, 768, 256, 942, 512, 953, 768, 256, 943, 512, 959,\n+    768, 256, 972, 512, 965, 768, 256, 973, 512, 969, 768, 256, 974, 512,\n+    7936, 837, 512, 7937, 837, 512, 7938, 837, 512, 7939, 837, 512, 7940,\n+    837, 512, 7941, 837, 512, 7942, 837, 512, 7943, 837, 512, 7944, 837, 512,\n+    7945, 837, 512, 7946, 837, 512, 7947, 837, 512, 7948, 837, 512, 7949,\n+    837, 512, 7950, 837, 512, 7951, 837, 512, 7968, 837, 512, 7969, 837, 512,\n+    7970, 837, 512, 7971, 837, 512, 7972, 837, 512, 7973, 837, 512, 7974,\n+    837, 512, 7975, 837, 512, 7976, 837, 512, 7977, 837, 512, 7978, 837, 512,\n+    7979, 837, 512, 7980, 837, 512, 7981, 837, 512, 7982, 837, 512, 7983,\n+    837, 512, 8032, 837, 512, 8033, 837, 512, 8034, 837, 512, 8035, 837, 512,\n+    8036, 837, 512, 8037, 837, 512, 8038, 837, 512, 8039, 837, 512, 8040,\n+    837, 512, 8041, 837, 512, 8042, 837, 512, 8043, 837, 512, 8044, 837, 512,\n+    8045, 837, 512, 8046, 837, 512, 8047, 837, 512, 945, 774, 512, 945, 772,\n+    512, 8048, 837, 512, 945, 837, 512, 940, 837, 512, 945, 834, 512, 8118,\n+    837, 512, 913, 774, 512, 913, 772, 512, 913, 768, 256, 902, 512, 913,\n+    837, 514, 32, 787, 256, 953, 514, 32, 787, 514, 32, 834, 512, 168, 834,\n+    512, 8052, 837, 512, 951, 837, 512, 942, 837, 512, 951, 834, 512, 8134,\n+    837, 512, 917, 768, 256, 904, 512, 919, 768, 256, 905, 512, 919, 837,\n+    512, 8127, 768, 512, 8127, 769, 512, 8127, 834, 512, 953, 774, 512, 953,\n+    772, 512, 970, 768, 256, 912, 512, 953, 834, 512, 970, 834, 512, 921,\n+    774, 512, 921, 772, 512, 921, 768, 256, 906, 512, 8190, 768, 512, 8190,\n+    769, 512, 8190, 834, 512, 965, 774, 512, 965, 772, 512, 971, 768, 256,\n+    944, 512, 961, 787, 512, 961, 788, 512, 965, 834, 512, 971, 834, 512,\n+    933, 774, 512, 933, 772, 512, 933, 768, 256, 910, 512, 929, 788, 512,\n+    168, 768, 256, 901, 256, 96, 512, 8060, 837, 512, 969, 837, 512, 974,\n+    837, 512, 969, 834, 512, 8182, 837, 512, 927, 768, 256, 908, 512, 937,\n+    768, 256, 911, 512, 937, 837, 256, 180, 514, 32, 788, 256, 8194, 256,\n+    8195, 258, 32, 258, 32, 258, 32, 258, 32, 258, 32, 257, 32, 258, 32, 258,\n+    32, 258, 32, 257, 8208, 514, 32, 819, 258, 46, 514, 46, 46, 770, 46, 46,\n+    46, 257, 32, 514, 8242, 8242, 770, 8242, 8242, 8242, 514, 8245, 8245,\n+    770, 8245, 8245, 8245, 514, 33, 33, 514, 32, 773, 514, 63, 63, 514, 63,\n+    33, 514, 33, 63, 1026, 8242, 8242, 8242, 8242, 258, 32, 259, 48, 259,\n+    105, 259, 52, 259, 53, 259, 54, 259, 55, 259, 56, 259, 57, 259, 43, 259,\n+    8722, 259, 61, 259, 40, 259, 41, 259, 110, 261, 48, 261, 49, 261, 50,\n+    261, 51, 261, 52, 261, 53, 261, 54, 261, 55, 261, 56, 261, 57, 261, 43,\n+    261, 8722, 261, 61, 261, 40, 261, 41, 261, 97, 261, 101, 261, 111, 261,\n+    120, 261, 601, 261, 104, 261, 107, 261, 108, 261, 109, 261, 110, 261,\n+    112, 261, 115, 261, 116, 514, 82, 115, 770, 97, 47, 99, 770, 97, 47, 115,\n+    262, 67, 514, 176, 67, 770, 99, 47, 111, 770, 99, 47, 117, 258, 400, 514,\n+    176, 70, 262, 103, 262, 72, 262, 72, 262, 72, 262, 104, 262, 295, 262,\n+    73, 262, 73, 262, 76, 262, 108, 262, 78, 514, 78, 111, 262, 80, 262, 81,\n+    262, 82, 262, 82, 262, 82, 515, 83, 77, 770, 84, 69, 76, 515, 84, 77,\n+    262, 90, 256, 937, 262, 90, 256, 75, 256, 197, 262, 66, 262, 67, 262,\n+    101, 262, 69, 262, 70, 262, 77, 262, 111, 258, 1488, 258, 1489, 258,\n+    1490, 258, 1491, 262, 105, 770, 70, 65, 88, 262, 960, 262, 947, 262, 915,\n+    262, 928, 262, 8721, 262, 68, 262, 100, 262, 101, 262, 105, 262, 106,\n+    772, 49, 8260, 55, 772, 49, 8260, 57, 1028, 49, 8260, 49, 48, 772, 49,\n+    8260, 51, 772, 50, 8260, 51, 772, 49, 8260, 53, 772, 50, 8260, 53, 772,\n+    51, 8260, 53, 772, 52, 8260, 53, 772, 49, 8260, 54, 772, 53, 8260, 54,\n+    772, 49, 8260, 56, 772, 51, 8260, 56, 772, 53, 8260, 56, 772, 55, 8260,\n+    56, 516, 49, 8260, 258, 73, 514, 73, 73, 770, 73, 73, 73, 514, 73, 86,\n+    258, 86, 514, 86, 73, 770, 86, 73, 73, 1026, 86, 73, 73, 73, 514, 73, 88,\n+    258, 88, 514, 88, 73, 770, 88, 73, 73, 258, 76, 258, 67, 258, 68, 258,\n+    77, 258, 105, 514, 105, 105, 770, 105, 105, 105, 514, 105, 118, 258, 118,\n+    514, 118, 105, 770, 118, 105, 105, 1026, 118, 105, 105, 105, 514, 105,\n+    120, 258, 120, 514, 120, 105, 770, 120, 105, 105, 258, 108, 258, 99, 258,\n+    100, 258, 109, 772, 48, 8260, 51, 512, 8592, 824, 512, 8594, 824, 512,\n+    8596, 824, 512, 8656, 824, 512, 8660, 824, 512, 8658, 824, 512, 8707,\n+    824, 512, 8712, 824, 512, 8715, 824, 512, 8739, 824, 512, 8741, 824, 514,\n+    8747, 8747, 770, 8747, 8747, 8747, 514, 8750, 8750, 770, 8750, 8750,\n+    8750, 512, 8764, 824, 512, 8771, 824, 512, 8773, 824, 512, 8776, 824,\n+    512, 61, 824, 512, 8801, 824, 512, 8781, 824, 512, 60, 824, 512, 62, 824,\n+    512, 8804, 824, 512, 8805, 824, 512, 8818, 824, 512, 8819, 824, 512,\n+    8822, 824, 512, 8823, 824, 512, 8826, 824, 512, 8827, 824, 512, 8834,\n+    824, 512, 8835, 824, 512, 8838, 824, 512, 8839, 824, 512, 8866, 824, 512,\n+    8872, 824, 512, 8873, 824, 512, 8875, 824, 512, 8828, 824, 512, 8829,\n+    824, 512, 8849, 824, 512, 8850, 824, 512, 8882, 824, 512, 8883, 824, 512,\n+    8884, 824, 512, 8885, 824, 256, 12296, 256, 12297, 263, 49, 263, 50, 263,\n+    51, 263, 52, 263, 53, 263, 54, 263, 55, 263, 56, 263, 57, 519, 49, 48,\n+    519, 49, 49, 519, 49, 50, 519, 49, 51, 519, 49, 52, 519, 49, 53, 519, 49,\n+    54, 519, 49, 55, 519, 49, 56, 519, 49, 57, 519, 50, 48, 770, 40, 49, 41,\n+    770, 40, 50, 41, 770, 40, 51, 41, 770, 40, 52, 41, 770, 40, 53, 41, 770,\n+    40, 54, 41, 770, 40, 55, 41, 770, 40, 56, 41, 770, 40, 57, 41, 1026, 40,\n+    49, 48, 41, 1026, 40, 49, 49, 41, 1026, 40, 49, 50, 41, 1026, 40, 49, 51,\n+    41, 1026, 40, 49, 52, 41, 1026, 40, 49, 53, 41, 1026, 40, 49, 54, 41,\n+    1026, 40, 49, 55, 41, 1026, 40, 49, 56, 41, 1026, 40, 49, 57, 41, 1026,\n+    40, 50, 48, 41, 514, 49, 46, 514, 50, 46, 514, 51, 46, 514, 52, 46, 514,\n+    53, 46, 514, 54, 46, 514, 55, 46, 514, 56, 46, 514, 57, 46, 770, 49, 48,\n+    46, 770, 49, 49, 46, 770, 49, 50, 46, 770, 49, 51, 46, 770, 49, 52, 46,\n+    770, 49, 53, 46, 770, 49, 54, 46, 770, 49, 55, 46, 770, 49, 56, 46, 770,\n+    49, 57, 46, 770, 50, 48, 46, 770, 40, 97, 41, 770, 40, 98, 41, 770, 40,\n+    99, 41, 770, 40, 100, 41, 770, 40, 101, 41, 770, 40, 102, 41, 770, 40,\n+    103, 41, 770, 40, 104, 41, 770, 40, 105, 41, 770, 40, 106, 41, 770, 40,\n+    107, 41, 770, 40, 108, 41, 770, 40, 109, 41, 770, 40, 110, 41, 770, 40,\n+    111, 41, 770, 40, 112, 41, 770, 40, 113, 41, 770, 40, 114, 41, 770, 40,\n+    115, 41, 770, 40, 116, 41, 770, 40, 117, 41, 770, 40, 118, 41, 770, 40,\n+    119, 41, 770, 40, 120, 41, 770, 40, 121, 41, 770, 40, 122, 41, 263, 65,\n+    263, 66, 263, 67, 263, 68, 263, 69, 263, 70, 263, 71, 263, 72, 263, 73,\n+    263, 74, 263, 75, 263, 76, 263, 77, 263, 78, 263, 79, 263, 80, 263, 81,\n+    263, 82, 263, 83, 263, 84, 263, 85, 263, 86, 263, 87, 263, 88, 263, 89,\n+    263, 90, 263, 97, 263, 98, 263, 99, 263, 100, 263, 101, 263, 102, 263,\n+    103, 263, 104, 263, 105, 263, 106, 263, 107, 263, 108, 263, 109, 263,\n+    110, 263, 111, 263, 112, 263, 113, 263, 114, 263, 115, 263, 116, 263,\n+    117, 263, 118, 263, 119, 263, 120, 263, 121, 263, 122, 263, 48, 1026,\n+    8747, 8747, 8747, 8747, 770, 58, 58, 61, 514, 61, 61, 770, 61, 61, 61,\n+    512, 10973, 824, 261, 106, 259, 86, 259, 11617, 258, 27597, 258, 40863,\n+    258, 19968, 258, 20008, 258, 20022, 258, 20031, 258, 20057, 258, 20101,\n+    258, 20108, 258, 20128, 258, 20154, 258, 20799, 258, 20837, 258, 20843,\n+    258, 20866, 258, 20886, 258, 20907, 258, 20960, 258, 20981, 258, 20992,\n+    258, 21147, 258, 21241, 258, 21269, 258, 21274, 258, 21304, 258, 21313,\n+    258, 21340, 258, 21353, 258, 21378, 258, 21430, 258, 21448, 258, 21475,\n+    258, 22231, 258, 22303, 258, 22763, 258, 22786, 258, 22794, 258, 22805,\n+    258, 22823, 258, 22899, 258, 23376, 258, 23424, 258, 23544, 258, 23567,\n+    258, 23586, 258, 23608, 258, 23662, 258, 23665, 258, 24027, 258, 24037,\n+    258, 24049, 258, 24062, 258, 24178, 258, 24186, 258, 24191, 258, 24308,\n+    258, 24318, 258, 24331, 258, 24339, 258, 24400, 258, 24417, 258, 24435,\n+    258, 24515, 258, 25096, 258, 25142, 258, 25163, 258, 25903, 258, 25908,\n+    258, 25991, 258, 26007, 258, 26020, 258, 26041, 258, 26080, 258, 26085,\n+    258, 26352, 258, 26376, 258, 26408, 258, 27424, 258, 27490, 258, 27513,\n+    258, 27571, 258, 27595, 258, 27604, 258, 27611, 258, 27663, 258, 27668,\n+    258, 27700, 258, 28779, 258, 29226, 258, 29238, 258, 29243, 258, 29247,\n+    258, 29255, 258, 29273, 258, 29275, 258, 29356, 258, 29572, 258, 29577,\n+    258, 29916, 258, 29926, 258, 29976, 258, 29983, 258, 29992, 258, 30000,\n+    258, 30091, 258, 30098, 258, 30326, 258, 30333, 258, 30382, 258, 30399,\n+    258, 30446, 258, 30683, 258, 30690, 258, 30707, 258, 31034, 258, 31160,\n+    258, 31166, 258, 31348, 258, 31435, 258, 31481, 258, 31859, 258, 31992,\n+    258, 32566, 258, 32593, 258, 32650, 258, 32701, 258, 32769, 258, 32780,\n+    258, 32786, 258, 32819, 258, 32895, 258, 32905, 258, 33251, 258, 33258,\n+    258, 33267, 258, 33276, 258, 33292, 258, 33307, 258, 33311, 258, 33390,\n+    258, 33394, 258, 33400, 258, 34381, 258, 34411, 258, 34880, 258, 34892,\n+    258, 34915, 258, 35198, 258, 35211, 258, 35282, 258, 35328, 258, 35895,\n+    258, 35910, 258, 35925, 258, 35960, 258, 35997, 258, 36196, 258, 36208,\n+    258, 36275, 258, 36523, 258, 36554, 258, 36763, 258, 36784, 258, 36789,\n+    258, 37009, 258, 37193, 258, 37318, 258, 37324, 258, 37329, 258, 38263,\n+    258, 38272, 258, 38428, 258, 38582, 258, 38585, 258, 38632, 258, 38737,\n+    258, 38750, 258, 38754, 258, 38761, 258, 38859, 258, 38893, 258, 38899,\n+    258, 38913, 258, 39080, 258, 39131, 258, 39135, 258, 39318, 258, 39321,\n+    258, 39340, 258, 39592, 258, 39640, 258, 39647, 258, 39717, 258, 39727,\n+    258, 39730, 258, 39740, 258, 39770, 258, 40165, 258, 40565, 258, 40575,\n+    258, 40613, 258, 40635, 258, 40643, 258, 40653, 258, 40657, 258, 40697,\n+    258, 40701, 258, 40718, 258, 40723, 258, 40736, 258, 40763, 258, 40778,\n+    258, 40786, 258, 40845, 258, 40860, 258, 40864, 264, 32, 258, 12306, 258,\n+    21313, 258, 21316, 258, 21317, 512, 12363, 12441, 512, 12365, 12441, 512,\n+    12367, 12441, 512, 12369, 12441, 512, 12371, 12441, 512, 12373, 12441,\n+    512, 12375, 12441, 512, 12377, 12441, 512, 12379, 12441, 512, 12381,\n+    12441, 512, 12383, 12441, 512, 12385, 12441, 512, 12388, 12441, 512,\n+    12390, 12441, 512, 12392, 12441, 512, 12399, 12441, 512, 12399, 12442,\n+    512, 12402, 12441, 512, 12402, 12442, 512, 12405, 12441, 512, 12405,\n+    12442, 512, 12408, 12441, 512, 12408, 12442, 512, 12411, 12441, 512,\n+    12411, 12442, 512, 12358, 12441, 514, 32, 12441, 514, 32, 12442, 512,\n+    12445, 12441, 521, 12424, 12426, 512, 12459, 12441, 512, 12461, 12441,\n+    512, 12463, 12441, 512, 12465, 12441, 512, 12467, 12441, 512, 12469,\n+    12441, 512, 12471, 12441, 512, 12473, 12441, 512, 12475, 12441, 512,\n+    12477, 12441, 512, 12479, 12441, 512, 12481, 12441, 512, 12484, 12441,\n+    512, 12486, 12441, 512, 12488, 12441, 512, 12495, 12441, 512, 12495,\n+    12442, 512, 12498, 12441, 512, 12498, 12442, 512, 12501, 12441, 512,\n+    12501, 12442, 512, 12504, 12441, 512, 12504, 12442, 512, 12507, 12441,\n+    512, 12507, 12442, 512, 12454, 12441, 512, 12527, 12441, 512, 12528,\n+    12441, 512, 12529, 12441, 512, 12530, 12441, 512, 12541, 12441, 521,\n+    12467, 12488, 258, 4352, 258, 4353, 258, 4522, 258, 4354, 258, 4524, 258,\n+    4525, 258, 4355, 258, 4356, 258, 4357, 258, 4528, 258, 4529, 258, 4530,\n+    258, 4531, 258, 4532, 258, 4533, 258, 4378, 258, 4358, 258, 4359, 258,\n+    4360, 258, 4385, 258, 4361, 258, 4362, 258, 4363, 258, 4364, 258, 4365,\n+    258, 4366, 258, 4367, 258, 4368, 258, 4369, 258, 4370, 258, 4449, 258,\n+    4450, 258, 4451, 258, 4452, 258, 4453, 258, 4454, 258, 4455, 258, 4456,\n+    258, 4457, 258, 4458, 258, 4459, 258, 4460, 258, 4461, 258, 4462, 258,\n+    4463, 258, 4464, 258, 4465, 258, 4466, 258, 4467, 258, 4468, 258, 4469,\n+    258, 4448, 258, 4372, 258, 4373, 258, 4551, 258, 4552, 258, 4556, 258,\n+    4558, 258, 4563, 258, 4567, 258, 4569, 258, 4380, 258, 4573, 258, 4575,\n+    258, 4381, 258, 4382, 258, 4384, 258, 4386, 258, 4387, 258, 4391, 258,\n+    4393, 258, 4395, 258, 4396, 258, 4397, 258, 4398, 258, 4399, 258, 4402,\n+    258, 4406, 258, 4416, 258, 4423, 258, 4428, 258, 4593, 258, 4594, 258,\n+    4439, 258, 4440, 258, 4441, 258, 4484, 258, 4485, 258, 4488, 258, 4497,\n+    258, 4498, 258, 4500, 258, 4510, 258, 4513, 259, 19968, 259, 20108, 259,\n+    19977, 259, 22235, 259, 19978, 259, 20013, 259, 19979, 259, 30002, 259,\n+    20057, 259, 19993, 259, 19969, 259, 22825, 259, 22320, 259, 20154, 770,\n+    40, 4352, 41, 770, 40, 4354, 41, 770, 40, 4355, 41, 770, 40, 4357, 41,\n+    770, 40, 4358, 41, 770, 40, 4359, 41, 770, 40, 4361, 41, 770, 40, 4363,\n+    41, 770, 40, 4364, 41, 770, 40, 4366, 41, 770, 40, 4367, 41, 770, 40,\n+    4368, 41, 770, 40, 4369, 41, 770, 40, 4370, 41, 1026, 40, 4352, 4449, 41,\n+    1026, 40, 4354, 4449, 41, 1026, 40, 4355, 4449, 41, 1026, 40, 4357, 4449,\n+    41, 1026, 40, 4358, 4449, 41, 1026, 40, 4359, 4449, 41, 1026, 40, 4361,\n+    4449, 41, 1026, 40, 4363, 4449, 41, 1026, 40, 4364, 4449, 41, 1026, 40,\n+    4366, 4449, 41, 1026, 40, 4367, 4449, 41, 1026, 40, 4368, 4449, 41, 1026,\n+    40, 4369, 4449, 41, 1026, 40, 4370, 4449, 41, 1026, 40, 4364, 4462, 41,\n+    1794, 40, 4363, 4457, 4364, 4453, 4523, 41, 1538, 40, 4363, 4457, 4370,\n+    4462, 41, 770, 40, 19968, 41, 770, 40, 20108, 41, 770, 40, 19977, 41,\n+    770, 40, 22235, 41, 770, 40, 20116, 41, 770, 40, 20845, 41, 770, 40,\n+    19971, 41, 770, 40, 20843, 41, 770, 40, 20061, 41, 770, 40, 21313, 41,\n+    770, 40, 26376, 41, 770, 40, 28779, 41, 770, 40, 27700, 41, 770, 40,\n+    26408, 41, 770, 40, 37329, 41, 770, 40, 22303, 41, 770, 40, 26085, 41,\n+    770, 40, 26666, 41, 770, 40, 26377, 41, 770, 40, 31038, 41, 770, 40,\n+    21517, 41, 770, 40, 29305, 41, 770, 40, 36001, 41, 770, 40, 31069, 41,\n+    770, 40, 21172, 41, 770, 40, 20195, 41, 770, 40, 21628, 41, 770, 40,\n+    23398, 41, 770, 40, 30435, 41, 770, 40, 20225, 41, 770, 40, 36039, 41,\n+    770, 40, 21332, 41, 770, 40, 31085, 41, 770, 40, 20241, 41, 770, 40,\n+    33258, 41, 770, 40, 33267, 41, 263, 21839, 263, 24188, 263, 25991, 263,\n+    31631, 778, 80, 84, 69, 519, 50, 49, 519, 50, 50, 519, 50, 51, 519, 50,\n+    52, 519, 50, 53, 519, 50, 54, 519, 50, 55, 519, 50, 56, 519, 50, 57, 519,\n+    51, 48, 519, 51, 49, 519, 51, 50, 519, 51, 51, 519, 51, 52, 519, 51, 53,\n+    263, 4352, 263, 4354, 263, 4355, 263, 4357, 263, 4358, 263, 4359, 263,\n+    4361, 263, 4363, 263, 4364, 263, 4366, 263, 4367, 263, 4368, 263, 4369,\n+    263, 4370, 519, 4352, 4449, 519, 4354, 4449, 519, 4355, 4449, 519, 4357,\n+    4449, 519, 4358, 4449, 519, 4359, 4449, 519, 4361, 4449, 519, 4363, 4449,\n+    519, 4364, 4449, 519, 4366, 4449, 519, 4367, 4449, 519, 4368, 4449, 519,\n+    4369, 4449, 519, 4370, 4449, 1287, 4366, 4449, 4535, 4352, 4457, 1031,\n+    4364, 4462, 4363, 4468, 519, 4363, 4462, 263, 19968, 263, 20108, 263,\n+    19977, 263, 22235, 263, 20116, 263, 20845, 263, 19971, 263, 20843, 263,\n+    20061, 263, 21313, 263, 26376, 263, 28779, 263, 27700, 263, 26408, 263,\n+    37329, 263, 22303, 263, 26085, 263, 26666, 263, 26377, 263, 31038, 263,\n+    21517, 263, 29305, 263, 36001, 263, 31069, 263, 21172, 263, 31192, 263,\n+    30007, 263, 22899, 263, 36969, 263, 20778, 263, 21360, 263, 27880, 263,\n+    38917, 263, 20241, 263, 20889, 263, 27491, 263, 19978, 263, 20013, 263,\n+    19979, 263, 24038, 263, 21491, 263, 21307, 263, 23447, 263, 23398, 263,\n+    30435, 263, 20225, 263, 36039, 263, 21332, 263, 22812, 519, 51, 54, 519,\n+    51, 55, 519, 51, 56, 519, 51, 57, 519, 52, 48, 519, 52, 49, 519, 52, 50,\n+    519, 52, 51, 519, 52, 52, 519, 52, 53, 519, 52, 54, 519, 52, 55, 519, 52,\n+    56, 519, 52, 57, 519, 53, 48, 514, 49, 26376, 514, 50, 26376, 514, 51,\n+    26376, 514, 52, 26376, 514, 53, 26376, 514, 54, 26376, 514, 55, 26376,\n+    514, 56, 26376, 514, 57, 26376, 770, 49, 48, 26376, 770, 49, 49, 26376,\n+    770, 49, 50, 26376, 522, 72, 103, 778, 101, 114, 103, 522, 101, 86, 778,\n+    76, 84, 68, 263, 12450, 263, 12452, 263, 12454, 263, 12456, 263, 12458,\n+    263, 12459, 263, 12461, 263, 12463, 263, 12465, 263, 12467, 263, 12469,\n+    263, 12471, 263, 12473, 263, 12475, 263, 12477, 263, 12479, 263, 12481,\n+    263, 12484, 263, 12486, 263, 12488, 263, 12490, 263, 12491, 263, 12492,\n+    263, 12493, 263, 12494, 263, 12495, 263, 12498, 263, 12501, 263, 12504,\n+    263, 12507, 263, 12510, 263, 12511, 263, 12512, 263, 12513, 263, 12514,\n+    263, 12516, 263, 12518, 263, 12520, 263, 12521, 263, 12522, 263, 12523,\n+    263, 12524, 263, 12525, 263, 12527, 263, 12528, 263, 12529, 263, 12530,\n+    1034, 12450, 12497, 12540, 12488, 1034, 12450, 12523, 12501, 12449, 1034,\n+    12450, 12531, 12506, 12450, 778, 12450, 12540, 12523, 1034, 12452, 12491,\n+    12531, 12464, 778, 12452, 12531, 12481, 778, 12454, 12457, 12531, 1290,\n+    12456, 12473, 12463, 12540, 12489, 1034, 12456, 12540, 12459, 12540, 778,\n+    12458, 12531, 12473, 778, 12458, 12540, 12512, 778, 12459, 12452, 12522,\n+    1034, 12459, 12521, 12483, 12488, 1034, 12459, 12525, 12522, 12540, 778,\n+    12460, 12525, 12531, 778, 12460, 12531, 12510, 522, 12462, 12460, 778,\n+    12462, 12491, 12540, 1034, 12461, 12517, 12522, 12540, 1034, 12462,\n+    12523, 12480, 12540, 522, 12461, 12525, 1290, 12461, 12525, 12464, 12521,\n+    12512, 1546, 12461, 12525, 12513, 12540, 12488, 12523, 1290, 12461,\n+    12525, 12527, 12483, 12488, 778, 12464, 12521, 12512, 1290, 12464, 12521,\n+    12512, 12488, 12531, 1290, 12463, 12523, 12476, 12452, 12525, 1034,\n+    12463, 12525, 12540, 12493, 778, 12465, 12540, 12473, 778, 12467, 12523,\n+    12490, 778, 12467, 12540, 12509, 1034, 12469, 12452, 12463, 12523, 1290,\n+    12469, 12531, 12481, 12540, 12512, 1034, 12471, 12522, 12531, 12464, 778,\n+    12475, 12531, 12481, 778, 12475, 12531, 12488, 778, 12480, 12540, 12473,\n+    522, 12487, 12471, 522, 12489, 12523, 522, 12488, 12531, 522, 12490,\n+    12494, 778, 12494, 12483, 12488, 778, 12495, 12452, 12484, 1290, 12497,\n+    12540, 12475, 12531, 12488, 778, 12497, 12540, 12484, 1034, 12496, 12540,\n+    12524, 12523, 1290, 12500, 12450, 12473, 12488, 12523, 778, 12500, 12463,\n+    12523, 522, 12500, 12467, 522, 12499, 12523, 1290, 12501, 12449, 12521,\n+    12483, 12489, 1034, 12501, 12451, 12540, 12488, 1290, 12502, 12483,\n+    12471, 12455, 12523, 778, 12501, 12521, 12531, 1290, 12504, 12463, 12479,\n+    12540, 12523, 522, 12506, 12477, 778, 12506, 12491, 12498, 778, 12504,\n+    12523, 12484, 778, 12506, 12531, 12473, 778, 12506, 12540, 12472, 778,\n+    12505, 12540, 12479, 1034, 12509, 12452, 12531, 12488, 778, 12508, 12523,\n+    12488, 522, 12507, 12531, 778, 12509, 12531, 12489, 778, 12507, 12540,\n+    12523, 778, 12507, 12540, 12531, 1034, 12510, 12452, 12463, 12525, 778,\n+    12510, 12452, 12523, 778, 12510, 12483, 12495, 778, 12510, 12523, 12463,\n+    1290, 12510, 12531, 12471, 12519, 12531, 1034, 12511, 12463, 12525,\n+    12531, 522, 12511, 12522, 1290, 12511, 12522, 12496, 12540, 12523, 522,\n+    12513, 12460, 1034, 12513, 12460, 12488, 12531, 1034, 12513, 12540,\n+    12488, 12523, 778, 12516, 12540, 12489, 778, 12516, 12540, 12523, 778,\n+    12518, 12450, 12531, 1034, 12522, 12483, 12488, 12523, 522, 12522, 12521,\n+    778, 12523, 12500, 12540, 1034, 12523, 12540, 12502, 12523, 522, 12524,\n+    12512, 1290, 12524, 12531, 12488, 12466, 12531, 778, 12527, 12483, 12488,\n+    514, 48, 28857, 514, 49, 28857, 514, 50, 28857, 514, 51, 28857, 514, 52,\n+    28857, 514, 53, 28857, 514, 54, 28857, 514, 55, 28857, 514, 56, 28857,\n+    514, 57, 28857, 770, 49, 48, 28857, 770, 49, 49, 28857, 770, 49, 50,\n+    28857, 770, 49, 51, 28857, 770, 49, 52, 28857, 770, 49, 53, 28857, 770,\n+    49, 54, 28857, 770, 49, 55, 28857, 770, 49, 56, 28857, 770, 49, 57,\n+    28857, 770, 50, 48, 28857, 770, 50, 49, 28857, 770, 50, 50, 28857, 770,\n+    50, 51, 28857, 770, 50, 52, 28857, 778, 104, 80, 97, 522, 100, 97, 522,\n+    65, 85, 778, 98, 97, 114, 522, 111, 86, 522, 112, 99, 522, 100, 109, 778,\n+    100, 109, 178, 778, 100, 109, 179, 522, 73, 85, 522, 24179, 25104, 522,\n+    26157, 21644, 522, 22823, 27491, 522, 26126, 27835, 1034, 26666, 24335,\n+    20250, 31038, 522, 112, 65, 522, 110, 65, 522, 956, 65, 522, 109, 65,\n+    522, 107, 65, 522, 75, 66, 522, 77, 66, 522, 71, 66, 778, 99, 97, 108,\n+    1034, 107, 99, 97, 108, 522, 112, 70, 522, 110, 70, 522, 956, 70, 522,\n+    956, 103, 522, 109, 103, 522, 107, 103, 522, 72, 122, 778, 107, 72, 122,\n+    778, 77, 72, 122, 778, 71, 72, 122, 778, 84, 72, 122, 522, 956, 8467,\n+    522, 109, 8467, 522, 100, 8467, 522, 107, 8467, 522, 102, 109, 522, 110,\n+    109, 522, 956, 109, 522, 109, 109, 522, 99, 109, 522, 107, 109, 778, 109,\n+    109, 178, 778, 99, 109, 178, 522, 109, 178, 778, 107, 109, 178, 778, 109,\n+    109, 179, 778, 99, 109, 179, 522, 109, 179, 778, 107, 109, 179, 778, 109,\n+    8725, 115, 1034, 109, 8725, 115, 178, 522, 80, 97, 778, 107, 80, 97, 778,\n+    77, 80, 97, 778, 71, 80, 97, 778, 114, 97, 100, 1290, 114, 97, 100, 8725,\n+    115, 1546, 114, 97, 100, 8725, 115, 178, 522, 112, 115, 522, 110, 115,\n+    522, 956, 115, 522, 109, 115, 522, 112, 86, 522, 110, 86, 522, 956, 86,\n+    522, 109, 86, 522, 107, 86, 522, 77, 86, 522, 112, 87, 522, 110, 87, 522,\n+    956, 87, 522, 109, 87, 522, 107, 87, 522, 77, 87, 522, 107, 937, 522, 77,\n+    937, 1034, 97, 46, 109, 46, 522, 66, 113, 522, 99, 99, 522, 99, 100,\n+    1034, 67, 8725, 107, 103, 778, 67, 111, 46, 522, 100, 66, 522, 71, 121,\n+    522, 104, 97, 522, 72, 80, 522, 105, 110, 522, 75, 75, 522, 75, 77, 522,\n+    107, 116, 522, 108, 109, 522, 108, 110, 778, 108, 111, 103, 522, 108,\n+    120, 522, 109, 98, 778, 109, 105, 108, 778, 109, 111, 108, 522, 80, 72,\n+    1034, 112, 46, 109, 46, 778, 80, 80, 77, 522, 80, 82, 522, 115, 114, 522,\n+    83, 118, 522, 87, 98, 778, 86, 8725, 109, 778, 65, 8725, 109, 514, 49,\n+    26085, 514, 50, 26085, 514, 51, 26085, 514, 52, 26085, 514, 53, 26085,\n+    514, 54, 26085, 514, 55, 26085, 514, 56, 26085, 514, 57, 26085, 770, 49,\n+    48, 26085, 770, 49, 49, 26085, 770, 49, 50, 26085, 770, 49, 51, 26085,\n+    770, 49, 52, 26085, 770, 49, 53, 26085, 770, 49, 54, 26085, 770, 49, 55,\n+    26085, 770, 49, 56, 26085, 770, 49, 57, 26085, 770, 50, 48, 26085, 770,\n+    50, 49, 26085, 770, 50, 50, 26085, 770, 50, 51, 26085, 770, 50, 52,\n+    26085, 770, 50, 53, 26085, 770, 50, 54, 26085, 770, 50, 55, 26085, 770,\n+    50, 56, 26085, 770, 50, 57, 26085, 770, 51, 48, 26085, 770, 51, 49,\n+    26085, 778, 103, 97, 108, 259, 1098, 259, 1100, 259, 42863, 259, 294,\n+    259, 339, 259, 42791, 259, 43831, 259, 619, 259, 43858, 256, 35912, 256,\n+    26356, 256, 36554, 256, 36040, 256, 28369, 256, 20018, 256, 21477, 256,\n+    40860, 256, 40860, 256, 22865, 256, 37329, 256, 21895, 256, 22856, 256,\n+    25078, 256, 30313, 256, 32645, 256, 34367, 256, 34746, 256, 35064, 256,\n+    37007, 256, 27138, 256, 27931, 256, 28889, 256, 29662, 256, 33853, 256,\n+    37226, 256, 39409, 256, 20098, 256, 21365, 256, 27396, 256, 29211, 256,\n+    34349, 256, 40478, 256, 23888, 256, 28651, 256, 34253, 256, 35172, 256,\n+    25289, 256, 33240, 256, 34847, 256, 24266, 256, 26391, 256, 28010, 256,\n+    29436, 256, 37070, 256, 20358, 256, 20919, 256, 21214, 256, 25796, 256,\n+    27347, 256, 29200, 256, 30439, 256, 32769, 256, 34310, 256, 34396, 256,\n+    36335, 256, 38706, 256, 39791, 256, 40442, 256, 30860, 256, 31103, 256,\n+    32160, 256, 33737, 256, 37636, 256, 40575, 256, 35542, 256, 22751, 256,\n+    24324, 256, 31840, 256, 32894, 256, 29282, 256, 30922, 256, 36034, 256,\n+    38647, 256, 22744, 256, 23650, 256, 27155, 256, 28122, 256, 28431, 256,\n+    32047, 256, 32311, 256, 38475, 256, 21202, 256, 32907, 256, 20956, 256,\n+    20940, 256, 31260, 256, 32190, 256, 33777, 256, 38517, 256, 35712, 256,\n+    25295, 256, 27138, 256, 35582, 256, 20025, 256, 23527, 256, 24594, 256,\n+    29575, 256, 30064, 256, 21271, 256, 30971, 256, 20415, 256, 24489, 256,\n+    19981, 256, 27852, 256, 25976, 256, 32034, 256, 21443, 256, 22622, 256,\n+    30465, 256, 33865, 256, 35498, 256, 27578, 256, 36784, 256, 27784, 256,\n+    25342, 256, 33509, 256, 25504, 256, 30053, 256, 20142, 256, 20841, 256,\n+    20937, 256, 26753, 256, 31975, 256, 33391, 256, 35538, 256, 37327, 256,\n+    21237, 256, 21570, 256, 22899, 256, 24300, 256, 26053, 256, 28670, 256,\n+    31018, 256, 38317, 256, 39530, 256, 40599, 256, 40654, 256, 21147, 256,\n+    26310, 256, 27511, 256, 36706, 256, 24180, 256, 24976, 256, 25088, 256,\n+    25754, 256, 28451, 256, 29001, 256, 29833, 256, 31178, 256, 32244, 256,\n+    32879, 256, 36646, 256, 34030, 256, 36899, 256, 37706, 256, 21015, 256,\n+    21155, 256, 21693, 256, 28872, 256, 35010, 256, 35498, 256, 24265, 256,\n+    24565, 256, 25467, 256, 27566, 256, 31806, 256, 29557, 256, 20196, 256,\n+    22265, 256, 23527, 256, 23994, 256, 24604, 256, 29618, 256, 29801, 256,\n+    32666, 256, 32838, 256, 37428, 256, 38646, 256, 38728, 256, 38936, 256,\n+    20363, 256, 31150, 256, 37300, 256, 38584, 256, 24801, 256, 20102, 256,\n+    20698, 256, 23534, 256, 23615, 256, 26009, 256, 27138, 256, 29134, 256,\n+    30274, 256, 34044, 256, 36988, 256, 40845, 256, 26248, 256, 38446, 256,\n+    21129, 256, 26491, 256, 26611, 256, 27969, 256, 28316, 256, 29705, 256,\n+    30041, 256, 30827, 256, 32016, 256, 39006, 256, 20845, 256, 25134, 256,\n+    38520, 256, 20523, 256, 23833, 256, 28138, 256, 36650, 256, 24459, 256,\n+    24900, 256, 26647, 256, 29575, 256, 38534, 256, 21033, 256, 21519, 256,\n+    23653, 256, 26131, 256, 26446, 256, 26792, 256, 27877, 256, 29702, 256,\n+    30178, 256, 32633, 256, 35023, 256, 35041, 256, 37324, 256, 38626, 256,\n+    21311, 256, 28346, 256, 21533, 256, 29136, 256, 29848, 256, 34298, 256,\n+    38563, 256, 40023, 256, 40607, 256, 26519, 256, 28107, 256, 33256, 256,\n+    31435, 256, 31520, 256, 31890, 256, 29376, 256, 28825, 256, 35672, 256,\n+    20160, 256, 33590, 256, 21050, 256, 20999, 256, 24230, 256, 25299, 256,\n+    31958, 256, 23429, 256, 27934, 256, 26292, 256, 36667, 256, 34892, 256,\n+    38477, 256, 35211, 256, 24275, 256, 20800, 256, 21952, 256, 22618, 256,\n+    26228, 256, 20958, 256, 29482, 256, 30410, 256, 31036, 256, 31070, 256,\n+    31077, 256, 31119, 256, 38742, 256, 31934, 256, 32701, 256, 34322, 256,\n+    35576, 256, 36920, 256, 37117, 256, 39151, 256, 39164, 256, 39208, 256,\n+    40372, 256, 37086, 256, 38583, 256, 20398, 256, 20711, 256, 20813, 256,\n+    21193, 256, 21220, 256, 21329, 256, 21917, 256, 22022, 256, 22120, 256,\n+    22592, 256, 22696, 256, 23652, 256, 23662, 256, 24724, 256, 24936, 256,\n+    24974, 256, 25074, 256, 25935, 256, 26082, 256, 26257, 256, 26757, 256,\n+    28023, 256, 28186, 256, 28450, 256, 29038, 256, 29227, 256, 29730, 256,\n+    30865, 256, 31038, 256, 31049, 256, 31048, 256, 31056, 256, 31062, 256,\n+    31069, 256, 31117, 256, 31118, 256, 31296, 256, 31361, 256, 31680, 256,\n+    32244, 256, 32265, 256, 32321, 256, 32626, 256, 32773, 256, 33261, 256,\n+    33401, 256, 33401, 256, 33879, 256, 35088, 256, 35222, 256, 35585, 256,\n+    35641, 256, 36051, 256, 36104, 256, 36790, 256, 36920, 256, 38627, 256,\n+    38911, 256, 38971, 256, 24693, 256, 55376, 57070, 256, 33304, 256, 20006,\n+    256, 20917, 256, 20840, 256, 20352, 256, 20805, 256, 20864, 256, 21191,\n+    256, 21242, 256, 21917, 256, 21845, 256, 21913, 256, 21986, 256, 22618,\n+    256, 22707, 256, 22852, 256, 22868, 256, 23138, 256, 23336, 256, 24274,\n+    256, 24281, 256, 24425, 256, 24493, 256, 24792, 256, 24910, 256, 24840,\n+    256, 24974, 256, 24928, 256, 25074, 256, 25140, 256, 25540, 256, 25628,\n+    256, 25682, 256, 25942, 256, 26228, 256, 26391, 256, 26395, 256, 26454,\n+    256, 27513, 256, 27578, 256, 27969, 256, 28379, 256, 28363, 256, 28450,\n+    256, 28702, 256, 29038, 256, 30631, 256, 29237, 256, 29359, 256, 29482,\n+    256, 29809, 256, 29958, 256, 30011, 256, 30237, 256, 30239, 256, 30410,\n+    256, 30427, 256, 30452, 256, 30538, 256, 30528, 256, 30924, 256, 31409,\n+    256, 31680, 256, 31867, 256, 32091, 256, 32244, 256, 32574, 256, 32773,\n+    256, 33618, 256, 33775, 256, 34681, 256, 35137, 256, 35206, 256, 35222,\n+    256, 35519, 256, 35576, 256, 35531, 256, 35585, 256, 35582, 256, 35565,\n+    256, 35641, 256, 35722, 256, 36104, 256, 36664, 256, 36978, 256, 37273,\n+    256, 37494, 256, 38524, 256, 38627, 256, 38742, 256, 38875, 256, 38911,\n+    256, 38923, 256, 38971, 256, 39698, 256, 40860, 256, 55370, 56394, 256,\n+    55370, 56388, 256, 55372, 57301, 256, 15261, 256, 16408, 256, 16441, 256,\n+    55380, 56905, 256, 55383, 56528, 256, 55391, 57043, 256, 40771, 256,\n+    40846, 514, 102, 102, 514, 102, 105, 514, 102, 108, 770, 102, 102, 105,\n+    770, 102, 102, 108, 514, 383, 116, 514, 115, 116, 514, 1396, 1398, 514,\n+    1396, 1381, 514, 1396, 1387, 514, 1406, 1398, 514, 1396, 1389, 512, 1497,\n+    1460, 512, 1522, 1463, 262, 1506, 262, 1488, 262, 1491, 262, 1492, 262,\n+    1499, 262, 1500, 262, 1501, 262, 1512, 262, 1514, 262, 43, 512, 1513,\n+    1473, 512, 1513, 1474, 512, 64329, 1473, 512, 64329, 1474, 512, 1488,\n+    1463, 512, 1488, 1464, 512, 1488, 1468, 512, 1489, 1468, 512, 1490, 1468,\n+    512, 1491, 1468, 512, 1492, 1468, 512, 1493, 1468, 512, 1494, 1468, 512,\n+    1496, 1468, 512, 1497, 1468, 512, 1498, 1468, 512, 1499, 1468, 512, 1500,\n+    1468, 512, 1502, 1468, 512, 1504, 1468, 512, 1505, 1468, 512, 1507, 1468,\n+    512, 1508, 1468, 512, 1510, 1468, 512, 1511, 1468, 512, 1512, 1468, 512,\n+    1513, 1468, 512, 1514, 1468, 512, 1493, 1465, 512, 1489, 1471, 512, 1499,\n+    1471, 512, 1508, 1471, 514, 1488, 1500, 267, 1649, 268, 1649, 267, 1659,\n+    268, 1659, 269, 1659, 270, 1659, 267, 1662, 268, 1662, 269, 1662, 270,\n+    1662, 267, 1664, 268, 1664, 269, 1664, 270, 1664, 267, 1658, 268, 1658,\n+    269, 1658, 270, 1658, 267, 1663, 268, 1663, 269, 1663, 270, 1663, 267,\n+    1657, 268, 1657, 269, 1657, 270, 1657, 267, 1700, 268, 1700, 269, 1700,\n+    270, 1700, 267, 1702, 268, 1702, 269, 1702, 270, 1702, 267, 1668, 268,\n+    1668, 269, 1668, 270, 1668, 267, 1667, 268, 1667, 269, 1667, 270, 1667,\n+    267, 1670, 268, 1670, 269, 1670, 270, 1670, 267, 1671, 268, 1671, 269,\n+    1671, 270, 1671, 267, 1677, 268, 1677, 267, 1676, 268, 1676, 267, 1678,\n+    268, 1678, 267, 1672, 268, 1672, 267, 1688, 268, 1688, 267, 1681, 268,\n+    1681, 267, 1705, 268, 1705, 269, 1705, 270, 1705, 267, 1711, 268, 1711,\n+    269, 1711, 270, 1711, 267, 1715, 268, 1715, 269, 1715, 270, 1715, 267,\n+    1713, 268, 1713, 269, 1713, 270, 1713, 267, 1722, 268, 1722, 267, 1723,\n+    268, 1723, 269, 1723, 270, 1723, 267, 1728, 268, 1728, 267, 1729, 268,\n+    1729, 269, 1729, 270, 1729, 267, 1726, 268, 1726, 269, 1726, 270, 1726,\n+    267, 1746, 268, 1746, 267, 1747, 268, 1747, 267, 1709, 268, 1709, 269,\n+    1709, 270, 1709, 267, 1735, 268, 1735, 267, 1734, 268, 1734, 267, 1736,\n+    268, 1736, 267, 1655, 267, 1739, 268, 1739, 267, 1733, 268, 1733, 267,\n+    1737, 268, 1737, 267, 1744, 268, 1744, 269, 1744, 270, 1744, 269, 1609,\n+    270, 1609, 523, 1574, 1575, 524, 1574, 1575, 523, 1574, 1749, 524, 1574,\n+    1749, 523, 1574, 1608, 524, 1574, 1608, 523, 1574, 1735, 524, 1574, 1735,\n+    523, 1574, 1734, 524, 1574, 1734, 523, 1574, 1736, 524, 1574, 1736, 523,\n+    1574, 1744, 524, 1574, 1744, 525, 1574, 1744, 523, 1574, 1609, 524, 1574,\n+    1609, 525, 1574, 1609, 267, 1740, 268, 1740, 269, 1740, 270, 1740, 523,\n+    1574, 1580, 523, 1574, 1581, 523, 1574, 1605, 523, 1574, 1609, 523, 1574,\n+    1610, 523, 1576, 1580, 523, 1576, 1581, 523, 1576, 1582, 523, 1576, 1605,\n+    523, 1576, 1609, 523, 1576, 1610, 523, 1578, 1580, 523, 1578, 1581, 523,\n+    1578, 1582, 523, 1578, 1605, 523, 1578, 1609, 523, 1578, 1610, 523, 1579,\n+    1580, 523, 1579, 1605, 523, 1579, 1609, 523, 1579, 1610, 523, 1580, 1581,\n+    523, 1580, 1605, 523, 1581, 1580, 523, 1581, 1605, 523, 1582, 1580, 523,\n+    1582, 1581, 523, 1582, 1605, 523, 1587, 1580, 523, 1587, 1581, 523, 1587,\n+    1582, 523, 1587, 1605, 523, 1589, 1581, 523, 1589, 1605, 523, 1590, 1580,\n+    523, 1590, 1581, 523, 1590, 1582, 523, 1590, 1605, 523, 1591, 1581, 523,\n+    1591, 1605, 523, 1592, 1605, 523, 1593, 1580, 523, 1593, 1605, 523, 1594,\n+    1580, 523, 1594, 1605, 523, 1601, 1580, 523, 1601, 1581, 523, 1601, 1582,\n+    523, 1601, 1605, 523, 1601, 1609, 523, 1601, 1610, 523, 1602, 1581, 523,\n+    1602, 1605, 523, 1602, 1609, 523, 1602, 1610, 523, 1603, 1575, 523, 1603,\n+    1580, 523, 1603, 1581, 523, 1603, 1582, 523, 1603, 1604, 523, 1603, 1605,\n+    523, 1603, 1609, 523, 1603, 1610, 523, 1604, 1580, 523, 1604, 1581, 523,\n+    1604, 1582, 523, 1604, 1605, 523, 1604, 1609, 523, 1604, 1610, 523, 1605,\n+    1580, 523, 1605, 1581, 523, 1605, 1582, 523, 1605, 1605, 523, 1605, 1609,\n+    523, 1605, 1610, 523, 1606, 1580, 523, 1606, 1581, 523, 1606, 1582, 523,\n+    1606, 1605, 523, 1606, 1609, 523, 1606, 1610, 523, 1607, 1580, 523, 1607,\n+    1605, 523, 1607, 1609, 523, 1607, 1610, 523, 1610, 1580, 523, 1610, 1581,\n+    523, 1610, 1582, 523, 1610, 1605, 523, 1610, 1609, 523, 1610, 1610, 523,\n+    1584, 1648, 523, 1585, 1648, 523, 1609, 1648, 779, 32, 1612, 1617, 779,\n+    32, 1613, 1617, 779, 32, 1614, 1617, 779, 32, 1615, 1617, 779, 32, 1616,\n+    1617, 779, 32, 1617, 1648, 524, 1574, 1585, 524, 1574, 1586, 524, 1574,\n+    1605, 524, 1574, 1606, 524, 1574, 1609, 524, 1574, 1610, 524, 1576, 1585,\n+    524, 1576, 1586, 524, 1576, 1605, 524, 1576, 1606, 524, 1576, 1609, 524,\n+    1576, 1610, 524, 1578, 1585, 524, 1578, 1586, 524, 1578, 1605, 524, 1578,\n+    1606, 524, 1578, 1609, 524, 1578, 1610, 524, 1579, 1585, 524, 1579, 1586,\n+    524, 1579, 1605, 524, 1579, 1606, 524, 1579, 1609, 524, 1579, 1610, 524,\n+    1601, 1609, 524, 1601, 1610, 524, 1602, 1609, 524, 1602, 1610, 524, 1603,\n+    1575, 524, 1603, 1604, 524, 1603, 1605, 524, 1603, 1609, 524, 1603, 1610,\n+    524, 1604, 1605, 524, 1604, 1609, 524, 1604, 1610, 524, 1605, 1575, 524,\n+    1605, 1605, 524, 1606, 1585, 524, 1606, 1586, 524, 1606, 1605, 524, 1606,\n+    1606, 524, 1606, 1609, 524, 1606, 1610, 524, 1609, 1648, 524, 1610, 1585,\n+    524, 1610, 1586, 524, 1610, 1605, 524, 1610, 1606, 524, 1610, 1609, 524,\n+    1610, 1610, 525, 1574, 1580, 525, 1574, 1581, 525, 1574, 1582, 525, 1574,\n+    1605, 525, 1574, 1607, 525, 1576, 1580, 525, 1576, 1581, 525, 1576, 1582,\n+    525, 1576, 1605, 525, 1576, 1607, 525, 1578, 1580, 525, 1578, 1581, 525,\n+    1578, 1582, 525, 1578, 1605, 525, 1578, 1607, 525, 1579, 1605, 525, 1580,\n+    1581, 525, 1580, 1605, 525, 1581, 1580, 525, 1581, 1605, 525, 1582, 1580,\n+    525, 1582, 1605, 525, 1587, 1580, 525, 1587, 1581, 525, 1587, 1582, 525,\n+    1587, 1605, 525, 1589, 1581, 525, 1589, 1582, 525, 1589, 1605, 525, 1590,\n+    1580, 525, 1590, 1581, 525, 1590, 1582, 525, 1590, 1605, 525, 1591, 1581,\n+    525, 1592, 1605, 525, 1593, 1580, 525, 1593, 1605, 525, 1594, 1580, 525,\n+    1594, 1605, 525, 1601, 1580, 525, 1601, 1581, 525, 1601, 1582, 525, 1601,\n+    1605, 525, 1602, 1581, 525, 1602, 1605, 525, 1603, 1580, 525, 1603, 1581,\n+    525, 1603, 1582, 525, 1603, 1604, 525, 1603, 1605, 525, 1604, 1580, 525,\n+    1604, 1581, 525, 1604, 1582, 525, 1604, 1605, 525, 1604, 1607, 525, 1605,\n+    1580, 525, 1605, 1581, 525, 1605, 1582, 525, 1605, 1605, 525, 1606, 1580,\n+    525, 1606, 1581, 525, 1606, 1582, 525, 1606, 1605, 525, 1606, 1607, 525,\n+    1607, 1580, 525, 1607, 1605, 525, 1607, 1648, 525, 1610, 1580, 525, 1610,\n+    1581, 525, 1610, 1582, 525, 1610, 1605, 525, 1610, 1607, 526, 1574, 1605,\n+    526, 1574, 1607, 526, 1576, 1605, 526, 1576, 1607, 526, 1578, 1605, 526,\n+    1578, 1607, 526, 1579, 1605, 526, 1579, 1607, 526, 1587, 1605, 526, 1587,\n+    1607, 526, 1588, 1605, 526, 1588, 1607, 526, 1603, 1604, 526, 1603, 1605,\n+    526, 1604, 1605, 526, 1606, 1605, 526, 1606, 1607, 526, 1610, 1605, 526,\n+    1610, 1607, 782, 1600, 1614, 1617, 782, 1600, 1615, 1617, 782, 1600,\n+    1616, 1617, 523, 1591, 1609, 523, 1591, 1610, 523, 1593, 1609, 523, 1593,\n+    1610, 523, 1594, 1609, 523, 1594, 1610, 523, 1587, 1609, 523, 1587, 1610,\n+    523, 1588, 1609, 523, 1588, 1610, 523, 1581, 1609, 523, 1581, 1610, 523,\n+    1580, 1609, 523, 1580, 1610, 523, 1582, 1609, 523, 1582, 1610, 523, 1589,\n+    1609, 523, 1589, 1610, 523, 1590, 1609, 523, 1590, 1610, 523, 1588, 1580,\n+    523, 1588, 1581, 523, 1588, 1582, 523, 1588, 1605, 523, 1588, 1585, 523,\n+    1587, 1585, 523, 1589, 1585, 523, 1590, 1585, 524, 1591, 1609, 524, 1591,\n+    1610, 524, 1593, 1609, 524, 1593, 1610, 524, 1594, 1609, 524, 1594, 1610,\n+    524, 1587, 1609, 524, 1587, 1610, 524, 1588, 1609, 524, 1588, 1610, 524,\n+    1581, 1609, 524, 1581, 1610, 524, 1580, 1609, 524, 1580, 1610, 524, 1582,\n+    1609, 524, 1582, 1610, 524, 1589, 1609, 524, 1589, 1610, 524, 1590, 1609,\n+    524, 1590, 1610, 524, 1588, 1580, 524, 1588, 1581, 524, 1588, 1582, 524,\n+    1588, 1605, 524, 1588, 1585, 524, 1587, 1585, 524, 1589, 1585, 524, 1590,\n+    1585, 525, 1588, 1580, 525, 1588, 1581, 525, 1588, 1582, 525, 1588, 1605,\n+    525, 1587, 1607, 525, 1588, 1607, 525, 1591, 1605, 526, 1587, 1580, 526,\n+    1587, 1581, 526, 1587, 1582, 526, 1588, 1580, 526, 1588, 1581, 526, 1588,\n+    1582, 526, 1591, 1605, 526, 1592, 1605, 524, 1575, 1611, 523, 1575, 1611,\n+    781, 1578, 1580, 1605, 780, 1578, 1581, 1580, 781, 1578, 1581, 1580, 781,\n+    1578, 1581, 1605, 781, 1578, 1582, 1605, 781, 1578, 1605, 1580, 781,\n+    1578, 1605, 1581, 781, 1578, 1605, 1582, 780, 1580, 1605, 1581, 781,\n+    1580, 1605, 1581, 780, 1581, 1605, 1610, 780, 1581, 1605, 1609, 781,\n+    1587, 1581, 1580, 781, 1587, 1580, 1581, 780, 1587, 1580, 1609, 780,\n+    1587, 1605, 1581, 781, 1587, 1605, 1581, 781, 1587, 1605, 1580, 780,\n+    1587, 1605, 1605, 781, 1587, 1605, 1605, 780, 1589, 1581, 1581, 781,\n+    1589, 1581, 1581, 780, 1589, 1605, 1605, 780, 1588, 1581, 1605, 781,\n+    1588, 1581, 1605, 780, 1588, 1580, 1610, 780, 1588, 1605, 1582, 781,\n+    1588, 1605, 1582, 780, 1588, 1605, 1605, 781, 1588, 1605, 1605, 780,\n+    1590, 1581, 1609, 780, 1590, 1582, 1605, 781, 1590, 1582, 1605, 780,\n+    1591, 1605, 1581, 781, 1591, 1605, 1581, 781, 1591, 1605, 1605, 780,\n+    1591, 1605, 1610, 780, 1593, 1580, 1605, 780, 1593, 1605, 1605, 781,\n+    1593, 1605, 1605, 780, 1593, 1605, 1609, 780, 1594, 1605, 1605, 780,\n+    1594, 1605, 1610, 780, 1594, 1605, 1609, 780, 1601, 1582, 1605, 781,\n+    1601, 1582, 1605, 780, 1602, 1605, 1581, 780, 1602, 1605, 1605, 780,\n+    1604, 1581, 1605, 780, 1604, 1581, 1610, 780, 1604, 1581, 1609, 781,\n+    1604, 1580, 1580, 780, 1604, 1580, 1580, 780, 1604, 1582, 1605, 781,\n+    1604, 1582, 1605, 780, 1604, 1605, 1581, 781, 1604, 1605, 1581, 781,\n+    1605, 1581, 1580, 781, 1605, 1581, 1605, 780, 1605, 1581, 1610, 781,\n+    1605, 1580, 1581, 781, 1605, 1580, 1605, 781, 1605, 1582, 1580, 781,\n+    1605, 1582, 1605, 781, 1605, 1580, 1582, 781, 1607, 1605, 1580, 781,\n+    1607, 1605, 1605, 781, 1606, 1581, 1605, 780, 1606, 1581, 1609, 780,\n+    1606, 1580, 1605, 781, 1606, 1580, 1605, 780, 1606, 1580, 1609, 780,\n+    1606, 1605, 1610, 780, 1606, 1605, 1609, 780, 1610, 1605, 1605, 781,\n+    1610, 1605, 1605, 780, 1576, 1582, 1610, 780, 1578, 1580, 1610, 780,\n+    1578, 1580, 1609, 780, 1578, 1582, 1610, 780, 1578, 1582, 1609, 780,\n+    1578, 1605, 1610, 780, 1578, 1605, 1609, 780, 1580, 1605, 1610, 780,\n+    1580, 1581, 1609, 780, 1580, 1605, 1609, 780, 1587, 1582, 1609, 780,\n+    1589, 1581, 1610, 780, 1588, 1581, 1610, 780, 1590, 1581, 1610, 780,\n+    1604, 1580, 1610, 780, 1604, 1605, 1610, 780, 1610, 1581, 1610, 780,\n+    1610, 1580, 1610, 780, 1610, 1605, 1610, 780, 1605, 1605, 1610, 780,\n+    1602, 1605, 1610, 780, 1606, 1581, 1610, 781, 1602, 1605, 1581, 781,\n+    1604, 1581, 1605, 780, 1593, 1605, 1610, 780, 1603, 1605, 1610, 781,\n+    1606, 1580, 1581, 780, 1605, 1582, 1610, 781, 1604, 1580, 1605, 780,\n+    1603, 1605, 1605, 780, 1604, 1580, 1605, 780, 1606, 1580, 1581, 780,\n+    1580, 1581, 1610, 780, 1581, 1580, 1610, 780, 1605, 1580, 1610, 780,\n+    1601, 1605, 1610, 780, 1576, 1581, 1610, 781, 1603, 1605, 1605, 781,\n+    1593, 1580, 1605, 781, 1589, 1605, 1605, 780, 1587, 1582, 1610, 780,\n+    1606, 1580, 1610, 779, 1589, 1604, 1746, 779, 1602, 1604, 1746, 1035,\n+    1575, 1604, 1604, 1607, 1035, 1575, 1603, 1576, 1585, 1035, 1605, 1581,\n+    1605, 1583, 1035, 1589, 1604, 1593, 1605, 1035, 1585, 1587, 1608, 1604,\n+    1035, 1593, 1604, 1610, 1607, 1035, 1608, 1587, 1604, 1605, 779, 1589,\n+    1604, 1609, 4619, 1589, 1604, 1609, 32, 1575, 1604, 1604, 1607, 32, 1593,\n+    1604, 1610, 1607, 32, 1608, 1587, 1604, 1605, 2059, 1580, 1604, 32, 1580,\n+    1604, 1575, 1604, 1607, 1035, 1585, 1740, 1575, 1604, 265, 44, 265,\n+    12289, 265, 12290, 265, 58, 265, 59, 265, 33, 265, 63, 265, 12310, 265,\n+    12311, 265, 8230, 265, 8229, 265, 8212, 265, 8211, 265, 95, 265, 95, 265,\n+    40, 265, 41, 265, 123, 265, 125, 265, 12308, 265, 12309, 265, 12304, 265,\n+    12305, 265, 12298, 265, 12299, 265, 12296, 265, 12297, 265, 12300, 265,\n+    12301, 265, 12302, 265, 12303, 265, 91, 265, 93, 258, 8254, 258, 8254,\n+    258, 8254, 258, 8254, 258, 95, 258, 95, 258, 95, 271, 44, 271, 12289,\n+    271, 46, 271, 59, 271, 58, 271, 63, 271, 33, 271, 8212, 271, 40, 271, 41,\n+    271, 123, 271, 125, 271, 12308, 271, 12309, 271, 35, 271, 38, 271, 42,\n+    271, 43, 271, 45, 271, 60, 271, 62, 271, 61, 271, 92, 271, 36, 271, 37,\n+    271, 64, 523, 32, 1611, 526, 1600, 1611, 523, 32, 1612, 523, 32, 1613,\n+    523, 32, 1614, 526, 1600, 1614, 523, 32, 1615, 526, 1600, 1615, 523, 32,\n+    1616, 526, 1600, 1616, 523, 32, 1617, 526, 1600, 1617, 523, 32, 1618,\n+    526, 1600, 1618, 267, 1569, 267, 1570, 268, 1570, 267, 1571, 268, 1571,\n+    267, 1572, 268, 1572, 267, 1573, 268, 1573, 267, 1574, 268, 1574, 269,\n+    1574, 270, 1574, 267, 1575, 268, 1575, 267, 1576, 268, 1576, 269, 1576,\n+    270, 1576, 267, 1577, 268, 1577, 267, 1578, 268, 1578, 269, 1578, 270,\n+    1578, 267, 1579, 268, 1579, 269, 1579, 270, 1579, 267, 1580, 268, 1580,\n+    269, 1580, 270, 1580, 267, 1581, 268, 1581, 269, 1581, 270, 1581, 267,\n+    1582, 268, 1582, 269, 1582, 270, 1582, 267, 1583, 268, 1583, 267, 1584,\n+    268, 1584, 267, 1585, 268, 1585, 267, 1586, 268, 1586, 267, 1587, 268,\n+    1587, 269, 1587, 270, 1587, 267, 1588, 268, 1588, 269, 1588, 270, 1588,\n+    267, 1589, 268, 1589, 269, 1589, 270, 1589, 267, 1590, 268, 1590, 269,\n+    1590, 270, 1590, 267, 1591, 268, 1591, 269, 1591, 270, 1591, 267, 1592,\n+    268, 1592, 269, 1592, 270, 1592, 267, 1593, 268, 1593, 269, 1593, 270,\n+    1593, 267, 1594, 268, 1594, 269, 1594, 270, 1594, 267, 1601, 268, 1601,\n+    269, 1601, 270, 1601, 267, 1602, 268, 1602, 269, 1602, 270, 1602, 267,\n+    1603, 268, 1603, 269, 1603, 270, 1603, 267, 1604, 268, 1604, 269, 1604,\n+    270, 1604, 267, 1605, 268, 1605, 269, 1605, 270, 1605, 267, 1606, 268,\n+    1606, 269, 1606, 270, 1606, 267, 1607, 268, 1607, 269, 1607, 270, 1607,\n+    267, 1608, 268, 1608, 267, 1609, 268, 1609, 267, 1610, 268, 1610, 269,\n+    1610, 270, 1610, 523, 1604, 1570, 524, 1604, 1570, 523, 1604, 1571, 524,\n+    1604, 1571, 523, 1604, 1573, 524, 1604, 1573, 523, 1604, 1575, 524, 1604,\n+    1575, 264, 33, 264, 34, 264, 35, 264, 36, 264, 37, 264, 38, 264, 39, 264,\n+    40, 264, 41, 264, 42, 264, 43, 264, 44, 264, 45, 264, 46, 264, 47, 264,\n+    48, 264, 49, 264, 50, 264, 51, 264, 52, 264, 53, 264, 54, 264, 55, 264,\n+    56, 264, 57, 264, 58, 264, 59, 264, 60, 264, 61, 264, 62, 264, 63, 264,\n+    64, 264, 65, 264, 66, 264, 67, 264, 68, 264, 69, 264, 70, 264, 71, 264,\n+    72, 264, 73, 264, 74, 264, 75, 264, 76, 264, 77, 264, 78, 264, 79, 264,\n+    80, 264, 81, 264, 82, 264, 83, 264, 84, 264, 85, 264, 86, 264, 87, 264,\n+    88, 264, 89, 264, 90, 264, 91, 264, 92, 264, 93, 264, 94, 264, 95, 264,\n+    96, 264, 97, 264, 98, 264, 99, 264, 100, 264, 101, 264, 102, 264, 103,\n+    264, 104, 264, 105, 264, 106, 264, 107, 264, 108, 264, 109, 264, 110,\n+    264, 111, 264, 112, 264, 113, 264, 114, 264, 115, 264, 116, 264, 117,\n+    264, 118, 264, 119, 264, 120, 264, 121, 264, 122, 264, 123, 264, 124,\n+    264, 125, 264, 126, 264, 10629, 264, 10630, 272, 12290, 272, 12300, 272,\n+    12301, 272, 12289, 272, 12539, 272, 12530, 272, 12449, 272, 12451, 272,\n+    12453, 272, 12455, 272, 12457, 272, 12515, 272, 12517, 272, 12519, 272,\n+    12483, 272, 12540, 272, 12450, 272, 12452, 272, 12454, 272, 12456, 272,\n+    12458, 272, 12459, 272, 12461, 272, 12463, 272, 12465, 272, 12467, 272,\n+    12469, 272, 12471, 272, 12473, 272, 12475, 272, 12477, 272, 12479, 272,\n+    12481, 272, 12484, 272, 12486, 272, 12488, 272, 12490, 272, 12491, 272,\n+    12492, 272, 12493, 272, 12494, 272, 12495, 272, 12498, 272, 12501, 272,\n+    12504, 272, 12507, 272, 12510, 272, 12511, 272, 12512, 272, 12513, 272,\n+    12514, 272, 12516, 272, 12518, 272, 12520, 272, 12521, 272, 12522, 272,\n+    12523, 272, 12524, 272, 12525, 272, 12527, 272, 12531, 272, 12441, 272,\n+    12442, 272, 12644, 272, 12593, 272, 12594, 272, 12595, 272, 12596, 272,\n+    12597, 272, 12598, 272, 12599, 272, 12600, 272, 12601, 272, 12602, 272,\n+    12603, 272, 12604, 272, 12605, 272, 12606, 272, 12607, 272, 12608, 272,\n+    12609, 272, 12610, 272, 12611, 272, 12612, 272, 12613, 272, 12614, 272,\n+    12615, 272, 12616, 272, 12617, 272, 12618, 272, 12619, 272, 12620, 272,\n+    12621, 272, 12622, 272, 12623, 272, 12624, 272, 12625, 272, 12626, 272,\n+    12627, 272, 12628, 272, 12629, 272, 12630, 272, 12631, 272, 12632, 272,\n+    12633, 272, 12634, 272, 12635, 272, 12636, 272, 12637, 272, 12638, 272,\n+    12639, 272, 12640, 272, 12641, 272, 12642, 272, 12643, 264, 162, 264,\n+    163, 264, 172, 264, 175, 264, 166, 264, 165, 264, 8361, 272, 9474, 272,\n+    8592, 272, 8593, 272, 8594, 272, 8595, 272, 9632, 272, 9675, 512, 55300,\n+    56473, 55300, 56506, 512, 55300, 56475, 55300, 56506, 512, 55300, 56485,\n+    55300, 56506, 512, 55300, 56625, 55300, 56615, 512, 55300, 56626, 55300,\n+    56615, 512, 55300, 57159, 55300, 57150, 512, 55300, 57159, 55300, 57175,\n+    512, 55301, 56505, 55301, 56506, 512, 55301, 56505, 55301, 56496, 512,\n+    55301, 56505, 55301, 56509, 512, 55301, 56760, 55301, 56751, 512, 55301,\n+    56761, 55301, 56751, 512, 55348, 56663, 55348, 56677, 512, 55348, 56664,\n+    55348, 56677, 512, 55348, 56671, 55348, 56686, 512, 55348, 56671, 55348,\n+    56687, 512, 55348, 56671, 55348, 56688, 512, 55348, 56671, 55348, 56689,\n+    512, 55348, 56671, 55348, 56690, 512, 55348, 56761, 55348, 56677, 512,\n+    55348, 56762, 55348, 56677, 512, 55348, 56763, 55348, 56686, 512, 55348,\n+    56764, 55348, 56686, 512, 55348, 56763, 55348, 56687, 512, 55348, 56764,\n+    55348, 56687, 262, 65, 262, 66, 262, 67, 262, 68, 262, 69, 262, 70, 262,\n+    71, 262, 72, 262, 73, 262, 74, 262, 75, 262, 76, 262, 77, 262, 78, 262,\n+    79, 262, 80, 262, 81, 262, 82, 262, 83, 262, 84, 262, 85, 262, 86, 262,\n+    87, 262, 88, 262, 89, 262, 90, 262, 97, 262, 98, 262, 99, 262, 100, 262,\n+    101, 262, 102, 262, 103, 262, 104, 262, 105, 262, 106, 262, 107, 262,\n+    108, 262, 109, 262, 110, 262, 111, 262, 112, 262, 113, 262, 114, 262,\n+    115, 262, 116, 262, 117, 262, 118, 262, 119, 262, 120, 262, 121, 262,\n+    122, 262, 65, 262, 66, 262, 67, 262, 68, 262, 69, 262, 70, 262, 71, 262,\n+    72, 262, 73, 262, 74, 262, 75, 262, 76, 262, 77, 262, 78, 262, 79, 262,\n+    80, 262, 81, 262, 82, 262, 83, 262, 84, 262, 85, 262, 86, 262, 87, 262,\n+    88, 262, 89, 262, 90, 262, 97, 262, 98, 262, 99, 262, 100, 262, 101, 262,\n+    102, 262, 103, 262, 105, 262, 106, 262, 107, 262, 108, 262, 109, 262,\n+    110, 262, 111, 262, 112, 262, 113, 262, 114, 262, 115, 262, 116, 262,\n+    117, 262, 118, 262, 119, 262, 120, 262, 121, 262, 122, 262, 65, 262, 66,\n+    262, 67, 262, 68, 262, 69, 262, 70, 262, 71, 262, 72, 262, 73, 262, 74,\n+    262, 75, 262, 76, 262, 77, 262, 78, 262, 79, 262, 80, 262, 81, 262, 82,\n+    262, 83, 262, 84, 262, 85, 262, 86, 262, 87, 262, 88, 262, 89, 262, 90,\n+    262, 97, 262, 98, 262, 99, 262, 100, 262, 101, 262, 102, 262, 103, 262,\n+    104, 262, 105, 262, 106, 262, 107, 262, 108, 262, 109, 262, 110, 262,\n+    111, 262, 112, 262, 113, 262, 114, 262, 115, 262, 116, 262, 117, 262,\n+    118, 262, 119, 262, 120, 262, 121, 262, 122, 262, 65, 262, 67, 262, 68,\n+    262, 71, 262, 74, 262, 75, 262, 78, 262, 79, 262, 80, 262, 81, 262, 83,\n+    262, 84, 262, 85, 262, 86, 262, 87, 262, 88, 262, 89, 262, 90, 262, 97,\n+    262, 98, 262, 99, 262, 100, 262, 102, 262, 104, 262, 105, 262, 106, 262,\n+    107, 262, 108, 262, 109, 262, 110, 262, 112, 262, 113, 262, 114, 262,\n+    115, 262, 116, 262, 117, 262, 118, 262, 119, 262, 120, 262, 121, 262,\n+    122, 262, 65, 262, 66, 262, 67, 262, 68, 262, 69, 262, 70, 262, 71, 262,\n+    72, 262, 73, 262, 74, 262, 75, 262, 76, 262, 77, 262, 78, 262, 79, 262,\n+    80, 262, 81, 262, 82, 262, 83, 262, 84, 262, 85, 262, 86, 262, 87, 262,\n+    88, 262, 89, 262, 90, 262, 97, 262, 98, 262, 99, 262, 100, 262, 101, 262,\n+    102, 262, 103, 262, 104, 262, 105, 262, 106, 262, 107, 262, 108, 262,\n+    109, 262, 110, 262, 111, 262, 112, 262, 113, 262, 114, 262, 115, 262,\n+    116, 262, 117, 262, 118, 262, 119, 262, 120, 262, 121, 262, 122, 262, 65,\n+    262, 66, 262, 68, 262, 69, 262, 70, 262, 71, 262, 74, 262, 75, 262, 76,\n+    262, 77, 262, 78, 262, 79, 262, 80, 262, 81, 262, 83, 262, 84, 262, 85,\n+    262, 86, 262, 87, 262, 88, 262, 89, 262, 97, 262, 98, 262, 99, 262, 100,\n+    262, 101, 262, 102, 262, 103, 262, 104, 262, 105, 262, 106, 262, 107,\n+    262, 108, 262, 109, 262, 110, 262, 111, 262, 112, 262, 113, 262, 114,\n+    262, 115, 262, 116, 262, 117, 262, 118, 262, 119, 262, 120, 262, 121,\n+    262, 122, 262, 65, 262, 66, 262, 68, 262, 69, 262, 70, 262, 71, 262, 73,\n+    262, 74, 262, 75, 262, 76, 262, 77, 262, 79, 262, 83, 262, 84, 262, 85,\n+    262, 86, 262, 87, 262, 88, 262, 89, 262, 97, 262, 98, 262, 99, 262, 100,\n+    262, 101, 262, 102, 262, 103, 262, 104, 262, 105, 262, 106, 262, 107,\n+    262, 108, 262, 109, 262, 110, 262, 111, 262, 112, 262, 113, 262, 114,\n+    262, 115, 262, 116, 262, 117, 262, 118, 262, 119, 262, 120, 262, 121,\n+    262, 122, 262, 65, 262, 66, 262, 67, 262, 68, 262, 69, 262, 70, 262, 71,\n+    262, 72, 262, 73, 262, 74, 262, 75, 262, 76, 262, 77, 262, 78, 262, 79,\n+    262, 80, 262, 81, 262, 82, 262, 83, 262, 84, 262, 85, 262, 86, 262, 87,\n+    262, 88, 262, 89, 262, 90, 262, 97, 262, 98, 262, 99, 262, 100, 262, 101,\n+    262, 102, 262, 103, 262, 104, 262, 105, 262, 106, 262, 107, 262, 108,\n+    262, 109, 262, 110, 262, 111, 262, 112, 262, 113, 262, 114, 262, 115,\n+    262, 116, 262, 117, 262, 118, 262, 119, 262, 120, 262, 121, 262, 122,\n+    262, 65, 262, 66, 262, 67, 262, 68, 262, 69, 262, 70, 262, 71, 262, 72,\n+    262, 73, 262, 74, 262, 75, 262, 76, 262, 77, 262, 78, 262, 79, 262, 80,\n+    262, 81, 262, 82, 262, 83, 262, 84, 262, 85, 262, 86, 262, 87, 262, 88,\n+    262, 89, 262, 90, 262, 97, 262, 98, 262, 99, 262, 100, 262, 101, 262,\n+    102, 262, 103, 262, 104, 262, 105, 262, 106, 262, 107, 262, 108, 262,\n+    109, 262, 110, 262, 111, 262, 112, 262, 113, 262, 114, 262, 115, 262,\n+    116, 262, 117, 262, 118, 262, 119, 262, 120, 262, 121, 262, 122, 262, 65,\n+    262, 66, 262, 67, 262, 68, 262, 69, 262, 70, 262, 71, 262, 72, 262, 73,\n+    262, 74, 262, 75, 262, 76, 262, 77, 262, 78, 262, 79, 262, 80, 262, 81,\n+    262, 82, 262, 83, 262, 84, 262, 85, 262, 86, 262, 87, 262, 88, 262, 89,\n+    262, 90, 262, 97, 262, 98, 262, 99, 262, 100, 262, 101, 262, 102, 262,\n+    103, 262, 104, 262, 105, 262, 106, 262, 107, 262, 108, 262, 109, 262,\n+    110, 262, 111, 262, 112, 262, 113, 262, 114, 262, 115, 262, 116, 262,\n+    117, 262, 118, 262, 119, 262, 120, 262, 121, 262, 122, 262, 65, 262, 66,\n+    262, 67, 262, 68, 262, 69, 262, 70, 262, 71, 262, 72, 262, 73, 262, 74,\n+    262, 75, 262, 76, 262, 77, 262, 78, 262, 79, 262, 80, 262, 81, 262, 82,\n+    262, 83, 262, 84, 262, 85, 262, 86, 262, 87, 262, 88, 262, 89, 262, 90,\n+    262, 97, 262, 98, 262, 99, 262, 100, 262, 101, 262, 102, 262, 103, 262,\n+    104, 262, 105, 262, 106, 262, 107, 262, 108, 262, 109, 262, 110, 262,\n+    111, 262, 112, 262, 113, 262, 114, 262, 115, 262, 116, 262, 117, 262,\n+    118, 262, 119, 262, 120, 262, 121, 262, 122, 262, 65, 262, 66, 262, 67,\n+    262, 68, 262, 69, 262, 70, 262, 71, 262, 72, 262, 73, 262, 74, 262, 75,\n+    262, 76, 262, 77, 262, 78, 262, 79, 262, 80, 262, 81, 262, 82, 262, 83,\n+    262, 84, 262, 85, 262, 86, 262, 87, 262, 88, 262, 89, 262, 90, 262, 97,\n+    262, 98, 262, 99, 262, 100, 262, 101, 262, 102, 262, 103, 262, 104, 262,\n+    105, 262, 106, 262, 107, 262, 108, 262, 109, 262, 110, 262, 111, 262,\n+    112, 262, 113, 262, 114, 262, 115, 262, 116, 262, 117, 262, 118, 262,\n+    119, 262, 120, 262, 121, 262, 122, 262, 65, 262, 66, 262, 67, 262, 68,\n+    262, 69, 262, 70, 262, 71, 262, 72, 262, 73, 262, 74, 262, 75, 262, 76,\n+    262, 77, 262, 78, 262, 79, 262, 80, 262, 81, 262, 82, 262, 83, 262, 84,\n+    262, 85, 262, 86, 262, 87, 262, 88, 262, 89, 262, 90, 262, 97, 262, 98,\n+    262, 99, 262, 100, 262, 101, 262, 102, 262, 103, 262, 104, 262, 105, 262,\n+    106, 262, 107, 262, 108, 262, 109, 262, 110, 262, 111, 262, 112, 262,\n+    113, 262, 114, 262, 115, 262, 116, 262, 117, 262, 118, 262, 119, 262,\n+    120, 262, 121, 262, 122, 262, 305, 262, 567, 262, 913, 262, 914, 262,\n+    915, 262, 916, 262, 917, 262, 918, 262, 919, 262, 920, 262, 921, 262,\n+    922, 262, 923, 262, 924, 262, 925, 262, 926, 262, 927, 262, 928, 262,\n+    929, 262, 1012, 262, 931, 262, 932, 262, 933, 262, 934, 262, 935, 262,\n+    936, 262, 937, 262, 8711, 262, 945, 262, 946, 262, 947, 262, 948, 262,\n+    949, 262, 950, 262, 951, 262, 952, 262, 953, 262, 954, 262, 955, 262,\n+    956, 262, 957, 262, 958, 262, 959, 262, 960, 262, 961, 262, 962, 262,\n+    963, 262, 964, 262, 965, 262, 966, 262, 967, 262, 968, 262, 969, 262,\n+    8706, 262, 1013, 262, 977, 262, 1008, 262, 981, 262, 1009, 262, 982, 262,\n+    913, 262, 914, 262, 915, 262, 916, 262, 917, 262, 918, 262, 919, 262,\n+    920, 262, 921, 262, 922, 262, 923, 262, 924, 262, 925, 262, 926, 262,\n+    927, 262, 928, 262, 929, 262, 1012, 262, 931, 262, 932, 262, 933, 262,\n+    934, 262, 935, 262, 936, 262, 937, 262, 8711, 262, 945, 262, 946, 262,\n+    947, 262, 948, 262, 949, 262, 950, 262, 951, 262, 952, 262, 953, 262,\n+    954, 262, 955, 262, 956, 262, 957, 262, 958, 262, 959, 262, 960, 262,\n+    961, 262, 962, 262, 963, 262, 964, 262, 965, 262, 966, 262, 967, 262,\n+    968, 262, 969, 262, 8706, 262, 1013, 262, 977, 262, 1008, 262, 981, 262,\n+    1009, 262, 982, 262, 913, 262, 914, 262, 915, 262, 916, 262, 917, 262,\n+    918, 262, 919, 262, 920, 262, 921, 262, 922, 262, 923, 262, 924, 262,\n+    925, 262, 926, 262, 927, 262, 928, 262, 929, 262, 1012, 262, 931, 262,\n+    932, 262, 933, 262, 934, 262, 935, 262, 936, 262, 937, 262, 8711, 262,\n+    945, 262, 946, 262, 947, 262, 948, 262, 949, 262, 950, 262, 951, 262,\n+    952, 262, 953, 262, 954, 262, 955, 262, 956, 262, 957, 262, 958, 262,\n+    959, 262, 960, 262, 961, 262, 962, 262, 963, 262, 964, 262, 965, 262,\n+    966, 262, 967, 262, 968, 262, 969, 262, 8706, 262, 1013, 262, 977, 262,\n+    1008, 262, 981, 262, 1009, 262, 982, 262, 913, 262, 914, 262, 915, 262,\n+    916, 262, 917, 262, 918, 262, 919, 262, 920, 262, 921, 262, 922, 262,\n+    923, 262, 924, 262, 925, 262, 926, 262, 927, 262, 928, 262, 929, 262,\n+    1012, 262, 931, 262, 932, 262, 933, 262, 934, 262, 935, 262, 936, 262,\n+    937, 262, 8711, 262, 945, 262, 946, 262, 947, 262, 948, 262, 949, 262,\n+    950, 262, 951, 262, 952, 262, 953, 262, 954, 262, 955, 262, 956, 262,\n+    957, 262, 958, 262, 959, 262, 960, 262, 961, 262, 962, 262, 963, 262,\n+    964, 262, 965, 262, 966, 262, 967, 262, 968, 262, 969, 262, 8706, 262,\n+    1013, 262, 977, 262, 1008, 262, 981, 262, 1009, 262, 982, 262, 913, 262,\n+    914, 262, 915, 262, 916, 262, 917, 262, 918, 262, 919, 262, 920, 262,\n+    921, 262, 922, 262, 923, 262, 924, 262, 925, 262, 926, 262, 927, 262,\n+    928, 262, 929, 262, 1012, 262, 931, 262, 932, 262, 933, 262, 934, 262,\n+    935, 262, 936, 262, 937, 262, 8711, 262, 945, 262, 946, 262, 947, 262,\n+    948, 262, 949, 262, 950, 262, 951, 262, 952, 262, 953, 262, 954, 262,\n+    955, 262, 956, 262, 957, 262, 958, 262, 959, 262, 960, 262, 961, 262,\n+    962, 262, 963, 262, 964, 262, 965, 262, 966, 262, 967, 262, 968, 262,\n+    969, 262, 8706, 262, 1013, 262, 977, 262, 1008, 262, 981, 262, 1009, 262,\n+    982, 262, 988, 262, 989, 262, 48, 262, 49, 262, 50, 262, 51, 262, 52,\n+    262, 53, 262, 54, 262, 55, 262, 56, 262, 57, 262, 48, 262, 49, 262, 50,\n+    262, 51, 262, 52, 262, 53, 262, 54, 262, 55, 262, 56, 262, 57, 262, 48,\n+    262, 49, 262, 50, 262, 51, 262, 52, 262, 53, 262, 54, 262, 55, 262, 56,\n+    262, 57, 262, 48, 262, 49, 262, 50, 262, 51, 262, 52, 262, 53, 262, 54,\n+    262, 55, 262, 56, 262, 57, 262, 48, 262, 49, 262, 50, 262, 51, 262, 52,\n+    262, 53, 262, 54, 262, 55, 262, 56, 262, 57, 262, 1575, 262, 1576, 262,\n+    1580, 262, 1583, 262, 1608, 262, 1586, 262, 1581, 262, 1591, 262, 1610,\n+    262, 1603, 262, 1604, 262, 1605, 262, 1606, 262, 1587, 262, 1593, 262,\n+    1601, 262, 1589, 262, 1602, 262, 1585, 262, 1588, 262, 1578, 262, 1579,\n+    262, 1582, 262, 1584, 262, 1590, 262, 1592, 262, 1594, 262, 1646, 262,\n+    1722, 262, 1697, 262, 1647, 262, 1576, 262, 1580, 262, 1607, 262, 1581,\n+    262, 1610, 262, 1603, 262, 1604, 262, 1605, 262, 1606, 262, 1587, 262,\n+    1593, 262, 1601, 262, 1589, 262, 1602, 262, 1588, 262, 1578, 262, 1579,\n+    262, 1582, 262, 1590, 262, 1594, 262, 1580, 262, 1581, 262, 1610, 262,\n+    1604, 262, 1606, 262, 1587, 262, 1593, 262, 1589, 262, 1602, 262, 1588,\n+    262, 1582, 262, 1590, 262, 1594, 262, 1722, 262, 1647, 262, 1576, 262,\n+    1580, 262, 1607, 262, 1581, 262, 1591, 262, 1610, 262, 1603, 262, 1605,\n+    262, 1606, 262, 1587, 262, 1593, 262, 1601, 262, 1589, 262, 1602, 262,\n+    1588, 262, 1578, 262, 1579, 262, 1582, 262, 1590, 262, 1592, 262, 1594,\n+    262, 1646, 262, 1697, 262, 1575, 262, 1576, 262, 1580, 262, 1583, 262,\n+    1607, 262, 1608, 262, 1586, 262, 1581, 262, 1591, 262, 1610, 262, 1604,\n+    262, 1605, 262, 1606, 262, 1587, 262, 1593, 262, 1601, 262, 1589, 262,\n+    1602, 262, 1585, 262, 1588, 262, 1578, 262, 1579, 262, 1582, 262, 1584,\n+    262, 1590, 262, 1592, 262, 1594, 262, 1576, 262, 1580, 262, 1583, 262,\n+    1608, 262, 1586, 262, 1581, 262, 1591, 262, 1610, 262, 1604, 262, 1605,\n+    262, 1606, 262, 1587, 262, 1593, 262, 1601, 262, 1589, 262, 1602, 262,\n+    1585, 262, 1588, 262, 1578, 262, 1579, 262, 1582, 262, 1584, 262, 1590,\n+    262, 1592, 262, 1594, 514, 48, 46, 514, 48, 44, 514, 49, 44, 514, 50, 44,\n+    514, 51, 44, 514, 52, 44, 514, 53, 44, 514, 54, 44, 514, 55, 44, 514, 56,\n+    44, 514, 57, 44, 770, 40, 65, 41, 770, 40, 66, 41, 770, 40, 67, 41, 770,\n+    40, 68, 41, 770, 40, 69, 41, 770, 40, 70, 41, 770, 40, 71, 41, 770, 40,\n+    72, 41, 770, 40, 73, 41, 770, 40, 74, 41, 770, 40, 75, 41, 770, 40, 76,\n+    41, 770, 40, 77, 41, 770, 40, 78, 41, 770, 40, 79, 41, 770, 40, 80, 41,\n+    770, 40, 81, 41, 770, 40, 82, 41, 770, 40, 83, 41, 770, 40, 84, 41, 770,\n+    40, 85, 41, 770, 40, 86, 41, 770, 40, 87, 41, 770, 40, 88, 41, 770, 40,\n+    89, 41, 770, 40, 90, 41, 770, 12308, 83, 12309, 263, 67, 263, 82, 519,\n+    67, 68, 519, 87, 90, 266, 65, 266, 66, 266, 67, 266, 68, 266, 69, 266,\n+    70, 266, 71, 266, 72, 266, 73, 266, 74, 266, 75, 266, 76, 266, 77, 266,\n+    78, 266, 79, 266, 80, 266, 81, 266, 82, 266, 83, 266, 84, 266, 85, 266,\n+    86, 266, 87, 266, 88, 266, 89, 266, 90, 522, 72, 86, 522, 77, 86, 522,\n+    83, 68, 522, 83, 83, 778, 80, 80, 86, 522, 87, 67, 515, 77, 67, 515, 77,\n+    68, 522, 68, 74, 522, 12411, 12363, 522, 12467, 12467, 266, 12469, 266,\n+    25163, 266, 23383, 266, 21452, 266, 12487, 266, 20108, 266, 22810, 266,\n+    35299, 266, 22825, 266, 20132, 266, 26144, 266, 28961, 266, 26009, 266,\n+    21069, 266, 24460, 266, 20877, 266, 26032, 266, 21021, 266, 32066, 266,\n+    29983, 266, 36009, 266, 22768, 266, 21561, 266, 28436, 266, 25237, 266,\n+    25429, 266, 19968, 266, 19977, 266, 36938, 266, 24038, 266, 20013, 266,\n+    21491, 266, 25351, 266, 36208, 266, 25171, 266, 31105, 266, 31354, 266,\n+    21512, 266, 28288, 266, 26377, 266, 26376, 266, 30003, 266, 21106, 266,\n+    21942, 266, 37197, 770, 12308, 26412, 12309, 770, 12308, 19977, 12309,\n+    770, 12308, 20108, 12309, 770, 12308, 23433, 12309, 770, 12308, 28857,\n+    12309, 770, 12308, 25171, 12309, 770, 12308, 30423, 12309, 770, 12308,\n+    21213, 12309, 770, 12308, 25943, 12309, 263, 24471, 263, 21487, 256,\n+    20029, 256, 20024, 256, 20033, 256, 55360, 56610, 256, 20320, 256, 20398,\n+    256, 20411, 256, 20482, 256, 20602, 256, 20633, 256, 20711, 256, 20687,\n+    256, 13470, 256, 55361, 56890, 256, 20813, 256, 20820, 256, 20836, 256,\n+    20855, 256, 55361, 56604, 256, 13497, 256, 20839, 256, 20877, 256, 55361,\n+    56651, 256, 20887, 256, 20900, 256, 20172, 256, 20908, 256, 20917, 256,\n+    55396, 56799, 256, 20981, 256, 20995, 256, 13535, 256, 21051, 256, 21062,\n+    256, 21106, 256, 21111, 256, 13589, 256, 21191, 256, 21193, 256, 21220,\n+    256, 21242, 256, 21253, 256, 21254, 256, 21271, 256, 21321, 256, 21329,\n+    256, 21338, 256, 21363, 256, 21373, 256, 21375, 256, 21375, 256, 21375,\n+    256, 55362, 56876, 256, 28784, 256, 21450, 256, 21471, 256, 55362, 57187,\n+    256, 21483, 256, 21489, 256, 21510, 256, 21662, 256, 21560, 256, 21576,\n+    256, 21608, 256, 21666, 256, 21750, 256, 21776, 256, 21843, 256, 21859,\n+    256, 21892, 256, 21892, 256, 21913, 256, 21931, 256, 21939, 256, 21954,\n+    256, 22294, 256, 22022, 256, 22295, 256, 22097, 256, 22132, 256, 20999,\n+    256, 22766, 256, 22478, 256, 22516, 256, 22541, 256, 22411, 256, 22578,\n+    256, 22577, 256, 22700, 256, 55365, 56548, 256, 22770, 256, 22775, 256,\n+    22790, 256, 22810, 256, 22818, 256, 22882, 256, 55365, 57000, 256, 55365,\n+    57066, 256, 23020, 256, 23067, 256, 23079, 256, 23000, 256, 23142, 256,\n+    14062, 256, 14076, 256, 23304, 256, 23358, 256, 23358, 256, 55366, 56776,\n+    256, 23491, 256, 23512, 256, 23527, 256, 23539, 256, 55366, 57112, 256,\n+    23551, 256, 23558, 256, 24403, 256, 23586, 256, 14209, 256, 23648, 256,\n+    23662, 256, 23744, 256, 23693, 256, 55367, 56804, 256, 23875, 256, 55367,\n+    56806, 256, 23918, 256, 23915, 256, 23932, 256, 24033, 256, 24034, 256,\n+    14383, 256, 24061, 256, 24104, 256, 24125, 256, 24169, 256, 14434, 256,\n+    55368, 56707, 256, 14460, 256, 24240, 256, 24243, 256, 24246, 256, 24266,\n+    256, 55400, 57234, 256, 24318, 256, 55368, 57137, 256, 55368, 57137, 256,\n+    33281, 256, 24354, 256, 24354, 256, 14535, 256, 55372, 57016, 256, 55384,\n+    56794, 256, 24418, 256, 24427, 256, 14563, 256, 24474, 256, 24525, 256,\n+    24535, 256, 24569, 256, 24705, 256, 14650, 256, 14620, 256, 24724, 256,\n+    55369, 57044, 256, 24775, 256, 24904, 256, 24908, 256, 24910, 256, 24908,\n+    256, 24954, 256, 24974, 256, 25010, 256, 24996, 256, 25007, 256, 25054,\n+    256, 25074, 256, 25078, 256, 25104, 256, 25115, 256, 25181, 256, 25265,\n+    256, 25300, 256, 25424, 256, 55370, 57100, 256, 25405, 256, 25340, 256,\n+    25448, 256, 25475, 256, 25572, 256, 55370, 57329, 256, 25634, 256, 25541,\n+    256, 25513, 256, 14894, 256, 25705, 256, 25726, 256, 25757, 256, 25719,\n+    256, 14956, 256, 25935, 256, 25964, 256, 55372, 56330, 256, 26083, 256,\n+    26360, 256, 26185, 256, 15129, 256, 26257, 256, 15112, 256, 15076, 256,\n+    20882, 256, 20885, 256, 26368, 256, 26268, 256, 32941, 256, 17369, 256,\n+    26391, 256, 26395, 256, 26401, 256, 26462, 256, 26451, 256, 55372, 57283,\n+    256, 15177, 256, 26618, 256, 26501, 256, 26706, 256, 26757, 256, 55373,\n+    56429, 256, 26766, 256, 26655, 256, 26900, 256, 15261, 256, 26946, 256,\n+    27043, 256, 27114, 256, 27304, 256, 55373, 56995, 256, 27355, 256, 15384,\n+    256, 27425, 256, 55374, 56487, 256, 27476, 256, 15438, 256, 27506, 256,\n+    27551, 256, 27578, 256, 27579, 256, 55374, 56973, 256, 55367, 56587, 256,\n+    55374, 57082, 256, 27726, 256, 55375, 56508, 256, 27839, 256, 27853, 256,\n+    27751, 256, 27926, 256, 27966, 256, 28023, 256, 27969, 256, 28009, 256,\n+    28024, 256, 28037, 256, 55375, 56606, 256, 27956, 256, 28207, 256, 28270,\n+    256, 15667, 256, 28363, 256, 28359, 256, 55375, 57041, 256, 28153, 256,\n+    28526, 256, 55375, 57182, 256, 55375, 57230, 256, 28614, 256, 28729, 256,\n+    28702, 256, 28699, 256, 15766, 256, 28746, 256, 28797, 256, 28791, 256,\n+    28845, 256, 55361, 56613, 256, 28997, 256, 55376, 56931, 256, 29084, 256,\n+    55376, 57259, 256, 29224, 256, 29237, 256, 29264, 256, 55377, 56840, 256,\n+    29312, 256, 29333, 256, 55377, 57141, 256, 55378, 56340, 256, 29562, 256,\n+    29579, 256, 16044, 256, 29605, 256, 16056, 256, 16056, 256, 29767, 256,\n+    29788, 256, 29809, 256, 29829, 256, 29898, 256, 16155, 256, 29988, 256,\n+    55379, 56374, 256, 30014, 256, 55379, 56466, 256, 30064, 256, 55368,\n+    56735, 256, 30224, 256, 55379, 57249, 256, 55379, 57272, 256, 55380,\n+    56388, 256, 16380, 256, 16392, 256, 30452, 256, 55380, 56563, 256, 55380,\n+    56562, 256, 55380, 56601, 256, 55380, 56627, 256, 30494, 256, 30495, 256,\n+    30495, 256, 30538, 256, 16441, 256, 30603, 256, 16454, 256, 16534, 256,\n+    55381, 56349, 256, 30798, 256, 30860, 256, 30924, 256, 16611, 256, 55381,\n+    56870, 256, 31062, 256, 55381, 56986, 256, 55381, 57029, 256, 31119, 256,\n+    31211, 256, 16687, 256, 31296, 256, 31306, 256, 31311, 256, 55382, 56700,\n+    256, 55382, 56999, 256, 55382, 56999, 256, 31470, 256, 16898, 256, 55382,\n+    57259, 256, 31686, 256, 31689, 256, 16935, 256, 55383, 56448, 256, 31954,\n+    256, 17056, 256, 31976, 256, 31971, 256, 32000, 256, 55383, 57222, 256,\n+    32099, 256, 17153, 256, 32199, 256, 32258, 256, 32325, 256, 17204, 256,\n+    55384, 56872, 256, 55384, 56903, 256, 17241, 256, 55384, 57049, 256,\n+    32634, 256, 55384, 57150, 256, 32661, 256, 32762, 256, 32773, 256, 55385,\n+    56538, 256, 55385, 56611, 256, 32864, 256, 55385, 56744, 256, 32880, 256,\n+    55372, 57183, 256, 17365, 256, 32946, 256, 33027, 256, 17419, 256, 33086,\n+    256, 23221, 256, 55385, 57255, 256, 55385, 57269, 256, 55372, 57235, 256,\n+    55372, 57244, 256, 33281, 256, 33284, 256, 36766, 256, 17515, 256, 33425,\n+    256, 33419, 256, 33437, 256, 21171, 256, 33457, 256, 33459, 256, 33469,\n+    256, 33510, 256, 55386, 57148, 256, 33509, 256, 33565, 256, 33635, 256,\n+    33709, 256, 33571, 256, 33725, 256, 33767, 256, 33879, 256, 33619, 256,\n+    33738, 256, 33740, 256, 33756, 256, 55387, 56374, 256, 55387, 56683, 256,\n+    55387, 56533, 256, 17707, 256, 34033, 256, 34035, 256, 34070, 256, 55388,\n+    57290, 256, 34148, 256, 55387, 57132, 256, 17757, 256, 17761, 256, 55387,\n+    57265, 256, 55388, 56530, 256, 17771, 256, 34384, 256, 34396, 256, 34407,\n+    256, 34409, 256, 34473, 256, 34440, 256, 34574, 256, 34530, 256, 34681,\n+    256, 34600, 256, 34667, 256, 34694, 256, 17879, 256, 34785, 256, 34817,\n+    256, 17913, 256, 34912, 256, 34915, 256, 55389, 56935, 256, 35031, 256,\n+    35038, 256, 17973, 256, 35066, 256, 13499, 256, 55390, 56494, 256, 55390,\n+    56678, 256, 18110, 256, 18119, 256, 35488, 256, 35565, 256, 35722, 256,\n+    35925, 256, 55391, 56488, 256, 36011, 256, 36033, 256, 36123, 256, 36215,\n+    256, 55391, 57135, 256, 55362, 56324, 256, 36299, 256, 36284, 256, 36336,\n+    256, 55362, 56542, 256, 36564, 256, 36664, 256, 55393, 56786, 256, 55393,\n+    56813, 256, 37012, 256, 37105, 256, 37137, 256, 55393, 57134, 256, 37147,\n+    256, 37432, 256, 37591, 256, 37592, 256, 37500, 256, 37881, 256, 37909,\n+    256, 55394, 57338, 256, 38283, 256, 18837, 256, 38327, 256, 55395, 56695,\n+    256, 18918, 256, 38595, 256, 23986, 256, 38691, 256, 55396, 56645, 256,\n+    55396, 56858, 256, 19054, 256, 19062, 256, 38880, 256, 55397, 56330, 256,\n+    19122, 256, 55397, 56470, 256, 38923, 256, 38923, 256, 38953, 256, 55397,\n+    56758, 256, 39138, 256, 19251, 256, 39209, 256, 39335, 256, 39362, 256,\n+    39422, 256, 19406, 256, 55398, 57136, 256, 39698, 256, 40000, 256, 40189,\n+    256, 19662, 256, 19693, 256, 40295, 256, 55400, 56526, 256, 19704, 256,\n+    55400, 56581, 256, 55400, 56846, 256, 55400, 56977, 256, 40635, 256,\n+    19798, 256, 40697, 256, 40702, 256, 40709, 256, 40719, 256, 40726, 256,\n+    40763, 256, 55401, 56832,\n+};\n+\n+\/* index tables for the decomposition data *\/\n+#define DECOMP_SHIFT1 6\n+#define DECOMP_SHIFT2 4\n+static const unsigned char decomp_index0[] = {\n+    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 13, 14, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 15, 16, 5, 5, 5, 5, 17, 18,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 19, 20,\n+    5, 5, 5, 5, 5, 21, 22, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    23, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+    5, 5, 5, 5, 5, 5, 5, 5, 5, 5,\n+};\n+\n+static const unsigned short decomp_index1[] = {\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13,\n+    14, 0, 0, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 0, 0, 0, 0, 0, 0, 0,\n+    25, 0, 26, 27, 0, 0, 0, 0, 0, 28, 0, 0, 29, 30, 31, 32, 33, 34, 35, 0,\n+    36, 37, 38, 0, 39, 0, 40, 0, 41, 0, 0, 0, 0, 42, 43, 44, 45, 0, 0, 0, 0,\n+    0, 0, 0, 0, 46, 0, 0, 0, 0, 0, 0, 0, 0, 0, 47, 0, 0, 0, 0, 48, 0, 0, 0,\n+    0, 49, 50, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 51, 52, 0, 53, 0, 0, 0, 0,\n+    0, 0, 54, 55, 0, 0, 0, 0, 0, 56, 0, 57, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 58, 59, 0, 0, 0, 60, 0, 0, 61, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0,\n+    0, 0, 0, 0, 63, 0, 0, 0, 0, 0, 0, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 65, 0,\n+    0, 0, 0, 0, 66, 0, 0, 0, 0, 0, 0, 0, 67, 0, 68, 0, 0, 69, 0, 0, 0, 70,\n+    71, 72, 73, 74, 75, 76, 77, 0, 0, 0, 0, 0, 0, 78, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 79, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 80, 81, 0,\n+    82, 83, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 84, 85, 86, 87, 88, 89, 0, 90, 91, 92, 0, 0, 0, 0,\n+    93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108,\n+    109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122,\n+    123, 124, 125, 126, 127, 128, 129, 130, 0, 131, 132, 133, 134, 0, 0, 0,\n+    0, 0, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 0, 146, 0,\n+    0, 0, 147, 0, 148, 149, 150, 0, 151, 152, 153, 0, 154, 0, 0, 0, 155, 0,\n+    0, 0, 156, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 157,\n+    158, 159, 160, 161, 162, 163, 164, 165, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 166, 0,\n+    0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 168, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 169, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 170, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    171, 0, 0, 0, 0, 0, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181,\n+    182, 183, 184, 185, 186, 0, 0, 187, 0, 0, 188, 189, 190, 191, 192, 0,\n+    193, 194, 195, 196, 197, 0, 198, 0, 0, 0, 199, 200, 201, 202, 203, 204,\n+    205, 0, 0, 0, 0, 0, 0, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215,\n+    216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229,\n+    230, 231, 232, 233, 234, 235, 236, 237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 238, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 239, 0, 0,\n+    0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 241, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 242, 243, 244, 245, 246, 247,\n+    248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261,\n+    262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 0, 0, 272, 273, 274,\n+    275, 276, 277, 278, 279, 280, 281, 282, 283, 0, 284, 285, 286, 287, 288,\n+    289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302,\n+    303, 304, 305, 306, 0, 307, 308, 309, 310, 311, 312, 313, 314, 0, 0, 315,\n+    0, 316, 0, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328,\n+    329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342,\n+    343, 344, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 345, 346, 0, 0, 0, 0, 0, 0, 0,\n+    347, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 348, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 349, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 350, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 351, 352, 0, 0, 0, 0, 353, 354, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364,\n+    365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378,\n+    379, 380, 381, 382, 383, 384, 385, 386, 387, 388, 389, 390, 391, 392,\n+    393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406,\n+    407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 419, 420, 421, 422, 423, 424, 425, 426, 427, 428, 429, 430,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 431, 432, 433, 434, 435, 0, 436, 0,\n+    0, 437, 0, 0, 0, 0, 0, 0, 438, 439, 440, 441, 442, 443, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 444, 445,\n+    446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459,\n+    460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473,\n+    474, 475, 476, 477, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+};\n+\n+static const unsigned short decomp_index2[] = {\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,\n+    3, 0, 6, 0, 0, 0, 0, 8, 0, 0, 11, 13, 15, 18, 0, 0, 20, 23, 25, 0, 27,\n+    31, 35, 0, 39, 42, 45, 48, 51, 54, 0, 57, 60, 63, 66, 69, 72, 75, 78, 81,\n+    0, 84, 87, 90, 93, 96, 99, 0, 0, 102, 105, 108, 111, 114, 0, 0, 117, 120,\n+    123, 126, 129, 132, 0, 135, 138, 141, 144, 147, 150, 153, 156, 159, 0,\n+    162, 165, 168, 171, 174, 177, 0, 0, 180, 183, 186, 189, 192, 0, 195, 198,\n+    201, 204, 207, 210, 213, 216, 219, 222, 225, 228, 231, 234, 237, 240,\n+    243, 0, 0, 246, 249, 252, 255, 258, 261, 264, 267, 270, 273, 276, 279,\n+    282, 285, 288, 291, 294, 297, 300, 303, 0, 0, 306, 309, 312, 315, 318,\n+    321, 324, 327, 330, 0, 333, 336, 339, 342, 345, 348, 0, 351, 354, 357,\n+    360, 363, 366, 369, 372, 0, 0, 375, 378, 381, 384, 387, 390, 393, 0, 0,\n+    396, 399, 402, 405, 408, 411, 0, 0, 414, 417, 420, 423, 426, 429, 432,\n+    435, 438, 441, 444, 447, 450, 453, 456, 459, 462, 465, 0, 0, 468, 471,\n+    474, 477, 480, 483, 486, 489, 492, 495, 498, 501, 504, 507, 510, 513,\n+    516, 519, 522, 525, 528, 531, 534, 537, 539, 542, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 545, 548, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 551, 554, 557, 560, 563, 566, 569, 572, 575, 578, 581, 584, 587,\n+    590, 593, 596, 599, 602, 605, 608, 611, 614, 617, 620, 623, 0, 626, 629,\n+    632, 635, 638, 641, 0, 0, 644, 647, 650, 653, 656, 659, 662, 665, 668,\n+    671, 674, 677, 680, 683, 686, 689, 0, 0, 692, 695, 698, 701, 704, 707,\n+    710, 713, 716, 719, 722, 725, 728, 731, 734, 737, 740, 743, 746, 749,\n+    752, 755, 758, 761, 764, 767, 770, 773, 776, 779, 782, 785, 788, 791,\n+    794, 797, 0, 0, 800, 803, 0, 0, 0, 0, 0, 0, 806, 809, 812, 815, 818, 821,\n+    824, 827, 830, 833, 836, 839, 842, 845, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 848, 850, 852, 854, 856, 858, 860, 862, 864, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 866, 869, 872, 875, 878, 881, 0, 0, 884, 886, 888,\n+    890, 892, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 894, 896, 0, 898, 900, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 903, 0, 0, 0, 0, 0, 905, 0, 0, 0,\n+    908, 0, 0, 0, 0, 0, 910, 913, 916, 919, 921, 924, 927, 0, 930, 0, 933,\n+    936, 939, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 942, 945, 948, 951, 954, 957, 960, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 963, 966, 969, 972, 975,\n+    0, 978, 980, 982, 984, 987, 990, 992, 0, 0, 0, 0, 0, 0, 0, 0, 0, 994,\n+    996, 998, 0, 1000, 1002, 0, 0, 0, 1004, 0, 0, 0, 0, 0, 0, 1006, 1009, 0,\n+    1012, 0, 0, 0, 1015, 0, 0, 0, 0, 1018, 1021, 1024, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 1027, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1030, 0, 0,\n+    0, 0, 0, 0, 1033, 1036, 0, 1039, 0, 0, 0, 1042, 0, 0, 0, 0, 1045, 1048,\n+    1051, 0, 0, 0, 0, 0, 0, 0, 1054, 1057, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1060,\n+    1063, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1066, 1069, 1072, 1075, 0,\n+    0, 1078, 1081, 0, 0, 1084, 1087, 1090, 1093, 1096, 1099, 0, 0, 1102,\n+    1105, 1108, 1111, 1114, 1117, 0, 0, 1120, 1123, 1126, 1129, 1132, 1135,\n+    1138, 1141, 1144, 1147, 1150, 1153, 0, 0, 1156, 1159, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 1162, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1165, 1168,\n+    1171, 1174, 1177, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1180, 1183,\n+    1186, 1189, 0, 0, 0, 0, 0, 0, 0, 1192, 0, 1195, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 1198, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 1201, 0, 0, 0, 0, 0, 0, 0, 1204, 0, 0, 1207, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1210, 1213, 1216,\n+    1219, 1222, 1225, 1228, 1231, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1234,\n+    1237, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1240, 1243, 0, 1246,\n+    0, 0, 0, 1249, 0, 0, 1252, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 1255, 1258, 1261, 0, 0, 1264, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1267,\n+    0, 0, 1270, 1273, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1276,\n+    1279, 0, 0, 0, 0, 0, 0, 1282, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 1285, 1288, 1291, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1294, 0, 0, 0, 0, 0, 0, 0, 1297, 0, 0, 0, 0, 0, 0, 1300, 1303, 0, 1306,\n+    1309, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1312, 1315, 1318, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1321, 0, 1324, 1327, 1330, 0, 0, 0, 0,\n+    1333, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1336, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1339, 1342, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1345, 0, 0, 0, 0, 0, 0, 1347, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 1350, 0, 0, 0, 0, 1353, 0, 0, 0, 0, 1356, 0, 0,\n+    0, 0, 1359, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1362, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 1365, 0, 1368, 1371, 1374, 1377, 1380, 0, 0, 0, 0, 0, 0, 0,\n+    1383, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1386, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 1389, 0, 0, 0, 0, 1392, 0, 0, 0, 0, 1395, 0, 0, 0, 0,\n+    1398, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1401, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 1404, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 1407, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1409, 0, 1412, 0, 1415, 0,\n+    1418, 0, 1421, 0, 0, 0, 1424, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1427, 0, 1430, 0, 0, 1433, 1436, 0, 1439,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    1442, 1444, 1446, 0, 1448, 1450, 1452, 1454, 1456, 1458, 1460, 1462,\n+    1464, 1466, 1468, 0, 1470, 1472, 1474, 1476, 1478, 1480, 1482, 1484,\n+    1486, 1488, 1490, 1492, 1494, 1496, 1498, 1500, 1502, 1504, 0, 1506,\n+    1508, 1510, 1512, 1514, 1516, 1518, 1520, 1522, 1524, 1526, 1528, 1530,\n+    1532, 1534, 1536, 1538, 1540, 1542, 1544, 1546, 1548, 1550, 1552, 1554,\n+    1556, 1558, 1560, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1562, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1564, 1566, 1568, 1570,\n+    1572, 1574, 1576, 1578, 1580, 1582, 1584, 1586, 1588, 1590, 1592, 1594,\n+    1596, 1598, 1600, 1602, 1604, 1606, 1608, 1610, 1612, 1614, 1616, 1618,\n+    1620, 1622, 1624, 1626, 1628, 1630, 1632, 1634, 1636, 1638, 1641, 1644,\n+    1647, 1650, 1653, 1656, 1659, 1662, 1665, 1668, 1671, 1674, 1677, 1680,\n+    1683, 1686, 1689, 1692, 1695, 1698, 1701, 1704, 1707, 1710, 1713, 1716,\n+    1719, 1722, 1725, 1728, 1731, 1734, 1737, 1740, 1743, 1746, 1749, 1752,\n+    1755, 1758, 1761, 1764, 1767, 1770, 1773, 1776, 1779, 1782, 1785, 1788,\n+    1791, 1794, 1797, 1800, 1803, 1806, 1809, 1812, 1815, 1818, 1821, 1824,\n+    1827, 1830, 1833, 1836, 1839, 1842, 1845, 1848, 1851, 1854, 1857, 1860,\n+    1863, 1866, 1869, 1872, 1875, 1878, 1881, 1884, 1887, 1890, 1893, 1896,\n+    1899, 1902, 1905, 1908, 1911, 1914, 1917, 1920, 1923, 1926, 1929, 1932,\n+    1935, 1938, 1941, 1944, 1947, 1950, 1953, 1956, 1959, 1962, 1965, 1968,\n+    1971, 1974, 1977, 1980, 1983, 1986, 1989, 1992, 1995, 1998, 2001, 2004,\n+    2007, 2010, 2013, 2016, 2019, 2022, 2025, 2028, 2031, 2034, 2037, 2040,\n+    2043, 2046, 2049, 2052, 2055, 2058, 2061, 2064, 2067, 2070, 2073, 2076,\n+    2079, 2082, 2085, 2088, 2091, 2094, 2097, 2100, 2103, 0, 0, 0, 0, 2106,\n+    2109, 2112, 2115, 2118, 2121, 2124, 2127, 2130, 2133, 2136, 2139, 2142,\n+    2145, 2148, 2151, 2154, 2157, 2160, 2163, 2166, 2169, 2172, 2175, 2178,\n+    2181, 2184, 2187, 2190, 2193, 2196, 2199, 2202, 2205, 2208, 2211, 2214,\n+    2217, 2220, 2223, 2226, 2229, 2232, 2235, 2238, 2241, 2244, 2247, 2250,\n+    2253, 2256, 2259, 2262, 2265, 2268, 2271, 2274, 2277, 2280, 2283, 2286,\n+    2289, 2292, 2295, 2298, 2301, 2304, 2307, 2310, 2313, 2316, 2319, 2322,\n+    2325, 2328, 2331, 2334, 2337, 2340, 2343, 2346, 2349, 2352, 2355, 2358,\n+    2361, 2364, 2367, 2370, 2373, 0, 0, 0, 0, 0, 0, 2376, 2379, 2382, 2385,\n+    2388, 2391, 2394, 2397, 2400, 2403, 2406, 2409, 2412, 2415, 2418, 2421,\n+    2424, 2427, 2430, 2433, 2436, 2439, 0, 0, 2442, 2445, 2448, 2451, 2454,\n+    2457, 0, 0, 2460, 2463, 2466, 2469, 2472, 2475, 2478, 2481, 2484, 2487,\n+    2490, 2493, 2496, 2499, 2502, 2505, 2508, 2511, 2514, 2517, 2520, 2523,\n+    2526, 2529, 2532, 2535, 2538, 2541, 2544, 2547, 2550, 2553, 2556, 2559,\n+    2562, 2565, 2568, 2571, 0, 0, 2574, 2577, 2580, 2583, 2586, 2589, 0, 0,\n+    2592, 2595, 2598, 2601, 2604, 2607, 2610, 2613, 0, 2616, 0, 2619, 0,\n+    2622, 0, 2625, 2628, 2631, 2634, 2637, 2640, 2643, 2646, 2649, 2652,\n+    2655, 2658, 2661, 2664, 2667, 2670, 2673, 2676, 2679, 2681, 2684, 2686,\n+    2689, 2691, 2694, 2696, 2699, 2701, 2704, 2706, 2709, 0, 0, 2711, 2714,\n+    2717, 2720, 2723, 2726, 2729, 2732, 2735, 2738, 2741, 2744, 2747, 2750,\n+    2753, 2756, 2759, 2762, 2765, 2768, 2771, 2774, 2777, 2780, 2783, 2786,\n+    2789, 2792, 2795, 2798, 2801, 2804, 2807, 2810, 2813, 2816, 2819, 2822,\n+    2825, 2828, 2831, 2834, 2837, 2840, 2843, 2846, 2849, 2852, 2855, 2858,\n+    2861, 2864, 2867, 0, 2870, 2873, 2876, 2879, 2882, 2885, 2887, 2890,\n+    2893, 2895, 2898, 2901, 2904, 2907, 2910, 0, 2913, 2916, 2919, 2922,\n+    2924, 2927, 2929, 2932, 2935, 2938, 2941, 2944, 2947, 2950, 0, 0, 2952,\n+    2955, 2958, 2961, 2964, 2967, 0, 2969, 2972, 2975, 2978, 2981, 2984,\n+    2987, 2989, 2992, 2995, 2998, 3001, 3004, 3007, 3010, 3012, 3015, 3018,\n+    3020, 0, 0, 3022, 3025, 3028, 0, 3031, 3034, 3037, 3040, 3042, 3045,\n+    3047, 3050, 3052, 0, 3055, 3057, 3059, 3061, 3063, 3065, 3067, 3069,\n+    3071, 3073, 3075, 0, 0, 0, 0, 0, 0, 3077, 0, 0, 0, 0, 0, 3079, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 3082, 3084, 3087, 0, 0, 0, 0, 0, 0, 0, 0,\n+    3091, 0, 0, 0, 3093, 3096, 0, 3100, 3103, 0, 0, 0, 0, 3107, 0, 3110, 0,\n+    0, 0, 0, 0, 0, 0, 0, 3113, 3116, 3119, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 3122, 0, 0, 0, 0, 0, 0, 0, 3127, 3129, 3131, 0, 0, 3133, 3135,\n+    3137, 3139, 3141, 3143, 3145, 3147, 3149, 3151, 3153, 3155, 3157, 3159,\n+    3161, 3163, 3165, 3167, 3169, 3171, 3173, 3175, 3177, 3179, 3181, 3183,\n+    3185, 0, 3187, 3189, 3191, 3193, 3195, 3197, 3199, 3201, 3203, 3205,\n+    3207, 3209, 3211, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3213, 0, 0, 0, 0, 0,\n+    0, 0, 3216, 3220, 3224, 3226, 0, 3229, 3233, 3237, 0, 3239, 3242, 3244,\n+    3246, 3248, 3250, 3252, 3254, 3256, 3258, 3260, 0, 3262, 3264, 0, 0,\n+    3267, 3269, 3271, 3273, 3275, 0, 0, 3277, 3280, 3284, 0, 3287, 0, 3289,\n+    0, 3291, 0, 3293, 3295, 3297, 3299, 0, 3301, 3303, 3305, 0, 3307, 3309,\n+    3311, 3313, 3315, 3317, 3319, 0, 3321, 3325, 3327, 3329, 3331, 3333, 0,\n+    0, 0, 0, 3335, 3337, 3339, 3341, 3343, 0, 0, 0, 0, 0, 0, 3345, 3349,\n+    3353, 3358, 3362, 3366, 3370, 3374, 3378, 3382, 3386, 3390, 3394, 3398,\n+    3402, 3406, 3409, 3411, 3414, 3418, 3421, 3423, 3426, 3430, 3435, 3438,\n+    3440, 3443, 3447, 3449, 3451, 3453, 3455, 3457, 3460, 3464, 3467, 3469,\n+    3472, 3476, 3481, 3484, 3486, 3489, 3493, 3495, 3497, 3499, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 3501, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    3505, 3508, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3511,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3514, 3517, 3520, 0, 0, 0, 0,\n+    3523, 0, 0, 0, 0, 3526, 0, 0, 3529, 0, 0, 0, 0, 0, 0, 0, 3532, 0, 3535,\n+    0, 0, 0, 0, 0, 3538, 3541, 0, 3545, 3548, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 3552, 0, 0, 3555, 0, 0, 3558, 0, 3561, 0, 0, 0, 0, 0,\n+    0, 3564, 0, 3567, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3570, 3573, 3576, 3579,\n+    3582, 0, 0, 3585, 3588, 0, 0, 3591, 3594, 0, 0, 0, 0, 0, 0, 3597, 3600,\n+    0, 0, 3603, 3606, 0, 0, 3609, 3612, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 3615, 3618, 3621, 3624, 3627, 3630, 3633, 3636, 0, 0,\n+    0, 0, 0, 0, 3639, 3642, 3645, 3648, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    3651, 3653, 0, 0, 0, 0, 0, 3655, 3657, 3659, 3661, 3663, 3665, 3667,\n+    3669, 3671, 3673, 3676, 3679, 3682, 3685, 3688, 3691, 3694, 3697, 3700,\n+    3703, 3706, 3710, 3714, 3718, 3722, 3726, 3730, 3734, 3738, 3742, 3747,\n+    3752, 3757, 3762, 3767, 3772, 3777, 3782, 3787, 3792, 3797, 3800, 3803,\n+    3806, 3809, 3812, 3815, 3818, 3821, 3824, 3828, 3832, 3836, 3840, 3844,\n+    3848, 3852, 3856, 3860, 3864, 3868, 3872, 3876, 3880, 3884, 3888, 3892,\n+    3896, 3900, 3904, 3908, 3912, 3916, 3920, 3924, 3928, 3932, 3936, 3940,\n+    3944, 3948, 3952, 3956, 3960, 3964, 3968, 3972, 3974, 3976, 3978, 3980,\n+    3982, 3984, 3986, 3988, 3990, 3992, 3994, 3996, 3998, 4000, 4002, 4004,\n+    4006, 4008, 4010, 4012, 4014, 4016, 4018, 4020, 4022, 4024, 4026, 4028,\n+    4030, 4032, 4034, 4036, 4038, 4040, 4042, 4044, 4046, 4048, 4050, 4052,\n+    4054, 4056, 4058, 4060, 4062, 4064, 4066, 4068, 4070, 4072, 4074, 4076,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4078, 0, 0, 0, 0, 0,\n+    0, 0, 4083, 4087, 4090, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 4094, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4097,\n+    4099, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4101, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4103, 0, 0, 0, 4105, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 4107, 4109, 4111, 4113, 4115, 4117, 4119, 4121,\n+    4123, 4125, 4127, 4129, 4131, 4133, 4135, 4137, 4139, 4141, 4143, 4145,\n+    4147, 4149, 4151, 4153, 4155, 4157, 4159, 4161, 4163, 4165, 4167, 4169,\n+    4171, 4173, 4175, 4177, 4179, 4181, 4183, 4185, 4187, 4189, 4191, 4193,\n+    4195, 4197, 4199, 4201, 4203, 4205, 4207, 4209, 4211, 4213, 4215, 4217,\n+    4219, 4221, 4223, 4225, 4227, 4229, 4231, 4233, 4235, 4237, 4239, 4241,\n+    4243, 4245, 4247, 4249, 4251, 4253, 4255, 4257, 4259, 4261, 4263, 4265,\n+    4267, 4269, 4271, 4273, 4275, 4277, 4279, 4281, 4283, 4285, 4287, 4289,\n+    4291, 4293, 4295, 4297, 4299, 4301, 4303, 4305, 4307, 4309, 4311, 4313,\n+    4315, 4317, 4319, 4321, 4323, 4325, 4327, 4329, 4331, 4333, 4335, 4337,\n+    4339, 4341, 4343, 4345, 4347, 4349, 4351, 4353, 4355, 4357, 4359, 4361,\n+    4363, 4365, 4367, 4369, 4371, 4373, 4375, 4377, 4379, 4381, 4383, 4385,\n+    4387, 4389, 4391, 4393, 4395, 4397, 4399, 4401, 4403, 4405, 4407, 4409,\n+    4411, 4413, 4415, 4417, 4419, 4421, 4423, 4425, 4427, 4429, 4431, 4433,\n+    4435, 4437, 4439, 4441, 4443, 4445, 4447, 4449, 4451, 4453, 4455, 4457,\n+    4459, 4461, 4463, 4465, 4467, 4469, 4471, 4473, 4475, 4477, 4479, 4481,\n+    4483, 4485, 4487, 4489, 4491, 4493, 4495, 4497, 4499, 4501, 4503, 4505,\n+    4507, 4509, 4511, 4513, 4515, 4517, 4519, 4521, 4523, 4525, 4527, 4529,\n+    4531, 4533, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4535, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4537, 0, 4539, 4541, 4543, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4545, 0, 4548, 0, 4551, 0,\n+    4554, 0, 4557, 0, 4560, 0, 4563, 0, 4566, 0, 4569, 0, 4572, 0, 4575, 0,\n+    4578, 0, 0, 4581, 0, 4584, 0, 4587, 0, 0, 0, 0, 0, 0, 4590, 4593, 0,\n+    4596, 4599, 0, 4602, 4605, 0, 4608, 4611, 0, 4614, 4617, 0, 0, 0, 0, 0,\n+    0, 4620, 0, 0, 0, 0, 0, 0, 4623, 4626, 0, 4629, 4632, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 4635, 0, 4638, 0, 4641, 0, 4644, 0, 4647, 0, 4650, 0,\n+    4653, 0, 4656, 0, 4659, 0, 4662, 0, 4665, 0, 4668, 0, 0, 4671, 0, 4674,\n+    0, 4677, 0, 0, 0, 0, 0, 0, 4680, 4683, 0, 4686, 4689, 0, 4692, 4695, 0,\n+    4698, 4701, 0, 4704, 4707, 0, 0, 0, 0, 0, 0, 4710, 0, 0, 4713, 4716,\n+    4719, 4722, 0, 0, 0, 4725, 4728, 0, 4731, 4733, 4735, 4737, 4739, 4741,\n+    4743, 4745, 4747, 4749, 4751, 4753, 4755, 4757, 4759, 4761, 4763, 4765,\n+    4767, 4769, 4771, 4773, 4775, 4777, 4779, 4781, 4783, 4785, 4787, 4789,\n+    4791, 4793, 4795, 4797, 4799, 4801, 4803, 4805, 4807, 4809, 4811, 4813,\n+    4815, 4817, 4819, 4821, 4823, 4825, 4827, 4829, 4831, 4833, 4835, 4837,\n+    4839, 4841, 4843, 4845, 4847, 4849, 4851, 4853, 4855, 4857, 4859, 4861,\n+    4863, 4865, 4867, 4869, 4871, 4873, 4875, 4877, 4879, 4881, 4883, 4885,\n+    4887, 4889, 4891, 4893, 4895, 4897, 4899, 4901, 4903, 4905, 4907, 4909,\n+    4911, 4913, 4915, 4917, 0, 0, 0, 4919, 4921, 4923, 4925, 4927, 4929,\n+    4931, 4933, 4935, 4937, 4939, 4941, 4943, 4945, 4947, 4951, 4955, 4959,\n+    4963, 4967, 4971, 4975, 4979, 4983, 4987, 4991, 4995, 4999, 5003, 5008,\n+    5013, 5018, 5023, 5028, 5033, 5038, 5043, 5048, 5053, 5058, 5063, 5068,\n+    5073, 5078, 5086, 0, 5093, 5097, 5101, 5105, 5109, 5113, 5117, 5121,\n+    5125, 5129, 5133, 5137, 5141, 5145, 5149, 5153, 5157, 5161, 5165, 5169,\n+    5173, 5177, 5181, 5185, 5189, 5193, 5197, 5201, 5205, 5209, 5213, 5217,\n+    5221, 5225, 5229, 5233, 5237, 5239, 5241, 5243, 0, 0, 0, 0, 0, 0, 0, 0,\n+    5245, 5249, 5252, 5255, 5258, 5261, 5264, 5267, 5270, 5273, 5276, 5279,\n+    5282, 5285, 5288, 5291, 5294, 5296, 5298, 5300, 5302, 5304, 5306, 5308,\n+    5310, 5312, 5314, 5316, 5318, 5320, 5322, 5325, 5328, 5331, 5334, 5337,\n+    5340, 5343, 5346, 5349, 5352, 5355, 5358, 5361, 5364, 5370, 5375, 0,\n+    5378, 5380, 5382, 5384, 5386, 5388, 5390, 5392, 5394, 5396, 5398, 5400,\n+    5402, 5404, 5406, 5408, 5410, 5412, 5414, 5416, 5418, 5420, 5422, 5424,\n+    5426, 5428, 5430, 5432, 5434, 5436, 5438, 5440, 5442, 5444, 5446, 5448,\n+    5450, 5452, 5454, 5456, 5458, 5460, 5462, 5464, 5466, 5468, 5470, 5472,\n+    5474, 5476, 5479, 5482, 5485, 5488, 5491, 5494, 5497, 5500, 5503, 5506,\n+    5509, 5512, 5515, 5518, 5521, 5524, 5527, 5530, 5533, 5536, 5539, 5542,\n+    5545, 5548, 5552, 5556, 5560, 5563, 5567, 5570, 5574, 5576, 5578, 5580,\n+    5582, 5584, 5586, 5588, 5590, 5592, 5594, 5596, 5598, 5600, 5602, 5604,\n+    5606, 5608, 5610, 5612, 5614, 5616, 5618, 5620, 5622, 5624, 5626, 5628,\n+    5630, 5632, 5634, 5636, 5638, 5640, 5642, 5644, 5646, 5648, 5650, 5652,\n+    5654, 5656, 5658, 5660, 5662, 5664, 5666, 0, 5668, 5673, 5678, 5683,\n+    5687, 5692, 5696, 5700, 5706, 5711, 5715, 5719, 5723, 5728, 5733, 5737,\n+    5741, 5744, 5748, 5753, 5758, 5761, 5767, 5774, 5780, 5784, 5790, 5796,\n+    5801, 5805, 5809, 5813, 5818, 5824, 5829, 5833, 5837, 5841, 5844, 5847,\n+    5850, 5853, 5857, 5861, 5867, 5871, 5876, 5882, 5886, 5889, 5892, 5898,\n+    5903, 5909, 5913, 5919, 5922, 5926, 5930, 5934, 5938, 5942, 5947, 5951,\n+    5954, 5958, 5962, 5966, 5971, 5975, 5979, 5983, 5989, 5994, 5997, 6003,\n+    6006, 6011, 6016, 6020, 6024, 6028, 6033, 6036, 6040, 6045, 6048, 6054,\n+    6058, 6061, 6064, 6067, 6070, 6073, 6076, 6079, 6082, 6085, 6088, 6092,\n+    6096, 6100, 6104, 6108, 6112, 6116, 6120, 6124, 6128, 6132, 6136, 6140,\n+    6144, 6148, 6152, 6155, 6158, 6162, 6165, 6168, 6171, 6175, 6179, 6182,\n+    6185, 6188, 6191, 6194, 6199, 6202, 6205, 6208, 6211, 6214, 6217, 6220,\n+    6223, 6227, 6232, 6235, 6238, 6241, 6244, 6247, 6250, 6253, 6257, 6261,\n+    6265, 6269, 6272, 6275, 6278, 6281, 6284, 6287, 6290, 6293, 6296, 6299,\n+    6303, 6307, 6310, 6314, 6318, 6322, 6325, 6329, 6333, 6338, 6341, 6345,\n+    6349, 6353, 6357, 6363, 6370, 6373, 6376, 6379, 6382, 6385, 6388, 6391,\n+    6394, 6397, 6400, 6403, 6406, 6409, 6412, 6415, 6418, 6421, 6424, 6429,\n+    6432, 6435, 6438, 6443, 6447, 6450, 6453, 6456, 6459, 6462, 6465, 6468,\n+    6471, 6474, 6477, 6481, 6484, 6487, 6491, 6495, 6498, 6503, 6507, 6510,\n+    6513, 6516, 6519, 6523, 6527, 6530, 6533, 6536, 6539, 6542, 6545, 6548,\n+    6551, 6554, 6558, 6562, 6566, 6570, 6574, 6578, 6582, 6586, 6590, 6594,\n+    6598, 6602, 6606, 6610, 6614, 6618, 6622, 6626, 6630, 6634, 6638, 6642,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6646, 6648, 0, 0, 6650, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6652, 6654, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6656, 6658, 6660,\n+    6662, 6664, 6666, 6668, 6670, 6672, 6674, 6676, 6678, 6680, 6682, 6684,\n+    6686, 6688, 6690, 6692, 6694, 6696, 6698, 6700, 6702, 6704, 6706, 6708,\n+    6710, 6712, 6714, 6716, 6718, 6720, 6722, 6724, 6726, 6728, 6730, 6732,\n+    6734, 6736, 6738, 6740, 6742, 6744, 6746, 6748, 6750, 6752, 6754, 6756,\n+    6758, 6760, 6762, 6764, 6766, 6768, 6770, 6772, 6774, 6776, 6778, 6780,\n+    6782, 6784, 6786, 6788, 6790, 6792, 6794, 6796, 6798, 6800, 6802, 6804,\n+    6806, 6808, 6810, 6812, 6814, 6816, 6818, 6820, 6822, 6824, 6826, 6828,\n+    6830, 6832, 6834, 6836, 6838, 6840, 6842, 6844, 6846, 6848, 6850, 6852,\n+    6854, 6856, 6858, 6860, 6862, 6864, 6866, 6868, 6870, 6872, 6874, 6876,\n+    6878, 6880, 6882, 6884, 6886, 6888, 6890, 6892, 6894, 6896, 6898, 6900,\n+    6902, 6904, 6906, 6908, 6910, 6912, 6914, 6916, 6918, 6920, 6922, 6924,\n+    6926, 6928, 6930, 6932, 6934, 6936, 6938, 6940, 6942, 6944, 6946, 6948,\n+    6950, 6952, 6954, 6956, 6958, 6960, 6962, 6964, 6966, 6968, 6970, 6972,\n+    6974, 6976, 6978, 6980, 6982, 6984, 6986, 6988, 6990, 6992, 6994, 6996,\n+    6998, 7000, 7002, 7004, 7006, 7008, 7010, 7012, 7014, 7016, 7018, 7020,\n+    7022, 7024, 7026, 7028, 7030, 7032, 7034, 7036, 7038, 7040, 7042, 7044,\n+    7046, 7048, 7050, 7052, 7054, 7056, 7058, 7060, 7062, 7064, 7066, 7068,\n+    7070, 7072, 7074, 7076, 7078, 7080, 7082, 7084, 7086, 7088, 7090, 7092,\n+    7094, 7096, 7098, 7100, 7102, 7104, 7106, 7108, 7110, 7112, 7114, 7116,\n+    7118, 7120, 7122, 7124, 7126, 7128, 7130, 7132, 7134, 7136, 7138, 7140,\n+    7142, 7144, 7146, 7148, 7150, 7152, 7154, 7156, 7158, 7160, 7162, 7164,\n+    7166, 7168, 7170, 7172, 7174, 7176, 7178, 7180, 7182, 7184, 7186, 7188,\n+    7190, 7192, 7194, 7196, 7198, 7200, 7202, 0, 0, 7204, 0, 7206, 0, 0,\n+    7208, 7210, 7212, 7214, 7216, 7218, 7220, 7222, 7224, 7226, 0, 7228, 0,\n+    7230, 0, 0, 7232, 7234, 0, 0, 0, 7236, 7238, 7240, 7242, 7244, 7246,\n+    7248, 7250, 7252, 7254, 7256, 7258, 7260, 7262, 7264, 7266, 7268, 7270,\n+    7272, 7274, 7276, 7278, 7280, 7282, 7284, 7286, 7288, 7290, 7292, 7294,\n+    7296, 7298, 7300, 7302, 7304, 7306, 7308, 7310, 7312, 7314, 7316, 7318,\n+    7320, 7322, 7324, 7326, 7328, 7330, 7332, 7334, 7336, 7338, 7340, 7342,\n+    7344, 7346, 7348, 7350, 7352, 7354, 7356, 7358, 7360, 7362, 7364, 7366,\n+    7368, 7371, 0, 0, 7373, 7375, 7377, 7379, 7381, 7383, 7385, 7387, 7389,\n+    7391, 7393, 7395, 7397, 7399, 7401, 7403, 7405, 7407, 7409, 7411, 7413,\n+    7415, 7417, 7419, 7421, 7423, 7425, 7427, 7429, 7431, 7433, 7435, 7437,\n+    7439, 7441, 7443, 7445, 7447, 7449, 7451, 7453, 7455, 7457, 7459, 7461,\n+    7463, 7465, 7467, 7469, 7471, 7473, 7475, 7477, 7479, 7481, 7483, 7485,\n+    7487, 7489, 7491, 7493, 7495, 7497, 7499, 7501, 7503, 7505, 7507, 7509,\n+    7511, 7513, 7515, 7517, 7519, 7521, 7523, 7525, 7527, 7529, 7531, 7533,\n+    7535, 7537, 7539, 7541, 7543, 7545, 7547, 7549, 7551, 7553, 7555, 7557,\n+    7559, 7561, 7563, 7566, 7569, 7572, 7574, 7576, 7578, 7581, 7584, 7587,\n+    7589, 0, 0, 0, 0, 0, 0, 7591, 7594, 7597, 7600, 7604, 7608, 7611, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7614, 7617, 7620, 7623, 7626, 0, 0, 0, 0,\n+    0, 7629, 0, 7632, 7635, 7637, 7639, 7641, 7643, 7645, 7647, 7649, 7651,\n+    7653, 7655, 7658, 7661, 7664, 7667, 7670, 7673, 7676, 7679, 7682, 7685,\n+    7688, 7691, 0, 7694, 7697, 7700, 7703, 7706, 0, 7709, 0, 7712, 7715, 0,\n+    7718, 7721, 0, 7724, 7727, 7730, 7733, 7736, 7739, 7742, 7745, 7748,\n+    7751, 7754, 7756, 7758, 7760, 7762, 7764, 7766, 7768, 7770, 7772, 7774,\n+    7776, 7778, 7780, 7782, 7784, 7786, 7788, 7790, 7792, 7794, 7796, 7798,\n+    7800, 7802, 7804, 7806, 7808, 7810, 7812, 7814, 7816, 7818, 7820, 7822,\n+    7824, 7826, 7828, 7830, 7832, 7834, 7836, 7838, 7840, 7842, 7844, 7846,\n+    7848, 7850, 7852, 7854, 7856, 7858, 7860, 7862, 7864, 7866, 7868, 7870,\n+    7872, 7874, 7876, 7878, 7880, 7882, 7884, 7886, 7888, 7890, 7892, 7894,\n+    7896, 7898, 7900, 7902, 7904, 7906, 7908, 7910, 7912, 7914, 7916, 7918,\n+    7920, 7922, 7924, 7926, 7928, 7930, 7932, 7934, 7936, 7938, 7940, 7942,\n+    7944, 7946, 7948, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    7950, 7952, 7954, 7956, 7958, 7960, 7962, 7964, 7966, 7968, 7970, 7972,\n+    7974, 7976, 7978, 7980, 7982, 7984, 7986, 7988, 7990, 7992, 7994, 7996,\n+    7999, 8002, 8005, 8008, 8011, 8014, 8017, 8020, 8023, 8026, 8029, 8032,\n+    8035, 8038, 8041, 8044, 8047, 8050, 8052, 8054, 8056, 8058, 8061, 8064,\n+    8067, 8070, 8073, 8076, 8079, 8082, 8085, 8088, 8091, 8094, 8097, 8100,\n+    8103, 8106, 8109, 8112, 8115, 8118, 8121, 8124, 8127, 8130, 8133, 8136,\n+    8139, 8142, 8145, 8148, 8151, 8154, 8157, 8160, 8163, 8166, 8169, 8172,\n+    8175, 8178, 8181, 8184, 8187, 8190, 8193, 8196, 8199, 8202, 8205, 8208,\n+    8211, 8214, 8217, 8220, 8223, 8226, 8229, 8232, 8235, 8238, 8241, 8244,\n+    8247, 8250, 8253, 8256, 8259, 8262, 8265, 8268, 8271, 8274, 8277, 8280,\n+    8283, 8286, 8289, 8292, 8295, 8298, 8301, 8304, 8307, 8310, 8313, 8316,\n+    8319, 8322, 8325, 8328, 8331, 8334, 8337, 8340, 8344, 8348, 8352, 8356,\n+    8360, 8364, 8367, 8370, 8373, 8376, 8379, 8382, 8385, 8388, 8391, 8394,\n+    8397, 8400, 8403, 8406, 8409, 8412, 8415, 8418, 8421, 8424, 8427, 8430,\n+    8433, 8436, 8439, 8442, 8445, 8448, 8451, 8454, 8457, 8460, 8463, 8466,\n+    8469, 8472, 8475, 8478, 8481, 8484, 8487, 8490, 8493, 8496, 8499, 8502,\n+    8505, 8508, 8511, 8514, 8517, 8520, 8523, 8526, 8529, 8532, 8535, 8538,\n+    8541, 8544, 8547, 8550, 8553, 8556, 8559, 8562, 8565, 8568, 8571, 8574,\n+    8577, 8580, 8583, 8586, 8589, 8592, 8595, 8598, 8601, 8604, 8607, 8610,\n+    8613, 8616, 8619, 8622, 8625, 8628, 8631, 8634, 8637, 8640, 8643, 8646,\n+    8649, 8652, 8655, 8658, 8661, 8664, 8667, 8670, 8673, 8676, 8679, 8682,\n+    8685, 8688, 8691, 8694, 8697, 8700, 8703, 8706, 8709, 8712, 8715, 8718,\n+    8721, 8724, 8727, 8730, 8733, 8736, 8739, 8742, 8745, 8748, 8751, 8754,\n+    8757, 8760, 8763, 8766, 8769, 8772, 8775, 8778, 8781, 8784, 8787, 8790,\n+    8794, 8798, 8802, 8805, 8808, 8811, 8814, 8817, 8820, 8823, 8826, 8829,\n+    8832, 8835, 8838, 8841, 8844, 8847, 8850, 8853, 8856, 8859, 8862, 8865,\n+    8868, 8871, 8874, 8877, 8880, 8883, 8886, 8889, 8892, 8895, 8898, 8901,\n+    8904, 8907, 8910, 8913, 8916, 8919, 8922, 8925, 8928, 8931, 8934, 8937,\n+    8940, 8943, 8946, 8949, 8952, 8955, 8958, 8961, 8964, 8967, 8970, 8973,\n+    8976, 8979, 8982, 8985, 8988, 8991, 8994, 8997, 9000, 9003, 9006, 9009,\n+    9012, 9015, 9018, 0, 0, 9021, 9025, 9029, 9033, 9037, 9041, 9045, 9049,\n+    9053, 9057, 9061, 9065, 9069, 9073, 9077, 9081, 9085, 9089, 9093, 9097,\n+    9101, 9105, 9109, 9113, 9117, 9121, 9125, 9129, 9133, 9137, 9141, 9145,\n+    9149, 9153, 9157, 9161, 9165, 9169, 9173, 9177, 9181, 9185, 9189, 9193,\n+    9197, 9201, 9205, 9209, 9213, 9217, 9221, 9225, 9229, 9233, 9237, 9241,\n+    9245, 9249, 9253, 9257, 9261, 9265, 9269, 9273, 0, 0, 9277, 9281, 9285,\n+    9289, 9293, 9297, 9301, 9305, 9309, 9313, 9317, 9321, 9325, 9329, 9333,\n+    9337, 9341, 9345, 9349, 9353, 9357, 9361, 9365, 9369, 9373, 9377, 9381,\n+    9385, 9389, 9393, 9397, 9401, 9405, 9409, 9413, 9417, 9421, 9425, 9429,\n+    9433, 9437, 9441, 9445, 9449, 9453, 9457, 9461, 9465, 9469, 9473, 9477,\n+    9481, 9485, 9489, 0, 0, 0, 0, 0, 0, 0, 0, 9493, 9497, 9501, 9506, 9511,\n+    9516, 9521, 9526, 9531, 9536, 9540, 9559, 9568, 0, 0, 0, 9573, 9575,\n+    9577, 9579, 9581, 9583, 9585, 9587, 9589, 9591, 0, 0, 0, 0, 0, 0, 9593,\n+    9595, 9597, 9599, 9601, 9603, 9605, 9607, 9609, 9611, 9613, 9615, 9617,\n+    9619, 9621, 9623, 9625, 9627, 9629, 9631, 9633, 0, 0, 9635, 9637, 9639,\n+    9641, 9643, 9645, 9647, 9649, 9651, 9653, 9655, 9657, 0, 9659, 9661,\n+    9663, 9665, 9667, 9669, 9671, 9673, 9675, 9677, 9679, 9681, 9683, 9685,\n+    9687, 9689, 9691, 9693, 9695, 0, 9697, 9699, 9701, 9703, 0, 0, 0, 0,\n+    9705, 9708, 9711, 0, 9714, 0, 9717, 9720, 9723, 9726, 9729, 9732, 9735,\n+    9738, 9741, 9744, 9747, 9749, 9751, 9753, 9755, 9757, 9759, 9761, 9763,\n+    9765, 9767, 9769, 9771, 9773, 9775, 9777, 9779, 9781, 9783, 9785, 9787,\n+    9789, 9791, 9793, 9795, 9797, 9799, 9801, 9803, 9805, 9807, 9809, 9811,\n+    9813, 9815, 9817, 9819, 9821, 9823, 9825, 9827, 9829, 9831, 9833, 9835,\n+    9837, 9839, 9841, 9843, 9845, 9847, 9849, 9851, 9853, 9855, 9857, 9859,\n+    9861, 9863, 9865, 9867, 9869, 9871, 9873, 9875, 9877, 9879, 9881, 9883,\n+    9885, 9887, 9889, 9891, 9893, 9895, 9897, 9899, 9901, 9903, 9905, 9907,\n+    9909, 9911, 9913, 9915, 9917, 9919, 9921, 9923, 9925, 9927, 9929, 9931,\n+    9933, 9935, 9937, 9939, 9941, 9943, 9945, 9947, 9949, 9951, 9953, 9955,\n+    9957, 9959, 9961, 9963, 9965, 9967, 9969, 9971, 9973, 9975, 9977, 9979,\n+    9981, 9984, 9987, 9990, 9993, 9996, 9999, 10002, 0, 0, 0, 0, 10005,\n+    10007, 10009, 10011, 10013, 10015, 10017, 10019, 10021, 10023, 10025,\n+    10027, 10029, 10031, 10033, 10035, 10037, 10039, 10041, 10043, 10045,\n+    10047, 10049, 10051, 10053, 10055, 10057, 10059, 10061, 10063, 10065,\n+    10067, 10069, 10071, 10073, 10075, 10077, 10079, 10081, 10083, 10085,\n+    10087, 10089, 10091, 10093, 10095, 10097, 10099, 10101, 10103, 10105,\n+    10107, 10109, 10111, 10113, 10115, 10117, 10119, 10121, 10123, 10125,\n+    10127, 10129, 10131, 10133, 10135, 10137, 10139, 10141, 10143, 10145,\n+    10147, 10149, 10151, 10153, 10155, 10157, 10159, 10161, 10163, 10165,\n+    10167, 10169, 10171, 10173, 10175, 10177, 10179, 10181, 10183, 10185,\n+    10187, 10189, 10191, 10193, 10195, 10197, 10199, 10201, 10203, 10205,\n+    10207, 10209, 10211, 10213, 10215, 10217, 10219, 10221, 10223, 10225,\n+    10227, 10229, 10231, 10233, 10235, 10237, 10239, 10241, 10243, 10245,\n+    10247, 10249, 10251, 10253, 10255, 10257, 10259, 10261, 10263, 10265,\n+    10267, 10269, 10271, 10273, 10275, 10277, 10279, 10281, 10283, 10285,\n+    10287, 10289, 10291, 10293, 10295, 10297, 10299, 10301, 10303, 10305,\n+    10307, 10309, 10311, 10313, 10315, 10317, 10319, 10321, 10323, 10325,\n+    10327, 10329, 10331, 10333, 10335, 10337, 10339, 10341, 10343, 10345,\n+    10347, 10349, 10351, 10353, 10355, 10357, 10359, 10361, 10363, 10365,\n+    10367, 10369, 10371, 10373, 10375, 10377, 10379, 10381, 10383, 0, 0, 0,\n+    10385, 10387, 10389, 10391, 10393, 10395, 0, 0, 10397, 10399, 10401,\n+    10403, 10405, 10407, 0, 0, 10409, 10411, 10413, 10415, 10417, 10419, 0,\n+    0, 10421, 10423, 10425, 0, 0, 0, 10427, 10429, 10431, 10433, 10435,\n+    10437, 10439, 0, 10441, 10443, 10445, 10447, 10449, 10451, 10453, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 10455, 0, 10460, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 10465, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    10470, 10475, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10480, 10485, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10490, 10495, 0, 10500, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 10505, 10510, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 0, 0, 10515, 10520, 10525, 10530, 10535, 10540, 10545, 0, 0, 0, 0, 0,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10550, 10555, 10560,\n+    10565, 10570, 10575, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 10580,\n+    10582, 10584, 10586, 10588, 10590, 10592, 10594, 10596, 10598, 10600,\n+    10602, 10604, 10606, 10608, 10610, 10612, 10614, 10616, 10618, 10620,\n+    10622, 10624, 10626, 10628, 10630, 10632, 10634, 10636, 10638, 10640,\n+    10642, 10644, 10646, 10648, 10650, 10652, 10654, 10656, 10658, 10660,\n+    10662, 10664, 10666, 10668, 10670, 10672, 10674, 10676, 10678, 10680,\n+    10682, 10684, 10686, 10688, 10690, 10692, 10694, 10696, 10698, 10700,\n+    10702, 10704, 10706, 10708, 10710, 10712, 10714, 10716, 10718, 10720,\n+    10722, 10724, 10726, 10728, 10730, 10732, 10734, 10736, 10738, 10740,\n+    10742, 10744, 10746, 10748, 0, 10750, 10752, 10754, 10756, 10758, 10760,\n+    10762, 10764, 10766, 10768, 10770, 10772, 10774, 10776, 10778, 10780,\n+    10782, 10784, 10786, 10788, 10790, 10792, 10794, 10796, 10798, 10800,\n+    10802, 10804, 10806, 10808, 10810, 10812, 10814, 10816, 10818, 10820,\n+    10822, 10824, 10826, 10828, 10830, 10832, 10834, 10836, 10838, 10840,\n+    10842, 10844, 10846, 10848, 10850, 10852, 10854, 10856, 10858, 10860,\n+    10862, 10864, 10866, 10868, 10870, 10872, 10874, 10876, 10878, 10880,\n+    10882, 10884, 10886, 10888, 10890, 0, 10892, 10894, 0, 0, 10896, 0, 0,\n+    10898, 10900, 0, 0, 10902, 10904, 10906, 10908, 0, 10910, 10912, 10914,\n+    10916, 10918, 10920, 10922, 10924, 10926, 10928, 10930, 10932, 0, 10934,\n+    0, 10936, 10938, 10940, 10942, 10944, 10946, 10948, 0, 10950, 10952,\n+    10954, 10956, 10958, 10960, 10962, 10964, 10966, 10968, 10970, 10972,\n+    10974, 10976, 10978, 10980, 10982, 10984, 10986, 10988, 10990, 10992,\n+    10994, 10996, 10998, 11000, 11002, 11004, 11006, 11008, 11010, 11012,\n+    11014, 11016, 11018, 11020, 11022, 11024, 11026, 11028, 11030, 11032,\n+    11034, 11036, 11038, 11040, 11042, 11044, 11046, 11048, 11050, 11052,\n+    11054, 11056, 11058, 11060, 11062, 11064, 11066, 11068, 11070, 11072,\n+    11074, 11076, 11078, 0, 11080, 11082, 11084, 11086, 0, 0, 11088, 11090,\n+    11092, 11094, 11096, 11098, 11100, 11102, 0, 11104, 11106, 11108, 11110,\n+    11112, 11114, 11116, 0, 11118, 11120, 11122, 11124, 11126, 11128, 11130,\n+    11132, 11134, 11136, 11138, 11140, 11142, 11144, 11146, 11148, 11150,\n+    11152, 11154, 11156, 11158, 11160, 11162, 11164, 11166, 11168, 11170,\n+    11172, 0, 11174, 11176, 11178, 11180, 0, 11182, 11184, 11186, 11188,\n+    11190, 0, 11192, 0, 0, 0, 11194, 11196, 11198, 11200, 11202, 11204,\n+    11206, 0, 11208, 11210, 11212, 11214, 11216, 11218, 11220, 11222, 11224,\n+    11226, 11228, 11230, 11232, 11234, 11236, 11238, 11240, 11242, 11244,\n+    11246, 11248, 11250, 11252, 11254, 11256, 11258, 11260, 11262, 11264,\n+    11266, 11268, 11270, 11272, 11274, 11276, 11278, 11280, 11282, 11284,\n+    11286, 11288, 11290, 11292, 11294, 11296, 11298, 11300, 11302, 11304,\n+    11306, 11308, 11310, 11312, 11314, 11316, 11318, 11320, 11322, 11324,\n+    11326, 11328, 11330, 11332, 11334, 11336, 11338, 11340, 11342, 11344,\n+    11346, 11348, 11350, 11352, 11354, 11356, 11358, 11360, 11362, 11364,\n+    11366, 11368, 11370, 11372, 11374, 11376, 11378, 11380, 11382, 11384,\n+    11386, 11388, 11390, 11392, 11394, 11396, 11398, 11400, 11402, 11404,\n+    11406, 11408, 11410, 11412, 11414, 11416, 11418, 11420, 11422, 11424,\n+    11426, 11428, 11430, 11432, 11434, 11436, 11438, 11440, 11442, 11444,\n+    11446, 11448, 11450, 11452, 11454, 11456, 11458, 11460, 11462, 11464,\n+    11466, 11468, 11470, 11472, 11474, 11476, 11478, 11480, 11482, 11484,\n+    11486, 11488, 11490, 11492, 11494, 11496, 11498, 11500, 11502, 11504,\n+    11506, 11508, 11510, 11512, 11514, 11516, 11518, 11520, 11522, 11524,\n+    11526, 11528, 11530, 11532, 11534, 11536, 11538, 11540, 11542, 11544,\n+    11546, 11548, 11550, 11552, 11554, 11556, 11558, 11560, 11562, 11564,\n+    11566, 11568, 11570, 11572, 11574, 11576, 11578, 11580, 11582, 11584,\n+    11586, 11588, 11590, 11592, 11594, 11596, 11598, 11600, 11602, 11604,\n+    11606, 11608, 11610, 11612, 11614, 11616, 11618, 11620, 11622, 11624,\n+    11626, 11628, 11630, 11632, 11634, 11636, 11638, 11640, 11642, 11644,\n+    11646, 11648, 11650, 11652, 11654, 11656, 11658, 11660, 11662, 11664,\n+    11666, 11668, 11670, 11672, 11674, 11676, 11678, 11680, 11682, 11684,\n+    11686, 11688, 11690, 11692, 11694, 11696, 11698, 11700, 11702, 11704,\n+    11706, 11708, 11710, 11712, 11714, 11716, 11718, 11720, 11722, 11724,\n+    11726, 11728, 11730, 11732, 11734, 11736, 11738, 11740, 11742, 11744,\n+    11746, 11748, 11750, 11752, 11754, 11756, 11758, 11760, 11762, 11764,\n+    11766, 11768, 11770, 11772, 11774, 11776, 11778, 11780, 11782, 11784,\n+    11786, 11788, 11790, 11792, 11794, 11796, 11798, 11800, 11802, 11804,\n+    11806, 11808, 11810, 11812, 11814, 11816, 11818, 11820, 11822, 11824,\n+    11826, 11828, 11830, 11832, 11834, 11836, 11838, 11840, 11842, 11844,\n+    11846, 11848, 11850, 11852, 11854, 11856, 11858, 11860, 11862, 11864,\n+    11866, 11868, 11870, 11872, 11874, 11876, 11878, 11880, 11882, 11884,\n+    11886, 0, 0, 11888, 11890, 11892, 11894, 11896, 11898, 11900, 11902,\n+    11904, 11906, 11908, 11910, 11912, 11914, 11916, 11918, 11920, 11922,\n+    11924, 11926, 11928, 11930, 11932, 11934, 11936, 11938, 11940, 11942,\n+    11944, 11946, 11948, 11950, 11952, 11954, 11956, 11958, 11960, 11962,\n+    11964, 11966, 11968, 11970, 11972, 11974, 11976, 11978, 11980, 11982,\n+    11984, 11986, 11988, 11990, 11992, 11994, 11996, 11998, 12000, 12002,\n+    12004, 12006, 12008, 12010, 12012, 12014, 12016, 12018, 12020, 12022,\n+    12024, 12026, 12028, 12030, 12032, 12034, 12036, 12038, 12040, 12042,\n+    12044, 12046, 12048, 12050, 12052, 12054, 12056, 12058, 12060, 12062,\n+    12064, 12066, 12068, 12070, 12072, 12074, 12076, 12078, 12080, 12082,\n+    12084, 12086, 12088, 12090, 12092, 12094, 12096, 12098, 12100, 12102,\n+    12104, 12106, 12108, 12110, 12112, 12114, 12116, 12118, 12120, 12122,\n+    12124, 12126, 12128, 12130, 12132, 12134, 12136, 12138, 12140, 12142,\n+    12144, 12146, 12148, 12150, 12152, 12154, 12156, 12158, 12160, 12162,\n+    12164, 12166, 12168, 12170, 12172, 12174, 12176, 12178, 12180, 12182,\n+    12184, 12186, 12188, 12190, 12192, 12194, 12196, 12198, 12200, 12202,\n+    12204, 12206, 12208, 12210, 12212, 12214, 12216, 12218, 12220, 12222,\n+    12224, 12226, 12228, 12230, 12232, 12234, 12236, 12238, 12240, 12242,\n+    12244, 12246, 12248, 12250, 12252, 12254, 12256, 12258, 12260, 12262,\n+    12264, 12266, 12268, 12270, 12272, 12274, 12276, 12278, 12280, 12282,\n+    12284, 12286, 12288, 12290, 12292, 12294, 12296, 12298, 12300, 12302,\n+    12304, 12306, 12308, 12310, 12312, 12314, 12316, 12318, 12320, 12322,\n+    12324, 12326, 12328, 12330, 12332, 12334, 12336, 12338, 12340, 12342,\n+    12344, 12346, 12348, 12350, 12352, 12354, 12356, 12358, 12360, 12362,\n+    12364, 12366, 12368, 12370, 12372, 12374, 12376, 12378, 12380, 12382,\n+    12384, 12386, 12388, 12390, 12392, 12394, 12396, 12398, 12400, 12402,\n+    12404, 12406, 12408, 12410, 12412, 12414, 12416, 12418, 12420, 12422,\n+    12424, 12426, 12428, 12430, 12432, 12434, 12436, 12438, 12440, 12442,\n+    12444, 12446, 12448, 12450, 12452, 12454, 12456, 12458, 12460, 12462,\n+    12464, 12466, 12468, 12470, 0, 0, 12472, 12474, 12476, 12478, 12480,\n+    12482, 12484, 12486, 12488, 12490, 12492, 12494, 12496, 12498, 12500,\n+    12502, 12504, 12506, 12508, 12510, 12512, 12514, 12516, 12518, 12520,\n+    12522, 12524, 12526, 12528, 12530, 12532, 12534, 12536, 12538, 12540,\n+    12542, 12544, 12546, 12548, 12550, 12552, 12554, 12556, 12558, 12560,\n+    12562, 12564, 12566, 12568, 12570, 12572, 12574, 12576, 12578, 0, 12580,\n+    12582, 12584, 12586, 12588, 12590, 12592, 12594, 12596, 12598, 12600,\n+    12602, 12604, 12606, 12608, 12610, 12612, 12614, 12616, 12618, 12620,\n+    12622, 12624, 12626, 12628, 12630, 12632, 0, 12634, 12636, 0, 12638, 0,\n+    0, 12640, 0, 12642, 12644, 12646, 12648, 12650, 12652, 12654, 12656,\n+    12658, 12660, 0, 12662, 12664, 12666, 12668, 0, 12670, 0, 12672, 0, 0, 0,\n+    0, 0, 0, 12674, 0, 0, 0, 0, 12676, 0, 12678, 0, 12680, 0, 12682, 12684,\n+    12686, 0, 12688, 12690, 0, 12692, 0, 0, 12694, 0, 12696, 0, 12698, 0,\n+    12700, 0, 12702, 0, 12704, 12706, 0, 12708, 0, 0, 12710, 12712, 12714,\n+    12716, 0, 12718, 12720, 12722, 12724, 12726, 12728, 12730, 0, 12732,\n+    12734, 12736, 12738, 0, 12740, 12742, 12744, 12746, 0, 12748, 0, 12750,\n+    12752, 12754, 12756, 12758, 12760, 12762, 12764, 12766, 12768, 0, 12770,\n+    12772, 12774, 12776, 12778, 12780, 12782, 12784, 12786, 12788, 12790,\n+    12792, 12794, 12796, 12798, 12800, 12802, 0, 0, 0, 0, 0, 12804, 12806,\n+    12808, 0, 12810, 12812, 12814, 12816, 12818, 0, 12820, 12822, 12824,\n+    12826, 12828, 12830, 12832, 12834, 12836, 12838, 12840, 12842, 12844,\n+    12846, 12848, 12850, 12852, 0, 0, 0, 0, 12854, 12857, 12860, 12863,\n+    12866, 12869, 12872, 12875, 12878, 12881, 12884, 0, 0, 0, 0, 0, 12887,\n+    12891, 12895, 12899, 12903, 12907, 12911, 12915, 12919, 12923, 12927,\n+    12931, 12935, 12939, 12943, 12947, 12951, 12955, 12959, 12963, 12967,\n+    12971, 12975, 12979, 12983, 12987, 12991, 12995, 12997, 12999, 13002, 0,\n+    13005, 13007, 13009, 13011, 13013, 13015, 13017, 13019, 13021, 13023,\n+    13025, 13027, 13029, 13031, 13033, 13035, 13037, 13039, 13041, 13043,\n+    13045, 13047, 13049, 13051, 13053, 13055, 13057, 13060, 13063, 13066,\n+    13069, 13073, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13076, 13079, 0, 0, 0, 0,\n+    13082, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13085, 13088, 13091,\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 13093, 13095, 13097, 13099, 13101,\n+    13103, 13105, 13107, 13109, 13111, 13113, 13115, 13117, 13119, 13121,\n+    13123, 13125, 13127, 13129, 13131, 13133, 13135, 13137, 13139, 13141,\n+    13143, 13145, 13147, 13149, 13151, 13153, 13155, 13157, 13159, 13161,\n+    13163, 13165, 13167, 13169, 13171, 13173, 13175, 13177, 13179, 0, 0, 0,\n+    0, 13181, 13185, 13189, 13193, 13197, 13201, 13205, 13209, 13213, 0, 0,\n+    0, 0, 0, 0, 0, 13217, 13219, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    13221, 13223, 13225, 13227, 13230, 13232, 13234, 13236, 13238, 13240,\n+    13242, 13244, 13246, 13248, 13251, 13253, 13255, 13257, 13259, 13262,\n+    13264, 13266, 13268, 13271, 13273, 13275, 13277, 13279, 13281, 13284,\n+    13286, 13288, 13290, 13292, 13294, 13296, 13298, 13300, 13302, 13304,\n+    13306, 13308, 13310, 13312, 13314, 13316, 13318, 13320, 13322, 13324,\n+    13326, 13328, 13330, 13333, 13335, 13337, 13339, 13342, 13344, 13346,\n+    13348, 13350, 13352, 13354, 13356, 13358, 13360, 13362, 13364, 13366,\n+    13368, 13370, 13372, 13374, 13376, 13378, 13380, 13382, 13384, 13386,\n+    13388, 13390, 13392, 13394, 13396, 13398, 13400, 13402, 13404, 13406,\n+    13409, 13411, 13413, 13415, 13417, 13419, 13421, 13424, 13427, 13429,\n+    13431, 13433, 13435, 13437, 13439, 13441, 13443, 13445, 13447, 13450,\n+    13452, 13454, 13456, 13458, 13461, 13463, 13465, 13467, 13469, 13471,\n+    13473, 13475, 13477, 13479, 13482, 13484, 13487, 13489, 13491, 13493,\n+    13495, 13497, 13499, 13501, 13503, 13505, 13507, 13509, 13512, 13514,\n+    13516, 13518, 13520, 13522, 13525, 13527, 13530, 13533, 13535, 13537,\n+    13539, 13541, 13544, 13547, 13549, 13551, 13553, 13555, 13557, 13559,\n+    13561, 13563, 13565, 13567, 13569, 13572, 13574, 13576, 13578, 13580,\n+    13582, 13584, 13586, 13588, 13590, 13592, 13594, 13596, 13598, 13600,\n+    13602, 13604, 13606, 13608, 13610, 13613, 13615, 13617, 13619, 13621,\n+    13623, 13626, 13628, 13630, 13632, 13634, 13636, 13638, 13640, 13642,\n+    13644, 13646, 13648, 13651, 13653, 13655, 13657, 13659, 13661, 13663,\n+    13665, 13667, 13669, 13671, 13673, 13675, 13677, 13679, 13681, 13683,\n+    13685, 13687, 13690, 13692, 13694, 13696, 13698, 13700, 13703, 13705,\n+    13707, 13709, 13711, 13713, 13715, 13717, 13719, 13722, 13724, 13726,\n+    13728, 13731, 13733, 13735, 13737, 13739, 13741, 13743, 13746, 13749,\n+    13752, 13754, 13757, 13759, 13761, 13763, 13765, 13767, 13769, 13771,\n+    13773, 13775, 13777, 13780, 13782, 13784, 13786, 13788, 13790, 13792,\n+    13795, 13797, 13799, 13802, 13805, 13807, 13809, 13811, 13813, 13815,\n+    13817, 13819, 13821, 13823, 13826, 13828, 13831, 13833, 13836, 13838,\n+    13840, 13842, 13845, 13847, 13849, 13852, 13855, 13857, 13859, 13861,\n+    13863, 13865, 13867, 13869, 13871, 13873, 13875, 13877, 13879, 13881,\n+    13884, 13886, 13889, 13891, 13894, 13896, 13899, 13902, 13905, 13907,\n+    13909, 13911, 13914, 13917, 13920, 13923, 13925, 13927, 13929, 13931,\n+    13933, 13935, 13937, 13939, 13942, 13944, 13946, 13948, 13950, 13953,\n+    13955, 13958, 13961, 13963, 13965, 13967, 13969, 13971, 13973, 13976,\n+    13979, 13982, 13984, 13986, 13989, 13991, 13993, 13995, 13998, 14000,\n+    14002, 14004, 14006, 14008, 14011, 14013, 14015, 14017, 14019, 14021,\n+    14023, 14026, 14029, 14031, 14034, 14036, 14039, 14041, 14043, 14045,\n+    14048, 14051, 14053, 14056, 14058, 14061, 14063, 14065, 14067, 14069,\n+    14071, 14073, 14076, 14079, 14082, 14085, 14087, 14089, 14091, 14093,\n+    14095, 14097, 14099, 14101, 14103, 14105, 14107, 14109, 14112, 14114,\n+    14116, 14118, 14120, 14122, 14124, 14126, 14128, 14130, 14132, 14134,\n+    14136, 14139, 14142, 14145, 14147, 14149, 14151, 14153, 14156, 14158,\n+    14161, 14163, 14165, 14168, 14171, 14173, 14175, 14177, 14179, 14181,\n+    14183, 14185, 14187, 14189, 14191, 14193, 14195, 14197, 14199, 14201,\n+    14203, 14205, 14207, 14209, 14212, 14214, 14216, 14218, 14220, 14222,\n+    14225, 14228, 14230, 14232, 14234, 14236, 14238, 14240, 14243, 14245,\n+    14247, 14249, 14251, 14254, 14257, 14259, 14261, 14263, 14266, 14268,\n+    14270, 14273, 14276, 14278, 14280, 14282, 14285, 14287, 14289, 14291,\n+    14293, 14295, 14297, 14299, 14302, 14304, 14306, 14308, 14311, 14313,\n+    14315, 14317, 14319, 14322, 14325, 14327, 14329, 14331, 14334, 14336,\n+    14339, 14341, 14343, 14345, 14348, 14350, 14352, 14354, 14356, 14358,\n+    14360, 14362, 14365, 14367, 14369, 14371, 14373, 14375, 14377, 14380,\n+    14382, 14385, 14388, 14391, 14393, 14395, 14397, 14399, 14401, 14403,\n+    14405, 14407, 0, 0,\n+};\n+\n+\/* NFC pairs *\/\n+#define COMP_SHIFT1 2\n+#define COMP_SHIFT2 1\n+static const unsigned short comp_index0[] = {\n+    0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 4,\n+    5, 6, 7, 0, 0, 0, 0, 8, 0, 9, 10, 0, 0, 0, 11, 12, 13, 14, 0, 0, 0, 0, 0,\n+    15, 16, 17, 0, 0, 0, 0, 18, 19, 20, 21, 0, 0, 0, 0, 22, 0, 0, 0, 0, 0, 0,\n+    23, 24, 25, 26, 0, 0, 0, 0, 27, 28, 29, 30, 0, 0, 0, 0, 31, 32, 33, 34,\n+    0, 0, 0, 0, 35, 0, 0, 0, 0, 0, 0, 36, 0, 37, 38, 39, 0, 0, 0, 40, 41, 42,\n+    43, 0, 0, 0, 0, 44, 45, 46, 0, 0, 0, 0, 0, 47, 48, 49, 50, 0, 0, 0, 51,\n+    52, 53, 54, 0, 0, 0, 0, 55, 56, 0, 0, 0, 0, 0, 0, 57, 58, 59, 60, 0, 0,\n+    0, 0, 61, 62, 63, 0, 0, 0, 0, 0, 64, 65, 66, 67, 0, 0, 0, 68, 69, 70, 71,\n+    0, 0, 0, 0, 72, 0, 73, 0, 0, 0, 0, 0, 74, 0, 75, 0, 0, 0, 0, 0, 76, 0, 0,\n+    0, 0, 0, 0, 77, 78, 79, 0, 0, 0, 0, 0, 80, 81, 82, 83, 0, 0, 0, 0, 84,\n+    85, 86, 0, 0, 0, 0, 0, 87, 88, 0, 89, 0, 0, 0, 90, 91, 0, 92, 0, 0, 0, 0,\n+    0, 93, 94, 95, 0, 0, 0, 0, 96, 97, 98, 99, 0, 0, 0, 0, 100, 0, 0, 0, 0,\n+    0, 0, 101, 102, 0, 103, 0, 0, 0, 0, 104, 105, 106, 107, 0, 0, 0, 0, 108,\n+    109, 110, 111, 0, 0, 0, 0, 112, 113, 0, 0, 0, 0, 0, 114, 115, 116, 117,\n+    0, 0, 0, 0, 118, 119, 120, 121, 0, 0, 0, 0, 122, 0, 123, 0, 0, 0, 0, 124,\n+    125, 126, 127, 128, 0, 0, 0, 129, 130, 131, 132, 0, 0, 0, 0, 133, 134, 0,\n+    0, 0, 0, 0, 0, 135, 136, 137, 138, 0, 0, 0, 139, 140, 141, 142, 0, 0, 0,\n+    0, 0, 143, 144, 145, 0, 0, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0, 150, 0,\n+    151, 0, 0, 0, 0, 152, 153, 154, 0, 0, 0, 0, 0, 0, 155, 0, 0, 0, 0, 0, 0,\n+    156, 157, 158, 0, 0, 0, 0, 0, 159, 160, 161, 162, 0, 0, 0, 163, 0, 0, 0,\n+    164, 0, 0, 0, 165, 166, 0, 0, 0, 0, 0, 0, 167, 0, 0, 0, 0, 0, 0, 0, 168,\n+    0, 0, 0, 0, 0, 0, 169, 170, 0, 0, 0, 0, 0, 0, 171, 0, 0, 0, 0, 0, 0, 0,\n+    172, 173, 0, 0, 0, 0, 0, 0, 174, 0, 0, 0, 0, 0, 0, 175, 176, 0, 0, 0, 0,\n+    0, 0, 177, 178, 0, 0, 0, 0, 0, 0, 179, 0, 0, 0, 0, 0, 0, 0, 180, 0, 0, 0,\n+    0, 0, 0, 181, 182, 183, 0, 0, 0, 0, 0, 184, 185, 0, 0, 0, 0, 0, 0, 186,\n+    0, 0, 0, 0, 0, 0, 0, 187, 0, 0, 0, 0, 0, 0, 188, 189, 0, 0, 0, 0, 0, 0,\n+    190, 0, 0, 0, 0, 0, 0, 0, 191, 192, 0, 0, 0, 0, 0, 0, 193, 0, 0, 0, 0, 0,\n+    0, 194, 195, 0, 0, 0, 0, 0, 0, 196, 197, 0, 0, 0, 0, 0, 0, 198, 0, 0, 0,\n+    0, 0, 0, 0, 199, 0, 0, 0, 0, 0, 0, 200, 201, 202, 0, 0, 0, 0, 0, 203,\n+    204, 0, 0, 0, 0, 0, 0, 205, 206, 0, 0, 0, 0, 0, 0, 207, 0, 0, 0, 0, 0, 0,\n+    208, 0, 0, 0, 0, 0, 0, 0, 209, 0, 0, 0, 0, 0, 0, 0, 210, 0, 0, 0, 0, 0,\n+    0, 0, 211, 0, 0, 0, 0, 0, 0, 0, 212, 0, 0, 0, 0, 0, 0, 0, 213, 0, 0, 0,\n+    0, 0, 0, 0, 214, 0, 0, 0, 0, 0, 0, 215, 0, 0, 0, 0, 0, 0, 216, 0, 0, 0,\n+    0, 0, 0, 0, 0, 217, 0, 0, 0, 0, 0, 0, 0, 218, 0, 0, 0, 0, 0, 0, 219, 0,\n+    0, 0, 0, 0, 0, 220, 221, 222, 0, 0, 0, 0, 0, 223, 224, 225, 0, 0, 0, 0,\n+    0, 226, 227, 228, 0, 0, 0, 0, 0, 229, 230, 231, 0, 0, 0, 0, 0, 0, 232, 0,\n+    0, 0, 0, 0, 0, 233, 0, 0, 0, 0, 0, 0, 234, 0, 0, 0, 0, 0, 0, 0, 235, 0,\n+    0, 0, 0, 0, 0, 0, 236, 0, 0, 0, 0, 0, 0, 0, 237, 0, 0, 0, 0, 0, 0, 238,\n+    0, 0, 0, 0, 0, 0, 0, 239, 0, 0, 0, 0, 0, 0, 0, 240, 0, 0, 0, 0, 0, 0, 0,\n+    241, 0, 0, 0, 0, 0, 0, 242, 0, 243, 244, 0, 0, 0, 0, 245, 246, 0, 0, 0,\n+    0, 0, 247, 0, 248, 0, 249, 0, 0, 0, 250, 251, 252, 0, 0, 0, 0, 0, 253, 0,\n+    254, 0, 0, 0, 0, 0, 0, 255, 0, 0, 0, 0, 0, 256, 257, 258, 0, 0, 0, 0, 0,\n+    259, 0, 260, 0, 261, 0, 0, 0, 0, 0, 0, 262, 0, 0, 0, 0, 0, 0, 0, 263, 0,\n+    0, 0, 264, 265, 266, 0, 267, 0, 0, 0, 268, 0, 269, 0, 0, 0, 0, 0, 270, 0,\n+    271, 272, 0, 0, 0, 0, 273, 274, 0, 275, 0, 0, 0, 276, 0, 277, 0, 0, 0, 0,\n+    0, 0, 0, 278, 0, 0, 0, 0, 0, 279, 280, 281, 282, 0, 0, 0, 0, 283, 284, 0,\n+    285, 0, 0, 0, 286, 0, 0, 0, 287, 0, 0, 0, 288, 0, 0, 0, 289, 0, 0, 0, 0,\n+    0, 0, 290, 0, 0, 0, 0, 291, 0, 0, 0, 0, 0, 0, 0, 292, 0, 0, 0, 0, 0, 0,\n+    0, 293, 0, 0, 0, 0, 0, 0, 294, 0, 0, 0, 0, 0, 0, 0, 295, 0, 0, 0, 0, 0,\n+    0, 0, 296, 0, 0, 0, 0, 0, 0, 0, 297, 0, 0, 0, 0, 0, 0, 298, 299, 0, 0, 0,\n+    0, 0, 0, 300, 0, 0, 0, 0, 0, 0, 0, 301, 0, 0, 0, 0, 0, 0, 0, 302, 0, 0,\n+    0, 0, 0, 0, 0, 303, 0, 0, 0, 0, 0, 0, 304, 0, 0, 0, 0, 0, 0, 0, 305, 0,\n+    0, 0, 0, 0, 0, 0, 306, 0, 0, 0, 0, 0, 0, 307, 0, 0, 0, 0, 0, 0, 0, 308,\n+    0, 0, 0, 0, 0, 0, 0, 309, 0, 0, 0, 0, 0, 0, 0, 310, 0, 0, 0, 0, 0, 0,\n+    311, 312, 0, 0, 0, 0, 0, 0, 313, 0, 0, 0, 0, 0, 0, 0, 314, 0, 0, 0, 0, 0,\n+    0, 0, 315, 0, 0, 0, 0, 0, 0, 0, 316, 0, 0, 0, 0, 0, 0, 317, 0, 0, 0, 0,\n+    0, 0, 0, 318, 0, 0, 0, 0, 0, 0, 0, 319, 0, 0, 0, 0, 0, 0, 0, 320, 0, 0,\n+    0, 0, 0, 0, 0, 321, 0, 0, 0, 0, 0, 0, 322, 0, 0, 0, 0, 0, 0, 0, 323, 0,\n+    0, 0, 0, 0, 0, 0, 324, 0, 0, 0, 0, 0, 0, 325, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    0, 326, 0, 0, 0, 0, 0, 0, 0, 327, 0, 0, 0, 0, 0, 0, 0, 328, 0, 0, 0, 0,\n+    0, 0, 329, 0, 0, 0, 0, 0, 0, 0, 330, 0, 0, 0, 0, 0, 0, 0, 331, 0, 0, 0,\n+    0, 0, 0, 0, 332, 0, 0, 0, 0, 0, 0, 0, 333, 0, 0, 0, 0, 0, 0, 334, 0, 0,\n+    0, 0, 0, 0, 0, 335, 0, 0, 0, 0, 0, 0, 0, 336, 337, 0, 0, 0, 0, 0, 0, 0,\n+    338, 0, 0, 0, 0, 0, 0, 339, 0, 0, 0, 0, 0, 0, 0, 340, 0, 0, 0, 0, 0, 0,\n+    0, 341, 0, 0, 0, 0, 0, 0, 0, 342, 0, 0, 0, 0, 0, 0, 0, 343, 0, 0, 0, 0,\n+    0, 0, 344, 0, 0, 0, 0, 0, 0, 0, 345, 346, 0, 0, 0, 0, 0, 0, 347, 0, 0, 0,\n+    0, 0, 0, 0, 348, 0, 0, 0, 0, 0, 0, 0, 349, 0, 0, 0, 0, 0, 0, 0, 350, 0,\n+    0, 0, 0, 0, 0, 0, 351, 0, 0, 0, 0, 0, 0, 0, 352, 0, 0, 0, 0, 0, 0, 353,\n+    0, 0, 0, 0, 0, 0, 0, 354, 0, 0, 0, 0, 0, 0, 0, 355, 0, 0, 0, 0, 0, 0, 0,\n+    356, 0, 0, 0, 0, 0, 0, 357, 0, 0, 0, 0, 0, 0, 0, 358, 0, 0, 0, 0, 0, 0,\n+    0, 359, 0, 0, 0, 0, 0, 0, 0, 360, 0, 0, 0, 0, 0, 0, 361, 0, 362, 0, 0, 0,\n+    0, 0, 0, 0, 363, 0, 0, 0, 0, 0, 0, 0, 364, 0, 0, 0, 0, 0, 0, 0, 365, 0,\n+    0, 0, 0, 0, 0, 0, 366, 0, 0, 0, 0, 0, 0, 367, 0, 0, 0, 0, 0, 0, 0, 368,\n+    0, 0, 0, 0, 0, 0, 369, 370, 0, 0, 0, 0, 0, 0, 371, 0, 0, 0, 0, 0, 0, 0,\n+    372, 0, 0, 0, 0, 0, 0, 0, 373, 0, 0, 0, 0, 0, 0, 374, 0, 0, 0, 0, 0, 0,\n+    0, 375, 0, 0, 376, 0, 0, 0, 0, 377, 0, 0, 378, 0, 0, 0, 0, 0, 0, 0, 379,\n+    0, 0, 0, 0, 0, 0, 0, 380, 0, 0, 0, 0, 0, 0, 381, 0, 0, 0, 0, 0, 0, 0,\n+    382, 0, 0, 0, 0, 0, 0, 0, 383, 0, 0, 0, 0, 0, 0, 0, 384, 0, 0, 0, 385, 0,\n+    0, 386, 0, 0, 0, 0, 387, 0, 0, 388, 0, 0, 0, 0, 0, 0, 0, 389, 0, 0, 0, 0,\n+    0, 0, 0, 390, 0, 0, 0, 0, 0, 0, 391, 0, 0, 0, 0, 0, 0, 0, 392, 0, 0, 0,\n+    0, 0, 0, 0, 393, 0, 0, 0, 0, 0, 0, 0, 394, 0, 0, 0, 395, 0, 0, 0, 0, 0,\n+    0, 0, 396, 0, 0, 0, 0, 0, 0, 397, 0, 0, 0, 0, 0, 0, 0, 398, 0, 0, 0, 0,\n+    0, 0, 0, 399, 0, 0, 400, 0, 0, 0, 0, 401, 0, 0, 402, 0, 0, 0, 0, 0, 0, 0,\n+    403, 0, 0, 0, 0, 0, 0, 0, 404, 0, 0, 0, 0, 0, 0, 405, 0, 0, 0, 0, 0, 0,\n+    0, 406, 0, 0, 0, 0, 0, 0, 0, 407, 0, 0, 0, 0, 0, 0, 0, 408, 0, 0, 0, 409,\n+    0, 0, 410, 0, 0, 0, 0, 411, 0, 0, 412, 0, 0, 0, 0, 0, 0, 0, 413, 0, 0, 0,\n+    0, 0, 0, 0, 414, 0, 0, 0, 0, 0, 0, 415, 0, 0, 0, 0, 0, 0, 0, 416, 0, 0,\n+    0, 0, 0, 0, 0, 417, 0, 0, 0, 0, 0, 0, 0, 418, 0, 0, 0, 419, 0, 0, 420, 0,\n+    0, 0, 0, 421, 0, 0, 422, 0, 0, 0, 423, 0, 0, 0, 424, 0, 0, 0, 425, 0, 0,\n+    0, 426, 0, 0, 0, 427, 0, 0, 0, 0, 0, 0, 0, 428, 0, 0, 0, 0, 0, 0, 429, 0,\n+    0, 0, 0, 0, 0, 0, 430, 0, 0, 0, 0, 0, 0, 0, 431, 0, 0, 432, 0, 0, 0, 0,\n+    433, 0, 0, 434, 0, 0, 0, 435, 0, 0, 0, 436, 0, 0, 0, 437, 0, 0, 0, 438,\n+    0, 0, 0, 439, 0, 0, 440, 0, 0, 0, 0, 0, 0, 0, 441, 0, 0, 0, 0, 0, 0, 0,\n+    442, 0, 0, 0, 0, 0, 0, 0, 443, 0, 0, 0, 0, 0, 0, 444, 0, 0, 0, 0, 0, 0,\n+    0, 445, 0, 0, 0, 0, 0, 0, 0, 446, 0, 0, 0, 447, 0, 0, 0, 448, 0, 0, 0,\n+    449, 0, 0, 450, 0, 0, 0, 0, 0, 0, 0, 451, 0, 0, 0, 0, 0, 0, 0, 452, 0, 0,\n+    0, 0, 0, 0, 0, 453, 0, 0, 0, 0, 0, 0, 454, 0, 0, 0, 0, 0, 0, 0, 455, 0,\n+    0, 0, 0, 0, 0, 0, 456, 0, 0, 0, 0, 0, 0, 0, 457, 0, 0, 0, 0, 0, 0, 458,\n+    0, 0, 0, 0, 0, 0, 0, 459, 0, 0, 0, 0, 0, 0, 0, 460, 0, 0, 0, 461, 0, 0,\n+    0, 462, 0, 0, 0, 0, 0, 0, 463, 0, 0, 0, 0, 0, 0, 0, 464, 0, 0, 0, 465, 0,\n+    0, 0, 466, 0, 0, 0, 0, 0, 0, 467, 0, 0, 0, 0, 0, 0, 0, 468, 0, 0, 0, 0,\n+    0, 0, 0, 469, 0, 0, 0, 0, 0, 0, 0, 470, 0, 0, 0, 0, 0, 0, 471, 0, 0, 0,\n+    0, 0, 0, 0, 472, 0, 0, 0, 0, 0, 0, 0, 473, 0, 0, 0, 0, 0, 0, 0, 474, 0,\n+    0, 0, 0, 0, 0, 475, 0, 0, 0, 0, 0, 0, 0, 476, 0, 0, 0, 0, 0, 0, 0, 477,\n+    0, 0, 0, 0, 0, 0, 0, 478, 0, 0, 0, 0, 0, 0, 479, 0, 0, 0, 0, 0, 0, 0,\n+    480, 0, 0, 0, 0, 0, 0, 0, 481, 0, 0, 0, 0, 0, 0, 0, 482, 0, 0, 0, 0, 0,\n+    0, 483, 0, 0, 0, 0, 0, 0, 0, 484, 0, 0, 0, 0, 0, 0, 0, 485, 0, 0, 0, 0,\n+    0, 0, 0, 486, 0, 0, 0, 0, 0, 0, 487, 0, 0, 0, 0, 0, 0, 0, 488, 0, 0, 0,\n+    0, 0, 0, 0, 489, 0, 0, 0, 0, 0, 0, 0, 490, 0, 0, 0, 0, 0, 0, 491, 0, 0,\n+    0, 0, 0, 0, 0, 492, 0, 0, 0, 0, 0, 0, 0, 493, 0, 0, 0, 0, 0, 0, 0, 494,\n+    0, 0, 0, 0, 0, 0, 495, 0, 0, 0, 0, 0, 0, 0, 496, 0, 0, 0, 0, 0, 0, 0,\n+    497, 0, 0, 0, 0, 0, 0, 0, 498, 0, 0, 0, 0, 0, 0, 499, 0, 0, 0, 0, 0, 0,\n+    0, 500, 0, 0, 0, 0, 0, 0, 0, 501, 0, 0, 0, 0, 0, 0, 0, 502, 0, 0, 0, 0,\n+    0, 0, 503, 0, 0, 0, 0, 0, 0, 0, 504, 0, 0, 0, 0, 0, 0, 0, 505, 0, 0, 0,\n+    0, 0, 0, 0, 506, 0, 0, 0, 0, 0, 0, 507, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n+    508, 0, 0, 0, 0, 0, 0, 0, 509, 0, 0, 0, 0, 0, 0, 0, 510, 0, 0, 0, 0, 0,\n+    0, 0, 511, 0, 0, 0, 0, 0, 0, 512, 0, 0, 0, 0, 0, 0, 0, 513, 0, 0, 0, 0,\n+    0, 0, 0, 514, 0, 0, 0, 0, 0, 0, 0, 515, 0, 0, 0, 0, 0, 0, 516, 0, 0, 0,\n+    0, 0, 0, 0, 517, 0, 0, 0, 0, 0, 0, 0, 518, 0, 0, 0, 0, 0, 0, 0, 519, 0,\n+    0, 0, 0, 0, 0, 520, 0, 0, 0, 0, 0, 0, 0, 521, 0, 0, 0, 0, 0, 0, 0, 522,\n+    0, 0, 0, 0, 0, 0, 0, 523, 0, 0, 0, 0, 0, 0, 524, 0, 0, 0, 0, 0, 0, 0,\n+    525, 0, 0, 0, 0, 0, 0, 0, 526, 0, 0, 0, 0, 0, 0, 0, 527, 0, 0, 0, 0, 0,\n+    0, 528, 0, 0, 0, 0, 0, 0, 0, 529, 0, 0, 0, 0, 0, 0, 0, 530, 0, 0, 0, 0,\n+    0, 0, 0, 531, 0, 0, 0, 0, 0, 0, 532, 0, 0, 0, 0, 0, 0, 0, 533, 0, 0, 0,\n+    0, 0, 0, 0, 534, 0, 0, 0, 0, 0, 0, 0, 535, 0, 0, 0, 0, 0, 0, 536, 0, 0,\n+    0, 0, 0, 0, 0, 537, 0, 0, 0, 0, 0, 0, 0, 538, 0, 0, 0, 0, 0, 0, 0, 539,\n+    0, 0, 0, 0, 0, 0, 540, 0, 0, 0, 0, 0, 0, 0, 541, 0, 0, 0, 0, 0, 0, 0,\n+    542, 0, 0, 0, 0, 0, 0, 0, 543, 0, 0, 0, 0, 0, 0, 544, 0, 0, 0, 0, 0, 0,\n+    0, 545, 0, 0, 0, 0, 0, 0, 0, 546, 0, 0, 0, 0, 0, 0, 0, 547, 0, 0, 0, 0,\n+    0, 0, 548, 0, 0, 0, 0, 0, 0, 0, 549, 0, 0, 0, 0, 0, 0, 0, 550, 0, 0, 0,\n+    0, 0, 0, 0, 551, 0, 0, 0, 0, 0, 0, 552, 0, 0, 0, 0, 0, 0, 0, 553, 0, 0,\n+    0, 0, 0, 0, 0, 554, 0, 0, 0, 0, 0, 0, 0, 555, 0, 0, 0, 0, 0, 0, 0, 556,\n+    0, 0, 0, 0, 0, 0, 557, 0, 0, 0, 0, 0, 0, 0, 558, 0, 0, 0, 0, 0, 0, 0,\n+    559, 0, 0, 0, 0, 0, 0, 0, 560, 0, 0, 0, 0, 0, 0, 0, 561, 0, 0, 0, 0, 0,\n+    0, 0, 562, 0, 0, 0, 0, 0, 0, 0, 563, 0, 0, 0, 0, 0, 0, 564,\n+};\n+\n+static const unsigned short comp_index1[] = {\n+    0, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 3, 0, 4, 5, 6, 7, 8, 9, 10,\n+    0, 11, 12, 0, 13, 0, 0, 0, 0, 0, 0, 14, 15, 0, 0, 0, 0, 16, 0, 0, 0, 0,\n+    0, 17, 18, 0, 19, 0, 20, 0, 0, 0, 0, 21, 0, 0, 0, 22, 0, 23, 0, 0, 24, 0,\n+    25, 26, 0, 27, 0, 28, 29, 30, 31, 32, 33, 34, 0, 35, 0, 36, 37, 38, 0, 0,\n+    0, 0, 0, 39, 0, 0, 0, 40, 41, 42, 43, 0, 44, 0, 0, 0, 0, 45, 0, 0, 0, 0,\n+    0, 46, 0, 47, 0, 48, 0, 0, 49, 0, 50, 0, 51, 0, 0, 52, 53, 54, 55, 56,\n+    57, 58, 0, 59, 0, 0, 60, 61, 0, 0, 0, 62, 0, 0, 0, 0, 0, 63, 64, 0, 0,\n+    65, 0, 66, 0, 0, 67, 0, 0, 0, 0, 0, 68, 0, 0, 0, 0, 69, 0, 0, 70, 0, 71,\n+    72, 0, 73, 0, 74, 0, 0, 75, 0, 0, 0, 0, 76, 0, 0, 77, 78, 0, 79, 0, 80,\n+    0, 0, 81, 0, 82, 83, 0, 84, 0, 0, 0, 0, 0, 85, 86, 87, 88, 89, 90, 91, 0,\n+    92, 0, 0, 93, 0, 0, 0, 94, 0, 0, 95, 0, 0, 0, 96, 0, 0, 97, 0, 98, 99, 0,\n+    100, 0, 101, 0, 0, 102, 0, 103, 104, 0, 105, 0, 106, 0, 0, 107, 0, 108,\n+    0, 0, 0, 109, 0, 110, 0, 0, 111, 0, 112, 113, 0, 114, 0, 0, 0, 0, 0, 115,\n+    116, 117, 118, 119, 120, 121, 0, 122, 123, 0, 124, 125, 0, 0, 0, 126, 0,\n+    0, 127, 0, 0, 128, 129, 0, 130, 131, 0, 0, 0, 0, 0, 132, 0, 0, 0, 133,\n+    134, 135, 136, 137, 0, 0, 0, 138, 0, 0, 139, 140, 0, 141, 0, 142, 0, 0,\n+    143, 0, 0, 0, 0, 144, 0, 145, 146, 147, 148, 149, 150, 151, 0, 152, 153,\n+    0, 154, 0, 0, 155, 0, 0, 0, 0, 156, 157, 0, 0, 0, 0, 0, 158, 159, 0, 160,\n+    0, 161, 162, 0, 0, 0, 163, 0, 164, 0, 0, 165, 0, 166, 167, 0, 168, 0,\n+    169, 170, 171, 172, 173, 174, 175, 0, 176, 0, 177, 178, 179, 0, 0, 0, 0,\n+    0, 180, 0, 0, 0, 181, 182, 183, 184, 0, 185, 186, 0, 0, 0, 0, 0, 187, 0,\n+    188, 0, 189, 0, 0, 190, 0, 191, 0, 192, 193, 0, 194, 195, 196, 197, 198,\n+    199, 200, 0, 201, 0, 0, 202, 203, 0, 0, 0, 204, 0, 0, 0, 205, 0, 0, 0, 0,\n+    0, 206, 0, 0, 0, 0, 207, 0, 0, 208, 0, 209, 0, 0, 210, 0, 211, 0, 0, 0,\n+    0, 212, 0, 0, 213, 0, 214, 215, 0, 216, 0, 217, 0, 0, 218, 219, 0, 0, 0,\n+    0, 0, 0, 220, 221, 0, 222, 0, 223, 0, 0, 224, 0, 225, 226, 0, 227, 0, 0,\n+    0, 0, 0, 228, 229, 230, 231, 232, 233, 234, 0, 235, 0, 0, 236, 0, 0, 0,\n+    237, 0, 0, 238, 0, 0, 0, 239, 0, 0, 240, 0, 241, 242, 0, 243, 0, 244, 0,\n+    0, 245, 0, 0, 0, 0, 0, 246, 247, 0, 248, 0, 249, 0, 0, 250, 0, 251, 0, 0,\n+    0, 252, 0, 253, 0, 0, 254, 0, 255, 256, 0, 257, 0, 258, 259, 260, 261,\n+    262, 263, 264, 0, 265, 266, 0, 267, 268, 0, 0, 0, 269, 0, 0, 270, 0, 0,\n+    0, 0, 0, 0, 271, 272, 0, 273, 274, 0, 0, 0, 275, 0, 276, 0, 0, 0, 277,\n+    278, 279, 280, 281, 0, 0, 0, 282, 0, 0, 283, 284, 0, 285, 0, 286, 0, 0,\n+    287, 0, 0, 0, 0, 288, 0, 0, 0, 0, 0, 289, 0, 290, 0, 0, 0, 0, 291, 292,\n+    0, 0, 293, 0, 0, 0, 0, 294, 295, 0, 0, 0, 0, 0, 0, 296, 0, 297, 0, 0, 0,\n+    0, 298, 0, 0, 299, 300, 0, 0, 301, 0, 0, 302, 0, 0, 0, 0, 0, 0, 303, 304,\n+    0, 0, 305, 0, 0, 306, 0, 307, 308, 0, 0, 0, 0, 0, 309, 310, 0, 0, 0, 0,\n+    0, 0, 311, 0, 312, 0, 0, 313, 0, 0, 0, 0, 0, 314, 315, 0, 0, 316, 0, 0,\n+    0, 0, 317, 318, 0, 0, 0, 0, 0, 0, 319, 0, 320, 0, 0, 0, 0, 321, 0, 0,\n+    322, 323, 0, 0, 324, 0, 0, 325, 0, 0, 0, 0, 0, 0, 326, 327, 0, 0, 328, 0,\n+    0, 329, 0, 330, 331, 0, 0, 0, 0, 0, 332, 333, 0, 0, 0, 0, 0, 0, 334, 0,\n+    335, 0, 0, 336, 0, 0, 0, 0, 0, 337, 338, 0, 0, 339, 0, 0, 340, 341, 0, 0,\n+    342, 0, 0, 343, 0, 0, 0, 0, 0, 0, 344, 0, 0, 345, 0, 0, 346, 0, 0, 0, 0,\n+    0, 347, 0, 0, 348, 0, 0, 349, 0, 0, 350, 0, 0, 0, 351, 0, 0, 0, 0, 0, 0,\n+    352, 0, 353, 0, 0, 354, 0, 0, 0, 0, 0, 0, 355, 0, 0, 0, 356, 357, 0, 0,\n+    358, 0, 0, 0, 359, 0, 0, 360, 361, 0, 0, 362, 0, 0, 0, 363, 0, 0, 364,\n+    365, 0, 0, 366, 0, 0, 0, 367, 0, 0, 368, 369, 0, 0, 370, 0, 0, 0, 371, 0,\n+    0, 0, 372, 0, 0, 0, 373, 0, 0, 0, 0, 0, 0, 374, 0, 0, 375, 0, 0, 376, 0,\n+    0, 377, 0, 0, 0, 0, 0, 0, 378, 0, 0, 379, 0, 0, 380, 0, 0, 0, 0, 0, 381,\n+    0, 382, 0, 383, 384, 0, 0, 0, 0, 0, 0, 385, 386, 0, 0, 0, 0, 0, 0, 387,\n+    0, 0, 0, 388, 0, 0, 389, 0, 0, 390, 0, 0, 0, 0, 391, 0, 392, 393, 0, 0,\n+    0, 394, 0, 0, 0, 395, 0, 0, 396, 0, 0, 0, 0, 0, 0, 397, 0, 0, 0, 398, 0,\n+    399, 400, 0, 0, 0, 401, 0, 0, 0, 402, 0, 0, 403, 0, 0, 404, 0, 0, 0, 0,\n+    0, 0, 405, 0, 0, 406, 0, 0, 0, 0, 407, 0, 408, 0, 0, 0, 0, 409, 0, 0,\n+    410, 0, 0, 0, 0, 411, 0, 0, 412, 0, 0, 0, 413, 0, 0, 414, 0, 0, 0, 0, 0,\n+    0, 415, 416, 0, 417, 418, 0, 0, 0, 419, 0, 0, 420, 0, 0, 0, 0, 421, 0, 0,\n+    422, 0, 0, 423, 0, 0, 0, 424, 0, 425, 426, 0, 0, 0, 427, 0, 0, 0, 0, 0,\n+    0, 428, 429, 0, 0, 0, 0, 0, 0, 430, 0, 0, 431, 0, 0, 0, 0, 432, 0, 433,\n+    0, 0, 0, 0, 434, 0, 435, 0, 0, 0, 0, 0, 0, 436, 437, 0, 0, 438, 0, 0,\n+    439, 0, 440, 441, 0, 0, 0, 442, 0, 0, 443, 0, 444, 445, 0, 446, 447, 0,\n+    0, 448, 0, 0, 0, 449, 0, 450, 451, 0, 0, 0, 452, 0, 0, 0, 0, 0, 453, 0,\n+    454, 455, 0, 456, 457, 0, 0, 0, 0, 0, 0, 458, 0, 0, 459, 0, 460, 461, 0,\n+    0, 0, 462, 0, 0, 463, 0, 464, 465, 0, 466, 467, 0, 0, 468, 0, 0, 0, 469,\n+    0, 470, 471, 0, 0, 0, 472, 0, 0, 0, 0, 0, 473, 0, 474, 475, 0, 476, 477,\n+    0, 0, 0, 0, 0, 0, 478, 0, 0, 479, 0, 0, 480, 0, 0, 0, 0, 0, 481, 0, 0,\n+    482, 0, 0, 0, 483, 0, 0, 484, 0, 0, 485, 0, 0, 0, 0, 0, 0, 486, 0, 0,\n+    487, 488, 0, 489, 0, 0, 490, 0, 0, 0, 0, 0, 0, 491, 0, 0, 492, 0, 0, 493,\n+    0, 0, 0, 494, 0, 0, 495, 0, 0, 0, 0, 0, 0, 496, 0, 0, 0, 497, 0, 0, 0,\n+    498, 499, 0, 0, 0, 500, 0, 0, 0, 0, 0, 501, 502, 0, 503, 0, 0, 0, 504, 0,\n+    0, 0, 505, 0, 0, 506, 507, 0, 0, 0, 0, 0, 508, 0, 0, 0, 509, 510, 0, 0,\n+    0, 0, 0, 511, 0, 0, 0, 512, 513, 0, 514, 0, 0, 0, 0, 515, 0, 0, 516, 0,\n+    0, 517, 0, 0, 0, 0, 0, 0, 518, 0, 0, 519, 0, 0, 520, 0, 0, 521, 0, 0, 0,\n+    0, 0, 0, 522, 0, 0, 523, 0, 0, 524, 0, 0, 525, 0, 0, 0, 0, 0, 0, 526, 0,\n+    0, 0, 527, 0, 0, 528, 0, 0, 529, 0, 0, 530, 0, 0, 0, 531, 0, 0, 0, 0, 0,\n+    0, 532, 533, 534, 0, 0, 0, 0, 0, 535, 536, 0, 0, 0, 0, 0, 537, 0, 0, 538,\n+    0, 0, 539, 0, 0, 0, 0, 0, 0, 540, 0, 541, 0, 0, 0, 0, 0, 542, 543, 0, 0,\n+    0, 0, 0, 544, 0, 0, 545, 0, 0, 546, 0, 0, 0, 0, 0, 0, 547, 0, 0, 548, 0,\n+    0, 549, 0, 0, 550, 0, 0, 0, 0, 551, 0, 0, 0, 0, 0, 552, 553, 0, 0, 0, 0,\n+    0, 554, 0, 0, 555, 0, 0, 556, 0, 0, 0, 0, 0, 0, 557, 0, 0, 558, 0, 0,\n+    559, 0, 0, 560, 0, 0, 0, 0, 561, 0, 0, 562, 0, 0, 0, 0, 0, 0, 563, 0, 0,\n+    564, 0, 0, 565, 0, 0, 0, 0, 0, 566, 567, 0, 0, 0, 0, 0, 568, 0, 0, 569,\n+    0, 0, 570, 0, 0, 0, 0, 0, 0, 571, 0, 0, 572, 0, 0, 573, 0, 0, 574, 0, 0,\n+    0, 0, 575, 0, 0, 0, 0, 0, 576, 577, 0, 0, 0, 0, 0, 578, 0, 0, 579, 0, 0,\n+    580, 0, 0, 0, 0, 0, 0, 581, 0, 0, 582, 0, 0, 583, 0, 0, 584, 0, 0, 0, 0,\n+    585, 0, 0, 0, 0, 0, 586, 587, 0, 0, 0, 0, 0, 588, 0, 0, 0, 0, 589, 0,\n+    590, 0, 0, 0, 0, 591, 0, 592, 0, 0, 0, 0, 593, 0, 0, 594, 0, 0, 0, 0, 0,\n+    0, 595, 0, 0, 596, 0, 0, 597, 0, 0, 0, 0, 0, 598, 599, 0, 0, 0, 0, 0,\n+    600, 0, 0, 0, 0, 601, 0, 602, 0, 0, 0, 0, 603, 0, 604, 0, 0, 0, 0, 605,\n+    0, 0, 0, 0, 0, 606, 0, 0, 607, 0, 0, 608, 0, 0, 609, 0, 0, 0, 0, 0, 0,\n+    610, 0, 0, 611, 0, 0, 612, 0, 0, 0, 0, 613, 0, 614, 0, 0, 0, 0, 615, 0,\n+    0, 0, 0, 0, 616, 0, 0, 617, 0, 0, 618, 0, 0, 619, 0, 0, 0, 0, 0, 0, 620,\n+    0, 0, 621, 0, 0, 622, 0, 0, 623, 0, 0, 0, 0, 0, 0, 624, 0, 0, 625, 0, 0,\n+    626, 0, 0, 0, 0, 627, 0, 628, 0, 0, 0, 0, 0, 0, 629, 0, 0, 630, 0, 0, 0,\n+    0, 631, 0, 632, 0, 0, 0, 0, 0, 633, 0, 0, 634, 0, 0, 635, 0, 0, 636, 0,\n+    0, 0, 0, 0, 0, 637, 0, 0, 638, 0, 0, 639, 0, 0, 640, 0, 0, 0, 0, 0, 0,\n+    641, 0, 0, 642, 0, 0, 643, 0, 0, 644, 0, 0, 0, 0, 0, 0, 645, 0, 0, 646,\n+    0, 0, 647, 0, 0, 648, 0, 0, 0, 0, 0, 0, 649, 0, 0, 650, 0, 0, 651, 0, 0,\n+    652, 0, 0, 0, 0, 0, 0, 653, 0, 0, 654, 0, 0, 655, 0, 0, 656, 0, 0, 0, 0,\n+    0, 0, 657, 0, 0, 658, 0, 0, 659, 0, 0, 660, 0, 0, 0, 0, 0, 0, 661, 0, 0,\n+    662, 0, 0, 663, 0, 0, 664, 0, 0, 0, 0, 0, 0, 665, 0, 0, 666, 0, 0, 667,\n+    0, 0, 668, 0, 0, 0, 0, 0, 0, 669, 0, 0, 670, 0, 0, 671, 0, 0, 672, 0, 0,\n+    0, 0, 0, 0, 673, 0, 0, 0, 674, 0, 0, 675, 0, 0, 676, 0, 0, 677, 0, 0, 0,\n+    0, 0, 0, 678, 0, 0, 679, 0, 0, 680, 0, 0, 681, 0, 0, 0, 0, 0, 0, 682, 0,\n+    0, 683, 0, 0, 684, 0, 0, 685, 0, 0, 0, 0, 0, 0, 686, 0, 0, 687, 0, 0,\n+    688, 0, 0, 689, 0, 0, 0, 0, 0, 0, 690, 0, 0, 691, 0, 0, 692, 0, 0, 693,\n+    0, 0, 0, 0, 0, 0, 694, 0, 0, 695, 0, 0, 696, 0, 0, 697, 0, 0, 0, 0, 0, 0,\n+    698, 0, 0, 699, 0, 0, 700, 0, 0, 701, 0, 0, 0, 0, 0, 0, 702, 0, 0, 703,\n+    0, 0, 704, 0, 0, 705, 0, 0, 0, 0, 0, 0, 706, 0, 0, 707, 0, 0, 708, 0, 0,\n+    709, 0, 0, 0, 0, 0, 0, 710, 0, 0, 711, 0, 0, 712, 0, 0, 713, 0, 0, 0, 0,\n+    0, 0, 714, 0, 0, 715, 0, 0, 716, 0, 0, 717, 0, 0, 0, 0, 0, 0, 718, 0, 0,\n+    719, 0, 0, 720, 0, 0, 721, 0, 0, 0, 722, 0, 0, 0, 0, 0, 0, 723, 0, 0,\n+    724, 0, 0, 725, 0, 0, 726, 0, 0, 0, 727, 0, 0, 0, 728, 729, 0, 0, 730, 0,\n+    0, 0, 0, 0, 0, 731,\n+};\n+\n+static const unsigned int comp_data[] = {\n+    0, 0, 0, 8814, 0, 8800, 0, 8815, 192, 193, 194, 195, 256, 258, 550, 196,\n+    7842, 197, 0, 461, 512, 514, 0, 7840, 0, 7680, 260, 0, 7682, 0, 0, 7684,\n+    7686, 0, 0, 262, 264, 0, 266, 0, 0, 268, 0, 199, 7690, 0, 0, 270, 0,\n+    7692, 0, 7696, 0, 7698, 7694, 0, 200, 201, 202, 7868, 274, 276, 278, 203,\n+    7866, 0, 0, 282, 516, 518, 0, 7864, 0, 552, 280, 7704, 0, 7706, 7710, 0,\n+    0, 500, 284, 0, 7712, 286, 288, 0, 0, 486, 0, 290, 292, 0, 7714, 7718, 0,\n+    542, 0, 7716, 0, 7720, 7722, 0, 204, 205, 206, 296, 298, 300, 304, 207,\n+    7880, 0, 0, 463, 520, 522, 0, 7882, 302, 0, 0, 7724, 308, 0, 0, 7728, 0,\n+    488, 0, 7730, 0, 310, 7732, 0, 0, 313, 0, 317, 0, 7734, 0, 315, 0, 7740,\n+    7738, 0, 0, 7742, 7744, 0, 0, 7746, 504, 323, 0, 209, 7748, 0, 0, 327, 0,\n+    7750, 0, 325, 0, 7754, 7752, 0, 210, 211, 212, 213, 332, 334, 558, 214,\n+    7886, 0, 336, 465, 524, 526, 416, 7884, 490, 0, 0, 7764, 7766, 0, 0, 340,\n+    7768, 0, 0, 344, 528, 530, 0, 7770, 0, 342, 7774, 0, 0, 346, 348, 0,\n+    7776, 0, 0, 352, 0, 7778, 536, 350, 7786, 0, 0, 356, 0, 7788, 538, 354,\n+    0, 7792, 7790, 0, 217, 218, 219, 360, 362, 364, 0, 220, 7910, 366, 368,\n+    467, 532, 534, 431, 7908, 7794, 0, 370, 7798, 0, 7796, 0, 7804, 0, 7806,\n+    7808, 7810, 372, 0, 7814, 7812, 0, 7816, 7818, 7820, 7922, 221, 374,\n+    7928, 562, 0, 7822, 376, 7926, 0, 0, 7924, 0, 377, 7824, 0, 379, 0, 0,\n+    381, 0, 7826, 7828, 0, 224, 225, 226, 227, 257, 259, 551, 228, 7843, 229,\n+    0, 462, 513, 515, 0, 7841, 0, 7681, 261, 0, 7683, 0, 0, 7685, 7687, 0, 0,\n+    263, 265, 0, 267, 0, 0, 269, 0, 231, 7691, 0, 0, 271, 0, 7693, 0, 7697,\n+    0, 7699, 7695, 0, 232, 233, 234, 7869, 275, 277, 279, 235, 7867, 0, 0,\n+    283, 517, 519, 0, 7865, 0, 553, 281, 7705, 0, 7707, 7711, 0, 0, 501, 285,\n+    0, 7713, 287, 289, 0, 0, 487, 0, 291, 293, 0, 7715, 7719, 0, 543, 0,\n+    7717, 0, 7721, 7723, 0, 7830, 0, 236, 237, 238, 297, 299, 301, 0, 239,\n+    7881, 0, 0, 464, 521, 523, 0, 7883, 303, 0, 0, 7725, 309, 0, 0, 496, 0,\n+    7729, 0, 489, 0, 7731, 0, 311, 7733, 0, 0, 314, 0, 318, 0, 7735, 0, 316,\n+    0, 7741, 7739, 0, 0, 7743, 7745, 0, 0, 7747, 505, 324, 0, 241, 7749, 0,\n+    0, 328, 0, 7751, 0, 326, 0, 7755, 7753, 0, 242, 243, 244, 245, 333, 335,\n+    559, 246, 7887, 0, 337, 466, 525, 527, 417, 7885, 491, 0, 0, 7765, 7767,\n+    0, 0, 341, 7769, 0, 0, 345, 529, 531, 0, 7771, 0, 343, 7775, 0, 0, 347,\n+    349, 0, 7777, 0, 0, 353, 0, 7779, 537, 351, 7787, 7831, 0, 357, 0, 7789,\n+    539, 355, 0, 7793, 7791, 0, 249, 250, 251, 361, 363, 365, 0, 252, 7911,\n+    367, 369, 468, 533, 535, 432, 7909, 7795, 0, 371, 7799, 0, 7797, 0, 7805,\n+    0, 7807, 7809, 7811, 373, 0, 7815, 7813, 0, 7832, 0, 7817, 7819, 7821,\n+    7923, 253, 375, 7929, 563, 0, 7823, 255, 7927, 7833, 0, 7925, 0, 378,\n+    7825, 0, 380, 0, 0, 382, 0, 7827, 7829, 0, 8173, 901, 8129, 0, 7846,\n+    7844, 0, 7850, 7848, 0, 478, 0, 0, 506, 0, 508, 482, 0, 0, 7688, 7872,\n+    7870, 0, 7876, 7874, 0, 0, 7726, 7890, 7888, 0, 7894, 7892, 0, 0, 7756,\n+    556, 0, 0, 7758, 554, 0, 0, 510, 475, 471, 469, 0, 0, 473, 7847, 7845, 0,\n+    7851, 7849, 0, 479, 0, 0, 507, 0, 509, 483, 0, 0, 7689, 7873, 7871, 0,\n+    7877, 7875, 0, 0, 7727, 7891, 7889, 0, 7895, 7893, 0, 0, 7757, 557, 0, 0,\n+    7759, 555, 0, 0, 511, 476, 472, 470, 0, 0, 474, 7856, 7854, 0, 7860,\n+    7858, 0, 7857, 7855, 0, 7861, 7859, 0, 7700, 7702, 7701, 7703, 7760,\n+    7762, 7761, 7763, 7780, 0, 7781, 0, 7782, 0, 7783, 0, 0, 7800, 0, 7801,\n+    0, 7802, 0, 7803, 7835, 0, 7900, 7898, 0, 7904, 7902, 0, 0, 7906, 7901,\n+    7899, 0, 7905, 7903, 0, 0, 7907, 7914, 7912, 0, 7918, 7916, 0, 0, 7920,\n+    7915, 7913, 0, 7919, 7917, 0, 0, 7921, 0, 494, 492, 0, 493, 0, 480, 0,\n+    481, 0, 0, 7708, 0, 7709, 560, 0, 561, 0, 0, 495, 8122, 902, 8121, 8120,\n+    7944, 7945, 0, 8124, 8136, 904, 7960, 7961, 8138, 905, 7976, 7977, 0,\n+    8140, 8154, 906, 8153, 8152, 0, 938, 7992, 7993, 8184, 908, 8008, 8009,\n+    0, 8172, 8170, 910, 8169, 8168, 0, 939, 0, 8025, 8186, 911, 8040, 8041,\n+    0, 8188, 0, 8116, 0, 8132, 8048, 940, 8113, 8112, 7936, 7937, 8118, 8115,\n+    8050, 941, 7952, 7953, 8052, 942, 7968, 7969, 8134, 8131, 8054, 943,\n+    8145, 8144, 0, 970, 7984, 7985, 8150, 0, 8056, 972, 8000, 8001, 8164,\n+    8165, 8058, 973, 8161, 8160, 0, 971, 8016, 8017, 8166, 0, 8060, 974,\n+    8032, 8033, 8182, 8179, 8146, 912, 8151, 0, 8162, 944, 8167, 0, 0, 8180,\n+    0, 979, 0, 980, 0, 1031, 0, 1232, 0, 1234, 0, 1027, 1024, 0, 0, 1238, 0,\n+    1025, 0, 1217, 0, 1244, 0, 1246, 1037, 0, 1250, 1049, 0, 1252, 0, 1036,\n+    0, 1254, 1262, 1038, 0, 1264, 1266, 0, 0, 1268, 0, 1272, 0, 1260, 0,\n+    1233, 0, 1235, 0, 1107, 1104, 0, 0, 1239, 0, 1105, 0, 1218, 0, 1245, 0,\n+    1247, 1117, 0, 1251, 1081, 0, 1253, 0, 1116, 0, 1255, 1263, 1118, 0,\n+    1265, 1267, 0, 0, 1269, 0, 1273, 0, 1261, 0, 1111, 1142, 0, 1143, 0, 0,\n+    1242, 0, 1243, 0, 1258, 0, 1259, 1570, 1571, 1573, 0, 0, 1572, 0, 1574,\n+    0, 1730, 0, 1747, 0, 1728, 0, 2345, 0, 2353, 0, 2356, 2507, 2508, 2891,\n+    2888, 2892, 0, 2964, 0, 0, 3018, 3020, 0, 0, 3019, 0, 3144, 0, 3264,\n+    3274, 3271, 3272, 0, 0, 3275, 0, 3402, 3404, 0, 0, 3403, 0, 3546, 3548,\n+    3550, 0, 3549, 4134, 0, 0, 6918, 0, 6920, 0, 6922, 0, 6924, 0, 6926, 0,\n+    6930, 0, 6971, 0, 6973, 0, 6976, 0, 6977, 0, 6979, 7736, 0, 7737, 0,\n+    7772, 0, 7773, 0, 7784, 0, 7785, 0, 7852, 0, 0, 7862, 7853, 0, 0, 7863,\n+    7878, 0, 7879, 0, 7896, 0, 7897, 0, 7938, 7940, 7942, 8064, 7939, 7941,\n+    7943, 8065, 0, 8066, 0, 8067, 0, 8068, 0, 8069, 0, 8070, 0, 8071, 7946,\n+    7948, 7950, 8072, 7947, 7949, 7951, 8073, 0, 8074, 0, 8075, 0, 8076, 0,\n+    8077, 0, 8078, 0, 8079, 7954, 7956, 7955, 7957, 7962, 7964, 7963, 7965,\n+    7970, 7972, 7974, 8080, 7971, 7973, 7975, 8081, 0, 8082, 0, 8083, 0,\n+    8084, 0, 8085, 0, 8086, 0, 8087, 7978, 7980, 7982, 8088, 7979, 7981,\n+    7983, 8089, 0, 8090, 0, 8091, 0, 8092, 0, 8093, 0, 8094, 0, 8095, 7986,\n+    7988, 7990, 0, 7987, 7989, 7991, 0, 7994, 7996, 7998, 0, 7995, 7997,\n+    7999, 0, 8002, 8004, 8003, 8005, 8010, 8012, 8011, 8013, 8018, 8020,\n+    8022, 0, 8019, 8021, 8023, 0, 8027, 8029, 8031, 0, 8034, 8036, 8038,\n+    8096, 8035, 8037, 8039, 8097, 0, 8098, 0, 8099, 0, 8100, 0, 8101, 0,\n+    8102, 0, 8103, 8042, 8044, 8046, 8104, 8043, 8045, 8047, 8105, 0, 8106,\n+    0, 8107, 0, 8108, 0, 8109, 0, 8110, 0, 8111, 0, 8114, 0, 8130, 0, 8178,\n+    0, 8119, 8141, 8142, 8143, 0, 0, 8135, 0, 8183, 8157, 8158, 8159, 0, 0,\n+    8602, 0, 8603, 0, 8622, 0, 8653, 0, 8655, 0, 8654, 0, 8708, 0, 8713, 0,\n+    8716, 0, 8740, 0, 8742, 0, 8769, 0, 8772, 0, 8775, 0, 8777, 0, 8813, 0,\n+    8802, 0, 8816, 0, 8817, 0, 8820, 0, 8821, 0, 8824, 0, 8825, 0, 8832, 0,\n+    8833, 0, 8928, 0, 8929, 0, 8836, 0, 8837, 0, 8840, 0, 8841, 0, 8930, 0,\n+    8931, 0, 8876, 0, 8877, 0, 8878, 0, 8879, 0, 8938, 0, 8939, 0, 8940, 0,\n+    8941, 12436, 0, 12364, 0, 12366, 0, 12368, 0, 12370, 0, 12372, 0, 12374,\n+    0, 12376, 0, 12378, 0, 12380, 0, 12382, 0, 12384, 0, 12386, 0, 12389, 0,\n+    12391, 0, 12393, 0, 12400, 12401, 12403, 12404, 12406, 12407, 12409,\n+    12410, 12412, 12413, 12446, 0, 12532, 0, 12460, 0, 12462, 0, 12464, 0,\n+    12466, 0, 12468, 0, 12470, 0, 12472, 0, 12474, 0, 12476, 0, 12478, 0,\n+    12480, 0, 12482, 0, 12485, 0, 12487, 0, 12489, 0, 12496, 12497, 12499,\n+    12500, 12502, 12503, 12505, 12506, 12508, 12509, 12535, 0, 12536, 0,\n+    12537, 0, 12538, 0, 12542, 0, 69786, 0, 69788, 0, 69803, 0, 0, 69934, 0,\n+    69935, 70475, 70476, 70844, 70843, 70846, 0, 0, 71098, 0, 71099,\n+};\n+\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-ucdn\/ucdn_db.h","additions":5730,"deletions":0,"binary":false,"changes":5730,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/* == Start of generated table == *\/\n+\/*\n+ * The following tables are generated by running:\n+ *\n+ *   .\/gen-emoji-table.py emoji-data.txt\n+ *\n+ * on file with this header:\n+ *\n+ * # emoji-data.txt\n+ * # Date: 2018-02-07, 07:55:18 GMT\n+ * # © 2018 Unicode®, Inc.\n+ * # Unicode and the Unicode Logo are registered trademarks of Unicode, Inc. in the U.S. and other countries.\n+ * # For terms of use, see http:\/\/www.unicode.org\/terms_of_use.html\n+ * #\n+ * # Emoji Data for UTS #51\n+ * # Version: 11.0\n+ * #\n+ * # For documentation and usage, see http:\/\/www.unicode.org\/reports\/tr51\n+ *\/\n+\n+#ifndef HB_UNICODE_EMOJI_TABLE_HH\n+#define HB_UNICODE_EMOJI_TABLE_HH\n+\n+#include \"hb-unicode.hh\"\n+\n+\n+static const struct hb_unicode_range_t _hb_unicode_emoji_Extended_Pictographic_table[] =\n+{\n+  {0x00A9, 0x00A9},\n+  {0x00AE, 0x00AE},\n+  {0x203C, 0x203C},\n+  {0x2049, 0x2049},\n+  {0x2122, 0x2122},\n+  {0x2139, 0x2139},\n+  {0x2194, 0x2199},\n+  {0x21A9, 0x21AA},\n+  {0x231A, 0x231B},\n+  {0x2328, 0x2328},\n+  {0x2388, 0x2388},\n+  {0x23CF, 0x23CF},\n+  {0x23E9, 0x23F3},\n+  {0x23F8, 0x23FA},\n+  {0x24C2, 0x24C2},\n+  {0x25AA, 0x25AB},\n+  {0x25B6, 0x25B6},\n+  {0x25C0, 0x25C0},\n+  {0x25FB, 0x25FE},\n+  {0x2600, 0x2605},\n+  {0x2607, 0x2612},\n+  {0x2614, 0x2685},\n+  {0x2690, 0x2705},\n+  {0x2708, 0x2712},\n+  {0x2714, 0x2714},\n+  {0x2716, 0x2716},\n+  {0x271D, 0x271D},\n+  {0x2721, 0x2721},\n+  {0x2728, 0x2728},\n+  {0x2733, 0x2734},\n+  {0x2744, 0x2744},\n+  {0x2747, 0x2747},\n+  {0x274C, 0x274C},\n+  {0x274E, 0x274E},\n+  {0x2753, 0x2755},\n+  {0x2757, 0x2757},\n+  {0x2763, 0x2767},\n+  {0x2795, 0x2797},\n+  {0x27A1, 0x27A1},\n+  {0x27B0, 0x27B0},\n+  {0x27BF, 0x27BF},\n+  {0x2934, 0x2935},\n+  {0x2B05, 0x2B07},\n+  {0x2B1B, 0x2B1C},\n+  {0x2B50, 0x2B50},\n+  {0x2B55, 0x2B55},\n+  {0x3030, 0x3030},\n+  {0x303D, 0x303D},\n+  {0x3297, 0x3297},\n+  {0x3299, 0x3299},\n+  {0x1F000, 0x1F0FF},\n+  {0x1F10D, 0x1F10F},\n+  {0x1F12F, 0x1F12F},\n+  {0x1F16C, 0x1F171},\n+  {0x1F17E, 0x1F17F},\n+  {0x1F18E, 0x1F18E},\n+  {0x1F191, 0x1F19A},\n+  {0x1F1AD, 0x1F1E5},\n+  {0x1F201, 0x1F20F},\n+  {0x1F21A, 0x1F21A},\n+  {0x1F22F, 0x1F22F},\n+  {0x1F232, 0x1F23A},\n+  {0x1F23C, 0x1F23F},\n+  {0x1F249, 0x1F3FA},\n+  {0x1F400, 0x1F53D},\n+  {0x1F546, 0x1F64F},\n+  {0x1F680, 0x1F6FF},\n+  {0x1F774, 0x1F77F},\n+  {0x1F7D5, 0x1F7FF},\n+  {0x1F80C, 0x1F80F},\n+  {0x1F848, 0x1F84F},\n+  {0x1F85A, 0x1F85F},\n+  {0x1F888, 0x1F88F},\n+  {0x1F8AE, 0x1F8FF},\n+  {0x1F90C, 0x1F93A},\n+  {0x1F93C, 0x1F945},\n+  {0x1F947, 0x1FFFD},\n+};\n+\n+#endif \/* HB_UNICODE_EMOJI_TABLE_HH *\/\n+\n+\/* == End of generated table == *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-unicode-emoji-table.hh","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -0,0 +1,577 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2011  Codethink Limited\n+ * Copyright © 2010,2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Codethink Author(s): Ryan Lortie\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#include \"hb-unicode.hh\"\n+\n+\n+\/**\n+ * SECTION: hb-unicode\n+ * @title: hb-unicode\n+ * @short_description: Unicode character property access\n+ * @include: hb.h\n+ *\n+ * Unicode functions are used to access Unicode character properties.\n+ * Client can pass its own Unicode functions to HarfBuzz, or access\n+ * the built-in Unicode functions that come with HarfBuzz.\n+ *\n+ * With the Unicode functions, one can query variour Unicode character\n+ * properties, such as General Category, Script, Combining Class, etc.\n+ **\/\n+\n+\n+\/*\n+ * hb_unicode_funcs_t\n+ *\/\n+\n+static hb_unicode_combining_class_t\n+hb_unicode_combining_class_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,\n+                                hb_codepoint_t      unicode   HB_UNUSED,\n+                                void               *user_data HB_UNUSED)\n+{\n+  return HB_UNICODE_COMBINING_CLASS_NOT_REORDERED;\n+}\n+\n+static unsigned int\n+hb_unicode_eastasian_width_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,\n+                                hb_codepoint_t      unicode   HB_UNUSED,\n+                                void               *user_data HB_UNUSED)\n+{\n+  return 1;\n+}\n+\n+static hb_unicode_general_category_t\n+hb_unicode_general_category_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,\n+                                 hb_codepoint_t      unicode   HB_UNUSED,\n+                                 void               *user_data HB_UNUSED)\n+{\n+  return HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER;\n+}\n+\n+static hb_codepoint_t\n+hb_unicode_mirroring_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,\n+                          hb_codepoint_t      unicode,\n+                          void               *user_data HB_UNUSED)\n+{\n+  return unicode;\n+}\n+\n+static hb_script_t\n+hb_unicode_script_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,\n+                       hb_codepoint_t      unicode   HB_UNUSED,\n+                       void               *user_data HB_UNUSED)\n+{\n+  return HB_SCRIPT_UNKNOWN;\n+}\n+\n+static hb_bool_t\n+hb_unicode_compose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,\n+                        hb_codepoint_t      a         HB_UNUSED,\n+                        hb_codepoint_t      b         HB_UNUSED,\n+                        hb_codepoint_t     *ab        HB_UNUSED,\n+                        void               *user_data HB_UNUSED)\n+{\n+  return false;\n+}\n+\n+static hb_bool_t\n+hb_unicode_decompose_nil (hb_unicode_funcs_t *ufuncs    HB_UNUSED,\n+                          hb_codepoint_t      ab        HB_UNUSED,\n+                          hb_codepoint_t     *a         HB_UNUSED,\n+                          hb_codepoint_t     *b         HB_UNUSED,\n+                          void               *user_data HB_UNUSED)\n+{\n+  return false;\n+}\n+\n+\n+static unsigned int\n+hb_unicode_decompose_compatibility_nil (hb_unicode_funcs_t *ufuncs     HB_UNUSED,\n+                                        hb_codepoint_t      u          HB_UNUSED,\n+                                        hb_codepoint_t     *decomposed HB_UNUSED,\n+                                        void               *user_data  HB_UNUSED)\n+{\n+  return 0;\n+}\n+\n+\n+extern \"C\" hb_unicode_funcs_t *hb_glib_get_unicode_funcs ();\n+extern \"C\" hb_unicode_funcs_t *hb_icu_get_unicode_funcs ();\n+extern \"C\" hb_unicode_funcs_t *hb_ucdn_get_unicode_funcs ();\n+\n+hb_unicode_funcs_t *\n+hb_unicode_funcs_get_default ()\n+{\n+#if defined(HAVE_UCDN)\n+  return hb_ucdn_get_unicode_funcs ();\n+#elif defined(HAVE_GLIB)\n+  return hb_glib_get_unicode_funcs ();\n+#elif defined(HAVE_ICU) && defined(HAVE_ICU_BUILTIN)\n+  return hb_icu_get_unicode_funcs ();\n+#else\n+#define HB_UNICODE_FUNCS_NIL 1\n+  return hb_unicode_funcs_get_empty ();\n+#endif\n+}\n+\n+#if !defined(HB_NO_UNICODE_FUNCS) && defined(HB_UNICODE_FUNCS_NIL)\n+#error \"Could not find any Unicode functions implementation, you have to provide your own\"\n+#error \"Consider building hb-ucdn.c.  If you absolutely want to build without any, check the code.\"\n+#endif\n+\n+\/**\n+ * hb_unicode_funcs_create: (Xconstructor)\n+ * @parent: (nullable):\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_unicode_funcs_t *\n+hb_unicode_funcs_create (hb_unicode_funcs_t *parent)\n+{\n+  hb_unicode_funcs_t *ufuncs;\n+\n+  if (!(ufuncs = hb_object_create<hb_unicode_funcs_t> ()))\n+    return hb_unicode_funcs_get_empty ();\n+\n+  if (!parent)\n+    parent = hb_unicode_funcs_get_empty ();\n+\n+  hb_unicode_funcs_make_immutable (parent);\n+  ufuncs->parent = hb_unicode_funcs_reference (parent);\n+\n+  ufuncs->func = parent->func;\n+\n+  \/* We can safely copy user_data from parent since we hold a reference\n+   * onto it and it's immutable.  We should not copy the destroy notifiers\n+   * though. *\/\n+  ufuncs->user_data = parent->user_data;\n+\n+  return ufuncs;\n+}\n+\n+\n+DEFINE_NULL_INSTANCE (hb_unicode_funcs_t) =\n+{\n+  HB_OBJECT_HEADER_STATIC,\n+\n+  nullptr, \/* parent *\/\n+  {\n+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_nil,\n+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+  }\n+};\n+\n+\/**\n+ * hb_unicode_funcs_get_empty:\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_unicode_funcs_t *\n+hb_unicode_funcs_get_empty ()\n+{\n+  return const_cast<hb_unicode_funcs_t *> (&Null(hb_unicode_funcs_t));\n+}\n+\n+\/**\n+ * hb_unicode_funcs_reference: (skip)\n+ * @ufuncs: Unicode functions.\n+ *\n+ *\n+ *\n+ * Return value: (transfer full):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_unicode_funcs_t *\n+hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs)\n+{\n+  return hb_object_reference (ufuncs);\n+}\n+\n+\/**\n+ * hb_unicode_funcs_destroy: (skip)\n+ * @ufuncs: Unicode functions.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_unicode_funcs_destroy (hb_unicode_funcs_t *ufuncs)\n+{\n+  if (!hb_object_destroy (ufuncs)) return;\n+\n+#define HB_UNICODE_FUNC_IMPLEMENT(name) \\\n+  if (ufuncs->destroy.name) ufuncs->destroy.name (ufuncs->user_data.name);\n+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+\n+  hb_unicode_funcs_destroy (ufuncs->parent);\n+\n+  free (ufuncs);\n+}\n+\n+\/**\n+ * hb_unicode_funcs_set_user_data: (skip)\n+ * @ufuncs: Unicode functions.\n+ * @key:\n+ * @data:\n+ * @destroy:\n+ * @replace:\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_unicode_funcs_set_user_data (hb_unicode_funcs_t *ufuncs,\n+                                hb_user_data_key_t *key,\n+                                void *              data,\n+                                hb_destroy_func_t   destroy,\n+                                hb_bool_t           replace)\n+{\n+  return hb_object_set_user_data (ufuncs, key, data, destroy, replace);\n+}\n+\n+\/**\n+ * hb_unicode_funcs_get_user_data: (skip)\n+ * @ufuncs: Unicode functions.\n+ * @key:\n+ *\n+ *\n+ *\n+ * Return value: (transfer none):\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void *\n+hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,\n+                                hb_user_data_key_t *key)\n+{\n+  return hb_object_get_user_data (ufuncs, key);\n+}\n+\n+\n+\/**\n+ * hb_unicode_funcs_make_immutable:\n+ * @ufuncs: Unicode functions.\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+void\n+hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs)\n+{\n+  if (hb_object_is_immutable (ufuncs))\n+    return;\n+\n+  hb_object_make_immutable (ufuncs);\n+}\n+\n+\/**\n+ * hb_unicode_funcs_is_immutable:\n+ * @ufuncs: Unicode functions.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs)\n+{\n+  return hb_object_is_immutable (ufuncs);\n+}\n+\n+\/**\n+ * hb_unicode_funcs_get_parent:\n+ * @ufuncs: Unicode functions.\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_unicode_funcs_t *\n+hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs)\n+{\n+  return ufuncs->parent ? ufuncs->parent : hb_unicode_funcs_get_empty ();\n+}\n+\n+\n+#define HB_UNICODE_FUNC_IMPLEMENT(name)                                         \\\n+                                                                                \\\n+void                                                                            \\\n+hb_unicode_funcs_set_##name##_func (hb_unicode_funcs_t             *ufuncs,     \\\n+                                    hb_unicode_##name##_func_t      func,       \\\n+                                    void                           *user_data,  \\\n+                                    hb_destroy_func_t               destroy)    \\\n+{                                                                               \\\n+  if (hb_object_is_immutable (ufuncs))                                          \\\n+    return;                                                                     \\\n+                                                                                \\\n+  if (ufuncs->destroy.name)                                                     \\\n+    ufuncs->destroy.name (ufuncs->user_data.name);                              \\\n+                                                                                \\\n+  if (func) {                                                                   \\\n+    ufuncs->func.name = func;                                                   \\\n+    ufuncs->user_data.name = user_data;                                         \\\n+    ufuncs->destroy.name = destroy;                                             \\\n+  } else {                                                                      \\\n+    ufuncs->func.name = ufuncs->parent->func.name;                              \\\n+    ufuncs->user_data.name = ufuncs->parent->user_data.name;                    \\\n+    ufuncs->destroy.name = nullptr;                                             \\\n+  }                                                                             \\\n+}\n+\n+HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+\n+\n+#define HB_UNICODE_FUNC_IMPLEMENT(return_type, name)                            \\\n+                                                                                \\\n+return_type                                                                     \\\n+hb_unicode_##name (hb_unicode_funcs_t *ufuncs,                                  \\\n+                   hb_codepoint_t      unicode)                                 \\\n+{                                                                               \\\n+  return ufuncs->name (unicode);                                                \\\n+}\n+HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+\n+\/**\n+ * hb_unicode_compose:\n+ * @ufuncs: Unicode functions.\n+ * @a:\n+ * @b:\n+ * @ab: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_unicode_compose (hb_unicode_funcs_t *ufuncs,\n+                    hb_codepoint_t      a,\n+                    hb_codepoint_t      b,\n+                    hb_codepoint_t     *ab)\n+{\n+  return ufuncs->compose (a, b, ab);\n+}\n+\n+\/**\n+ * hb_unicode_decompose:\n+ * @ufuncs: Unicode functions.\n+ * @ab:\n+ * @a: (out):\n+ * @b: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+hb_bool_t\n+hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,\n+                      hb_codepoint_t      ab,\n+                      hb_codepoint_t     *a,\n+                      hb_codepoint_t     *b)\n+{\n+  return ufuncs->decompose (ab, a, b);\n+}\n+\n+\/**\n+ * hb_unicode_decompose_compatibility:\n+ * @ufuncs: Unicode functions.\n+ * @u:\n+ * @decomposed: (out):\n+ *\n+ *\n+ *\n+ * Return value:\n+ *\n+ * Since: 0.9.2\n+ * Deprecated: 2.0.0\n+ **\/\n+unsigned int\n+hb_unicode_decompose_compatibility (hb_unicode_funcs_t *ufuncs,\n+                                    hb_codepoint_t      u,\n+                                    hb_codepoint_t     *decomposed)\n+{\n+  return ufuncs->decompose_compatibility (u, decomposed);\n+}\n+\n+\n+\/* See hb-unicode.hh for details. *\/\n+const uint8_t\n+_hb_modified_combining_class[256] =\n+{\n+  0, \/* HB_UNICODE_COMBINING_CLASS_NOT_REORDERED *\/\n+  1, \/* HB_UNICODE_COMBINING_CLASS_OVERLAY *\/\n+  2, 3, 4, 5, 6,\n+  7, \/* HB_UNICODE_COMBINING_CLASS_NUKTA *\/\n+  8, \/* HB_UNICODE_COMBINING_CLASS_KANA_VOICING *\/\n+  9, \/* HB_UNICODE_COMBINING_CLASS_VIRAMA *\/\n+\n+  \/* Hebrew *\/\n+  HB_MODIFIED_COMBINING_CLASS_CCC10,\n+  HB_MODIFIED_COMBINING_CLASS_CCC11,\n+  HB_MODIFIED_COMBINING_CLASS_CCC12,\n+  HB_MODIFIED_COMBINING_CLASS_CCC13,\n+  HB_MODIFIED_COMBINING_CLASS_CCC14,\n+  HB_MODIFIED_COMBINING_CLASS_CCC15,\n+  HB_MODIFIED_COMBINING_CLASS_CCC16,\n+  HB_MODIFIED_COMBINING_CLASS_CCC17,\n+  HB_MODIFIED_COMBINING_CLASS_CCC18,\n+  HB_MODIFIED_COMBINING_CLASS_CCC19,\n+  HB_MODIFIED_COMBINING_CLASS_CCC20,\n+  HB_MODIFIED_COMBINING_CLASS_CCC21,\n+  HB_MODIFIED_COMBINING_CLASS_CCC22,\n+  HB_MODIFIED_COMBINING_CLASS_CCC23,\n+  HB_MODIFIED_COMBINING_CLASS_CCC24,\n+  HB_MODIFIED_COMBINING_CLASS_CCC25,\n+  HB_MODIFIED_COMBINING_CLASS_CCC26,\n+\n+  \/* Arabic *\/\n+  HB_MODIFIED_COMBINING_CLASS_CCC27,\n+  HB_MODIFIED_COMBINING_CLASS_CCC28,\n+  HB_MODIFIED_COMBINING_CLASS_CCC29,\n+  HB_MODIFIED_COMBINING_CLASS_CCC30,\n+  HB_MODIFIED_COMBINING_CLASS_CCC31,\n+  HB_MODIFIED_COMBINING_CLASS_CCC32,\n+  HB_MODIFIED_COMBINING_CLASS_CCC33,\n+  HB_MODIFIED_COMBINING_CLASS_CCC34,\n+  HB_MODIFIED_COMBINING_CLASS_CCC35,\n+\n+  \/* Syriac *\/\n+  HB_MODIFIED_COMBINING_CLASS_CCC36,\n+\n+  37, 38, 39,\n+  40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59,\n+  60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,\n+  80, 81, 82, 83,\n+\n+  \/* Telugu *\/\n+  HB_MODIFIED_COMBINING_CLASS_CCC84,\n+  85, 86, 87, 88, 89, 90,\n+  HB_MODIFIED_COMBINING_CLASS_CCC91,\n+  92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102,\n+\n+  \/* Thai *\/\n+  HB_MODIFIED_COMBINING_CLASS_CCC103,\n+  104, 105, 106,\n+  HB_MODIFIED_COMBINING_CLASS_CCC107,\n+  108, 109, 110, 111, 112, 113, 114, 115, 116, 117,\n+\n+  \/* Lao *\/\n+  HB_MODIFIED_COMBINING_CLASS_CCC118,\n+  119, 120, 121,\n+  HB_MODIFIED_COMBINING_CLASS_CCC122,\n+  123, 124, 125, 126, 127, 128,\n+\n+  \/* Tibetan *\/\n+  HB_MODIFIED_COMBINING_CLASS_CCC129,\n+  HB_MODIFIED_COMBINING_CLASS_CCC130,\n+  131,\n+  HB_MODIFIED_COMBINING_CLASS_CCC132,\n+  133, 134, 135, 136, 137, 138, 139,\n+\n+\n+  140, 141, 142, 143, 144, 145, 146, 147, 148, 149,\n+  150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n+  160, 161, 162, 163, 164, 165, 166, 167, 168, 169,\n+  170, 171, 172, 173, 174, 175, 176, 177, 178, 179,\n+  180, 181, 182, 183, 184, 185, 186, 187, 188, 189,\n+  190, 191, 192, 193, 194, 195, 196, 197, 198, 199,\n+\n+  200, \/* HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT *\/\n+  201,\n+  202, \/* HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW *\/\n+  203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213,\n+  214, \/* HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE *\/\n+  215,\n+  216, \/* HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT *\/\n+  217,\n+  218, \/* HB_UNICODE_COMBINING_CLASS_BELOW_LEFT *\/\n+  219,\n+  220, \/* HB_UNICODE_COMBINING_CLASS_BELOW *\/\n+  221,\n+  222, \/* HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT *\/\n+  223,\n+  224, \/* HB_UNICODE_COMBINING_CLASS_LEFT *\/\n+  225,\n+  226, \/* HB_UNICODE_COMBINING_CLASS_RIGHT *\/\n+  227,\n+  228, \/* HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT *\/\n+  229,\n+  230, \/* HB_UNICODE_COMBINING_CLASS_ABOVE *\/\n+  231,\n+  232, \/* HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT *\/\n+  233, \/* HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW *\/\n+  234, \/* HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE *\/\n+  235, 236, 237, 238, 239,\n+  240, \/* HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT *\/\n+  241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254,\n+  255, \/* HB_UNICODE_COMBINING_CLASS_INVALID *\/\n+};\n+\n+\n+\/*\n+ * Emoji\n+ *\/\n+\n+#include \"hb-unicode-emoji-table.hh\"\n+\n+bool\n+_hb_unicode_is_emoji_Extended_Pictographic (hb_codepoint_t cp)\n+{\n+  return hb_bsearch (&cp, _hb_unicode_emoji_Extended_Pictographic_table,\n+                     ARRAY_LENGTH (_hb_unicode_emoji_Extended_Pictographic_table),\n+                     sizeof (hb_unicode_range_t),\n+                     hb_unicode_range_t::cmp);\n+}\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-unicode.cc","additions":577,"deletions":0,"binary":false,"changes":577,"status":"added"},{"patch":"@@ -0,0 +1,404 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2011  Codethink Limited\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Codethink Author(s): Ryan Lortie\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_UNICODE_H\n+#define HB_UNICODE_H\n+\n+#include \"hb-common.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+\/**\n+ * HB_UNICODE_MAX\n+ *\n+ * Since: 1.9.0\n+ **\/\n+#define HB_UNICODE_MAX 0x10FFFFu\n+\n+\n+\/* hb_unicode_general_category_t *\/\n+\n+\/* Unicode Character Database property: General_Category (gc) *\/\n+typedef enum\n+{\n+  HB_UNICODE_GENERAL_CATEGORY_CONTROL,                  \/* Cc *\/\n+  HB_UNICODE_GENERAL_CATEGORY_FORMAT,                   \/* Cf *\/\n+  HB_UNICODE_GENERAL_CATEGORY_UNASSIGNED,               \/* Cn *\/\n+  HB_UNICODE_GENERAL_CATEGORY_PRIVATE_USE,              \/* Co *\/\n+  HB_UNICODE_GENERAL_CATEGORY_SURROGATE,                \/* Cs *\/\n+  HB_UNICODE_GENERAL_CATEGORY_LOWERCASE_LETTER,         \/* Ll *\/\n+  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_LETTER,          \/* Lm *\/\n+  HB_UNICODE_GENERAL_CATEGORY_OTHER_LETTER,             \/* Lo *\/\n+  HB_UNICODE_GENERAL_CATEGORY_TITLECASE_LETTER,         \/* Lt *\/\n+  HB_UNICODE_GENERAL_CATEGORY_UPPERCASE_LETTER,         \/* Lu *\/\n+  HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK,             \/* Mc *\/\n+  HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK,           \/* Me *\/\n+  HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK,         \/* Mn *\/\n+  HB_UNICODE_GENERAL_CATEGORY_DECIMAL_NUMBER,           \/* Nd *\/\n+  HB_UNICODE_GENERAL_CATEGORY_LETTER_NUMBER,            \/* Nl *\/\n+  HB_UNICODE_GENERAL_CATEGORY_OTHER_NUMBER,             \/* No *\/\n+  HB_UNICODE_GENERAL_CATEGORY_CONNECT_PUNCTUATION,      \/* Pc *\/\n+  HB_UNICODE_GENERAL_CATEGORY_DASH_PUNCTUATION,         \/* Pd *\/\n+  HB_UNICODE_GENERAL_CATEGORY_CLOSE_PUNCTUATION,        \/* Pe *\/\n+  HB_UNICODE_GENERAL_CATEGORY_FINAL_PUNCTUATION,        \/* Pf *\/\n+  HB_UNICODE_GENERAL_CATEGORY_INITIAL_PUNCTUATION,      \/* Pi *\/\n+  HB_UNICODE_GENERAL_CATEGORY_OTHER_PUNCTUATION,        \/* Po *\/\n+  HB_UNICODE_GENERAL_CATEGORY_OPEN_PUNCTUATION,         \/* Ps *\/\n+  HB_UNICODE_GENERAL_CATEGORY_CURRENCY_SYMBOL,          \/* Sc *\/\n+  HB_UNICODE_GENERAL_CATEGORY_MODIFIER_SYMBOL,          \/* Sk *\/\n+  HB_UNICODE_GENERAL_CATEGORY_MATH_SYMBOL,              \/* Sm *\/\n+  HB_UNICODE_GENERAL_CATEGORY_OTHER_SYMBOL,             \/* So *\/\n+  HB_UNICODE_GENERAL_CATEGORY_LINE_SEPARATOR,           \/* Zl *\/\n+  HB_UNICODE_GENERAL_CATEGORY_PARAGRAPH_SEPARATOR,      \/* Zp *\/\n+  HB_UNICODE_GENERAL_CATEGORY_SPACE_SEPARATOR           \/* Zs *\/\n+} hb_unicode_general_category_t;\n+\n+\/* hb_unicode_combining_class_t *\/\n+\n+\/* Note: newer versions of Unicode may add new values.  Clients should be ready to handle\n+ * any value in the 0..254 range being returned from hb_unicode_combining_class().\n+ *\/\n+\n+\/* Unicode Character Database property: Canonical_Combining_Class (ccc) *\/\n+typedef enum\n+{\n+  HB_UNICODE_COMBINING_CLASS_NOT_REORDERED      = 0,\n+  HB_UNICODE_COMBINING_CLASS_OVERLAY            = 1,\n+  HB_UNICODE_COMBINING_CLASS_NUKTA              = 7,\n+  HB_UNICODE_COMBINING_CLASS_KANA_VOICING       = 8,\n+  HB_UNICODE_COMBINING_CLASS_VIRAMA             = 9,\n+\n+  \/* Hebrew *\/\n+  HB_UNICODE_COMBINING_CLASS_CCC10      =  10,\n+  HB_UNICODE_COMBINING_CLASS_CCC11      =  11,\n+  HB_UNICODE_COMBINING_CLASS_CCC12      =  12,\n+  HB_UNICODE_COMBINING_CLASS_CCC13      =  13,\n+  HB_UNICODE_COMBINING_CLASS_CCC14      =  14,\n+  HB_UNICODE_COMBINING_CLASS_CCC15      =  15,\n+  HB_UNICODE_COMBINING_CLASS_CCC16      =  16,\n+  HB_UNICODE_COMBINING_CLASS_CCC17      =  17,\n+  HB_UNICODE_COMBINING_CLASS_CCC18      =  18,\n+  HB_UNICODE_COMBINING_CLASS_CCC19      =  19,\n+  HB_UNICODE_COMBINING_CLASS_CCC20      =  20,\n+  HB_UNICODE_COMBINING_CLASS_CCC21      =  21,\n+  HB_UNICODE_COMBINING_CLASS_CCC22      =  22,\n+  HB_UNICODE_COMBINING_CLASS_CCC23      =  23,\n+  HB_UNICODE_COMBINING_CLASS_CCC24      =  24,\n+  HB_UNICODE_COMBINING_CLASS_CCC25      =  25,\n+  HB_UNICODE_COMBINING_CLASS_CCC26      =  26,\n+\n+  \/* Arabic *\/\n+  HB_UNICODE_COMBINING_CLASS_CCC27      =  27,\n+  HB_UNICODE_COMBINING_CLASS_CCC28      =  28,\n+  HB_UNICODE_COMBINING_CLASS_CCC29      =  29,\n+  HB_UNICODE_COMBINING_CLASS_CCC30      =  30,\n+  HB_UNICODE_COMBINING_CLASS_CCC31      =  31,\n+  HB_UNICODE_COMBINING_CLASS_CCC32      =  32,\n+  HB_UNICODE_COMBINING_CLASS_CCC33      =  33,\n+  HB_UNICODE_COMBINING_CLASS_CCC34      =  34,\n+  HB_UNICODE_COMBINING_CLASS_CCC35      =  35,\n+\n+  \/* Syriac *\/\n+  HB_UNICODE_COMBINING_CLASS_CCC36      =  36,\n+\n+  \/* Telugu *\/\n+  HB_UNICODE_COMBINING_CLASS_CCC84      =  84,\n+  HB_UNICODE_COMBINING_CLASS_CCC91      =  91,\n+\n+  \/* Thai *\/\n+  HB_UNICODE_COMBINING_CLASS_CCC103     = 103,\n+  HB_UNICODE_COMBINING_CLASS_CCC107     = 107,\n+\n+  \/* Lao *\/\n+  HB_UNICODE_COMBINING_CLASS_CCC118     = 118,\n+  HB_UNICODE_COMBINING_CLASS_CCC122     = 122,\n+\n+  \/* Tibetan *\/\n+  HB_UNICODE_COMBINING_CLASS_CCC129     = 129,\n+  HB_UNICODE_COMBINING_CLASS_CCC130     = 130,\n+  HB_UNICODE_COMBINING_CLASS_CCC133     = 132,\n+\n+\n+  HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW_LEFT        = 200,\n+  HB_UNICODE_COMBINING_CLASS_ATTACHED_BELOW             = 202,\n+  HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE             = 214,\n+  HB_UNICODE_COMBINING_CLASS_ATTACHED_ABOVE_RIGHT       = 216,\n+  HB_UNICODE_COMBINING_CLASS_BELOW_LEFT                 = 218,\n+  HB_UNICODE_COMBINING_CLASS_BELOW                      = 220,\n+  HB_UNICODE_COMBINING_CLASS_BELOW_RIGHT                = 222,\n+  HB_UNICODE_COMBINING_CLASS_LEFT                       = 224,\n+  HB_UNICODE_COMBINING_CLASS_RIGHT                      = 226,\n+  HB_UNICODE_COMBINING_CLASS_ABOVE_LEFT                 = 228,\n+  HB_UNICODE_COMBINING_CLASS_ABOVE                      = 230,\n+  HB_UNICODE_COMBINING_CLASS_ABOVE_RIGHT                = 232,\n+  HB_UNICODE_COMBINING_CLASS_DOUBLE_BELOW               = 233,\n+  HB_UNICODE_COMBINING_CLASS_DOUBLE_ABOVE               = 234,\n+\n+  HB_UNICODE_COMBINING_CLASS_IOTA_SUBSCRIPT             = 240,\n+\n+  HB_UNICODE_COMBINING_CLASS_INVALID    = 255\n+} hb_unicode_combining_class_t;\n+\n+\n+\/*\n+ * hb_unicode_funcs_t\n+ *\/\n+\n+typedef struct hb_unicode_funcs_t hb_unicode_funcs_t;\n+\n+\n+\/*\n+ * just give me the best implementation you've got there.\n+ *\/\n+HB_EXTERN hb_unicode_funcs_t *\n+hb_unicode_funcs_get_default (void);\n+\n+\n+HB_EXTERN hb_unicode_funcs_t *\n+hb_unicode_funcs_create (hb_unicode_funcs_t *parent);\n+\n+HB_EXTERN hb_unicode_funcs_t *\n+hb_unicode_funcs_get_empty (void);\n+\n+HB_EXTERN hb_unicode_funcs_t *\n+hb_unicode_funcs_reference (hb_unicode_funcs_t *ufuncs);\n+\n+HB_EXTERN void\n+hb_unicode_funcs_destroy (hb_unicode_funcs_t *ufuncs);\n+\n+HB_EXTERN hb_bool_t\n+hb_unicode_funcs_set_user_data (hb_unicode_funcs_t *ufuncs,\n+                                hb_user_data_key_t *key,\n+                                void *              data,\n+                                hb_destroy_func_t   destroy,\n+                                hb_bool_t           replace);\n+\n+\n+HB_EXTERN void *\n+hb_unicode_funcs_get_user_data (hb_unicode_funcs_t *ufuncs,\n+                                hb_user_data_key_t *key);\n+\n+\n+HB_EXTERN void\n+hb_unicode_funcs_make_immutable (hb_unicode_funcs_t *ufuncs);\n+\n+HB_EXTERN hb_bool_t\n+hb_unicode_funcs_is_immutable (hb_unicode_funcs_t *ufuncs);\n+\n+HB_EXTERN hb_unicode_funcs_t *\n+hb_unicode_funcs_get_parent (hb_unicode_funcs_t *ufuncs);\n+\n+\n+\/*\n+ * funcs\n+ *\/\n+\n+\/* typedefs *\/\n+\n+typedef hb_unicode_combining_class_t    (*hb_unicode_combining_class_func_t)    (hb_unicode_funcs_t *ufuncs,\n+                                                                                 hb_codepoint_t      unicode,\n+                                                                                 void               *user_data);\n+typedef hb_unicode_general_category_t   (*hb_unicode_general_category_func_t)   (hb_unicode_funcs_t *ufuncs,\n+                                                                                 hb_codepoint_t      unicode,\n+                                                                                 void               *user_data);\n+typedef hb_codepoint_t                  (*hb_unicode_mirroring_func_t)          (hb_unicode_funcs_t *ufuncs,\n+                                                                                 hb_codepoint_t      unicode,\n+                                                                                 void               *user_data);\n+typedef hb_script_t                     (*hb_unicode_script_func_t)             (hb_unicode_funcs_t *ufuncs,\n+                                                                                 hb_codepoint_t      unicode,\n+                                                                                 void               *user_data);\n+\n+typedef hb_bool_t                       (*hb_unicode_compose_func_t)            (hb_unicode_funcs_t *ufuncs,\n+                                                                                 hb_codepoint_t      a,\n+                                                                                 hb_codepoint_t      b,\n+                                                                                 hb_codepoint_t     *ab,\n+                                                                                 void               *user_data);\n+typedef hb_bool_t                       (*hb_unicode_decompose_func_t)          (hb_unicode_funcs_t *ufuncs,\n+                                                                                 hb_codepoint_t      ab,\n+                                                                                 hb_codepoint_t     *a,\n+                                                                                 hb_codepoint_t     *b,\n+                                                                                 void               *user_data);\n+\n+\/* setters *\/\n+\n+\/**\n+ * hb_unicode_funcs_set_combining_class_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_unicode_funcs_set_combining_class_func (hb_unicode_funcs_t *ufuncs,\n+                                           hb_unicode_combining_class_func_t func,\n+                                           void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_unicode_funcs_set_general_category_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_unicode_funcs_set_general_category_func (hb_unicode_funcs_t *ufuncs,\n+                                            hb_unicode_general_category_func_t func,\n+                                            void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_unicode_funcs_set_mirroring_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_unicode_funcs_set_mirroring_func (hb_unicode_funcs_t *ufuncs,\n+                                     hb_unicode_mirroring_func_t func,\n+                                     void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_unicode_funcs_set_script_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_unicode_funcs_set_script_func (hb_unicode_funcs_t *ufuncs,\n+                                  hb_unicode_script_func_t func,\n+                                  void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_unicode_funcs_set_compose_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_unicode_funcs_set_compose_func (hb_unicode_funcs_t *ufuncs,\n+                                   hb_unicode_compose_func_t func,\n+                                   void *user_data, hb_destroy_func_t destroy);\n+\n+\/**\n+ * hb_unicode_funcs_set_decompose_func:\n+ * @ufuncs: a Unicode function structure\n+ * @func: (closure user_data) (destroy destroy) (scope notified):\n+ * @user_data:\n+ * @destroy:\n+ *\n+ *\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN void\n+hb_unicode_funcs_set_decompose_func (hb_unicode_funcs_t *ufuncs,\n+                                     hb_unicode_decompose_func_t func,\n+                                     void *user_data, hb_destroy_func_t destroy);\n+\n+\/* accessors *\/\n+\n+\/**\n+ * hb_unicode_combining_class:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN hb_unicode_combining_class_t\n+hb_unicode_combining_class (hb_unicode_funcs_t *ufuncs,\n+                            hb_codepoint_t unicode);\n+\n+\/**\n+ * hb_unicode_general_category:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN hb_unicode_general_category_t\n+hb_unicode_general_category (hb_unicode_funcs_t *ufuncs,\n+                             hb_codepoint_t unicode);\n+\n+\/**\n+ * hb_unicode_mirroring:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN hb_codepoint_t\n+hb_unicode_mirroring (hb_unicode_funcs_t *ufuncs,\n+                      hb_codepoint_t unicode);\n+\n+\/**\n+ * hb_unicode_script:\n+ *\n+ * Since: 0.9.2\n+ **\/\n+HB_EXTERN hb_script_t\n+hb_unicode_script (hb_unicode_funcs_t *ufuncs,\n+                   hb_codepoint_t unicode);\n+\n+HB_EXTERN hb_bool_t\n+hb_unicode_compose (hb_unicode_funcs_t *ufuncs,\n+                    hb_codepoint_t      a,\n+                    hb_codepoint_t      b,\n+                    hb_codepoint_t     *ab);\n+\n+HB_EXTERN hb_bool_t\n+hb_unicode_decompose (hb_unicode_funcs_t *ufuncs,\n+                      hb_codepoint_t      ab,\n+                      hb_codepoint_t     *a,\n+                      hb_codepoint_t     *b);\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_UNICODE_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-unicode.h","additions":404,"deletions":0,"binary":false,"changes":404,"status":"added"},{"patch":"@@ -0,0 +1,394 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ * Copyright © 2011  Codethink Limited\n+ * Copyright © 2010,2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Codethink Author(s): Ryan Lortie\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_UNICODE_HH\n+#define HB_UNICODE_HH\n+\n+#include \"hb.hh\"\n+\n+\n+extern HB_INTERNAL const uint8_t _hb_modified_combining_class[256];\n+\n+\/*\n+ * hb_unicode_funcs_t\n+ *\/\n+\n+#define HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS \\\n+  HB_UNICODE_FUNC_IMPLEMENT (combining_class) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (eastasian_width) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (general_category) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (mirroring) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (script) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (compose) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (decompose) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (decompose_compatibility) \\\n+  \/* ^--- Add new callbacks here *\/\n+\n+\/* Simple callbacks are those taking a hb_codepoint_t and returning a hb_codepoint_t *\/\n+#define HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE \\\n+  HB_UNICODE_FUNC_IMPLEMENT (hb_unicode_combining_class_t, combining_class) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (unsigned int, eastasian_width) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (hb_unicode_general_category_t, general_category) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (hb_codepoint_t, mirroring) \\\n+  HB_UNICODE_FUNC_IMPLEMENT (hb_script_t, script) \\\n+  \/* ^--- Add new simple callbacks here *\/\n+\n+struct hb_unicode_funcs_t\n+{\n+  hb_object_header_t header;\n+\n+  hb_unicode_funcs_t *parent;\n+\n+#define HB_UNICODE_FUNC_IMPLEMENT(return_type, name) \\\n+  return_type name (hb_codepoint_t unicode) { return func.name (this, unicode, user_data.name); }\n+HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS_SIMPLE\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+\n+  hb_bool_t compose (hb_codepoint_t a, hb_codepoint_t b,\n+                     hb_codepoint_t *ab)\n+  {\n+    *ab = 0;\n+    if (unlikely (!a || !b)) return false;\n+    return func.compose (this, a, b, ab, user_data.compose);\n+  }\n+\n+  hb_bool_t decompose (hb_codepoint_t ab,\n+                       hb_codepoint_t *a, hb_codepoint_t *b)\n+  {\n+    *a = ab; *b = 0;\n+    return func.decompose (this, ab, a, b, user_data.decompose);\n+  }\n+\n+  unsigned int decompose_compatibility (hb_codepoint_t  u,\n+                                        hb_codepoint_t *decomposed)\n+  {\n+    unsigned int ret = func.decompose_compatibility (this, u, decomposed, user_data.decompose_compatibility);\n+    if (ret == 1 && u == decomposed[0]) {\n+      decomposed[0] = 0;\n+      return 0;\n+    }\n+    decomposed[ret] = 0;\n+    return ret;\n+  }\n+\n+  unsigned int\n+  modified_combining_class (hb_codepoint_t u)\n+  {\n+    \/* XXX This hack belongs to the Myanmar shaper. *\/\n+    if (unlikely (u == 0x1037u)) u = 0x103Au;\n+\n+    \/* XXX This hack belongs to the USE shaper (for Tai Tham):\n+     * Reorder SAKOT to ensure it comes after any tone marks. *\/\n+    if (unlikely (u == 0x1A60u)) return 254;\n+\n+    \/* XXX This hack belongs to the Tibetan shaper:\n+     * Reorder PADMA to ensure it comes after any vowel marks. *\/\n+    if (unlikely (u == 0x0FC6u)) return 254;\n+    \/* Reorder TSA -PHRU to reorder before U+0F74 *\/\n+    if (unlikely (u == 0x0F39u)) return 127;\n+\n+    return _hb_modified_combining_class[combining_class (u)];\n+  }\n+\n+  static hb_bool_t\n+  is_variation_selector (hb_codepoint_t unicode)\n+  {\n+    \/* U+180B..180D MONGOLIAN FREE VARIATION SELECTORs are handled in the\n+     * Arabic shaper.  No need to match them here. *\/\n+    return unlikely (hb_in_ranges<hb_codepoint_t> (unicode,\n+                                                   0xFE00u, 0xFE0Fu, \/* VARIATION SELECTOR-1..16 *\/\n+                                                   0xE0100u, 0xE01EFu));  \/* VARIATION SELECTOR-17..256 *\/\n+  }\n+\n+  \/* Default_Ignorable codepoints:\n+   *\n+   * Note: While U+115F, U+1160, U+3164 and U+FFA0 are Default_Ignorable,\n+   * we do NOT want to hide them, as the way Uniscribe has implemented them\n+   * is with regular spacing glyphs, and that's the way fonts are made to work.\n+   * As such, we make exceptions for those four.\n+   * Also ignoring U+1BCA0..1BCA3. https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/503\n+   *\n+   * Unicode 7.0:\n+   * $ grep '; Default_Ignorable_Code_Point ' DerivedCoreProperties.txt | sed 's\/;.*#\/#\/'\n+   * 00AD          # Cf       SOFT HYPHEN\n+   * 034F          # Mn       COMBINING GRAPHEME JOINER\n+   * 061C          # Cf       ARABIC LETTER MARK\n+   * 115F..1160    # Lo   [2] HANGUL CHOSEONG FILLER..HANGUL JUNGSEONG FILLER\n+   * 17B4..17B5    # Mn   [2] KHMER VOWEL INHERENT AQ..KHMER VOWEL INHERENT AA\n+   * 180B..180D    # Mn   [3] MONGOLIAN FREE VARIATION SELECTOR ONE..MONGOLIAN FREE VARIATION SELECTOR THREE\n+   * 180E          # Cf       MONGOLIAN VOWEL SEPARATOR\n+   * 200B..200F    # Cf   [5] ZERO WIDTH SPACE..RIGHT-TO-LEFT MARK\n+   * 202A..202E    # Cf   [5] LEFT-TO-RIGHT EMBEDDING..RIGHT-TO-LEFT OVERRIDE\n+   * 2060..2064    # Cf   [5] WORD JOINER..INVISIBLE PLUS\n+   * 2065          # Cn       <reserved-2065>\n+   * 2066..206F    # Cf  [10] LEFT-TO-RIGHT ISOLATE..NOMINAL DIGIT SHAPES\n+   * 3164          # Lo       HANGUL FILLER\n+   * FE00..FE0F    # Mn  [16] VARIATION SELECTOR-1..VARIATION SELECTOR-16\n+   * FEFF          # Cf       ZERO WIDTH NO-BREAK SPACE\n+   * FFA0          # Lo       HALFWIDTH HANGUL FILLER\n+   * FFF0..FFF8    # Cn   [9] <reserved-FFF0>..<reserved-FFF8>\n+   * 1BCA0..1BCA3  # Cf   [4] SHORTHAND FORMAT LETTER OVERLAP..SHORTHAND FORMAT UP STEP\n+   * 1D173..1D17A  # Cf   [8] MUSICAL SYMBOL BEGIN BEAM..MUSICAL SYMBOL END PHRASE\n+   * E0000         # Cn       <reserved-E0000>\n+   * E0001         # Cf       LANGUAGE TAG\n+   * E0002..E001F  # Cn  [30] <reserved-E0002>..<reserved-E001F>\n+   * E0020..E007F  # Cf  [96] TAG SPACE..CANCEL TAG\n+   * E0080..E00FF  # Cn [128] <reserved-E0080>..<reserved-E00FF>\n+   * E0100..E01EF  # Mn [240] VARIATION SELECTOR-17..VARIATION SELECTOR-256\n+   * E01F0..E0FFF  # Cn [3600] <reserved-E01F0>..<reserved-E0FFF>\n+   *\/\n+  static hb_bool_t\n+  is_default_ignorable (hb_codepoint_t ch)\n+  {\n+    hb_codepoint_t plane = ch >> 16;\n+    if (likely (plane == 0))\n+    {\n+      \/* BMP *\/\n+      hb_codepoint_t page = ch >> 8;\n+      switch (page) {\n+        case 0x00: return unlikely (ch == 0x00ADu);\n+        case 0x03: return unlikely (ch == 0x034Fu);\n+        case 0x06: return unlikely (ch == 0x061Cu);\n+        case 0x17: return hb_in_range<hb_codepoint_t> (ch, 0x17B4u, 0x17B5u);\n+        case 0x18: return hb_in_range<hb_codepoint_t> (ch, 0x180Bu, 0x180Eu);\n+        case 0x20: return hb_in_ranges<hb_codepoint_t> (ch, 0x200Bu, 0x200Fu,\n+                                            0x202Au, 0x202Eu,\n+                                            0x2060u, 0x206Fu);\n+        case 0xFE: return hb_in_range<hb_codepoint_t> (ch, 0xFE00u, 0xFE0Fu) || ch == 0xFEFFu;\n+        case 0xFF: return hb_in_range<hb_codepoint_t> (ch, 0xFFF0u, 0xFFF8u);\n+        default: return false;\n+      }\n+    }\n+    else\n+    {\n+      \/* Other planes *\/\n+      switch (plane) {\n+        case 0x01: return hb_in_range<hb_codepoint_t> (ch, 0x1D173u, 0x1D17Au);\n+        case 0x0E: return hb_in_range<hb_codepoint_t> (ch, 0xE0000u, 0xE0FFFu);\n+        default: return false;\n+      }\n+    }\n+  }\n+\n+  \/* Space estimates based on:\n+   * https:\/\/unicode.org\/charts\/PDF\/U2000.pdf\n+   * https:\/\/docs.microsoft.com\/en-us\/typography\/develop\/character-design-standards\/whitespace\n+   *\/\n+  enum space_t {\n+    NOT_SPACE = 0,\n+    SPACE_EM   = 1,\n+    SPACE_EM_2 = 2,\n+    SPACE_EM_3 = 3,\n+    SPACE_EM_4 = 4,\n+    SPACE_EM_5 = 5,\n+    SPACE_EM_6 = 6,\n+    SPACE_EM_16 = 16,\n+    SPACE_4_EM_18,      \/* 4\/18th of an EM! *\/\n+    SPACE,\n+    SPACE_FIGURE,\n+    SPACE_PUNCTUATION,\n+    SPACE_NARROW,\n+  };\n+  static space_t\n+  space_fallback_type (hb_codepoint_t u)\n+  {\n+    switch (u)\n+    {\n+      \/* All GC=Zs chars that can use a fallback. *\/\n+      default:      return NOT_SPACE;   \/* U+1680 OGHAM SPACE MARK *\/\n+      case 0x0020u: return SPACE;       \/* U+0020 SPACE *\/\n+      case 0x00A0u: return SPACE;       \/* U+00A0 NO-BREAK SPACE *\/\n+      case 0x2000u: return SPACE_EM_2;  \/* U+2000 EN QUAD *\/\n+      case 0x2001u: return SPACE_EM;    \/* U+2001 EM QUAD *\/\n+      case 0x2002u: return SPACE_EM_2;  \/* U+2002 EN SPACE *\/\n+      case 0x2003u: return SPACE_EM;    \/* U+2003 EM SPACE *\/\n+      case 0x2004u: return SPACE_EM_3;  \/* U+2004 THREE-PER-EM SPACE *\/\n+      case 0x2005u: return SPACE_EM_4;  \/* U+2005 FOUR-PER-EM SPACE *\/\n+      case 0x2006u: return SPACE_EM_6;  \/* U+2006 SIX-PER-EM SPACE *\/\n+      case 0x2007u: return SPACE_FIGURE;        \/* U+2007 FIGURE SPACE *\/\n+      case 0x2008u: return SPACE_PUNCTUATION;   \/* U+2008 PUNCTUATION SPACE *\/\n+      case 0x2009u: return SPACE_EM_5;          \/* U+2009 THIN SPACE *\/\n+      case 0x200Au: return SPACE_EM_16;         \/* U+200A HAIR SPACE *\/\n+      case 0x202Fu: return SPACE_NARROW;        \/* U+202F NARROW NO-BREAK SPACE *\/\n+      case 0x205Fu: return SPACE_4_EM_18;       \/* U+205F MEDIUM MATHEMATICAL SPACE *\/\n+      case 0x3000u: return SPACE_EM;            \/* U+3000 IDEOGRAPHIC SPACE *\/\n+    }\n+  }\n+\n+  struct {\n+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_unicode_##name##_func_t name;\n+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+  } func;\n+\n+  struct {\n+#define HB_UNICODE_FUNC_IMPLEMENT(name) void *name;\n+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+  } user_data;\n+\n+  struct {\n+#define HB_UNICODE_FUNC_IMPLEMENT(name) hb_destroy_func_t name;\n+    HB_UNICODE_FUNCS_IMPLEMENT_CALLBACKS\n+#undef HB_UNICODE_FUNC_IMPLEMENT\n+  } destroy;\n+};\n+DECLARE_NULL_INSTANCE (hb_unicode_funcs_t);\n+\n+\n+\/*\n+ * Modified combining marks\n+ *\/\n+\n+\/* Hebrew\n+ *\n+ * We permute the \"fixed-position\" classes 10-26 into the order\n+ * described in the SBL Hebrew manual:\n+ *\n+ * https:\/\/www.sbl-site.org\/Fonts\/SBLHebrewUserManual1.5x.pdf\n+ *\n+ * (as recommended by:\n+ *  https:\/\/forum.fontlab.com\/archive-old-microsoft-volt-group\/vista-and-diacritic-ordering\/msg22823\/)\n+ *\n+ * More details here:\n+ * https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=662055\n+ *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC10 22 \/* sheva *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC11 15 \/* hataf segol *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC12 16 \/* hataf patah *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC13 17 \/* hataf qamats *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC14 23 \/* hiriq *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC15 18 \/* tsere *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC16 19 \/* segol *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC17 20 \/* patah *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC18 21 \/* qamats *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC19 14 \/* holam *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC20 24 \/* qubuts *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC21 12 \/* dagesh *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC22 25 \/* meteg *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC23 13 \/* rafe *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC24 10 \/* shin dot *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC25 11 \/* sin dot *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC26 26 \/* point varika *\/\n+\n+\/*\n+ * Arabic\n+ *\n+ * Modify to move Shadda (ccc=33) before other marks.  See:\n+ * https:\/\/unicode.org\/faq\/normalization.html#8\n+ * https:\/\/unicode.org\/faq\/normalization.html#9\n+ *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC27 28 \/* fathatan *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC28 29 \/* dammatan *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC29 30 \/* kasratan *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC30 31 \/* fatha *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC31 32 \/* damma *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC32 33 \/* kasra *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC33 27 \/* shadda *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC34 34 \/* sukun *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC35 35 \/* superscript alef *\/\n+\n+\/* Syriac *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC36 36 \/* superscript alaph *\/\n+\n+\/* Telugu\n+ *\n+ * Modify Telugu length marks (ccc=84, ccc=91).\n+ * These are the only matras in the main Indic scripts range that have\n+ * a non-zero ccc.  That makes them reorder with the Halant that is\n+ * ccc=9.  Just zero them, we don't need them in our Indic shaper.\n+ *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC84 0 \/* length mark *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC91 0 \/* ai length mark *\/\n+\n+\/* Thai\n+ *\n+ * Modify U+0E38 and U+0E39 (ccc=103) to be reordered before U+0E3A (ccc=9).\n+ * Assign 3, which is unassigned otherwise.\n+ * Uniscribe does this reordering too.\n+ *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC103 3 \/* sara u \/ sara uu *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC107 107 \/* mai * *\/\n+\n+\/* Lao *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC118 118 \/* sign u \/ sign uu *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC122 122 \/* mai * *\/\n+\n+\/* Tibetan\n+ *\n+ * In case of multiple vowel-signs, use u first (but after achung)\n+ * this allows Dzongkha multi-vowel shortcuts to render correctly\n+ *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC129 129 \/* sign aa *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC130 132 \/* sign i *\/\n+#define HB_MODIFIED_COMBINING_CLASS_CCC132 131 \/* sign u *\/\n+\n+\/* Misc *\/\n+\n+#define HB_UNICODE_GENERAL_CATEGORY_IS_MARK(gen_cat) \\\n+        (FLAG_UNSAFE (gen_cat) & \\\n+         (FLAG (HB_UNICODE_GENERAL_CATEGORY_SPACING_MARK) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_ENCLOSING_MARK) | \\\n+          FLAG (HB_UNICODE_GENERAL_CATEGORY_NON_SPACING_MARK)))\n+\n+\n+\/*\n+ * Ranges, used for bsearch tables.\n+ *\/\n+\n+struct hb_unicode_range_t\n+{\n+  static int\n+  cmp (const void *_key, const void *_item)\n+  {\n+    hb_codepoint_t cp = *((hb_codepoint_t *) _key);\n+    const hb_unicode_range_t *range = (hb_unicode_range_t *) _item;\n+\n+    if (cp < range->start)\n+      return -1;\n+    else if (cp <= range->end)\n+      return 0;\n+    else\n+      return +1;\n+  }\n+\n+  hb_codepoint_t start;\n+  hb_codepoint_t end;\n+};\n+\n+\/*\n+ * Emoji.\n+ *\/\n+\n+HB_INTERNAL bool\n+_hb_unicode_is_emoji_Extended_Pictographic (hb_codepoint_t cp);\n+\n+\n+#endif \/* HB_UNICODE_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-unicode.hh","additions":394,"deletions":0,"binary":false,"changes":394,"status":"added"},{"patch":"","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-utf.hh","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-utf.hh","status":"copied"},{"patch":"@@ -0,0 +1,260 @@\n+\/*\n+ * Copyright © 2017,2018  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_VECTOR_HH\n+#define HB_VECTOR_HH\n+\n+#include \"hb.hh\"\n+#include \"hb-array.hh\"\n+#include \"hb-null.hh\"\n+\n+\n+template <typename Type>\n+struct hb_vector_t\n+{\n+  typedef Type item_t;\n+  static constexpr unsigned item_size = hb_static_size (Type);\n+\n+  HB_NO_COPY_ASSIGN_TEMPLATE (hb_vector_t, Type);\n+  hb_vector_t ()  { init (); }\n+  ~hb_vector_t () { fini (); }\n+\n+  unsigned int length;\n+  private:\n+  int allocated; \/* == -1 means allocation failed. *\/\n+  Type *arrayZ_;\n+  public:\n+\n+  void init ()\n+  {\n+    allocated = length = 0;\n+    arrayZ_ = nullptr;\n+  }\n+\n+  void fini ()\n+  {\n+    if (arrayZ_)\n+      free (arrayZ_);\n+    init ();\n+  }\n+  void fini_deep ()\n+  {\n+    Type *array = arrayZ();\n+    unsigned int count = length;\n+    for (unsigned int i = 0; i < count; i++)\n+      array[i].fini ();\n+    fini ();\n+  }\n+\n+  const Type * arrayZ () const { return arrayZ_; }\n+        Type * arrayZ ()       { return arrayZ_; }\n+\n+  Type& operator [] (int i_)\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= length))\n+      return Crap (Type);\n+    return arrayZ()[i];\n+  }\n+  const Type& operator [] (int i_) const\n+  {\n+    unsigned int i = (unsigned int) i_;\n+    if (unlikely (i >= length))\n+      return Null(Type);\n+    return arrayZ()[i];\n+  }\n+\n+  explicit_operator bool () const { return length; }\n+\n+  hb_array_t<Type> as_array ()\n+  { return hb_array (arrayZ(), length); }\n+  hb_array_t<const Type> as_array () const\n+  { return hb_array (arrayZ(), length); }\n+\n+  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int count) const\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<const Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int count)\n+  { return as_array ().sub_array (start_offset, count);}\n+  hb_array_t<Type> sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n+  { return as_array ().sub_array (start_offset, count);}\n+\n+  hb_sorted_array_t<Type> as_sorted_array ()\n+  { return hb_sorted_array (arrayZ(), length); }\n+  hb_sorted_array_t<const Type> as_sorted_array () const\n+  { return hb_sorted_array (arrayZ(), length); }\n+\n+  hb_array_t<const Type> sorted_sub_array (unsigned int start_offset, unsigned int count) const\n+  { return as_sorted_array ().sorted_sub_array (start_offset, count);}\n+  hb_array_t<const Type> sorted_sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/) const\n+  { return as_sorted_array ().sorted_sub_array (start_offset, count);}\n+  hb_array_t<Type> sorted_sub_array (unsigned int start_offset, unsigned int count)\n+  { return as_sorted_array ().sorted_sub_array (start_offset, count);}\n+  hb_array_t<Type> sorted_sub_array (unsigned int start_offset, unsigned int *count = nullptr \/* IN\/OUT *\/)\n+  { return as_sorted_array ().sorted_sub_array (start_offset, count);}\n+\n+  template <typename T> explicit_operator T * () { return arrayZ(); }\n+  template <typename T> explicit_operator const T * () const { return arrayZ(); }\n+  operator hb_array_t<Type> ()             { return as_array (); }\n+  operator hb_array_t<const Type> () const { return as_array (); }\n+\n+  Type * operator  + (unsigned int i) { return arrayZ() + i; }\n+  const Type * operator  + (unsigned int i) const { return arrayZ() + i; }\n+\n+  Type *push ()\n+  {\n+    if (unlikely (!resize (length + 1)))\n+      return &Crap(Type);\n+    return &arrayZ()[length - 1];\n+  }\n+  Type *push (const Type& v)\n+  {\n+    Type *p = push ();\n+    *p = v;\n+    return p;\n+  }\n+\n+  bool in_error () const { return allocated < 0; }\n+\n+  \/* Allocate for size but don't adjust length. *\/\n+  bool alloc (unsigned int size)\n+  {\n+    if (unlikely (allocated < 0))\n+      return false;\n+\n+    if (likely (size <= (unsigned) allocated))\n+      return true;\n+\n+    \/* Reallocate *\/\n+\n+    unsigned int new_allocated = allocated;\n+    while (size >= new_allocated)\n+      new_allocated += (new_allocated >> 1) + 8;\n+\n+    Type *new_array = nullptr;\n+    bool overflows =\n+      (int) new_allocated < 0 ||\n+      (new_allocated < (unsigned) allocated) ||\n+      hb_unsigned_mul_overflows (new_allocated, sizeof (Type));\n+    if (likely (!overflows))\n+      new_array = (Type *) realloc (arrayZ_, new_allocated * sizeof (Type));\n+\n+    if (unlikely (!new_array))\n+    {\n+      allocated = -1;\n+      return false;\n+    }\n+\n+    arrayZ_ = new_array;\n+    allocated = new_allocated;\n+\n+    return true;\n+  }\n+\n+  bool resize (int size_)\n+  {\n+    unsigned int size = size_ < 0 ? 0u : (unsigned int) size_;\n+    if (!alloc (size))\n+      return false;\n+\n+    if (size > length)\n+      memset (arrayZ() + length, 0, (size - length) * sizeof (*arrayZ()));\n+\n+    length = size;\n+    return true;\n+  }\n+\n+  void pop ()\n+  {\n+    if (!length) return;\n+    length--;\n+  }\n+\n+  void remove (unsigned int i)\n+  {\n+    if (unlikely (i >= length))\n+      return;\n+    Type *array = arrayZ();\n+    memmove (static_cast<void *> (&array[i]),\n+             static_cast<void *> (&array[i + 1]),\n+             (length - i - 1) * sizeof (Type));\n+    length--;\n+  }\n+\n+  void shrink (int size_)\n+  {\n+    unsigned int size = size_ < 0 ? 0u : (unsigned int) size_;\n+     if (size < length)\n+       length = size;\n+  }\n+\n+  template <typename T>\n+  Type *find (T v)\n+  {\n+    Type *array = arrayZ();\n+    for (unsigned int i = 0; i < length; i++)\n+      if (array[i] == v)\n+        return &array[i];\n+    return nullptr;\n+  }\n+  template <typename T>\n+  const Type *find (T v) const\n+  {\n+    const Type *array = arrayZ();\n+    for (unsigned int i = 0; i < length; i++)\n+      if (array[i] == v)\n+        return &array[i];\n+    return nullptr;\n+  }\n+\n+  void qsort (int (*cmp)(const void*, const void*))\n+  { as_array ().qsort (cmp); }\n+  void qsort (unsigned int start = 0, unsigned int end = (unsigned int) -1)\n+  { as_array ().qsort (start, end); }\n+\n+  template <typename T>\n+  Type *lsearch (const T &x, Type *not_found = nullptr)\n+  { return as_array ().lsearch (x, not_found); }\n+  template <typename T>\n+  const Type *lsearch (const T &x, const Type *not_found = nullptr) const\n+  { return as_array ().lsearch (x, not_found); }\n+\n+  template <typename T>\n+  Type *bsearch (const T &x, Type *not_found = nullptr)\n+  { return as_sorted_array ().bsearch (x, not_found); }\n+  template <typename T>\n+  const Type *bsearch (const T &x, const Type *not_found = nullptr) const\n+  { return as_sorted_array ().bsearch (x, not_found); }\n+  template <typename T>\n+  bool bfind (const T &x, unsigned int *i = nullptr,\n+                     hb_bfind_not_found_t not_found = HB_BFIND_NOT_FOUND_DONT_STORE,\n+                     unsigned int to_store = (unsigned int) -1) const\n+  { return as_sorted_array ().bfind (x, i, not_found, to_store); }\n+};\n+\n+\n+#endif \/* HB_VECTOR_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-vector.hh","additions":260,"deletions":0,"binary":false,"changes":260,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright © 2011  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H_IN\n+#error \"Include <hb.h> instead.\"\n+#endif\n+\n+#ifndef HB_VERSION_H\n+#define HB_VERSION_H\n+\n+#include \"hb-common.h\"\n+\n+HB_BEGIN_DECLS\n+\n+\n+#define HB_VERSION_MAJOR 2\n+#define HB_VERSION_MINOR 3\n+#define HB_VERSION_MICRO 1\n+\n+#define HB_VERSION_STRING \"2.3.1\"\n+\n+#define HB_VERSION_ATLEAST(major,minor,micro) \\\n+        ((major)*10000+(minor)*100+(micro) <= \\\n+         HB_VERSION_MAJOR*10000+HB_VERSION_MINOR*100+HB_VERSION_MICRO)\n+\n+\n+HB_EXTERN void\n+hb_version (unsigned int *major,\n+            unsigned int *minor,\n+            unsigned int *micro);\n+\n+HB_EXTERN const char *\n+hb_version_string (void);\n+\n+HB_EXTERN hb_bool_t\n+hb_version_atleast (unsigned int major,\n+                    unsigned int minor,\n+                    unsigned int micro);\n+\n+\n+HB_END_DECLS\n+\n+#endif \/* HB_VERSION_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-version.h","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright © 2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#include \"hb.hh\"\n+\n+#if defined(HB_ATOMIC_INT_NIL)\n+#error \"Could not find any system to define atomic_int macros, library WILL NOT be thread-safe\"\n+#error \"Check hb-atomic.hh for possible resolutions.\"\n+#endif\n+\n+#if defined(HB_MUTEX_IMPL_NIL)\n+#error \"Could not find any system to define mutex macros, library WILL NOT be thread-safe\"\n+#error \"Check hb-mutex.hh for possible resolutions.\"\n+#endif\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb-warning.cc","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,48 @@\n+\/*\n+ * Copyright © 2009  Red Hat, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_H\n+#define HB_H\n+#define HB_H_IN\n+\n+#include \"hb-blob.h\"\n+#include \"hb-buffer.h\"\n+#include \"hb-common.h\"\n+#include \"hb-deprecated.h\"\n+#include \"hb-face.h\"\n+#include \"hb-font.h\"\n+#include \"hb-map.h\"\n+#include \"hb-set.h\"\n+#include \"hb-shape.h\"\n+#include \"hb-shape-plan.h\"\n+#include \"hb-unicode.h\"\n+#include \"hb-version.h\"\n+\n+HB_BEGIN_DECLS\n+HB_END_DECLS\n+\n+#undef HB_H_IN\n+#endif \/* HB_H *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb.h","additions":48,"deletions":0,"binary":false,"changes":48,"status":"added"},{"patch":"@@ -0,0 +1,658 @@\n+\/*\n+ * Copyright © 2007,2008,2009  Red Hat, Inc.\n+ * Copyright © 2011,2012  Google, Inc.\n+ *\n+ *  This is part of HarfBuzz, a text shaping library.\n+ *\n+ * Permission is hereby granted, without written agreement and without\n+ * license or royalty fees, to use, copy, modify, and distribute this\n+ * software and its documentation for any purpose, provided that the\n+ * above copyright notice and the following two paragraphs appear in\n+ * all copies of this software.\n+ *\n+ * IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE TO ANY PARTY FOR\n+ * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES\n+ * ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN\n+ * IF THE COPYRIGHT HOLDER HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH\n+ * DAMAGE.\n+ *\n+ * THE COPYRIGHT HOLDER SPECIFICALLY DISCLAIMS ANY WARRANTIES, INCLUDING,\n+ * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n+ * FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS\n+ * ON AN \"AS IS\" BASIS, AND THE COPYRIGHT HOLDER HAS NO OBLIGATION TO\n+ * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.\n+ *\n+ * Red Hat Author(s): Behdad Esfahbod\n+ * Google Author(s): Behdad Esfahbod\n+ *\/\n+\n+#ifndef HB_HH\n+#define HB_HH\n+\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC\n+#if defined(_MSC_VER)\n+#pragma warning( disable: 4068 ) \/* Unknown pragma *\/\n+#endif\n+#if defined(__GNUC__) || defined(__clang__)\n+\/* Rules:\n+ *\n+ * - All pragmas are declared GCC even if they are clang ones.  Otherwise GCC\n+ *   nags, even though we instruct it to ignore -Wunknown-pragmas. ¯\\_(ツ)_\/¯\n+ *\n+ * - Within each category, keep sorted.\n+ *\n+ * - Warnings whose scope can be expanded in future compiler versions shall\n+ *   be declared as \"warning\".  Otherwise, either ignored or error.\n+ *\/\n+\n+\/* Setup.  Don't sort order within this category. *\/\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_WARNING\n+#pragma GCC diagnostic warning \"-Wall\"\n+#pragma GCC diagnostic warning \"-Wextra\"\n+#endif\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_IGNORED\n+#pragma GCC diagnostic ignored \"-Wpragmas\"\n+#pragma GCC diagnostic ignored \"-Wunknown-pragmas\"\n+#pragma GCC diagnostic ignored \"-Wunknown-warning-option\"\n+#endif\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_WARNING\n+\/\/#pragma GCC diagnostic warning \"-Weverything\"\n+#endif\n+\n+\/* Error.  Should never happen. *\/\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_ERROR\n+#pragma GCC diagnostic error   \"-Wc++11-narrowing\"\n+#pragma GCC diagnostic error   \"-Wcast-align\"\n+#pragma GCC diagnostic error   \"-Wcast-function-type\"\n+#pragma GCC diagnostic error   \"-Wdelete-non-virtual-dtor\"\n+#pragma GCC diagnostic error   \"-Wformat-security\"\n+#pragma GCC diagnostic error   \"-Wimplicit-function-declaration\"\n+#pragma GCC diagnostic error   \"-Winit-self\"\n+#pragma GCC diagnostic error   \"-Wmissing-braces\"\n+#pragma GCC diagnostic error   \"-Wmissing-declarations\"\n+#pragma GCC diagnostic error   \"-Wmissing-prototypes\"\n+#pragma GCC diagnostic error   \"-Wnested-externs\"\n+#pragma GCC diagnostic error   \"-Wold-style-definition\"\n+#pragma GCC diagnostic error   \"-Wpointer-arith\"\n+#pragma GCC diagnostic error   \"-Wredundant-decls\"\n+#pragma GCC diagnostic error   \"-Wreorder\"\n+#pragma GCC diagnostic error   \"-Wsign-compare\"\n+#pragma GCC diagnostic error   \"-Wstrict-prototypes\"\n+#pragma GCC diagnostic error   \"-Wstring-conversion\"\n+#pragma GCC diagnostic error   \"-Wswitch-enum\"\n+#pragma GCC diagnostic error   \"-Wtautological-overlap-compare\"\n+#pragma GCC diagnostic error   \"-Wunneeded-internal-declaration\"\n+#pragma GCC diagnostic error   \"-Wunused\"\n+#pragma GCC diagnostic error   \"-Wunused-local-typedefs\"\n+#pragma GCC diagnostic error   \"-Wunused-value\"\n+#pragma GCC diagnostic error   \"-Wunused-variable\"\n+#pragma GCC diagnostic error   \"-Wvla\"\n+#pragma GCC diagnostic error   \"-Wwrite-strings\"\n+#endif\n+\n+\/* Warning.  To be investigated if happens. *\/\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_WARNING\n+#pragma GCC diagnostic warning \"-Wbuiltin-macro-redefined\"\n+#pragma GCC diagnostic warning \"-Wdisabled-optimization\"\n+#pragma GCC diagnostic warning \"-Wformat=2\"\n+#pragma GCC diagnostic warning \"-Wignored-pragma-optimize\"\n+#pragma GCC diagnostic warning \"-Wlogical-op\"\n+#pragma GCC diagnostic warning \"-Wmaybe-uninitialized\"\n+#pragma GCC diagnostic warning \"-Wmissing-format-attribute\"\n+#pragma GCC diagnostic warning \"-Wundef\"\n+#endif\n+\n+\/* Ignored currently, but should be fixed at some point. *\/\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_IGNORED\n+#pragma GCC diagnostic ignored \"-Wconversion\"                   \/\/ TODO fix\n+#pragma GCC diagnostic ignored \"-Wformat-signedness\"            \/\/ TODO fix\n+#pragma GCC diagnostic ignored \"-Wshadow\"                       \/\/ TODO fix\n+#pragma GCC diagnostic ignored \"-Wunsafe-loop-optimizations\"    \/\/ TODO fix\n+#pragma GCC diagnostic ignored \"-Wunused-parameter\"             \/\/ TODO fix\n+#endif\n+\n+\/* Ignored intentionally. *\/\n+#ifndef HB_NO_PRAGMA_GCC_DIAGNOSTIC_IGNORED\n+#pragma GCC diagnostic ignored \"-Wclass-memaccess\"\n+#pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n+#pragma GCC diagnostic ignored \"-Wformat-zero-length\"\n+#pragma GCC diagnostic ignored \"-Wmissing-field-initializers\"\n+#pragma GCC diagnostic ignored \"-Wpacked\" \/\/ Erratic impl in clang\n+#pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n+#pragma GCC diagnostic ignored \"-Wtype-limits\"\n+#endif\n+\n+#endif\n+#endif\n+\n+#ifdef HAVE_CONFIG_H\n+#include \"config.h\"\n+#endif\n+\n+\/*\n+ * Following added based on what AC_USE_SYSTEM_EXTENSIONS adds to\n+ * config.h.in.  Copied here for the convenience of those embedding\n+ * HarfBuzz and not using our build system.\n+ *\/\n+\/* Enable extensions on AIX 3, Interix.  *\/\n+#ifndef _ALL_SOURCE\n+# define _ALL_SOURCE 1\n+#endif\n+\/* Enable GNU extensions on systems that have them.  *\/\n+#ifndef _GNU_SOURCE\n+# define _GNU_SOURCE 1\n+#endif\n+\/* Enable threading extensions on Solaris.  *\/\n+#ifndef _POSIX_PTHREAD_SEMANTICS\n+# define _POSIX_PTHREAD_SEMANTICS 1\n+#endif\n+\/* Enable extensions on HP NonStop.  *\/\n+#ifndef _TANDEM_SOURCE\n+# define _TANDEM_SOURCE 1\n+#endif\n+\/* Enable general extensions on Solaris.  *\/\n+#ifndef __EXTENSIONS__\n+# define __EXTENSIONS__ 1\n+#endif\n+\n+#if defined (_MSC_VER) && defined (HB_DLL_EXPORT)\n+#define HB_EXTERN __declspec (dllexport) extern\n+#endif\n+\n+#include \"hb.h\"\n+#define HB_H_IN\n+#include \"hb-ot.h\"\n+#define HB_OT_H_IN\n+#include \"hb-aat.h\"\n+#define HB_AAT_H_IN\n+\n+#include \"hb-aat.h\"\n+\n+#include <math.h>\n+#include <stdlib.h>\n+#include <stddef.h>\n+#include <string.h>\n+#include <assert.h>\n+#include <errno.h>\n+#include <stdio.h>\n+#include <stdarg.h>\n+\n+#if (defined(_MSC_VER) && _MSC_VER >= 1500) || defined(__MINGW32__)\n+#include <intrin.h>\n+#endif\n+\n+#define HB_PASTE1(a,b) a##b\n+#define HB_PASTE(a,b) HB_PASTE1(a,b)\n+\n+\n+\/* Compile-time custom allocator support. *\/\n+\n+#if defined(hb_malloc_impl) \\\n+ && defined(hb_calloc_impl) \\\n+ && defined(hb_realloc_impl) \\\n+ && defined(hb_free_impl)\n+extern \"C\" void* hb_malloc_impl(size_t size);\n+extern \"C\" void* hb_calloc_impl(size_t nmemb, size_t size);\n+extern \"C\" void* hb_realloc_impl(void *ptr, size_t size);\n+extern \"C\" void  hb_free_impl(void *ptr);\n+#define malloc hb_malloc_impl\n+#define calloc hb_calloc_impl\n+#define realloc hb_realloc_impl\n+#define free hb_free_impl\n+\n+#if defined(hb_memalign_impl)\n+extern \"C\" int hb_memalign_impl(void **memptr, size_t alignment, size_t size);\n+#define posix_memalign hb_memalign_impl\n+#else\n+#undef HAVE_POSIX_MEMALIGN\n+#endif\n+\n+#endif\n+\n+\n+\/*\n+ * Compiler attributes\n+ *\/\n+\n+#if __cplusplus < 201103L\n+\n+#ifndef nullptr\n+#define nullptr NULL\n+#endif\n+\n+#ifndef constexpr\n+#define constexpr const\n+#endif\n+\n+#ifndef static_assert\n+#define static_assert(e, msg) \\\n+        HB_UNUSED typedef int HB_PASTE(static_assertion_failed_at_line_, __LINE__) [(e) ? 1 : -1]\n+#endif \/\/ static_assert\n+\n+#if defined(__GNUC__)\n+#if (__GNUC__ < 4 || (__GNUC__ == 4 && __GNUC_MINOR__ < 8))\n+#define thread_local __thread\n+#endif\n+#else\n+#define thread_local\n+#endif\n+\n+template <typename T>\n+struct _hb_alignof\n+{\n+  struct s\n+  {\n+    char c;\n+    T t;\n+  };\n+  static constexpr size_t value = offsetof (s, t);\n+};\n+#ifndef alignof\n+#define alignof(x) (_hb_alignof<x>::value)\n+#endif\n+\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1127 *\/\n+#ifndef explicit_operator\n+#define explicit_operator operator\n+#endif\n+\n+#else \/* __cplusplus >= 201103L *\/\n+\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1127 *\/\n+#ifndef explicit_operator\n+#define explicit_operator explicit operator\n+#endif\n+\n+#endif \/* __cplusplus < 201103L *\/\n+\n+\n+#if (defined(__GNUC__) || defined(__clang__)) && defined(__OPTIMIZE__)\n+#define likely(expr) (__builtin_expect (!!(expr), 1))\n+#define unlikely(expr) (__builtin_expect (!!(expr), 0))\n+#else\n+#define likely(expr) (expr)\n+#define unlikely(expr) (expr)\n+#endif\n+\n+#if !defined(__GNUC__) && !defined(__clang__)\n+#undef __attribute__\n+#define __attribute__(x)\n+#endif\n+\n+#if defined(__GNUC__) && (__GNUC__ >= 3)\n+#define HB_PURE_FUNC    __attribute__((pure))\n+#define HB_CONST_FUNC   __attribute__((const))\n+#define HB_PRINTF_FUNC(format_idx, arg_idx) __attribute__((__format__ (__printf__, format_idx, arg_idx)))\n+#else\n+#define HB_PURE_FUNC\n+#define HB_CONST_FUNC\n+#define HB_PRINTF_FUNC(format_idx, arg_idx)\n+#endif\n+#if defined(__GNUC__) && (__GNUC__ >= 4)\n+#define HB_UNUSED       __attribute__((unused))\n+#elif defined(_MSC_VER) \/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/635 *\/\n+#define HB_UNUSED __pragma(warning(suppress: 4100 4101))\n+#else\n+#define HB_UNUSED\n+#endif\n+\n+#ifndef HB_INTERNAL\n+# if !defined(HB_NO_VISIBILITY) && !defined(__MINGW32__) && !defined(__CYGWIN__) && !defined(_MSC_VER) && !defined(__SUNPRO_CC)\n+#  define HB_INTERNAL __attribute__((__visibility__(\"hidden\")))\n+# elif defined(__MINGW32__)\n+   \/* We use -export-symbols on mingw32, since it does not support visibility attributes. *\/\n+#  define HB_INTERNAL\n+# elif defined (_MSC_VER) && defined (HB_DLL_EXPORT)\n+   \/* We do not try to export internal symbols on Visual Studio *\/\n+#  define HB_INTERNAL\n+#else\n+#  define HB_INTERNAL\n+#  define HB_NO_VISIBILITY 1\n+# endif\n+#endif\n+\n+#if defined(__GNUC__) && (__GNUC__ >= 3)\n+#define HB_FUNC __PRETTY_FUNCTION__\n+#elif defined(_MSC_VER)\n+#define HB_FUNC __FUNCSIG__\n+#else\n+#define HB_FUNC __func__\n+#endif\n+\n+#if defined(__SUNPRO_CC) && (__SUNPRO_CC < 0x5140)\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/630 *\/\n+#define __restrict\n+#endif\n+\n+\/*\n+ * Borrowed from https:\/\/bugzilla.mozilla.org\/show_bug.cgi?id=1215411\n+ * HB_FALLTHROUGH is an annotation to suppress compiler warnings about switch\n+ * cases that fall through without a break or return statement. HB_FALLTHROUGH\n+ * is only needed on cases that have code:\n+ *\n+ * switch (foo) {\n+ *   case 1: \/\/ These cases have no code. No fallthrough annotations are needed.\n+ *   case 2:\n+ *   case 3:\n+ *     foo = 4; \/\/ This case has code, so a fallthrough annotation is needed:\n+ *     HB_FALLTHROUGH;\n+ *   default:\n+ *     return foo;\n+ * }\n+ *\/\n+#if defined(__clang__) && __cplusplus >= 201103L\n+   \/* clang's fallthrough annotations are only available starting in C++11. *\/\n+#  define HB_FALLTHROUGH [[clang::fallthrough]]\n+#elif defined(__GNUC__) && (__GNUC__ >= 7)\n+   \/* GNU fallthrough attribute is available from GCC7 *\/\n+#  define HB_FALLTHROUGH __attribute__((fallthrough))\n+#elif defined(_MSC_VER)\n+   \/*\n+    * MSVC's __fallthrough annotations are checked by \/analyze (Code Analysis):\n+    * https:\/\/msdn.microsoft.com\/en-us\/library\/ms235402%28VS.80%29.aspx\n+    *\/\n+#  include <sal.h>\n+#  define HB_FALLTHROUGH __fallthrough\n+#else\n+#  define HB_FALLTHROUGH \/* FALLTHROUGH *\/\n+#endif\n+\n+#if defined(__clang__)\n+\/* Disable certain sanitizer errors. *\/\n+\/* https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1247 *\/\n+#define HB_NO_SANITIZE_SIGNED_INTEGER_OVERFLOW __attribute__((no_sanitize(\"signed-integer-overflow\")))\n+#else\n+#define HB_NO_SANITIZE_SIGNED_INTEGER_OVERFLOW\n+#endif\n+\n+\n+#ifdef _WIN32\n+   \/* We need Windows Vista for both Uniscribe backend and for\n+    * MemoryBarrier.  We don't support compiling on Windows XP,\n+    * though we run on it fine. *\/\n+#  if defined(_WIN32_WINNT) && _WIN32_WINNT < 0x0600\n+#    undef _WIN32_WINNT\n+#  endif\n+#  ifndef _WIN32_WINNT\n+#    if !defined(WINAPI_FAMILY) || !(WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)\n+#      define _WIN32_WINNT 0x0600\n+#    endif\n+#  endif\n+#  ifndef WIN32_LEAN_AND_MEAN\n+#    define WIN32_LEAN_AND_MEAN 1\n+#  endif\n+#  ifndef STRICT\n+#    define STRICT 1\n+#  endif\n+\n+#  if defined(_WIN32_WCE)\n+     \/* Some things not defined on Windows CE. *\/\n+#    define vsnprintf _vsnprintf\n+#    define getenv(Name) nullptr\n+#    if _WIN32_WCE < 0x800\n+#      define setlocale(Category, Locale) \"C\"\n+static int errno = 0; \/* Use something better? *\/\n+#    endif\n+#  elif defined(WINAPI_FAMILY) && (WINAPI_FAMILY==WINAPI_FAMILY_PC_APP || WINAPI_FAMILY==WINAPI_FAMILY_PHONE_APP)\n+#    define getenv(Name) nullptr\n+#  endif\n+#  if defined(_MSC_VER) && _MSC_VER < 1900\n+#    define snprintf _snprintf\n+#  endif\n+#endif\n+\n+#if defined(HAVE_ATEXIT) && !defined(HB_USE_ATEXIT)\n+\/* atexit() is only safe to be called from shared libraries on certain\n+ * platforms.  Whitelist.\n+ * https:\/\/bugs.freedesktop.org\/show_bug.cgi?id=82246 *\/\n+#  if defined(__linux) && defined(__GLIBC_PREREQ)\n+#    if __GLIBC_PREREQ(2,3)\n+\/* From atexit() manpage, it's safe with glibc 2.2.3 on Linux. *\/\n+#      define HB_USE_ATEXIT 1\n+#    endif\n+#  elif defined(_MSC_VER) || defined(__MINGW32__)\n+\/* For MSVC:\n+ * https:\/\/msdn.microsoft.com\/en-us\/library\/tze57ck3.aspx\n+ * https:\/\/msdn.microsoft.com\/en-us\/library\/zk17ww08.aspx\n+ * mingw32 headers say atexit is safe to use in shared libraries.\n+ *\/\n+#    define HB_USE_ATEXIT 1\n+#  elif defined(__ANDROID__)\n+\/* This is available since Android NKD r8 or r8b:\n+ * https:\/\/issuetracker.google.com\/code\/p\/android\/issues\/detail?id=6455\n+ *\/\n+#    define HB_USE_ATEXIT 1\n+#  elif defined(__APPLE__)\n+\/* For macOS and related platforms, the atexit man page indicates\n+ * that it will be invoked when the library is unloaded, not only\n+ * at application exit.\n+ *\/\n+#    define HB_USE_ATEXIT 1\n+#  endif\n+#endif\n+#ifdef HB_NO_ATEXIT\n+#  undef HB_USE_ATEXIT\n+#endif\n+#ifndef HB_USE_ATEXIT\n+#  define HB_USE_ATEXIT 0\n+#endif\n+\n+#define HB_STMT_START do\n+#define HB_STMT_END   while (0)\n+\n+\/* Static-assert as expression. *\/\n+template <unsigned int cond> class hb_assert_constant_t;\n+template <> class hb_assert_constant_t<1> {};\n+#define ASSERT_STATIC_EXPR_ZERO(_cond) (0 * (unsigned int) sizeof (hb_assert_constant_t<_cond>))\n+\n+\/* Lets assert int types.  Saves trouble down the road. *\/\n+static_assert ((sizeof (int8_t) == 1), \"\");\n+static_assert ((sizeof (uint8_t) == 1), \"\");\n+static_assert ((sizeof (int16_t) == 2), \"\");\n+static_assert ((sizeof (uint16_t) == 2), \"\");\n+static_assert ((sizeof (int32_t) == 4), \"\");\n+static_assert ((sizeof (uint32_t) == 4), \"\");\n+static_assert ((sizeof (int64_t) == 8), \"\");\n+static_assert ((sizeof (uint64_t) == 8), \"\");\n+static_assert ((sizeof (hb_codepoint_t) == 4), \"\");\n+static_assert ((sizeof (hb_position_t) == 4), \"\");\n+static_assert ((sizeof (hb_mask_t) == 4), \"\");\n+static_assert ((sizeof (hb_var_int_t) == 4), \"\");\n+\n+\n+#if __cplusplus >= 201103L\n+\n+\/* We only enable these with C++11 or later, since earlier language\n+ * does not allow structs with constructors in unions, and we need\n+ * those. *\/\n+\n+#define HB_NO_COPY_ASSIGN(TypeName) \\\n+  TypeName(const TypeName&); \\\n+  void operator=(const TypeName&)\n+#define HB_NO_COPY_ASSIGN_TEMPLATE(TypeName, T) \\\n+  TypeName(const TypeName<T>&); \\\n+  void operator=(const TypeName<T>&)\n+#define HB_NO_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) \\\n+  TypeName(const TypeName<T1, T2>&); \\\n+  void operator=(const TypeName<T1, T2>&)\n+#define HB_NO_CREATE_COPY_ASSIGN(TypeName) \\\n+  TypeName(); \\\n+  TypeName(const TypeName&); \\\n+  void operator=(const TypeName&)\n+#define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE(TypeName, T) \\\n+  TypeName(); \\\n+  TypeName(const TypeName<T>&); \\\n+  void operator=(const TypeName<T>&)\n+#define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) \\\n+  TypeName(); \\\n+  TypeName(const TypeName<T1, T2>&); \\\n+  void operator=(const TypeName<T1, T2>&)\n+\n+#else \/* __cpluspplus >= 201103L *\/\n+\n+#define HB_NO_COPY_ASSIGN(TypeName) static_assert (true, \"\")\n+#define HB_NO_COPY_ASSIGN_TEMPLATE(TypeName, T) static_assert (true, \"\")\n+#define HB_NO_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) static_assert (true, \"\")\n+#define HB_NO_CREATE_COPY_ASSIGN(TypeName) static_assert (true, \"\")\n+#define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE(TypeName, T) static_assert (true, \"\")\n+#define HB_NO_CREATE_COPY_ASSIGN_TEMPLATE2(TypeName, T1, T2) static_assert (true, \"\")\n+\n+#endif \/* __cpluspplus >= 201103L *\/\n+\n+\n+\/*\n+ * Compiler-assisted vectorization parameters.\n+ *\/\n+\n+\/*\n+ * Disable vectorization for now.  To correctly use them, we should\n+ * use posix_memalign() to allocate in hb_vector_t.  Otherwise, can\n+ * cause misaligned access.\n+ *\n+ * https:\/\/bugs.chromium.org\/p\/chromium\/issues\/detail?id=860184\n+ *\/\n+#if !defined(HB_VECTOR_SIZE)\n+#  define HB_VECTOR_SIZE 0\n+#endif\n+\n+\/* The `vector_size' attribute was introduced in gcc 3.1. *\/\n+#if !defined(HB_VECTOR_SIZE)\n+#  if defined( __GNUC__ ) && ( __GNUC__ >= 4 )\n+#    define HB_VECTOR_SIZE 128\n+#  else\n+#    define HB_VECTOR_SIZE 0\n+#  endif\n+#endif\n+static_assert (0 == (HB_VECTOR_SIZE & (HB_VECTOR_SIZE - 1)), \"HB_VECTOR_SIZE is not power of 2.\");\n+static_assert (0 == (HB_VECTOR_SIZE % 64), \"HB_VECTOR_SIZE is not multiple of 64.\");\n+#if HB_VECTOR_SIZE\n+typedef uint64_t hb_vector_size_impl_t __attribute__((vector_size (HB_VECTOR_SIZE \/ 8)));\n+#else\n+typedef uint64_t hb_vector_size_impl_t;\n+#endif\n+\n+\n+\/* HB_NDEBUG disables some sanity checks that are very safe to disable and\n+ * should be disabled in production systems.  If NDEBUG is defined, enable\n+ * HB_NDEBUG; but if it's desirable that normal assert()s (which are very\n+ * light-weight) to be enabled, then HB_DEBUG can be defined to disable\n+ * the costlier checks. *\/\n+#ifdef NDEBUG\n+#define HB_NDEBUG 1\n+#endif\n+\n+\n+\/* Flags *\/\n+\n+\/* Enable bitwise ops on enums marked as flags_t *\/\n+\/* To my surprise, looks like the function resolver is happy to silently cast\n+ * one enum to another...  So this doesn't provide the type-checking that I\n+ * originally had in mind... :(.\n+ *\n+ * For MSVC warnings, see: https:\/\/github.com\/harfbuzz\/harfbuzz\/pull\/163\n+ *\/\n+#ifdef _MSC_VER\n+# pragma warning(disable:4200)\n+# pragma warning(disable:4800)\n+#endif\n+#define HB_MARK_AS_FLAG_T(T) \\\n+        extern \"C++\" { \\\n+          static inline T operator | (T l, T r) { return T ((unsigned) l | (unsigned) r); } \\\n+          static inline T operator & (T l, T r) { return T ((unsigned) l & (unsigned) r); } \\\n+          static inline T operator ^ (T l, T r) { return T ((unsigned) l ^ (unsigned) r); } \\\n+          static inline T operator ~ (T r) { return T (~(unsigned int) r); } \\\n+          static inline T& operator |= (T &l, T r) { l = l | r; return l; } \\\n+          static inline T& operator &= (T& l, T r) { l = l & r; return l; } \\\n+          static inline T& operator ^= (T& l, T r) { l = l ^ r; return l; } \\\n+        } \\\n+        static_assert (true, \"\")\n+\n+\/* Useful for set-operations on small enums.\n+ * For example, for testing \"x ∈ {x1, x2, x3}\" use:\n+ * (FLAG_UNSAFE(x) & (FLAG(x1) | FLAG(x2) | FLAG(x3)))\n+ *\/\n+#define FLAG(x) (ASSERT_STATIC_EXPR_ZERO ((unsigned)(x) < 32) + (((uint32_t) 1U) << (unsigned)(x)))\n+#define FLAG_UNSAFE(x) ((unsigned)(x) < 32 ? (((uint32_t) 1U) << (unsigned)(x)) : 0)\n+#define FLAG_RANGE(x,y) (ASSERT_STATIC_EXPR_ZERO ((x) < (y)) + FLAG(y+1) - FLAG(x))\n+#define FLAG64(x) (ASSERT_STATIC_EXPR_ZERO ((unsigned)(x) < 64) + (((uint64_t) 1ULL) << (unsigned)(x)))\n+#define FLAG64_UNSAFE(x) ((unsigned)(x) < 64 ? (((uint64_t) 1ULL) << (unsigned)(x)) : 0)\n+\n+\n+\/* Size signifying variable-sized array *\/\n+#define VAR 1\n+\n+\n+\/* fallback for round() *\/\n+static inline double\n+_hb_round (double x)\n+{\n+  if (x >= 0)\n+    return floor (x + 0.5);\n+  else\n+    return ceil (x - 0.5);\n+}\n+#if !defined (HAVE_ROUND) && !defined (HAVE_DECL_ROUND)\n+#define round(x) _hb_round(x)\n+#endif\n+\n+\n+\/* fallback for posix_memalign() *\/\n+static inline int\n+_hb_memalign(void **memptr, size_t alignment, size_t size)\n+{\n+  if (unlikely (0 != (alignment & (alignment - 1)) ||\n+                !alignment ||\n+                0 != (alignment & (sizeof (void *) - 1))))\n+    return EINVAL;\n+\n+  char *p = (char *) malloc (size + alignment - 1);\n+  if (unlikely (!p))\n+    return ENOMEM;\n+\n+  size_t off = (size_t) p & (alignment - 1);\n+  if (off)\n+    p += alignment - off;\n+\n+  *memptr = (void *) p;\n+\n+  return 0;\n+}\n+#if !defined(posix_memalign) && !defined(HAVE_POSIX_MEMALIGN)\n+#define posix_memalign _hb_memalign\n+#endif\n+\n+\n+\/*\n+ * For lack of a better place, put Zawgyi script hack here.\n+ * https:\/\/github.com\/harfbuzz\/harfbuzz\/issues\/1162\n+ *\/\n+\n+#define HB_SCRIPT_MYANMAR_ZAWGYI        ((hb_script_t) HB_TAG ('Q','a','a','g'))\n+\n+\n+\/* Some really basic things everyone wants. *\/\n+template <typename T> struct hb_remove_const { typedef T value; };\n+template <typename T> struct hb_remove_const<const T> { typedef T value; };\n+#define hb_remove_const(T) hb_remove_const<T>::value\n+template <typename T> struct hb_remove_reference { typedef T value; };\n+template <typename T> struct hb_remove_reference<T &> { typedef T value; };\n+#define hb_remove_reference(T) hb_remove_reference<T>::value\n+template <typename T> struct hb_remove_pointer { typedef T value; };\n+template <typename T> struct hb_remove_pointer<T *> { typedef T value; };\n+#define hb_remove_pointer(T) hb_remove_pointer<T>::value\n+\n+\n+\/* Headers we include for everyone.  Keep topologically sorted by dependency.\n+ * They express dependency amongst themselves, but no other file should include\n+ * them directly.*\/\n+#include \"hb-atomic.hh\"\n+#include \"hb-mutex.hh\"\n+#include \"hb-null.hh\"\n+#include \"hb-dsalgs.hh\" \/\/ Requires: hb-null\n+#include \"hb-iter.hh\"   \/\/ Requires: hb-null\n+#include \"hb-debug.hh\"  \/\/ Requires: hb-atomic hb-dsalgs\n+#include \"hb-array.hh\"  \/\/ Requires: hb-dsalgs hb-iter hb-null\n+#include \"hb-vector.hh\" \/\/ Requires: hb-array hb-null\n+#include \"hb-object.hh\" \/\/ Requires: hb-atomic hb-mutex hb-vector\n+\n+#endif \/* HB_HH *\/\n","filename":"src\/java.desktop\/aix\/native\/libharfbuzz\/hb.hh","additions":658,"deletions":0,"binary":false,"changes":658,"status":"added"}]}