{"files":[{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires (os.family == \"linux\" | os.family == \"mac\")\n+ * @run testng AsyncShutdown\n+ * @summary Test shutdownInput\/shutdownOutput with threads blocked in read\/write\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class AsyncShutdown {\n+\n+    public void testShutdownInput1() throws IOException {\n+        withConnection((s1, s2) -> {\n+            scheduleShutdownInput(s1, 2000);\n+            int n = s1.getInputStream().read();\n+            assertTrue(n == -1);\n+        });\n+    }\n+\n+    public void testShutdownInput2() throws IOException {\n+        withConnection((s1, s2) -> {\n+            scheduleShutdownInput(s1, 2000);\n+            s1.setSoTimeout(30*1000);\n+            int n = s1.getInputStream().read();\n+            assertTrue(n == -1);\n+        });\n+    }\n+\n+    public void testShutdownOutput1() throws IOException {\n+        withConnection((s1, s2) -> {\n+            scheduleShutdownOutput(s1, 2000);\n+            byte[] data = new byte[128*1024];\n+            try {\n+                while (true) {\n+                    s1.getOutputStream().write(data);\n+                }\n+            } catch (IOException expected) { }\n+        });\n+    }\n+\n+    public void testShutdownOutput2() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s1.setSoTimeout(100);\n+            try {\n+                s1.getInputStream().read();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException e) { }\n+\n+            scheduleShutdownOutput(s1, 2000);\n+            byte[] data = new byte[128*1024];\n+            try {\n+                while (true) {\n+                    s1.getOutputStream().write(data);\n+                }\n+            } catch (IOException expected) { }\n+        });\n+    }\n+\n+    static void scheduleShutdownInput(Socket s, long delay) {\n+        schedule(() -> {\n+            try {\n+                s.shutdownInput();\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+\n+    static void scheduleShutdownOutput(Socket s, long delay) {\n+        schedule(() -> {\n+            try {\n+                s.shutdownOutput();\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+\n+    static void schedule(Runnable task, long delay) {\n+        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+        try {\n+            executor.schedule(task, delay, TimeUnit.MILLISECONDS);\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+\n+    interface ThrowingBiConsumer<T, U> {\n+        void accept(T t, U u) throws IOException;\n+    }\n+\n+    static void withConnection(ThrowingBiConsumer<Socket, Socket> consumer)\n+        throws IOException\n+    {\n+        Socket s1 = null;\n+        Socket s2 = null;\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            s1 = new Socket();\n+            s1.connect(ss.getLocalSocketAddress());\n+            s2 = ss.accept();\n+            consumer.accept(s1, s2);\n+        } finally {\n+            if (s1 != null) s1.close();\n+            if (s2 != null) s2.close();\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/AsyncShutdown.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @requires os.family != \"solaris\"\n+ * @run testng ConnectionReset\n+ * @summary Test behavior of read and available when a connection is reset\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+\n+@Test\n+public class ConnectionReset {\n+\n+    static final int REPEAT_COUNT = 5;\n+\n+    \/**\n+     * Tests available before read when there are no bytes to read\n+     *\/\n+    public void testAvailableBeforeRead1() throws IOException {\n+        System.out.println(\"testAvailableBeforeRead1\");\n+        withResetConnection(null, s -> {\n+            InputStream in = s.getInputStream();\n+            for (int i=0; i<REPEAT_COUNT; i++) {\n+                int bytesAvailable = in.available();\n+                System.out.format(\"available => %d%n\", bytesAvailable);\n+                assertTrue(bytesAvailable == 0);\n+                try {\n+                    int bytesRead = in.read();\n+                    if (bytesRead == -1) {\n+                        System.out.println(\"read => EOF\");\n+                    } else {\n+                        System.out.println(\"read => 1 byte\");\n+                    }\n+                    assertTrue(false);\n+                } catch (IOException ioe) {\n+                    System.out.format(\"read => %s (expected)%n\", ioe);\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests available before read when there are bytes to read\n+     *\/\n+    public void testAvailableBeforeRead2() throws IOException {\n+        System.out.println(\"testAvailableBeforeRead2\");\n+        byte[] data = { 1, 2, 3 };\n+        withResetConnection(data, s -> {\n+            InputStream in = s.getInputStream();\n+            int remaining = data.length;\n+            for (int i=0; i<REPEAT_COUNT; i++) {\n+                int bytesAvailable = in.available();\n+                System.out.format(\"available => %d%n\", bytesAvailable);\n+                assertTrue(bytesAvailable <= remaining);\n+                try {\n+                    int bytesRead = in.read();\n+                    if (bytesRead == -1) {\n+                        System.out.println(\"read => EOF\");\n+                        assertTrue(false);\n+                    } else {\n+                        System.out.println(\"read => 1 byte\");\n+                        assertTrue(remaining > 0);\n+                        remaining--;\n+                    }\n+                } catch (IOException ioe) {\n+                    System.out.format(\"read => %s%n\", ioe);\n+                    remaining = 0;\n+                }\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests read before available when there are no bytes to read\n+     *\/\n+    public void testReadBeforeAvailable1() throws IOException {\n+        System.out.println(\"testReadBeforeAvailable1\");\n+        withResetConnection(null, s -> {\n+            InputStream in = s.getInputStream();\n+            for (int i=0; i<REPEAT_COUNT; i++) {\n+                try {\n+                    int bytesRead = in.read();\n+                    if (bytesRead == -1) {\n+                        System.out.println(\"read => EOF\");\n+                    } else {\n+                        System.out.println(\"read => 1 byte\");\n+                    }\n+                    assertTrue(false);\n+                } catch (IOException ioe) {\n+                    System.out.format(\"read => %s (expected)%n\", ioe);\n+                }\n+                int bytesAvailable = in.available();\n+                System.out.format(\"available => %d%n\", bytesAvailable);\n+                assertTrue(bytesAvailable == 0);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests read before available when there are bytes to read\n+     *\/\n+    public void testReadBeforeAvailable2() throws IOException {\n+        System.out.println(\"testReadBeforeAvailable2\");\n+        byte[] data = { 1, 2, 3 };\n+        withResetConnection(data, s -> {\n+            InputStream in = s.getInputStream();\n+            int remaining = data.length;\n+            for (int i=0; i<REPEAT_COUNT; i++) {\n+                try {\n+                    int bytesRead = in.read();\n+                    if (bytesRead == -1) {\n+                        System.out.println(\"read => EOF\");\n+                        assertTrue(false);\n+                    } else {\n+                        System.out.println(\"read => 1 byte\");\n+                        assertTrue(remaining > 0);\n+                        remaining--;\n+                    }\n+                } catch (IOException ioe) {\n+                    System.out.format(\"read => %s%n\", ioe);\n+                    remaining = 0;\n+                }\n+                int bytesAvailable = in.available();\n+                System.out.format(\"available => %d%n\", bytesAvailable);\n+                assertTrue(bytesAvailable <= remaining);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Tests available and read on a socket closed after connection reset\n+     *\/\n+    public void testAfterClose() throws IOException {\n+        System.out.println(\"testAfterClose\");\n+        withResetConnection(null, s -> {\n+            InputStream in = s.getInputStream();\n+            try {\n+                in.read();\n+                assertTrue(false);\n+            } catch (IOException ioe) {\n+                \/\/ expected\n+            }\n+            s.close();\n+            try {\n+                int bytesAvailable = in.available();\n+                System.out.format(\"available => %d%n\", bytesAvailable);\n+                assertTrue(false);\n+            } catch (IOException ioe) {\n+                System.out.format(\"available => %s (expected)%n\", ioe);\n+            }\n+            try {\n+                int n = in.read();\n+                System.out.format(\"read => %d%n\", n);\n+                assertTrue(false);\n+            } catch (IOException ioe) {\n+                System.out.format(\"read => %s (expected)%n\", ioe);\n+            }\n+        });\n+    }\n+\n+    interface ThrowingConsumer<T> {\n+        void accept(T t) throws IOException;\n+    }\n+\n+    \/**\n+     * Invokes a consumer with a Socket connected to a peer that has closed the\n+     * connection with a \"connection reset\". The peer sends the given data bytes\n+     * before closing (when data is not null).\n+     *\/\n+    static void withResetConnection(byte[] data, ThrowingConsumer<Socket> consumer)\n+        throws IOException\n+    {\n+        var loopback = InetAddress.getLoopbackAddress();\n+        try (var listener = new ServerSocket()) {\n+            listener.bind(new InetSocketAddress(loopback, 0));\n+            try (var socket = new Socket()) {\n+                socket.connect(listener.getLocalSocketAddress());\n+                try (Socket peer = listener.accept()) {\n+                    if (data != null) {\n+                        peer.getOutputStream().write(data);\n+                    }\n+                    peer.setSoLinger(true, 0);\n+                }\n+                consumer.accept(socket);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/ConnectionReset.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"},{"patch":"@@ -0,0 +1,497 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Utils\n+ * @run testng Timeouts\n+ * @summary Test Socket timeouts\n+ *\/\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ConnectException;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.SocketException;\n+import java.net.SocketTimeoutException;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.*;\n+import jdk.test.lib.Utils;\n+\n+@Test\n+public class Timeouts {\n+\n+    \/**\n+     * Test timed connect where connection is established\n+     *\/\n+    public void testTimedConnect1() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            try (Socket s = new Socket()) {\n+                s.connect(ss.getLocalSocketAddress(), 2000);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test timed connect where connection is refused\n+     *\/\n+    public void testTimedConnect2() throws IOException {\n+        try (Socket s = new Socket()) {\n+            SocketAddress remote = Utils.refusingEndpoint();\n+            try {\n+                s.connect(remote, 2000);\n+            } catch (ConnectException expected) { }\n+        }\n+    }\n+\n+    \/**\n+     * Test connect with a timeout of Integer.MAX_VALUE\n+     *\/\n+    public void testTimedConnect3() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            try (Socket s = new Socket()) {\n+                s.connect(ss.getLocalSocketAddress(), Integer.MAX_VALUE);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test connect with a negative timeout. This case is not currently specified\n+     * but the long standing behavior is to throw IllegalArgumentException.\n+     *\/\n+    public void testTimedConnect4() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            try (Socket s = new Socket()) {\n+                try {\n+                    s.connect(ss.getLocalSocketAddress(), -1);\n+                    assertTrue(false);\n+                } catch (IllegalArgumentException expected) { }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test timed read where the read succeeds immediately\n+     *\/\n+    public void testTimedRead1() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s1.getOutputStream().write(99);\n+            s2.setSoTimeout(30*1000);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test timed read where the read succeeds after a delay\n+     *\/\n+    public void testTimedRead2() throws IOException {\n+        withConnection((s1, s2) -> {\n+            scheduleWrite(s1.getOutputStream(), 99, 2000);\n+            s2.setSoTimeout(30*1000);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test timed read where the read times out\n+     *\/\n+    public void testTimedRead3() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s2.setSoTimeout(2000);\n+            try {\n+                s2.getInputStream().read();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException expected) { }\n+        });\n+    }\n+\n+    \/**\n+     * Test timed read that succeeds after a previous read has timed out\n+     *\/\n+    public void testTimedRead4() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s2.setSoTimeout(2000);\n+            try {\n+                s2.getInputStream().read();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException e) { }\n+            s1.getOutputStream().write(99);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test timed read that succeeds after a previous read has timed out and\n+     * after a short delay\n+     *\/\n+    public void testTimedRead5() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s2.setSoTimeout(2000);\n+            try {\n+                s2.getInputStream().read();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException e) { }\n+            s2.setSoTimeout(30*3000);\n+            scheduleWrite(s1.getOutputStream(), 99, 2000);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test untimed read that succeeds after a previous read has timed out\n+     *\/\n+    public void testTimedRead6() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s2.setSoTimeout(2000);\n+            try {\n+                s2.getInputStream().read();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException e) { }\n+            s1.getOutputStream().write(99);\n+            s2.setSoTimeout(0);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test untimed read that succeeds after a previous read has timed out and\n+     * after a short delay\n+     *\/\n+    public void testTimedRead7() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s2.setSoTimeout(2000);\n+            try {\n+                s2.getInputStream().read();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException e) { }\n+            scheduleWrite(s1.getOutputStream(), 99, 2000);\n+            s2.setSoTimeout(0);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test async close of timed read\n+     *\/\n+    public void testTimedRead8() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s2.setSoTimeout(30*1000);\n+            scheduleClose(s2, 2000);\n+            try {\n+                s2.getInputStream().read();\n+                assertTrue(false);\n+            } catch (SocketException expected) { }\n+        });\n+    }\n+\n+    \/**\n+     * Test read with a timeout of Integer.MAX_VALUE\n+     *\/\n+    public void testTimedRead9() throws IOException {\n+        withConnection((s1, s2) -> {\n+            scheduleWrite(s1.getOutputStream(), 99, 2000);\n+            s2.setSoTimeout(Integer.MAX_VALUE);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+        });\n+    }\n+\n+    \/**\n+     * Test writing after a timed read.\n+     *\/\n+    public void testTimedWrite1() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s1.getOutputStream().write(99);\n+            s2.setSoTimeout(3000);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+\n+            \/\/ schedule thread to read s1 to EOF\n+            scheduleReadToEOF(s1.getInputStream(), 3000);\n+\n+            \/\/ write a lot so that write blocks\n+            byte[] data = new byte[128*1024];\n+            for (int i = 0; i < 100; i++) {\n+                s2.getOutputStream().write(data);\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Test async close of writer (after a timed read).\n+     *\/\n+    public void testTimedWrite2() throws IOException {\n+        withConnection((s1, s2) -> {\n+            s1.getOutputStream().write(99);\n+            s2.setSoTimeout(3000);\n+            int b = s2.getInputStream().read();\n+            assertTrue(b == 99);\n+\n+            \/\/ schedule s2 to be be closed\n+            scheduleClose(s2, 3000);\n+\n+            \/\/ write a lot so that write blocks\n+            byte[] data = new byte[128*1024];\n+            try {\n+                while (true) {\n+                    s2.getOutputStream().write(data);\n+                }\n+            } catch (SocketException expected) { }\n+        });\n+    }\n+\n+    \/**\n+     * Test timed accept where a connection is established immediately\n+     *\/\n+    public void testTimedAccept1() throws IOException {\n+        Socket s1 = null;\n+        Socket s2 = null;\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            s1 = new Socket();\n+            s1.connect(ss.getLocalSocketAddress());\n+            ss.setSoTimeout(30*1000);\n+            s2 = ss.accept();\n+        } finally {\n+            if (s1 != null) s1.close();\n+            if (s2 != null) s2.close();\n+        }\n+    }\n+\n+    \/**\n+     * Test timed accept where a connection is established after a short delay\n+     *\/\n+    public void testTimedAccept2() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            ss.setSoTimeout(30*1000);\n+            scheduleConnect(ss.getLocalSocketAddress(), 2000);\n+            Socket s = ss.accept();\n+            s.close();\n+        }\n+    }\n+\n+    \/**\n+     * Test timed accept where the accept times out\n+     *\/\n+    public void testTimedAccept3() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            ss.setSoTimeout(2000);\n+            try {\n+                Socket s = ss.accept();\n+                s.close();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException expected) { }\n+        }\n+    }\n+\n+    \/**\n+     * Test timed accept where a connection is established immediately after a\n+     * previous accept timed out.\n+     *\/\n+    public void testTimedAccept4() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            ss.setSoTimeout(2000);\n+            try {\n+                Socket s = ss.accept();\n+                s.close();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException expected) { }\n+            try (Socket s1 = new Socket()) {\n+                s1.connect(ss.getLocalSocketAddress());\n+                Socket s2 = ss.accept();\n+                s2.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test untimed accept where a connection is established after a previous\n+     * accept timed out\n+     *\/\n+    public void testTimedAccept5() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            ss.setSoTimeout(2000);\n+            try {\n+                Socket s = ss.accept();\n+                s.close();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException expected) { }\n+            ss.setSoTimeout(0);\n+            try (Socket s1 = new Socket()) {\n+                s1.connect(ss.getLocalSocketAddress());\n+                Socket s2 = ss.accept();\n+                s2.close();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test untimed accept where a connection is established after a previous\n+     * accept timed out and after a short delay\n+     *\/\n+    public void testTimedAccept6() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            ss.setSoTimeout(2000);\n+            try {\n+                Socket s = ss.accept();\n+                s.close();\n+                assertTrue(false);\n+            } catch (SocketTimeoutException expected) { }\n+            ss.setSoTimeout(0);\n+            scheduleConnect(ss.getLocalSocketAddress(), 2000);\n+            Socket s = ss.accept();\n+            s.close();\n+        }\n+    }\n+\n+    \/**\n+     * Test async close of a timed accept\n+     *\/\n+    public void testTimedAccept7() throws IOException {\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            ss.setSoTimeout(30*1000);\n+            scheduleClose(ss, 2000);\n+            try {\n+                ss.accept().close();\n+                assertTrue(false);\n+            } catch (SocketException expected) { }\n+        }\n+    }\n+\n+    \/**\n+     * Test Socket setSoTimeout with a negative timeout. This case is not currently\n+     * specified but the long standing behavior is to throw IllegalArgumentException.\n+     *\/\n+    @Test(expectedExceptions = { IllegalArgumentException.class })\n+    public void testBadTimeout1() throws IOException {\n+        try (Socket s = new Socket()) {\n+            s.setSoTimeout(-1);\n+        }\n+    }\n+\n+    \/**\n+     * Test ServerSocket setSoTimeout with a negative timeout. This case is not\n+     * currently specified but the long standing behavior is to throw\n+     * IllegalArgumentException.\n+     *\/\n+    @Test(expectedExceptions = { IllegalArgumentException.class })\n+    public void testBadTimeout2() throws IOException {\n+        try (ServerSocket ss = new ServerSocket()) {\n+            ss.setSoTimeout(-1);\n+        }\n+    }\n+\n+    interface ThrowingBiConsumer<T, U> {\n+        void accept(T t, U u) throws IOException;\n+    }\n+\n+    \/**\n+     * Invokes the consumer with a connected pair of sockets\n+     *\/\n+    static void withConnection(ThrowingBiConsumer<Socket, Socket> consumer)\n+        throws IOException\n+    {\n+        Socket s1 = null;\n+        Socket s2 = null;\n+        try (ServerSocket ss = new ServerSocket(0)) {\n+            s1 = new Socket();\n+            s1.connect(ss.getLocalSocketAddress());\n+            s2 = ss.accept();\n+            consumer.accept(s1, s2);\n+        } finally {\n+            if (s1 != null) s1.close();\n+            if (s2 != null) s2.close();\n+        }\n+    }\n+\n+    \/**\n+     * Schedule c to be closed after a delay\n+     *\/\n+    static void scheduleClose(Closeable c, long delay) {\n+        schedule(() -> {\n+            try {\n+                c.close();\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+\n+    \/**\n+     * Schedule a thread to connect to the given end point after a delay\n+     *\/\n+    static void scheduleConnect(SocketAddress remote, long delay) {\n+        schedule(() -> {\n+            try (Socket s = new Socket()) {\n+                s.connect(remote);\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+\n+    \/**\n+     * Schedule a thread to read to EOF after a delay\n+     *\/\n+    static void scheduleReadToEOF(InputStream in, long delay) {\n+        schedule(() -> {\n+            byte[] bytes = new byte[8192];\n+            try {\n+                while (in.read(bytes) != -1) { }\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+\n+    \/**\n+     * Schedule a thread to write after a delay\n+     *\/\n+    static void scheduleWrite(OutputStream out, byte[] data, long delay) {\n+        schedule(() -> {\n+            try {\n+                out.write(data);\n+            } catch (IOException ioe) { }\n+        }, delay);\n+    }\n+    static void scheduleWrite(OutputStream out, int b, long delay) {\n+        scheduleWrite(out, new byte[] { (byte)b }, delay);\n+    }\n+\n+    static void schedule(Runnable task, long delay) {\n+        ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+        try {\n+            executor.schedule(task, delay, TimeUnit.MILLISECONDS);\n+        } finally {\n+            executor.shutdown();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/Timeouts.java","additions":497,"deletions":0,"binary":false,"changes":497,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @run main UdpSocket\n+ * @summary Basic test for a Socket to a UDP socket\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.DatagramChannel;\n+import java.util.Arrays;\n+\n+public class UdpSocket {\n+\n+    static final String MESSAGE = \"hello\";\n+\n+    public static void main(String[] args) throws IOException {\n+        try (DatagramChannel dc = DatagramChannel.open()) {\n+            var loopback = InetAddress.getLoopbackAddress();\n+            dc.bind(new InetSocketAddress(loopback, 0));\n+\n+            int port = ((InetSocketAddress) dc.getLocalAddress()).getPort();\n+            try (Socket s = new Socket(loopback, port, false)) {\n+\n+                \/\/ send datagram with socket output stream\n+                byte[] array1 = MESSAGE.getBytes(\"UTF-8\");\n+                s.getOutputStream().write(array1);\n+\n+                \/\/ receive the datagram\n+                var buf = ByteBuffer.allocate(100);\n+                SocketAddress remote = dc.receive(buf);\n+                buf.flip();\n+                if (buf.remaining() != MESSAGE.length())\n+                    throw new RuntimeException(\"Unexpected size\");\n+\n+                \/\/ echo the datagram\n+                dc.send(buf, remote);\n+\n+                \/\/ receive datagram with the socket input stream\n+                byte[] array2 = new byte[100];\n+                int n = s.getInputStream().read(array2);\n+                if (n != MESSAGE.length())\n+                    throw new RuntimeException(\"Unexpected size\");\n+                if (!Arrays.equals(array1, 0, n, array2, 0, n))\n+                    throw new RuntimeException(\"Unexpected contents\");\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/Socket\/UdpSocket.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}