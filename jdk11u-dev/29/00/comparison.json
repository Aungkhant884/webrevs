{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -243,6 +243,1 @@\n-        if (status != UNAUTHORIZED && status != PROXY_UNAUTHORIZED) {\n-            \/\/ check if any authentication succeeded for first time\n-            if (exchange.serverauth != null && !exchange.serverauth.fromcache) {\n-                AuthInfo au = exchange.serverauth;\n-                cache.store(au.scheme, req.uri(), false, au.credentials);\n-            }\n+        if (status != PROXY_UNAUTHORIZED) {\n@@ -253,0 +248,1 @@\n+                    exchange.proxyauth = null;\n@@ -256,0 +252,6 @@\n+            if (status != UNAUTHORIZED) {\n+            \/\/ check if any authentication succeeded for first time\n+                if (exchange.serverauth != null && !exchange.serverauth.fromcache) {\n+                    AuthInfo au = exchange.serverauth;\n+                    cache.store(au.scheme, req.uri(), false, au.credentials);\n+                }\n@@ -257,0 +259,1 @@\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/AuthenticationFilter.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -145,0 +145,1 @@\n+        assert c == null || c.isSecure() == secure;\n@@ -158,0 +159,4 @@\n+        assert (conn instanceof PlainHttpConnection) || conn.isSecure()\n+            : \"Attempting to return unsecure connection to SSL pool: \"\n+                + conn.getClass();\n+\n@@ -453,1 +458,1 @@\n-            assert c.isSecure();\n+            assert c.isSecure() : \"connection \" + c + \" is not secure!\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -266,1 +266,1 @@\n-            return readBody(discarding(), true, executor);\n+            return readBody(discarding(), !request.isWebSocket(), executor);\n@@ -390,0 +390,8 @@\n+        if (debug.on()) {\n+            debug.log(\"readBody: return2Cache: \" + return2Cache);\n+            if (request.isWebSocket() && return2Cache && connection != null) {\n+                debug.log(\"websocket connection will be returned to cache: \"\n+                        + connection.getClass() + \"\/\" + connection );\n+            }\n+        }\n+        assert !return2Cache || !request.isWebSocket();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http1Response.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -163,0 +163,20 @@\n+    \/**\n+     * Closes the RawChannel that may have been used for WebSocket protocol.\n+     *\n+     * @apiNote This method should be called to close the connection\n+     * if an exception occurs during the websocket handshake, in cases where\n+     * {@link #rawChannel() rawChannel().close()} would have been called.\n+     * An unsuccessful handshake may prevent the creation of the RawChannel:\n+     * if a RawChannel has already been created, this method wil close it.\n+     * Otherwise, it will close the connection.\n+     *\n+     * @throws IOException if an I\/O exception occurs while closing\n+     *         the channel.\n+     *\/\n+    public synchronized void closeRawChannel() throws IOException {\n+        \/\/  close the rawChannel, if created, or the\n+        \/\/ connection, if not.\n+        if (rawchan != null) rawchan.close();\n+        else connection.close();\n+        }\n+\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/HttpResponseImpl.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -366,0 +366,4 @@\n+                            if (currentreq.isWebSocket()) {\n+                                \/\/ need to close the connection and open a new one.\n+                                exch.exchImpl.connection().close();\n+                            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,1 +76,1 @@\n-        dbgTag = \"[WebSocket] RawChannelTube(\" + tube.toString() +\")\";\n+        dbgTag = \"[WebSocket] RawChannelTube(\" + tube +\")\";\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/RawChannelTube.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * -Djava.net.HttpClient.log=\n+ * -Djdk.httpclient.HttpClient.log=\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/Log.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -218,1 +218,1 @@\n-        Exception exception = null;\n+        Throwable exception = null;\n@@ -225,0 +225,5 @@\n+        } catch (Error e) {\n+            \/\/ We should attempt to close the connection and relay\n+            \/\/ the error through the completable future even in this\n+            \/\/ case.\n+            exception = e;\n@@ -230,1 +235,3 @@\n-            ((RawChannel.Provider) response).rawChannel().close();\n+            \/\/ calling this method will close the rawChannel, if created,\n+            \/\/ or the connection, if not.\n+            ((RawChannel.Provider) response).closeRawChannel();\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/OpeningHandshake.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+        void closeRawChannel() throws IOException;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/websocket\/RawChannel.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,610 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import javax.net.ServerSocketFactory;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.UncheckedIOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.ServerSocket;\n+import java.net.SocketAddress;\n+import java.net.SocketOption;\n+import java.net.StandardSocketOptions;\n+import java.net.URI;\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.channels.ClosedByInterruptException;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.CharacterCodingException;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.BiFunction;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import static java.lang.String.format;\n+import static java.lang.System.err;\n+import static java.nio.charset.StandardCharsets.ISO_8859_1;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static java.util.Arrays.asList;\n+import static java.util.Objects.requireNonNull;\n+\n+\/**\n+ * Dummy WebSocket Server, which supports TLS.\n+ * By default the dummy webserver uses a plain TCP connection,\n+ * but it can use a TLS connection if secure() is called before\n+ * open(). It will use the default SSL context.\n+ *\n+ * Performs simpler version of the WebSocket Opening Handshake over HTTP (i.e.\n+ * no proxying, cookies, etc.) Supports sequential connections, one at a time,\n+ * i.e. in order for a client to connect to the server the previous client must\n+ * disconnect first.\n+ *\n+ * Expected client request:\n+ *\n+ *     GET \/chat HTTP\/1.1\n+ *     Host: server.example.com\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==\n+ *     Origin: http:\/\/example.com\n+ *     Sec-WebSocket-Protocol: chat, superchat\n+ *     Sec-WebSocket-Version: 13\n+ *\n+ * This server response:\n+ *\n+ *     HTTP\/1.1 101 Switching Protocols\n+ *     Upgrade: websocket\n+ *     Connection: Upgrade\n+ *     Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\n+ *     Sec-WebSocket-Protocol: chat\n+ *\/\n+public class DummySecureWebSocketServer implements Closeable {\n+\n+    \/**\n+     * Emulates some of the SocketChannel APIs over a Socket\n+     * instance.\n+     *\/\n+    public static class WebSocketChannel implements AutoCloseable {\n+        interface Reader {\n+            int read(ByteBuffer buf) throws IOException;\n+        }\n+        interface Writer {\n+            void write(ByteBuffer buf) throws IOException;\n+        }\n+        interface Config {\n+            <T> void setOption(SocketOption<T> option, T value) throws IOException;\n+        }\n+        interface Closer {\n+            void close() throws IOException;\n+        }\n+        final AutoCloseable channel;\n+        final Reader reader;\n+        final Writer writer;\n+        final Config config;\n+        final Closer closer;\n+        WebSocketChannel(AutoCloseable channel, Reader reader, Writer writer, Config config, Closer closer) {\n+            this.channel = channel;\n+            this.reader = reader;\n+            this.writer = writer;\n+            this.config = config;\n+            this.closer = closer;\n+        }\n+        public void close() throws IOException {\n+            closer.close();\n+        }\n+        public String toString() {\n+            return channel.toString();\n+        }\n+        public int read(ByteBuffer bb) throws IOException {\n+            return reader.read(bb);\n+        }\n+        public void write(ByteBuffer bb) throws IOException {\n+            writer.write(bb);\n+        }\n+        public <T> void setOption(SocketOption<T> option, T value) throws IOException {\n+            config.setOption(option, value);\n+        }\n+        public static WebSocketChannel of(Socket s) {\n+            Reader reader = (bb) -> DummySecureWebSocketServer.read(s.getInputStream(), bb);\n+            Writer writer = (bb) -> DummySecureWebSocketServer.write(s.getOutputStream(), bb);\n+            return new WebSocketChannel(s, reader, writer, s::setOption, s::close);\n+        }\n+    }\n+\n+    \/**\n+     * Emulates some of the ServerSocketChannel APIs over a ServerSocket\n+     * instance.\n+     *\/\n+    public static class WebServerSocketChannel implements AutoCloseable {\n+        interface Accepter {\n+            WebSocketChannel accept() throws IOException;\n+        }\n+        interface Binder {\n+            void bind(SocketAddress address) throws IOException;\n+        }\n+        interface Config {\n+            <T> void setOption(SocketOption<T> option, T value) throws IOException;\n+        }\n+        interface Closer {\n+            void close() throws IOException;\n+        }\n+        interface Addressable {\n+            SocketAddress getLocalAddress() throws IOException;\n+        }\n+        final AutoCloseable server;\n+        final Accepter accepter;\n+        final Binder binder;\n+        final Addressable address;\n+        final Config config;\n+        final Closer closer;\n+        WebServerSocketChannel(AutoCloseable server,\n+                               Accepter accepter,\n+                               Binder binder,\n+                               Addressable address,\n+                               Config config,\n+                               Closer closer) {\n+            this.server = server;\n+            this.accepter = accepter;\n+            this.binder = binder;\n+            this.address = address;\n+            this.config = config;\n+            this.closer = closer;\n+        }\n+        public void close() throws IOException {\n+            closer.close();\n+        }\n+        public String toString() {\n+            return server.toString();\n+        }\n+        public WebSocketChannel accept() throws IOException {\n+            return accepter.accept();\n+        }\n+        public void bind(SocketAddress address) throws IOException {\n+            binder.bind(address);\n+        }\n+        public <T> void setOption(SocketOption<T> option, T value) throws IOException {\n+            config.setOption(option, value);\n+        }\n+        public SocketAddress getLocalAddress()  throws IOException {\n+            return address.getLocalAddress();\n+        }\n+        public static WebServerSocketChannel of(ServerSocket ss) {\n+            Accepter a = () -> WebSocketChannel.of(ss.accept());\n+            return new WebServerSocketChannel(ss, a, ss::bind, ss::getLocalSocketAddress, ss::setOption, ss::close);\n+        }\n+    }\n+\n+    \/\/ Creates a secure WebServerSocketChannel\n+    static WebServerSocketChannel openWSS() throws IOException {\n+       return WebServerSocketChannel.of(SSLServerSocketFactory.getDefault().createServerSocket());\n+    }\n+\n+    \/\/ Creates a plain WebServerSocketChannel\n+    static WebServerSocketChannel openWS() throws IOException {\n+        return WebServerSocketChannel.of(ServerSocketFactory.getDefault().createServerSocket());\n+    }\n+\n+\n+    static int read(InputStream str, ByteBuffer buffer) throws IOException {\n+        int len = Math.min(buffer.remaining(), 1024);\n+        if (len <= 0) return 0;\n+        byte[] bytes = new byte[len];\n+        int res = 0;\n+        if (buffer.hasRemaining()) {\n+            len = Math.min(len, buffer.remaining());\n+            int n = str.read(bytes, 0, len);\n+            if (n > 0) {\n+                buffer.put(bytes, 0, n);\n+                res += n;\n+            } else if (res > 0) {\n+                return res;\n+            } else {\n+                return n;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    static void write(OutputStream str, ByteBuffer buffer) throws IOException {\n+        int len = Math.min(buffer.remaining(), 1024);\n+        if (len <= 0) return;\n+        byte[] bytes = new byte[len];\n+        int res = 0;\n+        int pos = buffer.position();\n+        while (buffer.hasRemaining()) {\n+            len = Math.min(len, buffer.remaining());\n+            buffer.get(bytes, 0, len);\n+            str.write(bytes, 0, len);\n+        }\n+    }\n+\n+    private final AtomicBoolean started = new AtomicBoolean();\n+    private final Thread thread;\n+    private volatile WebServerSocketChannel ss;\n+    private volatile InetSocketAddress address;\n+    private volatile boolean secure;\n+    private ByteBuffer read = ByteBuffer.allocate(16384);\n+    private final CountDownLatch readReady = new CountDownLatch(1);\n+    private volatile boolean done;\n+\n+    private static class Credentials {\n+        private final String name;\n+        private final String password;\n+        private Credentials(String name, String password) {\n+            this.name = name;\n+            this.password = password;\n+        }\n+        public String name() { return name; }\n+        public String password() { return password; }\n+    }\n+\n+    public DummySecureWebSocketServer() {\n+        this(defaultMapping(), null, null);\n+    }\n+\n+    public DummySecureWebSocketServer(String username, String password) {\n+        this(defaultMapping(), username, password);\n+    }\n+\n+    public DummySecureWebSocketServer(BiFunction<List<String>,Credentials,List<String>> mapping,\n+                                String username,\n+                                String password) {\n+        requireNonNull(mapping);\n+        Credentials credentials = username != null ?\n+                new Credentials(username, password) : null;\n+\n+        thread = new Thread(() -> {\n+            try {\n+                while (!Thread.currentThread().isInterrupted() && !done) {\n+                    err.println(\"Accepting next connection at: \" + ss);\n+                    WebSocketChannel channel = ss.accept();\n+                    err.println(\"Accepted: \" + channel);\n+                    try {\n+                        channel.setOption(StandardSocketOptions.TCP_NODELAY, true);\n+                        while (!done) {\n+                            StringBuilder request = new StringBuilder();\n+                            if (!readRequest(channel, request)) {\n+                                throw new IOException(\"Bad request:[\" + request + \"]\");\n+                            }\n+                            List<String> strings = asList(request.toString().split(\"\\r\\n\"));\n+                            List<String> response = mapping.apply(strings, credentials);\n+                            writeResponse(channel, response);\n+\n+                            if (response.get(0).startsWith(\"HTTP\/1.1 401\")) {\n+                                err.println(\"Sent 401 Authentication response \" + channel);\n+                                continue;\n+                            } else {\n+                                serve(channel);\n+                                break;\n+                            }\n+                        }\n+                    } catch (IOException e) {\n+                        if (!done) {\n+                            err.println(\"Error in connection: \" + channel + \", \" + e);\n+                        }\n+                    } finally {\n+                        err.println(\"Closed: \" + channel);\n+                        close(channel);\n+                        readReady.countDown();\n+                    }\n+                }\n+            } catch (ClosedByInterruptException ignored) {\n+            } catch (Throwable e) {\n+                if (!done) {\n+                    e.printStackTrace(err);\n+                }\n+            } finally {\n+                done = true;\n+                close(ss);\n+                err.println(\"Stopped at: \" + getURI());\n+            }\n+        });\n+        thread.setName(\"DummySecureWebSocketServer\");\n+        thread.setDaemon(false);\n+    }\n+\n+    \/\/ must be called before open()\n+    public DummySecureWebSocketServer secure() {\n+        secure = true;\n+        return this;\n+    }\n+\n+    protected void read(WebSocketChannel ch) throws IOException {\n+        \/\/ Read until the thread is interrupted or an error occurred\n+        \/\/ or the input is shutdown\n+        ByteBuffer b = ByteBuffer.allocate(65536);\n+        while (ch.read(b) != -1) {\n+            b.flip();\n+            if (read.remaining() < b.remaining()) {\n+                int required = read.capacity() - read.remaining() + b.remaining();\n+                int log2required = 32 - Integer.numberOfLeadingZeros(required - 1);\n+                ByteBuffer newBuffer = ByteBuffer.allocate(1 << log2required);\n+                newBuffer.put(read.flip());\n+                read = newBuffer;\n+            }\n+            read.put(b);\n+            b.clear();\n+        }\n+    }\n+\n+    protected void write(WebSocketChannel ch) throws IOException { }\n+\n+    protected final void serve(WebSocketChannel channel)\n+            throws InterruptedException\n+    {\n+        Thread reader = new Thread(() -> {\n+            try {\n+                read(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        Thread writer = new Thread(() -> {\n+            try {\n+                write(channel);\n+            } catch (IOException ignored) { }\n+        });\n+        reader.start();\n+        writer.start();\n+        try {\n+            while (!done) {\n+                try {\n+                    reader.join(500);\n+                } catch (InterruptedException x) {\n+                    if (done) {\n+                        close(channel);\n+                        break;\n+                    }\n+                }\n+            }\n+        } finally {\n+            reader.interrupt();\n+            try {\n+                while (!done) {\n+                    try {\n+                        writer.join(500);\n+                    } catch (InterruptedException x) {\n+                        if (done) break;\n+                    }\n+                }\n+            } finally {\n+                writer.interrupt();\n+            }\n+        }\n+    }\n+\n+    public ByteBuffer read() throws InterruptedException {\n+        readReady.await();\n+        return read.duplicate().asReadOnlyBuffer().flip();\n+    }\n+\n+    public void open() throws IOException {\n+        err.println(\"Starting\");\n+        if (!started.compareAndSet(false, true)) {\n+            throw new IllegalStateException(\"Already started\");\n+        }\n+        ss = secure ? openWSS() : openWS();\n+        try {\n+            ss.bind(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0));\n+            address = (InetSocketAddress) ss.getLocalAddress();\n+            thread.start();\n+        } catch (IOException e) {\n+            done = true;\n+            close(ss);\n+            throw e;\n+        }\n+        err.println(\"Started at: \" + getURI());\n+    }\n+\n+    @Override\n+    public void close() {\n+        err.println(\"Stopping: \" + getURI());\n+        done = true;\n+        thread.interrupt();\n+        close(ss);\n+    }\n+\n+    URI getURI() {\n+        if (!started.get()) {\n+            throw new IllegalStateException(\"Not yet started\");\n+        }\n+        if (!secure) {\n+            return URI.create(\"ws:\/\/localhost:\" + address.getPort());\n+        } else {\n+            return URI.create(\"wss:\/\/localhost:\" + address.getPort());\n+        }\n+    }\n+\n+    private boolean readRequest(WebSocketChannel channel, StringBuilder request)\n+            throws IOException\n+    {\n+        ByteBuffer buffer = ByteBuffer.allocate(512);\n+        while (channel.read(buffer) != -1) {\n+            \/\/ read the complete HTTP request headers, there should be no body\n+            CharBuffer decoded;\n+            buffer.flip();\n+            try {\n+                decoded = ISO_8859_1.newDecoder().decode(buffer);\n+            } catch (CharacterCodingException e) {\n+                throw new UncheckedIOException(e);\n+            }\n+            request.append(decoded);\n+            if (Pattern.compile(\"\\r\\n\\r\\n\").matcher(request).find())\n+                return true;\n+            buffer.clear();\n+        }\n+        return false;\n+    }\n+\n+    private void writeResponse(WebSocketChannel channel, List<String> response)\n+            throws IOException\n+    {\n+        String s = response.stream().collect(Collectors.joining(\"\\r\\n\"))\n+                + \"\\r\\n\\r\\n\";\n+        ByteBuffer encoded;\n+        try {\n+            encoded = ISO_8859_1.newEncoder().encode(CharBuffer.wrap(s));\n+        } catch (CharacterCodingException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+        while (encoded.hasRemaining()) {\n+            channel.write(encoded);\n+        }\n+    }\n+\n+    private static BiFunction<List<String>,Credentials,List<String>> defaultMapping() {\n+        return (request, credentials) -> {\n+            List<String> response = new LinkedList<>();\n+            Iterator<String> iterator = request.iterator();\n+            if (!iterator.hasNext()) {\n+                throw new IllegalStateException(\"The request is empty\");\n+            }\n+            String statusLine = iterator.next();\n+            if (!(statusLine.startsWith(\"GET \/\") && statusLine.endsWith(\" HTTP\/1.1\"))) {\n+                throw new IllegalStateException\n+                        (\"Unexpected status line: \" + request.get(0));\n+            }\n+            response.add(\"HTTP\/1.1 101 Switching Protocols\");\n+            Map<String, List<String>> requestHeaders = new HashMap<>();\n+            while (iterator.hasNext()) {\n+                String header = iterator.next();\n+                String[] split = header.split(\": \");\n+                if (split.length != 2) {\n+                    throw new IllegalStateException\n+                            (\"Unexpected header: \" + header\n+                                     + \", split=\" + Arrays.toString(split));\n+                }\n+                requestHeaders.computeIfAbsent(split[0], k -> new ArrayList<>()).add(split[1]);\n+\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Protocol\")) {\n+                throw new IllegalStateException(\"Subprotocols are not expected\");\n+            }\n+            if (requestHeaders.containsKey(\"Sec-WebSocket-Extensions\")) {\n+                throw new IllegalStateException(\"Extensions are not expected\");\n+            }\n+            expectHeader(requestHeaders, \"Connection\", \"Upgrade\");\n+            response.add(\"Connection: Upgrade\");\n+            expectHeader(requestHeaders, \"Upgrade\", \"websocket\");\n+            response.add(\"Upgrade: websocket\");\n+            expectHeader(requestHeaders, \"Sec-WebSocket-Version\", \"13\");\n+            List<String> key = requestHeaders.get(\"Sec-WebSocket-Key\");\n+            if (key == null || key.isEmpty()) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key is missing\");\n+            }\n+            if (key.size() != 1) {\n+                throw new IllegalStateException(\"Sec-WebSocket-Key has too many values : \" + key);\n+            }\n+            MessageDigest sha1 = null;\n+            try {\n+                sha1 = MessageDigest.getInstance(\"SHA-1\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new InternalError(e);\n+            }\n+            String x = key.get(0) + \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\";\n+            sha1.update(x.getBytes(ISO_8859_1));\n+            String v = Base64.getEncoder().encodeToString(sha1.digest());\n+            response.add(\"Sec-WebSocket-Accept: \" + v);\n+\n+            \/\/ check authorization credentials, if required by the server\n+            if (credentials != null && !authorized(credentials, requestHeaders)) {\n+                response.clear();\n+                response.add(\"HTTP\/1.1 401 Unauthorized\");\n+                response.add(\"Content-Length: 0\");\n+                response.add(\"WWW-Authenticate: Basic realm=\\\"dummy server realm\\\"\");\n+            }\n+\n+            return response;\n+        };\n+    }\n+\n+    \/\/ Checks credentials in the request against those allowable by the server.\n+    private static boolean authorized(Credentials credentials,\n+                                      Map<String,List<String>> requestHeaders) {\n+        List<String> authorization = requestHeaders.get(\"Authorization\");\n+        if (authorization == null)\n+            return false;\n+\n+        if (authorization.size() != 1) {\n+            throw new IllegalStateException(\"Authorization unexpected count:\" + authorization);\n+        }\n+        String header = authorization.get(0);\n+        if (!header.startsWith(\"Basic \"))\n+            throw new IllegalStateException(\"Authorization not Basic: \" + header);\n+\n+        header = header.substring(\"Basic \".length());\n+        String values = new String(Base64.getDecoder().decode(header), UTF_8);\n+        int sep = values.indexOf(':');\n+        if (sep < 1) {\n+            throw new IllegalStateException(\"Authorization not colon: \" +  values);\n+        }\n+        String name = values.substring(0, sep);\n+        String password = values.substring(sep + 1);\n+\n+        if (name.equals(credentials.name()) && password.equals(credentials.password()))\n+            return true;\n+\n+        return false;\n+    }\n+\n+    protected static String expectHeader(Map<String, List<String>> headers,\n+                                         String name,\n+                                         String value) {\n+        List<String> v = headers.get(name);\n+        if (v == null) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s' header, not present in %s\",\n+                           name, headers));\n+        }\n+        if (!v.contains(value)) {\n+            throw new IllegalStateException(\n+                    format(\"Expected '%s: %s', actual: '%s: %s'\",\n+                           name, value, name, v)\n+            );\n+        }\n+        return value;\n+    }\n+\n+    private static void close(AutoCloseable... acs) {\n+        for (AutoCloseable ac : acs) {\n+            try {\n+                ac.close();\n+            } catch (Exception ignored) { }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/DummySecureWebSocketServer.java","additions":610,"deletions":0,"binary":false,"changes":610,"status":"added"},{"patch":"@@ -0,0 +1,172 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.testng.Assert.assertThrows;\n+\n+\/**\n+ * Helper class to create instances of DummySecureWebSocketServer which\n+ * can support both plain and secure connections.\n+ * The caller should invoke DummySecureWebSocketServer::secure before\n+ * DummySecureWebSocketServer::open in order to enable secure connection.\n+ * When secure, the DummySecureWebSocketServer currently only support using the\n+ * default SSLEngine through the default SSLSocketServerFacrtory.\n+ *\/\n+public class SecureSupport {\n+\n+    private SecureSupport() { }\n+\n+    public static DummySecureWebSocketServer serverWithCannedData(int... data) {\n+        return serverWithCannedDataAndAuthentication(null, null, data);\n+    }\n+\n+    public static DummySecureWebSocketServer serverWithCannedDataAndAuthentication(\n+            String username,\n+            String password,\n+            int... data)\n+    {\n+        byte[] copy = new byte[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            copy[i] = (byte) data[i];\n+        }\n+        return serverWithCannedDataAndAuthentication(username, password, copy);\n+    }\n+\n+    public static DummySecureWebSocketServer serverWithCannedData(byte... data) {\n+       return serverWithCannedDataAndAuthentication(null, null, data);\n+    }\n+\n+    public static DummySecureWebSocketServer serverWithCannedDataAndAuthentication(\n+            String username,\n+            String password,\n+            byte... data)\n+    {\n+        byte[] copy = Arrays.copyOf(data, data.length);\n+        return new DummySecureWebSocketServer(username, password) {\n+            @Override\n+            protected void write(WebSocketChannel ch) throws IOException {\n+                int off = 0; int n = 1; \/\/ 1 byte at a time\n+                while (off + n < copy.length + n) {\n+                    int len = Math.min(copy.length - off, n);\n+                    ByteBuffer bytes = ByteBuffer.wrap(copy, off, len);\n+                    off += len;\n+                    ch.write(bytes);\n+                }\n+                super.write(ch);\n+            }\n+        };\n+    }\n+\n+    \/*\n+     * This server does not read from the wire, allowing its client to fill up\n+     * their send buffer. Used to test scenarios with outstanding send\n+     * operations.\n+     *\/\n+    public static DummySecureWebSocketServer notReadingServer() {\n+        return new DummySecureWebSocketServer() {\n+            @Override\n+            protected void read(WebSocketChannel ch) throws IOException {\n+                try {\n+                    Thread.sleep(Long.MAX_VALUE);\n+                } catch (InterruptedException e) {\n+                    throw new IOException(e);\n+                }\n+            }\n+        };\n+    }\n+\n+    public static DummySecureWebSocketServer writingServer(int... data) {\n+        byte[] copy = new byte[data.length];\n+        for (int i = 0; i < data.length; i++) {\n+            copy[i] = (byte) data[i];\n+        }\n+        return new DummySecureWebSocketServer() {\n+\n+            @Override\n+            protected void read(WebSocketChannel ch) throws IOException {\n+                try {\n+                    Thread.sleep(Long.MAX_VALUE);\n+                } catch (InterruptedException e) {\n+                    throw new IOException(e);\n+                }\n+            }\n+\n+            @Override\n+            protected void write(WebSocketChannel ch) throws IOException {\n+                int off = 0; int n = 1; \/\/ 1 byte at a time\n+                while (off + n < copy.length + n) {\n+                    int len = Math.min(copy.length - off, n);\n+                    ByteBuffer bytes = ByteBuffer.wrap(copy, off, len);\n+                    off += len;\n+                    ch.write(bytes);\n+                }\n+                super.write(ch);\n+            }\n+        };\n+\n+    }\n+\n+    public static String stringWith2NBytes(int n) {\n+        \/\/ -- Russian Alphabet (33 characters, 2 bytes per char) --\n+        char[] abc = {\n+                0x0410, 0x0411, 0x0412, 0x0413, 0x0414, 0x0415, 0x0401, 0x0416,\n+                0x0417, 0x0418, 0x0419, 0x041A, 0x041B, 0x041C, 0x041D, 0x041E,\n+                0x041F, 0x0420, 0x0421, 0x0422, 0x0423, 0x0424, 0x0425, 0x0426,\n+                0x0427, 0x0428, 0x0429, 0x042A, 0x042B, 0x042C, 0x042D, 0x042E,\n+                0x042F,\n+        };\n+        \/\/ repeat cyclically\n+        StringBuilder sb = new StringBuilder(n);\n+        for (int i = 0, j = 0; i < n; i++, j = (j + 1) % abc.length) {\n+            sb.append(abc[j]);\n+        }\n+        String s = sb.toString();\n+        assert s.length() == n && s.getBytes(StandardCharsets.UTF_8).length == 2 * n;\n+        return s;\n+    }\n+\n+    public static String malformedString() {\n+        return new String(new char[]{0xDC00, 0xD800});\n+    }\n+\n+    public static String incompleteString() {\n+        return new String(new char[]{0xD800});\n+    }\n+\n+    public static String stringWithNBytes(int n) {\n+        char[] chars = new char[n];\n+        Arrays.fill(chars, 'A');\n+        return new String(chars);\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/SecureSupport.java","additions":172,"deletions":0,"binary":false,"changes":172,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8217429\n+ * @bug 8217429 8236859\n@@ -28,1 +28,3 @@\n- * @compile DummyWebSocketServer.java ..\/ProxyServer.java\n+ * @library \/lib\/testlibrary\n+ * @compile SecureSupport.java DummySecureWebSocketServer.java ..\/ProxyServer.java\n+ * @build jdk.testlibrary.SimpleSSLContext WebSocketProxyTest\n@@ -30,0 +32,3 @@\n+ *         -Djdk.internal.httpclient.debug=true\n+ *         -Djdk.internal.httpclient.websocket.debug=true\n+ *         -Djdk.httpclient.HttpClient.log=errors,requests,headers\n@@ -55,0 +60,2 @@\n+\n+import jdk.testlibrary.SimpleSSLContext;\n@@ -58,0 +65,3 @@\n+\n+import javax.net.ssl.SSLContext;\n+\n@@ -69,0 +79,8 @@\n+    static {\n+        try {\n+            SSLContext.setDefault(new SimpleSSLContext().get());\n+        } catch (IOException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n@@ -76,1 +94,1 @@\n-    static final Function<int[],DummyWebSocketServer> SERVER_WITH_CANNED_DATA =\n+    static final Function<int[],DummySecureWebSocketServer> SERVER_WITH_CANNED_DATA =\n@@ -78,2 +96,2 @@\n-            @Override public DummyWebSocketServer apply(int[] data) {\n-                return Support.serverWithCannedData(data); }\n+            @Override public DummySecureWebSocketServer apply(int[] data) {\n+                return SecureSupport.serverWithCannedData(data); }\n@@ -83,1 +101,8 @@\n-    static final Function<int[],DummyWebSocketServer> AUTH_SERVER_WITH_CANNED_DATA =\n+    static final Function<int[],DummySecureWebSocketServer> SSL_SERVER_WITH_CANNED_DATA =\n+            new Function<>() {\n+                @Override public DummySecureWebSocketServer apply(int[] data) {\n+                    return SecureSupport.serverWithCannedData(data).secure(); }\n+                @Override public String toString() { return \"SSL_SERVER_WITH_CANNED_DATA\"; }\n+            };\n+\n+    static final Function<int[],DummySecureWebSocketServer> AUTH_SERVER_WITH_CANNED_DATA =\n@@ -85,2 +110,2 @@\n-            @Override public DummyWebSocketServer apply(int[] data) {\n-                return Support.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }\n+            @Override public DummySecureWebSocketServer apply(int[] data) {\n+                return SecureSupport.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data); }\n@@ -90,0 +115,7 @@\n+    static final Function<int[],DummySecureWebSocketServer> AUTH_SSL_SVR_WITH_CANNED_DATA =\n+            new Function<>() {\n+                @Override public DummySecureWebSocketServer apply(int[] data) {\n+                    return SecureSupport.serverWithCannedDataAndAuthentication(USERNAME, PASSWORD, data).secure(); }\n+                @Override public String toString() { return \"AUTH_SSL_SVR_WITH_CANNED_DATA\"; }\n+            };\n+\n@@ -108,3 +140,8 @@\n-            { SERVER_WITH_CANNED_DATA,      TUNNELING_PROXY_SERVER      },\n-            { SERVER_WITH_CANNED_DATA,      AUTH_TUNNELING_PROXY_SERVER },\n-            { AUTH_SERVER_WITH_CANNED_DATA, TUNNELING_PROXY_SERVER      },\n+            { SERVER_WITH_CANNED_DATA,       TUNNELING_PROXY_SERVER      },\n+            { SERVER_WITH_CANNED_DATA,       AUTH_TUNNELING_PROXY_SERVER },\n+            { SSL_SERVER_WITH_CANNED_DATA,   TUNNELING_PROXY_SERVER      },\n+            { SSL_SERVER_WITH_CANNED_DATA,   AUTH_TUNNELING_PROXY_SERVER },\n+            { AUTH_SERVER_WITH_CANNED_DATA,  TUNNELING_PROXY_SERVER      },\n+            { AUTH_SSL_SVR_WITH_CANNED_DATA, TUNNELING_PROXY_SERVER      },\n+            { AUTH_SERVER_WITH_CANNED_DATA,  AUTH_TUNNELING_PROXY_SERVER },\n+            { AUTH_SSL_SVR_WITH_CANNED_DATA, AUTH_TUNNELING_PROXY_SERVER },\n@@ -116,1 +153,1 @@\n-            (Function<int[],DummyWebSocketServer> serverSupplier,\n+            (Function<int[],DummySecureWebSocketServer> serverSupplier,\n@@ -137,0 +174,2 @@\n+            System.out.println(\"Server: \" + server.getURI());\n+            System.out.println(\"Proxy: \" + proxyAddress);\n@@ -212,1 +251,1 @@\n-             var server = new DummyWebSocketServer()){\n+             var server = new DummySecureWebSocketServer()){\n@@ -233,1 +272,24 @@\n-             var server = new DummyWebSocketServer()) {\n+             var server = new DummySecureWebSocketServer()) {\n+            server.open();\n+            InetSocketAddress proxyAddress = new InetSocketAddress(\n+                    InetAddress.getLoopbackAddress(), proxyServer.getPort());\n+\n+            String hv = \"Basic \" + Base64.getEncoder().encodeToString(\n+                    (USERNAME + \":\" + PASSWORD).getBytes(UTF_8));\n+\n+            var webSocket = newBuilder()\n+                    .proxy(ProxySelector.of(proxyAddress)).build()\n+                    .newWebSocketBuilder()\n+                    .header(\"Proxy-Authorization\", hv)\n+                    .buildAsync(server.getURI(), new WebSocket.Listener() { })\n+                    .join();\n+        }\n+    }\n+\n+    \/*\n+     * Ensures authentication succeeds when an `Authorization` header is explicitly set.\n+     *\/\n+    @Test\n+    public void explicitAuthenticate2() throws IOException  {\n+        try (var proxyServer = AUTH_TUNNELING_PROXY_SERVER.get();\n+             var server = new DummySecureWebSocketServer(USERNAME, PASSWORD).secure()) {\n@@ -245,0 +307,1 @@\n+                    .header(\"Authorization\", hv)\n@@ -256,1 +319,1 @@\n-             var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {\n+             var server = new DummySecureWebSocketServer(USERNAME, PASSWORD)) {\n@@ -284,1 +347,1 @@\n-             var server = new DummyWebSocketServer(USERNAME, PASSWORD)) {\n+             var server = new DummySecureWebSocketServer(USERNAME, PASSWORD)) {\n","filename":"test\/jdk\/java\/net\/httpclient\/websocket\/WebSocketProxyTest.java","additions":80,"deletions":17,"binary":false,"changes":97,"status":"modified"}]}