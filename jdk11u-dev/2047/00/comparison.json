{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,7 @@\n-import java.awt.*;\n+import java.awt.Adjustable;\n+import java.awt.Component;\n+import java.awt.Dimension;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.ScrollPane;\n+import java.awt.ScrollPaneAdjustable;\n@@ -108,1 +114,0 @@\n-        setInsets();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WScrollPanePeer.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -527,0 +527,1 @@\n+        s->SetInsets(env);\n@@ -704,1 +705,1 @@\n-    return static_cast<jint>(reinterpret_cast<INT_PTR>(AwtToolkit::GetInstance().SyncCall(\n+    return static_cast<jint>(reinterpret_cast<INT_PTR>(AwtToolkit::GetInstance().InvokeFunction(\n@@ -721,1 +722,1 @@\n-    AwtToolkit::GetInstance().SyncCall(AwtScrollPane::_SetInsets,\n+    AwtToolkit::GetInstance().InvokeFunction(AwtScrollPane::_SetInsets,\n@@ -745,1 +746,1 @@\n-    AwtToolkit::GetInstance().SyncCall(AwtScrollPane::_SetScrollPos, ssps);\n+    AwtToolkit::GetInstance().InvokeFunctionLater(AwtScrollPane::_SetScrollPos, ssps);\n@@ -806,1 +807,1 @@\n-    AwtToolkit::GetInstance().SyncCall(AwtScrollPane::_SetSpans, sss);\n+    AwtToolkit::GetInstance().InvokeFunction(AwtScrollPane::_SetSpans, sss);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_ScrollPane.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-  @bug 4152524\n+  @bug 4152524 8310054\n@@ -60,1 +60,1 @@\n-            f.pack();\n+            \/\/ Frame must not be packed, otherwise the bug isn't reproduced\n","filename":"test\/jdk\/java\/awt\/ScrollPane\/ScrollPaneExtraScrollBar.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,189 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.ScrollPane;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static java.awt.EventQueue.invokeAndWait;\n+\n+\/*\n+ * @test\n+ * @bug 8297923\n+ * @key headful\n+ * @requires os.family==\"windows\"\n+ * @summary Verifies no GDI objects are leaked after scrolling continuously\n+ * @run main\/othervm -Dsun.java2d.d3d=false ScrollPaneLeakTest\n+ *\/\n+public class ScrollPaneLeakTest {\n+\n+    \/**\n+     * The number of times the test repeats scrolling cycles.\n+     *\/\n+    private static final int REPEATS = 1;\n+\n+    \/**\n+     * The number of times the robot moves the scroll bar thumb down and up\n+     * per one cycle.\n+     *\/\n+    private static final int UP_DOWN_CYCLES = 20;\n+\n+    private static final Color CANVAS_FOREGROUND = new Color(200, 240, 200);\n+    private static final Color CANVAS_BACKGROUND = new Color(240, 200, 240);\n+    private static final Color SCROLL_PANE_BACKGROUND = new Color(240, 240, 200);\n+\n+    private static final Dimension CANVAS_SIZE = new Dimension(400, 600);\n+    private static final Dimension FRAME_SIZE = new Dimension(CANVAS_SIZE.width * 2,\n+                                                              3 * CANVAS_SIZE.height \/ 4);\n+    private static final Dimension SCROLL_PANE_SIZE = new Dimension(CANVAS_SIZE.width,\n+                                                                    CANVAS_SIZE.height \/ 2);\n+\n+    private static Frame frame;\n+    private static ScrollPane scroll;\n+\n+    private static final AtomicReference<Rectangle> frameBounds = new AtomicReference<>();\n+\n+    private static final AtomicReference<Rectangle> scrollBounds = new AtomicReference<>();\n+\n+    private static final AtomicReference<Integer> vertBarWidth = new AtomicReference<>();\n+    private static final AtomicReference<Integer> horzBarHeight = new AtomicReference<>();\n+\n+    public static void main(String[] args)\n+            throws InterruptedException, InvocationTargetException, AWTException {\n+        try {\n+            invokeAndWait(ScrollPaneLeakTest::createUI);\n+\n+            final Robot robot = new Robot();\n+            robot.waitForIdle();\n+\n+            invokeAndWait(() -> frame.setExtendedState(frame.getExtendedState()\n+                                                       | Frame.MAXIMIZED_BOTH));\n+            robot.waitForIdle();\n+\n+            invokeAndWait(() -> {\n+                scrollBounds.set(new Rectangle(scroll.getLocationOnScreen(),\n+                                               scroll.getSize()));\n+\n+                vertBarWidth.set(scroll.getVScrollbarWidth());\n+                horzBarHeight.set(scroll.getHScrollbarHeight());\n+            });\n+            robot.waitForIdle();\n+\n+            invokeAndWait(() -> scroll.setScrollPosition(0, 0));\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            final Rectangle sb = scrollBounds.get();\n+            final int vbar = vertBarWidth.get();\n+            final int hbar = horzBarHeight.get() * 2;\n+\n+            final Point pos = new Point();\n+            for (int no = 0; no < REPEATS; no++) {\n+                pos.x = sb.x + sb.width - vbar \/ 3;\n+                pos.y = sb.y + hbar;\n+\n+                robot.mouseMove(pos.x, pos.y);\n+                robot.mousePress(MouseEvent.BUTTON1_DOWN_MASK);\n+                for (int i = 0; i < UP_DOWN_CYCLES; i++) {\n+                    while (++pos.y < sb.y + sb.height - hbar) {\n+                        robot.mouseMove(pos.x, pos.y);\n+                        robot.delay(5);\n+                    }\n+                    while (--pos.y > sb.y + hbar) {\n+                        robot.mouseMove(pos.x, pos.y);\n+                        robot.delay(5);\n+                    }\n+                }\n+                robot.mouseRelease(MouseEvent.BUTTON1_DOWN_MASK);\n+\n+                invokeAndWait(() -> frame.setExtendedState(frame.getExtendedState()\n+                                                           | Frame.ICONIFIED));\n+                robot.delay(500);\n+                invokeAndWait(() -> frame.setExtendedState(frame.getExtendedState()\n+                                                           & ~Frame.ICONIFIED));\n+                robot.delay(500);\n+            }\n+\n+            invokeAndWait(() -> scroll.setScrollPosition(0, sb.height \/ 2));\n+\n+            invokeAndWait(() -> {\n+                Rectangle bounds = frame.getBounds();\n+                frameBounds.set(bounds);\n+            });\n+\n+            \/\/ Throws OutOfMemoryError when the test fails\n+            robot.createScreenCapture(frameBounds.get());\n+\n+            System.out.println(\"Robot created a screenshot: test passed\");\n+        } finally {\n+            invokeAndWait(frame::dispose);\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new Frame(\"Scroll Pane Leak Test\");\n+        frame.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                System.exit(0);\n+            }\n+        });\n+\n+        frame.setLayout(new FlowLayout(FlowLayout.CENTER));\n+        frame.setLocation(0, 0);\n+\n+        Canvas canvas = new Canvas() {\n+            @Override\n+            public void paint(Graphics g) {\n+                g.setColor(CANVAS_FOREGROUND);\n+                g.fillRect(0, 0, getWidth(), getHeight());\n+            }\n+        };\n+        canvas.setBackground(CANVAS_BACKGROUND);\n+        canvas.setSize(CANVAS_SIZE);\n+\n+        scroll = new ScrollPane(ScrollPane.SCROLLBARS_ALWAYS);\n+        scroll.add(canvas);\n+        scroll.setSize(SCROLL_PANE_SIZE);\n+        scroll.setBackground(SCROLL_PANE_BACKGROUND);\n+\n+        frame.add(scroll);\n+        frame.setSize(FRAME_SIZE);\n+\n+        frame.setVisible(true);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/ScrollPane\/ScrollPaneLeakTest.java","additions":189,"deletions":0,"binary":false,"changes":189,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.Frame;\n+import java.awt.Graphics;\n+import java.awt.Point;\n+import java.awt.Robot;\n+import java.awt.ScrollPane;\n+\n+\/*\n+ * @test\n+ * @bug 8311689\n+ * @key headful\n+ * @requires os.family==\"windows\"\n+ * @summary Verifies ScrollPane allows viewing the whole contents of its child\n+ * @run main ScrollPaneScrollEnd\n+ *\/\n+public final class ScrollPaneScrollEnd {\n+    private static final Color CANVAS_BACKGROUND = new Color(255, 200, 200);\n+    private static final Color CANVAS_FOREGROUND = new Color(255, 255, 200);\n+    private static final int OFFSET = 12;\n+\n+    private static final Dimension CANVAS_SIZE = new Dimension(900, 600);\n+    private static final Dimension SCROLL_PANE_SIZE =\n+            new Dimension(CANVAS_SIZE.width \/ 3, CANVAS_SIZE.height \/ 3);\n+    private static final int SCROLL_OFFSET = 100;\n+\n+    private static final int DELAY = 200;\n+\n+    public static void main(String[] args) throws Exception {\n+        Canvas canvas = new Canvas() {\n+            @Override\n+            public void paint(Graphics g) {\n+                g.setColor(CANVAS_BACKGROUND);\n+                g.fillRect(0, 0, getWidth(), getHeight());\n+\n+                g.setColor(CANVAS_FOREGROUND);\n+                g.fillRect(OFFSET, OFFSET,\n+                           getWidth() - OFFSET * 2, getHeight() - OFFSET * 2);\n+            }\n+        };\n+        canvas.setSize(CANVAS_SIZE);\n+\n+        ScrollPane scrollPane = new ScrollPane(ScrollPane.SCROLLBARS_AS_NEEDED);\n+        scrollPane.add(canvas);\n+        scrollPane.setSize(SCROLL_PANE_SIZE);\n+\n+        Frame frame = new Frame(\"ScrollPaneScrollEnd\");\n+        frame.add(scrollPane, \"Center\");\n+        frame.setLocation(100, 100);\n+        frame.pack();\n+        frame.setVisible(true);\n+\n+        final Robot robot = new Robot();\n+        robot.waitForIdle();\n+        robot.delay(DELAY);\n+\n+        final Dimension vp = scrollPane.getViewportSize();\n+        final Point expected = new Point(CANVAS_SIZE.width - vp.width,\n+                                         CANVAS_SIZE.height - vp.height);\n+\n+        scrollPane.setScrollPosition(CANVAS_SIZE.width + SCROLL_OFFSET,\n+                                     CANVAS_SIZE.height + SCROLL_OFFSET);\n+        try {\n+            if (!expected.equals(scrollPane.getScrollPosition())) {\n+                throw new Error(\"Can't scroll to the end of the child component\");\n+            }\n+        } finally {\n+            frame.dispose();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/ScrollPane\/ScrollPaneScrollEnd.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"}]}