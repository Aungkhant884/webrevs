{"files":[{"patch":"@@ -49,0 +49,1 @@\n+  friend class PrepareExtraDataClosure;\n@@ -191,0 +192,4 @@\n+  ciMetadata* cached_metadata(Metadata* o) {\n+    return _factory->cached_metadata(o);\n+  }\n+\n","filename":"src\/hotspot\/share\/ci\/ciEnv.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,1 +56,51 @@\n-void ciMethodData::load_extra_data() {\n+\/\/ Check for entries that reference an unloaded method\n+class PrepareExtraDataClosure : public CleanExtraDataClosure {\n+  MethodData*            _mdo;\n+  uint64_t               _safepoint_counter;\n+  GrowableArray<Method*> _uncached_methods;\n+\n+public:\n+  PrepareExtraDataClosure(MethodData* mdo)\n+    : _mdo(mdo),\n+      _safepoint_counter(SafepointSynchronize::safepoint_counter()),\n+      _uncached_methods()\n+  { }\n+\n+  bool is_live(Method* m) {\n+    if (!m->method_holder()->is_loader_alive()) {\n+      return false;\n+    }\n+    if (CURRENT_ENV->cached_metadata(m) == NULL) {\n+      \/\/ Uncached entries need to be pre-populated.\n+      _uncached_methods.append(m);\n+    }\n+    return true;\n+  }\n+\n+  bool has_safepointed() {\n+    return SafepointSynchronize::safepoint_counter() != _safepoint_counter;\n+  }\n+\n+  bool finish() {\n+    if (_uncached_methods.length() == 0) {\n+      \/\/ Preparation finished iff all Methods* were already cached.\n+      return true;\n+    }\n+    \/\/ Holding locks through safepoints is bad practice.\n+    MutexUnlocker mu(_mdo->extra_data_lock());\n+    for (int i = 0; i < _uncached_methods.length(); ++i) {\n+      if (has_safepointed()) {\n+        \/\/ The metadata in the growable array might contain stale\n+        \/\/ entries after a safepoint.\n+        return false;\n+      }\n+      Method* method = _uncached_methods.at(i);\n+      \/\/ Populating ciEnv caches may cause safepoints due\n+      \/\/ to taking the Compile_lock with safepoint checks.\n+      (void)CURRENT_ENV->get_method(method);\n+    }\n+    return false;\n+  }\n+};\n+\n+void ciMethodData::prepare_metadata() {\n@@ -59,0 +109,16 @@\n+  for (;;) {\n+    ResourceMark rm;\n+    PrepareExtraDataClosure cl(mdo);\n+    mdo->clean_extra_data(&cl);\n+    if (cl.finish()) {\n+      \/\/ When encountering uncached metadata, the Compile_lock might be\n+      \/\/ acquired when creating ciMetadata handles, causing safepoints\n+      \/\/ which requires a new round of preparation to clean out potentially\n+      \/\/ new unloading metadata.\n+      return;\n+    }\n+  }\n+}\n+\n+void ciMethodData::load_extra_data() {\n+  MethodData* mdo = get_MethodData();\n@@ -60,0 +126,5 @@\n+  \/\/ Deferred metadata cleaning due to concurrent class unloading.\n+  prepare_metadata();\n+  \/\/ After metadata preparation, there is no stale metadata,\n+  \/\/ and no safepoints can introduce more stale metadata.\n+  NoSafepointVerifier no_safepoint;\n@@ -72,1 +143,1 @@\n-    \/\/ in the translate_from call below) as we translate the copy:\n+    \/\/ in the prepare_metadata call above) as we translate the copy:\n@@ -86,5 +157,1 @@\n-\n-      { \/\/ During translation a safepoint can happen or VM lock can be taken (e.g., Compile_lock).\n-        MutexUnlocker ml(mdo->extra_data_lock());\n-        data_dst.translate_from(&data_src);\n-      }\n+      data_dst.translate_from(&data_src);\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.cpp","additions":74,"deletions":7,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -476,0 +476,1 @@\n+  void prepare_metadata();\n","filename":"src\/hotspot\/share\/ci\/ciMethodData.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -268,0 +268,18 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciObjectFactory::cached_metadata\n+\/\/\n+\/\/ Get the ciMetadata corresponding to some Metadata. If the ciMetadata has\n+\/\/ already been created, it is returned. Otherwise, null is returned.\n+ciMetadata* ciObjectFactory::cached_metadata(Metadata* key) {\n+  ASSERT_IN_VM;\n+\n+  bool found = false;\n+  int index = _ci_metadata->find_sorted<Metadata*, ciObjectFactory::metadata_compare>(key, found);\n+\n+  if (!found) {\n+    return NULL;\n+  }\n+  return _ci_metadata->at(index)->as_metadata();\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.cpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+  ciMetadata* cached_metadata(Metadata* key);\n","filename":"src\/hotspot\/share\/ci\/ciObjectFactory.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2167,0 +2167,1 @@\n+      MutexLockerEx ml(SafepointSynchronize::is_at_safepoint() ? NULL : mdo->extra_data_lock());\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1653,5 +1653,0 @@\n-class CleanExtraDataClosure : public StackObj {\n-public:\n-  virtual bool is_live(Method* m) = 0;\n-};\n-\n","filename":"src\/hotspot\/share\/oops\/methodData.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1947,1 +1947,5 @@\n-class CleanExtraDataClosure;\n+class CleanExtraDataClosure : public StackObj {\n+public:\n+  virtual bool is_live(Method* m) = 0;\n+};\n+\n@@ -2187,1 +2191,0 @@\n-  void clean_extra_data(CleanExtraDataClosure* cl);\n@@ -2192,0 +2195,2 @@\n+  void clean_extra_data(CleanExtraDataClosure* cl);\n+\n","filename":"src\/hotspot\/share\/oops\/methodData.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"}]}