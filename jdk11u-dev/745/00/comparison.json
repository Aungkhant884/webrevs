{"files":[{"patch":"@@ -48,1 +48,1 @@\n-  if( iff->outcnt() != 2 ) return NULL; \/\/ Ignore partially dead tests\n+  if (iff->outcnt() != 2) return NULL;  \/\/ Ignore partially dead tests\n@@ -52,1 +52,1 @@\n-  if( !is_member(phase->get_loop( iff->raw_out(0) )) )\n+  if (!is_member(phase->get_loop(iff->raw_out(0))))\n@@ -54,1 +54,1 @@\n-  if( !is_member(phase->get_loop( iff->raw_out(1) )) )\n+  if (!is_member(phase->get_loop(iff->raw_out(1))))\n@@ -66,1 +66,1 @@\n-  for( uint i = 0; i < _body.size(); i++ ) {\n+  for (uint i = 0; i < _body.size(); i++) {\n@@ -148,1 +148,3 @@\n-        if (exit->Opcode() == Op_IfFalse) exit_prob = 1.0 - exit_prob;\n+        if (exit->Opcode() == Op_IfFalse) {\n+          exit_prob = 1.0 - exit_prob;\n+        }\n@@ -205,1 +207,1 @@\n-      for( uint i = 0; i < _body.size(); i++ ) {\n+      for (uint i = 0; i < _body.size(); i++) {\n@@ -345,3 +347,4 @@\n-bool IdealLoopTree::policy_peeling( PhaseIdealLoop *phase ) const {\n-  Node *test = ((IdealLoopTree*)this)->tail();\n-  int  body_size = ((IdealLoopTree*)this)->_body.size();\n+bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) const {\n+  IdealLoopTree *loop = (IdealLoopTree*)this;\n+  Node *test = loop->tail();\n+  int body_size = loop->_body.size();\n@@ -349,2 +352,2 @@\n-  if( body_size > 255 \/* Prevent overflow for large body_size *\/\n-      || (body_size * body_size + phase->C->live_nodes()) > phase->C->max_node_limit() ) {\n+  if (body_size > 255 \/* Prevent overflow for large body_size *\/\n+      || (body_size * body_size + phase->C->live_nodes()) > phase->C->max_node_limit()) {\n@@ -362,2 +365,2 @@\n-  while( test != _head ) {      \/\/ Scan till run off top of loop\n-    if( test->is_If() ) {       \/\/ Test?\n+  while (test != _head) {       \/\/ Scan till run off top of loop\n+    if (test->is_If()) {        \/\/ Test?\n@@ -365,1 +368,1 @@\n-      if (ctrl->is_top())\n+      if (ctrl->is_top()) {\n@@ -367,0 +370,1 @@\n+      }\n@@ -368,1 +372,4 @@\n-      assert(test->Opcode() == Op_If || test->Opcode() == Op_CountedLoopEnd || test->Opcode() == Op_RangeCheck, \"Check this code when new subtype is added\");\n+      assert(test->Opcode() == Op_If ||\n+             test->Opcode() == Op_CountedLoopEnd ||\n+             test->Opcode() == Op_RangeCheck,\n+             \"Check this code when new subtype is added\");\n@@ -370,2 +377,1 @@\n-      if( !is_member(phase->get_loop(ctrl)) &&\n-          is_loop_exit(test) )\n+      if (!is_member(phase->get_loop(ctrl)) && is_loop_exit(test)) {\n@@ -373,0 +379,1 @@\n+      }\n@@ -558,1 +565,1 @@\n-void PhaseIdealLoop::do_peeling( IdealLoopTree *loop, Node_List &old_new ) {\n+void PhaseIdealLoop::do_peeling(IdealLoopTree *loop, Node_List &old_new) {\n@@ -607,1 +614,1 @@\n-      if (!new_exit_value )     \/\/ Backedge value is ALSO loop invariant?\n+      if (!new_exit_value)     \/\/ Backedge value is ALSO loop invariant?\n@@ -636,1 +643,1 @@\n-    if (!has_ctrl(nnn))\n+    if (!has_ctrl(nnn)) {\n@@ -638,0 +645,1 @@\n+    }\n@@ -652,1 +660,1 @@\n-bool IdealLoopTree::policy_maximally_unroll( PhaseIdealLoop *phase ) const {\n+bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop *phase) const {\n@@ -655,1 +663,1 @@\n-  if (!cl->is_valid_counted_loop())\n+  if (!cl->is_valid_counted_loop()) {\n@@ -657,1 +665,1 @@\n-\n+  }\n@@ -673,1 +681,1 @@\n-  assert( (intx)unroll_limit == LoopUnrollLimit * 4, \"LoopUnrollLimit must fit in 32bits\");\n+  assert((intx)unroll_limit == LoopUnrollLimit * 4, \"LoopUnrollLimit must fit in 32bits\");\n@@ -925,1 +933,1 @@\n-bool IdealLoopTree::policy_align( PhaseIdealLoop *phase ) const {\n+bool IdealLoopTree::policy_align(PhaseIdealLoop *phase) const {\n@@ -932,1 +940,1 @@\n-bool IdealLoopTree::policy_range_check( PhaseIdealLoop *phase ) const {\n+bool IdealLoopTree::policy_range_check(PhaseIdealLoop *phase) const {\n@@ -954,1 +962,3 @@\n-      if (bol->req() != 2) continue; \/\/ dead constant test\n+      if (bol->req() != 2) {\n+        continue; \/\/ dead constant test\n+      }\n@@ -959,1 +969,1 @@\n-      if (bol->as_Bool()->_test._test == BoolTest::ne)\n+      if (bol->as_Bool()->_test._test == BoolTest::ne) {\n@@ -961,1 +971,1 @@\n-\n+      }\n@@ -967,1 +977,1 @@\n-      if( limit_c == phase->C->top() )\n+      if (limit_c == phase->C->top()) {\n@@ -969,1 +979,2 @@\n-      if( is_member(phase->get_loop(limit_c) ) ) {\n+      }\n+      if (is_member(phase->get_loop(limit_c))) {\n@@ -974,1 +985,1 @@\n-        if( is_member(phase->get_loop(limit_c) ) )\n+        if (is_member(phase->get_loop(limit_c))) {\n@@ -976,0 +987,1 @@\n+        }\n@@ -984,1 +996,1 @@\n-      if( is_loop_exit(iff) )\n+      if (is_loop_exit(iff)) {\n@@ -986,0 +998,1 @@\n+      }\n@@ -995,1 +1008,1 @@\n-bool IdealLoopTree::policy_peel_only( PhaseIdealLoop *phase ) const {\n+bool IdealLoopTree::policy_peel_only(PhaseIdealLoop *phase) const {\n@@ -1001,2 +1014,2 @@\n-  for( uint i = 0; i < _body.size(); i++ )\n-    if( _body[i]->is_Mem() )\n+  for (uint i = 0; i < _body.size(); i++) {\n+    if (_body[i]->is_Mem()) {\n@@ -1004,1 +1017,2 @@\n-\n+    }\n+  }\n@@ -1012,2 +1026,2 @@\n-Node *PhaseIdealLoop::clone_up_backedge_goo( Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &visited, Node_Stack &clones ) {\n-  if( get_ctrl(n) != back_ctrl ) return n;\n+Node *PhaseIdealLoop::clone_up_backedge_goo(Node *back_ctrl, Node *preheader_ctrl, Node *n, VectorSet &visited, Node_Stack &clones) {\n+  if (get_ctrl(n) != back_ctrl) return n;\n@@ -1018,3 +1032,1 @@\n-    if (x != NULL)\n-      return x;\n-    return n;\n+    return (x != NULL) ? x : n;\n@@ -1025,1 +1037,1 @@\n-  if( n->in(0) && n->in(0) == back_ctrl ) {\n+  if (n->in(0) && n->in(0) == back_ctrl) {\n@@ -1029,1 +1041,1 @@\n-    x->set_req( 0, preheader_ctrl ); \/\/ Fix x's control input to preheader\n+    x->set_req(0, preheader_ctrl); \/\/ Fix x's control input to preheader\n@@ -1035,4 +1047,4 @@\n-  for( uint i = 1; i < n->req(); i++ ) {\n-    Node *g = clone_up_backedge_goo( back_ctrl, preheader_ctrl, n->in(i), visited, clones );\n-    if( g != n->in(i) ) {\n-      if( !x ) {\n+  for (uint i = 1; i < n->req(); i++) {\n+    Node *g = clone_up_backedge_goo(back_ctrl, preheader_ctrl, n->in(i), visited, clones);\n+    if (g != n->in(i)) {\n+      if (!x) {\n@@ -1046,2 +1058,2 @@\n-  if( x ) {                     \/\/ x can legally float to pre-header location\n-    register_new_node( x, preheader_ctrl );\n+  if (x) {                     \/\/ x can legally float to pre-header location\n+    register_new_node(x, preheader_ctrl);\n@@ -1050,1 +1062,1 @@\n-    set_ctrl( n, find_non_split_ctrl(back_ctrl->in(0)) );\n+    set_ctrl(n, find_non_split_ctrl(back_ctrl->in(0)));\n@@ -1336,1 +1348,1 @@\n-void PhaseIdealLoop::insert_pre_post_loops( IdealLoopTree *loop, Node_List &old_new, bool peel_only ) {\n+void PhaseIdealLoop::insert_pre_post_loops(IdealLoopTree *loop, Node_List &old_new, bool peel_only) {\n@@ -1351,1 +1363,1 @@\n-  assert( main_head->is_normal_loop(), \"\" );\n+  assert(main_head->is_normal_loop(), \"\");\n@@ -1353,1 +1365,1 @@\n-  assert( main_end->outcnt() == 2, \"1 true, 1 false path only\" );\n+  assert(main_end->outcnt() == 2, \"1 true, 1 false path only\");\n@@ -1365,1 +1377,1 @@\n-  if( bol->outcnt() != 1 ) {\n+  if (bol->outcnt() != 1) {\n@@ -1371,1 +1383,1 @@\n-  if( cmp->outcnt() != 1 ) {\n+  if (cmp->outcnt() != 1) {\n@@ -1408,1 +1420,1 @@\n-  assert( pre_exit->Opcode() == Op_IfFalse, \"\" );\n+  assert(pre_exit->Opcode() == Op_IfFalse, \"\");\n@@ -1410,1 +1422,1 @@\n-  _igvn.register_new_node_with_optimizer( new_pre_exit );\n+  _igvn.register_new_node_with_optimizer(new_pre_exit);\n@@ -1419,5 +1431,5 @@\n-  Node *min_cmp  = new CmpINode( pre_incr, min_opaq );\n-  Node *min_bol  = new BoolNode( min_cmp, b_test );\n-  register_new_node( min_opaq, new_pre_exit );\n-  register_new_node( min_cmp , new_pre_exit );\n-  register_new_node( min_bol , new_pre_exit );\n+  Node *min_cmp  = new CmpINode(pre_incr, min_opaq);\n+  Node *min_bol  = new BoolNode(min_cmp, b_test);\n+  register_new_node(min_opaq, new_pre_exit);\n+  register_new_node(min_cmp , new_pre_exit);\n+  register_new_node(min_bol , new_pre_exit);\n@@ -1426,2 +1438,2 @@\n-  IfNode *min_iff = new IfNode( new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN );\n-  _igvn.register_new_node_with_optimizer( min_iff );\n+  IfNode *min_iff = new IfNode(new_pre_exit, min_bol, PROB_ALWAYS, COUNT_UNKNOWN);\n+  _igvn.register_new_node_with_optimizer(min_iff);\n@@ -1432,1 +1444,1 @@\n-  _igvn.hash_delete( pre_exit );\n+  _igvn.hash_delete(pre_exit);\n@@ -1437,2 +1449,2 @@\n-  Node *min_taken = new IfTrueNode( min_iff );\n-  _igvn.register_new_node_with_optimizer( min_taken );\n+  Node *min_taken = new IfTrueNode(min_iff);\n+  _igvn.register_new_node_with_optimizer(min_taken);\n@@ -1453,1 +1465,1 @@\n-    if( main_phi->is_Phi() && main_phi->in(0) == main_head && main_phi->outcnt() > 0 ) {\n+    if (main_phi->is_Phi() && main_phi->in(0) == main_head && main_phi->outcnt() > 0) {\n@@ -1460,1 +1472,1 @@\n-      main_phi->set_req( LoopNode::EntryControl, fallpre );\n+      main_phi->set_req(LoopNode::EntryControl, fallpre);\n@@ -1475,1 +1487,1 @@\n-  Node* castii = cast_incr_before_loop( pre_incr, min_taken, main_head );\n+  Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);\n@@ -1484,2 +1496,2 @@\n-  assert( cmp_end->in(2) == limit, \"\" );\n-  Node *pre_limit = new AddINode( init, stride );\n+  assert(cmp_end->in(2) == limit, \"\");\n+  Node *pre_limit = new AddINode(init, stride);\n@@ -1491,2 +1503,2 @@\n-  register_new_node( pre_limit, pre_head->in(0) );\n-  register_new_node( pre_opaq , pre_head->in(0) );\n+  register_new_node(pre_limit, pre_head->in(0));\n+  register_new_node(pre_opaq , pre_head->in(0));\n@@ -1495,1 +1507,1 @@\n-  assert( cmp_end->outcnt() == 1, \"no other users\" );\n+  assert(cmp_end->outcnt() == 1, \"no other users\");\n@@ -1515,1 +1527,1 @@\n-    register_new_node( new_bol0, pre_head->in(0) );\n+    register_new_node(new_bol0, pre_head->in(0));\n@@ -1520,1 +1532,1 @@\n-    register_new_node( new_bol1, new_pre_exit );\n+    register_new_node(new_bol1, new_pre_exit);\n@@ -1526,1 +1538,1 @@\n-    register_new_node( new_bol2, main_end->in(CountedLoopEndNode::TestControl) );\n+    register_new_node(new_bol2, main_end->in(CountedLoopEndNode::TestControl));\n@@ -1532,1 +1544,3 @@\n-  if( peel_only ) main_head->set_main_no_pre_loop();\n+  if (peel_only) {\n+    main_head->set_main_no_pre_loop();\n+  }\n@@ -1551,2 +1565,3 @@\n-\/\/ unroll_policy has already informed us that more unrolling is about to happen to\n-\/\/ the main loop.  The resultant post loop will serve as a vectorized drain loop.\n+\/\/ unroll_policy has  already informed  us that more  unrolling is  about to\n+\/\/ happen  to the  main  loop.  The  resultant  post loop  will  serve as  a\n+\/\/ vectorized drain loop.\n@@ -1801,1 +1816,1 @@\n-void PhaseIdealLoop::do_unroll( IdealLoopTree *loop, Node_List &old_new, bool adjust_min_trip ) {\n+void PhaseIdealLoop::do_unroll(IdealLoopTree *loop, Node_List &old_new, bool adjust_min_trip) {\n@@ -1824,2 +1839,2 @@\n-    rpo( loop_head, stack, visited, rpo_list );\n-    dump(loop, rpo_list.size(), rpo_list );\n+    rpo(loop_head, stack, visited, rpo_list);\n+    dump(loop, rpo_list.size(), rpo_list);\n@@ -1920,2 +1935,2 @@\n-        limit = new Opaque2Node( C, limit );\n-        register_new_node( limit, opaq_ctrl );\n+        limit = new Opaque2Node(C, limit);\n+        register_new_node(limit, opaq_ctrl);\n@@ -1962,1 +1977,1 @@\n-        register_new_node( adj_limit, ctrl ); \/\/ adjust amount\n+        register_new_node(adj_limit, ctrl); \/\/ adjust amount\n@@ -1964,1 +1979,1 @@\n-        register_new_node( adj_cmp, ctrl );\n+        register_new_node(adj_cmp, ctrl);\n@@ -1966,1 +1981,1 @@\n-        register_new_node( adj_bool, ctrl );\n+        register_new_node(adj_bool, ctrl);\n@@ -2020,1 +2035,1 @@\n-    if( phi->is_Phi() && phi->in(0) == loop_head && phi->outcnt() > 0 ) {\n+    if (phi->is_Phi() && phi->in(0) == loop_head && phi->outcnt() > 0) {\n@@ -2022,2 +2037,2 @@\n-      _igvn.hash_delete( phi );\n-      _igvn.hash_delete( newphi );\n+      _igvn.hash_delete(phi);\n+      _igvn.hash_delete(newphi);\n@@ -2031,1 +2046,1 @@\n-  _igvn.hash_delete( clone_head );\n+  _igvn.hash_delete(clone_head);\n@@ -2042,1 +2057,1 @@\n-  _igvn.hash_delete( newcle );\n+  _igvn.hash_delete(newcle);\n@@ -2048,1 +2063,1 @@\n-  for( uint k = 0; k < max; k++ ) {\n+  for (uint k = 0; k < max; k++) {\n@@ -2052,1 +2067,1 @@\n-    if (!has_ctrl(old))\n+    if (!has_ctrl(old)) {\n@@ -2054,0 +2069,1 @@\n+    }\n@@ -2065,1 +2081,1 @@\n-    if(C->clone_map().is_debug()) {\n+    if (C->clone_map().is_debug()) {\n@@ -2086,1 +2102,1 @@\n-void PhaseIdealLoop::do_maximally_unroll( IdealLoopTree *loop, Node_List &old_new ) {\n+void PhaseIdealLoop::do_maximally_unroll(IdealLoopTree *loop, Node_List &old_new) {\n@@ -2289,1 +2305,1 @@\n-    register_new_node( plus_one, pre_ctrl );\n+    register_new_node(plus_one, pre_ctrl);\n@@ -2430,1 +2446,1 @@\n-int PhaseIdealLoop::do_range_check( IdealLoopTree *loop, Node_List &old_new ) {\n+int PhaseIdealLoop::do_range_check(IdealLoopTree *loop, Node_List &old_new) {\n@@ -2440,0 +2456,1 @@\n+\n@@ -2446,1 +2463,1 @@\n-  if (!cl->stride_is_con())\n+  if (!cl->stride_is_con()) {\n@@ -2448,1 +2465,1 @@\n-\n+  }\n@@ -2463,1 +2480,1 @@\n-  Node *ctrl  = cl->skip_predicates();\n+  Node *ctrl = cl->skip_predicates();\n@@ -2481,1 +2498,1 @@\n-  if (pre_opaq1->Opcode() != Op_Opaque1)\n+  if (pre_opaq1->Opcode() != Op_Opaque1) {\n@@ -2483,0 +2500,1 @@\n+  }\n@@ -2492,1 +2510,1 @@\n-  if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP)\n+  if (orig_limit == NULL || _igvn.type(orig_limit) == Type::TOP) {\n@@ -2494,1 +2512,1 @@\n-\n+  }\n@@ -2512,0 +2530,1 @@\n+\n@@ -2513,1 +2532,1 @@\n-  for( uint i = 0; i < loop->_body.size(); i++ ) {\n+  for (uint i = 0; i < loop->_body.size(); i++) {\n@@ -2521,1 +2540,1 @@\n-      if( !exit ) continue;\n+      if (!exit) continue;\n@@ -2526,1 +2545,1 @@\n-      if( !i1->is_Bool() ) continue;\n+      if (!i1->is_Bool()) continue;\n@@ -2530,1 +2549,1 @@\n-      if( flip )\n+      if (flip) {\n@@ -2532,1 +2551,1 @@\n-\n+      }\n@@ -2542,1 +2561,1 @@\n-      if( loop->is_member(get_loop(limit_c) ) ) {\n+      if (loop->is_member(get_loop(limit_c))) {\n@@ -2548,1 +2567,1 @@\n-        if( loop->is_member(get_loop(limit_c) ) )\n+        if (loop->is_member(get_loop(limit_c))) {\n@@ -2550,0 +2569,1 @@\n+        }\n@@ -2568,1 +2588,1 @@\n-      if( loop->is_member( get_loop(offset_c) ) )\n+      if (loop->is_member(get_loop(offset_c))) {\n@@ -2570,0 +2590,1 @@\n+      }\n@@ -2600,2 +2621,2 @@\n-      if( cmp->Opcode() == Op_CmpU ) {\/\/ Unsigned compare is really 2 tests\n-        if( b_test._test == BoolTest::lt ) { \/\/ Range checks always use lt\n+      if (cmp->Opcode() == Op_CmpU) {\/\/ Unsigned compare is really 2 tests\n+        if (b_test._test == BoolTest::lt) { \/\/ Range checks always use lt\n@@ -2632,1 +2653,1 @@\n-        switch( b_test._test ) {\n+        switch (b_test._test) {\n@@ -2639,1 +2660,1 @@\n-          register_new_node( offset, pre_ctrl );\n+          register_new_node(offset, pre_ctrl);\n@@ -2641,1 +2662,1 @@\n-          register_new_node( limit, pre_ctrl );\n+          register_new_node(limit, pre_ctrl);\n@@ -2647,1 +2668,1 @@\n-            register_new_node( limit, pre_ctrl );\n+            register_new_node(limit, pre_ctrl);\n@@ -2666,1 +2687,1 @@\n-      Node *kill_con = _igvn.intcon( 1-flip );\n+      Node *kill_con = _igvn.intcon(1-flip);\n@@ -2686,1 +2707,0 @@\n-\n@@ -2688,1 +2708,0 @@\n-\n@@ -2710,3 +2729,3 @@\n-  if( main_bol->outcnt() > 1 ) {\/\/ BoolNode shared?\n-    main_bol = main_bol->clone();\/\/ Clone a private BoolNode\n-    register_new_node( main_bol, main_cle->in(0) );\n+  if (main_bol->outcnt() > 1) {     \/\/ BoolNode shared?\n+    main_bol = main_bol->clone();   \/\/ Clone a private BoolNode\n+    register_new_node(main_bol, main_cle->in(0));\n@@ -2716,3 +2735,3 @@\n-  if( main_cmp->outcnt() > 1 ) { \/\/ CmpNode shared?\n-    main_cmp = main_cmp->clone();\/\/ Clone a private CmpNode\n-    register_new_node( main_cmp, main_cle->in(0) );\n+  if (main_cmp->outcnt() > 1) {    \/\/ CmpNode shared?\n+    main_cmp = main_cmp->clone();   \/\/ Clone a private CmpNode\n+    register_new_node(main_cmp, main_cle->in(0));\n@@ -2734,1 +2753,1 @@\n-  assert( opqzm->outcnt() == 1, \"cannot hack shared node\" );\n+  assert(opqzm->outcnt() == 1, \"cannot hack shared node\");\n@@ -2903,3 +2922,5 @@\n-  for( uint i = 0; i < _body.size(); i++ )\n-    if( _body.at(i)->outcnt() == 0 )\n-      _body.map( i--, _body.pop() );\n+  for (uint i = 0; i < _body.size(); i++) {\n+    if (_body.at(i)->outcnt() == 0) {\n+      _body.map(i--, _body.pop());\n+    }\n+  }\n@@ -2912,1 +2933,1 @@\n-void IdealLoopTree::adjust_loop_exit_prob( PhaseIdealLoop *phase ) {\n+void IdealLoopTree::adjust_loop_exit_prob(PhaseIdealLoop *phase) {\n@@ -2914,1 +2935,1 @@\n-  while( test != _head ) {\n+  while (test != _head) {\n@@ -2916,1 +2937,1 @@\n-    if( top == Op_IfTrue || top == Op_IfFalse ) {\n+    if (top == Op_IfTrue || top == Op_IfFalse) {\n@@ -2920,1 +2941,1 @@\n-      if( iff->outcnt() == 2 ) {        \/\/ Ignore dead tests\n+      if (iff->outcnt() == 2) {        \/\/ Ignore dead tests\n@@ -2922,4 +2943,4 @@\n-        if( bol && bol->req() > 1 && bol->in(1) &&\n-            ((bol->in(1)->Opcode() == Op_StorePConditional ) ||\n-             (bol->in(1)->Opcode() == Op_StoreIConditional ) ||\n-             (bol->in(1)->Opcode() == Op_StoreLConditional ) ||\n+        if (bol && bol->req() > 1 && bol->in(1) &&\n+            ((bol->in(1)->Opcode() == Op_StorePConditional) ||\n+             (bol->in(1)->Opcode() == Op_StoreIConditional) ||\n+             (bol->in(1)->Opcode() == Op_StoreLConditional) ||\n@@ -2927,6 +2948,6 @@\n-             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndExchangeP ) ||\n-             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndExchangeN ) ||\n-             (bol->in(1)->Opcode() == Op_ShenandoahWeakCompareAndSwapP ) ||\n-             (bol->in(1)->Opcode() == Op_ShenandoahWeakCompareAndSwapN ) ||\n-             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndSwapP ) ||\n-             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndSwapN ) ||\n+             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndExchangeP) ||\n+             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndExchangeN) ||\n+             (bol->in(1)->Opcode() == Op_ShenandoahWeakCompareAndSwapP) ||\n+             (bol->in(1)->Opcode() == Op_ShenandoahWeakCompareAndSwapN) ||\n+             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndSwapP) ||\n+             (bol->in(1)->Opcode() == Op_ShenandoahCompareAndSwapN) ||\n@@ -2934,18 +2955,18 @@\n-             (bol->in(1)->Opcode() == Op_CompareAndExchangeB ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndExchangeS ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndExchangeI ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndExchangeL ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndExchangeP ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndExchangeN ) ||\n-             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapB ) ||\n-             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapS ) ||\n-             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapI ) ||\n-             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapL ) ||\n-             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapP ) ||\n-             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapN ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndSwapB ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndSwapS ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndSwapI ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndSwapL ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndSwapP ) ||\n-             (bol->in(1)->Opcode() == Op_CompareAndSwapN )))\n+             (bol->in(1)->Opcode() == Op_CompareAndExchangeB) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndExchangeS) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndExchangeI) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndExchangeL) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndExchangeP) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndExchangeN) ||\n+             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapB) ||\n+             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapS) ||\n+             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapI) ||\n+             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapL) ||\n+             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapP) ||\n+             (bol->in(1)->Opcode() == Op_WeakCompareAndSwapN) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndSwapB) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndSwapS) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndSwapI) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndSwapL) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndSwapP) ||\n+             (bol->in(1)->Opcode() == Op_CompareAndSwapN)))\n@@ -2956,3 +2977,3 @@\n-        if( !phase->is_member( this, ex ) && iff->_fcnt == COUNT_UNKNOWN ) {\n-          if( top == Op_IfTrue ) {\n-            if( p < (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {\n+        if (!phase->is_member(this, ex) && iff->_fcnt == COUNT_UNKNOWN) {\n+          if (top == Op_IfTrue) {\n+            if (p < (PROB_FAIR + PROB_UNLIKELY_MAG(3))) {\n@@ -2962,1 +2983,1 @@\n-            if( p > (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {\n+            if (p > (PROB_FAIR - PROB_UNLIKELY_MAG(3))) {\n@@ -3031,1 +3052,1 @@\n-  if (_body.size() > EMPTY_LOOP_SIZE)\n+  if (_body.size() > EMPTY_LOOP_SIZE) {\n@@ -3033,3 +3054,4 @@\n-\n-  if (!_head->is_CountedLoop())\n-    return false;     \/\/ Dead loop\n+  }\n+  if (!_head->is_CountedLoop()) {\n+    return false;   \/\/ Dead loop\n+  }\n@@ -3037,5 +3059,6 @@\n-  if (!cl->is_valid_counted_loop())\n-    return false; \/\/ Malformed loop\n-  if (!phase->is_member(this, phase->get_ctrl(cl->loopexit()->in(CountedLoopEndNode::TestValue))))\n-    return false;             \/\/ Infinite loop\n-\n+  if (!cl->is_valid_counted_loop()) {\n+    return false;   \/\/ Malformed loop\n+  }\n+  if (!phase->is_member(this, phase->get_ctrl(cl->loopexit()->in(CountedLoopEndNode::TestValue)))) {\n+    return false;   \/\/ Infinite loop\n+  }\n@@ -3043,2 +3066,2 @@\n-    \/\/ If the loop we are removing is a pre-loop then the main and\n-    \/\/ post loop can be removed as well\n+    \/\/ If the loop we are removing is a pre-loop then the main and post loop\n+    \/\/ can be removed as well.\n@@ -3054,1 +3077,1 @@\n-      assert(iv == NULL, \"Too many phis\" );\n+      assert(iv == NULL, \"Too many phis\");\n@@ -3058,1 +3081,1 @@\n-  assert(iv == cl->phi(), \"Wrong phi\" );\n+  assert(iv == cl->phi(), \"Wrong phi\");\n@@ -3139,1 +3162,1 @@\n-  Node *final = new SubINode( exact_limit, cl->stride() );\n+  Node *final = new SubINode(exact_limit, cl->stride());\n@@ -3158,1 +3181,1 @@\n-  if(TraceLoopOpts) {\n+  if (TraceLoopOpts) {\n@@ -3179,1 +3202,1 @@\n-bool IdealLoopTree::iteration_split_impl( PhaseIdealLoop *phase, Node_List &old_new ) {\n+bool IdealLoopTree::iteration_split_impl(PhaseIdealLoop *phase, Node_List &old_new) {\n@@ -3307,3 +3330,2 @@\n-    \/\/ Adjust the pre-loop limits to align the main body\n-    \/\/ iterations.\n-    if (should_align)\n+    \/\/ Adjust the pre-loop limits to align the main body iterations.\n+    if (should_align) {\n@@ -3311,1 +3333,1 @@\n-\n+    }\n@@ -3313,1 +3335,1 @@\n-    if (should_peel)           \/\/ Might want to peel but do nothing else\n+    if (should_peel) {          \/\/ Might want to peel but do nothing else\n@@ -3315,0 +3337,1 @@\n+    }\n@@ -3322,1 +3345,1 @@\n-bool IdealLoopTree::iteration_split( PhaseIdealLoop *phase, Node_List &old_new ) {\n+bool IdealLoopTree::iteration_split(PhaseIdealLoop* phase, Node_List &old_new) {\n@@ -3324,1 +3347,1 @@\n-  if (_child && !_child->iteration_split(phase, old_new))\n+  if (_child && !_child->iteration_split(phase, old_new)) {\n@@ -3326,0 +3349,1 @@\n+  }\n@@ -3352,1 +3376,1 @@\n-  if (_next && !_next->iteration_split(phase, old_new))\n+  if (_next && !_next->iteration_split(phase, old_new)) {\n@@ -3354,0 +3378,1 @@\n+  }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":219,"deletions":194,"binary":false,"changes":413,"status":"modified"}]}