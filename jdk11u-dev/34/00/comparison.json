{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,1 +68,1 @@\n-    LIBS_linux := -lthread_db $(LIBDL), \\\n+    LIBS_linux := $(LIBDL), \\\n","filename":"make\/lib\/Lib-jdk.hotspot.agent.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+#include \"proc_service.h\"\n@@ -244,1 +245,1 @@\n- * Signature: (IZ)V\n+ * Signature: (I)V\n@@ -246,2 +247,2 @@\n-JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__IZ\n-  (JNIEnv *env, jobject this_obj, jint jpid, jboolean is_in_container) {\n+JNIEXPORT void JNICALL Java_sun_jvm_hotspot_debugger_linux_LinuxDebuggerLocal_attach0__I\n+  (JNIEnv *env, jobject this_obj, jint jpid) {\n@@ -257,1 +258,1 @@\n-  if ((ph = Pgrab(jpid, err_buf, sizeof(err_buf), is_in_container)) == NULL) {\n+  if ((ph = Pgrab(jpid, err_buf, sizeof(err_buf))) == NULL) {\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.c","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"proc_service.h\"\n@@ -33,0 +32,1 @@\n+#include <sys\/procfs.h>\n@@ -35,31 +35,0 @@\n-\/************************************************************************************\n-\n-0. This is very minimal subset of Solaris libproc just enough for current application.\n-Please note that the bulk of the functionality is from proc_service interface. This\n-adds Pgrab__ and some missing stuff. We hide the difference b\/w live process and core\n-file by this interface.\n-\n-1. pthread_id unique in both NPTL & LinuxThreads. We store this in\n-OSThread::_pthread_id in JVM code.\n-\n-2. All threads see the same pid when they call getpid() under NPTL.\n-Threads receive different pid under LinuxThreads. We used to save the result of\n-::getpid() call in OSThread::_thread_id. This way uniqueness of OSThread::_thread_id\n-was lost under NPTL. Now, we store the result of ::gettid() call in\n-OSThread::_thread_id. Because gettid returns actual pid of thread (lwp id), this is\n-unique again. We therefore use OSThread::_thread_id as unique identifier.\n-\n-3. There is a unique LWP id under both thread libraries. libthread_db  maps pthread_id\n-to its underlying lwp_id under both the thread libraries. thread_info.lwp_id stores\n-lwp_id of the thread. The lwp id is nothing but the actual pid of clone'd processes. But\n-unfortunately libthread_db does not work very well for core dumps. So, we get pthread_id\n-only for processes. For core dumps, we don't use libthread_db at all (like gdb).\n-\n-4. ptrace operates on this LWP id under both the thread libraries. When we say 'pid' for\n-ptrace call, we refer to lwp_id of the thread.\n-\n-5. for core file, we parse ELF files and read data from them. For processes we  use\n-combination of ptrace and \/proc calls.\n-\n-*************************************************************************************\/\n-\n@@ -90,1 +59,1 @@\n-Pgrab(pid_t pid, char* err_buf, size_t err_buf_len, bool is_in_container);\n+Pgrab(pid_t pid, char* err_buf, size_t err_buf_len);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/libproc.h","additions":3,"deletions":34,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include <thread_db.h>\n+#include <sys\/procfs.h>\n@@ -31,0 +31,1 @@\n+#include \"proc_service.h\"\n@@ -119,7 +120,0 @@\n-\n-   \/\/ initialize the thread_db library\n-   if (td_init() != TD_OK) {\n-     print_debug(\"libthread_db's td_init failed\\n\");\n-     return false;\n-   }\n-\n@@ -259,1 +253,1 @@\n-thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {\n+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id) {\n@@ -267,1 +261,0 @@\n-   newthr->pthread_id = pthread_id;\n@@ -298,58 +291,0 @@\n-\/\/ struct used for client data from thread_db callback\n-struct thread_db_client_data {\n-   struct ps_prochandle* ph;\n-   thread_info_callback callback;\n-};\n-\n-\/\/ callback function for libthread_db\n-static int thread_db_callback(const td_thrhandle_t *th_p, void *data) {\n-  struct thread_db_client_data* ptr = (struct thread_db_client_data*) data;\n-  td_thrinfo_t ti;\n-  td_err_e err;\n-\n-  memset(&ti, 0, sizeof(ti));\n-  err = td_thr_get_info(th_p, &ti);\n-  if (err != TD_OK) {\n-    print_debug(\"libthread_db : td_thr_get_info failed, can't get thread info\\n\");\n-    return err;\n-  }\n-\n-  print_debug(\"thread_db : pthread %d (lwp %d)\\n\", ti.ti_tid, ti.ti_lid);\n-\n-  if (ti.ti_state == TD_THR_UNKNOWN || ti.ti_state == TD_THR_ZOMBIE) {\n-    print_debug(\"Skipping pthread %d (lwp %d)\\n\", ti.ti_tid, ti.ti_lid);\n-    return TD_OK;\n-  }\n-\n-  if (ptr->callback(ptr->ph, ti.ti_tid, ti.ti_lid) != true)\n-    return TD_ERR;\n-\n-  return TD_OK;\n-}\n-\n-\/\/ read thread_info using libthread_db\n-bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb) {\n-  struct thread_db_client_data mydata;\n-  td_thragent_t* thread_agent = NULL;\n-  if (td_ta_new(ph, &thread_agent) != TD_OK) {\n-     print_debug(\"can't create libthread_db agent\\n\");\n-     return false;\n-  }\n-\n-  mydata.ph = ph;\n-  mydata.callback = cb;\n-\n-  \/\/ we use libthread_db iterator to iterate thru list of threads.\n-  if (td_ta_thr_iter(thread_agent, thread_db_callback, &mydata,\n-                 TD_THR_ANY_STATE, TD_THR_LOWEST_PRIORITY,\n-                 TD_SIGNO_MASK, TD_THR_ANY_USER_FLAGS) != TD_OK) {\n-     td_ta_delete(thread_agent);\n-     return false;\n-  }\n-\n-  \/\/ delete thread agent\n-  td_ta_delete(thread_agent);\n-  return true;\n-}\n-\n-\n@@ -487,6 +422,0 @@\n-\/\/ new libthread_db of NPTL seem to require this symbol\n-JNIEXPORT ps_err_e JNICALL\n-ps_get_thread_area() {\n-  print_debug(\"ps_get_thread_area not implemented\\n\");\n-  return PS_OK;\n-}\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/libproc_impl.c","additions":3,"deletions":74,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -49,1 +49,0 @@\n-   pthread_t                pthread_id; \/\/ not used cores, always -1\n@@ -112,5 +111,0 @@\n-typedef bool (*thread_info_callback)(struct ps_prochandle* ph, pthread_t pid, lwpid_t lwpid);\n-\n-\/\/ reads thread info using libthread_db and calls above callback for each thread\n-bool read_thread_info(struct ps_prochandle* ph, thread_info_callback cb);\n-\n@@ -128,1 +122,1 @@\n-thread_info* add_thread_info(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id);\n+thread_info* add_thread_info(struct ps_prochandle* ph, lwpid_t lwp_id);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/libproc_impl.h","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n-#include <thread_db.h>\n+#include <sys\/procfs.h>\n@@ -31,0 +31,1 @@\n+#include \"libproc.h\"\n@@ -32,3 +33,0 @@\n-\/\/ Linux does not have the proc service library, though it does provide the\n-\/\/ thread_db library which can be used to manipulate threads without having\n-\/\/ to know the details of NPTL\n@@ -82,4 +80,0 @@\n-\/\/ new libthread_db of NPTL seem to require this symbol\n-JNIEXPORT ps_err_e JNICALL\n-ps_get_thread_area();\n-\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/proc_service.h","additions":3,"deletions":9,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"proc_service.h\"\n@@ -514,2 +515,1 @@\n-   \/\/ we set pthread_t to -1 for core dump\n-   if((newthr = add_thread_info(ph, (pthread_t) -1,  prstat->pr_pid)) == NULL)\n+   if((newthr = add_thread_info(ph, prstat->pr_pid)) == NULL)\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_core.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -342,5 +342,0 @@\n-\/\/ callback for read_thread_info\n-static bool add_new_thread(struct ps_prochandle* ph, pthread_t pthread_id, lwpid_t lwp_id) {\n-  return add_thread_info(ph, pthread_id, lwp_id) != NULL;\n-}\n-\n@@ -446,1 +441,1 @@\n-Pgrab(pid_t pid, char* err_buf, size_t err_buf_len, bool is_in_container) {\n+Pgrab(pid_t pid, char* err_buf, size_t err_buf_len) {\n@@ -467,0 +462,1 @@\n+  add_thread_info(ph, ph->pid);\n@@ -476,22 +472,21 @@\n-  \/\/ read thread info\n-  if (is_in_container) {\n-    \/*\n-     * If the process is running in the container, SA scans all tasks in\n-     * \/proc\/<PID>\/task to read all threads info.\n-     *\/\n-    char taskpath[PATH_MAX];\n-    DIR *dirp;\n-    struct dirent *entry;\n-\n-    snprintf(taskpath, PATH_MAX, \"\/proc\/%d\/task\", ph->pid);\n-    dirp = opendir(taskpath);\n-    int lwp_id;\n-    while ((entry = readdir(dirp)) != NULL) {\n-      if (*entry->d_name == '.') {\n-        continue;\n-      }\n-      lwp_id = atoi(entry->d_name);\n-      if (lwp_id == ph->pid) {\n-        continue;\n-      }\n-      add_new_thread(ph, -1, lwp_id);\n+  \/*\n+   * Read thread info.\n+   * SA scans all tasks in \/proc\/<PID>\/task to read all threads info.\n+   *\/\n+  char taskpath[PATH_MAX];\n+  DIR *dirp;\n+  struct dirent *entry;\n+\n+  snprintf(taskpath, PATH_MAX, \"\/proc\/%d\/task\", ph->pid);\n+  dirp = opendir(taskpath);\n+  int lwp_id;\n+  while ((entry = readdir(dirp)) != NULL) {\n+    if (*entry->d_name == '.') {\n+      continue;\n+    }\n+    lwp_id = atoi(entry->d_name);\n+    if (lwp_id == ph->pid) {\n+      continue;\n+    }\n+    if (!process_doesnt_exist(lwp_id)) {\n+      add_thread_info(ph, lwp_id);\n@@ -499,3 +494,0 @@\n-    closedir(dirp);\n-  } else {\n-    read_thread_info(ph, add_new_thread);\n@@ -503,0 +495,1 @@\n+  closedir(dirp);\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/ps_proc.c","additions":25,"deletions":32,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,1 @@\n-    private native void attach0(int pid, boolean isInContainer)\n+    private native void attach0(int pid)\n@@ -324,1 +324,0 @@\n-           boolean isInContainer;\n@@ -326,1 +325,1 @@\n-              debugger.attach0(pid, isInContainer);\n+              debugger.attach0(pid);\n@@ -335,1 +334,0 @@\n-        task.isInContainer = (processID != NSpid);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"}]}