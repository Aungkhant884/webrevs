{"files":[{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2017 SAP SE. All rights reserved.\n+ * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2022 SAP SE. All rights reserved.\n@@ -283,1 +283,0 @@\n-  \/\/ Is there anything to do?\n@@ -285,0 +284,52 @@\n+  \/\/ These are reasonable sanity checks\n+  if (fp() == 0 || (intptr_t(fp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (sp() == 0 || (intptr_t(sp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (fp() - (abi_minframe_size + ijava_state_size) < sp()) {\n+    return false;\n+  }\n+  \/\/ These are hacks to keep us out of trouble.\n+  \/\/ The problem with these is that they mask other problems\n+  if (fp() <= sp()) {        \/\/ this attempts to deal with unsigned comparison above\n+    return false;\n+  }\n+\n+  \/\/ do some validation of frame elements\n+\n+  \/\/ first the method\n+\n+  Method* m = *interpreter_frame_method_addr();\n+\n+  \/\/ validate the method we'd find in this potential sender\n+  if (!Method::is_valid_method(m)) return false;\n+\n+  \/\/ stack frames shouldn't be much larger than max_stack elements\n+  \/\/ this test requires the use of unextended_sp which is the sp as seen by\n+  \/\/ the current frame, and not sp which is the \"raw\" pc which could point\n+  \/\/ further because of local variables of the callee method inserted after\n+  \/\/ method arguments\n+  if (fp() - unextended_sp() > 1024 + m->max_stack()*Interpreter::stackElementSize) {\n+    return false;\n+  }\n+\n+  \/\/ validate bci\/bcx\n+\n+  address  bcp    = interpreter_frame_bcp();\n+  if (m->validate_bci_from_bcp(bcp) < 0) {\n+    return false;\n+  }\n+\n+  \/\/ validate constantPoolCache*\n+  ConstantPoolCache* cp = *interpreter_frame_cache_addr();\n+  if (MetaspaceObj::is_valid(cp) == false) return false;\n+\n+  \/\/ validate locals\n+\n+  address locals =  (address) *interpreter_frame_locals_addr();\n+\n+  if (locals > thread->stack_base() || locals < (address) fp()) return false;\n+\n+  \/\/ We'd have to be pretty unlucky to be mislead at this point\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2016, 2019, SAP SE. All rights reserved.\n+ * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2022 SAP SE. All rights reserved.\n@@ -298,1 +298,0 @@\n-  \/\/ Is there anything to do?\n@@ -300,0 +299,52 @@\n+  \/\/ These are reasonable sanity checks\n+  if (fp() == 0 || (intptr_t(fp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (sp() == 0 || (intptr_t(sp()) & (wordSize-1)) != 0) {\n+    return false;\n+  }\n+  if (fp() - (z_abi_16_size + z_ijava_state_size) < sp()) {\n+    return false;\n+  }\n+  \/\/ These are hacks to keep us out of trouble.\n+  \/\/ The problem with these is that they mask other problems\n+  if (fp() <= sp()) {        \/\/ this attempts to deal with unsigned comparison above\n+    return false;\n+  }\n+\n+  \/\/ do some validation of frame elements\n+\n+  \/\/ first the method\n+\n+  Method* m = *interpreter_frame_method_addr();\n+\n+  \/\/ validate the method we'd find in this potential sender\n+  if (!Method::is_valid_method(m)) return false;\n+\n+  \/\/ stack frames shouldn't be much larger than max_stack elements\n+  \/\/ this test requires the use of unextended_sp which is the sp as seen by\n+  \/\/ the current frame, and not sp which is the \"raw\" pc which could point\n+  \/\/ further because of local variables of the callee method inserted after\n+  \/\/ method arguments\n+  if (fp() - unextended_sp() > 1024 + m->max_stack()*Interpreter::stackElementSize) {\n+    return false;\n+  }\n+\n+  \/\/ validate bci\/bcx\n+\n+  address  bcp    = interpreter_frame_bcp();\n+  if (m->validate_bci_from_bcp(bcp) < 0) {\n+    return false;\n+  }\n+\n+  \/\/ validate constantPoolCache*\n+  ConstantPoolCache* cp = *interpreter_frame_cache_addr();\n+  if (MetaspaceObj::is_valid(cp) == false) return false;\n+\n+  \/\/ validate locals\n+\n+  address locals =  (address) *interpreter_frame_locals_addr();\n+\n+  if (locals > thread->stack_base() || locals < (address) fp()) return false;\n+\n+  \/\/ We'd have to be pretty unlucky to be mislead at this point\n","filename":"src\/hotspot\/cpu\/s390\/frame_s390.cpp","additions":54,"deletions":3,"binary":false,"changes":57,"status":"modified"}]}