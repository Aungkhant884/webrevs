{"files":[{"patch":"@@ -28,0 +28,1 @@\n+ * @library \/test\/lib \/\n@@ -44,0 +45,1 @@\n+ * @library \/test\/lib \/\n@@ -55,0 +57,1 @@\n+ * @library \/test\/lib \/\n@@ -66,0 +69,1 @@\n+ * @library \/test\/lib \/\n@@ -77,0 +81,1 @@\n+ * @library \/test\/lib \/\n@@ -88,0 +93,1 @@\n+ * @library \/test\/lib \/\n@@ -106,0 +112,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -123,0 +131,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -161,9 +171,0 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (churnBytes.get() == 0) {\n-            Thread.sleep(1000);\n-        }\n-        Thread.sleep(5000);\n-\n-        long actual = churnBytes.get();\n-\n@@ -172,0 +173,20 @@\n+        long actual = 0;\n+\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        \/\/ Default to 1\/4 of the remaining time in 1s steps.\n+        final long STEP_MS = 1000;\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actual = churnBytes.get();\n+            if (minExpected <= actual) {\n+                \/\/ Wait some more to test if we are breaking the maximum boundary.\n+                Thread.sleep(5000);\n+                actual = churnBytes.get();\n+                break;\n+            }\n+            Thread.sleep(STEP_MS);\n+        }\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestChurnNotifications.java","additions":30,"deletions":9,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ * @library \/test\/lib \/\n@@ -46,0 +47,1 @@\n+ * @library \/test\/lib \/\n@@ -56,0 +58,1 @@\n+ * @library \/test\/lib \/\n@@ -66,0 +69,1 @@\n+ * @library \/test\/lib \/\n@@ -76,0 +80,1 @@\n+ * @library \/test\/lib \/\n@@ -87,0 +92,1 @@\n+ * @library \/test\/lib \/\n@@ -103,0 +109,2 @@\n+import jdk.test.lib.Utils;\n+\n@@ -113,0 +121,2 @@\n+        final long startTime = System.currentTimeMillis();\n+\n@@ -115,0 +125,2 @@\n+        final AtomicLong pausesCount = new AtomicLong();\n+        final AtomicLong cyclesCount = new AtomicLong();\n@@ -122,3 +134,1 @@\n-                    System.out.println(info.getGcInfo().toString());\n-                    System.out.println(info.getGcName());\n-                    System.out.println();\n+                    System.out.println(\"Received: \" + info.getGcName());\n@@ -131,0 +141,1 @@\n+                            pausesCount.incrementAndGet();\n@@ -133,0 +144,1 @@\n+                            cyclesCount.incrementAndGet();\n@@ -153,4 +165,24 @@\n-        \/\/ Wait until notifications start arriving, and then wait some more\n-        \/\/ to catch the ones arriving late.\n-        while (pausesDuration.get() == 0) {\n-            Thread.sleep(1000);\n+        \/\/ Look at test timeout to figure out how long we can wait without breaking into timeout.\n+        \/\/ Default to 1\/4 of the remaining time in 1s steps.\n+        final long STEP_MS = 1000;\n+        long spentTime = System.currentTimeMillis() - startTime;\n+        long maxTries = (Utils.adjustTimeout(Utils.DEFAULT_TEST_TIMEOUT) - spentTime) \/ STEP_MS \/ 4;\n+\n+        long actualPauses = 0;\n+        long actualCycles = 0;\n+\n+        \/\/ Wait until enough notifications are accrued to match minimum boundary.\n+        long minExpected = 10;\n+\n+        long tries = 0;\n+        while (tries++ < maxTries) {\n+            actualPauses = pausesCount.get();\n+            actualCycles = cyclesCount.get();\n+            if (minExpected <= actualPauses && minExpected <= actualCycles) {\n+                \/\/ Wait a little bit to catch the lingering notifications.\n+                Thread.sleep(5000);\n+                actualPauses = pausesCount.get();\n+                actualCycles = cyclesCount.get();\n+                break;\n+            }\n+            Thread.sleep(STEP_MS);\n@@ -158,7 +190,0 @@\n-        Thread.sleep(5000);\n-\n-        long pausesActual = pausesDuration.get();\n-        long cyclesActual = cyclesDuration.get();\n-\n-        long minExpected = 1;\n-        long maxExpected = Long.MAX_VALUE;\n@@ -167,2 +192,2 @@\n-            String msg = \"Pauses expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + pausesActual;\n-            if (minExpected <= pausesActual && pausesActual <= maxExpected) {\n+            String msg = \"Pauses expected = [\" + minExpected + \"; +inf], actual = \" + actualPauses;\n+            if (minExpected <= actualPauses) {\n@@ -176,2 +201,2 @@\n-            String msg = \"Cycles expected = [\" + minExpected + \"; \" + maxExpected + \"], actual = \" + cyclesActual;\n-            if (minExpected <= cyclesActual && cyclesActual <= maxExpected) {\n+            String msg = \"Cycles expected = [\" + minExpected + \"; +inf], actual = \" + actualCycles;\n+            if (minExpected <= actualCycles) {\n@@ -185,2 +210,6 @@\n-            String msg = \"Cycle duration (\" + cyclesActual + \"), pause duration (\" + pausesActual + \")\";\n-            if (pausesActual <= cyclesActual) {\n+            long actualPauseDuration = pausesDuration.get();\n+            long actualCycleDuration = cyclesDuration.get();\n+\n+            String msg = \"Pauses duration (\" + actualPauseDuration + \") is expected to be not larger than cycles duration (\" + actualCycleDuration + \")\";\n+\n+            if (actualPauseDuration <= actualCycleDuration) {\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/mxbeans\/TestPauseNotifications.java","additions":49,"deletions":20,"binary":false,"changes":69,"status":"modified"}]}