{"files":[{"patch":"@@ -13,1 +13,1 @@\n-        default: \"Linux additional (hotspot only), Linux x64, Linux x86, Windows x64, macOS x64\"\n+        default: \"Linux additional (hotspot only), Linux x64, Linux x86, Windows x64, macOS x64, macOS aarch64\"\n@@ -26,0 +26,1 @@\n+      jdk_version: ${{ steps.check_jdk_versions.outputs.jdk_version }}\n@@ -71,0 +72,20 @@\n+      - name: Determine full JDK versions\n+        id: check_jdk_versions\n+        shell: bash\n+        run: |\n+          FEATURE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\n+          INTERIM=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_INTERIM }}\n+          UPDATE=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\n+          PATCH=${{ fromJson(steps.check_deps.outputs.dependencies).DEFAULT_VERSION_PATCH }}\n+          if [ \"x${PATCH}\" != \"x0\" ]; then\n+             V=${FEATURE}.${INTERIM}.${UPDATE}.${PATCH}\n+          elif [ \"x${UPDATE}\" != \"x0\" ]; then\n+             V=${FEATURE}.${INTERIM}.${UPDATE}\n+          elif [ \"x${INTERIM}\" != \"x0\" ]; then\n+             V={FEATURE}.${INTERIM}\n+          else\n+             V=${FEATURE}\n+          fi\n+          echo \"::set-output name=jdk_version::${V}\"\n+        if: steps.check_submit.outputs.should_run != 'false'\n+\n@@ -134,1 +155,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -259,1 +280,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -448,1 +469,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -596,1 +617,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -729,1 +750,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -882,1 +903,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1037,1 +1058,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1224,1 +1245,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1322,1 +1343,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n@@ -1449,1 +1470,1 @@\n-      JDK_VERSION: \"${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_FEATURE }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_INTERIM }}.${{ fromJson(needs.prerequisites.outputs.dependencies).DEFAULT_VERSION_UPDATE }}\"\n+      JDK_VERSION: \"${{ needs.prerequisites.outputs.jdk_version }}\"\n","filename":".github\/workflows\/submit.yml","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -4,1 +4,1 @@\n-version=11.0.16\n+version=11.0.17\n","filename":".jcheck\/conf","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-DEFAULT_VERSION_UPDATE=16\n+DEFAULT_VERSION_UPDATE=17\n@@ -36,1 +36,1 @@\n-DEFAULT_VERSION_DATE=2022-07-19\n+DEFAULT_VERSION_DATE=2022-10-18\n@@ -40,1 +40,1 @@\n-DEFAULT_PROMOTED_VERSION_PRE=\n+DEFAULT_PROMOTED_VERSION_PRE=ea\n","filename":"make\/autoconf\/version-numbers","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,3 @@\n+\/\/ controller names have to match the *_IDX indices\n+static const char* cg_controller_name[] = { \"cpu\", \"cpuset\", \"cpuacct\", \"memory\", \"pids\" };\n+\n@@ -42,0 +45,1 @@\n+  CgroupV1Controller* pids = NULL;\n@@ -96,12 +100,19 @@\n-    if (strcmp(info._name, \"memory\") == 0) {\n-      memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n-      memory->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuset\") == 0) {\n-      cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpuset->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpu\") == 0) {\n-      cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpu->set_subsystem_path(info._cgroup_path);\n-    } else if (strcmp(info._name, \"cpuacct\") == 0) {\n-      cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n-      cpuacct->set_subsystem_path(info._cgroup_path);\n+    if (info._data_complete) { \/\/ pids controller might have incomplete data\n+      if (strcmp(info._name, \"memory\") == 0) {\n+        memory = new CgroupV1MemoryController(info._root_mount_path, info._mount_path);\n+        memory->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpuset\") == 0) {\n+        cpuset = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuset->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpu\") == 0) {\n+        cpu = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpu->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"cpuacct\") == 0) {\n+        cpuacct = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        cpuacct->set_subsystem_path(info._cgroup_path);\n+      } else if (strcmp(info._name, \"pids\") == 0) {\n+        pids = new CgroupV1Controller(info._root_mount_path, info._mount_path);\n+        pids->set_subsystem_path(info._cgroup_path);\n+      }\n+    } else {\n+      log_debug(os, container)(\"CgroupInfo for %s not complete\", cg_controller_name[i]);\n@@ -111,1 +122,1 @@\n-  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, memory);\n+  return new CgroupV1Subsystem(cpuset, cpu, cpuacct, pids, memory);\n@@ -125,1 +136,1 @@\n-  \/\/ true iff all controllers, memory, cpu, cpuset, cpuacct are enabled\n+  \/\/ true iff all required controllers, memory, cpu, cpuset, cpuacct are enabled\n@@ -127,1 +138,2 @@\n-  bool all_controllers_enabled;\n+  \/\/ pids might not be enabled on older Linux distros (SLES 12.1, RHEL 7.1)\n+  bool all_required_controllers_enabled;\n@@ -139,4 +151,3 @@\n-      log_debug(os, container)(\"Can't open %s, %s\",\n-                               proc_cgroups, os::strerror(errno));\n-      *flags = INVALID_CGROUPS_GENERIC;\n-      return false;\n+    log_debug(os, container)(\"Can't open %s, %s\", proc_cgroups, os::strerror(errno));\n+    *flags = INVALID_CGROUPS_GENERIC;\n+    return false;\n@@ -170,0 +181,5 @@\n+    } else if (strcmp(name, \"pids\") == 0) {\n+      log_debug(os, container)(\"Detected optional pids controller entry in %s\", proc_cgroups);\n+      cg_infos[PIDS_IDX]._name = os::strdup(name);\n+      cg_infos[PIDS_IDX]._hierarchy_id = hierarchy_id;\n+      cg_infos[PIDS_IDX]._enabled = (enabled == 1);\n@@ -175,1 +191,1 @@\n-  all_controllers_enabled = true;\n+  all_required_controllers_enabled = true;\n@@ -177,2 +193,8 @@\n-    is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n-    all_controllers_enabled = all_controllers_enabled && cg_infos[i]._enabled;\n+    \/\/ pids controller is optional. All other controllers are required\n+    if (i != PIDS_IDX) {\n+      is_cgroupsV2 = is_cgroupsV2 && cg_infos[i]._hierarchy_id == 0;\n+      all_required_controllers_enabled = all_required_controllers_enabled && cg_infos[i]._enabled;\n+    }\n+    if (log_is_enabled(Debug, os, container) && !cg_infos[i]._enabled) {\n+      log_debug(os, container)(\"controller %s is not enabled\\n\", cg_controller_name[i]);\n+    }\n@@ -181,2 +203,2 @@\n-  if (!all_controllers_enabled) {\n-    \/\/ one or more controllers disabled, disable container support\n+  if (!all_required_controllers_enabled) {\n+    \/\/ one or more required controllers disabled, disable container support\n@@ -223,1 +245,1 @@\n-        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[MEMORY_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for memory\");\n@@ -226,1 +248,1 @@\n-        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPUSET_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpuset\");\n@@ -229,1 +251,1 @@\n-        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPU_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpu\");\n@@ -232,1 +254,1 @@\n-        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch\");\n+        assert(hierarchy_id == cg_infos[CPUACCT_IDX]._hierarchy_id, \"\/proc\/cgroups and \/proc\/self\/cgroup hierarchy mismatch for cpuacc\");\n@@ -234,0 +256,4 @@\n+      } else if (strcmp(token, \"pids\") == 0) {\n+        assert(hierarchy_id == cg_infos[PIDS_IDX]._hierarchy_id, \"\/proc\/cgroups (%d) and \/proc\/self\/cgroup (%d) hierarchy mismatch for pids\",\n+                                                                 cg_infos[PIDS_IDX]._hierarchy_id, hierarchy_id);\n+        cg_infos[PIDS_IDX]._cgroup_path = os::strdup(cgroup_path);\n@@ -284,1 +310,1 @@\n-     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct\n+     * Find the cgroup mount point for memory, cpuset, cpu, cpuacct, pids\n@@ -291,0 +317,2 @@\n+     *\n+     * 44 31 0:39 \/ \/sys\/fs\/cgroup\/pids rw,nosuid,nodev,noexec,relatime shared:23 - cgroup cgroup rw,pids\n@@ -336,0 +364,6 @@\n+        } else if (strcmp(token, \"pids\") == 0) {\n+          any_cgroup_mounts_found = true;\n+          assert(cg_infos[PIDS_IDX]._mount_path == NULL, \"stomping of _mount_path\");\n+          cg_infos[PIDS_IDX]._mount_path = os::strdup(tmpmount);\n+          cg_infos[PIDS_IDX]._root_mount_path = os::strdup(tmproot);\n+          cg_infos[PIDS_IDX]._data_complete = true;\n@@ -390,0 +424,4 @@\n+  if (log_is_enabled(Debug, os, container) && !cg_infos[PIDS_IDX]._data_complete) {\n+    log_debug(os, container)(\"Optional cgroup v1 pids subsystem not found\");\n+    \/\/ keep the other controller info, pids is optional\n+  }\n@@ -393,1 +431,0 @@\n-\n@@ -517,0 +554,19 @@\n+\n+jlong CgroupSubsystem::limit_from_str(char* limit_str) {\n+  if (limit_str == NULL) {\n+    return OSCONTAINER_ERROR;\n+  }\n+  \/\/ Unlimited memory in cgroups is the literal string 'max' for\n+  \/\/ some controllers, for example the pids controller.\n+  if (strcmp(\"max\", limit_str) == 0) {\n+    os::free(limit_str);\n+    return (jlong)-1;\n+  }\n+  julong limit;\n+  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n+    os::free(limit_str);\n+    return OSCONTAINER_ERROR;\n+  }\n+  os::free(limit_str);\n+  return (jlong)limit;\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.cpp","additions":87,"deletions":31,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,2 @@\n-\/\/ Four controllers: cpu, cpuset, cpuacct, memory\n-#define CG_INFO_LENGTH 4\n+\/\/ Five controllers: cpu, cpuset, cpuacct, memory, pids\n+#define CG_INFO_LENGTH 5\n@@ -70,0 +70,1 @@\n+#define PIDS_IDX       4\n@@ -243,0 +244,1 @@\n+    jlong limit_from_str(char* limit_str);\n@@ -247,0 +249,1 @@\n+    virtual jlong pids_max() = 0;\n","filename":"src\/hotspot\/os\/linux\/cgroupSubsystem_linux.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -244,0 +244,25 @@\n+\n+\n+char* CgroupV1Subsystem::pids_max_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _pids, \"\/pids.max\",\n+                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+  if (pidsmax == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(pidsmax);\n+}\n+\n+\/* pids_max\n+ *\n+ * Return the maximum number of tasks available to the process\n+ *\n+ * return:\n+ *    maximum number of tasks\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV1Subsystem::pids_max() {\n+  if (_pids == NULL) return OSCONTAINER_ERROR;\n+  char * pidsmax_str = pids_max_val();\n+  return limit_from_str(pidsmax_str);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.cpp","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,2 @@\n+    jlong pids_max();\n+\n@@ -104,0 +106,3 @@\n+    CgroupV1Controller* _pids = NULL;\n+\n+    char * pids_max_val();\n@@ -109,0 +114,1 @@\n+                      CgroupV1Controller* pids,\n@@ -113,0 +119,1 @@\n+      _pids = pids;\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -206,18 +206,0 @@\n-jlong CgroupV2Subsystem::limit_from_str(char* limit_str) {\n-  if (limit_str == NULL) {\n-    return OSCONTAINER_ERROR;\n-  }\n-  \/\/ Unlimited memory in Cgroups V2 is the literal string 'max'\n-  if (strcmp(\"max\", limit_str) == 0) {\n-    os::free(limit_str);\n-    return (jlong)-1;\n-  }\n-  julong limit;\n-  if (sscanf(limit_str, JULONG_FORMAT, &limit) != 1) {\n-    os::free(limit_str);\n-    return OSCONTAINER_ERROR;\n-  }\n-  os::free(limit_str);\n-  return (jlong)limit;\n-}\n-\n@@ -247,0 +229,22 @@\n+char* CgroupV2Subsystem::pids_max_val() {\n+  GET_CONTAINER_INFO_CPTR(cptr, _unified, \"\/pids.max\",\n+                     \"Maximum number of tasks is: %s\", \"%s %*d\", pidsmax, 1024);\n+  if (pidsmax == NULL) {\n+    return NULL;\n+  }\n+  return os::strdup(pidsmax);\n+}\n+\n+\/* pids_max\n+ *\n+ * Return the maximum number of tasks available to the process\n+ *\n+ * return:\n+ *    maximum number of tasks\n+ *    -1 for unlimited\n+ *    OSCONTAINER_ERROR for not supported\n+ *\/\n+jlong CgroupV2Subsystem::pids_max() {\n+  char * pidsmax_str = pids_max_val();\n+  return limit_from_str(pidsmax_str);\n+}\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.cpp","additions":22,"deletions":18,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-    jlong limit_from_str(char* limit_str);\n+    char *pids_max_val();\n@@ -82,0 +82,2 @@\n+    jlong pids_max();\n+\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,0 +141,5 @@\n+\n+jlong OSContainer::pids_max() {\n+  assert(cgroup_subsystem != NULL, \"cgroup subsystem not available\");\n+  return cgroup_subsystem->pids_max();\n+}\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+  static jlong pids_max();\n","filename":"src\/hotspot\/os\/linux\/osContainer_linux.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2456,0 +2456,1 @@\n+    st->print_cr(\"container information not found.\");\n@@ -2547,0 +2548,9 @@\n+\n+  j = OSContainer::OSContainer::pids_max();\n+  st->print(\"maximum number of tasks: \");\n+  if (j > 0) {\n+    st->print_cr(JLONG_FORMAT, j);\n+  } else {\n+    st->print_cr(\"%s\", j == OSCONTAINER_ERROR ? \"not supported\" : \"unlimited\");\n+  }\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-  _metaspace_used_bytes = MetaspaceUtils::used_bytes();\n@@ -120,1 +119,1 @@\n-  MetaspaceUtils::print_metaspace_change(_before._metaspace_used_bytes);\n+  MetaspaceUtils::print_metaspace_change(_before._meta_sizes);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"memory\/metaspace\/metaspaceSizesSnapshot.hpp\"\n@@ -38,1 +39,1 @@\n-    size_t _metaspace_used_bytes;\n+    const metaspace::MetaspaceSizesSnapshot _meta_sizes;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapTransition.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"memory\/metaspace\/metaspaceSizesSnapshot.hpp\"\n@@ -270,2 +271,1 @@\n-      _old_gen_used(heap->old_gen()->used_in_bytes()),\n-      _metadata_used(MetaspaceUtils::used_bytes()) { };\n+      _old_gen_used(heap->old_gen()->used_in_bytes()) { }\n@@ -276,1 +276,1 @@\n-  size_t metadata_used() const  { return _metadata_used; }\n+  const metaspace::MetaspaceSizesSnapshot& metaspace_sizes() const { return _meta_sizes; }\n@@ -282,1 +282,1 @@\n-  size_t _metadata_used;\n+  const metaspace::MetaspaceSizesSnapshot _meta_sizes;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -193,5 +193,1 @@\n-    \/\/ Capture metadata size before collection for sizing.\n-    size_t metadata_prev_used = MetaspaceUtils::used_bytes();\n-\n-    size_t old_gen_prev_used = old_gen->used_in_bytes();\n-    size_t young_gen_prev_used = young_gen->used_in_bytes();\n+    const PreGCValues pre_gc_values(heap);\n@@ -354,3 +350,3 @@\n-    young_gen->print_used_change(young_gen_prev_used);\n-    old_gen->print_used_change(old_gen_prev_used);\n-    MetaspaceUtils::print_metaspace_change(metadata_prev_used);\n+    young_gen->print_used_change(pre_gc_values.young_gen_used());\n+    old_gen->print_used_change(pre_gc_values.old_gen_used());\n+    MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psMarkSweep.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1756,1 +1756,1 @@\n-  PreGCValues pre_gc_values(heap);\n+  const PreGCValues pre_gc_values(heap);\n@@ -1905,1 +1905,1 @@\n-    MetaspaceUtils::print_metaspace_change(pre_gc_values.metadata_used());\n+    MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -331,1 +331,1 @@\n-    PreGCValues pre_gc_values(heap);\n+    const PreGCValues pre_gc_values(heap);\n@@ -611,1 +611,1 @@\n-    MetaspaceUtils::print_metaspace_change(pre_gc_values.metadata_used());\n+    MetaspaceUtils::print_metaspace_change(pre_gc_values.metaspace_sizes());\n","filename":"src\/hotspot\/share\/gc\/parallel\/psScavenge.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -567,2 +567,0 @@\n-  const size_t metadata_prev_used = MetaspaceUtils::used_bytes();\n-\n@@ -593,0 +591,1 @@\n+    const metaspace::MetaspaceSizesSnapshot prev_meta_sizes;\n@@ -653,1 +652,1 @@\n-    MetaspaceUtils::print_metaspace_change(metadata_prev_used);\n+    MetaspaceUtils::print_metaspace_change(prev_meta_sizes);\n","filename":"src\/hotspot\/share\/gc\/shared\/genCollectedHeap.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-      const size_t metadata_prev_used = MetaspaceUtils::used_bytes();\n+      const metaspace::MetaspaceSizesSnapshot prev_meta_sizes;\n@@ -276,1 +276,1 @@\n-      MetaspaceUtils::print_metaspace_change(metadata_prev_used);\n+      MetaspaceUtils::print_metaspace_change(prev_meta_sizes);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -473,3 +473,30 @@\n-void MetaspaceUtils::print_metaspace_change(size_t prev_metadata_used) {\n-  log_info(gc, metaspace)(\"Metaspace: \"  SIZE_FORMAT \"K->\" SIZE_FORMAT \"K(\"  SIZE_FORMAT \"K)\",\n-                          prev_metadata_used\/K, used_bytes()\/K, reserved_bytes()\/K);\n+void MetaspaceUtils::print_metaspace_change(const metaspace::MetaspaceSizesSnapshot& pre_meta_values) {\n+  const metaspace::MetaspaceSizesSnapshot meta_values;\n+\n+  if (Metaspace::using_class_space()) {\n+    log_info(gc, metaspace)(HEAP_CHANGE_FORMAT\" \"\n+                            HEAP_CHANGE_FORMAT\" \"\n+                            HEAP_CHANGE_FORMAT,\n+                            HEAP_CHANGE_FORMAT_ARGS(\"Metaspace\",\n+                                                    pre_meta_values.used(),\n+                                                    pre_meta_values.committed(),\n+                                                    meta_values.used(),\n+                                                    meta_values.committed()),\n+                            HEAP_CHANGE_FORMAT_ARGS(\"NonClass\",\n+                                                    pre_meta_values.non_class_used(),\n+                                                    pre_meta_values.non_class_committed(),\n+                                                    meta_values.non_class_used(),\n+                                                    meta_values.non_class_committed()),\n+                            HEAP_CHANGE_FORMAT_ARGS(\"Class\",\n+                                                    pre_meta_values.class_used(),\n+                                                    pre_meta_values.class_committed(),\n+                                                    meta_values.class_used(),\n+                                                    meta_values.class_committed()));\n+  } else {\n+    log_info(gc, metaspace)(HEAP_CHANGE_FORMAT,\n+                            HEAP_CHANGE_FORMAT_ARGS(\"Metaspace\",\n+                                                    pre_meta_values.used(),\n+                                                    pre_meta_values.committed(),\n+                                                    meta_values.used(),\n+                                                    meta_values.committed()));\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"memory\/metaspace\/metaspaceSizesSnapshot.hpp\"\n@@ -430,2 +431,2 @@\n-  \/\/ Print change in used metadata.\n-  static void print_metaspace_change(size_t prev_metadata_used);\n+  \/\/ Log change in used metadata.\n+  static void print_metaspace_change(const metaspace::MetaspaceSizesSnapshot& pre_meta_values);\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Twitter, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"memory\/metaspace.hpp\"\n+#include \"memory\/metaspace\/metaspaceSizesSnapshot.hpp\"\n+\n+namespace metaspace {\n+\n+MetaspaceSizesSnapshot::MetaspaceSizesSnapshot()\n+    : _used(MetaspaceUtils::used_bytes()),\n+      _committed(MetaspaceUtils::committed_bytes()),\n+      _non_class_used(MetaspaceUtils::used_bytes(Metaspace::NonClassType)),\n+      _non_class_committed(MetaspaceUtils::committed_bytes(Metaspace::NonClassType)),\n+      _class_used(MetaspaceUtils::used_bytes(Metaspace::ClassType)),\n+      _class_committed(MetaspaceUtils::committed_bytes(Metaspace::ClassType)) { }\n+\n+} \/\/ namespace metaspace\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSizesSnapshot.cpp","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Twitter, Inc.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_MEMORY_METASPACE_METASPACESIZESSNAPSHOT_HPP\n+#define SHARE_MEMORY_METASPACE_METASPACESIZESSNAPSHOT_HPP\n+\n+namespace metaspace {\n+\n+class MetaspaceSizesSnapshot {\n+public:\n+  MetaspaceSizesSnapshot();\n+\n+  size_t used() const { return _used; }\n+  size_t committed() const { return _committed; }\n+  size_t non_class_used() const { return _non_class_used; }\n+  size_t non_class_committed() const { return _non_class_committed; }\n+  size_t class_used() const { return _class_used; }\n+  size_t class_committed() const { return _class_committed; }\n+\n+private:\n+  const size_t _used;\n+  const size_t _committed;\n+  const size_t _non_class_used;\n+  const size_t _non_class_committed;\n+  const size_t _class_used;\n+  const size_t _class_committed;\n+};\n+\n+} \/\/ namespace metaspace\n+\n+#endif \/\/ SHARE_MEMORY_METASPACE_METASPACESIZESSNAPSHOT_HPP\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceSizesSnapshot.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -3155,0 +3155,6 @@\n+\n+  \/\/ Check for bailout, and return\n+  if (C->failing()) {\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -894,1 +894,1 @@\n-  CgroupInfo cg_infos[4];\n+  CgroupInfo cg_infos[CG_INFO_LENGTH];\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,0 +336,7 @@\n+\/\/ Memory size transition formatting.\n+\n+#define HEAP_CHANGE_FORMAT \"%s: \" SIZE_FORMAT \"K(\" SIZE_FORMAT \"K)->\" SIZE_FORMAT \"K(\" SIZE_FORMAT \"K)\"\n+\n+#define HEAP_CHANGE_FORMAT_ARGS(_name_, _prev_used_, _prev_capacity_, _used_, _capacity_) \\\n+  (_name_), (_prev_used_) \/ K, (_prev_capacity_) \/ K, (_used_) \/ K, (_capacity_) \/ K\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -88,1 +88,2 @@\n-  \"LANG\", \"LC_ALL\", \"LC_CTYPE\", \"TZ\",\n+  \"LANG\", \"LC_ALL\", \"LC_CTYPE\", \"LC_NUMERIC\", \"LC_TIME\",\n+  \"TERM\", \"TMPDIR\", \"TZ\",\n","filename":"src\/hotspot\/share\/utilities\/vmError.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -152,0 +152,5 @@\n+    @Override\n+    public long getPidsMax() {\n+        return subsystem.getPidsMax();\n+    }\n+\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupMetrics.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+    public static final String MAX_VAL = \"max\";\n+\n+    public static long limitFromString(String strVal) {\n+        if (strVal == null || MAX_VAL.equals(strVal)) {\n+            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n+        }\n+        return Long.parseLong(strVal);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystem.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+    private static final String PIDS_CTRL = \"pids\";\n@@ -152,0 +153,1 @@\n+            case PIDS_CTRL:     infos.put(PIDS_CTRL, info); break;\n@@ -255,0 +257,1 @@\n+                    case PIDS_CTRL:\n@@ -306,0 +309,1 @@\n+                        case PIDS_CTRL:\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/CgroupSubsystemFactory.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+    private CgroupV1SubsystemController pids;\n@@ -129,0 +130,9 @@\n+            case \"pids\": {\n+                if (info.getMountRoot() != null && info.getMountPoint() != null) {\n+                    CgroupV1SubsystemController controller = new CgroupV1SubsystemController(info.getMountRoot(), info.getMountPoint());\n+                    controller.setPath(info.getCgroupPath());\n+                    subsystem.setPidsController(controller);\n+                    anyActiveControllers = true;\n+                }\n+                break;\n+            }\n@@ -173,0 +183,4 @@\n+    private void setPidsController(CgroupV1SubsystemController pids) {\n+        this.pids = pids;\n+    }\n+\n@@ -397,0 +411,7 @@\n+    \/*****************************************************************\n+     *  pids subsystem\n+     ****************************************************************\/\n+    public long getPidsMax() {\n+        String pidsMaxStr = CgroupSubsystemController.getStringValue(pids, \"pids.max\");\n+        return CgroupSubsystem.limitFromString(pidsMaxStr);\n+    }\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv1\/CgroupV1Subsystem.java","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -48,1 +48,0 @@\n-    private static final String MAX_VAL = \"max\";\n@@ -152,8 +151,1 @@\n-        return limitFromString(quota);\n-    }\n-\n-    private long limitFromString(String strVal) {\n-        if (strVal == null || MAX_VAL.equals(strVal)) {\n-            return CgroupSubsystem.LONG_RETVAL_UNLIMITED;\n-        }\n-        return Long.parseLong(strVal);\n+        return CgroupSubsystem.limitFromString(quota);\n@@ -254,1 +246,1 @@\n-        return limitFromString(strVal);\n+        return CgroupSubsystem.limitFromString(strVal);\n@@ -282,1 +274,1 @@\n-        long swapLimit = limitFromString(strVal);\n+        long swapLimit = CgroupSubsystem.limitFromString(strVal);\n@@ -313,1 +305,7 @@\n-        return limitFromString(softLimitStr);\n+        return CgroupSubsystem.limitFromString(softLimitStr);\n+    }\n+\n+    @Override\n+    public long getPidsMax() {\n+        String pidsMaxStr = CgroupSubsystemController.getStringValue(unified, \"pids.max\");\n+        return CgroupSubsystem.limitFromString(pidsMaxStr);\n","filename":"src\/java.base\/linux\/classes\/jdk\/internal\/platform\/cgroupv2\/CgroupV2Subsystem.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2337,1 +2337,1 @@\n-                int rs = resizeStamp(n);\n+                int rs = resizeStamp(n) << RESIZE_STAMP_SHIFT;\n@@ -2339,3 +2339,2 @@\n-                    if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n-                        sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||\n-                        transferIndex <= 0)\n+                    if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||\n+                        (nt = nextTable) == null || transferIndex <= 0)\n@@ -2346,2 +2345,1 @@\n-                else if (U.compareAndSetInt(this, SIZECTL, sc,\n-                                             (rs << RESIZE_STAMP_SHIFT) + 2))\n+                else if (U.compareAndSetInt(this, SIZECTL, sc, rs + 2))\n@@ -2361,1 +2359,1 @@\n-            int rs = resizeStamp(tab.length);\n+            int rs = resizeStamp(tab.length) << RESIZE_STAMP_SHIFT;\n@@ -2364,2 +2362,2 @@\n-                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||\n-                    sc == rs + MAX_RESIZERS || transferIndex <= 0)\n+                if (sc == rs + MAX_RESIZERS || sc == rs + 1 ||\n+                    transferIndex <= 0)\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ConcurrentHashMap.java","additions":7,"deletions":9,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -355,0 +355,13 @@\n+    \/*****************************************************************\n+     * pids subsystem\n+     ****************************************************************\/\n+\n+    \/**\n+     * Returns the maximum number of tasks that may be created in the Isolation Group.\n+     *\n+     * @return The maximum number of tasks, -1 if the quota is unlimited or\n+     *         -2 if not supported.\n+     *\n+     *\/\n+    public long getPidsMax();\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/platform\/Metrics.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -408,0 +408,3 @@\n+        limit = c.getPidsMax();\n+        ostream.println(formatLimitString(limit, INDENT + \"Maximum Processes Limit: \",\n+                                          longRetvalNotSupported, false));\n@@ -412,0 +415,4 @@\n+        return formatLimitString(limit, prefix, unavailable, true);\n+    }\n+\n+    private static String formatLimitString(long limit, String prefix, long unavailable, boolean scale) {\n@@ -413,1 +420,5 @@\n-            return prefix + SizePrefix.scaleValue(limit);\n+            if (scale) {\n+                return prefix + SizePrefix.scaleValue(limit);\n+            } else {\n+                return prefix + limit;\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/LauncherHelper.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+import static javax.accessibility.AccessibleContext.ACCESSIBLE_VALUE_PROPERTY;\n@@ -109,7 +110,0 @@\n-        if (c instanceof JProgressBar) {\n-            JProgressBar pb = (JProgressBar) c;\n-            pb.addChangeListener(new AXProgressChangeNotifier());\n-        } else if (c instanceof JSlider) {\n-            JSlider slider = (JSlider) c;\n-            slider.addChangeListener(new AXProgressChangeNotifier());\n-        }\n@@ -172,0 +166,7 @@\n+                } else if (name.compareTo(ACCESSIBLE_VALUE_PROPERTY) == 0) {\n+                    AccessibleRole thisRole = accessible.getAccessibleContext()\n+                                                        .getAccessibleRole();\n+                    if (thisRole == AccessibleRole.SLIDER ||\n+                            thisRole == AccessibleRole.PROGRESS_BAR) {\n+                        valueChanged(ptr);\n+                    }\n@@ -177,6 +178,0 @@\n-    private class AXProgressChangeNotifier implements ChangeListener {\n-        @Override\n-        public void stateChanged(ChangeEvent e) {\n-            if (ptr != 0) valueChanged(ptr);\n-        }\n-    }\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessible.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Red Hat Inc.\n+ * Copyright (c) 2020, 2021, Red Hat Inc.\n@@ -109,0 +109,1 @@\n+            \"pids 0 1 1\\n\" +\n@@ -172,1 +173,1 @@\n-            \"pids    3   80  1\";\n+            \"pids    9   80  1\";  \/\/ hierarchy has to match procSelfCgroupHybridContent\n","filename":"test\/hotspot\/jtreg\/containers\/cgroup\/CgroupSubsystemFactory.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -118,1 +118,2 @@\n-            \"memory_max_usage_in_bytes\"\n+            \"memory_max_usage_in_bytes\",\n+            \"maximum number of tasks\"\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestMisc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @summary Test JVM's awareness of pids controller\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ *          java.management\n+ * @build sun.hotspot.WhiteBox PrintContainerInfo\n+ * @run driver ClassFileInstaller -jar whitebox.jar sun.hotspot.WhiteBox sun.hotspot.WhiteBox$WhiteBoxPermission\n+ * @run driver TestPids\n+ *\/\n+import java.util.List;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.Utils;\n+\n+public class TestPids {\n+    private static final String imageName = Common.imageName(\"pids\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        Common.prepareWhiteBox();\n+        DockerTestUtils.buildJdkDockerImage(imageName, \"Dockerfile-BasicTest\", \"jdk-docker\");\n+\n+        try {\n+            testPids();\n+        } finally {\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        }\n+    }\n+\n+    private static void testPids() throws Exception {\n+        System.out.println(\"Testing pids controller ...\");\n+        testPids(\"400\");\n+        testPids(\"800\");\n+        testPids(\"2000\");\n+        testPids(\"Unlimited\");\n+    }\n+\n+    private static DockerRunOptions commonOpts() {\n+        DockerRunOptions opts = new DockerRunOptions(imageName, \"\/jdk\/bin\/java\", \"PrintContainerInfo\");\n+        opts.addDockerOpts(\"--volume\", Utils.TEST_CLASSES + \":\/test-classes\/\");\n+        opts.addJavaOpts(\"-Xlog:os+container=trace\", \"-cp\", \"\/test-classes\/\");\n+        Common.addWhiteBoxOpts(opts);\n+        return opts;\n+    }\n+\n+    private static void checkResult(List<String> lines, String lineMarker, String expectedValue) {\n+        boolean lineMarkerFound = false;\n+\n+        for (String line : lines) {\n+            if (line.contains(\"WARNING: Your kernel does not support pids limit capabilities\")) {\n+                System.out.println(\"Docker pids limitation seems not to work, avoiding check\");\n+                return;\n+            }\n+\n+            if (line.contains(lineMarker)) {\n+                lineMarkerFound = true;\n+                String[] parts = line.split(\":\");\n+                System.out.println(\"DEBUG: line = \" + line);\n+                System.out.println(\"DEBUG: parts.length = \" + parts.length);\n+\n+                Asserts.assertEquals(parts.length, 2);\n+                String actual = parts[1].replaceAll(\"\\\\s\",\"\");\n+                \/\/ Unlimited pids leads on some setups not to \"max\" in the output, but to a high number\n+                if (expectedValue.equals(\"max\")) {\n+                    if (actual.equals(\"max\")) {\n+                        System.out.println(\"Found expected max for unlimited pids value.\");\n+                    } else {\n+                        try {\n+                            int ai = Integer.parseInt(actual);\n+                            if (ai > 20000) {\n+                                System.out.println(\"Limit value \" + ai + \" got accepted as unlimited, log line was \" + line);\n+                            } else {\n+                                throw new RuntimeException(\"Limit value \" + ai + \" is not accepted as unlimited, log line was \" + line);\n+                            }\n+                        } catch (NumberFormatException ex) {\n+                            throw new RuntimeException(\"Could not convert \" + actual + \" to an integer, log line was \" + line);\n+                        }\n+                    }\n+                } else {\n+                    Asserts.assertEquals(actual, expectedValue);\n+                }\n+                break;\n+            }\n+        }\n+        Asserts.assertTrue(lineMarkerFound);\n+    }\n+\n+    private static void testPids(String value) throws Exception {\n+        Common.logNewTestCase(\"pids controller test, limiting value = \" + value);\n+\n+        DockerRunOptions opts = commonOpts();\n+        if (value.equals(\"Unlimited\")) {\n+            opts.addDockerOpts(\"--pids-limit=-1\");\n+        } else {\n+            opts.addDockerOpts(\"--pids-limit=\"+value);\n+        }\n+\n+        List<String> lines = Common.run(opts).asLines();\n+        if (value.equals(\"Unlimited\")) {\n+            checkResult(lines, \"Maximum number of tasks is: \", \"max\");\n+        } else {\n+            checkResult(lines, \"Maximum number of tasks is: \", value);\n+        }\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/containers\/docker\/TestPids.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -127,1 +127,1 @@\n-            long initOld = HeapRegionUsageTool.getOldUsage().getInit();\n+            long initHeap = HeapRegionUsageTool.getHeapUsage().getInit();\n@@ -131,1 +131,2 @@\n-            long expectedNewSize = HeapRegionUsageTool.alignDown(initOld \/ expectedRatio,\n+            \/\/ See GenArguments::scale_by_NewRatio_aligned for calculation in the JVM.\n+            long expectedNewSize = HeapRegionUsageTool.alignDown(initHeap \/ (expectedRatio + 1),\n@@ -148,1 +149,1 @@\n-            long initOld = HeapRegionUsageTool.getOldUsage().getInit();\n+            long initHeap = HeapRegionUsageTool.getHeapUsage().getInit();\n@@ -152,1 +153,2 @@\n-            long alignedDownNewSize = HeapRegionUsageTool.alignDown(initOld \/ expectedRatio,\n+            \/\/ See GenArguments::scale_by_NewRatio_aligned for calculation in the JVM.\n+            long alignedDownNewSize = HeapRegionUsageTool.alignDown(initHeap \/ (expectedRatio + 1),\n","filename":"test\/hotspot\/jtreg\/gc\/arguments\/TestNewRatioFlag.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -124,9 +124,1 @@\n-    try {\n-        output.shouldHaveExitValue(0);\n-    } catch (RuntimeException e) {\n-        \/\/ It's ok if there is no client vm in the jdk.\n-        if (output.firstMatch(\"Unrecognized option: -client\") == null) {\n-            throw e;\n-        }\n-    }\n-\n+    output.shouldHaveExitValue(0);\n@@ -136,8 +128,0 @@\n-  public static void runTest(String compiler, String[] other) throws Exception {\n-    ArrayList<String> joined = new ArrayList<String>();\n-    joined.add(compiler);\n-    joined.addAll(Arrays.asList(other));\n-    runWhiteBoxTest(joined.toArray(new String[0]), TestHumongousCodeCacheRootsHelper.class.getName(),\n-      new String[] {}, false);\n-  }\n-\n@@ -151,2 +135,3 @@\n-    runTest(\"-client\", baseArguments);\n-    runTest(\"-server\", baseArguments);\n+\n+    runWhiteBoxTest(baseArguments, TestHumongousCodeCacheRootsHelper.class.getName(),\n+      new String[] {}, false);\n","filename":"test\/hotspot\/jtreg\/gc\/g1\/TestHumongousCodeCacheRoots.java","additions":4,"deletions":19,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.io.File;\n@@ -36,0 +37,1 @@\n+import java.io.FileOutputStream;\n@@ -110,0 +112,12 @@\n+        PrintWriter pw;\n+        String logName = System.getProperty(\"test.classes\") +\n+            File.separator + \"loadedClasses.log\";\n+        \/\/ Create a log file to capture the names of the classes in the\n+        \/\/ allLoadedClasses array. The log file is for assisting in debugging\n+        \/\/ in case a null class is encountered in the allLoadedClasses array.\n+        try {\n+            pw = new PrintWriter(new FileOutputStream(\n+                new File(logName), true));\n+        } catch (FileNotFoundException e) {\n+            throw new RuntimeException(\"Could not write loaded classes to log\", e);\n+        }\n@@ -112,1 +126,14 @@\n-            for (Class clazz : allLoadedClasses) {\n+            int len = allLoadedClasses.length;\n+            pw.println(\"    allLoadedClasses length: \" + len);\n+            for (int idx = 0; idx < len; idx++) {\n+                Class cls = allLoadedClasses[idx];\n+                pw.println(\"    \" + idx + \" \" +\n+                    ((cls != null) ? cls.getName() : \"null\"));\n+            }\n+            for (int idx = 0; idx < len; idx++) {\n+                Class clazz = allLoadedClasses[idx];\n+                if (clazz == null) {\n+                    pw.flush();\n+                    pw.close();\n+                    throw new RuntimeException(\"null class encountered\");\n+                }\n@@ -116,0 +143,2 @@\n+                        pw.flush();\n+                        pw.close();\n@@ -136,0 +165,2 @@\n+                        pw.flush();\n+                        pw.close();\n@@ -142,0 +173,2 @@\n+        pw.flush();\n+        pw.close();\n","filename":"test\/hotspot\/jtreg\/runtime\/RedefineTests\/ModifyAnonymous.java","additions":35,"deletions":2,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,544 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network001.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between server and client\n- *     TCP\/IP sockets, and checks if those data are transfered correctly.\n- *     Both sockets are attached to local host name, or to the loopback\n- *     \"localhost\" (having IP address 127.0.0.1).\n- *     Information transfer is synchronized in this test. Client passes\n- *     a large data parcel to server, and server reads that parcel and checks\n- *     if it is same as expected (byte-to-byte equality). Then server passes\n- *     (some other) parcel to client, and client reads and verifies those bytes.\n- *     This ping-pong game is repeated 2000 times; and after that both sockets\n- *     check if there are no extra bytes accudentally passed through their\n- *     connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 125 bytes. So totally, each of the 2 sockets passes ~250Kb of\n- *     data to its partner, and thus ~500Kb of data are transfered by this test.\n- * COMMENTS\n- *     Note, that HotSpot 1.3beta-H fails to start this test due to the bug:\n- *         #4245704 (P1\/S1) Fails to launch with: jre\/bin\/net.dll ...\n- *\n- * @run main\/othervm nsk.stress.network.network001\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test transfers huge amount of data between server and client\n- * TCP\/IP sockets, and checks if those data are transfered correctly.\n- * Both sockets are attached to local host name, or to the loopback\n- * ``localhost'' (having IP address 127.0.0.1).\n- * <p>\n- * <p>Information transfer is synchronized in this test. Client passes\n- * a large data parcel to server, and server reads that parcel and checks\n- * if it is same as expected (byte-to-byte equality). Then server passes\n- * (some other) parcel to client, and client reads and verifies those bytes.\n- * This ping-pong game is repeated 2000 times; and after that both sockets\n- * check if there are no extra bytes accudentally passed through their\n- * connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 125 bytes. So totally, each of the 2 sockets passes ~250Kb of\n- * data to its partner, and thus ~500Kb of data are transfered by this test.\n- *\/\n-public class network001 {\n-    \/**\n-     * Number of parcels to be sent\/recieve.\n-     *\/\n-    private static final int DATA_PARCELS = 2000;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (now it equals to 250 bytes).\n-     *\/\n-    private static final int MAX_PARCEL = 250;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * Errors and optional reports log. Usually <code>System.out<\/code>.\n-     *\/\n-    static private PrintStream out = System.out;\n-\n-    \/**\n-     * Print error message: both client and server may print\n-     * concurently.\n-     *\/\n-    static private synchronized void println(Object message) {\n-        out.println(message.toString());\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va.\n-     *\/\n-    static private void display(Object report) {\n-        if (DEBUG_MODE)\n-            println(report.toString());\n-    }\n-\n-    \/**\n-     * Server thread intended to reply to data parcels sent by Client thread.\n-     *\/\n-    static private class Server extends Thread {\n-        \/**\n-         * This server thread listens the single socket.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Address and port of this server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Which port does this socket is listening.\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Accept connection, read the string \"abra\", and respond \"cadabra\".\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                display(\"Server socket: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Server thread got unexpected parcel:\");\n-                        println(\"sample=\" + sample);\n-                        println(\"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"server has read unexpected parcel\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Client thread intended to send data parcels to Server thread and\n-     * to recieve the server's replies.\n-     *\/\n-    static private class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-        }\n-\n-        \/**\n-         * Accept connection, read the string \"abra\", and respond \"cadabra\".\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Client thread got unexpected parcel:\");\n-                        println(\"sample=\" + sample);\n-                        println(\"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * A data parcel to sent\/recieved between Client and Server threads.\n-     * When data parcel is sent, first 4 bytes transfered encode the size\n-     * of the parcel (i.e.: number of data bytes in the parcel's contents).\n-     * Then the parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client thread may throw this exception to report the test\n-     * failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Attach client and server sockets to the local host, and check if\n-     * huge amount of data could be correctly transfered between these\n-     * sockets.\n-     * <p>\n-     * <p>Command-line parameters provided with <code>args[]<\/code> may\n-     * prompt the local host IP address or domain name. Execute:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network001 [<i>IP-address<\/i> | <i>host_name<\/i> |\n-     * localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <br>By default, the test uses the Internet address available via\n-     * the method <code>InetAddress.getLocalHost()<\/code>\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network001.out = out;\n-\n-        \/\/\n-        \/\/ Get IP address of the local machine.\n-        \/\/\n-\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 0:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 1:\n-                    String hostName = args[0];\n-                    address = InetAddress.getByName(args[0]);\n-                    break;\n-                default:\n-                    println(\"Use:\");\n-                    println(\"    java network001\");\n-                    println(\"or:\");\n-                    println(\"    java network001 ${IP_ADDRESS}\");\n-                    println(\"or:\");\n-                    println(\"    java network001 ${HOST_NAME}\");\n-                    println(\"or:\");\n-                    println(\"    java network001 localhost\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            println(exception);\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Incarnate the server & the client sockets.\n-        \/\/\n-\n-        Server server = null;\n-        try {\n-            server = new Server(address);\n-        } catch (IOException io) {\n-            println(\"Failed to create server: \" + io);\n-            return 2;\n-        }\n-        display(\"Server: \" + server);\n-\n-        int port = server.getPort();\n-\n-        Client client = null;\n-        try {\n-            client = new Client(address, port);\n-        } catch (IOException io) {\n-            out.println(\"Failed to create client: \" + io);\n-            return 2;\n-        }\n-        display(\"Client socket: \" + client);\n-\n-        \/\/\n-        \/\/ Execute the server and client threads.\n-        \/\/\n-\n-        Exception exception = null;\n-        try {\n-            server.start();\n-            client.start();\n-            while (client.isAlive() || server.isAlive())\n-                if (client.exception == null && server.exception == null)\n-                    Thread.yield();\n-                else\n-                    break;\n-        } catch (TestFailure failure) {\n-            exception = failure;\n-        }\n-\n-        \/\/ Failure diagnostics, if needed.\n-\n-        Exception problem[] = new Exception[3];\n-        problem[0] = exception;\n-        problem[1] = server.exception;\n-        problem[2] = client.exception;\n-\n-        int exitCode = 0;\n-\n-        for (int i = 0; i < 3; i++)\n-            if (problem[i] != null) {\n-                out.println(\"#### OOPS ! ####\");\n-                problem[i].printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0) {\n-            out.println(\"#### OOPS ! ####\");\n-            out.println(\"# Test failed.\");\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Test passed.\");\n-        return 0; \/\/ PASSED\n-    }\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test; and stop with exit code 95 if the test\n-     * has passed, or with code 97 if the test has failed.\n-     * (This is JCK-like exit codes convention.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit code.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network001.java","additions":0,"deletions":544,"binary":false,"changes":544,"status":"deleted"},{"patch":"@@ -1,697 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network002.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between 2 Java virtual machines\n- *     using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- *     Both client and server VMs run on the same local computer and attach TCP\/IP\n- *     sockets to the local host, or to the loopback domain \"localhost\" (having IP\n- *     address 127.0.0.1).\n- *     Information transfer is synchronized in this test. Client VM passes\n- *     a large data parcel to server VM, and server reads that parcel and checks\n- *     if it is same as expected (byte-to-byte equality). Then server passes\n- *     (some other) parcel to client, and client reads and verifies those data.\n- *     This ping-pong game is repeated 2000 times; and after that both VMs check\n- *     if there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 125 bytes. So totally, each of the 2 VMs passes ~250Kb of data\n- *     to its partner, and thus ~500Kb of data are transfered by this test.\n- * COMMENTS\n- *     HotSpot 1.3beta-H fails to start this test due to the hotspot bug:\n- *         #4245704 (P1\/S1) Fails to launch with: jre\/bin\/net.dll ...\n- *     Test was fixed:\n- *     added WAITTIME parameter defined timeout for TCP\/IP sockets in minutes\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @build nsk.stress.network.network002\n- * @run main\/othervm PropertyResolvingWrapper\n- *      nsk.stress.network.network002\n- *      \"${test.jdk}\/bin\/java ${test.vm.opts} ${test.java.opts}\" 5\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test transfers huge amount of data between 2 Java virtual machines\n- * using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- * Both client and server VMs run on the same local computer and attach TCP\/IP\n- * sockets to the local host, or to the loopback domain ``<code>localhost<\/code>''\n- * (having IP address <code>127.0.0.1<\/code>).\n- * <p>\n- * <p>Information transfer is synchronized in this test. Client VM passes\n- * a large data parcel to server VM, and server reads that parcel and checks\n- * if it is same as expected (byte-to-byte equality). Then server passes\n- * (some other) parcel to client, and client reads and verifies those data.\n- * This ping-pong game is repeated 2000 times; and after that both VMs check\n- * if there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 125 bytes. So totally, each of the 2 VMs passes ~250Kb of data\n- * to its partner, and thus ~500Kb of data are transfered by this test.\n- *\/\n-public class network002 {\n-    \/**\n-     * Timeout for TCP\/IP sockets (currently set to 1 min).\n-     *\/\n-    private static int SO_TIMEOUT;\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private static final int DATA_PARCELS = 2000;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved.\n-     *\/\n-    private static final int MAX_PARCEL = 250;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test. After <code>run(args[],out)<\/code> stops,\n-     * follow JDK-like convention for exit codes. I.e.: stop with\n-     * exit status 95 if the test has passed, or with status 97 if\n-     * the test has failed.\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * Incarnate new <code>network002<\/code> instance reporting to the given\n-     * <code>out<\/code> stream, and invoke the method <code>run(args)<\/code>\n-     * for that instance to perform the test.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network002 test = new network002(out);\n-        int exitCode = test.run(args);\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Parse command-line parameters stored into <code>args[]<\/code> array,\n-     * then perform the test. I.e.: start the server thread at the same VM\n-     * this method runs, then start the other client VM, and verify data\n-     * transfer through TCP\/IP connection between those different virtual\n-     * machines.\n-     * <p>\n-     * <p>There should be 1 or 2 command-line parameters:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network002 <i>java_command<\/i> <i>waittime<\/i>\n-     * [<i>IP-address<\/i> | <i>host_name<\/i> | localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>java_command<\/i><\/code> - how to start java,\n-     * e.g.: ``<code>c:\\jdk1.3\\bin\\java -classic<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>waittime<\/code> - timeout for TCP\/IP sockets in minutes\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <p>\n-     * <p>Usually, <code><i>java_command<\/i><\/code> should point to the same\n-     * Java machine just executing this test. However, every compatible Java 2\n-     * implementation is appropriate.\n-     * <p>\n-     * <p>If optional parameter is ommited, the test invokes the method\n-     * <code>InetAddress.getLocalHost()<\/code> to get the domain name and\n-     * IP-address of the local computer.\n-     *\/\n-    private int run(String args[]) {\n-        \/\/\n-        \/\/ Get the Internet address of the local machine.\n-        \/\/\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 2:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 3:\n-                    address = InetAddress.getByName(args[2]);\n-                    break;\n-                default:\n-                    complain(\"Illegal arguments number; execute:\");\n-                    complain(\"    java network002 $JAVA_COMMAND \" +\n-                            \"[$IP_ADDRESS | $HOST_NAME | localhost]\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            complain(exception.toString());\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Start the server thread on the same VM this method just runs.\n-        \/\/\n-        Server server = null;\n-        try {\n-            server = new Server(address);\n-            server.start();\n-        } catch (Exception exception) {\n-            complain(\"Failed to start server: \" + exception);\n-            return 2;\n-        }\n-        display(\"Server: \" + server);\n-\n-        \/\/\n-        \/\/ Start the client process on different VM.\n-        \/\/\n-        String IPAddress = server.getIPAddress(); \/\/ e.g.: 127.0.0.1\n-        int port = server.getPort();\n-        String command = args[0] + \" \" + network002.class.getName() + \"$Client \" + IPAddress + \" \" + port;\n-        try {\n-            SO_TIMEOUT = Integer.parseInt(args[1]) * 60 * 1000;\n-        } catch (NumberFormatException e) {\n-            complain(\"Wrong timeout argument: \" + e);\n-            return 2;\n-        }\n-\n-        Runtime runtime = Runtime.getRuntime();\n-\n-        Process client = null;\n-        IORedirector redirectOut = null;\n-        IORedirector redirectErr = null;\n-\n-        try {\n-            client = runtime.exec(command);\n-\n-            InputStream clientOut = client.getInputStream();\n-            InputStream clientErr = client.getErrorStream();\n-            redirectOut = new IORedirector(clientOut, DEBUG_MODE ? out : null);\n-            redirectErr = new IORedirector(clientErr, out);\n-            redirectOut.start();\n-            redirectErr.start();\n-\n-        } catch (Exception exception) {\n-            complain(\"Failed to start client: \" + exception);\n-            return 2;\n-        }\n-\n-        \/\/\n-        \/\/ Wait until the server and client both stop.\n-        \/\/\n-        try {\n-            client.waitFor();\n-            if (redirectOut.isAlive())\n-                redirectOut.join();\n-            if (redirectErr.isAlive())\n-                redirectErr.join();\n-\n-            \/\/ If client has crashed, also terminate the server (to avoid hangup).\n-            int clientStatus = client.exitValue();\n-            if (clientStatus != 95) {\n-                complain(\"\");\n-                complain(\"Client VM has crashed: exit status=\" + clientStatus);\n-                if (server.isAlive())\n-                    complain(\"Server also should be terminated.\");\n-                complain(\"Test failed.\");\n-                return 2; \/\/ failure\n-            }\n-\n-            \/\/ Client has finished OK; wait for the server.\n-            if (server.isAlive())\n-                server.join();\n-\n-        } catch (Exception exception) {\n-            complain(\"Test interrupted: \" + exception);\n-            complain(\"Test failed.\");\n-            return 2; \/\/ FAILURE\n-        }\n-\n-        \/\/\n-        \/\/ Complain failure, if occured.\n-        \/\/\n-\n-        if (server.exception != null) {\n-            complain(\"Server exception: \" + server.exception);\n-            complain(\"Test failed.\");\n-            return 2; \/\/ failure\n-        }\n-\n-        display(\"Test passed.\");\n-        return 0; \/\/ Ok\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * The test should report to the given <code>out<\/code> stream.\n-     *\/\n-    private network002(PrintStream out) {\n-        this.out = out;\n-    }\n-\n-    \/**\n-     * Log stream for error messages and\/or (optional) execution trace.\n-     *\/\n-    private PrintStream out;\n-\n-    \/**\n-     * Print error message.\n-     *\/\n-    private void complain(Object message) {\n-        out.println(\"# \" + message);\n-        out.flush();\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va?\n-     *\/\n-    private void display(Object report) {\n-        if (DEBUG_MODE)\n-            out.println(report.toString());\n-        out.flush();\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Server thread should reply to data parcels sent by Client VM.\n-     *\/\n-    private class Server extends Thread {\n-        \/**\n-         * The socket to listen for a client.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Display the server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Server's IP-address in the form ``<code><i>x.y.u.z<\/i><\/code>'',\n-         * or ``<code>127.0.0.1<\/code>'' for loopback connection.\n-         *\/\n-        public String getIPAddress() {\n-            return serverSocket.getInetAddress().getHostAddress();\n-        }\n-\n-        \/**\n-         * Which port is this socket listening?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        public Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Exception just arisen while the server was working,\n-         * or <code>null<\/code> if it was OK with the server.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Accept connection, then reply to client's parcels.\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                socket.setSoTimeout(SO_TIMEOUT);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    display(\"Server: i=\" + i);\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Server got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"the parcel just read seems wrong for server\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Client VM should send data parcels to Server VM and\n-     * recieve and verify the server's replies.\n-     *\/\n-    private static class Client {\n-        \/**\n-         * Print error message.\n-         *\/\n-        private static void complain(Object message) {\n-            System.err.println(\"# \" + message);\n-            System.err.flush();\n-        }\n-\n-        \/**\n-         * Display execution trace.\n-         *\/\n-        private static void display(Object message) {\n-            System.out.println(message.toString());\n-            System.out.flush();\n-        }\n-\n-        \/**\n-         * Exit with JCK-like status.\n-         *\/\n-        private static void exit(int exitCode) {\n-            System.exit(exitCode + 95);\n-        }\n-\n-        \/**\n-         * Atack server with huge data parcels, and check if it replies correctly.\n-         * The command-line parameters prescribe the server's IP-address and port:\n-         * <br>&nbsp;&nbsp;\n-         * <code>java network002$Client <i>IP-address<\/i> <i>port<\/i><\/code>\n-         * <br>where:\n-         * <br>&nbsp;&nbsp;\n-         * <code><i>IP-address<\/i><\/code> - local host's address,\n-         * or <code>127.0.0.1<\/code>\n-         * <br>&nbsp;&nbsp;\n-         * <code><i>port<\/i><\/code> - some port assigned by server\n-         *\/\n-        public static void main(String args[]) {\n-            if (args.length != 2) {\n-                complain(\"Illegal number of client paramenets, try:\");\n-                complain(\"    java network002$Client IP-address port\");\n-                exit(2); \/\/ FAILED\n-            }\n-\n-            try {\n-                InetAddress address = InetAddress.getByName(args[0]);\n-                int port = Integer.parseInt(args[1]);\n-\n-                Socket socket = new Socket(address, port);\n-                socket.setSoTimeout(SO_TIMEOUT);\n-                display(\"Client: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    display(\"Client: i=\" + i);\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Client got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception exception) {\n-                complain(\"Client exception: \" + exception);\n-                exit(2); \/\/ FAILED\n-            }\n-            exit(0); \/\/ PASSED, at least at the client side.\n-        }\n-\n-    }\n-\n-    \/**\n-     * Two of such threads should redirect <code>out<\/code> and <code>err<\/code>\n-     * streams of client VM.\n-     *\/\n-    private static class IORedirector extends Thread {\n-        \/**\n-         * Source stream.\n-         *\/\n-        InputStream in;\n-        \/**\n-         * Destination stream.\n-         *\/\n-        OutputStream out;\n-\n-        \/**\n-         * Redirect <code>in<\/code> to <code>out<\/code>.\n-         *\/\n-        public IORedirector(InputStream in, OutputStream out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-\n-        \/**\n-         * Read input stream until the EOF, and write everithing to output stream.\n-         * If output stream is assigned to <code>null<\/code>, do not print anything,\n-         * but read the input stream anywhere.\n-         *\/\n-        public void run() {\n-            try {\n-                for (; ; ) {\n-                    int symbol = in.read();\n-                    if (symbol < 0)\n-                        break; \/\/ EOF\n-                    if (out != null)\n-                        out.write(symbol);\n-                }\n-\n-                if (out != null)\n-                    out.flush();\n-\n-            } catch (Exception exception) {\n-                throw new TestFailure(\"IORedirector exception: \" + exception);\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * A data parcel to be sent\/recieved between Client VM and Server thread.\n-     * When data parcel is sent, first 4 bytes are transfered which encode the\n-     * <code>int<\/code> number equal to size of the parcel minus 1. I.e.: if\n-     * number of data bytes in the parcel's contents is <code>N<\/code>, then\n-     * the first 4 bytes encode the number <code>N-1<\/code>. After that, the\n-     * parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client may throw this exception to report the test failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network002.java","additions":0,"deletions":697,"binary":false,"changes":697,"status":"deleted"},{"patch":"@@ -1,658 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network003.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between one server and multiple\n- *     clients communicating via TCP\/IP sockets, and checks if those data are\n- *     transfered correctly. All TCP\/IP sockets are attached to local host\n- *     (by its domain name), or to the ``localhost'' loopback (having the IP\n- *     address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a large data parcel to server,\n- *     and server reads that parcel and checks if it is same as expected\n- *     (byte-to-byte equality is desired). Then server passes (some other) parcel\n- *     to the client, and client reads and verifies those bytes. This ping-pong\n- *     game is repeated 128 times; and after that each pair of sockets checks if\n- *     there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- *     data to each other, and thus ~32Kb of data are transfered by each sockets\n- *     pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- * COMMENTS\n- *     The production Solaris_JDK_1.3-b12 Server VM crashes under this test:\n- *         #\n- *         # HotSpot Virtual Machine Error, Unexpected Signal 10\n- *         # Please report this error at\n- *         # http:\/\/java.sun.com\/cgi-bin\/bugreport.cgi\n- *         #\n- *         # Error ID: 4F533F534F4C415249530E43505007D9 01\n- *         #\n- *         # Problematic Thread: prio=5 tid=0x214418 nid=0x103 runnable\n- *         #\n- *     (ErrorID == \"os_solaris.cpp, 2009\")\n- *\n- * @run main\/othervm nsk.stress.network.network003\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test transfers huge amount of data between one server and multiple\n- * clients communicating via TCP\/IP sockets, and checks if those data are\n- * transfered correctly. All TCP\/IP sockets are attached to local host\n- * (by its domain name), or to the ``localhost'' loopback (having the IP\n- * address 127.0.0.1).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a large data parcel to server,\n- * and server reads that parcel and checks if it is same as expected\n- * (byte-to-byte equality is desired). Then server passes (some other) parcel\n- * to the client, and client reads and verifies those bytes. This ping-pong\n- * game is repeated 128 times; and after that each pair of sockets checks if\n- * there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- * data to each other, and thus ~32Kb of data are transfered by each sockets\n- * pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- *\/\n-public class network003 {\n-    \/**\n-     * Do actually display optional reports?\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * Errors and optional reports log. Usually <code>System.out<\/code>.\n-     *\/\n-    static private PrintStream out = System.out;\n-\n-    \/**\n-     * Print error message: all clients and servers may print concurently.\n-     *\/\n-    static private synchronized void println(Object message) {\n-        out.println(message.toString());\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va.\n-     *\/\n-    static private void display(Object report) {\n-        if (DEBUG_MODE)\n-            println(report.toString());\n-    }\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * Number of client\/server connections to establish.\n-     *\/\n-    private static final int CONNECTIONS = detectOSLimitation();\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private static final int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private static final int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        ServerSocket ssoc[] = new ServerSocket[CONNECTIONS_TO_TRY];\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-        int i;\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                ssoc[i] = new ServerSocket(0);\n-                display(\"--- Open: ssoc[\" + i + \"] = \" + ssoc[i]);\n-            } catch (IOException ioe) {\n-                display(\"--- OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"--- Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\"--- Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                ssoc[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\"--- OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            println(\"# ------------------------- CAUTION: -------------------\");\n-            println(\"# While checking the OS limitations, the test found that\");\n-            println(\"# only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            println(\"# simultaneously. However, possibility to open at least\");\n-            println(\"# \" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            println(\"# \");\n-            println(\"# So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            println(\"# safe to be open simultaneously.\");\n-            println(\"# ------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/**\n-     * Server thread intended to reply to data parcels sent by Client thread.\n-     *\/\n-    static private class Server extends Thread {\n-        \/**\n-         * This server thread listens the single socket.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Address and port of this server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Accept connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                display(\"Server socket: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Server thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"server has read unexpected parcel\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Client thread intended to send data parcels to Server thread and\n-     * to recieve the server's replies.\n-     *\/\n-    static private class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-        }\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return socket.getPort();\n-        }\n-\n-\n-        \/**\n-         * Establish connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Client thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * A data parcel to sent\/recieved between Client and Server threads.\n-     * When data parcel is sent, first 4 bytes transfered encode the size\n-     * of the parcel (i.e.: number of data bytes in the parcel's contents).\n-     * Then the parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client thread may throw this exception to report the test\n-     * failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Attach client and server sockets to the local host, and check if\n-     * huge amount of data could be correctly transfered between these\n-     * sockets.\n-     * <p>\n-     * <p>Command-line parameters provided with <code>args[]<\/code> may\n-     * prompt the local host IP address or domain name. Execute:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network003 [<i>IP-address<\/i> | <i>host_name<\/i> |\n-     * localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <br>By default, the test uses the Internet address available via\n-     * the method <code>InetAddress.getLocalHost()<\/code>\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network003.out = out;\n-\n-        \/\/\n-        \/\/ Get IP address of the local machine.\n-        \/\/\n-\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 0:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 1:\n-                    String hostName = args[0];\n-                    address = InetAddress.getByName(args[0]);\n-                    break;\n-                default:\n-                    println(\"Use:\");\n-                    println(\"    java network003\");\n-                    println(\"or:\");\n-                    println(\"    java network003 ${IP_ADDRESS}\");\n-                    println(\"or:\");\n-                    println(\"    java network003 ${HOST_NAME}\");\n-                    println(\"or:\");\n-                    println(\"    java network003 localhost\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            println(exception);\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Incarnate the server & the client sockets.\n-        \/\/\n-\n-        Server server[] = new Server[CONNECTIONS];\n-        Client client[] = new Client[CONNECTIONS];\n-\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            try {\n-                server[i] = new Server(address);\n-            } catch (IOException io) {\n-                println(\"Failed to create server #\" + i + \": \" + io);\n-                return 2;\n-            }\n-            display(\"Server #\" + i + \": \" + server[i]);\n-        }\n-\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            int port = server[i].getPort();\n-            try {\n-                client[i] = new Client(address, port);\n-            } catch (IOException io) {\n-                out.println(\"Failed to create client #\" + i + \": \" + io);\n-                return 2;\n-            }\n-            display(\"Client socket #\" + i + \": \" + client[i]);\n-        }\n-\n-        \/\/\n-        \/\/ Execute the server and client threads.\n-        \/\/\n-\n-        Exception exception = null;\n-        try {\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                server[i].start();\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                client[i].start();\n-            boolean someIsAlive = true;\n-            while (someIsAlive) {\n-                boolean aliveFound = false;\n-                boolean someBroken = false;\n-                for (int i = 0; i < CONNECTIONS; i++)\n-                    if (client[i].isAlive() || server[i].isAlive()) {\n-                        if ((client[i].exception != null) ||\n-                                (server[i].exception != null))\n-                            someBroken = true;\n-                        aliveFound = true;\n-                        Thread.yield();\n-                    }\n-                someIsAlive = aliveFound;\n-                if (someBroken)\n-                    break;\n-            }\n-        } catch (TestFailure failure) {\n-            exception = failure;\n-        }\n-\n-        \/\/ Failure diagnostics, if needed.\n-\n-        Exception problem[] = new Exception[2 * CONNECTIONS + 1];\n-        problem[0] = exception;\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            problem[2 * i + 1] = server[i].exception;\n-            problem[2 * i + 2] = client[i].exception;\n-        }\n-\n-        int exitCode = 0;\n-\n-        for (int i = 0; i < 2 * CONNECTIONS + 1; i++)\n-            if (problem[i] != null) {\n-                out.println(\"#### OOPS ! ####\");\n-                problem[i].printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0) {\n-            out.println(\"#### OOPS ! ####\");\n-            out.println(\"# Test failed.\");\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Test passed.\");\n-        return 0; \/\/ PASSED\n-    }\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test; and stop with exit code 95 if the test\n-     * has passed, or with code 97 if the test has failed.\n-     * (This is JCK-like exit codes convention.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit code.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network003.java","additions":0,"deletions":658,"binary":false,"changes":658,"status":"deleted"},{"patch":"@@ -1,878 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network004.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between 2 Java virtual machines\n- *     using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- *     Both client and server VMs run on the same local computer and attach TCP\/IP\n- *     sockets to the local host, or to the loopback domain ``localhost''\n- *     (having IP address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a large data parcel to server,\n- *     and server reads that parcel and checks if it is same as expected\n- *     (byte-to-byte equality is desired). Then server passes (some other) parcel\n- *     to the client, and client reads and verifies those bytes. This ping-pong\n- *     game is repeated 128 times; and after that each pair of sockets checks if\n- *     there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average\n- *     parcel length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- *     data to each other, and thus ~32Kb of data are transfered by each sockets\n- *     pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- * COMMENTS\n- *     The production Solaris_JDK_1.3-b12 Server VM intermittently crashes under\n- *     this test, even when client part of the test is executed with Client HS:\n- *         >>>> java -server network004 java\n- *         #\n- *         # HotSpot Virtual Machine Error, Unexpected Signal 10\n- *         # Please report this error at\n- *         # http:\/\/java.sun.com\/cgi-bin\/bugreport.cgi\n- *         #\n- *         # Error ID: 4F533F534F4C415249530E43505007D9 01\n- *         #\n- *         # Problematic Thread: prio=5 tid=0x214418 nid=0x103 runnable\n- *         #\n- *     (ErrorID == \"os_solaris.cpp, 2009\")\n- *     If the client part of the test is executed with Server HS, the\n- *     production Solaris_JDK_1.3-b12 Server VM intermittently fails\n- *     this test due to timeout:\n- *         >>>> time java -server network004 'java -server -showversion'\n- *         java version \"1.3\"\n- *         Java(TM) 2 Runtime Environment, Standard Edition (build Solaris_JDK_1.3-b12)\n- *         Java HotSpot(TM) Server VM (build 1.3-b12, mixed mode)\n- *         # Client #96: java.io.InterruptedIOException: Read timed out\n- *         # Client VM has crashed: exit status=97\n- *         # Test failed.\n- *         156.0u 117.0s 7:06 63% 0+0k 0+0io 0pf+0w\n- *     Test was fixed:\n- *     added WAITTIME parameter defined timeout for TCP\/IP sockets in minutes\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @build nsk.stress.network.network004\n- * @run main\/othervm PropertyResolvingWrapper\n- *      nsk.stress.network.network004\n- *      \"${test.jdk}\/bin\/java ${test.vm.opts} ${test.java.opts}\" 5\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * This test transfers huge amount of data between 2 Java virtual machines\n- * using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- * Both client and server VMs run on the same local computer and attach TCP\/IP\n- * sockets to the local host, or to the loopback domain ``<code>localhost<\/code>''\n- * (having IP address <code>127.0.0.1<\/code>).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a large data parcel to server,\n- * and server reads that parcel and checks if it is same as expected\n- * (byte-to-byte equality is desired). Then server passes (some other) parcel\n- * to the client, and client reads and verifies those bytes. This ping-pong\n- * game is repeated 128 times; and after that each pair of sockets checks if\n- * there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average\n- * parcel length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- * data to each other, and thus ~32Kb of data are transfered by each sockets\n- * pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- *\/\n-public class network004 {\n-    \/**\n-     * Timeout for TCP\/IP sockets (currently set to 1 min).\n-     *\/\n-    private static int SO_TIMEOUT;\/\/ = 2*60*1000;\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private final static int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private final static int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        ServerSocket ssoc[] = new ServerSocket[CONNECTIONS_TO_TRY];\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-        int i;\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                ssoc[i] = new ServerSocket(0);\n-                display(\"--- Open: ssoc[\" + i + \"] = \" + ssoc[i]);\n-            } catch (IOException ioe) {\n-                display(\"--- OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"--- Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\"--- Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                ssoc[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\"--- OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            complain(\"------------------------- CAUTION: -------------------\");\n-            complain(\"While checking the OS limitations, the test found that\");\n-            complain(\"only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            complain(\"simultaneously. However, possibility to open at least\");\n-            complain(\"\" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            complain(\"\");\n-            complain(\"So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            complain(\"safe to be open simultaneously.\");\n-            complain(\"------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test. After <code>run(args[],out)<\/code> stops,\n-     * follow JDK-like convention for exit codes. I.e.: stop with\n-     * exit status 95 if the test has passed, or with status 97 if\n-     * the test has failed.\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * Parse command-line parameters stored into <code>args[]<\/code> array,\n-     * then perform the test. I.e.: start the server thread at the same VM\n-     * this method runs, then start the other client VM, and verify data\n-     * transfer through TCP\/IP connection between those different virtual\n-     * machines.\n-     * <p>\n-     * <p>There should be 1 or 2 command-line parameters:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network004 <i>java_command<\/i>\n-     * [<i>IP-address<\/i> | <i>host_name<\/i> | localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>java_command<\/i><\/code> - how to start java,\n-     * e.g.: ``<code>c:\\jdk1.3\\bin\\java -classic<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>waittime<\/code> - timeout for TCP\/IP sockets in minutes\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <p>\n-     * <p>Usually, <code><i>java_command<\/i><\/code> should point to the same\n-     * Java machine just executing this test. However, every compatible Java 2\n-     * implementation is appropriate.\n-     * <p>\n-     * <p>If optional parameter is ommited, the test invokes the method\n-     * <code>InetAddress.getLocalHost()<\/code> to get the domain name and\n-     * IP-address of the local computer.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network004.out = out;\n-\n-        \/\/\n-        \/\/ Get the Internet address of the local machine.\n-        \/\/\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 2:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 3:\n-                    address = InetAddress.getByName(args[2]);\n-                    break;\n-                default:\n-                    complain(\"Illegal arguments number; execute:\");\n-                    complain(\"    java network004 $JAVA_COMMAND \" +\n-                            \"[$IP_ADDRESS | $HOST_NAME | localhost]\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            complain(exception.toString());\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Detect if it is safe to open MAX_CONNETIONS simultaneously:\n-        \/\/\n-        final int CONNECTIONS = detectOSLimitation();\n-\n-        \/\/\n-        \/\/ Start the server thread on the same VM (which executes this method).\n-        \/\/\n-        Server server[] = new Server[CONNECTIONS];\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            try {\n-                server[i] = new Server(address);\n-            } catch (Exception exception) {\n-                complain(\"Server #\" + i + \": \" + exception);\n-                return 2;\n-            }\n-            display(\"Server #\" + i + \": \" + server[i]);\n-            server[i].start();\n-        }\n-\n-        \/\/\n-        \/\/ Start the client process on different VM.\n-        \/\/\n-        String command = args[0] + \" \" + network004.class.getName() + \"$Client\";\n-        try {\n-            SO_TIMEOUT = Integer.parseInt(args[1]) * 60 * 1000;\n-        } catch (NumberFormatException e) {\n-            complain(\"Wrong timeout argument: \" + e);\n-            return 2;\n-        }\n-\n-        Runtime runtime = Runtime.getRuntime();\n-\n-        Process client = null;\n-        IORedirector redirectOut = null;\n-        IORedirector redirectErr = null;\n-\n-        try {\n-            \/\/ Start clients on different JVM:\n-            client = runtime.exec(command);\n-\n-            \/\/ Provide clients with access to stderr and stdout:\n-            InputStream clientOut = client.getInputStream();\n-            InputStream clientErr = client.getErrorStream();\n-            redirectOut = new IORedirector(clientOut, DEBUG_MODE ? out : null);\n-            redirectErr = new IORedirector(clientErr, out);\n-            redirectOut.start();\n-            redirectErr.start();\n-\n-            \/\/ Pass parameters to clients (number of connections, and IP adresses and ports):\n-            PrintStream clientIn = new PrintStream(client.getOutputStream());\n-            clientIn.println(CONNECTIONS);\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                clientIn.println(server[i].getIPAddress() + \" \" + server[i].getPort());\n-            clientIn.flush();\n-            clientIn.close();\n-\n-        } catch (Exception exception) {\n-            complain(\"Failed to start client: \" + exception);\n-            return 2;\n-        }\n-\n-        \/\/\n-        \/\/ Wait until the server and client both stop.\n-        \/\/\n-        boolean testFailed = false;\n-        try {\n-            client.waitFor();\n-            \/\/ Let I\/O redirectors to flush:\n-            if (redirectOut.isAlive())\n-                redirectOut.join();\n-            if (redirectErr.isAlive())\n-                redirectErr.join();\n-\n-            \/\/ If client has crashed, also terminate the server (to avoid hangup).\n-            int clientStatus = client.exitValue();\n-            if (clientStatus != 95) {\n-                complain(\"Client VM has failed: exit status=\" + clientStatus);\n-                testFailed = true;\n-            }\n-\n-            \/\/ Client has finished OK; wait for the server.\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Server: waiting for #\" + i);\n-                while (server[i].isAlive())\n-                    server[i].join();\n-                if (server[i].exception != null) {\n-                    complain(\"Server thread #\" + i + \": \" + server[i].exception);\n-                    testFailed = true;\n-                }\n-            }\n-\n-        } catch (Exception exception) {\n-            complain(\"Test interrupted: \" + exception);\n-            testFailed = true;\n-        }\n-\n-        if (testFailed)\n-            complain(\"Test failed.\");\n-        else\n-            display(\"Test passed.\");\n-        return testFailed ? 2 : 0;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Log stream for error messages and\/or (optional) execution trace.\n-     *\/\n-    private static PrintStream out;\n-\n-    \/**\n-     * Print error message.\n-     *\/\n-    private static synchronized void complain(Object message) {\n-        out.println(\"# \" + message);\n-        out.flush();\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va?\n-     *\/\n-    private static synchronized void display(Object report) {\n-        if (DEBUG_MODE)\n-            out.println(report.toString());\n-        out.flush();\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Server thread should reply to data parcels sent by Client VM.\n-     *\/\n-    private static class Server extends Thread {\n-        \/**\n-         * The socket to listen for a client.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Display the server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Server's IP-address in the form ``<code><i>x.y.u.z<\/i><\/code>'',\n-         * or ``<code>127.0.0.1<\/code>'' for loopback connection.\n-         *\/\n-        public String getIPAddress() {\n-            return serverSocket.getInetAddress().getHostAddress();\n-        }\n-\n-        \/**\n-         * Which port is this socket listening?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        public Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Exception just arisen while the server was working,\n-         * or <code>null<\/code> if it was OK with the server.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Accept connection, then reply to client's parcels.\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                socket.setSoTimeout(SO_TIMEOUT);\n-\/\/              display(\"Server: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Server thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"server has read unexpected parcel\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Client VM should send data parcels to Server VM and\n-     * recieve and verify the server's replies.\n-     *\/\n-    private static class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-            socket.setSoTimeout(SO_TIMEOUT);\n-        }\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return socket.getPort();\n-        }\n-\n-        \/**\n-         * Establish connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Client thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-        \/**\n-         * Establish connections to lots of server sockets, atack servers with\n-         * huge data parcels, and check if it replies correctly. The addresses\n-         * and port numbers for server sockets are passed through <code>stdin<\/code>.\n-         * The input stream must consist of the stipulated number (up to 128+1) of\n-         * lines containing the pair of symbolic server domain name and the port number,\n-         * like:\n-         * <br>&nbsp;&nbsp; actual_number_of_sockets\n-         * <br>&nbsp;&nbsp; address_1 port_1\n-         * <br>&nbsp;&nbsp; address_2 port_2\n-         * <br>&nbsp;&nbsp; . . .\n-         * <br>&nbsp;&nbsp; address_N port_N\n-         * <br>where N must equal to the actual_number_of_sockets.\n-         *\/\n-        public static void main(String args[]) {\n-            \/\/ ---- Parse stdin for the list of server sockets: ---- \/\/\n-            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n-\n-            final int CONNECTIONS;\n-            try {\n-                String line = in.readLine();\n-                if (line == null) {\n-                    complain(\"Client expects paramenets passed through stdin:\");\n-                    complain(\"    actual_number_of_sockets\");\n-                    complain(\"    IP-address_1 port_1\");\n-                    complain(\"    IP-address_2 port_2\");\n-                    complain(\"    .   .   .\");\n-                    complain(\"    IP-address_N port_N\");\n-                    exit(2); \/\/ FAILED\n-                }\n-                CONNECTIONS = Integer.parseInt(line);\n-            } catch (IOException ioe) {\n-                complain(\"Client failed to read the actual number of CONNECTIONS\");\n-                throw new RuntimeException(ioe.toString());\n-            }\n-\n-            Client client[] = new Client[CONNECTIONS];\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                try {\n-                    String line = in.readLine();\n-                    if (line == null) {\n-                        complain(\"Client: failed to read address\/port for client #\" + i);\n-                        exit(3);\n-                    }\n-\n-                    StringTokenizer tokenz = new StringTokenizer(line);\n-                    if (tokenz.countTokens() != 2) {\n-                        complain(\"Client: illegal input string: \" + line);\n-                        exit(3);\n-                    }\n-                    String serverName = (String) tokenz.nextElement();\n-                    InetAddress address = InetAddress.getByName(serverName);\n-                    int port = Integer.parseInt((String) tokenz.nextElement());\n-\n-                    client[i] = new Client(address, port);\n-\n-                    display(\"Client #\" + i + \": \" + client[i]);\n-\n-                } catch (IOException ioe) {\n-                    complain(\"Client #\" + i + \": \" + ioe);\n-                    exit(3);\n-                }\n-\n-            \/\/ ---- Start testing: ---- \/\/\n-\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                client[i].start();\n-\n-            int status = 0;\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Client: waiting for #\" + i);\n-                while (client[i].isAlive())\n-                    yield();\n-                if (client[i].exception != null) {\n-                    complain(\"Client #\" + i + \": \" + client[i].exception);\n-                    status = 2;\n-                }\n-            }\n-\n-            exit(status);\n-        }\n-\n-        \/**\n-         * Print error message.\n-         *\/\n-        private static synchronized void complain(Object message) {\n-            System.err.println(\"# \" + message);\n-            System.err.flush();\n-        }\n-\n-        \/**\n-         * Display execution trace.\n-         *\/\n-        private static synchronized void display(Object message) {\n-            if (!DEBUG_MODE)\n-                return;\n-            System.out.println(message.toString());\n-            System.out.flush();\n-        }\n-\n-        \/**\n-         * Exit with JCK-like status.\n-         *\/\n-        private static void exit(int exitCode) {\n-            System.exit(exitCode + 95);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Two of such threads should redirect <code>out<\/code> and <code>err<\/code>\n-     * streams of client VM.\n-     *\/\n-    private static class IORedirector extends Thread {\n-        \/**\n-         * Source stream.\n-         *\/\n-        InputStream in;\n-        \/**\n-         * Destination stream.\n-         *\/\n-        OutputStream out;\n-\n-        \/**\n-         * Redirect <code>in<\/code> to <code>out<\/code>.\n-         *\/\n-        public IORedirector(InputStream in, OutputStream out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-\n-        \/**\n-         * Read input stream until the EOF, and write everithing to output stream.\n-         * If output stream is assigned to <code>null<\/code>, do not print anything,\n-         * but read the input stream anywhere.\n-         *\/\n-        public void run() {\n-            try {\n-                for (; ; ) {\n-                    int symbol = in.read();\n-                    if (symbol < 0)\n-                        break; \/\/ EOF\n-                    if (out != null)\n-                        out.write(symbol);\n-                }\n-\n-                if (out != null)\n-                    out.flush();\n-\n-            } catch (Exception exception) {\n-                throw new TestFailure(\"IORedirector exception: \" + exception);\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * A data parcel to be sent\/recieved between Client VM and Server thread.\n-     * When data parcel is sent, first 4 bytes are transfered which encode the\n-     * <code>int<\/code> number equal to size of the parcel minus 1. I.e.: if\n-     * number of data bytes in the parcel's contents is <code>N<\/code>, then\n-     * the first 4 bytes encode the number <code>N-1<\/code>. After that, the\n-     * parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client may throw this exception to report the test failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network004.java","additions":0,"deletions":878,"binary":false,"changes":878,"status":"deleted"},{"patch":"@@ -1,635 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network005.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test make huge number of data transers between one server and\n- *     multiple clients communicating via TCP\/IP sockets, and checks if those\n- *     data are transfered correctly. All TCP\/IP sockets are attached to local\n- *     host (by its domain name), or to the ``localhost'' loopback (having the\n- *     IP address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a large data parcel to server,\n- *     and server reads that parcel and checks if it is same as expected\n- *     (byte-to-byte equality is desired). Then server passes (some other) parcel\n- *     to the client, and client reads and verifies those bytes. This ping-pong\n- *     game is repeated 128 times; and after that each pair of sockets checks if\n- *     there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- *     data to each other, and thus ~32Kb of data are transfered by each sockets\n- *     pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- * COMMENTS\n- *\n- * @run main\/othervm nsk.stress.network.network005\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test make huge number of data transers between one server and\n- * multiple clients communicating via TCP\/IP sockets, and checks if those\n- * data are transfered correctly. All TCP\/IP sockets are attached to local\n- * host (by its domain name), or to the ``localhost'' loopback (having the\n- * IP address 127.0.0.1).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a large data parcel to server,\n- * and server reads that parcel and checks if it is same as expected\n- * (byte-to-byte equality is desired). Then server passes (some other) parcel\n- * to the client, and client reads and verifies those bytes. This ping-pong\n- * game is repeated 128 times; and after that each pair of sockets checks if\n- * there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- * data to each other, and thus ~32Kb of data are transfered by each sockets\n- * pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- *\/\n-public class network005 {\n-    \/**\n-     * Do actually display optional reports?\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * Errors and optional reports log. Usually <code>System.out<\/code>.\n-     *\/\n-    static private PrintStream out = System.out;\n-\n-    \/**\n-     * Print error message: all clients and servers may print concurently.\n-     *\/\n-    static private synchronized void println(Object message) {\n-        out.println(message.toString());\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va.\n-     *\/\n-    static private void display(Object report) {\n-        if (DEBUG_MODE)\n-            println(report.toString());\n-    }\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * Number of client\/server connections to establish.\n-     *\/\n-    private static final int CONNECTIONS = detectOSLimitation();\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private static final int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private static final int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-\n-        InetAddress address;\n-        ServerSocket serverSocket;\n-        try {\n-            address = InetAddress.getLocalHost();\n-            int anyPort = 0;\n-            int defaultBacklog = 50;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException ioe) {\n-            throw new Error(\"FATAL error while loading the test: \" + ioe);\n-        }\n-        display(serverSocket.toString());\n-\n-        Socket server[] = new Socket[CONNECTIONS_TO_TRY];\n-        Socket client[] = new Socket[CONNECTIONS_TO_TRY];\n-\n-        int i, port = serverSocket.getLocalPort();\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                client[i] = new Socket(address, port);\n-                display(\"--- Open: client[\" + i + \"] = \" + client[i]);\n-                server[i] = serverSocket.accept();\n-                display(\"--- Open: server[\" + i + \"] = \" + server[i]);\n-            } catch (IOException ioe) {\n-                display(\"--- OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"--- Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\"--- Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                server[j].close();\n-                client[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\"--- OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            println(\"# ------------------------- CAUTION: -------------------\");\n-            println(\"# While checking the OS limitations, the test found that\");\n-            println(\"# only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            println(\"# simultaneously. However, possibility to open at least\");\n-            println(\"# \" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            println(\"# \");\n-            println(\"# So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            println(\"# safe to be open simultaneously.\");\n-            println(\"# ------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/**\n-     * Server (or client) thread intended to transfer data parcels to\n-     * another client (or server) Agent.\n-     *\/\n-    static private class Agent extends Thread {\n-        \/**\n-         * Agent's client mode.\n-         *\/\n-        final static int CLIENT = 1;\n-        \/**\n-         * Agen's server mode.\n-         *\/\n-        final static int SERVER = 2;\n-\n-        \/**\n-         * Is this agent is client or server one?\n-         *\/\n-        private int mode;\n-\n-        \/**\n-         * This server thread listens the single socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            if (mode == SERVER)\n-                return socket.getLocalPort();\n-            else\n-                return socket.getPort();\n-        }\n-\n-        \/**\n-         * Address and port of this server socket.\n-         *\/\n-        public String toString() {\n-            String mode = (this.mode == CLIENT) ? \"Client\" : \"Server\";\n-            return mode + \": \" + socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        Agent(Socket socket, int mode) {\n-            if ((mode != SERVER) && (mode != CLIENT))\n-                throw new IllegalArgumentException(\"unknown mode=\" + mode);\n-            this.socket = socket;\n-            this.mode = mode;\n-        }\n-\n-        \/**\n-         * Transfer <code>DATA_PARCELS<\/code> parcels of random data.\n-         * Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    if (mode == SERVER) {\n-                        Parcel sample = new Parcel(istream); \/\/ read\n-                        if (!sample.equals(etalon)) {\n-                            println(\"Server agent for port #\"\n-                                    + getPort() + \" got unexpected parcel:\\n\"\n-                                    + \"sample=\" + sample + \"\\n\"\n-                                    + \"etalon=\" + etalon);\n-                            throw new TestFailure(\n-                                    \"server has read unexpected parcel\");\n-                        }\n-\n-                        etalon.send(ostream);                \/\/ reply\n-                        ostream.flush();\n-\n-                    } else {\n-                        etalon.send(ostream);                \/\/ init transfer\n-                        ostream.flush();\n-\n-                        Parcel sample = new Parcel(istream); \/\/ read\n-                        if (!sample.equals(etalon)) {\n-                            println(\"Client agent for port #\"\n-                                    + getPort() + \" got unexpected parcel:\\n\"\n-                                    + \"sample=\" + sample + \"\\n\"\n-                                    + \"etalon=\" + etalon);\n-                            throw new TestFailure(\n-                                    \"parcel context is unexpected to client\");\n-                        }\n-                    }\n-                }\n-\n-                if (mode == SERVER) {\n-                    int datum = istream.read(); \/\/ wait until client's close()\n-                    if (datum >= 0)\n-                        throw new TestFailure(\n-                                \"server has read ambigous byte: \" + datum);\n-\n-                    ostream.close(); \/\/ implies: socket.close();\n-\n-                } else {\n-                    if (istream.available() > 0) {\n-                        int datum = istream.read();\n-                        throw new TestFailure(\n-                                \"client has read ambigous byte: \" + datum);\n-                    }\n-                    ostream.close(); \/\/ implies: socket.close()\n-                }\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * A data parcel to sent\/recieved between Client and Server threads.\n-     * When data parcel is sent, first 4 bytes transfered encode the size\n-     * of the parcel (i.e.: number of data bytes in the parcel's contents).\n-     * Then the parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client thread may throw this exception to report the test\n-     * failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Attach client and server sockets to the local host, and check if\n-     * huge number of data transfers could be correctly transfered between\n-     * these sockets.\n-     * <p>\n-     * <p>Command-line parameters provided with <code>args[]<\/code> may\n-     * prompt the local host IP address or domain name. Execute:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network005 [<i>IP-address<\/i> | <i>host_name<\/i> |\n-     * localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <br>By default, the test uses the Internet address available via\n-     * the method <code>InetAddress.getLocalHost()<\/code>\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network005.out = out;\n-\n-        \/\/\n-        \/\/ Get IP address of the local machine.\n-        \/\/\n-\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 0:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 1:\n-                    String hostName = args[0];\n-                    address = InetAddress.getByName(args[0]);\n-                    break;\n-                default:\n-                    println(\"Use:\");\n-                    println(\"    java network005\");\n-                    println(\"or:\");\n-                    println(\"    java network005 ${IP_ADDRESS}\");\n-                    println(\"or:\");\n-                    println(\"    java network005 ${HOST_NAME}\");\n-                    println(\"or:\");\n-                    println(\"    java network005 localhost\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            println(exception);\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Assign ServerSocket to the local host:\n-        \/\/\n-\n-        ServerSocket serverSocket;\n-        try {\n-            final int anyPort = 0;\n-            final int defaultBacklog = 50;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException ioe) {\n-            println(\"# Failed to assign ServerSocket on: \" + address);\n-            return 2;\n-        }\n-        display(serverSocket.toString());\n-\n-        final int port = serverSocket.getLocalPort();\n-\n-        \/\/\n-        \/\/ Incarnate the server & the client agents.\n-        \/\/\n-\n-        Agent server[] = new Agent[CONNECTIONS];\n-        Agent client[] = new Agent[CONNECTIONS];\n-\n-        for (int i = 0; i < CONNECTIONS; i++)\n-            try {\n-                Socket socket;\n-                socket = new Socket(address, port);\n-                client[i] = new Agent(socket, Agent.CLIENT);\n-                display(\"Client #\" + i + \": \" + socket);\n-                socket = serverSocket.accept();\n-                server[i] = new Agent(socket, Agent.SERVER);\n-                display(\"Server #\" + i + \": \" + socket);\n-            } catch (IOException io) {\n-                println(\"Failed establish conection #\" + i + \": \" + io);\n-                return 2;\n-            }\n-\n-        \/\/\n-        \/\/ Execute the server and client threads.\n-        \/\/\n-\n-        Exception exception = null;\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            server[i].start();\n-            client[i].start();\n-        }\n-        try {\n-            boolean someIsAlive = true;\n-            while (someIsAlive) {\n-                boolean aliveFound = false;\n-                boolean someBroken = false;\n-                for (int i = 0; i < CONNECTIONS; i++)\n-                    if (client[i].isAlive() || server[i].isAlive()) {\n-                        if ((client[i].exception != null) ||\n-                                (server[i].exception != null))\n-                            someBroken = true;\n-                        aliveFound = true;\n-                        Thread.yield();\n-                    }\n-                someIsAlive = aliveFound;\n-                if (someBroken)\n-                    break;\n-            }\n-        } catch (TestFailure failure) {\n-            exception = failure;\n-        }\n-\n-        \/\/ Failure diagnostics, if needed.\n-\n-        Exception problem[] = new Exception[2 * CONNECTIONS + 1];\n-        problem[0] = exception;\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            problem[2 * i + 1] = server[i].exception;\n-            problem[2 * i + 2] = client[i].exception;\n-        }\n-\n-        int exitCode = 0;\n-\n-        for (int i = 0; i < 2 * CONNECTIONS + 1; i++)\n-            if (problem[i] != null) {\n-                out.println(\"#### OOPS ! ####\");\n-                problem[i].printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0) {\n-            out.println(\"#### OOPS ! ####\");\n-            out.println(\"# Test failed.\");\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Test passed.\");\n-        return 0; \/\/ PASSED\n-    }\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test; and stop with exit code 95 if the test\n-     * has passed, or with code 97 if the test has failed.\n-     * (This is JCK-like exit codes convention.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit code.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network005.java","additions":0,"deletions":635,"binary":false,"changes":635,"status":"deleted"},{"patch":"@@ -1,916 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network006.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick, quarantine]\n- * VM testbase comments: 8185072\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test makes huge number of data transfers between 2 Java virtual\n- *     machines using the TCP\/IP protocol, and checks if those data are transfered\n- *     correctly. Both client and server VMs run on the same local computer and\n- *     attach TCP\/IP sockets to the local host, or to the loopback domain\n- *     ``localhost'' (having IP address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a data parcel to server, and server\n- *     reads that parcel and checks if it is same as expected (byte-to-byte equality\n- *     is desired). Then server passes (some other) parcel to the client, and client\n- *     reads and verifies those bytes. This ping-pong game is repeated 128 times; and\n- *     after that each pair of sockets checks if there are no extra bytes accudentally\n- *     passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel length\n- *     is 128 bytes. So totally, each pair of sockets passes ~16Kb of data to each other,\n- *     and thus ~32Kb of data are transfered by each sockets pair. Totally, ~4Mb of data\n- *     are transfered by all client\/server pairs.\n- * COMMENTS\n- *     Test was fixed:\n- *     added WAITTIME parameter defined timeout for TCP\/IP sockets in minutes\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @build nsk.stress.network.network006\n- * @run main\/othervm PropertyResolvingWrapper\n- *      nsk.stress.network.network006\n- *      \"${test.jdk}\/bin\/java ${test.vm.opts} ${test.java.opts}\" 5\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test makes huge number of data transfers between 2 Java virtual\n- * machines using the TCP\/IP protocol, and checks if those data are transfered\n- * correctly. Both client and server VMs run on the same local computer and\n- * attach TCP\/IP sockets to the local host, or to the loopback domain\n- * ``<code>localhost<\/code>'' (having IP address <code>127.0.0.1<\/code>).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a data parcel to server, and server\n- * reads that parcel and checks if it is same as expected (byte-to-byte equality\n- * is desired). Then server passes (some other) parcel to the client, and client\n- * reads and verifies those bytes. This ping-pong game is repeated 128 times; and\n- * after that each pair of sockets checks if there are no extra bytes accudentally\n- * passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel length\n- * is 128 bytes. So totally, each pair of sockets passes ~16Kb of data to each other,\n- * and thus ~32Kb of data are transfered by each sockets pair. Totally, ~4Mb of data\n- * are transfered by all client\/server pairs.\n- *\/\n-public class network006 {\n-    \/**\n-     * Timeout for TCP\/IP sockets (currently set to 1 min).\n-     *\/\n-    private static int SO_TIMEOUT;\/\/ = 2*60*1000;\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * The test used to fail with connection reset by peer set to 50.\n-     * (and once in a three if it was set to 10).\n-     * So now we set it to MAX_CONNECTIONS (128).\n-     *\/\n-    private final static int BACKLOG_QUEUE_LENGTH = MAX_CONNECTIONS;\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private final static int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private final static int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-\n-        InetAddress address;\n-        ServerSocket serverSocket;\n-        try {\n-            address = InetAddress.getLocalHost();\n-            int anyPort = 0;\n-            int defaultBacklog = BACKLOG_QUEUE_LENGTH;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException ioe) {\n-            throw new Error(\"FATAL error while loading the test: \" + ioe);\n-        }\n-        display(serverSocket.toString());\n-\n-        Socket server[] = new Socket[CONNECTIONS_TO_TRY];\n-        Socket client[] = new Socket[CONNECTIONS_TO_TRY];\n-\n-        int i, port = serverSocket.getLocalPort();\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                client[i] = new Socket(address, port);\n-                display(\">Open: client[\" + i + \"] = \" + client[i]);\n-                server[i] = serverSocket.accept();\n-                display(\">Open: server[\" + i + \"] = \" + server[i]);\n-            } catch (IOException ioe) {\n-                display(\">OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"> Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\">Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                server[j].close();\n-                client[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\">OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            complain(\"------------------------- CAUTION: -------------------\");\n-            complain(\"While checking the OS limitations, the test found that\");\n-            complain(\"only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            complain(\"simultaneously. However, possibility to open at least\");\n-            complain(\"\" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            complain(\"\");\n-            complain(\"So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            complain(\"safe to be open simultaneously.\");\n-            complain(\"------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test. After <code>run(args[],out)<\/code> stops,\n-     * follow JDK-like convention for exit codes. I.e.: stop with\n-     * exit status 95 if the test has passed, or with status 97 if\n-     * the test has failed.\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * Parse command-line parameters stored into <code>args[]<\/code> array,\n-     * then perform the test. I.e.: start the server thread at the same VM\n-     * this method runs, then start the other client VM, and verify data\n-     * transfer through TCP\/IP connection between those different virtual\n-     * machines.\n-     * <p>\n-     * <p>There should be 2 or 3 command-line parameters:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network006 <i>java_command<\/i>\n-     * [<i>IP-address<\/i> | <i>host_name<\/i> | localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>java_command<\/i><\/code> - how to start java,\n-     * e.g.: ``<code>c:\\jdk1.3\\bin\\java -classic<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>waittime<\/code> - timeout for TCP\/IP sockets in minutes\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <p>\n-     * <p>Usually, <code><i>java_command<\/i><\/code> should point to the same\n-     * Java machine just executing this test. However, every compatible Java 2\n-     * implementation is appropriate.\n-     * <p>\n-     * <p>If optional parameter is ommited, the test invokes the method\n-     * <code>InetAddress.getLocalHost()<\/code> to get the domain name and\n-     * IP-address of the local computer.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network006.out = out;\n-\n-        \/\/\n-        \/\/ Get the Internet address of the local machine.\n-        \/\/\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 2:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 3:\n-                    address = InetAddress.getByName(args[2]);\n-                    break;\n-                default:\n-                    complain(\"Illegal arguments number; execute:\");\n-                    complain(\"    java \" + network006.class.getName() + \" $JAVA_COMMAND \" +\n-                            \"[$IP_ADDRESS | $HOST_NAME | localhost]\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            complain(exception.toString());\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Detect if it is safe to open MAX_CONNETIONS simultaneously:\n-        \/\/\n-        final int CONNECTIONS = detectOSLimitation();\n-\n-        \/\/\n-        \/\/ Assign ServerSocket, and start client VM which should open\n-        \/\/ the prescribed number of CONNECTIONS to that ServerSocket.\n-        \/\/\n-\n-        ServerSocket serverSocket;\n-        try {\n-            final int anyPort = 0;\n-            final int defaultBacklog = BACKLOG_QUEUE_LENGTH;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException exception) {\n-            complain(\"Cannot assign a ServerSocket on: \" + address);\n-            return 2;\n-        }\n-\n-        \/\/\n-        \/\/ Start the client process on different VM.\n-        \/\/\n-\n-        String IPAddress = address.getHostAddress();\n-        int localPort = serverSocket.getLocalPort();\n-        String arguments = \" \" + CONNECTIONS + \" \" + IPAddress + \" \" + localPort;\n-        \/\/String command = args[0] + \" \" + network006.class.getName() + \"$Client \" + arguments;\n-        String command = args[0] + \" \" + Client.class.getName() + \" \" + arguments;\n-        try {\n-            SO_TIMEOUT = Integer.parseInt(args[1]) * 60 * 1000;\n-        } catch (NumberFormatException e) {\n-            complain(\"Wrong timeout argument: \" + e);\n-            return 2;\n-        }\n-\n-        Runtime runtime = Runtime.getRuntime();\n-\n-        Process client = null;\n-        IORedirector redirectOut = null;\n-        IORedirector redirectErr = null;\n-\n-        try {\n-            \/\/ Start clients on different JVM:\n-            client = runtime.exec(command);\n-\n-            \/\/ Provide clients with access to stderr and stdout:\n-            InputStream clientOut = client.getInputStream();\n-            InputStream clientErr = client.getErrorStream();\n-            redirectOut = new IORedirector(clientOut, DEBUG_MODE ? out : null);\n-            redirectErr = new IORedirector(clientErr, out);\n-            redirectOut.start();\n-            redirectErr.start();\n-\n-        } catch (Exception exception) {\n-            complain(\"Failed to start client: \" + exception);\n-            return 2;\n-        }\n-        \/\/\n-        \/\/ Start the server threads (and let them establish connections):\n-        \/\/\n-\n-        Server server[] = new Server[CONNECTIONS];\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            server[i] = new Server(serverSocket);\n-            display(\"Server #\" + i + \": \" + server[i]);\n-            server[i].start();\n-        }\n-\n-        \/\/\n-        \/\/ Wait for the servers and the clients:\n-        \/\/\n-\n-        boolean testFailed = false;\n-\n-        try {\n-            client.waitFor();\n-            int clientStatus = client.exitValue();\n-            display(\"Client VM exitCode=\" + clientStatus);\n-\n-            \/\/ Let I\/O redirectors to flush:\n-            if (redirectOut.isAlive())\n-                redirectOut.join();\n-            if (redirectErr.isAlive())\n-                redirectErr.join();\n-\n-            \/\/ If client has crashed, also terminate the server (to avoid hangup).\n-            if (clientStatus != 95) {\n-                complain(\"Client VM has crashed: exit status=\" + clientStatus);\n-                testFailed = true;\n-            }\n-\n-            \/\/ Client has finished OK; wait for the server.\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Server: waiting for #\" + i);\n-                if (server[i].isAlive()) {\n-                    display(\"Server #\" + i + \": (joining...)\" + server[i]);\n-                    server[i].join();\n-                }\n-                if (server[i].exception != null) {\n-                    if (server[i].message != null)\n-                        complain(\"Server #\" + i + \"(finished): with message:\" + server[i].message);\n-\n-                    complain(\"Server #\" + i + \"(finished): \" + server[i].exception);\n-                    server[i].exception.printStackTrace(out);\n-                    out.flush();\n-\/\/                    complain(\"Server #\"+i+\": \"+server[i].exception.getStackTrace());\n-                    testFailed = true;\n-                }\n-            }\n-\n-        } catch (Exception exception) {\n-            complain(\"Test interrupted: \" + exception);\n-            testFailed = true;\n-        }\n-\n-        if (testFailed)\n-            complain(\"Test failed.\");\n-        else\n-            display(\"Test passed.\");\n-        return testFailed ? 2 : 0;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Log stream for error messages and\/or (optional) execution trace.\n-     *\/\n-    private static PrintStream out;\n-\n-    \/**\n-     * Print error message.\n-     *\/\n-    private static synchronized void complain(Object message) {\n-        out.println(\"# \" + message);\n-        out.flush();\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va?\n-     *\/\n-    private static synchronized void display(Object report) {\n-        if (DEBUG_MODE)\n-            out.println(report.toString());\n-        out.flush(); \/\/todo shouldn't this be inside if??\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Server thread should reply to data parcels sent by Client VM.\n-     *\/\n-    private static class Server extends Thread {\n-        \/**\n-         * The socket is assigned at the Server instantiation.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * The socket is assigned at the Server runtime.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Display the server socket.\n-         *\/\n-        public String toString() {\n-\n-            return \"ServerSocket: \" + serverSocket.toString();\n-\/\/                    + \" socket: \" + socket.toString();\n-        }\n-\n-        \/**\n-         * Which port is this socket listening?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port. \/\/ lidsten to??\n-         *\/\n-        public Server(ServerSocket serverSocket) {\n-            this.serverSocket = serverSocket;\n-        }\n-\n-        \/**\n-         * Exception just arisen while the server was working,\n-         * or <code>null<\/code> if it was OK with the server.\n-         *\/\n-        Exception exception = null;\n-        String message = null;\n-\n-        \/**\n-         * Accept connection, then reply to client's parcels.\n-         *\/\n-        public void run() {\n-            try {\n-                socket = serverSocket.accept();\n-                socket.setSoTimeout(SO_TIMEOUT);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    message = \"reading parcel number \" + i;\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Server thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(  \/\/received??\n-                                \"server has read unexpected parcel\");\n-                    }\n-                    message = \"sending parcel number \" + i;\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Client VM should send data parcels to Server VM and\n-     * recieve and verify the server's replies.\n-     *\/\n-    private static class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-        String message = null;\n-\n-\n-        public static java.io.PrintStream complainStream = System.out;\n-        public static java.io.PrintStream displayStream = System.err;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-            socket.setSoTimeout(SO_TIMEOUT);\n-        }\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return socket.getPort();\n-        }\n-\n-        \/**\n-         * Establish connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-                \/\/ suggested by Oleg -- to avoid race conditions\n-               \/* try{\n-                    Thread.sleep(500);\n-                }\n-                catch (java.lang.InterruptedException e)\n-                {\n-                }*\/\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    message = \"sending parcel number: \" + i;\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    message = \"reading parcel number: \" + i;\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Client thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-        \/**\n-         * Establish lots of connections to server socket, attack servers with\n-         * huge data parcels, and check if they reply correctly. The number of\n-         * connections to try, the address and port number for the server socket\n-         * are passed through <code>args[]<\/code>, like:\n-         * <pre>\n-         *    java network006$Client connections_to_try address port\n-         * <\/pre>\n-         *\/\n-        public static void main(String args[]) {\n-            if (DEBUG_MODE) {\n-                try {\n-                    String filename = \"Client\" + ((args.length == 3) ? args[2] : \"new\");\n-                    displayStream = new PrintStream(filename + \".out\");\n-                    complainStream = new PrintStream(filename + \".err\");\n-                } catch (FileNotFoundException exception) {\n-                    complain(exception);\n-                }\n-\n-            }\n-\n-            if (args.length != 3) {\n-                complain(\"Client expects 3 paramenets:\");\n-                complain(\"    java \" + Client.class.getName() + \" connections_to_try address port\");\n-                exit(1); \/\/ FAILED\n-            }\n-\n-            int CONNECTIONS = Integer.parseInt(args[0]);\n-            display(\"Client VM: will try \" + CONNECTIONS + \" connections.\");\n-            InetAddress address;\n-            try {\n-                address = InetAddress.getByName(args[1]);\n-            } catch (UnknownHostException exception) {\n-                address = null;\n-                complain(\"Client: cannot find host: \\\"\" + args[1] + \"\\\"\");\n-                exit(4);\n-            }\n-            display(\"Client: host to contact: \" + address);\n-            int port = Integer.parseInt(args[2]);\n-            display(\"Client: port to contact: \" + port);\n-\n-            \/\/\n-            \/\/ Establish connections, and start client processes:\n-            \/\/\n-\n-            Client client[] = new Client[CONNECTIONS];\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                try {\n-                    client[i] = new Client(address, port);\n-                    display(\"Client #\" + i + \": \" + client[i]);\n-\n-                } catch (IOException ioe) {\n-                    complain(\"Client #\" + i + \"(creation): \" + ioe);\n-                    ioe.printStackTrace(complainStream);\n-                    complainStream.flush();\n-\/\/                    complain(\"Client #\" + i + \"(creation): \" + ioe.getStackTrace());\n-                    exit(3);\n-                }\n-\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                client[i].start();\n-\n-            \/\/\n-            \/\/ Wait until testing is not finished:\n-            \/\/\n-\n-            int status = 0;\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Client: waiting for #\" + i);\n-                if (client[i].isAlive()) {\n-                    display(\"Client #\" + i + \": (joining...)\" + client[i]);\n-\n-                    try {\n-                        client[i].join();\n-                    } catch (InterruptedException ie) {\n-                        complain(\"Client #\" + i + \": \" + ie);\n-                        status = 3;\n-                    }\n-                }\n-                if (client[i].exception != null) {\n-                    if (client[i].message != null)\n-                        complain(\"Client #\" + i + \"(finished) with message: \" + client[i].message);\n-                    complain(\"Client #\" + i + \"(finished): \" + client[i].exception);\n-                    client[i].exception.printStackTrace(complainStream);\n-                    complainStream.flush();\n-                    if (status == 0)\n-                        status = 2;\n-                }\n-            }\n-\n-            exit(status);\n-        }\n-\n-        \/**\n-         * Print error message.\n-         *\/\n-        private static synchronized void complain(Object message) {\n-            complainStream.println(\"# \" + message);\n-            complainStream.flush();\n-        }\n-\n-        \/**\n-         * Display execution trace.\n-         *\/\n-        private static synchronized void display(Object message) {\n-            if (!DEBUG_MODE)\n-                return;\n-            displayStream.println(message.toString());\n-            displayStream.flush();\n-        }\n-\n-        \/**\n-         * Exit with JCK-like status.\n-         *\/\n-        private static void exit(int exitCode) {\n-            int status = exitCode + 95;\n-\/\/          display(\"Client: exiting with code=\" + status);\n-            System.exit(status);\n-        }\n-    }\n-\n-    \/**\n-     * Two of such threads should redirect <code>out<\/code> and <code>err<\/code>\n-     * streams of client VM.\n-     *\/\n-    private static class IORedirector extends Thread {\n-        \/**\n-         * Source stream.\n-         *\/\n-        InputStream in;\n-        \/**\n-         * Destination stream.\n-         *\/\n-        OutputStream out;\n-\n-        \/**\n-         * Redirect <code>in<\/code> to <code>out<\/code>.\n-         *\/\n-        public IORedirector(InputStream in, OutputStream out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-\n-        \/**\n-         * Read input stream until the EOF, and write everithing to output stream.\n-         * If output stream is assigned to <code>null<\/code>, do not print anything,\n-         * but read the input stream anywhere.\n-         *\/\n-        public void run() {\n-            try {\n-                for (; ; ) {\n-                    int symbol = in.read();\n-                    if (symbol < 0)\n-                        break; \/\/ EOF\n-                    if (out != null)\n-                        out.write(symbol);\n-                }\n-\n-                if (out != null)\n-                    out.flush();\n-\n-            } catch (Exception exception) {\n-                throw new TestFailure(\"IORedirector exception: \" + exception);\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * A data parcel to be sent\/recieved between Client VM and Server thread.\n-     * When data parcel is sent, first 4 bytes are transfered which encode the\n-     * <code>int<\/code> number equal to size of the parcel minus 1. I.e.: if\n-     * number of data bytes in the parcel's contents is <code>N<\/code>, then\n-     * the first 4 bytes encode the number <code>N-1<\/code>. After that, the\n-     * parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-    }\n-\n-    \/**\n-     * Server or Client may throw this exception to report the test failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network006.java","additions":0,"deletions":916,"binary":false,"changes":916,"status":"deleted"},{"patch":"@@ -24,0 +24,9 @@\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import static java.nio.file.StandardCopyOption.REPLACE_EXISTING;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n@@ -25,2 +34,5 @@\n- * Used by NonJavaNames.sh; needs to be run with a classpath including\n- * test\/java\/lang\/Class\/forName\/classes\n+ * @test\n+ * @bug 4952558\n+ * @library \/test\/lib\n+ * @run testng\/othervm NonJavaNames\n+ * @summary Verify names that aren't legal Java names are accepted by forName.\n@@ -37,1 +49,1 @@\n-     NonJavaNames.myInterface create(){\n+     NonJavaNames.myInterface create() {\n@@ -41,1 +53,1 @@\n-             public Baz2(){}\n+             public Baz2() { }\n@@ -47,2 +59,16 @@\n-    public static void main(String[] args) throws Exception {\n-        NonJavaNames.Baz bz = new NonJavaNames.Baz();\n+    private static final String SRC_DIR = System.getProperty(\"test.src\");\n+    private static final Path TEST_SRC = Path.of(SRC_DIR,  \"classes\");\n+    private static final Path TEST_CLASSES = Path.of(System.getProperty(\"test.classes\", \".\"));\n+\n+    @BeforeClass\n+    public void createInvalidNameClasses() throws IOException {\n+        Path hyphenPath = TEST_SRC.resolve(\"hyphen.class\");\n+        Path commaPath = TEST_SRC.resolve(\"comma.class\");\n+        Path periodPath = TEST_SRC.resolve(\"period.class\");\n+        Path leftsquarePath = TEST_SRC.resolve(\"left-square.class\");\n+        Path rightsquarePath = TEST_SRC.resolve(\"right-square.class\");\n+        Path plusPath = TEST_SRC.resolve(\"plus.class\");\n+        Path semicolonPath = TEST_SRC.resolve(\"semicolon.class\");\n+        Path zeroPath = TEST_SRC.resolve(\"0.class\");\n+        Path threePath = TEST_SRC.resolve(\"3.class\");\n+        Path zadePath = TEST_SRC.resolve(\"Z.class\");\n@@ -50,0 +76,26 @@\n+        Path dhyphenPath = TEST_CLASSES.resolve(\"-.class\");\n+        Path dcommaPath = TEST_CLASSES.resolve(\",.class\");\n+        Path dperiodPath = TEST_CLASSES.resolve(\"..class\");\n+        Path dleftsquarePath = TEST_CLASSES.resolve(\"[.class\");\n+        Path drightsquarePath = TEST_CLASSES.resolve(\"].class\");\n+        Path dplusPath = TEST_CLASSES.resolve(\"+.class\");\n+        Path dsemicolonPath = TEST_CLASSES.resolve(\";.class\");\n+        Path dzeroPath = TEST_CLASSES.resolve(\"0.class\");\n+        Path dthreePath = TEST_CLASSES.resolve(\"3.class\");\n+        Path dzadePath = TEST_CLASSES.resolve(\"Z.class\");\n+\n+        Files.copy(hyphenPath, dhyphenPath, REPLACE_EXISTING);\n+        Files.copy(commaPath, dcommaPath, REPLACE_EXISTING);\n+        Files.copy(periodPath, dperiodPath, REPLACE_EXISTING);\n+        Files.copy(leftsquarePath, dleftsquarePath, REPLACE_EXISTING);\n+        Files.copy(rightsquarePath, drightsquarePath, REPLACE_EXISTING);\n+        Files.copy(plusPath, dplusPath, REPLACE_EXISTING);\n+        Files.copy(semicolonPath, dsemicolonPath, REPLACE_EXISTING);\n+        Files.copy(zeroPath, dzeroPath, REPLACE_EXISTING);\n+        Files.copy(threePath, dthreePath, REPLACE_EXISTING);\n+        Files.copy(zadePath, dzadePath, REPLACE_EXISTING);\n+    }\n+\n+    @Test\n+    public void testForNameReturnsSameClass() throws ClassNotFoundException {\n+        NonJavaNames.Baz bz = new NonJavaNames.Baz();\n@@ -64,0 +116,1 @@\n+    }\n@@ -65,12 +118,5 @@\n-        String goodNonJavaClassNames []  = {\n-            \",\",\n-            \"+\",\n-            \"-\",\n-            \"0\",\n-            \"3\",\n-            \/\/ \":\", These names won't work under windows.\n-            \/\/ \"<\",\n-            \/\/ \">\",\n-            \"Z\",\n-            \"]\"\n-        };\n+    @Test(dataProvider = \"goodNonJavaClassNames\")\n+    public void testGoodNonJavaClassNames(String name) throws ClassNotFoundException {\n+        System.out.println(\"Testing good class name ``\" + name + \"''\");\n+        Class.forName(name);\n+    }\n@@ -78,3 +124,8 @@\n-        for(String s : goodNonJavaClassNames) {\n-            System.out.println(\"Testing good class name ``\" + s + \"''\");\n-            Class.forName(s);\n+    @Test(dataProvider = \"badNonJavaClassNames\")\n+    public void testBadNonJavaClassNames(String name) {\n+        System.out.println(\"Testing bad class name ``\" + name + \"''\");\n+        try {\n+            Class.forName(name);\n+        } catch (ClassNotFoundException e) {\n+            \/\/ Expected behavior\n+            return;\n@@ -82,0 +133,2 @@\n+        throw new RuntimeException(\"Bad class name ``\" + name + \"'' accepted.\");\n+    }\n@@ -83,4 +136,13 @@\n-        String badNonJavaClassNames []  = {\n-            \";\",\n-            \"[\",\n-            \".\"\n+    @DataProvider(name = \"goodNonJavaClassNames\")\n+    Object[][] getGoodNonJavaClassNames() {\n+        return new Object[][] {\n+                {\",\"},\n+                {\"+\"},\n+                {\"-\"},\n+                {\"0\"},\n+                {\"3\"},\n+                \/\/ \":\", These names won't work under windows.\n+                \/\/ \"<\",\n+                \/\/ \">\",\n+                {\"Z\"},\n+                {\"]\"}\n@@ -88,0 +150,1 @@\n+    }\n@@ -89,10 +152,7 @@\n-        for(String s : badNonJavaClassNames) {\n-            System.out.println(\"Testing bad class name ``\" + s + \"''\");\n-            try {\n-                Class.forName(s);\n-            } catch (Exception e) {\n-                \/\/ Expected behavior\n-                continue;\n-            }\n-            throw new RuntimeException(\"Bad class name ``\" + s + \"'' accepted.\");\n-        }\n+    @DataProvider(name = \"badNonJavaClassNames\")\n+    Object[][] getBadNonJavaClassNames() {\n+        return new Object[][] {\n+                {\";\"},\n+                {\"[\"},\n+                {\".\"}\n+        };\n","filename":"test\/jdk\/java\/lang\/Class\/forName\/NonJavaNames.java","additions":95,"deletions":35,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -1,108 +0,0 @@\n-#\n-# Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# @test\n-# @bug 4952558\n-# @summary Verify names that aren't legal Java names are accepted by forName.\n-# @author Joseph D. Darcy\n-# @compile NonJavaNames.java\n-# @run shell NonJavaNames.sh\n-\n-# This test uses hand-generated class files stored in the .\/classes\n-# directory.  After the renaming done below, those class files have\n-# single character names that are legal class names under in the class\n-# file but *not* legal Java language identifiers; e.g. \"3\" and \"+\".\n-# First, Z.java is compiled to Z.class.  Next, to create a test class\n-# file, the appropriate name structures within the class files are\n-# updated, as is the \"Hello world\" string the class's main method\n-# prints out.\n-\n-# Verify directory context variables are set\n-if [ \"${TESTJAVA}\" = \"\" ]\n-then\n-  echo \"TESTJAVA not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-if [ \"${TESTSRC}\" = \"\" ]\n-then\n-  echo \"TESTSRC not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-if [ \"${TESTCLASSES}\" = \"\" ]\n-then\n-  echo \"TESTCLASSES not set.  Test cannot execute.  Failed.\"\n-  exit 1\n-fi\n-\n-# All preconditions are met; run the tests\n-\n-OS=`uname -s`;\n-# Set classpath separator\n-case \"$OS\" in\n-        Windows* | CYGWIN* )\n-\tSEP=\";\"\n-        ;;\n-\n-\t* )\n-\tSEP=\":\"\n-esac\n-\n-# Copy \"hyphen.class\" to \"-.class\"\n-\n-COPYHYPHEN=\"cp ${TESTSRC}\/classes\/hyphen.class ${TESTCLASSES}\/-.class\"\n-$COPYHYPHEN\n-\n-COPYCOMMA=\"cp ${TESTSRC}\/classes\/comma.class ${TESTCLASSES}\/,.class\"\n-$COPYCOMMA\n-\n-COPYPERIOD=\"cp ${TESTSRC}\/classes\/period.class ${TESTCLASSES}\/..class\"\n-$COPYPERIOD\n-\n-COPYLEFTSQUARE=\"cp ${TESTSRC}\/classes\/left-square.class ${TESTCLASSES}\/[.class\"\n-$COPYLEFTSQUARE\n-\n-COPYRIGHTSQUARE=\"cp ${TESTSRC}\/classes\/right-square.class ${TESTCLASSES}\/].class\"\n-$COPYRIGHTSQUARE\n-\n-COPYPLUS=\"cp ${TESTSRC}\/classes\/plus.class ${TESTCLASSES}\/+.class\"\n-$COPYPLUS\n-\n-COPYSEMICOLON=\"cp ${TESTSRC}\/classes\/semicolon.class ${TESTCLASSES}\/;.class\"\n-$COPYSEMICOLON\n-\n-JAVA=\"$TESTJAVA\/bin\/java ${TESTVMOPTS} -classpath ${TESTSRC}\/classes${SEP}${TESTCLASSES}\"\n-\n-$JAVA NonJavaNames\n-RESULT=$?\n-\n-case \"$RESULT\" in\n-        0 )\n-        exit 0;\n-        ;;\n-\n-        * )\n-        exit 1\n-esac\n-\n","filename":"test\/jdk\/java\/lang\/Class\/forName\/NonJavaNames.sh","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -27,5 +27,3 @@\n- *\n- * @run shell make_src.sh\n- * @run shell build.sh\n- * @run main\/othervm -esa -ea EnclosingClassTest\n- *\n+ * @library \/test\/lib\n+ * @modules jdk.compiler\n+ * @run testng\/othervm EnclosingClassTest\n@@ -36,0 +34,17 @@\n+import java.io.BufferedReader;\n+import java.io.FileReader;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.InvocationTargetException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+import common.TestMe;\n+import jdk.test.lib.compiler.CompilerUtils;\n+import jdk.test.lib.util.FileUtils;\n+import org.testng.Assert;\n+import org.testng.annotations.BeforeClass;\n+import org.testng.annotations.Test;\n+\n@@ -62,5 +77,0 @@\n-import java.util.List;\n-import java.util.LinkedList;\n-import java.lang.reflect.Field;\n-import common.TestMe;\n-\n@@ -68,2 +78,64 @@\n-    static void info(Class<?> c, Class<?> encClass, String desc) {\n-        if (!\"\".equals(desc))\n+    private static final String SRC_DIR = System.getProperty(\"test.src\");\n+    private static final Path ENCLOSING_CLASS_SRC = Path.of(SRC_DIR, \"EnclosingClass.java\");\n+    private static final String GEN_SRC_DIR = \"gensrc\";\n+\n+    @BeforeClass\n+    public void createEnclosingClasses() throws IOException {\n+        Path pkg1Dir = Path.of(GEN_SRC_DIR, \"pkg1\");\n+        Path pkg2Dir = Path.of(GEN_SRC_DIR, \"pkg1\", \"pkg2\");\n+        Path pkg1File = pkg1Dir.resolve(\"EnclosingClass.java\");\n+        Path pkg2File = pkg2Dir.resolve(\"EnclosingClass.java\");\n+\n+        if (!Files.notExists(pkg1Dir)) {\n+            FileUtils.deleteFileTreeWithRetry(pkg1Dir);\n+        }\n+        Files.createDirectories(pkg2Dir);\n+        createAndWriteEnclosingClasses(ENCLOSING_CLASS_SRC, pkg1File, \"pkg1\");\n+        createAndWriteEnclosingClasses(ENCLOSING_CLASS_SRC, pkg2File, \"pkg1.pkg2\");\n+\n+        Assert.assertTrue(CompilerUtils.compile(ENCLOSING_CLASS_SRC, Path.of(System.getProperty(\"test.classes\")),\n+                \"--source-path\", SRC_DIR));\n+        Assert.assertTrue(CompilerUtils.compile(pkg1File, Path.of(System.getProperty(\"test.classes\")),\n+                \"-classpath\", System.getProperty(\"test.class.path\")));\n+        Assert.assertTrue(CompilerUtils.compile(pkg2File, Path.of(System.getProperty(\"test.classes\")),\n+                        \"-classpath\", System.getProperty(\"test.class.path\")));\n+    }\n+\n+    @Test\n+    public void testEnclosingClasses() throws ClassNotFoundException, NoSuchMethodException, IllegalAccessException,\n+            InvocationTargetException, InstantiationException {\n+        test(Class.forName(\"EnclosingClass\").getDeclaredConstructor().newInstance());\n+    }\n+\n+    @Test\n+    public void testEnclosingClassesInPackage() throws ClassNotFoundException, NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException, InstantiationException {\n+        test(Class.forName(\"pkg1.EnclosingClass\").getDeclaredConstructor().newInstance());\n+    }\n+\n+    @Test\n+    public void testEnclosingClassesInNestedPackage() throws ClassNotFoundException, NoSuchMethodException,\n+            IllegalAccessException, InvocationTargetException, InstantiationException {\n+        test(Class.forName(\"pkg1.pkg2.EnclosingClass\").getDeclaredConstructor().newInstance());\n+    }\n+\n+    private void createAndWriteEnclosingClasses(Path source, Path target, String packageName) throws IOException {\n+        String className = packageName + \".EnclosingClass\";\n+        try (BufferedReader br = new BufferedReader(new FileReader(source.toFile()));\n+        PrintWriter bw = new PrintWriter(new FileWriter(target.toFile()))) {\n+            String line;\n+            while ((line = br.readLine()) != null) {\n+                if (line.contains(\"canonical=\\\"EnclosingClass\")) {\n+                    line = line.replaceAll(\"canonical=\\\"EnclosingClass\", \"canonical=\\\"\" + className);\n+                } else if (line.contains(\"\\\"class EnclosingClass\")) {\n+                    line = line.replaceAll(\"\\\"class EnclosingClass\", \"\\\"class \" + className);\n+                } else if (line.contains(\"\/\/package\")) {\n+                    line = line.replaceAll(\"\/\/package\", \"package \" + packageName + \";\");\n+                }\n+                bw.println(line);\n+            }\n+        }\n+    }\n+\n+    private void info(Class<?> c, Class<?> encClass, String desc) {\n+        if (!\"\".equals(desc)) {\n@@ -71,0 +143,1 @@\n+        }\n@@ -79,2 +152,2 @@\n-    static void match(String actual, String expected) {\n-        assert((actual == null && expected == null) || actual.equals(expected));\n+    private void match(String actual, String expected) {\n+        Assert.assertTrue((actual == null && expected == null) || actual.equals(expected));\n@@ -86,4 +159,4 @@\n-    static void check(Class<?> c, Class<?> enc,\n-                      String encName, String encNameExpected,\n-                      String simpleName, String simpleNameExpected,\n-                      String canonicalName, String canonicalNameExpected) {\n+    private void check(Class<?> c, Class<?> enc,\n+                       String encName, String encNameExpected,\n+                       String simpleName, String simpleNameExpected,\n+                       String canonicalName, String canonicalNameExpected) {\n@@ -95,1 +168,1 @@\n-    static void testClass(Class<?> c, TestMe annotation, Field f) {\n+    private void testClass(Class<?> c, TestMe annotation, Field f) {\n@@ -117,1 +190,1 @@\n-    static void test(Object tests) {\n+    private void test(Object tests) {\n@@ -135,5 +208,0 @@\n-    public static void main(String[] args) {\n-        test(new EnclosingClass());\n-        test(new pkg1.EnclosingClass());\n-        test(new pkg1.pkg2.EnclosingClass());\n-    }\n@@ -141,0 +209,1 @@\n+\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingClass\/EnclosingClassTest.java","additions":95,"deletions":26,"binary":false,"changes":121,"status":"modified"},{"patch":"@@ -1,42 +0,0 @@\n-#\n-# Copyright (c) 2004, 2013, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# -*- shell-script -*-\n-#\n-# @summary Check getEnclosingClass and other methods\n-# @author Peter von der Ahé\n-\n-OS=`uname -s`;\n-case \"${OS}\" in\n-        Windows* | CYGWIN* )\n-                SEP=\";\"\n-        ;;\n-\n-        * )\n-        SEP=\":\"\n-        ;;\n-esac\n-\n-JAVAC=${COMPILEJAVA}\/bin\/javac\n-${JAVAC} ${TESTJAVACOPTS} ${TESTTOOLVMOPTS} -d ${TESTCLASSES} -sourcepath ${TESTSRC}${SEP}. \\\n-    ${TESTSRC}\/EnclosingClassTest.java\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingClass\/build.sh","additions":0,"deletions":42,"binary":false,"changes":42,"status":"deleted"},{"patch":"@@ -1,40 +0,0 @@\n-#\n-# Copyright (c) 2004, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-# -*- shell-script -*-\n-# @summary Check getEnclosingClass and other methods\n-# @author Peter von der Ahé\n-\n-rm -rf   pkg1\n-mkdir    pkg1\n-mkdir -p pkg1\/pkg2\n-\n-sed '\n-s\/canonical=\"EnclosingClass\/canonical=\"pkg1.EnclosingClass\/g;\n-s\/\"class EnclosingClass\/\"class pkg1.EnclosingClass\/g;\n-s\/\\\/\\\/package\/package pkg1;\/g' < ${TESTSRC}\/EnclosingClass.java > pkg1\/EnclosingClass.java\n-\n-sed '\n-s\/canonical=\"EnclosingClass\/canonical=\"pkg1.pkg2.EnclosingClass\/g;\n-s\/\"class EnclosingClass\/\"class pkg1.pkg2.EnclosingClass\/g;\n-s\/\\\/\\\/package\/package pkg1.pkg2;\/g' < ${TESTSRC}\/EnclosingClass.java > pkg1\/pkg2\/EnclosingClass.java\n","filename":"test\/jdk\/java\/lang\/Class\/getEnclosingClass\/make_src.sh","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @key randomness\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.RandomFactory\n@@ -37,0 +40,1 @@\n+import jdk.test.lib.RandomFactory;\n@@ -44,0 +48,2 @@\n+        Random r = RandomFactory.getRandom();\n+\n@@ -53,1 +59,1 @@\n-            double[] rand = new Random().doubles(1_000_000)\n+            double[] rand = r.doubles(1_000_000)\n@@ -88,1 +94,1 @@\n-        Assert.assertTrue(badParallelStreamError > jdkParallelStreamError);\n+        Assert.assertTrue(badParallelStreamError >= jdkParallelStreamError);\n@@ -100,1 +106,1 @@\n-    \/\/ from OpenJDK8 Collectors, unmodified\n+    \/\/ from OpenJDK 18 Collectors, unmodified\n@@ -110,1 +116,1 @@\n-    \/\/ from OpenJDK8 Collectors, unmodified\n+    \/\/ from OpenJDK 18 Collectors, unmodified\n@@ -112,1 +118,2 @@\n-        double tmp = summands[0] + summands[1];\n+        \/\/ Final sum with better error bounds subtract second summand as it is negated\n+        double tmp = summands[0] - summands[1];\n","filename":"test\/jdk\/java\/util\/DoubleStreamSums\/CompensatedSums.java","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,127 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @key cgroups\n+ * @summary Test JDK Metrics class when running inside a docker container with limited pids\n+ * @bug 8266490\n+ * @requires docker.support\n+ * @library \/test\/lib\n+ * @build TestPidsLimit\n+ * @run driver TestPidsLimit\n+ *\/\n+import java.util.ArrayList;\n+import java.util.List;\n+import jdk.test.lib.containers.docker.Common;\n+import jdk.test.lib.containers.docker.DockerRunOptions;\n+import jdk.test.lib.containers.docker.DockerTestUtils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.Asserts;\n+\n+public class TestPidsLimit {\n+    private static final String imageName = Common.imageName(\"pids\");\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!DockerTestUtils.canTestDocker()) {\n+            return;\n+        }\n+\n+        DockerTestUtils.buildJdkDockerImage(imageName, \"Dockerfile-BasicTest\", \"jdk-docker\");\n+\n+        try {\n+            testPidsLimit(\"1000\");\n+            testPidsLimit(\"2000\");\n+            testPidsLimit(\"Unlimited\");\n+        } finally {\n+            if (!DockerTestUtils.RETAIN_IMAGE_AFTER_TEST) {\n+                DockerTestUtils.removeDockerImage(imageName);\n+            }\n+        }\n+    }\n+\n+    private static void checkResult(List<String> lines, String lineMarker, String expectedValue) {\n+        boolean lineMarkerFound = false;\n+\n+        for (String line : lines) {\n+            if (line.contains(\"WARNING: Your kernel does not support pids limit capabilities\")) {\n+                System.out.println(\"Docker pids limitation seems not to work, avoiding check\");\n+                return;\n+            }\n+\n+            if (line.contains(lineMarker)) {\n+                lineMarkerFound = true;\n+                String[] parts = line.split(\":\");\n+                System.out.println(\"DEBUG: line = \" + line);\n+                System.out.println(\"DEBUG: parts.length = \" + parts.length);\n+\n+                Asserts.assertEquals(parts.length, 2);\n+                String actual = parts[1].replaceAll(\"\\\\s\",\"\");\n+                \/\/ Unlimited pids leads on some setups not to \"max\" in the output, but to a high number\n+                if (expectedValue.equals(\"Unlimited\")) {\n+                    if (actual.equals(\"Unlimited\")) {\n+                        System.out.println(\"Found expected value for unlimited pids.\");\n+                    } else {\n+                        try {\n+                            int ai = Integer.parseInt(actual);\n+                            if (ai > 20000) {\n+                                System.out.println(\"Limit value \" + ai + \" got accepted as unlimited, log line was \" + line);\n+                            } else {\n+                                throw new RuntimeException(\"Limit value \" + ai + \" is not accepted as unlimited, log line was \" + line);\n+                            }\n+                        } catch (NumberFormatException ex) {\n+                            throw new RuntimeException(\"Could not convert \" + actual + \" to an integer, log line was \" + line);\n+                        }\n+                    }\n+                } else {\n+                    Asserts.assertEquals(actual, expectedValue);\n+                }\n+                break;\n+            }\n+        }\n+        Asserts.assertTrue(lineMarkerFound);\n+    }\n+\n+    private static void testPidsLimit(String pidsLimit) throws Exception {\n+        Common.logNewTestCase(\"testPidsLimit (limit: \" + pidsLimit + \")\");\n+        DockerRunOptions opts = Common.newOptsShowSettings(imageName);\n+        if (pidsLimit.equals(\"Unlimited\")) {\n+            opts.addDockerOpts(\"--pids-limit=-1\");\n+        } else {\n+            opts.addDockerOpts(\"--pids-limit=\"+pidsLimit);\n+        }\n+\n+        OutputAnalyzer out = DockerTestUtils.dockerRunJava(opts);\n+        out.shouldHaveExitValue(0);\n+        \/\/ some docker enviroments do not have the pids limit capabilities\n+        String sdr = out.getOutput();\n+        if (sdr.contains(\"WARNING: Your kernel does not support pids limit capabilities\")) {\n+            System.out.println(\"Docker pids limitation seems not to work, avoiding check\");\n+        } else {\n+            List<String> lines = new ArrayList<>();\n+            sdr.lines().forEach(s -> lines.add(s));\n+            checkResult(lines, \"Maximum Processes Limit: \", pidsLimit);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/internal\/platform\/docker\/TestPidsLimit.java","additions":127,"deletions":0,"binary":false,"changes":127,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -110,1 +110,1 @@\n-            TestLibrary.bomb(\"could not create registry\");\n+            TestLibrary.bomb(\"could not create registry\", e);\n","filename":"test\/jdk\/sun\/rmi\/runtime\/Log\/checkLogging\/CheckLogging.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,162 @@\n+\/*\n+ * Copyright (c) 2022, Huawei Technologies Co., Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8240903\n+ * @summary Test consistency of moduleHashes attribute between builds\n+ * @library \/test\/lib\n+ * @run testng HashesOrderTest\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+\n+import jdk.test.lib.compiler.ModuleInfoMaker;\n+\n+import org.testng.annotations.Test;\n+\n+import static org.testng.Assert.assertEquals;\n+\n+public class HashesOrderTest {\n+    private ToolProvider JMOD_TOOL = ToolProvider.findFirst(\"jmod\")\n+        .orElseThrow(() ->\n+            new RuntimeException(\"jmod tool not found\")\n+        );\n+\n+    \/\/ buffer size used for reading and writing\n+    private static final int BUFFER_SIZE = 8192;\n+\n+    private int NUM_MODULES = 64;\n+    private Path mods;\n+    private Path lib1;\n+    private Path lib2;\n+    private ModuleInfoMaker builder;\n+\n+    @Test\n+    public void test() throws Exception {\n+        mods = Path.of(\"mods\");\n+        lib1 = Path.of(\"lib1\");\n+        lib2 = Path.of(\"lib2\");\n+        builder = new ModuleInfoMaker(Path.of(\"src\"));\n+\n+        Files.createDirectories(mods);\n+        Files.createDirectories(lib1);\n+        Files.createDirectories(lib2);\n+\n+        makeModule(\"ma\");\n+        String moduleName;\n+        for (int i = 0; i < NUM_MODULES; i++) {\n+            moduleName = \"m\" + i + \"b\";\n+            makeModule(moduleName, \"ma\");\n+            makeJmod(moduleName, lib1);\n+            makeJmod(moduleName, lib2);\n+        }\n+        makeJmod(\"ma\", lib1, \"--module-path\", lib1.toString(),\n+                \"--hash-modules\", \".*\");\n+        Path jmod1 = lib1.resolve(\"ma.jmod\");\n+\n+        makeJmod(\"ma\", lib2, \"--module-path\", lib2.toString(),\n+                \"--hash-modules\", \".*\");\n+        Path jmod2 = lib2.resolve(\"ma.jmod\");\n+\n+        assertEquals(mismatch(jmod1, jmod2), -1);\n+    }\n+\n+    private void makeModule(String mn, String... deps)\n+        throws IOException\n+    {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"module \")\n+          .append(mn)\n+          .append(\" {\")\n+          .append(\"\\n\");\n+        Arrays.stream(deps)\n+              .forEach(req -> {\n+                  sb.append(\"    requires \");\n+                  sb.append(req)\n+                    .append(\";\\n\");\n+              });\n+        sb.append(\"}\\n\");\n+        builder.writeJavaFiles(mn, sb.toString());\n+        builder.compile(mn, mods);\n+    }\n+\n+    private void makeJmod(String moduleName, Path libName, String... options) {\n+        Path mclasses = mods.resolve(moduleName);\n+        Path outfile = libName.resolve(moduleName + \".jmod\");\n+        List<String> args = new ArrayList<>();\n+        args.add(\"create\");\n+        Collections.addAll(args, options);\n+        Collections.addAll(args, \"--class-path\", mclasses.toString(),\n+                           outfile.toString());\n+\n+        runJmod(args);\n+    }\n+\n+    private void runJmod(List<String> args) {\n+        runJmod(args.toArray(new String[args.size()]));\n+    }\n+\n+    private void runJmod(String... args) {\n+        int rc = JMOD_TOOL.run(System.out, System.out, args);\n+        System.out.println(\"jmod \" + Arrays.stream(args).collect(Collectors.joining(\" \")));\n+        if (rc != 0) {\n+            throw new AssertionError(\"jmod failed: rc = \" + rc);\n+        }\n+    }\n+\n+    private long mismatch(Path path, Path path2) throws IOException {\n+        if (Files.isSameFile(path, path2)) {\n+            return -1;\n+        }\n+        byte[] buffer1 = new byte[BUFFER_SIZE];\n+        byte[] buffer2 = new byte[BUFFER_SIZE];\n+        try (InputStream in1 = Files.newInputStream(path);\n+             InputStream in2 = Files.newInputStream(path2);) {\n+            long totalRead = 0;\n+            while (true) {\n+                int nRead1 = in1.readNBytes(buffer1, 0, BUFFER_SIZE);\n+                int nRead2 = in2.readNBytes(buffer2, 0, BUFFER_SIZE);\n+\n+                int i = Arrays.mismatch(buffer1, 0, nRead1, buffer2, 0, nRead2);\n+                if (i > -1) {\n+                    return totalRead + i;\n+                }\n+                if (nRead1 < BUFFER_SIZE) {\n+                    \/\/ we've reached the end of the files, but found no mismatch\n+                    return -1;\n+                }\n+                totalRead += nRead1;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/tools\/jmod\/hashes\/HashesOrderTest.java","additions":162,"deletions":0,"binary":false,"changes":162,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,0 +59,4 @@\n+    public static DockerRunOptions newOptsShowSettings(String imageNameAndTag) {\n+        return new DockerRunOptions(imageNameAndTag, \"\/jdk\/bin\/java\", \"-version\", \"-XshowSettings:system\");\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/Common.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}