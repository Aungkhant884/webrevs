{"files":[{"patch":"@@ -15123,1 +15123,1 @@\n-instruct string_indexofU_char(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+instruct string_indexof_char(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n@@ -15128,0 +15128,1 @@\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U);\n@@ -15131,1 +15132,1 @@\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$ch -> $result\" %}\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result\" %}\n@@ -15141,0 +15142,19 @@\n+instruct stringL_indexof_char(iRegP_R1 str1, iRegI_R2 cnt1, iRegI_R3 ch,\n+                              iRegI_R0 result, iRegINoSp tmp1, iRegINoSp tmp2,\n+                              iRegINoSp tmp3, rFlagsReg cr)\n+%{\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  predicate(((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L);\n+  effect(USE_KILL str1, USE_KILL cnt1, USE_KILL ch,\n+         TEMP tmp1, TEMP tmp2, TEMP tmp3, KILL cr);\n+\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result\" %}\n+\n+  ins_encode %{\n+    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register,\n+                           $result$$Register, $tmp1$$Register, $tmp2$$Register,\n+                           $tmp3$$Register);\n+  %}\n+  ins_pipe(pipe_class_memory);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":22,"deletions":2,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -4796,0 +4796,64 @@\n+void MacroAssembler::stringL_indexof_char(Register str1, Register cnt1,\n+                                          Register ch, Register result,\n+                                          Register tmp1, Register tmp2, Register tmp3)\n+{\n+  Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP, MATCH, NOMATCH, DONE;\n+  Register cnt1_neg = cnt1;\n+  Register ch1 = rscratch1;\n+  Register result_tmp = rscratch2;\n+\n+  cbz(cnt1, NOMATCH);\n+\n+  cmp(cnt1, (u1)8);\n+  br(LT, DO1_SHORT);\n+\n+  orr(ch, ch, ch, LSL, 8);\n+  orr(ch, ch, ch, LSL, 16);\n+  orr(ch, ch, ch, LSL, 32);\n+\n+  sub(cnt1, cnt1, 8);\n+  mov(result_tmp, cnt1);\n+  lea(str1, Address(str1, cnt1));\n+  sub(cnt1_neg, zr, cnt1);\n+\n+  mov(tmp3, 0x0101010101010101);\n+\n+  BIND(CH1_LOOP);\n+    ldr(ch1, Address(str1, cnt1_neg));\n+    eor(ch1, ch, ch1);\n+    sub(tmp1, ch1, tmp3);\n+    orr(tmp2, ch1, 0x7f7f7f7f7f7f7f7f);\n+    bics(tmp1, tmp1, tmp2);\n+    br(NE, HAS_ZERO);\n+    adds(cnt1_neg, cnt1_neg, 8);\n+    br(LT, CH1_LOOP);\n+\n+    cmp(cnt1_neg, (u1)8);\n+    mov(cnt1_neg, 0);\n+    br(LT, CH1_LOOP);\n+    b(NOMATCH);\n+\n+  BIND(HAS_ZERO);\n+    rev(tmp1, tmp1);\n+    clz(tmp1, tmp1);\n+    add(cnt1_neg, cnt1_neg, tmp1, LSR, 3);\n+    b(MATCH);\n+\n+  BIND(DO1_SHORT);\n+    mov(result_tmp, cnt1);\n+    lea(str1, Address(str1, cnt1));\n+    sub(cnt1_neg, zr, cnt1);\n+  BIND(DO1_LOOP);\n+    ldrb(ch1, Address(str1, cnt1_neg));\n+    cmp(ch, ch1);\n+    br(EQ, MATCH);\n+    adds(cnt1_neg, cnt1_neg, 1);\n+    br(LT, DO1_LOOP);\n+  BIND(NOMATCH);\n+    mov(result, -1);\n+    b(DONE);\n+  BIND(MATCH);\n+    add(result, result_tmp, cnt1_neg);\n+  BIND(DONE);\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1263,0 +1263,3 @@\n+  void stringL_indexof_char(Register str1, Register cnt1,\n+                            Register ch, Register result,\n+                            Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -6609,0 +6609,93 @@\n+void MacroAssembler::stringL_indexof_char(Register str1, Register cnt1, Register ch, Register result,\n+                                          XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp) {\n+  ShortBranchVerifier sbv(this);\n+  assert(UseSSE42Intrinsics, \"SSE4.2 intrinsics are required\");\n+\n+  int stride = 16;\n+\n+  Label FOUND_CHAR, SCAN_TO_CHAR_INIT, SCAN_TO_CHAR_LOOP,\n+        SCAN_TO_16_CHAR, SCAN_TO_16_CHAR_LOOP, SCAN_TO_32_CHAR_LOOP,\n+        RET_NOT_FOUND, SCAN_TO_16_CHAR_INIT,\n+        FOUND_SEQ_CHAR, DONE_LABEL;\n+\n+  movptr(result, str1);\n+  if (UseAVX >= 2) {\n+    cmpl(cnt1, stride);\n+    jcc(Assembler::less, SCAN_TO_CHAR_INIT);\n+    cmpl(cnt1, stride*2);\n+    jcc(Assembler::less, SCAN_TO_16_CHAR_INIT);\n+    movdl(vec1, ch);\n+    vpbroadcastb(vec1, vec1, Assembler::AVX_256bit);\n+    vpxor(vec2, vec2);\n+    movl(tmp, cnt1);\n+    andl(tmp, 0xFFFFFFE0);  \/\/vector count (in chars)\n+    andl(cnt1,0x0000001F);  \/\/tail count (in chars)\n+\n+    bind(SCAN_TO_32_CHAR_LOOP);\n+    vmovdqu(vec3, Address(result, 0));\n+    vpcmpeqb(vec3, vec3, vec1, Assembler::AVX_256bit);\n+    vptest(vec2, vec3);\n+    jcc(Assembler::carryClear, FOUND_CHAR);\n+    addptr(result, 32);\n+    subl(tmp, stride*2);\n+    jcc(Assembler::notZero, SCAN_TO_32_CHAR_LOOP);\n+    jmp(SCAN_TO_16_CHAR);\n+\n+    bind(SCAN_TO_16_CHAR_INIT);\n+    movdl(vec1, ch);\n+    pxor(vec2, vec2);\n+    pshufb(vec1, vec2);\n+  }\n+\n+  bind(SCAN_TO_16_CHAR);\n+  cmpl(cnt1, stride);\n+  jcc(Assembler::less, SCAN_TO_CHAR_INIT);\/\/less than 16 entires left\n+  if (UseAVX < 2) {\n+    movdl(vec1, ch);\n+    pxor(vec2, vec2);\n+    pshufb(vec1, vec2);\n+  }\n+  movl(tmp, cnt1);\n+  andl(tmp, 0xFFFFFFF0);  \/\/vector count (in bytes)\n+  andl(cnt1,0x0000000F);  \/\/tail count (in bytes)\n+\n+  bind(SCAN_TO_16_CHAR_LOOP);\n+  movdqu(vec3, Address(result, 0));\n+  pcmpeqb(vec3, vec1);\n+  ptest(vec2, vec3);\n+  jcc(Assembler::carryClear, FOUND_CHAR);\n+  addptr(result, 16);\n+  subl(tmp, stride);\n+  jcc(Assembler::notZero, SCAN_TO_16_CHAR_LOOP);\/\/last 16 items...\n+\n+  bind(SCAN_TO_CHAR_INIT);\n+  testl(cnt1, cnt1);\n+  jcc(Assembler::zero, RET_NOT_FOUND);\n+  bind(SCAN_TO_CHAR_LOOP);\n+  load_unsigned_byte(tmp, Address(result, 0));\n+  cmpl(ch, tmp);\n+  jccb(Assembler::equal, FOUND_SEQ_CHAR);\n+  addptr(result, 1);\n+  subl(cnt1, 1);\n+  jccb(Assembler::zero, RET_NOT_FOUND);\n+  jmp(SCAN_TO_CHAR_LOOP);\n+\n+  bind(RET_NOT_FOUND);\n+  movl(result, -1);\n+  jmpb(DONE_LABEL);\n+\n+  bind(FOUND_CHAR);\n+  if (UseAVX >= 2) {\n+    vpmovmskb(tmp, vec3);\n+  } else {\n+    pmovmskb(tmp, vec3);\n+  }\n+  bsfl(ch, tmp);\n+  addl(result, ch);\n+\n+  bind(FOUND_SEQ_CHAR);\n+  subptr(result, str1);\n+\n+  bind(DONE_LABEL);\n+} \/\/ stringL_indexof_char\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":93,"deletions":0,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -1657,0 +1657,3 @@\n+  void stringL_indexof_char(Register str1, Register cnt1, Register ch, Register result,\n+                            XMMRegister vec1, XMMRegister vec2, XMMRegister vec3, Register tmp);\n+\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -11912,3 +11912,3 @@\n-instruct string_indexofU_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,\n-                              eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{\n-  predicate(UseSSE42Intrinsics);\n+instruct string_indexof_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,\n+                             eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n@@ -11917,1 +11917,1 @@\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n@@ -11925,0 +11925,13 @@\n+instruct stringL_indexof_char(eDIRegP str1, eDXRegI cnt1, eAXRegI ch,\n+                              eBXRegI result, regD vec1, regD vec2, regD vec3, eCXRegI tmp, eFlagsReg cr) %{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP vec1, TEMP vec2, TEMP vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                           $vec1$$XMMRegister, $vec2$$XMMRegister, $vec3$$XMMRegister, $tmp$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":17,"deletions":4,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -11511,2 +11511,2 @@\n-instruct string_indexofU_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n-                              rbx_RegI result, legVecS vec1, legVecS vec2, legVecS vec3, rcx_RegI tmp, rFlagsReg cr)\n+instruct string_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n+                             rbx_RegI result, legVecS vec1, legVecS vec2, legVecS vec3, rcx_RegI tmp, rFlagsReg cr)\n@@ -11514,1 +11514,1 @@\n-  predicate(UseSSE42Intrinsics);\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::U));\n@@ -11517,1 +11517,1 @@\n-  format %{ \"String IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  format %{ \"StringUTF16 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n@@ -11525,0 +11525,14 @@\n+instruct stringL_indexof_char(rdi_RegP str1, rdx_RegI cnt1, rax_RegI ch,\n+                              rbx_RegI result, legRegD tmp_vec1, legRegD tmp_vec2, legRegD tmp_vec3, rcx_RegI tmp, rFlagsReg cr)\n+%{\n+  predicate(UseSSE42Intrinsics && (((StrIndexOfCharNode*)n)->encoding() == StrIntrinsicNode::L));\n+  match(Set result (StrIndexOfChar (Binary str1 cnt1) ch));\n+  effect(TEMP tmp_vec1, TEMP tmp_vec2, TEMP tmp_vec3, USE_KILL str1, USE_KILL cnt1, USE_KILL ch, TEMP tmp, KILL cr);\n+  format %{ \"StringLatin1 IndexOf char[] $str1,$cnt1,$ch -> $result   \/\/ KILL all\" %}\n+  ins_encode %{\n+    __ stringL_indexof_char($str1$$Register, $cnt1$$Register, $ch$$Register, $result$$Register,\n+                           $tmp_vec1$$XMMRegister, $tmp_vec2$$XMMRegister, $tmp_vec3$$XMMRegister, $tmp$$Register);\n+  %}\n+  ins_pipe( pipe_slow );\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -526,0 +526,1 @@\n+    case vmIntrinsics::_indexOfL_char:\n@@ -811,0 +812,1 @@\n+  case vmIntrinsics::_indexOfL_char:\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -949,0 +949,1 @@\n+  do_intrinsic(_indexOfL_char,            java_lang_StringLatin1,indexOfChar_name, indexOfChar_signature,        F_S)   \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -499,0 +499,1 @@\n+  case vmIntrinsics::_indexOfL_char:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-  \/\/ Possible encodings of the two parameters passed to the string intrinsic.\n+  \/\/ Possible encodings of the parameters passed to the string intrinsic.\n@@ -53,1 +53,2 @@\n-  typedef enum ArgEncoding { LL, LU, UL, UU, none } ArgEnc;\n+  \/\/ 'L' means that the single string is Latin1 encoded\n+  typedef enum ArgEncoding { LL, LU, UL, UU, L, U, none } ArgEnc;\n","filename":"src\/hotspot\/share\/opto\/intrinsicnode.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-  bool inline_string_indexOfChar();\n+  bool inline_string_indexOfChar(StrIntrinsicNode::ArgEnc ae);\n@@ -593,1 +593,2 @@\n-  case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar();\n+  case vmIntrinsics::_indexOfU_char:            return inline_string_indexOfChar(StrIntrinsicNode::U);\n+  case vmIntrinsics::_indexOfL_char:            return inline_string_indexOfChar(StrIntrinsicNode::L);\n@@ -1423,1 +1424,1 @@\n-bool LibraryCallKit::inline_string_indexOfChar() {\n+bool LibraryCallKit::inline_string_indexOfChar(StrIntrinsicNode::ArgEnc ae) {\n@@ -1438,1 +1439,1 @@\n-  Node* src_offset = _gvn.transform(new LShiftINode(from_index, intcon(1)));\n+  Node* src_offset = ae == StrIntrinsicNode::L ? from_index : _gvn.transform(new LShiftINode(from_index, intcon(1)));\n@@ -1443,1 +1444,1 @@\n-  generate_string_range_check(src, src_offset, src_count, true);\n+  generate_string_range_check(src, src_offset, src_count, ae == StrIntrinsicNode::U);\n@@ -1451,1 +1452,1 @@\n-  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, StrIntrinsicNode::none);\n+  Node* result = new StrIndexOfCharNode(control(), memory(TypeAryPtr::BYTES), src_start, src_count, tgt, ae);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -212,0 +212,5 @@\n+        return indexOfChar(value, ch, fromIndex, max);\n+    }\n+\n+    @HotSpotIntrinsicCandidate\n+    private static int indexOfChar(byte[] value, int ch, int fromIndex, int max) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringLatin1.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8173585\n+ * @summary Test intrinsification of StringLatin1.indexOf(char). Note that\n+ * differing code paths are taken contingent upon the length of the input String.\n+ * Hence we must test against differing string lengths in order to validate\n+ * correct functionality. We also ensure the strings are long enough to trigger\n+ * the looping conditions of the individual code paths.\n+ *\n+ * Run with varing levels of AVX and SSE support, also without the intrinsic at all\n+ *\n+ * @library \/compiler\/patches \/test\/lib\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_indexOfL_char compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseSSE=0 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=1 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=2 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ * @run main\/othervm -Xbatch -XX:Tier4InvocationThreshold=200 -XX:CompileThreshold=100 -XX:+IgnoreUnrecognizedVMOptions -XX:UseAVX=3 compiler.intrinsics.string.TestStringLatin1IndexOfChar\n+ *\/\n+\n+package compiler.intrinsics.string;\n+\n+import jdk.test.lib.Asserts;\n+\n+public class TestStringLatin1IndexOfChar{\n+    private final static int MAX_LENGTH = 2048;\/\/future proof for AVX-512 instructions\n+\n+    public static void main(String[] args) throws Exception {\n+        for (int i = 0; i < 1_000; ++i) {\/\/repeat such that we enter into C2 code...\n+            findOneItem();\n+            withOffsetTest();\n+            testEmpty();\n+        }\n+    }\n+\n+    private static void testEmpty(){\n+        Asserts.assertEQ(\"\".indexOf('a'), -1);\n+    }\n+\n+    private final static char SEARCH_CHAR = 'z';\n+    private final static char INVERLEAVING_CHAR = 'a';\n+    private final static char MISSING_CHAR = 'd';\n+\n+    private static void findOneItem(){\n+        \/\/test strings of varying length ensuring that for all lengths one instance of the\n+        \/\/search char can be found. We check what happens when the search character is in\n+        \/\/each position of the search string (including first and last positions)\n+        for(int strLength : new int[]{1, 15, 31, 32, 79}){\n+            for(int searchPos = 0; searchPos < strLength; searchPos++){\n+                String totest = makeOneItemStringLatin1(strLength, searchPos);\n+\n+                int intri = totest.indexOf(SEARCH_CHAR);\n+                int nonintri = indexOfCharNonIntrinsic(totest, SEARCH_CHAR, 0);\n+                Asserts.assertEQ(intri, nonintri);\n+            }\n+        }\n+    }\n+\n+    private static String makeOneItemStringLatin1(int length, int searchPos){\n+        StringBuilder sb = new StringBuilder(length);\n+\n+        for(int n =0; n < length; n++){\n+            sb.append(searchPos==n?SEARCH_CHAR:INVERLEAVING_CHAR);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    private static void withOffsetTest(){\n+        \/\/progressivly move through string checking indexes and starting offset correctly processed\n+        \/\/string is of form azaza, aazaazaa, aaazaaazaaa, etc\n+        \/\/we find n s.t. maxlength = (n*3) + 2\n+        int maxaInstances = (MAX_LENGTH-2)\/3;\n+\n+        for(int aInstances = 5; aInstances < MAX_LENGTH; aInstances++){\n+            String totest = makeWithOffsetStringLatin1(aInstances);\n+\n+            int startoffset;\n+            {\n+                int intri = totest.indexOf(SEARCH_CHAR);\n+                int nonintri = indexOfCharNonIntrinsic(totest, SEARCH_CHAR, 0);\n+\n+                Asserts.assertEQ(intri, nonintri);\n+                startoffset = intri+1;\n+            }\n+\n+            {\n+                int intri = totest.indexOf(SEARCH_CHAR, startoffset);\n+                int nonintri = indexOfCharNonIntrinsic(totest, SEARCH_CHAR, startoffset);\n+\n+                Asserts.assertEQ(intri, nonintri);\n+                startoffset = intri+1;\n+            }\n+\n+            Asserts.assertEQ(totest.indexOf(SEARCH_CHAR, startoffset), -1);\/\/only two SEARCH_CHAR per string\n+            Asserts.assertEQ(totest.indexOf(MISSING_CHAR), -1);\n+        }\n+    }\n+\n+    private static String makeWithOffsetStringLatin1(int aInstances){\n+        StringBuilder sb = new StringBuilder((aInstances*3) + 2);\n+        for(int n =0; n < aInstances; n++){\n+            sb.append(INVERLEAVING_CHAR);\n+        }\n+\n+        sb.append(SEARCH_CHAR);\n+\n+        for(int n =0; n < aInstances; n++){\n+            sb.append(INVERLEAVING_CHAR);\n+        }\n+\n+        sb.append(SEARCH_CHAR);\n+\n+        for(int n =0; n < aInstances; n++){\n+            sb.append(INVERLEAVING_CHAR);\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static int indexOfCharNonIntrinsic(String value, int ch, int fromIndex) {\n+        \/\/non intrinsic version of indexOfChar\n+        byte c = (byte)ch;\n+        for (int i = fromIndex; i < value.length(); i++) {\n+            if (value.charAt(i) == c) {\n+               return i;\n+            }\n+        }\n+        return -1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/intrinsics\/string\/TestStringLatin1IndexOfChar.java","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,218 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import java.util.Random;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+\/**\n+ * This benchmark can be used to measure performance between StringLatin1 and StringUTF16 in terms of\n+ * performance of the indexOf(char) and indexOf(String) methods which are intrinsified.\n+ * On x86 the behaviour of the indexOf method is contingent upon the length of the string\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+public class StringIndexOfChar {\n+    @Param(\"100000\")\n+    private int loops;\n+\n+    @Param(\"1000\")\n+    private int pathCnt;\n+\n+    @Param(\"1999\")\n+    private int rngSeed;\n+\n+    private Random rng;\n+    private String[] latn1_short;\n+    private String[] latn1_sse4;\n+    private String[] latn1_avx2;\n+    private String[] latn1_mixedLength;\n+    private String[] utf16_short;\n+    private String[] utf16_sse4;\n+    private String[] utf16_avx2;\n+    private String[] utf16_mixedLength;\n+\n+    @Setup\n+    public void setup() {\n+        rng = new Random(rngSeed);\n+        latn1_short        = new String[pathCnt];\n+        latn1_sse4         = new String[pathCnt];\n+        latn1_avx2         = new String[pathCnt];\n+        latn1_mixedLength  = new String[pathCnt];\n+        utf16_short        = new String[pathCnt];\n+        utf16_sse4         = new String[pathCnt];\n+        utf16_avx2         = new String[pathCnt];\n+        utf16_mixedLength  = new String[pathCnt];\n+\n+        for (int i = 0; i < pathCnt; i++) {\n+            latn1_short[i] = makeRndString(false, 15);\n+            latn1_sse4[i]  = makeRndString(false, 16);\n+            latn1_avx2[i]  = makeRndString(false, 32);\n+            utf16_short[i] = makeRndString(true, 7);\n+            utf16_sse4[i]  = makeRndString(true, 8);\n+            utf16_avx2[i]  = makeRndString(true, 16);\n+            latn1_mixedLength[i] = makeRndString(false, rng.nextInt(65));\n+            utf16_mixedLength[i] = makeRndString(true, rng.nextInt(65));\n+        }\n+    }\n+\n+    private String makeRndString(boolean isUtf16, int length) {\n+        StringBuilder sb = new StringBuilder(length);\n+        if(length > 0){\n+            sb.append(isUtf16?'\\u2026':'b'); \/\/ ...\n+\n+            for (int i = 1; i < length-1; i++) {\n+                sb.append((char)('b' + rng.nextInt(26)));\n+            }\n+\n+            sb.append(rng.nextInt(3) >= 1?'a':'b');\/\/66.6% of time 'a' is in string\n+        }\n+        return sb.toString();\n+    }\n+\n+\n+    @Benchmark\n+    public void latin1_mixed_char(Blackhole bh) {\n+        for (String what : latn1_mixedLength) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_mixed_char(Blackhole bh) {\n+        for (String what : utf16_mixedLength) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void latin1_mixed_String(Blackhole bh) {\n+        for (String what : latn1_mixedLength) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_mixed_String(Blackhole bh) {\n+        for (String what : utf16_mixedLength) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+\n+    \/\/\/\/\/\/\/\/\/\/ more detailed code path dependent tests \/\/\/\/\/\/\/\/\/\/\n+\n+    @Benchmark\n+    public void latin1_Short_char(Blackhole bh) {\n+        for (String what : latn1_short) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void latin1_SSE4_char(Blackhole bh) {\n+        for (String what : latn1_sse4) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void latin1_AVX2_char(Blackhole bh) {\n+        for (String what : latn1_avx2) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_Short_char(Blackhole bh) {\n+        for (String what : utf16_short) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_SSE4_char(Blackhole bh) {\n+        for (String what : utf16_sse4) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_AVX2_char(Blackhole bh) {\n+        for (String what : utf16_avx2) {\n+            bh.consume(what.indexOf('a'));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void latin1_Short_String(Blackhole bh) {\n+        for (String what : latn1_short) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void latin1_SSE4_String(Blackhole bh) {\n+        for (String what : latn1_sse4) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void latin1_AVX2_String(Blackhole bh) {\n+        for (String what : latn1_avx2) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_Short_String(Blackhole bh) {\n+        for (String what : utf16_short) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_SSE4_String(Blackhole bh) {\n+        for (String what : utf16_sse4) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+\n+    @Benchmark\n+    public void utf16_AVX2_String(Blackhole bh) {\n+        for (String what : utf16_avx2) {\n+            bh.consume(what.indexOf(\"a\"));\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringIndexOfChar.java","additions":218,"deletions":0,"binary":false,"changes":218,"status":"added"}]}