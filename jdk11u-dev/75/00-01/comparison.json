{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,1 +81,0 @@\n-#include \"memory\/heapInspection.hpp\"\n@@ -2124,24 +2123,0 @@\n-class G1ParallelObjectIterator : public ParallelObjectIterator {\n-private:\n-  G1CollectedHeap*  _heap;\n-  HeapRegionClaimer _claimer;\n-\n-public:\n-  G1ParallelObjectIterator(uint thread_num) :\n-      _heap(G1CollectedHeap::heap()),\n-      _claimer(thread_num == 0 ? G1CollectedHeap::heap()->workers()->active_workers() : thread_num) {}\n-\n-  virtual void object_iterate(ObjectClosure* cl, uint worker_id) {\n-    _heap->object_iterate_parallel(cl, worker_id, &_claimer);\n-  }\n-};\n-\n-ParallelObjectIterator* G1CollectedHeap::parallel_object_iterator(uint thread_num) {\n-  return new G1ParallelObjectIterator(thread_num);\n-}\n-\n-void G1CollectedHeap::object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer) {\n-  IterateObjectClosureRegionClosure blk(cl);\n-  heap_region_par_iterate_from_worker_offset(&blk, claimer, worker_id);\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":1,"deletions":26,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -1119,2 +1119,0 @@\n-  void object_iterate_parallel(ObjectClosure* cl, uint worker_id, HeapRegionClaimer* claimer);\n-\n@@ -1128,2 +1126,0 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num);\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-class WorkGang;\n","filename":"src\/hotspot\/share\/gc\/parallel\/parallelScavengeHeap.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-#include \"memory\/heapInspection.hpp\"\n@@ -46,1 +45,0 @@\n-class AbstractGangTask;\n@@ -88,6 +86,0 @@\n-class ParallelObjectIterator : public CHeapObj<mtGC> {\n-public:\n-  virtual void object_iterate(ObjectClosure* cl, uint worker_id) = 0;\n-  virtual ~ParallelObjectIterator() {}\n-};\n-\n@@ -476,4 +468,0 @@\n-  virtual ParallelObjectIterator* parallel_object_iterator(uint thread_num) {\n-    return NULL;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2017, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,1 +157,1 @@\n-  inspect.heap_inspection(_out, _parallel_thread_num);\n+  inspect.heap_inspection(_out);\n","filename":"src\/hotspot\/share\/gc\/shared\/vmGCOperations.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,1 +128,0 @@\n-  uint _parallel_thread_num;\n@@ -134,2 +133,1 @@\n-  VM_GC_HeapInspection(outputStream* out, bool request_full_gc,\n-                       uint parallel_thread_num = 1) :\n+  VM_GC_HeapInspection(outputStream* out, bool request_full_gc) :\n@@ -142,1 +140,0 @@\n-    _parallel_thread_num = parallel_thread_num;\n","filename":"src\/hotspot\/share\/gc\/shared\/vmGCOperations.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -232,21 +232,0 @@\n-\/\/ Temporarily try to set the number of active workers.\n-\/\/ It's not guaranteed that it succeeds, and users need to\n-\/\/ query the number of active workers.\n-class WithUpdatedActiveWorkers : public StackObj {\n-private:\n-  AbstractWorkGang* const _gang;\n-  const uint              _old_active_workers;\n-\n-public:\n-  WithUpdatedActiveWorkers(AbstractWorkGang* gang, uint requested_num_workers) :\n-      _gang(gang),\n-      _old_active_workers(gang->active_workers()) {\n-    uint capped_num_workers = MIN2(requested_num_workers, gang->total_workers());\n-    gang->update_active_workers(capped_num_workers);\n-  }\n-\n-  ~WithUpdatedActiveWorkers() {\n-    _gang->update_active_workers(_old_active_workers);\n-  }\n-};\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/workgroup.hpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-#include \"runtime\/atomic.hpp\"\n@@ -240,35 +239,0 @@\n-\/\/ Return false if the entry could not be recorded on account\n-\/\/ of running out of space required to create a new entry.\n-bool KlassInfoTable::merge_entry(const KlassInfoEntry* cie) {\n-  Klass*          k = cie->klass();\n-  KlassInfoEntry* elt = lookup(k);\n-  \/\/ elt may be NULL if it's a new klass for which we\n-  \/\/ could not allocate space for a new entry in the hashtable.\n-  if (elt != NULL) {\n-    elt->set_count(elt->count() + cie->count());\n-    elt->set_words(elt->words() + cie->words());\n-    _size_of_instances_in_words += cie->words();\n-    return true;\n-  }\n-  return false;\n-}\n-\n-class KlassInfoTableMergeClosure : public KlassInfoClosure {\n-private:\n-  KlassInfoTable* _dest;\n-  bool _success;\n-public:\n-  KlassInfoTableMergeClosure(KlassInfoTable* table) : _dest(table), _success(true) {}\n-  void do_cinfo(KlassInfoEntry* cie) {\n-    _success &= _dest->merge_entry(cie);\n-  }\n-  bool success() { return _success; }\n-};\n-\n-\/\/ merge from table\n-bool KlassInfoTable::merge(KlassInfoTable* table) {\n-  KlassInfoTableMergeClosure closure(this);\n-  table->iterate(&closure);\n-  return closure.success();\n-}\n-\n@@ -726,1 +690,1 @@\n-  uintx _missed_count;\n+  size_t _missed_count;\n@@ -740,1 +704,1 @@\n-  uintx missed_count() { return _missed_count; }\n+  size_t missed_count() { return _missed_count; }\n@@ -748,59 +712,1 @@\n-\/\/ Heap inspection for every worker.\n-\/\/ When native OOM happens for KlassInfoTable, set _success to false.\n-void ParHeapInspectTask::work(uint worker_id) {\n-  uintx missed_count = 0;\n-  bool merge_success = true;\n-  if (!Atomic::load(&_success)) {\n-    \/\/ other worker has failed on parallel iteration.\n-    return;\n-  }\n-\n-  KlassInfoTable cit(false);\n-  if (cit.allocation_failed()) {\n-    \/\/ fail to allocate memory, stop parallel mode\n-    Atomic::store(false, &_success);\n-    return;\n-  }\n-  RecordInstanceClosure ric(&cit, _filter);\n-  _poi->object_iterate(&ric, worker_id);\n-  missed_count = ric.missed_count();\n-  {\n-    MutexLocker x(&_mutex);\n-    merge_success = _shared_cit->merge(&cit);\n-  }\n-  if (merge_success) {\n-    Atomic::add(missed_count, &_missed_count);\n-  } else {\n-    Atomic::store(false, &_success);\n-  }\n-}\n-\n-uintx HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter, uint parallel_thread_num) {\n-\n-  \/\/ Try parallel first.\n-  if (parallel_thread_num > 1) {\n-    ResourceMark rm;\n-\n-    WorkGang* gang = Universe::heap()->get_safepoint_workers();\n-    if (gang != NULL) {\n-      \/\/ The GC provided a WorkGang to be used during a safepoint.\n-\n-      \/\/ Can't run with more threads than provided by the WorkGang.\n-      WithUpdatedActiveWorkers update_and_restore(gang, parallel_thread_num);\n-\n-      ParallelObjectIterator* poi = Universe::heap()->parallel_object_iterator(gang->active_workers());\n-      if (poi != NULL) {\n-        \/\/ The GC supports parallel object iteration.\n-\n-        ParHeapInspectTask task(poi, cit, filter);\n-        \/\/ Run task with the active workers.\n-        gang->run_task(&task);\n-\n-        delete poi;\n-        if (task.success()) {\n-          return task.missed_count();\n-        }\n-      }\n-    }\n-  }\n-\n+size_t HeapInspection::populate_table(KlassInfoTable* cit, BoolObjectClosure *filter) {\n@@ -808,1 +714,0 @@\n-  \/\/ If no parallel iteration available, run serially.\n@@ -815,1 +720,1 @@\n-void HeapInspection::heap_inspection(outputStream* st, uint parallel_thread_num) {\n+void HeapInspection::heap_inspection(outputStream* st) {\n@@ -839,1 +744,1 @@\n-    uintx missed_count = populate_table(&cit, NULL, parallel_thread_num);\n+    size_t missed_count = populate_table(&cit);\n@@ -841,1 +746,1 @@\n-      st->print_cr(\"WARNING: Ran out of C-heap; undercounted \" UINTX_FORMAT\n+      st->print_cr(\"WARNING: Ran out of C-heap; undercounted \" SIZE_FORMAT\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":7,"deletions":102,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,0 @@\n-#include \"gc\/shared\/workgroup.hpp\"\n-\n-class ParallelObjectIterator;\n@@ -267,2 +264,0 @@\n-  bool merge(KlassInfoTable* table);\n-  bool merge_entry(const KlassInfoEntry* cie);\n@@ -372,2 +367,2 @@\n-  void heap_inspection(outputStream* st, uint parallel_thread_num = 1) NOT_SERVICES_RETURN;\n-  uintx populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL, uint parallel_thread_num = 1) NOT_SERVICES_RETURN_(0);\n+  void heap_inspection(outputStream* st) NOT_SERVICES_RETURN;\n+  size_t populate_table(KlassInfoTable* cit, BoolObjectClosure* filter = NULL) NOT_SERVICES_RETURN_(0);\n@@ -379,34 +374,0 @@\n-\/\/ Parallel heap inspection task. Parallel inspection can fail due to\n-\/\/ a native OOM when allocating memory for TL-KlassInfoTable.\n-\/\/ _success will be set false on an OOM, and serial inspection tried.\n-class ParHeapInspectTask : public AbstractGangTask {\n- private:\n-  ParallelObjectIterator* _poi;\n-  KlassInfoTable* _shared_cit;\n-  BoolObjectClosure* _filter;\n-  uintx _missed_count;\n-  bool _success;\n-  Mutex _mutex;\n-\n- public:\n-  ParHeapInspectTask(ParallelObjectIterator* poi,\n-                     KlassInfoTable* shared_cit,\n-                     BoolObjectClosure* filter) :\n-      AbstractGangTask(\"Iterating heap\"),\n-      _poi(poi),\n-      _shared_cit(shared_cit),\n-      _filter(filter),\n-      _missed_count(0),\n-      _success(true),\n-      _mutex(Mutex::leaf, \"Parallel heap iteration data merge lock\") {}\n-\n-  uintx missed_count() const {\n-    return _missed_count;\n-  }\n-\n-  bool success() {\n-    return _success;\n-  }\n-\n-  virtual void work(uint worker_id);\n-};\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":3,"deletions":42,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -453,0 +453,6 @@\n+  \/\/ Parse a string for a unsigned integer.  Returns true if value\n+  \/\/ is an unsigned integer greater than or equal to the minimum\n+  \/\/ parameter passed and returns the value in uintx_arg.  Returns\n+  \/\/ false otherwise, with uintx_arg undefined.\n+  static bool parse_uintx(const char* value, uintx* uintx_arg,\n+                          uintx min_size);\n@@ -490,6 +496,0 @@\n-  \/\/ Parse a string for a unsigned integer.  Returns true if value\n-  \/\/ is an unsigned integer greater than or equal to the minimum\n-  \/\/ parameter passed and returns the value in uintx_arg.  Returns\n-  \/\/ false otherwise, with uintx_arg undefined.\n-  static bool parse_uintx(const char* value, uintx* uintx_arg,\n-                          uintx min_size);\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -261,1 +261,0 @@\n-\/\/   arg1: parallel thread number\n@@ -265,1 +264,0 @@\n-  uint parallel_thread_num = MAX2<uint>(1, (uint)os::initial_active_processor_count() * 3 \/ 8);\n@@ -273,12 +271,1 @@\n-\n-  const char* num_str = op->arg(1);\n-  if (num_str != NULL && num_str[0] != '\\0') {\n-    uintx num;\n-    if (!Arguments::parse_uintx(num_str, &num, 0)) {\n-      out->print_cr(\"Invalid parallel thread number: [%s]\", num_str);\n-      return JNI_ERR;\n-    }\n-    parallel_thread_num = num == 0 ? parallel_thread_num : (uint)num;\n-  }\n-\n-  VM_GC_HeapInspection heapop(out, live_objects_only \/* request full gc *\/, parallel_thread_num);\n+  VM_GC_HeapInspection heapop(out, live_objects_only \/* request full gc *\/);\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":2,"deletions":15,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -152,18 +152,8 @@\n-        String parallel = null;\n-        String subopts[] = options.split(\",\");\n-        for (int i = 0; i < subopts.length; i++) {\n-            String subopt = subopts[i];\n-            if (subopt.equals(\"\") || options.equals(\"all\")) {\n-                \/\/  pass\n-            } else if (subopt.equals(\"live\")) {\n-                liveopt = \"-live\";\n-            } else if (subopt.startsWith(\"parallel=\")) {\n-                parallel = subopt.substring(\"parallel=\".length());\n-                if (parallel == null) {\n-                    System.err.println(\"Fail: no number provided in option: '\" + subopt + \"'\");\n-                    usage(1);\n-                }\n-            } else {\n-                System.err.println(\"Fail: invalid option: '\" + subopt + \"'\");\n-                usage(1);\n-            }\n+        if (options.equals(\"\") || options.equals(\"all\")) {\n+            \/\/  pass\n+        }\n+        else if (options.equals(\"live\")) {\n+            liveopt = \"-live\";\n+        }\n+        else {\n+            usage(1);\n@@ -172,1 +162,0 @@\n-        System.out.flush();\n@@ -174,1 +163,1 @@\n-        executeCommandForPid(pid, \"inspectheap\", liveopt, parallel);\n+        executeCommandForPid(pid, \"inspectheap\", liveopt);\n@@ -198,2 +187,1 @@\n-            System.err.println(\"Fail: invalid option or no file name\");\n-            usage(1);\n+            usage(1);  \/\/ invalid options or no filename\n@@ -274,4 +262,0 @@\n-        System.err.println(\"      parallel=<number>  parallel threads number for heap iteration:\");\n-        System.err.println(\"                         parallel=0 default behavior, use predefined number of threads\");\n-        System.err.println(\"                         parallel=1 disable parallel heap iteration\");\n-        System.err.println(\"                         parallel=<N> use N threads for parallel heap iteration\");\n","filename":"src\/jdk.jcmd\/share\/classes\/sun\/tools\/jmap\/JMap.java","additions":11,"deletions":27,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -71,15 +71,0 @@\n-    private static void testHistoParallelZero() throws Exception {\n-        OutputAnalyzer output = jmap(\"-histo:parallel=0\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    private static void testHistoParallel() throws Exception {\n-        OutputAnalyzer output = jmap(\"-histo:parallel=2\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n-    private static void testHistoNonParallel() throws Exception {\n-        OutputAnalyzer output = jmap(\"-histo:parallel=1\");\n-        output.shouldHaveExitValue(0);\n-    }\n-\n","filename":"test\/jdk\/sun\/tools\/jmap\/BasicJMapTest.java","additions":1,"deletions":16,"binary":false,"changes":17,"status":"modified"}]}