{"files":[{"patch":"@@ -1,24 +0,0 @@\n-#\n-# Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-exclusiveAccess.dirs=.\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/TEST.properties","additions":0,"deletions":24,"binary":false,"changes":24,"status":"deleted"},{"patch":"@@ -1,544 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network001.\n- * VM testbase keywords: [stress, diehard, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between server and client\n- *     TCP\/IP sockets, and checks if those data are transfered correctly.\n- *     Both sockets are attached to local host name, or to the loopback\n- *     \"localhost\" (having IP address 127.0.0.1).\n- *     Information transfer is synchronized in this test. Client passes\n- *     a large data parcel to server, and server reads that parcel and checks\n- *     if it is same as expected (byte-to-byte equality). Then server passes\n- *     (some other) parcel to client, and client reads and verifies those bytes.\n- *     This ping-pong game is repeated 2000 times; and after that both sockets\n- *     check if there are no extra bytes accudentally passed through their\n- *     connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 125 bytes. So totally, each of the 2 sockets passes ~250Kb of\n- *     data to its partner, and thus ~500Kb of data are transfered by this test.\n- * COMMENTS\n- *     Note, that HotSpot 1.3beta-H fails to start this test due to the bug:\n- *         #4245704 (P1\/S1) Fails to launch with: jre\/bin\/net.dll ...\n- *\n- * @run main\/othervm nsk.stress.network.network001\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test transfers huge amount of data between server and client\n- * TCP\/IP sockets, and checks if those data are transfered correctly.\n- * Both sockets are attached to local host name, or to the loopback\n- * ``localhost'' (having IP address 127.0.0.1).\n- * <p>\n- * <p>Information transfer is synchronized in this test. Client passes\n- * a large data parcel to server, and server reads that parcel and checks\n- * if it is same as expected (byte-to-byte equality). Then server passes\n- * (some other) parcel to client, and client reads and verifies those bytes.\n- * This ping-pong game is repeated 2000 times; and after that both sockets\n- * check if there are no extra bytes accudentally passed through their\n- * connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 125 bytes. So totally, each of the 2 sockets passes ~250Kb of\n- * data to its partner, and thus ~500Kb of data are transfered by this test.\n- *\/\n-public class network001 {\n-    \/**\n-     * Number of parcels to be sent\/recieve.\n-     *\/\n-    private static final int DATA_PARCELS = 2000;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (now it equals to 250 bytes).\n-     *\/\n-    private static final int MAX_PARCEL = 250;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * Errors and optional reports log. Usually <code>System.out<\/code>.\n-     *\/\n-    static private PrintStream out = System.out;\n-\n-    \/**\n-     * Print error message: both client and server may print\n-     * concurently.\n-     *\/\n-    static private synchronized void println(Object message) {\n-        out.println(message.toString());\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va.\n-     *\/\n-    static private void display(Object report) {\n-        if (DEBUG_MODE)\n-            println(report.toString());\n-    }\n-\n-    \/**\n-     * Server thread intended to reply to data parcels sent by Client thread.\n-     *\/\n-    static private class Server extends Thread {\n-        \/**\n-         * This server thread listens the single socket.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Address and port of this server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Which port does this socket is listening.\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Accept connection, read the string \"abra\", and respond \"cadabra\".\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                display(\"Server socket: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Server thread got unexpected parcel:\");\n-                        println(\"sample=\" + sample);\n-                        println(\"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"server has read unexpected parcel\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Client thread intended to send data parcels to Server thread and\n-     * to recieve the server's replies.\n-     *\/\n-    static private class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-        }\n-\n-        \/**\n-         * Accept connection, read the string \"abra\", and respond \"cadabra\".\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Client thread got unexpected parcel:\");\n-                        println(\"sample=\" + sample);\n-                        println(\"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * A data parcel to sent\/recieved between Client and Server threads.\n-     * When data parcel is sent, first 4 bytes transfered encode the size\n-     * of the parcel (i.e.: number of data bytes in the parcel's contents).\n-     * Then the parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client thread may throw this exception to report the test\n-     * failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Attach client and server sockets to the local host, and check if\n-     * huge amount of data could be correctly transfered between these\n-     * sockets.\n-     * <p>\n-     * <p>Command-line parameters provided with <code>args[]<\/code> may\n-     * prompt the local host IP address or domain name. Execute:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network001 [<i>IP-address<\/i> | <i>host_name<\/i> |\n-     * localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <br>By default, the test uses the Internet address available via\n-     * the method <code>InetAddress.getLocalHost()<\/code>\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network001.out = out;\n-\n-        \/\/\n-        \/\/ Get IP address of the local machine.\n-        \/\/\n-\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 0:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 1:\n-                    String hostName = args[0];\n-                    address = InetAddress.getByName(args[0]);\n-                    break;\n-                default:\n-                    println(\"Use:\");\n-                    println(\"    java network001\");\n-                    println(\"or:\");\n-                    println(\"    java network001 ${IP_ADDRESS}\");\n-                    println(\"or:\");\n-                    println(\"    java network001 ${HOST_NAME}\");\n-                    println(\"or:\");\n-                    println(\"    java network001 localhost\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            println(exception);\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Incarnate the server & the client sockets.\n-        \/\/\n-\n-        Server server = null;\n-        try {\n-            server = new Server(address);\n-        } catch (IOException io) {\n-            println(\"Failed to create server: \" + io);\n-            return 2;\n-        }\n-        display(\"Server: \" + server);\n-\n-        int port = server.getPort();\n-\n-        Client client = null;\n-        try {\n-            client = new Client(address, port);\n-        } catch (IOException io) {\n-            out.println(\"Failed to create client: \" + io);\n-            return 2;\n-        }\n-        display(\"Client socket: \" + client);\n-\n-        \/\/\n-        \/\/ Execute the server and client threads.\n-        \/\/\n-\n-        Exception exception = null;\n-        try {\n-            server.start();\n-            client.start();\n-            while (client.isAlive() || server.isAlive())\n-                if (client.exception == null && server.exception == null)\n-                    Thread.yield();\n-                else\n-                    break;\n-        } catch (TestFailure failure) {\n-            exception = failure;\n-        }\n-\n-        \/\/ Failure diagnostics, if needed.\n-\n-        Exception problem[] = new Exception[3];\n-        problem[0] = exception;\n-        problem[1] = server.exception;\n-        problem[2] = client.exception;\n-\n-        int exitCode = 0;\n-\n-        for (int i = 0; i < 3; i++)\n-            if (problem[i] != null) {\n-                out.println(\"#### OOPS ! ####\");\n-                problem[i].printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0) {\n-            out.println(\"#### OOPS ! ####\");\n-            out.println(\"# Test failed.\");\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Test passed.\");\n-        return 0; \/\/ PASSED\n-    }\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test; and stop with exit code 95 if the test\n-     * has passed, or with code 97 if the test has failed.\n-     * (This is JCK-like exit codes convention.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit code.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network001.java","additions":0,"deletions":544,"binary":false,"changes":544,"status":"deleted"},{"patch":"@@ -1,697 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network002.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between 2 Java virtual machines\n- *     using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- *     Both client and server VMs run on the same local computer and attach TCP\/IP\n- *     sockets to the local host, or to the loopback domain \"localhost\" (having IP\n- *     address 127.0.0.1).\n- *     Information transfer is synchronized in this test. Client VM passes\n- *     a large data parcel to server VM, and server reads that parcel and checks\n- *     if it is same as expected (byte-to-byte equality). Then server passes\n- *     (some other) parcel to client, and client reads and verifies those data.\n- *     This ping-pong game is repeated 2000 times; and after that both VMs check\n- *     if there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 125 bytes. So totally, each of the 2 VMs passes ~250Kb of data\n- *     to its partner, and thus ~500Kb of data are transfered by this test.\n- * COMMENTS\n- *     HotSpot 1.3beta-H fails to start this test due to the hotspot bug:\n- *         #4245704 (P1\/S1) Fails to launch with: jre\/bin\/net.dll ...\n- *     Test was fixed:\n- *     added WAITTIME parameter defined timeout for TCP\/IP sockets in minutes\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @build nsk.stress.network.network002\n- * @run main\/othervm PropertyResolvingWrapper\n- *      nsk.stress.network.network002\n- *      \"${test.jdk}\/bin\/java ${test.vm.opts} ${test.java.opts}\" 5\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test transfers huge amount of data between 2 Java virtual machines\n- * using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- * Both client and server VMs run on the same local computer and attach TCP\/IP\n- * sockets to the local host, or to the loopback domain ``<code>localhost<\/code>''\n- * (having IP address <code>127.0.0.1<\/code>).\n- * <p>\n- * <p>Information transfer is synchronized in this test. Client VM passes\n- * a large data parcel to server VM, and server reads that parcel and checks\n- * if it is same as expected (byte-to-byte equality). Then server passes\n- * (some other) parcel to client, and client reads and verifies those data.\n- * This ping-pong game is repeated 2000 times; and after that both VMs check\n- * if there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 125 bytes. So totally, each of the 2 VMs passes ~250Kb of data\n- * to its partner, and thus ~500Kb of data are transfered by this test.\n- *\/\n-public class network002 {\n-    \/**\n-     * Timeout for TCP\/IP sockets (currently set to 1 min).\n-     *\/\n-    private static int SO_TIMEOUT;\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private static final int DATA_PARCELS = 2000;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved.\n-     *\/\n-    private static final int MAX_PARCEL = 250;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test. After <code>run(args[],out)<\/code> stops,\n-     * follow JDK-like convention for exit codes. I.e.: stop with\n-     * exit status 95 if the test has passed, or with status 97 if\n-     * the test has failed.\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * Incarnate new <code>network002<\/code> instance reporting to the given\n-     * <code>out<\/code> stream, and invoke the method <code>run(args)<\/code>\n-     * for that instance to perform the test.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network002 test = new network002(out);\n-        int exitCode = test.run(args);\n-        return exitCode;\n-    }\n-\n-    \/**\n-     * Parse command-line parameters stored into <code>args[]<\/code> array,\n-     * then perform the test. I.e.: start the server thread at the same VM\n-     * this method runs, then start the other client VM, and verify data\n-     * transfer through TCP\/IP connection between those different virtual\n-     * machines.\n-     * <p>\n-     * <p>There should be 1 or 2 command-line parameters:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network002 <i>java_command<\/i> <i>waittime<\/i>\n-     * [<i>IP-address<\/i> | <i>host_name<\/i> | localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>java_command<\/i><\/code> - how to start java,\n-     * e.g.: ``<code>c:\\jdk1.3\\bin\\java -classic<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>waittime<\/code> - timeout for TCP\/IP sockets in minutes\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <p>\n-     * <p>Usually, <code><i>java_command<\/i><\/code> should point to the same\n-     * Java machine just executing this test. However, every compatible Java 2\n-     * implementation is appropriate.\n-     * <p>\n-     * <p>If optional parameter is ommited, the test invokes the method\n-     * <code>InetAddress.getLocalHost()<\/code> to get the domain name and\n-     * IP-address of the local computer.\n-     *\/\n-    private int run(String args[]) {\n-        \/\/\n-        \/\/ Get the Internet address of the local machine.\n-        \/\/\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 2:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 3:\n-                    address = InetAddress.getByName(args[2]);\n-                    break;\n-                default:\n-                    complain(\"Illegal arguments number; execute:\");\n-                    complain(\"    java network002 $JAVA_COMMAND \" +\n-                            \"[$IP_ADDRESS | $HOST_NAME | localhost]\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            complain(exception.toString());\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Start the server thread on the same VM this method just runs.\n-        \/\/\n-        Server server = null;\n-        try {\n-            server = new Server(address);\n-            server.start();\n-        } catch (Exception exception) {\n-            complain(\"Failed to start server: \" + exception);\n-            return 2;\n-        }\n-        display(\"Server: \" + server);\n-\n-        \/\/\n-        \/\/ Start the client process on different VM.\n-        \/\/\n-        String IPAddress = server.getIPAddress(); \/\/ e.g.: 127.0.0.1\n-        int port = server.getPort();\n-        String command = args[0] + \" \" + network002.class.getName() + \"$Client \" + IPAddress + \" \" + port;\n-        try {\n-            SO_TIMEOUT = Integer.parseInt(args[1]) * 60 * 1000;\n-        } catch (NumberFormatException e) {\n-            complain(\"Wrong timeout argument: \" + e);\n-            return 2;\n-        }\n-\n-        Runtime runtime = Runtime.getRuntime();\n-\n-        Process client = null;\n-        IORedirector redirectOut = null;\n-        IORedirector redirectErr = null;\n-\n-        try {\n-            client = runtime.exec(command);\n-\n-            InputStream clientOut = client.getInputStream();\n-            InputStream clientErr = client.getErrorStream();\n-            redirectOut = new IORedirector(clientOut, DEBUG_MODE ? out : null);\n-            redirectErr = new IORedirector(clientErr, out);\n-            redirectOut.start();\n-            redirectErr.start();\n-\n-        } catch (Exception exception) {\n-            complain(\"Failed to start client: \" + exception);\n-            return 2;\n-        }\n-\n-        \/\/\n-        \/\/ Wait until the server and client both stop.\n-        \/\/\n-        try {\n-            client.waitFor();\n-            if (redirectOut.isAlive())\n-                redirectOut.join();\n-            if (redirectErr.isAlive())\n-                redirectErr.join();\n-\n-            \/\/ If client has crashed, also terminate the server (to avoid hangup).\n-            int clientStatus = client.exitValue();\n-            if (clientStatus != 95) {\n-                complain(\"\");\n-                complain(\"Client VM has crashed: exit status=\" + clientStatus);\n-                if (server.isAlive())\n-                    complain(\"Server also should be terminated.\");\n-                complain(\"Test failed.\");\n-                return 2; \/\/ failure\n-            }\n-\n-            \/\/ Client has finished OK; wait for the server.\n-            if (server.isAlive())\n-                server.join();\n-\n-        } catch (Exception exception) {\n-            complain(\"Test interrupted: \" + exception);\n-            complain(\"Test failed.\");\n-            return 2; \/\/ FAILURE\n-        }\n-\n-        \/\/\n-        \/\/ Complain failure, if occured.\n-        \/\/\n-\n-        if (server.exception != null) {\n-            complain(\"Server exception: \" + server.exception);\n-            complain(\"Test failed.\");\n-            return 2; \/\/ failure\n-        }\n-\n-        display(\"Test passed.\");\n-        return 0; \/\/ Ok\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * The test should report to the given <code>out<\/code> stream.\n-     *\/\n-    private network002(PrintStream out) {\n-        this.out = out;\n-    }\n-\n-    \/**\n-     * Log stream for error messages and\/or (optional) execution trace.\n-     *\/\n-    private PrintStream out;\n-\n-    \/**\n-     * Print error message.\n-     *\/\n-    private void complain(Object message) {\n-        out.println(\"# \" + message);\n-        out.flush();\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va?\n-     *\/\n-    private void display(Object report) {\n-        if (DEBUG_MODE)\n-            out.println(report.toString());\n-        out.flush();\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Server thread should reply to data parcels sent by Client VM.\n-     *\/\n-    private class Server extends Thread {\n-        \/**\n-         * The socket to listen for a client.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Display the server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Server's IP-address in the form ``<code><i>x.y.u.z<\/i><\/code>'',\n-         * or ``<code>127.0.0.1<\/code>'' for loopback connection.\n-         *\/\n-        public String getIPAddress() {\n-            return serverSocket.getInetAddress().getHostAddress();\n-        }\n-\n-        \/**\n-         * Which port is this socket listening?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        public Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Exception just arisen while the server was working,\n-         * or <code>null<\/code> if it was OK with the server.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Accept connection, then reply to client's parcels.\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                socket.setSoTimeout(SO_TIMEOUT);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    display(\"Server: i=\" + i);\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Server got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"the parcel just read seems wrong for server\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Client VM should send data parcels to Server VM and\n-     * recieve and verify the server's replies.\n-     *\/\n-    private static class Client {\n-        \/**\n-         * Print error message.\n-         *\/\n-        private static void complain(Object message) {\n-            System.err.println(\"# \" + message);\n-            System.err.flush();\n-        }\n-\n-        \/**\n-         * Display execution trace.\n-         *\/\n-        private static void display(Object message) {\n-            System.out.println(message.toString());\n-            System.out.flush();\n-        }\n-\n-        \/**\n-         * Exit with JCK-like status.\n-         *\/\n-        private static void exit(int exitCode) {\n-            System.exit(exitCode + 95);\n-        }\n-\n-        \/**\n-         * Atack server with huge data parcels, and check if it replies correctly.\n-         * The command-line parameters prescribe the server's IP-address and port:\n-         * <br>&nbsp;&nbsp;\n-         * <code>java network002$Client <i>IP-address<\/i> <i>port<\/i><\/code>\n-         * <br>where:\n-         * <br>&nbsp;&nbsp;\n-         * <code><i>IP-address<\/i><\/code> - local host's address,\n-         * or <code>127.0.0.1<\/code>\n-         * <br>&nbsp;&nbsp;\n-         * <code><i>port<\/i><\/code> - some port assigned by server\n-         *\/\n-        public static void main(String args[]) {\n-            if (args.length != 2) {\n-                complain(\"Illegal number of client paramenets, try:\");\n-                complain(\"    java network002$Client IP-address port\");\n-                exit(2); \/\/ FAILED\n-            }\n-\n-            try {\n-                InetAddress address = InetAddress.getByName(args[0]);\n-                int port = Integer.parseInt(args[1]);\n-\n-                Socket socket = new Socket(address, port);\n-                socket.setSoTimeout(SO_TIMEOUT);\n-                display(\"Client: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(0);\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    display(\"Client: i=\" + i);\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Client got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception exception) {\n-                complain(\"Client exception: \" + exception);\n-                exit(2); \/\/ FAILED\n-            }\n-            exit(0); \/\/ PASSED, at least at the client side.\n-        }\n-\n-    }\n-\n-    \/**\n-     * Two of such threads should redirect <code>out<\/code> and <code>err<\/code>\n-     * streams of client VM.\n-     *\/\n-    private static class IORedirector extends Thread {\n-        \/**\n-         * Source stream.\n-         *\/\n-        InputStream in;\n-        \/**\n-         * Destination stream.\n-         *\/\n-        OutputStream out;\n-\n-        \/**\n-         * Redirect <code>in<\/code> to <code>out<\/code>.\n-         *\/\n-        public IORedirector(InputStream in, OutputStream out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-\n-        \/**\n-         * Read input stream until the EOF, and write everithing to output stream.\n-         * If output stream is assigned to <code>null<\/code>, do not print anything,\n-         * but read the input stream anywhere.\n-         *\/\n-        public void run() {\n-            try {\n-                for (; ; ) {\n-                    int symbol = in.read();\n-                    if (symbol < 0)\n-                        break; \/\/ EOF\n-                    if (out != null)\n-                        out.write(symbol);\n-                }\n-\n-                if (out != null)\n-                    out.flush();\n-\n-            } catch (Exception exception) {\n-                throw new TestFailure(\"IORedirector exception: \" + exception);\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * A data parcel to be sent\/recieved between Client VM and Server thread.\n-     * When data parcel is sent, first 4 bytes are transfered which encode the\n-     * <code>int<\/code> number equal to size of the parcel minus 1. I.e.: if\n-     * number of data bytes in the parcel's contents is <code>N<\/code>, then\n-     * the first 4 bytes encode the number <code>N-1<\/code>. After that, the\n-     * parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client may throw this exception to report the test failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network002.java","additions":0,"deletions":697,"binary":false,"changes":697,"status":"deleted"},{"patch":"@@ -1,658 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network003.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between one server and multiple\n- *     clients communicating via TCP\/IP sockets, and checks if those data are\n- *     transfered correctly. All TCP\/IP sockets are attached to local host\n- *     (by its domain name), or to the ``localhost'' loopback (having the IP\n- *     address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a large data parcel to server,\n- *     and server reads that parcel and checks if it is same as expected\n- *     (byte-to-byte equality is desired). Then server passes (some other) parcel\n- *     to the client, and client reads and verifies those bytes. This ping-pong\n- *     game is repeated 128 times; and after that each pair of sockets checks if\n- *     there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- *     data to each other, and thus ~32Kb of data are transfered by each sockets\n- *     pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- * COMMENTS\n- *     The production Solaris_JDK_1.3-b12 Server VM crashes under this test:\n- *         #\n- *         # HotSpot Virtual Machine Error, Unexpected Signal 10\n- *         # Please report this error at\n- *         # http:\/\/java.sun.com\/cgi-bin\/bugreport.cgi\n- *         #\n- *         # Error ID: 4F533F534F4C415249530E43505007D9 01\n- *         #\n- *         # Problematic Thread: prio=5 tid=0x214418 nid=0x103 runnable\n- *         #\n- *     (ErrorID == \"os_solaris.cpp, 2009\")\n- *\n- * @run main\/othervm nsk.stress.network.network003\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test transfers huge amount of data between one server and multiple\n- * clients communicating via TCP\/IP sockets, and checks if those data are\n- * transfered correctly. All TCP\/IP sockets are attached to local host\n- * (by its domain name), or to the ``localhost'' loopback (having the IP\n- * address 127.0.0.1).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a large data parcel to server,\n- * and server reads that parcel and checks if it is same as expected\n- * (byte-to-byte equality is desired). Then server passes (some other) parcel\n- * to the client, and client reads and verifies those bytes. This ping-pong\n- * game is repeated 128 times; and after that each pair of sockets checks if\n- * there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- * data to each other, and thus ~32Kb of data are transfered by each sockets\n- * pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- *\/\n-public class network003 {\n-    \/**\n-     * Do actually display optional reports?\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * Errors and optional reports log. Usually <code>System.out<\/code>.\n-     *\/\n-    static private PrintStream out = System.out;\n-\n-    \/**\n-     * Print error message: all clients and servers may print concurently.\n-     *\/\n-    static private synchronized void println(Object message) {\n-        out.println(message.toString());\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va.\n-     *\/\n-    static private void display(Object report) {\n-        if (DEBUG_MODE)\n-            println(report.toString());\n-    }\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * Number of client\/server connections to establish.\n-     *\/\n-    private static final int CONNECTIONS = detectOSLimitation();\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private static final int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private static final int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        ServerSocket ssoc[] = new ServerSocket[CONNECTIONS_TO_TRY];\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-        int i;\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                ssoc[i] = new ServerSocket(0);\n-                display(\"--- Open: ssoc[\" + i + \"] = \" + ssoc[i]);\n-            } catch (IOException ioe) {\n-                display(\"--- OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"--- Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\"--- Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                ssoc[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\"--- OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            println(\"# ------------------------- CAUTION: -------------------\");\n-            println(\"# While checking the OS limitations, the test found that\");\n-            println(\"# only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            println(\"# simultaneously. However, possibility to open at least\");\n-            println(\"# \" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            println(\"# \");\n-            println(\"# So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            println(\"# safe to be open simultaneously.\");\n-            println(\"# ------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/**\n-     * Server thread intended to reply to data parcels sent by Client thread.\n-     *\/\n-    static private class Server extends Thread {\n-        \/**\n-         * This server thread listens the single socket.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Address and port of this server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Accept connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                display(\"Server socket: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Server thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"server has read unexpected parcel\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * Client thread intended to send data parcels to Server thread and\n-     * to recieve the server's replies.\n-     *\/\n-    static private class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-        }\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return socket.getPort();\n-        }\n-\n-\n-        \/**\n-         * Establish connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        println(\"Client thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * A data parcel to sent\/recieved between Client and Server threads.\n-     * When data parcel is sent, first 4 bytes transfered encode the size\n-     * of the parcel (i.e.: number of data bytes in the parcel's contents).\n-     * Then the parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client thread may throw this exception to report the test\n-     * failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Attach client and server sockets to the local host, and check if\n-     * huge amount of data could be correctly transfered between these\n-     * sockets.\n-     * <p>\n-     * <p>Command-line parameters provided with <code>args[]<\/code> may\n-     * prompt the local host IP address or domain name. Execute:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network003 [<i>IP-address<\/i> | <i>host_name<\/i> |\n-     * localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <br>By default, the test uses the Internet address available via\n-     * the method <code>InetAddress.getLocalHost()<\/code>\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network003.out = out;\n-\n-        \/\/\n-        \/\/ Get IP address of the local machine.\n-        \/\/\n-\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 0:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 1:\n-                    String hostName = args[0];\n-                    address = InetAddress.getByName(args[0]);\n-                    break;\n-                default:\n-                    println(\"Use:\");\n-                    println(\"    java network003\");\n-                    println(\"or:\");\n-                    println(\"    java network003 ${IP_ADDRESS}\");\n-                    println(\"or:\");\n-                    println(\"    java network003 ${HOST_NAME}\");\n-                    println(\"or:\");\n-                    println(\"    java network003 localhost\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            println(exception);\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Incarnate the server & the client sockets.\n-        \/\/\n-\n-        Server server[] = new Server[CONNECTIONS];\n-        Client client[] = new Client[CONNECTIONS];\n-\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            try {\n-                server[i] = new Server(address);\n-            } catch (IOException io) {\n-                println(\"Failed to create server #\" + i + \": \" + io);\n-                return 2;\n-            }\n-            display(\"Server #\" + i + \": \" + server[i]);\n-        }\n-\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            int port = server[i].getPort();\n-            try {\n-                client[i] = new Client(address, port);\n-            } catch (IOException io) {\n-                out.println(\"Failed to create client #\" + i + \": \" + io);\n-                return 2;\n-            }\n-            display(\"Client socket #\" + i + \": \" + client[i]);\n-        }\n-\n-        \/\/\n-        \/\/ Execute the server and client threads.\n-        \/\/\n-\n-        Exception exception = null;\n-        try {\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                server[i].start();\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                client[i].start();\n-            boolean someIsAlive = true;\n-            while (someIsAlive) {\n-                boolean aliveFound = false;\n-                boolean someBroken = false;\n-                for (int i = 0; i < CONNECTIONS; i++)\n-                    if (client[i].isAlive() || server[i].isAlive()) {\n-                        if ((client[i].exception != null) ||\n-                                (server[i].exception != null))\n-                            someBroken = true;\n-                        aliveFound = true;\n-                        Thread.yield();\n-                    }\n-                someIsAlive = aliveFound;\n-                if (someBroken)\n-                    break;\n-            }\n-        } catch (TestFailure failure) {\n-            exception = failure;\n-        }\n-\n-        \/\/ Failure diagnostics, if needed.\n-\n-        Exception problem[] = new Exception[2 * CONNECTIONS + 1];\n-        problem[0] = exception;\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            problem[2 * i + 1] = server[i].exception;\n-            problem[2 * i + 2] = client[i].exception;\n-        }\n-\n-        int exitCode = 0;\n-\n-        for (int i = 0; i < 2 * CONNECTIONS + 1; i++)\n-            if (problem[i] != null) {\n-                out.println(\"#### OOPS ! ####\");\n-                problem[i].printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0) {\n-            out.println(\"#### OOPS ! ####\");\n-            out.println(\"# Test failed.\");\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Test passed.\");\n-        return 0; \/\/ PASSED\n-    }\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test; and stop with exit code 95 if the test\n-     * has passed, or with code 97 if the test has failed.\n-     * (This is JCK-like exit codes convention.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit code.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network003.java","additions":0,"deletions":658,"binary":false,"changes":658,"status":"deleted"},{"patch":"@@ -1,878 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network004.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test transfers huge amount of data between 2 Java virtual machines\n- *     using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- *     Both client and server VMs run on the same local computer and attach TCP\/IP\n- *     sockets to the local host, or to the loopback domain ``localhost''\n- *     (having IP address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a large data parcel to server,\n- *     and server reads that parcel and checks if it is same as expected\n- *     (byte-to-byte equality is desired). Then server passes (some other) parcel\n- *     to the client, and client reads and verifies those bytes. This ping-pong\n- *     game is repeated 128 times; and after that each pair of sockets checks if\n- *     there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average\n- *     parcel length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- *     data to each other, and thus ~32Kb of data are transfered by each sockets\n- *     pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- * COMMENTS\n- *     The production Solaris_JDK_1.3-b12 Server VM intermittently crashes under\n- *     this test, even when client part of the test is executed with Client HS:\n- *         >>>> java -server network004 java\n- *         #\n- *         # HotSpot Virtual Machine Error, Unexpected Signal 10\n- *         # Please report this error at\n- *         # http:\/\/java.sun.com\/cgi-bin\/bugreport.cgi\n- *         #\n- *         # Error ID: 4F533F534F4C415249530E43505007D9 01\n- *         #\n- *         # Problematic Thread: prio=5 tid=0x214418 nid=0x103 runnable\n- *         #\n- *     (ErrorID == \"os_solaris.cpp, 2009\")\n- *     If the client part of the test is executed with Server HS, the\n- *     production Solaris_JDK_1.3-b12 Server VM intermittently fails\n- *     this test due to timeout:\n- *         >>>> time java -server network004 'java -server -showversion'\n- *         java version \"1.3\"\n- *         Java(TM) 2 Runtime Environment, Standard Edition (build Solaris_JDK_1.3-b12)\n- *         Java HotSpot(TM) Server VM (build 1.3-b12, mixed mode)\n- *         # Client #96: java.io.InterruptedIOException: Read timed out\n- *         # Client VM has crashed: exit status=97\n- *         # Test failed.\n- *         156.0u 117.0s 7:06 63% 0+0k 0+0io 0pf+0w\n- *     Test was fixed:\n- *     added WAITTIME parameter defined timeout for TCP\/IP sockets in minutes\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @build nsk.stress.network.network004\n- * @run main\/othervm PropertyResolvingWrapper\n- *      nsk.stress.network.network004\n- *      \"${test.jdk}\/bin\/java ${test.vm.opts} ${test.java.opts}\" 5\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.BufferedReader;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-import java.util.StringTokenizer;\n-\n-\/**\n- * This test transfers huge amount of data between 2 Java virtual machines\n- * using the TCP\/IP protocol, and checks if those data are transfered correctly.\n- * Both client and server VMs run on the same local computer and attach TCP\/IP\n- * sockets to the local host, or to the loopback domain ``<code>localhost<\/code>''\n- * (having IP address <code>127.0.0.1<\/code>).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a large data parcel to server,\n- * and server reads that parcel and checks if it is same as expected\n- * (byte-to-byte equality is desired). Then server passes (some other) parcel\n- * to the client, and client reads and verifies those bytes. This ping-pong\n- * game is repeated 128 times; and after that each pair of sockets checks if\n- * there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average\n- * parcel length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- * data to each other, and thus ~32Kb of data are transfered by each sockets\n- * pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- *\/\n-public class network004 {\n-    \/**\n-     * Timeout for TCP\/IP sockets (currently set to 1 min).\n-     *\/\n-    private static int SO_TIMEOUT;\/\/ = 2*60*1000;\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private final static int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private final static int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        ServerSocket ssoc[] = new ServerSocket[CONNECTIONS_TO_TRY];\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-        int i;\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                ssoc[i] = new ServerSocket(0);\n-                display(\"--- Open: ssoc[\" + i + \"] = \" + ssoc[i]);\n-            } catch (IOException ioe) {\n-                display(\"--- OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"--- Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\"--- Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                ssoc[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\"--- OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            complain(\"------------------------- CAUTION: -------------------\");\n-            complain(\"While checking the OS limitations, the test found that\");\n-            complain(\"only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            complain(\"simultaneously. However, possibility to open at least\");\n-            complain(\"\" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            complain(\"\");\n-            complain(\"So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            complain(\"safe to be open simultaneously.\");\n-            complain(\"------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test. After <code>run(args[],out)<\/code> stops,\n-     * follow JDK-like convention for exit codes. I.e.: stop with\n-     * exit status 95 if the test has passed, or with status 97 if\n-     * the test has failed.\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * Parse command-line parameters stored into <code>args[]<\/code> array,\n-     * then perform the test. I.e.: start the server thread at the same VM\n-     * this method runs, then start the other client VM, and verify data\n-     * transfer through TCP\/IP connection between those different virtual\n-     * machines.\n-     * <p>\n-     * <p>There should be 1 or 2 command-line parameters:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network004 <i>java_command<\/i>\n-     * [<i>IP-address<\/i> | <i>host_name<\/i> | localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>java_command<\/i><\/code> - how to start java,\n-     * e.g.: ``<code>c:\\jdk1.3\\bin\\java -classic<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>waittime<\/code> - timeout for TCP\/IP sockets in minutes\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <p>\n-     * <p>Usually, <code><i>java_command<\/i><\/code> should point to the same\n-     * Java machine just executing this test. However, every compatible Java 2\n-     * implementation is appropriate.\n-     * <p>\n-     * <p>If optional parameter is ommited, the test invokes the method\n-     * <code>InetAddress.getLocalHost()<\/code> to get the domain name and\n-     * IP-address of the local computer.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network004.out = out;\n-\n-        \/\/\n-        \/\/ Get the Internet address of the local machine.\n-        \/\/\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 2:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 3:\n-                    address = InetAddress.getByName(args[2]);\n-                    break;\n-                default:\n-                    complain(\"Illegal arguments number; execute:\");\n-                    complain(\"    java network004 $JAVA_COMMAND \" +\n-                            \"[$IP_ADDRESS | $HOST_NAME | localhost]\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            complain(exception.toString());\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Detect if it is safe to open MAX_CONNETIONS simultaneously:\n-        \/\/\n-        final int CONNECTIONS = detectOSLimitation();\n-\n-        \/\/\n-        \/\/ Start the server thread on the same VM (which executes this method).\n-        \/\/\n-        Server server[] = new Server[CONNECTIONS];\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            try {\n-                server[i] = new Server(address);\n-            } catch (Exception exception) {\n-                complain(\"Server #\" + i + \": \" + exception);\n-                return 2;\n-            }\n-            display(\"Server #\" + i + \": \" + server[i]);\n-            server[i].start();\n-        }\n-\n-        \/\/\n-        \/\/ Start the client process on different VM.\n-        \/\/\n-        String command = args[0] + \" \" + network004.class.getName() + \"$Client\";\n-        try {\n-            SO_TIMEOUT = Integer.parseInt(args[1]) * 60 * 1000;\n-        } catch (NumberFormatException e) {\n-            complain(\"Wrong timeout argument: \" + e);\n-            return 2;\n-        }\n-\n-        Runtime runtime = Runtime.getRuntime();\n-\n-        Process client = null;\n-        IORedirector redirectOut = null;\n-        IORedirector redirectErr = null;\n-\n-        try {\n-            \/\/ Start clients on different JVM:\n-            client = runtime.exec(command);\n-\n-            \/\/ Provide clients with access to stderr and stdout:\n-            InputStream clientOut = client.getInputStream();\n-            InputStream clientErr = client.getErrorStream();\n-            redirectOut = new IORedirector(clientOut, DEBUG_MODE ? out : null);\n-            redirectErr = new IORedirector(clientErr, out);\n-            redirectOut.start();\n-            redirectErr.start();\n-\n-            \/\/ Pass parameters to clients (number of connections, and IP adresses and ports):\n-            PrintStream clientIn = new PrintStream(client.getOutputStream());\n-            clientIn.println(CONNECTIONS);\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                clientIn.println(server[i].getIPAddress() + \" \" + server[i].getPort());\n-            clientIn.flush();\n-            clientIn.close();\n-\n-        } catch (Exception exception) {\n-            complain(\"Failed to start client: \" + exception);\n-            return 2;\n-        }\n-\n-        \/\/\n-        \/\/ Wait until the server and client both stop.\n-        \/\/\n-        boolean testFailed = false;\n-        try {\n-            client.waitFor();\n-            \/\/ Let I\/O redirectors to flush:\n-            if (redirectOut.isAlive())\n-                redirectOut.join();\n-            if (redirectErr.isAlive())\n-                redirectErr.join();\n-\n-            \/\/ If client has crashed, also terminate the server (to avoid hangup).\n-            int clientStatus = client.exitValue();\n-            if (clientStatus != 95) {\n-                complain(\"Client VM has failed: exit status=\" + clientStatus);\n-                testFailed = true;\n-            }\n-\n-            \/\/ Client has finished OK; wait for the server.\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Server: waiting for #\" + i);\n-                while (server[i].isAlive())\n-                    server[i].join();\n-                if (server[i].exception != null) {\n-                    complain(\"Server thread #\" + i + \": \" + server[i].exception);\n-                    testFailed = true;\n-                }\n-            }\n-\n-        } catch (Exception exception) {\n-            complain(\"Test interrupted: \" + exception);\n-            testFailed = true;\n-        }\n-\n-        if (testFailed)\n-            complain(\"Test failed.\");\n-        else\n-            display(\"Test passed.\");\n-        return testFailed ? 2 : 0;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Log stream for error messages and\/or (optional) execution trace.\n-     *\/\n-    private static PrintStream out;\n-\n-    \/**\n-     * Print error message.\n-     *\/\n-    private static synchronized void complain(Object message) {\n-        out.println(\"# \" + message);\n-        out.flush();\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va?\n-     *\/\n-    private static synchronized void display(Object report) {\n-        if (DEBUG_MODE)\n-            out.println(report.toString());\n-        out.flush();\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Server thread should reply to data parcels sent by Client VM.\n-     *\/\n-    private static class Server extends Thread {\n-        \/**\n-         * The socket to listen for a client.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * Display the server socket.\n-         *\/\n-        public String toString() {\n-            return serverSocket.toString();\n-        }\n-\n-        \/**\n-         * Server's IP-address in the form ``<code><i>x.y.u.z<\/i><\/code>'',\n-         * or ``<code>127.0.0.1<\/code>'' for loopback connection.\n-         *\/\n-        public String getIPAddress() {\n-            return serverSocket.getInetAddress().getHostAddress();\n-        }\n-\n-        \/**\n-         * Which port is this socket listening?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        public Server(InetAddress address) throws IOException {\n-            int someFreePort = 0;\n-            int backlog = 50; \/\/ default for new ServerSocket(port)\n-            serverSocket = new ServerSocket(someFreePort, backlog, address);\n-        }\n-\n-        \/**\n-         * Exception just arisen while the server was working,\n-         * or <code>null<\/code> if it was OK with the server.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Accept connection, then reply to client's parcels.\n-         *\/\n-        public void run() {\n-            try {\n-                Socket socket = serverSocket.accept();\n-                socket.setSoTimeout(SO_TIMEOUT);\n-\/\/              display(\"Server: \" + socket);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Server thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"server has read unexpected parcel\");\n-                    }\n-\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Client VM should send data parcels to Server VM and\n-     * recieve and verify the server's replies.\n-     *\/\n-    private static class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-            socket.setSoTimeout(SO_TIMEOUT);\n-        }\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return socket.getPort();\n-        }\n-\n-        \/**\n-         * Establish connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Client thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-        \/**\n-         * Establish connections to lots of server sockets, atack servers with\n-         * huge data parcels, and check if it replies correctly. The addresses\n-         * and port numbers for server sockets are passed through <code>stdin<\/code>.\n-         * The input stream must consist of the stipulated number (up to 128+1) of\n-         * lines containing the pair of symbolic server domain name and the port number,\n-         * like:\n-         * <br>&nbsp;&nbsp; actual_number_of_sockets\n-         * <br>&nbsp;&nbsp; address_1 port_1\n-         * <br>&nbsp;&nbsp; address_2 port_2\n-         * <br>&nbsp;&nbsp; . . .\n-         * <br>&nbsp;&nbsp; address_N port_N\n-         * <br>where N must equal to the actual_number_of_sockets.\n-         *\/\n-        public static void main(String args[]) {\n-            \/\/ ---- Parse stdin for the list of server sockets: ---- \/\/\n-            BufferedReader in = new BufferedReader(new InputStreamReader(System.in));\n-\n-            final int CONNECTIONS;\n-            try {\n-                String line = in.readLine();\n-                if (line == null) {\n-                    complain(\"Client expects paramenets passed through stdin:\");\n-                    complain(\"    actual_number_of_sockets\");\n-                    complain(\"    IP-address_1 port_1\");\n-                    complain(\"    IP-address_2 port_2\");\n-                    complain(\"    .   .   .\");\n-                    complain(\"    IP-address_N port_N\");\n-                    exit(2); \/\/ FAILED\n-                }\n-                CONNECTIONS = Integer.parseInt(line);\n-            } catch (IOException ioe) {\n-                complain(\"Client failed to read the actual number of CONNECTIONS\");\n-                throw new RuntimeException(ioe.toString());\n-            }\n-\n-            Client client[] = new Client[CONNECTIONS];\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                try {\n-                    String line = in.readLine();\n-                    if (line == null) {\n-                        complain(\"Client: failed to read address\/port for client #\" + i);\n-                        exit(3);\n-                    }\n-\n-                    StringTokenizer tokenz = new StringTokenizer(line);\n-                    if (tokenz.countTokens() != 2) {\n-                        complain(\"Client: illegal input string: \" + line);\n-                        exit(3);\n-                    }\n-                    String serverName = (String) tokenz.nextElement();\n-                    InetAddress address = InetAddress.getByName(serverName);\n-                    int port = Integer.parseInt((String) tokenz.nextElement());\n-\n-                    client[i] = new Client(address, port);\n-\n-                    display(\"Client #\" + i + \": \" + client[i]);\n-\n-                } catch (IOException ioe) {\n-                    complain(\"Client #\" + i + \": \" + ioe);\n-                    exit(3);\n-                }\n-\n-            \/\/ ---- Start testing: ---- \/\/\n-\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                client[i].start();\n-\n-            int status = 0;\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Client: waiting for #\" + i);\n-                while (client[i].isAlive())\n-                    yield();\n-                if (client[i].exception != null) {\n-                    complain(\"Client #\" + i + \": \" + client[i].exception);\n-                    status = 2;\n-                }\n-            }\n-\n-            exit(status);\n-        }\n-\n-        \/**\n-         * Print error message.\n-         *\/\n-        private static synchronized void complain(Object message) {\n-            System.err.println(\"# \" + message);\n-            System.err.flush();\n-        }\n-\n-        \/**\n-         * Display execution trace.\n-         *\/\n-        private static synchronized void display(Object message) {\n-            if (!DEBUG_MODE)\n-                return;\n-            System.out.println(message.toString());\n-            System.out.flush();\n-        }\n-\n-        \/**\n-         * Exit with JCK-like status.\n-         *\/\n-        private static void exit(int exitCode) {\n-            System.exit(exitCode + 95);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Two of such threads should redirect <code>out<\/code> and <code>err<\/code>\n-     * streams of client VM.\n-     *\/\n-    private static class IORedirector extends Thread {\n-        \/**\n-         * Source stream.\n-         *\/\n-        InputStream in;\n-        \/**\n-         * Destination stream.\n-         *\/\n-        OutputStream out;\n-\n-        \/**\n-         * Redirect <code>in<\/code> to <code>out<\/code>.\n-         *\/\n-        public IORedirector(InputStream in, OutputStream out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-\n-        \/**\n-         * Read input stream until the EOF, and write everithing to output stream.\n-         * If output stream is assigned to <code>null<\/code>, do not print anything,\n-         * but read the input stream anywhere.\n-         *\/\n-        public void run() {\n-            try {\n-                for (; ; ) {\n-                    int symbol = in.read();\n-                    if (symbol < 0)\n-                        break; \/\/ EOF\n-                    if (out != null)\n-                        out.write(symbol);\n-                }\n-\n-                if (out != null)\n-                    out.flush();\n-\n-            } catch (Exception exception) {\n-                throw new TestFailure(\"IORedirector exception: \" + exception);\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * A data parcel to be sent\/recieved between Client VM and Server thread.\n-     * When data parcel is sent, first 4 bytes are transfered which encode the\n-     * <code>int<\/code> number equal to size of the parcel minus 1. I.e.: if\n-     * number of data bytes in the parcel's contents is <code>N<\/code>, then\n-     * the first 4 bytes encode the number <code>N-1<\/code>. After that, the\n-     * parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client may throw this exception to report the test failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network004.java","additions":0,"deletions":878,"binary":false,"changes":878,"status":"deleted"},{"patch":"@@ -1,635 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network005.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick]\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test make huge number of data transers between one server and\n- *     multiple clients communicating via TCP\/IP sockets, and checks if those\n- *     data are transfered correctly. All TCP\/IP sockets are attached to local\n- *     host (by its domain name), or to the ``localhost'' loopback (having the\n- *     IP address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a large data parcel to server,\n- *     and server reads that parcel and checks if it is same as expected\n- *     (byte-to-byte equality is desired). Then server passes (some other) parcel\n- *     to the client, and client reads and verifies those bytes. This ping-pong\n- *     game is repeated 128 times; and after that each pair of sockets checks if\n- *     there are no extra bytes accudentally passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel\n- *     length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- *     data to each other, and thus ~32Kb of data are transfered by each sockets\n- *     pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- * COMMENTS\n- *\n- * @run main\/othervm nsk.stress.network.network005\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test make huge number of data transers between one server and\n- * multiple clients communicating via TCP\/IP sockets, and checks if those\n- * data are transfered correctly. All TCP\/IP sockets are attached to local\n- * host (by its domain name), or to the ``localhost'' loopback (having the\n- * IP address 127.0.0.1).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a large data parcel to server,\n- * and server reads that parcel and checks if it is same as expected\n- * (byte-to-byte equality is desired). Then server passes (some other) parcel\n- * to the client, and client reads and verifies those bytes. This ping-pong\n- * game is repeated 128 times; and after that each pair of sockets checks if\n- * there are no extra bytes accudentally passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel\n- * length is 128 bytes. So totally, each pair of sockets passes ~16Kb of\n- * data to each other, and thus ~32Kb of data are transfered by each sockets\n- * pair. Totally, ~4Mb of data are transfered by all client\/server pairs.\n- *\/\n-public class network005 {\n-    \/**\n-     * Do actually display optional reports?\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * Errors and optional reports log. Usually <code>System.out<\/code>.\n-     *\/\n-    static private PrintStream out = System.out;\n-\n-    \/**\n-     * Print error message: all clients and servers may print concurently.\n-     *\/\n-    static private synchronized void println(Object message) {\n-        out.println(message.toString());\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va.\n-     *\/\n-    static private void display(Object report) {\n-        if (DEBUG_MODE)\n-            println(report.toString());\n-    }\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * Number of client\/server connections to establish.\n-     *\/\n-    private static final int CONNECTIONS = detectOSLimitation();\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private static final int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private static final int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-\n-        InetAddress address;\n-        ServerSocket serverSocket;\n-        try {\n-            address = InetAddress.getLocalHost();\n-            int anyPort = 0;\n-            int defaultBacklog = 50;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException ioe) {\n-            throw new Error(\"FATAL error while loading the test: \" + ioe);\n-        }\n-        display(serverSocket.toString());\n-\n-        Socket server[] = new Socket[CONNECTIONS_TO_TRY];\n-        Socket client[] = new Socket[CONNECTIONS_TO_TRY];\n-\n-        int i, port = serverSocket.getLocalPort();\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                client[i] = new Socket(address, port);\n-                display(\"--- Open: client[\" + i + \"] = \" + client[i]);\n-                server[i] = serverSocket.accept();\n-                display(\"--- Open: server[\" + i + \"] = \" + server[i]);\n-            } catch (IOException ioe) {\n-                display(\"--- OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"--- Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\"--- Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                server[j].close();\n-                client[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\"--- OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            println(\"# ------------------------- CAUTION: -------------------\");\n-            println(\"# While checking the OS limitations, the test found that\");\n-            println(\"# only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            println(\"# simultaneously. However, possibility to open at least\");\n-            println(\"# \" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            println(\"# \");\n-            println(\"# So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            println(\"# safe to be open simultaneously.\");\n-            println(\"# ------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/**\n-     * Server (or client) thread intended to transfer data parcels to\n-     * another client (or server) Agent.\n-     *\/\n-    static private class Agent extends Thread {\n-        \/**\n-         * Agent's client mode.\n-         *\/\n-        final static int CLIENT = 1;\n-        \/**\n-         * Agen's server mode.\n-         *\/\n-        final static int SERVER = 2;\n-\n-        \/**\n-         * Is this agent is client or server one?\n-         *\/\n-        private int mode;\n-\n-        \/**\n-         * This server thread listens the single socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            if (mode == SERVER)\n-                return socket.getLocalPort();\n-            else\n-                return socket.getPort();\n-        }\n-\n-        \/**\n-         * Address and port of this server socket.\n-         *\/\n-        public String toString() {\n-            String mode = (this.mode == CLIENT) ? \"Client\" : \"Server\";\n-            return mode + \": \" + socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port.\n-         *\/\n-        Agent(Socket socket, int mode) {\n-            if ((mode != SERVER) && (mode != CLIENT))\n-                throw new IllegalArgumentException(\"unknown mode=\" + mode);\n-            this.socket = socket;\n-            this.mode = mode;\n-        }\n-\n-        \/**\n-         * Transfer <code>DATA_PARCELS<\/code> parcels of random data.\n-         * Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-\n-                    if (mode == SERVER) {\n-                        Parcel sample = new Parcel(istream); \/\/ read\n-                        if (!sample.equals(etalon)) {\n-                            println(\"Server agent for port #\"\n-                                    + getPort() + \" got unexpected parcel:\\n\"\n-                                    + \"sample=\" + sample + \"\\n\"\n-                                    + \"etalon=\" + etalon);\n-                            throw new TestFailure(\n-                                    \"server has read unexpected parcel\");\n-                        }\n-\n-                        etalon.send(ostream);                \/\/ reply\n-                        ostream.flush();\n-\n-                    } else {\n-                        etalon.send(ostream);                \/\/ init transfer\n-                        ostream.flush();\n-\n-                        Parcel sample = new Parcel(istream); \/\/ read\n-                        if (!sample.equals(etalon)) {\n-                            println(\"Client agent for port #\"\n-                                    + getPort() + \" got unexpected parcel:\\n\"\n-                                    + \"sample=\" + sample + \"\\n\"\n-                                    + \"etalon=\" + etalon);\n-                            throw new TestFailure(\n-                                    \"parcel context is unexpected to client\");\n-                        }\n-                    }\n-                }\n-\n-                if (mode == SERVER) {\n-                    int datum = istream.read(); \/\/ wait until client's close()\n-                    if (datum >= 0)\n-                        throw new TestFailure(\n-                                \"server has read ambigous byte: \" + datum);\n-\n-                    ostream.close(); \/\/ implies: socket.close();\n-\n-                } else {\n-                    if (istream.available() > 0) {\n-                        int datum = istream.read();\n-                        throw new TestFailure(\n-                                \"client has read ambigous byte: \" + datum);\n-                    }\n-                    ostream.close(); \/\/ implies: socket.close()\n-                }\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-    }\n-\n-    \/**\n-     * A data parcel to sent\/recieved between Client and Server threads.\n-     * When data parcel is sent, first 4 bytes transfered encode the size\n-     * of the parcel (i.e.: number of data bytes in the parcel's contents).\n-     * Then the parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-\n-    }\n-\n-    \/**\n-     * Server or Client thread may throw this exception to report the test\n-     * failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-\n-    }\n-\n-    \/**\n-     * Attach client and server sockets to the local host, and check if\n-     * huge number of data transfers could be correctly transfered between\n-     * these sockets.\n-     * <p>\n-     * <p>Command-line parameters provided with <code>args[]<\/code> may\n-     * prompt the local host IP address or domain name. Execute:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network005 [<i>IP-address<\/i> | <i>host_name<\/i> |\n-     * localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <br>By default, the test uses the Internet address available via\n-     * the method <code>InetAddress.getLocalHost()<\/code>\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network005.out = out;\n-\n-        \/\/\n-        \/\/ Get IP address of the local machine.\n-        \/\/\n-\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 0:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 1:\n-                    String hostName = args[0];\n-                    address = InetAddress.getByName(args[0]);\n-                    break;\n-                default:\n-                    println(\"Use:\");\n-                    println(\"    java network005\");\n-                    println(\"or:\");\n-                    println(\"    java network005 ${IP_ADDRESS}\");\n-                    println(\"or:\");\n-                    println(\"    java network005 ${HOST_NAME}\");\n-                    println(\"or:\");\n-                    println(\"    java network005 localhost\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            println(exception);\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Assign ServerSocket to the local host:\n-        \/\/\n-\n-        ServerSocket serverSocket;\n-        try {\n-            final int anyPort = 0;\n-            final int defaultBacklog = 50;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException ioe) {\n-            println(\"# Failed to assign ServerSocket on: \" + address);\n-            return 2;\n-        }\n-        display(serverSocket.toString());\n-\n-        final int port = serverSocket.getLocalPort();\n-\n-        \/\/\n-        \/\/ Incarnate the server & the client agents.\n-        \/\/\n-\n-        Agent server[] = new Agent[CONNECTIONS];\n-        Agent client[] = new Agent[CONNECTIONS];\n-\n-        for (int i = 0; i < CONNECTIONS; i++)\n-            try {\n-                Socket socket;\n-                socket = new Socket(address, port);\n-                client[i] = new Agent(socket, Agent.CLIENT);\n-                display(\"Client #\" + i + \": \" + socket);\n-                socket = serverSocket.accept();\n-                server[i] = new Agent(socket, Agent.SERVER);\n-                display(\"Server #\" + i + \": \" + socket);\n-            } catch (IOException io) {\n-                println(\"Failed establish conection #\" + i + \": \" + io);\n-                return 2;\n-            }\n-\n-        \/\/\n-        \/\/ Execute the server and client threads.\n-        \/\/\n-\n-        Exception exception = null;\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            server[i].start();\n-            client[i].start();\n-        }\n-        try {\n-            boolean someIsAlive = true;\n-            while (someIsAlive) {\n-                boolean aliveFound = false;\n-                boolean someBroken = false;\n-                for (int i = 0; i < CONNECTIONS; i++)\n-                    if (client[i].isAlive() || server[i].isAlive()) {\n-                        if ((client[i].exception != null) ||\n-                                (server[i].exception != null))\n-                            someBroken = true;\n-                        aliveFound = true;\n-                        Thread.yield();\n-                    }\n-                someIsAlive = aliveFound;\n-                if (someBroken)\n-                    break;\n-            }\n-        } catch (TestFailure failure) {\n-            exception = failure;\n-        }\n-\n-        \/\/ Failure diagnostics, if needed.\n-\n-        Exception problem[] = new Exception[2 * CONNECTIONS + 1];\n-        problem[0] = exception;\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            problem[2 * i + 1] = server[i].exception;\n-            problem[2 * i + 2] = client[i].exception;\n-        }\n-\n-        int exitCode = 0;\n-\n-        for (int i = 0; i < 2 * CONNECTIONS + 1; i++)\n-            if (problem[i] != null) {\n-                out.println(\"#### OOPS ! ####\");\n-                problem[i].printStackTrace(out);\n-                exitCode = 2;\n-            }\n-\n-        if (exitCode != 0) {\n-            out.println(\"#### OOPS ! ####\");\n-            out.println(\"# Test failed.\");\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Test passed.\");\n-        return 0; \/\/ PASSED\n-    }\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test; and stop with exit code 95 if the test\n-     * has passed, or with code 97 if the test has failed.\n-     * (This is JCK-like exit codes convention.)\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit code.\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network005.java","additions":0,"deletions":635,"binary":false,"changes":635,"status":"deleted"},{"patch":"@@ -1,916 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n- * @test\n- * @key stress\n- *\n- * @summary converted from VM testbase nsk\/stress\/network\/network006.\n- * VM testbase keywords: [stress, slow, nonconcurrent, quick, quarantine]\n- * VM testbase comments: 8185072\n- * VM testbase readme:\n- * DESCRIPTION\n- *     This test makes huge number of data transfers between 2 Java virtual\n- *     machines using the TCP\/IP protocol, and checks if those data are transfered\n- *     correctly. Both client and server VMs run on the same local computer and\n- *     attach TCP\/IP sockets to the local host, or to the loopback domain\n- *     ``localhost'' (having IP address 127.0.0.1).\n- *     In this test, 128 client\/server connections are established. Once a\n- *     connection is established, client passes a data parcel to server, and server\n- *     reads that parcel and checks if it is same as expected (byte-to-byte equality\n- *     is desired). Then server passes (some other) parcel to the client, and client\n- *     reads and verifies those bytes. This ping-pong game is repeated 128 times; and\n- *     after that each pair of sockets checks if there are no extra bytes accudentally\n- *     passed through their connection.\n- *     Parcels lengths and contents are chosen randomly, and average parcel length\n- *     is 128 bytes. So totally, each pair of sockets passes ~16Kb of data to each other,\n- *     and thus ~32Kb of data are transfered by each sockets pair. Totally, ~4Mb of data\n- *     are transfered by all client\/server pairs.\n- * COMMENTS\n- *     Test was fixed:\n- *     added WAITTIME parameter defined timeout for TCP\/IP sockets in minutes\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run driver jdk.test.lib.FileInstaller . .\n- * @build nsk.stress.network.network006\n- * @run main\/othervm PropertyResolvingWrapper\n- *      nsk.stress.network.network006\n- *      \"${test.jdk}\/bin\/java ${test.vm.opts} ${test.java.opts}\" 5\n- *\/\n-\n-package nsk.stress.network;\n-\n-import java.io.FileNotFoundException;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.io.PrintStream;\n-import java.net.InetAddress;\n-import java.net.ServerSocket;\n-import java.net.Socket;\n-import java.net.UnknownHostException;\n-import java.util.Random;\n-\n-\/**\n- * This test makes huge number of data transfers between 2 Java virtual\n- * machines using the TCP\/IP protocol, and checks if those data are transfered\n- * correctly. Both client and server VMs run on the same local computer and\n- * attach TCP\/IP sockets to the local host, or to the loopback domain\n- * ``<code>localhost<\/code>'' (having IP address <code>127.0.0.1<\/code>).\n- * <p>\n- * <p>In this test, 128 client\/server connections are established. Once a\n- * connection is established, client passes a data parcel to server, and server\n- * reads that parcel and checks if it is same as expected (byte-to-byte equality\n- * is desired). Then server passes (some other) parcel to the client, and client\n- * reads and verifies those bytes. This ping-pong game is repeated 128 times; and\n- * after that each pair of sockets checks if there are no extra bytes accudentally\n- * passed through their connection.\n- * <p>\n- * <p>Parcels lengths and contents are chosen randomly, and average parcel length\n- * is 128 bytes. So totally, each pair of sockets passes ~16Kb of data to each other,\n- * and thus ~32Kb of data are transfered by each sockets pair. Totally, ~4Mb of data\n- * are transfered by all client\/server pairs.\n- *\/\n-public class network006 {\n-    \/**\n-     * Timeout for TCP\/IP sockets (currently set to 1 min).\n-     *\/\n-    private static int SO_TIMEOUT;\/\/ = 2*60*1000;\n-\n-    \/**\n-     * Maximal number of connections this test should open simultaneously.\n-     *\/\n-    private final static int MAX_CONNECTIONS = 128;\n-\n-    \/**\n-     * Check few more connections to make sure that MAX_CONNECTIONS are safe.\n-     *\/\n-    private final static int CONNECTIONS_RESERVE = 10;\n-\n-    \/**\n-     * The test used to fail with connection reset by peer set to 50.\n-     * (and once in a three if it was set to 10).\n-     * So now we set it to MAX_CONNECTIONS (128).\n-     *\/\n-    private final static int BACKLOG_QUEUE_LENGTH = MAX_CONNECTIONS;\n-\n-    \/**\n-     * Number of parcels to be sent\/recieved.\n-     *\/\n-    private final static int DATA_PARCELS = 128;\n-\n-    \/**\n-     * Maximal length of data parcel to be sent\/recieved\n-     * (it equals to 256 bytes now).\n-     *\/\n-    private final static int MAX_PARCEL = 1 << 8;\n-\n-    \/**\n-     * Either actually display optional reports or not.\n-     *\/\n-    static private final boolean DEBUG_MODE = false;\n-\n-    \/**\n-     * How many IP sockets can we open simultaneously?\n-     * Check if <code>MAX_CONNECTIONS<\/code> connections\n-     * can be open simultaneously.\n-     *\/\n-    private static int detectOSLimitation() {\n-        final int CONNECTIONS_TO_TRY = MAX_CONNECTIONS + CONNECTIONS_RESERVE;\n-        display(\"--- Trying to open \" + CONNECTIONS_TO_TRY + \" connections:\");\n-\n-        InetAddress address;\n-        ServerSocket serverSocket;\n-        try {\n-            address = InetAddress.getLocalHost();\n-            int anyPort = 0;\n-            int defaultBacklog = BACKLOG_QUEUE_LENGTH;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException ioe) {\n-            throw new Error(\"FATAL error while loading the test: \" + ioe);\n-        }\n-        display(serverSocket.toString());\n-\n-        Socket server[] = new Socket[CONNECTIONS_TO_TRY];\n-        Socket client[] = new Socket[CONNECTIONS_TO_TRY];\n-\n-        int i, port = serverSocket.getLocalPort();\n-        for (i = 0; i < CONNECTIONS_TO_TRY; i++)\n-            try {\n-                client[i] = new Socket(address, port);\n-                display(\">Open: client[\" + i + \"] = \" + client[i]);\n-                server[i] = serverSocket.accept();\n-                display(\">Open: server[\" + i + \"] = \" + server[i]);\n-            } catch (IOException ioe) {\n-                display(\">OOPS! -- failed to open connection #\" + i);\n-                break;\n-            }\n-        display(\"> Could open \" +\n-                (i < CONNECTIONS_TO_TRY ? \"only \" : \"\") + i + \" connections.\");\n-        display(\">Closing them:\");\n-        for (int j = 0; j < i; j++)\n-            try {\n-                server[j].close();\n-                client[j].close();\n-            } catch (IOException ioe) {\n-                throw new Error(\"FATAL error while loading the test: \" + ioe);\n-            }\n-        display(\">OK.\");\n-        int safeConnections = i - CONNECTIONS_RESERVE;\n-        if (safeConnections < 1)\n-            safeConnections = 1;\n-        if (safeConnections < MAX_CONNECTIONS) {\n-            complain(\"------------------------- CAUTION: -------------------\");\n-            complain(\"While checking the OS limitations, the test found that\");\n-            complain(\"only \" + i + \" TCP\/IP socket connections could be safely open\");\n-            complain(\"simultaneously. However, possibility to open at least\");\n-            complain(\"\" + MAX_CONNECTIONS + \"+\" + CONNECTIONS_RESERVE\n-                    + \" connections were expected.\");\n-            complain(\"\");\n-            complain(\"So, the test will check only \" + safeConnections + \" connection\"\n-                    + (safeConnections == 1 ? \"\" : \"s\") + \" which seem\");\n-            complain(\"safe to be open simultaneously.\");\n-            complain(\"------------------------------------------------------\");\n-        }\n-        return safeConnections;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Re-calls to the method <code>run(args[],out)<\/code> actually\n-     * performing the test. After <code>run(args[],out)<\/code> stops,\n-     * follow JDK-like convention for exit codes. I.e.: stop with\n-     * exit status 95 if the test has passed, or with status 97 if\n-     * the test has failed.\n-     *\n-     * @see #run(String[], PrintStream)\n-     *\/\n-    public static void main(String args[]) {\n-        int exitCode = run(args, System.out);\n-        System.exit(exitCode + 95);\n-        \/\/ JCK-like exit status.\n-    }\n-\n-    \/**\n-     * Parse command-line parameters stored into <code>args[]<\/code> array,\n-     * then perform the test. I.e.: start the server thread at the same VM\n-     * this method runs, then start the other client VM, and verify data\n-     * transfer through TCP\/IP connection between those different virtual\n-     * machines.\n-     * <p>\n-     * <p>There should be 2 or 3 command-line parameters:\n-     * <br>&nbsp;&nbsp;\n-     * <code>java network006 <i>java_command<\/i>\n-     * [<i>IP-address<\/i> | <i>host_name<\/i> | localhost ]<\/code>\n-     * <br>where parameters are:\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>java_command<\/i><\/code> - how to start java,\n-     * e.g.: ``<code>c:\\jdk1.3\\bin\\java -classic<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>waittime<\/code> - timeout for TCP\/IP sockets in minutes\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>IP-address<\/i><\/code> - local hots's address, or 127.0.0.1\n-     * <br>&nbsp;&nbsp;\n-     * <code><i>host_name<\/i><\/code> - local host's domain name, or the\n-     * keyword ``<code>localhost<\/code>''\n-     * <br>&nbsp;&nbsp;\n-     * <code>localhost<\/code> - placeholder for the IP-address 127.0.0.1\n-     * <p>\n-     * <p>Usually, <code><i>java_command<\/i><\/code> should point to the same\n-     * Java machine just executing this test. However, every compatible Java 2\n-     * implementation is appropriate.\n-     * <p>\n-     * <p>If optional parameter is ommited, the test invokes the method\n-     * <code>InetAddress.getLocalHost()<\/code> to get the domain name and\n-     * IP-address of the local computer.\n-     *\/\n-    public static int run(String args[], PrintStream out) {\n-        network006.out = out;\n-\n-        \/\/\n-        \/\/ Get the Internet address of the local machine.\n-        \/\/\n-        InetAddress address = null;\n-        try {\n-            switch (args.length) {\n-                case 2:\n-                    address = InetAddress.getLocalHost();\n-                    break;\n-                case 3:\n-                    address = InetAddress.getByName(args[2]);\n-                    break;\n-                default:\n-                    complain(\"Illegal arguments number; execute:\");\n-                    complain(\"    java \" + network006.class.getName() + \" $JAVA_COMMAND \" +\n-                            \"[$IP_ADDRESS | $HOST_NAME | localhost]\");\n-                    return 2; \/\/ FAILED\n-            }\n-        } catch (UnknownHostException exception) {\n-            complain(exception.toString());\n-            return 2; \/\/ FAILED\n-        }\n-        display(\"Host: \" + address);\n-\n-        \/\/\n-        \/\/ Detect if it is safe to open MAX_CONNETIONS simultaneously:\n-        \/\/\n-        final int CONNECTIONS = detectOSLimitation();\n-\n-        \/\/\n-        \/\/ Assign ServerSocket, and start client VM which should open\n-        \/\/ the prescribed number of CONNECTIONS to that ServerSocket.\n-        \/\/\n-\n-        ServerSocket serverSocket;\n-        try {\n-            final int anyPort = 0;\n-            final int defaultBacklog = BACKLOG_QUEUE_LENGTH;\n-            serverSocket = new ServerSocket(anyPort, defaultBacklog, address);\n-        } catch (IOException exception) {\n-            complain(\"Cannot assign a ServerSocket on: \" + address);\n-            return 2;\n-        }\n-\n-        \/\/\n-        \/\/ Start the client process on different VM.\n-        \/\/\n-\n-        String IPAddress = address.getHostAddress();\n-        int localPort = serverSocket.getLocalPort();\n-        String arguments = \" \" + CONNECTIONS + \" \" + IPAddress + \" \" + localPort;\n-        \/\/String command = args[0] + \" \" + network006.class.getName() + \"$Client \" + arguments;\n-        String command = args[0] + \" \" + Client.class.getName() + \" \" + arguments;\n-        try {\n-            SO_TIMEOUT = Integer.parseInt(args[1]) * 60 * 1000;\n-        } catch (NumberFormatException e) {\n-            complain(\"Wrong timeout argument: \" + e);\n-            return 2;\n-        }\n-\n-        Runtime runtime = Runtime.getRuntime();\n-\n-        Process client = null;\n-        IORedirector redirectOut = null;\n-        IORedirector redirectErr = null;\n-\n-        try {\n-            \/\/ Start clients on different JVM:\n-            client = runtime.exec(command);\n-\n-            \/\/ Provide clients with access to stderr and stdout:\n-            InputStream clientOut = client.getInputStream();\n-            InputStream clientErr = client.getErrorStream();\n-            redirectOut = new IORedirector(clientOut, DEBUG_MODE ? out : null);\n-            redirectErr = new IORedirector(clientErr, out);\n-            redirectOut.start();\n-            redirectErr.start();\n-\n-        } catch (Exception exception) {\n-            complain(\"Failed to start client: \" + exception);\n-            return 2;\n-        }\n-        \/\/\n-        \/\/ Start the server threads (and let them establish connections):\n-        \/\/\n-\n-        Server server[] = new Server[CONNECTIONS];\n-        for (int i = 0; i < CONNECTIONS; i++) {\n-            server[i] = new Server(serverSocket);\n-            display(\"Server #\" + i + \": \" + server[i]);\n-            server[i].start();\n-        }\n-\n-        \/\/\n-        \/\/ Wait for the servers and the clients:\n-        \/\/\n-\n-        boolean testFailed = false;\n-\n-        try {\n-            client.waitFor();\n-            int clientStatus = client.exitValue();\n-            display(\"Client VM exitCode=\" + clientStatus);\n-\n-            \/\/ Let I\/O redirectors to flush:\n-            if (redirectOut.isAlive())\n-                redirectOut.join();\n-            if (redirectErr.isAlive())\n-                redirectErr.join();\n-\n-            \/\/ If client has crashed, also terminate the server (to avoid hangup).\n-            if (clientStatus != 95) {\n-                complain(\"Client VM has crashed: exit status=\" + clientStatus);\n-                testFailed = true;\n-            }\n-\n-            \/\/ Client has finished OK; wait for the server.\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Server: waiting for #\" + i);\n-                if (server[i].isAlive()) {\n-                    display(\"Server #\" + i + \": (joining...)\" + server[i]);\n-                    server[i].join();\n-                }\n-                if (server[i].exception != null) {\n-                    if (server[i].message != null)\n-                        complain(\"Server #\" + i + \"(finished): with message:\" + server[i].message);\n-\n-                    complain(\"Server #\" + i + \"(finished): \" + server[i].exception);\n-                    server[i].exception.printStackTrace(out);\n-                    out.flush();\n-\/\/                    complain(\"Server #\"+i+\": \"+server[i].exception.getStackTrace());\n-                    testFailed = true;\n-                }\n-            }\n-\n-        } catch (Exception exception) {\n-            complain(\"Test interrupted: \" + exception);\n-            testFailed = true;\n-        }\n-\n-        if (testFailed)\n-            complain(\"Test failed.\");\n-        else\n-            display(\"Test passed.\");\n-        return testFailed ? 2 : 0;\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Log stream for error messages and\/or (optional) execution trace.\n-     *\/\n-    private static PrintStream out;\n-\n-    \/**\n-     * Print error message.\n-     *\/\n-    private static synchronized void complain(Object message) {\n-        out.println(\"# \" + message);\n-        out.flush();\n-    }\n-\n-    \/**\n-     * Display optional report: comment ca va?\n-     *\/\n-    private static synchronized void display(Object report) {\n-        if (DEBUG_MODE)\n-            out.println(report.toString());\n-        out.flush(); \/\/todo shouldn't this be inside if??\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Server thread should reply to data parcels sent by Client VM.\n-     *\/\n-    private static class Server extends Thread {\n-        \/**\n-         * The socket is assigned at the Server instantiation.\n-         *\/\n-        private ServerSocket serverSocket;\n-\n-        \/**\n-         * The socket is assigned at the Server runtime.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Display the server socket.\n-         *\/\n-        public String toString() {\n-\n-            return \"ServerSocket: \" + serverSocket.toString();\n-\/\/                    + \" socket: \" + socket.toString();\n-        }\n-\n-        \/**\n-         * Which port is this socket listening?\n-         *\/\n-        int getPort() {\n-            return serverSocket.getLocalPort();\n-        }\n-\n-        \/**\n-         * Find some free port at the given <code>address<\/code>\n-         * and attach new server to hear that port. \/\/ lidsten to??\n-         *\/\n-        public Server(ServerSocket serverSocket) {\n-            this.serverSocket = serverSocket;\n-        }\n-\n-        \/**\n-         * Exception just arisen while the server was working,\n-         * or <code>null<\/code> if it was OK with the server.\n-         *\/\n-        Exception exception = null;\n-        String message = null;\n-\n-        \/**\n-         * Accept connection, then reply to client's parcels.\n-         *\/\n-        public void run() {\n-            try {\n-                socket = serverSocket.accept();\n-                socket.setSoTimeout(SO_TIMEOUT);\n-\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    message = \"reading parcel number \" + i;\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Server thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(  \/\/received??\n-                                \"server has read unexpected parcel\");\n-                    }\n-                    message = \"sending parcel number \" + i;\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-                }\n-\n-                int datum = istream.read(); \/\/ wait for client close()\n-                if (datum >= 0)\n-                    throw new TestFailure(\n-                            \"server has read ambigous byte: \" + datum);\n-\n-                ostream.close(); \/\/ implies: socket.close();\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * Client VM should send data parcels to Server VM and\n-     * recieve and verify the server's replies.\n-     *\/\n-    private static class Client extends Thread {\n-        \/**\n-         * This thread uses the single client socket.\n-         *\/\n-        private Socket socket;\n-\n-        \/**\n-         * Address and port of this socket.\n-         *\/\n-        public String toString() {\n-            return socket.toString();\n-        }\n-\n-        \/**\n-         * Did the thread failed? If yes, what is the failure's reason.\n-         *\/\n-        Exception exception = null;\n-        String message = null;\n-\n-\n-        public static java.io.PrintStream complainStream = System.out;\n-        public static java.io.PrintStream displayStream = System.err;\n-\n-        \/**\n-         * Connect client socket on the given <code>address<\/code>\n-         * and <code>port<\/code>.\n-         *\/\n-        Client(InetAddress address, int port) throws IOException {\n-            socket = new Socket(address, port);\n-            socket.setSoTimeout(SO_TIMEOUT);\n-        }\n-\n-        \/**\n-         * What is the port number this socket is listening for?\n-         *\/\n-        int getPort() {\n-            return socket.getPort();\n-        }\n-\n-        \/**\n-         * Establish connection, then read\/respond <code>DATA_PARCELS<\/code> parcels\n-         * of random data. Set initial seed for pseudo-random numbers generator\n-         * to the value of the local port number.\n-         *\n-         * @see #DATA_PARCELS\n-         * @see #getPort()\n-         *\/\n-        public void run() {\n-            try {\n-                InputStream istream = socket.getInputStream();\n-                OutputStream ostream = socket.getOutputStream();\n-\n-                Random random = new Random(getPort());\n-                \/\/ suggested by Oleg -- to avoid race conditions\n-               \/* try{\n-                    Thread.sleep(500);\n-                }\n-                catch (java.lang.InterruptedException e)\n-                {\n-                }*\/\n-\n-                for (int i = 0; i < DATA_PARCELS; i++) {\n-                    Parcel etalon = new Parcel(random);\n-                    message = \"sending parcel number: \" + i;\n-                    etalon.send(ostream);\n-                    ostream.flush();\n-\n-                    message = \"reading parcel number: \" + i;\n-                    Parcel sample = new Parcel(istream); \/\/ read\n-                    if (!sample.equals(etalon)) {\n-                        complain(\"Client thread for port #\"\n-                                + getPort() + \" got unexpected parcel:\\n\"\n-                                + \"sample=\" + sample + \"\\n\"\n-                                + \"etalon=\" + etalon);\n-                        throw new TestFailure(\n-                                \"parcel context is unexpected to client\");\n-                    }\n-                }\n-\n-                if (istream.available() > 0) {\n-                    int datum = istream.read();\n-                    throw new TestFailure(\n-                            \"client has read ambigous byte: \" + datum);\n-                }\n-                ostream.close(); \/\/ implies: socket.close()\n-\n-            } catch (Exception oops) {\n-                exception = oops;\n-            }\n-        }\n-\n-        \/**\n-         * Establish lots of connections to server socket, attack servers with\n-         * huge data parcels, and check if they reply correctly. The number of\n-         * connections to try, the address and port number for the server socket\n-         * are passed through <code>args[]<\/code>, like:\n-         * <pre>\n-         *    java network006$Client connections_to_try address port\n-         * <\/pre>\n-         *\/\n-        public static void main(String args[]) {\n-            if (DEBUG_MODE) {\n-                try {\n-                    String filename = \"Client\" + ((args.length == 3) ? args[2] : \"new\");\n-                    displayStream = new PrintStream(filename + \".out\");\n-                    complainStream = new PrintStream(filename + \".err\");\n-                } catch (FileNotFoundException exception) {\n-                    complain(exception);\n-                }\n-\n-            }\n-\n-            if (args.length != 3) {\n-                complain(\"Client expects 3 paramenets:\");\n-                complain(\"    java \" + Client.class.getName() + \" connections_to_try address port\");\n-                exit(1); \/\/ FAILED\n-            }\n-\n-            int CONNECTIONS = Integer.parseInt(args[0]);\n-            display(\"Client VM: will try \" + CONNECTIONS + \" connections.\");\n-            InetAddress address;\n-            try {\n-                address = InetAddress.getByName(args[1]);\n-            } catch (UnknownHostException exception) {\n-                address = null;\n-                complain(\"Client: cannot find host: \\\"\" + args[1] + \"\\\"\");\n-                exit(4);\n-            }\n-            display(\"Client: host to contact: \" + address);\n-            int port = Integer.parseInt(args[2]);\n-            display(\"Client: port to contact: \" + port);\n-\n-            \/\/\n-            \/\/ Establish connections, and start client processes:\n-            \/\/\n-\n-            Client client[] = new Client[CONNECTIONS];\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                try {\n-                    client[i] = new Client(address, port);\n-                    display(\"Client #\" + i + \": \" + client[i]);\n-\n-                } catch (IOException ioe) {\n-                    complain(\"Client #\" + i + \"(creation): \" + ioe);\n-                    ioe.printStackTrace(complainStream);\n-                    complainStream.flush();\n-\/\/                    complain(\"Client #\" + i + \"(creation): \" + ioe.getStackTrace());\n-                    exit(3);\n-                }\n-\n-            for (int i = 0; i < CONNECTIONS; i++)\n-                client[i].start();\n-\n-            \/\/\n-            \/\/ Wait until testing is not finished:\n-            \/\/\n-\n-            int status = 0;\n-            for (int i = 0; i < CONNECTIONS; i++) {\n-                display(\"Client: waiting for #\" + i);\n-                if (client[i].isAlive()) {\n-                    display(\"Client #\" + i + \": (joining...)\" + client[i]);\n-\n-                    try {\n-                        client[i].join();\n-                    } catch (InterruptedException ie) {\n-                        complain(\"Client #\" + i + \": \" + ie);\n-                        status = 3;\n-                    }\n-                }\n-                if (client[i].exception != null) {\n-                    if (client[i].message != null)\n-                        complain(\"Client #\" + i + \"(finished) with message: \" + client[i].message);\n-                    complain(\"Client #\" + i + \"(finished): \" + client[i].exception);\n-                    client[i].exception.printStackTrace(complainStream);\n-                    complainStream.flush();\n-                    if (status == 0)\n-                        status = 2;\n-                }\n-            }\n-\n-            exit(status);\n-        }\n-\n-        \/**\n-         * Print error message.\n-         *\/\n-        private static synchronized void complain(Object message) {\n-            complainStream.println(\"# \" + message);\n-            complainStream.flush();\n-        }\n-\n-        \/**\n-         * Display execution trace.\n-         *\/\n-        private static synchronized void display(Object message) {\n-            if (!DEBUG_MODE)\n-                return;\n-            displayStream.println(message.toString());\n-            displayStream.flush();\n-        }\n-\n-        \/**\n-         * Exit with JCK-like status.\n-         *\/\n-        private static void exit(int exitCode) {\n-            int status = exitCode + 95;\n-\/\/          display(\"Client: exiting with code=\" + status);\n-            System.exit(status);\n-        }\n-    }\n-\n-    \/**\n-     * Two of such threads should redirect <code>out<\/code> and <code>err<\/code>\n-     * streams of client VM.\n-     *\/\n-    private static class IORedirector extends Thread {\n-        \/**\n-         * Source stream.\n-         *\/\n-        InputStream in;\n-        \/**\n-         * Destination stream.\n-         *\/\n-        OutputStream out;\n-\n-        \/**\n-         * Redirect <code>in<\/code> to <code>out<\/code>.\n-         *\/\n-        public IORedirector(InputStream in, OutputStream out) {\n-            this.in = in;\n-            this.out = out;\n-        }\n-\n-        \/**\n-         * Read input stream until the EOF, and write everithing to output stream.\n-         * If output stream is assigned to <code>null<\/code>, do not print anything,\n-         * but read the input stream anywhere.\n-         *\/\n-        public void run() {\n-            try {\n-                for (; ; ) {\n-                    int symbol = in.read();\n-                    if (symbol < 0)\n-                        break; \/\/ EOF\n-                    if (out != null)\n-                        out.write(symbol);\n-                }\n-\n-                if (out != null)\n-                    out.flush();\n-\n-            } catch (Exception exception) {\n-                throw new TestFailure(\"IORedirector exception: \" + exception);\n-            }\n-        }\n-    }\n-\n-    \/\/----------------------------------------------------------------\/\/\n-\n-    \/**\n-     * A data parcel to be sent\/recieved between Client VM and Server thread.\n-     * When data parcel is sent, first 4 bytes are transfered which encode the\n-     * <code>int<\/code> number equal to size of the parcel minus 1. I.e.: if\n-     * number of data bytes in the parcel's contents is <code>N<\/code>, then\n-     * the first 4 bytes encode the number <code>N-1<\/code>. After that, the\n-     * parcel's contents bytes are transered.\n-     *\/\n-    static class Parcel {\n-        private byte[] parcel;\n-\n-        \/**\n-         * Display all bytes as integer values from 0 to 255;\n-         * or return ``<tt>null<\/tt>'' if this Parcel is not\n-         * yet initialized.\n-         *\/\n-        public String toString() {\n-            if (parcel == null)\n-                return \"null\";\n-            String s = \"{\";\n-            for (int i = 0; i < parcel.length; i++)\n-                s += (i > 0 ? \", \" : \"\") + ((int) parcel[i] & 0xFF);\n-            return s + \"}\";\n-        }\n-\n-        \/**\n-         * Generate new <code>parcel[]<\/code> array using the given\n-         * <code>random<\/code> numbers generator. Client and Server\n-         * threads should use identical <code>random<\/code> generators,\n-         * so that those threads could generate equal data parcels and\n-         * check the parcel just transfered.\n-         *\/\n-        public Parcel(Random random) {\n-            int size = random.nextInt(MAX_PARCEL) + 1;\n-            parcel = new byte[size];\n-            for (int i = 0; i < size; i++)\n-                parcel[i] = (byte) random.nextInt(256);\n-        }\n-\n-        \/**\n-         * Read exactly <code>size<\/code> bytes from the <code>istream<\/code>\n-         * if possible, or throw <code>TestFailure<\/code> if unexpected end of\n-         * <code>istream<\/code> occurs.\n-         *\/\n-        private static byte[] readBytes(int size, InputStream istream)\n-                throws IOException {\n-\n-            byte data[] = new byte[size];\n-            for (int i = 0; i < size; i++) {\n-                int datum = istream.read();\n-                if (datum < 0)\n-                    throw new TestFailure(\n-                            \"unexpected EOF: have read: \" + i + \" bytes of \" + size);\n-                data[i] = (byte) datum;\n-            }\n-            return data;\n-        }\n-\n-        \/**\n-         * Read 4 bytes from <code>istream<\/code> and threat them to encode\n-         * size of data parcel following these 4 bytes.\n-         *\/\n-        private static int getSize(InputStream istream) throws IOException {\n-            byte data[] = readBytes(4, istream);\n-            int data0 = (int) data[0] & 0xFF;\n-            int data1 = (int) data[1] & 0xFF;\n-            int data2 = (int) data[2] & 0xFF;\n-            int data3 = (int) data[3] & 0xFF;\n-            int sizeWord = data0 + (data1 << 8) + (data2 << 16) + (data3 << 24);\n-            int size = sizeWord + 1;\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-            return size;\n-        }\n-\n-        \/**\n-         * Send 4 bytes encoding actual size of the parcel just to be transfered.\n-         *\/\n-        private static void putSize(OutputStream ostream, int size)\n-                throws IOException {\n-\n-            if (size <= 0)\n-                throw new TestFailure(\"illegal size: \" + size);\n-\n-            int sizeWord = size - 1;\n-            byte data[] = new byte[4];\n-            data[0] = (byte) sizeWord;\n-            data[1] = (byte) (sizeWord >> 8);\n-            data[2] = (byte) (sizeWord >> 16);\n-            data[3] = (byte) (sizeWord >> 24);\n-            ostream.write(data);\n-        }\n-\n-        \/**\n-         * Recieve data parcel.\n-         *\/\n-        public Parcel(InputStream istream) throws IOException {\n-            int size = getSize(istream);\n-            parcel = readBytes(size, istream);\n-        }\n-\n-        \/**\n-         * Send <code>this<\/code> data parcel.\n-         *\/\n-        public void send(OutputStream ostream) throws IOException {\n-            int size = parcel.length;\n-            putSize(ostream, size);\n-            ostream.write(parcel);\n-        }\n-\n-        \/**\n-         * Check byte-to-byte equality between <code>this<\/code> and the\n-         * <code>other<\/code> parcels.\n-         *\/\n-        public boolean equals(Parcel other) {\n-            if (this.parcel.length != other.parcel.length)\n-                return false;\n-            int size = parcel.length;\n-            for (int i = 0; i < size; i++)\n-                if (this.parcel[i] != other.parcel[i])\n-                    return false;\n-            return true;\n-        }\n-    }\n-\n-    \/**\n-     * Server or Client may throw this exception to report the test failure.\n-     *\/\n-    static class TestFailure extends RuntimeException {\n-        \/**\n-         * Report particular <code>purpose<\/code> of the test failure.\n-         *\/\n-        public TestFailure(String purpose) {\n-            super(purpose);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/stress\/network\/network006.java","additions":0,"deletions":916,"binary":false,"changes":916,"status":"deleted"}]}