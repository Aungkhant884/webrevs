{"files":[{"patch":"@@ -35,0 +35,8 @@\n+      apt-gcc-version:\n+        required: false\n+        type: string\n+        default: '10.3.0-1ubuntu1~20.04'\n+      apt-gcc-cross-suffix:\n+        required: false\n+        type: string\n+        default: 'cross1'\n@@ -88,4 +96,4 @@\n-              gcc-${{ inputs.gcc-major-version }} \\\n-              g++-${{ inputs.gcc-major-version }} \\\n-              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}} \\\n-              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}} \\\n+              gcc-${{ inputs.gcc-major-version }}=${{ inputs.apt-gcc-version }} \\\n+              g++-${{ inputs.gcc-major-version }}=${{ inputs.apt-gcc-version }} \\\n+              gcc-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-version }}${{ inputs.apt-gcc-cross-suffix }} \\\n+              g++-${{ inputs.gcc-major-version }}-${{ matrix.gnu-arch }}-linux-gnu${{ matrix.gnu-abi}}=${{ inputs.apt-gcc-version }}${{ inputs.apt-gcc-cross-suffix }} \\\n","filename":".github\/workflows\/build-cross-compile.yml","additions":12,"deletions":4,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-      apt-gcc-version: '10'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -150,1 +150,1 @@\n-      apt-gcc-version: '10'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -162,1 +162,1 @@\n-      apt-gcc-version: '10'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -174,1 +174,1 @@\n-      apt-gcc-version: '10'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n@@ -187,1 +187,1 @@\n-      apt-gcc-version: '10'\n+      apt-gcc-version: '10=10.3.0-1ubuntu1~20.04'\n","filename":".github\/workflows\/main.yml","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -500,1 +500,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/arm\/frame_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -305,1 +305,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/ppc\/frame_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -526,1 +526,1 @@\n-  Method* m = safe_interpreter_frame_method();\n+  Method* m = *interpreter_frame_method_addr();\n","filename":"src\/hotspot\/cpu\/x86\/frame_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,0 @@\n-#include \"runtime\/safefetch.inline.hpp\"\n@@ -244,8 +243,0 @@\n-Method* frame::safe_interpreter_frame_method() const {\n-  Method** m_addr = interpreter_frame_method_addr();\n-  if (m_addr == NULL) {\n-    return NULL;\n-  }\n-  return (Method*) SafeFetchN((intptr_t*) m_addr, 0);\n-}\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -171,2 +171,0 @@\n-  Method* safe_interpreter_frame_method() const;\n-\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3196,1 +3196,0 @@\n-            boolean skipParseException;\n@@ -3212,4 +3211,0 @@\n-            \/\/ When parsing a URI, skip creating exception objects if the server-based\n-            \/\/ authority is not required and the registry parse is successful.\n-            \/\/\n-            skipParseException = (!requireServerAuthority && regChars);\n@@ -3221,13 +3216,4 @@\n-                    q = parseServer(p, n, skipParseException);\n-                    if (q < n) {\n-                        if (skipParseException) {\n-                            userInfo = null;\n-                            host = null;\n-                            port = -1;\n-                            q = p;\n-                        } else {\n-                            failExpecting(\"end of authority\", q);\n-                        }\n-                    } else {\n-                        authority = input.substring(p, n);\n-                    }\n+                    q = parseServer(p, n);\n+                    if (q < n)\n+                        failExpecting(\"end of authority\", q);\n+                    authority = input.substring(p, n);\n@@ -3271,1 +3257,1 @@\n-        private int parseServer(int start, int n, boolean skipParseException)\n+        private int parseServer(int start, int n)\n@@ -3311,1 +3297,1 @@\n-                    q = parseHostname(p, n, skipParseException);\n+                    q = parseHostname(p, n);\n@@ -3328,2 +3314,0 @@\n-            } else if (p < n && skipParseException) {\n-                return p;\n@@ -3331,1 +3315,0 @@\n-\n@@ -3436,1 +3419,1 @@\n-        private int parseHostname(int start, int n, boolean skipParseException)\n+        private int parseHostname(int start, int n)\n@@ -3464,4 +3447,1 @@\n-            if ((p < n) && !at(p, n, ':')) {\n-                if (skipParseException) {\n-                    return p;\n-                }\n+            if ((p < n) && !at(p, n, ':'))\n@@ -3469,1 +3449,1 @@\n-            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/net\/URI.java","additions":9,"deletions":29,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-import sun.security.action.GetPropertyAction;\n+import sun.security.action.GetBooleanAction;\n@@ -123,2 +123,2 @@\n-     * Flag to specify whether the Extra ZIP64 validation should be\n-     * disabled.\n+     * Flag which specifies whether the validation of the Zip64 extra\n+     * fields should be disabled\n@@ -126,3 +126,3 @@\n-    private static final boolean DISABLE_ZIP64_EXTRA_VALIDATION =\n-            getDisableZip64ExtraFieldValidation();\n-\n+    private static final boolean disableZip64ExtraFieldValidation =\n+        AccessController.doPrivileged\n+                        (new GetBooleanAction(\"jdk.util.zip.disableZip64ExtraFieldValidation\"));\n@@ -1134,16 +1134,0 @@\n-    \/**\n-     * Returns the value of the System property which indicates whether the\n-     * Extra ZIP64 validation should be disabled.\n-     *\/\n-    static boolean getDisableZip64ExtraFieldValidation() {\n-        boolean result;\n-        String value = GetPropertyAction.privilegedGetProperty(\n-                \"jdk.util.zip.disableZip64ExtraFieldValidation\");\n-        if (value == null) {\n-            result = false;\n-        } else {\n-            result = value.isEmpty() || value.equalsIgnoreCase(\"true\");\n-        }\n-        return result;\n-    }\n-\n@@ -1260,4 +1244,1 @@\n-            \/\/ Walk through each Extra Header. Each Extra Header Must consist of:\n-            \/\/       Header ID - 2 bytes\n-            \/\/       Data Size - 2 bytes:\n-            while (currentOffset + Integer.BYTES <= extraEndOffset) {\n+            while (currentOffset < extraEndOffset) {\n@@ -1268,1 +1249,0 @@\n-                currentOffset += Short.BYTES;\n@@ -1274,4 +1254,1 @@\n-                    zerror(String.format(\n-                            \"Invalid CEN header (invalid extra data field size for \" +\n-                                    \"tag: 0x%04x at %d)\",\n-                            tag, cenPos));\n+                    zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n@@ -1279,0 +1256,1 @@\n+                currentOffset += Short.BYTES;\n@@ -1285,1 +1263,0 @@\n-\n@@ -1309,10 +1286,0 @@\n-            \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n-            \/\/ versions of Apache Ant and Commons Compress, validate csize and size\n-            \/\/ to make sure neither field == ZIP64_MAGICVAL\n-            if (blockSize == 0) {\n-                if (csize == ZIP64_MAGICVAL || size == ZIP64_MAGICVAL) {\n-                    zerror(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                }\n-                \/\/ Only validate the ZIP64_EXTID data if the block size > 0\n-                return;\n-            }\n@@ -1729,1 +1696,1 @@\n-                if (elen > 0 && !DISABLE_ZIP64_EXTRA_VALIDATION) {\n+                if (elen > 0 && !disableZip64ExtraFieldValidation) {\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":10,"deletions":43,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-import javax.print.attribute.standard.Sides;\n@@ -686,18 +685,0 @@\n-    private int getSides() {\n-        return (this.sidesAttr == null) ? -1 : this.sidesAttr.getValue();\n-    }\n-\n-    private void setSides(int sides) {\n-        if (attributes == null) {\n-            return;\n-        }\n-\n-        final Sides[] sidesTable = new Sides[] {Sides.ONE_SIDED, Sides.TWO_SIDED_LONG_EDGE, Sides.TWO_SIDED_SHORT_EDGE};\n-\n-        if (sides >= 0 && sides < sidesTable.length) {\n-            Sides s = sidesTable[sides];\n-            attributes.add(s);\n-            this.sidesAttr = s;\n-        }\n-    }\n-\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CPrinterJob.java","additions":0,"deletions":19,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -40,4 +40,0 @@\n-#define ONE_SIDED 0\n-#define TWO_SIDED_LONG_EDGE 1\n-#define TWO_SIDED_SHORT_EDGE 2\n-\n@@ -358,18 +354,0 @@\n-static jint duplexModeToSides(PMDuplexMode duplexMode) {\n-    switch(duplexMode) {\n-        case kPMDuplexNone: return ONE_SIDED;\n-        case kPMDuplexTumble: return TWO_SIDED_SHORT_EDGE;\n-        case kPMDuplexNoTumble: return TWO_SIDED_LONG_EDGE;\n-        default: return -1;\n-    }\n-}\n-\n-static PMDuplexMode sidesToDuplexMode(jint sides) {\n-    switch(sides) {\n-        case ONE_SIDED: return kPMDuplexNone;\n-        case TWO_SIDED_SHORT_EDGE: return kPMDuplexTumble;\n-        case TWO_SIDED_LONG_EDGE: return kPMDuplexNoTumble;\n-        default: return kPMDuplexNone;\n-    }\n-}\n-\n@@ -385,1 +363,0 @@\n-    DECLARE_METHOD(jm_setSides, sjc_CPrinterJob, \"setSides\", \"(I)V\");\n@@ -446,6 +423,0 @@\n-        PMDuplexMode duplexSetting;\n-        if (PMGetDuplex(src.PMPrintSettings, &duplexSetting) == noErr) {\n-            jint sides = duplexModeToSides(duplexSetting);\n-            (*env)->CallVoidMethod(env, dstPrinterJob, jm_setSides, sides); \/\/ AWT_THREADING Safe (known object)\n-            CHECK_EXCEPTION();\n-        }\n@@ -470,2 +441,0 @@\n-    DECLARE_METHOD(jm_getSides, sjc_CPrinterJob, \"getSides\", \"()I\");\n-\n@@ -530,11 +499,0 @@\n-\n-    jint sides = (*env)->CallIntMethod(env, srcPrinterJob, jm_getSides);\n-    CHECK_EXCEPTION();\n-\n-    if (sides >= 0) {\n-        PMDuplexMode duplexMode = sidesToDuplexMode(sides);\n-        PMPrintSettings printSettings = dst.PMPrintSettings;\n-        if (PMSetDuplex(printSettings, duplexMode) == noErr) {\n-            [dst updateFromPMPrintSettings];\n-        }\n-    }\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/CPrinterJob.m","additions":0,"deletions":42,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -1380,3 +1380,2 @@\n-                    int npf = newFramePosition; \/\/ copy into local variable\n-                    if (npf >= 0) {\n-                        clipBytePosition = npf * frameSize;\n+                    if (newFramePosition >= 0) {\n+                        clipBytePosition = newFramePosition * frameSize;\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/DirectAudioDevice.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1080,2 +1080,0 @@\n-        this.attributes = attributes;\n-\n","filename":"src\/java.desktop\/share\/classes\/sun\/print\/RasterPrinterJob.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-\n-#if !defined(AIX)\n@@ -49,2 +47,0 @@\n-#endif\n-\n","filename":"src\/java.desktop\/share\/native\/libharfbuzz\/hb-subset.cc","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: May 2023\n+ * @LastModified: May 2021\n@@ -33,3209 +33,2407 @@\n-    \/**\n-     * Java class file format Magic number (0xCAFEBABE)\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.1-200-A\"> The ClassFile Structure\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final int JVM_CLASSFILE_MAGIC = 0xCAFEBABE;\n-\n-    \/**\n-     * Major version number of class files for Java 1.1.\n-     *\n-     * @see #MINOR_1_1\n-     *\/\n-    public static final short MAJOR_1_1 = 45;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.1.\n-     *\n-     * @see #MAJOR_1_1\n-     *\/\n-    public static final short MINOR_1_1 = 3;\n-\n-    \/**\n-     * Major version number of class files for Java 1.2.\n-     *\n-     * @see #MINOR_1_2\n-     *\/\n-    public static final short MAJOR_1_2 = 46;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.2.\n-     *\n-     * @see #MAJOR_1_2\n-     *\/\n-    public static final short MINOR_1_2 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.2.\n-     *\n-     * @see #MINOR_1_2\n-     *\/\n-    public static final short MAJOR_1_3 = 47;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.3.\n-     *\n-     * @see #MAJOR_1_3\n-     *\/\n-    public static final short MINOR_1_3 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.3.\n-     *\n-     * @see #MINOR_1_3\n-     *\/\n-    public static final short MAJOR_1_4 = 48;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.4.\n-     *\n-     * @see #MAJOR_1_4\n-     *\/\n-    public static final short MINOR_1_4 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.4.\n-     *\n-     * @see #MINOR_1_4\n-     *\/\n-    public static final short MAJOR_1_5 = 49;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.5.\n-     *\n-     * @see #MAJOR_1_5\n-     *\/\n-    public static final short MINOR_1_5 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.6.\n-     *\n-     * @see #MINOR_1_6\n-     *\/\n-    public static final short MAJOR_1_6 = 50;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.6.\n-     *\n-     * @see #MAJOR_1_6\n-     *\/\n-    public static final short MINOR_1_6 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.7.\n-     *\n-     * @see #MINOR_1_7\n-     *\/\n-    public static final short MAJOR_1_7 = 51;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.7.\n-     *\n-     * @see #MAJOR_1_7\n-     *\/\n-    public static final short MINOR_1_7 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 1.8.\n-     *\n-     * @see #MINOR_1_8\n-     *\/\n-    public static final short MAJOR_1_8 = 52;\n-\n-    \/**\n-     * Minor version number of class files for Java 1.8.\n-     *\n-     * @see #MAJOR_1_8\n-     *\/\n-    public static final short MINOR_1_8 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 9.\n-     *\n-     * @see #MINOR_9\n-     *\/\n-    public static final short MAJOR_9 = 53;\n-\n-    \/**\n-     * Minor version number of class files for Java 9.\n-     *\n-     * @see #MAJOR_9\n-     *\/\n-    public static final short MINOR_9 = 0;\n-\n-    \/**\n-     * @deprecated Use {@link #MAJOR_9} instead\n-     *\/\n-    @Deprecated\n-    public static final short MAJOR_1_9 = MAJOR_9;\n-\n-    \/**\n-     * @deprecated Use {@link #MINOR_9} instead\n-     *\/\n-    @Deprecated\n-    public static final short MINOR_1_9 = MINOR_9;\n-\n-    \/**\n-     * Major version number of class files for Java 10.\n-     *\n-     * @see #MINOR_10\n-     *\/\n-    public static final short MAJOR_10 = 54;\n-\n-    \/**\n-     * Minor version number of class files for Java 10.\n-     *\n-     * @see #MAJOR_10\n-     *\/\n-    public static final short MINOR_10 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 11.\n-     *\n-     * @see #MINOR_11\n-     *\/\n-    public static final short MAJOR_11 = 55;\n-\n-    \/**\n-     * Minor version number of class files for Java 11.\n-     *\n-     * @see #MAJOR_11\n-     *\/\n-    public static final short MINOR_11 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 12.\n-     *\n-     * @see #MINOR_12\n-     *\/\n-    public static final short MAJOR_12 = 56;\n-\n-    \/**\n-     * Minor version number of class files for Java 12.\n-     *\n-     * @see #MAJOR_12\n-     *\/\n-    public static final short MINOR_12 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 13.\n-     *\n-     * @see #MINOR_13\n-     *\/\n-    public static final short MAJOR_13 = 57;\n-\n-    \/**\n-     * Minor version number of class files for Java 13.\n-     *\n-     * @see #MAJOR_13\n-     *\/\n-    public static final short MINOR_13 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 14.\n-     *\n-     * @see #MAJOR_14\n-     * @since 6.4.0\n-     *\/\n-    public static final short MINOR_14 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 15.\n-     *\n-     * @see #MAJOR_15\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_15 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 16.\n-     *\n-     * @see #MAJOR_16\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_16 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 17.\n-     *\n-     * @see #MAJOR_17\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_17 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 18.\n-     *\n-     * @see #MAJOR_18\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_18 = 0;\n-\n-    \/**\n-     * Minor version number of class files for Java 19.\n-     *\n-     * @see #MAJOR_19\n-     * @since 6.6.0\n-     *\/\n-    public static final short MINOR_19 = 0;\n-\n-    \/**\n-     * Major version number of class files for Java 14.\n-     *\n-     * @see #MINOR_14\n-     * @since 6.4.0\n-     *\/\n-    public static final short MAJOR_14 = 58;\n-\n-    \/**\n-     * Major version number of class files for Java 15.\n-     *\n-     * @see #MINOR_15\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_15 = 59;\n-\n-    \/**\n-     * Major version number of class files for Java 16.\n-     *\n-     * @see #MINOR_16\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_16 = 60;\n-\n-    \/**\n-     * Major version number of class files for Java 17.\n-     *\n-     * @see #MINOR_17\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_17 = 61;\n-\n-    \/**\n-     * Major version number of class files for Java 18.\n-     *\n-     * @see #MINOR_18\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_18 = 62;\n-\n-    \/**\n-     * Major version number of class files for Java 19.\n-     *\n-     * @see #MINOR_19\n-     * @since 6.6.0\n-     *\/\n-    public static final short MAJOR_19 = 63;\n-\n-    \/**\n-     * Default major version number. Class file is for Java 1.1.\n-     *\n-     * @see #MAJOR_1_1\n-     *\/\n-    public static final short MAJOR = MAJOR_1_1;\n-\n-    \/**\n-     * Default major version number. Class file is for Java 1.1.\n-     *\n-     * @see #MAJOR_1_1\n-     *\/\n-    public static final short MINOR = MINOR_1_1;\n-\n-    \/**\n-     * Maximum value for an unsigned short.\n-     *\/\n-    public static final int MAX_SHORT = 65535; \/\/ 2^16 - 1\n-\n-    \/**\n-     * Maximum value for an unsigned byte.\n-     *\/\n-    public static final int MAX_BYTE = 255; \/\/ 2^8 - 1\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.1-200-E.1\"> Flag definitions for\n-     *      Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.5\"> Flag definitions for Fields\n-     *      in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.6\"> Flag definitions for Methods\n-     *      in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.7.6-300-D.1-D.1\"> Flag\n-     *      definitions for Inner Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n-     *\/\n-    public static final short ACC_PUBLIC = 0x0001;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_PRIVATE = 0x0002;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_PROTECTED = 0x0004;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_STATIC = 0x0008;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_FINAL = 0x0010;\n-\n-    \/**\n-     * One of the access flags for the Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_OPEN = 0x0020;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_SUPER = 0x0020;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_SYNCHRONIZED = 0x0020;\n-\n-    \/**\n-     * One of the access flags for the Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_TRANSITIVE = 0x0020;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_BRIDGE = 0x0040;\n-\n-    \/**\n-     * One of the access flags for the Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_STATIC_PHASE = 0x0040;\n-\n-    \/**\n-     * One of the access flags for fields.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_VOLATILE = 0x0040;\n-\n-    \/**\n-     * One of the access flags for fields.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_TRANSIENT = 0x0080;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_VARARGS = 0x0080;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_NATIVE = 0x0100;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_INTERFACE = 0x0200;\n-\n-    \/**\n-     * One of the access flags for methods or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_ABSTRACT = 0x0400;\n-\n-    \/**\n-     * One of the access flags for methods.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_STRICT = 0x0800;\n-\n-    \/**\n-     * One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_SYNTHETIC = 0x1000;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_ANNOTATION = 0x2000;\n-\n-    \/**\n-     * One of the access flags for fields or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_ENUM = 0x4000;\n-\n-    \/\/ Applies to classes compiled by new compilers only\n-    \/**\n-     * One of the access flags for MethodParameter or Module attributes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_MANDATED = (short) 0x8000;\n-\n-    \/**\n-     * One of the access flags for classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     *\/\n-    public static final short ACC_MODULE = (short) 0x8000;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes.\n-     *\n-     * @see #ACC_PUBLIC\n-     * @deprecated Use {@link #MAX_ACC_FLAG_I}\n-     *\/\n-    @Deprecated\n-    public static final short MAX_ACC_FLAG = ACC_ENUM;\n-\n-    \/**\n-     * One of the access flags for fields, methods, or classes. ACC_MODULE is negative as a short.\n-     *\n-     * @see #ACC_PUBLIC\n-     * @since 6.4.0\n-     *\/\n-    public static final int MAX_ACC_FLAG_I = 0x8000; \/\/ ACC_MODULE is negative as a short\n-\n-    \/\/ Note that do to overloading:\n-    \/\/ 'synchronized' is for methods, might be 'open' (if Module), 'super' (if class), or 'transitive' (if Module).\n-    \/\/ 'volatile' is for fields, might be 'bridge' (if method) or 'static_phase' (if Module)\n-    \/\/ 'transient' is for fields, might be 'varargs' (if method)\n-    \/\/ 'module' is for classes, might be 'mandated' (if Module or MethodParameters)\n-    \/**\n-     * The names of the access flags.\n-     *\/\n-    private static final String[] ACCESS_NAMES = {\"public\", \"private\", \"protected\", \"static\", \"final\", \"synchronized\", \"volatile\", \"transient\", \"native\",\n-        \"interface\", \"abstract\", \"strictfp\", \"synthetic\", \"annotation\", \"enum\", \"module\"};\n-\n-    \/** @since 6.0 *\/\n-    public static final int ACCESS_NAMES_LENGTH = ACCESS_NAMES.length;\n-\n-    \/**\n-     * Marks a constant pool entry as type UTF-8.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.7\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Utf8 = 1;\n-\n-    \/*\n-     * The description of the constant pool is at: https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4\n-     * References below are to the individual sections\n-     *\/\n-\n-    \/**\n-     * Marks a constant pool entry as type Integer.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Integer = 3;\n-\n-    \/**\n-     * Marks a constant pool entry as type Float.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Float = 4;\n-\n-    \/**\n-     * Marks a constant pool entry as type Long.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Long = 5;\n-\n-    \/**\n-     * Marks a constant pool entry as type Double.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Double = 6;\n-\n-    \/**\n-     * Marks a constant pool entry as a Class\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.1\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Class = 7;\n-\n-    \/**\n-     * Marks a constant pool entry as a Field Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Fieldref = 9;\n-\n-    \/**\n-     * Marks a constant pool entry as type String\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.3\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_String = 8;\n-\n-    \/**\n-     * Marks a constant pool entry as a Method Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_Methodref = 10;\n-\n-    \/**\n-     * Marks a constant pool entry as an Interface Method Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_InterfaceMethodref = 11;\n-\n-    \/**\n-     * Marks a constant pool entry as a name and type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.6\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_NameAndType = 12;\n-\n-    \/**\n-     * Marks a constant pool entry as a Method Handle.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.8\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_MethodHandle = 15;\n-\n-    \/**\n-     * Marks a constant pool entry as a Method Type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.9\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_MethodType = 16;\n-\n-    \/**\n-     * Marks a constant pool entry as dynamically computed.\n-     *\n-     * @see <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\"> Change request for JEP\n-     *      309<\/a>\n-     * @since 6.3\n-     *\/\n-    public static final byte CONSTANT_Dynamic = 17;\n-\n-    \/**\n-     * Marks a constant pool entry as an Invoke Dynamic\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte CONSTANT_InvokeDynamic = 18;\n-\n-    \/**\n-     * Marks a constant pool entry as a Module Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.11\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     * @since 6.1\n-     *\/\n-    public static final byte CONSTANT_Module = 19;\n-\n-    \/**\n-     * Marks a constant pool entry as a Package Reference.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.12\"> The Constant Pool in The\n-     *      Java Virtual Machine Specification<\/a>\n-     * @since 6.1\n-     *\/\n-    public static final byte CONSTANT_Package = 20;\n-\n-    \/**\n-     * The names of the types of entries in a constant pool. Use getConstantName instead\n-     *\/\n-    private static final String[] CONSTANT_NAMES = {\"\", \"CONSTANT_Utf8\", \"\", \"CONSTANT_Integer\", \"CONSTANT_Float\", \"CONSTANT_Long\", \"CONSTANT_Double\",\n-        \"CONSTANT_Class\", \"CONSTANT_String\", \"CONSTANT_Fieldref\", \"CONSTANT_Methodref\", \"CONSTANT_InterfaceMethodref\", \"CONSTANT_NameAndType\", \"\", \"\",\n-        \"CONSTANT_MethodHandle\", \"CONSTANT_MethodType\", \"CONSTANT_Dynamic\", \"CONSTANT_InvokeDynamic\", \"CONSTANT_Module\", \"CONSTANT_Package\"};\n-\n-    \/**\n-     * The name of the static initializer, also called &quot;class initialization method&quot; or &quot;interface\n-     * initialization method&quot;. This is &quot;&lt;clinit&gt;&quot;.\n-     *\/\n-    public static final String STATIC_INITIALIZER_NAME = \"<clinit>\";\n-\n-    \/**\n-     * The name of every constructor method in a class, also called &quot;instance initialization method&quot;. This is\n-     * &quot;&lt;init&gt;&quot;.\n-     *\/\n-    public static final String CONSTRUCTOR_NAME = \"<init>\";\n-\n-    \/**\n-     * The names of the interfaces implemented by arrays\n-     *\/\n-    private static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = {\"java.lang.Cloneable\", \"java.io.Serializable\"};\n-\n-    \/**\n-     * Maximum Constant Pool entries. One of the limitations of the Java Virtual Machine.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.11-100-A\"> The Java Virtual\n-     *      Machine Specification, Java SE 8 Edition, page 330, chapter 4.11.<\/a>\n-     *\/\n-    public static final int MAX_CP_ENTRIES = 65535;\n-\n-    \/**\n-     * Maximum code size (plus one; the code size must be LESS than this) One of the limitations of the Java Virtual\n-     * Machine. Note vmspec2 page 152 (\"Limitations\") says: \"The amount of code per non-native, non-abstract method is\n-     * limited to 65536 bytes by the sizes of the indices in the exception_table of the Code attribute (4.7.3), in the\n-     * LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\" However this should be taken\n-     * as an upper limit rather than the defined maximum. On page 134 (4.8.1 Static Constants) of the same spec, it says:\n-     * \"The value of the code_length item must be less than 65536.\" The entry in the Limitations section has been removed\n-     * from later versions of the spec; it is not present in the Java SE 8 edition.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\"> The Java Virtual\n-     *      Machine Specification, Java SE 8 Edition, page 104, chapter 4.7.<\/a>\n-     *\/\n-    public static final int MAX_CODE_SIZE = 65536; \/\/ bytes\n-\n-    \/**\n-     * The maximum number of dimensions in an array ({@value}). One of the limitations of the Java Virtual Machine.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3.2-150\"> Field Descriptors in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final int MAX_ARRAY_DIMENSIONS = 255;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.nop\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short NOP = 0;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aconst_null\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ACONST_NULL = 1;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_M1 = 2;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_0 = 3;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_1 = 4;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_2 = 5;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_3 = 6;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_4 = 7;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ICONST_5 = 8;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LCONST_0 = 9;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LCONST_1 = 10;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCONST_0 = 11;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCONST_1 = 12;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCONST_2 = 13;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCONST_0 = 14;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCONST_1 = 15;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bipush\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BIPUSH = 16;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sipush\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SIPUSH = 17;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDC = 18;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDC_W = 19;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc2_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDC2_W = 20;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD = 21;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD = 22;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD = 23;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD = 24;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD = 25;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_0 = 26;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_1 = 27;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_2 = 28;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ILOAD_3 = 29;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_0 = 30;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_1 = 31;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_2 = 32;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LLOAD_3 = 33;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_0 = 34;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_1 = 35;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_2 = 36;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FLOAD_3 = 37;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_0 = 38;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_1 = 39;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_2 = 40;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DLOAD_3 = 41;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_0 = 42;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_1 = 43;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_2 = 44;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ALOAD_3 = 45;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iaload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IALOAD = 46;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.laload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LALOAD = 47;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.faload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FALOAD = 48;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.daload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DALOAD = 49;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aaload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short AALOAD = 50;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.baload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BALOAD = 51;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.caload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short CALOAD = 52;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.saload\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SALOAD = 53;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE = 54;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE = 55;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE = 56;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE = 57;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE = 58;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_0 = 59;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_1 = 60;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_2 = 61;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISTORE_3 = 62;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_0 = 63;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_1 = 64;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_2 = 65;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSTORE_3 = 66;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_0 = 67;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_1 = 68;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_2 = 69;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSTORE_3 = 70;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_0 = 71;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_1 = 72;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_2 = 73;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSTORE_3 = 74;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_0 = 75;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_1 = 76;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_2 = 77;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ASTORE_3 = 78;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IASTORE = 79;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LASTORE = 80;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FASTORE = 81;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DASTORE = 82;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short AASTORE = 83;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BASTORE = 84;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.castore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short CASTORE = 85;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sastore\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SASTORE = 86;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short POP = 87;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short POP2 = 88;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP = 89;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x1\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP_X1 = 90;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP_X2 = 91;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP2 = 92;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x1\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP2_X1 = 93;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x2\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DUP2_X2 = 94;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.swap\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short SWAP = 95;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iadd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IADD = 96;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ladd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LADD = 97;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fadd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FADD = 98;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dadd\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DADD = 99;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.isub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISUB = 100;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lsub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSUB = 101;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fsub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FSUB = 102;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dsub\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DSUB = 103;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.imul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IMUL = 104;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lmul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LMUL = 105;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fmul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FMUL = 106;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dmul\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DMUL = 107;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.idiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IDIV = 108;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LDIV = 109;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fdiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FDIV = 110;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ddiv\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DDIV = 111;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.irem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IREM = 112;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lrem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LREM = 113;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.frem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FREM = 114;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.drem\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DREM = 115;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ineg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INEG = 116;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lneg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LNEG = 117;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fneg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FNEG = 118;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dneg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DNEG = 119;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISHL = 120;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSHL = 121;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ISHR = 122;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LSHR = 123;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iushr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IUSHR = 124;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lushr\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LUSHR = 125;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iand\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IAND = 126;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.land\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LAND = 127;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ior\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IOR = 128;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lor\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LOR = 129;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ixor\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IXOR = 130;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lxor\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LXOR = 131;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iinc\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IINC = 132;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2l\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2L = 133;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2f\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2F = 134;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2d\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2D = 135;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2i\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short L2I = 136;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2f\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short L2F = 137;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2d\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short L2D = 138;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2i\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short F2I = 139;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2l\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short F2L = 140;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2d\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short F2D = 141;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2i\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short D2I = 142;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2l\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short D2L = 143;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2f\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short D2F = 144;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2b\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2B = 145;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INT2BYTE = 145; \/\/ Old notation\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2c\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2C = 146;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INT2CHAR = 146; \/\/ Old notation\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2s\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short I2S = 147;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INT2SHORT = 147; \/\/ Old notation\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lcmp\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LCMP = 148;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCMPL = 149;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FCMPG = 150;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpl\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCMPL = 151;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpg\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DCMPG = 152;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifeq\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFEQ = 153;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifne\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFNE = 154;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iflt\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFLT = 155;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifge\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFGE = 156;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifgt\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFGT = 157;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifle\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFLE = 158;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPEQ = 159;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPNE = 160;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPLT = 161;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPGE = 162;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPGT = 163;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ICMPLE = 164;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ACMPEQ = 165;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IF_ACMPNE = 166;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GOTO = 167;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short JSR = 168;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ret\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short RET = 169;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.tableswitch\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short TABLESWITCH = 170;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lookupswitch\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LOOKUPSWITCH = 171;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ireturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IRETURN = 172;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lreturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short LRETURN = 173;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.freturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short FRETURN = 174;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dreturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short DRETURN = 175;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.areturn\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ARETURN = 176;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.return\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short RETURN = 177;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getstatic\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GETSTATIC = 178;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putstatic\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short PUTSTATIC = 179;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getfield\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GETFIELD = 180;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putfield\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short PUTFIELD = 181;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUAL = 182;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKESPECIAL = 183;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKENONVIRTUAL = 183; \/\/ Old name in JDK 1.0\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKESTATIC = 184;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKEINTERFACE = 185;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INVOKEDYNAMIC = 186;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.new\"> Opcode definitions in The\n-     *      Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short NEW = 187;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.newarray\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short NEWARRAY = 188;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.anewarray\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ANEWARRAY = 189;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.arraylength\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ARRAYLENGTH = 190;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.athrow\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short ATHROW = 191;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.checkcast\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short CHECKCAST = 192;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.instanceof\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short INSTANCEOF = 193;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorenter\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short MONITORENTER = 194;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorexit\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short MONITOREXIT = 195;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.wide\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short WIDE = 196;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.multianewarray\"> Opcode\n-     *      definitions in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short MULTIANEWARRAY = 197;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnull\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFNULL = 198;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnonnull\"> Opcode definitions\n-     *      in The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IFNONNULL = 199;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short GOTO_W = 200;\n-\n-    \/**\n-     * Java VM opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr_w\"> Opcode definitions in\n-     *      The Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short JSR_W = 201;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n-     *      Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short BREAKPOINT = 202;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short LDC_QUICK = 203;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short LDC_W_QUICK = 204;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short LDC2_W_QUICK = 205;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETFIELD_QUICK = 206;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTFIELD_QUICK = 207;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETFIELD2_QUICK = 208;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTFIELD2_QUICK = 209;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETSTATIC_QUICK = 210;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTSTATIC_QUICK = 211;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETSTATIC2_QUICK = 212;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTSTATIC2_QUICK = 213;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUAL_QUICK = 214;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKENONVIRTUAL_QUICK = 215;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKESUPER_QUICK = 216;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKESTATIC_QUICK = 217;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEINTERFACE_QUICK = 218;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUALOBJECT_QUICK = 219;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short NEW_QUICK = 221;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short ANEWARRAY_QUICK = 222;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short MULTIANEWARRAY_QUICK = 223;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short CHECKCAST_QUICK = 224;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INSTANCEOF_QUICK = 225;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short INVOKEVIRTUAL_QUICK_W = 226;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short GETFIELD_QUICK_W = 227;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\n-     *      \"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n-     *      Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\"> Why the _quick\n-     *      opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a>\n-     *\/\n-    public static final short PUTFIELD_QUICK_W = 228;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n-     *      Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IMPDEP1 = 254;\n-\n-    \/**\n-     * JVM internal opcode.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\"> Reserved opcodes in the Java\n-     *      Virtual Machine Specification<\/a>\n-     *\/\n-    public static final short IMPDEP2 = 255;\n-\n-    \/**\n-     * BCEL virtual instruction for pushing an arbitrary data type onto the stack. Will be converted to the appropriate JVM\n-     * opcode when the class is dumped.\n-     *\/\n-    public static final short PUSH = 4711;\n-\n-    \/**\n-     * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH. Will be converted to the appropriate JVM opcode when\n-     * the class is dumped.\n-     *\/\n-    public static final short SWITCH = 4712;\n-\n-    \/** Illegal opcode. *\/\n-    public static final short UNDEFINED = -1;\n-\n-    \/** Illegal opcode. *\/\n-    public static final short UNPREDICTABLE = -2;\n-\n-    \/** Illegal opcode. *\/\n-    public static final short RESERVED = -3;\n-\n-    \/** Mnemonic for an illegal opcode. *\/\n-    public static final String ILLEGAL_OPCODE = \"<illegal opcode>\";\n-\n-    \/** Mnemonic for an illegal type. *\/\n-    public static final String ILLEGAL_TYPE = \"<illegal type>\";\n-\n-    \/**\n-     * Boolean data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_BOOLEAN = 4;\n-\n-    \/**\n-     * Char data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_CHAR = 5;\n-\n-    \/**\n-     * Float data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_FLOAT = 6;\n-\n-    \/**\n-     * Double data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_DOUBLE = 7;\n-\n-    \/**\n-     * Byte data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_BYTE = 8;\n-\n-    \/**\n-     * Short data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_SHORT = 9;\n-\n-    \/**\n-     * Int data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_INT = 10;\n-\n-    \/**\n-     * Long data type.\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\"> Static Constraints in\n-     *      the Java Virtual Machine Specification<\/a>\n-     *\/\n-    public static final byte T_LONG = 11;\n-\n-    \/** Void data type (non-standard). *\/\n-    public static final byte T_VOID = 12; \/\/ Non-standard\n-\n-    \/** Array data type. *\/\n-    public static final byte T_ARRAY = 13;\n-\n-    \/** Object data type. *\/\n-    public static final byte T_OBJECT = 14;\n-\n-    \/** Reference data type (deprecated). *\/\n-    public static final byte T_REFERENCE = 14; \/\/ Deprecated\n-\n-    \/** Unknown data type. *\/\n-    public static final byte T_UNKNOWN = 15;\n-\n-    \/** Address data type. *\/\n-    public static final byte T_ADDRESS = 16;\n-\n-    \/** Empty arrays used to replace references to ArrayUtils *\/\n-    public static final byte[] EMPTY_BYTE_ARRAY = {};\n-    public static final int[] EMPTY_INT_ARRAY = {};\n-    public static final String[] EMPTY_STRING_ARRAY = {};\n-\n-    \/**\n-     * The primitive type names corresponding to the T_XX constants, e.g., TYPE_NAMES[T_INT] = \"int\"\n-     *\/\n-    private static final String[] TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"boolean\", \"char\", \"float\", \"double\", \"byte\", \"short\",\n-        \"int\", \"long\", \"void\", \"array\", \"object\", \"unknown\", \"address\"};\n-\n-    \/**\n-     * The primitive class names corresponding to the T_XX constants, e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n-     *\/\n-    private static final String[] CLASS_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"java.lang.Boolean\", \"java.lang.Character\",\n-        \"java.lang.Float\", \"java.lang.Double\", \"java.lang.Byte\", \"java.lang.Short\", \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Void\", ILLEGAL_TYPE,\n-        ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE};\n-\n-    \/**\n-     * The signature characters corresponding to primitive types, e.g., SHORT_TYPE_NAMES[T_INT] = \"I\"\n-     *\/\n-    private static final String[] SHORT_TYPE_NAMES = {ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE, \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\", \"V\",\n-        ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE};\n-\n-    \/**\n-     * Number of byte code operands for each opcode, i.e., number of bytes after the tag byte itself. Indexed by opcode, so\n-     * NO_OF_OPERANDS[BIPUSH] = the number of operands for a bipush instruction.\n-     *\/\n-    static final short[] NO_OF_OPERANDS = {0\/* nop *\/, 0\/* aconst_null *\/, 0\/* iconst_m1 *\/, 0\/* iconst_0 *\/, 0\/* iconst_1 *\/, 0\/* iconst_2 *\/,\n-        0\/* iconst_3 *\/, 0\/* iconst_4 *\/, 0\/* iconst_5 *\/, 0\/* lconst_0 *\/, 0\/* lconst_1 *\/, 0\/* fconst_0 *\/, 0\/* fconst_1 *\/, 0\/* fconst_2 *\/, 0\/* dconst_0 *\/,\n-        0\/* dconst_1 *\/, 1\/* bipush *\/, 2\/* sipush *\/, 1\/* ldc *\/, 2\/* ldc_w *\/, 2\/* ldc2_w *\/, 1\/* iload *\/, 1\/* lload *\/, 1\/* fload *\/, 1\/* dload *\/,\n-        1\/* aload *\/, 0\/* iload_0 *\/, 0\/* iload_1 *\/, 0\/* iload_2 *\/, 0\/* iload_3 *\/, 0\/* lload_0 *\/, 0\/* lload_1 *\/, 0\/* lload_2 *\/, 0\/* lload_3 *\/,\n-        0\/* fload_0 *\/, 0\/* fload_1 *\/, 0\/* fload_2 *\/, 0\/* fload_3 *\/, 0\/* dload_0 *\/, 0\/* dload_1 *\/, 0\/* dload_2 *\/, 0\/* dload_3 *\/, 0\/* aload_0 *\/,\n-        0\/* aload_1 *\/, 0\/* aload_2 *\/, 0\/* aload_3 *\/, 0\/* iaload *\/, 0\/* laload *\/, 0\/* faload *\/, 0\/* daload *\/, 0\/* aaload *\/, 0\/* baload *\/, 0\/* caload *\/,\n-        0\/* saload *\/, 1\/* istore *\/, 1\/* lstore *\/, 1\/* fstore *\/, 1\/* dstore *\/, 1\/* astore *\/, 0\/* istore_0 *\/, 0\/* istore_1 *\/, 0\/* istore_2 *\/,\n-        0\/* istore_3 *\/, 0\/* lstore_0 *\/, 0\/* lstore_1 *\/, 0\/* lstore_2 *\/, 0\/* lstore_3 *\/, 0\/* fstore_0 *\/, 0\/* fstore_1 *\/, 0\/* fstore_2 *\/, 0\/* fstore_3 *\/,\n-        0\/* dstore_0 *\/, 0\/* dstore_1 *\/, 0\/* dstore_2 *\/, 0\/* dstore_3 *\/, 0\/* astore_0 *\/, 0\/* astore_1 *\/, 0\/* astore_2 *\/, 0\/* astore_3 *\/, 0\/* iastore *\/,\n-        0\/* lastore *\/, 0\/* fastore *\/, 0\/* dastore *\/, 0\/* aastore *\/, 0\/* bastore *\/, 0\/* castore *\/, 0\/* sastore *\/, 0\/* pop *\/, 0\/* pop2 *\/, 0\/* dup *\/,\n-        0\/* dup_x1 *\/, 0\/* dup_x2 *\/, 0\/* dup2 *\/, 0\/* dup2_x1 *\/, 0\/* dup2_x2 *\/, 0\/* swap *\/, 0\/* iadd *\/, 0\/* ladd *\/, 0\/* fadd *\/, 0\/* dadd *\/, 0\/* isub *\/,\n-        0\/* lsub *\/, 0\/* fsub *\/, 0\/* dsub *\/, 0\/* imul *\/, 0\/* lmul *\/, 0\/* fmul *\/, 0\/* dmul *\/, 0\/* idiv *\/, 0\/* ldiv *\/, 0\/* fdiv *\/, 0\/* ddiv *\/,\n-        0\/* irem *\/, 0\/* lrem *\/, 0\/* frem *\/, 0\/* drem *\/, 0\/* ineg *\/, 0\/* lneg *\/, 0\/* fneg *\/, 0\/* dneg *\/, 0\/* ishl *\/, 0\/* lshl *\/, 0\/* ishr *\/,\n-        0\/* lshr *\/, 0\/* iushr *\/, 0\/* lushr *\/, 0\/* iand *\/, 0\/* land *\/, 0\/* ior *\/, 0\/* lor *\/, 0\/* ixor *\/, 0\/* lxor *\/, 2\/* iinc *\/, 0\/* i2l *\/,\n-        0\/* i2f *\/, 0\/* i2d *\/, 0\/* l2i *\/, 0\/* l2f *\/, 0\/* l2d *\/, 0\/* f2i *\/, 0\/* f2l *\/, 0\/* f2d *\/, 0\/* d2i *\/, 0\/* d2l *\/, 0\/* d2f *\/, 0\/* i2b *\/,\n-        0\/* i2c *\/, 0\/* i2s *\/, 0\/* lcmp *\/, 0\/* fcmpl *\/, 0\/* fcmpg *\/, 0\/* dcmpl *\/, 0\/* dcmpg *\/, 2\/* ifeq *\/, 2\/* ifne *\/, 2\/* iflt *\/, 2\/* ifge *\/,\n-        2\/* ifgt *\/, 2\/* ifle *\/, 2\/* if_icmpeq *\/, 2\/* if_icmpne *\/, 2\/* if_icmplt *\/, 2\/* if_icmpge *\/, 2\/* if_icmpgt *\/, 2\/* if_icmple *\/, 2\/* if_acmpeq *\/,\n-        2\/* if_acmpne *\/, 2\/* goto *\/, 2\/* jsr *\/, 1\/* ret *\/, UNPREDICTABLE\/* tableswitch *\/, UNPREDICTABLE\/* lookupswitch *\/, 0\/* ireturn *\/, 0\/* lreturn *\/,\n-        0\/* freturn *\/, 0\/* dreturn *\/, 0\/* areturn *\/, 0\/* return *\/, 2\/* getstatic *\/, 2\/* putstatic *\/, 2\/* getfield *\/, 2\/* putfield *\/,\n-        2\/* invokevirtual *\/, 2\/* invokespecial *\/, 2\/* invokestatic *\/, 4\/* invokeinterface *\/, 4\/* invokedynamic *\/, 2\/* new *\/, 1\/* newarray *\/,\n-        2\/* anewarray *\/, 0\/* arraylength *\/, 0\/* athrow *\/, 2\/* checkcast *\/, 2\/* instanceof *\/, 0\/* monitorenter *\/, 0\/* monitorexit *\/,\n-        UNPREDICTABLE\/* wide *\/, 3\/* multianewarray *\/, 2\/* ifnull *\/, 2\/* ifnonnull *\/, 4\/* goto_w *\/, 4\/* jsr_w *\/, 0\/* breakpoint *\/, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, RESERVED\/* impdep1 *\/,\n-        RESERVED\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * How the byte code operands are to be interpreted for each opcode. Indexed by opcode. TYPE_OF_OPERANDS[ILOAD] = an\n-     * array of shorts describing the data types for the instruction.\n-     *\/\n-    static final short[][] TYPE_OF_OPERANDS = {{}\/* nop *\/, {}\/* aconst_null *\/, {}\/* iconst_m1 *\/, {}\/* iconst_0 *\/, {}\/* iconst_1 *\/,\n-        {}\/* iconst_2 *\/, {}\/* iconst_3 *\/, {}\/* iconst_4 *\/, {}\/* iconst_5 *\/, {}\/* lconst_0 *\/, {}\/* lconst_1 *\/, {}\/* fconst_0 *\/, {}\/* fconst_1 *\/,\n-        {}\/* fconst_2 *\/, {}\/* dconst_0 *\/, {}\/* dconst_1 *\/, {T_BYTE}\/* bipush *\/, {T_SHORT}\/* sipush *\/, {T_BYTE}\/* ldc *\/, {T_SHORT}\/* ldc_w *\/,\n-        {T_SHORT}\/* ldc2_w *\/, {T_BYTE}\/* iload *\/, {T_BYTE}\/* lload *\/, {T_BYTE}\/* fload *\/, {T_BYTE}\/* dload *\/, {T_BYTE}\/* aload *\/, {}\/* iload_0 *\/,\n-        {}\/* iload_1 *\/, {}\/* iload_2 *\/, {}\/* iload_3 *\/, {}\/* lload_0 *\/, {}\/* lload_1 *\/, {}\/* lload_2 *\/, {}\/* lload_3 *\/, {}\/* fload_0 *\/, {}\/* fload_1 *\/,\n-        {}\/* fload_2 *\/, {}\/* fload_3 *\/, {}\/* dload_0 *\/, {}\/* dload_1 *\/, {}\/* dload_2 *\/, {}\/* dload_3 *\/, {}\/* aload_0 *\/, {}\/* aload_1 *\/, {}\/* aload_2 *\/,\n-        {}\/* aload_3 *\/, {}\/* iaload *\/, {}\/* laload *\/, {}\/* faload *\/, {}\/* daload *\/, {}\/* aaload *\/, {}\/* baload *\/, {}\/* caload *\/, {}\/* saload *\/,\n-        {T_BYTE}\/* istore *\/, {T_BYTE}\/* lstore *\/, {T_BYTE}\/* fstore *\/, {T_BYTE}\/* dstore *\/, {T_BYTE}\/* astore *\/, {}\/* istore_0 *\/, {}\/* istore_1 *\/,\n-        {}\/* istore_2 *\/, {}\/* istore_3 *\/, {}\/* lstore_0 *\/, {}\/* lstore_1 *\/, {}\/* lstore_2 *\/, {}\/* lstore_3 *\/, {}\/* fstore_0 *\/, {}\/* fstore_1 *\/,\n-        {}\/* fstore_2 *\/, {}\/* fstore_3 *\/, {}\/* dstore_0 *\/, {}\/* dstore_1 *\/, {}\/* dstore_2 *\/, {}\/* dstore_3 *\/, {}\/* astore_0 *\/, {}\/* astore_1 *\/,\n-        {}\/* astore_2 *\/, {}\/* astore_3 *\/, {}\/* iastore *\/, {}\/* lastore *\/, {}\/* fastore *\/, {}\/* dastore *\/, {}\/* aastore *\/, {}\/* bastore *\/,\n-        {}\/* castore *\/, {}\/* sastore *\/, {}\/* pop *\/, {}\/* pop2 *\/, {}\/* dup *\/, {}\/* dup_x1 *\/, {}\/* dup_x2 *\/, {}\/* dup2 *\/, {}\/* dup2_x1 *\/,\n-        {}\/* dup2_x2 *\/, {}\/* swap *\/, {}\/* iadd *\/, {}\/* ladd *\/, {}\/* fadd *\/, {}\/* dadd *\/, {}\/* isub *\/, {}\/* lsub *\/, {}\/* fsub *\/, {}\/* dsub *\/,\n-        {}\/* imul *\/, {}\/* lmul *\/, {}\/* fmul *\/, {}\/* dmul *\/, {}\/* idiv *\/, {}\/* ldiv *\/, {}\/* fdiv *\/, {}\/* ddiv *\/, {}\/* irem *\/, {}\/* lrem *\/,\n-        {}\/* frem *\/, {}\/* drem *\/, {}\/* ineg *\/, {}\/* lneg *\/, {}\/* fneg *\/, {}\/* dneg *\/, {}\/* ishl *\/, {}\/* lshl *\/, {}\/* ishr *\/, {}\/* lshr *\/,\n-        {}\/* iushr *\/, {}\/* lushr *\/, {}\/* iand *\/, {}\/* land *\/, {}\/* ior *\/, {}\/* lor *\/, {}\/* ixor *\/, {}\/* lxor *\/, {T_BYTE, T_BYTE}\/* iinc *\/, {}\/* i2l *\/,\n-        {}\/* i2f *\/, {}\/* i2d *\/, {}\/* l2i *\/, {}\/* l2f *\/, {}\/* l2d *\/, {}\/* f2i *\/, {}\/* f2l *\/, {}\/* f2d *\/, {}\/* d2i *\/, {}\/* d2l *\/, {}\/* d2f *\/,\n-        {}\/* i2b *\/, {}\/* i2c *\/, {}\/* i2s *\/, {}\/* lcmp *\/, {}\/* fcmpl *\/, {}\/* fcmpg *\/, {}\/* dcmpl *\/, {}\/* dcmpg *\/, {T_SHORT}\/* ifeq *\/,\n-        {T_SHORT}\/* ifne *\/, {T_SHORT}\/* iflt *\/, {T_SHORT}\/* ifge *\/, {T_SHORT}\/* ifgt *\/, {T_SHORT}\/* ifle *\/, {T_SHORT}\/* if_icmpeq *\/,\n-        {T_SHORT}\/* if_icmpne *\/, {T_SHORT}\/* if_icmplt *\/, {T_SHORT}\/* if_icmpge *\/, {T_SHORT}\/* if_icmpgt *\/, {T_SHORT}\/* if_icmple *\/,\n-        {T_SHORT}\/* if_acmpeq *\/, {T_SHORT}\/* if_acmpne *\/, {T_SHORT}\/* goto *\/, {T_SHORT}\/* jsr *\/, {T_BYTE}\/* ret *\/, {}\/* tableswitch *\/,\n-        {}\/* lookupswitch *\/, {}\/* ireturn *\/, {}\/* lreturn *\/, {}\/* freturn *\/, {}\/* dreturn *\/, {}\/* areturn *\/, {}\/* return *\/, {T_SHORT}\/* getstatic *\/,\n-        {T_SHORT}\/* putstatic *\/, {T_SHORT}\/* getfield *\/, {T_SHORT}\/* putfield *\/, {T_SHORT}\/* invokevirtual *\/, {T_SHORT}\/* invokespecial *\/,\n-        {T_SHORT}\/* invokestatic *\/, {T_SHORT, T_BYTE, T_BYTE}\/* invokeinterface *\/, {T_SHORT, T_BYTE, T_BYTE}\/* invokedynamic *\/, {T_SHORT}\/* new *\/,\n-        {T_BYTE}\/* newarray *\/, {T_SHORT}\/* anewarray *\/, {}\/* arraylength *\/, {}\/* athrow *\/, {T_SHORT}\/* checkcast *\/, {T_SHORT}\/* instanceof *\/,\n-        {}\/* monitorenter *\/, {}\/* monitorexit *\/, {T_BYTE}\/* wide *\/, {T_SHORT, T_BYTE}\/* multianewarray *\/, {T_SHORT}\/* ifnull *\/, {T_SHORT}\/* ifnonnull *\/,\n-        {T_INT}\/* goto_w *\/, {T_INT}\/* jsr_w *\/, {}\/* breakpoint *\/, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n-        {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}\/* impdep1 *\/, {}\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * Names of opcodes. Indexed by opcode. OPCODE_NAMES[ALOAD] = \"aload\".\n-     *\/\n-    static final String[] OPCODE_NAMES = {\"nop\", \"aconst_null\", \"iconst_m1\", \"iconst_0\", \"iconst_1\", \"iconst_2\", \"iconst_3\", \"iconst_4\", \"iconst_5\",\n-        \"lconst_0\", \"lconst_1\", \"fconst_0\", \"fconst_1\", \"fconst_2\", \"dconst_0\", \"dconst_1\", \"bipush\", \"sipush\", \"ldc\", \"ldc_w\", \"ldc2_w\", \"iload\", \"lload\",\n-        \"fload\", \"dload\", \"aload\", \"iload_0\", \"iload_1\", \"iload_2\", \"iload_3\", \"lload_0\", \"lload_1\", \"lload_2\", \"lload_3\", \"fload_0\", \"fload_1\", \"fload_2\",\n-        \"fload_3\", \"dload_0\", \"dload_1\", \"dload_2\", \"dload_3\", \"aload_0\", \"aload_1\", \"aload_2\", \"aload_3\", \"iaload\", \"laload\", \"faload\", \"daload\", \"aaload\",\n-        \"baload\", \"caload\", \"saload\", \"istore\", \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore_0\", \"istore_1\", \"istore_2\", \"istore_3\", \"lstore_0\", \"lstore_1\",\n-        \"lstore_2\", \"lstore_3\", \"fstore_0\", \"fstore_1\", \"fstore_2\", \"fstore_3\", \"dstore_0\", \"dstore_1\", \"dstore_2\", \"dstore_3\", \"astore_0\", \"astore_1\",\n-        \"astore_2\", \"astore_3\", \"iastore\", \"lastore\", \"fastore\", \"dastore\", \"aastore\", \"bastore\", \"castore\", \"sastore\", \"pop\", \"pop2\", \"dup\", \"dup_x1\",\n-        \"dup_x2\", \"dup2\", \"dup2_x1\", \"dup2_x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\", \"dadd\", \"isub\", \"lsub\", \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\", \"dmul\", \"idiv\",\n-        \"ldiv\", \"fdiv\", \"ddiv\", \"irem\", \"lrem\", \"frem\", \"drem\", \"ineg\", \"lneg\", \"fneg\", \"dneg\", \"ishl\", \"lshl\", \"ishr\", \"lshr\", \"iushr\", \"lushr\", \"iand\",\n-        \"land\", \"ior\", \"lor\", \"ixor\", \"lxor\", \"iinc\", \"i2l\", \"i2f\", \"i2d\", \"l2i\", \"l2f\", \"l2d\", \"f2i\", \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\", \"i2b\", \"i2c\", \"i2s\",\n-        \"lcmp\", \"fcmpl\", \"fcmpg\", \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\", \"ifgt\", \"ifle\", \"if_icmpeq\", \"if_icmpne\", \"if_icmplt\", \"if_icmpge\",\n-        \"if_icmpgt\", \"if_icmple\", \"if_acmpeq\", \"if_acmpne\", \"goto\", \"jsr\", \"ret\", \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\", \"dreturn\",\n-        \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\", \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\", \"invokeinterface\",\n-        \"invokedynamic\", \"new\", \"newarray\", \"anewarray\", \"arraylength\", \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\", \"monitorexit\", \"wide\",\n-        \"multianewarray\", \"ifnull\", \"ifnonnull\", \"goto_w\", \"jsr_w\", \"breakpoint\", ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n-        ILLEGAL_OPCODE, ILLEGAL_OPCODE, \"impdep1\", \"impdep2\"};\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static final int OPCODE_NAMES_LENGTH = OPCODE_NAMES.length;\n-\n-    \/**\n-     * Number of words consumed on operand stack by instructions. Indexed by opcode. CONSUME_STACK[FALOAD] = number of words\n-     * consumed from the stack by a faload instruction.\n-     *\/\n-    static final int[] CONSUME_STACK = {0\/* nop *\/, 0\/* aconst_null *\/, 0\/* iconst_m1 *\/, 0\/* iconst_0 *\/, 0\/* iconst_1 *\/, 0\/* iconst_2 *\/,\n-        0\/* iconst_3 *\/, 0\/* iconst_4 *\/, 0\/* iconst_5 *\/, 0\/* lconst_0 *\/, 0\/* lconst_1 *\/, 0\/* fconst_0 *\/, 0\/* fconst_1 *\/, 0\/* fconst_2 *\/, 0\/* dconst_0 *\/,\n-        0\/* dconst_1 *\/, 0\/* bipush *\/, 0\/* sipush *\/, 0\/* ldc *\/, 0\/* ldc_w *\/, 0\/* ldc2_w *\/, 0\/* iload *\/, 0\/* lload *\/, 0\/* fload *\/, 0\/* dload *\/,\n-        0\/* aload *\/, 0\/* iload_0 *\/, 0\/* iload_1 *\/, 0\/* iload_2 *\/, 0\/* iload_3 *\/, 0\/* lload_0 *\/, 0\/* lload_1 *\/, 0\/* lload_2 *\/, 0\/* lload_3 *\/,\n-        0\/* fload_0 *\/, 0\/* fload_1 *\/, 0\/* fload_2 *\/, 0\/* fload_3 *\/, 0\/* dload_0 *\/, 0\/* dload_1 *\/, 0\/* dload_2 *\/, 0\/* dload_3 *\/, 0\/* aload_0 *\/,\n-        0\/* aload_1 *\/, 0\/* aload_2 *\/, 0\/* aload_3 *\/, 2\/* iaload *\/, 2\/* laload *\/, 2\/* faload *\/, 2\/* daload *\/, 2\/* aaload *\/, 2\/* baload *\/, 2\/* caload *\/,\n-        2\/* saload *\/, 1\/* istore *\/, 2\/* lstore *\/, 1\/* fstore *\/, 2\/* dstore *\/, 1\/* astore *\/, 1\/* istore_0 *\/, 1\/* istore_1 *\/, 1\/* istore_2 *\/,\n-        1\/* istore_3 *\/, 2\/* lstore_0 *\/, 2\/* lstore_1 *\/, 2\/* lstore_2 *\/, 2\/* lstore_3 *\/, 1\/* fstore_0 *\/, 1\/* fstore_1 *\/, 1\/* fstore_2 *\/, 1\/* fstore_3 *\/,\n-        2\/* dstore_0 *\/, 2\/* dstore_1 *\/, 2\/* dstore_2 *\/, 2\/* dstore_3 *\/, 1\/* astore_0 *\/, 1\/* astore_1 *\/, 1\/* astore_2 *\/, 1\/* astore_3 *\/, 3\/* iastore *\/,\n-        4\/* lastore *\/, 3\/* fastore *\/, 4\/* dastore *\/, 3\/* aastore *\/, 3\/* bastore *\/, 3\/* castore *\/, 3\/* sastore *\/, 1\/* pop *\/, 2\/* pop2 *\/, 1\/* dup *\/,\n-        2\/* dup_x1 *\/, 3\/* dup_x2 *\/, 2\/* dup2 *\/, 3\/* dup2_x1 *\/, 4\/* dup2_x2 *\/, 2\/* swap *\/, 2\/* iadd *\/, 4\/* ladd *\/, 2\/* fadd *\/, 4\/* dadd *\/, 2\/* isub *\/,\n-        4\/* lsub *\/, 2\/* fsub *\/, 4\/* dsub *\/, 2\/* imul *\/, 4\/* lmul *\/, 2\/* fmul *\/, 4\/* dmul *\/, 2\/* idiv *\/, 4\/* ldiv *\/, 2\/* fdiv *\/, 4\/* ddiv *\/,\n-        2\/* irem *\/, 4\/* lrem *\/, 2\/* frem *\/, 4\/* drem *\/, 1\/* ineg *\/, 2\/* lneg *\/, 1\/* fneg *\/, 2\/* dneg *\/, 2\/* ishl *\/, 3\/* lshl *\/, 2\/* ishr *\/,\n-        3\/* lshr *\/, 2\/* iushr *\/, 3\/* lushr *\/, 2\/* iand *\/, 4\/* land *\/, 2\/* ior *\/, 4\/* lor *\/, 2\/* ixor *\/, 4\/* lxor *\/, 0\/* iinc *\/, 1\/* i2l *\/,\n-        1\/* i2f *\/, 1\/* i2d *\/, 2\/* l2i *\/, 2\/* l2f *\/, 2\/* l2d *\/, 1\/* f2i *\/, 1\/* f2l *\/, 1\/* f2d *\/, 2\/* d2i *\/, 2\/* d2l *\/, 2\/* d2f *\/, 1\/* i2b *\/,\n-        1\/* i2c *\/, 1\/* i2s *\/, 4\/* lcmp *\/, 2\/* fcmpl *\/, 2\/* fcmpg *\/, 4\/* dcmpl *\/, 4\/* dcmpg *\/, 1\/* ifeq *\/, 1\/* ifne *\/, 1\/* iflt *\/, 1\/* ifge *\/,\n-        1\/* ifgt *\/, 1\/* ifle *\/, 2\/* if_icmpeq *\/, 2\/* if_icmpne *\/, 2\/* if_icmplt *\/, 2 \/* if_icmpge *\/, 2\/* if_icmpgt *\/, 2\/* if_icmple *\/, 2\/* if_acmpeq *\/,\n-        2\/* if_acmpne *\/, 0\/* goto *\/, 0\/* jsr *\/, 0\/* ret *\/, 1\/* tableswitch *\/, 1\/* lookupswitch *\/, 1\/* ireturn *\/, 2\/* lreturn *\/, 1\/* freturn *\/,\n-        2\/* dreturn *\/, 1\/* areturn *\/, 0\/* return *\/, 0\/* getstatic *\/, UNPREDICTABLE\/* putstatic *\/, 1\/* getfield *\/, UNPREDICTABLE\/* putfield *\/,\n-        UNPREDICTABLE\/* invokevirtual *\/, UNPREDICTABLE\/* invokespecial *\/, UNPREDICTABLE\/* invokestatic *\/, UNPREDICTABLE\/* invokeinterface *\/,\n-        UNPREDICTABLE\/* invokedynamic *\/, 0\/* new *\/, 1\/* newarray *\/, 1\/* anewarray *\/, 1\/* arraylength *\/, 1\/* athrow *\/, 1\/* checkcast *\/, 1\/* instanceof *\/,\n-        1\/* monitorenter *\/, 1\/* monitorexit *\/, 0\/* wide *\/, UNPREDICTABLE\/* multianewarray *\/, 1\/* ifnull *\/, 1\/* ifnonnull *\/, 0\/* goto_w *\/, 0\/* jsr_w *\/,\n-        0\/* breakpoint *\/, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNPREDICTABLE\/* impdep1 *\/, UNPREDICTABLE\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * Number of words produced onto operand stack by instructions. Indexed by opcode. CONSUME_STACK[DALOAD] = number of\n-     * words consumed from the stack by a daload instruction.\n-     *\/\n-    static final int[] PRODUCE_STACK = {0\/* nop *\/, 1\/* aconst_null *\/, 1\/* iconst_m1 *\/, 1\/* iconst_0 *\/, 1\/* iconst_1 *\/, 1\/* iconst_2 *\/,\n-        1\/* iconst_3 *\/, 1\/* iconst_4 *\/, 1\/* iconst_5 *\/, 2\/* lconst_0 *\/, 2\/* lconst_1 *\/, 1\/* fconst_0 *\/, 1\/* fconst_1 *\/, 1\/* fconst_2 *\/, 2\/* dconst_0 *\/,\n-        2\/* dconst_1 *\/, 1\/* bipush *\/, 1\/* sipush *\/, 1\/* ldc *\/, 1\/* ldc_w *\/, 2\/* ldc2_w *\/, 1\/* iload *\/, 2\/* lload *\/, 1\/* fload *\/, 2\/* dload *\/,\n-        1\/* aload *\/, 1\/* iload_0 *\/, 1\/* iload_1 *\/, 1\/* iload_2 *\/, 1\/* iload_3 *\/, 2\/* lload_0 *\/, 2\/* lload_1 *\/, 2\/* lload_2 *\/, 2\/* lload_3 *\/,\n-        1\/* fload_0 *\/, 1\/* fload_1 *\/, 1\/* fload_2 *\/, 1\/* fload_3 *\/, 2\/* dload_0 *\/, 2\/* dload_1 *\/, 2\/* dload_2 *\/, 2\/* dload_3 *\/, 1\/* aload_0 *\/,\n-        1\/* aload_1 *\/, 1\/* aload_2 *\/, 1\/* aload_3 *\/, 1\/* iaload *\/, 2\/* laload *\/, 1\/* faload *\/, 2\/* daload *\/, 1\/* aaload *\/, 1\/* baload *\/, 1\/* caload *\/,\n-        1\/* saload *\/, 0\/* istore *\/, 0\/* lstore *\/, 0\/* fstore *\/, 0\/* dstore *\/, 0\/* astore *\/, 0\/* istore_0 *\/, 0\/* istore_1 *\/, 0\/* istore_2 *\/,\n-        0\/* istore_3 *\/, 0\/* lstore_0 *\/, 0\/* lstore_1 *\/, 0\/* lstore_2 *\/, 0\/* lstore_3 *\/, 0\/* fstore_0 *\/, 0\/* fstore_1 *\/, 0\/* fstore_2 *\/, 0\/* fstore_3 *\/,\n-        0\/* dstore_0 *\/, 0\/* dstore_1 *\/, 0\/* dstore_2 *\/, 0\/* dstore_3 *\/, 0\/* astore_0 *\/, 0\/* astore_1 *\/, 0\/* astore_2 *\/, 0\/* astore_3 *\/, 0\/* iastore *\/,\n-        0\/* lastore *\/, 0\/* fastore *\/, 0\/* dastore *\/, 0\/* aastore *\/, 0\/* bastore *\/, 0\/* castore *\/, 0\/* sastore *\/, 0\/* pop *\/, 0\/* pop2 *\/, 2\/* dup *\/,\n-        3\/* dup_x1 *\/, 4\/* dup_x2 *\/, 4\/* dup2 *\/, 5\/* dup2_x1 *\/, 6\/* dup2_x2 *\/, 2\/* swap *\/, 1\/* iadd *\/, 2\/* ladd *\/, 1\/* fadd *\/, 2\/* dadd *\/, 1\/* isub *\/,\n-        2\/* lsub *\/, 1\/* fsub *\/, 2\/* dsub *\/, 1\/* imul *\/, 2\/* lmul *\/, 1\/* fmul *\/, 2\/* dmul *\/, 1\/* idiv *\/, 2\/* ldiv *\/, 1\/* fdiv *\/, 2\/* ddiv *\/,\n-        1\/* irem *\/, 2\/* lrem *\/, 1\/* frem *\/, 2\/* drem *\/, 1\/* ineg *\/, 2\/* lneg *\/, 1\/* fneg *\/, 2\/* dneg *\/, 1\/* ishl *\/, 2\/* lshl *\/, 1\/* ishr *\/,\n-        2\/* lshr *\/, 1\/* iushr *\/, 2\/* lushr *\/, 1\/* iand *\/, 2\/* land *\/, 1\/* ior *\/, 2\/* lor *\/, 1\/* ixor *\/, 2\/* lxor *\/, 0\/* iinc *\/, 2\/* i2l *\/,\n-        1\/* i2f *\/, 2\/* i2d *\/, 1\/* l2i *\/, 1\/* l2f *\/, 2\/* l2d *\/, 1\/* f2i *\/, 2\/* f2l *\/, 2\/* f2d *\/, 1\/* d2i *\/, 2\/* d2l *\/, 1\/* d2f *\/, 1\/* i2b *\/,\n-        1\/* i2c *\/, 1\/* i2s *\/, 1\/* lcmp *\/, 1\/* fcmpl *\/, 1\/* fcmpg *\/, 1\/* dcmpl *\/, 1\/* dcmpg *\/, 0\/* ifeq *\/, 0\/* ifne *\/, 0\/* iflt *\/, 0\/* ifge *\/,\n-        0\/* ifgt *\/, 0\/* ifle *\/, 0\/* if_icmpeq *\/, 0\/* if_icmpne *\/, 0\/* if_icmplt *\/, 0\/* if_icmpge *\/, 0\/* if_icmpgt *\/, 0\/* if_icmple *\/, 0\/* if_acmpeq *\/,\n-        0\/* if_acmpne *\/, 0\/* goto *\/, 1\/* jsr *\/, 0\/* ret *\/, 0\/* tableswitch *\/, 0\/* lookupswitch *\/, 0\/* ireturn *\/, 0\/* lreturn *\/, 0\/* freturn *\/,\n-        0\/* dreturn *\/, 0\/* areturn *\/, 0\/* return *\/, UNPREDICTABLE\/* getstatic *\/, 0\/* putstatic *\/, UNPREDICTABLE\/* getfield *\/, 0\/* putfield *\/,\n-        UNPREDICTABLE\/* invokevirtual *\/, UNPREDICTABLE\/* invokespecial *\/, UNPREDICTABLE\/* invokestatic *\/, UNPREDICTABLE\/* invokeinterface *\/,\n-        UNPREDICTABLE\/* invokedynamic *\/, 1\/* new *\/, 1\/* newarray *\/, 1\/* anewarray *\/, 1\/* arraylength *\/, 1\/* athrow *\/, 1\/* checkcast *\/, 1\/* instanceof *\/,\n-        0\/* monitorenter *\/, 0\/* monitorexit *\/, 0\/* wide *\/, 1\/* multianewarray *\/, 0\/* ifnull *\/, 0\/* ifnonnull *\/, 0\/* goto_w *\/, 1\/* jsr_w *\/,\n-        0\/* breakpoint *\/, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n-        UNPREDICTABLE\/* impdep1 *\/, UNPREDICTABLE\/* impdep2 *\/\n-    };\n-\n-    \/**\n-     * Attributes and their corresponding names.\n-     *\/\n-    public static final byte ATTR_UNKNOWN = -1;\n-\n-    public static final byte ATTR_SOURCE_FILE = 0;\n-\n-    public static final byte ATTR_CONSTANT_VALUE = 1;\n-\n-    public static final byte ATTR_CODE = 2;\n-\n-    public static final byte ATTR_EXCEPTIONS = 3;\n-\n-    public static final byte ATTR_LINE_NUMBER_TABLE = 4;\n-\n-    public static final byte ATTR_LOCAL_VARIABLE_TABLE = 5;\n-\n-    public static final byte ATTR_INNER_CLASSES = 6;\n-\n-    public static final byte ATTR_SYNTHETIC = 7;\n-\n-    public static final byte ATTR_DEPRECATED = 8;\n-\n-    public static final byte ATTR_PMG = 9;\n-\n-    public static final byte ATTR_SIGNATURE = 10;\n-\n-    public static final byte ATTR_STACK_MAP = 11;\n-    public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS = 12;\n-    public static final byte ATTR_RUNTIME_INVISIBLE_ANNOTATIONS = 13;\n-    public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS = 14;\n-    public static final byte ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = 15;\n-    public static final byte ATTR_ANNOTATION_DEFAULT = 16;\n-    public static final byte ATTR_LOCAL_VARIABLE_TYPE_TABLE = 17;\n-    public static final byte ATTR_ENCLOSING_METHOD = 18;\n-    public static final byte ATTR_STACK_MAP_TABLE = 19;\n-    public static final byte ATTR_BOOTSTRAP_METHODS = 20;\n-    public static final byte ATTR_METHOD_PARAMETERS = 21;\n-    public static final byte ATTR_MODULE = 22;\n-    public static final byte ATTR_MODULE_PACKAGES = 23;\n-    public static final byte ATTR_MODULE_MAIN_CLASS = 24;\n-    public static final byte ATTR_NEST_HOST = 25;\n-    public static final byte ATTR_NEST_MEMBERS = 26;\n-    public static final short KNOWN_ATTRIBUTES = 27; \/\/ count of attributes\n-    private static final String[] ATTRIBUTE_NAMES = {\"SourceFile\", \"ConstantValue\", \"Code\", \"Exceptions\", \"LineNumberTable\", \"LocalVariableTable\",\n-        \"InnerClasses\", \"Synthetic\", \"Deprecated\", \"PMGClass\", \"Signature\", \"StackMap\", \"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\",\n-        \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\", \"AnnotationDefault\", \"LocalVariableTypeTable\", \"EnclosingMethod\",\n-        \"StackMapTable\", \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\", \"ModuleMainClass\", \"NestHost\", \"NestMembers\"};\n-    \/**\n-     * Constants used in the StackMap attribute.\n-     *\/\n-    public static final byte ITEM_Bogus = 0;\n-    public static final byte ITEM_Integer = 1;\n-    public static final byte ITEM_Float = 2;\n-    public static final byte ITEM_Double = 3;\n-    public static final byte ITEM_Long = 4;\n-    public static final byte ITEM_Null = 5;\n-    public static final byte ITEM_InitObject = 6;\n-    public static final byte ITEM_Object = 7;\n-    public static final byte ITEM_NewObject = 8;\n-    private static final String[] ITEM_NAMES = {\"Bogus\", \"Integer\", \"Float\", \"Double\", \"Long\", \"Null\", \"InitObject\", \"Object\", \"NewObject\"};\n-\n-    \/**\n-     * Constants used to identify StackMapEntry types.\n-     *\n-     * For those types which can specify a range, the constant names the lowest value.\n-     *\/\n-    public static final int SAME_FRAME = 0;\n-\n-    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n-\n-    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n-\n-    public static final int CHOP_FRAME = 248;\n-    public static final int SAME_FRAME_EXTENDED = 251;\n-    public static final int APPEND_FRAME = 252;\n-    public static final int FULL_FRAME = 255;\n-    \/**\n-     * Constants that define the maximum value of those constants which store ranges.\n-     *\/\n-\n-    public static final int SAME_FRAME_MAX = 63;\n-    public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX = 127;\n-    public static final int CHOP_FRAME_MAX = 250;\n-    public static final int APPEND_FRAME_MAX = 254;\n-    public static final byte REF_getField = 1;\n-\n-    public static final byte REF_getStatic = 2;\n-\n-    public static final byte REF_putField = 3;\n-\n-    public static final byte REF_putStatic = 4;\n-    public static final byte REF_invokeVirtual = 5;\n-    public static final byte REF_invokeStatic = 6;\n-    public static final byte REF_invokeSpecial = 7;\n-    public static final byte REF_newInvokeSpecial = 8;\n-    public static final byte REF_invokeInterface = 9;\n-    \/**\n-     * The names of the reference_kinds of a CONSTANT_MethodHandle_info.\n-     *\/\n-    private static final String[] METHODHANDLE_NAMES = {\"\", \"getField\", \"getStatic\", \"putField\", \"putStatic\", \"invokeVirtual\", \"invokeStatic\", \"invokeSpecial\",\n-        \"newInvokeSpecial\", \"invokeInterface\"};\n-\n-    \/**\n-     * @param index\n-     * @return the ACCESS_NAMES entry at the given index\n-     * @since 6.0\n-     *\/\n-    public static String getAccessName(final int index) {\n-        return ACCESS_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the attribute name\n-     * @since 6.0\n-     *\/\n-    public static String getAttributeName(final int index) {\n-        return ATTRIBUTE_NAMES[index];\n-    }\n-\n-    \/**\n-     * The primitive class names corresponding to the T_XX constants, e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n-     *\n-     * @param index\n-     * @return the class name\n-     * @since 6.0\n-     *\/\n-    public static String getClassTypeName(final int index) {\n-        return CLASS_TYPE_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the CONSTANT_NAMES entry at the given index\n-     * @since 6.0\n-     *\/\n-    public static String getConstantName(final int index) {\n-        return CONSTANT_NAMES[index];\n-    }\n-\n-    \/\/ Constants defining the behavior of the Method Handles (JVMS 5.4.3.5)\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return Number of words consumed on operand stack\n-     * @since 6.0\n-     *\/\n-    public static int getConsumeStack(final int index) {\n-        return CONSUME_STACK[index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static Iterable<String> getInterfacesImplementedByArrays() {\n-        return Collections.unmodifiableList(Arrays.asList(INTERFACES_IMPLEMENTED_BY_ARRAYS));\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the item name\n-     * @since 6.0\n-     *\/\n-    public static String getItemName(final int index) {\n-        return ITEM_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the method handle name\n-     * @since 6.0\n-     *\/\n-    public static String getMethodHandleName(final int index) {\n-        return METHODHANDLE_NAMES[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return Number of byte code operands\n-     * @since 6.0\n-     *\/\n-    public static short getNoOfOperands(final int index) {\n-        return NO_OF_OPERANDS[index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static String getOpcodeName(final int index) {\n-        return OPCODE_NAMES[index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static short getOperandType(final int opcode, final int index) {\n-        return TYPE_OF_OPERANDS[opcode][index];\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public static long getOperandTypeCount(final int opcode) {\n-        return TYPE_OF_OPERANDS[opcode].length;\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return Number of words produced onto operand stack\n-     * @since 6.0\n-     *\/\n-    public static int getProduceStack(final int index) {\n-        return PRODUCE_STACK[index];\n-    }\n-\n-    \/**\n-     *\n-     * @param index\n-     * @return the short type name\n-     * @since 6.0\n-     *\/\n-    public static String getShortTypeName(final int index) {\n-        return SHORT_TYPE_NAMES[index];\n-    }\n-\n-    \/**\n-     * The primitive type names corresponding to the T_XX constants, e.g., TYPE_NAMES[T_INT] = \"int\"\n-     *\n-     * @param index\n-     * @return the type name\n-     * @since 6.0\n-     *\/\n-    public static String getTypeName(final int index) {\n-        return TYPE_NAMES[index];\n-    }\n-\n-    private Const() {\n-    } \/\/ not instantiable\n+  \/**\n+   * Java class file format Magic number (0xCAFEBABE)\n+   *\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se7\/html\/jvms-4.html#jvms-4.1-200-A\">\n+   * The ClassFile Structure in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final int JVM_CLASSFILE_MAGIC = 0xCAFEBABE;\n+\n+  \/** Major version number of class files for Java 1.1.\n+   *  @see #MINOR_1_1\n+   *  *\/\n+  public static final short MAJOR_1_1 = 45;\n+\n+  \/** Minor version number of class files for Java 1.1.\n+   *  @see #MAJOR_1_1\n+   *  *\/\n+  public static final short MINOR_1_1 = 3;\n+\n+  \/** Major version number of class files for Java 1.2.\n+   *  @see #MINOR_1_2\n+   *  *\/\n+  public static final short MAJOR_1_2 = 46;\n+\n+  \/** Minor version number of class files for Java 1.2.\n+   *  @see #MAJOR_1_2\n+   *  *\/\n+  public static final short MINOR_1_2 = 0;\n+\n+  \/** Major version number of class files for Java 1.2.\n+   *  @see #MINOR_1_2\n+   *  *\/\n+  public static final short MAJOR_1_3 = 47;\n+\n+  \/** Minor version number of class files for Java 1.3.\n+   *  @see #MAJOR_1_3\n+   *  *\/\n+  public static final short MINOR_1_3 = 0;\n+\n+  \/** Major version number of class files for Java 1.3.\n+   *  @see #MINOR_1_3\n+   *  *\/\n+  public static final short MAJOR_1_4 = 48;\n+\n+  \/** Minor version number of class files for Java 1.4.\n+   *  @see #MAJOR_1_4\n+   *  *\/\n+  public static final short MINOR_1_4 = 0;\n+\n+  \/** Major version number of class files for Java 1.4.\n+   *  @see #MINOR_1_4\n+   *  *\/\n+  public static final short MAJOR_1_5 = 49;\n+\n+  \/** Minor version number of class files for Java 1.5.\n+   *  @see #MAJOR_1_5\n+   *  *\/\n+  public static final short MINOR_1_5 = 0;\n+\n+  \/** Major version number of class files for Java 1.6.\n+   *  @see #MINOR_1_6\n+   *  *\/\n+  public static final short MAJOR_1_6 = 50;\n+\n+  \/** Minor version number of class files for Java 1.6.\n+   *  @see #MAJOR_1_6\n+   *  *\/\n+  public static final short MINOR_1_6 = 0;\n+\n+  \/** Major version number of class files for Java 1.7.\n+   *  @see #MINOR_1_7\n+   *  *\/\n+  public static final short MAJOR_1_7 = 51;\n+\n+  \/** Minor version number of class files for Java 1.7.\n+   *  @see #MAJOR_1_7\n+   *  *\/\n+  public static final short MINOR_1_7 = 0;\n+\n+  \/** Major version number of class files for Java 1.8.\n+   *  @see #MINOR_1_8\n+   *  *\/\n+  public static final short MAJOR_1_8 = 52;\n+\n+  \/** Minor version number of class files for Java 1.8.\n+   *  @see #MAJOR_1_8\n+   *  *\/\n+  public static final short MINOR_1_8 = 0;\n+\n+  \/** Major version number of class files for Java 9.\n+   *  @see #MINOR_9\n+   *  *\/\n+  public static final short MAJOR_9 = 53;\n+\n+  \/** Minor version number of class files for Java 9.\n+   *  @see #MAJOR_9\n+   *  *\/\n+  public static final short MINOR_9 = 0;\n+\n+  \/**\n+   * @deprecated Use {@link #MAJOR_9} instead\n+   *\/\n+  @Deprecated\n+  public static final short MAJOR_1_9 = MAJOR_9;\n+\n+  \/**\n+   * @deprecated Use {@link #MINOR_9} instead\n+   *\/\n+  @Deprecated\n+  public static final short MINOR_1_9 = MINOR_9;\n+\n+  \/** Major version number of class files for Java 10.\n+   *  @see #MINOR_10\n+   *  *\/\n+  public static final short MAJOR_10 = 54;\n+\n+  \/** Minor version number of class files for Java 10.\n+   *  @see #MAJOR_10\n+   *  *\/\n+  public static final short MINOR_10 = 0;\n+\n+  \/** Major version number of class files for Java 11.\n+   *  @see #MINOR_11\n+   *  *\/\n+  public static final short MAJOR_11 = 55;\n+\n+  \/** Minor version number of class files for Java 11.\n+   *  @see #MAJOR_11\n+   *  *\/\n+  public static final short MINOR_11 = 0;\n+\n+  \/** Major version number of class files for Java 12.\n+   *  @see #MINOR_12\n+   *  *\/\n+  public static final short MAJOR_12 = 56;\n+\n+  \/** Minor version number of class files for Java 12.\n+   *  @see #MAJOR_12\n+   *  *\/\n+  public static final short MINOR_12 = 0;\n+\n+  \/** Major version number of class files for Java 13.\n+   *  @see #MINOR_13\n+   *  *\/\n+  public static final short MAJOR_13 = 57;\n+\n+  \/** Minor version number of class files for Java 13.\n+   *  @see #MAJOR_13\n+   *  *\/\n+  public static final short MINOR_13 = 0;\n+\n+  \/** Major version number of class files for Java 14.\n+   *  @see #MINOR_14\n+   *  @since 6.4.0\n+   *  *\/\n+  public static final short MAJOR_14 = 58;\n+\n+  \/** Minor version number of class files for Java 14.\n+   *  @see #MAJOR_14\n+   *  @since 6.4.0\n+   *  *\/\n+  public static final short MINOR_14 = 0;\n+\n+  \/** Default major version number.  Class file is for Java 1.1.\n+   *  @see #MAJOR_1_1\n+   *  *\/\n+  public static final short MAJOR = MAJOR_1_1;\n+\n+  \/** Default major version number.  Class file is for Java 1.1.\n+   *  @see #MAJOR_1_1\n+   *  *\/\n+  public static final short MINOR     = MINOR_1_1;\n+\n+  \/** Maximum value for an unsigned short.\n+   *\/\n+  public static final int MAX_SHORT = 65535; \/\/ 2^16 - 1\n+\n+  \/** Maximum value for an unsigned byte.\n+   *\/\n+  public static final int MAX_BYTE  = 255; \/\/ 2^8 - 1\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.1-200-E.1\">\n+   *  Flag definitions for Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.5\">\n+   *  Flag definitions for Fields in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.6\">\n+   *  Flag definitions for Methods in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *  @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.7.6-300-D.1-D.1\">\n+   *  Flag definitions for Inner Classes in the Java Virtual Machine Specification (Java SE 9 Edition).<\/a>\n+   *\/\n+  public static final short ACC_PUBLIC       = 0x0001;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_PRIVATE      = 0x0002;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_PROTECTED    = 0x0004;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_STATIC       = 0x0008;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_FINAL        = 0x0010;\n+\n+  \/** One of the access flags for the Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_OPEN         = 0x0020;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_SUPER        = 0x0020;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_SYNCHRONIZED = 0x0020;\n+\n+  \/** One of the access flags for the Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_TRANSITIVE   = 0x0020;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_BRIDGE       = 0x0040;\n+\n+  \/** One of the access flags for the Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_STATIC_PHASE = 0x0040;\n+\n+  \/** One of the access flags for fields.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_VOLATILE     = 0x0040;\n+\n+  \/** One of the access flags for fields.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_TRANSIENT    = 0x0080;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_VARARGS      = 0x0080;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_NATIVE       = 0x0100;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_INTERFACE    = 0x0200;\n+\n+  \/** One of the access flags for methods or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_ABSTRACT     = 0x0400;\n+\n+  \/** One of the access flags for methods.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_STRICT       = 0x0800;\n+\n+  \/** One of the access flags for fields, methods, classes, MethodParameter attribute, or Module attribute.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_SYNTHETIC    = 0x1000;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_ANNOTATION   = 0x2000;\n+\n+  \/** One of the access flags for fields or classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_ENUM         = 0x4000;\n+\n+  \/\/ Applies to classes compiled by new compilers only\n+  \/** One of the access flags for MethodParameter or Module attributes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_MANDATED     = (short) 0x8000;\n+\n+  \/** One of the access flags for classes.\n+   *  @see #ACC_PUBLIC\n+   *\/\n+  public static final short ACC_MODULE       = (short) 0x8000;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   *  @see #ACC_PUBLIC\n+   *  @deprecated Use {@link #MAX_ACC_FLAG_I}\n+   *\/\n+  @Deprecated\n+  public static final short MAX_ACC_FLAG     = ACC_ENUM;\n+\n+  \/** One of the access flags for fields, methods, or classes.\n+   * ACC_MODULE is negative as a short.\n+   * @see #ACC_PUBLIC\n+   * @since 6.4.0\n+   *\/\n+  public static final int MAX_ACC_FLAG_I = 0x8000; \/\/ ACC_MODULE is negative as a short\n+\n+  \/\/ Note that do to overloading:\n+  \/\/ 'synchronized' is for methods, might be 'open' (if Module), 'super' (if class), or 'transitive' (if Module).\n+  \/\/ 'volatile'     is for fields,  might be 'bridge' (if method) or 'static_phase' (if Module)\n+  \/\/ 'transient'    is for fields,  might be 'varargs' (if method)\n+  \/\/ 'module'       is for classes, might be 'mandated' (if Module or MethodParameters)\n+  \/**\n+   * The names of the access flags.\n+   *\/\n+  private static final String[] ACCESS_NAMES = {\n+    \"public\", \"private\", \"protected\", \"static\", \"final\", \"synchronized\",\n+    \"volatile\", \"transient\", \"native\", \"interface\", \"abstract\", \"strictfp\",\n+    \"synthetic\", \"annotation\", \"enum\", \"module\"\n+  };\n+\n+  \/** @since 6.0 *\/\n+  public static final int ACCESS_NAMES_LENGTH = ACCESS_NAMES.length;\n+\n+  \/**\n+   * @param index\n+   * @return the ACCESS_NAMES entry at the given index\n+   * @since 6.0\n+   *\/\n+  public static String getAccessName(final int index) {\n+      return ACCESS_NAMES[index];\n+  }\n+\n+  \/*\n+   * The description of the constant pool is at:\n+   * http:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4\n+   * References below are to the individual sections\n+   *\/\n+\n+  \/**\n+   * Marks a constant pool entry as type UTF-8.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.7\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Utf8               = 1;\n+\n+  \/**\n+   * Marks a constant pool entry as type Integer.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Integer            = 3;\n+\n+  \/**\n+   * Marks a constant pool entry as type Float.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.4\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Float              = 4;\n+\n+  \/**\n+   * Marks a constant pool entry as type Long.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Long               = 5;\n+\n+  \/**\n+   * Marks a constant pool entry as type Double.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.5\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Double             = 6;\n+\n+  \/**\n+   * Marks a constant pool entry as a Class\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.1\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Class              = 7;\n+\n+  \/**\n+   * Marks a constant pool entry as a Field Reference.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_Fieldref           = 9;\n+\n+  \/**\n+   * Marks a constant pool entry as type String\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.3\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_String             = 8;\n+\n+  \/** Marks a constant pool entry as a Method Reference.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a> *\/\n+  public static final byte CONSTANT_Methodref          = 10;\n+\n+  \/**\n+   * Marks a constant pool entry as an Interface Method Reference.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.2\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_InterfaceMethodref = 11;\n+\n+  \/** Marks a constant pool entry as a name and type.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.6\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a> *\/\n+  public static final byte CONSTANT_NameAndType        = 12;\n+\n+  \/**\n+   * Marks a constant pool entry as a Method Handle.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.8\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_MethodHandle       = 15;\n+\n+  \/**\n+   * Marks a constant pool entry as a Method Type.\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.9\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_MethodType         = 16;\n+\n+  \/**\n+   * Marks a constant pool entry as dynamically computed.\n+   * @see  <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\">\n+   * Change request for JEP 309<\/a>\n+   * @since 6.3\n+   *\/\n+  public static final byte CONSTANT_Dynamic            = 17;\n+\n+  \/**\n+   * Marks a constant pool entry as an Invoke Dynamic\n+   * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final byte CONSTANT_InvokeDynamic      = 18;\n+\n+  \/**\n+   * Marks a constant pool entry as a Module Reference.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.11\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   * @since 6.1\n+   *\/\n+  public static final byte CONSTANT_Module             = 19;\n+\n+  \/**\n+   * Marks a constant pool entry as a Package Reference.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se9\/html\/jvms-4.html#jvms-4.4.12\">\n+   * The Constant Pool in The Java Virtual Machine Specification<\/a>\n+   * @since 6.1\n+   *\/\n+  public static final byte CONSTANT_Package            = 20;\n+\n+  \/**\n+   * The names of the types of entries in a constant pool.\n+   * Use getConstantName instead\n+   *\/\n+  private static final String[] CONSTANT_NAMES = {\n+    \"\", \"CONSTANT_Utf8\", \"\", \"CONSTANT_Integer\",\n+    \"CONSTANT_Float\", \"CONSTANT_Long\", \"CONSTANT_Double\",\n+    \"CONSTANT_Class\", \"CONSTANT_String\", \"CONSTANT_Fieldref\",\n+    \"CONSTANT_Methodref\", \"CONSTANT_InterfaceMethodref\",\n+    \"CONSTANT_NameAndType\", \"\", \"\", \"CONSTANT_MethodHandle\",\n+    \"CONSTANT_MethodType\", \"CONSTANT_Dynamic\", \"CONSTANT_InvokeDynamic\",\n+    \"CONSTANT_Module\", \"CONSTANT_Package\"};\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the CONSTANT_NAMES entry at the given index\n+   * @since 6.0\n+   *\/\n+  public static String getConstantName(final int index) {\n+      return CONSTANT_NAMES[index];\n+  }\n+\n+  \/** The name of the static initializer, also called &quot;class\n+   *  initialization method&quot; or &quot;interface initialization\n+   *   method&quot;. This is &quot;&lt;clinit&gt;&quot;.\n+   *\/\n+  public static final String STATIC_INITIALIZER_NAME = \"<clinit>\";\n+\n+  \/** The name of every constructor method in a class, also called\n+   * &quot;instance initialization method&quot;. This is &quot;&lt;init&gt;&quot;.\n+   *\/\n+  public static final String CONSTRUCTOR_NAME = \"<init>\";\n+\n+  \/**\n+   * The names of the interfaces implemented by arrays\n+   *\/\n+  private static final String[] INTERFACES_IMPLEMENTED_BY_ARRAYS = {\"java.lang.Cloneable\", \"java.io.Serializable\"};\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static Iterable<String> getInterfacesImplementedByArrays() {\n+      return Collections.unmodifiableList(Arrays.asList(INTERFACES_IMPLEMENTED_BY_ARRAYS));\n+  }\n+\n+  \/**\n+   * Maximum Constant Pool entries.\n+   * One of the limitations of the Java Virtual Machine.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.11-100-A\">\n+   * The Java Virtual Machine Specification, Java SE 8 Edition, page 330, chapter 4.11.<\/a>\n+   *\/\n+  public static final int MAX_CP_ENTRIES     = 65535;\n+\n+  \/**\n+   * Maximum code size (plus one; the code size must be LESS than this)\n+   * One of the limitations of the Java Virtual Machine.\n+   * Note vmspec2 page 152 (\"Limitations\") says:\n+   * \"The amount of code per non-native, non-abstract method is limited to 65536 bytes by\n+   * the sizes of the indices in the exception_table of the Code attribute (4.7.3),\n+   * in the LineNumberTable attribute (4.7.8), and in the LocalVariableTable attribute (4.7.9).\"\n+   * However this should be taken as an upper limit rather than the defined maximum.\n+   * On page 134 (4.8.1 Static Constants) of the same spec, it says:\n+   * \"The value of the code_length item must be less than 65536.\"\n+   * The entry in the Limitations section has been removed from later versions of the spec;\n+   * it is not present in the Java SE 8 edition.\n+   *\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.3-300-E\">\n+   * The Java Virtual Machine Specification, Java SE 8 Edition, page 104, chapter 4.7.<\/a>\n+   *\/\n+  public static final int MAX_CODE_SIZE      = 65536; \/\/bytes\n+\n+  \/**\n+   * The maximum number of dimensions in an array ({@value}).\n+   * One of the limitations of the Java Virtual Machine.\n+   *\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3.2-150\">\n+   * Field Descriptors in The Java Virtual Machine Specification<\/a>\n+   *\/\n+  public static final int MAX_ARRAY_DIMENSIONS = 255;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.nop\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short NOP              = 0;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aconst_null\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ACONST_NULL      = 1;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_M1        = 2;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_0         = 3;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_1         = 4;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_2         = 5;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_3         = 6;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_4         = 7;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iconst_i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ICONST_5         = 8;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LCONST_0         = 9;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lconst_l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LCONST_1         = 10;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCONST_0         = 11;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCONST_1         = 12;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fconst_f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCONST_2         = 13;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCONST_0         = 14;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dconst_d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCONST_1         = 15;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bipush\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short BIPUSH           = 16;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sipush\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SIPUSH           = 17;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDC              = 18;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDC_W            = 19;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldc2_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDC2_W           = 20;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD            = 21;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD            = 22;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD            = 23;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD            = 24;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD            = 25;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_0          = 26;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_1          = 27;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_2          = 28;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ILOAD_3          = 29;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_0          = 30;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_1          = 31;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_2          = 32;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LLOAD_3          = 33;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_0          = 34;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_1          = 35;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_2          = 36;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FLOAD_3          = 37;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_0          = 38;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_1          = 39;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_2          = 40;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DLOAD_3          = 41;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_0          = 42;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_1          = 43;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_2          = 44;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aload_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ALOAD_3          = 45;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iaload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IALOAD           = 46;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.laload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LALOAD           = 47;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.faload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FALOAD           = 48;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.daload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DALOAD           = 49;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aaload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short AALOAD           = 50;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.baload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short BALOAD           = 51;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.caload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short CALOAD           = 52;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.saload\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SALOAD           = 53;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE           = 54;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE           = 55;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE           = 56;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE           = 57;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE           = 58;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_0         = 59;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_1         = 60;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_2         = 61;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.istore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISTORE_3         = 62;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_0         = 63;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_1         = 64;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_2         = 65;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSTORE_3         = 66;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_0         = 67;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_1         = 68;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_2         = 69;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSTORE_3         = 70;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_0         = 71;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_1         = 72;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_2         = 73;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dstore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSTORE_3         = 74;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_0         = 75;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_1         = 76;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_2         = 77;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.astore_n\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ASTORE_3         = 78;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IASTORE          = 79;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LASTORE          = 80;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FASTORE          = 81;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DASTORE          = 82;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.aastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short AASTORE          = 83;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.bastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short BASTORE          = 84;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.castore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short CASTORE          = 85;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.sastore\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SASTORE          = 86;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short POP              = 87;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.pop2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short POP2             = 88;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP              = 89;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x1\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP_X1           = 90;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup_x2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP_X2           = 91;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP2             = 92;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x1\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP2_X1          = 93;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dup2_x2\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DUP2_X2          = 94;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.swap\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short SWAP             = 95;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iadd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IADD             = 96;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ladd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LADD             = 97;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fadd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FADD             = 98;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dadd\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DADD             = 99;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.isub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISUB             = 100;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lsub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSUB             = 101;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fsub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FSUB             = 102;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dsub\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DSUB             = 103;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.imul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IMUL             = 104;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lmul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LMUL             = 105;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fmul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FMUL             = 106;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dmul\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DMUL             = 107;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.idiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IDIV             = 108;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ldiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LDIV             = 109;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fdiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FDIV             = 110;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ddiv\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DDIV             = 111;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.irem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IREM             = 112;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lrem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LREM             = 113;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.frem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FREM             = 114;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.drem\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DREM             = 115;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ineg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INEG             = 116;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lneg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LNEG             = 117;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fneg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FNEG             = 118;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dneg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DNEG             = 119;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISHL             = 120;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSHL             = 121;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ishr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ISHR             = 122;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lshr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LSHR             = 123;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iushr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IUSHR            = 124;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lushr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LUSHR            = 125;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iand\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IAND             = 126;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.land\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LAND             = 127;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ior\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IOR              = 128;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lor\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LOR              = 129;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ixor\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IXOR             = 130;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lxor\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LXOR             = 131;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iinc\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IINC             = 132;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2L              = 133;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2F              = 134;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2D              = 135;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short L2I              = 136;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short L2F              = 137;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.l2d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short L2D              = 138;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short F2I              = 139;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short F2L              = 140;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.f2d\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short F2D              = 141;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2i\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short D2I              = 142;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2l\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short D2L              = 143;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.d2f\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short D2F              = 144;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2b\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2B              = 145;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INT2BYTE         = 145; \/\/ Old notation\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2c\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2C              = 146;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INT2CHAR         = 146; \/\/ Old notation\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.i2s\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short I2S              = 147;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INT2SHORT        = 147; \/\/ Old notation\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lcmp\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LCMP             = 148;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCMPL            = 149;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.fcmpg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FCMPG            = 150;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpl\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCMPL            = 151;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dcmpg\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DCMPG            = 152;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifeq\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFEQ             = 153;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifne\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFNE             = 154;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.iflt\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFLT             = 155;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifge\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFGE             = 156;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifgt\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFGT             = 157;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifle\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFLE             = 158;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPEQ        = 159;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPNE        = 160;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPLT        = 161;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPGE        = 162;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPGT        = 163;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_icmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ICMPLE        = 164;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ACMPEQ        = 165;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.if_acmp_cond\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IF_ACMPNE        = 166;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GOTO             = 167;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short JSR              = 168;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ret\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short RET              = 169;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.tableswitch\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short TABLESWITCH      = 170;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lookupswitch\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LOOKUPSWITCH     = 171;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ireturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IRETURN          = 172;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.lreturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short LRETURN          = 173;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.freturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short FRETURN          = 174;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.dreturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short DRETURN          = 175;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.areturn\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ARETURN          = 176;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.return\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short RETURN           = 177;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getstatic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GETSTATIC        = 178;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putstatic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short PUTSTATIC        = 179;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.getfield\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GETFIELD         = 180;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.putfield\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short PUTFIELD         = 181;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKEVIRTUAL    = 182;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKESPECIAL    = 183;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKENONVIRTUAL = 183; \/\/ Old name in JDK 1.0\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKESTATIC     = 184;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKEINTERFACE  = 185;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INVOKEDYNAMIC    = 186;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.new\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short NEW              = 187;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.newarray\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short NEWARRAY         = 188;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.anewarray\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ANEWARRAY        = 189;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.arraylength\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ARRAYLENGTH      = 190;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.athrow\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short ATHROW           = 191;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.checkcast\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short CHECKCAST        = 192;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.instanceof\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short INSTANCEOF       = 193;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorenter\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short MONITORENTER     = 194;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.monitorexit\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short MONITOREXIT      = 195;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.wide\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short WIDE             = 196;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.multianewarray\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short MULTIANEWARRAY   = 197;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnull\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFNULL           = 198;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.ifnonnull\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short IFNONNULL        = 199;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.goto_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short GOTO_W           = 200;\n+\n+  \/** Java VM opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.jsr_w\">\n+   * Opcode definitions in The Java Virtual Machine Specification<\/a> *\/\n+  public static final short JSR_W            = 201;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n+   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n+  public static final short BREAKPOINT                = 202;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short LDC_QUICK                 = 203;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short LDC_W_QUICK               = 204;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short LDC2_W_QUICK              = 205;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETFIELD_QUICK            = 206;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTFIELD_QUICK            = 207;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETFIELD2_QUICK           = 208;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTFIELD2_QUICK           = 209;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETSTATIC_QUICK           = 210;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTSTATIC_QUICK           = 211;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETSTATIC2_QUICK          = 212;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTSTATIC2_QUICK          = 213;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEVIRTUAL_QUICK       = 214;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKENONVIRTUAL_QUICK    = 215;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKESUPER_QUICK         = 216;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKESTATIC_QUICK        = 217;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEINTERFACE_QUICK     = 218;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEVIRTUALOBJECT_QUICK = 219;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short NEW_QUICK                 = 221;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short ANEWARRAY_QUICK           = 222;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short MULTIANEWARRAY_QUICK      = 223;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short CHECKCAST_QUICK           = 224;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INSTANCEOF_QUICK          = 225;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short INVOKEVIRTUAL_QUICK_W     = 226;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short GETFIELD_QUICK_W          = 227;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/web.archive.org\/web\/20120108031230\/http:\/\/java.sun.com\/docs\/books\/jvms\/first_edition\/html\/Quick.doc.html\">\n+   * Specification of _quick opcodes in the Java Virtual Machine Specification (version 1)<\/a>\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se5.0\/html\/ChangesAppendix.doc.html#448885\">\n+   * Why the _quick opcodes were removed from the second version of the Java Virtual Machine Specification.<\/a> *\/\n+  public static final short PUTFIELD_QUICK_W          = 228;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n+   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n+  public static final short IMPDEP1                   = 254;\n+\n+  \/** JVM internal opcode.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.2\">\n+   * Reserved opcodes in the Java Virtual Machine Specification<\/a> *\/\n+  public static final short IMPDEP2                   = 255;\n+\n+  \/**\n+   * BCEL virtual instruction for pushing an arbitrary data type onto the stack.  Will be converted to the appropriate JVM\n+   * opcode when the class is dumped.\n+   *\/\n+  public static final short PUSH             = 4711;\n+\n+  \/**\n+   * BCEL virtual instruction for either LOOKUPSWITCH or TABLESWITCH.  Will be converted to the appropriate JVM\n+   * opcode when the class is dumped.\n+   *\/\n+  public static final short SWITCH           = 4712;\n+\n+  \/** Illegal opcode. *\/\n+  public static final short  UNDEFINED      = -1;\n+\n+  \/** Illegal opcode. *\/\n+  public static final short  UNPREDICTABLE  = -2;\n+\n+  \/** Illegal opcode. *\/\n+  public static final short  RESERVED       = -3;\n+\n+  \/** Mnemonic for an illegal opcode. *\/\n+  public static final String ILLEGAL_OPCODE = \"<illegal opcode>\";\n+\n+  \/** Mnemonic for an illegal type. *\/\n+  public static final String ILLEGAL_TYPE   = \"<illegal type>\";\n+\n+  \/** Boolean data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_BOOLEAN = 4;\n+\n+  \/** Char data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_CHAR    = 5;\n+\n+  \/** Float data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_FLOAT   = 6;\n+\n+  \/** Double data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_DOUBLE  = 7;\n+\n+  \/** Byte data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_BYTE    = 8;\n+\n+  \/** Short data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_SHORT   = 9;\n+\n+  \/** Int data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_INT     = 10;\n+\n+  \/** Long data type.\n+   * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.9.1-120-P\">\n+   * Static Constraints in the Java Virtual Machine Specification<\/a> *\/\n+  public static final byte T_LONG    = 11;\n+\n+  \/** Void data type (non-standard). *\/\n+  public static final byte T_VOID      = 12; \/\/ Non-standard\n+\n+  \/** Array data type. *\/\n+  public static final byte T_ARRAY     = 13;\n+\n+  \/** Object data type. *\/\n+  public static final byte T_OBJECT    = 14;\n+\n+  \/** Reference data type (deprecated). *\/\n+  public static final byte T_REFERENCE = 14; \/\/ Deprecated\n+\n+  \/** Unknown data type. *\/\n+  public static final byte T_UNKNOWN   = 15;\n+\n+  \/** Address data type. *\/\n+  public static final byte T_ADDRESS   = 16;\n+\n+  \/** The primitive type names corresponding to the T_XX constants,\n+   * e.g., TYPE_NAMES[T_INT] = \"int\"\n+   *\/\n+  private static final String[] TYPE_NAMES = {\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n+    \"boolean\", \"char\", \"float\", \"double\", \"byte\", \"short\", \"int\", \"long\",\n+    \"void\", \"array\", \"object\", \"unknown\", \"address\"\n+  };\n+\n+  \/**\n+   * The primitive type names corresponding to the T_XX constants,\n+   * e.g., TYPE_NAMES[T_INT] = \"int\"\n+   * @param index\n+   * @return the type name\n+   * @since 6.0\n+   *\/\n+  public static String getTypeName(final int index) {\n+      return TYPE_NAMES[index];\n+  }\n+\n+  \/** The primitive class names corresponding to the T_XX constants,\n+   * e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n+   *\/\n+  private static final String[] CLASS_TYPE_NAMES = {\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n+    \"java.lang.Boolean\", \"java.lang.Character\", \"java.lang.Float\",\n+    \"java.lang.Double\", \"java.lang.Byte\", \"java.lang.Short\",\n+    \"java.lang.Integer\", \"java.lang.Long\", \"java.lang.Void\",\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE,  ILLEGAL_TYPE\n+  };\n+\n+  \/**\n+   * The primitive class names corresponding to the T_XX constants,\n+   * e.g., CLASS_TYPE_NAMES[T_INT] = \"java.lang.Integer\"\n+   * @param index\n+   * @return the class name\n+   * @since 6.0\n+   *\/\n+  public static String getClassTypeName(final int index) {\n+      return CLASS_TYPE_NAMES[index];\n+  }\n+\n+  \/** The signature characters corresponding to primitive types,\n+   * e.g., SHORT_TYPE_NAMES[T_INT] = \"I\"\n+   *\/\n+  private static final String[] SHORT_TYPE_NAMES = {\n+    ILLEGAL_TYPE, ILLEGAL_TYPE,  ILLEGAL_TYPE, ILLEGAL_TYPE,\n+    \"Z\", \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"J\",\n+    \"V\", ILLEGAL_TYPE, ILLEGAL_TYPE, ILLEGAL_TYPE\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the short type name\n+   * @since 6.0\n+   *\/\n+  public static String getShortTypeName(final int index) {\n+      return SHORT_TYPE_NAMES[index];\n+  }\n+\n+\n+  \/**\n+   * Number of byte code operands for each opcode, i.e., number of bytes after the tag byte\n+   * itself.  Indexed by opcode, so NO_OF_OPERANDS[BIPUSH] = the number of operands for a bipush\n+   * instruction.\n+   *\/\n+  private static final short[] NO_OF_OPERANDS = {\n+    0\/*nop*\/, 0\/*aconst_null*\/, 0\/*iconst_m1*\/, 0\/*iconst_0*\/,\n+    0\/*iconst_1*\/, 0\/*iconst_2*\/, 0\/*iconst_3*\/, 0\/*iconst_4*\/,\n+    0\/*iconst_5*\/, 0\/*lconst_0*\/, 0\/*lconst_1*\/, 0\/*fconst_0*\/,\n+    0\/*fconst_1*\/, 0\/*fconst_2*\/, 0\/*dconst_0*\/, 0\/*dconst_1*\/,\n+    1\/*bipush*\/, 2\/*sipush*\/, 1\/*ldc*\/, 2\/*ldc_w*\/, 2\/*ldc2_w*\/,\n+    1\/*iload*\/, 1\/*lload*\/, 1\/*fload*\/, 1\/*dload*\/, 1\/*aload*\/,\n+    0\/*iload_0*\/, 0\/*iload_1*\/, 0\/*iload_2*\/, 0\/*iload_3*\/,\n+    0\/*lload_0*\/, 0\/*lload_1*\/, 0\/*lload_2*\/, 0\/*lload_3*\/,\n+    0\/*fload_0*\/, 0\/*fload_1*\/, 0\/*fload_2*\/, 0\/*fload_3*\/,\n+    0\/*dload_0*\/, 0\/*dload_1*\/, 0\/*dload_2*\/, 0\/*dload_3*\/,\n+    0\/*aload_0*\/, 0\/*aload_1*\/, 0\/*aload_2*\/, 0\/*aload_3*\/,\n+    0\/*iaload*\/, 0\/*laload*\/, 0\/*faload*\/, 0\/*daload*\/,\n+    0\/*aaload*\/, 0\/*baload*\/, 0\/*caload*\/, 0\/*saload*\/,\n+    1\/*istore*\/, 1\/*lstore*\/, 1\/*fstore*\/, 1\/*dstore*\/,\n+    1\/*astore*\/, 0\/*istore_0*\/, 0\/*istore_1*\/, 0\/*istore_2*\/,\n+    0\/*istore_3*\/, 0\/*lstore_0*\/, 0\/*lstore_1*\/, 0\/*lstore_2*\/,\n+    0\/*lstore_3*\/, 0\/*fstore_0*\/, 0\/*fstore_1*\/, 0\/*fstore_2*\/,\n+    0\/*fstore_3*\/, 0\/*dstore_0*\/, 0\/*dstore_1*\/, 0\/*dstore_2*\/,\n+    0\/*dstore_3*\/, 0\/*astore_0*\/, 0\/*astore_1*\/, 0\/*astore_2*\/,\n+    0\/*astore_3*\/, 0\/*iastore*\/, 0\/*lastore*\/, 0\/*fastore*\/,\n+    0\/*dastore*\/, 0\/*aastore*\/, 0\/*bastore*\/, 0\/*castore*\/,\n+    0\/*sastore*\/, 0\/*pop*\/, 0\/*pop2*\/, 0\/*dup*\/, 0\/*dup_x1*\/,\n+    0\/*dup_x2*\/, 0\/*dup2*\/, 0\/*dup2_x1*\/, 0\/*dup2_x2*\/, 0\/*swap*\/,\n+    0\/*iadd*\/, 0\/*ladd*\/, 0\/*fadd*\/, 0\/*dadd*\/, 0\/*isub*\/,\n+    0\/*lsub*\/, 0\/*fsub*\/, 0\/*dsub*\/, 0\/*imul*\/, 0\/*lmul*\/,\n+    0\/*fmul*\/, 0\/*dmul*\/, 0\/*idiv*\/, 0\/*ldiv*\/, 0\/*fdiv*\/,\n+    0\/*ddiv*\/, 0\/*irem*\/, 0\/*lrem*\/, 0\/*frem*\/, 0\/*drem*\/,\n+    0\/*ineg*\/, 0\/*lneg*\/, 0\/*fneg*\/, 0\/*dneg*\/, 0\/*ishl*\/,\n+    0\/*lshl*\/, 0\/*ishr*\/, 0\/*lshr*\/, 0\/*iushr*\/, 0\/*lushr*\/,\n+    0\/*iand*\/, 0\/*land*\/, 0\/*ior*\/, 0\/*lor*\/, 0\/*ixor*\/, 0\/*lxor*\/,\n+    2\/*iinc*\/, 0\/*i2l*\/, 0\/*i2f*\/, 0\/*i2d*\/, 0\/*l2i*\/, 0\/*l2f*\/,\n+    0\/*l2d*\/, 0\/*f2i*\/, 0\/*f2l*\/, 0\/*f2d*\/, 0\/*d2i*\/, 0\/*d2l*\/,\n+    0\/*d2f*\/, 0\/*i2b*\/, 0\/*i2c*\/, 0\/*i2s*\/, 0\/*lcmp*\/, 0\/*fcmpl*\/,\n+    0\/*fcmpg*\/, 0\/*dcmpl*\/, 0\/*dcmpg*\/, 2\/*ifeq*\/, 2\/*ifne*\/,\n+    2\/*iflt*\/, 2\/*ifge*\/, 2\/*ifgt*\/, 2\/*ifle*\/, 2\/*if_icmpeq*\/,\n+    2\/*if_icmpne*\/, 2\/*if_icmplt*\/, 2\/*if_icmpge*\/, 2\/*if_icmpgt*\/,\n+    2\/*if_icmple*\/, 2\/*if_acmpeq*\/, 2\/*if_acmpne*\/, 2\/*goto*\/,\n+    2\/*jsr*\/, 1\/*ret*\/, UNPREDICTABLE\/*tableswitch*\/, UNPREDICTABLE\/*lookupswitch*\/,\n+    0\/*ireturn*\/, 0\/*lreturn*\/, 0\/*freturn*\/,\n+    0\/*dreturn*\/, 0\/*areturn*\/, 0\/*return*\/,\n+    2\/*getstatic*\/, 2\/*putstatic*\/, 2\/*getfield*\/,\n+    2\/*putfield*\/, 2\/*invokevirtual*\/, 2\/*invokespecial*\/, 2\/*invokestatic*\/,\n+    4\/*invokeinterface*\/, 4\/*invokedynamic*\/, 2\/*new*\/,\n+    1\/*newarray*\/, 2\/*anewarray*\/,\n+    0\/*arraylength*\/, 0\/*athrow*\/, 2\/*checkcast*\/,\n+    2\/*instanceof*\/, 0\/*monitorenter*\/,\n+    0\/*monitorexit*\/, UNPREDICTABLE\/*wide*\/, 3\/*multianewarray*\/,\n+    2\/*ifnull*\/, 2\/*ifnonnull*\/, 4\/*goto_w*\/,\n+    4\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, RESERVED\/*impdep1*\/, RESERVED\/*impdep2*\/\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return Number of byte code operands\n+   * @since 6.0\n+   *\/\n+  public static short getNoOfOperands(final int index) {\n+      return NO_OF_OPERANDS[index];\n+  }\n+\n+  \/**\n+   * How the byte code operands are to be interpreted for each opcode.\n+   * Indexed by opcode.  TYPE_OF_OPERANDS[ILOAD] = an array of shorts\n+   * describing the data types for the instruction.\n+   *\/\n+  private static final short[][] TYPE_OF_OPERANDS = {\n+    {}\/*nop*\/, {}\/*aconst_null*\/, {}\/*iconst_m1*\/, {}\/*iconst_0*\/,\n+    {}\/*iconst_1*\/, {}\/*iconst_2*\/, {}\/*iconst_3*\/, {}\/*iconst_4*\/,\n+    {}\/*iconst_5*\/, {}\/*lconst_0*\/, {}\/*lconst_1*\/, {}\/*fconst_0*\/,\n+    {}\/*fconst_1*\/, {}\/*fconst_2*\/, {}\/*dconst_0*\/, {}\/*dconst_1*\/,\n+    {T_BYTE}\/*bipush*\/, {T_SHORT}\/*sipush*\/, {T_BYTE}\/*ldc*\/,\n+    {T_SHORT}\/*ldc_w*\/, {T_SHORT}\/*ldc2_w*\/,\n+    {T_BYTE}\/*iload*\/, {T_BYTE}\/*lload*\/, {T_BYTE}\/*fload*\/,\n+    {T_BYTE}\/*dload*\/, {T_BYTE}\/*aload*\/, {}\/*iload_0*\/,\n+    {}\/*iload_1*\/, {}\/*iload_2*\/, {}\/*iload_3*\/, {}\/*lload_0*\/,\n+    {}\/*lload_1*\/, {}\/*lload_2*\/, {}\/*lload_3*\/, {}\/*fload_0*\/,\n+    {}\/*fload_1*\/, {}\/*fload_2*\/, {}\/*fload_3*\/, {}\/*dload_0*\/,\n+    {}\/*dload_1*\/, {}\/*dload_2*\/, {}\/*dload_3*\/, {}\/*aload_0*\/,\n+    {}\/*aload_1*\/, {}\/*aload_2*\/, {}\/*aload_3*\/, {}\/*iaload*\/,\n+    {}\/*laload*\/, {}\/*faload*\/, {}\/*daload*\/, {}\/*aaload*\/,\n+    {}\/*baload*\/, {}\/*caload*\/, {}\/*saload*\/, {T_BYTE}\/*istore*\/,\n+    {T_BYTE}\/*lstore*\/, {T_BYTE}\/*fstore*\/, {T_BYTE}\/*dstore*\/,\n+    {T_BYTE}\/*astore*\/, {}\/*istore_0*\/, {}\/*istore_1*\/,\n+    {}\/*istore_2*\/, {}\/*istore_3*\/, {}\/*lstore_0*\/, {}\/*lstore_1*\/,\n+    {}\/*lstore_2*\/, {}\/*lstore_3*\/, {}\/*fstore_0*\/, {}\/*fstore_1*\/,\n+    {}\/*fstore_2*\/, {}\/*fstore_3*\/, {}\/*dstore_0*\/, {}\/*dstore_1*\/,\n+    {}\/*dstore_2*\/, {}\/*dstore_3*\/, {}\/*astore_0*\/, {}\/*astore_1*\/,\n+    {}\/*astore_2*\/, {}\/*astore_3*\/, {}\/*iastore*\/, {}\/*lastore*\/,\n+    {}\/*fastore*\/, {}\/*dastore*\/, {}\/*aastore*\/, {}\/*bastore*\/,\n+    {}\/*castore*\/, {}\/*sastore*\/, {}\/*pop*\/, {}\/*pop2*\/, {}\/*dup*\/,\n+    {}\/*dup_x1*\/, {}\/*dup_x2*\/, {}\/*dup2*\/, {}\/*dup2_x1*\/,\n+    {}\/*dup2_x2*\/, {}\/*swap*\/, {}\/*iadd*\/, {}\/*ladd*\/, {}\/*fadd*\/,\n+    {}\/*dadd*\/, {}\/*isub*\/, {}\/*lsub*\/, {}\/*fsub*\/, {}\/*dsub*\/,\n+    {}\/*imul*\/, {}\/*lmul*\/, {}\/*fmul*\/, {}\/*dmul*\/, {}\/*idiv*\/,\n+    {}\/*ldiv*\/, {}\/*fdiv*\/, {}\/*ddiv*\/, {}\/*irem*\/, {}\/*lrem*\/,\n+    {}\/*frem*\/, {}\/*drem*\/, {}\/*ineg*\/, {}\/*lneg*\/, {}\/*fneg*\/,\n+    {}\/*dneg*\/, {}\/*ishl*\/, {}\/*lshl*\/, {}\/*ishr*\/, {}\/*lshr*\/,\n+    {}\/*iushr*\/, {}\/*lushr*\/, {}\/*iand*\/, {}\/*land*\/, {}\/*ior*\/,\n+    {}\/*lor*\/, {}\/*ixor*\/, {}\/*lxor*\/, {T_BYTE, T_BYTE}\/*iinc*\/,\n+    {}\/*i2l*\/, {}\/*i2f*\/, {}\/*i2d*\/, {}\/*l2i*\/, {}\/*l2f*\/, {}\/*l2d*\/,\n+    {}\/*f2i*\/, {}\/*f2l*\/, {}\/*f2d*\/, {}\/*d2i*\/, {}\/*d2l*\/, {}\/*d2f*\/,\n+    {}\/*i2b*\/, {}\/*i2c*\/, {}\/*i2s*\/, {}\/*lcmp*\/, {}\/*fcmpl*\/,\n+    {}\/*fcmpg*\/, {}\/*dcmpl*\/, {}\/*dcmpg*\/, {T_SHORT}\/*ifeq*\/,\n+    {T_SHORT}\/*ifne*\/, {T_SHORT}\/*iflt*\/, {T_SHORT}\/*ifge*\/,\n+    {T_SHORT}\/*ifgt*\/, {T_SHORT}\/*ifle*\/, {T_SHORT}\/*if_icmpeq*\/,\n+    {T_SHORT}\/*if_icmpne*\/, {T_SHORT}\/*if_icmplt*\/,\n+    {T_SHORT}\/*if_icmpge*\/, {T_SHORT}\/*if_icmpgt*\/,\n+    {T_SHORT}\/*if_icmple*\/, {T_SHORT}\/*if_acmpeq*\/,\n+    {T_SHORT}\/*if_acmpne*\/, {T_SHORT}\/*goto*\/, {T_SHORT}\/*jsr*\/,\n+    {T_BYTE}\/*ret*\/, {}\/*tableswitch*\/, {}\/*lookupswitch*\/,\n+    {}\/*ireturn*\/, {}\/*lreturn*\/, {}\/*freturn*\/, {}\/*dreturn*\/,\n+    {}\/*areturn*\/, {}\/*return*\/, {T_SHORT}\/*getstatic*\/,\n+    {T_SHORT}\/*putstatic*\/, {T_SHORT}\/*getfield*\/,\n+    {T_SHORT}\/*putfield*\/, {T_SHORT}\/*invokevirtual*\/,\n+    {T_SHORT}\/*invokespecial*\/, {T_SHORT}\/*invokestatic*\/,\n+    {T_SHORT, T_BYTE, T_BYTE}\/*invokeinterface*\/, {T_SHORT, T_BYTE, T_BYTE}\/*invokedynamic*\/,\n+    {T_SHORT}\/*new*\/, {T_BYTE}\/*newarray*\/,\n+    {T_SHORT}\/*anewarray*\/, {}\/*arraylength*\/, {}\/*athrow*\/,\n+    {T_SHORT}\/*checkcast*\/, {T_SHORT}\/*instanceof*\/,\n+    {}\/*monitorenter*\/, {}\/*monitorexit*\/, {T_BYTE}\/*wide*\/,\n+    {T_SHORT, T_BYTE}\/*multianewarray*\/, {T_SHORT}\/*ifnull*\/,\n+    {T_SHORT}\/*ifnonnull*\/, {T_INT}\/*goto_w*\/, {T_INT}\/*jsr_w*\/,\n+    {}\/*breakpoint*\/, {}, {}, {}, {}, {}, {}, {},\n+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n+    {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {},\n+    {}\/*impdep1*\/, {}\/*impdep2*\/\n+  };\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static short getOperandType(final int opcode, final int index) {\n+      return TYPE_OF_OPERANDS[opcode][index];\n+  }\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static long getOperandTypeCount(final int opcode) {\n+      return TYPE_OF_OPERANDS[opcode].length;\n+  }\n+\n+  \/**\n+   * Names of opcodes.  Indexed by opcode.  OPCODE_NAMES[ALOAD] = \"aload\".\n+   *\/\n+  private static final String[] OPCODE_NAMES = {\n+    \"nop\", \"aconst_null\", \"iconst_m1\", \"iconst_0\", \"iconst_1\",\n+    \"iconst_2\", \"iconst_3\", \"iconst_4\", \"iconst_5\", \"lconst_0\",\n+    \"lconst_1\", \"fconst_0\", \"fconst_1\", \"fconst_2\", \"dconst_0\",\n+    \"dconst_1\", \"bipush\", \"sipush\", \"ldc\", \"ldc_w\", \"ldc2_w\", \"iload\",\n+    \"lload\", \"fload\", \"dload\", \"aload\", \"iload_0\", \"iload_1\", \"iload_2\",\n+    \"iload_3\", \"lload_0\", \"lload_1\", \"lload_2\", \"lload_3\", \"fload_0\",\n+    \"fload_1\", \"fload_2\", \"fload_3\", \"dload_0\", \"dload_1\", \"dload_2\",\n+    \"dload_3\", \"aload_0\", \"aload_1\", \"aload_2\", \"aload_3\", \"iaload\",\n+    \"laload\", \"faload\", \"daload\", \"aaload\", \"baload\", \"caload\", \"saload\",\n+    \"istore\", \"lstore\", \"fstore\", \"dstore\", \"astore\", \"istore_0\",\n+    \"istore_1\", \"istore_2\", \"istore_3\", \"lstore_0\", \"lstore_1\",\n+    \"lstore_2\", \"lstore_3\", \"fstore_0\", \"fstore_1\", \"fstore_2\",\n+    \"fstore_3\", \"dstore_0\", \"dstore_1\", \"dstore_2\", \"dstore_3\",\n+    \"astore_0\", \"astore_1\", \"astore_2\", \"astore_3\", \"iastore\", \"lastore\",\n+    \"fastore\", \"dastore\", \"aastore\", \"bastore\", \"castore\", \"sastore\",\n+    \"pop\", \"pop2\", \"dup\", \"dup_x1\", \"dup_x2\", \"dup2\", \"dup2_x1\",\n+    \"dup2_x2\", \"swap\", \"iadd\", \"ladd\", \"fadd\", \"dadd\", \"isub\", \"lsub\",\n+    \"fsub\", \"dsub\", \"imul\", \"lmul\", \"fmul\", \"dmul\", \"idiv\", \"ldiv\",\n+    \"fdiv\", \"ddiv\", \"irem\", \"lrem\", \"frem\", \"drem\", \"ineg\", \"lneg\",\n+    \"fneg\", \"dneg\", \"ishl\", \"lshl\", \"ishr\", \"lshr\", \"iushr\", \"lushr\",\n+    \"iand\", \"land\", \"ior\", \"lor\", \"ixor\", \"lxor\", \"iinc\", \"i2l\", \"i2f\",\n+    \"i2d\", \"l2i\", \"l2f\", \"l2d\", \"f2i\", \"f2l\", \"f2d\", \"d2i\", \"d2l\", \"d2f\",\n+    \"i2b\", \"i2c\", \"i2s\", \"lcmp\", \"fcmpl\", \"fcmpg\",\n+    \"dcmpl\", \"dcmpg\", \"ifeq\", \"ifne\", \"iflt\", \"ifge\", \"ifgt\", \"ifle\",\n+    \"if_icmpeq\", \"if_icmpne\", \"if_icmplt\", \"if_icmpge\", \"if_icmpgt\",\n+    \"if_icmple\", \"if_acmpeq\", \"if_acmpne\", \"goto\", \"jsr\", \"ret\",\n+    \"tableswitch\", \"lookupswitch\", \"ireturn\", \"lreturn\", \"freturn\",\n+    \"dreturn\", \"areturn\", \"return\", \"getstatic\", \"putstatic\", \"getfield\",\n+    \"putfield\", \"invokevirtual\", \"invokespecial\", \"invokestatic\",\n+    \"invokeinterface\", \"invokedynamic\", \"new\", \"newarray\", \"anewarray\",\n+    \"arraylength\", \"athrow\", \"checkcast\", \"instanceof\", \"monitorenter\",\n+    \"monitorexit\", \"wide\", \"multianewarray\", \"ifnull\", \"ifnonnull\",\n+    \"goto_w\", \"jsr_w\", \"breakpoint\", ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE, ILLEGAL_OPCODE,\n+    ILLEGAL_OPCODE, \"impdep1\", \"impdep2\"\n+  };\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static final int OPCODE_NAMES_LENGTH = OPCODE_NAMES.length;\n+\n+\n+  \/**\n+   * @since 6.0\n+   *\/\n+  public static String getOpcodeName(final int index) {\n+      return OPCODE_NAMES[index];\n+  }\n+\n+  \/**\n+   * Number of words consumed on operand stack by instructions.\n+   * Indexed by opcode.  CONSUME_STACK[FALOAD] = number of words\n+   * consumed from the stack by a faload instruction.\n+   *\/\n+  private static final int[] CONSUME_STACK = {\n+    0\/*nop*\/, 0\/*aconst_null*\/, 0\/*iconst_m1*\/, 0\/*iconst_0*\/, 0\/*iconst_1*\/,\n+    0\/*iconst_2*\/, 0\/*iconst_3*\/, 0\/*iconst_4*\/, 0\/*iconst_5*\/, 0\/*lconst_0*\/,\n+    0\/*lconst_1*\/, 0\/*fconst_0*\/, 0\/*fconst_1*\/, 0\/*fconst_2*\/, 0\/*dconst_0*\/,\n+    0\/*dconst_1*\/, 0\/*bipush*\/, 0\/*sipush*\/, 0\/*ldc*\/, 0\/*ldc_w*\/, 0\/*ldc2_w*\/, 0\/*iload*\/,\n+    0\/*lload*\/, 0\/*fload*\/, 0\/*dload*\/, 0\/*aload*\/, 0\/*iload_0*\/, 0\/*iload_1*\/, 0\/*iload_2*\/,\n+    0\/*iload_3*\/, 0\/*lload_0*\/, 0\/*lload_1*\/, 0\/*lload_2*\/, 0\/*lload_3*\/, 0\/*fload_0*\/,\n+    0\/*fload_1*\/, 0\/*fload_2*\/, 0\/*fload_3*\/, 0\/*dload_0*\/, 0\/*dload_1*\/, 0\/*dload_2*\/,\n+    0\/*dload_3*\/, 0\/*aload_0*\/, 0\/*aload_1*\/, 0\/*aload_2*\/, 0\/*aload_3*\/, 2\/*iaload*\/,\n+    2\/*laload*\/, 2\/*faload*\/, 2\/*daload*\/, 2\/*aaload*\/, 2\/*baload*\/, 2\/*caload*\/, 2\/*saload*\/,\n+    1\/*istore*\/, 2\/*lstore*\/, 1\/*fstore*\/, 2\/*dstore*\/, 1\/*astore*\/, 1\/*istore_0*\/,\n+    1\/*istore_1*\/, 1\/*istore_2*\/, 1\/*istore_3*\/, 2\/*lstore_0*\/, 2\/*lstore_1*\/,\n+    2\/*lstore_2*\/, 2\/*lstore_3*\/, 1\/*fstore_0*\/, 1\/*fstore_1*\/, 1\/*fstore_2*\/,\n+    1\/*fstore_3*\/, 2\/*dstore_0*\/, 2\/*dstore_1*\/, 2\/*dstore_2*\/, 2\/*dstore_3*\/,\n+    1\/*astore_0*\/, 1\/*astore_1*\/, 1\/*astore_2*\/, 1\/*astore_3*\/, 3\/*iastore*\/, 4\/*lastore*\/,\n+    3\/*fastore*\/, 4\/*dastore*\/, 3\/*aastore*\/, 3\/*bastore*\/, 3\/*castore*\/, 3\/*sastore*\/,\n+    1\/*pop*\/, 2\/*pop2*\/, 1\/*dup*\/, 2\/*dup_x1*\/, 3\/*dup_x2*\/, 2\/*dup2*\/, 3\/*dup2_x1*\/,\n+    4\/*dup2_x2*\/, 2\/*swap*\/, 2\/*iadd*\/, 4\/*ladd*\/, 2\/*fadd*\/, 4\/*dadd*\/, 2\/*isub*\/, 4\/*lsub*\/,\n+    2\/*fsub*\/, 4\/*dsub*\/, 2\/*imul*\/, 4\/*lmul*\/, 2\/*fmul*\/, 4\/*dmul*\/, 2\/*idiv*\/, 4\/*ldiv*\/,\n+    2\/*fdiv*\/, 4\/*ddiv*\/, 2\/*irem*\/, 4\/*lrem*\/, 2\/*frem*\/, 4\/*drem*\/, 1\/*ineg*\/, 2\/*lneg*\/,\n+    1\/*fneg*\/, 2\/*dneg*\/, 2\/*ishl*\/, 3\/*lshl*\/, 2\/*ishr*\/, 3\/*lshr*\/, 2\/*iushr*\/, 3\/*lushr*\/,\n+    2\/*iand*\/, 4\/*land*\/, 2\/*ior*\/, 4\/*lor*\/, 2\/*ixor*\/, 4\/*lxor*\/, 0\/*iinc*\/,\n+    1\/*i2l*\/, 1\/*i2f*\/, 1\/*i2d*\/, 2\/*l2i*\/, 2\/*l2f*\/, 2\/*l2d*\/, 1\/*f2i*\/, 1\/*f2l*\/,\n+    1\/*f2d*\/, 2\/*d2i*\/, 2\/*d2l*\/, 2\/*d2f*\/, 1\/*i2b*\/, 1\/*i2c*\/, 1\/*i2s*\/,\n+    4\/*lcmp*\/, 2\/*fcmpl*\/, 2\/*fcmpg*\/, 4\/*dcmpl*\/, 4\/*dcmpg*\/, 1\/*ifeq*\/, 1\/*ifne*\/,\n+    1\/*iflt*\/, 1\/*ifge*\/, 1\/*ifgt*\/, 1\/*ifle*\/, 2\/*if_icmpeq*\/, 2\/*if_icmpne*\/, 2\/*if_icmplt*\/,\n+    2 \/*if_icmpge*\/, 2\/*if_icmpgt*\/, 2\/*if_icmple*\/, 2\/*if_acmpeq*\/, 2\/*if_acmpne*\/,\n+    0\/*goto*\/, 0\/*jsr*\/, 0\/*ret*\/, 1\/*tableswitch*\/, 1\/*lookupswitch*\/, 1\/*ireturn*\/,\n+    2\/*lreturn*\/, 1\/*freturn*\/, 2\/*dreturn*\/, 1\/*areturn*\/, 0\/*return*\/, 0\/*getstatic*\/,\n+    UNPREDICTABLE\/*putstatic*\/, 1\/*getfield*\/, UNPREDICTABLE\/*putfield*\/,\n+    UNPREDICTABLE\/*invokevirtual*\/, UNPREDICTABLE\/*invokespecial*\/,\n+    UNPREDICTABLE\/*invokestatic*\/,\n+    UNPREDICTABLE\/*invokeinterface*\/, UNPREDICTABLE\/*invokedynamic*\/, 0\/*new*\/, 1\/*newarray*\/, 1\/*anewarray*\/,\n+    1\/*arraylength*\/, 1\/*athrow*\/, 1\/*checkcast*\/, 1\/*instanceof*\/, 1\/*monitorenter*\/,\n+    1\/*monitorexit*\/, 0\/*wide*\/, UNPREDICTABLE\/*multianewarray*\/, 1\/*ifnull*\/, 1\/*ifnonnull*\/,\n+    0\/*goto_w*\/, 0\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNPREDICTABLE\/*impdep1*\/, UNPREDICTABLE\/*impdep2*\/\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return Number of words consumed on operand stack\n+   * @since 6.0\n+   *\/\n+  public static int getConsumeStack(final int index) {\n+      return CONSUME_STACK[index];\n+  }\n+\n+\n+  \/**\n+   * Number of words produced onto operand stack by instructions.\n+   * Indexed by opcode.  CONSUME_STACK[DALOAD] = number of words\n+   * consumed from the stack by a daload instruction.\n+   *\/\n+  private static final int[] PRODUCE_STACK = {\n+    0\/*nop*\/, 1\/*aconst_null*\/, 1\/*iconst_m1*\/, 1\/*iconst_0*\/, 1\/*iconst_1*\/,\n+    1\/*iconst_2*\/, 1\/*iconst_3*\/, 1\/*iconst_4*\/, 1\/*iconst_5*\/, 2\/*lconst_0*\/,\n+    2\/*lconst_1*\/, 1\/*fconst_0*\/, 1\/*fconst_1*\/, 1\/*fconst_2*\/, 2\/*dconst_0*\/,\n+    2\/*dconst_1*\/, 1\/*bipush*\/, 1\/*sipush*\/, 1\/*ldc*\/, 1\/*ldc_w*\/, 2\/*ldc2_w*\/, 1\/*iload*\/,\n+    2\/*lload*\/, 1\/*fload*\/, 2\/*dload*\/, 1\/*aload*\/, 1\/*iload_0*\/, 1\/*iload_1*\/, 1\/*iload_2*\/,\n+    1\/*iload_3*\/, 2\/*lload_0*\/, 2\/*lload_1*\/, 2\/*lload_2*\/, 2\/*lload_3*\/, 1\/*fload_0*\/,\n+    1\/*fload_1*\/, 1\/*fload_2*\/, 1\/*fload_3*\/, 2\/*dload_0*\/, 2\/*dload_1*\/, 2\/*dload_2*\/,\n+    2\/*dload_3*\/, 1\/*aload_0*\/, 1\/*aload_1*\/, 1\/*aload_2*\/, 1\/*aload_3*\/, 1\/*iaload*\/,\n+    2\/*laload*\/, 1\/*faload*\/, 2\/*daload*\/, 1\/*aaload*\/, 1\/*baload*\/, 1\/*caload*\/, 1\/*saload*\/,\n+    0\/*istore*\/, 0\/*lstore*\/, 0\/*fstore*\/, 0\/*dstore*\/, 0\/*astore*\/, 0\/*istore_0*\/,\n+    0\/*istore_1*\/, 0\/*istore_2*\/, 0\/*istore_3*\/, 0\/*lstore_0*\/, 0\/*lstore_1*\/,\n+    0\/*lstore_2*\/, 0\/*lstore_3*\/, 0\/*fstore_0*\/, 0\/*fstore_1*\/, 0\/*fstore_2*\/,\n+    0\/*fstore_3*\/, 0\/*dstore_0*\/, 0\/*dstore_1*\/, 0\/*dstore_2*\/, 0\/*dstore_3*\/,\n+    0\/*astore_0*\/, 0\/*astore_1*\/, 0\/*astore_2*\/, 0\/*astore_3*\/, 0\/*iastore*\/, 0\/*lastore*\/,\n+    0\/*fastore*\/, 0\/*dastore*\/, 0\/*aastore*\/, 0\/*bastore*\/, 0\/*castore*\/, 0\/*sastore*\/,\n+    0\/*pop*\/, 0\/*pop2*\/, 2\/*dup*\/, 3\/*dup_x1*\/, 4\/*dup_x2*\/, 4\/*dup2*\/, 5\/*dup2_x1*\/,\n+    6\/*dup2_x2*\/, 2\/*swap*\/, 1\/*iadd*\/, 2\/*ladd*\/, 1\/*fadd*\/, 2\/*dadd*\/, 1\/*isub*\/, 2\/*lsub*\/,\n+    1\/*fsub*\/, 2\/*dsub*\/, 1\/*imul*\/, 2\/*lmul*\/, 1\/*fmul*\/, 2\/*dmul*\/, 1\/*idiv*\/, 2\/*ldiv*\/,\n+    1\/*fdiv*\/, 2\/*ddiv*\/, 1\/*irem*\/, 2\/*lrem*\/, 1\/*frem*\/, 2\/*drem*\/, 1\/*ineg*\/, 2\/*lneg*\/,\n+    1\/*fneg*\/, 2\/*dneg*\/, 1\/*ishl*\/, 2\/*lshl*\/, 1\/*ishr*\/, 2\/*lshr*\/, 1\/*iushr*\/, 2\/*lushr*\/,\n+    1\/*iand*\/, 2\/*land*\/, 1\/*ior*\/, 2\/*lor*\/, 1\/*ixor*\/, 2\/*lxor*\/,\n+    0\/*iinc*\/, 2\/*i2l*\/, 1\/*i2f*\/, 2\/*i2d*\/, 1\/*l2i*\/, 1\/*l2f*\/, 2\/*l2d*\/, 1\/*f2i*\/,\n+    2\/*f2l*\/, 2\/*f2d*\/, 1\/*d2i*\/, 2\/*d2l*\/, 1\/*d2f*\/,\n+    1\/*i2b*\/, 1\/*i2c*\/, 1\/*i2s*\/, 1\/*lcmp*\/, 1\/*fcmpl*\/, 1\/*fcmpg*\/,\n+    1\/*dcmpl*\/, 1\/*dcmpg*\/, 0\/*ifeq*\/, 0\/*ifne*\/, 0\/*iflt*\/, 0\/*ifge*\/, 0\/*ifgt*\/, 0\/*ifle*\/,\n+    0\/*if_icmpeq*\/, 0\/*if_icmpne*\/, 0\/*if_icmplt*\/, 0\/*if_icmpge*\/, 0\/*if_icmpgt*\/,\n+    0\/*if_icmple*\/, 0\/*if_acmpeq*\/, 0\/*if_acmpne*\/, 0\/*goto*\/, 1\/*jsr*\/, 0\/*ret*\/,\n+    0\/*tableswitch*\/, 0\/*lookupswitch*\/, 0\/*ireturn*\/, 0\/*lreturn*\/, 0\/*freturn*\/,\n+    0\/*dreturn*\/, 0\/*areturn*\/, 0\/*return*\/, UNPREDICTABLE\/*getstatic*\/, 0\/*putstatic*\/,\n+    UNPREDICTABLE\/*getfield*\/, 0\/*putfield*\/, UNPREDICTABLE\/*invokevirtual*\/,\n+    UNPREDICTABLE\/*invokespecial*\/, UNPREDICTABLE\/*invokestatic*\/,\n+    UNPREDICTABLE\/*invokeinterface*\/, UNPREDICTABLE\/*invokedynamic*\/, 1\/*new*\/, 1\/*newarray*\/, 1\/*anewarray*\/,\n+    1\/*arraylength*\/, 1\/*athrow*\/, 1\/*checkcast*\/, 1\/*instanceof*\/, 0\/*monitorenter*\/,\n+    0\/*monitorexit*\/, 0\/*wide*\/, 1\/*multianewarray*\/, 0\/*ifnull*\/, 0\/*ifnonnull*\/,\n+    0\/*goto_w*\/, 1\/*jsr_w*\/, 0\/*breakpoint*\/, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNDEFINED, UNDEFINED, UNDEFINED,\n+    UNDEFINED, UNPREDICTABLE\/*impdep1*\/, UNPREDICTABLE\/*impdep2*\/\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return Number of words produced onto operand stack\n+   * @since 6.0\n+   *\/\n+  public static int getProduceStack(final int index) {\n+      return PRODUCE_STACK[index];\n+  }\n+\n+  \/** Attributes and their corresponding names.\n+   *\/\n+  public static final byte ATTR_UNKNOWN                                 = -1;\n+  public static final byte ATTR_SOURCE_FILE                             = 0;\n+  public static final byte ATTR_CONSTANT_VALUE                          = 1;\n+  public static final byte ATTR_CODE                                    = 2;\n+  public static final byte ATTR_EXCEPTIONS                              = 3;\n+  public static final byte ATTR_LINE_NUMBER_TABLE                       = 4;\n+  public static final byte ATTR_LOCAL_VARIABLE_TABLE                    = 5;\n+  public static final byte ATTR_INNER_CLASSES                           = 6;\n+  public static final byte ATTR_SYNTHETIC                               = 7;\n+  public static final byte ATTR_DEPRECATED                              = 8;\n+  public static final byte ATTR_PMG                                     = 9;\n+  public static final byte ATTR_SIGNATURE                               = 10;\n+  public static final byte ATTR_STACK_MAP                               = 11;\n+  public static final byte ATTR_RUNTIME_VISIBLE_ANNOTATIONS             = 12;\n+  public static final byte ATTR_RUNTIME_INVISIBLE_ANNOTATIONS           = 13;\n+  public static final byte ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS   = 14;\n+  public static final byte ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS = 15;\n+  public static final byte ATTR_ANNOTATION_DEFAULT                      = 16;\n+  public static final byte ATTR_LOCAL_VARIABLE_TYPE_TABLE               = 17;\n+  public static final byte ATTR_ENCLOSING_METHOD                        = 18;\n+  public static final byte ATTR_STACK_MAP_TABLE                         = 19;\n+  public static final byte ATTR_BOOTSTRAP_METHODS                       = 20;\n+  public static final byte ATTR_METHOD_PARAMETERS                       = 21;\n+  public static final byte ATTR_MODULE                                  = 22;\n+  public static final byte ATTR_MODULE_PACKAGES                         = 23;\n+  public static final byte ATTR_MODULE_MAIN_CLASS                       = 24;\n+  public static final byte ATTR_NEST_HOST                               = 25;\n+  public static final byte ATTR_NEST_MEMBERS                            = 26;\n+\n+  public static final short KNOWN_ATTRIBUTES = 27; \/\/ count of attributes\n+\n+  private static final String[] ATTRIBUTE_NAMES = {\n+    \"SourceFile\", \"ConstantValue\", \"Code\", \"Exceptions\",\n+    \"LineNumberTable\", \"LocalVariableTable\",\n+    \"InnerClasses\", \"Synthetic\", \"Deprecated\",\n+    \"PMGClass\", \"Signature\", \"StackMap\",\n+    \"RuntimeVisibleAnnotations\", \"RuntimeInvisibleAnnotations\",\n+    \"RuntimeVisibleParameterAnnotations\", \"RuntimeInvisibleParameterAnnotations\",\n+    \"AnnotationDefault\", \"LocalVariableTypeTable\", \"EnclosingMethod\", \"StackMapTable\",\n+    \"BootstrapMethods\", \"MethodParameters\", \"Module\", \"ModulePackages\",\n+    \"ModuleMainClass\", \"NestHost\", \"NestMembers\"\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the attribute name\n+   * @since 6.0\n+   *\/\n+  public static String getAttributeName(final int index) {\n+      return ATTRIBUTE_NAMES[index];\n+  }\n+\n+  \/** Constants used in the StackMap attribute.\n+   *\/\n+  public static final byte ITEM_Bogus      = 0;\n+  public static final byte ITEM_Integer    = 1;\n+  public static final byte ITEM_Float      = 2;\n+  public static final byte ITEM_Double     = 3;\n+  public static final byte ITEM_Long       = 4;\n+  public static final byte ITEM_Null       = 5;\n+  public static final byte ITEM_InitObject = 6;\n+  public static final byte ITEM_Object     = 7;\n+  public static final byte ITEM_NewObject  = 8;\n+\n+  private static final String[] ITEM_NAMES = {\n+    \"Bogus\", \"Integer\", \"Float\", \"Double\", \"Long\",\n+    \"Null\", \"InitObject\", \"Object\", \"NewObject\"\n+  };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the item name\n+   * @since 6.0\n+   *\/\n+  public static String getItemName(final int index) {\n+      return ITEM_NAMES[index];\n+  }\n+\n+  \/** Constants used to identify StackMapEntry types.\n+   *\n+   * For those types which can specify a range, the\n+   * constant names the lowest value.\n+   *\/\n+  public static final int SAME_FRAME = 0;\n+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME = 64;\n+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED = 247;\n+  public static final int CHOP_FRAME = 248;\n+  public static final int SAME_FRAME_EXTENDED = 251;\n+  public static final int APPEND_FRAME = 252;\n+  public static final int FULL_FRAME = 255;\n+\n+  \/** Constants that define the maximum value of\n+   * those constants which store ranges. *\/\n+\n+  public static final int SAME_FRAME_MAX = 63;\n+  public static final int SAME_LOCALS_1_STACK_ITEM_FRAME_MAX = 127;\n+  public static final int CHOP_FRAME_MAX = 250;\n+  public static final int APPEND_FRAME_MAX = 254;\n+\n+\n+  \/\/ Constants defining the behavior of the Method Handles (JVMS 5.4.3.5)\n+\n+  public static final byte REF_getField         = 1;\n+  public static final byte REF_getStatic        = 2;\n+  public static final byte REF_putField         = 3;\n+  public static final byte REF_putStatic        = 4;\n+  public static final byte REF_invokeVirtual    = 5;\n+  public static final byte REF_invokeStatic     = 6;\n+  public static final byte REF_invokeSpecial    = 7;\n+  public static final byte REF_newInvokeSpecial = 8;\n+  public static final byte REF_invokeInterface  = 9;\n+\n+  \/**\n+   * The names of the reference_kinds of a CONSTANT_MethodHandle_info.\n+   *\/\n+  private static final String[] METHODHANDLE_NAMES = {\n+      \"\", \"getField\", \"getStatic\", \"putField\", \"putStatic\", \"invokeVirtual\",\n+      \"invokeStatic\", \"invokeSpecial\", \"newInvokeSpecial\", \"invokeInterface\" };\n+\n+  \/**\n+   *\n+   * @param index\n+   * @return the method handle name\n+   * @since 6.0\n+   *\/\n+  public static String getMethodHandleName(final int index) {\n+      return METHODHANDLE_NAMES[index];\n+  }\n+\n+  private Const() { } \/\/ not instantiable\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Const.java","additions":2409,"deletions":3211,"binary":false,"changes":5620,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021 Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import jdk.xml.internal.Utils;\n-\n@@ -27,1 +25,0 @@\n- *\n@@ -29,1 +26,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -33,8 +30,0 @@\n-    \/**\n-     * Enum corresponding to the various Exception Class arrays, used by\n-     * {@link ExceptionConst#createExceptions(EXCS, Class...)}\n-     *\/\n-    public enum EXCS {\n-        EXCS_CLASS_AND_INTERFACE_RESOLUTION, EXCS_FIELD_AND_METHOD_RESOLUTION, EXCS_INTERFACE_METHOD_RESOLUTION, EXCS_STRING_RESOLUTION, EXCS_ARRAY_EXCEPTION,\n-    }\n-\n@@ -78,1 +67,2 @@\n-    public static final Class<ArrayIndexOutOfBoundsException> ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION = ArrayIndexOutOfBoundsException.class;\n+    public static final Class<ArrayIndexOutOfBoundsException> ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION\n+                                                            = ArrayIndexOutOfBoundsException.class;\n@@ -82,1 +72,0 @@\n-\n@@ -84,7 +73,0 @@\n-    \/**\n-     * Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual Machine Specification\n-     *\/\n-    private static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = {NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR,\n-        EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR}; \/\/ Chapter 5.1\n-\n-    private static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = {NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR}; \/\/ Chapter 5.2\n@@ -93,1 +75,2 @@\n-     * Empty array.\n+     * Pre-defined exception arrays according to chapters 5.1-5.4 of the Java Virtual\n+     * Machine Specification\n@@ -95,0 +78,7 @@\n+    private static final Class<?>[] EXCS_CLASS_AND_INTERFACE_RESOLUTION = {\n+            NO_CLASS_DEF_FOUND_ERROR, CLASS_FORMAT_ERROR, VERIFY_ERROR, ABSTRACT_METHOD_ERROR,\n+            EXCEPTION_IN_INITIALIZER_ERROR, ILLEGAL_ACCESS_ERROR\n+    }; \/\/ Chapter 5.1\n+    private static final Class<?>[] EXCS_FIELD_AND_METHOD_RESOLUTION = {\n+            NO_SUCH_FIELD_ERROR, ILLEGAL_ACCESS_ERROR, NO_SUCH_METHOD_ERROR\n+    }; \/\/ Chapter 5.2\n@@ -96,0 +86,5 @@\n+    private static final Class<?>[] EXCS_STRING_RESOLUTION = new Class<?>[0];\n+    \/\/ Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)\n+    private static final Class<?>[] EXCS_ARRAY_EXCEPTION = {\n+            NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION\n+    };\n@@ -98,1 +93,2 @@\n-     * Empty array.\n+     * Enum corresponding to the various Exception Class arrays,\n+     * used by {@link ExceptionConst#createExceptions(EXCS, Class...)}\n@@ -100,1 +96,7 @@\n-    private static final Class<?>[] EXCS_STRING_RESOLUTION = new Class<?>[0];\n+    public enum EXCS {\n+        EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+        EXCS_FIELD_AND_METHOD_RESOLUTION,\n+        EXCS_INTERFACE_METHOD_RESOLUTION,\n+        EXCS_STRING_RESOLUTION,\n+        EXCS_ARRAY_EXCEPTION,\n+    }\n@@ -102,2 +104,10 @@\n-    \/\/ Chapter 5.4 (no errors but the ones that _always_ could happen! How stupid.)\n-    private static final Class<?>[] EXCS_ARRAY_EXCEPTION = {NULL_POINTER_EXCEPTION, ARRAY_INDEX_OUT_OF_BOUNDS_EXCEPTION};\n+    \/\/ helper method to merge exception class arrays\n+    private static Class<?>[] mergeExceptions(final Class<?>[] input, final Class<?> ... extraClasses) {\n+        final int extraLen = extraClasses == null ? 0 : extraClasses.length;\n+        final Class<?>[] excs = new Class<?>[input.length + extraLen];\n+        System.arraycopy(input, 0, excs, 0, input.length);\n+        if (extraLen > 0) {\n+            System.arraycopy(extraClasses, 0, excs, input.length, extraLen);\n+        }\n+        return excs;\n+    }\n@@ -107,1 +117,0 @@\n-     *\n@@ -112,1 +121,1 @@\n-    public static Class<?>[] createExceptions(final EXCS type, final Class<?>... extraClasses) {\n+    public static Class<?>[] createExceptions(final EXCS type, final Class<?> ... extraClasses) {\n@@ -129,4 +138,1 @@\n-    \/\/ helper method to merge exception class arrays\n-    private static Class<?>[] mergeExceptions(final Class<?>[] input, final Class<?>... extraClasses) {\n-        return Utils.arraysAppend(input, extraClasses);\n-    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/ExceptionConst.java","additions":39,"deletions":33,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,3 @@\n- * The repository maintains informations about class interdependencies, e.g., whether a class is a sub-class of another.\n- * Delegates actual class loading to SyntheticRepository with current class path by default.\n+ * The repository maintains informations about class interdependencies, e.g.,\n+ * whether a class is a sub-class of another. Delegates actual class loading\n+ * to SyntheticRepository with current class path by default.\n@@ -33,1 +34,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -37,1 +38,3 @@\n-    private static com.sun.org.apache.bcel.internal.util.Repository repository = SyntheticRepository.getInstance();\n+    private static com.sun.org.apache.bcel.internal.util.Repository repository\n+            = SyntheticRepository.getInstance();\n+\n@@ -40,3 +43,1 @@\n-     * Adds clazz to repository if there isn't an equally named class already in there.\n-     *\n-     * @return old entry in repository\n+     * @return currently used repository instance\n@@ -44,4 +45,2 @@\n-    public static JavaClass addClass(final JavaClass clazz) {\n-        final JavaClass old = repository.findClass(clazz.getClassName());\n-        repository.storeClass(clazz);\n-        return old;\n+    public static com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n+        return repository;\n@@ -50,0 +49,1 @@\n+\n@@ -51,1 +51,1 @@\n-     * Clears the repository.\n+     * Sets repository instance to be used for class loading\n@@ -53,2 +53,2 @@\n-    public static void clearCache() {\n-        repository.clear();\n+    public static void setRepository( final com.sun.org.apache.bcel.internal.util.Repository rep ) {\n+        repository = rep;\n@@ -57,0 +57,1 @@\n+\n@@ -58,3 +59,6 @@\n-     * @return all interfaces implemented by class and its super classes and the interfaces that those interfaces extend,\n-     *         and so on. (Some people call this a transitive hull).\n-     * @throws ClassNotFoundException if any of the class's superclasses or superinterfaces can't be found\n+     * Lookups class somewhere found on your CLASSPATH, or whereever the\n+     * repository instance looks for it.\n+     *\n+     * @return class object for given fully qualified class name\n+     * @throws ClassNotFoundException if the class could not be found or\n+     * parsed correctly\n@@ -62,2 +66,2 @@\n-    public static JavaClass[] getInterfaces(final JavaClass clazz) throws ClassNotFoundException {\n-        return clazz.getAllInterfaces();\n+    public static JavaClass lookupClass( final String class_name ) throws ClassNotFoundException {\n+        return repository.loadClass(class_name);\n@@ -66,0 +70,1 @@\n+\n@@ -67,4 +72,6 @@\n-     * @return all interfaces implemented by class and its super classes and the interfaces that extend those interfaces,\n-     *         and so on\n-     * @throws ClassNotFoundException if the named class can't be found, or if any of its superclasses or superinterfaces\n-     *         can't be found\n+     * Tries to find class source using the internal repository instance.\n+     *\n+     * @see Class\n+     * @return JavaClass object for given runtime class\n+     * @throws ClassNotFoundException if the class could not be found or\n+     * parsed correctly\n@@ -72,2 +79,2 @@\n-    public static JavaClass[] getInterfaces(final String className) throws ClassNotFoundException {\n-        return getInterfaces(lookupClass(className));\n+    public static JavaClass lookupClass( final Class<?> clazz ) throws ClassNotFoundException {\n+        return repository.loadClass(clazz);\n@@ -76,0 +83,1 @@\n+\n@@ -77,1 +85,1 @@\n-     * @return currently used repository instance\n+     * Clear the repository.\n@@ -79,2 +87,2 @@\n-    public static com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n-        return repository;\n+    public static void clearCache() {\n+        repository.clear();\n@@ -83,0 +91,1 @@\n+\n@@ -84,2 +93,3 @@\n-     * @return list of super classes of clazz in ascending order, i.e., Object is always the last element\n-     * @throws ClassNotFoundException if any of the superclasses can't be found\n+     * Adds clazz to repository if there isn't an equally named class already in there.\n+     *\n+     * @return old entry in repository\n@@ -87,2 +97,4 @@\n-    public static JavaClass[] getSuperClasses(final JavaClass clazz) throws ClassNotFoundException {\n-        return clazz.getSuperClasses();\n+    public static JavaClass addClass( final JavaClass clazz ) {\n+        final JavaClass old = repository.findClass(clazz.getClassName());\n+        repository.storeClass(clazz);\n+        return old;\n@@ -91,0 +103,1 @@\n+\n@@ -92,2 +105,1 @@\n-     * @return list of super classes of clazz in ascending order, i.e., Object is always the last element.\n-     * @throws ClassNotFoundException if the named class or any of its superclasses can't be found\n+     * Removes class with given (fully qualified) name from repository.\n@@ -95,2 +107,2 @@\n-    public static JavaClass[] getSuperClasses(final String className) throws ClassNotFoundException {\n-        return getSuperClasses(lookupClass(className));\n+    public static void removeClass( final String clazz ) {\n+        repository.removeClass(repository.findClass(clazz));\n@@ -99,0 +111,1 @@\n+\n@@ -100,2 +113,1 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if any superclasses or superinterfaces of clazz can't be found\n+     * Removes given class from repository.\n@@ -103,2 +115,2 @@\n-    public static boolean implementationOf(final JavaClass clazz, final JavaClass inter) throws ClassNotFoundException {\n-        return clazz.implementationOf(inter);\n+    public static void removeClass( final JavaClass clazz ) {\n+        repository.removeClass(clazz);\n@@ -107,0 +119,1 @@\n+\n@@ -108,2 +121,3 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if inter or any superclasses or superinterfaces of clazz can't be found\n+     * @return list of super classes of clazz in ascending order, i.e.,\n+     * Object is always the last element\n+     * @throws ClassNotFoundException if any of the superclasses can't be found\n@@ -111,2 +125,2 @@\n-    public static boolean implementationOf(final JavaClass clazz, final String inter) throws ClassNotFoundException {\n-        return implementationOf(clazz, lookupClass(inter));\n+    public static JavaClass[] getSuperClasses( final JavaClass clazz ) throws ClassNotFoundException {\n+        return clazz.getSuperClasses();\n@@ -115,0 +129,1 @@\n+\n@@ -116,2 +131,4 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if clazz or any superclasses or superinterfaces of clazz can't be found\n+     * @return list of super classes of clazz in ascending order, i.e.,\n+     * Object is always the last element.\n+     * @throws ClassNotFoundException if the named class or any of its\n+     *  superclasses can't be found\n@@ -119,2 +136,3 @@\n-    public static boolean implementationOf(final String clazz, final JavaClass inter) throws ClassNotFoundException {\n-        return implementationOf(lookupClass(clazz), inter);\n+    public static JavaClass[] getSuperClasses( final String class_name ) throws ClassNotFoundException {\n+        final JavaClass jc = lookupClass(class_name);\n+        return getSuperClasses(jc);\n@@ -123,0 +141,1 @@\n+\n@@ -124,2 +143,5 @@\n-     * @return true, if clazz is an implementation of interface inter\n-     * @throws ClassNotFoundException if clazz, inter, or any superclasses or superinterfaces of clazz can't be found\n+     * @return all interfaces implemented by class and its super\n+     * classes and the interfaces that those interfaces extend, and so on.\n+     * (Some people call this a transitive hull).\n+     * @throws ClassNotFoundException if any of the class's\n+     *  superclasses or superinterfaces can't be found\n@@ -127,2 +149,2 @@\n-    public static boolean implementationOf(final String clazz, final String inter) throws ClassNotFoundException {\n-        return implementationOf(lookupClass(clazz), lookupClass(inter));\n+    public static JavaClass[] getInterfaces( final JavaClass clazz ) throws ClassNotFoundException {\n+        return clazz.getAllInterfaces();\n@@ -131,0 +153,1 @@\n+\n@@ -132,4 +155,4 @@\n-     * Equivalent to runtime \"instanceof\" operator.\n-     *\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if any superclasses or superinterfaces of clazz can't be found\n+     * @return all interfaces implemented by class and its super\n+     * classes and the interfaces that extend those interfaces, and so on\n+     * @throws ClassNotFoundException if the named class can't be found,\n+     *   or if any of its superclasses or superinterfaces can't be found\n@@ -137,2 +160,2 @@\n-    public static boolean instanceOf(final JavaClass clazz, final JavaClass superclass) throws ClassNotFoundException {\n-        return clazz.instanceOf(superclass);\n+    public static JavaClass[] getInterfaces( final String class_name ) throws ClassNotFoundException {\n+        return getInterfaces(lookupClass(class_name));\n@@ -141,0 +164,1 @@\n+\n@@ -142,2 +166,4 @@\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if superclass can't be found\n+     * Equivalent to runtime \"instanceof\" operator.\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if any superclasses or superinterfaces\n+     *   of clazz can't be found\n@@ -145,2 +171,3 @@\n-    public static boolean instanceOf(final JavaClass clazz, final String superclass) throws ClassNotFoundException {\n-        return instanceOf(clazz, lookupClass(superclass));\n+    public static boolean instanceOf( final JavaClass clazz, final JavaClass super_class )\n+            throws ClassNotFoundException {\n+        return clazz.instanceOf(super_class);\n@@ -149,0 +176,1 @@\n+\n@@ -150,2 +178,3 @@\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if clazz can't be found\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if either clazz or super_class\n+     *   can't be found\n@@ -153,2 +182,3 @@\n-    public static boolean instanceOf(final String clazz, final JavaClass superclass) throws ClassNotFoundException {\n-        return instanceOf(lookupClass(clazz), superclass);\n+    public static boolean instanceOf( final String clazz, final String super_class )\n+            throws ClassNotFoundException {\n+        return instanceOf(lookupClass(clazz), lookupClass(super_class));\n@@ -157,0 +187,1 @@\n+\n@@ -158,2 +189,2 @@\n-     * @return true, if clazz is an instance of superclass\n-     * @throws ClassNotFoundException if either clazz or superclass can't be found\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if super_class can't be found\n@@ -161,2 +192,3 @@\n-    public static boolean instanceOf(final String clazz, final String superclass) throws ClassNotFoundException {\n-        return instanceOf(lookupClass(clazz), lookupClass(superclass));\n+    public static boolean instanceOf( final JavaClass clazz, final String super_class )\n+            throws ClassNotFoundException {\n+        return instanceOf(clazz, lookupClass(super_class));\n@@ -165,0 +197,1 @@\n+\n@@ -166,5 +199,2 @@\n-     * Tries to find class source using the internal repository instance.\n-     *\n-     * @see Class\n-     * @return JavaClass object for given runtime class\n-     * @throws ClassNotFoundException if the class could not be found or parsed correctly\n+     * @return true, if clazz is an instance of super_class\n+     * @throws ClassNotFoundException if clazz can't be found\n@@ -172,2 +202,3 @@\n-    public static JavaClass lookupClass(final Class<?> clazz) throws ClassNotFoundException {\n-        return repository.loadClass(clazz);\n+    public static boolean instanceOf( final String clazz, final JavaClass super_class )\n+            throws ClassNotFoundException {\n+        return instanceOf(lookupClass(clazz), super_class);\n@@ -176,0 +207,1 @@\n+\n@@ -177,4 +209,3 @@\n-     * Lookups class somewhere found on your CLASSPATH, or wherever the repository instance looks for it.\n-     *\n-     * @return class object for given fully qualified class name\n-     * @throws ClassNotFoundException if the class could not be found or parsed correctly\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if any superclasses or superinterfaces\n+     *   of clazz can't be found\n@@ -182,2 +213,3 @@\n-    public static JavaClass lookupClass(final String className) throws ClassNotFoundException {\n-        return repository.loadClass(className);\n+    public static boolean implementationOf( final JavaClass clazz, final JavaClass inter )\n+            throws ClassNotFoundException {\n+        return clazz.implementationOf(inter);\n@@ -186,0 +218,1 @@\n+\n@@ -187,1 +220,3 @@\n-     * Removes given class from repository.\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if clazz, inter, or any superclasses\n+     *   or superinterfaces of clazz can't be found\n@@ -189,2 +224,3 @@\n-    public static void removeClass(final JavaClass clazz) {\n-        repository.removeClass(clazz);\n+    public static boolean implementationOf( final String clazz, final String inter )\n+            throws ClassNotFoundException {\n+        return implementationOf(lookupClass(clazz), lookupClass(inter));\n@@ -193,0 +229,1 @@\n+\n@@ -194,1 +231,3 @@\n-     * Removes class with given (fully qualified) name from repository.\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if inter or any superclasses\n+     *   or superinterfaces of clazz can't be found\n@@ -196,2 +235,3 @@\n-    public static void removeClass(final String clazz) {\n-        repository.removeClass(repository.findClass(clazz));\n+    public static boolean implementationOf( final JavaClass clazz, final String inter )\n+            throws ClassNotFoundException {\n+        return implementationOf(clazz, lookupClass(inter));\n@@ -200,0 +240,1 @@\n+\n@@ -201,1 +242,3 @@\n-     * Sets repository instance to be used for class loading\n+     * @return true, if clazz is an implementation of interface inter\n+     * @throws ClassNotFoundException if clazz or any superclasses or\n+     *   superinterfaces of clazz can't be found\n@@ -203,2 +246,3 @@\n-    public static void setRepository(final com.sun.org.apache.bcel.internal.util.Repository rep) {\n-        repository = rep;\n+    public static boolean implementationOf( final String clazz, final JavaClass inter )\n+            throws ClassNotFoundException {\n+        return implementationOf(lookupClass(clazz), inter);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/Repository.java","additions":137,"deletions":93,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -32,5 +32,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int access_flags; \/\/ TODO not used externally at present\n+    private int access_flags;\n@@ -42,1 +38,2 @@\n-     * @param a initial access flags\n+     * @param a\n+     *            inital access flags\n@@ -62,2 +59,8 @@\n-    public final boolean isAbstract() {\n-        return (access_flags & Const.ACC_ABSTRACT) != 0;\n+    \/**\n+     * Set access flags aka \"modifiers\".\n+     *\n+     * @param access_flags\n+     *            Access flags of the object.\n+     *\/\n+    public final void setAccessFlags(final int access_flags) {\n+        this.access_flags = access_flags;\n@@ -66,2 +69,8 @@\n-    public final void isAbstract(final boolean flag) {\n-        setFlag(Const.ACC_ABSTRACT, flag);\n+    \/**\n+     * Set access flags aka \"modifiers\".\n+     *\n+     * @param access_flags\n+     *            Access flags of the object.\n+     *\/\n+    public final void setModifiers(final int access_flags) {\n+        setAccessFlags(access_flags);\n@@ -70,2 +79,10 @@\n-    public final boolean isAnnotation() {\n-        return (access_flags & Const.ACC_ANNOTATION) != 0;\n+    private void setFlag(final int flag, final boolean set) {\n+        if ((access_flags & flag) != 0) { \/\/ Flag is set already\n+            if (!set) {\n+                access_flags ^= flag;\n+            }\n+        } else { \/\/ Flag not set\n+            if (set) {\n+                access_flags |= flag;\n+            }\n+        }\n@@ -74,2 +91,2 @@\n-    public final void isAnnotation(final boolean flag) {\n-        setFlag(Const.ACC_ANNOTATION, flag);\n+    public final void isPublic(final boolean flag) {\n+        setFlag(Const.ACC_PUBLIC, flag);\n@@ -78,2 +95,2 @@\n-    public final boolean isEnum() {\n-        return (access_flags & Const.ACC_ENUM) != 0;\n+    public final boolean isPublic() {\n+        return (access_flags & Const.ACC_PUBLIC) != 0;\n@@ -82,2 +99,2 @@\n-    public final void isEnum(final boolean flag) {\n-        setFlag(Const.ACC_ENUM, flag);\n+    public final void isPrivate(final boolean flag) {\n+        setFlag(Const.ACC_PRIVATE, flag);\n@@ -86,2 +103,2 @@\n-    public final boolean isFinal() {\n-        return (access_flags & Const.ACC_FINAL) != 0;\n+    public final boolean isPrivate() {\n+        return (access_flags & Const.ACC_PRIVATE) != 0;\n@@ -90,2 +107,2 @@\n-    public final void isFinal(final boolean flag) {\n-        setFlag(Const.ACC_FINAL, flag);\n+    public final void isProtected(final boolean flag) {\n+        setFlag(Const.ACC_PROTECTED, flag);\n@@ -94,2 +111,2 @@\n-    public final boolean isInterface() {\n-        return (access_flags & Const.ACC_INTERFACE) != 0;\n+    public final boolean isProtected() {\n+        return (access_flags & Const.ACC_PROTECTED) != 0;\n@@ -98,2 +115,2 @@\n-    public final void isInterface(final boolean flag) {\n-        setFlag(Const.ACC_INTERFACE, flag);\n+    public final void isStatic(final boolean flag) {\n+        setFlag(Const.ACC_STATIC, flag);\n@@ -102,2 +119,2 @@\n-    public final boolean isNative() {\n-        return (access_flags & Const.ACC_NATIVE) != 0;\n+    public final boolean isStatic() {\n+        return (access_flags & Const.ACC_STATIC) != 0;\n@@ -106,2 +123,2 @@\n-    public final void isNative(final boolean flag) {\n-        setFlag(Const.ACC_NATIVE, flag);\n+    public final void isFinal(final boolean flag) {\n+        setFlag(Const.ACC_FINAL, flag);\n@@ -110,2 +127,2 @@\n-    public final boolean isPrivate() {\n-        return (access_flags & Const.ACC_PRIVATE) != 0;\n+    public final boolean isFinal() {\n+        return (access_flags & Const.ACC_FINAL) != 0;\n@@ -114,2 +131,2 @@\n-    public final void isPrivate(final boolean flag) {\n-        setFlag(Const.ACC_PRIVATE, flag);\n+    public final void isSynchronized(final boolean flag) {\n+        setFlag(Const.ACC_SYNCHRONIZED, flag);\n@@ -118,2 +135,2 @@\n-    public final boolean isProtected() {\n-        return (access_flags & Const.ACC_PROTECTED) != 0;\n+    public final boolean isSynchronized() {\n+        return (access_flags & Const.ACC_SYNCHRONIZED) != 0;\n@@ -122,2 +139,2 @@\n-    public final void isProtected(final boolean flag) {\n-        setFlag(Const.ACC_PROTECTED, flag);\n+    public final void isVolatile(final boolean flag) {\n+        setFlag(Const.ACC_VOLATILE, flag);\n@@ -126,2 +143,2 @@\n-    public final boolean isPublic() {\n-        return (access_flags & Const.ACC_PUBLIC) != 0;\n+    public final boolean isVolatile() {\n+        return (access_flags & Const.ACC_VOLATILE) != 0;\n@@ -130,2 +147,2 @@\n-    public final void isPublic(final boolean flag) {\n-        setFlag(Const.ACC_PUBLIC, flag);\n+    public final void isTransient(final boolean flag) {\n+        setFlag(Const.ACC_TRANSIENT, flag);\n@@ -134,2 +151,2 @@\n-    public final boolean isStatic() {\n-        return (access_flags & Const.ACC_STATIC) != 0;\n+    public final boolean isTransient() {\n+        return (access_flags & Const.ACC_TRANSIENT) != 0;\n@@ -138,2 +155,2 @@\n-    public final void isStatic(final boolean flag) {\n-        setFlag(Const.ACC_STATIC, flag);\n+    public final void isNative(final boolean flag) {\n+        setFlag(Const.ACC_NATIVE, flag);\n@@ -142,2 +159,2 @@\n-    public final boolean isStrictfp() {\n-        return (access_flags & Const.ACC_STRICT) != 0;\n+    public final boolean isNative() {\n+        return (access_flags & Const.ACC_NATIVE) != 0;\n@@ -146,2 +163,2 @@\n-    public final void isStrictfp(final boolean flag) {\n-        setFlag(Const.ACC_STRICT, flag);\n+    public final void isInterface(final boolean flag) {\n+        setFlag(Const.ACC_INTERFACE, flag);\n@@ -150,2 +167,2 @@\n-    public final boolean isSynchronized() {\n-        return (access_flags & Const.ACC_SYNCHRONIZED) != 0;\n+    public final boolean isInterface() {\n+        return (access_flags & Const.ACC_INTERFACE) != 0;\n@@ -154,2 +171,2 @@\n-    public final void isSynchronized(final boolean flag) {\n-        setFlag(Const.ACC_SYNCHRONIZED, flag);\n+    public final void isAbstract(final boolean flag) {\n+        setFlag(Const.ACC_ABSTRACT, flag);\n@@ -158,2 +175,2 @@\n-    public final boolean isSynthetic() {\n-        return (access_flags & Const.ACC_SYNTHETIC) != 0;\n+    public final boolean isAbstract() {\n+        return (access_flags & Const.ACC_ABSTRACT) != 0;\n@@ -162,2 +179,2 @@\n-    public final void isSynthetic(final boolean flag) {\n-        setFlag(Const.ACC_SYNTHETIC, flag);\n+    public final void isStrictfp(final boolean flag) {\n+        setFlag(Const.ACC_STRICT, flag);\n@@ -166,2 +183,2 @@\n-    public final boolean isTransient() {\n-        return (access_flags & Const.ACC_TRANSIENT) != 0;\n+    public final boolean isStrictfp() {\n+        return (access_flags & Const.ACC_STRICT) != 0;\n@@ -170,2 +187,2 @@\n-    public final void isTransient(final boolean flag) {\n-        setFlag(Const.ACC_TRANSIENT, flag);\n+    public final void isSynthetic(final boolean flag) {\n+        setFlag(Const.ACC_SYNTHETIC, flag);\n@@ -174,2 +191,2 @@\n-    public final boolean isVarArgs() {\n-        return (access_flags & Const.ACC_VARARGS) != 0;\n+    public final boolean isSynthetic() {\n+        return (access_flags & Const.ACC_SYNTHETIC) != 0;\n@@ -178,2 +195,2 @@\n-    public final void isVarArgs(final boolean flag) {\n-        setFlag(Const.ACC_VARARGS, flag);\n+    public final void isAnnotation(final boolean flag) {\n+        setFlag(Const.ACC_ANNOTATION, flag);\n@@ -182,2 +199,2 @@\n-    public final boolean isVolatile() {\n-        return (access_flags & Const.ACC_VOLATILE) != 0;\n+    public final boolean isAnnotation() {\n+        return (access_flags & Const.ACC_ANNOTATION) != 0;\n@@ -186,2 +203,2 @@\n-    public final void isVolatile(final boolean flag) {\n-        setFlag(Const.ACC_VOLATILE, flag);\n+    public final void isEnum(final boolean flag) {\n+        setFlag(Const.ACC_ENUM, flag);\n@@ -190,7 +207,2 @@\n-    \/**\n-     * Set access flags aka \"modifiers\".\n-     *\n-     * @param accessFlags Access flags of the object.\n-     *\/\n-    public final void setAccessFlags(final int accessFlags) {\n-        this.access_flags = accessFlags;\n+    public final boolean isEnum() {\n+        return (access_flags & Const.ACC_ENUM) != 0;\n@@ -199,8 +211,2 @@\n-    private void setFlag(final int flag, final boolean set) {\n-        if ((access_flags & flag) != 0) { \/\/ Flag is set already\n-            if (!set) {\n-                access_flags ^= flag;\n-            }\n-        } else if (set) {\n-            access_flags |= flag;\n-        }\n+    public final void isVarArgs(final boolean flag) {\n+        setFlag(Const.ACC_VARARGS, flag);\n@@ -209,7 +215,2 @@\n-    \/**\n-     * Set access flags aka \"modifiers\".\n-     *\n-     * @param accessFlags Access flags of the object.\n-     *\/\n-    public final void setModifiers(final int accessFlags) {\n-        setAccessFlags(accessFlags);\n+    public final boolean isVarArgs() {\n+        return (access_flags & Const.ACC_VARARGS) != 0;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AccessFlags.java","additions":93,"deletions":92,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n- * Represents the default value of a annotation for a method info.\n+ * Represents the default value of a annotation for a method info\n@@ -40,4 +40,4 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n+     * @param name_index    Index pointing to the name <em>Code<\/em>\n+     * @param length        Content length in bytes\n+     * @param input         Input stream\n+     * @param constant_pool Array of constants\n@@ -45,3 +45,3 @@\n-    AnnotationDefault(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (ElementValue) null, constantPool);\n-        defaultValue = ElementValue.readElementValue(input, constantPool);\n+    AnnotationDefault(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (ElementValue) null, constant_pool);\n+        defaultValue = ElementValue.readElementValue(input, constant_pool);\n@@ -51,4 +51,4 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param defaultValue the annotation's default value\n-     * @param constantPool Array of constants\n+     * @param name_index    Index pointing to the name <em>Code<\/em>\n+     * @param length        Content length in bytes\n+     * @param defaultValue  the annotation's default value\n+     * @param constant_pool Array of constants\n@@ -56,2 +56,2 @@\n-    public AnnotationDefault(final int nameIndex, final int length, final ElementValue defaultValue, final ConstantPool constantPool) {\n-        super(Const.ATTR_ANNOTATION_DEFAULT, nameIndex, length, constantPool);\n+    public AnnotationDefault(final int name_index, final int length, final ElementValue defaultValue, final ConstantPool constant_pool) {\n+        super(Const.ATTR_ANNOTATION_DEFAULT, name_index, length, constant_pool);\n@@ -62,2 +62,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -72,9 +73,5 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n-\n-    @Override\n-    public final void dump(final DataOutputStream dos) throws IOException {\n-        super.dump(dos);\n-        defaultValue.dump(dos);\n+    \/**\n+     * @param defaultValue the default value of this methodinfo's annotation\n+     *\/\n+    public final void setDefaultValue(final ElementValue defaultValue) {\n+        this.defaultValue = defaultValue;\n@@ -90,5 +87,9 @@\n-    \/**\n-     * @param defaultValue the default value of this methodinfo's annotation\n-     *\/\n-    public final void setDefaultValue(final ElementValue defaultValue) {\n-        this.defaultValue = defaultValue;\n+    @Override\n+    public Attribute copy(final ConstantPool _constant_pool) {\n+        return (Attribute) clone();\n+    }\n+\n+    @Override\n+    public final void dump(final DataOutputStream dos) throws IOException {\n+        super.dump(dos);\n+        defaultValue.dump(dos);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationDefault.java","additions":31,"deletions":30,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -30,8 +30,38 @@\n-public class AnnotationElementValue extends ElementValue {\n-    \/\/ For annotation element values, this is the annotation\n-    private final AnnotationEntry annotationEntry;\n-\n-    public AnnotationElementValue(final int type, final AnnotationEntry annotationEntry, final ConstantPool cpool) {\n-        super(type, cpool);\n-        if (type != ANNOTATION) {\n-            throw new ClassFormatException(\"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n+public class AnnotationElementValue extends ElementValue\n+{\n+        \/\/ For annotation element values, this is the annotation\n+        private final AnnotationEntry annotationEntry;\n+\n+        public AnnotationElementValue(final int type, final AnnotationEntry annotationEntry,\n+                        final ConstantPool cpool)\n+        {\n+                super(type, cpool);\n+                if (type != ANNOTATION) {\n+                    throw new IllegalArgumentException(\n+                                    \"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n+                }\n+                this.annotationEntry = annotationEntry;\n+        }\n+\n+        @Override\n+        public void dump(final DataOutputStream dos) throws IOException\n+        {\n+                dos.writeByte(super.getType()); \/\/ u1 type of value (ANNOTATION == '@')\n+                annotationEntry.dump(dos);\n+        }\n+\n+        @Override\n+        public String stringifyValue()\n+        {\n+                return annotationEntry.toString();\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+                return stringifyValue();\n+        }\n+\n+        public AnnotationEntry getAnnotationEntry()\n+        {\n+                return annotationEntry;\n@@ -39,22 +69,0 @@\n-        this.annotationEntry = annotationEntry;\n-    }\n-\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getType()); \/\/ u1 type of value (ANNOTATION == '@')\n-        annotationEntry.dump(dos);\n-    }\n-\n-    public AnnotationEntry getAnnotationEntry() {\n-        return annotationEntry;\n-    }\n-\n-    @Override\n-    public String stringifyValue() {\n-        return annotationEntry.toString();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        return stringifyValue();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationElementValue.java","additions":38,"deletions":30,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.util.Collections;\n@@ -29,1 +30,2 @@\n-import java.util.stream.Stream;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -32,1 +34,1 @@\n- * Represents one annotation in the annotation table\n+ * represents one annotation in the annotation table\n@@ -38,1 +40,3 @@\n-    public static final AnnotationEntry[] EMPTY_ARRAY = {};\n+    private final int typeIndex;\n+    private final ConstantPool constantPool;\n+    private final boolean isRuntimeVisible;\n@@ -40,5 +44,1 @@\n-    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {\n-        \/\/ Find attributes that contain annotation data\n-        return Stream.of(attrs).filter(Annotations.class::isInstance).flatMap(e -> Stream.of(((Annotations) e).getAnnotationEntries()))\n-            .toArray(AnnotationEntry[]::new);\n-    }\n+    private List<ElementValuePair> elementValuePairs;\n@@ -46,1 +46,1 @@\n-    \/**\n+    \/*\n@@ -53,1 +53,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -55,3 +55,4 @@\n-    public static AnnotationEntry read(final DataInput input, final ConstantPool constantPool, final boolean isRuntimeVisible) throws IOException {\n-        final AnnotationEntry annotationEntry = new AnnotationEntry(input.readUnsignedShort(), constantPool, isRuntimeVisible);\n-        final int numElementValuePairs = input.readUnsignedShort();\n+    public static AnnotationEntry read(final DataInput input, final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {\n+\n+        final AnnotationEntry annotationEntry = new AnnotationEntry(input.readUnsignedShort(), constant_pool, isRuntimeVisible);\n+        final int num_element_value_pairs = input.readUnsignedShort();\n@@ -59,3 +60,4 @@\n-        for (int i = 0; i < numElementValuePairs; i++) {\n-            annotationEntry.elementValuePairs\n-                .add(new ElementValuePair(input.readUnsignedShort(), ElementValue.readElementValue(input, constantPool), constantPool));\n+        for (int i = 0; i < num_element_value_pairs; i++) {\n+            annotationEntry.elementValuePairs.add(\n+                    new ElementValuePair(input.readUnsignedShort(), ElementValue.readElementValue(input, constant_pool),\n+                    constant_pool));\n@@ -66,3 +68,5 @@\n-    private final int typeIndex;\n-\n-    private final ConstantPool constantPool;\n+    public AnnotationEntry(final int type_index, final ConstantPool constant_pool, final boolean isRuntimeVisible) {\n+        this.typeIndex = type_index;\n+        this.constantPool = constant_pool;\n+        this.isRuntimeVisible = isRuntimeVisible;\n+    }\n@@ -70,1 +74,3 @@\n-    private final boolean isRuntimeVisible;\n+    public int getTypeIndex() {\n+        return typeIndex;\n+    }\n@@ -72,1 +78,3 @@\n-    private List<ElementValuePair> elementValuePairs;\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n+    }\n@@ -74,4 +82,2 @@\n-    public AnnotationEntry(final int typeIndex, final ConstantPool constantPool, final boolean isRuntimeVisible) {\n-        this.typeIndex = typeIndex;\n-        this.constantPool = constantPool;\n-        this.isRuntimeVisible = isRuntimeVisible;\n+    public boolean isRuntimeVisible() {\n+        return isRuntimeVisible;\n@@ -81,1 +87,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n@@ -91,13 +97,0 @@\n-    public void addElementNameValuePair(final ElementValuePair elementNameValuePair) {\n-        elementValuePairs.add(elementNameValuePair);\n-    }\n-\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n-        dos.writeShort(elementValuePairs.size()); \/\/ u2 element_value pair\n-        \/\/ count\n-        for (final ElementValuePair envp : elementValuePairs) {\n-            envp.dump(dos);\n-        }\n-    }\n-\n@@ -108,1 +101,2 @@\n-        return constantPool.getConstantUtf8(typeIndex).getBytes();\n+        final ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(typeIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -118,2 +112,5 @@\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n+    \/**\n+     * @return the number of element value pairs in this annotation entry\n+     *\/\n+    public final int getNumElementValuePairs() {\n+        return elementValuePairs.size();\n@@ -127,1 +124,1 @@\n-        return elementValuePairs.toArray(ElementValuePair.EMPTY_ARRAY);\n+        return elementValuePairs.toArray(new ElementValuePair[elementValuePairs.size()]);\n@@ -130,9 +127,7 @@\n-    \/**\n-     * @return the number of element value pairs in this annotation entry\n-     *\/\n-    public final int getNumElementValuePairs() {\n-        return elementValuePairs.size();\n-    }\n-\n-    public int getTypeIndex() {\n-        return typeIndex;\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n+        dos.writeShort(elementValuePairs.size()); \/\/ u2 element_value pair\n+        \/\/ count\n+        for (final ElementValuePair envp : elementValuePairs) {\n+            envp.dump(dos);\n+        }\n@@ -141,2 +136,2 @@\n-    public boolean isRuntimeVisible() {\n-        return isRuntimeVisible;\n+    public void addElementNameValuePair(final ElementValuePair elementNameValuePair) {\n+        elementValuePairs.add(elementNameValuePair);\n@@ -154,1 +149,0 @@\n-                result.append(\", \");\n@@ -156,2 +150,0 @@\n-            \/\/ remove last \", \"\n-            result.setLength(result.length() - 2);\n@@ -167,0 +159,12 @@\n+\n+    public static AnnotationEntry[] createAnnotationEntries(final Attribute[] attrs) {\n+        \/\/ Find attributes that contain annotation data\n+        final List<AnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n+        for (final Attribute attribute : attrs) {\n+            if (attribute instanceof Annotations) {\n+                final Annotations runtimeAnnotations = (Annotations) attribute;\n+                Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getAnnotationEntries());\n+            }\n+        }\n+        return accumulatedAnnotations.toArray(new AnnotationEntry[accumulatedAnnotations.size()]);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AnnotationEntry.java","additions":61,"deletions":57,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -27,4 +27,0 @@\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -37,1 +33,1 @@\n-public abstract class Annotations extends Attribute implements Iterable<AnnotationEntry> {\n+public abstract class Annotations extends Attribute {\n@@ -43,8 +39,22 @@\n-     * Constructs an instance.\n-     *\n-     * @param annotationType   the subclass type of the annotation\n-     * @param nameIndex        Index pointing to the name <em>Code<\/em>\n-     * @param length           Content length in bytes\n-     * @param annotationTable  the actual annotations\n-     * @param constantPool     Array of constants\n-     * @param isRuntimeVisible whether this Annotation visible at runtime\n+     * @param annotation_type the subclass type of the annotation\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     *\/\n+    Annotations(final byte annotation_type, final int name_index, final int length, final DataInput input,\n+            final ConstantPool constant_pool, final boolean isRuntimeVisible) throws IOException {\n+        this(annotation_type, name_index, length, (AnnotationEntry[]) null, constant_pool, isRuntimeVisible);\n+        final int annotation_table_length = input.readUnsignedShort();\n+        annotationTable = new AnnotationEntry[annotation_table_length];\n+        for (int i = 0; i < annotation_table_length; i++) {\n+            annotationTable[i] = AnnotationEntry.read(input, constant_pool, isRuntimeVisible);\n+        }\n+    }\n+\n+    \/**\n+     * @param annotationType the subclass type of the annotation\n+     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param length Content length in bytes\n+     * @param annotationTable the actual annotations\n+     * @param constantPool Array of constants\n@@ -60,24 +70,2 @@\n-     * Constructs an instance.\n-     *\n-     * @param annotationType   the subclass type of the annotation\n-     * @param nameIndex        Index pointing to the name <em>Code<\/em>\n-     * @param length           Content length in bytes\n-     * @param input            Input stream\n-     * @param constantPool     Array of constants\n-     * @param isRuntimeVisible whether this Annotation visible at runtime\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    Annotations(final byte annotationType, final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool,\n-            final boolean isRuntimeVisible) throws IOException {\n-        this(annotationType, nameIndex, length, (AnnotationEntry[]) null, constantPool, isRuntimeVisible);\n-        final int annotationTableLength = input.readUnsignedShort();\n-        annotationTable = new AnnotationEntry[annotationTableLength];\n-        for (int i = 0; i < annotationTableLength; i++) {\n-            annotationTable[i] = AnnotationEntry.read(input, constantPool, isRuntimeVisible);\n-        }\n-    }\n-\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly\n-     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n-     * fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n+     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n@@ -92,4 +80,5 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        \/\/ TODO Auto-generated method stub\n-        return null;\n+    \/**\n+     * @param annotationTable the entries to set in this annotation\n+     *\/\n+    public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {\n+        this.annotationTable = annotationTable;\n@@ -99,1 +88,1 @@\n-     * Gets the array of annotation entries in this annotation\n+     * returns the array of annotation entries in this annotation\n@@ -106,2 +95,0 @@\n-     * Gets the number of annotation entries in this annotation.\n-     *\n@@ -121,32 +108,0 @@\n-    @Override\n-    public Iterator<AnnotationEntry> iterator() {\n-        return Stream.of(annotationTable).iterator();\n-    }\n-\n-    \/**\n-     * Sets the entries to set in this annotation.\n-     *\n-     * @param annotationTable the entries to set in this annotation\n-     *\/\n-    public final void setAnnotationTable(final AnnotationEntry[] annotationTable) {\n-        this.annotationTable = annotationTable;\n-    }\n-\n-    \/**\n-     * Converts to a String representation.\n-     *\n-     * @return String representation\n-     *\/\n-    @Override\n-    public final String toString() {\n-        final StringBuilder buf = new StringBuilder(Const.getAttributeName(getTag()));\n-        buf.append(\":\\n\");\n-        for (int i = 0; i < annotationTable.length; i++) {\n-            buf.append(\"  \").append(annotationTable[i]);\n-            if (i < annotationTable.length - 1) {\n-                buf.append('\\n');\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n@@ -162,1 +117,0 @@\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Annotations.java","additions":31,"deletions":77,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n-public class ArrayElementValue extends ElementValue {\n+public class ArrayElementValue extends ElementValue\n+{\n@@ -34,1 +35,18 @@\n-    public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool) {\n+    @Override\n+    public String toString()\n+    {\n+        final StringBuilder sb = new StringBuilder();\n+        sb.append(\"{\");\n+        for (int i = 0; i < elementValues.length; i++)\n+        {\n+            sb.append(elementValues[i]);\n+            if ((i + 1) < elementValues.length) {\n+                sb.append(\",\");\n+            }\n+        }\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    public ArrayElementValue(final int type, final ElementValue[] datums, final ConstantPool cpool)\n+    {\n@@ -37,1 +55,2 @@\n-            throw new ClassFormatException(\"Only element values of type array can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type array can be built with this ctor - type specified: \" + type);\n@@ -43,1 +62,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -51,8 +71,0 @@\n-    public ElementValue[] getElementValuesArray() {\n-        return elementValues;\n-    }\n-\n-    public int getElementValuesArraySize() {\n-        return elementValues.length;\n-    }\n-\n@@ -60,1 +72,2 @@\n-    public String stringifyValue() {\n+    public String stringifyValue()\n+    {\n@@ -63,1 +76,2 @@\n-        for (int i = 0; i < elementValues.length; i++) {\n+        for (int i = 0; i < elementValues.length; i++)\n+        {\n@@ -65,1 +79,1 @@\n-            if (i + 1 < elementValues.length) {\n+            if ((i + 1) < elementValues.length) {\n@@ -73,12 +87,8 @@\n-    @Override\n-    public String toString() {\n-        final StringBuilder sb = new StringBuilder();\n-        sb.append(\"{\");\n-        for (int i = 0; i < elementValues.length; i++) {\n-            sb.append(elementValues[i]);\n-            if (i + 1 < elementValues.length) {\n-                sb.append(\",\");\n-            }\n-        }\n-        sb.append(\"}\");\n-        return sb.toString();\n+    public ElementValue[] getElementValuesArray()\n+    {\n+        return elementValues;\n+    }\n+\n+    public int getElementValuesArraySize()\n+    {\n+        return elementValues.length;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ArrayElementValue.java","additions":37,"deletions":27,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -33,11 +32,6 @@\n- * Abstract super class for <em>Attribute<\/em> objects. Currently the <em>ConstantValue<\/em>, <em>SourceFile<\/em>, <em>Code<\/em>, <em>Exceptiontable<\/em>,\n- * <em>LineNumberTable<\/em>, <em>LocalVariableTable<\/em>, <em>InnerClasses<\/em> and <em>Synthetic<\/em> attributes are supported. The <em>Unknown<\/em> attribute\n- * stands for non-standard-attributes.\n- *\n- * <pre>\n- * attribute_info {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u1 info[attribute_length];\n- * }\n- * <\/pre>\n+ * Abstract super class for <em>Attribute<\/em> objects. Currently the\n+ * <em>ConstantValue<\/em>, <em>SourceFile<\/em>, <em>Code<\/em>,\n+ * <em>Exceptiontable<\/em>, <em>LineNumberTable<\/em>,\n+ * <em>LocalVariableTable<\/em>, <em>InnerClasses<\/em> and\n+ * <em>Synthetic<\/em> attributes are supported. The <em>Unknown<\/em>\n+ * attribute stands for non-standard-attributes.\n@@ -56,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -60,0 +54,4 @@\n+    private int name_index; \/\/ Points to attribute name in constant pool\n+    private int length; \/\/ Content length of attribute field\n+    private final byte tag; \/\/ Tag to distinguish subclasses\n+    private ConstantPool constant_pool;\n@@ -61,8 +59,1 @@\n-    private static final Map<String, Object> READERS = new HashMap<>();\n-\n-    \/**\n-     * Empty array.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final Attribute[] EMPTY_ARRAY = {};\n+    private static final Map<String, Object> readers = new HashMap<>();\n@@ -71,2 +62,3 @@\n-     * Add an Attribute reader capable of parsing (user-defined) attributes named \"name\". You should not add readers for the\n-     * standard attributes such as \"LineNumberTable\", because those are handled internally.\n+     * Add an Attribute reader capable of parsing (user-defined) attributes\n+     * named \"name\". You should not add readers for the standard attributes such\n+     * as \"LineNumberTable\", because those are handled internally.\n@@ -75,1 +67,1 @@\n-     * @param unknownAttributeReader the reader object\n+     * @param r    the reader object\n@@ -77,2 +69,3 @@\n-    public static void addAttributeReader(final String name, final UnknownAttributeReader unknownAttributeReader) {\n-        READERS.put(name, unknownAttributeReader);\n+    public static void addAttributeReader(final String name, final UnknownAttributeReader r)\n+    {\n+        readers.put(name, r);\n@@ -88,2 +81,3 @@\n-     * Class method reads one attribute from the input data stream. This method must not be accessible from the outside. It\n-     * is called by the Field and Method constructor methods.\n+     * Class method reads one attribute from the input data stream. This method\n+     * must not be accessible from the outside. It is called by the Field and\n+     * Method constructor methods.\n@@ -94,2 +88,2 @@\n-     * @param dataInput Input stream\n-     * @param constantPool Array of constants\n+     * @param file Input stream\n+     * @param constant_pool Array of constants\n@@ -97,1 +91,2 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -100,1 +95,3 @@\n-    public static Attribute readAttribute(final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n+    public static Attribute readAttribute(final DataInput file, final ConstantPool constant_pool)\n+            throws IOException, ClassFormatException\n+    {\n@@ -102,3 +99,4 @@\n-        \/\/ Get class name from constant pool via 'name_index' indirection\n-        final int nameIndex = dataInput.readUnsignedShort();\n-        final String name = constantPool.getConstantUtf8(nameIndex).getBytes();\n+        \/\/ Get class name from constant pool via `name_index' indirection\n+        final int name_index = file.readUnsignedShort();\n+        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n+        final String name = c.getBytes();\n@@ -107,1 +105,1 @@\n-        final int length = dataInput.readInt();\n+        final int length = file.readInt();\n@@ -110,2 +108,4 @@\n-        for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++) {\n-            if (name.equals(Const.getAttributeName(i))) {\n+        for (byte i = 0; i < Const.KNOWN_ATTRIBUTES; i++)\n+        {\n+            if (name.equals(Const.getAttributeName(i)))\n+            {\n@@ -117,70 +117,72 @@\n-        \/\/ Call proper constructor, depending on 'tag'\n-        switch (tag) {\n-        case Const.ATTR_UNKNOWN:\n-            final Object r = READERS.get(name);\n-            if (r instanceof UnknownAttributeReader) {\n-                return ((UnknownAttributeReader) r).createAttribute(nameIndex, length, dataInput, constantPool);\n-            }\n-            return new Unknown(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_CONSTANT_VALUE:\n-            return new ConstantValue(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_SOURCE_FILE:\n-            return new SourceFile(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_CODE:\n-            return new Code(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_EXCEPTIONS:\n-            return new ExceptionTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_LINE_NUMBER_TABLE:\n-            return new LineNumberTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_LOCAL_VARIABLE_TABLE:\n-            return new LocalVariableTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_INNER_CLASSES:\n-            return new InnerClasses(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_SYNTHETIC:\n-            return new Synthetic(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_DEPRECATED:\n-            return new Deprecated(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_PMG:\n-            return new PMGClass(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_SIGNATURE:\n-            return new Signature(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_STACK_MAP:\n-            \/\/ old style stack map: unneeded for JDK5 and below;\n-            \/\/ illegal(?) for JDK6 and above. So just delete with a warning.\n-            println(\"Warning: Obsolete StackMap attribute ignored.\");\n-            return new Unknown(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:\n-            return new RuntimeVisibleAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:\n-            return new RuntimeInvisibleAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:\n-            return new RuntimeVisibleParameterAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:\n-            return new RuntimeInvisibleParameterAnnotations(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_ANNOTATION_DEFAULT:\n-            return new AnnotationDefault(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:\n-            return new LocalVariableTypeTable(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_ENCLOSING_METHOD:\n-            return new EnclosingMethod(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_STACK_MAP_TABLE:\n-            \/\/ read new style stack map: StackMapTable. The rest of the code\n-            \/\/ calls this a StackMap for historical reasons.\n-            return new StackMap(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_BOOTSTRAP_METHODS:\n-            return new BootstrapMethods(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_METHOD_PARAMETERS:\n-            return new MethodParameters(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_MODULE:\n-            return new Module(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_MODULE_PACKAGES:\n-            return new ModulePackages(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_MODULE_MAIN_CLASS:\n-            return new ModuleMainClass(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_NEST_HOST:\n-            return new NestHost(nameIndex, length, dataInput, constantPool);\n-        case Const.ATTR_NEST_MEMBERS:\n-            return new NestMembers(nameIndex, length, dataInput, constantPool);\n-        default:\n-            \/\/ Never reached\n-            throw new IllegalStateException(\"Unrecognized attribute type tag parsed: \" + tag);\n+        \/\/ Call proper constructor, depending on `tag'\n+        switch (tag)\n+        {\n+            case Const.ATTR_UNKNOWN:\n+                final Object r = readers.get(name);\n+                if (r instanceof UnknownAttributeReader)\n+                {\n+                    return ((UnknownAttributeReader) r).createAttribute(name_index, length, file, constant_pool);\n+                }\n+                return new Unknown(name_index, length, file, constant_pool);\n+            case Const.ATTR_CONSTANT_VALUE:\n+                return new ConstantValue(name_index, length, file, constant_pool);\n+            case Const.ATTR_SOURCE_FILE:\n+                return new SourceFile(name_index, length, file, constant_pool);\n+            case Const.ATTR_CODE:\n+                return new Code(name_index, length, file, constant_pool);\n+            case Const.ATTR_EXCEPTIONS:\n+                return new ExceptionTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_LINE_NUMBER_TABLE:\n+                return new LineNumberTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_LOCAL_VARIABLE_TABLE:\n+                return new LocalVariableTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_INNER_CLASSES:\n+                return new InnerClasses(name_index, length, file, constant_pool);\n+            case Const.ATTR_SYNTHETIC:\n+                return new Synthetic(name_index, length, file, constant_pool);\n+            case Const.ATTR_DEPRECATED:\n+                return new Deprecated(name_index, length, file, constant_pool);\n+            case Const.ATTR_PMG:\n+                return new PMGClass(name_index, length, file, constant_pool);\n+            case Const.ATTR_SIGNATURE:\n+                return new Signature(name_index, length, file, constant_pool);\n+            case Const.ATTR_STACK_MAP:\n+                \/\/ old style stack map: unneeded for JDK5 and below;\n+                \/\/ illegal(?) for JDK6 and above.  So just delete with a warning.\n+                println(\"Warning: Obsolete StackMap attribute ignored.\");\n+                return new Unknown(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS:\n+                return new RuntimeVisibleAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS:\n+                return new RuntimeInvisibleAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS:\n+                return new RuntimeVisibleParameterAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS:\n+                return new RuntimeInvisibleParameterAnnotations(name_index, length, file, constant_pool);\n+            case Const.ATTR_ANNOTATION_DEFAULT:\n+                return new AnnotationDefault(name_index, length, file, constant_pool);\n+            case Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE:\n+                return new LocalVariableTypeTable(name_index, length, file, constant_pool);\n+            case Const.ATTR_ENCLOSING_METHOD:\n+                return new EnclosingMethod(name_index, length, file, constant_pool);\n+            case Const.ATTR_STACK_MAP_TABLE:\n+                \/\/ read new style stack map: StackMapTable.  The rest of the code\n+                \/\/ calls this a StackMap for historical reasons.\n+                return new StackMap(name_index, length, file, constant_pool);\n+            case Const.ATTR_BOOTSTRAP_METHODS:\n+                return new BootstrapMethods(name_index, length, file, constant_pool);\n+            case Const.ATTR_METHOD_PARAMETERS:\n+                return new MethodParameters(name_index, length, file, constant_pool);\n+            case Const.ATTR_MODULE:\n+                return new Module(name_index, length, file, constant_pool);\n+            case Const.ATTR_MODULE_PACKAGES:\n+                return new ModulePackages(name_index, length, file, constant_pool);\n+            case Const.ATTR_MODULE_MAIN_CLASS:\n+                return new ModuleMainClass(name_index, length, file, constant_pool);\n+            case Const.ATTR_NEST_HOST:\n+                return new NestHost(name_index, length, file, constant_pool);\n+            case Const.ATTR_NEST_MEMBERS:\n+                return new NestMembers(name_index, length, file, constant_pool);\n+            default:\n+                \/\/ Never reached\n+                throw new IllegalStateException(\"Unrecognized attribute type tag parsed: \" + tag);\n@@ -191,2 +193,3 @@\n-     * Class method reads one attribute from the input data stream. This method must not be accessible from the outside. It\n-     * is called by the Field and Method constructor methods.\n+     * Class method reads one attribute from the input data stream. This method\n+     * must not be accessible from the outside. It is called by the Field and\n+     * Method constructor methods.\n@@ -197,2 +200,2 @@\n-     * @param dataInputStream Input stream\n-     * @param constantPool Array of constants\n+     * @param file Input stream\n+     * @param constant_pool Array of constants\n@@ -200,1 +203,2 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -202,2 +206,4 @@\n-    public static Attribute readAttribute(final DataInputStream dataInputStream, final ConstantPool constantPool) throws IOException {\n-        return readAttribute((DataInput) dataInputStream, constantPool);\n+    public static Attribute readAttribute(final DataInputStream file, final ConstantPool constant_pool)\n+            throws IOException, ClassFormatException\n+    {\n+        return readAttribute((DataInput) file, constant_pool);\n@@ -211,2 +217,3 @@\n-    public static void removeAttributeReader(final String name) {\n-        READERS.remove(name);\n+    public static void removeAttributeReader(final String name)\n+    {\n+        readers.remove(name);\n@@ -215,41 +222,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int name_index; \/\/ Points to attribute name in constant pool TODO make private (has getter & setter)\n-\n-    \/**\n-     * @deprecated (since 6.0) (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int length; \/\/ Content length of attribute field TODO make private (has getter & setter)\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected byte tag; \/\/ Tag to distinguish subclasses TODO make private & final; supposed to be immutable\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected ConstantPool constant_pool; \/\/ TODO make private (has getter & setter)\n-\n-    \/**\n-     * Constructs an instance.\n-     *\n-     * <pre>\n-     * attribute_info {\n-     *   u2 attribute_name_index;\n-     *   u4 attribute_length;\n-     *   u1 info[attribute_length];\n-     * }\n-     * <\/pre>\n-     *\n-     * @param tag tag.\n-     * @param nameIndex u2 name index.\n-     * @param length u4 length.\n-     * @param constantPool constant pool.\n-     *\/\n-    protected Attribute(final byte tag, final int nameIndex, final int length, final ConstantPool constantPool) {\n+    protected Attribute(final byte tag, final int name_index, final int length, final ConstantPool constant_pool)\n+    {\n@@ -257,3 +225,3 @@\n-        this.name_index = Args.requireU2(nameIndex, 0, constantPool.getLength(), getClass().getSimpleName() + \" name index\");\n-        this.length = Args.requireU4(length, getClass().getSimpleName() + \" attribute length\");\n-        this.constant_pool = constantPool;\n+        this.name_index = name_index;\n+        this.length = length;\n+        this.constant_pool = constant_pool;\n@@ -263,2 +231,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -266,1 +235,2 @@\n-     * @param v Visitor object\n+     * @param v\n+     *            Visitor object\n@@ -272,1 +242,2 @@\n-     * Use copy() if you want to have a deep copy(), i.e., with all references copied correctly.\n+     * Use copy() if you want to have a deep copy(), i.e., with all references\n+     * copied correctly.\n@@ -277,1 +248,2 @@\n-    public Object clone() {\n+    public Object clone()\n+    {\n@@ -279,1 +251,2 @@\n-        try {\n+        try\n+        {\n@@ -281,1 +254,3 @@\n-        } catch (final CloneNotSupportedException e) {\n+        }\n+        catch (final CloneNotSupportedException e)\n+        {\n@@ -288,2 +263,1 @@\n-     * @param constantPool constant pool to save.\n-     * @return deep copy of this attribute.\n+     * @return deep copy of this attribute\n@@ -291,1 +265,1 @@\n-    public abstract Attribute copy(ConstantPool constantPool);\n+    public abstract Attribute copy(ConstantPool _constant_pool);\n@@ -294,1 +268,1 @@\n-     * Dumps attribute to file stream in binary format.\n+     * Dump attribute to file stream in binary format.\n@@ -296,2 +270,3 @@\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @param file\n+     *            Output file stream\n+     * @throws IOException\n@@ -299,1 +274,2 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump(final DataOutputStream file) throws IOException\n+    {\n@@ -308,1 +284,2 @@\n-    public final ConstantPool getConstantPool() {\n+    public final ConstantPool getConstantPool()\n+    {\n@@ -315,1 +292,2 @@\n-    public final int getLength() {\n+    public final int getLength()\n+    {\n@@ -323,2 +301,4 @@\n-    public String getName() {\n-        return constant_pool.getConstantUtf8(name_index).getBytes();\n+    public String getName()\n+    {\n+        final ConstantUtf8 c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -330,1 +310,2 @@\n-    public final int getNameIndex() {\n+    public final int getNameIndex()\n+    {\n@@ -337,1 +318,2 @@\n-    public final byte getTag() {\n+    public final byte getTag()\n+    {\n@@ -342,1 +324,1 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * @param constant_pool Constant pool to be used for this object.\n@@ -345,2 +327,3 @@\n-    public final void setConstantPool(final ConstantPool constantPool) {\n-        this.constant_pool = constantPool;\n+    public final void setConstantPool(final ConstantPool constant_pool)\n+    {\n+        this.constant_pool = constant_pool;\n@@ -352,1 +335,2 @@\n-    public final void setLength(final int length) {\n+    public final void setLength(final int length)\n+    {\n@@ -357,1 +341,1 @@\n-     * @param nameIndex of attribute.\n+     * @param name_index of attribute.\n@@ -359,2 +343,3 @@\n-    public final void setNameIndex(final int nameIndex) {\n-        this.name_index = nameIndex;\n+    public final void setNameIndex(final int name_index)\n+    {\n+        this.name_index = name_index;\n@@ -367,1 +352,2 @@\n-    public String toString() {\n+    public String toString()\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Attribute.java","additions":176,"deletions":190,"binary":false,"changes":366,"status":"modified"},{"patch":"@@ -25,3 +25,4 @@\n- * Unknown (non-standard) attributes may be read via user-defined factory objects that can be registered with the\n- * Attribute.addAttributeReader method. These factory objects should implement this interface.\n- *\n+ * Unknown (non-standard) attributes may be read via user-defined factory\n+ * objects that can be registered with the Attribute.addAttributeReader\n+ * method. These factory objects should implement this interface.\n+\n@@ -36,17 +37,24 @@\n-     * When this attribute reader is added via the static method Attribute.addAttributeReader, an attribute name is\n-     * associated with it. As the class file parser parses attributes, it will call various AttributeReaders based on the\n-     * name of the attributes it is constructing.\n-     *\n-     * @param nameIndex An index into the constant pool, indexing a ConstantUtf8 that represents the name of the attribute.\n-     *\n-     * @param length The length of the data contained in the attribute. This is written into the constant pool and should\n-     *        agree with what the factory expects the length to be.\n-     *\n-     * @param file This is the data input stream that the factory needs to read its data from.\n-     *\n-     * @param constantPool This is the constant pool associated with the Attribute that we are constructing.\n-     *\n-     * @return The user-defined AttributeReader should take this data and use it to construct an attribute. In the case of\n-     *         errors, a null can be returned which will cause the parsing of the class file to fail.\n-     *\n-     * @see Attribute#addAttributeReader( String, AttributeReader )\n+     When this attribute reader is added via the static method\n+     Attribute.addAttributeReader, an attribute name is associated with it.\n+     As the class file parser parses attributes, it will call various\n+     AttributeReaders based on the name of the attributes it is\n+     constructing.\n+\n+     @param name_index An index into the constant pool, indexing a\n+     ConstantUtf8 that represents the name of the attribute.\n+\n+     @param length The length of the data contained in the attribute.  This\n+     is written into the constant pool and should agree with what the\n+     factory expects the length to be.\n+\n+     @param file This is the data input stream that the factory needs to read\n+     its data from.\n+\n+     @param constant_pool This is the constant pool associated with the\n+     Attribute that we are constructing.\n+\n+     @return The user-defined AttributeReader should take this data and use\n+     it to construct an attribute.  In the case of errors, a null can be\n+     returned which will cause the parsing of the class file to fail.\n+\n+     @see Attribute#addAttributeReader( String, AttributeReader )\n@@ -54,1 +62,1 @@\n-    Attribute createAttribute(int nameIndex, int length, java.io.DataInputStream file, ConstantPool constantPool);\n+    Attribute createAttribute( int name_index, int length, java.io.DataInputStream file, ConstantPool constant_pool );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/AttributeReader.java","additions":29,"deletions":21,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -32,2 +32,3 @@\n- * This class represents a bootstrap method attribute, i.e., the bootstrap method ref, the number of bootstrap arguments\n- * and an array of the bootstrap arguments.\n+ * This class represents a bootstrap method attribute, i.e., the bootstrap\n+ * method ref, the number of bootstrap arguments and an array of the\n+ * bootstrap arguments.\n@@ -35,2 +36,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\"> The class File Format :\n- *      The BootstrapMethods Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\">\n+ * The class File Format : The BootstrapMethods Attribute<\/a>\n@@ -47,0 +48,1 @@\n+\n@@ -49,2 +51,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -60,1 +60,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -71,2 +71,2 @@\n-    private BootstrapMethod(final int bootstrapMethodRef, final int numBootstrapArguments) {\n-        this(bootstrapMethodRef, new int[numBootstrapArguments]);\n+    private BootstrapMethod(final int bootstrap_method_ref, final int num_bootstrap_arguments) {\n+        this(bootstrap_method_ref, new int[num_bootstrap_arguments]);\n@@ -85,1 +85,1 @@\n-     * @return deep copy of this object\n+     * @return index into constant_pool of bootstrap_method\n@@ -87,7 +87,2 @@\n-    public BootstrapMethod copy() {\n-        try {\n-            return (BootstrapMethod) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public int getBootstrapMethodRef() {\n+        return bootstrapMethodRef;\n@@ -97,4 +92,1 @@\n-     * Dump object to file stream in binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @param bootstrapMethodRef int index into constant_pool of CONSTANT_MethodHandle\n@@ -102,6 +94,2 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        file.writeShort(bootstrapMethodRef);\n-        file.writeShort(bootstrapArguments.length);\n-        for (final int bootstrapArgument : bootstrapArguments) {\n-            file.writeShort(bootstrapArgument);\n-        }\n+    public void setBootstrapMethodRef(final int bootstrapMethodRef) {\n+        this.bootstrapMethodRef = bootstrapMethodRef;\n@@ -117,7 +105,0 @@\n-    \/**\n-     * @return index into constant_pool of bootstrap_method\n-     *\/\n-    public int getBootstrapMethodRef() {\n-        return bootstrapMethodRef;\n-    }\n-\n@@ -138,7 +119,0 @@\n-    \/**\n-     * @param bootstrapMethodRef int index into constant_pool of CONSTANT_MethodHandle\n-     *\/\n-    public void setBootstrapMethodRef(final int bootstrapMethodRef) {\n-        this.bootstrapMethodRef = bootstrapMethodRef;\n-    }\n-\n@@ -150,1 +124,2 @@\n-        return \"BootstrapMethod(\" + bootstrapMethodRef + \", \" + bootstrapArguments.length + \", \" + Arrays.toString(bootstrapArguments) + \")\";\n+        return \"BootstrapMethod(\" + bootstrapMethodRef + \", \" + bootstrapArguments.length + \", \"\n+               + Arrays.toString(bootstrapArguments) + \")\";\n@@ -156,1 +131,1 @@\n-    public final String toString(final ConstantPool constantPool) {\n+    public final String toString( final ConstantPool constantPool ) {\n@@ -158,4 +133,6 @@\n-        final String bootstrapMethodName = constantPool.constantToString(bootstrapMethodRef, Const.CONSTANT_MethodHandle);\n-        buf.append(Utility.compactClassName(bootstrapMethodName, false));\n-        final int bootstrapArgumentsLen = bootstrapArguments.length;\n-        if (bootstrapArgumentsLen > 0) {\n+        String bootstrap_method_name;\n+        bootstrap_method_name = constantPool.constantToString(bootstrapMethodRef,\n+                Const.CONSTANT_MethodHandle);\n+        buf.append(Utility.compactClassName(bootstrap_method_name, false));\n+        final int num_bootstrap_arguments = bootstrapArguments.length;\n+        if (num_bootstrap_arguments > 0) {\n@@ -163,1 +140,1 @@\n-            for (int i = 0; i < bootstrapArgumentsLen; i++) {\n+            for (int i = 0; i < num_bootstrap_arguments; i++) {\n@@ -170,0 +147,26 @@\n+\n+    \/**\n+     * Dump object to file stream in binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException\n+     *\/\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        file.writeShort(bootstrapMethodRef);\n+        file.writeShort(bootstrapArguments.length);\n+        for (final int bootstrap_argument : bootstrapArguments) {\n+            file.writeShort(bootstrap_argument);\n+        }\n+    }\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public BootstrapMethod copy() {\n+        try {\n+            return (BootstrapMethod) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethod.java","additions":51,"deletions":48,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -35,2 +33,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\"> The class File Format :\n- *      The BootstrapMethods Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.23\">\n+ * The class File Format : The BootstrapMethods Attribute<\/a>\n@@ -39,1 +37,1 @@\n-public class BootstrapMethods extends Attribute implements Iterable<BootstrapMethod> {\n+public class BootstrapMethods extends Attribute {\n@@ -41,1 +39,1 @@\n-    private BootstrapMethod[] bootstrapMethods; \/\/ TODO this could be made final (setter is not used)\n+    private BootstrapMethod[] bootstrapMethods;  \/\/ TODO this could be made final (setter is not used)\n@@ -44,4 +42,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -53,0 +49,1 @@\n+\n@@ -54,1 +51,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -57,1 +54,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -59,2 +56,2 @@\n-    public BootstrapMethods(final int nameIndex, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constantPool) {\n-        super(Const.ATTR_BOOTSTRAP_METHODS, nameIndex, length, constantPool);\n+    public BootstrapMethods(final int name_index, final int length, final BootstrapMethod[] bootstrapMethods, final ConstantPool constant_pool) {\n+        super(Const.ATTR_BOOTSTRAP_METHODS, name_index, length, constant_pool);\n@@ -67,1 +64,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -70,2 +67,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -73,2 +70,2 @@\n-    BootstrapMethods(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (BootstrapMethod[]) null, constantPool);\n+    BootstrapMethods(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (BootstrapMethod[]) null, constant_pool);\n@@ -76,3 +73,3 @@\n-        final int numBootstrapMethods = input.readUnsignedShort();\n-        bootstrapMethods = new BootstrapMethod[numBootstrapMethods];\n-        for (int i = 0; i < numBootstrapMethods; i++) {\n+        final int num_bootstrap_methods = input.readUnsignedShort();\n+        bootstrapMethods = new BootstrapMethod[num_bootstrap_methods];\n+        for (int i = 0; i < num_bootstrap_methods; i++) {\n@@ -83,0 +80,14 @@\n+    \/**\n+     * @return array of bootstrap method \"records\"\n+     *\/\n+    public final BootstrapMethod[] getBootstrapMethods() {\n+        return bootstrapMethods;\n+    }\n+\n+    \/**\n+     * @param bootstrapMethods the array of bootstrap methods\n+     *\/\n+    public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {\n+        this.bootstrapMethods = bootstrapMethods;\n+    }\n+\n@@ -95,1 +106,1 @@\n-    public BootstrapMethods copy(final ConstantPool constantPool) {\n+    public BootstrapMethods copy(final ConstantPool _constant_pool) {\n@@ -102,1 +113,1 @@\n-        c.setConstantPool(constantPool);\n+        c.setConstantPool(_constant_pool);\n@@ -110,1 +121,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -117,2 +128,2 @@\n-        for (final BootstrapMethod bootstrapMethod : bootstrapMethods) {\n-            bootstrapMethod.dump(file);\n+        for (final BootstrapMethod bootstrap_method : bootstrapMethods) {\n+            bootstrap_method.dump(file);\n@@ -122,19 +133,0 @@\n-    \/**\n-     * @return array of bootstrap method \"records\"\n-     *\/\n-    public final BootstrapMethod[] getBootstrapMethods() {\n-        return bootstrapMethods;\n-    }\n-\n-    @Override\n-    public Iterator<BootstrapMethod> iterator() {\n-        return Stream.of(bootstrapMethods).iterator();\n-    }\n-\n-    \/**\n-     * @param bootstrapMethods the array of bootstrap methods\n-     *\/\n-    public final void setBootstrapMethods(final BootstrapMethod[] bootstrapMethods) {\n-        this.bootstrapMethods = bootstrapMethods;\n-    }\n-\n@@ -154,2 +146,2 @@\n-            final int indentCount = buf.length() - start;\n-            final String[] lines = bootstrapMethods[i].toString(super.getConstantPool()).split(\"\\\\r?\\\\n\");\n+            final int indent_count = buf.length() - start;\n+            final String[] lines = (bootstrapMethods[i].toString(super.getConstantPool())).split(\"\\\\r?\\\\n\");\n@@ -158,1 +150,1 @@\n-                buf.append(\"\\n\").append(\"          \", 0, indentCount).append(lines[j]);\n+                buf.append(\"\\n\").append(\"          \".substring(0,indent_count)).append(lines[j]);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/BootstrapMethods.java","additions":41,"deletions":49,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -30,1 +32,2 @@\n-public class ClassElementValue extends ElementValue {\n+public class ClassElementValue extends ElementValue\n+{\n@@ -36,1 +39,2 @@\n-    public ClassElementValue(final int type, final int idx, final ConstantPool cpool) {\n+    public ClassElementValue(final int type, final int idx, final ConstantPool cpool)\n+    {\n@@ -41,4 +45,3 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getType()); \/\/ u1 kind of value\n-        dos.writeShort(idx);\n+    public int getIndex()\n+    {\n+        return idx;\n@@ -47,2 +50,5 @@\n-    public String getClassString() {\n-        return super.getConstantPool().getConstantUtf8(idx).getBytes();\n+    public String getClassString()\n+    {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(idx,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -51,2 +57,6 @@\n-    public int getIndex() {\n-        return idx;\n+    @Override\n+    public String stringifyValue()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(idx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\n@@ -56,2 +66,4 @@\n-    public String stringifyValue() {\n-        return super.getConstantPool().getConstantUtf8(idx).getBytes();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getType()); \/\/ u1 kind of value\n+        dos.writeShort(idx);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassElementValue.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -25,1 +25,4 @@\n- * Thrown when the BCEL attempts to read a class file and determines that a class is malformed or otherwise cannot be interpreted as a class file.\n+ * Thrown when the BCEL attempts to read a class file and determines\n+ * that the file is malformed or otherwise cannot be interpreted as a\n+ * class file.\n+ *\n@@ -31,4 +34,0 @@\n-    \/**\n-     * Constructs a new instance with {@code null} as its detail message. The cause is not initialized, and may subsequently be initialized by a call to\n-     * {@link #initCause}.\n-     *\/\n@@ -36,0 +35,1 @@\n+        super();\n@@ -38,8 +38,3 @@\n-    \/**\n-     * Constructs a new instance with the specified detail message. The cause is not initialized, and may subsequently be initialized by a call to\n-     * {@link #initCause}.\n-     *\n-     * @param message the detail message. The detail message is saved for later retrieval by the {@link #getMessage()} method.\n-     *\/\n-    public ClassFormatException(final String message) {\n-        super(message);\n+\n+    public ClassFormatException(final String s) {\n+        super(s);\n@@ -49,7 +44,0 @@\n-     * Constructs a new instance with the specified detail message and cause.\n-     * <p>\n-     * Note that the detail message associated with {@code cause} is <i>not<\/i> automatically incorporated in this runtime exception's detail message.\n-     *\n-     * @param message the detail message (which is saved for later retrieval by the {@link #getMessage()} method).\n-     * @param cause   the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that\n-     *                the cause is nonexistent or unknown.)\n@@ -61,12 +49,0 @@\n-\n-    \/**\n-     * Constructs a new instance with the specified cause and a detail message of {@code (cause==null ? null : cause.toString())} (which typically contains the\n-     * class and detail message of {@code cause}). This constructor is useful for runtime exceptions that are little more than wrappers for other throwables.\n-     *\n-     * @param cause the cause (which is saved for later retrieval by the {@link #getCause()} method). (A {@code null} value is permitted, and indicates that the\n-     *              cause is nonexistent or unknown.)\n-     * @since 6.7.0\n-     *\/\n-    public ClassFormatException(final Throwable cause) {\n-        super(cause);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassFormatException.java","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -35,3 +35,10 @@\n- * Wrapper class that parses a given Java .class file. The method <a href =\"#parse\">parse<\/a> returns a\n- * <a href =\"JavaClass.html\"> JavaClass<\/a> object on success. When an I\/O error or an inconsistency occurs an\n- * appropriate exception is propagated back to the caller.\n+ * Wrapper class that parses a given Java .class file. The method <A\n+ * href =\"#parse\">parse<\/A> returns a <A href =\"JavaClass.html\">\n+ * JavaClass<\/A> object on success. When an I\/O error or an\n+ * inconsistency occurs an appropiate exception is propagated back to\n+ * the caller.\n+ *\n+ * The structure and the names comply, except for a few conveniences,\n+ * exactly with the <A href=\"http:\/\/docs.oracle.com\/javase\/specs\/\">\n+ * JVM specification 1.0<\/a>. See this paper for\n+ * further details about the structure of a bytecode file.\n@@ -39,3 +46,0 @@\n- * The structure and the names comply, except for a few conveniences, exactly with the\n- * <a href=\"http:\/\/docs.oracle.com\/javase\/specs\/\"> JVM specification 1.0<\/a>. See this paper for further details about\n- * the structure of a bytecode file.\n@@ -45,1 +49,0 @@\n-    private static final int BUFSIZE = 8192;\n@@ -61,0 +64,2 @@\n+    private static final int BUFSIZE = 8192;\n+\n@@ -70,1 +75,1 @@\n-        this.fileOwned = false;\n+        fileOwned = false;\n@@ -72,1 +77,1 @@\n-        this.isZip = clazz.startsWith(\"java.util.zip.\") || clazz.startsWith(\"java.util.jar.\");\n+        isZip = clazz.startsWith(\"java.util.zip.\") || clazz.startsWith(\"java.util.jar.\");\n@@ -80,2 +85,2 @@\n-    \/**\n-     * Parses class from given .class file.\n+\n+    \/** Parses class from given .class file.\n@@ -86,1 +91,1 @@\n-        this.isZip = false;\n+        isZip = false;\n@@ -88,1 +93,1 @@\n-        this.fileOwned = true;\n+        fileOwned = true;\n@@ -91,2 +96,2 @@\n-    \/**\n-     * Parses class from given .class file in a ZIP-archive\n+\n+    \/** Parses class from given .class file in a ZIP-archive\n@@ -98,2 +103,2 @@\n-        this.isZip = true;\n-        this.fileOwned = true;\n+        isZip = true;\n+        fileOwned = true;\n@@ -104,0 +109,1 @@\n+\n@@ -105,3 +111,5 @@\n-     * Parses the given Java class file and return an object that represents the contained data, i.e., constants, methods,\n-     * fields and commands. A <em>ClassFormatException<\/em> is raised, if the file is not a valid .class file. (This does\n-     * not include verification of the byte code as it is performed by the java interpreter).\n+     * Parses the given Java class file and return an object that represents\n+     * the contained data, i.e., constants, methods, fields and commands.\n+     * A <em>ClassFormatException<\/em> is raised, if the file is not a valid\n+     * .class file. (This does not include verification of the byte code as it\n+     * is performed by the java interpreter).\n@@ -110,2 +118,2 @@\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -125,1 +133,2 @@\n-                    dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry), BUFSIZE));\n+                    dataInputStream = new DataInputStream(new BufferedInputStream(zip.getInputStream(entry),\n+                            BUFSIZE));\n@@ -127,1 +136,2 @@\n-                    dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(fileName), BUFSIZE));\n+                    dataInputStream = new DataInputStream(new BufferedInputStream(new FileInputStream(\n+                            fileName), BUFSIZE));\n@@ -150,3 +160,3 @@\n-            \/\/ Unknown[] u = Unknown.getUnknownAttributes();\n-            \/\/ for (int i=0; i < u.length; i++)\n-            \/\/ System.err.println(\"WARNING: \" + u[i]);\n+            \/\/Unknown[] u = Unknown.getUnknownAttributes();\n+            \/\/for (int i=0; i < u.length; i++)\n+            \/\/  System.err.println(\"WARNING: \" + u[i]);\n@@ -154,9 +164,9 @@\n-            \/\/ if(file.available() > 0) {\n-            \/\/ int bytes = file.available();\n-            \/\/ byte[] buf = new byte[bytes];\n-            \/\/ file.read(buf);\n-            \/\/ if(!(isZip && (buf.length == 1))) {\n-            \/\/ System.err.println(\"WARNING: Trailing garbage at end of \" + fileName);\n-            \/\/ System.err.println(bytes + \" extra bytes: \" + Utility.toHexString(buf));\n-            \/\/ }\n-            \/\/ }\n+            \/\/      if(file.available() > 0) {\n+            \/\/        int bytes = file.available();\n+            \/\/        byte[] buf = new byte[bytes];\n+            \/\/        file.read(buf);\n+            \/\/        if(!(isZip && (buf.length == 1))) {\n+            \/\/      System.err.println(\"WARNING: Trailing garbage at end of \" + fileName);\n+            \/\/      System.err.println(bytes + \" extra bytes: \" + Utility.toHexString(buf));\n+            \/\/        }\n+            \/\/      }\n@@ -170,2 +180,2 @@\n-                } catch (final IOException ignored) {\n-                    \/\/ ignore close exceptions\n+                } catch (final IOException ioe) {\n+                    \/\/ignore close exceptions\n@@ -178,2 +188,2 @@\n-            } catch (final IOException ignored) {\n-                \/\/ ignore close exceptions\n+            } catch (final IOException ioe) {\n+                \/\/ignore close exceptions\n@@ -183,2 +193,4 @@\n-        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor, accessFlags, constantPool, interfaces, fields, methods, attributes,\n-            isZip ? JavaClass.ZIP : JavaClass.FILE);\n+        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor,\n+                accessFlags, constantPool, interfaces, fields, methods, attributes, isZip\n+                        ? JavaClass.ZIP\n+                        : JavaClass.FILE);\n@@ -187,0 +199,1 @@\n+\n@@ -189,3 +202,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -194,3 +206,3 @@\n-        final int attributesCount = dataInputStream.readUnsignedShort();\n-        attributes = new Attribute[attributesCount];\n-        for (int i = 0; i < attributesCount; i++) {\n+        final int attributes_count = dataInputStream.readUnsignedShort();\n+        attributes = new Attribute[attributes_count];\n+        for (int i = 0; i < attributes_count; i++) {\n@@ -201,0 +213,1 @@\n+\n@@ -203,3 +216,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -209,2 +221,2 @@\n-        \/*\n-         * Interfaces are implicitly abstract, the flag should be set according to the JVM specification.\n+        \/* Interfaces are implicitely abstract, the flag should be set\n+         * according to the JVM specification.\n@@ -215,1 +227,2 @@\n-        if ((accessFlags & Const.ACC_ABSTRACT) != 0 && (accessFlags & Const.ACC_FINAL) != 0) {\n+        if (((accessFlags & Const.ACC_ABSTRACT) != 0)\n+                && ((accessFlags & Const.ACC_FINAL) != 0)) {\n@@ -222,0 +235,1 @@\n+\n@@ -224,3 +238,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -232,0 +245,1 @@\n+\n@@ -234,3 +248,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -239,3 +252,3 @@\n-        final int fieldsCount = dataInputStream.readUnsignedShort();\n-        fields = new Field[fieldsCount];\n-        for (int i = 0; i < fieldsCount; i++) {\n+        final int fields_count = dataInputStream.readUnsignedShort();\n+        fields = new Field[fields_count];\n+        for (int i = 0; i < fields_count; i++) {\n@@ -246,0 +259,1 @@\n+\n@@ -248,4 +262,4 @@\n-     * Checks whether the header of the file is ok. Of course, this has to be the first action on successive file reads.\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * Checks whether the header of the file is ok.\n+     * Of course, this has to be the first action on successive file reads.\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -259,0 +273,1 @@\n+\n@@ -261,3 +276,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -266,3 +280,3 @@\n-        final int interfacesCount = dataInputStream.readUnsignedShort();\n-        interfaces = new int[interfacesCount];\n-        for (int i = 0; i < interfacesCount; i++) {\n+        final int interfaces_count = dataInputStream.readUnsignedShort();\n+        interfaces = new int[interfaces_count];\n+        for (int i = 0; i < interfaces_count; i++) {\n@@ -273,0 +287,1 @@\n+\n@@ -275,3 +290,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n@@ -279,4 +293,4 @@\n-    private void readMethods() throws IOException {\n-        final int methodsCount = dataInputStream.readUnsignedShort();\n-        methods = new Method[methodsCount];\n-        for (int i = 0; i < methodsCount; i++) {\n+    private void readMethods() throws IOException, ClassFormatException {\n+        final int methods_count = dataInputStream.readUnsignedShort();\n+        methods = new Method[methods_count];\n+        for (int i = 0; i < methods_count; i++) {\n@@ -287,0 +301,1 @@\n+\n@@ -289,3 +304,2 @@\n-     *\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws  IOException\n+     * @throws  ClassFormatException\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ClassParser.java","additions":97,"deletions":83,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,3 +31,6 @@\n- * This class represents a chunk of Java byte code contained in a method. It is instantiated by the\n- * <em>Attribute.readAttribute()<\/em> method. A <em>Code<\/em> attribute contains informations about operand stack, local\n- * variables, byte code and the exceptions handled within this method.\n+ * This class represents a chunk of Java byte code contained in a\n+ * method. It is instantiated by the\n+ * <em>Attribute.readAttribute()<\/em> method. A <em>Code<\/em>\n+ * attribute contains informations about operand stack, local\n+ * variables, byte code and the exceptions handled within this\n+ * method.\n@@ -36,2 +38,3 @@\n- * This attribute has attributes itself, namely <em>LineNumberTable<\/em> which is used for debugging purposes and\n- * <em>LocalVariableTable<\/em> which contains information about the local variables.\n+ * This attribute has attributes itself, namely <em>LineNumberTable<\/em> which\n+ * is used for debugging purposes and <em>LocalVariableTable<\/em> which\n+ * contains information about the local variables.\n@@ -39,22 +42,3 @@\n- * <pre>\n- * Code_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 max_stack;\n- *   u2 max_locals;\n- *   u4 code_length;\n- *   u1 code[code_length];\n- *   u2 exception_table_length;\n- *   {\n- *     u2 start_pc;\n- *     u2 end_pc;\n- *     u2 handler_pc;\n- *     u2 catch_type;\n- *   } exception_table[exception_table_length];\n- *   u2 attributes_count;\n- *   attribute_info attributes[attributes_count];\n- * }\n- * <\/pre>\n- * @see Attribute\n- * @see CodeException\n- * @see LineNumberTable\n+ * @see     Attribute\n+ * @see     CodeException\n+ * @see     LineNumberTable\n@@ -62,1 +46,0 @@\n- * @LastModified: Feb 2023\n@@ -66,2 +49,2 @@\n-    private int maxStack; \/\/ Maximum size of stack used by this method \/\/ TODO this could be made final (setter is not used)\n-    private int maxLocals; \/\/ Number of local variables \/\/ TODO this could be made final (setter is not used)\n+    private int maxStack; \/\/ Maximum size of stack used by this method  \/\/ TODO this could be made final (setter is not used)\n+    private int maxLocals; \/\/ Number of local variables  \/\/ TODO this could be made final (setter is not used)\n@@ -72,0 +55,1 @@\n+\n@@ -73,4 +57,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param code The source Code.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -78,3 +60,3 @@\n-    public Code(final Code code) {\n-        this(code.getNameIndex(), code.getLength(), code.getMaxStack(), code.getMaxLocals(), code.getCode(), code.getExceptionTable(), code.getAttributes(),\n-                code.getConstantPool());\n+    public Code(final Code c) {\n+        this(c.getNameIndex(), c.getLength(), c.getMaxStack(), c.getMaxLocals(), c.getCode(), c\n+                .getExceptionTable(), c.getAttributes(), c.getConstantPool());\n@@ -83,0 +65,1 @@\n+\n@@ -84,1 +67,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -87,1 +70,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -89,1 +72,2 @@\n-    Code(final int nameIndex, final int length, final DataInput file, final ConstantPool constantPool) throws IOException {\n+    Code(final int name_index, final int length, final DataInput file, final ConstantPool constant_pool)\n+            throws IOException {\n@@ -91,3 +75,4 @@\n-        this(nameIndex, length, file.readUnsignedShort(), file.readUnsignedShort(), (byte[]) null, (CodeException[]) null, (Attribute[]) null, constantPool);\n-        final int codeLength = Args.requireU4(file.readInt(), 1, \"Code length attribute\");\n-        code = new byte[codeLength]; \/\/ Read byte code\n+        this(name_index, length, file.readUnsignedShort(), file.readUnsignedShort(), (byte[]) null,\n+                (CodeException[]) null, (Attribute[]) null, constant_pool);\n+        final int code_length = file.readInt();\n+        code = new byte[code_length]; \/\/ Read byte code\n@@ -95,3 +80,2 @@\n-        \/*\n-         * Read exception table that contains all regions where an exception handler is active, i.e., a try { ... } catch()\n-         * block.\n+        \/* Read exception table that contains all regions where an exception\n+         * handler is active, i.e., a try { ... } catch() block.\n@@ -99,3 +83,3 @@\n-        final int exceptionTableLength = file.readUnsignedShort();\n-        exceptionTable = new CodeException[exceptionTableLength];\n-        for (int i = 0; i < exceptionTableLength; i++) {\n+        final int exception_table_length = file.readUnsignedShort();\n+        exceptionTable = new CodeException[exception_table_length];\n+        for (int i = 0; i < exception_table_length; i++) {\n@@ -104,2 +88,2 @@\n-        \/*\n-         * Read all attributes, currently 'LineNumberTable' and 'LocalVariableTable'\n+        \/* Read all attributes, currently `LineNumberTable' and\n+         * `LocalVariableTable'\n@@ -107,4 +91,4 @@\n-        final int attributesCount = file.readUnsignedShort();\n-        attributes = new Attribute[attributesCount];\n-        for (int i = 0; i < attributesCount; i++) {\n-            attributes[i] = Attribute.readAttribute(file, constantPool);\n+        final int attributes_count = file.readUnsignedShort();\n+        attributes = new Attribute[attributes_count];\n+        for (int i = 0; i < attributes_count; i++) {\n+            attributes[i] = Attribute.readAttribute(file, constant_pool);\n@@ -112,3 +96,3 @@\n-        \/*\n-         * Adjust length, because of setAttributes in this(), s.b. length is incorrect, because it didn't take the internal\n-         * attributes into account yet! Very subtle bug, fixed in 3.1.1.\n+        \/* Adjust length, because of setAttributes in this(), s.b.  length\n+         * is incorrect, because it didn't take the internal attributes\n+         * into account yet! Very subtle bug, fixed in 3.1.1.\n@@ -119,0 +103,1 @@\n+\n@@ -120,1 +105,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -127,1 +112,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -129,9 +114,8 @@\n-    public Code(final int nameIndex, final int length, final int maxStack, final int maxLocals, final byte[] code, final CodeException[] exceptionTable,\n-        final Attribute[] attributes, final ConstantPool constantPool) {\n-        super(Const.ATTR_CODE, nameIndex, length, constantPool);\n-        this.maxStack = Args.requireU2(maxStack, \"maxStack\");\n-        this.maxLocals = Args.requireU2(maxLocals, \"maxLocals\");\n-        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n-        Args.requireU2(this.exceptionTable.length, \"exceptionTable.length\");\n-        this.attributes = attributes != null ? attributes : EMPTY_ARRAY;\n+    public Code(final int name_index, final int length, final int maxStack, final int maxLocals, final byte[] code,\n+            final CodeException[] exceptionTable, final Attribute[] attributes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_CODE, name_index, length, constant_pool);\n+        this.maxStack = maxStack;\n+        this.maxLocals = maxLocals;\n+        this.code = code != null ? code : new byte[0];\n+        this.exceptionTable = exceptionTable != null ? exceptionTable : new CodeException[0];\n+        this.attributes = attributes != null ? attributes : new Attribute[0];\n@@ -141,0 +125,1 @@\n+\n@@ -142,2 +127,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -148,1 +134,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -152,32 +138,0 @@\n-    \/**\n-     * @return the full size of this code attribute, minus its first 6 bytes, including the size of all its contained\n-     *         attributes\n-     *\/\n-    private int calculateLength() {\n-        int len = 0;\n-        if (attributes != null) {\n-            for (final Attribute attribute : attributes) {\n-                len += attribute.getLength() + 6 \/* attribute header size *\/;\n-            }\n-        }\n-        return len + getInternalLength();\n-    }\n-\n-    \/**\n-     * @return deep copy of this attribute\n-     *\n-     * @param constantPool the constant pool to duplicate\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Code c = (Code) clone();\n-        if (code != null) {\n-            c.code = code.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        c.exceptionTable = new CodeException[exceptionTable.length];\n-        Arrays.setAll(c.exceptionTable, i -> exceptionTable[i].copy());\n-        c.attributes = new Attribute[attributes.length];\n-        Arrays.setAll(c.attributes, i -> attributes[i].copy(constantPool));\n-        return c;\n-    }\n@@ -189,1 +143,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -192,1 +146,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -208,0 +162,1 @@\n+\n@@ -216,25 +171,0 @@\n-    \/**\n-     * @return Actual byte code of the method.\n-     *\/\n-    public byte[] getCode() {\n-        return code;\n-    }\n-\n-    \/**\n-     * @return Table of handled exceptions.\n-     * @see CodeException\n-     *\/\n-    public CodeException[] getExceptionTable() {\n-        return exceptionTable;\n-    }\n-\n-    \/**\n-     * @return the internal length of this code attribute (minus the first 6 bytes) and excluding all its attributes\n-     *\/\n-    private int getInternalLength() {\n-        return 2 \/* maxStack *\/ + 2 \/* maxLocals *\/ + 4 \/* code length *\/\n-            + code.length \/* byte-code *\/\n-            + 2 \/* exception-table length *\/\n-            + 8 * (exceptionTable == null ? 0 : exceptionTable.length) \/* exception table *\/\n-            + 2 \/* attributes count *\/;\n-    }\n@@ -254,0 +184,1 @@\n+\n@@ -266,0 +197,18 @@\n+\n+    \/**\n+     * @return Actual byte code of the method.\n+     *\/\n+    public byte[] getCode() {\n+        return code;\n+    }\n+\n+\n+    \/**\n+     * @return Table of handled exceptions.\n+     * @see CodeException\n+     *\/\n+    public CodeException[] getExceptionTable() {\n+        return exceptionTable;\n+    }\n+\n+\n@@ -273,0 +222,1 @@\n+\n@@ -280,0 +230,29 @@\n+\n+    \/**\n+     * @return the internal length of this code attribute (minus the first 6 bytes)\n+     * and excluding all its attributes\n+     *\/\n+    private int getInternalLength() {\n+        return 2 \/*maxStack*\/+ 2 \/*maxLocals*\/+ 4 \/*code length*\/\n+                + code.length \/*byte-code*\/\n+                + 2 \/*exception-table length*\/\n+                + 8 * (exceptionTable == null ? 0 : exceptionTable.length) \/* exception table *\/\n+                + 2 \/* attributes count *\/;\n+    }\n+\n+\n+    \/**\n+     * @return the full size of this code attribute, minus its first 6 bytes,\n+     * including the size of all its contained attributes\n+     *\/\n+    private int calculateLength() {\n+        int len = 0;\n+        if (attributes != null) {\n+            for (final Attribute attribute : attributes) {\n+                len += attribute.getLength() + 6 \/*attribute header size*\/;\n+            }\n+        }\n+        return len + getInternalLength();\n+    }\n+\n+\n@@ -283,2 +262,2 @@\n-    public void setAttributes(final Attribute[] attributes) {\n-        this.attributes = attributes != null ? attributes : EMPTY_ARRAY;\n+    public void setAttributes( final Attribute[] attributes ) {\n+        this.attributes = attributes != null ? attributes : new Attribute[0];\n@@ -288,0 +267,1 @@\n+\n@@ -291,2 +271,2 @@\n-    public void setCode(final byte[] code) {\n-        this.code = code != null ? code : Const.EMPTY_BYTE_ARRAY;\n+    public void setCode( final byte[] code ) {\n+        this.code = code != null ? code : new byte[0];\n@@ -296,0 +276,1 @@\n+\n@@ -299,2 +280,2 @@\n-    public void setExceptionTable(final CodeException[] exceptionTable) {\n-        this.exceptionTable = exceptionTable != null ? exceptionTable : CodeException.EMPTY_CODE_EXCEPTION_ARRAY;\n+    public void setExceptionTable( final CodeException[] exceptionTable ) {\n+        this.exceptionTable = exceptionTable != null ? exceptionTable : new CodeException[0];\n@@ -304,0 +285,1 @@\n+\n@@ -307,1 +289,1 @@\n-    public void setMaxLocals(final int maxLocals) {\n+    public void setMaxLocals( final int maxLocals ) {\n@@ -311,0 +293,1 @@\n+\n@@ -314,1 +297,1 @@\n-    public void setMaxStack(final int maxStack) {\n+    public void setMaxStack( final int maxStack ) {\n@@ -318,7 +301,0 @@\n-    \/**\n-     * @return String representation of code chunk.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return toString(true);\n-    }\n@@ -327,3 +303,0 @@\n-     * Converts this object to a String.\n-     *\n-     * @param verbose Provides verbose output when true.\n@@ -332,1 +305,1 @@\n-    public String toString(final boolean verbose) {\n+    public String toString( final boolean verbose ) {\n@@ -334,2 +307,3 @@\n-        buf.append(\"Code(maxStack = \").append(maxStack).append(\", maxLocals = \").append(maxLocals).append(\", code_length = \").append(code.length).append(\")\\n\")\n-            .append(Utility.codeToString(code, super.getConstantPool(), 0, -1, verbose));\n+        buf.append(\"Code(maxStack = \").append(maxStack).append(\", maxLocals = \").append(\n+                maxLocals).append(\", code_length = \").append(code.length).append(\")\\n\").append(\n+                Utility.codeToString(code, super.getConstantPool(), 0, -1, verbose));\n@@ -351,0 +325,34 @@\n+\n+\n+    \/**\n+     * @return String representation of code chunk.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return toString(true);\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\n+     * @param _constant_pool the constant pool to duplicate\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Code c = (Code) clone();\n+        if (code != null) {\n+            c.code = new byte[code.length];\n+            System.arraycopy(code, 0, c.code, 0, code.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        c.exceptionTable = new CodeException[exceptionTable.length];\n+        for (int i = 0; i < exceptionTable.length; i++) {\n+            c.exceptionTable[i] = exceptionTable[i].copy();\n+        }\n+        c.attributes = new Attribute[attributes.length];\n+        for (int i = 0; i < attributes.length; i++) {\n+            c.attributes[i] = attributes[i].copy(_constant_pool);\n+        }\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Code.java","additions":163,"deletions":155,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +30,3 @@\n- * This class represents an entry in the exception table of the <em>Code<\/em> attribute and is used only there. It\n- * contains a range in which a particular exception handler is active.\n+ * This class represents an entry in the exception table of the <em>Code<\/em>\n+ * attribute and is used only there. It contains a range in which a\n+ * particular exception handler is active.\n@@ -34,22 +34,2 @@\n- * <pre>\n- * Code_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 max_stack;\n- *   u2 max_locals;\n- *   u4 code_length;\n- *   u1 code[code_length];\n- *   u2 exception_table_length;\n- *   {\n- *     u2 start_pc;\n- *     u2 end_pc;\n- *     u2 handler_pc;\n- *     u2 catch_type;\n- *   } exception_table[exception_table_length];\n- *   u2 attributes_count;\n- *   attribute_info attributes[attributes_count];\n- * }\n- * <\/pre>\n- *\n- * @see Code\n- * @LastModified: Feb 2023\n+ * @see     Code\n+ * @LastModified: May 2021\n@@ -59,2 +39,4 @@\n-    \/**\n-     * Empty array.\n+    private int startPc; \/\/ Range in the code the exception handler is\n+    private int endPc; \/\/ active. startPc is inclusive, endPc exclusive\n+    private int handlerPc; \/* Starting address of exception handler, i.e.,\n+     * an offset from start of code.\n@@ -62,10 +44,3 @@\n-    static final CodeException[] EMPTY_CODE_EXCEPTION_ARRAY = {};\n-\n-    \/** Range in the code the exception handler. *\/\n-    private int startPc;\n-\n-    \/** active. startPc is inclusive, endPc exclusive. *\/\n-    private int endPc;\n-\n-    \/**\n-     * Starting address of exception handler, i.e., an offset from start of code.\n+    private int catchType; \/* If this is zero the handler catches any\n+     * exception, otherwise it points to the\n+     * exception class which is to be caught.\n@@ -73,1 +48,0 @@\n-    private int handlerPc;\n@@ -75,4 +49,0 @@\n-    \/*\n-     * If this is zero the handler catches any exception, otherwise it points to the exception class which is to be caught.\n-     *\/\n-    private int catchType;\n@@ -81,3 +51,1 @@\n-     * Constructs a new instance from another instance.\n-     *\n-     * @param c Source for copying.\n+     * Initialize from another object.\n@@ -89,0 +57,1 @@\n+\n@@ -90,2 +59,1 @@\n-     * Constructs a new instance from a DataInput.\n-     *\n+     * Construct object from file stream.\n@@ -93,1 +61,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -96,1 +64,2 @@\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort());\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n+                .readUnsignedShort());\n@@ -99,0 +68,1 @@\n+\n@@ -100,3 +70,2 @@\n-     * Constructs a new instance.\n-     *\n-     * @param startPc Range in the code the exception handler is active, startPc is inclusive while\n+     * @param startPc Range in the code the exception handler is active,\n+     * startPc is inclusive while\n@@ -104,3 +73,5 @@\n-     * @param handlerPc Starting address of exception handler, i.e., an offset from start of code.\n-     * @param catchType If zero the handler catches any exception, otherwise it points to the exception class which is to be\n-     *        caught.\n+     * @param handlerPc Starting address of exception handler, i.e.,\n+     * an offset from start of code.\n+     * @param catchType If zero the handler catches any\n+     * exception, otherwise it points to the exception class which is\n+     * to be caught.\n@@ -109,4 +80,4 @@\n-        this.startPc = Args.requireU2(startPc, \"startPc\");\n-        this.endPc = Args.requireU2(endPc, \"endPc\");\n-        this.handlerPc = Args.requireU2(handlerPc, \"handlerPc\");\n-        this.catchType = Args.requireU2(catchType, \"catchType\");\n+        this.startPc = startPc;\n+        this.endPc = endPc;\n+        this.handlerPc = handlerPc;\n+        this.catchType = catchType;\n@@ -115,0 +86,1 @@\n+\n@@ -116,2 +88,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -122,1 +95,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -126,11 +99,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public CodeException copy() {\n-        try {\n-            return (CodeException) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -139,1 +101,1 @@\n-     * Dumps code exception to file stream in binary format.\n+     * Dump code exception to file stream in binary format.\n@@ -142,1 +104,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -144,1 +106,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -151,0 +113,1 @@\n+\n@@ -152,1 +115,2 @@\n-     * @return 0, if the handler catches any exception, otherwise it points to the exception class which is to be caught.\n+     * @return 0, if the handler catches any exception, otherwise it points to\n+     * the exception class which is to be caught.\n@@ -158,0 +122,1 @@\n+\n@@ -165,0 +130,1 @@\n+\n@@ -172,0 +138,1 @@\n+\n@@ -179,0 +146,1 @@\n+\n@@ -182,1 +150,1 @@\n-    public void setCatchType(final int catchType) {\n+    public void setCatchType( final int catchType ) {\n@@ -186,0 +154,1 @@\n+\n@@ -189,1 +158,1 @@\n-    public void setEndPC(final int endPc) {\n+    public void setEndPC( final int endPc ) {\n@@ -193,0 +162,1 @@\n+\n@@ -196,1 +166,1 @@\n-    public void setHandlerPC(final int handlerPc) { \/\/ TODO unused\n+    public void setHandlerPC( final int handlerPc ) { \/\/ TODO unused\n@@ -200,0 +170,1 @@\n+\n@@ -203,1 +174,1 @@\n-    public void setStartPC(final int startPc) { \/\/ TODO unused\n+    public void setStartPC( final int startPc ) { \/\/ TODO unused\n@@ -207,0 +178,1 @@\n+\n@@ -212,1 +184,2 @@\n-        return \"CodeException(startPc = \" + startPc + \", endPc = \" + endPc + \", handlerPc = \" + handlerPc + \", catchType = \" + catchType + \")\";\n+        return \"CodeException(startPc = \" + startPc + \", endPc = \" + endPc + \", handlerPc = \"\n+                + handlerPc + \", catchType = \" + catchType + \")\";\n@@ -215,3 +188,0 @@\n-    public String toString(final ConstantPool cp) {\n-        return toString(cp, true);\n-    }\n@@ -220,2 +190,0 @@\n-     * @param cp constant pool source.\n-     * @param verbose Output more if true.\n@@ -224,1 +192,1 @@\n-    public String toString(final ConstantPool cp, final boolean verbose) {\n+    public String toString( final ConstantPool cp, final boolean verbose ) {\n@@ -229,1 +197,2 @@\n-            str = Utility.compactClassName(cp.getConstantString(catchType, Const.CONSTANT_Class), false) + (verbose ? \"(\" + catchType + \")\" : \"\");\n+            str = Utility.compactClassName(cp.getConstantString(catchType, Const.CONSTANT_Class), false)\n+                    + (verbose ? \"(\" + catchType + \")\" : \"\");\n@@ -233,0 +202,18 @@\n+\n+\n+    public String toString( final ConstantPool cp ) {\n+        return toString(cp, true);\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public CodeException copy() {\n+        try {\n+            return (CodeException) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/CodeException.java","additions":77,"deletions":90,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -48,0 +48,1 @@\n+\n@@ -49,1 +50,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -55,0 +56,14 @@\n+    \/* In fact this tag is redundant since we can distinguish different\n+     * `Constant' objects by their type, i.e., via `instanceof'. In some\n+     * places we will use the tag for switch()es anyway.\n+     *\n+     * First, we want match the specification as closely as possible. Second we\n+     * need the tag as an index to select the corresponding class name from the\n+     * `CONSTANT_NAMES' array.\n+     *\/\n+    private byte tag;\n+\n+    Constant(final byte tag) {\n+        this.tag = tag;\n+    }\n+\n@@ -56,1 +71,5 @@\n-     * @return Comparison strategy object\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n@@ -58,2 +77,40 @@\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n+    @Override\n+    public abstract void accept( Visitor v );\n+\n+    public abstract void dump( DataOutputStream file ) throws IOException;\n+\n+    \/**\n+     * @return Tag of constant, i.e., its type. No setTag() method to avoid\n+     * confusion.\n+     *\/\n+    public final byte getTag() {\n+        return tag;\n+    }\n+\n+    \/**\n+     * @return String representation.\n+     *\/\n+    @Override\n+    public String toString() {\n+        return Const.getConstantName(tag) + \"[\" + tag + \"]\";\n+    }\n+\n+    \/**\n+     * @return deep copy of this constant\n+     *\/\n+    public Constant copy() {\n+        try {\n+            return (Constant) super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n@@ -114,28 +171,1 @@\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n-\n-    \/*\n-     * In fact this tag is redundant since we can distinguish different 'Constant' objects by their type, i.e., via\n-     * 'instanceof'. In some places we will use the tag for switch()es anyway.\n-     *\n-     * First, we want match the specification as closely as possible. Second we need the tag as an index to select the\n-     * corresponding class name from the 'CONSTANT_NAMES' array.\n-     *\/\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected byte tag; \/\/ TODO should be private & final\n-\n-    Constant(final byte tag) {\n-        this.tag = tag;\n-    }\n-\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n+     * @return Comparison strategy object\n@@ -143,10 +173,2 @@\n-    @Override\n-    public abstract void accept(Visitor v);\n-\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -156,1 +178,1 @@\n-     * @return deep copy of this constant\n+     * @param comparator Comparison strategy object\n@@ -158,7 +180,2 @@\n-    public Constant copy() {\n-        try {\n-            return (Constant) super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n@@ -167,2 +184,0 @@\n-    public abstract void dump(DataOutputStream file) throws IOException;\n-\n@@ -170,1 +185,2 @@\n-     * Returns value as defined by given BCELComparator strategy. By default two Constant objects are said to be equal when\n+     * Returns value as defined by given BCELComparator strategy.\n+     * By default two Constant objects are said to be equal when\n@@ -173,1 +189,1 @@\n-     * @see Object#equals(Object)\n+     * @see java.lang.Object#equals(java.lang.Object)\n@@ -176,1 +192,1 @@\n-    public boolean equals(final Object obj) {\n+    public boolean equals( final Object obj ) {\n@@ -181,9 +197,2 @@\n-     * @return Tag of constant, i.e., its type. No setTag() method to avoid confusion.\n-     *\/\n-    public final byte getTag() {\n-        return tag;\n-    }\n-\n-    \/**\n-     * Returns value as defined by given BCELComparator strategy. By default return the hashcode of the result of\n-     * toString().\n+     * Returns value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the result of toString().\n@@ -191,1 +200,1 @@\n-     * @see Object#hashCode()\n+     * @see java.lang.Object#hashCode()\n@@ -197,8 +206,0 @@\n-\n-    \/**\n-     * @return String representation.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return Const.getConstantName(tag) + \"[\" + tag + \"]\";\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Constant.java","additions":75,"deletions":74,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -29,1 +29,2 @@\n- * Abstract super class for Fieldref, Methodref, InterfaceMethodref and InvokeDynamic constants.\n+ * Abstract super class for Fieldref, Methodref, InterfaceMethodref and\n+ *                          InvokeDynamic constants.\n@@ -44,5 +45,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int class_index; \/\/ TODO make private (has getter & setter)\n+    private int class_index;\n@@ -50,0 +47,1 @@\n+    private int name_and_type_index;\n@@ -52,1 +50,1 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     * Initialize from another object.\n@@ -54,2 +52,4 @@\n-    @java.lang.Deprecated\n-    protected int name_and_type_index; \/\/ TODO make private (has getter & setter)\n+    public ConstantCP(final ConstantCP c) {\n+        this(c.getTag(), c.getClassIndex(), c.getNameAndTypeIndex());\n+    }\n+\n@@ -60,1 +60,1 @@\n-     * @param tag Constant type tag\n+     * @param tag  Constant type tag\n@@ -62,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -68,0 +68,1 @@\n+\n@@ -69,2 +70,2 @@\n-     * @param classIndex Reference to the class containing the field\n-     * @param nameAndTypeIndex and the field signature\n+     * @param class_index Reference to the class containing the field\n+     * @param name_and_type_index and the field signature\n@@ -72,1 +73,1 @@\n-    protected ConstantCP(final byte tag, final int classIndex, final int nameAndTypeIndex) {\n+    protected ConstantCP(final byte tag, final int class_index, final int name_and_type_index) {\n@@ -74,2 +75,2 @@\n-        this.class_index = classIndex;\n-        this.name_and_type_index = nameAndTypeIndex;\n+        this.class_index = class_index;\n+        this.name_and_type_index = name_and_type_index;\n@@ -78,8 +79,0 @@\n-    \/**\n-     * Initialize from another object.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public ConstantCP(final ConstantCP c) {\n-        this(c.getTag(), c.getClassIndex(), c.getNameAndTypeIndex());\n-    }\n@@ -91,1 +84,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -94,1 +87,1 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n+    public final void dump( final DataOutputStream file ) throws IOException {\n@@ -100,6 +93,0 @@\n-    \/**\n-     * @return Class this field belongs to.\n-     *\/\n-    public String getClass(final ConstantPool cp) {\n-        return cp.constantToString(class_index, Const.CONSTANT_Class);\n-    }\n@@ -114,0 +101,9 @@\n+\n+    \/**\n+     * @param class_index points to Constant_class\n+     *\/\n+    public final void setClassIndex( final int class_index ) {\n+        this.class_index = class_index;\n+    }\n+\n+\n@@ -121,0 +117,1 @@\n+\n@@ -122,1 +119,1 @@\n-     * @param classIndex points to Constant_class\n+     * @param name_and_type_index points to Constant_NameAndType\n@@ -124,2 +121,2 @@\n-    public final void setClassIndex(final int classIndex) {\n-        this.class_index = classIndex;\n+    public final void setNameAndTypeIndex( final int name_and_type_index ) {\n+        this.name_and_type_index = name_and_type_index;\n@@ -128,0 +125,1 @@\n+\n@@ -129,1 +127,1 @@\n-     * @param nameAndTypeIndex points to Constant_NameAndType\n+     * @return Class this field belongs to.\n@@ -131,2 +129,2 @@\n-    public final void setNameAndTypeIndex(final int nameAndTypeIndex) {\n-        this.name_and_type_index = nameAndTypeIndex;\n+    public String getClass( final ConstantPool cp ) {\n+        return cp.constantToString(class_index, Const.CONSTANT_Class);\n@@ -135,0 +133,1 @@\n+\n@@ -138,1 +137,1 @@\n-     *         not final as ConstantInvokeDynamic needs to modify\n+     * not final as ConstantInvokeDynamic needs to modify\n@@ -142,1 +141,2 @@\n-        return super.toString() + \"(class_index = \" + class_index + \", name_and_type_index = \" + name_and_type_index + \")\";\n+        return super.toString() + \"(class_index = \" + class_index + \", name_and_type_index = \"\n+                + name_and_type_index + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantCP.java","additions":40,"deletions":40,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a (external) class.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a (external) class.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -39,0 +40,1 @@\n+\n@@ -41,2 +43,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +48,1 @@\n+\n@@ -58,0 +59,1 @@\n+\n@@ -59,1 +61,2 @@\n-     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n+     * @param nameIndex Name index in constant pool.  Should refer to a\n+     * ConstantUtf8.\n@@ -66,0 +69,1 @@\n+\n@@ -67,2 +71,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +82,1 @@\n+\n@@ -84,1 +90,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,14 +95,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(nameIndex).getBytes();\n-    }\n@@ -111,0 +103,1 @@\n+\n@@ -114,1 +107,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -118,0 +111,17 @@\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantClass.java","additions":34,"deletions":24,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a Double object.\n+ * This class is derived from the abstract  {@link Constant}\n+ * and represents a reference to a Double object.\n@@ -39,0 +40,10 @@\n+\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantDouble(final double bytes) {\n+        super(Const.CONSTANT_Double);\n+        this.bytes = bytes;\n+    }\n+\n+\n@@ -41,2 +52,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +57,1 @@\n+\n@@ -52,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,7 +68,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantDouble(final double bytes) {\n-        super(Const.CONSTANT_Double);\n-        this.bytes = bytes;\n-    }\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,0 +94,1 @@\n+\n@@ -96,7 +102,0 @@\n-    \/**\n-     * @return Double object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Double.valueOf(bytes);\n-    }\n@@ -107,1 +106,1 @@\n-    public void setBytes(final double bytes) {\n+    public void setBytes( final double bytes ) {\n@@ -111,0 +110,1 @@\n+\n@@ -118,0 +118,8 @@\n+\n+\n+    \/** @return Double object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return bytes;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantDouble.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a dynamically computed\n- * constant.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a dynamically computed constant.\n@@ -33,3 +33,3 @@\n- * @see Constant\n- * @see <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\"> Change request for JEP\n- *      309<\/a>\n+ * @see     Constant\n+ * @see  <a href=\"https:\/\/bugs.openjdk.java.net\/secure\/attachment\/74618\/constant-dynamic.html\">\n+ * Change request for JEP 309<\/a>\n@@ -42,2 +42,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -54,1 +52,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -61,2 +59,2 @@\n-    public ConstantDynamic(final int bootstrapMethodAttrIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_Dynamic, bootstrapMethodAttrIndex, nameAndTypeIndex);\n+    public ConstantDynamic(final int bootstrap_method_attr_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_Dynamic, bootstrap_method_attr_index, name_and_type_index);\n@@ -67,2 +65,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -80,1 +79,2 @@\n-     *         Note that this method is a functional duplicate of getClassIndex for use by ConstantInvokeDynamic.\n+     * Note that this method is a functional duplicate of getClassIndex\n+     * for use by ConstantInvokeDynamic.\n@@ -84,1 +84,1 @@\n-        return super.getClassIndex(); \/\/ AKA bootstrap_method_attr_index\n+        return super.getClassIndex();  \/\/ AKA bootstrap_method_attr_index\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantDynamic.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -36,2 +37,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -43,0 +42,1 @@\n+\n@@ -47,1 +47,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -53,0 +53,1 @@\n+\n@@ -54,2 +55,2 @@\n-     * @param classIndex Reference to the class containing the Field\n-     * @param nameAndTypeIndex and the Field signature\n+     * @param class_index Reference to the class containing the Field\n+     * @param name_and_type_index and the Field signature\n@@ -57,2 +58,2 @@\n-    public ConstantFieldref(final int classIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_Fieldref, classIndex, nameAndTypeIndex);\n+    public ConstantFieldref(final int class_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_Fieldref, class_index, name_and_type_index);\n@@ -61,0 +62,1 @@\n+\n@@ -62,2 +64,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of Fields, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of Fields,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -68,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantFieldref.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a float object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a float object.\n@@ -39,0 +40,1 @@\n+\n@@ -40,4 +42,11 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * @param bytes Data\n+     *\/\n+    public ConstantFloat(final float bytes) {\n+        super(Const.CONSTANT_Float);\n+        this.bytes = bytes;\n+    }\n+\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -49,0 +58,1 @@\n+\n@@ -53,1 +63,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -59,7 +69,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantFloat(final float bytes) {\n-        super(Const.CONSTANT_Float);\n-        this.bytes = bytes;\n-    }\n@@ -68,2 +71,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -74,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -78,0 +82,1 @@\n+\n@@ -82,1 +87,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -85,1 +90,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -90,0 +95,1 @@\n+\n@@ -97,7 +103,0 @@\n-    \/**\n-     * @return Float object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Float.valueOf(bytes);\n-    }\n@@ -108,1 +107,1 @@\n-    public void setBytes(final float bytes) {\n+    public void setBytes( final float bytes ) {\n@@ -112,0 +111,1 @@\n+\n@@ -119,0 +119,8 @@\n+\n+\n+    \/** @return Float object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return bytes;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantFloat.java","additions":34,"deletions":26,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to an int object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to an int object.\n@@ -39,0 +40,10 @@\n+\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantInteger(final int bytes) {\n+        super(Const.CONSTANT_Integer);\n+        this.bytes = bytes;\n+    }\n+\n+\n@@ -41,2 +52,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +57,1 @@\n+\n@@ -52,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,7 +68,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantInteger(final int bytes) {\n-        super(Const.CONSTANT_Integer);\n-        this.bytes = bytes;\n-    }\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,0 +94,1 @@\n+\n@@ -96,7 +102,0 @@\n-    \/**\n-     * @return Integer object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Integer.valueOf(bytes);\n-    }\n@@ -107,1 +106,1 @@\n-    public void setBytes(final int bytes) {\n+    public void setBytes( final int bytes ) {\n@@ -111,0 +110,1 @@\n+\n@@ -118,0 +118,8 @@\n+\n+\n+    \/** @return Integer object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return Integer.valueOf(bytes);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInteger.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -36,2 +37,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -43,0 +42,1 @@\n+\n@@ -47,1 +47,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -53,0 +53,1 @@\n+\n@@ -54,2 +55,2 @@\n-     * @param classIndex Reference to the class containing the method\n-     * @param nameAndTypeIndex and the method signature\n+     * @param class_index Reference to the class containing the method\n+     * @param name_and_type_index and the method signature\n@@ -57,2 +58,2 @@\n-    public ConstantInterfaceMethodref(final int classIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_InterfaceMethodref, classIndex, nameAndTypeIndex);\n+    public ConstantInterfaceMethodref(final int class_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_InterfaceMethodref, class_index, name_and_type_index);\n@@ -61,0 +62,1 @@\n+\n@@ -62,2 +64,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -68,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInterfaceMethodref.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a invoke dynamic.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a invoke dynamic.\n@@ -32,3 +33,3 @@\n- * @see Constant\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\"> The\n- *      CONSTANT_InvokeDynamic_info Structure in The Java Virtual Machine Specification<\/a>\n+ * @see     Constant\n+ * @see  <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.4.10\">\n+ * The CONSTANT_InvokeDynamic_info Structure in The Java Virtual Machine Specification<\/a>\n@@ -41,2 +42,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +47,1 @@\n+\n@@ -52,1 +52,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -55,1 +55,1 @@\n-        this(file.readUnsignedShort(), file.readUnsignedShort());\n+        this(file.readShort(), file.readShort());\n@@ -58,2 +58,3 @@\n-    public ConstantInvokeDynamic(final int bootstrapMethodAttrIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_InvokeDynamic, bootstrapMethodAttrIndex, nameAndTypeIndex);\n+\n+    public ConstantInvokeDynamic(final int bootstrap_method_attr_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_InvokeDynamic, bootstrap_method_attr_index, name_and_type_index);\n@@ -62,0 +63,1 @@\n+\n@@ -63,2 +65,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -69,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -76,1 +79,2 @@\n-     *         Note that this method is a functional duplicate of getClassIndex for use by ConstantInvokeDynamic.\n+     * Note that this method is a functional duplicate of getClassIndex\n+     * for use by ConstantInvokeDynamic.\n@@ -80,1 +84,1 @@\n-        return super.getClassIndex(); \/\/ AKA bootstrap_method_attr_index\n+        return super.getClassIndex();  \/\/ AKA bootstrap_method_attr_index\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantInvokeDynamic.java","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a long object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a long object.\n@@ -39,0 +40,10 @@\n+\n+    \/**\n+     * @param bytes Data\n+     *\/\n+    public ConstantLong(final long bytes) {\n+        super(Const.CONSTANT_Long);\n+        this.bytes = bytes;\n+    }\n+\n+\n@@ -41,2 +52,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +57,1 @@\n+\n@@ -52,1 +62,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,7 +68,0 @@\n-    \/**\n-     * @param bytes Data\n-     *\/\n-    public ConstantLong(final long bytes) {\n-        super(Const.CONSTANT_Long);\n-        this.bytes = bytes;\n-    }\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,0 +94,1 @@\n+\n@@ -96,7 +102,0 @@\n-    \/**\n-     * @return Long object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return Long.valueOf(bytes);\n-    }\n@@ -107,1 +106,1 @@\n-    public void setBytes(final long bytes) {\n+    public void setBytes( final long bytes ) {\n@@ -111,0 +110,1 @@\n+\n@@ -118,0 +118,8 @@\n+\n+\n+    \/** @return Long object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        return bytes;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantLong.java","additions":32,"deletions":24,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a method handle.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a method handle.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -41,0 +42,1 @@\n+\n@@ -43,2 +45,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -50,0 +50,1 @@\n+\n@@ -54,1 +55,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -60,1 +61,2 @@\n-    public ConstantMethodHandle(final int referenceKind, final int referenceIndex) {\n+\n+    public ConstantMethodHandle(final int reference_kind, final int reference_index) {\n@@ -62,2 +64,2 @@\n-        this.referenceKind = referenceKind;\n-        this.referenceIndex = referenceIndex;\n+        this.referenceKind = reference_kind;\n+        this.referenceIndex = reference_index;\n@@ -66,0 +68,1 @@\n+\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -90,3 +95,0 @@\n-    public int getReferenceIndex() {\n-        return referenceIndex;\n-    }\n@@ -98,2 +100,8 @@\n-    public void setReferenceIndex(final int referenceIndex) {\n-        this.referenceIndex = referenceIndex;\n+\n+    public void setReferenceKind(final int reference_kind) {\n+        this.referenceKind = reference_kind;\n+    }\n+\n+\n+    public int getReferenceIndex() {\n+        return referenceIndex;\n@@ -102,2 +110,3 @@\n-    public void setReferenceKind(final int referenceKind) {\n-        this.referenceKind = referenceKind;\n+\n+    public void setReferenceIndex(final int reference_index) {\n+        this.referenceIndex = reference_index;\n@@ -106,0 +115,1 @@\n+\n@@ -111,1 +121,2 @@\n-        return super.toString() + \"(referenceKind = \" + referenceKind + \", referenceIndex = \" + referenceIndex + \")\";\n+        return super.toString() + \"(referenceKind = \" + referenceKind +\n+                \", referenceIndex = \" + referenceIndex + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodHandle.java","additions":32,"deletions":21,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a method type.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a method type.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -40,0 +41,1 @@\n+\n@@ -42,2 +44,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -49,0 +49,1 @@\n+\n@@ -53,1 +54,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -59,1 +60,2 @@\n-    public ConstantMethodType(final int descriptorIndex) {\n+\n+    public ConstantMethodType(final int descriptor_index) {\n@@ -61,1 +63,1 @@\n-        this.descriptorIndex = descriptorIndex;\n+        this.descriptorIndex = descriptor_index;\n@@ -64,0 +66,1 @@\n+\n@@ -65,2 +68,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -71,1 +75,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -75,0 +79,1 @@\n+\n@@ -79,1 +84,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -82,1 +87,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -87,0 +92,1 @@\n+\n@@ -91,2 +97,3 @@\n-    public void setDescriptorIndex(final int descriptorIndex) {\n-        this.descriptorIndex = descriptorIndex;\n+\n+    public void setDescriptorIndex(final int descriptor_index) {\n+        this.descriptorIndex = descriptor_index;\n@@ -95,0 +102,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodType.java","additions":22,"deletions":14,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -36,2 +37,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -43,0 +42,1 @@\n+\n@@ -47,1 +47,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -53,0 +53,1 @@\n+\n@@ -54,2 +55,2 @@\n-     * @param classIndex Reference to the class containing the method\n-     * @param nameAndTypeIndex and the method signature\n+     * @param class_index Reference to the class containing the method\n+     * @param name_and_type_index and the method signature\n@@ -57,2 +58,2 @@\n-    public ConstantMethodref(final int classIndex, final int nameAndTypeIndex) {\n-        super(Const.CONSTANT_Methodref, classIndex, nameAndTypeIndex);\n+    public ConstantMethodref(final int class_index, final int name_and_type_index) {\n+        super(Const.CONSTANT_Methodref, class_index, name_and_type_index);\n@@ -61,0 +62,1 @@\n+\n@@ -62,2 +64,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -68,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantMethodref.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a module.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a module.\n@@ -33,3 +34,1 @@\n- * <p>\n- * Note: Early access Java 9 support- currently subject to change\n- * <\/p>\n+ * <p>Note: Early access Java 9 support- currently subject to change<\/p>\n@@ -37,1 +36,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -44,0 +43,1 @@\n+\n@@ -46,2 +46,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -53,0 +51,1 @@\n+\n@@ -57,1 +56,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -63,0 +62,1 @@\n+\n@@ -64,1 +64,2 @@\n-     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n+     * @param nameIndex Name index in constant pool.  Should refer to a\n+     * ConstantUtf8.\n@@ -71,0 +72,1 @@\n+\n@@ -72,2 +74,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -78,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -82,0 +85,1 @@\n+\n@@ -86,1 +90,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -89,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -94,14 +98,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(nameIndex).getBytes();\n-    }\n@@ -116,0 +106,1 @@\n+\n@@ -119,1 +110,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -123,0 +114,17 @@\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantModule.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to the name and signature of a\n- * field or method.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to the name and signature\n+ * of a field or method.\n@@ -34,1 +35,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -41,0 +42,1 @@\n+\n@@ -43,2 +45,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -50,0 +50,1 @@\n+\n@@ -54,1 +55,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -60,0 +61,1 @@\n+\n@@ -70,0 +72,1 @@\n+\n@@ -71,2 +74,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -81,0 +85,1 @@\n+\n@@ -85,1 +90,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -88,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -94,6 +99,0 @@\n-    \/**\n-     * @return name\n-     *\/\n-    public String getName(final ConstantPool cp) {\n-        return cp.constantToString(getNameIndex(), Const.CONSTANT_Utf8);\n-    }\n@@ -108,2 +107,2 @@\n-    \/**\n-     * @return signature\n+\n+    \/** @return name\n@@ -111,2 +110,2 @@\n-    public String getSignature(final ConstantPool cp) {\n-        return cp.constantToString(getSignatureIndex(), Const.CONSTANT_Utf8);\n+    public String getName( final ConstantPool cp ) {\n+        return cp.constantToString(getNameIndex(), Const.CONSTANT_Utf8);\n@@ -115,0 +114,1 @@\n+\n@@ -122,0 +122,8 @@\n+\n+    \/** @return signature\n+     *\/\n+    public String getSignature( final ConstantPool cp ) {\n+        return cp.constantToString(getSignatureIndex(), Const.CONSTANT_Utf8);\n+    }\n+\n+\n@@ -125,1 +133,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -129,0 +137,1 @@\n+\n@@ -132,1 +141,1 @@\n-    public void setSignatureIndex(final int signatureIndex) {\n+    public void setSignatureIndex( final int signatureIndex ) {\n@@ -136,0 +145,1 @@\n+\n@@ -141,1 +151,2 @@\n-        return super.toString() + \"(nameIndex = \" + nameIndex + \", signatureIndex = \" + signatureIndex + \")\";\n+        return super.toString() + \"(nameIndex = \" + nameIndex + \", signatureIndex = \"\n+                + signatureIndex + \")\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantNameAndType.java","additions":35,"deletions":24,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * This interface denotes those constants that have a \"natural\" value, such as ConstantLong, ConstantString, etc..\n+ * This interface denotes those constants that have a \"natural\" value,\n+ * such as ConstantLong, ConstantString, etc..\n@@ -27,1 +28,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -31,2 +32,1 @@\n-    \/**\n-     * @return object representing the constant, e.g., Long for ConstantLong\n+    \/** @return object representing the constant, e.g., Long for ConstantLong\n@@ -34,1 +34,1 @@\n-    Object getConstantValue(ConstantPool cp);\n+    Object getConstantValue( ConstantPool cp );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantObject.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a package.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a package.\n@@ -33,3 +34,1 @@\n- * <p>\n- * Note: Early access Java 9 support- currently subject to change\n- * <\/p>\n+ * <p>Note: Early access Java 9 support- currently subject to change<\/p>\n@@ -37,1 +36,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -44,0 +43,1 @@\n+\n@@ -46,2 +46,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -53,0 +51,1 @@\n+\n@@ -57,1 +56,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -63,0 +62,1 @@\n+\n@@ -64,1 +64,2 @@\n-     * @param nameIndex Name index in constant pool. Should refer to a ConstantUtf8.\n+     * @param nameIndex Name index in constant pool.  Should refer to a\n+     * ConstantUtf8.\n@@ -71,0 +72,1 @@\n+\n@@ -72,2 +74,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -78,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -82,0 +85,1 @@\n+\n@@ -86,1 +90,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -89,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -94,14 +98,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(nameIndex).getBytes();\n-    }\n@@ -116,0 +106,1 @@\n+\n@@ -119,1 +110,1 @@\n-    public void setNameIndex(final int nameIndex) {\n+    public void setNameIndex( final int nameIndex ) {\n@@ -123,0 +114,17 @@\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantPackage.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n@@ -30,0 +28,1 @@\n+import com.sun.org.apache.bcel.internal.generic.ConstantPoolGen;\n@@ -32,9 +31,6 @@\n- * This class represents the constant pool, i.e., a table of constants, of a parsed classfile. It may contain null references, due to the JVM specification that\n- * skips an entry after an 8-byte constant (double, long) entry. Those interested in generating constant pools programmatically should see\n- * <a href=\"..\/generic\/ConstantPoolGen.html\"> ConstantPoolGen<\/a>.\n- *\n- * @see Constant\n- * @see com.sun.org.apache.bcel.internal.generic.ConstantPoolGen\n- * @LastModified: Feb 2023\n- *\/\n-public class ConstantPool implements Cloneable, Node, Iterable<Constant> {\n+ * This class represents the constant pool, i.e., a table of constants, of\n+ * a parsed classfile. It may contain null references, due to the JVM\n+ * specification that skips an entry after an 8-byte constant (double,\n+ * long) entry.  Those interested in generating constant pools\n+ * programatically should see <a href=\"..\/generic\/ConstantPoolGen.html\">\n+ * ConstantPoolGen<\/a>.\n@@ -42,27 +38,5 @@\n-    private static String escape(final String str) {\n-        final int len = str.length();\n-        final StringBuilder buf = new StringBuilder(len + 5);\n-        final char[] ch = str.toCharArray();\n-        for (int i = 0; i < len; i++) {\n-            switch (ch[i]) {\n-            case '\\n':\n-                buf.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                buf.append(\"\\\\r\");\n-                break;\n-            case '\\t':\n-                buf.append(\"\\\\t\");\n-                break;\n-            case '\\b':\n-                buf.append(\"\\\\b\");\n-                break;\n-            case '\"':\n-                buf.append(\"\\\\\\\"\");\n-                break;\n-            default:\n-                buf.append(ch[i]);\n-            }\n-        }\n-        return buf.toString();\n-    }\n+ * @see     Constant\n+ * @see     com.sun.org.apache.bcel.internal.generic.ConstantPoolGen\n+ * @LastModified: June 2022\n+ *\/\n+public class ConstantPool implements Cloneable, Node {\n@@ -83,1 +57,2 @@\n-     * @throws IOException if problem in readUnsignedShort or readConstant\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -85,1 +60,1 @@\n-    public ConstantPool(final DataInput input) throws IOException {\n+    public ConstantPool(final DataInput input) throws IOException, ClassFormatException {\n@@ -87,4 +62,4 @@\n-        final int constantPoolCount = input.readUnsignedShort();\n-        constantPool = new Constant[constantPoolCount];\n-        \/*\n-         * constantPool[0] is unused by the compiler and may be used freely by the implementation.\n+        final int constant_pool_count = input.readUnsignedShort();\n+        constantPool = new Constant[constant_pool_count];\n+        \/* constantPool[0] is unused by the compiler and may be used freely\n+         * by the implementation.\n@@ -92,1 +67,1 @@\n-        for (int i = 1; i < constantPoolCount; i++) {\n+        for (int i = 1; i < constant_pool_count; i++) {\n@@ -94,3 +69,4 @@\n-            \/*\n-             * Quote from the JVM specification: \"All eight byte constants take up two spots in the constant pool. If this is the n'th byte in the constant\n-             * pool, then the next item will be numbered n+2\"\n+            \/* Quote from the JVM specification:\n+             * \"All eight byte constants take up two spots in the constant pool.\n+             * If this is the n'th byte in the constant pool, then the next item\n+             * will be numbered n+2\"\n@@ -101,1 +77,1 @@\n-            if (tag == Const.CONSTANT_Double || tag == Const.CONSTANT_Long) {\n+            if ((tag == Const.CONSTANT_Double) || (tag == Const.CONSTANT_Long)) {\n@@ -108,2 +84,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e., the hierarchy of methods, fields,\n-     * attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -114,1 +91,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -121,1 +98,1 @@\n-     * @param c Constant to be printed\n+     * @param  c Constant to be printed\n@@ -123,1 +100,0 @@\n-     * @throws IllegalArgumentException if c is unknown constant type\n@@ -125,1 +101,1 @@\n-    public String constantToString(Constant c) throws IllegalArgumentException {\n+    public String constantToString( Constant c ) throws ClassFormatException {\n@@ -130,66 +106,68 @@\n-        case Const.CONSTANT_Class:\n-            i = ((ConstantClass) c).getNameIndex();\n-            c = getConstantUtf8(i);\n-            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-            break;\n-        case Const.CONSTANT_String:\n-            i = ((ConstantString) c).getStringIndex();\n-            c = getConstantUtf8(i);\n-            str = \"\\\"\" + escape(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n-            break;\n-        case Const.CONSTANT_Utf8:\n-            str = ((ConstantUtf8) c).getBytes();\n-            break;\n-        case Const.CONSTANT_Double:\n-            str = String.valueOf(((ConstantDouble) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Float:\n-            str = String.valueOf(((ConstantFloat) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Long:\n-            str = String.valueOf(((ConstantLong) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Integer:\n-            str = String.valueOf(((ConstantInteger) c).getBytes());\n-            break;\n-        case Const.CONSTANT_NameAndType:\n-            str = constantToString(((ConstantNameAndType) c).getNameIndex(), Const.CONSTANT_Utf8) + \" \"\n-                    + constantToString(((ConstantNameAndType) c).getSignatureIndex(), Const.CONSTANT_Utf8);\n-            break;\n-        case Const.CONSTANT_InterfaceMethodref:\n-        case Const.CONSTANT_Methodref:\n-        case Const.CONSTANT_Fieldref:\n-            str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class) + \".\"\n-                    + constantToString(((ConstantCP) c).getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n-            break;\n-        case Const.CONSTANT_MethodHandle:\n-            \/\/ Note that the ReferenceIndex may point to a Fieldref, Methodref or\n-            \/\/ InterfaceMethodref - so we need to peek ahead to get the actual type.\n-            final ConstantMethodHandle cmh = (ConstantMethodHandle) c;\n-            str = Const.getMethodHandleName(cmh.getReferenceKind()) + \" \"\n-                    + constantToString(cmh.getReferenceIndex(), getConstant(cmh.getReferenceIndex()).getTag());\n-            break;\n-        case Const.CONSTANT_MethodType:\n-            final ConstantMethodType cmt = (ConstantMethodType) c;\n-            str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);\n-            break;\n-        case Const.CONSTANT_InvokeDynamic:\n-            final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;\n-            str = cid.getBootstrapMethodAttrIndex() + \":\" + constantToString(cid.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n-            break;\n-        case Const.CONSTANT_Dynamic:\n-            final ConstantDynamic cd = (ConstantDynamic) c;\n-            str = cd.getBootstrapMethodAttrIndex() + \":\" + constantToString(cd.getNameAndTypeIndex(), Const.CONSTANT_NameAndType);\n-            break;\n-        case Const.CONSTANT_Module:\n-            i = ((ConstantModule) c).getNameIndex();\n-            c = getConstantUtf8(i);\n-            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-            break;\n-        case Const.CONSTANT_Package:\n-            i = ((ConstantPackage) c).getNameIndex();\n-            c = getConstantUtf8(i);\n-            str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n-            break;\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown constant type \" + tag);\n+            case Const.CONSTANT_Class:\n+                i = ((ConstantClass) c).getNameIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+                break;\n+            case Const.CONSTANT_String:\n+                i = ((ConstantString) c).getStringIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = \"\\\"\" + escape(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n+                break;\n+            case Const.CONSTANT_Utf8:\n+                str = ((ConstantUtf8) c).getBytes();\n+                break;\n+            case Const.CONSTANT_Double:\n+                str = String.valueOf(((ConstantDouble) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Float:\n+                str = String.valueOf(((ConstantFloat) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Long:\n+                str = String.valueOf(((ConstantLong) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Integer:\n+                str = String.valueOf(((ConstantInteger) c).getBytes());\n+                break;\n+            case Const.CONSTANT_NameAndType:\n+                str = constantToString(((ConstantNameAndType) c).getNameIndex(),\n+                        Const.CONSTANT_Utf8)\n+                        + \" \" + constantToString(((ConstantNameAndType) c).getSignatureIndex(),\n+                        Const.CONSTANT_Utf8);\n+                break;\n+            case Const.CONSTANT_InterfaceMethodref:\n+            case Const.CONSTANT_Methodref:\n+            case Const.CONSTANT_Fieldref:\n+                str = constantToString(((ConstantCP) c).getClassIndex(), Const.CONSTANT_Class)\n+                        + \".\" + constantToString(((ConstantCP) c).getNameAndTypeIndex(),\n+                        Const.CONSTANT_NameAndType);\n+                break;\n+            case Const.CONSTANT_MethodHandle:\n+                \/\/ Note that the ReferenceIndex may point to a Fieldref, Methodref or\n+                \/\/ InterfaceMethodref - so we need to peek ahead to get the actual type.\n+                final ConstantMethodHandle cmh = (ConstantMethodHandle) c;\n+                str = Const.getMethodHandleName(cmh.getReferenceKind())\n+                        + \" \" + constantToString(cmh.getReferenceIndex(),\n+                        getConstant(cmh.getReferenceIndex()).getTag());\n+                break;\n+            case Const.CONSTANT_MethodType:\n+                final ConstantMethodType cmt = (ConstantMethodType) c;\n+                str = constantToString(cmt.getDescriptorIndex(), Const.CONSTANT_Utf8);\n+                break;\n+            case Const.CONSTANT_InvokeDynamic:\n+                final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) c;\n+                str = cid.getBootstrapMethodAttrIndex()\n+                        + \":\" + constantToString(cid.getNameAndTypeIndex(),\n+                        Const.CONSTANT_NameAndType);\n+                break;\n+            case Const.CONSTANT_Module:\n+                i = ((ConstantModule) c).getNameIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+                break;\n+            case Const.CONSTANT_Package:\n+                i = ((ConstantPackage) c).getNameIndex();\n+                c = getConstant(i, Const.CONSTANT_Utf8);\n+                str = Utility.compactClassName(((ConstantUtf8) c).getBytes(), false);\n+                break;\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown constant type \" + tag);\n@@ -200,9 +178,26 @@\n-    \/**\n-     * Retrieves constant at 'index' from constant pool and resolve it to a string representation.\n-     *\n-     * @param index of constant in constant pool\n-     * @param tag   expected type\n-     * @return String representation\n-     *\/\n-    public String constantToString(final int index, final byte tag) {\n-        return constantToString(getConstant(index, tag));\n+    private static String escape( final String str ) {\n+        final int len = str.length();\n+        final StringBuilder buf = new StringBuilder(len + 5);\n+        final char[] ch = str.toCharArray();\n+        for (int i = 0; i < len; i++) {\n+            switch (ch[i]) {\n+                case '\\n':\n+                    buf.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    buf.append(\"\\\\r\");\n+                    break;\n+                case '\\t':\n+                    buf.append(\"\\\\t\");\n+                    break;\n+                case '\\b':\n+                    buf.append(\"\\\\b\");\n+                    break;\n+                case '\"':\n+                    buf.append(\"\\\\\\\"\");\n+                    break;\n+                default:\n+                    buf.append(ch[i]);\n+            }\n+        }\n+        return buf.toString();\n@@ -212,1 +207,6 @@\n-     * @return deep copy of this constant pool\n+     * Retrieves constant at `index' from constant pool and resolve it to\n+     * a string representation.\n+     *\n+     * @param  index of constant in constant pool\n+     * @param  tag expected type\n+     * @return String representation\n@@ -214,14 +214,3 @@\n-    public ConstantPool copy() {\n-        ConstantPool c = null;\n-        try {\n-            c = (ConstantPool) clone();\n-            c.constantPool = new Constant[constantPool.length];\n-            for (int i = 1; i < constantPool.length; i++) {\n-                if (constantPool[i] != null) {\n-                    c.constantPool[i] = constantPool[i].copy();\n-                }\n-            }\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return c;\n+    public String constantToString( final int index, final byte tag ) throws ClassFormatException {\n+        final Constant c = getConstant(index, tag);\n+        return constantToString(c);\n@@ -234,1 +223,1 @@\n-     * @throws IOException if problem in writeShort or dump\n+     * @throws IOException\n@@ -236,1 +225,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -241,2 +230,3 @@\n-         *\/\n-        final int size = Math.min(constantPool.length, Const.MAX_CP_ENTRIES);\n+        *\/\n+        int size = constantPool.length < ConstantPoolGen.CONSTANT_POOL_SIZE ?\n+                constantPool.length : ConstantPoolGen.CONSTANT_POOL_SIZE;\n@@ -255,15 +245,1 @@\n-     * @param index Index in constant pool\n-     * @return Constant value\n-     * @see Constant\n-     * @throws ClassFormatException if index is invalid\n-     *\/\n-    @SuppressWarnings(\"unchecked\")\n-    public <T extends Constant> T getConstant(final int index) throws ClassFormatException {\n-        return (T) getConstant(index, Constant.class);\n-    }\n-\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @param tag   Tag of expected constant, i.e., its type\n+     * @param  index Index in constant pool\n@@ -271,2 +247,1 @@\n-     * @see Constant\n-     * @throws ClassFormatException if constant type does not match tag\n+     * @see    Constant\n@@ -274,19 +249,4 @@\n-    @SuppressWarnings(\"unchecked\")\n-    public <T extends Constant> T getConstant(final int index, final byte tag) throws ClassFormatException {\n-        return (T) getConstant(index, tag, Constant.class);\n-    }\n-\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @param tag   Tag of expected constant, i.e., its type\n-     * @return Constant value\n-     * @see Constant\n-     * @throws ClassFormatException if constant type does not match tag\n-     * @since 6.6.0\n-     *\/\n-    public <T extends Constant> T getConstant(final int index, final byte tag, final Class<T> castTo) throws ClassFormatException {\n-        final T c = getConstant(index);\n-        if (c.getTag() != tag) {\n-            throw new ClassFormatException(\"Expected class '\" + Const.getConstantName(tag) + \"' at index \" + index + \" and got \" + c);\n+    public Constant getConstant( final int index ) {\n+        if (index >= constantPool.length || index < 0) {\n+            throw new ClassFormatException(\"Invalid constant pool reference: \" + index\n+                    + \". Constant pool size is: \" + constantPool.length);\n@@ -294,1 +254,1 @@\n-        return c;\n+        return constantPool[index];\n@@ -298,1 +258,2 @@\n-     * Gets constant from constant pool.\n+     * Gets constant from constant pool and check whether it has the\n+     * expected type.\n@@ -300,3 +261,2 @@\n-     * @param <T> A {@link Constant} subclass\n-     * @param index Index in constant pool\n-     * @param castTo The {@link Constant} subclass to cast to.\n+     * @param  index Index in constant pool\n+     * @param  tag Tag of expected constant, i.e., its type\n@@ -304,3 +264,2 @@\n-     * @see Constant\n-     * @throws ClassFormatException if index is invalid\n-     * @since 6.6.0\n+     * @see    Constant\n+     * @throws  ClassFormatException\n@@ -308,7 +267,5 @@\n-    public <T extends Constant> T getConstant(final int index, final Class<T> castTo) throws ClassFormatException {\n-        if (index >= constantPool.length || index < 0) {\n-            throw new ClassFormatException(\"Invalid constant pool reference using index: \" + index + \". Constant pool size is: \" + constantPool.length);\n-        }\n-        if (constantPool[index] != null && !castTo.isAssignableFrom(constantPool[index].getClass())) {\n-            throw new ClassFormatException(\"Invalid constant pool reference at index: \" + index +\n-                    \". Expected \" + castTo + \" but was \" + constantPool[index].getClass());\n+    public Constant getConstant( final int index, final byte tag ) throws ClassFormatException {\n+        Constant c;\n+        c = getConstant(index);\n+        if (c == null) {\n+            throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n@@ -316,9 +273,3 @@\n-        \/\/ Previous check ensures this won't throw a ClassCastException\n-        final T c = castTo.cast(constantPool[index]);\n-        if (c == null\n-            \/\/ the 0th element is always null\n-            && index != 0) {\n-            final Constant prev = constantPool[index - 1];\n-            if (prev == null || prev.getTag() != Const.CONSTANT_Double && prev.getTag() != Const.CONSTANT_Long) {\n-                throw new ClassFormatException(\"Constant pool at index \" + index + \" is null.\");\n-            }\n+        if (c.getTag() != tag) {\n+            throw new ClassFormatException(\"Expected class `\" + Const.getConstantName(tag)\n+                    + \"' at index \" + index + \" and got \" + c);\n@@ -329,12 +280,0 @@\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @return ConstantInteger value\n-     * @see ConstantInteger\n-     * @throws ClassFormatException if constant type does not match tag\n-     *\/\n-    public ConstantInteger getConstantInteger(final int index) {\n-        return getConstant(index, Const.CONSTANT_Integer, ConstantInteger.class);\n-    }\n-\n@@ -343,1 +282,1 @@\n-     * @see Constant\n+     * @see    Constant\n@@ -350,2 +289,4 @@\n-     * Gets string from constant pool and bypass the indirection of 'ConstantClass' and 'ConstantString' objects. I.e. these classes have an index field that\n-     * points to another entry of the constant pool of type 'ConstantUtf8' which contains the real data.\n+     * Gets string from constant pool and bypass the indirection of\n+     * `ConstantClass' and `ConstantString' objects. I.e. these classes have\n+     * an index field that points to another entry of the constant pool of\n+     * type `ConstantUtf8' which contains the real data.\n@@ -353,2 +294,2 @@\n-     * @param index Index in constant pool\n-     * @param tag   Tag of expected constant, either ConstantClass or ConstantString\n+     * @param  index Index in constant pool\n+     * @param  tag Tag of expected constant, either ConstantClass or ConstantString\n@@ -356,3 +297,3 @@\n-     * @see ConstantClass\n-     * @see ConstantString\n-     * @throws IllegalArgumentException if tag is invalid\n+     * @see    ConstantClass\n+     * @see    ConstantString\n+     * @throws  ClassFormatException\n@@ -360,1 +301,2 @@\n-    public String getConstantString(final int index, final byte tag) throws IllegalArgumentException {\n+    public String getConstantString( final int index, final byte tag ) throws ClassFormatException {\n+        Constant c;\n@@ -362,4 +304,7 @@\n-        \/*\n-         * This switch() is not that elegant, since the four classes have the same contents, they just differ in the name of the index field variable. But we\n-         * want to stick to the JVM naming conventions closely though we could have solved these more elegantly by using the same variable name or by\n-         * subclassing.\n+        c = getConstant(index, tag);\n+        \/* This switch() is not that elegant, since the four classes have the\n+         * same contents, they just differ in the name of the index\n+         * field variable.\n+         * But we want to stick to the JVM naming conventions closely though\n+         * we could have solved these more elegantly by using the same\n+         * variable name or by subclassing.\n@@ -368,16 +313,14 @@\n-        case Const.CONSTANT_Class:\n-            i = getConstant(index, ConstantClass.class).getNameIndex();\n-            break;\n-        case Const.CONSTANT_String:\n-            i = getConstant(index, ConstantString.class).getStringIndex();\n-            break;\n-        case Const.CONSTANT_Module:\n-            i = getConstant(index, ConstantModule.class).getNameIndex();\n-            break;\n-        case Const.CONSTANT_Package:\n-            i = getConstant(index, ConstantPackage.class).getNameIndex();\n-            break;\n-        case Const.CONSTANT_Utf8:\n-            return getConstantUtf8(index).getBytes();\n-        default:\n-            throw new IllegalArgumentException(\"getConstantString called with illegal tag \" + tag);\n+            case Const.CONSTANT_Class:\n+                i = ((ConstantClass) c).getNameIndex();\n+                break;\n+            case Const.CONSTANT_String:\n+                i = ((ConstantString) c).getStringIndex();\n+                break;\n+            case Const.CONSTANT_Module:\n+                i = ((ConstantModule) c).getNameIndex();\n+                break;\n+            case Const.CONSTANT_Package:\n+                i = ((ConstantPackage) c).getNameIndex();\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"getConstantString called with illegal tag \" + tag);\n@@ -386,1 +329,2 @@\n-        return getConstantUtf8(i).getBytes();\n+        c = getConstant(i, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n@@ -389,11 +333,0 @@\n-    \/**\n-     * Gets constant from constant pool and check whether it has the expected type.\n-     *\n-     * @param index Index in constant pool\n-     * @return ConstantUtf8 value\n-     * @see ConstantUtf8\n-     * @throws ClassFormatException if constant type does not match tag\n-     *\/\n-    public ConstantUtf8 getConstantUtf8(final int index) throws ClassFormatException {\n-        return getConstant(index, Const.CONSTANT_Utf8, ConstantUtf8.class);\n-    }\n@@ -408,4 +341,0 @@\n-    @Override\n-    public Iterator<Constant> iterator() {\n-        return Arrays.stream(constantPool).iterator();\n-    }\n@@ -416,1 +345,1 @@\n-    public void setConstant(final int index, final Constant constant) {\n+    public void setConstant( final int index, final Constant constant ) {\n@@ -420,0 +349,1 @@\n+\n@@ -423,1 +353,1 @@\n-    public void setConstantPool(final Constant[] constantPool) {\n+    public void setConstantPool( final Constant[] constantPool ) {\n@@ -427,0 +357,1 @@\n+\n@@ -438,0 +369,20 @@\n+\n+\n+    \/**\n+     * @return deep copy of this constant pool\n+     *\/\n+    public ConstantPool copy() {\n+        ConstantPool c = null;\n+        try {\n+            c = (ConstantPool) clone();\n+            c.constantPool = new Constant[constantPool.length];\n+            for (int i = 1; i < constantPool.length; i++) {\n+                if (constantPool[i] != null) {\n+                    c.constantPool[i] = constantPool[i].copy();\n+                }\n+            }\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantPool.java","additions":220,"deletions":269,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from the abstract {@link Constant} and represents a reference to a String object.\n+ * This class is derived from the abstract {@link Constant}\n+ * and represents a reference to a String object.\n@@ -33,1 +34,1 @@\n- * @see Constant\n+ * @see     Constant\n@@ -39,0 +40,1 @@\n+\n@@ -41,2 +43,0 @@\n-     *\n-     * @param c Source to copy.\n@@ -48,0 +48,1 @@\n+\n@@ -52,1 +53,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -58,0 +59,1 @@\n+\n@@ -66,0 +68,1 @@\n+\n@@ -67,2 +70,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -73,1 +77,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -77,0 +81,1 @@\n+\n@@ -81,1 +86,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -84,1 +89,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -89,14 +94,0 @@\n-    \/**\n-     * @return dereferenced string\n-     *\/\n-    public String getBytes(final ConstantPool cp) {\n-        return (String) getConstantValue(cp);\n-    }\n-\n-    \/**\n-     * @return String object\n-     *\/\n-    @Override\n-    public Object getConstantValue(final ConstantPool cp) {\n-        return cp.getConstantUtf8(stringIndex).getBytes();\n-    }\n@@ -111,0 +102,1 @@\n+\n@@ -114,1 +106,1 @@\n-    public void setStringIndex(final int stringIndex) {\n+    public void setStringIndex( final int stringIndex ) {\n@@ -118,0 +110,1 @@\n+\n@@ -125,0 +118,16 @@\n+\n+\n+    \/** @return String object\n+     *\/\n+    @Override\n+    public Object getConstantValue( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(stringIndex, Const.CONSTANT_Utf8);\n+        return ((ConstantUtf8) c).getBytes();\n+    }\n+\n+\n+    \/** @return dereferenced string\n+     *\/\n+    public String getBytes( final ConstantPool cp ) {\n+        return (String) getConstantValue(cp);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantString.java","additions":34,"deletions":25,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,0 +23,1 @@\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -29,3 +30,0 @@\n-import java.util.Objects;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -35,24 +33,0 @@\n- * <p>\n- * The following system properties govern caching this class performs.\n- * <\/p>\n- * <ul>\n- * <li>{@value #SYS_PROP_CACHE_MAX_ENTRIES} (since 6.4): The size of the cache, by default 0, meaning caching is\n- * disabled.<\/li>\n- * <li>{@value #SYS_PROP_CACHE_MAX_ENTRY_SIZE} (since 6.0): The maximum size of the values to cache, by default 200, 0\n- * disables caching. Values larger than this are <em>not<\/em> cached.<\/li>\n- * <li>{@value #SYS_PROP_STATISTICS} (since 6.0): Prints statistics on the console when the JVM exits.<\/li>\n- * <\/ul>\n- * <p>\n- * Here is a sample Maven invocation with caching disabled:\n- * <\/p>\n- *\n- * <pre>\n- * mvn test -Dbcel.statistics=true -Dbcel.maxcached.size=0 -Dbcel.maxcached=0\n- * <\/pre>\n- * <p>\n- * Here is a sample Maven invocation with caching enabled:\n- * <\/p>\n- *\n- * <pre>\n- * mvn test -Dbcel.statistics=true -Dbcel.maxcached.size=100000 -Dbcel.maxcached=5000000\n- * <\/pre>\n@@ -61,1 +35,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -71,1 +45,2 @@\n-        private static final HashMap<String, ConstantUtf8> CACHE = new LinkedHashMap<String, ConstantUtf8>(INITIAL_CAPACITY, 0.75f, true) {\n+        private static final HashMap<String, ConstantUtf8> CACHE = new LinkedHashMap<String, ConstantUtf8>(\n+            INITIAL_CAPACITY, 0.75f, true) {\n@@ -90,16 +65,0 @@\n-    \/\/ TODO these should perhaps be AtomicInt?\n-    private static volatile int considered;\n-    private static volatile int created;\n-    private static volatile int hits;\n-    private static volatile int skipped;\n-\n-    private static final String SYS_PROP_CACHE_MAX_ENTRIES = \"bcel.maxcached\";\n-    private static final String SYS_PROP_CACHE_MAX_ENTRY_SIZE = \"bcel.maxcached.size\";\n-    private static final String SYS_PROP_STATISTICS = \"bcel.statistics\";\n-\n-    static {\n-        if (Cache.BCEL_STATISTICS) {\n-            Runtime.getRuntime().addShutdownHook(new Thread(ConstantUtf8::printStats));\n-        }\n-    }\n-\n@@ -115,5 +74,0 @@\n-    \/\/ for access by test code\n-    static synchronized void clearStats() {\n-        hits = considered = skipped = created = 0;\n-    }\n-\n@@ -132,1 +86,0 @@\n-            skipped++;\n@@ -135,1 +88,1 @@\n-        considered++;\n+\n@@ -139,1 +92,0 @@\n-                hits++;\n@@ -177,9 +129,0 @@\n-    \/\/ for access by test code\n-    static void printStats() {\n-        final String prefix = \"[Apache Commons BCEL]\";\n-        System.err.printf(\"%s Cache hit %,d\/%,d, %d skipped.%n\", prefix, hits, considered, skipped);\n-        System.err.printf(\"%s Total of %,d ConstantUtf8 objects created.%n\", prefix, created);\n-        System.err.printf(\"%s Configuration: %s=%,d, %s=%,d.%n\", prefix, SYS_PROP_CACHE_MAX_ENTRIES, Cache.MAX_ENTRIES, SYS_PROP_CACHE_MAX_ENTRY_SIZE,\n-            Cache.MAX_ENTRY_SIZE);\n-    }\n-\n@@ -201,1 +144,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -206,1 +149,0 @@\n-        created++;\n@@ -214,2 +156,4 @@\n-        this.value = Objects.requireNonNull(value, \"value\");\n-        created++;\n+        if (value == null) {\n+            throw new IllegalArgumentException(\"Value must not be null.\");\n+        }\n+        this.value = value;\n@@ -219,1 +163,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n+     * Called by objects that are traversing the nodes of the tree implicitely defined by the contents of a Java class.\n@@ -233,1 +177,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantUtf8.java","additions":13,"deletions":69,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and represents a constant value, i.e., a default value for initializing\n- * a class field. This class is instantiated by the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and represents a constant\n+ * value, i.e., a default value for initializing a class field.\n+ * This class is instantiated by the <em>Attribute.readAttribute()<\/em> method.\n@@ -35,8 +35,1 @@\n- * <pre>\n- * ConstantValue_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 constantvalue_index;\n- * }\n- * <\/pre>\n- * @see Attribute\n+ * @see     Attribute\n@@ -48,0 +41,1 @@\n+\n@@ -49,4 +43,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -58,0 +50,1 @@\n+\n@@ -60,2 +53,1 @@\n-     *\n-     * @param nameIndex Name index in constant pool\n+     * @param name_index Name index in constant pool\n@@ -64,2 +56,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -67,2 +59,3 @@\n-    ConstantValue(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n+    ConstantValue(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), constant_pool);\n@@ -71,0 +64,1 @@\n+\n@@ -72,1 +66,1 @@\n-     * @param nameIndex Name index in constant pool\n+     * @param name_index Name index in constant pool\n@@ -75,1 +69,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -77,2 +71,3 @@\n-    public ConstantValue(final int nameIndex, final int length, final int constantValueIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_CONSTANT_VALUE, nameIndex, Args.require(length, 2, \"ConstantValue attribute length\"), constantPool);\n+    public ConstantValue(final int name_index, final int length, final int constantValueIndex,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_CONSTANT_VALUE, name_index, length, constant_pool);\n@@ -82,0 +77,1 @@\n+\n@@ -83,2 +79,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +86,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -93,9 +90,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ConstantValue c = (ConstantValue) clone();\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -107,1 +95,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -110,1 +98,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -115,0 +103,1 @@\n+\n@@ -122,0 +111,1 @@\n+\n@@ -125,1 +115,1 @@\n-    public void setConstantValueIndex(final int constantValueIndex) {\n+    public void setConstantValueIndex( final int constantValueIndex ) {\n@@ -129,0 +119,1 @@\n+\n@@ -139,19 +130,19 @@\n-        case Const.CONSTANT_Long:\n-            buf = String.valueOf(((ConstantLong) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Float:\n-            buf = String.valueOf(((ConstantFloat) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Double:\n-            buf = String.valueOf(((ConstantDouble) c).getBytes());\n-            break;\n-        case Const.CONSTANT_Integer:\n-            buf = String.valueOf(((ConstantInteger) c).getBytes());\n-            break;\n-        case Const.CONSTANT_String:\n-            i = ((ConstantString) c).getStringIndex();\n-            c = super.getConstantPool().getConstantUtf8(i);\n-            buf = \"\\\"\" + Utility.convertString(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n-            break;\n-        default:\n-            throw new IllegalStateException(\"Type of ConstValue invalid: \" + c);\n+            case Const.CONSTANT_Long:\n+                buf = String.valueOf(((ConstantLong) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Float:\n+                buf = String.valueOf(((ConstantFloat) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Double:\n+                buf = String.valueOf(((ConstantDouble) c).getBytes());\n+                break;\n+            case Const.CONSTANT_Integer:\n+                buf = String.valueOf(((ConstantInteger) c).getBytes());\n+                break;\n+            case Const.CONSTANT_String:\n+                i = ((ConstantString) c).getStringIndex();\n+                c = super.getConstantPool().getConstant(i, Const.CONSTANT_Utf8);\n+                buf = \"\\\"\" + Utility.convertString(((ConstantUtf8) c).getBytes()) + \"\\\"\";\n+                break;\n+            default:\n+                throw new IllegalStateException(\"Type of ConstValue invalid: \" + c);\n@@ -161,0 +152,11 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ConstantValue c = (ConstantValue) clone();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ConstantValue.java","additions":61,"deletions":59,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -31,2 +30,3 @@\n- * This class is derived from <em>Attribute<\/em> and denotes that this is a deprecated method. It is instantiated from\n- * the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and denotes that this is a\n+ * deprecated method.\n+ * It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -34,1 +34,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -40,0 +40,1 @@\n+\n@@ -41,4 +42,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -50,0 +49,1 @@\n+\n@@ -51,1 +51,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -54,1 +54,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -56,2 +56,2 @@\n-    public Deprecated(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n-        super(Const.ATTR_DEPRECATED, nameIndex, Args.require0(length, \"Deprecated attribute length\"), constantPool);\n+    public Deprecated(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_DEPRECATED, name_index, length, constant_pool);\n@@ -61,0 +61,1 @@\n+\n@@ -64,1 +65,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -67,2 +68,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -70,2 +71,3 @@\n-    Deprecated(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (byte[]) null, constantPool);\n+    Deprecated(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (byte[]) null, constant_pool);\n@@ -79,0 +81,1 @@\n+\n@@ -80,2 +83,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -86,1 +90,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -90,12 +94,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Deprecated c = (Deprecated) clone();\n-        if (bytes != null) {\n-            c.bytes = bytes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -107,1 +99,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -110,1 +102,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -117,0 +109,1 @@\n+\n@@ -124,0 +117,1 @@\n+\n@@ -127,1 +121,1 @@\n-    public void setBytes(final byte[] bytes) {\n+    public void setBytes( final byte[] bytes ) {\n@@ -131,0 +125,1 @@\n+\n@@ -136,1 +131,16 @@\n-        return Const.getAttributeName(Const.ATTR_DEPRECATED) + \": true\";\n+        return Const.getAttributeName(Const.ATTR_DEPRECATED);\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Deprecated c = (Deprecated) clone();\n+        if (bytes != null) {\n+            c.bytes = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Deprecated.java","additions":46,"deletions":36,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -22,1 +22,0 @@\n-import java.util.Objects;\n@@ -24,1 +23,0 @@\n-import java.util.stream.Stream;\n@@ -32,1 +30,2 @@\n-public class DescendingVisitor implements Visitor {\n+public class DescendingVisitor implements Visitor\n+{\n@@ -40,2 +39,1 @@\n-     * @param clazz Class to traverse\n-     * @param visitor visitor object to apply to all components\n+     * @return container of current entitity, i.e., predecessor during traversal\n@@ -43,7 +41,3 @@\n-    public DescendingVisitor(final JavaClass clazz, final Visitor visitor) {\n-        this.clazz = clazz;\n-        this.visitor = visitor;\n-    }\n-\n-    private <E extends Node> void accept(final E[] node) {\n-        Stream.of(node).forEach(e -> e.accept(this));\n+    public Object predecessor()\n+    {\n+        return predecessor(0);\n@@ -53,1 +47,3 @@\n-     * @return current object\n+     * @param level\n+     *            nesting level, i.e., 0 returns the direct predecessor\n+     * @return container of current entitity, i.e., predecessor during traversal\n@@ -55,2 +51,8 @@\n-    public Object current() {\n-        return stack.peek();\n+    public Object predecessor(final int level)\n+    {\n+        final int size = stack.size();\n+        if ((size < 2) || (level < 0))\n+        {\n+            return null;\n+        }\n+        return stack.elementAt(size - (level + 2)); \/\/ size - 1 == current\n@@ -60,1 +62,1 @@\n-     * @return container of current entitity, i.e., predecessor during traversal\n+     * @return current object\n@@ -62,2 +64,3 @@\n-    public Object predecessor() {\n-        return predecessor(0);\n+    public Object current()\n+    {\n+        return stack.peek();\n@@ -67,2 +70,4 @@\n-     * @param level nesting level, i.e., 0 returns the direct predecessor\n-     * @return container of current entitity, i.e., predecessor during traversal\n+     * @param clazz\n+     *            Class to traverse\n+     * @param visitor\n+     *            visitor object to apply to all components\n@@ -70,6 +75,4 @@\n-    public Object predecessor(final int level) {\n-        final int size = stack.size();\n-        if (size < 2 || level < 0) {\n-            return null;\n-        }\n-        return stack.elementAt(size - (level + 2)); \/\/ size - 1 == current\n+    public DescendingVisitor(final JavaClass clazz, final Visitor visitor)\n+    {\n+        this.clazz = clazz;\n+        this.visitor = visitor;\n@@ -81,1 +84,2 @@\n-    public void visit() {\n+    public void visit()\n+    {\n@@ -85,3 +89,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -89,4 +90,17 @@\n-    public void visitAnnotation(final Annotations annotation) {\n-        stack.push(annotation);\n-        annotation.accept(visitor);\n-        accept(annotation.getAnnotationEntries());\n+    public void visitJavaClass(final JavaClass _clazz)\n+    {\n+        stack.push(_clazz);\n+        _clazz.accept(visitor);\n+        final Field[] fields = _clazz.getFields();\n+        for (final Field field : fields) {\n+            field.accept(this);\n+        }\n+        final Method[] methods = _clazz.getMethods();\n+        for (final Method method : methods) {\n+            method.accept(this);\n+        }\n+        final Attribute[] attributes = _clazz.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n+        _clazz.getConstantPool().accept(this);\n@@ -100,3 +114,8 @@\n-    public void visitAnnotationDefault(final AnnotationDefault obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitAnnotation(final Annotations annotation)\n+    {\n+        stack.push(annotation);\n+        annotation.accept(visitor);\n+        final AnnotationEntry[] entries = annotation.getAnnotationEntries();\n+        for (final AnnotationEntry entrie : entries) {\n+            entrie.accept(this);\n+        }\n@@ -110,1 +129,2 @@\n-    public void visitAnnotationEntry(final AnnotationEntry annotationEntry) {\n+    public void visitAnnotationEntry(final AnnotationEntry annotationEntry)\n+    {\n@@ -116,3 +136,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -120,8 +137,8 @@\n-    public void visitBootstrapMethods(final BootstrapMethods bm) {\n-        stack.push(bm);\n-        bm.accept(visitor);\n-        \/\/ BootstrapMethod[] bms = bm.getBootstrapMethods();\n-        \/\/ for (int i = 0; i < bms.length; i++)\n-        \/\/ {\n-        \/\/ bms[i].accept(this);\n-        \/\/ }\n+    public void visitField(final Field field)\n+    {\n+        stack.push(field);\n+        field.accept(visitor);\n+        final Attribute[] attributes = field.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n@@ -132,5 +149,4 @@\n-    public void visitCode(final Code code) {\n-        stack.push(code);\n-        code.accept(visitor);\n-        accept(code.getExceptionTable());\n-        accept(code.getAttributes());\n+    public void visitConstantValue(final ConstantValue cv)\n+    {\n+        stack.push(cv);\n+        cv.accept(visitor);\n@@ -141,3 +157,8 @@\n-    public void visitCodeException(final CodeException ce) {\n-        stack.push(ce);\n-        ce.accept(visitor);\n+    public void visitMethod(final Method method)\n+    {\n+        stack.push(method);\n+        method.accept(visitor);\n+        final Attribute[] attributes = method.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n@@ -148,3 +169,4 @@\n-    public void visitConstantClass(final ConstantClass constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitExceptionTable(final ExceptionTable table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n@@ -155,3 +177,12 @@\n-    public void visitConstantDouble(final ConstantDouble constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitCode(final Code code)\n+    {\n+        stack.push(code);\n+        code.accept(visitor);\n+        final CodeException[] table = code.getExceptionTable();\n+        for (final CodeException element : table) {\n+            element.accept(this);\n+        }\n+        final Attribute[] attributes = code.getAttributes();\n+        for (final Attribute attribute : attributes) {\n+            attribute.accept(this);\n+        }\n@@ -161,1 +192,0 @@\n-    \/** @since 6.3 *\/\n@@ -163,3 +193,4 @@\n-    public void visitConstantDynamic(final ConstantDynamic obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitCodeException(final CodeException ce)\n+    {\n+        stack.push(ce);\n+        ce.accept(visitor);\n@@ -170,3 +201,8 @@\n-    public void visitConstantFieldref(final ConstantFieldref constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLineNumberTable(final LineNumberTable table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n+        final LineNumber[] numbers = table.getLineNumberTable();\n+        for (final LineNumber number : numbers) {\n+            number.accept(this);\n+        }\n@@ -177,3 +213,4 @@\n-    public void visitConstantFloat(final ConstantFloat constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLineNumber(final LineNumber number)\n+    {\n+        stack.push(number);\n+        number.accept(visitor);\n@@ -184,3 +221,8 @@\n-    public void visitConstantInteger(final ConstantInteger constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLocalVariableTable(final LocalVariableTable table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n+        final LocalVariable[] vars = table.getLocalVariableTable();\n+        for (final LocalVariable var : vars) {\n+            var.accept(this);\n+        }\n@@ -191,3 +233,8 @@\n-    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitStackMap(final StackMap table)\n+    {\n+        stack.push(table);\n+        table.accept(visitor);\n+        final StackMapEntry[] vars = table.getStackMap();\n+        for (final StackMapEntry var : vars) {\n+            var.accept(this);\n+        }\n@@ -197,3 +244,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -201,3 +245,4 @@\n-    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitStackMapEntry(final StackMapEntry var)\n+    {\n+        stack.push(var);\n+        var.accept(visitor);\n@@ -208,3 +253,4 @@\n-    public void visitConstantLong(final ConstantLong constant) {\n-        stack.push(constant);\n-        constant.accept(visitor);\n+    public void visitLocalVariable(final LocalVariable var)\n+    {\n+        stack.push(var);\n+        var.accept(visitor);\n@@ -214,1 +260,0 @@\n-    \/** @since 6.0 *\/\n@@ -216,3 +261,12 @@\n-    public void visitConstantMethodHandle(final ConstantMethodHandle obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantPool(final ConstantPool cp)\n+    {\n+        stack.push(cp);\n+        cp.accept(visitor);\n+        final Constant[] constants = cp.getConstantPool();\n+        for (int i = 1; i < constants.length; i++)\n+        {\n+            if (constants[i] != null)\n+            {\n+                constants[i].accept(this);\n+            }\n+        }\n@@ -223,1 +277,2 @@\n-    public void visitConstantMethodref(final ConstantMethodref constant) {\n+    public void visitConstantClass(final ConstantClass constant)\n+    {\n@@ -229,1 +284,0 @@\n-    \/** @since 6.0 *\/\n@@ -231,3 +285,4 @@\n-    public void visitConstantMethodType(final ConstantMethodType obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantDouble(final ConstantDouble constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -237,1 +292,0 @@\n-    \/** @since 6.1 *\/\n@@ -239,3 +293,4 @@\n-    public void visitConstantModule(final ConstantModule obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantFieldref(final ConstantFieldref constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -246,1 +301,2 @@\n-    public void visitConstantNameAndType(final ConstantNameAndType constant) {\n+    public void visitConstantFloat(final ConstantFloat constant)\n+    {\n@@ -252,1 +308,0 @@\n-    \/** @since 6.1 *\/\n@@ -254,3 +309,4 @@\n-    public void visitConstantPackage(final ConstantPackage obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantInteger(final ConstantInteger constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -261,4 +317,5 @@\n-    public void visitConstantPool(final ConstantPool cp) {\n-        stack.push(cp);\n-        cp.accept(visitor);\n-        Stream.of(cp.getConstantPool()).filter(Objects::nonNull).forEach(e -> e.accept(this));\n+    public void visitConstantInterfaceMethodref(\n+            final ConstantInterfaceMethodref constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -268,0 +325,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -269,1 +329,3 @@\n-    public void visitConstantString(final ConstantString constant) {\n+    public void visitConstantInvokeDynamic(\n+            final ConstantInvokeDynamic constant)\n+    {\n@@ -276,1 +338,2 @@\n-    public void visitConstantUtf8(final ConstantUtf8 constant) {\n+    public void visitConstantLong(final ConstantLong constant)\n+    {\n@@ -283,3 +346,4 @@\n-    public void visitConstantValue(final ConstantValue cv) {\n-        stack.push(cv);\n-        cv.accept(visitor);\n+    public void visitConstantMethodref(final ConstantMethodref constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -290,3 +354,4 @@\n-    public void visitDeprecated(final Deprecated attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitConstantNameAndType(final ConstantNameAndType constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -296,3 +361,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -300,3 +362,4 @@\n-    public void visitEnclosingMethod(final EnclosingMethod obj) {\n-        stack.push(obj);\n-        obj.accept(visitor);\n+    public void visitConstantString(final ConstantString constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -307,3 +370,4 @@\n-    public void visitExceptionTable(final ExceptionTable table) {\n-        stack.push(table);\n-        table.accept(visitor);\n+    public void visitConstantUtf8(final ConstantUtf8 constant)\n+    {\n+        stack.push(constant);\n+        constant.accept(visitor);\n@@ -314,4 +378,8 @@\n-    public void visitField(final Field field) {\n-        stack.push(field);\n-        field.accept(visitor);\n-        accept(field.getAttributes());\n+    public void visitInnerClasses(final InnerClasses ic)\n+    {\n+        stack.push(ic);\n+        ic.accept(visitor);\n+        final InnerClass[] ics = ic.getInnerClasses();\n+        for (final InnerClass ic2 : ics) {\n+            ic2.accept(this);\n+        }\n@@ -322,1 +390,2 @@\n-    public void visitInnerClass(final InnerClass inner) {\n+    public void visitInnerClass(final InnerClass inner)\n+    {\n@@ -328,0 +397,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -329,4 +401,9 @@\n-    public void visitInnerClasses(final InnerClasses ic) {\n-        stack.push(ic);\n-        ic.accept(visitor);\n-        accept(ic.getInnerClasses());\n+    public void visitBootstrapMethods(final BootstrapMethods bm)\n+    {\n+        stack.push(bm);\n+        bm.accept(visitor);\n+        \/\/ BootstrapMethod[] bms = bm.getBootstrapMethods();\n+        \/\/ for (int i = 0; i < bms.length; i++)\n+        \/\/ {\n+        \/\/     bms[i].accept(this);\n+        \/\/ }\n@@ -337,7 +414,4 @@\n-    public void visitJavaClass(final JavaClass clazz) {\n-        stack.push(clazz);\n-        clazz.accept(visitor);\n-        accept(clazz.getFields());\n-        accept(clazz.getMethods());\n-        accept(clazz.getAttributes());\n-        clazz.getConstantPool().accept(this);\n+    public void visitDeprecated(final Deprecated attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -348,3 +422,4 @@\n-    public void visitLineNumber(final LineNumber number) {\n-        stack.push(number);\n-        number.accept(visitor);\n+    public void visitSignature(final Signature attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -355,4 +430,4 @@\n-    public void visitLineNumberTable(final LineNumberTable table) {\n-        stack.push(table);\n-        table.accept(visitor);\n-        accept(table.getLineNumberTable());\n+    public void visitSourceFile(final SourceFile attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -363,3 +438,4 @@\n-    public void visitLocalVariable(final LocalVariable var) {\n-        stack.push(var);\n-        var.accept(visitor);\n+    public void visitSynthetic(final Synthetic attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -370,4 +446,4 @@\n-    public void visitLocalVariableTable(final LocalVariableTable table) {\n-        stack.push(table);\n-        table.accept(visitor);\n-        accept(table.getLocalVariableTable());\n+    public void visitUnknown(final Unknown attribute)\n+    {\n+        stack.push(attribute);\n+        attribute.accept(visitor);\n@@ -381,1 +457,2 @@\n-    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj) {\n+    public void visitAnnotationDefault(final AnnotationDefault obj)\n+    {\n@@ -387,0 +464,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -388,4 +468,4 @@\n-    public void visitMethod(final Method method) {\n-        stack.push(method);\n-        method.accept(visitor);\n-        accept(method.getAttributes());\n+    public void visitEnclosingMethod(final EnclosingMethod obj)\n+    {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -396,1 +476,1 @@\n-     * @since 6.4.0\n+     * @since 6.0\n@@ -399,1 +479,2 @@\n-    public void visitMethodParameter(final MethodParameter obj) {\n+    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj)\n+    {\n@@ -409,1 +490,2 @@\n-    public void visitMethodParameters(final MethodParameters obj) {\n+    public void visitParameterAnnotation(final ParameterAnnotations obj)\n+    {\n@@ -412,1 +494,0 @@\n-        Stream.of(obj.getParameters()).forEach(e -> e.accept(this));\n@@ -416,1 +497,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -418,1 +501,2 @@\n-    public void visitModule(final Module obj) {\n+    public void visitMethodParameters(final MethodParameters obj)\n+    {\n@@ -421,4 +505,4 @@\n-        accept(obj.getRequiresTable());\n-        accept(obj.getExportsTable());\n-        accept(obj.getOpensTable());\n-        accept(obj.getProvidesTable());\n+        final MethodParameter[] table = obj.getParameters();\n+        for (final MethodParameter element : table) {\n+            element.accept(this);\n+        }\n@@ -428,1 +512,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.4.0\n+     *\/\n@@ -430,1 +516,2 @@\n-    public void visitModuleExports(final ModuleExports obj) {\n+    public void visitMethodParameter(final MethodParameter obj)\n+    {\n@@ -436,1 +523,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.0 *\/\n@@ -438,1 +525,1 @@\n-    public void visitModuleMainClass(final ModuleMainClass obj) {\n+    public void visitConstantMethodType(final ConstantMethodType obj) {\n@@ -444,1 +531,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.0 *\/\n@@ -446,1 +533,1 @@\n-    public void visitModuleOpens(final ModuleOpens obj) {\n+    public void visitConstantMethodHandle(final ConstantMethodHandle obj) {\n@@ -452,1 +539,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.0 *\/\n@@ -454,1 +541,1 @@\n-    public void visitModulePackages(final ModulePackages obj) {\n+    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry obj) {\n@@ -460,1 +547,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.1 *\/\n@@ -462,1 +549,1 @@\n-    public void visitModuleProvides(final ModuleProvides obj) {\n+    public void visitConstantPackage(final ConstantPackage obj) {\n@@ -468,1 +555,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.1 *\/\n@@ -470,1 +557,1 @@\n-    public void visitModuleRequires(final ModuleRequires obj) {\n+    public void visitConstantModule(final ConstantModule obj) {\n@@ -476,1 +563,1 @@\n-    \/** @since 6.4.0 *\/\n+    \/** @since 6.3 *\/\n@@ -478,1 +565,1 @@\n-    public void visitNestHost(final NestHost obj) {\n+    public void visitConstantDynamic(final ConstantDynamic obj) {\n@@ -486,1 +573,1 @@\n-    public void visitNestMembers(final NestMembers obj) {\n+    public void visitModule(final Module obj) {\n@@ -489,0 +576,16 @@\n+        final ModuleRequires[] rtable = obj.getRequiresTable();\n+        for (final ModuleRequires element : rtable) {\n+            element.accept(this);\n+        }\n+        final ModuleExports[] etable = obj.getExportsTable();\n+        for (final ModuleExports element : etable) {\n+            element.accept(this);\n+        }\n+        final ModuleOpens[] otable = obj.getOpensTable();\n+        for (final ModuleOpens element : otable) {\n+            element.accept(this);\n+        }\n+        final ModuleProvides[] ptable = obj.getProvidesTable();\n+        for (final ModuleProvides element : ptable) {\n+            element.accept(this);\n+        }\n@@ -492,3 +595,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -496,1 +597,1 @@\n-    public void visitParameterAnnotation(final ParameterAnnotations obj) {\n+    public void visitModuleRequires(final ModuleRequires obj) {\n@@ -502,1 +603,1 @@\n-    \/** @since 6.0 *\/\n+    \/** @since 6.4.0 *\/\n@@ -504,1 +605,1 @@\n-    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry obj) {\n+    public void visitModuleExports(final ModuleExports obj) {\n@@ -510,0 +611,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -511,3 +613,3 @@\n-    public void visitSignature(final Signature attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitModuleOpens(final ModuleOpens obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -517,0 +619,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -518,3 +621,3 @@\n-    public void visitSourceFile(final SourceFile attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitModuleProvides(final ModuleProvides obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -524,0 +627,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -525,4 +629,3 @@\n-    public void visitStackMap(final StackMap table) {\n-        stack.push(table);\n-        table.accept(visitor);\n-        accept(table.getStackMap());\n+    public void visitModulePackages(final ModulePackages obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -532,0 +635,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -533,3 +637,3 @@\n-    public void visitStackMapEntry(final StackMapEntry var) {\n-        stack.push(var);\n-        var.accept(visitor);\n+    public void visitModuleMainClass(final ModuleMainClass obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -539,0 +643,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -540,3 +645,3 @@\n-    public void visitSynthetic(final Synthetic attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitNestHost(final NestHost obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n@@ -546,0 +651,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -547,3 +653,3 @@\n-    public void visitUnknown(final Unknown attribute) {\n-        stack.push(attribute);\n-        attribute.accept(visitor);\n+    public void visitNestMembers(final NestMembers obj) {\n+        stack.push(obj);\n+        obj.accept(visitor);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/DescendingVisitor.java","additions":318,"deletions":212,"binary":false,"changes":530,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-\n@@ -30,22 +28,0 @@\n- * The element_value structure is documented at https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se11\/html\/jvms-4.html#jvms-4.7.16.1\n- *\n- * <pre>\n- * element_value {\n- *    u1 tag;\n- *    union {\n- *        u2 const_value_index;\n- *\n- *        {   u2 type_name_index;\n- *            u2 const_name_index;\n- *        } enum_const_value;\n- *\n- *        u2 class_info_index;\n- *\n- *        annotation annotation_value;\n- *\n- *        {   u2            num_values;\n- *            element_value values[num_values];\n- *        } array_value;\n- *    } value;\n- *}\n- *<\/pre>\n@@ -55,15 +31,3 @@\n-public abstract class ElementValue {\n-\n-    public static final byte STRING = 's';\n-    public static final byte ENUM_CONSTANT = 'e';\n-    public static final byte CLASS = 'c';\n-    public static final byte ANNOTATION = '@';\n-    public static final byte ARRAY = '[';\n-    public static final byte PRIMITIVE_INT = 'I';\n-    public static final byte PRIMITIVE_BYTE = 'B';\n-    public static final byte PRIMITIVE_CHAR = 'C';\n-    public static final byte PRIMITIVE_DOUBLE = 'D';\n-    public static final byte PRIMITIVE_FLOAT = 'F';\n-    public static final byte PRIMITIVE_LONG = 'J';\n-    public static final byte PRIMITIVE_SHORT = 'S';\n-    public static final byte PRIMITIVE_BOOLEAN = 'Z';\n+public abstract class ElementValue\n+{\n+    private final int type;\n@@ -71,11 +35,1 @@\n-    \/**\n-     * Reads an {@code element_value} as an {@code ElementValue}.\n-     *\n-     * @param input Raw data input.\n-     * @param cpool Constant pool.\n-     * @return a new ElementValue.\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool) throws IOException {\n-        return readElementValue(input, cpool, 0);\n-    }\n+    private final ConstantPool cpool;\n@@ -83,51 +37,4 @@\n-    \/**\n-     * Reads an {@code element_value} as an {@code ElementValue}.\n-     *\n-     * @param input Raw data input.\n-     * @param cpool Constant pool.\n-     * @param arrayNesting level of current array nesting.\n-     * @return a new ElementValue.\n-     * @throws IOException if an I\/O error occurs.\n-     * @since 6.7.0\n-     *\/\n-    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool, int arrayNesting)\n-            throws IOException {\n-        final byte tag = input.readByte();\n-        switch (tag) {\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_DOUBLE:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_BOOLEAN:\n-        case STRING:\n-            return new SimpleElementValue(tag, input.readUnsignedShort(), cpool);\n-\n-        case ENUM_CONSTANT:\n-            return new EnumElementValue(ENUM_CONSTANT, input.readUnsignedShort(), input.readUnsignedShort(), cpool);\n-\n-        case CLASS:\n-            return new ClassElementValue(CLASS, input.readUnsignedShort(), cpool);\n-\n-        case ANNOTATION:\n-            \/\/ TODO isRuntimeVisible\n-            return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(input, cpool, false), cpool);\n-\n-        case ARRAY:\n-            arrayNesting++;\n-            if (arrayNesting > Const.MAX_ARRAY_DIMENSIONS) {\n-                \/\/ JVM spec 4.4.1\n-                throw new ClassFormatException(String.format(\"Arrays are only valid if they represent %,d or fewer dimensions.\", Const.MAX_ARRAY_DIMENSIONS));\n-            }\n-            final int numArrayVals = input.readUnsignedShort();\n-            final ElementValue[] evalues = new ElementValue[numArrayVals];\n-            for (int j = 0; j < numArrayVals; j++) {\n-                evalues[j] = ElementValue.readElementValue(input, cpool, arrayNesting);\n-            }\n-            return new ArrayElementValue(ARRAY, evalues, cpool);\n-\n-        default:\n-            throw new ClassFormatException(\"Unexpected element value tag in annotation: \" + tag);\n-        }\n+    @Override\n+    public String toString()\n+    {\n+        return stringifyValue();\n@@ -136,12 +43,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int type; \/\/ TODO should be final\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @java.lang.Deprecated\n-    protected ConstantPool cpool; \/\/ TODO should be final\n-\n-    protected ElementValue(final int type, final ConstantPool cpool) {\n+    protected ElementValue(final int type, final ConstantPool cpool)\n+    {\n@@ -152,0 +49,7 @@\n+    public int getElementValueType()\n+    {\n+        return type;\n+    }\n+\n+    public abstract String stringifyValue();\n+\n@@ -154,0 +58,54 @@\n+    public static final byte STRING            = 's';\n+    public static final byte ENUM_CONSTANT     = 'e';\n+    public static final byte CLASS             = 'c';\n+    public static final byte ANNOTATION        = '@';\n+    public static final byte ARRAY             = '[';\n+    public static final byte PRIMITIVE_INT     = 'I';\n+    public static final byte PRIMITIVE_BYTE    = 'B';\n+    public static final byte PRIMITIVE_CHAR    = 'C';\n+    public static final byte PRIMITIVE_DOUBLE  = 'D';\n+    public static final byte PRIMITIVE_FLOAT   = 'F';\n+    public static final byte PRIMITIVE_LONG    = 'J';\n+    public static final byte PRIMITIVE_SHORT   = 'S';\n+    public static final byte PRIMITIVE_BOOLEAN = 'Z';\n+\n+    public static ElementValue readElementValue(final DataInput input, final ConstantPool cpool) throws IOException\n+    {\n+        final byte type = input.readByte();\n+        switch (type)\n+        {\n+            case PRIMITIVE_BYTE:\n+            case PRIMITIVE_CHAR:\n+            case PRIMITIVE_DOUBLE:\n+            case PRIMITIVE_FLOAT:\n+            case PRIMITIVE_INT:\n+            case PRIMITIVE_LONG:\n+            case PRIMITIVE_SHORT:\n+            case PRIMITIVE_BOOLEAN:\n+            case STRING:\n+                return new SimpleElementValue(type, input.readUnsignedShort(), cpool);\n+\n+            case ENUM_CONSTANT:\n+                return new EnumElementValue(ENUM_CONSTANT, input.readUnsignedShort(), input.readUnsignedShort(), cpool);\n+\n+            case CLASS:\n+                return new ClassElementValue(CLASS, input.readUnsignedShort(), cpool);\n+\n+            case ANNOTATION:\n+                \/\/ TODO isRuntimeVisible\n+                return new AnnotationElementValue(ANNOTATION, AnnotationEntry.read(input, cpool, false), cpool);\n+\n+            case ARRAY:\n+                final int numArrayVals = input.readUnsignedShort();\n+                final ElementValue[] evalues = new ElementValue[numArrayVals];\n+                for (int j = 0; j < numArrayVals; j++)\n+                {\n+                    evalues[j] = ElementValue.readElementValue(input, cpool);\n+                }\n+                return new ArrayElementValue(ARRAY, evalues, cpool);\n+\n+            default:\n+                throw new IllegalArgumentException(\"Unexpected element value kind in annotation: \" + type);\n+        }\n+    }\n+\n@@ -159,4 +117,0 @@\n-    public int getElementValueType() {\n-        return type;\n-    }\n-\n@@ -168,8 +122,2 @@\n-    public abstract String stringifyValue();\n-\n-    public String toShortString() {\n-        return stringifyValue();\n-    }\n-\n-    @Override\n-    public String toString() {\n+    public String toShortString()\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ElementValue.java","additions":73,"deletions":125,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -28,1 +30,1 @@\n- * An annotation's element value pair.\n+ * an annotation's element value pair\n@@ -32,4 +34,2 @@\n-public class ElementValuePair {\n-\n-    static final ElementValuePair[] EMPTY_ARRAY = {};\n-\n+public class ElementValuePair\n+{\n@@ -42,1 +42,3 @@\n-    public ElementValuePair(final int elementNameIndex, final ElementValue elementValue, final ConstantPool constantPool) {\n+    public ElementValuePair(final int elementNameIndex, final ElementValue elementValue,\n+            final ConstantPool constantPool)\n+    {\n@@ -48,7 +50,5 @@\n-    protected void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(elementNameIndex); \/\/ u2 name of the element\n-        elementValue.dump(dos);\n-    }\n-\n-    public int getNameIndex() {\n-        return elementNameIndex;\n+    public String getNameString()\n+    {\n+        final ConstantUtf8 c = (ConstantUtf8) constantPool.getConstant(\n+                elementNameIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -57,2 +57,3 @@\n-    public String getNameString() {\n-        return constantPool.getConstantUtf8(elementNameIndex).getBytes();\n+    public final ElementValue getValue()\n+    {\n+        return elementValue;\n@@ -61,2 +62,3 @@\n-    public final ElementValue getValue() {\n-        return elementValue;\n+    public int getNameIndex()\n+    {\n+        return elementNameIndex;\n@@ -65,1 +67,2 @@\n-    public String toShortString() {\n+    public String toShortString()\n+    {\n@@ -67,1 +70,2 @@\n-        result.append(getNameString()).append(\"=\").append(getValue().toShortString());\n+        result.append(getNameString()).append(\"=\").append(\n+                getValue().toShortString());\n@@ -70,0 +74,5 @@\n+\n+    protected void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(elementNameIndex); \/\/ u2 name of the element\n+        elementValue.dump(dos);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ElementValuePair.java","additions":28,"deletions":19,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Visitor with empty method bodies, can be extended and used in conjunction with the DescendingVisitor class, e.g. By\n- * courtesy of David Spencer.\n+ * Visitor with empty method bodies, can be extended and used in conjunction\n+ * with the DescendingVisitor class, e.g. By courtesy of David Spencer.\n@@ -30,2 +30,4 @@\n-public class EmptyVisitor implements Visitor {\n-    protected EmptyVisitor() {\n+public class EmptyVisitor implements Visitor\n+{\n+    protected EmptyVisitor()\n+    {\n@@ -38,1 +40,2 @@\n-    public void visitAnnotation(final Annotations obj) {\n+    public void visitAnnotation(final Annotations obj)\n+    {\n@@ -45,1 +48,2 @@\n-    public void visitAnnotationDefault(final AnnotationDefault obj) {\n+    public void visitParameterAnnotation(final ParameterAnnotations obj)\n+    {\n@@ -52,1 +56,2 @@\n-    public void visitAnnotationEntry(final AnnotationEntry obj) {\n+    public void visitAnnotationEntry(final AnnotationEntry obj)\n+    {\n@@ -59,1 +64,2 @@\n-    public void visitBootstrapMethods(final BootstrapMethods obj) {\n+    public void visitAnnotationDefault(final AnnotationDefault obj)\n+    {\n@@ -63,1 +69,2 @@\n-    public void visitCode(final Code obj) {\n+    public void visitCode(final Code obj)\n+    {\n@@ -67,1 +74,2 @@\n-    public void visitCodeException(final CodeException obj) {\n+    public void visitCodeException(final CodeException obj)\n+    {\n@@ -71,1 +79,2 @@\n-    public void visitConstantClass(final ConstantClass obj) {\n+    public void visitConstantClass(final ConstantClass obj)\n+    {\n@@ -75,1 +84,2 @@\n-    public void visitConstantDouble(final ConstantDouble obj) {\n+    public void visitConstantDouble(final ConstantDouble obj)\n+    {\n@@ -78,3 +88,0 @@\n-    \/**\n-     * @since 6.3\n-     *\/\n@@ -82,1 +89,2 @@\n-    public void visitConstantDynamic(final ConstantDynamic obj) {\n+    public void visitConstantFieldref(final ConstantFieldref obj)\n+    {\n@@ -86,1 +94,2 @@\n-    public void visitConstantFieldref(final ConstantFieldref obj) {\n+    public void visitConstantFloat(final ConstantFloat obj)\n+    {\n@@ -90,1 +99,2 @@\n-    public void visitConstantFloat(final ConstantFloat obj) {\n+    public void visitConstantInteger(final ConstantInteger obj)\n+    {\n@@ -94,1 +104,2 @@\n-    public void visitConstantInteger(final ConstantInteger obj) {\n+    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj)\n+    {\n@@ -98,1 +109,2 @@\n-    public void visitConstantInterfaceMethodref(final ConstantInterfaceMethodref obj) {\n+    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic obj)\n+    {\n@@ -102,1 +114,2 @@\n-    public void visitConstantInvokeDynamic(final ConstantInvokeDynamic obj) {\n+    public void visitConstantLong(final ConstantLong obj)\n+    {\n@@ -106,1 +119,2 @@\n-    public void visitConstantLong(final ConstantLong obj) {\n+    public void visitConstantMethodref(final ConstantMethodref obj)\n+    {\n@@ -109,3 +123,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -113,5 +124,2 @@\n-    public void visitConstantMethodHandle(final ConstantMethodHandle constantMethodHandle) {\n-    }\n-\n-    @Override\n-    public void visitConstantMethodref(final ConstantMethodref obj) {\n+    public void visitConstantNameAndType(final ConstantNameAndType obj)\n+    {\n@@ -120,3 +128,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -124,1 +129,2 @@\n-    public void visitConstantMethodType(final ConstantMethodType obj) {\n+    public void visitConstantPool(final ConstantPool obj)\n+    {\n@@ -127,3 +133,0 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n@@ -131,1 +134,2 @@\n-    public void visitConstantModule(final ConstantModule constantModule) {\n+    public void visitConstantString(final ConstantString obj)\n+    {\n@@ -135,1 +139,2 @@\n-    public void visitConstantNameAndType(final ConstantNameAndType obj) {\n+    public void visitConstantUtf8(final ConstantUtf8 obj)\n+    {\n@@ -138,3 +143,0 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n@@ -142,1 +144,2 @@\n-    public void visitConstantPackage(final ConstantPackage constantPackage) {\n+    public void visitConstantValue(final ConstantValue obj)\n+    {\n@@ -146,1 +149,2 @@\n-    public void visitConstantPool(final ConstantPool obj) {\n+    public void visitDeprecated(final Deprecated obj)\n+    {\n@@ -150,1 +154,2 @@\n-    public void visitConstantString(final ConstantString obj) {\n+    public void visitExceptionTable(final ExceptionTable obj)\n+    {\n@@ -154,1 +159,2 @@\n-    public void visitConstantUtf8(final ConstantUtf8 obj) {\n+    public void visitField(final Field obj)\n+    {\n@@ -158,1 +164,2 @@\n-    public void visitConstantValue(final ConstantValue obj) {\n+    public void visitInnerClass(final InnerClass obj)\n+    {\n@@ -162,1 +169,2 @@\n-    public void visitDeprecated(final Deprecated obj) {\n+    public void visitInnerClasses(final InnerClasses obj)\n+    {\n@@ -169,1 +177,2 @@\n-    public void visitEnclosingMethod(final EnclosingMethod obj) {\n+    public void visitBootstrapMethods(final BootstrapMethods obj)\n+    {\n@@ -173,1 +182,2 @@\n-    public void visitExceptionTable(final ExceptionTable obj) {\n+    public void visitJavaClass(final JavaClass obj)\n+    {\n@@ -177,1 +187,2 @@\n-    public void visitField(final Field obj) {\n+    public void visitLineNumber(final LineNumber obj)\n+    {\n@@ -181,1 +192,2 @@\n-    public void visitInnerClass(final InnerClass obj) {\n+    public void visitLineNumberTable(final LineNumberTable obj)\n+    {\n@@ -185,1 +197,2 @@\n-    public void visitInnerClasses(final InnerClasses obj) {\n+    public void visitLocalVariable(final LocalVariable obj)\n+    {\n@@ -189,1 +202,2 @@\n-    public void visitJavaClass(final JavaClass obj) {\n+    public void visitLocalVariableTable(final LocalVariableTable obj)\n+    {\n@@ -193,1 +207,2 @@\n-    public void visitLineNumber(final LineNumber obj) {\n+    public void visitMethod(final Method obj)\n+    {\n@@ -197,1 +212,2 @@\n-    public void visitLineNumberTable(final LineNumberTable obj) {\n+    public void visitSignature(final Signature obj)\n+    {\n@@ -201,1 +217,2 @@\n-    public void visitLocalVariable(final LocalVariable obj) {\n+    public void visitSourceFile(final SourceFile obj)\n+    {\n@@ -205,1 +222,7 @@\n-    public void visitLocalVariableTable(final LocalVariableTable obj) {\n+    public void visitSynthetic(final Synthetic obj)\n+    {\n+    }\n+\n+    @Override\n+    public void visitUnknown(final Unknown obj)\n+    {\n@@ -208,3 +231,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n@@ -212,1 +232,2 @@\n-    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj) {\n+    public void visitStackMap(final StackMap obj)\n+    {\n@@ -216,1 +237,2 @@\n-    public void visitMethod(final Method obj) {\n+    public void visitStackMapEntry(final StackMapEntry obj)\n+    {\n@@ -221,1 +243,4 @@\n-     * @Override public void visitStackMapTable(StackMapTable obj) { }\n+    @Override\n+    public void visitStackMapTable(StackMapTable obj)\n+    {\n+    }\n@@ -226,1 +251,4 @@\n-     * @Override public void visitStackMapTableEntry(StackMapTableEntry obj) { }\n+    @Override\n+    public void visitStackMapTableEntry(StackMapTableEntry obj)\n+    {\n+    }\n@@ -230,1 +258,1 @@\n-     * @since 6.4.0\n+     * @since 6.0\n@@ -233,1 +261,2 @@\n-    public void visitMethodParameter(final MethodParameter obj) {\n+    public void visitEnclosingMethod(final EnclosingMethod obj)\n+    {\n@@ -240,1 +269,2 @@\n-    public void visitMethodParameters(final MethodParameters obj) {\n+    public void visitLocalVariableTypeTable(final LocalVariableTypeTable obj)\n+    {\n@@ -243,1 +273,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -245,1 +277,2 @@\n-    public void visitModule(final Module obj) {\n+    public void visitMethodParameters(final MethodParameters obj)\n+    {\n@@ -248,1 +281,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.4.0\n+     *\/\n@@ -250,1 +285,2 @@\n-    public void visitModuleExports(final ModuleExports obj) {\n+    public void visitMethodParameter(final MethodParameter obj)\n+    {\n@@ -253,1 +289,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -255,1 +293,2 @@\n-    public void visitModuleMainClass(final ModuleMainClass obj) {\n+    public void visitConstantMethodType(final ConstantMethodType obj)\n+    {\n@@ -258,1 +297,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -260,1 +301,1 @@\n-    public void visitModuleOpens(final ModuleOpens obj) {\n+    public void visitConstantMethodHandle(final ConstantMethodHandle constantMethodHandle) {\n@@ -263,1 +304,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -265,1 +308,1 @@\n-    public void visitModulePackages(final ModulePackages obj) {\n+    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry parameterAnnotationEntry) {\n@@ -268,1 +311,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.1\n+     *\/\n@@ -270,1 +315,1 @@\n-    public void visitModuleProvides(final ModuleProvides obj) {\n+    public void visitConstantPackage(final ConstantPackage constantPackage) {\n@@ -273,1 +318,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.1\n+     *\/\n@@ -275,1 +322,1 @@\n-    public void visitModuleRequires(final ModuleRequires obj) {\n+    public void visitConstantModule(final ConstantModule constantModule) {\n@@ -278,1 +325,3 @@\n-    \/** @since 6.4.0 *\/\n+    \/**\n+     * @since 6.3\n+     *\/\n@@ -280,1 +329,1 @@\n-    public void visitNestHost(final NestHost obj) {\n+    public void visitConstantDynamic(final ConstantDynamic obj) {\n@@ -285,1 +334,1 @@\n-    public void visitNestMembers(final NestMembers obj) {\n+    public void visitModule(final Module obj) {\n@@ -288,3 +337,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -292,1 +339,1 @@\n-    public void visitParameterAnnotation(final ParameterAnnotations obj) {\n+    public void visitModuleRequires(final ModuleRequires obj) {\n@@ -295,3 +342,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+    \/** @since 6.4.0 *\/\n@@ -299,1 +344,1 @@\n-    public void visitParameterAnnotationEntry(final ParameterAnnotationEntry parameterAnnotationEntry) {\n+    public void visitModuleExports(final ModuleExports obj) {\n@@ -302,0 +347,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -303,1 +349,1 @@\n-    public void visitSignature(final Signature obj) {\n+    public void visitModuleOpens(final ModuleOpens obj) {\n@@ -306,0 +352,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -307,1 +354,1 @@\n-    public void visitSourceFile(final SourceFile obj) {\n+    public void visitModuleProvides(final ModuleProvides obj) {\n@@ -310,0 +357,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -311,1 +359,1 @@\n-    public void visitStackMap(final StackMap obj) {\n+    public void visitModulePackages(final ModulePackages obj) {\n@@ -314,0 +362,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -315,1 +364,1 @@\n-    public void visitStackMapEntry(final StackMapEntry obj) {\n+    public void visitModuleMainClass(final ModuleMainClass obj) {\n@@ -318,0 +367,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -319,1 +369,1 @@\n-    public void visitSynthetic(final Synthetic obj) {\n+    public void visitNestHost(final NestHost obj) {\n@@ -322,0 +372,1 @@\n+    \/** @since 6.4.0 *\/\n@@ -323,1 +374,1 @@\n-    public void visitUnknown(final Unknown obj) {\n+    public void visitNestMembers(final NestMembers obj) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EmptyVisitor.java","additions":150,"deletions":99,"binary":false,"changes":249,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,1 +31,2 @@\n- * This attribute exists for local or anonymous classes and ... there can be only one.\n+ * This attribute exists for local or\n+ * anonymous classes and ... there can be only one.\n@@ -44,1 +44,1 @@\n-    \/\/ Otherwise, the value of the method_index item must point to a\n+    \/\/ Otherwise, the value of the  method_index item must point to a\n@@ -47,1 +47,1 @@\n-    \/\/ to in the class_index. *It is the compiler responsibility* to\n+    \/\/ to in the class_index.  *It is the compiler responsibility* to\n@@ -57,4 +57,4 @@\n-    private EnclosingMethod(final int nameIndex, final int len, final int classIndex, final int methodIndex, final ConstantPool cpool) {\n-        super(Const.ATTR_ENCLOSING_METHOD, nameIndex, Args.require(len, 4, \"EnclosingMethod attribute length\"), cpool);\n-        this.classIndex = Args.requireU2(classIndex, 0, cpool.getLength(), \"EnclosingMethod class index\");\n-        this.methodIndex = Args.requireU2(methodIndex, \"EnclosingMethod method index\");\n+    private EnclosingMethod(final int nameIndex, final int len, final int classIdx,final int methodIdx, final ConstantPool cpool) {\n+        super(Const.ATTR_ENCLOSING_METHOD, nameIndex, len, cpool);\n+        classIndex  = classIdx;\n+        methodIndex = methodIdx;\n@@ -65,1 +65,1 @@\n-        v.visitEnclosingMethod(this);\n+      v.visitEnclosingMethod(this);\n@@ -69,1 +69,1 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool constant_pool) {\n@@ -73,11 +73,0 @@\n-    @Override\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        super.dump(file);\n-        file.writeShort(classIndex);\n-        file.writeShort(methodIndex);\n-    }\n-\n-    public final ConstantClass getEnclosingClass() {\n-        return super.getConstantPool().getConstant(classIndex, Const.CONSTANT_Class, ConstantClass.class);\n-    }\n-\n@@ -89,7 +78,0 @@\n-    public final ConstantNameAndType getEnclosingMethod() {\n-        if (methodIndex == 0) {\n-            return null;\n-        }\n-        return super.getConstantPool().getConstant(methodIndex, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-    }\n-\n@@ -107,0 +89,22 @@\n+\n+    public final ConstantClass getEnclosingClass() {\n+        final ConstantClass c =\n+            (ConstantClass)super.getConstantPool().getConstant(classIndex,Const.CONSTANT_Class);\n+        return c;\n+    }\n+\n+    public final ConstantNameAndType getEnclosingMethod() {\n+        if (methodIndex == 0) {\n+            return null;\n+        }\n+        final ConstantNameAndType nat =\n+            (ConstantNameAndType)super.getConstantPool().getConstant(methodIndex,Const.CONSTANT_NameAndType);\n+        return nat;\n+    }\n+\n+    @Override\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        super.dump(file);\n+        file.writeShort(classIndex);\n+        file.writeShort(methodIndex);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EnclosingMethod.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -30,1 +32,2 @@\n-public class EnumElementValue extends ElementValue {\n+public class EnumElementValue extends ElementValue\n+{\n@@ -36,1 +39,3 @@\n-    public EnumElementValue(final int type, final int typeIdx, final int valueIdx, final ConstantPool cpool) {\n+    public EnumElementValue(final int type, final int typeIdx, final int valueIdx,\n+            final ConstantPool cpool)\n+    {\n@@ -39,1 +44,2 @@\n-            throw new ClassFormatException(\"Only element values of type enum can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type enum can be built with this ctor - type specified: \" + type);\n@@ -46,1 +52,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -52,2 +59,6 @@\n-    public String getEnumTypeString() {\n-        return super.getConstantPool().getConstantUtf8(typeIdx).getBytes();\n+    @Override\n+    public String stringifyValue()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(valueIdx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\n@@ -56,2 +67,5 @@\n-    public String getEnumValueString() {\n-        return super.getConstantPool().getConstantUtf8(valueIdx).getBytes();\n+    public String getEnumTypeString()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(typeIdx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\/\/ Utility.signatureToString(cu8.getBytes());\n@@ -60,2 +74,5 @@\n-    public int getTypeIndex() {\n-        return typeIdx;\n+    public String getEnumValueString()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) super.getConstantPool().getConstant(valueIdx,\n+                Const.CONSTANT_Utf8);\n+        return cu8.getBytes();\n@@ -64,1 +81,2 @@\n-    public int getValueIndex() {\n+    public int getValueIndex()\n+    {\n@@ -68,3 +86,3 @@\n-    @Override\n-    public String stringifyValue() {\n-        return super.getConstantPool().getConstantUtf8(valueIdx).getBytes();\n+    public int getTypeIndex()\n+    {\n+        return typeIdx;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/EnumElementValue.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,4 +31,6 @@\n- * This class represents the table of exceptions that are thrown by a method. This attribute may be used once per\n- * method. The name of this class is <em>ExceptionTable<\/em> for historical reasons; The Java Virtual Machine\n- * Specification, Second Edition defines this attribute using the name <em>Exceptions<\/em> (which is inconsistent with\n- * the other classes).\n+ * This class represents the table of exceptions that are thrown by a\n+ * method. This attribute may be used once per method.  The name of\n+ * this class is <em>ExceptionTable<\/em> for historical reasons; The\n+ * Java Virtual Machine Specification, Second Edition defines this\n+ * attribute using the name <em>Exceptions<\/em> (which is inconsistent\n+ * with the other classes).\n@@ -37,10 +38,1 @@\n- * <pre>\n- * Exceptions_attribute {\n- *   u2 attribute_name_index;\n- *   u4 attribute_length;\n- *   u2 number_of_exceptions;\n- *   u2 exception_index_table[number_of_exceptions];\n- * }\n- * <\/pre>\n- * @see Code\n- * @LastModified: Feb 2023\n+ * @see     Code\n@@ -52,0 +44,1 @@\n+\n@@ -53,4 +46,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -62,0 +53,14 @@\n+\n+    \/**\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param exceptionIndexTable Table of indices in constant pool\n+     * @param constant_pool Array of constants\n+     *\/\n+    public ExceptionTable(final int name_index, final int length, final int[] exceptionIndexTable,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_EXCEPTIONS, name_index, length, constant_pool);\n+        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : new int[0];\n+    }\n+\n+\n@@ -64,1 +69,0 @@\n-     *\n@@ -69,1 +73,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -73,3 +77,3 @@\n-        final int exceptionCount = input.readUnsignedShort();\n-        exceptionIndexTable = new int[exceptionCount];\n-        for (int i = 0; i < exceptionCount; i++) {\n+        final int number_of_exceptions = input.readUnsignedShort();\n+        exceptionIndexTable = new int[number_of_exceptions];\n+        for (int i = 0; i < number_of_exceptions; i++) {\n@@ -80,11 +84,0 @@\n-    \/**\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param exceptionIndexTable Table of indices in constant pool\n-     * @param constantPool Array of constants\n-     *\/\n-    public ExceptionTable(final int nameIndex, final int length, final int[] exceptionIndexTable, final ConstantPool constantPool) {\n-        super(Const.ATTR_EXCEPTIONS, nameIndex, length, constantPool);\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n-        Args.requireU2(this.exceptionIndexTable.length, \"exceptionIndexTable.length\");\n-    }\n@@ -93,2 +86,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -99,1 +93,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -103,12 +97,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ExceptionTable c = (ExceptionTable) clone();\n-        if (exceptionIndexTable != null) {\n-            c.exceptionIndexTable = exceptionIndexTable.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -120,1 +102,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -123,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -131,0 +113,1 @@\n+\n@@ -138,0 +121,9 @@\n+\n+    \/**\n+     * @return Length of exception table.\n+     *\/\n+    public int getNumberOfExceptions() {\n+        return exceptionIndexTable == null ? 0 : exceptionIndexTable.length;\n+    }\n+\n+\n@@ -143,1 +135,4 @@\n-        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(exceptionIndexTable[i], Const.CONSTANT_Class)));\n+        for (int i = 0; i < exceptionIndexTable.length; i++) {\n+            names[i] = super.getConstantPool().getConstantString(exceptionIndexTable[i],\n+                    Const.CONSTANT_Class).replace('\/', '.');\n+        }\n@@ -147,6 +142,0 @@\n-    \/**\n-     * @return Length of exception table.\n-     *\/\n-    public int getNumberOfExceptions() {\n-        return exceptionIndexTable == null ? 0 : exceptionIndexTable.length;\n-    }\n@@ -155,2 +144,2 @@\n-     * @param exceptionIndexTable the list of exception indexes Also redefines number_of_exceptions according to table\n-     *        length.\n+     * @param exceptionIndexTable the list of exception indexes\n+     * Also redefines number_of_exceptions according to table length.\n@@ -158,2 +147,2 @@\n-    public void setExceptionIndexTable(final int[] exceptionIndexTable) {\n-        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : Const.EMPTY_INT_ARRAY;\n+    public void setExceptionIndexTable( final int[] exceptionIndexTable ) {\n+        this.exceptionIndexTable = exceptionIndexTable != null ? exceptionIndexTable : new int[0];\n@@ -162,0 +151,1 @@\n+\n@@ -179,0 +169,16 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ExceptionTable c = (ExceptionTable) clone();\n+        if (exceptionIndexTable != null) {\n+            c.exceptionIndexTable = new int[exceptionIndexTable.length];\n+            System.arraycopy(exceptionIndexTable, 0, c.exceptionIndexTable, 0,\n+                    exceptionIndexTable.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ExceptionTable.java","additions":71,"deletions":65,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -33,2 +33,3 @@\n- * This class represents the field info structure, i.e., the representation for a variable in the class. See JVM\n- * specification for details.\n+ * This class represents the field info structure, i.e., the representation\n+ * for a variable in the class. See JVM specification for details.\n+ *\n@@ -38,7 +39,0 @@\n-    \/**\n-     * Empty array constant.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final Field[] EMPTY_ARRAY = {};\n-\n@@ -48,1 +42,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -51,1 +45,2 @@\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -54,0 +49,1 @@\n+\n@@ -55,1 +51,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -61,4 +57,0 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    static final Field[] EMPTY_FIELD_ARRAY = {};\n@@ -67,1 +59,2 @@\n-     * @return Comparison strategy object\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -69,2 +62,2 @@\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n+    public Field(final Field c) {\n+        super(c);\n@@ -73,6 +66,0 @@\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n@@ -82,1 +69,0 @@\n-     *\n@@ -85,2 +71,3 @@\n-    Field(final DataInput file, final ConstantPool constantPool) throws IOException, ClassFormatException {\n-        super(file, constantPool);\n+    Field(final DataInput file, final ConstantPool constant_pool) throws IOException,\n+            ClassFormatException {\n+        super(file, constant_pool);\n@@ -89,9 +76,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Field(final Field c) {\n-        super(c);\n-    }\n@@ -100,3 +78,3 @@\n-     * @param accessFlags Access rights of field\n-     * @param nameIndex Points to field name in constant pool\n-     * @param signatureIndex Points to encoded signature\n+     * @param access_flags Access rights of field\n+     * @param name_index Points to field name in constant pool\n+     * @param signature_index Points to encoded signature\n@@ -104,1 +82,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -106,2 +84,3 @@\n-    public Field(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes, final ConstantPool constantPool) {\n-        super(accessFlags, nameIndex, signatureIndex, attributes, constantPool);\n+    public Field(final int access_flags, final int name_index, final int signature_index, final Attribute[] attributes,\n+            final ConstantPool constant_pool) {\n+        super(access_flags, name_index, signature_index, attributes, constant_pool);\n@@ -110,0 +89,1 @@\n+\n@@ -111,2 +91,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -117,1 +98,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -121,17 +102,0 @@\n-    \/**\n-     * @return deep copy of this field\n-     *\/\n-    public Field copy(final ConstantPool constantPool) {\n-        return (Field) copy_(constantPool);\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two Field objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n@@ -151,6 +115,0 @@\n-    \/**\n-     * @return type of field\n-     *\/\n-    public Type getType() {\n-        return Type.getReturnType(getSignature());\n-    }\n@@ -159,12 +117,2 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    \/**\n-     * Return string representation close to declaration format, 'public static final short MAX = 100', e.g..\n+     * Return string representation close to declaration format,\n+     * `public static final short MAX = 100', e.g..\n@@ -182,1 +130,1 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n@@ -198,0 +146,57 @@\n+\n+\n+    \/**\n+     * @return deep copy of this field\n+     *\/\n+    public Field copy( final ConstantPool _constant_pool ) {\n+        return (Field) copy_(_constant_pool);\n+    }\n+\n+\n+    \/**\n+     * @return type of field\n+     *\/\n+    public Type getType() {\n+        return Type.getReturnType(getSignature());\n+    }\n+\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two Field objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the field's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Field.java","additions":87,"deletions":82,"binary":false,"changes":169,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n-import java.util.Arrays;\n+\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -34,24 +35,4 @@\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int name_index; \/\/ Points to field name in constant pool\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected int signature_index; \/\/ Points to encoded signature\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected Attribute[] attributes; \/\/ Collection of attributes\n-\n-    \/**\n-     * @deprecated (since 6.0) will be removed (not needed)\n-     *\/\n-    @java.lang.Deprecated\n-    protected int attributes_count; \/\/ No. of attributes\n+    private int name_index; \/\/ Points to field name in constant pool\n+    private int signature_index; \/\/ Points to encoded signature\n+    private Attribute[] attributes; \/\/ Collection of attributes\n+    private int attributes_count; \/\/ No. of attributes\n@@ -62,5 +43,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @java.lang.Deprecated\n-    protected ConstantPool constant_pool;\n+    private ConstantPool constant_pool;\n@@ -68,2 +45,2 @@\n-    private String signatureAttributeString;\n-    private boolean searchedForSignatureAttribute;\n+    private String signatureAttributeString = null;\n+    private boolean searchedForSignatureAttribute = false;\n@@ -74,0 +51,1 @@\n+\n@@ -75,4 +53,2 @@\n-     * Construct object from file stream.\n-     *\n-     * @param file Input stream\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -80,8 +56,3 @@\n-    protected FieldOrMethod(final DataInput file, final ConstantPool constantPool) throws IOException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null, constantPool);\n-        final int attributesCount = file.readUnsignedShort();\n-        attributes = new Attribute[attributesCount];\n-        for (int i = 0; i < attributesCount; i++) {\n-            attributes[i] = Attribute.readAttribute(file, constantPool);\n-        }\n-        this.attributes_count = attributesCount; \/\/ init deprecated field\n+    protected FieldOrMethod(final FieldOrMethod c) {\n+        this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(),\n+                c.getAttributes(), c.getConstantPool());\n@@ -90,0 +61,1 @@\n+\n@@ -94,1 +66,2 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -98,2 +71,4 @@\n-    protected FieldOrMethod(final DataInputStream file, final ConstantPool constantPool) throws IOException {\n-        this((DataInput) file, constantPool);\n+    protected FieldOrMethod(final DataInputStream file, final ConstantPool constant_pool)\n+            throws IOException,\n+            ClassFormatException {\n+        this((DataInput) file, constant_pool);\n@@ -103,4 +78,4 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from file stream.\n+     * @param file Input stream\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -108,2 +83,10 @@\n-    protected FieldOrMethod(final FieldOrMethod c) {\n-        this(c.getAccessFlags(), c.getNameIndex(), c.getSignatureIndex(), c.getAttributes(), c.getConstantPool());\n+    protected FieldOrMethod(final DataInput file, final ConstantPool constant_pool)\n+            throws IOException, ClassFormatException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), null,\n+                constant_pool);\n+        final int attributes_count = file.readUnsignedShort();\n+        attributes = new Attribute[attributes_count];\n+        for (int i = 0; i < attributes_count; i++) {\n+            attributes[i] = Attribute.readAttribute(file, constant_pool);\n+        }\n+        this.attributes_count = attributes_count; \/\/ init deprecated field\n@@ -112,0 +95,1 @@\n+\n@@ -113,3 +97,3 @@\n-     * @param accessFlags Access rights of method\n-     * @param nameIndex Points to field name in constant pool\n-     * @param signatureIndex Points to encoded signature\n+     * @param access_flags Access rights of method\n+     * @param name_index Points to field name in constant pool\n+     * @param signature_index Points to encoded signature\n@@ -117,1 +101,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -119,6 +103,6 @@\n-    protected FieldOrMethod(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes,\n-        final ConstantPool constantPool) {\n-        super(accessFlags);\n-        this.name_index = nameIndex;\n-        this.signature_index = signatureIndex;\n-        this.constant_pool = constantPool;\n+    protected FieldOrMethod(final int access_flags, final int name_index, final int signature_index,\n+            final Attribute[] attributes, final ConstantPool constant_pool) {\n+        super(access_flags);\n+        this.name_index = name_index;\n+        this.signature_index = signature_index;\n+        this.constant_pool = constant_pool;\n@@ -128,15 +112,0 @@\n-    \/**\n-     * @return deep copy of this field\n-     *\/\n-    protected FieldOrMethod copy_(final ConstantPool constantPool) {\n-        try {\n-            final FieldOrMethod c = (FieldOrMethod) clone();\n-            c.constant_pool = constantPool;\n-            c.attributes = new Attribute[attributes.length];\n-            c.attributes_count = attributes_count; \/\/ init deprecated field\n-            Arrays.setAll(c.attributes, i -> attributes[i].copy(constantPool));\n-            return c;\n-        } catch (final CloneNotSupportedException e) {\n-            throw new IllegalStateException(e);\n-        }\n-    }\n@@ -148,1 +117,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -162,11 +131,0 @@\n-    \/**\n-     * @return Annotations on the field or method\n-     * @since 6.0\n-     *\/\n-    public AnnotationEntry[] getAnnotationEntries() {\n-        if (annotationEntries == null) {\n-            annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());\n-        }\n-\n-        return annotationEntries;\n-    }\n@@ -181,0 +139,1 @@\n+\n@@ -182,1 +141,1 @@\n-     * @return Constant pool used by this object.\n+     * @param attributes Collection of object attributes.\n@@ -184,2 +143,3 @@\n-    public final ConstantPool getConstantPool() {\n-        return constant_pool;\n+    public final void setAttributes( final Attribute[] attributes ) {\n+        this.attributes = attributes;\n+        this.attributes_count = attributes != null ? attributes.length : 0; \/\/ init deprecated field\n@@ -188,0 +148,1 @@\n+\n@@ -189,5 +150,1 @@\n-     * Hunts for a signature attribute on the member and returns its contents. So where the 'regular' signature may be\n-     * (Ljava\/util\/Vector;)V the signature attribute may in fact say 'Ljava\/lang\/Vector&lt;Ljava\/lang\/String&gt;;' Coded for\n-     * performance - searches for the attribute only when requested - only searches for it once.\n-     *\n-     * @since 6.0\n+     * @return Constant pool used by this object.\n@@ -195,12 +152,2 @@\n-    public final String getGenericSignature() {\n-        if (!searchedForSignatureAttribute) {\n-            boolean found = false;\n-            for (int i = 0; !found && i < attributes.length; i++) {\n-                if (attributes[i] instanceof Signature) {\n-                    signatureAttributeString = ((Signature) attributes[i]).getSignature();\n-                    found = true;\n-                }\n-            }\n-            searchedForSignatureAttribute = true;\n-        }\n-        return signatureAttributeString;\n+    public final ConstantPool getConstantPool() {\n+        return constant_pool;\n@@ -209,0 +156,1 @@\n+\n@@ -210,1 +158,1 @@\n-     * @return Name of object, i.e., method name or field name\n+     * @param constant_pool Constant pool to be used for this object.\n@@ -212,2 +160,2 @@\n-    public final String getName() {\n-        return constant_pool.getConstantUtf8(name_index).getBytes();\n+    public final void setConstantPool( final ConstantPool constant_pool ) {\n+        this.constant_pool = constant_pool;\n@@ -216,0 +164,1 @@\n+\n@@ -223,0 +172,1 @@\n+\n@@ -224,1 +174,1 @@\n-     * @return String representation of object's type signature (java style)\n+     * @param name_index Index in constant pool of object's name.\n@@ -226,2 +176,2 @@\n-    public final String getSignature() {\n-        return constant_pool.getConstantUtf8(signature_index).getBytes();\n+    public final void setNameIndex( final int name_index ) {\n+        this.name_index = name_index;\n@@ -230,0 +180,1 @@\n+\n@@ -237,0 +188,1 @@\n+\n@@ -238,1 +190,1 @@\n-     * @param attributes Collection of object attributes.\n+     * @param signature_index Index in constant pool of field signature.\n@@ -240,3 +192,2 @@\n-    public final void setAttributes(final Attribute[] attributes) {\n-        this.attributes = attributes;\n-        this.attributes_count = attributes != null ? attributes.length : 0; \/\/ init deprecated field\n+    public final void setSignatureIndex( final int signature_index ) {\n+        this.signature_index = signature_index;\n@@ -245,0 +196,1 @@\n+\n@@ -246,1 +198,1 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * @return Name of object, i.e., method name or field name\n@@ -248,2 +200,4 @@\n-    public final void setConstantPool(final ConstantPool constantPool) {\n-        this.constant_pool = constantPool;\n+    public final String getName() {\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -252,0 +206,1 @@\n+\n@@ -253,1 +208,1 @@\n-     * @param nameIndex Index in constant pool of object's name.\n+     * @return String representation of object's type signature (java style)\n@@ -255,2 +210,4 @@\n-    public final void setNameIndex(final int nameIndex) {\n-        this.name_index = nameIndex;\n+    public final String getSignature() {\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constant_pool.getConstant(signature_index, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -259,0 +216,1 @@\n+\n@@ -260,1 +218,1 @@\n-     * @param signatureIndex Index in constant pool of field signature.\n+     * @return deep copy of this field\n@@ -262,2 +220,59 @@\n-    public final void setSignatureIndex(final int signatureIndex) {\n-        this.signature_index = signatureIndex;\n+    protected FieldOrMethod copy_( final ConstantPool _constant_pool ) {\n+        FieldOrMethod c = null;\n+\n+        try {\n+          c = (FieldOrMethod)clone();\n+        } catch(final CloneNotSupportedException e) {\n+            \/\/ ignored, but will cause NPE ...\n+        }\n+\n+        c.constant_pool    = constant_pool;\n+        c.attributes       = new Attribute[attributes.length];\n+        c.attributes_count = attributes_count; \/\/ init deprecated field\n+\n+        for (int i = 0; i < attributes.length; i++) {\n+            c.attributes[i] = attributes[i].copy(constant_pool);\n+        }\n+\n+        return c;\n+    }\n+\n+    \/**\n+     * @return Annotations on the field or method\n+     * @since 6.0\n+     *\/\n+    public AnnotationEntry[] getAnnotationEntries() {\n+        if (annotationEntries == null) {\n+            annotationEntries = AnnotationEntry.createAnnotationEntries(getAttributes());\n+        }\n+\n+        return annotationEntries;\n+    }\n+\n+    \/**\n+     * Hunts for a signature attribute on the member and returns its contents.\n+     * So where the 'regular' signature may be (Ljava\/util\/Vector;)V the\n+     * signature attribute may in fact say\n+     * 'Ljava\/lang\/Vector&lt;Ljava\/lang\/String&gt;;' Coded for performance -\n+     * searches for the attribute only when requested - only searches for it\n+     * once.\n+     *\n+     * @since 6.0\n+     *\/\n+    public final String getGenericSignature()\n+    {\n+        if (!searchedForSignatureAttribute)\n+        {\n+            boolean found = false;\n+            for (int i = 0; !found && i < attributes.length; i++)\n+            {\n+                if (attributes[i] instanceof Signature)\n+                {\n+                    signatureAttributeString = ((Signature) attributes[i])\n+                            .getSignature();\n+                    found = true;\n+                }\n+            }\n+            searchedForSignatureAttribute = true;\n+        }\n+        return signatureAttributeString;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/FieldOrMethod.java","additions":144,"deletions":129,"binary":false,"changes":273,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * This class represents a inner class attribute, i.e., the class indices of the inner and outer classes, the name and\n- * the attributes of the inner class.\n+ * This class represents a inner class attribute, i.e., the class\n+ * indices of the inner and outer classes, the name and the attributes\n+ * of the inner class.\n@@ -43,0 +44,1 @@\n+\n@@ -44,4 +46,1 @@\n-     * Construct object from file stream.\n-     *\n-     * @param file Input stream\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object.\n@@ -49,2 +48,3 @@\n-    InnerClass(final DataInput file) throws IOException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort());\n+    public InnerClass(final InnerClass c) {\n+        this(c.getInnerClassIndex(), c.getOuterClassIndex(), c.getInnerNameIndex(), c\n+                .getInnerAccessFlags());\n@@ -53,0 +53,1 @@\n+\n@@ -54,3 +55,3 @@\n-     * Initialize from another object.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from file stream.\n+     * @param file Input stream\n+     * @throws IOException\n@@ -58,2 +59,3 @@\n-    public InnerClass(final InnerClass c) {\n-        this(c.getInnerClassIndex(), c.getOuterClassIndex(), c.getInnerNameIndex(), c.getInnerAccessFlags());\n+    InnerClass(final DataInput file) throws IOException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n+                .readUnsignedShort());\n@@ -62,0 +64,1 @@\n+\n@@ -65,1 +68,1 @@\n-     * @param innerNameIndex Name index in constant pool of inner class\n+     * @param innerNameIndex  Name index in constant pool of inner class\n@@ -68,1 +71,2 @@\n-    public InnerClass(final int innerClassIndex, final int outerClassIndex, final int innerNameIndex, final int innerAccessFlags) {\n+    public InnerClass(final int innerClassIndex, final int outerClassIndex, final int innerNameIndex,\n+            final int innerAccessFlags) {\n@@ -75,0 +79,1 @@\n+\n@@ -76,2 +81,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -82,1 +88,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -86,11 +92,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public InnerClass copy() {\n-        try {\n-            return (InnerClass) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -102,1 +97,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -104,1 +99,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -111,0 +106,1 @@\n+\n@@ -118,0 +114,1 @@\n+\n@@ -125,0 +122,1 @@\n+\n@@ -132,0 +130,1 @@\n+\n@@ -139,0 +138,1 @@\n+\n@@ -142,1 +142,1 @@\n-    public void setInnerAccessFlags(final int innerAccessFlags) {\n+    public void setInnerAccessFlags( final int innerAccessFlags ) {\n@@ -146,0 +146,1 @@\n+\n@@ -149,1 +150,1 @@\n-    public void setInnerClassIndex(final int innerClassIndex) {\n+    public void setInnerClassIndex( final int innerClassIndex ) {\n@@ -153,0 +154,1 @@\n+\n@@ -156,1 +158,1 @@\n-    public void setInnerNameIndex(final int innerNameIndex) { \/\/ TODO unused\n+    public void setInnerNameIndex( final int innerNameIndex ) { \/\/ TODO unused\n@@ -160,0 +162,1 @@\n+\n@@ -163,1 +166,1 @@\n-    public void setOuterClassIndex(final int outerClassIndex) { \/\/ TODO unused\n+    public void setOuterClassIndex( final int outerClassIndex ) { \/\/ TODO unused\n@@ -167,0 +170,1 @@\n+\n@@ -172,1 +176,2 @@\n-        return \"InnerClass(\" + innerClassIndex + \", \" + outerClassIndex + \", \" + innerNameIndex + \", \" + innerAccessFlags + \")\";\n+        return \"InnerClass(\" + innerClassIndex + \", \" + outerClassIndex + \", \"\n+                + innerNameIndex + \", \" + innerAccessFlags + \")\";\n@@ -175,0 +180,1 @@\n+\n@@ -178,5 +184,6 @@\n-    public String toString(final ConstantPool constantPool) {\n-        String outerClassName;\n-        String innerName;\n-        String innerClassName = constantPool.getConstantString(innerClassIndex, Const.CONSTANT_Class);\n-        innerClassName = Utility.compactClassName(innerClassName, false);\n+    public String toString( final ConstantPool constantPool ) {\n+        String outer_class_name;\n+        String inner_name;\n+        String inner_class_name = constantPool.getConstantString(innerClassIndex,\n+                Const.CONSTANT_Class);\n+        inner_class_name = Utility.compactClassName(inner_class_name, false);\n@@ -184,2 +191,3 @@\n-            outerClassName = constantPool.getConstantString(outerClassIndex, Const.CONSTANT_Class);\n-            outerClassName = \" of class \" + Utility.compactClassName(outerClassName, false);\n+            outer_class_name = constantPool.getConstantString(outerClassIndex,\n+                    Const.CONSTANT_Class);\n+            outer_class_name = \" of class \" + Utility.compactClassName(outer_class_name, false);\n@@ -187,1 +195,1 @@\n-            outerClassName = \"\";\n+            outer_class_name = \"\";\n@@ -190,1 +198,2 @@\n-            innerName = constantPool.getConstantUtf8(innerNameIndex).getBytes();\n+            inner_name = ((ConstantUtf8) constantPool.getConstant(innerNameIndex,\n+                    Const.CONSTANT_Utf8)).getBytes();\n@@ -192,1 +201,1 @@\n-            innerName = \"(anonymous)\";\n+            inner_name = \"(anonymous)\";\n@@ -195,2 +204,15 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n-        return \"  \" + access + innerName + \"=class \" + innerClassName + outerClassName;\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n+        return \"  \" + access + inner_name + \"=class \" + inner_class_name + outer_class_name;\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public InnerClass copy() {\n+        try {\n+            return (InnerClass) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClass.java","additions":70,"deletions":48,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -32,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -35,2 +31,4 @@\n- * This class is derived from <em>Attribute<\/em> and denotes that this class is an Inner class of another. to the source\n- * file of this class. It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and denotes that this class\n+ * is an Inner class of another.\n+ * to the source file of this class.\n+ * It is instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -38,1 +36,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -40,6 +38,1 @@\n-public final class InnerClasses extends Attribute implements Iterable<InnerClass> {\n-\n-    \/**\n-     * Empty array.\n-     *\/\n-    private static final InnerClass[] EMPTY_INNER_CLASSE_ARRAY = {};\n+public final class InnerClasses extends Attribute {\n@@ -49,0 +42,1 @@\n+\n@@ -50,4 +44,2 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -59,0 +51,14 @@\n+\n+    \/**\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param innerClasses array of inner classes attributes\n+     * @param constant_pool Array of constants\n+     *\/\n+    public InnerClasses(final int name_index, final int length, final InnerClass[] innerClasses,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_INNER_CLASSES, name_index, length, constant_pool);\n+        this.innerClasses = innerClasses != null ? innerClasses : new InnerClass[0];\n+    }\n+\n+\n@@ -62,1 +68,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -65,2 +71,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -68,5 +74,6 @@\n-    InnerClasses(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (InnerClass[]) null, constantPool);\n-        final int classCount = input.readUnsignedShort();\n-        innerClasses = new InnerClass[classCount];\n-        for (int i = 0; i < classCount; i++) {\n+    InnerClasses(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (InnerClass[]) null, constant_pool);\n+        final int number_of_classes = input.readUnsignedShort();\n+        innerClasses = new InnerClass[number_of_classes];\n+        for (int i = 0; i < number_of_classes; i++) {\n@@ -77,11 +84,0 @@\n-    \/**\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param innerClasses array of inner classes attributes\n-     * @param constantPool Array of constants\n-     *\/\n-    public InnerClasses(final int nameIndex, final int length, final InnerClass[] innerClasses, final ConstantPool constantPool) {\n-        super(Const.ATTR_INNER_CLASSES, nameIndex, length, constantPool);\n-        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n-        Args.requireU2(this.innerClasses.length, \"innerClasses.length\");\n-    }\n@@ -90,2 +86,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -96,1 +93,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -100,12 +97,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        \/\/ TODO this could be recoded to use a lower level constructor after creating a copy of the inner classes\n-        final InnerClasses c = (InnerClasses) clone();\n-        c.innerClasses = new InnerClass[innerClasses.length];\n-        Arrays.setAll(c.innerClasses, i -> innerClasses[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -117,1 +102,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -120,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -123,2 +108,2 @@\n-        for (final InnerClass innerClass : innerClasses) {\n-            innerClass.dump(file);\n+        for (final InnerClass inner_class : innerClasses) {\n+            inner_class.dump(file);\n@@ -128,0 +113,1 @@\n+\n@@ -135,4 +121,0 @@\n-    @Override\n-    public Iterator<InnerClass> iterator() {\n-        return Stream.of(innerClasses).iterator();\n-    }\n@@ -143,2 +125,2 @@\n-    public void setInnerClasses(final InnerClass[] innerClasses) {\n-        this.innerClasses = innerClasses != null ? innerClasses : EMPTY_INNER_CLASSE_ARRAY;\n+    public void setInnerClasses( final InnerClass[] innerClasses ) {\n+        this.innerClasses = innerClasses != null ? innerClasses : new InnerClass[0];\n@@ -147,0 +129,1 @@\n+\n@@ -156,2 +139,2 @@\n-        for (final InnerClass innerClass : innerClasses) {\n-            buf.append(innerClass.toString(super.getConstantPool())).append(\"\\n\");\n+        for (final InnerClass inner_class : innerClasses) {\n+            buf.append(inner_class.toString(super.getConstantPool())).append(\"\\n\");\n@@ -159,1 +142,17 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        \/\/ TODO this could be recoded to use a lower level constructor after creating a copy of the inner classes\n+        final InnerClasses c = (InnerClasses) clone();\n+        c.innerClasses = new InnerClass[innerClasses.length];\n+        for (int i = 0; i < innerClasses.length; i++) {\n+            c.innerClasses[i] = innerClasses[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/InnerClasses.java","additions":63,"deletions":64,"binary":false,"changes":127,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import java.util.Arrays;\n-import java.util.List;\n@@ -32,1 +30,0 @@\n-import java.util.Set;\n@@ -34,0 +31,2 @@\n+import java.util.List;\n+import java.util.Set;\n@@ -43,5 +42,7 @@\n- * Represents a Java class, i.e., the data structures, constant pool, fields, methods and commands contained in a Java\n- * .class file. See <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\">JVM specification<\/a> for details. The intent of\n- * this class is to represent a parsed or otherwise existing class file. Those interested in programmatically generating\n- * classes should see the <a href=\"..\/generic\/ClassGen.html\">ClassGen<\/a> class.\n- *\n+ * Represents a Java class, i.e., the data structures, constant pool,\n+ * fields, methods and commands contained in a Java .class file.\n+ * See <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/\">JVM specification<\/a> for details.\n+ * The intent of this class is to represent a parsed or otherwise existing\n+ * class file.  Those interested in programatically generating classes\n+ * should see the <a href=\"..\/generic\/ClassGen.html\">ClassGen<\/a> class.\n+\n@@ -49,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -53,56 +54,0 @@\n-    \/**\n-     * The standard class file extension.\n-     *\n-     * @since 6.7.0\n-     *\/\n-    public static final String EXTENSION = \".class\";\n-\n-    \/**\n-     * Empty array.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final JavaClass[] EMPTY_ARRAY = {};\n-\n-    public static final byte HEAP = 1;\n-    public static final byte FILE = 2;\n-    public static final byte ZIP = 3;\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n-\n-        @Override\n-        public boolean equals(final Object o1, final Object o2) {\n-            final JavaClass THIS = (JavaClass) o1;\n-            final JavaClass THAT = (JavaClass) o2;\n-            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n-        }\n-\n-        @Override\n-        public int hashCode(final Object o) {\n-            final JavaClass THIS = (JavaClass) o;\n-            return THIS.getClassName().hashCode();\n-        }\n-    };\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-    private static String indent(final Object obj) {\n-        final StringTokenizer tokenizer = new StringTokenizer(obj.toString(), \"\\n\");\n-        final StringBuilder buf = new StringBuilder();\n-        while (tokenizer.hasMoreTokens()) {\n-            buf.append(\"\\t\").append(tokenizer.nextToken()).append(\"\\n\");\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n-\n@@ -110,1 +55,1 @@\n-    private final String packageName;\n+    private String packageName;\n@@ -124,2 +69,1 @@\n-\n-    private AnnotationEntry[] annotations; \/\/ annotations defined on the class\n+    private AnnotationEntry[] annotations;   \/\/ annotations defined on the class\n@@ -127,0 +71,7 @@\n+    private boolean isAnonymous = false;\n+    private boolean isNested = false;\n+    private boolean computedNestedTypeStatus = false;\n+    public static final byte HEAP = 1;\n+    public static final byte FILE = 2;\n+    public static final byte ZIP = 3;\n+    private static final boolean debug = false;\n@@ -128,1 +79,1 @@\n-    private boolean isAnonymous;\n+    private static BCELComparator bcelComparator = new BCELComparator() {\n@@ -130,1 +81,6 @@\n-    private boolean isNested;\n+        @Override\n+        public boolean equals( final Object o1, final Object o2 ) {\n+            final JavaClass THIS = (JavaClass) o1;\n+            final JavaClass THAT = (JavaClass) o2;\n+            return Objects.equals(THIS.getClassName(), THAT.getClassName());\n+        }\n@@ -132,1 +88,0 @@\n-    private boolean computedNestedTypeStatus;\n@@ -134,0 +89,6 @@\n+        @Override\n+        public int hashCode( final Object o ) {\n+            final JavaClass THIS = (JavaClass) o;\n+            return THIS.getClassName().hashCode();\n+        }\n+    };\n@@ -135,2 +96,3 @@\n-     * In cases where we go ahead and create something, use the default SyntheticRepository, because we don't know any\n-     * better.\n+     * In cases where we go ahead and create something,\n+     * use the default SyntheticRepository, because we\n+     * don't know any better.\n@@ -138,1 +100,2 @@\n-    private transient com.sun.org.apache.bcel.internal.util.Repository repository = SyntheticRepository.getInstance();\n+    private transient com.sun.org.apache.bcel.internal.util.Repository repository\n+            = SyntheticRepository.getInstance();\n@@ -140,19 +103,0 @@\n-    \/**\n-     * Constructor gets all contents as arguments.\n-     *\n-     * @param classNameIndex Class name\n-     * @param superclassNameIndex Superclass name\n-     * @param fileName File name\n-     * @param major Major compiler version\n-     * @param minor Minor compiler version\n-     * @param accessFlags Access rights defined by bit flags\n-     * @param constantPool Array of constants\n-     * @param interfaces Implemented interfaces\n-     * @param fields Class fields\n-     * @param methods Class methods\n-     * @param attributes Class attributes\n-     *\/\n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags,\n-        final ConstantPool constantPool, final int[] interfaces, final Field[] fields, final Method[] methods, final Attribute[] attributes) {\n-        this(classNameIndex, superclassNameIndex, fileName, major, minor, accessFlags, constantPool, interfaces, fields, methods, attributes, HEAP);\n-    }\n@@ -163,3 +107,4 @@\n-     * @param classNameIndex Index into constant pool referencing a ConstantClass that represents this class.\n-     * @param superclassNameIndex Index into constant pool referencing a ConstantClass that represents this class's\n-     *        superclass.\n+     * @param classNameIndex Index into constant pool referencing a\n+     * ConstantClass that represents this class.\n+     * @param superclassNameIndex Index into constant pool referencing a\n+     * ConstantClass that represents this class's superclass.\n@@ -169,1 +114,1 @@\n-     * @param accessFlags Access rights defined by bit flags\n+     * @param access_flags Access rights defined by bit flags\n@@ -177,3 +122,5 @@\n-    public JavaClass(final int classNameIndex, final int superclassNameIndex, final String fileName, final int major, final int minor, final int accessFlags,\n-        final ConstantPool constantPool, int[] interfaces, Field[] fields, Method[] methods, Attribute[] attributes, final byte source) {\n-        super(accessFlags);\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex,\n+            final String fileName, final int major, final int minor, final int access_flags,\n+            final ConstantPool constantPool, int[] interfaces, Field[] fields,\n+            Method[] methods, Attribute[] attributes, final byte source) {\n+        super(access_flags);\n@@ -181,1 +128,1 @@\n-            interfaces = Const.EMPTY_INT_ARRAY;\n+            interfaces = new int[0];\n@@ -184,1 +131,1 @@\n-            attributes = Attribute.EMPTY_ARRAY;\n+            attributes = new Attribute[0];\n@@ -187,1 +134,1 @@\n-            fields = Field.EMPTY_FIELD_ARRAY;\n+            fields = new Field[0];\n@@ -190,1 +137,1 @@\n-            methods = Method.EMPTY_METHOD_ARRAY;\n+            methods = new Method[0];\n@@ -210,3 +157,3 @@\n-        \/*\n-         * According to the specification the following entries must be of type 'ConstantClass' but we check that anyway via the\n-         * 'ConstPool.getConstant' method.\n+        \/* According to the specification the following entries must be of type\n+         * `ConstantClass' but we check that anyway via the\n+         * `ConstPool.getConstant' method.\n@@ -224,1 +171,2 @@\n-            superclassName = constantPool.getConstantString(superclassNameIndex, Const.CONSTANT_Class);\n+            superclassName = constantPool.getConstantString(superclassNameIndex,\n+                    Const.CONSTANT_Class);\n@@ -236,0 +184,1 @@\n+\n@@ -237,2 +186,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Constructor gets all contents as arguments.\n@@ -240,1 +188,11 @@\n-     * @param v Visitor object\n+     * @param classNameIndex Class name\n+     * @param superclassNameIndex Superclass name\n+     * @param fileName File name\n+     * @param major Major compiler version\n+     * @param minor Minor compiler version\n+     * @param access_flags Access rights defined by bit flags\n+     * @param constantPool Array of constants\n+     * @param interfaces Implemented interfaces\n+     * @param fields Class fields\n+     * @param methods Class methods\n+     * @param attributes Class attributes\n@@ -242,3 +200,6 @@\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitJavaClass(this);\n+    public JavaClass(final int classNameIndex, final int superclassNameIndex,\n+            final String fileName, final int major, final int minor, final int access_flags,\n+            final ConstantPool constantPool, final int[] interfaces, final Field[] fields,\n+            final Method[] methods, final Attribute[] attributes) {\n+        this(classNameIndex, superclassNameIndex, fileName, major, minor, access_flags,\n+                constantPool, interfaces, fields, methods, attributes, HEAP);\n@@ -247,0 +208,1 @@\n+\n@@ -248,1 +210,3 @@\n-     * Return the natural ordering of two JavaClasses. This ordering is based on the class name\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -250,1 +214,1 @@\n-     * @since 6.0\n+     * @param v Visitor object\n@@ -253,2 +217,2 @@\n-    public int compareTo(final JavaClass obj) {\n-        return getClassName().compareTo(obj.getClassName());\n+    public void accept( final Visitor v ) {\n+        v.visitJavaClass(this);\n@@ -257,3 +221,6 @@\n-    private void computeNestedTypeStatus() {\n-        if (computedNestedTypeStatus) {\n-            return;\n+\n+    \/* Print debug information depending on `JavaClass.debug'\n+     *\/\n+    static void Debug( final String str ) {\n+        if (debug) {\n+            System.out.println(str);\n@@ -261,16 +228,17 @@\n-        for (final Attribute attribute : this.attributes) {\n-            if (attribute instanceof InnerClasses) {\n-                ((InnerClasses) attribute).forEach(innerClass ->  {\n-                    boolean innerClassAttributeRefersToMe = false;\n-                    String innerClassName = constantPool.getConstantString(innerClass.getInnerClassIndex(), Const.CONSTANT_Class);\n-                    innerClassName = Utility.compactClassName(innerClassName, false);\n-                    if (innerClassName.equals(getClassName())) {\n-                        innerClassAttributeRefersToMe = true;\n-                    }\n-                    if (innerClassAttributeRefersToMe) {\n-                        this.isNested = true;\n-                        if (innerClass.getInnerNameIndex() == 0) {\n-                            this.isAnonymous = true;\n-                        }\n-                    }\n-                });\n+    }\n+\n+\n+    \/**\n+     * Dump class to a file.\n+     *\n+     * @param file Output file\n+     * @throws IOException\n+     *\/\n+    public void dump(final File file) throws IOException {\n+        final String parent = file.getParent();\n+        if (parent != null) {\n+            final File dir = new File(parent);\n+            if (!dir.mkdirs()) { \/\/ either was not created or already existed\n+                if (!dir.isDirectory()) {\n+                    throw new IOException(\"Could not create the directory \" + dir);\n+                }\n@@ -279,1 +247,3 @@\n-        this.computedNestedTypeStatus = true;\n+        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n+            dump(dos);\n+        }\n@@ -282,0 +252,1 @@\n+\n@@ -283,1 +254,4 @@\n-     * @return deep copy of this class\n+     * Dump class to a file named fileName.\n+     *\n+     * @param _file_name Output file name\n+     * @throws IOException\n@@ -285,1 +259,11 @@\n-    public JavaClass copy() {\n+    public void dump( final String _file_name ) throws IOException {\n+        dump(new File(_file_name));\n+    }\n+\n+\n+    \/**\n+     * @return class in binary format\n+     *\/\n+    public byte[] getBytes() {\n+        final ByteArrayOutputStream s = new ByteArrayOutputStream();\n+        final DataOutputStream ds = new DataOutputStream(s);\n@@ -287,13 +271,9 @@\n-            final JavaClass c = (JavaClass) clone();\n-            c.constantPool = constantPool.copy();\n-            c.interfaces = interfaces.clone();\n-            c.interfaceNames = interfaceNames.clone();\n-            c.fields = new Field[fields.length];\n-            Arrays.setAll(c.fields, i -> fields[i].copy(c.constantPool));\n-            c.methods = new Method[methods.length];\n-            Arrays.setAll(c.methods, i -> methods[i].copy(c.constantPool));\n-            c.attributes = new Attribute[attributes.length];\n-            Arrays.setAll(c.attributes, i -> attributes[i].copy(c.constantPool));\n-            return c;\n-        } catch (final CloneNotSupportedException e) {\n-            return null;\n+            dump(ds);\n+        } catch (final IOException e) {\n+            System.err.println(\"Error dumping class: \" + e.getMessage());\n+        } finally {\n+            try {\n+                ds.close();\n+            } catch (final IOException e2) {\n+                System.err.println(\"Error dumping class: \" + e2.getMessage());\n+            }\n@@ -301,0 +281,1 @@\n+        return s.toByteArray();\n@@ -303,0 +284,12 @@\n+\n+    \/**\n+     * Dump Java class to output stream in binary format.\n+     *\n+     * @param file Output stream\n+     * @throws IOException\n+     *\/\n+    public void dump( final OutputStream file ) throws IOException {\n+        dump(new DataOutputStream(file));\n+    }\n+\n+\n@@ -307,1 +300,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -309,1 +302,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -340,49 +333,0 @@\n-    \/**\n-     * Dump class to a file.\n-     *\n-     * @param file Output file\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public void dump(final File file) throws IOException {\n-        final String parent = file.getParent();\n-        if (parent != null) {\n-            final File dir = new File(parent);\n-            if (!dir.mkdirs() && !dir.isDirectory()) {\n-                throw new IOException(\"Could not create the directory \" + dir);\n-            }\n-        }\n-        try (DataOutputStream dos = new DataOutputStream(new FileOutputStream(file))) {\n-            dump(dos);\n-        }\n-    }\n-\n-    \/**\n-     * Dump Java class to output stream in binary format.\n-     *\n-     * @param file Output stream\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public void dump(final OutputStream file) throws IOException {\n-        dump(new DataOutputStream(file));\n-    }\n-\n-    \/**\n-     * Dump class to a file named fileName.\n-     *\n-     * @param fileName Output file name\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    public void dump(final String fileName) throws IOException {\n-        dump(new File(fileName));\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two JavaClass objects are said to be equal when\n-     * their class names are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n@@ -391,3 +335,1 @@\n-     * Get all interfaces implemented by this JavaClass (transitively).\n-     *\n-     * @throws ClassNotFoundException if any of the class's superclasses or interfaces can't be found.\n+     * @return Attributes of the class.\n@@ -395,18 +337,2 @@\n-    public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n-        final ClassQueue queue = new ClassQueue();\n-        final Set<JavaClass> allInterfaces = new TreeSet<>();\n-        queue.enqueue(this);\n-        while (!queue.empty()) {\n-            final JavaClass clazz = queue.dequeue();\n-            final JavaClass souper = clazz.getSuperClass();\n-            final JavaClass[] interfaces = clazz.getInterfaces();\n-            if (clazz.isInterface()) {\n-                allInterfaces.add(clazz);\n-            } else if (souper != null) {\n-                queue.enqueue(souper);\n-            }\n-            for (final JavaClass iface : interfaces) {\n-                queue.enqueue(iface);\n-            }\n-        }\n-        return allInterfaces.toArray(JavaClass.EMPTY_ARRAY);\n+    public Attribute[] getAttributes() {\n+        return attributes;\n@@ -428,1 +354,1 @@\n-     * @return Attributes of the class.\n+     * @return Class name.\n@@ -430,2 +356,2 @@\n-    public Attribute[] getAttributes() {\n-        return attributes;\n+    public String getClassName() {\n+        return className;\n@@ -434,12 +360,0 @@\n-    \/**\n-     * @return class in binary format\n-     *\/\n-    public byte[] getBytes() {\n-        final ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (DataOutputStream dos = new DataOutputStream(baos)) {\n-            dump(dos);\n-        } catch (final IOException e) {\n-            e.printStackTrace();\n-        }\n-        return baos.toByteArray();\n-    }\n@@ -448,1 +362,1 @@\n-     * @return Class name.\n+     * @return Package name.\n@@ -450,2 +364,2 @@\n-    public String getClassName() {\n-        return className;\n+    public String getPackageName() {\n+        return packageName;\n@@ -454,0 +368,1 @@\n+\n@@ -461,0 +376,1 @@\n+\n@@ -468,0 +384,1 @@\n+\n@@ -469,2 +386,3 @@\n-     * @return Fields, i.e., variables of the class. Like the JVM spec mandates for the classfile format, these fields are\n-     *         those specific to this class, and not those of the superclass or superinterfaces.\n+     * @return Fields, i.e., variables of the class. Like the JVM spec\n+     * mandates for the classfile format, these fields are those specific to\n+     * this class, and not those of the superclass or superinterfaces.\n@@ -476,0 +394,1 @@\n+\n@@ -483,6 +402,0 @@\n-    \/**\n-     * @return Indices in constant pool of implemented interfaces.\n-     *\/\n-    public int[] getInterfaceIndices() {\n-        return interfaces;\n-    }\n@@ -497,0 +410,1 @@\n+\n@@ -498,3 +412,1 @@\n-     * Get interfaces directly implemented by this JavaClass.\n-     *\n-     * @throws ClassNotFoundException if any of the class's interfaces can't be found.\n+     * @return Indices in constant pool of implemented interfaces.\n@@ -502,7 +414,2 @@\n-    public JavaClass[] getInterfaces() throws ClassNotFoundException {\n-        final String[] interfaces = getInterfaceNames();\n-        final JavaClass[] classes = new JavaClass[interfaces.length];\n-        for (int i = 0; i < interfaces.length; i++) {\n-            classes[i] = repository.loadClass(interfaces[i]);\n-        }\n-        return classes;\n+    public int[] getInterfaceIndices() {\n+        return interfaces;\n@@ -511,0 +418,1 @@\n+\n@@ -518,0 +426,1 @@\n+\n@@ -519,13 +428,1 @@\n-     * @return A {@link Method} corresponding to java.lang.reflect.Method if any\n-     *\/\n-    public Method getMethod(final java.lang.reflect.Method m) {\n-        for (final Method method : methods) {\n-            if (m.getName().equals(method.getName()) && m.getModifiers() == method.getModifiers() && Type.getSignature(m).equals(method.getSignature())) {\n-                return method;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * @return Methods of the class.\n+     * @return Methods of the class.\n@@ -537,6 +434,0 @@\n-    \/**\n-     * @return Minor number of class file version.\n-     *\/\n-    public int getMinor() {\n-        return minor;\n-    }\n@@ -545,1 +436,2 @@\n-     * @return Package name.\n+     * @return A {@link Method} corresponding to\n+     * java.lang.reflect.Method if any\n@@ -547,2 +439,8 @@\n-    public String getPackageName() {\n-        return packageName;\n+    public Method getMethod( final java.lang.reflect.Method m ) {\n+        for (final Method method : methods) {\n+            if (m.getName().equals(method.getName()) && (m.getModifiers() == method.getModifiers())\n+                    && Type.getSignature(m).equals(method.getSignature())) {\n+                return method;\n+            }\n+        }\n+        return null;\n@@ -551,7 +449,0 @@\n-    \/**\n-     * Gets the ClassRepository which holds its definition. By default this is the same as\n-     * SyntheticRepository.getInstance();\n-     *\/\n-    public com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n-        return repository;\n-    }\n@@ -560,1 +451,1 @@\n-     * @return returns either HEAP (generated), FILE, or ZIP\n+     * @return Minor number of class file version.\n@@ -562,2 +453,2 @@\n-    public final byte getSource() {\n-        return source;\n+    public int getMinor() {\n+        return minor;\n@@ -566,0 +457,1 @@\n+\n@@ -567,1 +459,1 @@\n-     * @return file name where this class was read from\n+     * @return sbsolute path to file where this class was read from\n@@ -573,39 +465,0 @@\n-    \/**\n-     * Gets the source file path including the package path.\n-     *\n-     * @return path to original source file of parsed class, relative to original source directory.\n-     * @since 6.7.0\n-     *\/\n-    public String getSourceFilePath() {\n-        final StringBuilder outFileName = new StringBuilder();\n-        if (!packageName.isEmpty()) {\n-            outFileName.append(Utility.packageToPath(packageName));\n-            outFileName.append('\/');\n-        }\n-        outFileName.append(sourceFileName);\n-        return outFileName.toString();\n-    }\n-\n-    \/**\n-     * @return the superclass for this JavaClass object, or null if this is java.lang.Object\n-     * @throws ClassNotFoundException if the superclass can't be found\n-     *\/\n-    public JavaClass getSuperClass() throws ClassNotFoundException {\n-        if (\"java.lang.Object\".equals(getClassName())) {\n-            return null;\n-        }\n-        return repository.loadClass(getSuperclassName());\n-    }\n-\n-    \/**\n-     * @return list of super classes of this class in ascending order, i.e., java.lang.Object is always the last element\n-     * @throws ClassNotFoundException if any of the superclasses can't be found\n-     *\/\n-    public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n-        JavaClass clazz = this;\n-        final List<JavaClass> allSuperClasses = new ArrayList<>();\n-        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n-            allSuperClasses.add(clazz);\n-        }\n-        return allSuperClasses.toArray(JavaClass.EMPTY_ARRAY);\n-    }\n@@ -614,2 +467,3 @@\n-     * returns the super class name of this class. In the case that this class is java.lang.Object, it will return itself\n-     * (java.lang.Object). This is probably incorrect but isn't fixed at this time to not break existing clients.\n+     * returns the super class name of this class. In the case that this class is\n+     * java.lang.Object, it will return itself (java.lang.Object). This is probably incorrect\n+     * but isn't fixed at this time to not break existing clients.\n@@ -623,0 +477,1 @@\n+\n@@ -630,75 +485,0 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    \/**\n-     * @return true, if this class is an implementation of interface inter\n-     * @throws ClassNotFoundException if superclasses or superinterfaces of this class can't be found\n-     *\/\n-    public boolean implementationOf(final JavaClass inter) throws ClassNotFoundException {\n-        if (!inter.isInterface()) {\n-            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n-        }\n-        if (this.equals(inter)) {\n-            return true;\n-        }\n-        final JavaClass[] superInterfaces = getAllInterfaces();\n-        for (final JavaClass superInterface : superInterfaces) {\n-            if (superInterface.equals(inter)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * Equivalent to runtime \"instanceof\" operator.\n-     *\n-     * @return true if this JavaClass is derived from the super class\n-     * @throws ClassNotFoundException if superclasses or superinterfaces of this object can't be found\n-     *\/\n-    public final boolean instanceOf(final JavaClass superclass) throws ClassNotFoundException {\n-        if (this.equals(superclass)) {\n-            return true;\n-        }\n-        for (final JavaClass clazz : getSuperClasses()) {\n-            if (clazz.equals(superclass)) {\n-                return true;\n-            }\n-        }\n-        if (superclass.isInterface()) {\n-            return implementationOf(superclass);\n-        }\n-        return false;\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public final boolean isAnonymous() {\n-        computeNestedTypeStatus();\n-        return this.isAnonymous;\n-    }\n-\n-    public final boolean isClass() {\n-        return (super.getAccessFlags() & Const.ACC_INTERFACE) == 0;\n-    }\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public final boolean isNested() {\n-        computeNestedTypeStatus();\n-        return this.isNested;\n-    }\n-\n-    public final boolean isSuper() {\n-        return (super.getAccessFlags() & Const.ACC_SUPER) != 0;\n-    }\n-\n@@ -708,1 +488,1 @@\n-    public void setAttributes(final Attribute[] attributes) {\n+    public void setAttributes( final Attribute[] attributes ) {\n@@ -712,0 +492,1 @@\n+\n@@ -715,1 +496,1 @@\n-    public void setClassName(final String className) {\n+    public void setClassName( final String className ) {\n@@ -719,0 +500,1 @@\n+\n@@ -722,1 +504,1 @@\n-    public void setClassNameIndex(final int classNameIndex) {\n+    public void setClassNameIndex( final int classNameIndex ) {\n@@ -726,0 +508,1 @@\n+\n@@ -729,1 +512,1 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n+    public void setConstantPool( final ConstantPool constantPool ) {\n@@ -733,0 +516,1 @@\n+\n@@ -736,1 +520,1 @@\n-    public void setFields(final Field[] fields) {\n+    public void setFields( final Field[] fields ) {\n@@ -740,0 +524,1 @@\n+\n@@ -743,1 +528,1 @@\n-    public void setFileName(final String fileName) {\n+    public void setFileName( final String fileName ) {\n@@ -747,0 +532,1 @@\n+\n@@ -750,1 +536,1 @@\n-    public void setInterfaceNames(final String[] interfaceNames) {\n+    public void setInterfaceNames( final String[] interfaceNames ) {\n@@ -754,0 +540,1 @@\n+\n@@ -757,1 +544,1 @@\n-    public void setInterfaces(final int[] interfaces) {\n+    public void setInterfaces( final int[] interfaces ) {\n@@ -761,0 +548,1 @@\n+\n@@ -764,1 +552,1 @@\n-    public void setMajor(final int major) {\n+    public void setMajor( final int major ) {\n@@ -768,0 +556,1 @@\n+\n@@ -771,1 +560,1 @@\n-    public void setMethods(final Method[] methods) {\n+    public void setMethods( final Method[] methods ) {\n@@ -775,0 +564,1 @@\n+\n@@ -778,1 +568,1 @@\n-    public void setMinor(final int minor) {\n+    public void setMinor( final int minor ) {\n@@ -782,6 +572,0 @@\n-    \/**\n-     * Sets the ClassRepository which loaded the JavaClass. Should be called immediately after parsing is done.\n-     *\/\n-    public void setRepository(final com.sun.org.apache.bcel.internal.util.Repository repository) { \/\/ TODO make protected?\n-        this.repository = repository;\n-    }\n@@ -792,1 +576,1 @@\n-    public void setSourceFileName(final String sourceFileName) {\n+    public void setSourceFileName( final String sourceFileName ) {\n@@ -796,0 +580,1 @@\n+\n@@ -799,1 +584,1 @@\n-    public void setSuperclassName(final String superclassName) {\n+    public void setSuperclassName( final String superclassName ) {\n@@ -803,0 +588,1 @@\n+\n@@ -806,1 +592,1 @@\n-    public void setSuperclassNameIndex(final int superclassNameIndex) {\n+    public void setSuperclassNameIndex( final int superclassNameIndex ) {\n@@ -810,0 +596,1 @@\n+\n@@ -816,1 +603,1 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n@@ -818,2 +605,3 @@\n-        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(className).append(\" extends \")\n-            .append(Utility.compactClassName(superclassName, false)).append('\\n');\n+        buf.append(access).append(Utility.classOrInterface(super.getAccessFlags())).append(\" \").append(\n+                className).append(\" extends \").append(\n+                Utility.compactClassName(superclassName, false)).append('\\n');\n@@ -844,1 +632,1 @@\n-        if (annotations != null && annotations.length > 0) {\n+        if (annotations!=null && annotations.length>0) {\n@@ -864,0 +652,282 @@\n+\n+\n+    private static String indent( final Object obj ) {\n+        final StringTokenizer tok = new StringTokenizer(obj.toString(), \"\\n\");\n+        final StringBuilder buf = new StringBuilder();\n+        while (tok.hasMoreTokens()) {\n+            buf.append(\"\\t\").append(tok.nextToken()).append(\"\\n\");\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this class\n+     *\/\n+    public JavaClass copy() {\n+        JavaClass c = null;\n+        try {\n+            c = (JavaClass) clone();\n+            c.constantPool = constantPool.copy();\n+            c.interfaces = interfaces.clone();\n+            c.interfaceNames = interfaceNames.clone();\n+            c.fields = new Field[fields.length];\n+            for (int i = 0; i < fields.length; i++) {\n+                c.fields[i] = fields[i].copy(c.constantPool);\n+            }\n+            c.methods = new Method[methods.length];\n+            for (int i = 0; i < methods.length; i++) {\n+                c.methods[i] = methods[i].copy(c.constantPool);\n+            }\n+            c.attributes = new Attribute[attributes.length];\n+            for (int i = 0; i < attributes.length; i++) {\n+                c.attributes[i] = attributes[i].copy(c.constantPool);\n+            }\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return c;\n+    }\n+\n+\n+    public final boolean isSuper() {\n+        return (super.getAccessFlags() & Const.ACC_SUPER) != 0;\n+    }\n+\n+\n+    public final boolean isClass() {\n+        return (super.getAccessFlags() & Const.ACC_INTERFACE) == 0;\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public final boolean isAnonymous() {\n+        computeNestedTypeStatus();\n+        return this.isAnonymous;\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public final boolean isNested() {\n+        computeNestedTypeStatus();\n+        return this.isNested;\n+    }\n+\n+    private void computeNestedTypeStatus() {\n+        if (computedNestedTypeStatus) {\n+            return;\n+        }\n+        for (final Attribute attribute : this.attributes) {\n+              if (attribute instanceof InnerClasses) {\n+                  final InnerClass[] innerClasses = ((InnerClasses) attribute).getInnerClasses();\n+                  for (final InnerClass innerClasse : innerClasses) {\n+                      boolean innerClassAttributeRefersToMe = false;\n+                      String inner_class_name = constantPool.getConstantString(innerClasse.getInnerClassIndex(),\n+                                 Const.CONSTANT_Class);\n+                      inner_class_name = Utility.compactClassName(inner_class_name, false);\n+                      if (inner_class_name.equals(getClassName())) {\n+                          innerClassAttributeRefersToMe = true;\n+                      }\n+                      if (innerClassAttributeRefersToMe) {\n+                          this.isNested = true;\n+                          if (innerClasse.getInnerNameIndex() == 0) {\n+                              this.isAnonymous = true;\n+                          }\n+                      }\n+                  }\n+              }\n+        }\n+        this.computedNestedTypeStatus = true;\n+    }\n+\n+\n+    \/** @return returns either HEAP (generated), FILE, or ZIP\n+     *\/\n+    public final byte getSource() {\n+        return source;\n+    }\n+\n+\n+    \/********************* New repository functionality *********************\/\n+    \/**\n+     * Gets the ClassRepository which holds its definition. By default\n+     * this is the same as SyntheticRepository.getInstance();\n+     *\/\n+    public com.sun.org.apache.bcel.internal.util.Repository getRepository() {\n+        return repository;\n+    }\n+\n+\n+    \/**\n+     * Sets the ClassRepository which loaded the JavaClass.\n+     * Should be called immediately after parsing is done.\n+     *\/\n+    public void setRepository( final com.sun.org.apache.bcel.internal.util.Repository repository ) { \/\/ TODO make protected?\n+        this.repository = repository;\n+    }\n+\n+\n+    \/** Equivalent to runtime \"instanceof\" operator.\n+     *\n+     * @return true if this JavaClass is derived from the super class\n+     * @throws ClassNotFoundException if superclasses or superinterfaces\n+     *   of this object can't be found\n+     *\/\n+    public final boolean instanceOf( final JavaClass super_class ) throws ClassNotFoundException {\n+        if (this.equals(super_class)) {\n+            return true;\n+        }\n+        final JavaClass[] super_classes = getSuperClasses();\n+        for (final JavaClass super_classe : super_classes) {\n+            if (super_classe.equals(super_class)) {\n+                return true;\n+            }\n+        }\n+        if (super_class.isInterface()) {\n+            return implementationOf(super_class);\n+        }\n+        return false;\n+    }\n+\n+\n+    \/**\n+     * @return true, if this class is an implementation of interface inter\n+     * @throws ClassNotFoundException if superclasses or superinterfaces\n+     *   of this class can't be found\n+     *\/\n+    public boolean implementationOf( final JavaClass inter ) throws ClassNotFoundException {\n+        if (!inter.isInterface()) {\n+            throw new IllegalArgumentException(inter.getClassName() + \" is no interface\");\n+        }\n+        if (this.equals(inter)) {\n+            return true;\n+        }\n+        final JavaClass[] super_interfaces = getAllInterfaces();\n+        for (final JavaClass super_interface : super_interfaces) {\n+            if (super_interface.equals(inter)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+\n+    \/**\n+     * @return the superclass for this JavaClass object, or null if this\n+     * is java.lang.Object\n+     * @throws ClassNotFoundException if the superclass can't be found\n+     *\/\n+    public JavaClass getSuperClass() throws ClassNotFoundException {\n+        if (\"java.lang.Object\".equals(getClassName())) {\n+            return null;\n+        }\n+        return repository.loadClass(getSuperclassName());\n+    }\n+\n+\n+    \/**\n+     * @return list of super classes of this class in ascending order, i.e.,\n+     * java.lang.Object is always the last element\n+     * @throws ClassNotFoundException if any of the superclasses can't be found\n+     *\/\n+    public JavaClass[] getSuperClasses() throws ClassNotFoundException {\n+        JavaClass clazz = this;\n+        final List<JavaClass> allSuperClasses = new ArrayList<>();\n+        for (clazz = clazz.getSuperClass(); clazz != null; clazz = clazz.getSuperClass()) {\n+            allSuperClasses.add(clazz);\n+        }\n+        return allSuperClasses.toArray(new JavaClass[allSuperClasses.size()]);\n+    }\n+\n+\n+    \/**\n+     * Get interfaces directly implemented by this JavaClass.\n+     *\/\n+    public JavaClass[] getInterfaces() throws ClassNotFoundException {\n+        final String[] _interfaces = getInterfaceNames();\n+        final JavaClass[] classes = new JavaClass[_interfaces.length];\n+        for (int i = 0; i < _interfaces.length; i++) {\n+            classes[i] = repository.loadClass(_interfaces[i]);\n+        }\n+        return classes;\n+    }\n+\n+\n+    \/**\n+     * Get all interfaces implemented by this JavaClass (transitively).\n+     *\/\n+    public JavaClass[] getAllInterfaces() throws ClassNotFoundException {\n+        final ClassQueue queue = new ClassQueue();\n+        final Set<JavaClass> allInterfaces = new TreeSet<>();\n+        queue.enqueue(this);\n+        while (!queue.empty()) {\n+            final JavaClass clazz = queue.dequeue();\n+            final JavaClass souper = clazz.getSuperClass();\n+            final JavaClass[] _interfaces = clazz.getInterfaces();\n+            if (clazz.isInterface()) {\n+                allInterfaces.add(clazz);\n+            } else {\n+                if (souper != null) {\n+                    queue.enqueue(souper);\n+                }\n+            }\n+            for (final JavaClass _interface : _interfaces) {\n+                queue.enqueue(_interface);\n+            }\n+        }\n+        return allInterfaces.toArray(new JavaClass[allInterfaces.size()]);\n+    }\n+\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two JavaClass objects are said to be equal when\n+     * their class names are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return the natural ordering of two JavaClasses.\n+     * This ordering is based on the class name\n+     * @since 6.0\n+     *\/\n+    @Override\n+    public int compareTo( final JavaClass obj ) {\n+        return getClassName().compareTo(obj.getClassName());\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the class name.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/JavaClass.java","additions":505,"deletions":435,"binary":false,"changes":940,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n-\n@@ -31,2 +29,3 @@\n- * This class represents a (PC offset, line number) pair, i.e., a line number in the source that corresponds to a\n- * relative address in the byte code. This is used for debugging purposes.\n+ * This class represents a (PC offset, line number) pair, i.e., a line number in\n+ * the source that corresponds to a relative address in the byte code. This\n+ * is used for debugging purposes.\n@@ -34,1 +33,1 @@\n- * @see LineNumberTable\n+ * @see     LineNumberTable\n@@ -38,2 +37,0 @@\n-    static final LineNumber[] EMPTY_ARRAY = {};\n-\n@@ -41,1 +38,1 @@\n-    private int startPc;\n+    private short startPc;\n@@ -44,1 +41,11 @@\n-    private int lineNumber;\n+    private short lineNumber;\n+\n+    \/**\n+     * Initialize from another object.\n+     *\n+     * @param c the object to copy\n+     *\/\n+    public LineNumber(final LineNumber c) {\n+        this(c.getStartPC(), c.getLineNumber());\n+    }\n+\n@@ -56,0 +63,1 @@\n+\n@@ -61,2 +69,2 @@\n-        this.startPc = Args.requireU2(startPc, \"startPc\");\n-        this.lineNumber = Args.requireU2(lineNumber, \"lineNumber\");\n+        this.startPc = (short) startPc;\n+        this.lineNumber = (short)lineNumber;\n@@ -65,8 +73,0 @@\n-    \/**\n-     * Initialize from another object.\n-     *\n-     * @param c the object to copy\n-     *\/\n-    public LineNumber(final LineNumber c) {\n-        this(c.getStartPC(), c.getLineNumber());\n-    }\n@@ -75,2 +75,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -81,1 +82,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -85,11 +86,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public LineNumber copy() {\n-        try {\n-            return (LineNumber) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -103,1 +93,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -108,0 +98,1 @@\n+\n@@ -112,1 +103,1 @@\n-        return lineNumber & 0xffff;\n+        return 0xffff & lineNumber;\n@@ -115,0 +106,1 @@\n+\n@@ -119,1 +111,1 @@\n-        return startPc & 0xffff;\n+        return  0xffff & startPc;\n@@ -122,0 +114,1 @@\n+\n@@ -125,1 +118,1 @@\n-    public void setLineNumber(final int lineNumber) {\n+    public void setLineNumber( final int lineNumber ) {\n@@ -129,0 +122,1 @@\n+\n@@ -132,1 +126,1 @@\n-    public void setStartPC(final int startPc) {\n+    public void setStartPC( final int startPc ) {\n@@ -136,0 +130,1 @@\n+\n@@ -141,1 +136,14 @@\n-        return \"LineNumber(\" + getStartPC() + \", \" + getLineNumber() + \")\";\n+        return \"LineNumber(\" + startPc + \", \" + lineNumber + \")\";\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public LineNumber copy() {\n+        try {\n+            return (LineNumber) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumber.java","additions":47,"deletions":39,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -22,0 +22,1 @@\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -25,6 +26,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -34,2 +29,3 @@\n- * This class represents a table of line numbers for debugging purposes. This attribute is used by the <em>Code<\/em>\n- * attribute. It contains pairs of PCs and line numbers.\n+ * This class represents a table of line numbers for debugging\n+ * purposes. This attribute is used by the <em>Code<\/em> attribute. It\n+ * contains pairs of PCs and line numbers.\n@@ -37,1 +33,1 @@\n- * @see Code\n+ * @see     Code\n@@ -41,1 +37,1 @@\n-public final class LineNumberTable extends Attribute implements Iterable<LineNumber> {\n+public final class LineNumberTable extends Attribute {\n@@ -46,8 +42,4 @@\n-    \/**\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index of name\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O Exception occurs in readUnsignedShort\n+\n+    \/*\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -55,7 +47,2 @@\n-    LineNumberTable(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (LineNumber[]) null, constantPool);\n-        final int lineNumberTableLength = input.readUnsignedShort();\n-        lineNumberTable = new LineNumber[lineNumberTableLength];\n-        for (int i = 0; i < lineNumberTableLength; i++) {\n-            lineNumberTable[i] = new LineNumber(input);\n-        }\n+    public LineNumberTable(final LineNumberTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLineNumberTable(), c.getConstantPool());\n@@ -64,0 +51,1 @@\n+\n@@ -65,2 +53,1 @@\n-     * @param nameIndex Index of name\n-     *\n+     * @param name_index Index of name\n@@ -68,1 +55,0 @@\n-     *\n@@ -70,2 +56,1 @@\n-     *\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -73,4 +58,4 @@\n-    public LineNumberTable(final int nameIndex, final int length, final LineNumber[] lineNumberTable, final ConstantPool constantPool) {\n-        super(Const.ATTR_LINE_NUMBER_TABLE, nameIndex, length, constantPool);\n-        this.lineNumberTable = lineNumberTable != null ? lineNumberTable : LineNumber.EMPTY_ARRAY;\n-        Args.requireU2(this.lineNumberTable.length, \"lineNumberTable.length\");\n+    public LineNumberTable(final int name_index, final int length, final LineNumber[] line_number_table,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_LINE_NUMBER_TABLE, name_index, length, constant_pool);\n+        this.lineNumberTable = line_number_table;\n@@ -79,3 +64,7 @@\n-    \/*\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n+    \/**\n+     * Construct object from input stream.\n+     * @param name_index Index of name\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException if an I\/O Exception occurs in readUnsignedShort\n@@ -83,2 +72,8 @@\n-    public LineNumberTable(final LineNumberTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLineNumberTable(), c.getConstantPool());\n+    LineNumberTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (LineNumber[]) null, constant_pool);\n+        final int line_number_table_length = input.readUnsignedShort();\n+        lineNumberTable = new LineNumber[line_number_table_length];\n+        for (int i = 0; i < line_number_table_length; i++) {\n+            lineNumberTable[i] = new LineNumber(input);\n+        }\n@@ -88,2 +83,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -94,1 +90,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -98,14 +94,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        \/\/ TODO could use the lower level constructor and thereby allow\n-        \/\/ lineNumberTable to be made final\n-        final LineNumberTable c = (LineNumberTable) clone();\n-        c.lineNumberTable = new LineNumber[lineNumberTable.length];\n-        Arrays.setAll(c.lineNumberTable, i -> lineNumberTable[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n-\n@@ -119,1 +101,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -134,0 +116,30 @@\n+    \/**\n+     * @param lineNumberTable the line number entries for this table\n+     *\/\n+    public void setLineNumberTable( final LineNumber[] lineNumberTable ) {\n+        this.lineNumberTable = lineNumberTable;\n+    }\n+\n+    \/**\n+     * @return String representation.\n+     *\/\n+    @Override\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder();\n+        final StringBuilder line = new StringBuilder();\n+\n+        for (int i = 0; i < lineNumberTable.length; i++) {\n+            line.append(lineNumberTable[i].toString());\n+            if (i < lineNumberTable.length - 1) {\n+                line.append(\", \");\n+            }\n+            if ((line.length() > MAX_LINE_LENGTH) && (i < lineNumberTable.length - 1)) {\n+                line.append(SecuritySupport.NEWLINE);\n+                buf.append(line);\n+                line.setLength(0);\n+            }\n+        }\n+        buf.append(line);\n+        return buf.toString();\n+    }\n+\n@@ -140,1 +152,1 @@\n-    public int getSourceLine(final int pos) {\n+    public int getSourceLine( final int pos ) {\n@@ -146,1 +158,1 @@\n-        int minIndex = -1;\n+        int min_index = -1;\n@@ -148,2 +160,1 @@\n-        \/*\n-         * Do a binary search since the array is ordered.\n+        \/* Do a binary search since the array is ordered.\n@@ -152,1 +163,1 @@\n-            final int i = l + r >>> 1;\n+            final int i = (l + r) >>> 1;\n@@ -156,2 +167,1 @@\n-            }\n-            if (pos < j) {\n+            } else if (pos < j) {\n@@ -162,3 +172,3 @@\n-            \/*\n-             * If exact match can't be found (which is the most common case) return the line number that corresponds to the greatest\n-             * index less than pos.\n+            \/* If exact match can't be found (which is the most common case)\n+             * return the line number that corresponds to the greatest index less\n+             * than pos.\n@@ -168,1 +178,1 @@\n-                minIndex = i;\n+                min_index = i;\n@@ -171,2 +181,2 @@\n-        \/*\n-         * It's possible that we did not find any valid entry for the bytecode offset we were looking for.\n+        \/* It's possible that we did not find any valid entry for the bytecode\n+         * offset we were looking for.\n@@ -174,1 +184,1 @@\n-        if (minIndex < 0) {\n+        if (min_index < 0) {\n@@ -177,10 +187,1 @@\n-        return lineNumberTable[minIndex].getLineNumber();\n-    }\n-\n-    public int getTableLength() {\n-        return lineNumberTable == null ? 0 : lineNumberTable.length;\n-    }\n-\n-    @Override\n-    public Iterator<LineNumber> iterator() {\n-        return Stream.of(lineNumberTable).iterator();\n+        return lineNumberTable[min_index].getLineNumber();\n@@ -190,8 +191,1 @@\n-     * @param lineNumberTable the line number entries for this table\n-     *\/\n-    public void setLineNumberTable(final LineNumber[] lineNumberTable) {\n-        this.lineNumberTable = lineNumberTable;\n-    }\n-\n-    \/**\n-     * @return String representation.\n+     * @return deep copy of this attribute\n@@ -200,3 +194,5 @@\n-    public String toString() {\n-        final StringBuilder buf = new StringBuilder();\n-        final StringBuilder line = new StringBuilder();\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        \/\/ TODO could use the lower level constructor and thereby allow\n+        \/\/ lineNumberTable to be made final\n+        final LineNumberTable c = (LineNumberTable) clone();\n+        c.lineNumberTable = new LineNumber[lineNumberTable.length];\n@@ -204,9 +200,1 @@\n-            line.append(lineNumberTable[i].toString());\n-            if (i < lineNumberTable.length - 1) {\n-                line.append(\", \");\n-            }\n-            if (line.length() > MAX_LINE_LENGTH && i < lineNumberTable.length - 1) {\n-                line.append(SecuritySupport.NEWLINE);\n-                buf.append(line);\n-                line.setLength(0);\n-            }\n+            c.lineNumberTable[i] = lineNumberTable[i].copy();\n@@ -214,2 +202,7 @@\n-        buf.append(line);\n-        return buf.toString();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n+\n+\n+    public int getTableLength() {\n+        return lineNumberTable == null ? 0 : lineNumberTable.length;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LineNumberTable.java","additions":96,"deletions":103,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -30,4 +30,6 @@\n- * This class represents a local variable within a method. It contains its scope, name, signature and index on the\n- * method's frame. It is used both to represent an element of the LocalVariableTable as well as an element of the\n- * LocalVariableTypeTable. The nomenclature used here may be a bit confusing; while the two items have the same layout\n- * in a class file, a LocalVariableTable attribute contains a descriptor_index, not a signatureIndex. The\n+ * This class represents a local variable within a method. It contains its\n+ * scope, name, signature and index on the method's frame.  It is used both\n+ * to represent an element of the LocalVariableTable as well as an element\n+ * of the LocalVariableTypeTable.  The nomenclature used here may be a bit confusing;\n+ * while the two items have the same layout in a class file, a LocalVariableTable\n+ * attribute contains a descriptor_index, not a signatureIndex.  The\n@@ -35,1 +37,0 @@\n- *\n@@ -38,3 +39,3 @@\n- * @see LocalVariableTable\n- * @see LocalVariableTypeTable\n- * @LastModified: Feb 2023\n+ * @see     LocalVariableTable\n+ * @see     LocalVariableTypeTable\n+ * @LastModified: May 2021\n@@ -44,5 +45,1 @@\n-    static final LocalVariable[] EMPTY_ARRAY = {};\n-\n-    \/** Range in which the variable is valid. *\/\n-    private int startPc;\n-\n+    private int startPc; \/\/ Range in which the variable is valid\n@@ -50,0 +47,9 @@\n+    private int nameIndex; \/\/ Index in constant pool of variable name\n+    \/\/ Technically, a decscriptor_index for a local variable table entry\n+    \/\/ and a signatureIndex for a local variable type table entry.\n+    private int signatureIndex; \/\/ Index of variable signature\n+    private int index; \/* Variable is index'th local variable on\n+     * this method's frame.\n+     *\/\n+    private ConstantPool constantPool;\n+    private int origIndex; \/\/ never changes; used to match up with LocalVariableTypeTable entries\n@@ -51,2 +57,0 @@\n-    \/** Index in constant pool of variable name. *\/\n-    private int nameIndex;\n@@ -55,6 +59,4 @@\n-     * Technically, a decscriptor_index for a local variable table entry and a signatureIndex for a local variable type table entry. Index of variable signature\n-     *\/\n-    private int signatureIndex;\n-\n-    \/*\n-     * Variable is index'th local variable on this method's frame.\n+     * Initializes from another LocalVariable. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n+     *\n+     * @param localVariable Another LocalVariable.\n@@ -62,6 +64,5 @@\n-    private int index;\n-\n-    private ConstantPool constantPool;\n-\n-    \/** Never changes; used to match up with LocalVariableTypeTable entries. *\/\n-    private final int origIndex;\n+    public LocalVariable(final LocalVariable localVariable) {\n+        this(localVariable.getStartPC(), localVariable.getLength(), localVariable.getNameIndex(),\n+                localVariable.getSignatureIndex(), localVariable.getIndex(), localVariable.getConstantPool());\n+        this.origIndex = localVariable.getOrigIndex();\n+    }\n@@ -71,1 +72,0 @@\n-     *\n@@ -73,1 +73,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -75,2 +75,3 @@\n-    LocalVariable(final DataInput file, final ConstantPool constantPool) throws IOException {\n-        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), constantPool);\n+    LocalVariable(final DataInput file, final ConstantPool constant_pool) throws IOException {\n+        this(file.readUnsignedShort(), file.readUnsignedShort(), file.readUnsignedShort(), file\n+                .readUnsignedShort(), file.readUnsignedShort(), constant_pool);\n@@ -79,0 +80,1 @@\n+\n@@ -84,1 +86,1 @@\n-     * @param index Variable is 'index'th local variable on the method's frame\n+     * @param index Variable is `index'th local variable on the method's frame\n@@ -87,2 +89,9 @@\n-    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index, final ConstantPool constantPool) {\n-        this(startPc, length, nameIndex, signatureIndex, index, constantPool, index);\n+    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index,\n+            final ConstantPool constantPool) {\n+        this.startPc = startPc;\n+        this.length = length;\n+        this.nameIndex = nameIndex;\n+        this.signatureIndex = signatureIndex;\n+        this.index = index;\n+        this.constantPool = constantPool;\n+        this.origIndex = index;\n@@ -91,0 +100,1 @@\n+\n@@ -96,1 +106,1 @@\n-     * @param index Variable is 'index'th local variable on the method's frame\n+     * @param index Variable is `index'th local variable on the method's frame\n@@ -98,1 +108,1 @@\n-     * @param origIndex Variable is 'index'th local variable on the method's frame prior to any changes\n+     * @param origIndex Variable is `index'th local variable on the method's frame prior to any changes\n@@ -100,8 +110,7 @@\n-    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index, final ConstantPool constantPool,\n-        final int origIndex) {\n-        this.startPc = Args.requireU2(startPc, \"startPc\");\n-        this.length = Args.requireU2(length, \"length\");\n-        this.nameIndex = Args.requireU2(nameIndex, \"nameIndex\");\n-        this.signatureIndex = Args.requireU2(signatureIndex, \"signatureIndex\");\n-        this.index = Args.requireU2(index, \"index\");\n-        this.origIndex = Args.requireU2(origIndex, \"origIndex\");\n+    public LocalVariable(final int startPc, final int length, final int nameIndex, final int signatureIndex, final int index,\n+            final ConstantPool constantPool, final int origIndex) {\n+        this.startPc = startPc;\n+        this.length = length;\n+        this.nameIndex = nameIndex;\n+        this.signatureIndex = signatureIndex;\n+        this.index = index;\n@@ -109,0 +118,1 @@\n+        this.origIndex = origIndex;\n@@ -111,10 +121,0 @@\n-    \/**\n-     * Initializes from another LocalVariable. Note that both objects use the same references (shallow copy). Use copy() for\n-     * a physical copy.\n-     *\n-     * @param localVariable Another LocalVariable.\n-     *\/\n-    public LocalVariable(final LocalVariable localVariable) {\n-        this(localVariable.getStartPC(), localVariable.getLength(), localVariable.getNameIndex(), localVariable.getSignatureIndex(), localVariable.getIndex(),\n-            localVariable.getConstantPool());\n-    }\n@@ -123,2 +123,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -129,1 +130,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -133,11 +134,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public LocalVariable copy() {\n-        try {\n-            return (LocalVariable) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n@@ -149,1 +139,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @exception IOException if an I\/O error occurs.\n@@ -167,6 +157,0 @@\n-    \/**\n-     * @return index of register where variable is stored\n-     *\/\n-    public int getIndex() {\n-        return index;\n-    }\n@@ -181,0 +165,1 @@\n+\n@@ -185,1 +170,3 @@\n-        return constantPool.getConstantUtf8(nameIndex).getBytes();\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constantPool.getConstant(nameIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -188,0 +175,1 @@\n+\n@@ -195,6 +183,0 @@\n-    \/**\n-     * @return index of register where variable was originally stored\n-     *\/\n-    public int getOrigIndex() {\n-        return origIndex;\n-    }\n@@ -206,1 +188,3 @@\n-        return constantPool.getConstantUtf8(signatureIndex).getBytes();\n+        ConstantUtf8 c;\n+        c = (ConstantUtf8) constantPool.getConstant(signatureIndex, Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -209,0 +193,1 @@\n+\n@@ -216,0 +201,17 @@\n+\n+    \/**\n+     * @return index of register where variable is stored\n+     *\/\n+    public int getIndex() {\n+        return index;\n+    }\n+\n+\n+    \/**\n+     * @return index of register where variable was originally stored\n+     *\/\n+    public int getOrigIndex() {\n+        return origIndex;\n+    }\n+\n+\n@@ -223,2 +225,3 @@\n-    \/**\n-     * @param constantPool Constant pool to be used for this object.\n+\n+    \/*\n+     * Helper method shared with LocalVariableTypeTable\n@@ -226,2 +229,6 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n-        this.constantPool = constantPool;\n+    String toStringShared( final boolean typeTable ) {\n+        final String name = getName();\n+        final String signature = Utility.signatureToString(getSignature(), false);\n+        final String label = \"LocalVariable\" + (typeTable ? \"Types\" : \"\" );\n+        return label + \"(startPc = \" + startPc + \", length = \" + length + \", index = \"\n+                + index + \":\" + signature + \" \" + name + \")\";\n@@ -230,0 +237,1 @@\n+\n@@ -231,1 +239,1 @@\n-     * @param index the index in the local variable table of this variable\n+     * @param constantPool Constant pool to be used for this object.\n@@ -233,2 +241,2 @@\n-    public void setIndex(final int index) { \/\/ TODO unused\n-        this.index = index;\n+    public void setConstantPool( final ConstantPool constantPool ) {\n+        this.constantPool = constantPool;\n@@ -237,0 +245,1 @@\n+\n@@ -240,1 +249,1 @@\n-    public void setLength(final int length) {\n+    public void setLength( final int length ) {\n@@ -244,0 +253,1 @@\n+\n@@ -247,1 +257,1 @@\n-    public void setNameIndex(final int nameIndex) { \/\/ TODO unused\n+    public void setNameIndex( final int nameIndex ) { \/\/ TODO unused\n@@ -251,0 +261,1 @@\n+\n@@ -254,1 +265,1 @@\n-    public void setSignatureIndex(final int signatureIndex) { \/\/ TODO unused\n+    public void setSignatureIndex( final int signatureIndex ) { \/\/ TODO unused\n@@ -258,0 +269,9 @@\n+\n+    \/**\n+     * @param index the index in the local variable table of this variable\n+     *\/\n+    public void setIndex( final int index ) { \/\/ TODO unused\n+        this.index = index;\n+    }\n+\n+\n@@ -261,1 +281,1 @@\n-    public void setStartPC(final int startPc) { \/\/ TODO unused\n+    public void setStartPC( final int startPc ) { \/\/ TODO unused\n@@ -265,0 +285,1 @@\n+\n@@ -273,2 +294,3 @@\n-    \/*\n-     * Helper method shared with LocalVariableTypeTable\n+\n+    \/**\n+     * @return deep copy of this object\n@@ -276,5 +298,7 @@\n-    String toStringShared(final boolean typeTable) {\n-        final String name = getName();\n-        final String signature = Utility.signatureToString(getSignature(), false);\n-        final String label = \"LocalVariable\" + (typeTable ? \"Types\" : \"\");\n-        return label + \"(startPc = \" + startPc + \", length = \" + length + \", index = \" + index + \":\" + signature + \" \" + name + \")\";\n+    public LocalVariable copy() {\n+        try {\n+            return (LocalVariable) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariable.java","additions":127,"deletions":103,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -32,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -35,2 +31,2 @@\n- * This class represents colection of local variables in a method. This attribute is contained in the <em>Code<\/em>\n- * attribute.\n+ * This class represents colection of local variables in a\n+ * method. This attribute is contained in the <em>Code<\/em> attribute.\n@@ -38,1 +34,1 @@\n- * @see Code\n+ * @see     Code\n@@ -41,1 +37,1 @@\n-public class LocalVariableTable extends Attribute implements Iterable<LocalVariable> {\n+public class LocalVariableTable extends Attribute {\n@@ -45,0 +41,1 @@\n+\n@@ -46,7 +43,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -54,7 +46,2 @@\n-    LocalVariableTable(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (LocalVariable[]) null, constantPool);\n-        final int localVariableTableLength = input.readUnsignedShort();\n-        localVariableTable = new LocalVariable[localVariableTableLength];\n-        for (int i = 0; i < localVariableTableLength; i++) {\n-            localVariableTable[i] = new LocalVariable(input, constantPool);\n-        }\n+    public LocalVariableTable(final LocalVariableTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTable(), c.getConstantPool());\n@@ -63,0 +50,1 @@\n+\n@@ -64,1 +52,1 @@\n-     * @param nameIndex Index in constant pool to 'LocalVariableTable'\n+     * @param nameIndex Index in constant pool to `LocalVariableTable'\n@@ -69,1 +57,2 @@\n-    public LocalVariableTable(final int nameIndex, final int length, final LocalVariable[] localVariableTable, final ConstantPool constantPool) {\n+    public LocalVariableTable(final int nameIndex, final int length, final LocalVariable[] localVariableTable,\n+            final ConstantPool constantPool) {\n@@ -71,2 +60,1 @@\n-        this.localVariableTable = localVariableTable != null ? localVariableTable : LocalVariable.EMPTY_ARRAY;\n-        Args.requireU2(this.localVariableTable.length, \"localVariableTable.length\");\n+        this.localVariableTable = localVariableTable;\n@@ -75,0 +63,1 @@\n+\n@@ -76,4 +65,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -81,2 +72,8 @@\n-    public LocalVariableTable(final LocalVariableTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTable(), c.getConstantPool());\n+    LocalVariableTable(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (LocalVariable[]) null, constant_pool);\n+        final int local_variable_table_length = input.readUnsignedShort();\n+        localVariableTable = new LocalVariable[local_variable_table_length];\n+        for (int i = 0; i < local_variable_table_length; i++) {\n+            localVariableTable[i] = new LocalVariable(input, constant_pool);\n+        }\n@@ -85,0 +82,1 @@\n+\n@@ -86,2 +84,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -92,1 +91,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -96,11 +95,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final LocalVariableTable c = (LocalVariableTable) clone();\n-        c.localVariableTable = new LocalVariable[localVariableTable.length];\n-        Arrays.setAll(c.localVariableTable, i -> localVariableTable[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -112,1 +100,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -115,1 +103,1 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n+    public final void dump( final DataOutputStream file ) throws IOException {\n@@ -123,0 +111,9 @@\n+\n+    \/**\n+     * @return Array of local variables of method.\n+     *\/\n+    public final LocalVariable[] getLocalVariableTable() {\n+        return localVariableTable;\n+    }\n+\n+\n@@ -129,2 +126,2 @@\n-     * @deprecated since 5.2 because multiple variables can share the same slot, use getLocalVariable(int index, int pc)\n-     *             instead.\n+     * @deprecated since 5.2 because multiple variables can share the\n+     *             same slot, use getLocalVariable(int index, int pc) instead.\n@@ -133,1 +130,1 @@\n-    public final LocalVariable getLocalVariable(final int index) {\n+    public final LocalVariable getLocalVariable( final int index ) {\n@@ -142,0 +139,1 @@\n+\n@@ -149,1 +147,1 @@\n-    public final LocalVariable getLocalVariable(final int index, final int pc) {\n+    public final LocalVariable getLocalVariable( final int index, final int pc ) {\n@@ -152,3 +150,3 @@\n-                final int startPc = variable.getStartPC();\n-                final int endPc = startPc + variable.getLength();\n-                if (pc >= startPc && pc <= endPc) {\n+                final int start_pc = variable.getStartPC();\n+                final int end_pc = start_pc + variable.getLength();\n+                if ((pc >= start_pc) && (pc <= end_pc)) {\n@@ -162,10 +160,0 @@\n-    \/**\n-     * @return Array of local variables of method.\n-     *\/\n-    public final LocalVariable[] getLocalVariableTable() {\n-        return localVariableTable;\n-    }\n-\n-    public final int getTableLength() {\n-        return localVariableTable == null ? 0 : localVariableTable.length;\n-    }\n@@ -173,3 +161,2 @@\n-    @Override\n-    public Iterator<LocalVariable> iterator() {\n-        return Stream.of(localVariableTable).iterator();\n+    public final void setLocalVariableTable( final LocalVariable[] local_variable_table ) {\n+        this.localVariableTable = local_variable_table;\n@@ -178,3 +165,0 @@\n-    public final void setLocalVariableTable(final LocalVariable[] localVariableTable) {\n-        this.localVariableTable = localVariableTable;\n-    }\n@@ -196,0 +180,20 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final LocalVariableTable c = (LocalVariableTable) clone();\n+        c.localVariableTable = new LocalVariable[localVariableTable.length];\n+        for (int i = 0; i < localVariableTable.length; i++) {\n+            c.localVariableTable[i] = localVariableTable[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n+\n+\n+    public final int getTableLength() {\n+        return localVariableTable == null ? 0 : localVariableTable.length;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTable.java","additions":75,"deletions":71,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -26,3 +26,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -31,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -64,1 +60,1 @@\n-public class LocalVariableTypeTable extends Attribute implements Iterable<LocalVariable> {\n+public class LocalVariableTypeTable extends Attribute {\n@@ -66,1 +62,10 @@\n-    private LocalVariable[] localVariableTypeTable; \/\/ variables\n+    private LocalVariable[] localVariableTypeTable;        \/\/ variables\n+\n+    public LocalVariableTypeTable(final LocalVariableTypeTable c) {\n+        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTypeTable(), c.getConstantPool());\n+    }\n+\n+    public LocalVariableTypeTable(final int name_index, final int length, final LocalVariable[] local_variable_table, final ConstantPool constant_pool) {\n+        super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, name_index, length, constant_pool);\n+        this.localVariableTypeTable = local_variable_table;\n+    }\n@@ -71,2 +76,2 @@\n-        final int localVariableTypeTableLength = input.readUnsignedShort();\n-        localVariableTypeTable = new LocalVariable[localVariableTypeTableLength];\n+        final int local_variable_type_table_length = input.readUnsignedShort();\n+        localVariableTypeTable = new LocalVariable[local_variable_type_table_length];\n@@ -74,1 +79,1 @@\n-        for (int i = 0; i < localVariableTypeTableLength; i++) {\n+        for (int i = 0; i < local_variable_type_table_length; i++) {\n@@ -79,10 +84,0 @@\n-    public LocalVariableTypeTable(final int nameIndex, final int length, final LocalVariable[] localVariableTypeTable, final ConstantPool constantPool) {\n-        super(Const.ATTR_LOCAL_VARIABLE_TYPE_TABLE, nameIndex, length, constantPool);\n-        this.localVariableTypeTable = localVariableTypeTable != null ? localVariableTypeTable : LocalVariable.EMPTY_ARRAY;\n-        Args.requireU2(this.localVariableTypeTable.length, \"localVariableTypeTable.length\");\n-    }\n-\n-    public LocalVariableTypeTable(final LocalVariableTypeTable c) {\n-        this(c.getNameIndex(), c.getLength(), c.getLocalVariableTypeTable(), c.getConstantPool());\n-    }\n-\n@@ -94,13 +89,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final LocalVariableTypeTable c = (LocalVariableTypeTable) clone();\n-\n-        c.localVariableTypeTable = new LocalVariable[localVariableTypeTable.length];\n-        Arrays.setAll(c.localVariableTypeTable, i -> localVariableTypeTable[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n-\n@@ -116,0 +98,4 @@\n+    public final LocalVariable[] getLocalVariableTypeTable() {\n+        return localVariableTypeTable;\n+    }\n+\n@@ -126,15 +112,2 @@\n-    public final LocalVariable[] getLocalVariableTypeTable() {\n-        return localVariableTypeTable;\n-    }\n-\n-    public final int getTableLength() {\n-        return localVariableTypeTable == null ? 0 : localVariableTypeTable.length;\n-    }\n-\n-    @Override\n-    public Iterator<LocalVariable> iterator() {\n-        return Stream.of(localVariableTypeTable).iterator();\n-    }\n-\n-    public final void setLocalVariableTable(final LocalVariable[] localVariableTable) {\n-        this.localVariableTypeTable = localVariableTable;\n+    public final void setLocalVariableTable(final LocalVariable[] local_variable_table) {\n+        this.localVariableTypeTable = local_variable_table;\n@@ -160,0 +133,20 @@\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy(final ConstantPool constant_pool) {\n+        final LocalVariableTypeTable c = (LocalVariableTypeTable) clone();\n+\n+        c.localVariableTypeTable = new LocalVariable[localVariableTypeTable.length];\n+        for (int i = 0; i < localVariableTypeTable.length; i++) {\n+            c.localVariableTypeTable[i] = localVariableTypeTable[i].copy();\n+        }\n+\n+        c.setConstantPool(constant_pool);\n+        return c;\n+    }\n+\n+    public final int getTableLength() {\n+        return localVariableTypeTable == null ? 0 : localVariableTypeTable.length;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/LocalVariableTypeTable.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import com.sun.org.apache.bcel.internal.Const;\n@@ -31,2 +32,4 @@\n- * This class represents the method info structure, i.e., the representation for a method in the class. See JVM\n- * specification for details. A method has access flags, a name, a signature and a number of attributes.\n+ * This class represents the method info structure, i.e., the representation\n+ * for a method in the class. See JVM specification for details.\n+ * A method has access flags, a name, a signature and a number of attributes.\n+ *\n@@ -36,7 +39,0 @@\n-    \/**\n-     * Empty array constant.\n-     *\n-     * @since 6.6.0\n-     *\/\n-    public static final Method[] EMPTY_ARRAY = {};\n-\n@@ -46,1 +42,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -49,1 +45,2 @@\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -52,0 +49,1 @@\n+\n@@ -53,1 +51,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -59,11 +57,2 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    static final Method[] EMPTY_METHOD_ARRAY = {};\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n+    \/\/ annotations defined on the parameters of a method\n+    private ParameterAnnotationEntry[] parameterAnnotationEntries;\n@@ -72,1 +61,2 @@\n-     * @param comparator Comparison strategy object\n+     * Empty constructor, all attributes have to be defined via `setXXX'\n+     * methods. Use at your own risk.\n@@ -74,2 +64,1 @@\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n+    public Method() {\n@@ -78,2 +67,0 @@\n-    \/\/ annotations defined on the parameters of a method\n-    private ParameterAnnotationEntry[] parameterAnnotationEntries;\n@@ -82,1 +69,2 @@\n-     * Empty constructor, all attributes have to be defined via 'setXXX' methods. Use at your own risk.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n@@ -84,1 +72,2 @@\n-    public Method() {\n+    public Method(final Method c) {\n+        super(c);\n@@ -87,0 +76,1 @@\n+\n@@ -89,1 +79,0 @@\n-     *\n@@ -91,2 +80,2 @@\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws IOException\n+     * @throws ClassFormatException\n@@ -94,2 +83,3 @@\n-    Method(final DataInput file, final ConstantPool constantPool) throws IOException, ClassFormatException {\n-        super(file, constantPool);\n+    Method(final DataInput file, final ConstantPool constant_pool) throws IOException,\n+            ClassFormatException {\n+        super(file, constant_pool);\n@@ -98,0 +88,1 @@\n+\n@@ -99,3 +90,3 @@\n-     * @param accessFlags Access rights of method\n-     * @param nameIndex Points to field name in constant pool\n-     * @param signatureIndex Points to encoded signature\n+     * @param access_flags Access rights of method\n+     * @param name_index Points to field name in constant pool\n+     * @param signature_index Points to encoded signature\n@@ -103,1 +94,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -105,2 +96,3 @@\n-    public Method(final int accessFlags, final int nameIndex, final int signatureIndex, final Attribute[] attributes, final ConstantPool constantPool) {\n-        super(accessFlags, nameIndex, signatureIndex, attributes, constantPool);\n+    public Method(final int access_flags, final int name_index, final int signature_index, final Attribute[] attributes,\n+            final ConstantPool constant_pool) {\n+        super(access_flags, name_index, signature_index, attributes, constant_pool);\n@@ -109,9 +101,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Method(final Method c) {\n-        super(c);\n-    }\n@@ -120,2 +103,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -126,1 +110,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -130,24 +114,0 @@\n-    \/**\n-     * @return deep copy of this method\n-     *\/\n-    public Method copy(final ConstantPool constantPool) {\n-        return (Method) copy_(constantPool);\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two method objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n-\n-    \/**\n-     * @return array of method argument types\n-     *\/\n-    public Type[] getArgumentTypes() {\n-        return Type.getArgumentTypes(getSignature());\n-    }\n@@ -167,0 +127,1 @@\n+\n@@ -168,2 +129,2 @@\n-     * @return ExceptionTable attribute of method, if any, i.e., list all exceptions the method may throw not exception\n-     *         handlers!\n+     * @return ExceptionTable attribute of method, if any, i.e., list all\n+     * exceptions the method may throw not exception handlers!\n@@ -180,10 +141,0 @@\n-    \/**\n-     * @return LineNumberTable of code attribute if any, i.e. the call is forwarded to the Code atribute.\n-     *\/\n-    public LineNumberTable getLineNumberTable() {\n-        final Code code = getCode();\n-        if (code == null) {\n-            return null;\n-        }\n-        return code.getLineNumberTable();\n-    }\n@@ -191,2 +142,2 @@\n-    \/**\n-     * @return LocalVariableTable of code attribute if any, i.e. the call is forwarded to the Code atribute.\n+    \/** @return LocalVariableTable of code attribute if any, i.e. the call is forwarded\n+     * to the Code atribute.\n@@ -202,10 +153,0 @@\n-    \/**\n-     * @return Annotations on the parameters of a method\n-     * @since 6.0\n-     *\/\n-    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n-        if (parameterAnnotationEntries == null) {\n-            parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());\n-        }\n-        return parameterAnnotationEntries;\n-    }\n@@ -213,2 +154,2 @@\n-    \/**\n-     * @return return type of method\n+    \/** @return LineNumberTable of code attribute if any, i.e. the call is forwarded\n+     * to the Code atribute.\n@@ -216,2 +157,6 @@\n-    public Type getReturnType() {\n-        return Type.getReturnType(getSignature());\n+    public LineNumberTable getLineNumberTable() {\n+        final Code code = getCode();\n+        if (code == null) {\n+            return null;\n+        }\n+        return code.getLineNumberTable();\n@@ -220,10 +165,0 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n@@ -232,2 +167,2 @@\n-     * Return string representation close to declaration format, 'public static void main(String[] args) throws\n-     * IOException', e.g.\n+     * Return string representation close to declaration format,\n+     * `public static void main(String[] args) throws IOException', e.g.\n@@ -241,1 +176,1 @@\n-        ConstantUtf8 c = super.getConstantPool().getConstantUtf8(super.getSignatureIndex());\n+        ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(super.getSignatureIndex(), Const.CONSTANT_Utf8);\n@@ -243,1 +178,1 @@\n-        c = super.getConstantPool().getConstantUtf8(super.getNameIndex());\n+        c = (ConstantUtf8) super.getConstantPool().getConstant(super.getNameIndex(), Const.CONSTANT_Utf8);\n@@ -245,1 +180,2 @@\n-        signature = Utility.methodSignatureToString(signature, name, access, true, getLocalVariableTable());\n+        signature = Utility.methodSignatureToString(signature, name, access, true,\n+                getLocalVariableTable());\n@@ -248,1 +184,1 @@\n-            if (!(attribute instanceof Code || attribute instanceof ExceptionTable)) {\n+            if (!((attribute instanceof Code) || (attribute instanceof ExceptionTable))) {\n@@ -261,0 +197,76 @@\n+\n+\n+    \/**\n+     * @return deep copy of this method\n+     *\/\n+    public Method copy( final ConstantPool _constant_pool ) {\n+        return (Method) copy_(_constant_pool);\n+    }\n+\n+\n+    \/**\n+     * @return return type of method\n+     *\/\n+    public Type getReturnType() {\n+        return Type.getReturnType(getSignature());\n+    }\n+\n+\n+    \/**\n+     * @return array of method argument types\n+     *\/\n+    public Type[] getArgumentTypes() {\n+        return Type.getArgumentTypes(getSignature());\n+    }\n+\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two method objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the method's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n+    }\n+\n+    \/**\n+     * @return Annotations on the parameters of a method\n+     * @since 6.0\n+     *\/\n+    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n+        if (parameterAnnotationEntries == null) {\n+            parameterAnnotationEntries = ParameterAnnotationEntry.createParameterAnnotationEntries(getAttributes());\n+        }\n+        return parameterAnnotationEntries;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Method.java","additions":133,"deletions":121,"binary":false,"changes":254,"status":"modified"},{"patch":"@@ -33,2 +33,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\"> The class File Format :\n- *      The MethodParameters Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\">\n+ * The class File Format : The MethodParameters Attribute<\/a>\n@@ -37,1 +37,1 @@\n-public class MethodParameter implements Cloneable, Node {\n+public class MethodParameter implements Cloneable {\n@@ -52,2 +52,2 @@\n-     * @throws IOException if an I\/O error occurs.\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws java.io.IOException\n+     * @throws ClassFormatException\n@@ -60,3 +60,2 @@\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitMethodParameter(this);\n+    public int getNameIndex() {\n+        return nameIndex;\n@@ -65,10 +64,2 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public MethodParameter copy() {\n-        try {\n-            return (MethodParameter) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public void setNameIndex(final int name_index) {\n+        this.nameIndex = name_index;\n@@ -78,4 +69,1 @@\n-     * Dump object to file stream on binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * Returns the name of the parameter.\n@@ -83,4 +71,6 @@\n-    public final void dump(final DataOutputStream file) throws IOException {\n-        file.writeShort(nameIndex);\n-        file.writeShort(accessFlags);\n-    }\n+    public String getParameterName(final ConstantPool constant_pool) {\n+        if (nameIndex == 0) {\n+            return null;\n+        }\n+        return ((ConstantUtf8) constant_pool.getConstant(nameIndex, Const.CONSTANT_Utf8)).getBytes();\n+       }\n@@ -92,12 +82,2 @@\n-    public int getNameIndex() {\n-        return nameIndex;\n-    }\n-\n-    \/**\n-     * Returns the name of the parameter.\n-     *\/\n-    public String getParameterName(final ConstantPool constantPool) {\n-        if (nameIndex == 0) {\n-            return null;\n-        }\n-        return constantPool.getConstantUtf8(nameIndex).getBytes();\n+    public void setAccessFlags(final int access_flags) {\n+        this.accessFlags = access_flags;\n@@ -110,0 +90,4 @@\n+    public boolean isSynthetic() {\n+        return (accessFlags & Const.ACC_SYNTHETIC) != 0;\n+    }\n+\n@@ -114,2 +98,2 @@\n-    public boolean isSynthetic() {\n-        return (accessFlags & Const.ACC_SYNTHETIC) != 0;\n+    public void accept(final Visitor v) {\n+        v.visitMethodParameter(this);\n@@ -118,2 +102,9 @@\n-    public void setAccessFlags(final int accessFlags) {\n-        this.accessFlags = accessFlags;\n+    \/**\n+     * Dump object to file stream on binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException\n+     *\/\n+    public final void dump(final DataOutputStream file) throws IOException {\n+        file.writeShort(nameIndex);\n+        file.writeShort(accessFlags);\n@@ -122,2 +113,10 @@\n-    public void setNameIndex(final int nameIndex) {\n-        this.nameIndex = nameIndex;\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public MethodParameter copy() {\n+        try {\n+            return (MethodParameter) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameter.java","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -27,3 +27,0 @@\n-import java.util.Arrays;\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -36,2 +33,2 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\"> The class File Format :\n- *      The MethodParameters Attribute<\/a>\n+ * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.24\">\n+ * The class File Format : The MethodParameters Attribute<\/a>\n@@ -40,1 +37,1 @@\n-public class MethodParameters extends Attribute implements Iterable<MethodParameter> {\n+public class MethodParameters extends Attribute {\n@@ -42,6 +39,1 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    private static final MethodParameter[] EMPTY_METHOD_PARAMETER_ARRAY = {};\n-\n-    private MethodParameter[] parameters = EMPTY_METHOD_PARAMETER_ARRAY;\n+    private MethodParameter[] parameters = new MethodParameter[0];\n@@ -49,2 +41,2 @@\n-    MethodParameters(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_METHOD_PARAMETERS, nameIndex, length, constantPool);\n+    MethodParameters(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        super(Const.ATTR_METHOD_PARAMETERS, name_index, length, constant_pool);\n@@ -52,3 +44,3 @@\n-        final int parameterCount = input.readUnsignedByte();\n-        parameters = new MethodParameter[parameterCount];\n-        for (int i = 0; i < parameterCount; i++) {\n+        final int parameters_count = input.readUnsignedByte();\n+        parameters = new MethodParameter[parameters_count];\n+        for (int i = 0; i < parameters_count; i++) {\n@@ -59,0 +51,8 @@\n+    public MethodParameter[] getParameters() {\n+        return parameters;\n+    }\n+\n+    public void setParameters(final MethodParameter[] parameters) {\n+        this.parameters = parameters;\n+    }\n+\n@@ -65,1 +65,1 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool _constant_pool) {\n@@ -69,2 +69,4 @@\n-        Arrays.setAll(c.parameters, i -> parameters[i].copy());\n-        c.setConstantPool(constantPool);\n+        for (int i = 0; i < parameters.length; i++) {\n+            c.parameters[i] = parameters[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n@@ -78,1 +80,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -81,3 +83,3 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n-        super.dump(file);\n-        file.writeByte(parameters.length);\n+       public void dump(final DataOutputStream file) throws IOException {\n+           super.dump(file);\n+           file.writeByte(parameters.length);\n@@ -88,13 +90,0 @@\n-\n-    public MethodParameter[] getParameters() {\n-        return parameters;\n-    }\n-\n-    @Override\n-    public Iterator<MethodParameter> iterator() {\n-        return Stream.of(parameters).iterator();\n-    }\n-\n-    public void setParameters(final MethodParameter[] parameters) {\n-        this.parameters = parameters;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/MethodParameters.java","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.util.Arrays;\n@@ -32,2 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and represents the list of modules required, exported, opened or\n- * provided by a module. There may be at most one Module attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and represents the list of\n+ * modules required, exported, opened or provided by a module.\n+ * There may be at most one Module attribute in a ClassFile structure.\n@@ -35,1 +35,1 @@\n- * @see Attribute\n+ * @see   Attribute\n@@ -40,7 +40,0 @@\n-    \/**\n-     * The module file name extension.\n-     *\n-     * @since 6.7.0\n-     *\/\n-    public static final String EXTENSION = \".jmod\";\n-\n@@ -60,2 +53,1 @@\n-     *\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -64,2 +56,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -67,2 +59,2 @@\n-    Module(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_MODULE, nameIndex, length, constantPool);\n+    Module(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        super(Const.ATTR_MODULE, name_index, length, constant_pool);\n@@ -74,3 +66,3 @@\n-        final int requiresCount = input.readUnsignedShort();\n-        requiresTable = new ModuleRequires[requiresCount];\n-        for (int i = 0; i < requiresCount; i++) {\n+        final int requires_count = input.readUnsignedShort();\n+        requiresTable = new ModuleRequires[requires_count];\n+        for (int i = 0; i < requires_count; i++) {\n@@ -80,3 +72,3 @@\n-        final int exportsCount = input.readUnsignedShort();\n-        exportsTable = new ModuleExports[exportsCount];\n-        for (int i = 0; i < exportsCount; i++) {\n+        final int exports_count = input.readUnsignedShort();\n+        exportsTable = new ModuleExports[exports_count];\n+        for (int i = 0; i < exports_count; i++) {\n@@ -86,3 +78,3 @@\n-        final int opensCount = input.readUnsignedShort();\n-        opensTable = new ModuleOpens[opensCount];\n-        for (int i = 0; i < opensCount; i++) {\n+        final int opens_count = input.readUnsignedShort();\n+        opensTable = new ModuleOpens[opens_count];\n+        for (int i = 0; i < opens_count; i++) {\n@@ -98,3 +90,3 @@\n-        final int providesCount = input.readUnsignedShort();\n-        providesTable = new ModuleProvides[providesCount];\n-        for (int i = 0; i < providesCount; i++) {\n+        final int provides_count = input.readUnsignedShort();\n+        providesTable = new ModuleProvides[provides_count];\n+        for (int i = 0; i < provides_count; i++) {\n@@ -105,0 +97,1 @@\n+\n@@ -106,2 +99,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -112,1 +106,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -119,1 +113,2 @@\n-     * @return deep copy of this attribute\n+     * @return table of required modules\n+     * @see ModuleRequires\n@@ -121,3 +116,3 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Module c = (Module) clone();\n+    public ModuleRequires[] getRequiresTable() {\n+        return requiresTable;\n+    }\n@@ -125,2 +120,0 @@\n-        c.requiresTable = new ModuleRequires[requiresTable.length];\n-        Arrays.setAll(c.requiresTable, i -> requiresTable[i].copy());\n@@ -128,2 +121,7 @@\n-        c.exportsTable = new ModuleExports[exportsTable.length];\n-        Arrays.setAll(c.exportsTable, i -> exportsTable[i].copy());\n+    \/**\n+     * @return table of exported interfaces\n+     * @see ModuleExports\n+     *\/\n+    public ModuleExports[] getExportsTable() {\n+        return exportsTable;\n+    }\n@@ -131,2 +129,0 @@\n-        c.opensTable = new ModuleOpens[opensTable.length];\n-        Arrays.setAll(c.opensTable, i -> opensTable[i].copy());\n@@ -134,2 +130,7 @@\n-        c.providesTable = new ModuleProvides[providesTable.length];\n-        Arrays.setAll(c.providesTable, i -> providesTable[i].copy());\n+    \/**\n+     * @return table of provided interfaces\n+     * @see ModuleOpens\n+     *\/\n+    public ModuleOpens[] getOpensTable() {\n+        return opensTable;\n+    }\n@@ -137,2 +138,7 @@\n-        c.setConstantPool(constantPool);\n-        return c;\n+\n+    \/**\n+     * @return table of provided interfaces\n+     * @see ModuleProvides\n+     *\/\n+    public ModuleProvides[] getProvidesTable() {\n+        return providesTable;\n@@ -141,0 +147,1 @@\n+\n@@ -145,1 +152,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -148,1 +155,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -181,31 +188,0 @@\n-    \/**\n-     * @return table of exported interfaces\n-     * @see ModuleExports\n-     *\/\n-    public ModuleExports[] getExportsTable() {\n-        return exportsTable;\n-    }\n-\n-    \/**\n-     * @return table of provided interfaces\n-     * @see ModuleOpens\n-     *\/\n-    public ModuleOpens[] getOpensTable() {\n-        return opensTable;\n-    }\n-\n-    \/**\n-     * @return table of provided interfaces\n-     * @see ModuleProvides\n-     *\/\n-    public ModuleProvides[] getProvidesTable() {\n-        return providesTable;\n-    }\n-\n-    \/**\n-     * @return table of required modules\n-     * @see ModuleRequires\n-     *\/\n-    public ModuleRequires[] getRequiresTable() {\n-        return requiresTable;\n-    }\n@@ -221,2 +197,2 @@\n-        buf.append(\"  name:    \").append(Utility.pathToPackage(cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module))).append(\"\\n\");\n-        buf.append(\"  flags:   \").append(String.format(\"%04x\", moduleFlags)).append(\"\\n\");\n+        buf.append(\"  name:    \") .append(cp.getConstantString(moduleNameIndex, Const.CONSTANT_Module).replace('\/', '.')).append(\"\\n\");\n+        buf.append(\"  flags:   \") .append(String.format(\"%04x\", moduleFlags)).append(\"\\n\");\n@@ -224,1 +200,1 @@\n-        buf.append(\"  version: \").append(version).append(\"\\n\");\n+        buf.append(\"  version: \") .append(version).append(\"\\n\");\n@@ -243,2 +219,2 @@\n-            final String className = cp.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"    \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String class_name = cp.getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"    \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n@@ -252,1 +228,33 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Module c = (Module) clone();\n+\n+        c.requiresTable = new ModuleRequires[requiresTable.length];\n+        for (int i = 0; i < requiresTable.length; i++) {\n+            c.requiresTable[i] = requiresTable[i].copy();\n+        }\n+\n+        c.exportsTable = new ModuleExports[exportsTable.length];\n+        for (int i = 0; i < exportsTable.length; i++) {\n+            c.exportsTable[i] = exportsTable[i].copy();\n+        }\n+\n+        c.opensTable = new ModuleOpens[opensTable.length];\n+        for (int i = 0; i < opensTable.length; i++) {\n+            c.opensTable[i] = opensTable[i].copy();\n+        }\n+\n+        c.providesTable = new ModuleProvides[providesTable.length];\n+        for (int i = 0; i < providesTable.length; i++) {\n+            c.providesTable[i] = providesTable[i].copy();\n+        }\n+\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Module.java","additions":93,"deletions":85,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the exports table of the Module attribute. Each entry describes a package which may\n- * open the parent module.\n+ * This class represents an entry in the exports table of the Module attribute.\n+ * Each entry describes a package which may open the parent module.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int exportsIndex; \/\/ points to CONSTANT_Package_info\n+    private final int exportsIndex;  \/\/ points to CONSTANT_Package_info\n@@ -42,1 +42,2 @@\n-    private final int[] exportsToIndex; \/\/ points to CONSTANT_Module_info\n+    private final int[] exportsToIndex;  \/\/ points to CONSTANT_Module_info\n+\n@@ -60,0 +61,1 @@\n+\n@@ -61,2 +63,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -67,1 +70,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -73,12 +76,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleExports copy() {\n-        try {\n-            return (ModuleExports) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -91,1 +82,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -100,0 +91,1 @@\n+\n@@ -108,0 +100,1 @@\n+\n@@ -111,1 +104,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -113,2 +106,2 @@\n-        final String packageName = constantPool.constantToString(exportsIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(packageName, false));\n+        final String package_name = constant_pool.constantToString(exportsIndex, Const.CONSTANT_Package);\n+        buf.append(Utility.compactClassName(package_name, false));\n@@ -118,2 +111,15 @@\n-            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n+            final String module_name = constant_pool.getConstantString(index, Const.CONSTANT_Module);\n+            buf.append(\"      \").append(Utility.compactClassName(module_name, false)).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleExports copy() {\n+        try {\n+            return (ModuleExports) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n@@ -121,1 +127,1 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleExports.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,2 @@\n- * This class is derived from <em>Attribute<\/em> and indicates the main class of a module. There may be at most one\n- * ModuleMainClass attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and indicates the main class of a module.\n+ * There may be at most one ModuleMainClass attribute in a ClassFile structure.\n@@ -35,1 +34,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -41,0 +40,1 @@\n+\n@@ -42,7 +42,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -50,3 +45,2 @@\n-    ModuleMainClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, 0, constantPool);\n-        mainClassIndex = input.readUnsignedShort();\n+    public ModuleMainClass(final ModuleMainClass c) {\n+        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n@@ -55,0 +49,1 @@\n+\n@@ -56,1 +51,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -61,3 +56,4 @@\n-    public ModuleMainClass(final int nameIndex, final int length, final int mainClassIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_NEST_MEMBERS, nameIndex, length, constantPool);\n-        this.mainClassIndex = Args.requireU2(mainClassIndex, \"mainClassIndex\");\n+    public ModuleMainClass(final int name_index, final int length, final int mainClassIndex,\n+            final ConstantPool constantPool) {\n+        super(Const.ATTR_NEST_MEMBERS, name_index, length, constantPool);\n+        this.mainClassIndex = mainClassIndex;\n@@ -66,0 +62,1 @@\n+\n@@ -67,4 +64,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param nameIndex Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constantPool Array of constants\n+     * @throws IOException\n@@ -72,2 +71,3 @@\n-    public ModuleMainClass(final ModuleMainClass c) {\n-        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n+    ModuleMainClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(nameIndex, length, 0, constantPool);\n+        mainClassIndex = input.readUnsignedShort();\n@@ -76,0 +76,1 @@\n+\n@@ -77,2 +78,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class. I.e.,\n-     * the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitly\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -83,1 +85,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -87,9 +89,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ModuleMainClass c = (ModuleMainClass) clone();\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -104,1 +97,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -109,0 +102,1 @@\n+\n@@ -116,0 +110,1 @@\n+\n@@ -119,1 +114,1 @@\n-    public void setHostClassIndex(final int mainClassIndex) {\n+    public void setHostClassIndex( final int mainClassIndex ) {\n@@ -123,0 +118,1 @@\n+\n@@ -130,2 +126,2 @@\n-        final String className = super.getConstantPool().getConstantString(mainClassIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(className, false));\n+        final String class_name = super.getConstantPool().getConstantString(mainClassIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(class_name, false));\n@@ -134,0 +130,11 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ModuleMainClass c = (ModuleMainClass) clone();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleMainClass.java","additions":47,"deletions":40,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the opens table of the Module attribute. Each entry describes a package which the\n- * parent module opens.\n+ * This class represents an entry in the opens table of the Module attribute.\n+ * Each entry describes a package which the parent module opens.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int opensIndex; \/\/ points to CONSTANT_Package_info\n+    private final int opensIndex;  \/\/ points to CONSTANT_Package_info\n@@ -42,1 +42,2 @@\n-    private final int[] opensToIndex; \/\/ points to CONSTANT_Module_info\n+    private final int[] opensToIndex;  \/\/ points to CONSTANT_Module_info\n+\n@@ -60,0 +61,1 @@\n+\n@@ -61,2 +63,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -67,1 +70,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -73,12 +76,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleOpens copy() {\n-        try {\n-            return (ModuleOpens) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -91,1 +82,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -100,0 +91,1 @@\n+\n@@ -108,0 +100,1 @@\n+\n@@ -111,1 +104,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -113,2 +106,2 @@\n-        final String packageName = constantPool.constantToString(opensIndex, Const.CONSTANT_Package);\n-        buf.append(Utility.compactClassName(packageName, false));\n+        final String package_name = constant_pool.constantToString(opensIndex, Const.CONSTANT_Package);\n+        buf.append(Utility.compactClassName(package_name, false));\n@@ -118,2 +111,15 @@\n-            final String moduleName = constantPool.getConstantString(index, Const.CONSTANT_Module);\n-            buf.append(\"      \").append(Utility.compactClassName(moduleName, false)).append(\"\\n\");\n+            final String module_name = constant_pool.getConstantString(index, Const.CONSTANT_Module);\n+            buf.append(\"      \").append(Utility.compactClassName(module_name, false)).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleOpens copy() {\n+        try {\n+            return (ModuleOpens) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n@@ -121,1 +127,1 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleOpens.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents the list of packages that are exported or opened by the\n- * Module attribute. There may be at most one ModulePackages attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and represents the list of packages that are exported or opened by the Module attribute.\n+ * There may be at most one ModulePackages attribute in a ClassFile structure.\n@@ -35,2 +34,1 @@\n- * @see Attribute\n- * @LastModified: Feb 2023\n+ * @see     Attribute\n@@ -42,0 +40,1 @@\n+\n@@ -43,7 +42,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -51,7 +45,2 @@\n-    ModulePackages(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (int[]) null, constantPool);\n-        final int packageCount = input.readUnsignedShort();\n-        packageIndexTable = new int[packageCount];\n-        for (int i = 0; i < packageCount; i++) {\n-            packageIndexTable[i] = input.readUnsignedShort();\n-        }\n+    public ModulePackages(final ModulePackages c) {\n+        this(c.getNameIndex(), c.getLength(), c.getPackageIndexTable(), c.getConstantPool());\n@@ -60,0 +49,1 @@\n+\n@@ -66,1 +56,2 @@\n-    public ModulePackages(final int nameIndex, final int length, final int[] packageIndexTable, final ConstantPool constantPool) {\n+    public ModulePackages(final int nameIndex, final int length, final int[] packageIndexTable,\n+            final ConstantPool constantPool) {\n@@ -68,2 +59,1 @@\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n-        Args.requireU2(this.packageIndexTable.length, \"packageIndexTable.length\");\n+        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : new int[0];\n@@ -72,0 +62,1 @@\n+\n@@ -73,4 +64,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -78,2 +71,7 @@\n-    public ModulePackages(final ModulePackages c) {\n-        this(c.getNameIndex(), c.getLength(), c.getPackageIndexTable(), c.getConstantPool());\n+    ModulePackages(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (int[]) null, constant_pool);\n+        final int number_of_packages = input.readUnsignedShort();\n+        packageIndexTable = new int[number_of_packages];\n+        for (int i = 0; i < number_of_packages; i++) {\n+            packageIndexTable[i] = input.readUnsignedShort();\n+        }\n@@ -82,0 +80,1 @@\n+\n@@ -83,2 +82,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +89,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -93,12 +93,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final ModulePackages c = (ModulePackages) clone();\n-        if (packageIndexTable != null) {\n-            c.packageIndexTable = packageIndexTable.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -110,1 +98,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -113,1 +101,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -121,6 +109,0 @@\n-    \/**\n-     * @return Length of package table.\n-     *\/\n-    public int getNumberOfPackages() {\n-        return packageIndexTable == null ? 0 : packageIndexTable.length;\n-    }\n@@ -135,0 +117,9 @@\n+\n+    \/**\n+     * @return Length of package table.\n+     *\/\n+    public int getNumberOfPackages() {\n+        return packageIndexTable == null ? 0 : packageIndexTable.length;\n+    }\n+\n+\n@@ -140,1 +131,4 @@\n-        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(packageIndexTable[i], Const.CONSTANT_Package)));\n+        for (int i = 0; i < packageIndexTable.length; i++) {\n+            names[i] = super.getConstantPool().getConstantString(packageIndexTable[i],\n+                    Const.CONSTANT_Package).replace('\/', '.');\n+        }\n@@ -144,0 +138,1 @@\n+\n@@ -145,1 +140,2 @@\n-     * @param packageIndexTable the list of package indexes Also redefines number_of_packages according to table length.\n+     * @param packageIndexTable the list of package indexes\n+     * Also redefines number_of_packages according to table length.\n@@ -147,2 +143,2 @@\n-    public void setPackageIndexTable(final int[] packageIndexTable) {\n-        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : Const.EMPTY_INT_ARRAY;\n+    public void setPackageIndexTable( final int[] packageIndexTable ) {\n+        this.packageIndexTable = packageIndexTable != null ? packageIndexTable : new int[0];\n@@ -151,0 +147,1 @@\n+\n@@ -161,2 +158,2 @@\n-            final String packageName = super.getConstantPool().getConstantString(index, Const.CONSTANT_Package);\n-            buf.append(\"  \").append(Utility.compactClassName(packageName, false)).append(\"\\n\");\n+            final String package_name = super.getConstantPool().getConstantString(index, Const.CONSTANT_Package);\n+            buf.append(\"  \").append(Utility.compactClassName(package_name, false)).append(\"\\n\");\n@@ -164,1 +161,17 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final ModulePackages c = (ModulePackages) clone();\n+        if (packageIndexTable != null) {\n+            c.packageIndexTable = new int[packageIndexTable.length];\n+            System.arraycopy(packageIndexTable, 0, c.packageIndexTable, 0,\n+                    packageIndexTable.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModulePackages.java","additions":73,"deletions":60,"binary":false,"changes":133,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the provides table of the Module attribute. Each entry describes a service\n- * implementation that the parent module provides.\n+ * This class represents an entry in the provides table of the Module attribute.\n+ * Each entry describes a service implementation that the parent module provides.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int providesIndex; \/\/ points to CONSTANT_Class_info\n+    private final int providesIndex;  \/\/ points to CONSTANT_Class_info\n@@ -41,1 +41,2 @@\n-    private final int[] providesWithIndex; \/\/ points to CONSTANT_Class_info\n+    private final int[] providesWithIndex;  \/\/ points to CONSTANT_Class_info\n+\n@@ -58,0 +59,1 @@\n+\n@@ -59,2 +61,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -65,1 +68,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -71,12 +74,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleProvides copy() {\n-        try {\n-            return (ModuleProvides) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -89,1 +80,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -97,0 +88,1 @@\n+\n@@ -105,0 +97,1 @@\n+\n@@ -108,1 +101,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -110,2 +103,2 @@\n-        final String interfaceName = constantPool.constantToString(providesIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(interfaceName, false));\n+        final String interface_name = constant_pool.constantToString(providesIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(interface_name, false));\n@@ -114,2 +107,15 @@\n-            final String className = constantPool.getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"      \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String class_name = constant_pool.getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"      \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n+        }\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleProvides copy() {\n+        try {\n+            return (ModuleProvides) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n@@ -117,1 +123,1 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleProvides.java","additions":33,"deletions":27,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * This class represents an entry in the requires table of the Module attribute. Each entry describes a module on which\n- * the parent module depends.\n+ * This class represents an entry in the requires table of the Module attribute.\n+ * Each entry describes a module on which the parent module depends.\n@@ -34,1 +34,1 @@\n- * @see Module\n+ * @see   Module\n@@ -39,1 +39,1 @@\n-    private final int requiresIndex; \/\/ points to CONSTANT_Module_info\n+    private final int requiresIndex;  \/\/ points to CONSTANT_Module_info\n@@ -41,1 +41,2 @@\n-    private final int requiresVersionIndex; \/\/ either 0 or points to CONSTANT_Utf8_info\n+    private final int requiresVersionIndex;  \/\/ either 0 or points to CONSTANT_Utf8_info\n+\n@@ -55,0 +56,1 @@\n+\n@@ -56,2 +58,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -62,1 +65,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -68,12 +71,0 @@\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public ModuleRequires copy() {\n-        try {\n-            return (ModuleRequires) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n-    }\n-\n@@ -86,1 +77,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -92,0 +83,1 @@\n+\n@@ -100,0 +92,1 @@\n+\n@@ -103,1 +96,1 @@\n-    public String toString(final ConstantPool constantPool) {\n+    public String toString( final ConstantPool constant_pool ) {\n@@ -105,2 +98,2 @@\n-        final String moduleName = constantPool.constantToString(requiresIndex, Const.CONSTANT_Module);\n-        buf.append(Utility.compactClassName(moduleName, false));\n+        final String module_name = constant_pool.constantToString(requiresIndex, Const.CONSTANT_Module);\n+        buf.append(Utility.compactClassName(module_name, false));\n@@ -108,1 +101,1 @@\n-        final String version = requiresVersionIndex == 0 ? \"0\" : constantPool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n+        final String version = requiresVersionIndex == 0 ? \"0\" : constant_pool.getConstantString(requiresVersionIndex, Const.CONSTANT_Utf8);\n@@ -112,0 +105,13 @@\n+\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public ModuleRequires copy() {\n+        try {\n+            return (ModuleRequires) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ModuleRequires.java","additions":31,"deletions":25,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,2 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and records the nest host of the nest to which the current class or\n- * interface claims to belong. There may be at most one NestHost attribute in a ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and records the nest host of the nest\n+ * to which the current class or interface claims to belong.\n+ * There may be at most one NestHost attribute in a ClassFile structure.\n@@ -35,1 +35,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -41,0 +41,1 @@\n+\n@@ -42,7 +43,2 @@\n-     * Constructs object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initializes from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -50,3 +46,2 @@\n-    NestHost(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, 0, constantPool);\n-        hostClassIndex = input.readUnsignedShort();\n+    public NestHost(final NestHost c) {\n+        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n@@ -55,0 +50,1 @@\n+\n@@ -61,1 +57,2 @@\n-    public NestHost(final int nameIndex, final int length, final int hostClassIndex, final ConstantPool constantPool) {\n+    public NestHost(final int nameIndex, final int length, final int hostClassIndex,\n+            final ConstantPool constantPool) {\n@@ -63,1 +60,1 @@\n-        this.hostClassIndex = Args.requireU2(hostClassIndex, \"hostClassIndex\");\n+        this.hostClassIndex = hostClassIndex;\n@@ -66,0 +63,1 @@\n+\n@@ -67,4 +65,6 @@\n-     * Initializes from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Constructs object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -72,2 +72,3 @@\n-    public NestHost(final NestHost c) {\n-        this(c.getNameIndex(), c.getLength(), c.getHostClassIndex(), c.getConstantPool());\n+    NestHost(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, 0, constant_pool);\n+        hostClassIndex = input.readUnsignedShort();\n@@ -76,0 +77,1 @@\n+\n@@ -77,2 +79,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -83,1 +86,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -87,9 +90,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final NestHost c = (NestHost) clone();\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -104,1 +98,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -109,0 +103,1 @@\n+\n@@ -116,0 +111,1 @@\n+\n@@ -119,1 +115,1 @@\n-    public void setHostClassIndex(final int hostClassIndex) {\n+    public void setHostClassIndex( final int hostClassIndex ) {\n@@ -123,0 +119,1 @@\n+\n@@ -130,2 +127,2 @@\n-        final String className = super.getConstantPool().getConstantString(hostClassIndex, Const.CONSTANT_Class);\n-        buf.append(Utility.compactClassName(className, false));\n+        final String class_name = super.getConstantPool().getConstantString(hostClassIndex, Const.CONSTANT_Class);\n+        buf.append(Utility.compactClassName(class_name, false));\n@@ -134,0 +131,11 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final NestHost c = (NestHost) clone();\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/NestHost.java","additions":46,"deletions":38,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -26,1 +27,0 @@\n-import java.util.Arrays;\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,3 +31,3 @@\n- * This class is derived from <em>Attribute<\/em> and records the classes and interfaces that are authorized to claim\n- * membership in the nest hosted by the current class or interface. There may be at most one NestMembers attribute in a\n- * ClassFile structure.\n+ * This class is derived from <em>Attribute<\/em> and records the classes and interfaces that\n+ * are authorized to claim membership in the nest hosted by the current class or interface.\n+ * There may be at most one NestMembers attribute in a ClassFile structure.\n@@ -36,2 +35,1 @@\n- * @see Attribute\n- * @LastModified: Feb 2023\n+ * @see     Attribute\n@@ -43,0 +41,1 @@\n+\n@@ -44,7 +43,2 @@\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index in constant pool\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n@@ -52,7 +46,2 @@\n-    NestMembers(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (int[]) null, constantPool);\n-        final int classCount = input.readUnsignedShort();\n-        classes = new int[classCount];\n-        for (int i = 0; i < classCount; i++) {\n-            classes[i] = input.readUnsignedShort();\n-        }\n+    public NestMembers(final NestMembers c) {\n+        this(c.getNameIndex(), c.getLength(), c.getClasses(), c.getConstantPool());\n@@ -61,0 +50,1 @@\n+\n@@ -62,1 +52,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -65,1 +55,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -67,4 +57,4 @@\n-    public NestMembers(final int nameIndex, final int length, final int[] classes, final ConstantPool constantPool) {\n-        super(Const.ATTR_NEST_MEMBERS, nameIndex, length, constantPool);\n-        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n-        Args.requireU2(this.classes.length, \"classes.length\");\n+    public NestMembers(final int name_index, final int length, final int[] classes,\n+            final ConstantPool constant_pool) {\n+        super(Const.ATTR_NEST_MEMBERS, name_index, length, constant_pool);\n+        this.classes = classes != null ? classes : new int[0];\n@@ -73,0 +63,1 @@\n+\n@@ -74,4 +65,6 @@\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n+     * Construct object from input stream.\n+     * @param name_index Index in constant pool\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -79,2 +72,7 @@\n-    public NestMembers(final NestMembers c) {\n-        this(c.getNameIndex(), c.getLength(), c.getClasses(), c.getConstantPool());\n+    NestMembers(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (int[]) null, constant_pool);\n+        final int number_of_classes = input.readUnsignedShort();\n+        classes = new int[number_of_classes];\n+        for (int i = 0; i < number_of_classes; i++) {\n+            classes[i] = input.readUnsignedShort();\n+        }\n@@ -83,0 +81,1 @@\n+\n@@ -84,2 +83,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -90,1 +90,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -94,12 +94,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final NestMembers c = (NestMembers) clone();\n-        if (classes.length > 0) {\n-            c.classes = classes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -111,1 +99,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -114,1 +102,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -122,0 +110,1 @@\n+\n@@ -129,0 +118,9 @@\n+\n+    \/**\n+     * @return Length of classes table.\n+     *\/\n+    public int getNumberClasses() {\n+        return classes == null ? 0 : classes.length;\n+    }\n+\n+\n@@ -134,1 +132,4 @@\n-        Arrays.setAll(names, i -> Utility.pathToPackage(super.getConstantPool().getConstantString(classes[i], Const.CONSTANT_Class)));\n+        for (int i = 0; i < classes.length; i++) {\n+            names[i] = super.getConstantPool().getConstantString(classes[i],\n+                    Const.CONSTANT_Class).replace('\/', '.');\n+        }\n@@ -138,6 +139,0 @@\n-    \/**\n-     * @return Length of classes table.\n-     *\/\n-    public int getNumberClasses() {\n-        return classes.length;\n-    }\n@@ -146,1 +141,2 @@\n-     * @param classes the list of class indexes Also redefines number_of_classes according to table length.\n+     * @param classes the list of class indexes\n+     * Also redefines number_of_classes according to table length.\n@@ -148,2 +144,2 @@\n-    public void setClasses(final int[] classes) {\n-        this.classes = classes != null ? classes : Const.EMPTY_INT_ARRAY;\n+    public void setClasses( final int[] classes ) {\n+        this.classes = classes != null ? classes : new int[0];\n@@ -152,0 +148,1 @@\n+\n@@ -162,2 +159,2 @@\n-            final String className = super.getConstantPool().getConstantString(index, Const.CONSTANT_Class);\n-            buf.append(\"  \").append(Utility.compactClassName(className, false)).append(\"\\n\");\n+            final String class_name = super.getConstantPool().getConstantString(index, Const.CONSTANT_Class);\n+            buf.append(\"  \").append(Utility.compactClassName(class_name, false)).append(\"\\n\");\n@@ -165,1 +162,17 @@\n-        return buf.substring(0, buf.length() - 1); \/\/ remove the last newline\n+        return buf.substring(0, buf.length()-1); \/\/ remove the last newline\n+    }\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final NestMembers c = (NestMembers) clone();\n+        if (classes != null) {\n+            c.classes = new int[classes.length];\n+            System.arraycopy(classes, 0, c.classes, 0,\n+                    classes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/NestMembers.java","additions":77,"deletions":64,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -29,1 +30,1 @@\n-    void accept(Visitor obj);\n+    void accept( Visitor obj );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Node.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference to a PMG attribute.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference\n+ * to a PMG attribute.\n@@ -33,1 +34,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -40,0 +41,11 @@\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n+     *\/\n+    public PMGClass(final PMGClass pgmClass) {\n+        this(pgmClass.getNameIndex(), pgmClass.getLength(), pgmClass.getPMGIndex(), pgmClass.getPMGClassIndex(),\n+            pgmClass.getConstantPool());\n+    }\n+\n+\n@@ -42,2 +54,1 @@\n-     *\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -46,2 +57,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -49,2 +60,3 @@\n-    PMGClass(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), input.readUnsignedShort(), constantPool);\n+    PMGClass(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), input.readUnsignedShort(), constant_pool);\n@@ -53,0 +65,1 @@\n+\n@@ -54,1 +67,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -60,2 +73,3 @@\n-    public PMGClass(final int nameIndex, final int length, final int pmgIndex, final int pmgClassIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_PMG, nameIndex, length, constantPool);\n+    public PMGClass(final int name_index, final int length, final int pmgIndex, final int pmgClassIndex,\n+            final ConstantPool constantPool) {\n+        super(Const.ATTR_PMG, name_index, length, constantPool);\n@@ -66,9 +80,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param pgmClass Source to copy.\n-     *\/\n-    public PMGClass(final PMGClass pgmClass) {\n-        this(pgmClass.getNameIndex(), pgmClass.getLength(), pgmClass.getPMGIndex(), pgmClass.getPMGClassIndex(), pgmClass.getConstantPool());\n-    }\n@@ -77,2 +82,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -83,1 +89,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -87,7 +93,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n@@ -99,1 +98,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -102,1 +101,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -108,0 +107,1 @@\n+\n@@ -115,0 +115,1 @@\n+\n@@ -116,1 +117,1 @@\n-     * @return PMG class name.\n+     * @param pmgClassIndex\n@@ -118,2 +119,2 @@\n-    public String getPMGClassName() {\n-        return super.getConstantPool().getConstantUtf8(pmgClassIndex).getBytes();\n+    public void setPMGClassIndex( final int pmgClassIndex ) {\n+        this.pmgClassIndex = pmgClassIndex;\n@@ -122,0 +123,1 @@\n+\n@@ -129,0 +131,1 @@\n+\n@@ -130,1 +133,1 @@\n-     * @return PMG name.\n+     * @param pmgIndex\n@@ -132,2 +135,2 @@\n-    public String getPMGName() {\n-        return super.getConstantPool().getConstantUtf8(pmgIndex).getBytes();\n+    public void setPMGIndex( final int pmgIndex ) {\n+        this.pmgIndex = pmgIndex;\n@@ -136,0 +139,1 @@\n+\n@@ -137,1 +141,1 @@\n-     * @param pmgClassIndex\n+     * @return PMG name.\n@@ -139,2 +143,4 @@\n-    public void setPMGClassIndex(final int pmgClassIndex) {\n-        this.pmgClassIndex = pmgClassIndex;\n+    public String getPMGName() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(pmgIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -143,0 +149,1 @@\n+\n@@ -144,1 +151,1 @@\n-     * @param pmgIndex\n+     * @return PMG class name.\n@@ -146,2 +153,4 @@\n-    public void setPMGIndex(final int pmgIndex) {\n-        this.pmgIndex = pmgIndex;\n+    public String getPMGClassName() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(pmgClassIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -150,0 +159,1 @@\n+\n@@ -157,0 +167,9 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        return (Attribute) clone();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/PMGClass.java","additions":63,"deletions":44,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -38,14 +38,0 @@\n-    static final ParameterAnnotationEntry[] EMPTY_ARRAY = {};\n-\n-    public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attrs) {\n-        \/\/ Find attributes that contain parameter annotation data\n-        final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n-        for (final Attribute attribute : attrs) {\n-            if (attribute instanceof ParameterAnnotations) {\n-                final ParameterAnnotations runtimeAnnotations = (ParameterAnnotations) attribute;\n-                Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getParameterAnnotationEntries());\n-            }\n-        }\n-        return accumulatedAnnotations.toArray(ParameterAnnotationEntry.EMPTY_ARRAY);\n-    }\n-\n@@ -54,0 +40,1 @@\n+\n@@ -58,1 +45,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -60,4 +47,4 @@\n-    ParameterAnnotationEntry(final DataInput input, final ConstantPool constantPool) throws IOException {\n-        final int annotationTableLength = input.readUnsignedShort();\n-        annotationTable = new AnnotationEntry[annotationTableLength];\n-        for (int i = 0; i < annotationTableLength; i++) {\n+    ParameterAnnotationEntry(final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        final int annotation_table_length = input.readUnsignedShort();\n+        annotationTable = new AnnotationEntry[annotation_table_length];\n+        for (int i = 0; i < annotation_table_length; i++) {\n@@ -65,1 +52,1 @@\n-            annotationTable[i] = AnnotationEntry.read(input, constantPool, false);\n+            annotationTable[i] = AnnotationEntry.read(input, constant_pool, false);\n@@ -69,0 +56,1 @@\n+\n@@ -70,2 +58,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -76,1 +65,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -80,0 +69,7 @@\n+    \/**\n+     * returns the array of annotation entries in this annotation\n+     *\/\n+    public AnnotationEntry[] getAnnotationEntries() {\n+        return annotationTable;\n+    }\n+\n@@ -87,6 +83,11 @@\n-    \/**\n-     * returns the array of annotation entries in this annotation\n-     *\/\n-    public AnnotationEntry[] getAnnotationEntries() {\n-        return annotationTable;\n-    }\n+  public static ParameterAnnotationEntry[] createParameterAnnotationEntries(final Attribute[] attrs) {\n+      \/\/ Find attributes that contain parameter annotation data\n+      final List<ParameterAnnotationEntry> accumulatedAnnotations = new ArrayList<>(attrs.length);\n+      for (final Attribute attribute : attrs) {\n+          if (attribute instanceof ParameterAnnotations) {\n+              final ParameterAnnotations runtimeAnnotations = (ParameterAnnotations)attribute;\n+              Collections.addAll(accumulatedAnnotations, runtimeAnnotations.getParameterAnnotationEntries());\n+          }\n+      }\n+      return accumulatedAnnotations.toArray(new ParameterAnnotationEntry[accumulatedAnnotations.size()]);\n+  }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotationEntry.java","additions":30,"deletions":29,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Iterator;\n-import java.util.stream.Stream;\n@@ -35,1 +33,1 @@\n-public abstract class ParameterAnnotations extends Attribute implements Iterable<ParameterAnnotationEntry> {\n+public abstract class ParameterAnnotations extends Attribute {\n@@ -41,2 +39,2 @@\n-     * @param parameterAnnotationType the subclass type of the parameter annotation\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param parameter_annotation_type the subclass type of the parameter annotation\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -45,1 +43,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -47,7 +45,8 @@\n-    ParameterAnnotations(final byte parameterAnnotationType, final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n-        throws IOException {\n-        this(parameterAnnotationType, nameIndex, length, (ParameterAnnotationEntry[]) null, constantPool);\n-        final int numParameters = input.readUnsignedByte();\n-        parameterAnnotationTable = new ParameterAnnotationEntry[numParameters];\n-        for (int i = 0; i < numParameters; i++) {\n-            parameterAnnotationTable[i] = new ParameterAnnotationEntry(input, constantPool);\n+    ParameterAnnotations(final byte parameter_annotation_type, final int name_index, final int length,\n+            final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(parameter_annotation_type, name_index, length, (ParameterAnnotationEntry[]) null,\n+                constant_pool);\n+        final int num_parameters = input.readUnsignedByte();\n+        parameterAnnotationTable = new ParameterAnnotationEntry[num_parameters];\n+        for (int i = 0; i < num_parameters; i++) {\n+            parameterAnnotationTable[i] = new ParameterAnnotationEntry(input, constant_pool);\n@@ -57,0 +56,1 @@\n+\n@@ -65,1 +65,1 @@\n-        final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {\n+            final ParameterAnnotationEntry[] parameterAnnotationTable, final ConstantPool constantPool) {\n@@ -70,0 +70,1 @@\n+\n@@ -71,2 +72,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -77,1 +79,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -81,0 +83,1 @@\n+\n@@ -82,1 +85,1 @@\n-     * @return deep copy of this attribute\n+     * @param parameterAnnotationTable the entries to set in this parameter annotation\n@@ -84,3 +87,2 @@\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n+    public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable ) {\n+        this.parameterAnnotationTable = parameterAnnotationTable;\n@@ -89,10 +91,0 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        super.dump(dos);\n-        dos.writeByte(parameterAnnotationTable.length);\n-\n-        for (final ParameterAnnotationEntry element : parameterAnnotationTable) {\n-            element.dump(dos);\n-        }\n-\n-    }\n@@ -101,1 +93,1 @@\n-     * returns the array of parameter annotation entries in this parameter annotation\n+     * @return the parameter annotation entry table\n@@ -103,1 +95,1 @@\n-    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n+    public final ParameterAnnotationEntry[] getParameterAnnotationTable() {\n@@ -107,0 +99,1 @@\n+\n@@ -108,1 +101,1 @@\n-     * @return the parameter annotation entry table\n+     * returns the array of parameter annotation entries in this parameter annotation\n@@ -110,1 +103,1 @@\n-    public final ParameterAnnotationEntry[] getParameterAnnotationTable() {\n+    public ParameterAnnotationEntry[] getParameterAnnotationEntries() {\n@@ -115,2 +108,9 @@\n-    public Iterator<ParameterAnnotationEntry> iterator() {\n-        return Stream.of(parameterAnnotationTable).iterator();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        super.dump(dos);\n+        dos.writeByte(parameterAnnotationTable.length);\n+\n+        for (final ParameterAnnotationEntry element : parameterAnnotationTable) {\n+            element.dump(dos);\n+        }\n+\n@@ -120,1 +120,1 @@\n-     * @param parameterAnnotationTable the entries to set in this parameter annotation\n+     * @return deep copy of this attribute\n@@ -122,2 +122,3 @@\n-    public final void setParameterAnnotationTable(final ParameterAnnotationEntry[] parameterAnnotationTable) {\n-        this.parameterAnnotationTable = parameterAnnotationTable;\n+    @Override\n+    public Attribute copy( final ConstantPool constant_pool ) {\n+        return (Attribute) clone();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/ParameterAnnotations.java","additions":41,"deletions":40,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * represents an annotation that is represented in the class file but is not provided to the JVM.\n+ * represents an annotation that is represented in the class file but is not\n+ * provided to the JVM.\n@@ -35,2 +36,2 @@\n-public class RuntimeInvisibleAnnotations extends Annotations {\n-\n+public class RuntimeInvisibleAnnotations extends Annotations\n+{\n@@ -38,5 +39,8 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param name_index\n+     *            Index pointing to the name <em>Code<\/em>\n+     * @param length\n+     *            Content length in bytes\n+     * @param input\n+     *            Input stream\n+     * @param constant_pool\n+     *            Array of constants\n@@ -44,2 +48,4 @@\n-    public RuntimeInvisibleAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS, nameIndex, length, input, constantPool, false);\n+    public RuntimeInvisibleAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException\n+    {\n+        super(Const.ATTR_RUNTIME_INVISIBLE_ANNOTATIONS, name_index, length, input, constant_pool, false);\n@@ -52,1 +58,2 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool constant_pool)\n+    {\n@@ -57,1 +64,2 @@\n-    public final void dump(final DataOutputStream dos) throws IOException {\n+    public final void dump(final DataOutputStream dos) throws IOException\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleAnnotations.java","additions":20,"deletions":12,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * Represents a parameter annotation that is represented in the class file but is not provided to the JVM.\n+ * Represents a parameter annotation that is represented in the class file\n+ * but is not provided to the JVM.\n@@ -37,1 +38,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -40,2 +41,1 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param constant_pool Array of constants\n@@ -43,3 +43,3 @@\n-    public RuntimeInvisibleParameterAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n-        throws IOException {\n-        super(Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, nameIndex, length, input, constantPool);\n+    public RuntimeInvisibleParameterAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        super(Const.ATTR_RUNTIME_INVISIBLE_PARAMETER_ANNOTATIONS, name_index, length, input, constant_pool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeInvisibleParameterAnnotations.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * represents an annotation that is represented in the class file and is provided to the JVM.\n+ * represents an annotation that is represented in the class file and is\n+ * provided to the JVM.\n@@ -35,2 +36,2 @@\n-public class RuntimeVisibleAnnotations extends Annotations {\n-\n+public class RuntimeVisibleAnnotations extends Annotations\n+{\n@@ -38,5 +39,8 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param name_index\n+     *            Index pointing to the name <em>Code<\/em>\n+     * @param length\n+     *            Content length in bytes\n+     * @param input\n+     *            Input stream\n+     * @param constant_pool\n+     *            Array of constants\n@@ -44,2 +48,3 @@\n-    public RuntimeVisibleAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        super(Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, nameIndex, length, input, constantPool, true);\n+    public RuntimeVisibleAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException\n+    {\n+        super(Const.ATTR_RUNTIME_VISIBLE_ANNOTATIONS, name_index, length, input, constant_pool, true);\n@@ -52,1 +57,2 @@\n-    public Attribute copy(final ConstantPool constantPool) {\n+    public Attribute copy(final ConstantPool constant_pool)\n+    {\n@@ -57,1 +63,2 @@\n-    public final void dump(final DataOutputStream dos) throws IOException {\n+    public final void dump(final DataOutputStream dos) throws IOException\n+    {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleAnnotations.java","additions":19,"deletions":12,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * Represents a parameter annotation that is represented in the class file and is provided to the JVM.\n+ * Represents a parameter annotation that is represented in the class file\n+ * and is provided to the JVM.\n@@ -37,1 +38,1 @@\n-     * @param nameIndex Index pointing to the name <em>Code<\/em>\n+     * @param name_index Index pointing to the name <em>Code<\/em>\n@@ -40,2 +41,1 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param constant_pool Array of constants\n@@ -43,3 +43,3 @@\n-    public RuntimeVisibleParameterAnnotations(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool)\n-        throws IOException {\n-        super(Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, nameIndex, length, input, constantPool);\n+    public RuntimeVisibleParameterAnnotations(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        super(Const.ATTR_RUNTIME_VISIBLE_PARAMETER_ANNOTATIONS, name_index, length, input, constant_pool);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/RuntimeVisibleParameterAnnotations.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,2 +28,0 @@\n-import java.nio.charset.StandardCharsets;\n-import java.util.Objects;\n@@ -32,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -35,1 +32,2 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference to a GJ attribute.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference\n+ * to a GJ attribute.\n@@ -37,1 +35,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -41,0 +39,90 @@\n+    private int signatureIndex;\n+\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n+     *\/\n+    public Signature(final Signature c) {\n+        this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());\n+    }\n+\n+\n+    \/**\n+     * Construct object from file stream.\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n+     *\/\n+    Signature(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), constant_pool);\n+    }\n+\n+\n+    \/**\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n+     * @param length Content length in bytes\n+     * @param signatureIndex Index in constant pool to CONSTANT_Utf8\n+     * @param constant_pool Array of constants\n+     *\/\n+    public Signature(final int name_index, final int length, final int signatureIndex, final ConstantPool constant_pool) {\n+        super(Const.ATTR_SIGNATURE, name_index, length, constant_pool);\n+        this.signatureIndex = signatureIndex;\n+    }\n+\n+\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        \/\/System.err.println(\"Visiting non-standard Signature object\");\n+        v.visitSignature(this);\n+    }\n+\n+\n+    \/**\n+     * Dump source file attribute to file stream in binary format.\n+     *\n+     * @param file Output file stream\n+     * @throws IOException\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream file ) throws IOException {\n+        super.dump(file);\n+        file.writeShort(signatureIndex);\n+    }\n+\n+\n+    \/**\n+     * @return Index in constant pool of source file name.\n+     *\/\n+    public int getSignatureIndex() {\n+        return signatureIndex;\n+    }\n+\n+\n+    \/**\n+     * @param signatureIndex the index info the constant pool of this signature\n+     *\/\n+    public void setSignatureIndex( final int signatureIndex ) {\n+        this.signatureIndex = signatureIndex;\n+    }\n+\n+\n+    \/**\n+     * @return GJ signature.\n+     *\/\n+    public String getSignature() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(signatureIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n+    }\n+\n@@ -47,1 +135,1 @@\n-            super(data.getBytes(StandardCharsets.UTF_8));\n+            super(data.getBytes());\n@@ -50,0 +138,1 @@\n+\n@@ -51,1 +140,1 @@\n-            return new String(buf, StandardCharsets.UTF_8);\n+            return new String(buf);\n@@ -54,0 +143,1 @@\n+\n@@ -61,3 +151,0 @@\n-    private static boolean identStart(final int ch) {\n-        return ch == 'T' || ch == 'L';\n-    }\n@@ -65,8 +152,2 @@\n-    \/\/ @since 6.0 is no longer final\n-    public static boolean isActualParameterList(final String s) {\n-        return s.startsWith(\"L\") && s.endsWith(\">;\");\n-    }\n-\n-    \/\/ @since 6.0 is no longer final\n-    public static boolean isFormalParameterList(final String s) {\n-        return s.startsWith(\"<\") && s.indexOf(':') > 0;\n+    private static boolean identStart( final int ch ) {\n+        return ch == 'T' || ch == 'L';\n@@ -75,32 +156,0 @@\n-    private static void matchGJIdent(final MyByteArrayInputStream in, final StringBuilder buf) {\n-        int ch;\n-        matchIdent(in, buf);\n-        ch = in.read();\n-        if (ch == '<' || ch == '(') { \/\/ Parameterized or method\n-            \/\/ System.out.println(\"Enter <\");\n-            buf.append((char) ch);\n-            matchGJIdent(in, buf);\n-            while ((ch = in.read()) != '>' && ch != ')') { \/\/ List of parameters\n-                if (ch == -1) {\n-                    throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" reaching EOF\");\n-                }\n-                \/\/ System.out.println(\"Still no >\");\n-                buf.append(\", \");\n-                in.unread();\n-                matchGJIdent(in, buf); \/\/ Recursive call\n-            }\n-            \/\/ System.out.println(\"Exit >\");\n-            buf.append((char) ch);\n-        } else {\n-            in.unread();\n-        }\n-        ch = in.read();\n-        if (identStart(ch)) {\n-            in.unread();\n-            matchGJIdent(in, buf);\n-        } else if (ch == ')') {\n-            in.unread();\n-        } else if (ch != ';') {\n-            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" read \" + (char) ch);\n-        }\n-    }\n@@ -108,1 +157,1 @@\n-    private static void matchIdent(final MyByteArrayInputStream in, final StringBuilder buf) {\n+    private static void matchIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {\n@@ -111,1 +160,2 @@\n-            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" no ident, reaching EOF\");\n+            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData()\n+                    + \" no ident, reaching EOF\");\n@@ -113,1 +163,1 @@\n-        \/\/ System.out.println(\"return from ident:\" + (char)ch);\n+        \/\/System.out.println(\"return from ident:\" + (char)ch);\n@@ -123,5 +173,1 @@\n-                final int skipExpected = \"Ljava\/lang\/Object\".length();\n-                final long skipActual = in.skip(skipExpected);\n-                if (skipActual != skipExpected) {\n-                    throw new IllegalStateException(String.format(\"Unexpected skip: expected=%,d, actual=%,d\", skipExpected, skipActual));\n-                }\n+                in.skip(\"Ljava\/lang\/Object\".length());\n@@ -131,1 +177,1 @@\n-                \/\/ System.out.println(\"so far:\" + buf2 + \":next:\" +(char)ch);\n+                \/\/System.out.println(\"so far:\" + buf2 + \":next:\" +(char)ch);\n@@ -144,4 +190,4 @@\n-            \/\/ System.out.println(\"within ident:\"+ (char)ch);\n-        } while (ch != -1 && (Character.isJavaIdentifierPart((char) ch) || ch == '\/'));\n-        buf.append(Utility.pathToPackage(buf2.toString()));\n-        \/\/ System.out.println(\"regular return ident:\"+ (char)ch + \":\" + buf2);\n+            \/\/System.out.println(\"within ident:\"+ (char)ch);\n+        } while ((ch != -1) && (Character.isJavaIdentifierPart((char) ch) || (ch == '\/')));\n+        buf.append(buf2.toString().replace('\/', '.'));\n+        \/\/System.out.println(\"regular return ident:\"+ (char)ch + \":\" + buf2);\n@@ -153,2 +199,39 @@\n-    public static String translate(final String s) {\n-        \/\/ System.out.println(\"Sig:\" + s);\n+\n+    private static void matchGJIdent( final MyByteArrayInputStream in, final StringBuilder buf ) {\n+        int ch;\n+        matchIdent(in, buf);\n+        ch = in.read();\n+        if ((ch == '<') || ch == '(') { \/\/ Parameterized or method\n+            \/\/System.out.println(\"Enter <\");\n+            buf.append((char) ch);\n+            matchGJIdent(in, buf);\n+            while (((ch = in.read()) != '>') && (ch != ')')) { \/\/ List of parameters\n+                if (ch == -1) {\n+                    throw new IllegalArgumentException(\"Illegal signature: \" + in.getData()\n+                            + \" reaching EOF\");\n+                }\n+                \/\/System.out.println(\"Still no >\");\n+                buf.append(\", \");\n+                in.unread();\n+                matchGJIdent(in, buf); \/\/ Recursive call\n+            }\n+            \/\/System.out.println(\"Exit >\");\n+            buf.append((char) ch);\n+        } else {\n+            in.unread();\n+        }\n+        ch = in.read();\n+        if (identStart(ch)) {\n+            in.unread();\n+            matchGJIdent(in, buf);\n+        } else if (ch == ')') {\n+            in.unread();\n+            return;\n+        } else if (ch != ';') {\n+            throw new IllegalArgumentException(\"Illegal signature: \" + in.getData() + \" read \" + (char) ch);\n+        }\n+    }\n+\n+\n+    public static String translate( final String s ) {\n+        \/\/System.out.println(\"Sig:\" + s);\n@@ -160,14 +243,0 @@\n-    private int signatureIndex;\n-\n-    \/**\n-     * Construct object from file stream.\n-     *\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param input Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    Signature(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n-    }\n@@ -175,11 +244,3 @@\n-    \/**\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n-     * @param length Content length in bytes\n-     * @param signatureIndex Index in constant pool to CONSTANT_Utf8\n-     * @param constantPool Array of constants\n-     *\/\n-    public Signature(final int nameIndex, final int length, final int signatureIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_SIGNATURE, nameIndex, Args.require(length, 2, \"Signature length attribute\"), constantPool);\n-        this.signatureIndex = signatureIndex;\n-        \/\/ validate:\n-        Objects.requireNonNull(constantPool.getConstantUtf8(signatureIndex), \"constantPool.getConstantUtf8(signatureIndex)\");\n+    \/\/ @since 6.0 is no longer final\n+    public static boolean isFormalParameterList( final String s ) {\n+        return s.startsWith(\"<\") && (s.indexOf(':') > 0);\n@@ -188,9 +249,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Signature(final Signature c) {\n-        this(c.getNameIndex(), c.getLength(), c.getSignatureIndex(), c.getConstantPool());\n-    }\n@@ -198,10 +250,3 @@\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        \/\/ System.err.println(\"Visiting non-standard Signature object\");\n-        v.visitSignature(this);\n+    \/\/ @since 6.0 is no longer final\n+    public static boolean isActualParameterList( final String s ) {\n+        return s.startsWith(\"L\") && s.endsWith(\">;\");\n@@ -210,7 +255,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n@@ -219,4 +257,1 @@\n-     * Dump source file attribute to file stream in binary format.\n-     *\n-     * @param file Output file stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @return String representation\n@@ -225,17 +260,3 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n-        super.dump(file);\n-        file.writeShort(signatureIndex);\n-    }\n-\n-    \/**\n-     * @return GJ signature.\n-     *\/\n-    public String getSignature() {\n-        return super.getConstantPool().getConstantUtf8(signatureIndex).getBytes();\n-    }\n-\n-    \/**\n-     * @return Index in constant pool of source file name.\n-     *\/\n-    public int getSignatureIndex() {\n-        return signatureIndex;\n+    public String toString() {\n+        final String s = getSignature();\n+        return \"Signature: \" + s;\n@@ -244,6 +265,0 @@\n-    \/**\n-     * @param signatureIndex the index info the constant pool of this signature\n-     *\/\n-    public void setSignatureIndex(final int signatureIndex) {\n-        this.signatureIndex = signatureIndex;\n-    }\n@@ -252,1 +267,1 @@\n-     * @return String representation\n+     * @return deep copy of this attribute\n@@ -255,2 +270,2 @@\n-    public String toString() {\n-        return \"Signature: \" + getSignature();\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        return (Attribute) clone();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Signature.java","additions":161,"deletions":146,"binary":false,"changes":307,"status":"modified"},{"patch":"@@ -32,1 +32,2 @@\n-public class SimpleElementValue extends ElementValue {\n+public class SimpleElementValue extends ElementValue\n+{\n@@ -35,1 +36,2 @@\n-    public SimpleElementValue(final int type, final int index, final ConstantPool cpool) {\n+    public SimpleElementValue(final int type, final int index, final ConstantPool cpool)\n+    {\n@@ -40,21 +42,0 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        final int type = super.getType();\n-        dos.writeByte(type); \/\/ u1 kind of value\n-        switch (type) {\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_BOOLEAN:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_DOUBLE:\n-        case STRING:\n-            dos.writeShort(getIndex());\n-            break;\n-        default:\n-            throw new ClassFormatException(\"SimpleElementValue doesnt know how to write out type \" + type);\n-        }\n-    }\n-\n@@ -64,1 +45,2 @@\n-    public int getIndex() {\n+    public int getIndex()\n+    {\n@@ -68,3 +50,10 @@\n-    public boolean getValueBoolean() {\n-        if (super.getType() != PRIMITIVE_BOOLEAN) {\n-            throw new IllegalStateException(\"Dont call getValueBoolean() on a non BOOLEAN ElementValue\");\n+    public void setIndex(final int index)\n+    {\n+        this.index = index;\n+    }\n+\n+    public String getValueString()\n+    {\n+        if (super.getType() != STRING) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n@@ -72,2 +61,14 @@\n-        final ConstantInteger bo = (ConstantInteger) super.getConstantPool().getConstant(getIndex());\n-        return bo.getBytes() != 0;\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n+    }\n+\n+    public int getValueInt()\n+    {\n+        if (super.getType() != PRIMITIVE_INT) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n+        }\n+        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Integer);\n+        return c.getBytes();\n@@ -76,1 +77,2 @@\n-    public byte getValueByte() {\n+    public byte getValueByte()\n+    {\n@@ -78,1 +80,2 @@\n-            throw new IllegalStateException(\"Dont call getValueByte() on a non BYTE ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueByte() on a non BYTE ElementValue\");\n@@ -80,1 +83,3 @@\n-        return (byte) super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n+        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Integer);\n+        return (byte) c.getBytes();\n@@ -83,1 +88,2 @@\n-    public char getValueChar() {\n+    public char getValueChar()\n+    {\n@@ -85,1 +91,2 @@\n-            throw new IllegalStateException(\"Dont call getValueChar() on a non CHAR ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueChar() on a non CHAR ElementValue\");\n@@ -87,1 +94,3 @@\n-        return (char) super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n+        final ConstantInteger c = (ConstantInteger) super.getConstantPool().getConstant(getIndex(),\n+                Const.CONSTANT_Integer);\n+        return (char) c.getBytes();\n@@ -90,3 +99,5 @@\n-    public double getValueDouble() {\n-        if (super.getType() != PRIMITIVE_DOUBLE) {\n-            throw new IllegalStateException(\"Dont call getValueDouble() on a non DOUBLE ElementValue\");\n+    public long getValueLong()\n+    {\n+        if (super.getType() != PRIMITIVE_LONG) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueLong() on a non LONG ElementValue\");\n@@ -94,2 +105,2 @@\n-        final ConstantDouble d = (ConstantDouble) super.getConstantPool().getConstant(getIndex());\n-        return d.getBytes();\n+        final ConstantLong j = (ConstantLong) super.getConstantPool().getConstant(getIndex());\n+        return j.getBytes();\n@@ -98,1 +109,2 @@\n-    public float getValueFloat() {\n+    public float getValueFloat()\n+    {\n@@ -100,1 +112,2 @@\n-            throw new IllegalStateException(\"Dont call getValueFloat() on a non FLOAT ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueFloat() on a non FLOAT ElementValue\");\n@@ -106,3 +119,5 @@\n-    public int getValueInt() {\n-        if (super.getType() != PRIMITIVE_INT) {\n-            throw new IllegalStateException(\"Dont call getValueInt() on a non INT ElementValue\");\n+    public double getValueDouble()\n+    {\n+        if (super.getType() != PRIMITIVE_DOUBLE) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueDouble() on a non DOUBLE ElementValue\");\n@@ -110,1 +125,2 @@\n-        return super.getConstantPool().getConstantInteger(getIndex()).getBytes();\n+        final ConstantDouble d = (ConstantDouble) super.getConstantPool().getConstant(getIndex());\n+        return d.getBytes();\n@@ -113,3 +129,5 @@\n-    public long getValueLong() {\n-        if (super.getType() != PRIMITIVE_LONG) {\n-            throw new IllegalStateException(\"Dont call getValueLong() on a non LONG ElementValue\");\n+    public boolean getValueBoolean()\n+    {\n+        if (super.getType() != PRIMITIVE_BOOLEAN) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueBoolean() on a non BOOLEAN ElementValue\");\n@@ -117,2 +135,2 @@\n-        final ConstantLong j = (ConstantLong) super.getConstantPool().getConstant(getIndex());\n-        return j.getBytes();\n+        final ConstantInteger bo = (ConstantInteger) super.getConstantPool().getConstant(getIndex());\n+        return bo.getBytes() != 0;\n@@ -121,1 +139,2 @@\n-    public short getValueShort() {\n+    public short getValueShort()\n+    {\n@@ -123,1 +142,2 @@\n-            throw new IllegalStateException(\"Dont call getValueShort() on a non SHORT ElementValue\");\n+            throw new IllegalStateException(\n+                    \"Dont call getValueShort() on a non SHORT ElementValue\");\n@@ -129,9 +149,4 @@\n-    public String getValueString() {\n-        if (super.getType() != STRING) {\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n-        }\n-        return super.getConstantPool().getConstantUtf8(getIndex()).getBytes();\n-    }\n-\n-    public void setIndex(final int index) {\n-        this.index = index;\n+    @Override\n+    public String toString()\n+    {\n+        return stringifyValue();\n@@ -142,1 +157,2 @@\n-    public String stringifyValue() {\n+    public String stringifyValue()\n+    {\n@@ -144,2 +160,3 @@\n-        final int type = super.getType();\n-        switch (type) {\n+        final int _type = super.getType();\n+        switch (_type)\n+        {\n@@ -147,1 +164,3 @@\n-            return Integer.toString(cpool.getConstantInteger(getIndex()).getBytes());\n+            final ConstantInteger c = (ConstantInteger) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Integer);\n+            return Integer.toString(c.getBytes());\n@@ -149,1 +168,2 @@\n-            final ConstantLong j = cpool.getConstant(getIndex(), Const.CONSTANT_Long, ConstantLong.class);\n+            final ConstantLong j = (ConstantLong) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Long);\n@@ -152,1 +172,2 @@\n-            final ConstantDouble d = cpool.getConstant(getIndex(), Const.CONSTANT_Double, ConstantDouble.class);\n+            final ConstantDouble d = (ConstantDouble) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Double);\n@@ -155,1 +176,2 @@\n-            final ConstantFloat f = cpool.getConstant(getIndex(), Const.CONSTANT_Float, ConstantFloat.class);\n+            final ConstantFloat f = (ConstantFloat) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Float);\n@@ -158,1 +180,2 @@\n-            final ConstantInteger s = cpool.getConstantInteger(getIndex());\n+            final ConstantInteger s = (ConstantInteger) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Integer);\n@@ -161,1 +184,2 @@\n-            final ConstantInteger b = cpool.getConstantInteger(getIndex());\n+            final ConstantInteger b = (ConstantInteger) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Integer);\n@@ -164,2 +188,3 @@\n-            final ConstantInteger ch = cpool.getConstantInteger(getIndex());\n-            return String.valueOf((char) ch.getBytes());\n+            final ConstantInteger ch = (ConstantInteger) cpool.getConstant(\n+                    getIndex(), Const.CONSTANT_Integer);\n+            return String.valueOf((char)ch.getBytes());\n@@ -167,1 +192,2 @@\n-            final ConstantInteger bo = cpool.getConstantInteger(getIndex());\n+            final ConstantInteger bo = (ConstantInteger) cpool.getConstant(\n+                    getIndex(), Const.CONSTANT_Integer);\n@@ -173,1 +199,3 @@\n-            return cpool.getConstantUtf8(getIndex()).getBytes();\n+            final ConstantUtf8 cu8 = (ConstantUtf8) cpool.getConstant(getIndex(),\n+                    Const.CONSTANT_Utf8);\n+            return cu8.getBytes();\n@@ -175,1 +203,1 @@\n-            throw new IllegalStateException(\"SimpleElementValue class does not know how to stringify type \" + type);\n+            throw new IllegalStateException(\"SimpleElementValue class does not know how to stringify type \" + _type);\n@@ -180,2 +208,20 @@\n-    public String toString() {\n-        return stringifyValue();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        final int _type = super.getType();\n+        dos.writeByte(_type); \/\/ u1 kind of value\n+        switch (_type)\n+        {\n+        case PRIMITIVE_INT:\n+        case PRIMITIVE_BYTE:\n+        case PRIMITIVE_CHAR:\n+        case PRIMITIVE_FLOAT:\n+        case PRIMITIVE_LONG:\n+        case PRIMITIVE_BOOLEAN:\n+        case PRIMITIVE_SHORT:\n+        case PRIMITIVE_DOUBLE:\n+        case STRING:\n+            dos.writeShort(getIndex());\n+            break;\n+        default:\n+            throw new IllegalStateException(\"SimpleElementValue doesnt know how to write out type \" + _type);\n+        }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SimpleElementValue.java","additions":124,"deletions":78,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,3 +31,4 @@\n- * This class is derived from <em>Attribute<\/em> and represents a reference to the source file of this class. At most\n- * one SourceFile attribute should appear per classfile. The intention of this class is that it is instantiated from the\n- * <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and represents a reference\n+ * to the source file of this class.  At most one SourceFile attribute\n+ * should appear per classfile.  The intention of this class is that it is\n+ * instantiated from the <em>Attribute.readAttribute()<\/em> method.\n@@ -36,1 +36,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -42,0 +42,10 @@\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n+     *\/\n+    public SourceFile(final SourceFile c) {\n+        this(c.getNameIndex(), c.getLength(), c.getSourceFileIndex(), c.getConstantPool());\n+    }\n+\n+\n@@ -44,2 +54,1 @@\n-     *\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -48,2 +57,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -51,2 +60,3 @@\n-    SourceFile(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, input.readUnsignedShort(), constantPool);\n+    SourceFile(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, input.readUnsignedShort(), constant_pool);\n@@ -55,0 +65,1 @@\n+\n@@ -56,1 +67,2 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8, which should represent the string \"SourceFile\".\n+     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n+     * should represent the string \"SourceFile\".\n@@ -58,5 +70,8 @@\n-     * @param constantPool The constant pool that this attribute is associated with.\n-     * @param sourceFileIndex Index in constant pool to CONSTANT_Utf8. This string will be interpreted as the name of the\n-     *        file from which this class was compiled. It will not be interpreted as indicating the name of the directory\n-     *        contqining the file or an absolute path; this information has to be supplied the consumer of this attribute -\n-     *        in many cases, the JVM.\n+     * @param constantPool The constant pool that this attribute is\n+     * associated with.\n+     * @param sourceFileIndex Index in constant pool to CONSTANT_Utf8.  This\n+     * string will be interpreted as the name of the file from which this\n+     * class was compiled.  It will not be interpreted as indicating the name\n+     * of the directory contqining the file or an absolute path; this\n+     * information has to be supplied the consumer of this attribute - in\n+     * many cases, the JVM.\n@@ -64,3 +79,3 @@\n-    public SourceFile(final int nameIndex, final int length, final int sourceFileIndex, final ConstantPool constantPool) {\n-        super(Const.ATTR_SOURCE_FILE, nameIndex, Args.require(length, 2, \"SourceFile length attribute\"), constantPool);\n-        this.sourceFileIndex = Args.requireU2(sourceFileIndex, 0, constantPool.getLength(), \"SourceFile source file index\");\n+    public SourceFile(final int name_index, final int length, final int sourceFileIndex, final ConstantPool constantPool) {\n+        super(Const.ATTR_SOURCE_FILE, name_index, length, constantPool);\n+        this.sourceFileIndex = sourceFileIndex;\n@@ -69,9 +84,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use clone() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public SourceFile(final SourceFile c) {\n-        this(c.getNameIndex(), c.getLength(), c.getSourceFileIndex(), c.getConstantPool());\n-    }\n@@ -80,2 +86,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -86,1 +93,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -90,7 +97,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        return (Attribute) clone();\n-    }\n@@ -102,1 +102,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -105,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -110,0 +110,1 @@\n+\n@@ -117,0 +118,1 @@\n+\n@@ -118,1 +120,1 @@\n-     * @return Source file name.\n+     * @param sourceFileIndex\n@@ -120,2 +122,2 @@\n-    public String getSourceFileName() {\n-        return super.getConstantPool().getConstantUtf8(sourceFileIndex).getBytes();\n+    public void setSourceFileIndex( final int sourceFileIndex ) {\n+        this.sourceFileIndex = sourceFileIndex;\n@@ -124,0 +126,1 @@\n+\n@@ -125,1 +128,1 @@\n-     * @param sourceFileIndex\n+     * @return Source file name.\n@@ -127,2 +130,4 @@\n-    public void setSourceFileIndex(final int sourceFileIndex) {\n-        this.sourceFileIndex = sourceFileIndex;\n+    public String getSourceFileName() {\n+        final ConstantUtf8 c = (ConstantUtf8) super.getConstantPool().getConstant(sourceFileIndex,\n+                Const.CONSTANT_Utf8);\n+        return c.getBytes();\n@@ -131,0 +136,1 @@\n+\n@@ -138,0 +144,9 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        return (Attribute) clone();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/SourceFile.java","additions":62,"deletions":47,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.util.Arrays;\n@@ -29,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,4 +30,7 @@\n- * This class represents a stack map attribute used for preverification of Java classes for the\n- * <a href=\"http:\/\/java.sun.com\/j2me\/\"> Java 2 Micro Edition<\/a> (J2ME). This attribute is used by the\n- * <a href=\"http:\/\/java.sun.com\/products\/cldc\/\">KVM<\/a> and contained within the Code attribute of a method. See CLDC\n- * specification 5.3.1.2\n+ * This class represents a stack map attribute used for\n+ * preverification of Java classes for the <a\n+ * href=\"https:\/\/www.oracle.com\/java\/technologies\/javameoverview.html\">Java Platform, Micro Edition<\/a>\n+ * (Java ME). This attribute is used by the <a\n+ * href=\"https:\/\/www.oracle.com\/technetwork\/java\/embedded\/javame\/java-mobile\/kvmwp-150240.pdf\">KVM<\/a>\n+ * and contained within the Code attribute of a method. See CLDC specification\n+ * 5.3.1.2\n@@ -37,12 +38,3 @@\n- * <pre>\n- * StackMapTable_attribute {\n- *   u2              attribute_name_index;\n- *   u4              attribute_length;\n- *   u2              number_of_entries;\n- *   stack_map_frame entries[number_of_entries];\n- * }\n- * <\/pre>\n- *\n- * @see Code\n- * @see StackMapEntry\n- * @see StackMapType\n+ * @see     Code\n+ * @see     StackMapEntry\n+ * @see     StackMapType\n@@ -53,1 +45,1 @@\n-    private StackMapEntry[] table; \/\/ Table of stack map entries\n+    private StackMapEntry[] map; \/\/ Table of stack map entries\n@@ -55,17 +47,0 @@\n-    \/**\n-     * Construct object from input stream.\n-     *\n-     * @param nameIndex Index of name\n-     * @param length Content length in bytes\n-     * @param dataInput Input stream\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n-     *\/\n-    StackMap(final int nameIndex, final int length, final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (StackMapEntry[]) null, constantPool);\n-        final int mapLength = dataInput.readUnsignedShort();\n-        table = new StackMapEntry[mapLength];\n-        for (int i = 0; i < mapLength; i++) {\n-            table[i] = new StackMapEntry(dataInput, constantPool);\n-        }\n-    }\n@@ -74,2 +49,1 @@\n-     * @param nameIndex Index of name\n-     *\n+     * @param name_index Index of name\n@@ -77,1 +51,0 @@\n-     *\n@@ -79,2 +52,1 @@\n-     *\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -82,4 +54,3 @@\n-    public StackMap(final int nameIndex, final int length, final StackMapEntry[] table, final ConstantPool constantPool) {\n-        super(Const.ATTR_STACK_MAP, nameIndex, length, constantPool);\n-        this.table = table != null ? table : StackMapEntry.EMPTY_ARRAY;\n-        Args.requireU2(this.table.length, \"table.length\");\n+    public StackMap(final int name_index, final int length, final StackMapEntry[] map, final ConstantPool constant_pool) {\n+        super(Const.ATTR_STACK_MAP, name_index, length, constant_pool);\n+        this.map = map;\n@@ -88,0 +59,1 @@\n+\n@@ -89,2 +61,1 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Construct object from input stream.\n@@ -92,1 +63,5 @@\n-     * @param v Visitor object\n+     * @param name_index Index of name\n+     * @param length Content length in bytes\n+     * @param input Input stream\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -94,3 +69,7 @@\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackMap(this);\n+    StackMap(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool) throws IOException {\n+        this(name_index, length, (StackMapEntry[]) null, constant_pool);\n+        final int map_length = input.readUnsignedShort();\n+        map = new StackMapEntry[map_length];\n+        for (int i = 0; i < map_length; i++) {\n+            map[i] = new StackMapEntry(input, constant_pool);\n+        }\n@@ -99,11 +78,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final StackMap c = (StackMap) clone();\n-        c.table = new StackMapEntry[table.length];\n-        Arrays.setAll(c.table, i -> table[i].copy());\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -115,1 +83,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -118,1 +86,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -120,2 +88,2 @@\n-        file.writeShort(table.length);\n-        for (final StackMapEntry entry : table) {\n+        file.writeShort(map.length);\n+        for (final StackMapEntry entry : map) {\n@@ -126,3 +94,0 @@\n-    public int getMapLength() {\n-        return table.length;\n-    }\n@@ -134,1 +99,1 @@\n-        return table;\n+        return map;\n@@ -137,0 +102,1 @@\n+\n@@ -138,1 +104,1 @@\n-     * @param table Array of stack map entries\n+     * @param map Array of stack map entries\n@@ -140,2 +106,2 @@\n-    public void setStackMap(final StackMapEntry[] table) {\n-        this.table = table != null ? table : StackMapEntry.EMPTY_ARRAY;\n+    public void setStackMap( final StackMapEntry[] map ) {\n+        this.map = map;\n@@ -143,1 +109,1 @@\n-        for (final StackMapEntry element : this.table) {\n+        for (final StackMapEntry element : map) {\n@@ -149,0 +115,1 @@\n+\n@@ -155,5 +122,3 @@\n-        int runningOffset = -1; \/\/ no +1 on first entry\n-        for (int i = 0; i < table.length; i++) {\n-            runningOffset = table[i].getByteCodeOffset() + runningOffset + 1;\n-            buf.append(String.format(\"%n@%03d %s\", runningOffset, table[i]));\n-            if (i < table.length - 1) {\n+        for (int i = 0; i < map.length; i++) {\n+            buf.append(map[i]);\n+            if (i < map.length - 1) {\n@@ -166,0 +131,33 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final StackMap c = (StackMap) clone();\n+        c.map = new StackMapEntry[map.length];\n+        for (int i = 0; i < map.length; i++) {\n+            c.map[i] = map[i].copy();\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n+\n+\n+    \/**\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackMap(this);\n+    }\n+\n+\n+    public int getMapLength() {\n+        return map == null ? 0 : map.length;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMap.java","additions":77,"deletions":79,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import java.util.Arrays;\n-\n@@ -32,4 +30,3 @@\n- * This class represents a stack map entry recording the types of local variables and the of stack items at a given\n- * byte code offset. See CLDC specification 5.3.1.2.\n- *\n- * See also https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.4\n+ * This class represents a stack map entry recording the types of\n+ * local variables and the the of stack items at a given byte code offset.\n+ * See CLDC specification 5.3.1.2\n@@ -37,13 +34,2 @@\n- * <pre>\n- * union stack_map_frame {\n- *   same_frame;\n- *   same_locals_1_stack_item_frame;\n- *   same_locals_1_stack_item_frame_extended;\n- *   chop_frame;\n- *   same_frame_extended;\n- *   append_frame;\n- *   full_frame;\n- * }\n- * <\/pre>\n- * @see StackMap\n- * @see StackMapType\n+ * @see     StackMap\n+ * @see     StackMapType\n@@ -51,3 +37,2 @@\n-public final class StackMapEntry implements Node, Cloneable {\n-\n-    static final StackMapEntry[] EMPTY_ARRAY = {};\n+public final class StackMapEntry implements Node, Cloneable\n+{\n@@ -61,0 +46,1 @@\n+\n@@ -64,2 +50,2 @@\n-     * @param dataInput Input stream\n-     * @throws IOException if an I\/O error occurs.\n+     * @param input Input stream\n+     * @throws IOException\n@@ -67,2 +53,2 @@\n-    StackMapEntry(final DataInput dataInput, final ConstantPool constantPool) throws IOException {\n-        this(dataInput.readByte() & 0xFF, -1, null, null, constantPool);\n+    StackMapEntry(final DataInput input, final ConstantPool constantPool) throws IOException {\n+        this(input.readByte() & 0xFF, -1, null, null, constantPool);\n@@ -72,1 +58,2 @@\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -74,1 +61,2 @@\n-            typesOfStackItems = new StackMapType[] { new StackMapType(dataInput, constantPool) };\n+            typesOfStackItems = new StackMapType[1];\n+            typesOfStackItems[0] = new StackMapType(input, constantPool);\n@@ -76,2 +64,3 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n-            typesOfStackItems = new StackMapType[] { new StackMapType(dataInput, constantPool) };\n+            byteCodeOffset = input.readShort();\n+            typesOfStackItems = new StackMapType[1];\n+            typesOfStackItems[0] = new StackMapType(input, constantPool);\n@@ -79,1 +68,1 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n+            byteCodeOffset = input.readShort();\n@@ -81,1 +70,1 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n+            byteCodeOffset = input.readShort();\n@@ -83,5 +72,5 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n-            final int numberOfLocals = frameType - 251;\n-            typesOfLocals = new StackMapType[numberOfLocals];\n-            for (int i = 0; i < numberOfLocals; i++) {\n-                typesOfLocals[i] = new StackMapType(dataInput, constantPool);\n+            byteCodeOffset = input.readShort();\n+            final int number_of_locals = frameType - 251;\n+            typesOfLocals = new StackMapType[number_of_locals];\n+            for (int i = 0; i < number_of_locals; i++) {\n+                typesOfLocals[i] = new StackMapType(input, constantPool);\n@@ -90,5 +79,5 @@\n-            byteCodeOffset = dataInput.readUnsignedShort();\n-            final int numberOfLocals = dataInput.readUnsignedShort();\n-            typesOfLocals = new StackMapType[numberOfLocals];\n-            for (int i = 0; i < numberOfLocals; i++) {\n-                typesOfLocals[i] = new StackMapType(dataInput, constantPool);\n+            byteCodeOffset = input.readShort();\n+            final int number_of_locals = input.readShort();\n+            typesOfLocals = new StackMapType[number_of_locals];\n+            for (int i = 0; i < number_of_locals; i++) {\n+                typesOfLocals[i] = new StackMapType(input, constantPool);\n@@ -96,4 +85,4 @@\n-            final int numberOfStackItems = dataInput.readUnsignedShort();\n-            typesOfStackItems = new StackMapType[numberOfStackItems];\n-            for (int i = 0; i < numberOfStackItems; i++) {\n-                typesOfStackItems[i] = new StackMapType(dataInput, constantPool);\n+            final int number_of_stack_items = input.readShort();\n+            typesOfStackItems = new StackMapType[number_of_stack_items];\n+            for (int i = 0; i < number_of_stack_items; i++) {\n+                typesOfStackItems[i] = new StackMapType(input, constantPool);\n@@ -103,1 +92,1 @@\n-            throw new ClassFormatException(\"Invalid frame type found while parsing stack map table: \" + frameType);\n+            throw new ClassFormatException (\"Invalid frame type found while parsing stack map table: \" + frameType);\n@@ -116,1 +105,2 @@\n-     * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)} instead\n+     * @deprecated Since 6.0, use {@link #StackMapEntry(int, int, StackMapType[], StackMapType[], ConstantPool)}\n+     * instead\n@@ -119,2 +109,3 @@\n-    public StackMapEntry(final int byteCodeOffset, final int numberOfLocals, final StackMapType[] typesOfLocals, final int numberOfStackItems,\n-        final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n+    public StackMapEntry(final int byteCodeOffset, final int numberOfLocals,\n+            final StackMapType[] typesOfLocals, final int numberOfStackItems,\n+            final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n@@ -122,2 +113,2 @@\n-        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : StackMapType.EMPTY_ARRAY;\n-        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : StackMapType.EMPTY_ARRAY;\n+        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];\n+        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];\n@@ -125,6 +116,0 @@\n-        if (numberOfLocals < 0) {\n-            throw new IllegalArgumentException(\"numberOfLocals < 0\");\n-        }\n-        if (numberOfStackItems < 0) {\n-            throw new IllegalArgumentException(\"numberOfStackItems < 0\");\n-        }\n@@ -142,2 +127,3 @@\n-    public StackMapEntry(final int tag, final int byteCodeOffset, final StackMapType[] typesOfLocals, final StackMapType[] typesOfStackItems,\n-        final ConstantPool constantPool) {\n+    public StackMapEntry(final int tag, final int byteCodeOffset,\n+            final StackMapType[] typesOfLocals,\n+            final StackMapType[] typesOfStackItems, final ConstantPool constantPool) {\n@@ -146,2 +132,2 @@\n-        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : StackMapType.EMPTY_ARRAY;\n-        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : StackMapType.EMPTY_ARRAY;\n+        this.typesOfLocals = typesOfLocals != null ? typesOfLocals : new StackMapType[0];\n+        this.typesOfStackItems = typesOfStackItems != null ? typesOfStackItems : new StackMapType[0];\n@@ -151,28 +137,0 @@\n-    \/**\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackMapEntry(this);\n-    }\n-\n-    \/**\n-     * @return deep copy of this object\n-     *\/\n-    public StackMapEntry copy() {\n-        StackMapEntry e;\n-        try {\n-            e = (StackMapEntry) clone();\n-        } catch (final CloneNotSupportedException ex) {\n-            throw new Error(\"Clone Not Supported\");\n-        }\n-\n-        e.typesOfLocals = new StackMapType[typesOfLocals.length];\n-        Arrays.setAll(e.typesOfLocals, i -> typesOfLocals[i].copy());\n-        e.typesOfStackItems = new StackMapType[typesOfStackItems.length];\n-        Arrays.setAll(e.typesOfStackItems, i -> typesOfStackItems[i].copy());\n-        return e;\n-    }\n@@ -184,1 +142,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -186,1 +144,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -188,1 +146,4 @@\n-        if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n+            \/\/ nothing to be done\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -212,1 +173,1 @@\n-        } else if (!(frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX)) {\n+        } else {\n@@ -214,1 +175,1 @@\n-            throw new ClassFormatException(\"Invalid Stack map table tag: \" + frameType);\n+            throw new ClassFormatException (\"Invalid Stack map table tag: \" + frameType);\n@@ -218,3 +179,0 @@\n-    public int getByteCodeOffset() {\n-        return byteCodeOffset;\n-    }\n@@ -223,1 +181,1 @@\n-     * @return Constant pool used by this object.\n+     * @return String representation.\n@@ -225,2 +183,45 @@\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n+    @Override\n+    public String toString() {\n+        final StringBuilder buf = new StringBuilder(64);\n+        buf.append(\"(\");\n+        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n+            buf.append(\"SAME\");\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                  frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            buf.append(\"SAME_LOCALS_1_STACK\");\n+        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n+            buf.append(\"SAME_LOCALS_1_STACK_EXTENDED\");\n+        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n+            buf.append(\"CHOP \").append(String.valueOf(251-frameType));\n+        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+            buf.append(\"SAME_EXTENDED\");\n+        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n+            buf.append(\"APPEND \").append(String.valueOf(frameType-251));\n+        } else if (frameType == Const.FULL_FRAME) {\n+            buf.append(\"FULL\");\n+        } else {\n+            buf.append(\"UNKNOWN (\").append(frameType).append(\")\");\n+        }\n+        buf.append(\", offset delta=\").append(byteCodeOffset);\n+        if (typesOfLocals.length > 0) {\n+            buf.append(\", locals={\");\n+            for (int i = 0; i < typesOfLocals.length; i++) {\n+                buf.append(typesOfLocals[i]);\n+                if (i < typesOfLocals.length - 1) {\n+                    buf.append(\", \");\n+                }\n+            }\n+            buf.append(\"}\");\n+        }\n+        if (typesOfStackItems.length > 0) {\n+            buf.append(\", stack items={\");\n+            for (int i = 0; i < typesOfStackItems.length; i++) {\n+                buf.append(typesOfStackItems[i]);\n+                if (i < typesOfStackItems.length - 1) {\n+                    buf.append(\", \");\n+                }\n+            }\n+            buf.append(\"}\");\n+        }\n+        buf.append(\")\");\n+        return buf.toString();\n@@ -229,3 +230,0 @@\n-    public int getFrameType() {\n-        return frameType;\n-    }\n@@ -240,2 +238,2 @@\n-        }\n-        if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n@@ -243,2 +241,1 @@\n-        }\n-        if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n+        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n@@ -246,2 +243,1 @@\n-        }\n-        if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX || frameType == Const.SAME_FRAME_EXTENDED) {\n+        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n@@ -249,2 +245,3 @@\n-        }\n-        if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n+        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n+            return 3;\n+        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n@@ -252,2 +249,2 @@\n-            for (final StackMapType typesOfLocal : typesOfLocals) {\n-                len += typesOfLocal.hasIndex() ? 3 : 1;\n+            for (final StackMapType types_of_local : typesOfLocals) {\n+                len += types_of_local.hasIndex() ? 3 : 1;\n@@ -256,2 +253,10 @@\n-        }\n-        if (frameType != Const.FULL_FRAME) {\n+        } else if (frameType == Const.FULL_FRAME) {\n+            int len = 7;\n+            for (final StackMapType types_of_local : typesOfLocals) {\n+                len += types_of_local.hasIndex() ? 3 : 1;\n+            }\n+            for (final StackMapType types_of_stack_item : typesOfStackItems) {\n+                len += types_of_stack_item.hasIndex() ? 3 : 1;\n+            }\n+            return len;\n+        } else {\n@@ -260,8 +265,0 @@\n-        int len = 7;\n-        for (final StackMapType typesOfLocal : typesOfLocals) {\n-            len += typesOfLocal.hasIndex() ? 3 : 1;\n-        }\n-        for (final StackMapType typesOfStackItem : typesOfStackItems) {\n-            len += typesOfStackItem.hasIndex() ? 3 : 1;\n-        }\n-        return len;\n@@ -270,3 +267,0 @@\n-    public int getNumberOfLocals() {\n-        return typesOfLocals.length;\n-    }\n@@ -274,2 +268,15 @@\n-    public int getNumberOfStackItems() {\n-        return typesOfStackItems.length;\n+    public void setFrameType( final int f ) {\n+        if (f >= Const.SAME_FRAME && f <= Const.SAME_FRAME_MAX) {\n+            byteCodeOffset = f - Const.SAME_FRAME;\n+        } else if (f >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   f <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            byteCodeOffset = f - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;\n+        } else if (f == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f >= Const.CHOP_FRAME && f <= Const.CHOP_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f == Const.SAME_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f >= Const.APPEND_FRAME && f <= Const.APPEND_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (f == Const.FULL_FRAME) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid StackMap frameType\");\n+        }\n+        frameType = f;\n@@ -278,3 +285,0 @@\n-    public StackMapType[] getTypesOfLocals() {\n-        return typesOfLocals;\n-    }\n@@ -282,2 +286,2 @@\n-    public StackMapType[] getTypesOfStackItems() {\n-        return typesOfStackItems;\n+    public int getFrameType() {\n+        return frameType;\n@@ -286,9 +290,0 @@\n-    private boolean invalidFrameType(final int f) {\n-        \/\/ @formatter:off\n-        return f != Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED\n-            && !(f >= Const.CHOP_FRAME && f <= Const.CHOP_FRAME_MAX)\n-            && f != Const.SAME_FRAME_EXTENDED\n-            && !(f >= Const.APPEND_FRAME && f <= Const.APPEND_FRAME_MAX)\n-            && f != Const.FULL_FRAME;\n-        \/\/ @formatter:on\n-    }\n@@ -296,3 +291,3 @@\n-    public void setByteCodeOffset(final int newOffset) {\n-        if (newOffset < 0 || newOffset > 32767) {\n-            throw new IllegalArgumentException(\"Invalid StackMap offset: \" + newOffset);\n+    public void setByteCodeOffset( final int new_offset ) {\n+        if (new_offset < 0 || new_offset > 32767) {\n+            throw new IllegalArgumentException(\"Invalid StackMap offset: \" + new_offset);\n@@ -301,2 +296,3 @@\n-        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n-            if (newOffset > Const.SAME_FRAME_MAX) {\n+        if (frameType >= Const.SAME_FRAME &&\n+            frameType <= Const.SAME_FRAME_MAX) {\n+            if (new_offset > Const.SAME_FRAME_MAX) {\n@@ -305,1 +301,1 @@\n-                frameType = newOffset;\n+                frameType = new_offset;\n@@ -307,2 +303,3 @@\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            if (newOffset > Const.SAME_FRAME_MAX) {\n+        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME &&\n+                   frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n+            if (new_offset > Const.SAME_FRAME_MAX) {\n@@ -311,1 +308,1 @@\n-                frameType = Const.SAME_LOCALS_1_STACK_ITEM_FRAME + newOffset;\n+                frameType = Const.SAME_LOCALS_1_STACK_ITEM_FRAME + new_offset;\n@@ -313,1 +310,8 @@\n-        } else if (invalidFrameType(frameType)) {\n+        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType >= Const.CHOP_FRAME &&\n+                   frameType <= Const.CHOP_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType == Const.SAME_FRAME_EXTENDED) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType >= Const.APPEND_FRAME &&\n+                   frameType <= Const.APPEND_FRAME_MAX) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else if (frameType == Const.FULL_FRAME) { \/\/ CHECKSTYLE IGNORE EmptyBlock\n+        } else {\n@@ -316,1 +320,1 @@\n-        byteCodeOffset = newOffset;\n+        byteCodeOffset = new_offset;\n@@ -319,0 +323,1 @@\n+\n@@ -320,1 +325,5 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * Update the distance (as an offset delta) from this StackMap\n+     * entry to the next.  Note that this might cause the the\n+     * frame type to change.  Note also that delta may be negative.\n+     *\n+     * @param delta offset delta\n@@ -322,2 +331,2 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n-        this.constantPool = constantPool;\n+    public void updateByteCodeOffset(final int delta) {\n+        setByteCodeOffset(byteCodeOffset + delta);\n@@ -326,9 +335,3 @@\n-    public void setFrameType(final int ft) {\n-        if (ft >= Const.SAME_FRAME && ft <= Const.SAME_FRAME_MAX) {\n-            byteCodeOffset = ft - Const.SAME_FRAME;\n-        } else if (ft >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && ft <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            byteCodeOffset = ft - Const.SAME_LOCALS_1_STACK_ITEM_FRAME;\n-        } else if (invalidFrameType(ft)) {\n-            throw new IllegalArgumentException(\"Invalid StackMap frameType\");\n-        }\n-        frameType = ft;\n+\n+    public int getByteCodeOffset() {\n+        return byteCodeOffset;\n@@ -337,0 +340,1 @@\n+\n@@ -342,1 +346,6 @@\n-    public void setNumberOfLocals(final int n) { \/\/ TODO unused\n+    public void setNumberOfLocals( final int n ) { \/\/ TODO unused\n+    }\n+\n+\n+    public int getNumberOfLocals() {\n+        return typesOfLocals.length;\n@@ -345,0 +354,11 @@\n+\n+    public void setTypesOfLocals( final StackMapType[] types ) {\n+        typesOfLocals = types != null ? types : new StackMapType[0];\n+    }\n+\n+\n+    public StackMapType[] getTypesOfLocals() {\n+        return typesOfLocals;\n+    }\n+\n+\n@@ -350,1 +370,6 @@\n-    public void setNumberOfStackItems(final int n) { \/\/ TODO unused\n+    public void setNumberOfStackItems( final int n ) { \/\/ TODO unused\n+    }\n+\n+\n+    public int getNumberOfStackItems() {\n+        return typesOfStackItems.length;\n@@ -353,2 +378,3 @@\n-    public void setTypesOfLocals(final StackMapType[] types) {\n-        typesOfLocals = types != null ? types : StackMapType.EMPTY_ARRAY;\n+\n+    public void setTypesOfStackItems( final StackMapType[] types ) {\n+        typesOfStackItems = types != null ? types : new StackMapType[0];\n@@ -357,2 +383,3 @@\n-    public void setTypesOfStackItems(final StackMapType[] types) {\n-        typesOfStackItems = types != null ? types : StackMapType.EMPTY_ARRAY;\n+\n+    public StackMapType[] getTypesOfStackItems() {\n+        return typesOfStackItems;\n@@ -361,0 +388,1 @@\n+\n@@ -362,1 +390,1 @@\n-     * @return String representation.\n+     * @return deep copy of this object\n@@ -364,20 +392,6 @@\n-    @Override\n-    public String toString() {\n-        final StringBuilder buf = new StringBuilder(64);\n-        buf.append(\"(\");\n-        if (frameType >= Const.SAME_FRAME && frameType <= Const.SAME_FRAME_MAX) {\n-            buf.append(\"SAME\");\n-        } else if (frameType >= Const.SAME_LOCALS_1_STACK_ITEM_FRAME && frameType <= Const.SAME_LOCALS_1_STACK_ITEM_FRAME_MAX) {\n-            buf.append(\"SAME_LOCALS_1_STACK\");\n-        } else if (frameType == Const.SAME_LOCALS_1_STACK_ITEM_FRAME_EXTENDED) {\n-            buf.append(\"SAME_LOCALS_1_STACK_EXTENDED\");\n-        } else if (frameType >= Const.CHOP_FRAME && frameType <= Const.CHOP_FRAME_MAX) {\n-            buf.append(\"CHOP \").append(String.valueOf(251 - frameType));\n-        } else if (frameType == Const.SAME_FRAME_EXTENDED) {\n-            buf.append(\"SAME_EXTENDED\");\n-        } else if (frameType >= Const.APPEND_FRAME && frameType <= Const.APPEND_FRAME_MAX) {\n-            buf.append(\"APPEND \").append(String.valueOf(frameType - 251));\n-        } else if (frameType == Const.FULL_FRAME) {\n-            buf.append(\"FULL\");\n-        } else {\n-            buf.append(\"UNKNOWN (\").append(frameType).append(\")\");\n+    public StackMapEntry copy() {\n+        StackMapEntry e;\n+        try {\n+            e = (StackMapEntry) clone();\n+        } catch (final CloneNotSupportedException ex) {\n+            throw new Error(\"Clone Not Supported\");\n@@ -385,10 +399,4 @@\n-        buf.append(\", offset delta=\").append(byteCodeOffset);\n-        if (typesOfLocals.length > 0) {\n-            buf.append(\", locals={\");\n-            for (int i = 0; i < typesOfLocals.length; i++) {\n-                buf.append(typesOfLocals[i]);\n-                if (i < typesOfLocals.length - 1) {\n-                    buf.append(\", \");\n-                }\n-            }\n-            buf.append(\"}\");\n+\n+        e.typesOfLocals = new StackMapType[typesOfLocals.length];\n+        for (int i = 0; i < typesOfLocals.length; i++) {\n+            e.typesOfLocals[i] = typesOfLocals[i].copy();\n@@ -396,9 +404,3 @@\n-        if (typesOfStackItems.length > 0) {\n-            buf.append(\", stack items={\");\n-            for (int i = 0; i < typesOfStackItems.length; i++) {\n-                buf.append(typesOfStackItems[i]);\n-                if (i < typesOfStackItems.length - 1) {\n-                    buf.append(\", \");\n-                }\n-            }\n-            buf.append(\"}\");\n+        e.typesOfStackItems = new StackMapType[typesOfStackItems.length];\n+        for (int i = 0; i < typesOfStackItems.length; i++) {\n+            e.typesOfStackItems[i] = typesOfStackItems[i].copy();\n@@ -406,2 +408,1 @@\n-        buf.append(\")\");\n-        return buf.toString();\n+        return e;\n@@ -410,0 +411,1 @@\n+\n@@ -411,2 +413,3 @@\n-     * Update the distance (as an offset delta) from this StackMap entry to the next. Note that this might cause the\n-     * frame type to change. Note also that delta may be negative.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -414,1 +417,1 @@\n-     * @param delta offset delta\n+     * @param v Visitor object\n@@ -416,2 +419,19 @@\n-    public void updateByteCodeOffset(final int delta) {\n-        setByteCodeOffset(byteCodeOffset + delta);\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackMapEntry(this);\n+    }\n+\n+\n+    \/**\n+     * @return Constant pool used by this object.\n+     *\/\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n+    }\n+\n+\n+    \/**\n+     * @param constantPool Constant pool to be used for this object.\n+     *\/\n+    public void setConstantPool( final ConstantPool constantPool ) {\n+        this.constantPool = constantPool;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapEntry.java","additions":239,"deletions":219,"binary":false,"changes":458,"status":"modified"},{"patch":"@@ -31,1 +31,2 @@\n- * This class represents the type of a local variable or item on stack used in the StackMap entries.\n+ * This class represents the type of a local variable or item on stack\n+ * used in the StackMap entries.\n@@ -33,3 +34,3 @@\n- * @see StackMapEntry\n- * @see StackMap\n- * @see Const\n+ * @see     StackMapEntry\n+ * @see     StackMap\n+ * @see     Const\n@@ -39,2 +40,0 @@\n-    public static final StackMapType[] EMPTY_ARRAY = {}; \/\/ must be public because BCELifier code generator writes calls to it\n-\n@@ -45,9 +44,0 @@\n-    \/**\n-     * @param type type tag as defined in the Constants interface\n-     * @param index index to constant pool, or byte code offset\n-     *\/\n-    public StackMapType(final byte type, final int index, final ConstantPool constantPool) {\n-        this.type = checkType(type);\n-        this.index = index;\n-        this.constantPool = constantPool;\n-    }\n@@ -57,1 +47,0 @@\n-     *\n@@ -59,1 +48,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -61,2 +50,2 @@\n-    StackMapType(final DataInput file, final ConstantPool constantPool) throws IOException {\n-        this(file.readByte(), -1, constantPool);\n+    StackMapType(final DataInput file, final ConstantPool constant_pool) throws IOException {\n+        this(file.readByte(), -1, constant_pool);\n@@ -64,1 +53,1 @@\n-            this.index = file.readUnsignedShort();\n+            this.index = file.readShort();\n@@ -66,1 +55,1 @@\n-        this.constantPool = constantPool;\n+        this.constantPool = constant_pool;\n@@ -69,3 +58,8 @@\n-    private byte checkType(final byte type) {\n-        if (type < Const.ITEM_Bogus || type > Const.ITEM_NewObject) {\n-            throw new ClassFormatException(\"Illegal type for StackMapType: \" + type);\n+\n+    \/**\n+     * @param type type tag as defined in the Constants interface\n+     * @param index index to constant pool, or byte code offset\n+     *\/\n+    public StackMapType(final byte type, final int index, final ConstantPool constant_pool) {\n+        if ((type < Const.ITEM_Bogus) || (type > Const.ITEM_NewObject)) {\n+            throw new IllegalArgumentException(\"Illegal type for StackMapType: \" + type);\n@@ -73,0 +67,15 @@\n+        this.type = type;\n+        this.index = index;\n+        this.constantPool = constant_pool;\n+    }\n+\n+\n+    public void setType( final byte t ) {\n+        if ((t < Const.ITEM_Bogus) || (t > Const.ITEM_NewObject)) {\n+            throw new IllegalArgumentException(\"Illegal type for StackMapType: \" + t);\n+        }\n+        type = t;\n+    }\n+\n+\n+    public byte getType() {\n@@ -76,2 +85,8 @@\n-    \/**\n-     * @return deep copy of this object\n+\n+    public void setIndex( final int t ) {\n+        index = t;\n+    }\n+\n+\n+    \/** @return index to constant pool if type == ITEM_Object, or offset\n+     * in byte code, if type == ITEM_NewObject, and -1 otherwise\n@@ -79,7 +94,2 @@\n-    public StackMapType copy() {\n-        try {\n-            return (StackMapType) clone();\n-        } catch (final CloneNotSupportedException e) {\n-            \/\/ TODO should this throw?\n-        }\n-        return null;\n+    public int getIndex() {\n+        return index;\n@@ -88,0 +98,1 @@\n+\n@@ -92,1 +103,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -94,1 +105,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -101,6 +112,0 @@\n-    \/**\n-     * @return Constant pool used by this object.\n-     *\/\n-    public ConstantPool getConstantPool() {\n-        return constantPool;\n-    }\n@@ -108,14 +113,1 @@\n-    \/**\n-     * @return index to constant pool if type == ITEM_Object, or offset in byte code, if type == ITEM_NewObject, and -1\n-     *         otherwise\n-     *\/\n-    public int getIndex() {\n-        return index;\n-    }\n-\n-    public byte getType() {\n-        return type;\n-    }\n-\n-    \/**\n-     * @return true, if type is either ITEM_Object or ITEM_NewObject\n+    \/** @return true, if type is either ITEM_Object or ITEM_NewObject\n@@ -127,0 +119,1 @@\n+\n@@ -133,2 +126,1 @@\n-        }\n-        if (type == Const.ITEM_NewObject) {\n+        } else if (type == Const.ITEM_NewObject) {\n@@ -136,0 +128,2 @@\n+        } else {\n+            return \"\";\n@@ -137,1 +131,0 @@\n-        return \"\";\n@@ -140,0 +133,1 @@\n+\n@@ -141,1 +135,1 @@\n-     * @param constantPool Constant pool to be used for this object.\n+     * @return String representation\n@@ -143,2 +137,3 @@\n-    public void setConstantPool(final ConstantPool constantPool) {\n-        this.constantPool = constantPool;\n+    @Override\n+    public String toString() {\n+        return \"(type=\" + Const.getItemName(type) + printIndex() + \")\";\n@@ -147,2 +142,11 @@\n-    public void setIndex(final int index) {\n-        this.index = index;\n+\n+    \/**\n+     * @return deep copy of this object\n+     *\/\n+    public StackMapType copy() {\n+        try {\n+            return (StackMapType) clone();\n+        } catch (final CloneNotSupportedException e) {\n+            \/\/ TODO should this throw?\n+        }\n+        return null;\n@@ -151,2 +155,6 @@\n-    public void setType(final byte type) {\n-        this.type = checkType(type);\n+\n+    \/**\n+     * @return Constant pool used by this object.\n+     *\/\n+    public ConstantPool getConstantPool() {\n+        return constantPool;\n@@ -155,0 +163,1 @@\n+\n@@ -156,1 +165,1 @@\n-     * @return String representation\n+     * @param constantPool Constant pool to be used for this object.\n@@ -158,3 +167,2 @@\n-    @Override\n-    public String toString() {\n-        return \"(type=\" + Const.getItemName(type) + printIndex() + \")\";\n+    public void setConstantPool( final ConstantPool constantPool ) {\n+        this.constantPool = constantPool;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/StackMapType.java","additions":77,"deletions":69,"binary":false,"changes":146,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.util.Args;\n@@ -32,4 +31,7 @@\n- * This class is derived from <em>Attribute<\/em> and declares this class as 'synthetic', i.e., it needs special\n- * handling. The JVM specification states \"A class member that does not appear in the source code must be marked using a\n- * Synthetic attribute.\" It may appear in the ClassFile attribute table, a field_info table or a method_info table. This\n- * class is intended to be instantiated from the <em>Attribute.readAttribute()<\/em> method.\n+ * This class is derived from <em>Attribute<\/em> and declares this class as\n+ * `synthetic', i.e., it needs special handling.  The JVM specification\n+ * states \"A class member that does not appear in the source code must be\n+ * marked using a Synthetic attribute.\"  It may appear in the ClassFile\n+ * attribute table, a field_info table or a method_info table.  This class\n+ * is intended to be instantiated from the\n+ * <em>Attribute.readAttribute()<\/em> method.\n@@ -37,1 +39,1 @@\n- * @see Attribute\n+ * @see     Attribute\n@@ -43,0 +45,10 @@\n+\n+    \/**\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use copy() for a physical copy.\n+     *\/\n+    public Synthetic(final Synthetic c) {\n+        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n+    }\n+\n+\n@@ -44,1 +56,2 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8, which should represent the string \"Synthetic\".\n+     * @param name_index Index in constant pool to CONSTANT_Utf8, which\n+     * should represent the string \"Synthetic\".\n@@ -47,1 +60,2 @@\n-     * @param constantPool The constant pool this attribute is associated with.\n+     * @param constant_pool The constant pool this attribute is associated\n+     * with.\n@@ -49,2 +63,2 @@\n-    public Synthetic(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n-        super(Const.ATTR_SYNTHETIC, nameIndex, Args.require0(length, \"Synthetic attribute length\"), constantPool);\n+    public Synthetic(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_SYNTHETIC, name_index, length, constant_pool);\n@@ -54,0 +68,1 @@\n+\n@@ -57,1 +72,1 @@\n-     * @param nameIndex Index in constant pool to CONSTANT_Utf8\n+     * @param name_index Index in constant pool to CONSTANT_Utf8\n@@ -60,2 +75,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -63,2 +78,3 @@\n-    Synthetic(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (byte[]) null, constantPool);\n+    Synthetic(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (byte[]) null, constant_pool);\n@@ -72,9 +88,0 @@\n-    \/**\n-     * Initialize from another object. Note that both objects use the same references (shallow copy). Use copy() for a\n-     * physical copy.\n-     *\n-     * @param c Source to copy.\n-     *\/\n-    public Synthetic(final Synthetic c) {\n-        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n-    }\n@@ -83,2 +90,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -89,1 +97,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -93,12 +101,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Synthetic c = (Synthetic) clone();\n-        if (bytes != null) {\n-            c.bytes = bytes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -110,1 +106,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -113,1 +109,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -120,0 +116,1 @@\n+\n@@ -127,0 +124,1 @@\n+\n@@ -130,1 +128,1 @@\n-    public void setBytes(final byte[] bytes) {\n+    public void setBytes( final byte[] bytes ) {\n@@ -134,0 +132,1 @@\n+\n@@ -145,0 +144,15 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Synthetic c = (Synthetic) clone();\n+        if (bytes != null) {\n+            c.bytes = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Synthetic.java","additions":56,"deletions":42,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n@@ -32,3 +33,5 @@\n- * This class represents a reference to an unknown (i.e., application-specific) attribute of a class. It is instantiated\n- * from the {@link Attribute#readAttribute(java.io.DataInput, ConstantPool)} method. Applications that need to read in\n- * application-specific attributes should create an {@link UnknownAttributeReader} implementation and attach it via\n+ * This class represents a reference to an unknown (i.e.,\n+ * application-specific) attribute of a class.  It is instantiated from the\n+ * {@link Attribute#readAttribute(java.io.DataInput, ConstantPool)} method.\n+ * Applications that need to read in application-specific attributes should create an\n+ * {@link UnknownAttributeReader} implementation and attach it via\n@@ -36,0 +39,1 @@\n+\n@@ -43,1 +47,0 @@\n-\n@@ -45,0 +48,12 @@\n+    private static final Map<String, Unknown> unknownAttributes = new HashMap<>();\n+\n+\n+    \/** @return array of unknown attributes, but just one for each kind.\n+     *\/\n+    static Unknown[] getUnknownAttributes() {\n+        final Unknown[] unknowns = new Unknown[unknownAttributes.size()];\n+        unknownAttributes.values().toArray(unknowns);\n+        unknownAttributes.clear();\n+        return unknowns;\n+    }\n+\n@@ -47,1 +62,10 @@\n-     * Constructs a new instance for a non-standard attribute.\n+     * Initialize from another object. Note that both objects use the same\n+     * references (shallow copy). Use clone() for a physical copy.\n+     *\/\n+    public Unknown(final Unknown c) {\n+        this(c.getNameIndex(), c.getLength(), c.getBytes(), c.getConstantPool());\n+    }\n+\n+\n+    \/**\n+     * Create a non-standard attribute.\n@@ -49,1 +73,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -52,1 +76,1 @@\n-     * @param constantPool Array of constants\n+     * @param constant_pool Array of constants\n@@ -54,2 +78,2 @@\n-    public Unknown(final int nameIndex, final int length, final byte[] bytes, final ConstantPool constantPool) {\n-        super(Const.ATTR_UNKNOWN, nameIndex, length, constantPool);\n+    public Unknown(final int name_index, final int length, final byte[] bytes, final ConstantPool constant_pool) {\n+        super(Const.ATTR_UNKNOWN, name_index, length, constant_pool);\n@@ -57,1 +81,3 @@\n-        this.name = constantPool.getConstantUtf8(nameIndex).getBytes();\n+        name = ((ConstantUtf8) constant_pool.getConstant(name_index, Const.CONSTANT_Utf8))\n+                .getBytes();\n+        unknownAttributes.put(name, this);\n@@ -60,0 +86,1 @@\n+\n@@ -61,1 +88,1 @@\n-     * Constructs a new instance from an input stream.\n+     * Construct object from input stream.\n@@ -63,1 +90,1 @@\n-     * @param nameIndex Index in constant pool\n+     * @param name_index Index in constant pool\n@@ -66,2 +93,2 @@\n-     * @param constantPool Array of constants\n-     * @throws IOException if an I\/O error occurs.\n+     * @param constant_pool Array of constants\n+     * @throws IOException\n@@ -69,2 +96,3 @@\n-    Unknown(final int nameIndex, final int length, final DataInput input, final ConstantPool constantPool) throws IOException {\n-        this(nameIndex, length, (byte[]) null, constantPool);\n+    Unknown(final int name_index, final int length, final DataInput input, final ConstantPool constant_pool)\n+            throws IOException {\n+        this(name_index, length, (byte[]) null, constant_pool);\n@@ -77,8 +105,0 @@\n-    \/**\n-     * Constructs a new instance from another instance. Note that both objects use the same references (shallow copy). Use clone() for a physical copy.\n-     *\n-     * @param unknown Source.\n-     *\/\n-    public Unknown(final Unknown unknown) {\n-        this(unknown.getNameIndex(), unknown.getLength(), unknown.getBytes(), unknown.getConstantPool());\n-    }\n@@ -87,2 +107,3 @@\n-     * Called by objects that are traversing the nodes of the tree implicitly defined by the contents of a Java class.\n-     * I.e., the hierarchy of methods, fields, attributes, etc. spawns a tree of objects.\n+     * Called by objects that are traversing the nodes of the tree implicitely\n+     * defined by the contents of a Java class. I.e., the hierarchy of methods,\n+     * fields, attributes, etc. spawns a tree of objects.\n@@ -93,1 +114,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -97,12 +118,0 @@\n-    \/**\n-     * @return deep copy of this attribute\n-     *\/\n-    @Override\n-    public Attribute copy(final ConstantPool constantPool) {\n-        final Unknown c = (Unknown) clone();\n-        if (bytes != null) {\n-            c.bytes = bytes.clone();\n-        }\n-        c.setConstantPool(constantPool);\n-        return c;\n-    }\n@@ -111,1 +120,1 @@\n-     * Dumps unknown bytes to file stream.\n+     * Dump unknown bytes to file stream.\n@@ -114,1 +123,1 @@\n-     * @throws IOException if an I\/O error occurs.\n+     * @throws IOException\n@@ -117,1 +126,1 @@\n-    public void dump(final DataOutputStream file) throws IOException {\n+    public void dump( final DataOutputStream file ) throws IOException {\n@@ -124,0 +133,1 @@\n+\n@@ -131,0 +141,1 @@\n+\n@@ -139,0 +150,1 @@\n+\n@@ -142,1 +154,1 @@\n-    public void setBytes(final byte[] bytes) {\n+    public void setBytes( final byte[] bytes ) {\n@@ -146,0 +158,1 @@\n+\n@@ -155,3 +168,3 @@\n-        final int limit = 10;\n-        if (super.getLength() > limit) {\n-            final byte[] tmp = Arrays.copyOf(bytes, limit);\n+        if (super.getLength() > 10) {\n+            final byte[] tmp = new byte[10];\n+            System.arraycopy(bytes, 0, tmp, 0, 10);\n@@ -164,0 +177,15 @@\n+\n+\n+    \/**\n+     * @return deep copy of this attribute\n+     *\/\n+    @Override\n+    public Attribute copy( final ConstantPool _constant_pool ) {\n+        final Unknown c = (Unknown) clone();\n+        if (bytes != null) {\n+            c.bytes = new byte[bytes.length];\n+            System.arraycopy(bytes, 0, c.bytes, 0, bytes.length);\n+        }\n+        c.setConstantPool(_constant_pool);\n+        return c;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Unknown.java","additions":75,"deletions":47,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Unknown (non-standard) attributes may be read via user-defined factory objects that can be registered with the\n- * Attribute.addAttributeReader method. These factory objects should implement this interface.\n+ * Unknown (non-standard) attributes may be read via user-defined factory\n+ * objects that can be registered with the Attribute.addAttributeReader\n+ * method. These factory objects should implement this interface.\n@@ -34,3 +35,3 @@\n-     * When this attribute reader is added via the static method Attribute.addAttributeReader, an attribute name is\n-     * associated with it. As the class file parser parses attributes, it will call various AttributeReaders based on the\n-     * name of the attributes it is constructing.\n+     * When this attribute reader is added via the static method Attribute.addAttributeReader,\n+     * an attribute name is associated with it. As the class file parser parses attributes,\n+     * it will call various AttributeReaders based on the name of the attributes it is constructing.\n@@ -38,5 +39,6 @@\n-     * @param nameIndex An index into the constant pool, indexing a ConstantUtf8 that represents the name of the attribute.\n-     * @param length The length of the data contained in the attribute. This is written into the constant pool and should\n-     *        agree with what the factory expects the length to be.\n-     * @param file This is the data input that the factory needs to read its data from.\n-     * @param constantPool This is the constant pool associated with the Attribute that we are constructing.\n+     * @param name_index    An index into the constant pool, indexing a ConstantUtf8\n+     *                      that represents the name of the attribute.\n+     * @param length        The length of the data contained in the attribute. This is written\n+     *                      into the constant pool and should agree with what the factory expects the length to be.\n+     * @param file          This is the data input that the factory needs to read its data from.\n+     * @param constant_pool This is the constant pool associated with the Attribute that we are constructing.\n@@ -44,2 +46,3 @@\n-     * @return The user-defined AttributeReader should take this data and use it to construct an attribute. In the case of\n-     *         errors, a null can be returned which will cause the parsing of the class file to fail.\n+     * @return The user-defined AttributeReader should take this data and use\n+     * it to construct an attribute.  In the case of errors, a null can be\n+     * returned which will cause the parsing of the class file to fail.\n@@ -49,1 +52,1 @@\n-    Attribute createAttribute(int nameIndex, int length, java.io.DataInput file, ConstantPool constantPool);\n+    Attribute createAttribute( int name_index, int length, java.io.DataInput file, ConstantPool constant_pool );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/UnknownAttributeReader.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.util.Arrays;\n@@ -46,1 +45,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -51,29 +50,3 @@\n-    \/**\n-     * Decode characters into bytes. Used by <a href=\"Utility.html#decode(java.lang.String, boolean)\">decode()<\/a>\n-     *\/\n-    private static class JavaReader extends FilterReader {\n-\n-        public JavaReader(final Reader in) {\n-            super(in);\n-        }\n-\n-        @Override\n-        public int read() throws IOException {\n-            final int b = in.read();\n-            if (b != ESCAPE_CHAR) {\n-                return b;\n-            }\n-            final int i = in.read();\n-            if (i < 0) {\n-                return -1;\n-            }\n-            if (i >= '0' && i <= '9' || i >= 'a' && i <= 'f') { \/\/ Normal escape\n-                final int j = in.read();\n-                if (j < 0) {\n-                    return -1;\n-                }\n-                final char[] tmp = {(char) i, (char) j};\n-                return Integer.parseInt(new String(tmp), 16);\n-            }\n-            return MAP_CHAR[i];\n-        }\n+    private static int unwrap( final ThreadLocal<Integer> tl ) {\n+        return tl.get();\n+    }\n@@ -81,7 +54,2 @@\n-        @Override\n-        public int read(final char[] cbuf, final int off, final int len) throws IOException {\n-            for (int i = 0; i < len; i++) {\n-                cbuf[off + i] = (char) read();\n-            }\n-            return len;\n-        }\n+    private static void wrap( final ThreadLocal<Integer> tl, final int value ) {\n+        tl.set(value);\n@@ -90,3 +58,4 @@\n-    \/**\n-     * Encode bytes into valid java identifier characters. Used by\n-     * <a href=\"Utility.html#encode(byte[], boolean)\">encode()<\/a>\n+    \/* How many chars have been consumed\n+     * during parsing in typeSignatureToString().\n+     * Read by methodSignatureToString().\n+     * Set by side effect, but only internally.\n@@ -94,35 +63,1 @@\n-    private static class JavaWriter extends FilterWriter {\n-\n-        public JavaWriter(final Writer out) {\n-            super(out);\n-        }\n-\n-        @Override\n-        public void write(final char[] cbuf, final int off, final int len) throws IOException {\n-            for (int i = 0; i < len; i++) {\n-                write(cbuf[off + i]);\n-            }\n-        }\n-\n-        @Override\n-        public void write(final int b) throws IOException {\n-            if (isJavaIdentifierPart((char) b) && b != ESCAPE_CHAR) {\n-                out.write(b);\n-            } else {\n-                out.write(ESCAPE_CHAR); \/\/ Escape character\n-                \/\/ Special escape\n-                if (b >= 0 && b < FREE_CHARS) {\n-                    out.write(CHAR_MAP[b]);\n-                } else { \/\/ Normal escape\n-                    final char[] tmp = Integer.toHexString(b).toCharArray();\n-                    if (tmp.length == 1) {\n-                        out.write('0');\n-                        out.write(tmp[0]);\n-                    } else {\n-                        out.write(tmp[0]);\n-                        out.write(tmp[1]);\n-                    }\n-                }\n-            }\n-        }\n-\n+    private static ThreadLocal<Integer> consumed_chars = new ThreadLocal<Integer>() {\n@@ -130,2 +65,2 @@\n-        public void write(final String str, final int off, final int len) throws IOException {\n-            write(str.toCharArray(), off, len);\n+        protected Integer initialValue() {\n+            return 0;\n@@ -133,12 +68,10 @@\n-    }\n-\n-    \/*\n-     * How many chars have been consumed during parsing in typeSignatureToString(). Read by methodSignatureToString(). Set\n-     * by side effect, but only internally.\n-     *\/\n-    private static final ThreadLocal<Integer> CONSUMER_CHARS = ThreadLocal.withInitial(() -> Integer.valueOf(0));\n-\n-    \/*\n-     * The 'WIDE' instruction is used in the byte code to allow 16-bit wide indices for local variables. This opcode\n-     * precedes an 'ILOAD', e.g.. The opcode immediately following takes an extra byte which is combined with the following\n-     * byte to form a 16-bit value.\n+    };\n+\n+    \/* The `WIDE' instruction is used in the\n+     * byte code to allow 16-bit wide indices\n+     * for local variables. This opcode\n+     * precedes an `ILOAD', e.g.. The opcode\n+     * immediately following takes an extra\n+     * byte which is combined with the\n+     * following byte to form a\n+     * 16-bit value.\n@@ -146,1 +79,1 @@\n-    private static boolean wide;\n+    private static boolean wide = false;\n@@ -148,27 +81,0 @@\n-    \/\/ A-Z, g-z, _, $\n-    private static final int FREE_CHARS = 48;\n-\n-    private static final int[] CHAR_MAP = new int[FREE_CHARS];\n-\n-    private static final int[] MAP_CHAR = new int[256]; \/\/ Reverse map\n-\n-    private static final char ESCAPE_CHAR = '$';\n-\n-    static {\n-        int j = 0;\n-        for (int i = 'A'; i <= 'Z'; i++) {\n-            CHAR_MAP[j] = i;\n-            MAP_CHAR[i] = j;\n-            j++;\n-        }\n-        for (int i = 'g'; i <= 'z'; i++) {\n-            CHAR_MAP[j] = i;\n-            MAP_CHAR[i] = j;\n-            j++;\n-        }\n-        CHAR_MAP[j] = '$';\n-        MAP_CHAR['$'] = j;\n-        j++;\n-        CHAR_MAP[j] = '_';\n-        MAP_CHAR['_'] = j;\n-    }\n@@ -177,1 +83,1 @@\n-     * Convert bit field of flags into string such as 'static final'.\n+     * Convert bit field of flags into string such as `static final'.\n@@ -179,1 +85,1 @@\n-     * @param accessFlags Access flags\n+     * @param  access_flags Access flags\n@@ -182,2 +88,2 @@\n-    public static String accessToString(final int accessFlags) {\n-        return accessToString(accessFlags, false);\n+    public static String accessToString( final int access_flags ) {\n+        return accessToString(access_flags, false);\n@@ -186,0 +92,1 @@\n+\n@@ -187,1 +94,1 @@\n-     * Convert bit field of flags into string such as 'static final'.\n+     * Convert bit field of flags into string such as `static final'.\n@@ -189,2 +96,4 @@\n-     * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be \"synchronized\".\n-     * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.\n+     * Special case: Classes compiled with new compilers and with the\n+     * `ACC_SUPER' flag would be said to be \"synchronized\". This is\n+     * because SUN used the same value for the flags `ACC_SUPER' and\n+     * `ACC_SYNCHRONIZED'.\n@@ -192,2 +101,2 @@\n-     * @param accessFlags Access flags\n-     * @param forClass access flags are for class qualifiers ?\n+     * @param  access_flags Access flags\n+     * @param  for_class access flags are for class qualifiers ?\n@@ -196,1 +105,1 @@\n-    public static String accessToString(final int accessFlags, final boolean forClass) {\n+    public static String accessToString( final int access_flags, final boolean for_class ) {\n@@ -201,4 +110,5 @@\n-            if ((accessFlags & p) != 0) {\n-                \/*\n-                 * Special case: Classes compiled with new compilers and with the 'ACC_SUPER' flag would be said to be \"synchronized\".\n-                 * This is because SUN used the same value for the flags 'ACC_SUPER' and 'ACC_SYNCHRONIZED'.\n+            if ((access_flags & p) != 0) {\n+                \/* Special case: Classes compiled with new compilers and with the\n+                 * `ACC_SUPER' flag would be said to be \"synchronized\". This is\n+                 * because SUN used the same value for the flags `ACC_SUPER' and\n+                 * `ACC_SYNCHRONIZED'.\n@@ -206,1 +116,1 @@\n-                if (forClass && (p == Const.ACC_SUPER || p == Const.ACC_INTERFACE)) {\n+                if (for_class && ((p == Const.ACC_SUPER) || (p == Const.ACC_INTERFACE))) {\n@@ -215,6 +125,0 @@\n-    \/**\n-     * Convert (signed) byte to (unsigned) short value, i.e., all negative values become positive.\n-     *\/\n-    private static short byteToShort(final byte b) {\n-        return b < 0 ? (short) (256 + b) : (short) b;\n-    }\n@@ -223,1 +127,1 @@\n-     * @param accessFlags the class flags\n+     * @param access_flags the class flags\n@@ -227,10 +131,2 @@\n-    public static String classOrInterface(final int accessFlags) {\n-        return (accessFlags & Const.ACC_INTERFACE) != 0 ? \"interface\" : \"class\";\n-    }\n-\n-    \/**\n-     * @return 'flag' with bit 'i' set to 0\n-     *\/\n-    public static int clearBit(final int flag, final int i) {\n-        final int bit = pow2(i);\n-        return (flag & bit) == 0 ? flag : flag ^ bit;\n+    public static String classOrInterface( final int access_flags ) {\n+        return ((access_flags & Const.ACC_INTERFACE) != 0) ? \"interface\" : \"class\";\n@@ -239,3 +135,0 @@\n-    public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length) {\n-        return codeToString(code, constantPool, index, length, true);\n-    }\n@@ -244,2 +137,4 @@\n-     * Disassemble a byte array of JVM byte codes starting from code line 'index' and return the disassembled string\n-     * representation. Decode only 'num' opcodes (including their operands), use -1 if you want to decompile everything.\n+     * Disassemble a byte array of JVM byte codes starting from code line\n+     * `index' and return the disassembled string representation. Decode only\n+     * `num' opcodes (including their operands), use -1 if you want to\n+     * decompile everything.\n@@ -247,5 +142,6 @@\n-     * @param code byte code array\n-     * @param constantPool Array of constants\n-     * @param index offset in 'code' array <EM>(number of opcodes, not bytes!)<\/EM>\n-     * @param length number of opcodes to decompile, -1 for all\n-     * @param verbose be verbose, e.g. print constant pool index\n+     * @param  code byte code array\n+     * @param  constant_pool Array of constants\n+     * @param  index offset in `code' array\n+     * <EM>(number of opcodes, not bytes!)<\/EM>\n+     * @param  length number of opcodes to decompile, -1 for all\n+     * @param  verbose be verbose, e.g. print constant pool index\n@@ -254,1 +150,2 @@\n-    public static String codeToString(final byte[] code, final ConstantPool constantPool, final int index, final int length, final boolean verbose) {\n+    public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index,\n+            final int length, final boolean verbose ) {\n@@ -258,1 +155,1 @@\n-                codeToString(stream, constantPool, verbose);\n+                codeToString(stream, constant_pool, verbose);\n@@ -261,1 +158,1 @@\n-                if (length < 0 || i < length) {\n+                if ((length < 0) || (i < length)) {\n@@ -263,1 +160,1 @@\n-                    buf.append(indices).append(codeToString(stream, constantPool, verbose)).append('\\n');\n+                    buf.append(indices).append(codeToString(stream, constant_pool, verbose)).append('\\n');\n@@ -272,2 +169,3 @@\n-    public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool) throws IOException {\n-        return codeToString(bytes, constantPool, true);\n+\n+    public static String codeToString( final byte[] code, final ConstantPool constant_pool, final int index, final int length ) {\n+        return codeToString(code, constant_pool, index, length, true);\n@@ -276,0 +174,1 @@\n+\n@@ -277,1 +176,2 @@\n-     * Disassemble a stream of byte codes and return the string representation.\n+     * Disassemble a stream of byte codes and return the\n+     * string representation.\n@@ -279,3 +179,3 @@\n-     * @param bytes stream of bytes\n-     * @param constantPool Array of constants\n-     * @param verbose be verbose, e.g. print constant pool index\n+     * @param  bytes stream of bytes\n+     * @param  constant_pool Array of constants\n+     * @param  verbose be verbose, e.g. print constant pool index\n@@ -287,1 +187,1 @@\n-    public static String codeToString(final ByteSequence bytes, final ConstantPool constantPool,\n+    public static String codeToString(final ByteSequence bytes, final ConstantPool constant_pool,\n@@ -290,1 +190,1 @@\n-        int defaultOffset = 0;\n+        int default_offset = 0;\n@@ -298,2 +198,2 @@\n-        int[] jumpTable;\n-        int noPadBytes = 0;\n+        int[] jump_table;\n+        int no_pad_bytes = 0;\n@@ -302,2 +202,2 @@\n-        \/*\n-         * Special case: Skip (0-3) padding bytes, i.e., the following bytes are 4-byte-aligned\n+        \/* Special case: Skip (0-3) padding bytes, i.e., the\n+         * following bytes are 4-byte-aligned\n@@ -305,1 +205,1 @@\n-        if (opcode == Const.TABLESWITCH || opcode == Const.LOOKUPSWITCH) {\n+        if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\n@@ -307,2 +207,2 @@\n-            noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n-            for (int i = 0; i < noPadBytes; i++) {\n+            no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n+            for (int i = 0; i < no_pad_bytes; i++) {\n@@ -311,1 +211,2 @@\n-                    System.err.println(\"Warning: Padding byte != 0 in \" + Const.getOpcodeName(opcode) + \":\" + b);\n+                    System.err.println(\"Warning: Padding byte != 0 in \"\n+                            + Const.getOpcodeName(opcode) + \":\" + b);\n@@ -315,1 +216,1 @@\n-            defaultOffset = bytes.readInt();\n+            default_offset = bytes.readInt();\n@@ -318,15 +219,16 @@\n-        \/*\n-         * Table switch has variable length arguments.\n-         *\/\n-        case Const.TABLESWITCH:\n-            low = bytes.readInt();\n-            high = bytes.readInt();\n-            offset = bytes.getIndex() - 12 - noPadBytes - 1;\n-            defaultOffset += offset;\n-            buf.append(\"\\tdefault = \").append(defaultOffset).append(\", low = \").append(low).append(\", high = \").append(high).append(\"(\");\n-            jumpTable = new int[high - low + 1];\n-            for (int i = 0; i < jumpTable.length; i++) {\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(jumpTable[i]);\n-                if (i < jumpTable.length - 1) {\n-                    buf.append(\", \");\n+            \/* Table switch has variable length arguments.\n+             *\/\n+            case Const.TABLESWITCH:\n+                low = bytes.readInt();\n+                high = bytes.readInt();\n+                offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n+                default_offset += offset;\n+                buf.append(\"\\tdefault = \").append(default_offset).append(\", low = \").append(low)\n+                        .append(\", high = \").append(high).append(\"(\");\n+                jump_table = new int[high - low + 1];\n+                for (int i = 0; i < jump_table.length; i++) {\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(jump_table[i]);\n+                    if (i < jump_table.length - 1) {\n+                        buf.append(\", \");\n+                    }\n@@ -334,19 +236,19 @@\n-            }\n-            buf.append(\")\");\n-            break;\n-        \/*\n-         * Lookup switch has variable length arguments.\n-         *\/\n-        case Const.LOOKUPSWITCH: {\n-            npairs = bytes.readInt();\n-            offset = bytes.getIndex() - 8 - noPadBytes - 1;\n-            match = new int[npairs];\n-            jumpTable = new int[npairs];\n-            defaultOffset += offset;\n-            buf.append(\"\\tdefault = \").append(defaultOffset).append(\", npairs = \").append(npairs).append(\" (\");\n-            for (int i = 0; i < npairs; i++) {\n-                match[i] = bytes.readInt();\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(\"(\").append(match[i]).append(\", \").append(jumpTable[i]).append(\")\");\n-                if (i < npairs - 1) {\n-                    buf.append(\", \");\n+                buf.append(\")\");\n+                break;\n+            \/* Lookup switch has variable length arguments.\n+             *\/\n+            case Const.LOOKUPSWITCH: {\n+                npairs = bytes.readInt();\n+                offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n+                match = new int[npairs];\n+                jump_table = new int[npairs];\n+                default_offset += offset;\n+                buf.append(\"\\tdefault = \").append(default_offset).append(\", npairs = \").append(\n+                        npairs).append(\" (\");\n+                for (int i = 0; i < npairs; i++) {\n+                    match[i] = bytes.readInt();\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(\"(\").append(match[i]).append(\", \").append(jump_table[i]).append(\")\");\n+                    if (i < npairs - 1) {\n+                        buf.append(\", \");\n+                    }\n@@ -354,0 +256,1 @@\n+                buf.append(\")\");\n@@ -355,160 +258,157 @@\n-            buf.append(\")\");\n-        }\n-            break;\n-        \/*\n-         * Two address bytes + offset from start of byte stream form the jump target\n-         *\/\n-        case Const.GOTO:\n-        case Const.IFEQ:\n-        case Const.IFGE:\n-        case Const.IFGT:\n-        case Const.IFLE:\n-        case Const.IFLT:\n-        case Const.JSR:\n-        case Const.IFNE:\n-        case Const.IFNONNULL:\n-        case Const.IFNULL:\n-        case Const.IF_ACMPEQ:\n-        case Const.IF_ACMPNE:\n-        case Const.IF_ICMPEQ:\n-        case Const.IF_ICMPGE:\n-        case Const.IF_ICMPGT:\n-        case Const.IF_ICMPLE:\n-        case Const.IF_ICMPLT:\n-        case Const.IF_ICMPNE:\n-            buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readShort());\n-            break;\n-        \/*\n-         * 32-bit wide jumps\n-         *\/\n-        case Const.GOTO_W:\n-        case Const.JSR_W:\n-            buf.append(\"\\t\\t#\").append(bytes.getIndex() - 1 + bytes.readInt());\n-            break;\n-        \/*\n-         * Index byte references local variable (register)\n-         *\/\n-        case Const.ALOAD:\n-        case Const.ASTORE:\n-        case Const.DLOAD:\n-        case Const.DSTORE:\n-        case Const.FLOAD:\n-        case Const.FSTORE:\n-        case Const.ILOAD:\n-        case Const.ISTORE:\n-        case Const.LLOAD:\n-        case Const.LSTORE:\n-        case Const.RET:\n-            if (wide) {\n-                vindex = bytes.readUnsignedShort();\n-                wide = false; \/\/ Clear flag\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-            }\n-            buf.append(\"\\t\\t%\").append(vindex);\n-            break;\n-        \/*\n-         * Remember wide byte which is used to form a 16-bit address in the following instruction. Relies on that the method is\n-         * called again with the following opcode.\n-         *\/\n-        case Const.WIDE:\n-            wide = true;\n-            buf.append(\"\\t(wide)\");\n-            break;\n-        \/*\n-         * Array of basic type.\n-         *\/\n-        case Const.NEWARRAY:\n-            buf.append(\"\\t\\t<\").append(Const.getTypeName(bytes.readByte())).append(\">\");\n-            break;\n-        \/*\n-         * Access object\/class fields.\n-         *\/\n-        case Const.GETFIELD:\n-        case Const.GETSTATIC:\n-        case Const.PUTFIELD:\n-        case Const.PUTSTATIC:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, Const.CONSTANT_Fieldref)).append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Operands are references to classes in constant pool\n-         *\/\n-        case Const.NEW:\n-        case Const.CHECKCAST:\n-            buf.append(\"\\t\");\n-            \/\/$FALL-THROUGH$\n-        case Const.INSTANCEOF:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t<\").append(constantPool.constantToString(index, Const.CONSTANT_Class)).append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Operands are references to methods in constant pool\n-         *\/\n-        case Const.INVOKESPECIAL:\n-        case Const.INVOKESTATIC:\n-            index = bytes.readUnsignedShort();\n-            final Constant c = constantPool.getConstant(index);\n-            \/\/ With Java8 operand may be either a CONSTANT_Methodref\n-            \/\/ or a CONSTANT_InterfaceMethodref. (markro)\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, c.getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        case Const.INVOKEVIRTUAL:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_Methodref)).append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        case Const.INVOKEINTERFACE:\n-            index = bytes.readUnsignedShort();\n-            final int nargs = bytes.readUnsignedByte(); \/\/ historical, redundant\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_InterfaceMethodref)).append(verbose ? \" (\" + index + \")\\t\" : \"\")\n-                .append(nargs).append(\"\\t\").append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n-            break;\n-        case Const.INVOKEDYNAMIC:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\").append(constantPool.constantToString(index, Const.CONSTANT_InvokeDynamic)).append(verbose ? \" (\" + index + \")\\t\" : \"\")\n-                .append(bytes.readUnsignedByte()) \/\/ Thrid byte is a reserved space\n-                .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n-            break;\n-        \/*\n-         * Operands are references to items in constant pool\n-         *\/\n-        case Const.LDC_W:\n-        case Const.LDC2_W:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        case Const.LDC:\n-            index = bytes.readUnsignedByte();\n-            buf.append(\"\\t\\t\").append(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Array of references.\n-         *\/\n-        case Const.ANEWARRAY:\n-            index = bytes.readUnsignedShort();\n-            buf.append(\"\\t\\t<\").append(compactClassName(constantPool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\")\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-            break;\n-        \/*\n-         * Multidimensional array of references.\n-         *\/\n-        case Const.MULTIANEWARRAY: {\n-            index = bytes.readUnsignedShort();\n-            final int dimensions = bytes.readUnsignedByte();\n-            buf.append(\"\\t<\").append(compactClassName(constantPool.getConstantString(index, Const.CONSTANT_Class), false)).append(\">\\t\").append(dimensions)\n-                .append(verbose ? \" (\" + index + \")\" : \"\");\n-        }\n-            break;\n-        \/*\n-         * Increment local variable.\n-         *\/\n-        case Const.IINC:\n-            if (wide) {\n-                vindex = bytes.readUnsignedShort();\n-                constant = bytes.readShort();\n-                wide = false;\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-                constant = bytes.readByte();\n+                break;\n+            \/* Two address bytes + offset from start of byte stream form the\n+             * jump target\n+             *\/\n+            case Const.GOTO:\n+            case Const.IFEQ:\n+            case Const.IFGE:\n+            case Const.IFGT:\n+            case Const.IFLE:\n+            case Const.IFLT:\n+            case Const.JSR:\n+            case Const.IFNE:\n+            case Const.IFNONNULL:\n+            case Const.IFNULL:\n+            case Const.IF_ACMPEQ:\n+            case Const.IF_ACMPNE:\n+            case Const.IF_ICMPEQ:\n+            case Const.IF_ICMPGE:\n+            case Const.IF_ICMPGT:\n+            case Const.IF_ICMPLE:\n+            case Const.IF_ICMPLT:\n+            case Const.IF_ICMPNE:\n+                buf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readShort());\n+                break;\n+            \/* 32-bit wide jumps\n+             *\/\n+            case Const.GOTO_W:\n+            case Const.JSR_W:\n+                buf.append(\"\\t\\t#\").append((bytes.getIndex() - 1) + bytes.readInt());\n+                break;\n+            \/* Index byte references local variable (register)\n+             *\/\n+            case Const.ALOAD:\n+            case Const.ASTORE:\n+            case Const.DLOAD:\n+            case Const.DSTORE:\n+            case Const.FLOAD:\n+            case Const.FSTORE:\n+            case Const.ILOAD:\n+            case Const.ISTORE:\n+            case Const.LLOAD:\n+            case Const.LSTORE:\n+            case Const.RET:\n+                if (wide) {\n+                    vindex = bytes.readUnsignedShort();\n+                    wide = false; \/\/ Clear flag\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                }\n+                buf.append(\"\\t\\t%\").append(vindex);\n+                break;\n+            \/*\n+             * Remember wide byte which is used to form a 16-bit address in the\n+             * following instruction. Relies on that the method is called again with\n+             * the following opcode.\n+             *\/\n+            case Const.WIDE:\n+                wide = true;\n+                buf.append(\"\\t(wide)\");\n+                break;\n+            \/* Array of basic type.\n+             *\/\n+            case Const.NEWARRAY:\n+                buf.append(\"\\t\\t<\").append(Const.getTypeName(bytes.readByte())).append(\">\");\n+                break;\n+            \/* Access object\/class fields.\n+             *\/\n+            case Const.GETFIELD:\n+            case Const.GETSTATIC:\n+            case Const.PUTFIELD:\n+            case Const.PUTSTATIC:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\\t\").append(\n+                        constant_pool.constantToString(index, Const.CONSTANT_Fieldref)).append(\n+                        verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Operands are references to classes in constant pool\n+             *\/\n+            case Const.NEW:\n+            case Const.CHECKCAST:\n+                buf.append(\"\\t\");\n+                \/\/$FALL-THROUGH$\n+            case Const.INSTANCEOF:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t<\").append(\n+                        constant_pool.constantToString(index, Const.CONSTANT_Class))\n+                        .append(\">\").append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Operands are references to methods in constant pool\n+             *\/\n+            case Const.INVOKESPECIAL:\n+            case Const.INVOKESTATIC:\n+                index = bytes.readUnsignedShort();\n+                final Constant c = constant_pool.getConstant(index);\n+                \/\/ With Java8 operand may be either a CONSTANT_Methodref\n+                \/\/ or a CONSTANT_InterfaceMethodref.   (markro)\n+                buf.append(\"\\t\").append(\n+                        constant_pool.constantToString(index, c.getTag()))\n+                        .append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            case Const.INVOKEVIRTUAL:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\").append(\n+                        constant_pool.constantToString(index, Const.CONSTANT_Methodref))\n+                        .append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            case Const.INVOKEINTERFACE:\n+                index = bytes.readUnsignedShort();\n+                final int nargs = bytes.readUnsignedByte(); \/\/ historical, redundant\n+                buf.append(\"\\t\").append(\n+                        constant_pool\n+                                .constantToString(index, Const.CONSTANT_InterfaceMethodref))\n+                        .append(verbose ? \" (\" + index + \")\\t\" : \"\").append(nargs).append(\"\\t\")\n+                        .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n+                break;\n+            case Const.INVOKEDYNAMIC:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\").append(\n+                        constant_pool\n+                                .constantToString(index, Const.CONSTANT_InvokeDynamic))\n+                        .append(verbose ? \" (\" + index + \")\\t\" : \"\")\n+                        .append(bytes.readUnsignedByte())  \/\/ Thrid byte is a reserved space\n+                        .append(bytes.readUnsignedByte()); \/\/ Last byte is a reserved space\n+                break;\n+            \/* Operands are references to items in constant pool\n+             *\/\n+            case Const.LDC_W:\n+            case Const.LDC2_W:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\\t\").append(\n+                        constant_pool.constantToString(index, constant_pool.getConstant(index)\n+                                .getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            case Const.LDC:\n+                index = bytes.readUnsignedByte();\n+                buf.append(\"\\t\\t\").append(\n+                        constant_pool.constantToString(index, constant_pool.getConstant(index)\n+                                .getTag())).append(verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Array of references.\n+             *\/\n+            case Const.ANEWARRAY:\n+                index = bytes.readUnsignedShort();\n+                buf.append(\"\\t\\t<\").append(\n+                        compactClassName(constant_pool.getConstantString(index,\n+                                Const.CONSTANT_Class), false)).append(\">\").append(\n+                        verbose ? \" (\" + index + \")\" : \"\");\n+                break;\n+            \/* Multidimensional array of references.\n+             *\/\n+            case Const.MULTIANEWARRAY: {\n+                index = bytes.readUnsignedShort();\n+                final int dimensions = bytes.readUnsignedByte();\n+                buf.append(\"\\t<\").append(\n+                        compactClassName(constant_pool.getConstantString(index,\n+                                Const.CONSTANT_Class), false)).append(\">\\t\").append(dimensions)\n+                        .append(verbose ? \" (\" + index + \")\" : \"\");\n@@ -516,18 +416,31 @@\n-            buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n-            break;\n-        default:\n-            if (Const.getNoOfOperands(opcode) > 0) {\n-                for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n-                    buf.append(\"\\t\\t\");\n-                    switch (Const.getOperandType(opcode, i)) {\n-                    case Const.T_BYTE:\n-                        buf.append(bytes.readByte());\n-                        break;\n-                    case Const.T_SHORT:\n-                        buf.append(bytes.readShort());\n-                        break;\n-                    case Const.T_INT:\n-                        buf.append(bytes.readInt());\n-                        break;\n-                    default: \/\/ Never reached\n-                        throw new IllegalStateException(\"Unreachable default case reached!\");\n+                break;\n+            \/* Increment local variable.\n+             *\/\n+            case Const.IINC:\n+                if (wide) {\n+                    vindex = bytes.readUnsignedShort();\n+                    constant = bytes.readShort();\n+                    wide = false;\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                    constant = bytes.readByte();\n+                }\n+                buf.append(\"\\t\\t%\").append(vindex).append(\"\\t\").append(constant);\n+                break;\n+            default:\n+                if (Const.getNoOfOperands(opcode) > 0) {\n+                    for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n+                        buf.append(\"\\t\\t\");\n+                        switch (Const.getOperandType(opcode, i)) {\n+                            case Const.T_BYTE:\n+                                buf.append(bytes.readByte());\n+                                break;\n+                            case Const.T_SHORT:\n+                                buf.append(bytes.readShort());\n+                                break;\n+                            case Const.T_INT:\n+                                buf.append(bytes.readInt());\n+                                break;\n+                            default: \/\/ Never reached\n+                                throw new IllegalStateException(\"Unreachable default case reached!\");\n+                        }\n@@ -536,1 +449,0 @@\n-            }\n@@ -541,0 +453,7 @@\n+\n+    public static String codeToString( final ByteSequence bytes, final ConstantPool constant_pool )\n+            throws IOException {\n+        return codeToString(bytes, constant_pool, true);\n+    }\n+\n+\n@@ -542,1 +461,2 @@\n-     * Shorten long class names, <em>java\/lang\/String<\/em> becomes <em>String<\/em>.\n+     * Shorten long class names, <em>java\/lang\/String<\/em> becomes\n+     * <em>String<\/em>.\n@@ -547,1 +467,1 @@\n-    public static String compactClassName(final String str) {\n+    public static String compactClassName( final String str ) {\n@@ -551,0 +471,1 @@\n+\n@@ -552,2 +473,4 @@\n-     * Shorten long class names, <em>java\/lang\/String<\/em> becomes <em>java.lang.String<\/em>, e.g.. If <em>chopit<\/em> is\n-     * <em>true<\/em> the prefix <em>java.lang<\/em> is also removed.\n+     * Shorten long class names, <em>java\/lang\/String<\/em> becomes\n+     * <em>java.lang.String<\/em>,\n+     * e.g.. If <em>chopit<\/em> is <em>true<\/em> the prefix <em>java.lang<\/em>\n+     * is also removed.\n@@ -559,1 +482,1 @@\n-    public static String compactClassName(final String str, final boolean chopit) {\n+    public static String compactClassName( final String str, final boolean chopit ) {\n@@ -563,0 +486,1 @@\n+\n@@ -564,2 +488,4 @@\n-     * Shorten long class name <em>str<\/em>, i.e., chop off the <em>prefix<\/em>, if the class name starts with this string\n-     * and the flag <em>chopit<\/em> is true. Slashes <em>\/<\/em> are converted to dots <em>.<\/em>.\n+     * Shorten long class name <em>str<\/em>, i.e., chop off the <em>prefix<\/em>,\n+     * if the\n+     * class name starts with this string and the flag <em>chopit<\/em> is true.\n+     * Slashes <em>\/<\/em> are converted to dots <em>.<\/em>.\n@@ -572,1 +498,1 @@\n-    public static String compactClassName(String str, final String prefix, final boolean chopit) {\n+    public static String compactClassName( String str, final String prefix, final boolean chopit ) {\n@@ -574,4 +500,6 @@\n-        str = pathToPackage(str); \/\/ Is '\/' on all systems, even DOS\n-        \/\/ If string starts with 'prefix' and contains no further dots\n-        if (chopit && str.startsWith(prefix) && str.substring(len).indexOf('.') == -1) {\n-            str = str.substring(len);\n+        str = str.replace('\/', '.'); \/\/ Is `\/' on all systems, even DOS\n+        if (chopit) {\n+            \/\/ If string starts with `prefix' and contains no further dots\n+            if (str.startsWith(prefix) && (str.substring(len).indexOf('.') == -1)) {\n+                str = str.substring(len);\n+            }\n@@ -582,0 +510,1 @@\n+\n@@ -583,1 +512,1 @@\n-     * Escape all occurrences of newline chars '\\n', quotes \\\", etc.\n+     * @return `flag' with bit `i' set to 1\n@@ -585,26 +514,2 @@\n-    public static String convertString(final String label) {\n-        final char[] ch = label.toCharArray();\n-        final StringBuilder buf = new StringBuilder();\n-        for (final char element : ch) {\n-            switch (element) {\n-            case '\\n':\n-                buf.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                buf.append(\"\\\\r\");\n-                break;\n-            case '\\\"':\n-                buf.append(\"\\\\\\\"\");\n-                break;\n-            case '\\'':\n-                buf.append(\"\\\\'\");\n-                break;\n-            case '\\\\':\n-                buf.append(\"\\\\\\\\\");\n-                break;\n-            default:\n-                buf.append(element);\n-                break;\n-            }\n-        }\n-        return buf.toString();\n+    public static int setBit( final int flag, final int i ) {\n+        return flag | pow2(i);\n@@ -613,28 +518,7 @@\n-    private static int countBrackets(final String brackets) {\n-        final char[] chars = brackets.toCharArray();\n-        int count = 0;\n-        boolean open = false;\n-        for (final char c : chars) {\n-            switch (c) {\n-            case '[':\n-                if (open) {\n-                    throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-                }\n-                open = true;\n-                break;\n-            case ']':\n-                if (!open) {\n-                    throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-                }\n-                open = false;\n-                count++;\n-                break;\n-            default:\n-                \/\/ Don't care\n-                break;\n-            }\n-        }\n-        if (open) {\n-            throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n-        }\n-        return count;\n+\n+    \/**\n+     * @return `flag' with bit `i' set to 0\n+     *\/\n+    public static int clearBit( final int flag, final int i ) {\n+        final int bit = pow2(i);\n+        return (flag & bit) == 0 ? flag : flag ^ bit;\n@@ -643,0 +527,1 @@\n+\n@@ -644,1 +529,10 @@\n-     * Decode a string back to a byte array.\n+     * @return true, if bit `i' in `flag' is set\n+     *\/\n+    public static boolean isSet( final int flag, final int i ) {\n+        return (flag & pow2(i)) != 0;\n+    }\n+\n+\n+    \/**\n+     * Converts string containing the method return and argument types\n+     * to a byte code method signature.\n@@ -646,2 +540,3 @@\n-     * @param s the string to convert\n-     * @param uncompress use gzip to uncompress the stream of bytes\n+     * @param  ret Return type of method\n+     * @param  argv Types of method arguments\n+     * @return Byte code representation of method signature\n@@ -649,1 +544,1 @@\n-     * @throws IOException if there's a gzip exception\n+     * @throws ClassFormatException if the signature is for Void\n@@ -651,16 +546,11 @@\n-    public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n-        byte[] bytes;\n-        try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray())); ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n-            int ch;\n-            while ((ch = jr.read()) >= 0) {\n-                bos.write(ch);\n-            }\n-            bytes = bos.toByteArray();\n-        }\n-        if (uncompress) {\n-            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n-            final byte[] tmp = new byte[bytes.length * 3]; \/\/ Rough estimate\n-            int count = 0;\n-            int b;\n-            while ((b = gis.read()) >= 0) {\n-                tmp[count++] = (byte) b;\n+    public static String methodTypeToSignature( final String ret, final String[] argv )\n+            throws ClassFormatException {\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        String str;\n+        if (argv != null) {\n+            for (final String element : argv) {\n+                str = getSignature(element);\n+                if (str.endsWith(\"V\")) {\n+                    throw new ClassFormatException(\"Invalid type: \" + element);\n+                }\n+                buf.append(str);\n@@ -668,1 +558,0 @@\n-            bytes = Arrays.copyOf(tmp, count);\n@@ -670,1 +559,3 @@\n-        return bytes;\n+        str = getSignature(ret);\n+        buf.append(\")\").append(str);\n+        return buf.toString();\n@@ -673,0 +564,1 @@\n+\n@@ -674,15 +566,1 @@\n-     * Encode byte array it into Java identifier string, i.e., a string that only contains the following characters: (a, ...\n-     * z, A, ... Z, 0, ... 9, _, $). The encoding algorithm itself is not too clever: if the current byte's ASCII value\n-     * already is a valid Java identifier part, leave it as it is. Otherwise it writes the escape character($) followed by:\n-     *\n-     * <ul>\n-     * <li>the ASCII value as a hexadecimal string, if the value is not in the range 200..247<\/li>\n-     * <li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247<\/li>\n-     * <\/ul>\n-     *\n-     * <p>\n-     * This operation inflates the original byte array by roughly 40-50%\n-     * <\/p>\n-     *\n-     * @param bytes the byte array to convert\n-     * @param compress use gzip to minimize string\n+     * Converts argument list portion of method signature to string with all class names compacted.\n@@ -690,1 +568,3 @@\n-     * @throws IOException if there's a gzip exception\n+     * @param  signature    Method signature\n+     * @return String Array of argument types\n+     * @throws ClassFormatException\n@@ -692,157 +572,2 @@\n-    public static String encode(byte[] bytes, final boolean compress) throws IOException {\n-        if (compress) {\n-            try (ByteArrayOutputStream baos = new ByteArrayOutputStream(); GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n-                gos.write(bytes, 0, bytes.length);\n-                gos.finish();\n-                bytes = baos.toByteArray();\n-            }\n-        }\n-        final CharArrayWriter caw = new CharArrayWriter();\n-        try (JavaWriter jw = new JavaWriter(caw)) {\n-            for (final byte b : bytes) {\n-                final int in = b & 0x000000ff; \/\/ Normalize to unsigned\n-                jw.write(in);\n-            }\n-        }\n-        return caw.toString();\n-    }\n-\n-    \/**\n-     * Fillup char with up to length characters with char 'fill' and justify it left or right.\n-     *\n-     * @param str string to format\n-     * @param length length of desired string\n-     * @param leftJustify format left or right\n-     * @param fill fill character\n-     * @return formatted string\n-     *\/\n-    public static String fillup(final String str, final int length, final boolean leftJustify, final char fill) {\n-        final int len = length - str.length();\n-        final char[] buf = new char[Math.max(len, 0)];\n-        Arrays.fill(buf, fill);\n-        if (leftJustify) {\n-            return str + new String(buf);\n-        }\n-        return new String(buf) + str;\n-    }\n-\n-    \/**\n-     * Return a string for an integer justified left or right and filled up with 'fill' characters if necessary.\n-     *\n-     * @param i integer to format\n-     * @param length length of desired string\n-     * @param leftJustify format left or right\n-     * @param fill fill character\n-     * @return formatted int\n-     *\/\n-    public static String format(final int i, final int length, final boolean leftJustify, final char fill) {\n-        return fillup(Integer.toString(i), length, leftJustify, fill);\n-    }\n-\n-    \/**\n-     * WARNING:\n-     *\n-     * There is some nomenclature confusion through much of the BCEL code base with respect to the terms Descriptor and\n-     * Signature. For the offical definitions see:\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3\"> Descriptors in The Java\n-     *      Virtual Machine Specification<\/a>\n-     *\n-     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.9.1\"> Signatures in The Java\n-     *      Virtual Machine Specification<\/a>\n-     *\n-     *      In brief, a descriptor is a string representing the type of a field or method. Signatures are similar, but more\n-     *      complex. Signatures are used to encode declarations written in the Java programming language that use types\n-     *      outside the type system of the Java Virtual Machine. They are used to describe the type of any class, interface,\n-     *      constructor, method or field whose declaration uses type variables or parameterized types.\n-     *\n-     *      To parse a descriptor, call typeSignatureToString. To parse a signature, call signatureToString.\n-     *\n-     *      Note that if the signature string is a single, non-generic item, the call to signatureToString reduces to a call\n-     *      to typeSignatureToString. Also note, that if you only wish to parse the first item in a longer signature string,\n-     *      you should call typeSignatureToString directly.\n-     *\/\n-\n-    \/**\n-     * Parse Java type such as \"char\", or \"java.lang.String[]\" and return the signature in byte code format, e.g. \"C\" or\n-     * \"[Ljava\/lang\/String;\" respectively.\n-     *\n-     * @param type Java type\n-     * @return byte code signature\n-     *\/\n-    public static String getSignature(String type) {\n-        final StringBuilder buf = new StringBuilder();\n-        final char[] chars = type.toCharArray();\n-        boolean charFound = false;\n-        boolean delim = false;\n-        int index = -1;\n-        loop: for (int i = 0; i < chars.length; i++) {\n-            switch (chars[i]) {\n-            case ' ':\n-            case '\\t':\n-            case '\\n':\n-            case '\\r':\n-            case '\\f':\n-                if (charFound) {\n-                    delim = true;\n-                }\n-                break;\n-            case '[':\n-                if (!charFound) {\n-                    throw new IllegalArgumentException(\"Illegal type: \" + type);\n-                }\n-                index = i;\n-                break loop;\n-            default:\n-                charFound = true;\n-                if (!delim) {\n-                    buf.append(chars[i]);\n-                }\n-            }\n-        }\n-        int brackets = 0;\n-        if (index > 0) {\n-            brackets = countBrackets(type.substring(index));\n-        }\n-        type = buf.toString();\n-        buf.setLength(0);\n-        for (int i = 0; i < brackets; i++) {\n-            buf.append('[');\n-        }\n-        boolean found = false;\n-        for (int i = Const.T_BOOLEAN; i <= Const.T_VOID && !found; i++) {\n-            if (Const.getTypeName(i).equals(type)) {\n-                found = true;\n-                buf.append(Const.getShortTypeName(i));\n-            }\n-        }\n-        if (!found) {\n-            buf.append('L').append(packageToPath(type)).append(';');\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * @param ch the character to test if it's part of an identifier\n-     *\n-     * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)\n-     *\/\n-    public static boolean isJavaIdentifierPart(final char ch) {\n-        return ch >= 'a' && ch <= 'z' || ch >= 'A' && ch <= 'Z' || ch >= '0' && ch <= '9' || ch == '_';\n-    }\n-\n-    \/**\n-     * @return true, if bit 'i' in 'flag' is set\n-     *\/\n-    public static boolean isSet(final int flag, final int i) {\n-        return (flag & pow2(i)) != 0;\n-    }\n-\n-    \/**\n-     * Converts argument list portion of method signature to string with all class names compacted.\n-     *\n-     * @param signature Method signature\n-     * @return String Array of argument types\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n-     *\/\n-    public static String[] methodSignatureArgumentTypes(final String signature) throws ClassFormatException {\n+    public static String[] methodSignatureArgumentTypes( final String signature )\n+            throws ClassFormatException {\n@@ -852,0 +577,1 @@\n+\n@@ -855,2 +581,2 @@\n-     * @param signature Method signature\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature    Method signature\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -858,1 +584,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -860,1 +586,2 @@\n-    public static String[] methodSignatureArgumentTypes(final String signature, final boolean chopit) throws ClassFormatException {\n+    public static String[] methodSignatureArgumentTypes( final String signature, final boolean chopit )\n+            throws ClassFormatException {\n@@ -864,1 +591,1 @@\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n@@ -871,2 +598,2 @@\n-                \/\/ corrected concurrent private static field acess\n-                index += unwrap(CONSUMER_CHARS); \/\/ update position\n+                \/\/corrected concurrent private static field acess\n+                index += unwrap(consumed_chars); \/\/ update position\n@@ -877,1 +604,1 @@\n-        return vec.toArray(Const.EMPTY_STRING_ARRAY);\n+        return vec.toArray(new String[vec.size()]);\n@@ -880,0 +607,1 @@\n+\n@@ -883,1 +611,1 @@\n-     * @param signature Method signature\n+     * @param  signature    Method signature\n@@ -885,1 +613,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -887,1 +615,1 @@\n-    public static String methodSignatureReturnType(final String signature) throws ClassFormatException {\n+    public static String methodSignatureReturnType( final String signature ) throws ClassFormatException {\n@@ -891,0 +619,1 @@\n+\n@@ -894,2 +623,2 @@\n-     * @param signature Method signature\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature    Method signature\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -897,1 +626,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -899,1 +628,1 @@\n-    public static String methodSignatureReturnType(final String signature, final boolean chopit) throws ClassFormatException {\n+    public static String methodSignatureReturnType( final String signature, final boolean chopit ) throws ClassFormatException {\n@@ -903,1 +632,1 @@\n-            \/\/ Read return type after ')'\n+            \/\/ Read return type after `)'\n@@ -915,0 +644,1 @@\n+\n@@ -918,3 +648,3 @@\n-     * @param signature to convert\n-     * @param name of method\n-     * @param access flags of method\n+     * @param  signature to convert\n+     * @param  name of method\n+     * @param  access flags of method\n@@ -923,1 +653,1 @@\n-    public static String methodSignatureToString(final String signature, final String name, final String access) {\n+    public static String methodSignatureToString( final String signature, final String name, final String access ) {\n@@ -927,0 +657,1 @@\n+\n@@ -930,4 +661,4 @@\n-     * @param signature to convert\n-     * @param name of method\n-     * @param access flags of method\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature to convert\n+     * @param  name of method\n+     * @param  access flags of method\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -936,1 +667,1 @@\n-    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit) {\n+    public static String methodSignatureToString( final String signature, final String name, final String access, final boolean chopit ) {\n@@ -940,0 +671,1 @@\n+\n@@ -941,2 +673,3 @@\n-     * This method converts a method signature string into a Java type declaration like 'void main(String[])' and throws a\n-     * 'ClassFormatException' when the parsed type is invalid.\n+     * This method converts a method signature string into a Java type declaration like\n+     * `void main(String[])' and throws a `ClassFormatException' when the parsed\n+     * type is invalid.\n@@ -944,5 +677,5 @@\n-     * @param signature Method signature\n-     * @param name Method name\n-     * @param access Method access rights\n-     * @param chopit flag that determines whether chopping is executed or not\n-     * @param vars the LocalVariableTable for the method\n+     * @param  signature    Method signature\n+     * @param  name         Method name\n+     * @param  access       Method access rights\n+     * @param  chopit flag that determines whether chopping is executed or not\n+     * @param  vars the LocalVariableTable for the method\n@@ -950,1 +683,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -952,2 +685,2 @@\n-    public static String methodSignatureToString(final String signature, final String name, final String access, final boolean chopit,\n-        final LocalVariableTable vars) throws ClassFormatException {\n+    public static String methodSignatureToString( final String signature, final String name,\n+            final String access, final boolean chopit, final LocalVariableTable vars ) throws ClassFormatException {\n@@ -957,1 +690,1 @@\n-        int varIndex = access.contains(\"static\") ? 0 : 1;\n+        int var_index = access.contains(\"static\") ? 0 : 1;\n@@ -959,1 +692,1 @@\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n@@ -965,2 +698,2 @@\n-                final String paramType = typeSignatureToString(signature.substring(index), chopit);\n-                buf.append(paramType);\n+                final String param_type = typeSignatureToString(signature.substring(index), chopit);\n+                buf.append(param_type);\n@@ -968,1 +701,1 @@\n-                    final LocalVariable l = vars.getLocalVariable(varIndex, 0);\n+                    final LocalVariable l = vars.getLocalVariable(var_index, 0);\n@@ -973,1 +706,1 @@\n-                    buf.append(\" arg\").append(varIndex);\n+                    buf.append(\" arg\").append(var_index);\n@@ -975,2 +708,2 @@\n-                if (\"double\".equals(paramType) || \"long\".equals(paramType)) {\n-                    varIndex += 2;\n+                if (\"double\".equals(param_type) || \"long\".equals(param_type)) {\n+                    var_index += 2;\n@@ -978,1 +711,1 @@\n-                    varIndex++;\n+                    var_index++;\n@@ -981,2 +714,2 @@\n-                \/\/ corrected concurrent private static field acess\n-                index += unwrap(CONSUMER_CHARS); \/\/ update position\n+                \/\/corrected concurrent private static field acess\n+                index += unwrap(consumed_chars); \/\/ update position\n@@ -985,1 +718,1 @@\n-            \/\/ Read return type after ')'\n+            \/\/ Read return type after `)'\n@@ -995,39 +728,2 @@\n-        return access + (!access.isEmpty() ? \" \" : \"\") + \/\/ May be an empty string\n-            type + \" \" + name + buf.toString();\n-    }\n-\n-    \/**\n-     * Converts string containing the method return and argument types to a byte code method signature.\n-     *\n-     * @param ret Return type of method\n-     * @param argv Types of method arguments\n-     * @return Byte code representation of method signature\n-     *\n-     * @throws ClassFormatException if the signature is for Void\n-     *\/\n-    public static String methodTypeToSignature(final String ret, final String[] argv) throws ClassFormatException {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        String str;\n-        if (argv != null) {\n-            for (final String element : argv) {\n-                str = getSignature(element);\n-                if (str.endsWith(\"V\")) {\n-                    throw new ClassFormatException(\"Invalid type: \" + element);\n-                }\n-                buf.append(str);\n-            }\n-        }\n-        str = getSignature(ret);\n-        buf.append(\")\").append(str);\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Converts '.'s to '\/'s.\n-     *\n-     * @param name Source\n-     * @return converted value\n-     * @since 6.7.0\n-     *\/\n-    public static String packageToPath(final String name) {\n-        return name.replace('.', '\/');\n+        return access + ((access.length() > 0) ? \" \" : \"\") + \/\/ May be an empty string\n+                type + \" \" + name + buf.toString();\n@@ -1036,10 +732,0 @@\n-    \/**\n-     * Converts a path to a package name.\n-     *\n-     * @param str the source path.\n-     * @return a package name.\n-     * @since 6.6.0\n-     *\/\n-    public static String pathToPackage(final String str) {\n-        return str.replace('\/', '.');\n-    }\n@@ -1047,1 +733,1 @@\n-    private static int pow2(final int n) {\n+    private static int pow2( final int n ) {\n@@ -1051,39 +737,0 @@\n-    public static String printArray(final Object[] obj) {\n-        return printArray(obj, true);\n-    }\n-\n-    public static String printArray(final Object[] obj, final boolean braces) {\n-        return printArray(obj, braces, false);\n-    }\n-\n-    public static String printArray(final Object[] obj, final boolean braces, final boolean quote) {\n-        if (obj == null) {\n-            return null;\n-        }\n-        final StringBuilder buf = new StringBuilder();\n-        if (braces) {\n-            buf.append('{');\n-        }\n-        for (int i = 0; i < obj.length; i++) {\n-            if (obj[i] != null) {\n-                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n-            } else {\n-                buf.append(\"null\");\n-            }\n-            if (i < obj.length - 1) {\n-                buf.append(\", \");\n-            }\n-        }\n-        if (braces) {\n-            buf.append('}');\n-        }\n-        return buf.toString();\n-    }\n-\n-    public static void printArray(final PrintStream out, final Object[] obj) {\n-        out.println(printArray(obj, true));\n-    }\n-\n-    public static void printArray(final PrintWriter out, final Object[] obj) {\n-        out.println(printArray(obj, true));\n-    }\n@@ -1099,1 +746,1 @@\n-    public static String replace(String str, final String old, final String new_) {\n+    public static String replace( String str, final String old, final String new_ ) {\n@@ -1101,1 +748,1 @@\n-        int oldIndex;\n+        int old_index;\n@@ -1103,1 +750,1 @@\n-            if (str.contains(old)) { \/\/ 'old' found in str\n+            if (str.contains(old)) { \/\/ `old' found in str\n@@ -1105,1 +752,1 @@\n-                oldIndex = 0; \/\/ String start offset\n+                old_index = 0; \/\/ String start offset\n@@ -1107,2 +754,2 @@\n-                while ((index = str.indexOf(old, oldIndex)) != -1) {\n-                    buf.append(str, oldIndex, index); \/\/ append prefix\n+                while ((index = str.indexOf(old, old_index)) != -1) {\n+                    buf.append(str.substring(old_index, index)); \/\/ append prefix\n@@ -1110,1 +757,1 @@\n-                    oldIndex = index + old.length(); \/\/ Skip 'old'.length chars\n+                    old_index = index + old.length(); \/\/ Skip `old'.length chars\n@@ -1112,1 +759,1 @@\n-                buf.append(str.substring(oldIndex)); \/\/ append rest of string\n+                buf.append(str.substring(old_index)); \/\/ append rest of string\n@@ -1121,12 +768,0 @@\n-    \/**\n-     * Map opcode names to opcode numbers. E.g., return Constants.ALOAD for \"aload\"\n-     *\/\n-    public static short searchOpcode(String name) {\n-        name = name.toLowerCase(Locale.ENGLISH);\n-        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; i++) {\n-            if (Const.getOpcodeName(i).equals(name)) {\n-                return i;\n-            }\n-        }\n-        return -1;\n-    }\n@@ -1135,1 +770,24 @@\n-     * @return 'flag' with bit 'i' set to 1\n+     * WARNING:\n+     *\n+     * There is some nomenclature confusion through much of the BCEL code base with\n+     * respect to the terms Descriptor and Signature.  For the offical definitions see:\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.3\">\n+     * Descriptors in The Java Virtual Machine Specification<\/a>\n+     *\n+     * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-4.html#jvms-4.7.9.1\">\n+     * Signatures in The Java Virtual Machine Specification<\/a>\n+     *\n+     * In brief, a descriptor is a string representing the type of a field or method.\n+     * Signatures are similar, but more complex.  Signatures are used to encode declarations\n+     * written in the Java programming language that use types outside the type system of the\n+     * Java Virtual Machine.  They are used to describe the type of any class, interface,\n+     * constructor, method or field whose declaration uses type variables or parameterized types.\n+     *\n+     * To parse a descriptor, call typeSignatureToString.\n+     * To parse a signature, call signatureToString.\n+     *\n+     * Note that if the signature string is a single, non-generic item, the call to\n+     * signatureToString reduces to a call to typeSignatureToString.\n+     * Also note, that if you only wish to parse the first item in a longer signature\n+     * string, you should call typeSignatureToString directly.\n@@ -1137,3 +795,1 @@\n-    public static int setBit(final int flag, final int i) {\n-        return flag | pow2(i);\n-    }\n+\n@@ -1142,1 +798,2 @@\n-     * Converts a signature to a string with all class names compacted. Class, Method and Type signatures are supported.\n+     * Converts a signature to a string with all class names compacted.\n+     * Class, Method and Type signatures are supported.\n@@ -1145,1 +802,1 @@\n-     * @param signature signature to convert\n+     * @param  signature signature to convert\n@@ -1148,1 +805,1 @@\n-    public static String signatureToString(final String signature) {\n+    public static String signatureToString( final String signature ) {\n@@ -1152,0 +809,1 @@\n+\n@@ -1153,2 +811,3 @@\n-     * Converts a signature to a string. Class, Method and Type signatures are supported. Enum and Interface signatures are\n-     * not supported.\n+     * Converts a signature to a string.\n+     * Class, Method and Type signatures are supported.\n+     * Enum and Interface signatures are not supported.\n@@ -1156,2 +815,2 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1160,1 +819,1 @@\n-    public static String signatureToString(final String signature, final boolean chopit) {\n+    public static String signatureToString( final String signature, final boolean chopit ) {\n@@ -1167,1 +826,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1173,1 +832,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1176,1 +835,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1182,2 +841,2 @@\n-        index += unwrap(CONSUMER_CHARS); \/\/ update position\n-        if (typeParams.isEmpty() && index == signature.length()) {\n+        index += unwrap(consumed_chars); \/\/ update position\n+        if ((typeParams.length() == 0) && (index == signature.length())) {\n@@ -1194,1 +853,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1199,1 +858,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1204,91 +863,0 @@\n-    \/**\n-     * Convert bytes into hexadecimal string\n-     *\n-     * @param bytes an array of bytes to convert to hexadecimal\n-     *\n-     * @return bytes as hexadecimal string, e.g. 00 fa 12 ...\n-     *\/\n-    public static String toHexString(final byte[] bytes) {\n-        final StringBuilder buf = new StringBuilder();\n-        for (int i = 0; i < bytes.length; i++) {\n-            final short b = byteToShort(bytes[i]);\n-            final String hex = Integer.toHexString(b);\n-            if (b < 0x10) {\n-                buf.append('0');\n-            }\n-            buf.append(hex);\n-            if (i < bytes.length - 1) {\n-                buf.append(' ');\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Return type of method signature as a byte value as defined in <em>Constants<\/em>\n-     *\n-     * @param signature in format described above\n-     * @return type of method signature\n-     * @see Const\n-     *\n-     * @throws ClassFormatException if signature is not a method signature\n-     *\/\n-    public static byte typeOfMethodSignature(final String signature) throws ClassFormatException {\n-        int index;\n-        try {\n-            if (signature.charAt(0) != '(') {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            index = signature.lastIndexOf(')') + 1;\n-            return typeOfSignature(signature.substring(index));\n-        } catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n-        }\n-    }\n-\n-    \/**\n-     * Return type of signature as a byte value as defined in <em>Constants<\/em>\n-     *\n-     * @param signature in format described above\n-     * @return type of signature\n-     * @see Const\n-     *\n-     * @throws ClassFormatException if signature isn't a known type\n-     *\/\n-    public static byte typeOfSignature(final String signature) throws ClassFormatException {\n-        try {\n-            switch (signature.charAt(0)) {\n-            case 'B':\n-                return Const.T_BYTE;\n-            case 'C':\n-                return Const.T_CHAR;\n-            case 'D':\n-                return Const.T_DOUBLE;\n-            case 'F':\n-                return Const.T_FLOAT;\n-            case 'I':\n-                return Const.T_INT;\n-            case 'J':\n-                return Const.T_LONG;\n-            case 'L':\n-            case 'T':\n-                return Const.T_REFERENCE;\n-            case '[':\n-                return Const.T_ARRAY;\n-            case 'V':\n-                return Const.T_VOID;\n-            case 'Z':\n-                return Const.T_BOOLEAN;\n-            case 'S':\n-                return Const.T_SHORT;\n-            case '!':\n-            case '+':\n-            case '*':\n-                return typeOfSignature(signature.substring(1));\n-            default:\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) {\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n-        }\n-    }\n@@ -1299,2 +867,2 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1303,1 +871,1 @@\n-    private static String typeParamTypesToString(final String signature, final boolean chopit) {\n+    private static String typeParamTypesToString( final String signature, final boolean chopit ) {\n@@ -1306,1 +874,1 @@\n-        int index = 1; \/\/ skip the '<'\n+        int index = 1;  \/\/ skip the '<'\n@@ -1309,1 +877,1 @@\n-        index += unwrap(CONSUMER_CHARS); \/\/ update position\n+        index += unwrap(consumed_chars); \/\/ update position\n@@ -1314,1 +882,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1316,1 +884,1 @@\n-        wrap(CONSUMER_CHARS, index + 1); \/\/ account for the '>' char\n+        wrap(consumed_chars, index + 1); \/\/ account for the '>' char\n@@ -1320,0 +888,1 @@\n+\n@@ -1323,2 +892,2 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1327,1 +896,1 @@\n-    private static String typeParamTypeToString(final String signature, final boolean chopit) {\n+    private static String typeParamTypeToString( final String signature, final boolean chopit ) {\n@@ -1334,1 +903,1 @@\n-        index++; \/\/ account for the ':'\n+        index++;  \/\/ account for the ':'\n@@ -1339,1 +908,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1343,1 +912,1 @@\n-            index++; \/\/ skip over the ':'\n+            index++;  \/\/ skip over the ':'\n@@ -1346,1 +915,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1348,1 +917,1 @@\n-        wrap(CONSUMER_CHARS, index);\n+        wrap(consumed_chars, index);\n@@ -1352,0 +921,1 @@\n+\n@@ -1355,3 +925,3 @@\n-     * @param signature signature to convert\n-     * @param chopit flag that determines whether chopping is executed or not\n-     * @param term character indicating the end of the list\n+     * @param  signature signature to convert\n+     * @param  chopit flag that determines whether chopping is executed or not\n+     * @param  term character indicating the end of the list\n@@ -1360,1 +930,1 @@\n-    private static String typeSignaturesToString(final String signature, final boolean chopit, final char term) {\n+    private static String typeSignaturesToString( final String signature, final boolean chopit, final char term ) {\n@@ -1363,1 +933,1 @@\n-        int index = 1; \/\/ skip the 'open' character\n+        int index = 1;  \/\/ skip the 'open' character\n@@ -1367,1 +937,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1373,1 +943,1 @@\n-            index += unwrap(CONSUMER_CHARS); \/\/ update position\n+            index += unwrap(consumed_chars); \/\/ update position\n@@ -1375,1 +945,1 @@\n-        wrap(CONSUMER_CHARS, index + 1); \/\/ account for the term char\n+        wrap(consumed_chars, index + 1); \/\/ account for the term char\n@@ -1379,0 +949,1 @@\n+\n@@ -1381,2 +952,2 @@\n-     * This method converts a type signature string into a Java type declaration such as 'String[]' and throws a\n-     * 'ClassFormatException' when the parsed type is invalid.\n+     * This method converts a type signature string into a Java type declaration such as\n+     * `String[]' and throws a `ClassFormatException' when the parsed type is invalid.\n@@ -1384,2 +955,2 @@\n-     * @param signature type signature\n-     * @param chopit flag that determines whether chopping is executed or not\n+     * @param  signature type signature\n+     * @param  chopit flag that determines whether chopping is executed or not\n@@ -1387,1 +958,1 @@\n-     * @throws ClassFormatException if a class is malformed or cannot be interpreted as a class file\n+     * @throws ClassFormatException\n@@ -1390,3 +961,3 @@\n-    public static String typeSignatureToString(final String signature, final boolean chopit) throws ClassFormatException {\n-        \/\/ corrected concurrent private static field acess\n-        wrap(CONSUMER_CHARS, 1); \/\/ This is the default, read just one char like 'B'\n+    public static String typeSignatureToString( final String signature, final boolean chopit ) throws ClassFormatException {\n+        \/\/corrected concurrent private static field acess\n+        wrap(consumed_chars, 1); \/\/ This is the default, read just one char like `B'\n@@ -1395,16 +966,20 @@\n-            case 'B':\n-                return \"byte\";\n-            case 'C':\n-                return \"char\";\n-            case 'D':\n-                return \"double\";\n-            case 'F':\n-                return \"float\";\n-            case 'I':\n-                return \"int\";\n-            case 'J':\n-                return \"long\";\n-            case 'T': { \/\/ TypeVariableSignature\n-                final int index = signature.indexOf(';'); \/\/ Look for closing ';'\n-                if (index < 0) {\n-                    throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n+                case 'B':\n+                    return \"byte\";\n+                case 'C':\n+                    return \"char\";\n+                case 'D':\n+                    return \"double\";\n+                case 'F':\n+                    return \"float\";\n+                case 'I':\n+                    return \"int\";\n+                case 'J':\n+                    return \"long\";\n+                case 'T': { \/\/ TypeVariableSignature\n+                    final int index = signature.indexOf(';'); \/\/ Look for closing `;'\n+                    if (index < 0) {\n+                        throw new ClassFormatException(\"Invalid type variable signature: \" + signature);\n+                    }\n+                    \/\/corrected concurrent private static field acess\n+                    wrap(consumed_chars, index + 1); \/\/ \"Tblabla;\" `T' and `;' are removed\n+                    return compactClassName(signature.substring(1, index), chopit);\n@@ -1412,12 +987,4 @@\n-                \/\/ corrected concurrent private static field acess\n-                wrap(CONSUMER_CHARS, index + 1); \/\/ \"Tblabla;\" 'T' and ';' are removed\n-                return compactClassName(signature.substring(1, index), chopit);\n-            }\n-            case 'L': { \/\/ Full class name\n-                \/\/ should this be a while loop? can there be more than\n-                \/\/ one generic clause? (markro)\n-                int fromIndex = signature.indexOf('<'); \/\/ generic type?\n-                if (fromIndex < 0) {\n-                    fromIndex = 0;\n-                } else {\n-                    fromIndex = signature.indexOf('>', fromIndex);\n+                case 'L': { \/\/ Full class name\n+                    \/\/ should this be a while loop? can there be more than\n+                    \/\/ one generic clause?  (markro)\n+                    int fromIndex = signature.indexOf('<'); \/\/ generic type?\n@@ -1425,0 +992,9 @@\n+                        fromIndex = 0;\n+                    } else {\n+                        fromIndex = signature.indexOf('>', fromIndex);\n+                        if (fromIndex < 0) {\n+                            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                        }\n+                    }\n+                    final int index = signature.indexOf(';', fromIndex); \/\/ Look for closing `;'\n+                    if (index < 0) {\n@@ -1427,23 +1003,0 @@\n-                }\n-                final int index = signature.indexOf(';', fromIndex); \/\/ Look for closing ';'\n-                if (index < 0) {\n-                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                }\n-\n-                \/\/ check to see if there are any TypeArguments\n-                final int bracketIndex = signature.substring(0, index).indexOf('<');\n-                if (bracketIndex < 0) {\n-                    \/\/ just a class identifier\n-                    wrap(CONSUMER_CHARS, index + 1); \/\/ \"Lblabla;\" 'L' and ';' are removed\n-                    return compactClassName(signature.substring(1, index), chopit);\n-                }\n-                \/\/ but make sure we are not looking past the end of the current item\n-                fromIndex = signature.indexOf(';');\n-                if (fromIndex < 0) {\n-                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n-                }\n-                if (fromIndex < bracketIndex) {\n-                    \/\/ just a class identifier\n-                    wrap(CONSUMER_CHARS, fromIndex + 1); \/\/ \"Lblabla;\" 'L' and ';' are removed\n-                    return compactClassName(signature.substring(1, fromIndex), chopit);\n-                }\n@@ -1451,13 +1004,17 @@\n-                \/\/ we have TypeArguments; build up partial result\n-                \/\/ as we recurse for each TypeArgument\n-                final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n-                int consumedChars = bracketIndex + 1; \/\/ Shadows global var\n-\n-                \/\/ check for wildcards\n-                if (signature.charAt(consumedChars) == '+') {\n-                    type.append(\"? extends \");\n-                    consumedChars++;\n-                } else if (signature.charAt(consumedChars) == '-') {\n-                    type.append(\"? super \");\n-                    consumedChars++;\n-                }\n+                    \/\/ check to see if there are any TypeArguments\n+                    final int bracketIndex = signature.substring(0, index).indexOf('<');\n+                    if (bracketIndex < 0) {\n+                        \/\/ just a class identifier\n+                        wrap(consumed_chars, index + 1); \/\/ \"Lblabla;\" `L' and `;' are removed\n+                        return compactClassName(signature.substring(1, index), chopit);\n+                    }\n+                    \/\/ but make sure we are not looking past the end of the current item\n+                    fromIndex = signature.indexOf(';');\n+                    if (fromIndex < 0) {\n+                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                    }\n+                    if (fromIndex < bracketIndex) {\n+                        \/\/ just a class identifier\n+                        wrap(consumed_chars, fromIndex + 1); \/\/ \"Lblabla;\" `L' and `;' are removed\n+                        return compactClassName(signature.substring(1, fromIndex), chopit);\n+                    }\n@@ -1465,10 +1022,4 @@\n-                \/\/ get the first TypeArgument\n-                if (signature.charAt(consumedChars) == '*') {\n-                    type.append(\"?\");\n-                    consumedChars++;\n-                } else {\n-                    type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n-                    \/\/ update our consumed count by the number of characters the for type argument\n-                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n-                }\n+                    \/\/ we have TypeArguments; build up partial result\n+                    \/\/ as we recurse for each TypeArgument\n+                    final StringBuilder type = new StringBuilder(compactClassName(signature.substring(1, bracketIndex), chopit)).append(\"<\");\n+                    int consumed_chars = bracketIndex + 1; \/\/ Shadows global var\n@@ -1476,3 +1027,0 @@\n-                \/\/ are there more TypeArguments?\n-                while (signature.charAt(consumedChars) != '>') {\n-                    type.append(\", \");\n@@ -1480,1 +1028,1 @@\n-                    if (signature.charAt(consumedChars) == '+') {\n+                    if (signature.charAt(consumed_chars) == '+') {\n@@ -1482,2 +1030,2 @@\n-                        consumedChars++;\n-                    } else if (signature.charAt(consumedChars) == '-') {\n+                        consumed_chars++;\n+                    } else if (signature.charAt(consumed_chars) == '-') {\n@@ -1485,1 +1033,1 @@\n-                        consumedChars++;\n+                        consumed_chars++;\n@@ -1487,1 +1035,3 @@\n-                    if (signature.charAt(consumedChars) == '*') {\n+\n+                    \/\/ get the first TypeArgument\n+                    if (signature.charAt(consumed_chars) == '*') {\n@@ -1489,1 +1039,1 @@\n-                        consumedChars++;\n+                        consumed_chars++;\n@@ -1491,1 +1041,1 @@\n-                        type.append(typeSignatureToString(signature.substring(consumedChars), chopit));\n+                        type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n@@ -1493,2 +1043,2 @@\n-                        consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                        wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n+                        wrap(Utility.consumed_chars, consumed_chars);\n@@ -1496,1 +1046,0 @@\n-                }\n@@ -1498,15 +1047,43 @@\n-                \/\/ process the closing \">\"\n-                consumedChars++;\n-                type.append(\">\");\n-\n-                if (signature.charAt(consumedChars) == '.') {\n-                    \/\/ we have a ClassTypeSignatureSuffix\n-                    type.append(\".\");\n-                    \/\/ convert SimpleClassTypeSignature to fake ClassTypeSignature\n-                    \/\/ and then recurse to parse it\n-                    type.append(typeSignatureToString(\"L\" + signature.substring(consumedChars + 1), chopit));\n-                    \/\/ update our consumed count by the number of characters the for type argument\n-                    \/\/ note that this count includes the \"L\" we added, but that is ok\n-                    \/\/ as it accounts for the \".\" we didn't consume\n-                    consumedChars = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                    wrap(Utility.CONSUMER_CHARS, consumedChars);\n+                    \/\/ are there more TypeArguments?\n+                    while (signature.charAt(consumed_chars) != '>') {\n+                        type.append(\", \");\n+                        \/\/ check for wildcards\n+                        if (signature.charAt(consumed_chars) == '+') {\n+                            type.append(\"? extends \");\n+                            consumed_chars++;\n+                        } else if (signature.charAt(consumed_chars) == '-') {\n+                            type.append(\"? super \");\n+                            consumed_chars++;\n+                        }\n+                        if (signature.charAt(consumed_chars) == '*') {\n+                            type.append(\"?\");\n+                            consumed_chars++;\n+                        } else {\n+                            type.append(typeSignatureToString(signature.substring(consumed_chars), chopit));\n+                            \/\/ update our consumed count by the number of characters the for type argument\n+                            consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n+                            wrap(Utility.consumed_chars, consumed_chars);\n+                        }\n+                    }\n+\n+                    \/\/ process the closing \">\"\n+                    consumed_chars++;\n+                    type.append(\">\");\n+\n+                    if (signature.charAt(consumed_chars) == '.') {\n+                        \/\/ we have a ClassTypeSignatureSuffix\n+                        type.append(\".\");\n+                        \/\/ convert SimpleClassTypeSignature to fake ClassTypeSignature\n+                        \/\/ and then recurse to parse it\n+                        type.append(typeSignatureToString(\"L\" + signature.substring(consumed_chars+1), chopit));\n+                        \/\/ update our consumed count by the number of characters the for type argument\n+                        \/\/ note that this count includes the \"L\" we added, but that is ok\n+                        \/\/ as it accounts for the \".\" we didn't consume\n+                        consumed_chars = unwrap(Utility.consumed_chars) + consumed_chars;\n+                        wrap(Utility.consumed_chars, consumed_chars);\n+                        return type.toString();\n+                    }\n+                    if (signature.charAt(consumed_chars) != ';') {\n+                        throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                    }\n+                    wrap(Utility.consumed_chars, consumed_chars + 1); \/\/ remove final \";\"\n@@ -1515,2 +1092,22 @@\n-                if (signature.charAt(consumedChars) != ';') {\n-                    throw new ClassFormatException(\"Invalid signature: \" + signature);\n+                case 'S':\n+                    return \"short\";\n+                case 'Z':\n+                    return \"boolean\";\n+                case '[': { \/\/ Array declaration\n+                    int n;\n+                    StringBuilder brackets;\n+                    String type;\n+                    int consumed_chars; \/\/ Shadows global var\n+                    brackets = new StringBuilder(); \/\/ Accumulate []'s\n+                    \/\/ Count opening brackets and look for optional size argument\n+                    for (n = 0; signature.charAt(n) == '['; n++) {\n+                        brackets.append(\"[]\");\n+                    }\n+                    consumed_chars = n; \/\/ Remember value\n+                    \/\/ The rest of the string denotes a `<field_type>'\n+                    type = typeSignatureToString(signature.substring(n), chopit);\n+                    \/\/corrected concurrent private static field acess\n+                    \/\/Utility.consumed_chars += consumed_chars; is replaced by:\n+                    final int _temp = unwrap(Utility.consumed_chars) + consumed_chars;\n+                    wrap(Utility.consumed_chars, _temp);\n+                    return type + brackets.toString();\n@@ -1518,2 +1115,211 @@\n-                wrap(Utility.CONSUMER_CHARS, consumedChars + 1); \/\/ remove final \";\"\n-                return type.toString();\n+                case 'V':\n+                    return \"void\";\n+                default:\n+                    throw new ClassFormatException(\"Invalid signature: `\" + signature + \"'\");\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid signature: \" + signature, e);\n+        }\n+    }\n+\n+\n+    \/** Parse Java type such as \"char\", or \"java.lang.String[]\" and return the\n+     * signature in byte code format, e.g. \"C\" or \"[Ljava\/lang\/String;\" respectively.\n+     *\n+     * @param  type Java type\n+     * @return byte code signature\n+     *\/\n+    public static String getSignature( String type ) {\n+        final StringBuilder buf = new StringBuilder();\n+        final char[] chars = type.toCharArray();\n+        boolean char_found = false;\n+        boolean delim = false;\n+        int index = -1;\n+        loop: for (int i = 0; i < chars.length; i++) {\n+            switch (chars[i]) {\n+                case ' ':\n+                case '\\t':\n+                case '\\n':\n+                case '\\r':\n+                case '\\f':\n+                    if (char_found) {\n+                        delim = true;\n+                    }\n+                    break;\n+                case '[':\n+                    if (!char_found) {\n+                        throw new IllegalArgumentException(\"Illegal type: \" + type);\n+                    }\n+                    index = i;\n+                    break loop;\n+                default:\n+                    char_found = true;\n+                    if (!delim) {\n+                        buf.append(chars[i]);\n+                    }\n+            }\n+        }\n+        int brackets = 0;\n+        if (index > 0) {\n+            brackets = countBrackets(type.substring(index));\n+        }\n+        type = buf.toString();\n+        buf.setLength(0);\n+        for (int i = 0; i < brackets; i++) {\n+            buf.append('[');\n+        }\n+        boolean found = false;\n+        for (int i = Const.T_BOOLEAN; (i <= Const.T_VOID) && !found; i++) {\n+            if (Const.getTypeName(i).equals(type)) {\n+                found = true;\n+                buf.append(Const.getShortTypeName(i));\n+            }\n+        }\n+        if (!found) {\n+            buf.append('L').append(type.replace('.', '\/')).append(';');\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    private static int countBrackets( final String brackets ) {\n+        final char[] chars = brackets.toCharArray();\n+        int count = 0;\n+        boolean open = false;\n+        for (final char c : chars) {\n+            switch (c) {\n+                case '[':\n+                    if (open) {\n+                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                    }\n+                    open = true;\n+                    break;\n+                case ']':\n+                    if (!open) {\n+                        throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+                    }\n+                    open = false;\n+                    count++;\n+                    break;\n+                default:\n+                    \/\/ Don't care\n+                    break;\n+            }\n+        }\n+        if (open) {\n+            throw new IllegalArgumentException(\"Illegally nested brackets:\" + brackets);\n+        }\n+        return count;\n+    }\n+\n+\n+    \/**\n+     * Return type of method signature as a byte value as defined in <em>Constants<\/em>\n+     *\n+     * @param  signature in format described above\n+     * @return type of method signature\n+     * @see    Const\n+     *\n+     * @throws ClassFormatException if signature is not a method signature\n+     *\/\n+    public static byte typeOfMethodSignature( final String signature ) throws ClassFormatException {\n+        int index;\n+        try {\n+            if (signature.charAt(0) != '(') {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            index = signature.lastIndexOf(')') + 1;\n+            return typeOfSignature(signature.substring(index));\n+        } catch (final StringIndexOutOfBoundsException e) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Return type of signature as a byte value as defined in <em>Constants<\/em>\n+     *\n+     * @param  signature in format described above\n+     * @return type of signature\n+     * @see    Const\n+     *\n+     * @throws ClassFormatException if signature isn't a known type\n+     *\/\n+    public static byte typeOfSignature( final String signature ) throws ClassFormatException {\n+        try {\n+            switch (signature.charAt(0)) {\n+                case 'B':\n+                    return Const.T_BYTE;\n+                case 'C':\n+                    return Const.T_CHAR;\n+                case 'D':\n+                    return Const.T_DOUBLE;\n+                case 'F':\n+                    return Const.T_FLOAT;\n+                case 'I':\n+                    return Const.T_INT;\n+                case 'J':\n+                    return Const.T_LONG;\n+                case 'L':\n+                case 'T':\n+                    return Const.T_REFERENCE;\n+                case '[':\n+                    return Const.T_ARRAY;\n+                case 'V':\n+                    return Const.T_VOID;\n+                case 'Z':\n+                    return Const.T_BOOLEAN;\n+                case 'S':\n+                    return Const.T_SHORT;\n+                case '!':\n+                case '+':\n+                case '*':\n+                    return typeOfSignature(signature.substring(1));\n+                default:\n+                    throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) {\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+        }\n+    }\n+\n+\n+    \/** Map opcode names to opcode numbers. E.g., return Constants.ALOAD for \"aload\"\n+     *\/\n+    public static short searchOpcode( String name ) {\n+        name = name.toLowerCase(Locale.ENGLISH);\n+        for (short i = 0; i < Const.OPCODE_NAMES_LENGTH; i++) {\n+            if (Const.getOpcodeName(i).equals(name)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n+\n+\n+    \/**\n+     * Convert (signed) byte to (unsigned) short value, i.e., all negative\n+     * values become positive.\n+     *\/\n+    private static short byteToShort( final byte b ) {\n+        return (b < 0) ? (short) (256 + b) : (short) b;\n+    }\n+\n+\n+    \/** Convert bytes into hexadecimal string\n+     *\n+     * @param bytes an array of bytes to convert to hexadecimal\n+     *\n+     * @return bytes as hexadecimal string, e.g. 00 fa 12 ...\n+     *\/\n+    public static String toHexString( final byte[] bytes ) {\n+        final StringBuilder buf = new StringBuilder();\n+        for (int i = 0; i < bytes.length; i++) {\n+            final short b = byteToShort(bytes[i]);\n+            final String hex = Integer.toHexString(b);\n+            if (b < 0x10) {\n+                buf.append('0');\n+            }\n+            buf.append(hex);\n+            if (i < bytes.length - 1) {\n+                buf.append(' ');\n@@ -1521,13 +1327,232 @@\n-            case 'S':\n-                return \"short\";\n-            case 'Z':\n-                return \"boolean\";\n-            case '[': { \/\/ Array declaration\n-                int n;\n-                StringBuilder brackets;\n-                String type;\n-                int consumedChars; \/\/ Shadows global var\n-                brackets = new StringBuilder(); \/\/ Accumulate []'s\n-                \/\/ Count opening brackets and look for optional size argument\n-                for (n = 0; signature.charAt(n) == '['; n++) {\n-                    brackets.append(\"[]\");\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * Return a string for an integer justified left or right and filled up with\n+     * `fill' characters if necessary.\n+     *\n+     * @param i integer to format\n+     * @param length length of desired string\n+     * @param left_justify format left or right\n+     * @param fill fill character\n+     * @return formatted int\n+     *\/\n+    public static String format( final int i, final int length, final boolean left_justify, final char fill ) {\n+        return fillup(Integer.toString(i), length, left_justify, fill);\n+    }\n+\n+\n+    \/**\n+     * Fillup char with up to length characters with char `fill' and justify it left or right.\n+     *\n+     * @param str string to format\n+     * @param length length of desired string\n+     * @param left_justify format left or right\n+     * @param fill fill character\n+     * @return formatted string\n+     *\/\n+    public static String fillup( final String str, final int length, final boolean left_justify, final char fill ) {\n+        final int len = length - str.length();\n+        final char[] buf = new char[(len < 0) ? 0 : len];\n+        for (int j = 0; j < buf.length; j++) {\n+            buf[j] = fill;\n+        }\n+        if (left_justify) {\n+            return str + new String(buf);\n+        }\n+        return new String(buf) + str;\n+    }\n+\n+\n+    static boolean equals( final byte[] a, final byte[] b ) {\n+        int size;\n+        if ((size = a.length) != b.length) {\n+            return false;\n+        }\n+        for (int i = 0; i < size; i++) {\n+            if (a[i] != b[i]) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+\n+    public static void printArray( final PrintStream out, final Object[] obj ) {\n+        out.println(printArray(obj, true));\n+    }\n+\n+\n+    public static void printArray( final PrintWriter out, final Object[] obj ) {\n+        out.println(printArray(obj, true));\n+    }\n+\n+\n+    public static String printArray( final Object[] obj ) {\n+        return printArray(obj, true);\n+    }\n+\n+\n+    public static String printArray( final Object[] obj, final boolean braces ) {\n+        return printArray(obj, braces, false);\n+    }\n+\n+\n+    public static String printArray( final Object[] obj, final boolean braces, final boolean quote ) {\n+        if (obj == null) {\n+            return null;\n+        }\n+        final StringBuilder buf = new StringBuilder();\n+        if (braces) {\n+            buf.append('{');\n+        }\n+        for (int i = 0; i < obj.length; i++) {\n+            if (obj[i] != null) {\n+                buf.append(quote ? \"\\\"\" : \"\").append(obj[i]).append(quote ? \"\\\"\" : \"\");\n+            } else {\n+                buf.append(\"null\");\n+            }\n+            if (i < obj.length - 1) {\n+                buf.append(\", \");\n+            }\n+        }\n+        if (braces) {\n+            buf.append('}');\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * @param ch the character to test if it's part of an identifier\n+     *\n+     * @return true, if character is one of (a, ... z, A, ... Z, 0, ... 9, _)\n+     *\/\n+    public static boolean isJavaIdentifierPart( final char ch ) {\n+        return ((ch >= 'a') && (ch <= 'z')) || ((ch >= 'A') && (ch <= 'Z'))\n+                || ((ch >= '0') && (ch <= '9')) || (ch == '_');\n+    }\n+\n+\n+    \/**\n+     * Encode byte array it into Java identifier string, i.e., a string\n+     * that only contains the following characters: (a, ... z, A, ... Z,\n+     * 0, ... 9, _, $).  The encoding algorithm itself is not too\n+     * clever: if the current byte's ASCII value already is a valid Java\n+     * identifier part, leave it as it is. Otherwise it writes the\n+     * escape character($) followed by:\n+     *\n+     * <ul>\n+     *   <li> the ASCII value as a hexadecimal string, if the value is not in the range 200..247<\/li>\n+     *   <li>a Java identifier char not used in a lowercase hexadecimal string, if the value is in the range 200..247<\/li>\n+     * <\/ul>\n+     *\n+     * <p>This operation inflates the original byte array by roughly 40-50%<\/p>\n+     *\n+     * @param bytes the byte array to convert\n+     * @param compress use gzip to minimize string\n+     *\n+     * @throws IOException if there's a gzip exception\n+     *\/\n+    public static String encode(byte[] bytes, final boolean compress) throws IOException {\n+        if (compress) {\n+            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+                    GZIPOutputStream gos = new GZIPOutputStream(baos)) {\n+                gos.write(bytes, 0, bytes.length);\n+                bytes = baos.toByteArray();\n+            }\n+        }\n+        final CharArrayWriter caw = new CharArrayWriter();\n+        try (JavaWriter jw = new JavaWriter(caw)) {\n+            for (final byte b : bytes) {\n+                final int in = b & 0x000000ff; \/\/ Normalize to unsigned\n+                jw.write(in);\n+            }\n+        }\n+        return caw.toString();\n+    }\n+\n+\n+    \/**\n+     * Decode a string back to a byte array.\n+     *\n+     * @param s the string to convert\n+     * @param uncompress use gzip to uncompress the stream of bytes\n+     *\n+     * @throws IOException if there's a gzip exception\n+     *\/\n+    public static byte[] decode(final String s, final boolean uncompress) throws IOException {\n+        byte[] bytes;\n+        try (JavaReader jr = new JavaReader(new CharArrayReader(s.toCharArray()));\n+                ByteArrayOutputStream bos = new ByteArrayOutputStream()) {\n+            int ch;\n+            while ((ch = jr.read()) >= 0) {\n+                bos.write(ch);\n+            }\n+            bytes = bos.toByteArray();\n+        }\n+        if (uncompress) {\n+            final GZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n+            final byte[] tmp = new byte[bytes.length * 3]; \/\/ Rough estimate\n+            int count = 0;\n+            int b;\n+            while ((b = gis.read()) >= 0) {\n+                tmp[count++] = (byte) b;\n+            }\n+            bytes = new byte[count];\n+            System.arraycopy(tmp, 0, bytes, 0, count);\n+        }\n+        return bytes;\n+    }\n+\n+    \/\/ A-Z, g-z, _, $\n+    private static final int FREE_CHARS = 48;\n+    private static int[] CHAR_MAP = new int[FREE_CHARS];\n+    private static int[] MAP_CHAR = new int[256]; \/\/ Reverse map\n+    private static final char ESCAPE_CHAR = '$';\n+    static {\n+        int j = 0;\n+        for (int i = 'A'; i <= 'Z'; i++) {\n+            CHAR_MAP[j] = i;\n+            MAP_CHAR[i] = j;\n+            j++;\n+        }\n+        for (int i = 'g'; i <= 'z'; i++) {\n+            CHAR_MAP[j] = i;\n+            MAP_CHAR[i] = j;\n+            j++;\n+        }\n+        CHAR_MAP[j] = '$';\n+        MAP_CHAR['$'] = j;\n+        j++;\n+        CHAR_MAP[j] = '_';\n+        MAP_CHAR['_'] = j;\n+    }\n+\n+    \/**\n+     * Decode characters into bytes.\n+     * Used by <a href=\"Utility.html#decode(java.lang.String, boolean)\">decode()<\/a>\n+     *\/\n+    private static class JavaReader extends FilterReader {\n+\n+        public JavaReader(final Reader in) {\n+            super(in);\n+        }\n+\n+\n+        @Override\n+        public int read() throws IOException {\n+            final int b = in.read();\n+            if (b != ESCAPE_CHAR) {\n+                return b;\n+            }\n+            final int i = in.read();\n+            if (i < 0) {\n+                return -1;\n+            }\n+            if (((i >= '0') && (i <= '9')) || ((i >= 'a') && (i <= 'f'))) { \/\/ Normal escape\n+                final int j = in.read();\n+                if (j < 0) {\n+                    return -1;\n@@ -1535,8 +1560,5 @@\n-                consumedChars = n; \/\/ Remember value\n-                \/\/ The rest of the string denotes a '<field_type>'\n-                type = typeSignatureToString(signature.substring(n), chopit);\n-                \/\/ corrected concurrent private static field acess\n-                \/\/ Utility.consumed_chars += consumed_chars; is replaced by:\n-                final int temp = unwrap(Utility.CONSUMER_CHARS) + consumedChars;\n-                wrap(Utility.CONSUMER_CHARS, temp);\n-                return type + brackets.toString();\n+                final char[] tmp = {\n+                        (char) i, (char) j\n+                };\n+                final int s = Integer.parseInt(new String(tmp), 16);\n+                return s;\n@@ -1544,4 +1566,8 @@\n-            case 'V':\n-                return \"void\";\n-            default:\n-                throw new ClassFormatException(\"Invalid signature: '\" + signature + \"'\");\n+            return MAP_CHAR[i];\n+        }\n+\n+\n+        @Override\n+        public int read( final char[] cbuf, final int off, final int len ) throws IOException {\n+            for (int i = 0; i < len; i++) {\n+                cbuf[off + i] = (char) read();\n@@ -1549,2 +1575,1 @@\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid signature: \" + signature, e);\n+            return len;\n@@ -1554,2 +1579,46 @@\n-    private static int unwrap(final ThreadLocal<Integer> tl) {\n-        return tl.get();\n+    \/**\n+     * Encode bytes into valid java identifier characters.\n+     * Used by <a href=\"Utility.html#encode(byte[], boolean)\">encode()<\/a>\n+     *\/\n+    private static class JavaWriter extends FilterWriter {\n+\n+        public JavaWriter(final Writer out) {\n+            super(out);\n+        }\n+\n+\n+        @Override\n+        public void write( final int b ) throws IOException {\n+            if (isJavaIdentifierPart((char) b) && (b != ESCAPE_CHAR)) {\n+                out.write(b);\n+            } else {\n+                out.write(ESCAPE_CHAR); \/\/ Escape character\n+                \/\/ Special escape\n+                if (b >= 0 && b < FREE_CHARS) {\n+                    out.write(CHAR_MAP[b]);\n+                } else { \/\/ Normal escape\n+                    final char[] tmp = Integer.toHexString(b).toCharArray();\n+                    if (tmp.length == 1) {\n+                        out.write('0');\n+                        out.write(tmp[0]);\n+                    } else {\n+                        out.write(tmp[0]);\n+                        out.write(tmp[1]);\n+                    }\n+                }\n+            }\n+        }\n+\n+\n+        @Override\n+        public void write( final char[] cbuf, final int off, final int len ) throws IOException {\n+            for (int i = 0; i < len; i++) {\n+                write(cbuf[off + i]);\n+            }\n+        }\n+\n+\n+        @Override\n+        public void write( final String str, final int off, final int len ) throws IOException {\n+            write(str.toCharArray(), off, len);\n+        }\n@@ -1558,2 +1627,30 @@\n-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n-        tl.set(value);\n+\n+    \/**\n+     * Escape all occurences of newline chars '\\n', quotes \\\", etc.\n+     *\/\n+    public static String convertString( final String label ) {\n+        final char[] ch = label.toCharArray();\n+        final StringBuilder buf = new StringBuilder();\n+        for (final char element : ch) {\n+            switch (element) {\n+                case '\\n':\n+                    buf.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    buf.append(\"\\\\r\");\n+                    break;\n+                case '\\\"':\n+                    buf.append(\"\\\\\\\"\");\n+                    break;\n+                case '\\'':\n+                    buf.append(\"\\\\'\");\n+                    break;\n+                case '\\\\':\n+                    buf.append(\"\\\\\\\\\");\n+                    break;\n+                default:\n+                    buf.append(element);\n+                    break;\n+            }\n+        }\n+        return buf.toString();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Utility.java","additions":1188,"deletions":1091,"binary":false,"changes":2279,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n- * Interface to make use of the Visitor pattern programming style. I.e. a class that implements this interface can\n- * traverse the contents of a Java class just by calling the 'accept' method which all classes have.\n+ * Interface to make use of the Visitor pattern programming style. I.e. a class\n+ * that implements this interface can traverse the contents of a Java class just\n+ * by calling the `accept' method which all classes have.\n+ *\n@@ -28,21 +30,2 @@\n-public interface Visitor {\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotation(Annotations obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotationDefault(AnnotationDefault obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitAnnotationEntry(AnnotationEntry obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitBootstrapMethods(BootstrapMethods obj);\n-\n+public interface Visitor\n+{\n@@ -57,7 +40,0 @@\n-    \/**\n-     * @since 6.3\n-     *\/\n-    default void visitConstantDynamic(final ConstantDynamic constantDynamic) {\n-        \/\/ empty\n-    }\n-\n@@ -76,5 +52,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitConstantMethodHandle(ConstantMethodHandle obj);\n-\n@@ -83,10 +54,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitConstantMethodType(ConstantMethodType obj);\n-\n-    \/**\n-     * @since 6.1\n-     *\/\n-    void visitConstantModule(ConstantModule constantModule);\n-\n@@ -95,5 +56,0 @@\n-    \/**\n-     * @since 6.1\n-     *\/\n-    void visitConstantPackage(ConstantPackage constantPackage);\n-\n@@ -110,5 +66,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitEnclosingMethod(EnclosingMethod obj);\n-\n@@ -133,0 +84,34 @@\n+    void visitMethod(Method obj);\n+\n+    void visitSignature(Signature obj);\n+\n+    void visitSourceFile(SourceFile obj);\n+\n+    void visitSynthetic(Synthetic obj);\n+\n+    void visitUnknown(Unknown obj);\n+\n+    void visitStackMap(StackMap obj);\n+\n+    void visitStackMapEntry(StackMapEntry obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotation(Annotations obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitParameterAnnotation(ParameterAnnotations obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotationEntry(AnnotationEntry obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitAnnotationDefault(AnnotationDefault obj);\n+\n@@ -138,1 +123,14 @@\n-    void visitMethod(Method obj);\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitEnclosingMethod(EnclosingMethod obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitBootstrapMethods(BootstrapMethods obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitMethodParameters(MethodParameters obj);\n@@ -150,1 +148,28 @@\n-    void visitMethodParameters(MethodParameters obj);\n+    void visitConstantMethodType(ConstantMethodType obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitConstantMethodHandle(ConstantMethodHandle obj);\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    void visitParameterAnnotationEntry(ParameterAnnotationEntry obj);\n+\n+    \/**\n+     * @since 6.1\n+     *\/\n+    void visitConstantPackage(ConstantPackage constantPackage);\n+\n+    \/**\n+     * @since 6.1\n+     *\/\n+    void visitConstantModule(ConstantModule constantModule);\n+\n+    \/**\n+     * @since 6.3\n+     *\/\n+    default void visitConstantDynamic(final ConstantDynamic constantDynamic) {\n+        \/\/ empty\n+    }\n@@ -162,1 +187,1 @@\n-    default void visitModuleExports(final ModuleExports constantModule) {\n+    default void visitModuleRequires(final ModuleRequires constantModule) {\n@@ -169,1 +194,1 @@\n-    default void visitModuleMainClass(final ModuleMainClass obj) {\n+    default void visitModuleExports(final ModuleExports constantModule) {\n@@ -183,1 +208,1 @@\n-    default void visitModulePackages(final ModulePackages constantModule) {\n+    default void visitModuleProvides(final ModuleProvides constantModule) {\n@@ -190,1 +215,1 @@\n-    default void visitModuleProvides(final ModuleProvides constantModule) {\n+    default void visitModulePackages(final ModulePackages constantModule) {\n@@ -197,1 +222,1 @@\n-    default void visitModuleRequires(final ModuleRequires constantModule) {\n+    default void visitModuleMainClass(final ModuleMainClass obj) {\n@@ -214,22 +239,0 @@\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitParameterAnnotation(ParameterAnnotations obj);\n-\n-    \/**\n-     * @since 6.0\n-     *\/\n-    void visitParameterAnnotationEntry(ParameterAnnotationEntry obj);\n-\n-    void visitSignature(Signature obj);\n-\n-    void visitSourceFile(SourceFile obj);\n-\n-    void visitStackMap(StackMap obj);\n-\n-    void visitStackMapEntry(StackMapEntry obj);\n-\n-    void visitSynthetic(Synthetic obj);\n-\n-    void visitUnknown(Unknown obj);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/classfile\/Visitor.java","additions":87,"deletions":84,"binary":false,"changes":171,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; value\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load reference from array\n+    \/** Load reference from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * AASTORE - Store into reference array\n+ * AASTORE -  Store into reference array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store into reference array\n+    \/** Store into reference array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ... -&gt; ..., null<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., null\n- * <\/PRE>\n@@ -40,0 +38,9 @@\n+\n+    \/** @return Type.NULL\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.NULL;\n+    }\n+\n+\n@@ -41,2 +48,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +56,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -53,8 +62,0 @@\n-\n-    \/**\n-     * @return Type.NULL\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.NULL;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ACONST_NULL.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -23,0 +23,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -25,0 +27,1 @@\n+ * <PRE>Stack: ... -&gt; ..., objectref<\/PRE>\n@@ -26,3 +29,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., objectref\n- * <\/PRE>\n@@ -34,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,1 +38,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ALOAD, com.sun.org.apache.bcel.internal.Const.ALOAD_0);\n+        super(Const.ALOAD, Const.ALOAD_0);\n@@ -40,3 +41,2 @@\n-    \/**\n-     * Load reference from local variable\n-     *\n+\n+    \/** Load reference from local variable\n@@ -46,1 +46,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ALOAD, com.sun.org.apache.bcel.internal.Const.ALOAD_0, n);\n+        super(Const.ALOAD, Const.ALOAD_0, n);\n@@ -49,0 +49,1 @@\n+\n@@ -50,2 +51,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +59,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ALOAD.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n- * ANEWARRAY - Create new array of references\n+ * ANEWARRAY -  Create new array of references\n+ * <PRE>Stack: ..., count -&gt; ..., arrayref<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ..., count -&gt; ..., arrayref\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower, StackConsumer, StackProducer {\n+public class ANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction,\n+        ExceptionThrower, StackConsumer, StackProducer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,0 +41,1 @@\n+\n@@ -45,0 +46,8 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION);\n+    }\n+\n+\n@@ -46,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -52,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -62,4 +73,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION);\n-    }\n@@ -68,1 +75,1 @@\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n@@ -73,1 +80,1 @@\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ANEWARRAY.java","additions":22,"deletions":15,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * ARETURN - Return reference from method\n+ * ARETURN -  Return reference from method\n+ * <PRE>Stack: ..., objectref -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -40,0 +38,1 @@\n+\n@@ -41,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ARETURN.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * ARRAYLENGTH - Get length of array\n+ * ARRAYLENGTH -  Get length of array\n+ * <PRE>Stack: ..., arrayref -&gt; ..., length<\/PRE>\n@@ -28,4 +29,1 @@\n- * <PRE>\n- * Stack: ..., arrayref -&gt; ..., length\n- * <\/PRE>\n- * @LastModified: Feb 2023\n+ * @LastModified: Jun 2019\n@@ -33,1 +31,2 @@\n-public class ARRAYLENGTH extends Instruction implements ExceptionThrower, StackProducer, StackConsumer \/* since 6.0 *\/ {\n+public class ARRAYLENGTH extends Instruction\n+    implements ExceptionThrower, StackProducer, StackConsumer \/* since 6.0 *\/ {\n@@ -35,2 +34,1 @@\n-    \/**\n-     * Get length of array\n+    \/** Get length of array\n@@ -42,0 +40,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NULL_POINTER_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -43,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -54,8 +65,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ARRAYLENGTH.java","additions":23,"deletions":20,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -22,0 +22,2 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+\n@@ -24,0 +26,1 @@\n+ * <PRE>Stack ..., objectref -&gt; ... <\/PRE>\n@@ -25,3 +28,0 @@\n- * <PRE>\n- * Stack ..., objectref -&gt; ...\n- * <\/PRE>\n@@ -33,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -36,1 +37,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ASTORE, com.sun.org.apache.bcel.internal.Const.ASTORE_0);\n+        super(Const.ASTORE, Const.ASTORE_0);\n@@ -39,3 +40,2 @@\n-    \/**\n-     * Store reference into local variable\n-     *\n+\n+    \/** Store reference into local variable\n@@ -45,1 +45,1 @@\n-        super(com.sun.org.apache.bcel.internal.Const.ASTORE, com.sun.org.apache.bcel.internal.Const.ASTORE_0, n);\n+        super(Const.ASTORE, Const.ASTORE_0, n);\n@@ -48,0 +48,1 @@\n+\n@@ -49,2 +50,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -55,1 +58,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ASTORE.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,2 @@\n- * ATHROW - Throw exception\n+ * ATHROW -  Throw exception\n+ * <PRE>Stack: ..., objectref -&gt; objectref<\/PRE>\n@@ -28,3 +29,1 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; objectref\n- * <\/PRE>\n+ * @LastModified: Jan 2020\n@@ -35,1 +34,1 @@\n-     * Throw exception\n+     *  Throw exception\n@@ -41,0 +40,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.THROWABLE\n+        };\n+    }\n+\n+\n@@ -42,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -53,8 +65,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.THROWABLE};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ATHROW.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AllocationInstruction.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,2 @@\n-public class AnnotationElementValueGen extends ElementValueGen {\n+public class AnnotationElementValueGen extends ElementValueGen\n+{\n@@ -37,6 +38,2 @@\n-    public AnnotationElementValueGen(final AnnotationElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(ANNOTATION, cpool);\n-        a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);\n-    }\n-\n-    public AnnotationElementValueGen(final AnnotationEntryGen a, final ConstantPoolGen cpool) {\n+    public AnnotationElementValueGen(final AnnotationEntryGen a, final ConstantPoolGen cpool)\n+    {\n@@ -47,1 +44,3 @@\n-    public AnnotationElementValueGen(final int type, final AnnotationEntryGen annotation, final ConstantPoolGen cpool) {\n+    public AnnotationElementValueGen(final int type, final AnnotationEntryGen annotation,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -50,1 +49,2 @@\n-            throw new IllegalArgumentException(\"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type annotation can be built with this ctor - type specified: \" + type);\n@@ -55,0 +55,7 @@\n+    public AnnotationElementValueGen(final AnnotationElementValue value,\n+            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n+    {\n+        super(ANNOTATION, cpool);\n+        a = new AnnotationEntryGen(value.getAnnotationEntry(), cpool, copyPoolEntries);\n+    }\n+\n@@ -56,1 +63,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -61,2 +69,4 @@\n-    public AnnotationEntryGen getAnnotation() {\n-        return a;\n+    @Override\n+    public String stringifyValue()\n+    {\n+        throw new UnsupportedOperationException(\"Not implemented yet\");\n@@ -69,2 +79,5 @@\n-    public ElementValue getElementValue() {\n-        return new AnnotationElementValue(super.getElementValueType(), a.getAnnotation(), getConstantPool().getConstantPool());\n+    public ElementValue getElementValue()\n+    {\n+        return new AnnotationElementValue(super.getElementValueType(),\n+                a.getAnnotation(),\n+                getConstantPool().getConstantPool());\n@@ -73,3 +86,3 @@\n-    @Override\n-    public String stringifyValue() {\n-        throw new UnsupportedOperationException(\"Not implemented yet\");\n+    public AnnotationEntryGen getAnnotation()\n+    {\n+        return a;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AnnotationElementValueGen.java","additions":30,"deletions":17,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -46,0 +46,90 @@\n+    private int typeIndex;\n+\n+    private List<ElementValuePairGen> evs;\n+\n+    private final ConstantPoolGen cpool;\n+\n+    private boolean isRuntimeVisible = false;\n+\n+    \/**\n+     * Here we are taking a fixed annotation of type Annotation and building a\n+     * modifiable AnnotationGen object. If the pool passed in is for a different\n+     * class file, then copyPoolEntries should have been passed as true as that\n+     * will force us to do a deep copy of the annotation and move the cpool\n+     * entries across. We need to copy the type and the element name value pairs\n+     * and the visibility.\n+     *\/\n+    public AnnotationEntryGen(final AnnotationEntry a, final ConstantPoolGen cpool,\n+                              final boolean copyPoolEntries) {\n+        this.cpool = cpool;\n+        if (copyPoolEntries) {\n+            typeIndex = cpool.addUtf8(a.getAnnotationType());\n+        } else {\n+            typeIndex = a.getAnnotationTypeIndex();\n+        }\n+        isRuntimeVisible = a.isRuntimeVisible();\n+        evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);\n+    }\n+\n+    private List<ElementValuePairGen> copyValues(final ElementValuePair[] in, final ConstantPoolGen cpool,\n+                                                 final boolean copyPoolEntries) {\n+        final List<ElementValuePairGen> out = new ArrayList<>();\n+        for (final ElementValuePair nvp : in) {\n+            out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));\n+        }\n+        return out;\n+    }\n+\n+    private AnnotationEntryGen(final ConstantPoolGen cpool) {\n+        this.cpool = cpool;\n+    }\n+\n+    \/**\n+     * Retrieve an immutable version of this AnnotationGen\n+     *\/\n+    public AnnotationEntry getAnnotation() {\n+        final AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(),\n+                isRuntimeVisible);\n+        for (final ElementValuePairGen element : evs) {\n+            a.addElementNameValuePair(element.getElementNameValuePair());\n+        }\n+        return a;\n+    }\n+\n+    public AnnotationEntryGen(final ObjectType type,\n+                              final List<ElementValuePairGen> elements, final boolean vis,\n+                              final ConstantPoolGen cpool) {\n+        this.cpool = cpool;\n+        this.typeIndex = cpool.addUtf8(type.getSignature());\n+        evs = elements;\n+        isRuntimeVisible = vis;\n+    }\n+\n+    public static AnnotationEntryGen read(final DataInput dis,\n+                                          final ConstantPoolGen cpool, final boolean b) throws IOException {\n+        final AnnotationEntryGen a = new AnnotationEntryGen(cpool);\n+        a.typeIndex = dis.readUnsignedShort();\n+        final int elemValuePairCount = dis.readUnsignedShort();\n+        for (int i = 0; i < elemValuePairCount; i++) {\n+            final int nidx = dis.readUnsignedShort();\n+            a.addElementNameValuePair(new ElementValuePairGen(nidx,\n+                    ElementValueGen.readElementValue(dis, cpool), cpool));\n+        }\n+        a.isRuntimeVisible(b);\n+        return a;\n+    }\n+\n+    public void dump(final DataOutputStream dos) throws IOException {\n+        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n+        dos.writeShort(evs.size()); \/\/ u2 element_value pair count\n+        for (final ElementValuePairGen envp : evs) {\n+            envp.dump(dos);\n+        }\n+    }\n+\n+    public void addElementNameValuePair(final ElementValuePairGen evp) {\n+        if (evs == null) {\n+            evs = new ArrayList<>();\n+        }\n+        evs.add(evp);\n+    }\n@@ -47,1 +137,15 @@\n-    static final AnnotationEntryGen[] EMPTY_ARRAY = {};\n+    public int getTypeIndex() {\n+        return typeIndex;\n+    }\n+\n+    public final String getTypeSignature() {\n+        \/\/ ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);\n+        final ConstantUtf8 utf8 = (ConstantUtf8) cpool\n+                .getConstant(typeIndex\/* c.getNameIndex() *\/);\n+        return utf8.getBytes();\n+    }\n+\n+    public final String getTypeName() {\n+        return getTypeSignature();\/\/ BCELBUG: Should I use this instead?\n+        \/\/ Utility.signatureToString(getTypeSignature());\n+    }\n@@ -50,1 +154,45 @@\n-     * Converts a list of AnnotationGen objects into a set of attributes that can be attached to the class file.\n+     * Returns list of ElementNameValuePair objects\n+     *\/\n+    public List<ElementValuePairGen> getValues() {\n+        return evs;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        final StringBuilder s = new StringBuilder(32); \/\/ CHECKSTYLE IGNORE MagicNumber\n+        s.append(\"AnnotationGen:[\").append(getTypeName()).append(\" #\").append(evs.size()).append(\" {\");\n+        for (int i = 0; i < evs.size(); i++) {\n+            s.append(evs.get(i));\n+            if (i + 1 < evs.size()) {\n+                s.append(\",\");\n+            }\n+        }\n+        s.append(\"}]\");\n+        return s.toString();\n+    }\n+\n+    public String toShortString() {\n+        final StringBuilder s = new StringBuilder();\n+        s.append(\"@\").append(getTypeName()).append(\"(\");\n+        for (int i = 0; i < evs.size(); i++) {\n+            s.append(evs.get(i));\n+            if (i + 1 < evs.size()) {\n+                s.append(\",\");\n+            }\n+        }\n+        s.append(\")\");\n+        return s.toString();\n+    }\n+\n+    private void isRuntimeVisible(final boolean b) {\n+        isRuntimeVisible = b;\n+    }\n+\n+    public boolean isRuntimeVisible() {\n+        return isRuntimeVisible;\n+    }\n+\n+\n+    \/**\n+     * Converts a list of AnnotationGen objects into a set of attributes\n+     * that can be attached to the class file.\n@@ -52,1 +200,1 @@\n-     * @param cp The constant pool gen where we can create the necessary name refs\n+     * @param cp  The constant pool gen where we can create the necessary name refs\n@@ -57,1 +205,1 @@\n-            return Attribute.EMPTY_ARRAY;\n+            return new Attribute[0];\n@@ -64,1 +212,1 @@\n-            \/\/ put the annotations in the right output stream\n+            \/\/  put the annotations in the right output stream\n@@ -75,1 +223,2 @@\n-            try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes); DataOutputStream riaDos = new DataOutputStream(riaBytes)) {\n+            try (DataOutputStream rvaDos = new DataOutputStream(rvaBytes);\n+                    DataOutputStream riaDos = new DataOutputStream(riaBytes)) {\n@@ -105,2 +254,3 @@\n-                newAttributes\n-                    .add(new RuntimeVisibleAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));\n+                newAttributes.add(\n+                        new RuntimeVisibleAnnotations(rvaIndex, rvaData.length,\n+                            new DataInputStream(new ByteArrayInputStream(rvaData)), cp.getConstantPool()));\n@@ -110,1 +260,2 @@\n-                    new RuntimeInvisibleAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));\n+                        new RuntimeInvisibleAnnotations(riaIndex, riaData.length,\n+                            new DataInputStream(new ByteArrayInputStream(riaData)), cp.getConstantPool()));\n@@ -113,1 +264,1 @@\n-            return newAttributes.toArray(Attribute.EMPTY_ARRAY);\n+            return newAttributes.toArray(new Attribute[newAttributes.size()]);\n@@ -121,0 +272,1 @@\n+\n@@ -122,2 +274,3 @@\n-     * Annotations against a class are stored in one of four attribute kinds: - RuntimeVisibleParameterAnnotations -\n-     * RuntimeInvisibleParameterAnnotations\n+     * Annotations against a class are stored in one of four attribute kinds:\n+     * - RuntimeVisibleParameterAnnotations\n+     * - RuntimeInvisibleParameterAnnotations\n@@ -125,2 +278,3 @@\n-    static Attribute[] getParameterAnnotationAttributes(final ConstantPoolGen cp,\n-        final List<AnnotationEntryGen>[] \/* Array of lists, array size depends on #params *\/ vec) {\n+    static Attribute[] getParameterAnnotationAttributes(\n+            final ConstantPoolGen cp,\n+            final List<AnnotationEntryGen>[] \/*Array of lists, array size depends on #params *\/vec) {\n@@ -187,2 +341,5 @@\n-                newAttributes.add(new RuntimeVisibleParameterAnnotations(rvaIndex, rvaData.length, new DataInputStream(new ByteArrayInputStream(rvaData)),\n-                    cp.getConstantPool()));\n+                newAttributes\n+                        .add(new RuntimeVisibleParameterAnnotations(rvaIndex,\n+                                rvaData.length,\n+                                new DataInputStream(new ByteArrayInputStream(rvaData)),\n+                                    cp.getConstantPool()));\n@@ -191,2 +348,5 @@\n-                newAttributes.add(new RuntimeInvisibleParameterAnnotations(riaIndex, riaData.length, new DataInputStream(new ByteArrayInputStream(riaData)),\n-                    cp.getConstantPool()));\n+                newAttributes\n+                        .add(new RuntimeInvisibleParameterAnnotations(riaIndex,\n+                                riaData.length,\n+                                new DataInputStream(new ByteArrayInputStream(riaData)),\n+                                    cp.getConstantPool()));\n@@ -194,1 +354,1 @@\n-            return newAttributes.toArray(Attribute.EMPTY_ARRAY);\n+            return newAttributes.toArray(new Attribute[newAttributes.size()]);\n@@ -196,2 +356,2 @@\n-            System.err.println(\"IOException whilst processing parameter annotations\");\n-            e.printStackTrace();\n+            System.err.println(\"IOException whilst processing parameter annotations.\" +\n+                    e.getMessage());\n@@ -202,139 +362,0 @@\n-    public static AnnotationEntryGen read(final DataInput dis, final ConstantPoolGen cpool, final boolean b) throws IOException {\n-        final AnnotationEntryGen a = new AnnotationEntryGen(cpool);\n-        a.typeIndex = dis.readUnsignedShort();\n-        final int elemValuePairCount = dis.readUnsignedShort();\n-        for (int i = 0; i < elemValuePairCount; i++) {\n-            final int nidx = dis.readUnsignedShort();\n-            a.addElementNameValuePair(new ElementValuePairGen(nidx, ElementValueGen.readElementValue(dis, cpool), cpool));\n-        }\n-        a.isRuntimeVisible(b);\n-        return a;\n-    }\n-\n-    private int typeIndex;\n-\n-    private List<ElementValuePairGen> evs;\n-\n-    private final ConstantPoolGen cpool;\n-\n-    private boolean isRuntimeVisible;\n-\n-    \/**\n-     * Here we are taking a fixed annotation of type Annotation and building a modifiable AnnotationGen object. If the pool\n-     * passed in is for a different class file, then copyPoolEntries should have been passed as true as that will force us\n-     * to do a deep copy of the annotation and move the cpool entries across. We need to copy the type and the element name\n-     * value pairs and the visibility.\n-     *\/\n-    public AnnotationEntryGen(final AnnotationEntry a, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        this.cpool = cpool;\n-        if (copyPoolEntries) {\n-            typeIndex = cpool.addUtf8(a.getAnnotationType());\n-        } else {\n-            typeIndex = a.getAnnotationTypeIndex();\n-        }\n-        isRuntimeVisible = a.isRuntimeVisible();\n-        evs = copyValues(a.getElementValuePairs(), cpool, copyPoolEntries);\n-    }\n-\n-    private AnnotationEntryGen(final ConstantPoolGen cpool) {\n-        this.cpool = cpool;\n-    }\n-\n-    public AnnotationEntryGen(final ObjectType type, final List<ElementValuePairGen> elements, final boolean vis, final ConstantPoolGen cpool) {\n-        this.cpool = cpool;\n-        this.typeIndex = cpool.addUtf8(type.getSignature());\n-        evs = elements;\n-        isRuntimeVisible = vis;\n-    }\n-\n-    public void addElementNameValuePair(final ElementValuePairGen evp) {\n-        if (evs == null) {\n-            evs = new ArrayList<>();\n-        }\n-        evs.add(evp);\n-    }\n-\n-    private List<ElementValuePairGen> copyValues(final ElementValuePair[] in, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        final List<ElementValuePairGen> out = new ArrayList<>();\n-        for (final ElementValuePair nvp : in) {\n-            out.add(new ElementValuePairGen(nvp, cpool, copyPoolEntries));\n-        }\n-        return out;\n-    }\n-\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeShort(typeIndex); \/\/ u2 index of type name in cpool\n-        dos.writeShort(evs.size()); \/\/ u2 element_value pair count\n-        for (final ElementValuePairGen envp : evs) {\n-            envp.dump(dos);\n-        }\n-    }\n-\n-    \/**\n-     * Retrieve an immutable version of this AnnotationGen\n-     *\/\n-    public AnnotationEntry getAnnotation() {\n-        final AnnotationEntry a = new AnnotationEntry(typeIndex, cpool.getConstantPool(), isRuntimeVisible);\n-        for (final ElementValuePairGen element : evs) {\n-            a.addElementNameValuePair(element.getElementNameValuePair());\n-        }\n-        return a;\n-    }\n-\n-    public int getTypeIndex() {\n-        return typeIndex;\n-    }\n-\n-    public final String getTypeName() {\n-        return getTypeSignature();\/\/ BCELBUG: Should I use this instead?\n-        \/\/ Utility.signatureToString(getTypeSignature());\n-    }\n-\n-    public final String getTypeSignature() {\n-        \/\/ ConstantClass c = (ConstantClass)cpool.getConstant(typeIndex);\n-        final ConstantUtf8 utf8 = (ConstantUtf8) cpool.getConstant(typeIndex\/* c.getNameIndex() *\/);\n-        return utf8.getBytes();\n-    }\n-\n-    \/**\n-     * Returns list of ElementNameValuePair objects\n-     *\/\n-    public List<ElementValuePairGen> getValues() {\n-        return evs;\n-    }\n-\n-    public boolean isRuntimeVisible() {\n-        return isRuntimeVisible;\n-    }\n-\n-    private void isRuntimeVisible(final boolean b) {\n-        isRuntimeVisible = b;\n-    }\n-\n-    public String toShortString() {\n-        final StringBuilder s = new StringBuilder();\n-        s.append(\"@\").append(getTypeName()).append(\"(\");\n-        for (int i = 0; i < evs.size(); i++) {\n-            s.append(evs.get(i));\n-            if (i + 1 < evs.size()) {\n-                s.append(\",\");\n-            }\n-        }\n-        s.append(\")\");\n-        return s.toString();\n-    }\n-\n-    @Override\n-    public String toString() {\n-        final StringBuilder s = new StringBuilder(32); \/\/ CHECKSTYLE IGNORE MagicNumber\n-        s.append(\"AnnotationGen:[\").append(getTypeName()).append(\" #\").append(evs.size()).append(\" {\");\n-        for (int i = 0; i < evs.size(); i++) {\n-            s.append(evs.get(i));\n-            if (i + 1 < evs.size()) {\n-                s.append(\",\");\n-            }\n-        }\n-        s.append(\"}]\");\n-        return s.toString();\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/AnnotationEntryGen.java","additions":181,"deletions":160,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -29,1 +30,2 @@\n-public abstract class ArithmeticInstruction extends Instruction implements TypedInstruction, StackProducer, StackConsumer {\n+public abstract class ArithmeticInstruction extends Instruction implements TypedInstruction,\n+        StackProducer, StackConsumer {\n@@ -32,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +40,1 @@\n+\n@@ -44,2 +48,2 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    \/** @return type associated with the instruction\n@@ -48,45 +52,45 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case Const.DADD:\n-        case Const.DDIV:\n-        case Const.DMUL:\n-        case Const.DNEG:\n-        case Const.DREM:\n-        case Const.DSUB:\n-            return Type.DOUBLE;\n-        case Const.FADD:\n-        case Const.FDIV:\n-        case Const.FMUL:\n-        case Const.FNEG:\n-        case Const.FREM:\n-        case Const.FSUB:\n-            return Type.FLOAT;\n-        case Const.IADD:\n-        case Const.IAND:\n-        case Const.IDIV:\n-        case Const.IMUL:\n-        case Const.INEG:\n-        case Const.IOR:\n-        case Const.IREM:\n-        case Const.ISHL:\n-        case Const.ISHR:\n-        case Const.ISUB:\n-        case Const.IUSHR:\n-        case Const.IXOR:\n-            return Type.INT;\n-        case Const.LADD:\n-        case Const.LAND:\n-        case Const.LDIV:\n-        case Const.LMUL:\n-        case Const.LNEG:\n-        case Const.LOR:\n-        case Const.LREM:\n-        case Const.LSHL:\n-        case Const.LSHR:\n-        case Const.LSUB:\n-        case Const.LUSHR:\n-        case Const.LXOR:\n-            return Type.LONG;\n-        default: \/\/ Never reached\n-            throw new ClassGenException(\"Unknown type \" + opcode);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case Const.DADD:\n+            case Const.DDIV:\n+            case Const.DMUL:\n+            case Const.DNEG:\n+            case Const.DREM:\n+            case Const.DSUB:\n+                return Type.DOUBLE;\n+            case Const.FADD:\n+            case Const.FDIV:\n+            case Const.FMUL:\n+            case Const.FNEG:\n+            case Const.FREM:\n+            case Const.FSUB:\n+                return Type.FLOAT;\n+            case Const.IADD:\n+            case Const.IAND:\n+            case Const.IDIV:\n+            case Const.IMUL:\n+            case Const.INEG:\n+            case Const.IOR:\n+            case Const.IREM:\n+            case Const.ISHL:\n+            case Const.ISHR:\n+            case Const.ISUB:\n+            case Const.IUSHR:\n+            case Const.IXOR:\n+                return Type.INT;\n+            case Const.LADD:\n+            case Const.LAND:\n+            case Const.LDIV:\n+            case Const.LMUL:\n+            case Const.LNEG:\n+            case Const.LOR:\n+            case Const.LREM:\n+            case Const.LSHL:\n+            case Const.LSHR:\n+            case Const.LSUB:\n+            case Const.LUSHR:\n+            case Const.LXOR:\n+                return Type.LONG;\n+            default: \/\/ Never reached\n+                throw new ClassGenException(\"Unknown type \" + _opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArithmeticInstruction.java","additions":53,"deletions":49,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -35,1 +35,2 @@\n-public class ArrayElementValueGen extends ElementValueGen {\n+public class ArrayElementValueGen extends ElementValueGen\n+{\n@@ -40,14 +41,2 @@\n-    \/**\n-     * @param value\n-     * @param cpool\n-     *\/\n-    public ArrayElementValueGen(final ArrayElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(ARRAY, cpool);\n-        evalues = new ArrayList<>();\n-        final ElementValue[] in = value.getElementValuesArray();\n-        for (final ElementValue element : in) {\n-            evalues.add(ElementValueGen.copy(element, cpool, copyPoolEntries));\n-        }\n-    }\n-\n-    public ArrayElementValueGen(final ConstantPoolGen cp) {\n+    public ArrayElementValueGen(final ConstantPoolGen cp)\n+    {\n@@ -58,1 +47,3 @@\n-    public ArrayElementValueGen(final int type, final ElementValue[] datums, final ConstantPoolGen cpool) {\n+    public ArrayElementValueGen(final int type, final ElementValue[] datums,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -61,1 +52,2 @@\n-            throw new IllegalArgumentException(\"Only element values of type array can be built with this ctor - type specified: \" + type);\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type array can be built with this ctor - type specified: \" + type);\n@@ -69,13 +61,0 @@\n-    public void addElement(final ElementValueGen gen) {\n-        evalues.add(gen);\n-    }\n-\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 type of value (ARRAY == '[')\n-        dos.writeShort(evalues.size());\n-        for (final ElementValueGen element : evalues) {\n-            element.dump(dos);\n-        }\n-    }\n-\n@@ -86,1 +65,2 @@\n-    public ElementValue getElementValue() {\n+    public ElementValue getElementValue()\n+    {\n@@ -92,1 +72,3 @@\n-        return new ArrayElementValue(super.getElementValueType(), immutableData, getConstantPool().getConstantPool());\n+        return new ArrayElementValue(super.getElementValueType(),\n+                immutableData,\n+                getConstantPool().getConstantPool());\n@@ -95,2 +77,13 @@\n-    public List<ElementValueGen> getElementValues() {\n-        return evalues;\n+    \/**\n+     * @param value\n+     * @param cpool\n+     *\/\n+    public ArrayElementValueGen(final ArrayElementValue value, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n+        super(ARRAY, cpool);\n+        evalues = new ArrayList<>();\n+        final ElementValue[] in = value.getElementValuesArray();\n+        for (final ElementValue element : in) {\n+            evalues.add(ElementValueGen.copy(element, cpool, copyPoolEntries));\n+        }\n@@ -99,2 +92,8 @@\n-    public int getElementValuesSize() {\n-        return evalues.size();\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 type of value (ARRAY == '[')\n+        dos.writeShort(evalues.size());\n+        for (final ElementValueGen element : evalues) {\n+            element.dump(dos);\n+        }\n@@ -104,1 +103,2 @@\n-    public String stringifyValue() {\n+    public String stringifyValue()\n+    {\n@@ -116,0 +116,15 @@\n+\n+    public List<ElementValueGen> getElementValues()\n+    {\n+        return evalues;\n+    }\n+\n+    public int getElementValuesSize()\n+    {\n+        return evalues.size();\n+    }\n+\n+    public void addElement(final ElementValueGen gen)\n+    {\n+        evalues.add(gen);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayElementValueGen.java","additions":52,"deletions":37,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -29,1 +30,2 @@\n-public abstract class ArrayInstruction extends Instruction implements ExceptionThrower, TypedInstruction {\n+public abstract class ArrayInstruction extends Instruction implements ExceptionThrower,\n+        TypedInstruction {\n@@ -32,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +40,1 @@\n+\n@@ -44,0 +48,1 @@\n+\n@@ -49,2 +54,2 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    \/** @return type associated with the instruction\n@@ -53,29 +58,29 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case com.sun.org.apache.bcel.internal.Const.IALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.IASTORE:\n-            return Type.INT;\n-        case com.sun.org.apache.bcel.internal.Const.CALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.CASTORE:\n-            return Type.CHAR;\n-        case com.sun.org.apache.bcel.internal.Const.BALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.BASTORE:\n-            return Type.BYTE;\n-        case com.sun.org.apache.bcel.internal.Const.SALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.SASTORE:\n-            return Type.SHORT;\n-        case com.sun.org.apache.bcel.internal.Const.LALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.LASTORE:\n-            return Type.LONG;\n-        case com.sun.org.apache.bcel.internal.Const.DALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.DASTORE:\n-            return Type.DOUBLE;\n-        case com.sun.org.apache.bcel.internal.Const.FALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.FASTORE:\n-            return Type.FLOAT;\n-        case com.sun.org.apache.bcel.internal.Const.AALOAD:\n-        case com.sun.org.apache.bcel.internal.Const.AASTORE:\n-            return Type.OBJECT;\n-        default:\n-            throw new ClassGenException(\"Unknown case in switch\" + opcode);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case com.sun.org.apache.bcel.internal.Const.IALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.IASTORE:\n+                return Type.INT;\n+            case com.sun.org.apache.bcel.internal.Const.CALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.CASTORE:\n+                return Type.CHAR;\n+            case com.sun.org.apache.bcel.internal.Const.BALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.BASTORE:\n+                return Type.BYTE;\n+            case com.sun.org.apache.bcel.internal.Const.SALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.SASTORE:\n+                return Type.SHORT;\n+            case com.sun.org.apache.bcel.internal.Const.LALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.LASTORE:\n+                return Type.LONG;\n+            case com.sun.org.apache.bcel.internal.Const.DALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.DASTORE:\n+                return Type.DOUBLE;\n+            case com.sun.org.apache.bcel.internal.Const.FALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.FASTORE:\n+                return Type.FLOAT;\n+            case com.sun.org.apache.bcel.internal.Const.AALOAD:\n+            case com.sun.org.apache.bcel.internal.Const.AASTORE:\n+                return Type.OBJECT;\n+            default:\n+                throw new ClassGenException(\"Unknown case in switch\" + _opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayInstruction.java","additions":38,"deletions":33,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ *\n@@ -30,2 +31,3 @@\n-    private final int dimensions;\n-    private final Type basicType;\n+    private int dimensions;\n+    private Type basicType;\n+\n@@ -37,1 +39,0 @@\n-     * @param dimensions array dimensions\n@@ -43,0 +44,1 @@\n+\n@@ -46,2 +48,1 @@\n-     * @param className complete name of class (java.lang.String, e.g.)\n-     * @param dimensions array dimensions\n+     * @param class_name complete name of class (java.lang.String, e.g.)\n@@ -49,2 +50,2 @@\n-    public ArrayType(final String className, final int dimensions) {\n-        this(ObjectType.getInstance(className), dimensions);\n+    public ArrayType(final String class_name, final int dimensions) {\n+        this(ObjectType.getInstance(class_name), dimensions);\n@@ -53,0 +54,1 @@\n+\n@@ -57,1 +59,0 @@\n-     * @param dimensions array dimensions\n@@ -61,1 +62,1 @@\n-        if (dimensions < 1 || dimensions > Const.MAX_BYTE) {\n+        if ((dimensions < 1) || (dimensions > Const.MAX_BYTE)) {\n@@ -65,11 +66,11 @@\n-        case Const.T_ARRAY:\n-            final ArrayType array = (ArrayType) type;\n-            this.dimensions = dimensions + array.dimensions;\n-            basicType = array.basicType;\n-            break;\n-        case Const.T_VOID:\n-            throw new ClassGenException(\"Invalid type: void[]\");\n-        default: \/\/ Basic type or reference\n-            this.dimensions = dimensions;\n-            basicType = type;\n-            break;\n+            case Const.T_ARRAY:\n+                final ArrayType array = (ArrayType) type;\n+                this.dimensions = dimensions + array.dimensions;\n+                basicType = array.basicType;\n+                break;\n+            case Const.T_VOID:\n+                throw new ClassGenException(\"Invalid type: void[]\");\n+            default: \/\/ Basic type or reference\n+                this.dimensions = dimensions;\n+                basicType = type;\n+                break;\n@@ -85,11 +86,0 @@\n-    \/**\n-     * @return true if both type objects refer to the same array type.\n-     *\/\n-    @Override\n-    public boolean equals(final Object type) {\n-        if (type instanceof ArrayType) {\n-            final ArrayType array = (ArrayType) type;\n-            return array.dimensions == dimensions && array.basicType.equals(basicType);\n-        }\n-        return false;\n-    }\n@@ -104,18 +94,0 @@\n-    \/**\n-     * Gets the name of referenced class.\n-     *\n-     * @return name of referenced class.\n-     * @since 6.7.0\n-     *\/\n-    @Override\n-    @Deprecated\n-    public String getClassName() {\n-        return signature;\n-    }\n-\n-    \/**\n-     * @return number of dimensions of array\n-     *\/\n-    public int getDimensions() {\n-        return dimensions;\n-    }\n@@ -133,2 +105,9 @@\n-    \/**\n-     * @return a hash code value for the object.\n+\n+    \/** @return number of dimensions of array\n+     *\/\n+    public int getDimensions() {\n+        return dimensions;\n+    }\n+\n+\n+    \/** @return a hash code value for the object.\n@@ -140,0 +119,12 @@\n+\n+\n+    \/** @return true if both type objects refer to the same array type.\n+     *\/\n+    @Override\n+    public boolean equals( final Object _type ) {\n+        if (_type instanceof ArrayType) {\n+            final ArrayType array = (ArrayType) _type;\n+            return (array.dimensions == dimensions) && array.basicType.equals(basicType);\n+        }\n+        return false;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ArrayType.java","additions":42,"deletions":51,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -26,3 +27,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -32,2 +30,1 @@\n-    \/**\n-     * Load byte or boolean from array\n+    \/** Load byte or boolean from array\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n- * BASTORE - Store into byte or boolean array\n+ * BASTORE -  Store into byte or boolean array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -26,3 +27,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -32,2 +30,1 @@\n-    \/**\n-     * Store byte or boolean into array\n+    \/** Store byte or boolean into array\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,3 +30,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., value\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., value<\/PRE>\n+ *\n@@ -38,0 +37,1 @@\n+\n@@ -39,1 +39,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -44,2 +45,2 @@\n-    \/**\n-     * Push byte on stack\n+\n+    \/** Push byte on stack\n@@ -52,0 +53,1 @@\n+\n@@ -53,4 +55,1 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * Dump instruction as byte code to stream out.\n@@ -59,6 +58,3 @@\n-    public void accept(final Visitor v) {\n-        v.visitPushInstruction(this);\n-        v.visitStackProducer(this);\n-        v.visitTypedInstruction(this);\n-        v.visitConstantPushInstruction(this);\n-        v.visitBIPUSH(this);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        super.dump(out);\n+        out.writeByte(b);\n@@ -67,0 +63,1 @@\n+\n@@ -68,1 +65,1 @@\n-     * Dump instruction as byte code to stream out.\n+     * @return mnemonic for instruction\n@@ -71,3 +68,2 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        super.dump(out);\n-        out.writeByte(b);\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + b;\n@@ -76,0 +72,1 @@\n+\n@@ -77,1 +74,1 @@\n-     * @return Type.BYTE\n+     * Read needed data (e.g. index) from file.\n@@ -80,2 +77,3 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.BYTE;\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(2);\n+        b = bytes.readByte();\n@@ -84,0 +82,1 @@\n+\n@@ -89,2 +88,2 @@\n-    \/**\n-     * Read needed data (e.g. index) from file.\n+\n+    \/** @return Type.BYTE\n@@ -93,3 +92,2 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(2);\n-        b = bytes.readByte();\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.BYTE;\n@@ -98,0 +96,1 @@\n+\n@@ -99,1 +98,6 @@\n-     * @return mnemonic for instruction\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -102,2 +106,6 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + b;\n+    public void accept( final Visitor v ) {\n+        v.visitPushInstruction(this);\n+        v.visitStackProducer(this);\n+        v.visitTypedInstruction(this);\n+        v.visitConstantPushInstruction(this);\n+        v.visitBIPUSH(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BIPUSH.java","additions":39,"deletions":31,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+ *\n@@ -32,0 +33,1 @@\n+\n@@ -33,2 +35,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -39,1 +43,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BREAKPOINT.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ *\n@@ -30,26 +31,0 @@\n-    \/\/ @since 6.0 no longer final\n-    public static BasicType getType(final byte type) {\n-        switch (type) {\n-        case Const.T_VOID:\n-            return VOID;\n-        case Const.T_BOOLEAN:\n-            return BOOLEAN;\n-        case Const.T_BYTE:\n-            return BYTE;\n-        case Const.T_SHORT:\n-            return SHORT;\n-        case Const.T_CHAR:\n-            return CHAR;\n-        case Const.T_INT:\n-            return INT;\n-        case Const.T_LONG:\n-            return LONG;\n-        case Const.T_DOUBLE:\n-            return DOUBLE;\n-        case Const.T_FLOAT:\n-            return FLOAT;\n-        default:\n-            throw new ClassGenException(\"Invalid type: \" + type);\n-        }\n-    }\n-\n@@ -57,1 +32,1 @@\n-     * Constructor for basic types such as int, long, 'void'\n+     * Constructor for basic types such as int, long, `void'\n@@ -64,1 +39,1 @@\n-        if (type < Const.T_BOOLEAN || type > Const.T_VOID) {\n+        if ((type < Const.T_BOOLEAN) || (type > Const.T_VOID)) {\n@@ -69,6 +44,25 @@\n-    \/**\n-     * @return true if both type objects refer to the same type\n-     *\/\n-    @Override\n-    public boolean equals(final Object type) {\n-        return type instanceof BasicType && ((BasicType) type).getType() == this.getType();\n+\n+    \/\/ @since 6.0 no longer final\n+    public static BasicType getType( final byte type ) {\n+        switch (type) {\n+            case Const.T_VOID:\n+                return VOID;\n+            case Const.T_BOOLEAN:\n+                return BOOLEAN;\n+            case Const.T_BYTE:\n+                return BYTE;\n+            case Const.T_SHORT:\n+                return SHORT;\n+            case Const.T_CHAR:\n+                return CHAR;\n+            case Const.T_INT:\n+                return INT;\n+            case Const.T_LONG:\n+                return LONG;\n+            case Const.T_DOUBLE:\n+                return DOUBLE;\n+            case Const.T_FLOAT:\n+                return FLOAT;\n+            default:\n+                throw new ClassGenException(\"Invalid type: \" + type);\n+        }\n@@ -77,2 +71,2 @@\n-    \/**\n-     * @return a hash code value for the object.\n+\n+    \/** @return a hash code value for the object.\n@@ -84,0 +78,8 @@\n+\n+\n+    \/** @return true if both type objects refer to the same type\n+     *\/\n+    @Override\n+    public boolean equals( final Object _type ) {\n+        return (_type instanceof BasicType) ? ((BasicType) _type).getType() == this.getType() : false;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BasicType.java","additions":38,"deletions":36,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -24,2 +24,4 @@\n- * BranchHandle is returned by specialized InstructionList.append() whenever a BranchInstruction is appended. This is\n- * useful when the target of this instruction is not known at time of creation and must be set later via setTarget().\n+ * BranchHandle is returned by specialized InstructionList.append() whenever a\n+ * BranchInstruction is appended. This is useful when the target of this\n+ * instruction is not known at time of creation and must be set later\n+ * via setTarget().\n@@ -33,7 +35,0 @@\n-    \/**\n-     * Factory method.\n-     *\/\n-    static BranchHandle getBranchHandle(final BranchInstruction i) {\n-        return new BranchHandle(i);\n-    }\n-\n@@ -44,0 +39,1 @@\n+\n@@ -49,3 +45,1 @@\n-    \/*\n-     * Override InstructionHandle methods: delegate to branch instruction. Through this overriding all access to the private\n-     * i_position field should be prevented.\n+    \/** Factory method.\n@@ -53,3 +47,2 @@\n-    @Override\n-    public int getPosition() {\n-        return bi.getPosition();\n+    static BranchHandle getBranchHandle( final BranchInstruction i ) {\n+        return new BranchHandle(i);\n@@ -58,6 +51,0 @@\n-    \/**\n-     * @return target of instruction.\n-     *\/\n-    public InstructionHandle getTarget() {\n-        return bi.getTarget();\n-    }\n@@ -65,2 +52,3 @@\n-    \/**\n-     * Set new contents. Old instruction is disposed and may not be used anymore.\n+    \/* Override InstructionHandle methods: delegate to branch instruction.\n+     * Through this overriding all access to the private i_position field should\n+     * be prevented.\n@@ -68,7 +56,3 @@\n-    @Override \/\/ This is only done in order to apply the additional type check; could be merged with super impl.\n-    public void setInstruction(final Instruction i) { \/\/ TODO could be package-protected?\n-        super.setInstruction(i);\n-        if (!(i instanceof BranchInstruction)) {\n-            throw new ClassGenException(\"Assigning \" + i + \" to branch handle which is not a branch instruction\");\n-        }\n-        bi = (BranchInstruction) i;\n+    @Override\n+    public int getPosition() {\n+        return bi.getPosition();\n@@ -77,0 +61,1 @@\n+\n@@ -78,1 +63,1 @@\n-    void setPosition(final int pos) {\n+    void setPosition( final int pos ) {\n@@ -84,0 +69,9 @@\n+\n+    @Override\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        final int x = bi.updatePosition(offset, max_offset);\n+        super.setPosition(bi.getPosition());\n+        return x;\n+    }\n+\n+\n@@ -87,1 +81,1 @@\n-    public void setTarget(final InstructionHandle ih) {\n+    public void setTarget( final InstructionHandle ih ) {\n@@ -91,6 +85,0 @@\n-    @Override\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        final int x = bi.updatePosition(offset, maxOffset);\n-        super.setPosition(bi.getPosition());\n-        return x;\n-    }\n@@ -101,2 +89,24 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        bi.updateTarget(oldIh, newIh);\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        bi.updateTarget(old_ih, new_ih);\n+    }\n+\n+\n+    \/**\n+     * @return target of instruction.\n+     *\/\n+    public InstructionHandle getTarget() {\n+        return bi.getTarget();\n+    }\n+\n+\n+    \/**\n+     * Set new contents. Old instruction is disposed and may not be used anymore.\n+     *\/\n+    @Override \/\/ This is only done in order to apply the additional type check; could be merged with super impl.\n+    public void setInstruction( final Instruction i ) { \/\/ TODO could be package-protected?\n+        super.setInstruction(i);\n+        if (!(i instanceof BranchInstruction)) {\n+            throw new ClassGenException(\"Assigning \" + i\n+                    + \" to branch handle which is not a branch instruction\");\n+        }\n+        bi = (BranchInstruction) i;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BranchHandle.java","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,3 @@\n- * Abstract super class for branching instructions like GOTO, IFEQ, etc.. Branch instructions may have a variable\n- * length, namely GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n+ * Abstract super class for branching instructions like GOTO, IFEQ, etc..\n+ * Branch instructions may have a variable length, namely GOTO, JSR,\n+ * LOOKUPSWITCH and TABLESWITCH.\n@@ -32,1 +33,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: July 2020\n@@ -36,0 +37,4 @@\n+    private int index; \/\/ Branch target relative to this instruction\n+    private InstructionHandle target; \/\/ Target object in instruction list\n+    private int position; \/\/ Byte code offset\n+\n@@ -37,1 +42,2 @@\n-     * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen\n+     * Empty constructor needed for the Class.newInstance() statement in\n+     * Instruction.readInstruction(). Not to be used otherwise.\n@@ -39,7 +45,1 @@\n-    static void notifyTarget(final InstructionHandle oldIh, final InstructionHandle newIh, final InstructionTargeter t) {\n-        if (oldIh != null) {\n-            oldIh.removeTargeter(t);\n-        }\n-        if (newIh != null) {\n-            newIh.addTargeter(t);\n-        }\n+    BranchInstruction() {\n@@ -48,5 +48,0 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int index; \/\/ Branch target relative to this instruction\n@@ -54,2 +49,3 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+    \/** Common super constructor\n+     * @param opcode Instruction opcode\n+     * @param target instruction to branch to\n@@ -57,2 +53,5 @@\n-    @Deprecated\n-    protected InstructionHandle target; \/\/ Target object in instruction list\n+    protected BranchInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, (short) 3);\n+        setTarget(target);\n+    }\n+\n@@ -61,1 +60,2 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n@@ -63,2 +63,10 @@\n-    @Deprecated\n-    protected int position; \/\/ Byte code offset\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        index = getTargetOffset();\n+        if (!isValidShort(index)) {\n+            throw new ClassGenException(\"Branch target offset too large for short: \" + index);\n+        }\n+        out.writeShort(index); \/\/ May be negative, i.e., point backwards\n+    }\n+\n@@ -67,1 +75,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * @param _target branch target\n+     * @return the offset to  `target' relative to this instruction\n@@ -69,1 +78,11 @@\n-    BranchInstruction() {\n+    protected int getTargetOffset( final InstructionHandle _target ) {\n+        if (_target == null) {\n+            throw new ClassGenException(\"Target of \" + super.toString(true)\n+                    + \" is invalid null handle\");\n+        }\n+        final int t = _target.getPosition();\n+        if (t < 0) {\n+            throw new ClassGenException(\"Invalid branch target position offset for \"\n+                    + super.toString(true) + \":\" + t + \":\" + _target);\n+        }\n+        return t - position;\n@@ -72,0 +91,1 @@\n+\n@@ -73,4 +93,1 @@\n-     * Common super constructor\n-     *\n-     * @param opcode Instruction opcode\n-     * @param target instruction to branch to\n+     * @return the offset to this instruction's target\n@@ -78,3 +95,2 @@\n-    protected BranchInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, (short) 3);\n-        setTarget(target);\n+    protected int getTargetOffset() {\n+        return getTargetOffset(target);\n@@ -83,0 +99,1 @@\n+\n@@ -84,1 +101,8 @@\n-     * @return true, if ih is target of this instruction\n+     * Called by InstructionList.setPositions when setting the position for every\n+     * instruction. In the presence of variable length instructions `setPositions'\n+     * performs multiple passes over the instruction list to calculate the\n+     * correct (byte) positions and offsets by calling this function.\n+     *\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n@@ -86,3 +110,3 @@\n-    @Override\n-    public boolean containsTarget(final InstructionHandle ih) {\n-        return target == ih;\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        position += offset;\n+        return 0;\n@@ -91,0 +115,1 @@\n+\n@@ -92,1 +117,9 @@\n-     * Inform target that it's not targeted anymore.\n+     * Long output format:\n+     *\n+     * &lt;position in byte code&gt;\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\"\n+     * \"&lt;\"&lt;target instruction&gt;\"&gt;\" \"@\"&lt;branch target offset&gt;\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -95,4 +128,25 @@\n-    void dispose() {\n-        setTarget(null);\n-        index = -1;\n-        position = -1;\n+    public String toString( final boolean verbose ) {\n+        final String s = super.toString(verbose);\n+        String t = \"null\";\n+        if (verbose) {\n+            if (target != null) {\n+                if (target.getInstruction() == this) {\n+                    t = \"<points to itself>\";\n+                } else if (target.getInstruction() == null) {\n+                    t = \"<null instruction!!!?>\";\n+                } else {\n+                    \/\/ I'm more interested in the address of the target then\n+                    \/\/ the instruction located there.\n+                    \/\/t = target.getInstruction().toString(false); \/\/ Avoid circles\n+                    t = \"\" + target.getPosition();\n+                }\n+            }\n+        } else {\n+            if (target != null) {\n+                index = target.getPosition();\n+                \/\/ index = getTargetOffset();  crashes if positions haven't been set\n+                \/\/ t = \"\" + (index + position);\n+                t = \"\" + index;\n+            }\n+        }\n+        return s + \" -> \" + t;\n@@ -101,0 +155,1 @@\n+\n@@ -102,1 +157,2 @@\n-     * Dump instruction as byte code to stream out.\n+     * Read needed data (e.g. index) from file. Conversion to a InstructionHandle\n+     * is done in InstructionList(byte[]).\n@@ -104,1 +160,3 @@\n-     * @param out Output stream\n+     * @param bytes input stream\n+     * @param wide wide prefix?\n+     * @see InstructionList\n@@ -107,7 +165,3 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        index = getTargetOffset();\n-        if (!isValidShort(index)) {\n-            throw new ClassGenException(\"Branch target offset too large for short: \" + index);\n-        }\n-        out.writeShort(index); \/\/ May be negative, i.e., point backwards\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(3);\n+        index = bytes.readShort();\n@@ -116,0 +170,1 @@\n+\n@@ -123,7 +178,0 @@\n-    \/**\n-     * @return the position\n-     * @since 6.0\n-     *\/\n-    protected int getPosition() {\n-        return position;\n-    }\n@@ -138,0 +186,1 @@\n+\n@@ -139,1 +188,2 @@\n-     * @return the offset to this instruction's target\n+     * Set branch target\n+     * @param target branch target\n@@ -141,2 +191,3 @@\n-    protected int getTargetOffset() {\n-        return getTargetOffset(target);\n+    public void setTarget( final InstructionHandle target ) {\n+        notifyTarget(this.target, target, this);\n+        this.target = target;\n@@ -145,0 +196,1 @@\n+\n@@ -146,2 +198,1 @@\n-     * @param target branch target\n-     * @return the offset to 'target' relative to this instruction\n+     * Used by BranchInstruction, LocalVariableGen, CodeExceptionGen, LineNumberGen\n@@ -149,3 +200,4 @@\n-    protected int getTargetOffset(final InstructionHandle target) {\n-        if (target == null) {\n-            throw new ClassGenException(\"Target of \" + super.toString(true) + \" is invalid null handle\");\n+    static void notifyTarget( final InstructionHandle old_ih, final InstructionHandle new_ih,\n+            final InstructionTargeter t ) {\n+        if (old_ih != null) {\n+            old_ih.removeTargeter(t);\n@@ -153,3 +205,2 @@\n-        final int t = target.getPosition();\n-        if (t < 0) {\n-            throw new ClassGenException(\"Invalid branch target position offset for \" + super.toString(true) + \":\" + t + \":\" + target);\n+        if (new_ih != null) {\n+            new_ih.addTargeter(t);\n@@ -157,1 +208,0 @@\n-        return t - position;\n@@ -160,0 +210,1 @@\n+\n@@ -161,5 +212,2 @@\n-     * Read needed data (e.g. index) from file. Conversion to a InstructionHandle is done in InstructionList(byte[]).\n-     *\n-     * @param bytes input stream\n-     * @param wide wide prefix?\n-     * @see InstructionList\n+     * @param old_ih old target\n+     * @param new_ih new target\n@@ -168,3 +216,6 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(3);\n-        index = bytes.readShort();\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        if (target == old_ih) {\n+            setTarget(new_ih);\n+        } else {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but \" + target);\n+        }\n@@ -173,7 +224,0 @@\n-    \/**\n-     * @param index the index to set\n-     * @since 6.0\n-     *\/\n-    protected void setIndex(final int index) {\n-        this.index = index;\n-    }\n@@ -182,2 +226,1 @@\n-     * @param position the position to set\n-     * @since 6.0\n+     * @return true, if ih is target of this instruction\n@@ -185,2 +228,3 @@\n-    protected void setPosition(final int position) {\n-        this.position = position;\n+    @Override\n+    public boolean containsTarget( final InstructionHandle ih ) {\n+        return target == ih;\n@@ -208,3 +252,1 @@\n-     * Set branch target\n-     *\n-     * @param target branch target\n+     * Inform target that it's not targeted anymore.\n@@ -212,3 +254,5 @@\n-    public void setTarget(final InstructionHandle target) {\n-        notifyTarget(this.target, target, this);\n-        this.target = target;\n+    @Override\n+    void dispose() {\n+        setTarget(null);\n+        index = -1;\n+        position = -1;\n@@ -217,0 +261,1 @@\n+\n@@ -218,7 +263,2 @@\n-     * Long output format:\n-     *\n-     * &lt;position in byte code&gt; &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\"\n-     * \"&lt;\"&lt;target instruction&gt;\"&gt;\" \"@\"&lt;branch target offset&gt;\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * @return the position\n+     * @since 6.0\n@@ -226,24 +266,2 @@\n-    @Override\n-    public String toString(final boolean verbose) {\n-        final String s = super.toString(verbose);\n-        String t = \"null\";\n-        if (target != null) {\n-            if (verbose) {\n-                if (target.getInstruction() == this) {\n-                    t = \"<points to itself>\";\n-                } else if (target.getInstruction() == null) {\n-                    t = \"<null instruction!!!?>\";\n-                } else {\n-                    \/\/ I'm more interested in the address of the target then\n-                    \/\/ the instruction located there.\n-                    \/\/ t = target.getInstruction().toString(false); \/\/ Avoid circles\n-                    t = \"\" + target.getPosition();\n-                }\n-            } else {\n-                index = target.getPosition();\n-                \/\/ index = getTargetOffset(); crashes if positions haven't been set\n-                \/\/ t = \"\" + (index + position);\n-                t = \"\" + index;\n-            }\n-        }\n-        return s + \" -> \" + t;\n+    protected int getPosition() {\n+        return position;\n@@ -252,0 +270,1 @@\n+\n@@ -253,7 +272,2 @@\n-     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n-     * length instructions 'setPositions' performs multiple passes over the instruction list to calculate the correct (byte)\n-     * positions and offsets by calling this function.\n-     *\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n+     * @param position the position to set\n+     * @since 6.0\n@@ -261,3 +275,2 @@\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        position += offset;\n-        return 0;\n+    protected void setPosition(final int position) {\n+        this.position = position;\n@@ -266,0 +279,1 @@\n+\n@@ -267,2 +281,2 @@\n-     * @param oldIh old target\n-     * @param newIh new target\n+     * @param index the index to set\n+     * @since 6.0\n@@ -270,6 +284,2 @@\n-    @Override\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        if (target != oldIh) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but \" + target);\n-        }\n-        setTarget(newIh);\n+    protected void setIndex(final int index) {\n+        this.index = index;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/BranchInstruction.java","additions":154,"deletions":144,"binary":false,"changes":298,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load char from array\n+    \/** Load char from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * CASTORE - Store into char array\n+ * CASTORE -  Store into char array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store char into array\n+    \/** Store char into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ..., objectref<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., objectref\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class CHECKCAST extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer, StackConsumer {\n+public class CHECKCAST extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer,\n+        StackConsumer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,3 +41,2 @@\n-    \/**\n-     * Check whether object is of given type\n-     *\n+\n+    \/** Check whether object is of given type\n@@ -50,0 +49,20 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.CLASS_CAST_EXCEPTION);\n+    }\n+\n+\n+    @Override\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+        Type t = getType(cpg);\n+        if (t instanceof ArrayType) {\n+            t = ((ArrayType) t).getBasicType();\n+        }\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n+    }\n+\n+\n@@ -51,2 +70,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -66,17 +87,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.CLASS_CAST_EXCEPTION);\n-    }\n-\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        Type t = getType(cpg);\n-        if (t instanceof ArrayType) {\n-            t = ((ArrayType) t).getBasicType();\n-        }\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CHECKCAST.java","additions":32,"deletions":28,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -32,1 +31,2 @@\n- * Abstract super class for instructions that use an index into the constant pool such as LDC, INVOKEVIRTUAL, etc.\n+ * Abstract super class for instructions that use an index into the\n+ * constant pool such as LDC, INVOKEVIRTUAL, etc.\n@@ -40,1 +40,4 @@\n-public abstract class CPInstruction extends Instruction implements TypedInstruction, IndexedInstruction {\n+public abstract class CPInstruction extends Instruction implements TypedInstruction,\n+        IndexedInstruction {\n+\n+    private int index; \/\/ index to constant pool\n@@ -42,5 +45,0 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int index; \/\/ index to constant pool\n@@ -49,1 +47,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -54,0 +53,1 @@\n+\n@@ -62,0 +62,1 @@\n+\n@@ -64,1 +65,0 @@\n-     *\n@@ -68,1 +68,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -73,0 +73,1 @@\n+\n@@ -74,1 +75,7 @@\n-     * @return index in constant pool referred by this instruction.\n+     * Long output format:\n+     *\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; constant pool index&gt;\"&gt;\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -77,2 +84,2 @@\n-    public final int getIndex() {\n-        return index;\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + index;\n@@ -81,0 +88,1 @@\n+\n@@ -82,1 +90,1 @@\n-     * @return type related with this instruction.\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -85,5 +93,5 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        String name = cp.getConstantString(index, com.sun.org.apache.bcel.internal.Const.CONSTANT_Class);\n-        if (!name.startsWith(\"[\")) {\n-            name = \"L\" + name + \";\";\n+    public String toString( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(index);\n+        String str = cp.constantToString(c);\n+        if (c instanceof ConstantClass) {\n+            str = str.replace('.', '\/');\n@@ -91,1 +99,1 @@\n-        return Type.getType(name);\n+        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + str;\n@@ -94,0 +102,1 @@\n+\n@@ -96,1 +105,0 @@\n-     *\n@@ -101,1 +109,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -106,0 +114,10 @@\n+\n+    \/**\n+     * @return index in constant pool referred by this instruction.\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return index;\n+    }\n+\n+\n@@ -108,2 +126,1 @@\n-     *\n-     * @param index in constant pool.\n+     * @param index in  constant pool.\n@@ -112,1 +129,1 @@\n-    public void setIndex(final int index) { \/\/ TODO could be package-protected?\n+    public void setIndex( final int index ) { \/\/ TODO could be package-protected?\n@@ -119,13 +136,0 @@\n-    \/**\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; constant pool\n-     * index&gt;\"&gt;\"\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + index;\n-    }\n@@ -133,2 +137,1 @@\n-    \/**\n-     * @return mnemonic for instruction with symbolic references resolved\n+    \/** @return type related with this instruction.\n@@ -137,5 +140,5 @@\n-    public String toString(final ConstantPool cp) {\n-        final Constant c = cp.getConstant(index);\n-        String str = cp.constantToString(c);\n-        if (c instanceof ConstantClass) {\n-            str = Utility.packageToPath(str);\n+    public Type getType( final ConstantPoolGen cpg ) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        String name = cp.getConstantString(index, com.sun.org.apache.bcel.internal.Const.CONSTANT_Class);\n+        if (!name.startsWith(\"[\")) {\n+            name = \"L\" + name + \";\";\n@@ -143,1 +146,1 @@\n-        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + str;\n+        return Type.getType(name);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CPInstruction.java","additions":50,"deletions":47,"binary":false,"changes":97,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-public class ClassElementValueGen extends ElementValueGen {\n+public class ClassElementValueGen extends ElementValueGen\n+{\n@@ -38,1 +39,1 @@\n-    private final int idx;\n+    private int idx;\n@@ -40,11 +41,2 @@\n-    public ClassElementValueGen(final ClassElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(CLASS, cpool);\n-        if (copyPoolEntries) {\n-            \/\/ idx = cpool.addClass(value.getClassString());\n-            idx = cpool.addUtf8(value.getClassString());\n-        } else {\n-            idx = value.getIndex();\n-        }\n-    }\n-\n-    protected ClassElementValueGen(final int typeIdx, final ConstantPoolGen cpool) {\n+    protected ClassElementValueGen(final int typeIdx, final ConstantPoolGen cpool)\n+    {\n@@ -55,1 +47,2 @@\n-    public ClassElementValueGen(final ObjectType t, final ConstantPoolGen cpool) {\n+    public ClassElementValueGen(final ObjectType t, final ConstantPoolGen cpool)\n+    {\n@@ -61,0 +54,3 @@\n+    \/**\n+     * Return immutable variant of this ClassElementValueGen\n+     *\/\n@@ -62,3 +58,5 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n-        dos.writeShort(idx);\n+    public ElementValue getElementValue()\n+    {\n+        return new ClassElementValue(super.getElementValueType(),\n+                idx,\n+                getConstantPool().getConstantPool());\n@@ -67,1 +65,22 @@\n-    public String getClassString() {\n+    public ClassElementValueGen(final ClassElementValue value, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n+        super(CLASS, cpool);\n+        if (copyPoolEntries)\n+        {\n+            \/\/ idx = cpool.addClass(value.getClassString());\n+            idx = cpool.addUtf8(value.getClassString());\n+        }\n+        else\n+        {\n+            idx = value.getIndex();\n+        }\n+    }\n+\n+    public int getIndex()\n+    {\n+        return idx;\n+    }\n+\n+    public String getClassString()\n+    {\n@@ -76,3 +95,0 @@\n-    \/**\n-     * Return immutable variant of this ClassElementValueGen\n-     *\/\n@@ -80,6 +96,3 @@\n-    public ElementValue getElementValue() {\n-        return new ClassElementValue(super.getElementValueType(), idx, getConstantPool().getConstantPool());\n-    }\n-\n-    public int getIndex() {\n-        return idx;\n+    public String stringifyValue()\n+    {\n+        return getClassString();\n@@ -89,2 +102,4 @@\n-    public String stringifyValue() {\n-        return getClassString();\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n+        dos.writeShort(idx);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassElementValueGen.java","additions":44,"deletions":29,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import java.util.Arrays;\n-import java.util.Collections;\n@@ -30,0 +28,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;\n@@ -39,1 +38,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -43,1 +41,2 @@\n- * Template class for building up a java class. May be initialized with an existing java class (file).\n+ * Template class for building up a java class. May be initialized with an\n+ * existing java class (file).\n@@ -46,1 +45,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -50,0 +49,17 @@\n+    \/* Corresponds to the fields found in a JavaClass object.\n+     *\/\n+    private String className;\n+    private String superClassName;\n+    private final String fileName;\n+    private int classNameIndex = -1;\n+    private int superclass_name_index = -1;\n+    private int major = Const.MAJOR_1_1;\n+    private int minor = Const.MINOR_1_1;\n+    private ConstantPoolGen cp; \/\/ Template for building up constant pool\n+    \/\/ ArrayLists instead of arrays to gather fields, methods, etc.\n+    private final List<Field> fieldList = new ArrayList<>();\n+    private final List<Method> methodList = new ArrayList<>();\n+    private final List<Attribute> attributeList = new ArrayList<>();\n+    private final List<String> interfaceList = new ArrayList<>();\n+    private final List<AnnotationEntryGen> annotationList = new ArrayList<>();\n+\n@@ -53,1 +69,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -59,0 +75,1 @@\n+\n@@ -60,1 +77,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -66,6 +83,0 @@\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n@@ -73,2 +84,8 @@\n-    \/**\n-     * @param comparator Comparison strategy object\n+    \/** Convenience constructor to set up some important values initially.\n+     *\n+     * @param className fully qualified class name\n+     * @param superClassName fully qualified superclass name\n+     * @param fileName source file name\n+     * @param accessFlags access qualifiers\n+     * @param interfaces implemented interfaces\n+     * @param cp constant pool to use\n@@ -76,2 +93,19 @@\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags,\n+            final String[] interfaces, final ConstantPoolGen cp) {\n+        super(accessFlags);\n+        this.className = className;\n+        this.superClassName = superClassName;\n+        this.fileName = fileName;\n+        this.cp = cp;\n+        \/\/ Put everything needed by default into the constant pool and the vectors\n+        if (fileName != null) {\n+            addAttribute(new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp\n+                    .getConstantPool()));\n+        }\n+        classNameIndex = cp.addClass(className);\n+        superclass_name_index = cp.addClass(superClassName);\n+        if (interfaces != null) {\n+            for (final String interface1 : interfaces) {\n+                addInterface(interface1);\n+            }\n+        }\n@@ -80,14 +114,0 @@\n-    \/*\n-     * Corresponds to the fields found in a JavaClass object.\n-     *\/\n-    private String className;\n-    private String superClassName;\n-    private final String fileName;\n-    private int classNameIndex = -1;\n-    private int superclassNameIndex = -1;\n-    private int major = Const.MAJOR_1_1;\n-    private int minor = Const.MINOR_1_1;\n-    private ConstantPoolGen cp; \/\/ Template for building up constant pool\n-    \/\/ ArrayLists instead of arrays to gather fields, methods, etc.\n-    private final List<Field> fieldList = new ArrayList<>();\n-    private final List<Method> methodList = new ArrayList<>();\n@@ -95,5 +115,13 @@\n-    private final List<Attribute> attributeList = new ArrayList<>();\n-\n-    private final List<String> interfaceList = new ArrayList<>();\n-\n-    private final List<AnnotationEntryGen> annotationList = new ArrayList<>();\n+    \/** Convenience constructor to set up some important values initially.\n+     *\n+     * @param className fully qualified class name\n+     * @param superClassName fully qualified superclass name\n+     * @param fileName source file name\n+     * @param accessFlags access qualifiers\n+     * @param interfaces implemented interfaces\n+     *\/\n+    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags,\n+            final String[] interfaces) {\n+        this(className, superClassName, fileName, accessFlags, interfaces,\n+                new ConstantPoolGen());\n+    }\n@@ -101,1 +129,0 @@\n-    private List<ClassObserver> observers;\n@@ -105,1 +132,0 @@\n-     *\n@@ -111,1 +137,1 @@\n-        superclassNameIndex = clazz.getSuperclassNameIndex();\n+        superclass_name_index = clazz.getSuperclassNameIndex();\n@@ -121,1 +147,6 @@\n-        Collections.addAll(interfaceList, clazz.getInterfaceNames());\n+        final Method[] methods = clazz.getMethods();\n+        final Field[] fields = clazz.getFields();\n+        final String[] interfaces = clazz.getInterfaceNames();\n+        for (final String interface1 : interfaces) {\n+            addInterface(interface1);\n+        }\n@@ -127,3 +158,9 @@\n-        Collections.addAll(annotationList, annotations);\n-        Collections.addAll(methodList, clazz.getMethods());\n-        Collections.addAll(fieldList, clazz.getFields());\n+        for (final AnnotationEntryGen annotation : annotations) {\n+            addAnnotationEntry(annotation);\n+        }\n+        for (final Method method : methods) {\n+            addMethod(method);\n+        }\n+        for (final Field field : fields) {\n+            addField(field);\n+        }\n@@ -133,7 +170,1 @@\n-     * Convenience constructor to set up some important values initially.\n-     *\n-     * @param className fully qualified class name\n-     * @param superClassName fully qualified superclass name\n-     * @param fileName source file name\n-     * @param accessFlags access qualifiers\n-     * @param interfaces implemented interfaces\n+     * Look for attributes representing annotations and unpack them.\n@@ -141,2 +172,25 @@\n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces) {\n-        this(className, superClassName, fileName, accessFlags, interfaces, new ConstantPoolGen());\n+    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs)\n+    {\n+        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<>();\n+        for (final Attribute attr : attrs) {\n+            if (attr instanceof RuntimeVisibleAnnotations)\n+            {\n+                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n+                final AnnotationEntry[] annos = rva.getAnnotationEntries();\n+                for (final AnnotationEntry a : annos) {\n+                    annotationGenObjs.add(new AnnotationEntryGen(a,\n+                            getConstantPool(), false));\n+                }\n+            }\n+            else\n+                if (attr instanceof RuntimeInvisibleAnnotations)\n+                {\n+                    final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n+                    final AnnotationEntry[] annos = ria.getAnnotationEntries();\n+                    for (final AnnotationEntry a : annos) {\n+                        annotationGenObjs.add(new AnnotationEntryGen(a,\n+                                getConstantPool(), false));\n+                    }\n+                }\n+        }\n+        return annotationGenObjs.toArray(new AnnotationEntryGen[annotationGenObjs.size()]);\n@@ -145,0 +199,1 @@\n+\n@@ -146,8 +201,1 @@\n-     * Convenience constructor to set up some important values initially.\n-     *\n-     * @param className fully qualified class name\n-     * @param superClassName fully qualified superclass name\n-     * @param fileName source file name\n-     * @param accessFlags access qualifiers\n-     * @param interfaces implemented interfaces\n-     * @param cp constant pool to use\n+     * @return the (finally) built up Java class object.\n@@ -155,15 +203,13 @@\n-    public ClassGen(final String className, final String superClassName, final String fileName, final int accessFlags, final String[] interfaces,\n-        final ConstantPoolGen cp) {\n-        super(accessFlags);\n-        this.className = className;\n-        this.superClassName = superClassName;\n-        this.fileName = fileName;\n-        this.cp = cp;\n-        \/\/ Put everything needed by default into the constant pool and the vectors\n-        if (fileName != null) {\n-            addAttribute(new SourceFile(cp.addUtf8(\"SourceFile\"), 2, cp.addUtf8(fileName), cp.getConstantPool()));\n-        }\n-        classNameIndex = cp.addClass(className);\n-        superclassNameIndex = cp.addClass(superClassName);\n-        if (interfaces != null) {\n-            Collections.addAll(interfaceList, interfaces);\n+    public JavaClass getJavaClass() {\n+        final int[] interfaces = getInterfaces();\n+        final Field[] fields = getFields();\n+        final Method[] methods = getMethods();\n+        Attribute[] attributes = null;\n+        if (annotationList.isEmpty()) {\n+            attributes = getAttributes();\n+        } else {\n+            \/\/ TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'\n+            final Attribute[] annAttributes  = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());\n+            attributes = new Attribute[attributeList.size()+annAttributes.length];\n+            attributeList.toArray(attributes);\n+            System.arraycopy(annAttributes,0,attributes,attributeList.size(),annAttributes.length);\n@@ -171,0 +217,4 @@\n+        \/\/ Must be last since the above calls may still add something to it\n+        final ConstantPool _cp = this.cp.getFinalConstantPool();\n+        return new JavaClass(classNameIndex, superclass_name_index, fileName, major, minor,\n+                super.getAccessFlags(), _cp, interfaces, fields, methods, attributes);\n@@ -173,2 +223,7 @@\n-    public void addAnnotationEntry(final AnnotationEntryGen a) {\n-        annotationList.add(a);\n+\n+    \/**\n+     * Add an interface to this class, i.e., this class has to implement it.\n+     * @param name interface to implement (fully qualified class name)\n+     *\/\n+    public void addInterface( final String name ) {\n+        interfaceList.add(name);\n@@ -177,0 +232,1 @@\n+\n@@ -178,3 +234,2 @@\n-     * Add an attribute to this class.\n-     *\n-     * @param a attribute to add\n+     * Remove an interface from this class.\n+     * @param name interface to remove (fully qualified name)\n@@ -182,2 +237,2 @@\n-    public void addAttribute(final Attribute a) {\n-        attributeList.add(a);\n+    public void removeInterface( final String name ) {\n+        interfaceList.remove(name);\n@@ -186,0 +241,1 @@\n+\n@@ -187,5 +243,1 @@\n-     * Convenience method.\n-     *\n-     * Add an empty constructor to this class that does nothing but calling super().\n-     *\n-     * @param accessFlags rights for constructor\n+     * @return major version number of class file\n@@ -193,8 +245,18 @@\n-    public void addEmptyConstructor(final int accessFlags) {\n-        final InstructionList il = new InstructionList();\n-        il.append(InstructionConst.THIS); \/\/ Push 'this'\n-        il.append(new INVOKESPECIAL(cp.addMethodref(superClassName, Const.CONSTRUCTOR_NAME, \"()V\")));\n-        il.append(InstructionConst.RETURN);\n-        final MethodGen mg = new MethodGen(accessFlags, Type.VOID, Type.NO_ARGS, null, Const.CONSTRUCTOR_NAME, className, il, cp);\n-        mg.setMaxStack(1);\n-        addMethod(mg.getMethod());\n+    public int getMajor() {\n+        return major;\n+    }\n+\n+\n+    \/** Set major version number of class file, default value is 45 (JDK 1.1)\n+     * @param major major version number\n+     *\/\n+    public void setMajor( final int major ) { \/\/ TODO could be package-protected - only called by test code\n+        this.major = major;\n+    }\n+\n+\n+    \/** Set minor version number of class file, default value is 3 (JDK 1.1)\n+     * @param minor minor version number\n+     *\/\n+    public void setMinor( final int minor ) {  \/\/ TODO could be package-protected - only called by test code\n+        this.minor = minor;\n@@ -204,3 +266,1 @@\n-     * Add a field to this class.\n-     *\n-     * @param f field to add\n+     * @return minor version number of class file\n@@ -208,2 +268,2 @@\n-    public void addField(final Field f) {\n-        fieldList.add(f);\n+    public int getMinor() {\n+        return minor;\n@@ -212,0 +272,1 @@\n+\n@@ -213,3 +274,2 @@\n-     * Add an interface to this class, i.e., this class has to implement it.\n-     *\n-     * @param name interface to implement (fully qualified class name)\n+     * Add an attribute to this class.\n+     * @param a attribute to add\n@@ -217,2 +277,6 @@\n-    public void addInterface(final String name) {\n-        interfaceList.add(name);\n+    public void addAttribute( final Attribute a ) {\n+        attributeList.add(a);\n+    }\n+\n+    public void addAnnotationEntry(final AnnotationEntryGen a) {\n+        annotationList.add(a);\n@@ -221,0 +285,1 @@\n+\n@@ -223,1 +288,0 @@\n-     *\n@@ -226,1 +290,1 @@\n-    public void addMethod(final Method m) {\n+    public void addMethod( final Method m ) {\n@@ -230,0 +294,1 @@\n+\n@@ -231,1 +296,4 @@\n-     * Add observer for this object.\n+     * Convenience method.\n+     *\n+     * Add an empty constructor to this class that does nothing but calling super().\n+     * @param access_flags rights for constructor\n@@ -233,5 +301,9 @@\n-    public void addObserver(final ClassObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n+    public void addEmptyConstructor( final int access_flags ) {\n+        final InstructionList il = new InstructionList();\n+        il.append(InstructionConst.THIS); \/\/ Push `this'\n+        il.append(new INVOKESPECIAL(cp.addMethodref(superClassName, \"<init>\", \"()V\")));\n+        il.append(InstructionConst.RETURN);\n+        final MethodGen mg = new MethodGen(access_flags, Type.VOID, Type.NO_ARGS, null, \"<init>\",\n+                className, il, cp);\n+        mg.setMaxStack(1);\n+        addMethod(mg.getMethod());\n@@ -240,7 +312,7 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n+\n+    \/**\n+     * Add a field to this class.\n+     * @param f field to add\n+     *\/\n+    public void addField( final Field f ) {\n+        fieldList.add(f);\n@@ -249,1 +321,2 @@\n-    public boolean containsField(final Field f) {\n+\n+    public boolean containsField( final Field f ) {\n@@ -253,2 +326,2 @@\n-    \/**\n-     * @return field object with given name, or null\n+\n+    \/** @return field object with given name, or null\n@@ -256,1 +329,1 @@\n-    public Field containsField(final String name) {\n+    public Field containsField( final String name ) {\n@@ -265,2 +338,2 @@\n-    \/**\n-     * @return method object with given name and signature, or null\n+\n+    \/** @return method object with given name and signature, or null\n@@ -268,1 +341,1 @@\n-    public Method containsMethod(final String name, final String signature) {\n+    public Method containsMethod( final String name, final String signature ) {\n@@ -277,0 +350,1 @@\n+\n@@ -278,4 +352,2 @@\n-     * Return value as defined by given BCELComparator strategy. By default two ClassGen objects are said to be equal when\n-     * their class names are equal.\n-     *\n-     * @see Object#equals(Object)\n+     * Remove an attribute from this class.\n+     * @param a attribute to remove\n@@ -283,3 +355,2 @@\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n+    public void removeAttribute( final Attribute a ) {\n+        attributeList.remove(a);\n@@ -288,3 +359,7 @@\n-    \/\/ J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?\n-    public AnnotationEntryGen[] getAnnotationEntries() {\n-        return annotationList.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n+\n+    \/**\n+     * Remove a method from this class.\n+     * @param m method to remove\n+     *\/\n+    public void removeMethod( final Method m ) {\n+        methodList.remove(m);\n@@ -293,2 +368,14 @@\n-    public Attribute[] getAttributes() {\n-        return attributeList.toArray(Attribute.EMPTY_ARRAY);\n+\n+    \/** Replace given method with new one. If the old one does not exist\n+     * add the new_ method to the class anyway.\n+     *\/\n+    public void replaceMethod( final Method old, final Method new_ ) {\n+        if (new_ == null) {\n+            throw new ClassGenException(\"Replacement method must not be null\");\n+        }\n+        final int i = methodList.indexOf(old);\n+        if (i < 0) {\n+            methodList.add(new_);\n+        } else {\n+            methodList.set(i, new_);\n+        }\n@@ -297,2 +384,14 @@\n-    public String getClassName() {\n-        return className;\n+\n+    \/** Replace given field with new one. If the old one does not exist\n+     * add the new_ field to the class anyway.\n+     *\/\n+    public void replaceField( final Field old, final Field new_ ) {\n+        if (new_ == null) {\n+            throw new ClassGenException(\"Replacement method must not be null\");\n+        }\n+        final int i = fieldList.indexOf(old);\n+        if (i < 0) {\n+            fieldList.add(new_);\n+        } else {\n+            fieldList.set(i, new_);\n+        }\n@@ -301,2 +400,7 @@\n-    public int getClassNameIndex() {\n-        return classNameIndex;\n+\n+    \/**\n+     * Remove a field to this class.\n+     * @param f field to remove\n+     *\/\n+    public void removeField( final Field f ) {\n+        fieldList.remove(f);\n@@ -305,2 +409,3 @@\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n+\n+    public String getClassName() {\n+        return className;\n@@ -309,2 +414,3 @@\n-    public Field[] getFields() {\n-        return fieldList.toArray(Field.EMPTY_ARRAY);\n+\n+    public String getSuperclassName() {\n+        return superClassName;\n@@ -313,0 +419,1 @@\n+\n@@ -317,0 +424,36 @@\n+\n+    public void setClassName( final String name ) {\n+        className = name.replace('\/', '.');\n+        classNameIndex = cp.addClass(name);\n+    }\n+\n+\n+    public void setSuperclassName( final String name ) {\n+        superClassName = name.replace('\/', '.');\n+        superclass_name_index = cp.addClass(name);\n+    }\n+\n+\n+    public Method[] getMethods() {\n+        return methodList.toArray(new Method[methodList.size()]);\n+    }\n+\n+\n+    public void setMethods( final Method[] methods ) {\n+        methodList.clear();\n+        for (final Method method : methods) {\n+            addMethod(method);\n+        }\n+    }\n+\n+\n+    public void setMethodAt( final Method method, final int pos ) {\n+        methodList.set(pos, method);\n+    }\n+\n+\n+    public Method getMethodAt( final int pos ) {\n+        return methodList.get(pos);\n+    }\n+\n+\n@@ -318,1 +461,4 @@\n-        return interfaceList.toArray(Const.EMPTY_STRING_ARRAY);\n+        final int size = interfaceList.size();\n+        final String[] interfaces = new String[size];\n+        interfaceList.toArray(interfaces);\n+        return interfaces;\n@@ -321,0 +467,1 @@\n+\n@@ -324,1 +471,3 @@\n-        Arrays.setAll(interfaces, i -> cp.addClass(interfaceList.get(i)));\n+        for (int i = 0; i < size; i++) {\n+            interfaces[i] = cp.addClass(interfaceList.get(i));\n+        }\n@@ -328,22 +477,0 @@\n-    \/**\n-     * @return the (finally) built up Java class object.\n-     *\/\n-    public JavaClass getJavaClass() {\n-        final int[] interfaces = getInterfaces();\n-        final Field[] fields = getFields();\n-        final Method[] methods = getMethods();\n-        Attribute[] attributes = null;\n-        if (annotationList.isEmpty()) {\n-            attributes = getAttributes();\n-        } else {\n-            \/\/ TODO: Sometime later, trash any attributes called 'RuntimeVisibleAnnotations' or 'RuntimeInvisibleAnnotations'\n-            final Attribute[] annAttributes = AnnotationEntryGen.getAnnotationAttributes(cp, getAnnotationEntries());\n-            attributes = new Attribute[attributeList.size() + annAttributes.length];\n-            attributeList.toArray(attributes);\n-            System.arraycopy(annAttributes, 0, attributes, attributeList.size(), annAttributes.length);\n-        }\n-        \/\/ Must be last since the above calls may still add something to it\n-        final ConstantPool cp = this.cp.getFinalConstantPool();\n-        return new JavaClass(classNameIndex, superclassNameIndex, fileName, major, minor, super.getAccessFlags(), cp, interfaces, fields, methods,\n-            attributes);\n-    }\n@@ -351,5 +478,2 @@\n-    \/**\n-     * @return major version number of class file\n-     *\/\n-    public int getMajor() {\n-        return major;\n+    public Field[] getFields() {\n+        return fieldList.toArray(new Field[fieldList.size()]);\n@@ -358,3 +482,0 @@\n-    public Method getMethodAt(final int pos) {\n-        return methodList.get(pos);\n-    }\n@@ -362,2 +483,2 @@\n-    public Method[] getMethods() {\n-        return methodList.toArray(Method.EMPTY_ARRAY);\n+    public Attribute[] getAttributes() {\n+        return attributeList.toArray(new Attribute[attributeList.size()]);\n@@ -366,5 +487,3 @@\n-    \/**\n-     * @return minor version number of class file\n-     *\/\n-    public int getMinor() {\n-        return minor;\n+    \/\/  J5TODO: Should we make calling unpackAnnotations() lazy and put it in here?\n+    public AnnotationEntryGen[] getAnnotationEntries() {\n+        return annotationList.toArray(new AnnotationEntryGen[annotationList.size()]);\n@@ -373,2 +492,3 @@\n-    public String getSuperclassName() {\n-        return superClassName;\n+\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n@@ -377,2 +497,3 @@\n-    public int getSuperclassNameIndex() {\n-        return superclassNameIndex;\n+\n+    public void setConstantPool( final ConstantPoolGen constant_pool ) {\n+        cp = constant_pool;\n@@ -381,8 +502,5 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the class name.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n+\n+    public void setClassNameIndex( final int class_name_index ) {\n+        this.classNameIndex = class_name_index;\n+        className = cp.getConstantPool().getConstantString(class_name_index,\n+                Const.CONSTANT_Class).replace('\/', '.');\n@@ -391,7 +509,5 @@\n-    \/**\n-     * Remove an attribute from this class.\n-     *\n-     * @param a attribute to remove\n-     *\/\n-    public void removeAttribute(final Attribute a) {\n-        attributeList.remove(a);\n+\n+    public void setSuperclassNameIndex( final int superclass_name_index ) {\n+        this.superclass_name_index = superclass_name_index;\n+        superClassName = cp.getConstantPool().getConstantString(superclass_name_index,\n+                Const.CONSTANT_Class).replace('\/', '.');\n@@ -400,7 +516,3 @@\n-    \/**\n-     * Remove a field to this class.\n-     *\n-     * @param f field to remove\n-     *\/\n-    public void removeField(final Field f) {\n-        fieldList.remove(f);\n+\n+    public int getSuperclassNameIndex() {\n+        return superclass_name_index;\n@@ -409,7 +521,3 @@\n-    \/**\n-     * Remove an interface from this class.\n-     *\n-     * @param name interface to remove (fully qualified name)\n-     *\/\n-    public void removeInterface(final String name) {\n-        interfaceList.remove(name);\n+\n+    public int getClassNameIndex() {\n+        return classNameIndex;\n@@ -418,4 +526,4 @@\n-    \/**\n-     * Remove a method from this class.\n-     *\n-     * @param m method to remove\n+    private List<ClassObserver> observers;\n+\n+\n+    \/** Add observer for this object.\n@@ -423,2 +531,5 @@\n-    public void removeMethod(final Method m) {\n-        methodList.remove(m);\n+    public void addObserver( final ClassObserver o ) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n@@ -427,2 +538,2 @@\n-    \/**\n-     * Remove observer for this object.\n+\n+    \/** Remove observer for this object.\n@@ -430,1 +541,1 @@\n-    public void removeObserver(final ClassObserver o) {\n+    public void removeObserver( final ClassObserver o ) {\n@@ -436,14 +547,0 @@\n-    \/**\n-     * Replace given field with new one. If the old one does not exist add the new_ field to the class anyway.\n-     *\/\n-    public void replaceField(final Field old, final Field newField) {\n-        if (newField == null) {\n-            throw new ClassGenException(\"Replacement method must not be null\");\n-        }\n-        final int i = fieldList.indexOf(old);\n-        if (i < 0) {\n-            fieldList.add(newField);\n-        } else {\n-            fieldList.set(i, newField);\n-        }\n-    }\n@@ -451,2 +548,3 @@\n-    \/**\n-     * Replace given method with new one. If the old one does not exist add the newMethod method to the class anyway.\n+    \/** Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be\n+     * called by the user after he has finished editing the object.\n@@ -454,9 +552,5 @@\n-    public void replaceMethod(final Method old, final Method newMethod) {\n-        if (newMethod == null) {\n-            throw new ClassGenException(\"Replacement method must not be null\");\n-        }\n-        final int i = methodList.indexOf(old);\n-        if (i < 0) {\n-            methodList.add(newMethod);\n-        } else {\n-            methodList.set(i, newMethod);\n+    public void update() {\n+        if (observers != null) {\n+            for (final ClassObserver observer : observers) {\n+                observer.notify(this);\n+            }\n@@ -466,4 +560,0 @@\n-    public void setClassName(final String name) {\n-        className = Utility.pathToPackage(name);\n-        classNameIndex = cp.addClass(name);\n-    }\n@@ -471,3 +561,7 @@\n-    public void setClassNameIndex(final int classNameIndex) {\n-        this.classNameIndex = classNameIndex;\n-        this.className = Utility.pathToPackage(cp.getConstantPool().getConstantString(classNameIndex, Const.CONSTANT_Class));\n+    @Override\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+        }\n@@ -476,3 +570,0 @@\n-    public void setConstantPool(final ConstantPoolGen constantPool) {\n-        cp = constantPool;\n-    }\n@@ -481,3 +572,1 @@\n-     * Set major version number of class file, default value is 45 (JDK 1.1)\n-     *\n-     * @param major major version number\n+     * @return Comparison strategy object\n@@ -485,6 +574,2 @@\n-    public void setMajor(final int major) { \/\/ TODO could be package-protected - only called by test code\n-        this.major = major;\n-    }\n-\n-    public void setMethodAt(final Method method, final int pos) {\n-        methodList.set(pos, method);\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n@@ -493,4 +578,0 @@\n-    public void setMethods(final Method[] methods) {\n-        methodList.clear();\n-        Collections.addAll(methodList, methods);\n-    }\n@@ -499,3 +580,1 @@\n-     * Set minor version number of class file, default value is 3 (JDK 1.1)\n-     *\n-     * @param minor minor version number\n+     * @param comparator Comparison strategy object\n@@ -503,7 +582,2 @@\n-    public void setMinor(final int minor) { \/\/ TODO could be package-protected - only called by test code\n-        this.minor = minor;\n-    }\n-\n-    public void setSuperclassName(final String name) {\n-        superClassName = Utility.pathToPackage(name);\n-        superclassNameIndex = cp.addClass(name);\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n@@ -512,4 +586,0 @@\n-    public void setSuperclassNameIndex(final int superclassNameIndex) {\n-        this.superclassNameIndex = superclassNameIndex;\n-        superClassName = Utility.pathToPackage(cp.getConstantPool().getConstantString(superclassNameIndex, Const.CONSTANT_Class));\n-    }\n@@ -518,1 +588,5 @@\n-     * Look for attributes representing annotations and unpack them.\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two ClassGen objects are said to be equal when\n+     * their class names are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n@@ -520,12 +594,3 @@\n-    private AnnotationEntryGen[] unpackAnnotations(final Attribute[] attrs) {\n-        final List<AnnotationEntryGen> annotationGenObjs = new ArrayList<>();\n-        for (final Attribute attr : attrs) {\n-            if (attr instanceof RuntimeVisibleAnnotations) {\n-                final RuntimeVisibleAnnotations rva = (RuntimeVisibleAnnotations) attr;\n-                rva.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n-            } else if (attr instanceof RuntimeInvisibleAnnotations) {\n-                final RuntimeInvisibleAnnotations ria = (RuntimeInvisibleAnnotations) attr;\n-                ria.forEach(a -> annotationGenObjs.add(new AnnotationEntryGen(a, getConstantPool(), false)));\n-            }\n-        }\n-        return annotationGenObjs.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n@@ -534,0 +599,1 @@\n+\n@@ -535,2 +601,4 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after they have finished editing the object.\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the class name.\n+     *\n+     * @see java.lang.Object#hashCode()\n@@ -538,6 +606,3 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final ClassObserver observer : observers) {\n-                observer.notify(this);\n-            }\n-        }\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassGen.java","additions":377,"deletions":312,"binary":false,"changes":689,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Thrown on internal exceptions.\n+ * Thrown on internal errors. Extends RuntimeException so it hasn't to be declared\n+ * in the throws clause every time.\n+ *\n@@ -32,0 +34,1 @@\n+        super();\n@@ -34,0 +37,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassGenException.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Implement this interface if you're interested in changes to a ClassGen object and register yourself with\n- * addObserver().\n+ * Implement this interface if you're interested in changes to a ClassGen object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(ClassGen clazz);\n+    void notify( ClassGen clazz );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ClassObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -26,4 +26,6 @@\n- * This class represents an exception handler, i.e., specifies the region where a handler is active and an instruction\n- * where the actual handling is done. pool as parameters. Opposed to the JVM specification the end of the handled region\n- * is set to be inclusive, i.e. all instructions between start and end are protected including the start and end\n- * instructions (handles) themselves. The end of the region is automatically mapped to be exclusive when calling\n+ * This class represents an exception handler, i.e., specifies the  region where\n+ * a handler is active and an instruction where the actual handling is done.\n+ * pool as parameters. Opposed to the JVM specification the end of the handled\n+ * region is set to be inclusive, i.e. all instructions between start and end\n+ * are protected including the start and end instructions (handles) themselves.\n+ * The end of the region is automatically mapped to be exclusive when calling\n@@ -32,3 +34,3 @@\n- * @see MethodGen\n- * @see CodeException\n- * @see InstructionHandle\n+ * @see     MethodGen\n+ * @see     CodeException\n+ * @see     InstructionHandle\n@@ -38,2 +40,0 @@\n-    static final CodeExceptionGen[] EMPTY_ARRAY = {};\n-\n@@ -45,0 +45,1 @@\n+\n@@ -46,2 +47,2 @@\n-     * Add an exception handler, i.e., specify region where a handler is active and an instruction where the actual handling\n-     * is done.\n+     * Add an exception handler, i.e., specify region where a handler is active and an\n+     * instruction where the actual handling is done.\n@@ -54,1 +55,2 @@\n-    public CodeExceptionGen(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc, final ObjectType catchType) {\n+    public CodeExceptionGen(final InstructionHandle startPc, final InstructionHandle endPc,\n+            final InstructionHandle handlerPc, final ObjectType catchType) {\n@@ -61,8 +63,0 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n-    }\n@@ -71,1 +65,7 @@\n-     * @return true, if ih is target of this handler\n+     * Get CodeException object.<BR>\n+     *\n+     * This relies on that the instruction list has already been dumped\n+     * to byte code or or that the `setPositions' methods has been\n+     * called for the instruction list.\n+     *\n+     * @param cp constant pool\n@@ -73,3 +73,4 @@\n-    @Override\n-    public boolean containsTarget(final InstructionHandle ih) {\n-        return startPc == ih || endPc == ih || handlerPc == ih;\n+    public CodeException getCodeException( final ConstantPoolGen cp ) {\n+        return new CodeException(startPc.getPosition(), endPc.getPosition()\n+                + endPc.getInstruction().getLength(), handlerPc.getPosition(),\n+                (catchType == null) ? 0 : cp.addClass(catchType));\n@@ -78,3 +79,7 @@\n-    \/** Gets the type of the Exception to catch, 'null' for ANY. *\/\n-    public ObjectType getCatchType() {\n-        return catchType;\n+\n+    \/* Set start of handler\n+     * @param startPc Start of handled region (inclusive)\n+     *\/\n+    public void setStartPC( final InstructionHandle start_pc ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.startPc, start_pc, this);\n+        this.startPc = start_pc;\n@@ -83,7 +88,3 @@\n-    \/**\n-     * Get CodeException object.<BR>\n-     *\n-     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n-     * has been called for the instruction list.\n-     *\n-     * @param cp constant pool\n+\n+    \/* Set end of handler\n+     * @param endPc End of handled region (inclusive)\n@@ -91,3 +92,3 @@\n-    public CodeException getCodeException(final ConstantPoolGen cp) {\n-        return new CodeException(startPc.getPosition(), endPc.getPosition() + endPc.getInstruction().getLength(), handlerPc.getPosition(),\n-            catchType == null ? 0 : cp.addClass(catchType));\n+    public void setEndPC( final InstructionHandle end_pc ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.endPc, end_pc, this);\n+        this.endPc = end_pc;\n@@ -96,2 +97,3 @@\n-    \/**\n-     * @return end of handled region (inclusive)\n+\n+    \/* Set handler code\n+     * @param handlerPc Start of handler\n@@ -99,2 +101,3 @@\n-    public InstructionHandle getEndPC() {\n-        return endPc;\n+    public void setHandlerPC( final InstructionHandle handler_pc ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.handlerPc, handler_pc, this);\n+        this.handlerPc = handler_pc;\n@@ -103,0 +106,1 @@\n+\n@@ -104,1 +108,2 @@\n-     * @return start of handler\n+     * @param old_ih old target, either start or end\n+     * @param new_ih new target\n@@ -106,2 +111,19 @@\n-    public InstructionHandle getHandlerPC() {\n-        return handlerPc;\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        boolean targeted = false;\n+        if (startPc == old_ih) {\n+            targeted = true;\n+            setStartPC(new_ih);\n+        }\n+        if (endPc == old_ih) {\n+            targeted = true;\n+            setEndPC(new_ih);\n+        }\n+        if (handlerPc == old_ih) {\n+            targeted = true;\n+            setHandlerPC(new_ih);\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but {\" + startPc + \", \"\n+                    + endPc + \", \" + handlerPc + \"}\");\n+        }\n@@ -110,0 +132,1 @@\n+\n@@ -111,1 +134,1 @@\n-     * @return start of handled region (inclusive)\n+     * @return true, if ih is target of this handler\n@@ -113,2 +136,3 @@\n-    public InstructionHandle getStartPC() {\n-        return startPc;\n+    @Override\n+    public boolean containsTarget( final InstructionHandle ih ) {\n+        return (startPc == ih) || (endPc == ih) || (handlerPc == ih);\n@@ -117,0 +141,1 @@\n+\n@@ -118,1 +143,1 @@\n-    public void setCatchType(final ObjectType catchType) {\n+    public void setCatchType( final ObjectType catchType ) {\n@@ -122,4 +147,8 @@\n-    \/*\n-     * Set end of handler\n-     *\n-     * @param endPc End of handled region (inclusive)\n+\n+    \/** Gets the type of the Exception to catch, 'null' for ANY. *\/\n+    public ObjectType getCatchType() {\n+        return catchType;\n+    }\n+\n+\n+    \/** @return start of handled region (inclusive)\n@@ -127,3 +156,2 @@\n-    public void setEndPC(final InstructionHandle endPc) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.endPc, endPc, this);\n-        this.endPc = endPc;\n+    public InstructionHandle getStartPC() {\n+        return startPc;\n@@ -132,4 +160,2 @@\n-    \/*\n-     * Set handler code\n-     *\n-     * @param handlerPc Start of handler\n+\n+    \/** @return end of handled region (inclusive)\n@@ -137,3 +163,2 @@\n-    public void setHandlerPC(final InstructionHandle handlerPc) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.handlerPc, handlerPc, this);\n-        this.handlerPc = handlerPc;\n+    public InstructionHandle getEndPC() {\n+        return endPc;\n@@ -142,4 +167,2 @@\n-    \/*\n-     * Set start of handler\n-     *\n-     * @param startPc Start of handled region (inclusive)\n+\n+    \/** @return start of handler\n@@ -147,3 +170,2 @@\n-    public void setStartPC(final InstructionHandle startPc) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.startPc, startPc, this);\n-        this.startPc = startPc;\n+    public InstructionHandle getHandlerPC() {\n+        return handlerPc;\n@@ -152,0 +174,1 @@\n+\n@@ -157,4 +180,1 @@\n-    \/**\n-     * @param oldIh old target, either start or end\n-     * @param newIh new target\n-     *\/\n+\n@@ -162,16 +182,5 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n-        if (startPc == oldIh) {\n-            targeted = true;\n-            setStartPC(newIh);\n-        }\n-        if (endPc == oldIh) {\n-            targeted = true;\n-            setEndPC(newIh);\n-        }\n-        if (handlerPc == oldIh) {\n-            targeted = true;\n-            setHandlerPC(newIh);\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but {\" + startPc + \", \" + endPc + \", \" + handlerPc + \"}\");\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CodeExceptionGen.java","additions":98,"deletions":89,"binary":false,"changes":187,"status":"modified"},{"patch":"@@ -25,4 +25,6 @@\n- * Wrapper class for 'compound' operations, virtual instructions that don't exist as byte code, but give a useful\n- * meaning. For example, the (virtual) PUSH instruction takes an arbitrary argument and produces the appropriate code at\n- * dump time (ICONST, LDC, BIPUSH, ...). Also you can use the SWITCH instruction as a useful template for either\n- * LOOKUPSWITCH or TABLESWITCH.\n+ * Wrapper class for `compound' operations, virtual instructions that\n+ * don't exist as byte code, but give a useful meaning. For example,\n+ * the (virtual) PUSH instruction takes an arbitray argument and produces the\n+ * appropiate code at dump time (ICONST, LDC, BIPUSH, ...). Also you can use the\n+ * SWITCH instruction as a useful template for either LOOKUPSWITCH or\n+ * TABLESWITCH.\n@@ -30,1 +32,2 @@\n- * The interface provides the possibility for the user to write 'templates' or 'macros' for such reusable code patterns.\n+ * The interface provides the possibilty for the user to write\n+ * `templates' or `macros' for such reuseable code patterns.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/CompoundInstruction.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,0 @@\n-import java.util.Arrays;\n@@ -31,1 +30,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.ConstantDynamic;\n@@ -43,1 +41,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -46,5 +43,8 @@\n- * This class is used to build up a constant pool. The user adds constants via 'addXXX' methods, 'addString',\n- * 'addClass', etc.. These methods return an index into the constant pool. Finally, 'getFinalConstantPool()' returns the\n- * constant pool built up. Intermediate versions of the constant pool can be obtained with 'getConstantPool()'. A\n- * constant pool has capacity for Constants.MAX_SHORT entries. Note that the first (0) is used by the JVM and that\n- * Double and Long constants need two slots.\n+ * This class is used to build up a constant pool. The user adds\n+ * constants via `addXXX' methods, `addString', `addClass',\n+ * etc.. These methods return an index into the constant\n+ * pool. Finally, `getFinalConstantPool()' returns the constant pool\n+ * built up. Intermediate versions of the constant pool can be\n+ * obtained with `getConstantPool()'. A constant pool has capacity for\n+ * Constants.MAX_SHORT entries. Note that the first (0) is used by the\n+ * JVM and that Double and Long constants need two slots.\n@@ -53,1 +53,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: June 2022\n@@ -56,1 +56,1 @@\n-\n+    public static final int CONSTANT_POOL_SIZE = 65535;\n@@ -58,0 +58,3 @@\n+    private int size;\n+    private Constant[] constants;\n+    private int index = 1; \/\/ First entry (0) used by JVM\n@@ -60,1 +63,0 @@\n-\n@@ -62,1 +64,0 @@\n-\n@@ -64,1 +65,0 @@\n-\n@@ -67,23 +67,1 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int size;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected Constant[] constants;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getSize()\n-     *\/\n-    @Deprecated\n-    protected int index = 1; \/\/ First entry (0) used by JVM\n-\n-    private final Map<String, Integer> stringTable = new HashMap<>();\n-\n-    private final Map<String, Integer> classTable = new HashMap<>();\n-\n-    private final Map<String, Integer> utf8Table = new HashMap<>();\n+    private static class Index {\n@@ -91,1 +69,1 @@\n-    private final Map<String, Integer> natTable = new HashMap<>();\n+        final int index;\n@@ -93,1 +71,0 @@\n-    private final Map<String, Integer> cpTable = new HashMap<>();\n@@ -95,6 +72,3 @@\n-    \/**\n-     * Constructs a new empty constant pool.\n-     *\/\n-    public ConstantPoolGen() {\n-        size = DEFAULT_BUFFER_SIZE;\n-        constants = new Constant[size];\n+        Index(final int i) {\n+            index = i;\n+        }\n@@ -103,0 +77,1 @@\n+\n@@ -104,1 +79,1 @@\n-     * Constructs a new instance with the given array of constants.\n+     * Initialize with given array of constants.\n@@ -116,2 +91,2 @@\n-        if (cs.length > Const.MAX_CP_ENTRIES) {\n-            throw new IllegalStateException(\"The number of constants \" + cs.length\n+        if (cs.length > CONSTANT_POOL_SIZE) {\n+            throw new RuntimeException(\"The number of constants \" + cs.length\n@@ -119,1 +94,1 @@\n-                    + Const.MAX_CP_ENTRIES);\n+                    + CONSTANT_POOL_SIZE);\n@@ -124,1 +99,1 @@\n-        size = Math.min(Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64), Const.MAX_CP_ENTRIES);\n+        size = Math.min(Math.max(DEFAULT_BUFFER_SIZE, cs.length + 64), CONSTANT_POOL_SIZE);\n@@ -132,0 +107,1 @@\n+\n@@ -139,1 +115,1 @@\n-                    stringTable.put(key, Integer.valueOf(i));\n+                    stringTable.put(key, new Index(i));\n@@ -146,1 +122,1 @@\n-                    classTable.put(key, Integer.valueOf(i));\n+                    classTable.put(key, new Index(i));\n@@ -150,2 +126,2 @@\n-                final ConstantUtf8 u8NameIdx = (ConstantUtf8) constants[n.getNameIndex()];\n-                final ConstantUtf8 u8SigIdx = (ConstantUtf8) constants[n.getSignatureIndex()];\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+                final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n@@ -153,1 +129,1 @@\n-                sb.append(u8NameIdx.getBytes());\n+                sb.append(u8.getBytes());\n@@ -155,1 +131,1 @@\n-                sb.append(u8SigIdx.getBytes());\n+                sb.append(u8_2.getBytes());\n@@ -160,1 +136,1 @@\n-                    natTable.put(key, Integer.valueOf(i));\n+                    natTable.put(key, new Index(i));\n@@ -166,1 +142,1 @@\n-                    utf8Table.put(key, Integer.valueOf(i));\n+                    utf8Table.put(key, new Index(i));\n@@ -170,1 +146,1 @@\n-                String className;\n+                String class_name;\n@@ -174,3 +150,3 @@\n-                    className = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());\n-                } else if (c instanceof ConstantDynamic) {\n-                    className = Integer.toString(((ConstantDynamic) m).getBootstrapMethodAttrIndex());\n+                    class_name = Integer.toString(((ConstantInvokeDynamic) m).getBootstrapMethodAttrIndex());\n+                    \/\/ since name can't begin with digit, can  use\n+                    \/\/ METHODREF_DELIM with out fear of duplicates.\n@@ -178,1 +154,1 @@\n-                    final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n+                final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n@@ -180,1 +156,1 @@\n-                    className = Utility.pathToPackage(u8.getBytes());\n+                    class_name = u8.getBytes().replace('\/', '.');\n@@ -185,1 +161,1 @@\n-                final String methodName = u8.getBytes();\n+                final String method_name = u8.getBytes();\n@@ -189,1 +165,0 @@\n-                \/\/ Since name cannot begin with digit, we can use METHODREF_DELIM without fear of duplicates\n@@ -197,1 +172,1 @@\n-                sb.append(className);\n+                sb.append(class_name);\n@@ -199,1 +174,1 @@\n-                sb.append(methodName);\n+                sb.append(method_name);\n@@ -206,1 +181,1 @@\n-                    cpTable.put(key, Integer.valueOf(i));\n+                    cpTable.put(key, new Index(i));\n@@ -208,0 +183,20 @@\n+            } else if (c == null) { \/\/ entries may be null\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantInteger) {\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantLong) {\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantFloat) {\n+                \/\/ nothing to do\n+            } else if (c instanceof ConstantDouble) {\n+                \/\/ nothing to do\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {\n+                \/\/ TODO should this be handled somehow?\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {\n+                \/\/ TODO should this be handled somehow?\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {\n+                \/\/ TODO should this be handled somehow?\n+            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {\n+                \/\/ TODO should this be handled somehow?\n+            } else {\n+                assert false : \"Unexpected constant type: \" + c.getClass().getName();\n@@ -209,22 +204,0 @@\n-\/\/            else if (c == null) { \/\/ entries may be null\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantInteger) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantLong) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantFloat) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof ConstantDouble) {\n-\/\/                \/\/ nothing to do\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodType) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantMethodHandle) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantModule) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else if (c instanceof com.sun.org.apache.bcel.internal.classfile.ConstantPackage) {\n-\/\/                \/\/ TODO should this be handled somehow?\n-\/\/            } else {\n-\/\/                \/\/ Not helpful, should throw an exception.\n-\/\/                assert false : \"Unexpected constant type: \" + c.getClass().getName();\n-\/\/            }\n@@ -234,0 +207,1 @@\n+\n@@ -235,3 +209,1 @@\n-     * Constructs a new instance with the given constant pool.\n-     *\n-     * @param cp the constant pool.\n+     * Initialize with given constant pool.\n@@ -243,0 +215,1 @@\n+\n@@ -244,2 +217,33 @@\n-     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY instruction, e.g. to the\n-     * ConstantPool.\n+     * Create empty constant pool.\n+     *\/\n+    public ConstantPoolGen() {\n+        size = DEFAULT_BUFFER_SIZE;\n+        constants = new Constant[size];\n+    }\n+\n+\n+    \/** Resize internal array of constants.\n+     *\/\n+    protected void adjustSize() {\n+        \/\/ 3 extra spaces are needed as some entries may take 3 slots\n+        if (index + 3 >= CONSTANT_POOL_SIZE) {\n+            throw new RuntimeException(\"The number of constants \" + (index + 3)\n+                    + \" is over the size limit of the constant pool: \"\n+                    + CONSTANT_POOL_SIZE);\n+        }\n+\n+        if (index + 3 >= size) {\n+            final Constant[] cs = constants;\n+            size *= 2;\n+            \/\/ the constant array shall not exceed the size of the constant pool\n+            size = Math.min(size, CONSTANT_POOL_SIZE);\n+            constants = new Constant[size];\n+            System.arraycopy(cs, 0, constants, 0, index);\n+        }\n+    }\n+\n+    private final Map<String, Index> stringTable = new HashMap<>();\n+\n+\n+    \/**\n+     * Look for ConstantString in ConstantPool containing String `str'.\n@@ -247,2 +251,2 @@\n-     * @param type type of array class\n-     * @return index of entry\n+     * @param str String to search for\n+     * @return index on success, -1 otherwise\n@@ -250,2 +254,3 @@\n-    public int addArrayClass(final ArrayType type) {\n-        return addClass_(type.getSignature());\n+    public int lookupString( final String str ) {\n+        final Index index = stringTable.get(str);\n+        return (index != null) ? index.index : -1;\n@@ -254,0 +259,1 @@\n+\n@@ -255,1 +261,1 @@\n-     * Add a new Class reference to the ConstantPool for a given type.\n+     * Add a new String constant to the ConstantPool, if it is not already in there.\n@@ -257,1 +263,1 @@\n-     * @param type Class to add\n+     * @param str String to add\n@@ -260,2 +266,14 @@\n-    public int addClass(final ObjectType type) {\n-        return addClass(type.getClassName());\n+    public int addString( final String str ) {\n+        int ret;\n+        if ((ret = lookupString(str)) != -1) {\n+            return ret; \/\/ Already in CP\n+        }\n+        final int utf8 = addUtf8(str);\n+        adjustSize();\n+        final ConstantString s = new ConstantString(utf8);\n+        ret = index;\n+        constants[index++] = s;\n+        if (!stringTable.containsKey(str)) {\n+            stringTable.put(str, new Index(ret));\n+        }\n+        return ret;\n@@ -264,0 +282,3 @@\n+    private final Map<String, Index> classTable = new HashMap<>();\n+\n+\n@@ -265,1 +286,1 @@\n-     * Add a new Class reference to the ConstantPool, if it is not already in there.\n+     * Look for ConstantClass in ConstantPool named `str'.\n@@ -267,2 +288,2 @@\n-     * @param str Class to add\n-     * @return index of entry\n+     * @param str String to search for\n+     * @return index on success, -1 otherwise\n@@ -270,2 +291,3 @@\n-    public int addClass(final String str) {\n-        return addClass_(Utility.packageToPath(str));\n+    public int lookupClass( final String str ) {\n+        final Index index = classTable.get(str.replace('.', '\/'));\n+        return (index != null) ? index.index : -1;\n@@ -274,4 +296,5 @@\n-    private int addClass_(final String clazz) {\n-        final int cpRet;\n-        if ((cpRet = lookupClass(clazz)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+\n+    private int addClass_( final String clazz ) {\n+        int ret;\n+        if ((ret = lookupClass(clazz)) != -1) {\n+            return ret; \/\/ Already in CP\n@@ -281,1 +304,1 @@\n-        final int ret = index;\n+        ret = index;\n@@ -283,1 +306,4 @@\n-        return computeIfAbsent(classTable, clazz, ret);\n+        if (!classTable.containsKey(clazz)) {\n+            classTable.put(clazz, new Index(ret));\n+        }\n+        return ret;\n@@ -286,0 +312,1 @@\n+\n@@ -287,1 +314,1 @@\n-     * Adds a constant from another ConstantPool and returns the new index.\n+     * Add a new Class reference to the ConstantPool, if it is not already in there.\n@@ -289,2 +316,1 @@\n-     * @param constant The constant to add.\n-     * @param cpGen Source pool.\n+     * @param str Class to add\n@@ -293,50 +319,41 @@\n-    public int addConstant(final Constant constant, final ConstantPoolGen cpGen) {\n-        final Constant[] constants = cpGen.getConstantPool().getConstantPool();\n-        switch (constant.getTag()) {\n-        case Const.CONSTANT_String: {\n-            final ConstantString s = (ConstantString) constant;\n-            final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];\n-            return addString(u8.getBytes());\n-        }\n-        case Const.CONSTANT_Class: {\n-            final ConstantClass s = (ConstantClass) constant;\n-            final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];\n-            return addClass(u8.getBytes());\n-        }\n-        case Const.CONSTANT_NameAndType: {\n-            final ConstantNameAndType n = (ConstantNameAndType) constant;\n-            final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n-            final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n-            return addNameAndType(u8.getBytes(), u8_2.getBytes());\n-        }\n-        case Const.CONSTANT_Utf8:\n-            return addUtf8(((ConstantUtf8) constant).getBytes());\n-        case Const.CONSTANT_Double:\n-            return addDouble(((ConstantDouble) constant).getBytes());\n-        case Const.CONSTANT_Float:\n-            return addFloat(((ConstantFloat) constant).getBytes());\n-        case Const.CONSTANT_Long:\n-            return addLong(((ConstantLong) constant).getBytes());\n-        case Const.CONSTANT_Integer:\n-            return addInteger(((ConstantInteger) constant).getBytes());\n-        case Const.CONSTANT_InterfaceMethodref:\n-        case Const.CONSTANT_Methodref:\n-        case Const.CONSTANT_Fieldref: {\n-            final ConstantCP m = (ConstantCP) constant;\n-            final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n-            final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];\n-            ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];\n-            final String className = Utility.pathToPackage(u8.getBytes());\n-            u8 = (ConstantUtf8) constants[n.getNameIndex()];\n-            final String name = u8.getBytes();\n-            u8 = (ConstantUtf8) constants[n.getSignatureIndex()];\n-            final String signature = u8.getBytes();\n-            switch (constant.getTag()) {\n-            case Const.CONSTANT_InterfaceMethodref:\n-                return addInterfaceMethodref(className, name, signature);\n-            case Const.CONSTANT_Methodref:\n-                return addMethodref(className, name, signature);\n-            case Const.CONSTANT_Fieldref:\n-                return addFieldref(className, name, signature);\n-            default: \/\/ Never reached\n-                throw new IllegalArgumentException(\"Unknown constant type \" + constant);\n+    public int addClass( final String str ) {\n+        return addClass_(str.replace('.', '\/'));\n+    }\n+\n+\n+    \/**\n+     * Add a new Class reference to the ConstantPool for a given type.\n+     *\n+     * @param type Class to add\n+     * @return index of entry\n+     *\/\n+    public int addClass( final ObjectType type ) {\n+        return addClass(type.getClassName());\n+    }\n+\n+\n+    \/**\n+     * Add a reference to an array class (e.g. String[][]) as needed by MULTIANEWARRAY\n+     * instruction, e.g. to the ConstantPool.\n+     *\n+     * @param type type of array class\n+     * @return index of entry\n+     *\/\n+    public int addArrayClass( final ArrayType type ) {\n+        return addClass_(type.getSignature());\n+    }\n+\n+\n+    \/**\n+     * Look for ConstantInteger in ConstantPool.\n+     *\n+     * @param n integer number to look for\n+     * @return index on success, -1 otherwise\n+     *\/\n+    public int lookupInteger( final int n ) {\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantInteger) {\n+                final ConstantInteger c = (ConstantInteger) constants[i];\n+                if (c.getBytes() == n) {\n+                    return i;\n+                }\n@@ -345,3 +362,1 @@\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown constant type \" + constant);\n-        }\n+        return -1;\n@@ -350,0 +365,1 @@\n+\n@@ -351,1 +367,1 @@\n-     * Add a new double constant to the ConstantPool, if it is not already in there.\n+     * Add a new Integer constant to the ConstantPool, if it is not already in there.\n@@ -353,1 +369,1 @@\n-     * @param n Double number to add\n+     * @param n integer number to add\n@@ -356,1 +372,1 @@\n-    public int addDouble(final double n) {\n+    public int addInteger( final int n ) {\n@@ -358,1 +374,1 @@\n-        if ((ret = lookupDouble(n)) != -1) {\n+        if ((ret = lookupInteger(n)) != -1) {\n@@ -363,2 +379,1 @@\n-        constants[index] = new ConstantDouble(n);\n-        index += 2; \/\/ Wastes one entry according to spec\n+        constants[index++] = new ConstantInteger(n);\n@@ -368,0 +383,1 @@\n+\n@@ -369,1 +385,1 @@\n-     * Add a new Fieldref constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantFloat in ConstantPool.\n@@ -371,4 +387,2 @@\n-     * @param className class name string to add\n-     * @param fieldName field name string to add\n-     * @param signature signature string to add\n-     * @return index of entry\n+     * @param n Float number to look for\n+     * @return index on success, -1 otherwise\n@@ -376,4 +390,9 @@\n-    public int addFieldref(final String className, final String fieldName, final String signature) {\n-        final int cpRet;\n-        if ((cpRet = lookupFieldref(className, fieldName, signature)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+    public int lookupFloat( final float n ) {\n+        final int bits = Float.floatToIntBits(n);\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantFloat) {\n+                final ConstantFloat c = (ConstantFloat) constants[i];\n+                if (Float.floatToIntBits(c.getBytes()) == bits) {\n+                    return i;\n+                }\n+            }\n@@ -381,6 +400,1 @@\n-        adjustSize();\n-        final int classIndex = addClass(className);\n-        final int nameAndTypeIndex = addNameAndType(fieldName, signature);\n-        final int ret = index;\n-        constants[index++] = new ConstantFieldref(classIndex, nameAndTypeIndex);\n-        return computeIfAbsent(cpTable, className + FIELDREF_DELIM + fieldName + FIELDREF_DELIM + signature, ret);\n+        return -1;\n@@ -389,0 +403,1 @@\n+\n@@ -395,1 +410,1 @@\n-    public int addFloat(final float n) {\n+    public int addFloat( final float n ) {\n@@ -406,0 +421,3 @@\n+    private final Map<String, Index> utf8Table = new HashMap<>();\n+\n+\n@@ -407,1 +425,1 @@\n-     * Add a new Integer constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantUtf8 in ConstantPool.\n@@ -409,1 +427,13 @@\n-     * @param n integer number to add\n+     * @param n Utf8 string to look for\n+     * @return index on success, -1 otherwise\n+     *\/\n+    public int lookupUtf8( final String n ) {\n+        final Index index = utf8Table.get(n);\n+        return (index != null) ? index.index : -1;\n+    }\n+\n+\n+    \/**\n+     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.\n+     *\n+     * @param n Utf8 string to add\n@@ -412,1 +442,1 @@\n-    public int addInteger(final int n) {\n+    public int addUtf8( final String n ) {\n@@ -414,1 +444,1 @@\n-        if ((ret = lookupInteger(n)) != -1) {\n+        if ((ret = lookupUtf8(n)) != -1) {\n@@ -419,1 +449,4 @@\n-        constants[index++] = new ConstantInteger(n);\n+        constants[index++] = new ConstantUtf8(n);\n+        if (!utf8Table.containsKey(n)) {\n+            utf8Table.put(n, new Index(ret));\n+        }\n@@ -423,3 +456,0 @@\n-    public int addInterfaceMethodref(final MethodGen method) {\n-        return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n-    }\n@@ -428,1 +458,1 @@\n-     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantLong in ConstantPool.\n@@ -430,4 +460,2 @@\n-     * @param className class name string to add\n-     * @param methodName method name string to add\n-     * @param signature signature string to add\n-     * @return index of entry\n+     * @param n Long number to look for\n+     * @return index on success, -1 otherwise\n@@ -435,4 +463,8 @@\n-    public int addInterfaceMethodref(final String className, final String methodName, final String signature) {\n-        final int cpRet;\n-        if ((cpRet = lookupInterfaceMethodref(className, methodName, signature)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+    public int lookupLong( final long n ) {\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantLong) {\n+                final ConstantLong c = (ConstantLong) constants[i];\n+                if (c.getBytes() == n) {\n+                    return i;\n+                }\n+            }\n@@ -440,6 +472,1 @@\n-        adjustSize();\n-        final int classIndex = addClass(className);\n-        final int nameAndTypeIndex = addNameAndType(methodName, signature);\n-        final int ret = index;\n-        constants[index++] = new ConstantInterfaceMethodref(classIndex, nameAndTypeIndex);\n-        return computeIfAbsent(cpTable, className + IMETHODREF_DELIM + methodName + IMETHODREF_DELIM + signature, ret);\n+        return -1;\n@@ -448,0 +475,1 @@\n+\n@@ -454,1 +482,1 @@\n-    public int addLong(final long n) {\n+    public int addLong( final long n ) {\n@@ -465,3 +493,1 @@\n-    public int addMethodref(final MethodGen method) {\n-        return addMethodref(method.getClassName(), method.getName(), method.getSignature());\n-    }\n+\n@@ -470,1 +496,1 @@\n-     * Add a new Methodref constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantDouble in ConstantPool.\n@@ -472,4 +498,2 @@\n-     * @param className class name string to add\n-     * @param methodName method name string to add\n-     * @param signature method signature string to add\n-     * @return index of entry\n+     * @param n Double number to look for\n+     * @return index on success, -1 otherwise\n@@ -477,4 +501,9 @@\n-    public int addMethodref(final String className, final String methodName, final String signature) {\n-        final int cpRet;\n-        if ((cpRet = lookupMethodref(className, methodName, signature)) != -1) {\n-            return cpRet; \/\/ Already in CP\n+    public int lookupDouble( final double n ) {\n+        final long bits = Double.doubleToLongBits(n);\n+        for (int i = 1; i < index; i++) {\n+            if (constants[i] instanceof ConstantDouble) {\n+                final ConstantDouble c = (ConstantDouble) constants[i];\n+                if (Double.doubleToLongBits(c.getBytes()) == bits) {\n+                    return i;\n+                }\n+            }\n@@ -482,6 +511,1 @@\n-        adjustSize();\n-        final int nameAndTypeIndex = addNameAndType(methodName, signature);\n-        final int classIndex = addClass(className);\n-        final int ret = index;\n-        constants[index++] = new ConstantMethodref(classIndex, nameAndTypeIndex);\n-        return computeIfAbsent(cpTable, className + METHODREF_DELIM + methodName + METHODREF_DELIM + signature, ret);\n+        return -1;\n@@ -490,0 +514,1 @@\n+\n@@ -491,1 +516,1 @@\n-     * Add a new NameAndType constant to the ConstantPool if it is not already in there.\n+     * Add a new double constant to the ConstantPool, if it is not already in there.\n@@ -493,2 +518,1 @@\n-     * @param name Name string to add\n-     * @param signature signature string to add\n+     * @param n Double number to add\n@@ -497,1 +521,1 @@\n-    public int addNameAndType(final String name, final String signature) {\n+    public int addDouble( final double n ) {\n@@ -499,1 +523,1 @@\n-        if ((ret = lookupNameAndType(name, signature)) != -1) {\n+        if ((ret = lookupDouble(n)) != -1) {\n@@ -503,2 +527,0 @@\n-        final int nameIndex = addUtf8(name);\n-        final int signatureIndex = addUtf8(signature);\n@@ -506,2 +528,3 @@\n-        constants[index++] = new ConstantNameAndType(nameIndex, signatureIndex);\n-        return computeIfAbsent(natTable, name + NAT_DELIM + signature, ret);\n+        constants[index] = new ConstantDouble(n);\n+        index += 2; \/\/ Wastes one entry according to spec\n+        return ret;\n@@ -510,0 +533,3 @@\n+    private final Map<String, Index> natTable = new HashMap<>();\n+\n+\n@@ -511,1 +537,1 @@\n-     * Add a new String constant to the ConstantPool, if it is not already in there.\n+     * Look for ConstantNameAndType in ConstantPool.\n@@ -513,2 +539,3 @@\n-     * @param str String to add\n-     * @return index of entry\n+     * @param name of variable\/method\n+     * @param signature of variable\/method\n+     * @return index on success, -1 otherwise\n@@ -516,11 +543,3 @@\n-    public int addString(final String str) {\n-        int ret;\n-        if ((ret = lookupString(str)) != -1) {\n-            return ret; \/\/ Already in CP\n-        }\n-        final int utf8 = addUtf8(str);\n-        adjustSize();\n-        final ConstantString s = new ConstantString(utf8);\n-        ret = index;\n-        constants[index++] = s;\n-        return computeIfAbsent(stringTable, str, ret);\n+    public int lookupNameAndType( final String name, final String signature ) {\n+        final Index _index = natTable.get(name + NAT_DELIM + signature);\n+        return (_index != null) ? _index.index : -1;\n@@ -529,0 +548,1 @@\n+\n@@ -530,1 +550,2 @@\n-     * Add a new Utf8 constant to the ConstantPool, if it is not already in there.\n+     * Add a new NameAndType constant to the ConstantPool if it is not already\n+     * in there.\n@@ -532,1 +553,2 @@\n-     * @param n Utf8 string to add\n+     * @param name Name string to add\n+     * @param signature signature string to add\n@@ -535,1 +557,1 @@\n-    public int addUtf8(final String n) {\n+    public int addNameAndType( final String name, final String signature ) {\n@@ -537,1 +559,3 @@\n-        if ((ret = lookupUtf8(n)) != -1) {\n+        int name_index;\n+        int signature_index;\n+        if ((ret = lookupNameAndType(name, signature)) != -1) {\n@@ -541,0 +565,2 @@\n+        name_index = addUtf8(name);\n+        signature_index = addUtf8(signature);\n@@ -542,22 +568,4 @@\n-        constants[index++] = new ConstantUtf8(n);\n-        return computeIfAbsent(utf8Table, n, ret);\n-    }\n-\n-    \/**\n-     * Resize internal array of constants.\n-     *\/\n-    protected void adjustSize() {\n-        \/\/ 3 extra spaces are needed as some entries may take 3 slots\n-        if (index + 3 >= Const.MAX_CP_ENTRIES) {\n-            throw new IllegalStateException(\"The number of constants \" + (index + 3)\n-                    + \" is over the size limit of the constant pool: \"\n-                    + Const.MAX_CP_ENTRIES);\n-        }\n-\n-        if (index + 3 >= size) {\n-            final Constant[] cs = constants;\n-            size *= 2;\n-            \/\/ the constant array shall not exceed the size of the constant pool\n-            size = Math.min(size, Const.MAX_CP_ENTRIES);\n-            constants = new Constant[size];\n-            System.arraycopy(cs, 0, constants, 0, index);\n+        constants[index++] = new ConstantNameAndType(name_index, signature_index);\n+        final String key = name + NAT_DELIM + signature;\n+        if (!natTable.containsKey(key)) {\n+            natTable.put(key, new Index(ret));\n@@ -565,0 +573,1 @@\n+        return ret;\n@@ -567,3 +576,1 @@\n-    private int computeIfAbsent(final Map<String, Integer> map, final String key, final int value) {\n-        return map.computeIfAbsent(key, k -> Integer.valueOf(value));\n-    }\n+    private final Map<String, Index> cpTable = new HashMap<>();\n@@ -571,7 +578,0 @@\n-    \/**\n-     * @param i index in constant pool\n-     * @return constant pool entry at index i\n-     *\/\n-    public Constant getConstant(final int i) {\n-        return constants[i];\n-    }\n@@ -580,1 +580,6 @@\n-     * @return intermediate constant pool\n+     * Look for ConstantMethodref in ConstantPool.\n+     *\n+     * @param class_name Where to find method\n+     * @param method_name Guess what\n+     * @param signature return and argument types\n+     * @return index on success, -1 otherwise\n@@ -582,2 +587,4 @@\n-    public ConstantPool getConstantPool() {\n-        return new ConstantPool(constants);\n+    public int lookupMethodref( final String class_name, final String method_name, final String signature ) {\n+        final Index index = cpTable.get(class_name + METHODREF_DELIM + method_name\n+                + METHODREF_DELIM + signature);\n+        return (index != null) ? index.index : -1;\n@@ -586,6 +593,0 @@\n-    \/**\n-     * @return constant pool with proper length\n-     *\/\n-    public ConstantPool getFinalConstantPool() {\n-        return new ConstantPool(Arrays.copyOf(constants, index));\n-    }\n@@ -593,2 +594,2 @@\n-    private int getIndex(final Map<String, Integer> map, final String key) {\n-        return toIndex(map.get(key));\n+    public int lookupMethodref( final MethodGen method ) {\n+        return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());\n@@ -597,6 +598,0 @@\n-    \/**\n-     * @return current size of constant pool\n-     *\/\n-    public int getSize() {\n-        return index;\n-    }\n@@ -605,1 +600,2 @@\n-     * Look for ConstantClass in ConstantPool named 'str'.\n+     * Add a new Methodref constant to the ConstantPool, if it is not already\n+     * in there.\n@@ -607,2 +603,4 @@\n-     * @param str String to search for\n-     * @return index on success, -1 otherwise\n+     * @param class_name class name string to add\n+     * @param method_name method name string to add\n+     * @param signature method signature string to add\n+     * @return index of entry\n@@ -610,2 +608,17 @@\n-    public int lookupClass(final String str) {\n-        return getIndex(classTable, Utility.packageToPath(str));\n+    public int addMethodref( final String class_name, final String method_name, final String signature ) {\n+        int ret;\n+        int class_index;\n+        int name_and_type_index;\n+        if ((ret = lookupMethodref(class_name, method_name, signature)) != -1) {\n+            return ret; \/\/ Already in CP\n+        }\n+        adjustSize();\n+        name_and_type_index = addNameAndType(method_name, signature);\n+        class_index = addClass(class_name);\n+        ret = index;\n+        constants[index++] = new ConstantMethodref(class_index, name_and_type_index);\n+        final String key = class_name + METHODREF_DELIM + method_name + METHODREF_DELIM + signature;\n+        if (!cpTable.containsKey(key)) {\n+            cpTable.put(key, new Index(ret));\n+        }\n+        return ret;\n@@ -614,17 +627,3 @@\n-    \/**\n-     * Look for ConstantDouble in ConstantPool.\n-     *\n-     * @param n Double number to look for\n-     * @return index on success, -1 otherwise\n-     *\/\n-    public int lookupDouble(final double n) {\n-        final long bits = Double.doubleToLongBits(n);\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantDouble) {\n-                final ConstantDouble c = (ConstantDouble) constants[i];\n-                if (Double.doubleToLongBits(c.getBytes()) == bits) {\n-                    return i;\n-                }\n-            }\n-        }\n-        return -1;\n+\n+    public int addMethodref( final MethodGen method ) {\n+        return addMethodref(method.getClassName(), method.getName(), method.getSignature());\n@@ -633,0 +632,1 @@\n+\n@@ -634,1 +634,1 @@\n-     * Look for ConstantFieldref in ConstantPool.\n+     * Look for ConstantInterfaceMethodref in ConstantPool.\n@@ -636,2 +636,2 @@\n-     * @param className Where to find method\n-     * @param fieldName Guess what\n+     * @param class_name Where to find method\n+     * @param method_name Guess what\n@@ -641,2 +641,4 @@\n-    public int lookupFieldref(final String className, final String fieldName, final String signature) {\n-        return getIndex(cpTable, className + FIELDREF_DELIM + fieldName + FIELDREF_DELIM + signature);\n+    public int lookupInterfaceMethodref( final String class_name, final String method_name, final String signature ) {\n+        final Index index = cpTable.get(class_name + IMETHODREF_DELIM + method_name\n+                + IMETHODREF_DELIM + signature);\n+        return (index != null) ? index.index : -1;\n@@ -645,17 +647,4 @@\n-    \/**\n-     * Look for ConstantFloat in ConstantPool.\n-     *\n-     * @param n Float number to look for\n-     * @return index on success, -1 otherwise\n-     *\/\n-    public int lookupFloat(final float n) {\n-        final int bits = Float.floatToIntBits(n);\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantFloat) {\n-                final ConstantFloat c = (ConstantFloat) constants[i];\n-                if (Float.floatToIntBits(c.getBytes()) == bits) {\n-                    return i;\n-                }\n-            }\n-        }\n-        return -1;\n+\n+    public int lookupInterfaceMethodref( final MethodGen method ) {\n+        return lookupInterfaceMethodref(method.getClassName(), method.getName(), method\n+                .getSignature());\n@@ -664,0 +653,1 @@\n+\n@@ -665,1 +655,2 @@\n-     * Look for ConstantInteger in ConstantPool.\n+     * Add a new InterfaceMethodref constant to the ConstantPool, if it is not already\n+     * in there.\n@@ -667,2 +658,4 @@\n-     * @param n integer number to look for\n-     * @return index on success, -1 otherwise\n+     * @param class_name class name string to add\n+     * @param method_name method name string to add\n+     * @param signature signature string to add\n+     * @return index of entry\n@@ -670,8 +663,6 @@\n-    public int lookupInteger(final int n) {\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantInteger) {\n-                final ConstantInteger c = (ConstantInteger) constants[i];\n-                if (c.getBytes() == n) {\n-                    return i;\n-                }\n-            }\n+    public int addInterfaceMethodref( final String class_name, final String method_name, final String signature ) {\n+        int ret;\n+        int class_index;\n+        int name_and_type_index;\n+        if ((ret = lookupInterfaceMethodref(class_name, method_name, signature)) != -1) {\n+            return ret; \/\/ Already in CP\n@@ -679,1 +670,10 @@\n-        return -1;\n+        adjustSize();\n+        class_index = addClass(class_name);\n+        name_and_type_index = addNameAndType(method_name, signature);\n+        ret = index;\n+        constants[index++] = new ConstantInterfaceMethodref(class_index, name_and_type_index);\n+        final String key = class_name + IMETHODREF_DELIM + method_name + IMETHODREF_DELIM + signature;\n+        if (!cpTable.containsKey(key)) {\n+            cpTable.put(key, new Index(ret));\n+        }\n+        return ret;\n@@ -682,2 +682,3 @@\n-    public int lookupInterfaceMethodref(final MethodGen method) {\n-        return lookupInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n+\n+    public int addInterfaceMethodref( final MethodGen method ) {\n+        return addInterfaceMethodref(method.getClassName(), method.getName(), method.getSignature());\n@@ -686,0 +687,1 @@\n+\n@@ -687,1 +689,1 @@\n-     * Look for ConstantInterfaceMethodref in ConstantPool.\n+     * Look for ConstantFieldref in ConstantPool.\n@@ -689,2 +691,2 @@\n-     * @param className Where to find method\n-     * @param methodName Guess what\n+     * @param class_name Where to find method\n+     * @param field_name Guess what\n@@ -694,2 +696,4 @@\n-    public int lookupInterfaceMethodref(final String className, final String methodName, final String signature) {\n-        return getIndex(cpTable, className + IMETHODREF_DELIM + methodName + IMETHODREF_DELIM + signature);\n+    public int lookupFieldref( final String class_name, final String field_name, final String signature ) {\n+        final Index index = cpTable.get(class_name + FIELDREF_DELIM + field_name\n+                + FIELDREF_DELIM + signature);\n+        return (index != null) ? index.index : -1;\n@@ -698,0 +702,1 @@\n+\n@@ -699,1 +704,2 @@\n-     * Look for ConstantLong in ConstantPool.\n+     * Add a new Fieldref constant to the ConstantPool, if it is not already\n+     * in there.\n@@ -701,2 +707,4 @@\n-     * @param n Long number to look for\n-     * @return index on success, -1 otherwise\n+     * @param class_name class name string to add\n+     * @param field_name field name string to add\n+     * @param signature signature string to add\n+     * @return index of entry\n@@ -704,8 +712,6 @@\n-    public int lookupLong(final long n) {\n-        for (int i = 1; i < index; i++) {\n-            if (constants[i] instanceof ConstantLong) {\n-                final ConstantLong c = (ConstantLong) constants[i];\n-                if (c.getBytes() == n) {\n-                    return i;\n-                }\n-            }\n+    public int addFieldref( final String class_name, final String field_name, final String signature ) {\n+        int ret;\n+        int class_index;\n+        int name_and_type_index;\n+        if ((ret = lookupFieldref(class_name, field_name, signature)) != -1) {\n+            return ret; \/\/ Already in CP\n@@ -713,1 +719,10 @@\n-        return -1;\n+        adjustSize();\n+        class_index = addClass(class_name);\n+        name_and_type_index = addNameAndType(field_name, signature);\n+        ret = index;\n+        constants[index++] = new ConstantFieldref(class_index, name_and_type_index);\n+        final String key = class_name + FIELDREF_DELIM + field_name + FIELDREF_DELIM + signature;\n+        if (!cpTable.containsKey(key)) {\n+            cpTable.put(key, new Index(ret));\n+        }\n+        return ret;\n@@ -716,3 +731,0 @@\n-    public int lookupMethodref(final MethodGen method) {\n-        return lookupMethodref(method.getClassName(), method.getName(), method.getSignature());\n-    }\n@@ -721,6 +733,2 @@\n-     * Look for ConstantMethodref in ConstantPool.\n-     *\n-     * @param className Where to find method\n-     * @param methodName Guess what\n-     * @param signature return and argument types\n-     * @return index on success, -1 otherwise\n+     * @param i index in constant pool\n+     * @return constant pool entry at index i\n@@ -728,2 +736,2 @@\n-    public int lookupMethodref(final String className, final String methodName, final String signature) {\n-        return getIndex(cpTable, className + METHODREF_DELIM + methodName + METHODREF_DELIM + signature);\n+    public Constant getConstant( final int i ) {\n+        return constants[i];\n@@ -732,0 +740,1 @@\n+\n@@ -733,1 +742,1 @@\n-     * Look for ConstantNameAndType in ConstantPool.\n+     * Use with care!\n@@ -735,3 +744,2 @@\n-     * @param name of variable\/method\n-     * @param signature of variable\/method\n-     * @return index on success, -1 otherwise\n+     * @param i index in constant pool\n+     * @param c new constant pool entry at index i\n@@ -739,2 +747,2 @@\n-    public int lookupNameAndType(final String name, final String signature) {\n-        return getIndex(natTable, name + NAT_DELIM + signature);\n+    public void setConstant( final int i, final Constant c ) {\n+        constants[i] = c;\n@@ -743,0 +751,1 @@\n+\n@@ -744,4 +753,1 @@\n-     * Look for ConstantString in ConstantPool containing String 'str'.\n-     *\n-     * @param str String to search for\n-     * @return index on success, -1 otherwise\n+     * @return intermediate constant pool\n@@ -749,2 +755,2 @@\n-    public int lookupString(final String str) {\n-        return getIndex(stringTable, str);\n+    public ConstantPool getConstantPool() {\n+        return new ConstantPool(constants);\n@@ -753,0 +759,1 @@\n+\n@@ -754,4 +761,1 @@\n-     * Look for ConstantUtf8 in ConstantPool.\n-     *\n-     * @param n Utf8 string to look for\n-     * @return index on success, -1 otherwise\n+     * @return current size of constant pool\n@@ -759,2 +763,2 @@\n-    public int lookupUtf8(final String n) {\n-        return getIndex(utf8Table, n);\n+    public int getSize() {\n+        return index;\n@@ -763,0 +767,1 @@\n+\n@@ -764,4 +769,1 @@\n-     * Use with care!\n-     *\n-     * @param i index in constant pool\n-     * @param c new constant pool entry at index i\n+     * @return constant pool with proper length\n@@ -769,2 +771,4 @@\n-    public void setConstant(final int i, final Constant c) {\n-        constants[i] = c;\n+    public ConstantPool getFinalConstantPool() {\n+        final Constant[] cs = new Constant[index];\n+        System.arraycopy(constants, 0, cs, 0, index);\n+        return new ConstantPool(cs);\n@@ -773,3 +777,0 @@\n-    private int toIndex(final Integer index) {\n-        return index != null ? index.intValue() : -1;\n-    }\n@@ -788,0 +789,60 @@\n+\n+\n+    \/** Import constant from another ConstantPool and return new index.\n+     *\/\n+    public int addConstant( final Constant c, final ConstantPoolGen cp ) {\n+        final Constant[] constants = cp.getConstantPool().getConstantPool();\n+        switch (c.getTag()) {\n+            case Const.CONSTANT_String: {\n+                final ConstantString s = (ConstantString) c;\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getStringIndex()];\n+                return addString(u8.getBytes());\n+            }\n+            case Const.CONSTANT_Class: {\n+                final ConstantClass s = (ConstantClass) c;\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[s.getNameIndex()];\n+                return addClass(u8.getBytes());\n+            }\n+            case Const.CONSTANT_NameAndType: {\n+                final ConstantNameAndType n = (ConstantNameAndType) c;\n+                final ConstantUtf8 u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+                final ConstantUtf8 u8_2 = (ConstantUtf8) constants[n.getSignatureIndex()];\n+                return addNameAndType(u8.getBytes(), u8_2.getBytes());\n+            }\n+            case Const.CONSTANT_Utf8:\n+                return addUtf8(((ConstantUtf8) c).getBytes());\n+            case Const.CONSTANT_Double:\n+                return addDouble(((ConstantDouble) c).getBytes());\n+            case Const.CONSTANT_Float:\n+                return addFloat(((ConstantFloat) c).getBytes());\n+            case Const.CONSTANT_Long:\n+                return addLong(((ConstantLong) c).getBytes());\n+            case Const.CONSTANT_Integer:\n+                return addInteger(((ConstantInteger) c).getBytes());\n+            case Const.CONSTANT_InterfaceMethodref:\n+            case Const.CONSTANT_Methodref:\n+            case Const.CONSTANT_Fieldref: {\n+                final ConstantCP m = (ConstantCP) c;\n+                final ConstantClass clazz = (ConstantClass) constants[m.getClassIndex()];\n+                final ConstantNameAndType n = (ConstantNameAndType) constants[m.getNameAndTypeIndex()];\n+                ConstantUtf8 u8 = (ConstantUtf8) constants[clazz.getNameIndex()];\n+                final String class_name = u8.getBytes().replace('\/', '.');\n+                u8 = (ConstantUtf8) constants[n.getNameIndex()];\n+                final String name = u8.getBytes();\n+                u8 = (ConstantUtf8) constants[n.getSignatureIndex()];\n+                final String signature = u8.getBytes();\n+                switch (c.getTag()) {\n+                    case Const.CONSTANT_InterfaceMethodref:\n+                        return addInterfaceMethodref(class_name, name, signature);\n+                    case Const.CONSTANT_Methodref:\n+                        return addMethodref(class_name, name, signature);\n+                    case Const.CONSTANT_Fieldref:\n+                        return addFieldref(class_name, name, signature);\n+                    default: \/\/ Never reached\n+                        throw new IllegalArgumentException(\"Unknown constant type \" + c);\n+                }\n+            }\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown constant type \" + c);\n+        }\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConstantPoolGen.java","additions":485,"deletions":424,"binary":false,"changes":909,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Denotes a push instruction that produces a literal on the stack such as SIPUSH, BIPUSH, ICONST, etc.\n- *\n+ * Denotes a push instruction that produces a literal on the stack\n+ * such as  SIPUSH, BIPUSH, ICONST, etc.\n@@ -28,0 +28,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConstantPushInstruction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -29,1 +30,2 @@\n-public abstract class ConversionInstruction extends Instruction implements TypedInstruction, StackProducer, StackConsumer {\n+public abstract class ConversionInstruction extends Instruction implements TypedInstruction,\n+        StackProducer, StackConsumer {\n@@ -32,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +40,1 @@\n+\n@@ -44,2 +48,2 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    \/** @return type associated with the instruction\n@@ -48,27 +52,27 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case Const.D2I:\n-        case Const.F2I:\n-        case Const.L2I:\n-            return Type.INT;\n-        case Const.D2F:\n-        case Const.I2F:\n-        case Const.L2F:\n-            return Type.FLOAT;\n-        case Const.D2L:\n-        case Const.F2L:\n-        case Const.I2L:\n-            return Type.LONG;\n-        case Const.F2D:\n-        case Const.I2D:\n-        case Const.L2D:\n-            return Type.DOUBLE;\n-        case Const.I2B:\n-            return Type.BYTE;\n-        case Const.I2C:\n-            return Type.CHAR;\n-        case Const.I2S:\n-            return Type.SHORT;\n-        default: \/\/ Never reached\n-            throw new ClassGenException(\"Unknown type \" + opcode);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case Const.D2I:\n+            case Const.F2I:\n+            case Const.L2I:\n+                return Type.INT;\n+            case Const.D2F:\n+            case Const.I2F:\n+            case Const.L2F:\n+                return Type.FLOAT;\n+            case Const.D2L:\n+            case Const.F2L:\n+            case Const.I2L:\n+                return Type.LONG;\n+            case Const.F2D:\n+            case Const.I2D:\n+            case Const.L2D:\n+                return Type.DOUBLE;\n+            case Const.I2B:\n+                return Type.BYTE;\n+            case Const.I2C:\n+                return Type.CHAR;\n+            case Const.I2S:\n+                return Type.SHORT;\n+            default: \/\/ Never reached\n+                throw new ClassGenException(\"Unknown type \" + _opcode);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ConversionInstruction.java","additions":35,"deletions":31,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert double to float\n+    \/** Convert double to float\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2F.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert double to int\n+    \/** Convert double to int\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2I.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert double to long\n+    \/** Convert double to long\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/D2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result1.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result1.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Add doubles\n+    \/** Add doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DADD.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load double from array\n+    \/** Load double from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * DASTORE - Store into double array\n+ * DASTORE -  Store into double array\n+ * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store double into array\n+    \/** Store double into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,7 @@\n+    \/** @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.DOUBLE;\n+    }\n+\n@@ -38,2 +43,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +51,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +57,0 @@\n-\n-    \/**\n-     * @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.DOUBLE;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCMPG.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,7 @@\n+    \/** @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.DOUBLE;\n+    }\n+\n@@ -38,2 +43,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +51,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +57,0 @@\n-\n-    \/**\n-     * @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.DOUBLE;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCMPL.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n+ *\n@@ -33,1 +32,2 @@\n-    private final double value;\n+    private double value;\n+\n@@ -36,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,1 +40,0 @@\n-        this(0);\n@@ -42,0 +42,1 @@\n+\n@@ -54,0 +55,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return value;\n+    }\n+\n+\n+    \/** @return Type.DOUBLE\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.DOUBLE;\n+    }\n+\n+\n@@ -55,2 +71,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -61,1 +79,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -68,13 +86,0 @@\n-\n-    \/**\n-     * @return Type.DOUBLE\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.DOUBLE;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Double.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DCONST.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * DDIV - Divide doubles\n+ * DDIV -  Divide doubles\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Divide doubles\n+    \/** Divide doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DDIV.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack ... -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack ... -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Load double from local variable\n-     *\n+\n+    \/** Load double from local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DLOAD.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Multiply doubles\n+    \/** Multiply doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DMUL.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DNEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Remainder of doubles\n+    \/** Remainder of doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DREM.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * DRETURN - Return double from method\n+ * DRETURN -  Return double from method\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Return double from method\n+    \/** Return double from method\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <pre>Stack: ..., value.word1, value.word2 -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <pre>\n- * Stack: ..., value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Store double into local variable\n-     *\n+\n+    \/** Store double into local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DSTORE.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -35,2 +32,1 @@\n-    \/**\n-     * Substract doubles\n+    \/** Substract doubles\n@@ -42,0 +38,1 @@\n+\n@@ -43,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DSUB.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word -&gt; ..., word, word<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word -&gt; ..., word, word\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word2, word1 -&gt; ..., word2, word1, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ..., word2, word1, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word2, word1, word3, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word3, word2, word1 -&gt; ..., word2, word1, word3, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2_X1.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word4, word3, word2, word1 -&gt; ..., word2, word1, word4, word3, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word4, word3, word2, word1 -&gt; ..., word2, word1, word4, word3, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP2_X2.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ..., word1, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP_X1.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word3, word2, word1 -&gt; ..., word1, word3, word2, word1<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word3, word2, word1 -&gt; ..., word1, word3, word2, word1\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/DUP_X2.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -39,1 +39,25 @@\n-public abstract class ElementValueGen {\n+public abstract class ElementValueGen\n+{\n+    private final int type;\n+    private final ConstantPoolGen cpGen;\n+\n+    protected ElementValueGen(final int type, final ConstantPoolGen cpGen)\n+    {\n+        this.type = type;\n+        this.cpGen = cpGen;\n+    }\n+\n+    \/**\n+     * Subtypes return an immutable variant of the ElementValueGen\n+     *\/\n+    public abstract ElementValue getElementValue();\n+\n+    public int getElementValueType()\n+    {\n+        return type;\n+    }\n+\n+    public abstract String stringifyValue();\n+\n+    public abstract void dump(DataOutputStream dos) throws IOException;\n+\n@@ -66,29 +90,3 @@\n-    \/**\n-     * Creates an (modifiable) ElementValueGen copy of an (immutable) ElementValue - constant pool is assumed correct.\n-     *\/\n-    public static ElementValueGen copy(final ElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        switch (value.getElementValueType()) {\n-        case 'B': \/\/ byte\n-        case 'C': \/\/ char\n-        case 'D': \/\/ double\n-        case 'F': \/\/ float\n-        case 'I': \/\/ int\n-        case 'J': \/\/ long\n-        case 'S': \/\/ short\n-        case 'Z': \/\/ boolean\n-        case 's': \/\/ String\n-            return new SimpleElementValueGen((SimpleElementValue) value, cpool, copyPoolEntries);\n-        case 'e': \/\/ Enum constant\n-            return new EnumElementValueGen((EnumElementValue) value, cpool, copyPoolEntries);\n-        case '@': \/\/ Annotation\n-            return new AnnotationElementValueGen((AnnotationElementValue) value, cpool, copyPoolEntries);\n-        case '[': \/\/ Array\n-            return new ArrayElementValueGen((ArrayElementValue) value, cpool, copyPoolEntries);\n-        case 'c': \/\/ Class\n-            return new ClassElementValueGen((ClassElementValue) value, cpool, copyPoolEntries);\n-        default:\n-            throw new UnsupportedOperationException(\"Not implemented yet! (\" + value.getElementValueType() + \")\");\n-        }\n-    }\n-\n-    public static ElementValueGen readElementValue(final DataInput dis, final ConstantPoolGen cpGen) throws IOException {\n+    public static ElementValueGen readElementValue(final DataInput dis,\n+            final ConstantPoolGen cpGen) throws IOException\n+    {\n@@ -96,1 +94,2 @@\n-        switch (type) {\n+        switch (type)\n+        {\n@@ -98,1 +97,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_BYTE, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_BYTE, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -100,1 +100,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_CHAR, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_CHAR, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -102,1 +103,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_DOUBLE, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_DOUBLE, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -104,1 +106,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_FLOAT, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_FLOAT, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -106,1 +109,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_INT, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_INT, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -108,1 +112,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_LONG, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_LONG, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -110,1 +115,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_SHORT, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_SHORT, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -112,1 +118,2 @@\n-            return new SimpleElementValueGen(PRIMITIVE_BOOLEAN, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(PRIMITIVE_BOOLEAN, dis\n+                    .readUnsignedShort(), cpGen);\n@@ -114,1 +121,2 @@\n-            return new SimpleElementValueGen(STRING, dis.readUnsignedShort(), cpGen);\n+            return new SimpleElementValueGen(STRING, dis.readUnsignedShort(),\n+                    cpGen);\n@@ -116,1 +124,2 @@\n-            return new EnumElementValueGen(dis.readUnsignedShort(), dis.readUnsignedShort(), cpGen);\n+            return new EnumElementValueGen(dis.readUnsignedShort(), dis\n+                    .readUnsignedShort(), cpGen);\n@@ -122,2 +131,3 @@\n-            return new AnnotationElementValueGen(ANNOTATION, new AnnotationEntryGen(AnnotationEntry.read(dis, cpGen.getConstantPool(), true), cpGen, false),\n-                cpGen);\n+            return new AnnotationElementValueGen(ANNOTATION,\n+                    new AnnotationEntryGen(AnnotationEntry.read(dis, cpGen\n+                            .getConstantPool(), true), cpGen, false), cpGen);\n@@ -127,2 +137,4 @@\n-            for (int j = 0; j < numArrayVals; j++) {\n-                evalues[j] = ElementValue.readElementValue(dis, cpGen.getConstantPool());\n+            for (int j = 0; j < numArrayVals; j++)\n+            {\n+                evalues[j] = ElementValue.readElementValue(dis, cpGen\n+                        .getConstantPool());\n@@ -136,20 +148,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @Deprecated\n-    protected int type;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private and final; do not access directly, use getter\n-     *\/\n-    @Deprecated\n-    protected ConstantPoolGen cpGen;\n-\n-    protected ElementValueGen(final int type, final ConstantPoolGen cpGen) {\n-        this.type = type;\n-        this.cpGen = cpGen;\n-    }\n-\n-    public abstract void dump(DataOutputStream dos) throws IOException;\n-\n-    protected ConstantPoolGen getConstantPool() {\n+    protected ConstantPoolGen getConstantPool()\n+    {\n@@ -160,1 +154,2 @@\n-     * Subtypes return an immutable variant of the ElementValueGen\n+     * Creates an (modifiable) ElementValueGen copy of an (immutable)\n+     * ElementValue - constant pool is assumed correct.\n@@ -162,4 +157,31 @@\n-    public abstract ElementValue getElementValue();\n-\n-    public int getElementValueType() {\n-        return type;\n+    public static ElementValueGen copy(final ElementValue value,\n+            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n+    {\n+        switch (value.getElementValueType())\n+        {\n+        case 'B': \/\/ byte\n+        case 'C': \/\/ char\n+        case 'D': \/\/ double\n+        case 'F': \/\/ float\n+        case 'I': \/\/ int\n+        case 'J': \/\/ long\n+        case 'S': \/\/ short\n+        case 'Z': \/\/ boolean\n+        case 's': \/\/ String\n+            return new SimpleElementValueGen((SimpleElementValue) value, cpool,\n+                    copyPoolEntries);\n+        case 'e': \/\/ Enum constant\n+            return new EnumElementValueGen((EnumElementValue) value, cpool,\n+                    copyPoolEntries);\n+        case '@': \/\/ Annotation\n+            return new AnnotationElementValueGen(\n+                    (AnnotationElementValue) value, cpool, copyPoolEntries);\n+        case '[': \/\/ Array\n+            return new ArrayElementValueGen((ArrayElementValue) value, cpool,\n+                    copyPoolEntries);\n+        case 'c': \/\/ Class\n+            return new ClassElementValueGen((ClassElementValue) value, cpool,\n+                    copyPoolEntries);\n+        default:\n+            throw new UnsupportedOperationException(\"Not implemented yet! (\" + value.getElementValueType() + \")\");\n+        }\n@@ -167,2 +189,0 @@\n-\n-    public abstract String stringifyValue();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ElementValueGen.java","additions":92,"deletions":72,"binary":false,"changes":164,"status":"modified"},{"patch":"@@ -34,2 +34,3 @@\n-public class ElementValuePairGen {\n-    private final int nameIdx;\n+public class ElementValuePairGen\n+{\n+    private int nameIdx;\n@@ -41,1 +42,3 @@\n-    public ElementValuePairGen(final ElementValuePair nvp, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+    public ElementValuePairGen(final ElementValuePair nvp, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n@@ -51,1 +54,2 @@\n-        if (copyPoolEntries) {\n+        if (copyPoolEntries)\n+        {\n@@ -53,1 +57,3 @@\n-        } else {\n+        }\n+        else\n+        {\n@@ -59,1 +65,13 @@\n-    protected ElementValuePairGen(final int idx, final ElementValueGen value, final ConstantPoolGen cpool) {\n+    \/**\n+     * Retrieve an immutable version of this ElementNameValuePairGen\n+     *\/\n+    public ElementValuePair getElementNameValuePair()\n+    {\n+        final ElementValue immutableValue = value.getElementValue();\n+        return new ElementValuePair(nameIdx, immutableValue, constantPoolGen\n+                .getConstantPool());\n+    }\n+\n+    protected ElementValuePairGen(final int idx, final ElementValueGen value,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -65,1 +83,3 @@\n-    public ElementValuePairGen(final String name, final ElementValueGen value, final ConstantPoolGen cpool) {\n+    public ElementValuePairGen(final String name, final ElementValueGen value,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -71,1 +91,2 @@\n-    protected void dump(final DataOutputStream dos) throws IOException {\n+    protected void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -76,9 +97,2 @@\n-    \/**\n-     * Retrieve an immutable version of this ElementNameValuePairGen\n-     *\/\n-    public ElementValuePair getElementNameValuePair() {\n-        final ElementValue immutableValue = value.getElementValue();\n-        return new ElementValuePair(nameIdx, immutableValue, constantPoolGen.getConstantPool());\n-    }\n-\n-    public int getNameIndex() {\n+    public int getNameIndex()\n+    {\n@@ -88,1 +102,2 @@\n-    public final String getNameString() {\n+    public final String getNameString()\n+    {\n@@ -93,1 +108,2 @@\n-    public final ElementValueGen getValue() {\n+    public final ElementValueGen getValue()\n+    {\n@@ -98,2 +114,4 @@\n-    public String toString() {\n-        return \"ElementValuePair:[\" + getNameString() + \"=\" + value.stringifyValue() + \"]\";\n+    public String toString()\n+    {\n+        return \"ElementValuePair:[\" + getNameString() + \"=\"\n+                + value.stringifyValue() + \"]\";\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ElementValuePairGen.java","additions":39,"deletions":21,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -30,1 +31,1 @@\n-    public void visitAALOAD(final AALOAD obj) {\n+    public void visitStackInstruction( final StackInstruction obj ) {\n@@ -33,0 +34,1 @@\n+\n@@ -34,1 +36,1 @@\n-    public void visitAASTORE(final AASTORE obj) {\n+    public void visitLocalVariableInstruction( final LocalVariableInstruction obj ) {\n@@ -37,0 +39,1 @@\n+\n@@ -38,1 +41,1 @@\n-    public void visitACONST_NULL(final ACONST_NULL obj) {\n+    public void visitBranchInstruction( final BranchInstruction obj ) {\n@@ -41,0 +44,1 @@\n+\n@@ -42,1 +46,1 @@\n-    public void visitAllocationInstruction(final AllocationInstruction obj) {\n+    public void visitLoadClass( final LoadClass obj ) {\n@@ -45,0 +49,1 @@\n+\n@@ -46,1 +51,1 @@\n-    public void visitALOAD(final ALOAD obj) {\n+    public void visitFieldInstruction( final FieldInstruction obj ) {\n@@ -49,0 +54,1 @@\n+\n@@ -50,1 +56,1 @@\n-    public void visitANEWARRAY(final ANEWARRAY obj) {\n+    public void visitIfInstruction( final IfInstruction obj ) {\n@@ -53,0 +59,1 @@\n+\n@@ -54,1 +61,1 @@\n-    public void visitARETURN(final ARETURN obj) {\n+    public void visitConversionInstruction( final ConversionInstruction obj ) {\n@@ -57,0 +64,1 @@\n+\n@@ -58,1 +66,1 @@\n-    public void visitArithmeticInstruction(final ArithmeticInstruction obj) {\n+    public void visitPopInstruction( final PopInstruction obj ) {\n@@ -61,0 +69,1 @@\n+\n@@ -62,1 +71,1 @@\n-    public void visitArrayInstruction(final ArrayInstruction obj) {\n+    public void visitJsrInstruction( final JsrInstruction obj ) {\n@@ -65,0 +74,1 @@\n+\n@@ -66,1 +76,1 @@\n-    public void visitARRAYLENGTH(final ARRAYLENGTH obj) {\n+    public void visitGotoInstruction( final GotoInstruction obj ) {\n@@ -69,0 +79,1 @@\n+\n@@ -70,1 +81,1 @@\n-    public void visitASTORE(final ASTORE obj) {\n+    public void visitStoreInstruction( final StoreInstruction obj ) {\n@@ -73,0 +84,1 @@\n+\n@@ -74,1 +86,1 @@\n-    public void visitATHROW(final ATHROW obj) {\n+    public void visitTypedInstruction( final TypedInstruction obj ) {\n@@ -77,0 +89,1 @@\n+\n@@ -78,1 +91,1 @@\n-    public void visitBALOAD(final BALOAD obj) {\n+    public void visitSelect( final Select obj ) {\n@@ -81,0 +94,1 @@\n+\n@@ -82,1 +96,1 @@\n-    public void visitBASTORE(final BASTORE obj) {\n+    public void visitUnconditionalBranch( final UnconditionalBranch obj ) {\n@@ -85,0 +99,1 @@\n+\n@@ -86,1 +101,1 @@\n-    public void visitBIPUSH(final BIPUSH obj) {\n+    public void visitPushInstruction( final PushInstruction obj ) {\n@@ -89,0 +104,1 @@\n+\n@@ -90,1 +106,1 @@\n-    public void visitBranchInstruction(final BranchInstruction obj) {\n+    public void visitArithmeticInstruction( final ArithmeticInstruction obj ) {\n@@ -93,0 +109,1 @@\n+\n@@ -94,1 +111,1 @@\n-    public void visitBREAKPOINT(final BREAKPOINT obj) {\n+    public void visitCPInstruction( final CPInstruction obj ) {\n@@ -97,0 +114,1 @@\n+\n@@ -98,1 +116,1 @@\n-    public void visitCALOAD(final CALOAD obj) {\n+    public void visitInvokeInstruction( final InvokeInstruction obj ) {\n@@ -101,0 +119,1 @@\n+\n@@ -102,1 +121,1 @@\n-    public void visitCASTORE(final CASTORE obj) {\n+    public void visitArrayInstruction( final ArrayInstruction obj ) {\n@@ -105,0 +124,1 @@\n+\n@@ -106,1 +126,1 @@\n-    public void visitCHECKCAST(final CHECKCAST obj) {\n+    public void visitAllocationInstruction( final AllocationInstruction obj ) {\n@@ -109,0 +129,1 @@\n+\n@@ -110,1 +131,1 @@\n-    public void visitConstantPushInstruction(final ConstantPushInstruction obj) {\n+    public void visitReturnInstruction( final ReturnInstruction obj ) {\n@@ -113,0 +134,1 @@\n+\n@@ -114,1 +136,1 @@\n-    public void visitConversionInstruction(final ConversionInstruction obj) {\n+    public void visitFieldOrMethod( final FieldOrMethod obj ) {\n@@ -117,0 +139,1 @@\n+\n@@ -118,1 +141,1 @@\n-    public void visitCPInstruction(final CPInstruction obj) {\n+    public void visitConstantPushInstruction( final ConstantPushInstruction obj ) {\n@@ -121,0 +144,1 @@\n+\n@@ -122,1 +146,1 @@\n-    public void visitD2F(final D2F obj) {\n+    public void visitExceptionThrower( final ExceptionThrower obj ) {\n@@ -125,0 +149,1 @@\n+\n@@ -126,1 +151,1 @@\n-    public void visitD2I(final D2I obj) {\n+    public void visitLoadInstruction( final LoadInstruction obj ) {\n@@ -129,0 +154,1 @@\n+\n@@ -130,1 +156,1 @@\n-    public void visitD2L(final D2L obj) {\n+    public void visitVariableLengthInstruction( final VariableLengthInstruction obj ) {\n@@ -133,0 +159,1 @@\n+\n@@ -134,1 +161,1 @@\n-    public void visitDADD(final DADD obj) {\n+    public void visitStackProducer( final StackProducer obj ) {\n@@ -137,0 +164,1 @@\n+\n@@ -138,1 +166,1 @@\n-    public void visitDALOAD(final DALOAD obj) {\n+    public void visitStackConsumer( final StackConsumer obj ) {\n@@ -141,0 +169,1 @@\n+\n@@ -142,1 +171,1 @@\n-    public void visitDASTORE(final DASTORE obj) {\n+    public void visitACONST_NULL( final ACONST_NULL obj ) {\n@@ -145,0 +174,1 @@\n+\n@@ -146,1 +176,1 @@\n-    public void visitDCMPG(final DCMPG obj) {\n+    public void visitGETSTATIC( final GETSTATIC obj ) {\n@@ -149,0 +179,1 @@\n+\n@@ -150,1 +181,1 @@\n-    public void visitDCMPL(final DCMPL obj) {\n+    public void visitIF_ICMPLT( final IF_ICMPLT obj ) {\n@@ -153,0 +184,1 @@\n+\n@@ -154,1 +186,1 @@\n-    public void visitDCONST(final DCONST obj) {\n+    public void visitMONITOREXIT( final MONITOREXIT obj ) {\n@@ -157,0 +189,1 @@\n+\n@@ -158,1 +191,1 @@\n-    public void visitDDIV(final DDIV obj) {\n+    public void visitIFLT( final IFLT obj ) {\n@@ -161,0 +194,1 @@\n+\n@@ -162,1 +196,1 @@\n-    public void visitDLOAD(final DLOAD obj) {\n+    public void visitLSTORE( final LSTORE obj ) {\n@@ -165,0 +199,1 @@\n+\n@@ -166,1 +201,1 @@\n-    public void visitDMUL(final DMUL obj) {\n+    public void visitPOP2( final POP2 obj ) {\n@@ -169,0 +204,1 @@\n+\n@@ -170,1 +206,1 @@\n-    public void visitDNEG(final DNEG obj) {\n+    public void visitBASTORE( final BASTORE obj ) {\n@@ -173,0 +209,1 @@\n+\n@@ -174,1 +211,1 @@\n-    public void visitDREM(final DREM obj) {\n+    public void visitISTORE( final ISTORE obj ) {\n@@ -177,0 +214,1 @@\n+\n@@ -178,1 +216,1 @@\n-    public void visitDRETURN(final DRETURN obj) {\n+    public void visitCHECKCAST( final CHECKCAST obj ) {\n@@ -181,0 +219,1 @@\n+\n@@ -182,1 +221,1 @@\n-    public void visitDSTORE(final DSTORE obj) {\n+    public void visitFCMPG( final FCMPG obj ) {\n@@ -185,0 +224,1 @@\n+\n@@ -186,1 +226,1 @@\n-    public void visitDSUB(final DSUB obj) {\n+    public void visitI2F( final I2F obj ) {\n@@ -189,0 +229,1 @@\n+\n@@ -190,1 +231,1 @@\n-    public void visitDUP(final DUP obj) {\n+    public void visitATHROW( final ATHROW obj ) {\n@@ -193,0 +234,1 @@\n+\n@@ -194,1 +236,1 @@\n-    public void visitDUP_X1(final DUP_X1 obj) {\n+    public void visitDCMPL( final DCMPL obj ) {\n@@ -197,0 +239,1 @@\n+\n@@ -198,1 +241,1 @@\n-    public void visitDUP_X2(final DUP_X2 obj) {\n+    public void visitARRAYLENGTH( final ARRAYLENGTH obj ) {\n@@ -201,0 +244,1 @@\n+\n@@ -202,1 +246,1 @@\n-    public void visitDUP2(final DUP2 obj) {\n+    public void visitDUP( final DUP obj ) {\n@@ -205,0 +249,1 @@\n+\n@@ -206,1 +251,1 @@\n-    public void visitDUP2_X1(final DUP2_X1 obj) {\n+    public void visitINVOKESTATIC( final INVOKESTATIC obj ) {\n@@ -209,0 +254,1 @@\n+\n@@ -210,1 +256,1 @@\n-    public void visitDUP2_X2(final DUP2_X2 obj) {\n+    public void visitLCONST( final LCONST obj ) {\n@@ -213,0 +259,1 @@\n+\n@@ -214,1 +261,1 @@\n-    public void visitExceptionThrower(final ExceptionThrower obj) {\n+    public void visitDREM( final DREM obj ) {\n@@ -217,0 +264,1 @@\n+\n@@ -218,1 +266,1 @@\n-    public void visitF2D(final F2D obj) {\n+    public void visitIFGE( final IFGE obj ) {\n@@ -221,0 +269,1 @@\n+\n@@ -222,1 +271,1 @@\n-    public void visitF2I(final F2I obj) {\n+    public void visitCALOAD( final CALOAD obj ) {\n@@ -225,0 +274,1 @@\n+\n@@ -226,1 +276,1 @@\n-    public void visitF2L(final F2L obj) {\n+    public void visitLASTORE( final LASTORE obj ) {\n@@ -229,0 +279,1 @@\n+\n@@ -230,1 +281,1 @@\n-    public void visitFADD(final FADD obj) {\n+    public void visitI2D( final I2D obj ) {\n@@ -233,0 +284,1 @@\n+\n@@ -234,1 +286,1 @@\n-    public void visitFALOAD(final FALOAD obj) {\n+    public void visitDADD( final DADD obj ) {\n@@ -237,0 +289,1 @@\n+\n@@ -238,1 +291,1 @@\n-    public void visitFASTORE(final FASTORE obj) {\n+    public void visitINVOKESPECIAL( final INVOKESPECIAL obj ) {\n@@ -241,0 +294,1 @@\n+\n@@ -242,1 +296,1 @@\n-    public void visitFCMPG(final FCMPG obj) {\n+    public void visitIAND( final IAND obj ) {\n@@ -245,0 +299,1 @@\n+\n@@ -246,1 +301,1 @@\n-    public void visitFCMPL(final FCMPL obj) {\n+    public void visitPUTFIELD( final PUTFIELD obj ) {\n@@ -249,0 +304,1 @@\n+\n@@ -250,1 +306,1 @@\n-    public void visitFCONST(final FCONST obj) {\n+    public void visitILOAD( final ILOAD obj ) {\n@@ -253,0 +309,1 @@\n+\n@@ -254,1 +311,1 @@\n-    public void visitFDIV(final FDIV obj) {\n+    public void visitDLOAD( final DLOAD obj ) {\n@@ -257,0 +314,1 @@\n+\n@@ -258,1 +316,1 @@\n-    public void visitFieldInstruction(final FieldInstruction obj) {\n+    public void visitDCONST( final DCONST obj ) {\n@@ -261,0 +319,1 @@\n+\n@@ -262,1 +321,1 @@\n-    public void visitFieldOrMethod(final FieldOrMethod obj) {\n+    public void visitNEW( final NEW obj ) {\n@@ -265,0 +324,1 @@\n+\n@@ -266,1 +326,1 @@\n-    public void visitFLOAD(final FLOAD obj) {\n+    public void visitIFNULL( final IFNULL obj ) {\n@@ -269,0 +329,1 @@\n+\n@@ -270,1 +331,1 @@\n-    public void visitFMUL(final FMUL obj) {\n+    public void visitLSUB( final LSUB obj ) {\n@@ -273,0 +334,1 @@\n+\n@@ -274,1 +336,1 @@\n-    public void visitFNEG(final FNEG obj) {\n+    public void visitL2I( final L2I obj ) {\n@@ -277,0 +339,1 @@\n+\n@@ -278,1 +341,1 @@\n-    public void visitFREM(final FREM obj) {\n+    public void visitISHR( final ISHR obj ) {\n@@ -281,0 +344,1 @@\n+\n@@ -282,1 +346,1 @@\n-    public void visitFRETURN(final FRETURN obj) {\n+    public void visitTABLESWITCH( final TABLESWITCH obj ) {\n@@ -285,0 +349,1 @@\n+\n@@ -286,1 +351,1 @@\n-    public void visitFSTORE(final FSTORE obj) {\n+    public void visitIINC( final IINC obj ) {\n@@ -289,0 +354,1 @@\n+\n@@ -290,1 +356,1 @@\n-    public void visitFSUB(final FSUB obj) {\n+    public void visitDRETURN( final DRETURN obj ) {\n@@ -293,0 +359,1 @@\n+\n@@ -294,1 +361,1 @@\n-    public void visitGETFIELD(final GETFIELD obj) {\n+    public void visitFSTORE( final FSTORE obj ) {\n@@ -297,0 +364,1 @@\n+\n@@ -298,1 +366,1 @@\n-    public void visitGETSTATIC(final GETSTATIC obj) {\n+    public void visitDASTORE( final DASTORE obj ) {\n@@ -301,0 +369,1 @@\n+\n@@ -302,1 +371,1 @@\n-    public void visitGOTO(final GOTO obj) {\n+    public void visitIALOAD( final IALOAD obj ) {\n@@ -305,0 +374,1 @@\n+\n@@ -306,1 +376,1 @@\n-    public void visitGOTO_W(final GOTO_W obj) {\n+    public void visitDDIV( final DDIV obj ) {\n@@ -309,0 +379,1 @@\n+\n@@ -310,1 +381,1 @@\n-    public void visitGotoInstruction(final GotoInstruction obj) {\n+    public void visitIF_ICMPGE( final IF_ICMPGE obj ) {\n@@ -313,0 +384,1 @@\n+\n@@ -314,1 +386,1 @@\n-    public void visitI2B(final I2B obj) {\n+    public void visitLAND( final LAND obj ) {\n@@ -317,0 +389,1 @@\n+\n@@ -318,1 +391,1 @@\n-    public void visitI2C(final I2C obj) {\n+    public void visitIDIV( final IDIV obj ) {\n@@ -321,0 +394,1 @@\n+\n@@ -322,1 +396,1 @@\n-    public void visitI2D(final I2D obj) {\n+    public void visitLOR( final LOR obj ) {\n@@ -325,0 +399,1 @@\n+\n@@ -326,1 +401,1 @@\n-    public void visitI2F(final I2F obj) {\n+    public void visitCASTORE( final CASTORE obj ) {\n@@ -329,0 +404,1 @@\n+\n@@ -330,1 +406,1 @@\n-    public void visitI2L(final I2L obj) {\n+    public void visitFREM( final FREM obj ) {\n@@ -333,0 +409,1 @@\n+\n@@ -334,1 +411,1 @@\n-    public void visitI2S(final I2S obj) {\n+    public void visitLDC( final LDC obj ) {\n@@ -337,0 +414,1 @@\n+\n@@ -338,1 +416,1 @@\n-    public void visitIADD(final IADD obj) {\n+    public void visitBIPUSH( final BIPUSH obj ) {\n@@ -341,0 +419,1 @@\n+\n@@ -342,1 +421,1 @@\n-    public void visitIALOAD(final IALOAD obj) {\n+    public void visitDSTORE( final DSTORE obj ) {\n@@ -345,0 +424,1 @@\n+\n@@ -346,1 +426,1 @@\n-    public void visitIAND(final IAND obj) {\n+    public void visitF2L( final F2L obj ) {\n@@ -349,0 +429,1 @@\n+\n@@ -350,1 +431,1 @@\n-    public void visitIASTORE(final IASTORE obj) {\n+    public void visitFMUL( final FMUL obj ) {\n@@ -353,0 +434,1 @@\n+\n@@ -354,1 +436,1 @@\n-    public void visitICONST(final ICONST obj) {\n+    public void visitLLOAD( final LLOAD obj ) {\n@@ -357,0 +439,1 @@\n+\n@@ -358,1 +441,1 @@\n-    public void visitIDIV(final IDIV obj) {\n+    public void visitJSR( final JSR obj ) {\n@@ -361,0 +444,1 @@\n+\n@@ -362,1 +446,1 @@\n-    public void visitIF_ACMPEQ(final IF_ACMPEQ obj) {\n+    public void visitFSUB( final FSUB obj ) {\n@@ -365,0 +449,1 @@\n+\n@@ -366,1 +451,1 @@\n-    public void visitIF_ACMPNE(final IF_ACMPNE obj) {\n+    public void visitSASTORE( final SASTORE obj ) {\n@@ -369,0 +454,1 @@\n+\n@@ -370,1 +456,1 @@\n-    public void visitIF_ICMPEQ(final IF_ICMPEQ obj) {\n+    public void visitALOAD( final ALOAD obj ) {\n@@ -373,0 +459,1 @@\n+\n@@ -374,1 +461,1 @@\n-    public void visitIF_ICMPGE(final IF_ICMPGE obj) {\n+    public void visitDUP2_X2( final DUP2_X2 obj ) {\n@@ -377,0 +464,1 @@\n+\n@@ -378,1 +466,1 @@\n-    public void visitIF_ICMPGT(final IF_ICMPGT obj) {\n+    public void visitRETURN( final RETURN obj ) {\n@@ -381,0 +469,1 @@\n+\n@@ -382,1 +471,1 @@\n-    public void visitIF_ICMPLE(final IF_ICMPLE obj) {\n+    public void visitDALOAD( final DALOAD obj ) {\n@@ -385,0 +474,1 @@\n+\n@@ -386,1 +476,1 @@\n-    public void visitIF_ICMPLT(final IF_ICMPLT obj) {\n+    public void visitSIPUSH( final SIPUSH obj ) {\n@@ -389,0 +479,1 @@\n+\n@@ -390,1 +481,1 @@\n-    public void visitIF_ICMPNE(final IF_ICMPNE obj) {\n+    public void visitDSUB( final DSUB obj ) {\n@@ -393,0 +484,1 @@\n+\n@@ -394,1 +486,1 @@\n-    public void visitIFEQ(final IFEQ obj) {\n+    public void visitL2F( final L2F obj ) {\n@@ -397,0 +489,1 @@\n+\n@@ -398,1 +491,1 @@\n-    public void visitIFGE(final IFGE obj) {\n+    public void visitIF_ICMPGT( final IF_ICMPGT obj ) {\n@@ -401,0 +494,1 @@\n+\n@@ -402,1 +496,1 @@\n-    public void visitIFGT(final IFGT obj) {\n+    public void visitF2D( final F2D obj ) {\n@@ -405,0 +499,1 @@\n+\n@@ -406,1 +501,1 @@\n-    public void visitIfInstruction(final IfInstruction obj) {\n+    public void visitI2L( final I2L obj ) {\n@@ -409,0 +504,1 @@\n+\n@@ -410,1 +506,1 @@\n-    public void visitIFLE(final IFLE obj) {\n+    public void visitIF_ACMPNE( final IF_ACMPNE obj ) {\n@@ -413,0 +509,1 @@\n+\n@@ -414,1 +511,1 @@\n-    public void visitIFLT(final IFLT obj) {\n+    public void visitPOP( final POP obj ) {\n@@ -417,0 +514,1 @@\n+\n@@ -418,1 +516,1 @@\n-    public void visitIFNE(final IFNE obj) {\n+    public void visitI2S( final I2S obj ) {\n@@ -421,0 +519,1 @@\n+\n@@ -422,1 +521,1 @@\n-    public void visitIFNONNULL(final IFNONNULL obj) {\n+    public void visitIFEQ( final IFEQ obj ) {\n@@ -425,0 +524,1 @@\n+\n@@ -426,1 +526,1 @@\n-    public void visitIFNULL(final IFNULL obj) {\n+    public void visitSWAP( final SWAP obj ) {\n@@ -429,0 +529,1 @@\n+\n@@ -430,1 +531,1 @@\n-    public void visitIINC(final IINC obj) {\n+    public void visitIOR( final IOR obj ) {\n@@ -433,0 +534,1 @@\n+\n@@ -434,1 +536,1 @@\n-    public void visitILOAD(final ILOAD obj) {\n+    public void visitIREM( final IREM obj ) {\n@@ -437,0 +539,1 @@\n+\n@@ -438,1 +541,1 @@\n-    public void visitIMPDEP1(final IMPDEP1 obj) {\n+    public void visitIASTORE( final IASTORE obj ) {\n@@ -441,0 +544,1 @@\n+\n@@ -442,1 +546,1 @@\n-    public void visitIMPDEP2(final IMPDEP2 obj) {\n+    public void visitNEWARRAY( final NEWARRAY obj ) {\n@@ -445,0 +549,1 @@\n+\n@@ -446,1 +551,1 @@\n-    public void visitIMUL(final IMUL obj) {\n+    public void visitINVOKEINTERFACE( final INVOKEINTERFACE obj ) {\n@@ -449,0 +554,1 @@\n+\n@@ -450,1 +556,1 @@\n-    public void visitINEG(final INEG obj) {\n+    public void visitINEG( final INEG obj ) {\n@@ -453,0 +559,1 @@\n+\n@@ -454,1 +561,1 @@\n-    public void visitINSTANCEOF(final INSTANCEOF obj) {\n+    public void visitLCMP( final LCMP obj ) {\n@@ -457,3 +564,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n+\n@@ -461,1 +566,1 @@\n-    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC obj) {\n+    public void visitJSR_W( final JSR_W obj ) {\n@@ -464,0 +569,1 @@\n+\n@@ -465,1 +571,1 @@\n-    public void visitInvokeInstruction(final InvokeInstruction obj) {\n+    public void visitMULTIANEWARRAY( final MULTIANEWARRAY obj ) {\n@@ -468,0 +574,1 @@\n+\n@@ -469,1 +576,1 @@\n-    public void visitINVOKEINTERFACE(final INVOKEINTERFACE obj) {\n+    public void visitDUP_X2( final DUP_X2 obj ) {\n@@ -472,0 +579,1 @@\n+\n@@ -473,1 +581,1 @@\n-    public void visitINVOKESPECIAL(final INVOKESPECIAL obj) {\n+    public void visitSALOAD( final SALOAD obj ) {\n@@ -476,0 +584,1 @@\n+\n@@ -477,1 +586,1 @@\n-    public void visitINVOKESTATIC(final INVOKESTATIC obj) {\n+    public void visitIFNONNULL( final IFNONNULL obj ) {\n@@ -480,0 +589,1 @@\n+\n@@ -481,1 +591,1 @@\n-    public void visitINVOKEVIRTUAL(final INVOKEVIRTUAL obj) {\n+    public void visitDMUL( final DMUL obj ) {\n@@ -484,0 +594,1 @@\n+\n@@ -485,1 +596,1 @@\n-    public void visitIOR(final IOR obj) {\n+    public void visitIFNE( final IFNE obj ) {\n@@ -488,0 +599,1 @@\n+\n@@ -489,1 +601,1 @@\n-    public void visitIREM(final IREM obj) {\n+    public void visitIF_ICMPLE( final IF_ICMPLE obj ) {\n@@ -492,0 +604,1 @@\n+\n@@ -493,1 +606,1 @@\n-    public void visitIRETURN(final IRETURN obj) {\n+    public void visitLDC2_W( final LDC2_W obj ) {\n@@ -496,0 +609,1 @@\n+\n@@ -497,1 +611,1 @@\n-    public void visitISHL(final ISHL obj) {\n+    public void visitGETFIELD( final GETFIELD obj ) {\n@@ -500,0 +614,1 @@\n+\n@@ -501,1 +616,1 @@\n-    public void visitISHR(final ISHR obj) {\n+    public void visitLADD( final LADD obj ) {\n@@ -504,0 +619,1 @@\n+\n@@ -505,1 +621,1 @@\n-    public void visitISTORE(final ISTORE obj) {\n+    public void visitNOP( final NOP obj ) {\n@@ -508,0 +624,1 @@\n+\n@@ -509,1 +626,1 @@\n-    public void visitISUB(final ISUB obj) {\n+    public void visitFALOAD( final FALOAD obj ) {\n@@ -512,0 +629,1 @@\n+\n@@ -513,1 +631,1 @@\n-    public void visitIUSHR(final IUSHR obj) {\n+    public void visitINSTANCEOF( final INSTANCEOF obj ) {\n@@ -516,0 +634,1 @@\n+\n@@ -517,1 +636,1 @@\n-    public void visitIXOR(final IXOR obj) {\n+    public void visitIFLE( final IFLE obj ) {\n@@ -520,0 +639,1 @@\n+\n@@ -521,1 +641,1 @@\n-    public void visitJSR(final JSR obj) {\n+    public void visitLXOR( final LXOR obj ) {\n@@ -524,0 +644,1 @@\n+\n@@ -525,1 +646,1 @@\n-    public void visitJSR_W(final JSR_W obj) {\n+    public void visitLRETURN( final LRETURN obj ) {\n@@ -528,0 +649,1 @@\n+\n@@ -529,1 +651,1 @@\n-    public void visitJsrInstruction(final JsrInstruction obj) {\n+    public void visitFCONST( final FCONST obj ) {\n@@ -532,0 +654,1 @@\n+\n@@ -533,1 +656,1 @@\n-    public void visitL2D(final L2D obj) {\n+    public void visitIUSHR( final IUSHR obj ) {\n@@ -536,0 +659,1 @@\n+\n@@ -537,1 +661,1 @@\n-    public void visitL2F(final L2F obj) {\n+    public void visitBALOAD( final BALOAD obj ) {\n@@ -540,0 +664,1 @@\n+\n@@ -541,1 +666,1 @@\n-    public void visitL2I(final L2I obj) {\n+    public void visitDUP2( final DUP2 obj ) {\n@@ -544,0 +669,1 @@\n+\n@@ -545,1 +671,1 @@\n-    public void visitLADD(final LADD obj) {\n+    public void visitIF_ACMPEQ( final IF_ACMPEQ obj ) {\n@@ -548,0 +674,1 @@\n+\n@@ -549,1 +676,1 @@\n-    public void visitLALOAD(final LALOAD obj) {\n+    public void visitIMPDEP1( final IMPDEP1 obj ) {\n@@ -552,0 +679,1 @@\n+\n@@ -553,1 +681,1 @@\n-    public void visitLAND(final LAND obj) {\n+    public void visitMONITORENTER( final MONITORENTER obj ) {\n@@ -556,0 +684,1 @@\n+\n@@ -557,1 +686,1 @@\n-    public void visitLASTORE(final LASTORE obj) {\n+    public void visitLSHL( final LSHL obj ) {\n@@ -560,0 +689,1 @@\n+\n@@ -561,1 +691,1 @@\n-    public void visitLCMP(final LCMP obj) {\n+    public void visitDCMPG( final DCMPG obj ) {\n@@ -564,0 +694,1 @@\n+\n@@ -565,1 +696,1 @@\n-    public void visitLCONST(final LCONST obj) {\n+    public void visitD2L( final D2L obj ) {\n@@ -568,0 +699,1 @@\n+\n@@ -569,1 +701,1 @@\n-    public void visitLDC(final LDC obj) {\n+    public void visitIMPDEP2( final IMPDEP2 obj ) {\n@@ -572,0 +704,1 @@\n+\n@@ -573,1 +706,1 @@\n-    public void visitLDC2_W(final LDC2_W obj) {\n+    public void visitL2D( final L2D obj ) {\n@@ -576,0 +709,1 @@\n+\n@@ -577,1 +711,1 @@\n-    public void visitLDIV(final LDIV obj) {\n+    public void visitRET( final RET obj ) {\n@@ -580,0 +714,1 @@\n+\n@@ -581,1 +716,1 @@\n-    public void visitLLOAD(final LLOAD obj) {\n+    public void visitIFGT( final IFGT obj ) {\n@@ -584,0 +719,1 @@\n+\n@@ -585,1 +721,1 @@\n-    public void visitLMUL(final LMUL obj) {\n+    public void visitIXOR( final IXOR obj ) {\n@@ -588,0 +724,1 @@\n+\n@@ -589,1 +726,1 @@\n-    public void visitLNEG(final LNEG obj) {\n+    public void visitINVOKEVIRTUAL( final INVOKEVIRTUAL obj ) {\n@@ -592,0 +729,1 @@\n+\n@@ -593,1 +731,1 @@\n-    public void visitLoadClass(final LoadClass obj) {\n+    public void visitFASTORE( final FASTORE obj ) {\n@@ -596,0 +734,1 @@\n+\n@@ -597,1 +736,1 @@\n-    public void visitLoadInstruction(final LoadInstruction obj) {\n+    public void visitIRETURN( final IRETURN obj ) {\n@@ -600,0 +739,1 @@\n+\n@@ -601,1 +741,1 @@\n-    public void visitLocalVariableInstruction(final LocalVariableInstruction obj) {\n+    public void visitIF_ICMPNE( final IF_ICMPNE obj ) {\n@@ -604,0 +744,1 @@\n+\n@@ -605,1 +746,1 @@\n-    public void visitLOOKUPSWITCH(final LOOKUPSWITCH obj) {\n+    public void visitFLOAD( final FLOAD obj ) {\n@@ -608,0 +749,1 @@\n+\n@@ -609,1 +751,1 @@\n-    public void visitLOR(final LOR obj) {\n+    public void visitLDIV( final LDIV obj ) {\n@@ -612,0 +754,1 @@\n+\n@@ -613,1 +756,1 @@\n-    public void visitLREM(final LREM obj) {\n+    public void visitPUTSTATIC( final PUTSTATIC obj ) {\n@@ -616,0 +759,1 @@\n+\n@@ -617,1 +761,1 @@\n-    public void visitLRETURN(final LRETURN obj) {\n+    public void visitAALOAD( final AALOAD obj ) {\n@@ -620,0 +764,1 @@\n+\n@@ -621,1 +766,1 @@\n-    public void visitLSHL(final LSHL obj) {\n+    public void visitD2I( final D2I obj ) {\n@@ -624,0 +769,1 @@\n+\n@@ -625,1 +771,1 @@\n-    public void visitLSHR(final LSHR obj) {\n+    public void visitIF_ICMPEQ( final IF_ICMPEQ obj ) {\n@@ -628,0 +774,1 @@\n+\n@@ -629,1 +776,1 @@\n-    public void visitLSTORE(final LSTORE obj) {\n+    public void visitAASTORE( final AASTORE obj ) {\n@@ -632,0 +779,1 @@\n+\n@@ -633,1 +781,1 @@\n-    public void visitLSUB(final LSUB obj) {\n+    public void visitARETURN( final ARETURN obj ) {\n@@ -636,0 +784,1 @@\n+\n@@ -637,1 +786,1 @@\n-    public void visitLUSHR(final LUSHR obj) {\n+    public void visitDUP2_X1( final DUP2_X1 obj ) {\n@@ -640,0 +789,1 @@\n+\n@@ -641,1 +791,1 @@\n-    public void visitLXOR(final LXOR obj) {\n+    public void visitFNEG( final FNEG obj ) {\n@@ -644,0 +794,1 @@\n+\n@@ -645,1 +796,1 @@\n-    public void visitMONITORENTER(final MONITORENTER obj) {\n+    public void visitGOTO_W( final GOTO_W obj ) {\n@@ -648,0 +799,1 @@\n+\n@@ -649,1 +801,1 @@\n-    public void visitMONITOREXIT(final MONITOREXIT obj) {\n+    public void visitD2F( final D2F obj ) {\n@@ -652,0 +804,1 @@\n+\n@@ -653,1 +806,1 @@\n-    public void visitMULTIANEWARRAY(final MULTIANEWARRAY obj) {\n+    public void visitGOTO( final GOTO obj ) {\n@@ -656,0 +809,1 @@\n+\n@@ -657,1 +811,1 @@\n-    public void visitNEW(final NEW obj) {\n+    public void visitISUB( final ISUB obj ) {\n@@ -660,0 +814,1 @@\n+\n@@ -661,1 +816,1 @@\n-    public void visitNEWARRAY(final NEWARRAY obj) {\n+    public void visitF2I( final F2I obj ) {\n@@ -664,0 +819,1 @@\n+\n@@ -665,1 +821,1 @@\n-    public void visitNOP(final NOP obj) {\n+    public void visitDNEG( final DNEG obj ) {\n@@ -668,0 +824,1 @@\n+\n@@ -669,1 +826,1 @@\n-    public void visitPOP(final POP obj) {\n+    public void visitICONST( final ICONST obj ) {\n@@ -672,0 +829,1 @@\n+\n@@ -673,1 +831,1 @@\n-    public void visitPOP2(final POP2 obj) {\n+    public void visitFDIV( final FDIV obj ) {\n@@ -676,0 +834,1 @@\n+\n@@ -677,1 +836,1 @@\n-    public void visitPopInstruction(final PopInstruction obj) {\n+    public void visitI2B( final I2B obj ) {\n@@ -680,0 +839,1 @@\n+\n@@ -681,1 +841,1 @@\n-    public void visitPushInstruction(final PushInstruction obj) {\n+    public void visitLNEG( final LNEG obj ) {\n@@ -684,0 +844,1 @@\n+\n@@ -685,1 +846,1 @@\n-    public void visitPUTFIELD(final PUTFIELD obj) {\n+    public void visitLREM( final LREM obj ) {\n@@ -688,0 +849,1 @@\n+\n@@ -689,1 +851,1 @@\n-    public void visitPUTSTATIC(final PUTSTATIC obj) {\n+    public void visitIMUL( final IMUL obj ) {\n@@ -692,0 +854,1 @@\n+\n@@ -693,1 +856,1 @@\n-    public void visitRET(final RET obj) {\n+    public void visitIADD( final IADD obj ) {\n@@ -696,0 +859,1 @@\n+\n@@ -697,1 +861,1 @@\n-    public void visitRETURN(final RETURN obj) {\n+    public void visitLSHR( final LSHR obj ) {\n@@ -700,0 +864,1 @@\n+\n@@ -701,1 +866,1 @@\n-    public void visitReturnInstruction(final ReturnInstruction obj) {\n+    public void visitLOOKUPSWITCH( final LOOKUPSWITCH obj ) {\n@@ -704,0 +869,1 @@\n+\n@@ -705,1 +871,1 @@\n-    public void visitSALOAD(final SALOAD obj) {\n+    public void visitDUP_X1( final DUP_X1 obj ) {\n@@ -708,0 +874,1 @@\n+\n@@ -709,1 +876,1 @@\n-    public void visitSASTORE(final SASTORE obj) {\n+    public void visitFCMPL( final FCMPL obj ) {\n@@ -712,0 +879,1 @@\n+\n@@ -713,1 +881,1 @@\n-    public void visitSelect(final Select obj) {\n+    public void visitI2C( final I2C obj ) {\n@@ -716,0 +884,1 @@\n+\n@@ -717,1 +886,1 @@\n-    public void visitSIPUSH(final SIPUSH obj) {\n+    public void visitLMUL( final LMUL obj ) {\n@@ -720,0 +889,1 @@\n+\n@@ -721,1 +891,1 @@\n-    public void visitStackConsumer(final StackConsumer obj) {\n+    public void visitLUSHR( final LUSHR obj ) {\n@@ -724,0 +894,1 @@\n+\n@@ -725,1 +896,1 @@\n-    public void visitStackInstruction(final StackInstruction obj) {\n+    public void visitISHL( final ISHL obj ) {\n@@ -728,0 +899,1 @@\n+\n@@ -729,1 +901,1 @@\n-    public void visitStackProducer(final StackProducer obj) {\n+    public void visitLALOAD( final LALOAD obj ) {\n@@ -732,0 +904,1 @@\n+\n@@ -733,1 +906,1 @@\n-    public void visitStoreInstruction(final StoreInstruction obj) {\n+    public void visitASTORE( final ASTORE obj ) {\n@@ -736,0 +909,1 @@\n+\n@@ -737,1 +911,1 @@\n-    public void visitSWAP(final SWAP obj) {\n+    public void visitANEWARRAY( final ANEWARRAY obj ) {\n@@ -740,0 +914,1 @@\n+\n@@ -741,1 +916,1 @@\n-    public void visitTABLESWITCH(final TABLESWITCH obj) {\n+    public void visitFRETURN( final FRETURN obj ) {\n@@ -744,0 +919,1 @@\n+\n@@ -745,1 +921,1 @@\n-    public void visitTypedInstruction(final TypedInstruction obj) {\n+    public void visitFADD( final FADD obj ) {\n@@ -748,0 +924,1 @@\n+\n@@ -749,1 +926,1 @@\n-    public void visitUnconditionalBranch(final UnconditionalBranch obj) {\n+    public void visitBREAKPOINT( final BREAKPOINT obj ) {\n@@ -752,0 +929,3 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n@@ -753,1 +933,1 @@\n-    public void visitVariableLengthInstruction(final VariableLengthInstruction obj) {\n+    public void visitINVOKEDYNAMIC(final INVOKEDYNAMIC obj) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/EmptyVisitor.java","additions":364,"deletions":184,"binary":false,"changes":548,"status":"modified"},{"patch":"@@ -34,1 +34,2 @@\n-public class EnumElementValueGen extends ElementValueGen {\n+public class EnumElementValueGen extends ElementValueGen\n+{\n@@ -36,1 +37,1 @@\n-    private final int typeIdx;\n+    private int typeIdx;\n@@ -38,14 +39,1 @@\n-    private final int valueIdx;\n-\n-    public EnumElementValueGen(final EnumElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n-        super(ENUM_CONSTANT, cpool);\n-        if (copyPoolEntries) {\n-            typeIdx = cpool.addUtf8(value.getEnumTypeString());\/\/ was\n-                                                               \/\/ addClass(value.getEnumTypeString());\n-            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was\n-                                                                  \/\/ addString(value.getEnumValueString());\n-        } else {\n-            typeIdx = value.getTypeIndex();\n-            valueIdx = value.getValueIndex();\n-        }\n-    }\n+    private int valueIdx;\n@@ -54,2 +42,3 @@\n-     * This ctor assumes the constant pool already contains the right type and value - as indicated by typeIdx and valueIdx.\n-     * This ctor is used for deserialization\n+     * This ctor assumes the constant pool already contains the right type and\n+     * value - as indicated by typeIdx and valueIdx. This ctor is used for\n+     * deserialization\n@@ -57,1 +46,3 @@\n-    protected EnumElementValueGen(final int typeIdx, final int valueIdx, final ConstantPoolGen cpool) {\n+    protected EnumElementValueGen(final int typeIdx, final int valueIdx,\n+            final ConstantPoolGen cpool)\n+    {\n@@ -60,1 +51,3 @@\n-            throw new IllegalArgumentException(\"Only element values of type enum can be built with this ctor - type specified: \" + super.getElementValueType());\n+            throw new IllegalArgumentException(\n+                    \"Only element values of type enum can be built with this ctor - type specified: \"\n+                            + super.getElementValueType());\n@@ -66,1 +59,14 @@\n-    public EnumElementValueGen(final ObjectType t, final String value, final ConstantPoolGen cpool) {\n+    \/**\n+     * Return immutable variant of this EnumElementValue\n+     *\/\n+    @Override\n+    public ElementValue getElementValue()\n+    {\n+        System.err.println(\"Duplicating value: \" + getEnumTypeString() + \":\"\n+                + getEnumValueString());\n+        return new EnumElementValue(super.getElementValueType(), typeIdx, valueIdx,\n+                getConstantPool().getConstantPool());\n+    }\n+\n+    public EnumElementValueGen(final ObjectType t, final String value, final ConstantPoolGen cpool)\n+    {\n@@ -72,0 +78,18 @@\n+    public EnumElementValueGen(final EnumElementValue value, final ConstantPoolGen cpool,\n+            final boolean copyPoolEntries)\n+    {\n+        super(ENUM_CONSTANT, cpool);\n+        if (copyPoolEntries)\n+        {\n+            typeIdx = cpool.addUtf8(value.getEnumTypeString());\/\/ was\n+                                                                \/\/ addClass(value.getEnumTypeString());\n+            valueIdx = cpool.addUtf8(value.getEnumValueString()); \/\/ was\n+                                                                    \/\/ addString(value.getEnumValueString());\n+        }\n+        else\n+        {\n+            typeIdx = value.getTypeIndex();\n+            valueIdx = value.getValueIndex();\n+        }\n+    }\n+\n@@ -73,1 +97,2 @@\n-    public void dump(final DataOutputStream dos) throws IOException {\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n@@ -79,3 +104,0 @@\n-    \/**\n-     * Return immutable variant of this EnumElementValue\n-     *\/\n@@ -83,3 +105,8 @@\n-    public ElementValue getElementValue() {\n-        System.err.println(\"Duplicating value: \" + getEnumTypeString() + \":\" + getEnumValueString());\n-        return new EnumElementValue(super.getElementValueType(), typeIdx, valueIdx, getConstantPool().getConstantPool());\n+    public String stringifyValue()\n+    {\n+        final ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(valueIdx);\n+        return cu8.getBytes();\n+        \/\/ ConstantString cu8 =\n+        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n+        \/\/ return\n+        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n@@ -90,1 +117,2 @@\n-    public String getEnumTypeString() {\n+    public String getEnumTypeString()\n+    {\n@@ -96,1 +124,2 @@\n-        return ((ConstantUtf8) getConstantPool().getConstant(typeIdx)).getBytes();\n+        return ((ConstantUtf8) getConstantPool().getConstant(typeIdx))\n+                .getBytes();\n@@ -100,1 +129,2 @@\n-    public String getEnumValueString() {\n+    public String getEnumValueString()\n+    {\n@@ -108,5 +138,2 @@\n-    public int getTypeIndex() {\n-        return typeIdx;\n-    }\n-\n-    public int getValueIndex() {\n+    public int getValueIndex()\n+    {\n@@ -116,8 +143,3 @@\n-    @Override\n-    public String stringifyValue() {\n-        final ConstantUtf8 cu8 = (ConstantUtf8) getConstantPool().getConstant(valueIdx);\n-        return cu8.getBytes();\n-        \/\/ ConstantString cu8 =\n-        \/\/ (ConstantString)getConstantPool().getConstant(valueIdx);\n-        \/\/ return\n-        \/\/ ((ConstantUtf8)getConstantPool().getConstant(cu8.getStringIndex())).getBytes();\n+    public int getTypeIndex()\n+    {\n+        return typeIdx;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/EnumElementValueGen.java","additions":66,"deletions":44,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n- * Denote an instruction that may throw a run-time or a linking exception (or both) during execution. This is not quite\n- * the truth as such; because all instructions may throw an java.lang.VirtualMachineError. These exceptions are omitted.\n+ * Denote an instruction that may throw a run-time or a linking\n+ * exception (or both) during execution.  This is not quite the truth\n+ * as such; because all instructions may throw an\n+ * java.lang.VirtualMachineError. These exceptions are omitted.\n@@ -28,3 +30,10 @@\n- * The Lava Language Specification specifies exactly which <i>RUN-TIME<\/i> and which <i>LINKING<\/i> exceptions each\n- * instruction may throw which is reflected by the implementers. Due to the structure of the JVM specification, it may\n- * be possible that an Instruction implementing this interface returns a Class[] of size 0.\n+ * The Lava Language Specification specifies exactly which\n+ * <i>RUN-TIME<\/i> and which <i>LINKING<\/i> exceptions each\n+ * instruction may throw which is reflected by the implementers.  Due\n+ * to the structure of the JVM specification, it may be possible that\n+ * an Instruction implementing this interface returns a Class[] of\n+ * size 0.\n+ *\n+ * Please note that we speak of an \"exception\" here when we mean any\n+ * \"Throwable\" object; so this term is equally used for \"Exception\"\n+ * and \"Error\" objects.\n@@ -32,2 +41,0 @@\n- * Please note that we speak of an \"exception\" here when we mean any \"Throwable\" object; so this term is equally used\n- * for \"Exception\" and \"Error\" objects.\n@@ -37,1 +44,1 @@\n-    Class<?>[] getExceptions();\n+    java.lang.Class<?>[] getExceptions();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ExceptionThrower.java","additions":15,"deletions":8,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert float to double\n+    \/** Convert float to double\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2D.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert float to int\n+    \/** Convert float to int\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2I.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert float to long\n+    \/** Convert float to long\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/F2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Add floats\n+    \/** Add floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load float from array\n+    \/** Load float from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * FASTORE - Store into float array\n+ * FASTORE -  Store into float array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store float into array\n+    \/** Store float into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,9 @@\n+\n+    \/** @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.FLOAT;\n+    }\n+\n+\n@@ -38,2 +45,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +53,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +59,0 @@\n-\n-    \/**\n-     * @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.FLOAT;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCMPG.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,9 @@\n+\n+    \/** @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.FLOAT;\n+    }\n+\n+\n@@ -38,2 +45,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +53,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -50,8 +59,0 @@\n-\n-    \/**\n-     * @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.FLOAT;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCMPL.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n+ *\n@@ -33,1 +32,2 @@\n-    private final float value;\n+    private float value;\n+\n@@ -36,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,1 +40,0 @@\n-        this(0);\n@@ -42,0 +42,1 @@\n+\n@@ -56,0 +57,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return value;\n+    }\n+\n+\n+    \/** @return Type.FLOAT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.FLOAT;\n+    }\n+\n+\n@@ -57,2 +73,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -63,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,13 +88,0 @@\n-\n-    \/**\n-     * @return Type.FLOAT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.FLOAT;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Float.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FCONST.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Divide floats\n+    \/** Divide floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FDIV.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack ... -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack ... -&gt; ..., result\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Load float from local variable\n-     *\n+\n+    \/** Load float from local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FLOAD.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Multiply floats\n+    \/** Multiply floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FNEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Remainder of floats\n+    \/** Remainder of floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FREM.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * FRETURN - Return float from method\n+ * FRETURN -  Return float from method\n+ * <PRE>Stack: ..., value -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Return float from method\n+    \/** Return float from method\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Store float into local variable\n-     *\n+\n+    \/** Store float into local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FSTORE.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Substract floats\n+    \/** Substract floats\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FSUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.util.stream.Stream;\n@@ -28,0 +27,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.AnnotationEntry;\n@@ -39,2 +39,3 @@\n- * Template class for building up a field. The only extraordinary thing one can do is to add a constant value attribute\n- * to a field (which must of course be compatible with to the declared type).\n+ * Template class for building up a field.  The only extraordinary thing\n+ * one can do is to add a constant value attribute to a field (which must of\n+ * course be compatible with to the declared type).\n@@ -47,0 +48,1 @@\n+    private Object value = null;\n@@ -50,1 +52,1 @@\n-        public boolean equals(final Object o1, final Object o2) {\n+        public boolean equals( final Object o1, final Object o2 ) {\n@@ -53,1 +55,2 @@\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n@@ -56,0 +59,1 @@\n+\n@@ -57,1 +61,1 @@\n-        public int hashCode(final Object o) {\n+        public int hashCode( final Object o ) {\n@@ -63,6 +67,0 @@\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n@@ -71,1 +69,8 @@\n-     * @param comparator Comparison strategy object\n+     * Declare a field. If it is static (isStatic() == true) and has a\n+     * basic type like int or String it may have an initial value\n+     * associated with it as defined by setInitValue().\n+     *\n+     * @param access_flags access qualifiers\n+     * @param type  field type\n+     * @param name field name\n+     * @param cp constant pool\n@@ -73,2 +78,5 @@\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n+    public FieldGen(final int access_flags, final Type type, final String name, final ConstantPoolGen cp) {\n+        super(access_flags);\n+        setType(type);\n+        setName(name);\n+        setConstantPool(cp);\n@@ -77,3 +85,0 @@\n-    private Object value;\n-\n-    private List<FieldObserver> observers;\n@@ -94,2 +99,5 @@\n-                final Annotations runtimeAnnotations = (Annotations) attr;\n-                runtimeAnnotations.forEach(element -> addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n+                final Annotations runtimeAnnotations = (Annotations)attr;\n+                final AnnotationEntry[] annotationEntries = runtimeAnnotations.getAnnotationEntries();\n+                for (final AnnotationEntry element : annotationEntries) {\n+                    addAnnotationEntry(new AnnotationEntryGen(element,cp,false));\n+                }\n@@ -102,0 +110,8 @@\n+\n+    private void setValue( final int index ) {\n+        final ConstantPool cp = super.getConstantPool().getConstantPool();\n+        final Constant c = cp.getConstant(index);\n+        value = ((ConstantObject) c).getConstantValue(cp);\n+    }\n+\n+\n@@ -103,7 +119,2 @@\n-     * Declare a field. If it is static (isStatic() == true) and has a basic type like int or String it may have an initial\n-     * value associated with it as defined by setInitValue().\n-     *\n-     * @param accessFlags access qualifiers\n-     * @param type field type\n-     * @param name field name\n-     * @param cp constant pool\n+     * Set (optional) initial value of field, otherwise it will be set to null\/0\/false\n+     * by the JVM automatically.\n@@ -111,5 +122,5 @@\n-    public FieldGen(final int accessFlags, final Type type, final String name, final ConstantPoolGen cp) {\n-        super(accessFlags);\n-        setType(type);\n-        setName(name);\n-        setConstantPool(cp);\n+    public void setInitValue( final String str ) {\n+        checkType(  ObjectType.getInstance(\"java.lang.String\"));\n+        if (str != null) {\n+            value = str;\n+        }\n@@ -118,2 +129,6 @@\n-    private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        Stream.of(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries())).forEach(this::addAttribute);\n+\n+    public void setInitValue( final long l ) {\n+        checkType(Type.LONG);\n+        if (l != 0L) {\n+            value = Long.valueOf(l);\n+        }\n@@ -122,18 +137,5 @@\n-    private int addConstant() {\n-        switch (super.getType().getType()) { \/\/ sic\n-        case Const.T_INT:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-        case Const.T_BOOLEAN:\n-        case Const.T_SHORT:\n-            return super.getConstantPool().addInteger(((Integer) value).intValue());\n-        case Const.T_FLOAT:\n-            return super.getConstantPool().addFloat(((Float) value).floatValue());\n-        case Const.T_DOUBLE:\n-            return super.getConstantPool().addDouble(((Double) value).doubleValue());\n-        case Const.T_LONG:\n-            return super.getConstantPool().addLong(((Long) value).longValue());\n-        case Const.T_REFERENCE:\n-            return super.getConstantPool().addString((String) value);\n-        default:\n-            throw new IllegalStateException(\"Unhandled : \" + super.getType().getType()); \/\/ sic\n+\n+    public void setInitValue( final int i ) {\n+        checkType(Type.INT);\n+        if (i != 0) {\n+            value = Integer.valueOf(i);\n@@ -143,6 +145,5 @@\n-    \/**\n-     * Add observer for this object.\n-     *\/\n-    public void addObserver(final FieldObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n+\n+    public void setInitValue( final short s ) {\n+        checkType(Type.SHORT);\n+        if (s != 0) {\n+            value = Integer.valueOf(s);\n@@ -150,1 +151,0 @@\n-        observers.add(o);\n@@ -153,2 +153,42 @@\n-    \/**\n-     * Remove any initial value.\n+\n+    public void setInitValue( final char c ) {\n+        checkType(Type.CHAR);\n+        if (c != 0) {\n+            value = Integer.valueOf(c);\n+        }\n+    }\n+\n+\n+    public void setInitValue( final byte b ) {\n+        checkType(Type.BYTE);\n+        if (b != 0) {\n+            value = Integer.valueOf(b);\n+        }\n+    }\n+\n+\n+    public void setInitValue( final boolean b ) {\n+        checkType(Type.BOOLEAN);\n+        if (b) {\n+            value = Integer.valueOf(1);\n+        }\n+    }\n+\n+\n+    public void setInitValue( final float f ) {\n+        checkType(Type.FLOAT);\n+        if (f != 0.0) {\n+            value = f;\n+        }\n+    }\n+\n+\n+    public void setInitValue( final double d ) {\n+        checkType(Type.DOUBLE);\n+        if (d != 0.0) {\n+            value = d;\n+        }\n+    }\n+\n+\n+    \/** Remove any initial value.\n@@ -160,1 +200,2 @@\n-    private void checkType(final Type atype) {\n+\n+    private void checkType( final Type atype ) {\n@@ -173,19 +214,0 @@\n-    \/**\n-     * @return deep copy of this field\n-     *\/\n-    public FieldGen copy(final ConstantPoolGen cp) {\n-        final FieldGen fg = (FieldGen) clone();\n-        fg.setConstantPool(cp);\n-        return fg;\n-    }\n-\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default two FieldGen objects are said to be equal when\n-     * their names and signatures are equal.\n-     *\n-     * @see Object#equals(Object)\n-     *\/\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n-    }\n@@ -198,2 +220,2 @@\n-        final int nameIndex = super.getConstantPool().addUtf8(super.getName());\n-        final int signatureIndex = super.getConstantPool().addUtf8(signature);\n+        final int name_index = super.getConstantPool().addUtf8(super.getName());\n+        final int signature_index = super.getConstantPool().addUtf8(signature);\n@@ -203,1 +225,2 @@\n-            addAttribute(new ConstantValue(super.getConstantPool().addUtf8(\"ConstantValue\"), 2, index, super.getConstantPool().getConstantPool())); \/\/ sic\n+            addAttribute(new ConstantValue(super.getConstantPool().addUtf8(\"ConstantValue\"), 2, index,\n+                    super.getConstantPool().getConstantPool())); \/\/ sic\n@@ -206,1 +229,2 @@\n-        return new Field(super.getAccessFlags(), nameIndex, signatureIndex, getAttributes(), super.getConstantPool().getConstantPool()); \/\/ sic\n+        return new Field(super.getAccessFlags(), name_index, signature_index, getAttributes(),\n+                super.getConstantPool().getConstantPool()); \/\/ sic\n@@ -209,3 +233,26 @@\n-    public String getInitValue() {\n-        if (value != null) {\n-            return value.toString();\n+    private void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+          final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+      }\n+\n+\n+    private int addConstant() {\n+        switch (super.getType().getType()) { \/\/ sic\n+            case Const.T_INT:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+            case Const.T_BOOLEAN:\n+            case Const.T_SHORT:\n+                return super.getConstantPool().addInteger(((Integer) value));\n+            case Const.T_FLOAT:\n+                return super.getConstantPool().addFloat(((Float) value));\n+            case Const.T_DOUBLE:\n+                return super.getConstantPool().addDouble(((Double) value));\n+            case Const.T_LONG:\n+                return super.getConstantPool().addLong(((Long) value));\n+            case Const.T_REFERENCE:\n+                return super.getConstantPool().addString((String) value);\n+            default:\n+                throw new IllegalStateException(\"Unhandled : \" + super.getType().getType()); \/\/ sic\n@@ -213,1 +260,0 @@\n-        return null;\n@@ -216,0 +262,1 @@\n+\n@@ -221,26 +268,1 @@\n-    \/**\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the field's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    \/**\n-     * Remove observer for this object.\n-     *\/\n-    public void removeObserver(final FieldObserver o) {\n-        if (observers != null) {\n-            observers.remove(o);\n-        }\n-    }\n-\n-    public void setInitValue(final boolean b) {\n-        checkType(Type.BOOLEAN);\n-        if (b) {\n-            value = Integer.valueOf(1);\n-        }\n-    }\n+    private List<FieldObserver> observers;\n@@ -248,6 +270,0 @@\n-    public void setInitValue(final byte b) {\n-        checkType(Type.BYTE);\n-        if (b != 0) {\n-            value = Integer.valueOf(b);\n-        }\n-    }\n@@ -255,4 +271,5 @@\n-    public void setInitValue(final char c) {\n-        checkType(Type.CHAR);\n-        if (c != 0) {\n-            value = Integer.valueOf(c);\n+    \/** Add observer for this object.\n+     *\/\n+    public void addObserver( final FieldObserver o ) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n@@ -260,0 +277,1 @@\n+        observers.add(o);\n@@ -262,6 +280,0 @@\n-    public void setInitValue(final double d) {\n-        checkType(Type.DOUBLE);\n-        if (d != 0.0) {\n-            value = Double.valueOf(d);\n-        }\n-    }\n@@ -269,4 +281,5 @@\n-    public void setInitValue(final float f) {\n-        checkType(Type.FLOAT);\n-        if (f != 0.0) {\n-            value = Float.valueOf(f);\n+    \/** Remove observer for this object.\n+     *\/\n+    public void removeObserver( final FieldObserver o ) {\n+        if (observers != null) {\n+            observers.remove(o);\n@@ -276,6 +289,0 @@\n-    public void setInitValue(final int i) {\n-        checkType(Type.INT);\n-        if (i != 0) {\n-            value = Integer.valueOf(i);\n-        }\n-    }\n@@ -283,4 +290,9 @@\n-    public void setInitValue(final long l) {\n-        checkType(Type.LONG);\n-        if (l != 0L) {\n-            value = Long.valueOf(l);\n+    \/** Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be\n+     * called by the user after he has finished editing the object.\n+     *\/\n+    public void update() {\n+        if (observers != null) {\n+            for (final FieldObserver observer : observers ) {\n+                observer.notify(this);\n+            }\n@@ -290,6 +302,0 @@\n-    public void setInitValue(final short s) {\n-        checkType(Type.SHORT);\n-        if (s != 0) {\n-            value = Integer.valueOf(s);\n-        }\n-    }\n@@ -297,7 +303,3 @@\n-    \/**\n-     * Set (optional) initial value of field, otherwise it will be set to null\/0\/false by the JVM automatically.\n-     *\/\n-    public void setInitValue(final String str) {\n-        checkType(ObjectType.getInstance(\"java.lang.String\"));\n-        if (str != null) {\n-            value = str;\n+    public String getInitValue() {\n+        if (value != null) {\n+            return value.toString();\n@@ -305,0 +307,1 @@\n+        return null;\n@@ -307,5 +310,0 @@\n-    private void setValue(final int index) {\n-        final ConstantPool cp = super.getConstantPool().getConstantPool();\n-        final Constant c = cp.getConstant(index);\n-        value = ((ConstantObject) c).getConstantValue(cp);\n-    }\n@@ -314,1 +312,2 @@\n-     * Return string representation close to declaration format, 'public static final short MAX = 100', e.g..\n+     * Return string representation close to declaration format,\n+     * `public static final short MAX = 100', e.g..\n@@ -324,1 +323,1 @@\n-        access = access.isEmpty() ? \"\" : access + \" \";\n+        access = access.isEmpty() ? \"\" : (access + \" \");\n@@ -336,0 +335,10 @@\n+\n+    \/** @return deep copy of this field\n+     *\/\n+    public FieldGen copy( final ConstantPoolGen cp ) {\n+        final FieldGen fg = (FieldGen) clone();\n+        fg.setConstantPool(cp);\n+        return fg;\n+    }\n+\n+\n@@ -337,2 +346,1 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after they have finished editing the object.\n+     * @return Comparison strategy object\n@@ -340,6 +348,35 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final FieldObserver observer : observers) {\n-                observer.notify(this);\n-            }\n-        }\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two FieldGen objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the field's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGen.java","additions":210,"deletions":173,"binary":false,"changes":383,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-import java.util.Collections;\n@@ -31,1 +30,2 @@\n- * Super class for FieldGen and MethodGen objects, since they have some methods in common!\n+ * Super class for FieldGen and MethodGen objects, since they have\n+ * some methods in common!\n@@ -37,17 +37,3 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected String name;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected Type type;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected ConstantPoolGen cp;\n+    private String name;\n+    private Type type;\n+    private ConstantPoolGen cp;\n@@ -60,2 +46,0 @@\n-    protected FieldGenOrMethodGen() {\n-    }\n@@ -63,5 +47,1 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    protected FieldGenOrMethodGen(final int accessFlags) { \/\/ TODO could this be package protected?\n-        super(accessFlags);\n+    protected FieldGenOrMethodGen() {\n@@ -70,3 +50,0 @@\n-    protected void addAll(final Attribute[] attrs) {\n-        Collections.addAll(attributeList, attrs);\n-    }\n@@ -77,12 +54,2 @@\n-    public void addAnnotationEntry(final AnnotationEntryGen ag) {\n-        annotationList.add(ag);\n-    }\n-\n-    \/**\n-     * Add an attribute to this method. Currently, the JVM knows about the 'Code', 'ConstantValue', 'Synthetic' and\n-     * 'Exceptions' attributes. Other attributes will be ignored by the JVM but do no harm.\n-     *\n-     * @param a attribute to be added\n-     *\/\n-    public void addAttribute(final Attribute a) {\n-        attributeList.add(a);\n+    protected FieldGenOrMethodGen(final int access_flags) { \/\/ TODO could this be package protected?\n+        super(access_flags);\n@@ -92,5 +59,3 @@\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n+    public void setType( final Type type ) { \/\/ TODO could be package-protected?\n+        if (type.getType() == Const.T_ADDRESS) {\n+            throw new IllegalArgumentException(\"Type can not be \" + type);\n@@ -98,0 +63,1 @@\n+        this.type = type;\n@@ -100,3 +66,0 @@\n-    public AnnotationEntryGen[] getAnnotationEntries() {\n-        return annotationList.toArray(AnnotationEntryGen.EMPTY_ARRAY);\n-    }\n@@ -104,5 +67,3 @@\n-    \/**\n-     * @return all attributes of this method.\n-     *\/\n-    public Attribute[] getAttributes() {\n-        return attributeList.toArray(Attribute.EMPTY_ARRAY);\n+    @Override\n+    public Type getType() {\n+        return type;\n@@ -111,3 +72,0 @@\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n-    }\n@@ -115,2 +73,1 @@\n-    \/**\n-     * @return name of method\/field.\n+    \/** @return name of method\/field.\n@@ -123,4 +80,0 @@\n-    \/**\n-     * @return signature of method\/field.\n-     *\/\n-    public abstract String getSignature();\n@@ -129,2 +82,7 @@\n-    public Type getType() {\n-        return type;\n+    public void setName( final String name ) { \/\/ TODO could be package-protected?\n+        this.name = name;\n+    }\n+\n+\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n@@ -133,0 +91,6 @@\n+\n+    public void setConstantPool( final ConstantPoolGen cp ) { \/\/ TODO could be package-protected?\n+        this.cp = cp;\n+    }\n+\n+\n@@ -134,1 +98,6 @@\n-     * @since 6.0\n+     * Add an attribute to this method. Currently, the JVM knows about\n+     * the `Code', `ConstantValue', `Synthetic' and `Exceptions'\n+     * attributes. Other attributes will be ignored by the JVM but do no\n+     * harm.\n+     *\n+     * @param a attribute to be added\n@@ -136,2 +105,2 @@\n-    public void removeAnnotationEntries() {\n-        annotationList.clear();\n+    public void addAttribute( final Attribute a ) {\n+        attributeList.add(a);\n@@ -143,2 +112,3 @@\n-    public void removeAnnotationEntry(final AnnotationEntryGen ag) {\n-        annotationList.remove(ag);\n+    public void addAnnotationEntry(final AnnotationEntryGen ag)\n+    {\n+        annotationList.add(ag);\n@@ -147,0 +117,1 @@\n+\n@@ -150,1 +121,1 @@\n-    public void removeAttribute(final Attribute a) {\n+    public void removeAttribute( final Attribute a ) {\n@@ -154,0 +125,9 @@\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void removeAnnotationEntry(final AnnotationEntryGen ag)\n+    {\n+        annotationList.remove(ag);\n+    }\n+\n+\n@@ -161,2 +141,6 @@\n-    public void setConstantPool(final ConstantPoolGen cp) { \/\/ TODO could be package-protected?\n-        this.cp = cp;\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void removeAnnotationEntries()\n+    {\n+        annotationList.clear();\n@@ -165,3 +149,6 @@\n-    @Override\n-    public void setName(final String name) { \/\/ TODO could be package-protected?\n-        this.name = name;\n+\n+    \/**\n+     * @return all attributes of this method.\n+     *\/\n+    public Attribute[] getAttributes() {\n+        return attributeList.toArray(new Attribute[0]);\n@@ -170,0 +157,10 @@\n+    public AnnotationEntryGen[] getAnnotationEntries() {\n+        return annotationList.toArray(new AnnotationEntryGen[0]);\n+      }\n+\n+\n+    \/** @return signature of method\/field.\n+     *\/\n+    public abstract String getSignature();\n+\n+\n@@ -171,3 +168,5 @@\n-    public void setType(final Type type) { \/\/ TODO could be package-protected?\n-        if (type.getType() == Const.T_ADDRESS) {\n-            throw new IllegalArgumentException(\"Type can not be \" + type);\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n@@ -175,1 +174,0 @@\n-        this.type = type;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldGenOrMethodGen.java","additions":78,"deletions":80,"binary":false,"changes":158,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ *\n@@ -32,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -37,0 +39,1 @@\n+\n@@ -44,0 +47,1 @@\n+\n@@ -45,1 +49,1 @@\n-     * @return name of referenced field.\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -47,2 +51,4 @@\n-    public String getFieldName(final ConstantPoolGen cpg) {\n-        return getName(cpg);\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \"\n+                + cp.constantToString(super.getIndex(), com.sun.org.apache.bcel.internal.Const.CONSTANT_Fieldref);\n@@ -51,2 +57,2 @@\n-    \/**\n-     * @return size of field (1 or 2)\n+\n+    \/** @return size of field (1 or 2)\n@@ -54,1 +60,1 @@\n-    protected int getFieldSize(final ConstantPoolGen cpg) {\n+    protected int getFieldSize( final ConstantPoolGen cpg ) {\n@@ -58,6 +64,0 @@\n-    \/**\n-     * @return type of field\n-     *\/\n-    public Type getFieldType(final ConstantPoolGen cpg) {\n-        return Type.getType(getSignature(cpg));\n-    }\n@@ -65,2 +65,1 @@\n-    \/**\n-     * @return return type of referenced field\n+    \/** @return return type of referenced field\n@@ -69,1 +68,1 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n+    public Type getType( final ConstantPoolGen cpg ) {\n@@ -73,2 +72,2 @@\n-    \/**\n-     * @return mnemonic for instruction with symbolic references resolved\n+\n+    \/** @return type of field\n@@ -76,3 +75,9 @@\n-    @Override\n-    public String toString(final ConstantPool cp) {\n-        return com.sun.org.apache.bcel.internal.Const.getOpcodeName(super.getOpcode()) + \" \" + cp.constantToString(super.getIndex(), com.sun.org.apache.bcel.internal.Const.CONSTANT_Fieldref);\n+    public Type getFieldType( final ConstantPoolGen cpg ) {\n+        return Type.getType(getSignature(cpg));\n+    }\n+\n+\n+    \/** @return name of referenced field.\n+     *\/\n+    public String getFieldName( final ConstantPoolGen cpg ) {\n+        return getName(cpg);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldInstruction.java","additions":26,"deletions":21,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Imnplement this interface if you're interested in changes to a FieldGen object and register yourself with\n- * addObserver().\n+ * Imnplement this interface if you're interested in changes to a FieldGen object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(FieldGen field);\n+    void notify( FieldGen field );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -32,1 +31,3 @@\n- * Super class for InvokeInstruction and FieldInstruction, since they have some methods in common!\n+ * Super class for InvokeInstruction and FieldInstruction, since they have\n+ * some methods in common!\n+ *\n@@ -37,1 +38,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -43,0 +45,1 @@\n+\n@@ -50,0 +53,21 @@\n+\n+    \/** @return signature of referenced method\/field.\n+     *\/\n+    public String getSignature(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n+        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();\n+    }\n+\n+\n+    \/** @return name of referenced method\/field.\n+     *\/\n+    public String getName(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n+        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n+    }\n+\n+\n@@ -52,4 +76,7 @@\n-     * @deprecated If the instruction references an array class, this method will return \"java.lang.Object\". For code\n-     *             generated by Java 1.5, this answer is sometimes wrong (e.g., if the \"clone()\" method is called on an\n-     *             array). A better idea is to use the {@link #getReferenceType(ConstantPoolGen)} method, which correctly\n-     *             distinguishes between class types and array types.\n+     * @deprecated If the instruction references an array class,\n+     *    this method will return \"java.lang.Object\".\n+     *    For code generated by Java 1.5, this answer is\n+     *    sometimes wrong (e.g., if the \"clone()\" method is\n+     *    called on an array).  A better idea is to use\n+     *    the {@link #getReferenceType(ConstantPoolGen)} method, which correctly distinguishes\n+     *    between class types and array types.\n@@ -67,1 +94,1 @@\n-        return Utility.pathToPackage(className);\n+        return className.replace('\/', '.');\n@@ -70,4 +97,5 @@\n-    \/**\n-     * @return type of the referenced class\/interface\n-     * @deprecated If the instruction references an array class, the ObjectType returned will be invalid. Use\n-     *             getReferenceType() instead.\n+\n+    \/** @return type of the referenced class\/interface\n+     * @deprecated If the instruction references an array class,\n+     *    the ObjectType returned will be invalid.  Use\n+     *    getReferenceType() instead.\n@@ -80,24 +108,0 @@\n-    \/**\n-     * Gets the ObjectType of the method return or field.\n-     *\n-     * @return type of the referenced class\/interface\n-     * @throws ClassGenException when the field is (or method returns) an array,\n-     *\/\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        final ReferenceType rt = getReferenceType(cpg);\n-        if (rt instanceof ObjectType) {\n-            return (ObjectType) rt;\n-        }\n-        throw new ClassGenException(rt.getClass().getCanonicalName() + \" \" + rt.getSignature() + \" does not represent an ObjectType\");\n-    }\n-\n-    \/**\n-     * @return name of referenced method\/field.\n-     *\/\n-    public String getName(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n-        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n-        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n-    }\n@@ -106,2 +110,2 @@\n-     * Gets the reference type representing the class, interface, or array class referenced by the instruction.\n-     *\n+     * Gets the reference type representing the class, interface,\n+     * or array class referenced by the instruction.\n@@ -109,2 +113,3 @@\n-     * @return an ObjectType (if the referenced class type is a class or interface), or an ArrayType (if the referenced\n-     *         class type is an array class)\n+     * @return an ObjectType (if the referenced class type is a class\n+     *   or interface), or an ArrayType (if the referenced class\n+     *   type is an array class)\n@@ -119,1 +124,1 @@\n-        className = Utility.pathToPackage(className);\n+        className = className.replace('\/', '.');\n@@ -123,0 +128,1 @@\n+\n@@ -124,1 +130,4 @@\n-     * @return signature of referenced method\/field.\n+     * Gets the ObjectType of the method return or field.\n+     *\n+     * @return type of the referenced class\/interface\n+     * @throws ClassGenException when the field is (or method returns) an array,\n@@ -126,5 +135,8 @@\n-    public String getSignature(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantCP cmr = (ConstantCP) cp.getConstant(super.getIndex());\n-        final ConstantNameAndType cnat = (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n-        return ((ConstantUtf8) cp.getConstant(cnat.getSignatureIndex())).getBytes();\n+    @Override\n+    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+        final ReferenceType rt = getReferenceType(cpg);\n+        if (rt instanceof ObjectType) {\n+            return (ObjectType) rt;\n+        }\n+        throw new ClassGenException(rt.getClass().getCanonicalName() + \" \" +\n+                rt.getSignature() + \" does not represent an ObjectType\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/FieldOrMethod.java","additions":59,"deletions":47,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -28,5 +28,1 @@\n- *\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., value\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., objectref -&gt; ..., value<\/PRE>\n@@ -34,0 +30,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ..., value.word1, value.word2<\/PRE>\n@@ -35,3 +32,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., value.word1, value.word2\n- * <\/PRE>\n@@ -39,1 +33,2 @@\n-public class GETFIELD extends FieldInstruction implements ExceptionThrower, StackConsumer, StackProducer {\n+public class GETFIELD extends FieldInstruction implements ExceptionThrower, StackConsumer,\n+        StackProducer {\n@@ -42,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -47,0 +43,1 @@\n+\n@@ -51,0 +48,15 @@\n+\n+    @Override\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -52,2 +64,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -58,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -69,11 +83,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-    @Override\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GETFIELD.java","additions":27,"deletions":24,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -29,5 +29,1 @@\n- *\n- * <PRE>\n- * Stack: ..., -&gt; ..., value\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., -&gt; ..., value<\/PRE>\n@@ -35,0 +31,1 @@\n+ * <PRE>Stack: ..., -&gt; ..., value.word1, value.word2<\/PRE>\n@@ -36,3 +33,0 @@\n- * <PRE>\n- * Stack: ..., -&gt; ..., value.word1, value.word2\n- * <\/PRE>\n@@ -43,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +43,1 @@\n+\n@@ -52,0 +48,14 @@\n+\n+    @Override\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +63,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,10 +82,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n-\n-    @Override\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GETSTATIC.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *\n@@ -33,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,0 +40,1 @@\n+\n@@ -42,14 +45,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitUnconditionalBranch(this);\n-        v.visitBranchInstruction(this);\n-        v.visitGotoInstruction(this);\n-        v.visitGOTO(this);\n-    }\n@@ -59,1 +48,0 @@\n-     *\n@@ -63,1 +51,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -65,2 +53,2 @@\n-        final short opcode = getOpcode();\n-        if (opcode == com.sun.org.apache.bcel.internal.Const.GOTO) {\n+        final short _opcode = getOpcode();\n+        if (_opcode == com.sun.org.apache.bcel.internal.Const.GOTO) {\n@@ -70,1 +58,1 @@\n-            out.writeByte(opcode);\n+            out.writeByte(_opcode);\n@@ -75,0 +63,1 @@\n+\n@@ -76,2 +65,2 @@\n-     * Called in pass 2 of InstructionList.setPositions() in order to update the branch target, that may shift due to\n-     * variable length instructions.\n+     * Called in pass 2 of InstructionList.setPositions() in order to update\n+     * the branch target, that may shift due to variable length instructions.\n@@ -80,1 +69,1 @@\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n@@ -84,1 +73,1 @@\n-    protected int updatePosition(final int offset, final int maxOffset) {\n+    protected int updatePosition( final int offset, final int max_offset ) {\n@@ -87,1 +76,1 @@\n-        if (Math.abs(i) >= Short.MAX_VALUE - maxOffset) { \/\/ to large for short (estimate)\n+        if (Math.abs(i) >= (Short.MAX_VALUE - max_offset)) { \/\/ to large for short (estimate)\n@@ -89,1 +78,1 @@\n-            final short oldLength = (short) super.getLength();\n+            final short old_length = (short) super.getLength();\n@@ -91,1 +80,1 @@\n-            return super.getLength() - oldLength;\n+            return super.getLength() - old_length;\n@@ -95,0 +84,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitUnconditionalBranch(this);\n+        v.visitBranchInstruction(this);\n+        v.visitGotoInstruction(this);\n+        v.visitGOTO(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GOTO.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -35,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +42,1 @@\n+\n@@ -45,13 +48,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitUnconditionalBranch(this);\n-        v.visitBranchInstruction(this);\n-        v.visitGotoInstruction(this);\n-        v.visitGOTO_W(this);\n-    }\n@@ -61,1 +51,0 @@\n-     *\n@@ -65,1 +54,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -71,0 +60,1 @@\n+\n@@ -75,1 +65,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -79,0 +69,17 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitUnconditionalBranch(this);\n+        v.visitBranchInstruction(this);\n+        v.visitGotoInstruction(this);\n+        v.visitGOTO_W(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GOTO_W.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -29,0 +30,5 @@\n+    GotoInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, target);\n+    }\n+\n+\n@@ -30,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -34,4 +41,0 @@\n-\n-    GotoInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, target);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/GotoInstruction.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to byte\n+    \/** Convert int to byte\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2B.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to char\n+    \/** Convert int to char\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2C.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to double\n+    \/** Convert int to double\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2D.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to float\n+    \/** Convert int to float\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2F.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Convert int to long\n+    \/** Convert int to long\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2L.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/I2S.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Add ints\n+    \/** Add ints\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -40,0 +38,1 @@\n+\n@@ -41,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IALOAD.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IAND.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * IASTORE - Store into int array\n+ * IASTORE -  Store into int array\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -40,0 +38,1 @@\n+\n@@ -41,2 +40,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +48,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IASTORE.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,3 +25,1 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n@@ -32,1 +30,2 @@\n-    private final int value;\n+    private int value;\n+\n@@ -35,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,1 +38,0 @@\n-        this(0);\n@@ -41,0 +40,1 @@\n+\n@@ -43,1 +43,3 @@\n-        if (i < -1 || i > 5) {\n+        if ((i >= -1) && (i <= 5)) {\n+            super.setOpcode((short) (com.sun.org.apache.bcel.internal.Const.ICONST_0 + i)); \/\/ Even works for i == -1\n+        } else {\n@@ -46,1 +48,0 @@\n-        super.setOpcode((short) (com.sun.org.apache.bcel.internal.Const.ICONST_0 + i)); \/\/ Even works for i == -1\n@@ -50,0 +51,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return Integer.valueOf(value);\n+    }\n+\n+\n+    \/** @return Type.INT\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.INT;\n+    }\n+\n+\n@@ -51,2 +67,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -57,1 +75,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -64,13 +82,0 @@\n-\n-    \/**\n-     * @return Type.INT\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.INT;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Integer.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ICONST.java","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -35,2 +33,1 @@\n-    \/**\n-     * Divide ints\n+    \/** Divide ints\n@@ -42,0 +39,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -43,2 +51,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +59,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -57,8 +67,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IDIV.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction, e.g. IFEQ.negate() == IFNE\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction, e.g. IFEQ.negate() == IFNE\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFEQ.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFLT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFLT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFGE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFLE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFLE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFGT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFGT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFGT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFLE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFGE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFGE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFLT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFEQ(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFEQ(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., reference -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., reference -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNULL(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNULL(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNONNULL.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., reference -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., reference -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IFNONNULL(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IFNONNULL(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IFNULL.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ACMPNE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ACMPNE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ACMPEQ.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ACMPEQ(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ACMPEQ(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ACMPNE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPNE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPNE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPEQ.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPLT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPLT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPGE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPLE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPLE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPGT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPGT(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPGT(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPLE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPGE(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPGE(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPLT.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., value1, value2 -&gt; ...<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,10 @@\n+\n+    \/**\n+     * @return negation of instruction\n+     *\/\n+    @Override\n+    public IfInstruction negate() {\n+        return new IF_ICMPEQ(super.getTarget());\n+    }\n+\n+\n@@ -44,2 +55,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +63,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,8 +69,0 @@\n-\n-    \/**\n-     * @return negation of instruction\n-     *\/\n-    @Override\n-    public IfInstruction negate() {\n-        return new IF_ICMPEQ(super.getTarget());\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IF_ICMPNE.java","additions":20,"deletions":15,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n@@ -32,0 +31,1 @@\n+ *\n@@ -38,0 +38,1 @@\n+\n@@ -39,1 +40,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -44,0 +46,1 @@\n+\n@@ -49,2 +52,2 @@\n-        \/\/ Default behavior of LocalVariableInstruction causes error\n-        super.setOpcode(Const.IINC);\n+        super(); \/\/ Default behavior of LocalVariableInstruction causes error\n+        super.setOpcode(com.sun.org.apache.bcel.internal.Const.IINC);\n@@ -56,11 +59,0 @@\n-    \/**\n-     * Calls corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitLocalVariableInstruction(this);\n-        v.visitIINC(this);\n-    }\n@@ -69,2 +61,1 @@\n-     * Dumps instruction as byte code to stream out.\n-     *\n+     * Dump instruction as byte code to stream out.\n@@ -74,1 +65,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -76,1 +67,1 @@\n-            out.writeByte(Const.WIDE);\n+            out.writeByte(com.sun.org.apache.bcel.internal.Const.WIDE);\n@@ -88,6 +79,0 @@\n-    \/**\n-     * @return increment factor\n-     *\/\n-    public final int getIncrement() {\n-        return c;\n-    }\n@@ -95,6 +80,12 @@\n-    \/**\n-     * @return int type\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.INT;\n+    private void setWide() {\n+        wide = super.getIndex() > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n+        if (c > 0) {\n+            wide = wide || (c > Byte.MAX_VALUE);\n+        } else {\n+            wide = wide || (c < Byte.MIN_VALUE);\n+        }\n+        if (wide) {\n+            super.setLength(6); \/\/ wide byte included\n+        } else {\n+            super.setLength(3);\n+        }\n@@ -103,0 +94,1 @@\n+\n@@ -104,1 +96,1 @@\n-     * Reads needed data (e.g. index) from file.\n+     * Read needed data (e.g. index) from file.\n@@ -107,1 +99,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -120,0 +112,1 @@\n+\n@@ -121,1 +114,1 @@\n-     * Sets increment factor.\n+     * @return mnemonic for instruction\n@@ -123,3 +116,3 @@\n-    public final void setIncrement(final int c) {\n-        this.c = c;\n-        setWide();\n+    @Override\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + c;\n@@ -128,0 +121,1 @@\n+\n@@ -129,1 +123,1 @@\n-     * Sets index of local variable.\n+     * Set index of local variable.\n@@ -132,1 +126,1 @@\n-    public final void setIndex(final int n) {\n+    public final void setIndex( final int n ) {\n@@ -140,12 +134,6 @@\n-    private void setWide() {\n-        wide = super.getIndex() > Const.MAX_BYTE;\n-        if (c > 0) {\n-            wide = wide || c > Byte.MAX_VALUE;\n-        } else {\n-            wide = wide || c < Byte.MIN_VALUE;\n-        }\n-        if (wide) {\n-            super.setLength(6); \/\/ wide byte included\n-        } else {\n-            super.setLength(3);\n-        }\n+\n+    \/**\n+     * @return increment factor\n+     *\/\n+    public final int getIncrement() {\n+        return c;\n@@ -154,0 +142,1 @@\n+\n@@ -155,1 +144,21 @@\n-     * Returns mnemonic for instruction.\n+     * Set increment factor.\n+     *\/\n+    public final void setIncrement( final int c ) {\n+        this.c = c;\n+        setWide();\n+    }\n+\n+\n+    \/** @return int type\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.INT;\n+    }\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -157,1 +166,1 @@\n-     * @return mnemonic for instruction.\n+     * @param v Visitor object\n@@ -160,2 +169,3 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + c;\n+    public void accept( final Visitor v ) {\n+        v.visitLocalVariableInstruction(this);\n+        v.visitIINC(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IINC.java","additions":65,"deletions":55,"binary":false,"changes":120,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ... -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., result\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Load int from local variable\n-     *\n+\n+    \/** Load int from local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ILOAD.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -33,0 +34,1 @@\n+\n@@ -34,2 +36,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -40,1 +44,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMPDEP1.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -33,0 +34,1 @@\n+\n@@ -34,2 +36,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -40,1 +44,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMPDEP2.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Multiply ints\n+    \/** Multiply ints\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ..., result<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ..., result\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class INSTANCEOF extends CPInstruction implements LoadClass, ExceptionThrower, StackProducer, StackConsumer {\n+public class INSTANCEOF extends CPInstruction implements LoadClass, ExceptionThrower,\n+        StackProducer, StackConsumer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,0 +41,1 @@\n+\n@@ -45,0 +46,17 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION);\n+    }\n+\n+\n+    @Override\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+        Type t = getType(cpg);\n+        if (t instanceof ArrayType) {\n+            t = ((ArrayType) t).getBasicType();\n+        }\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n+    }\n+\n+\n@@ -46,2 +64,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -52,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -61,14 +81,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION);\n-    }\n-\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        Type t = getType(cpg);\n-        if (t instanceof ArrayType) {\n-            t = ((ArrayType) t).getBasicType();\n-        }\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INSTANCEOF.java","additions":28,"deletions":22,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,2 +34,3 @@\n- * Class for INVOKEDYNAMIC. Not an instance of InvokeInstruction, since that class expects to be able to get the class\n- * of the method. Ignores the bootstrap mechanism entirely.\n+ * Class for INVOKEDYNAMIC. Not an instance of InvokeInstruction, since that class\n+ * expects to be able to get the class of the method. Ignores the bootstrap\n+ * mechanism entirely.\n@@ -37,2 +38,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\"> The\n- *      invokedynamic instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokedynamic\">\n+ * The invokedynamic instruction in The Java Virtual Machine Specification<\/a>\n@@ -40,1 +42,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -45,1 +47,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -50,0 +53,1 @@\n+\n@@ -54,0 +58,45 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+        out.writeByte(0);\n+        out.writeByte(0);\n+       }\n+\n+\n+    \/**\n+     * Read needed data (i.e., index) from file.\n+     *\/\n+    @Override\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.initFromFile(bytes, wide);\n+        super.setLength(5);\n+        bytes.readByte(); \/\/ Skip 0 byte\n+        bytes.readByte(); \/\/ Skip 0 byte\n+    }\n+\n+\n+    \/**\n+     * @return mnemonic for instruction with symbolic references resolved\n+     *\/\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        return super.toString(cp);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -55,2 +104,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -61,1 +112,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -74,1 +125,1 @@\n-     * Dump instruction as byte code to stream out.\n+     * Override the parent method because our classname is held elsewhere.\n@@ -76,12 +127,2 @@\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-        out.writeByte(0);\n-        out.writeByte(0);\n-    }\n-\n-    \/**\n-     * Override the parent method because our class name is held elsewhere.\n+     * @param cpg the ConstantPool generator\n+     * @deprecated in FieldOrMethod\n@@ -89,2 +130,1 @@\n-     * Note: Contrary to this method's name it does not return the class name of the invoke target; rather it returns the\n-     * name of the method that will be used to invoke the Lambda method generated by this invoke dynamic instruction.\n+     * @return name of the referenced class\/interface\n@@ -96,2 +136,2 @@\n-        final ConstantInvokeDynamic cid = cp.getConstant(super.getIndex(), Const.CONSTANT_InvokeDynamic, ConstantInvokeDynamic.class);\n-        return cp.getConstant(cid.getNameAndTypeIndex(), ConstantNameAndType.class).getName(cp);\n+        final ConstantInvokeDynamic cid = (ConstantInvokeDynamic) cp.getConstant(super.getIndex(), Const.CONSTANT_InvokeDynamic);\n+        return ((ConstantNameAndType) cp.getConstant(cid.getNameAndTypeIndex())).getName(cp);\n@@ -100,5 +140,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.ILLEGAL_ACCESS_ERROR, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n@@ -107,2 +142,2 @@\n-     * Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object, as that is the only type we can\n-     * say for sure the reference will be.\n+     * Since InvokeDynamic doesn't refer to a reference type, just return java.lang.Object,\n+     * as that is the only type we can say for sure the reference will be.\n@@ -110,1 +145,2 @@\n-     * @param cpg the ConstantPoolGen used to create the instruction\n+     * @param cpg\n+     *            the ConstantPoolGen used to create the instruction\n@@ -118,12 +154,0 @@\n-\n-    \/**\n-     * Read needed data (i.e., index) from file.\n-     *\/\n-    @Override\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.initFromFile(bytes, wide);\n-        super.setLength(5);\n-        bytes.readByte(); \/\/ Skip 0 byte\n-        bytes.readByte(); \/\/ Skip 0 byte\n-    }\n-\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEDYNAMIC.java","additions":71,"deletions":47,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+ * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -35,6 +36,3 @@\n- * <PRE>\n- * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n- *\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\"> The\n- *      invokeinterface instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokeinterface\">\n+ * The invokeinterface instruction in The Java Virtual Machine Specification<\/a>\n@@ -46,0 +44,1 @@\n+\n@@ -47,1 +46,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -52,0 +52,1 @@\n+\n@@ -61,23 +62,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitStackProducer(this);\n-        v.visitLoadClass(this);\n-        v.visitCPInstruction(this);\n-        v.visitFieldOrMethod(this);\n-        v.visitInvokeInstruction(this);\n-        v.visitINVOKEINTERFACE(this);\n-    }\n-\n-    @Override\n-    public int consumeStack(final ConstantPoolGen cpg) { \/\/ nargs is given in byte-code\n-        return nargs; \/\/ nargs includes this reference\n-    }\n@@ -87,1 +65,0 @@\n-     *\n@@ -91,1 +68,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -98,0 +75,1 @@\n+\n@@ -99,1 +77,2 @@\n-     * The <B>count<\/B> argument according to the Java Language Specification, Second Edition.\n+     * The <B>count<\/B> argument according to the Java Language Specification,\n+     * Second Edition.\n@@ -105,5 +84,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.ILLEGAL_ACCESS_ERROR, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n@@ -115,1 +89,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -122,0 +96,1 @@\n+\n@@ -126,1 +101,1 @@\n-    public String toString(final ConstantPool cp) {\n+    public String toString( final ConstantPool cp ) {\n@@ -129,0 +104,38 @@\n+\n+\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) { \/\/ nargs is given in byte-code\n+        return nargs; \/\/ nargs includes this reference\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_INTERFACE_METHOD_RESOLUTION,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitStackProducer(this);\n+        v.visitLoadClass(this);\n+        v.visitCPInstruction(this);\n+        v.visitFieldOrMethod(this);\n+        v.visitInvokeInstruction(this);\n+        v.visitINVOKEINTERFACE(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEINTERFACE.java","additions":53,"deletions":40,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n- * INVOKESPECIAL - Invoke instance method; special handling for superclass, private and instance initialization method\n- * invocations\n+ * INVOKESPECIAL - Invoke instance method; special handling for superclass, private\n+ * and instance initialization method invocations\n@@ -34,3 +34,1 @@\n- * <PRE>\n- * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -38,2 +36,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\"> The\n- *      invokespecial instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokespecial\">\n+ * The invokespecial instruction in The Java Virtual Machine Specification<\/a>\n@@ -44,1 +43,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -49,0 +49,1 @@\n+\n@@ -53,0 +54,21 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR);\n+    }\n+\n+\n@@ -54,2 +76,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +84,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -71,17 +95,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR, ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.UNSATISFIED_LINK_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKESPECIAL.java","additions":35,"deletions":28,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n- * <PRE>\n- * Stack: ..., [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -37,2 +35,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\"> The invokestatic\n- *      instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokestatic\">\n+ * The invokestatic instruction in The Java Virtual Machine Specification<\/a>\n@@ -43,1 +42,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +48,1 @@\n+\n@@ -52,0 +53,19 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+      out.writeByte(super.getOpcode());\n+      out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +73,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +81,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,17 +92,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.UNSATISFIED_LINK_ERROR,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKESTATIC.java","additions":31,"deletions":26,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -33,3 +33,1 @@\n- * <PRE>\n- * Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., objectref, [arg1, [arg2 ...]] -&gt; ...<\/PRE>\n@@ -37,2 +35,3 @@\n- * @see <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\"> The\n- *      invokevirtual instruction in The Java Virtual Machine Specification<\/a>\n+ * @see\n+ * <a href=\"https:\/\/docs.oracle.com\/javase\/specs\/jvms\/se8\/html\/jvms-6.html#jvms-6.5.invokevirtual\">\n+ * The invokevirtual instruction in The Java Virtual Machine Specification<\/a>\n@@ -43,1 +42,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +48,1 @@\n+\n@@ -52,0 +53,21 @@\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+    }\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR,\n+            ExceptionConst.ABSTRACT_METHOD_ERROR,\n+            ExceptionConst.UNSATISFIED_LINK_ERROR);\n+    }\n+\n+\n@@ -53,2 +75,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +83,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,17 +94,0 @@\n-\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR, ExceptionConst.ABSTRACT_METHOD_ERROR, ExceptionConst.UNSATISFIED_LINK_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/INVOKEVIRTUAL.java","additions":33,"deletions":26,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -35,2 +33,1 @@\n-    \/**\n-     * Remainder of ints\n+    \/** Remainder of ints\n@@ -42,0 +39,11 @@\n+\n+    \/** @return exceptions this instruction may cause\n+     *\/\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -43,2 +51,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -49,1 +59,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -57,8 +67,0 @@\n-\n-    \/**\n-     * @return exceptions this instruction may cause\n-     *\/\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IREM.java","additions":18,"deletions":16,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * IRETURN - Return int from method\n+ * IRETURN -  Return int from method\n+ * <PRE>Stack: ..., value -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Return int from method\n+    \/** Return int from method\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IRETURN.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISHL.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,3 +39,2 @@\n-    \/**\n-     * Store int into local variable\n-     *\n+\n+    \/** Store int into local variable\n@@ -49,0 +47,1 @@\n+\n@@ -50,2 +49,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -56,1 +57,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISTORE.java","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Substract ints\n+    \/** Substract ints\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ISUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IUSHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IXOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -30,1 +31,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -35,0 +37,1 @@\n+\n@@ -43,0 +46,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IfInstruction.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denote entity that refers to an index, e.g. local variable instructions, RET, CPInstruction, etc.\n+ * Denote entity that refers to an index, e.g. local variable instructions,\n+ * RET, CPInstruction, etc.\n+ *\n@@ -31,1 +33,2 @@\n-    void setIndex(int index);\n+\n+    void setIndex( int index );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/IndexedInstruction.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: July 2020\n@@ -36,1 +36,2 @@\n-    static final Instruction[] EMPTY_ARRAY = {};\n+    private short length = 1; \/\/ Length of instruction in bytes\n+    private short opcode = -1; \/\/ Opcode number\n@@ -40,10 +41,0 @@\n-    \/**\n-     * Gets Comparator object used in the equals() method to determine equality of instructions.\n-     *\n-     * @return currently used comparator for equals()\n-     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n-     *\/\n-    @Deprecated\n-    public static InstructionComparator getComparator() {\n-        return cmp;\n-    }\n@@ -52,5 +43,2 @@\n-     * Tests if the value can fit in a byte (signed)\n-     *\n-     * @param value the value to check\n-     * @return true if the value is in range\n-     * @since 6.0\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -58,2 +46,1 @@\n-    public static boolean isValidByte(final int value) {\n-        return value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE;\n+    Instruction() {\n@@ -62,9 +49,4 @@\n-    \/**\n-     * Tests if the value can fit in a short (signed)\n-     *\n-     * @param value the value to check\n-     * @return true if the value is in range\n-     * @since 6.0\n-     *\/\n-    public static boolean isValidShort(final int value) {\n-        return value >= Short.MIN_VALUE && value <= Short.MAX_VALUE;\n+\n+    public Instruction(final short opcode, final short length) {\n+        this.length = length;\n+        this.opcode = opcode;\n@@ -73,0 +55,1 @@\n+\n@@ -74,8 +57,2 @@\n-     * Reads an instruction from (byte code) input stream and return the appropriate object.\n-     * <p>\n-     * If the Instruction is defined in {@link InstructionConst}, then the singleton instance is returned.\n-     * <\/p>\n-     * @param bytes input stream bytes\n-     * @return instruction object being read\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n-     * @see InstructionConst#getInstruction(int)\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n@@ -83,308 +60,3 @@\n-    \/\/ @since 6.0 no longer final\n-    public static Instruction readInstruction(final ByteSequence bytes) throws IOException {\n-        boolean wide = false;\n-        short opcode = (short) bytes.readUnsignedByte();\n-        Instruction obj = null;\n-        if (opcode == Const.WIDE) { \/\/ Read next opcode after wide byte\n-            wide = true;\n-            opcode = (short) bytes.readUnsignedByte();\n-        }\n-        final Instruction instruction = InstructionConst.getInstruction(opcode);\n-        if (instruction != null) {\n-            return instruction; \/\/ Used predefined immutable object, if available\n-        }\n-\n-        switch (opcode) {\n-        case Const.BIPUSH:\n-            obj = new BIPUSH();\n-            break;\n-        case Const.SIPUSH:\n-            obj = new SIPUSH();\n-            break;\n-        case Const.LDC:\n-            obj = new LDC();\n-            break;\n-        case Const.LDC_W:\n-            obj = new LDC_W();\n-            break;\n-        case Const.LDC2_W:\n-            obj = new LDC2_W();\n-            break;\n-        case Const.ILOAD:\n-            obj = new ILOAD();\n-            break;\n-        case Const.LLOAD:\n-            obj = new LLOAD();\n-            break;\n-        case Const.FLOAD:\n-            obj = new FLOAD();\n-            break;\n-        case Const.DLOAD:\n-            obj = new DLOAD();\n-            break;\n-        case Const.ALOAD:\n-            obj = new ALOAD();\n-            break;\n-        case Const.ILOAD_0:\n-            obj = new ILOAD(0);\n-            break;\n-        case Const.ILOAD_1:\n-            obj = new ILOAD(1);\n-            break;\n-        case Const.ILOAD_2:\n-            obj = new ILOAD(2);\n-            break;\n-        case Const.ILOAD_3:\n-            obj = new ILOAD(3);\n-            break;\n-        case Const.LLOAD_0:\n-            obj = new LLOAD(0);\n-            break;\n-        case Const.LLOAD_1:\n-            obj = new LLOAD(1);\n-            break;\n-        case Const.LLOAD_2:\n-            obj = new LLOAD(2);\n-            break;\n-        case Const.LLOAD_3:\n-            obj = new LLOAD(3);\n-            break;\n-        case Const.FLOAD_0:\n-            obj = new FLOAD(0);\n-            break;\n-        case Const.FLOAD_1:\n-            obj = new FLOAD(1);\n-            break;\n-        case Const.FLOAD_2:\n-            obj = new FLOAD(2);\n-            break;\n-        case Const.FLOAD_3:\n-            obj = new FLOAD(3);\n-            break;\n-        case Const.DLOAD_0:\n-            obj = new DLOAD(0);\n-            break;\n-        case Const.DLOAD_1:\n-            obj = new DLOAD(1);\n-            break;\n-        case Const.DLOAD_2:\n-            obj = new DLOAD(2);\n-            break;\n-        case Const.DLOAD_3:\n-            obj = new DLOAD(3);\n-            break;\n-        case Const.ALOAD_0:\n-            obj = new ALOAD(0);\n-            break;\n-        case Const.ALOAD_1:\n-            obj = new ALOAD(1);\n-            break;\n-        case Const.ALOAD_2:\n-            obj = new ALOAD(2);\n-            break;\n-        case Const.ALOAD_3:\n-            obj = new ALOAD(3);\n-            break;\n-        case Const.ISTORE:\n-            obj = new ISTORE();\n-            break;\n-        case Const.LSTORE:\n-            obj = new LSTORE();\n-            break;\n-        case Const.FSTORE:\n-            obj = new FSTORE();\n-            break;\n-        case Const.DSTORE:\n-            obj = new DSTORE();\n-            break;\n-        case Const.ASTORE:\n-            obj = new ASTORE();\n-            break;\n-        case Const.ISTORE_0:\n-            obj = new ISTORE(0);\n-            break;\n-        case Const.ISTORE_1:\n-            obj = new ISTORE(1);\n-            break;\n-        case Const.ISTORE_2:\n-            obj = new ISTORE(2);\n-            break;\n-        case Const.ISTORE_3:\n-            obj = new ISTORE(3);\n-            break;\n-        case Const.LSTORE_0:\n-            obj = new LSTORE(0);\n-            break;\n-        case Const.LSTORE_1:\n-            obj = new LSTORE(1);\n-            break;\n-        case Const.LSTORE_2:\n-            obj = new LSTORE(2);\n-            break;\n-        case Const.LSTORE_3:\n-            obj = new LSTORE(3);\n-            break;\n-        case Const.FSTORE_0:\n-            obj = new FSTORE(0);\n-            break;\n-        case Const.FSTORE_1:\n-            obj = new FSTORE(1);\n-            break;\n-        case Const.FSTORE_2:\n-            obj = new FSTORE(2);\n-            break;\n-        case Const.FSTORE_3:\n-            obj = new FSTORE(3);\n-            break;\n-        case Const.DSTORE_0:\n-            obj = new DSTORE(0);\n-            break;\n-        case Const.DSTORE_1:\n-            obj = new DSTORE(1);\n-            break;\n-        case Const.DSTORE_2:\n-            obj = new DSTORE(2);\n-            break;\n-        case Const.DSTORE_3:\n-            obj = new DSTORE(3);\n-            break;\n-        case Const.ASTORE_0:\n-            obj = new ASTORE(0);\n-            break;\n-        case Const.ASTORE_1:\n-            obj = new ASTORE(1);\n-            break;\n-        case Const.ASTORE_2:\n-            obj = new ASTORE(2);\n-            break;\n-        case Const.ASTORE_3:\n-            obj = new ASTORE(3);\n-            break;\n-        case Const.IINC:\n-            obj = new IINC();\n-            break;\n-        case Const.IFEQ:\n-            obj = new IFEQ();\n-            break;\n-        case Const.IFNE:\n-            obj = new IFNE();\n-            break;\n-        case Const.IFLT:\n-            obj = new IFLT();\n-            break;\n-        case Const.IFGE:\n-            obj = new IFGE();\n-            break;\n-        case Const.IFGT:\n-            obj = new IFGT();\n-            break;\n-        case Const.IFLE:\n-            obj = new IFLE();\n-            break;\n-        case Const.IF_ICMPEQ:\n-            obj = new IF_ICMPEQ();\n-            break;\n-        case Const.IF_ICMPNE:\n-            obj = new IF_ICMPNE();\n-            break;\n-        case Const.IF_ICMPLT:\n-            obj = new IF_ICMPLT();\n-            break;\n-        case Const.IF_ICMPGE:\n-            obj = new IF_ICMPGE();\n-            break;\n-        case Const.IF_ICMPGT:\n-            obj = new IF_ICMPGT();\n-            break;\n-        case Const.IF_ICMPLE:\n-            obj = new IF_ICMPLE();\n-            break;\n-        case Const.IF_ACMPEQ:\n-            obj = new IF_ACMPEQ();\n-            break;\n-        case Const.IF_ACMPNE:\n-            obj = new IF_ACMPNE();\n-            break;\n-        case Const.GOTO:\n-            obj = new GOTO();\n-            break;\n-        case Const.JSR:\n-            obj = new JSR();\n-            break;\n-        case Const.RET:\n-            obj = new RET();\n-            break;\n-        case Const.TABLESWITCH:\n-            obj = new TABLESWITCH();\n-            break;\n-        case Const.LOOKUPSWITCH:\n-            obj = new LOOKUPSWITCH();\n-            break;\n-        case Const.GETSTATIC:\n-            obj = new GETSTATIC();\n-            break;\n-        case Const.PUTSTATIC:\n-            obj = new PUTSTATIC();\n-            break;\n-        case Const.GETFIELD:\n-            obj = new GETFIELD();\n-            break;\n-        case Const.PUTFIELD:\n-            obj = new PUTFIELD();\n-            break;\n-        case Const.INVOKEVIRTUAL:\n-            obj = new INVOKEVIRTUAL();\n-            break;\n-        case Const.INVOKESPECIAL:\n-            obj = new INVOKESPECIAL();\n-            break;\n-        case Const.INVOKESTATIC:\n-            obj = new INVOKESTATIC();\n-            break;\n-        case Const.INVOKEINTERFACE:\n-            obj = new INVOKEINTERFACE();\n-            break;\n-        case Const.INVOKEDYNAMIC:\n-            obj = new INVOKEDYNAMIC();\n-            break;\n-        case Const.NEW:\n-            obj = new NEW();\n-            break;\n-        case Const.NEWARRAY:\n-            obj = new NEWARRAY();\n-            break;\n-        case Const.ANEWARRAY:\n-            obj = new ANEWARRAY();\n-            break;\n-        case Const.CHECKCAST:\n-            obj = new CHECKCAST();\n-            break;\n-        case Const.INSTANCEOF:\n-            obj = new INSTANCEOF();\n-            break;\n-        case Const.MULTIANEWARRAY:\n-            obj = new MULTIANEWARRAY();\n-            break;\n-        case Const.IFNULL:\n-            obj = new IFNULL();\n-            break;\n-        case Const.IFNONNULL:\n-            obj = new IFNONNULL();\n-            break;\n-        case Const.GOTO_W:\n-            obj = new GOTO_W();\n-            break;\n-        case Const.JSR_W:\n-            obj = new JSR_W();\n-            break;\n-        case Const.BREAKPOINT:\n-            obj = new BREAKPOINT();\n-            break;\n-        case Const.IMPDEP1:\n-            obj = new IMPDEP1();\n-            break;\n-        case Const.IMPDEP2:\n-            obj = new IMPDEP2();\n-            break;\n-        default:\n-            throw new ClassGenException(\"Illegal opcode detected: \" + opcode);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(opcode); \/\/ Common for all instructions\n+    }\n@@ -392,1 +64,0 @@\n-        }\n@@ -394,6 +65,4 @@\n-        if (wide && !(obj instanceof LocalVariableInstruction || obj instanceof RET)) {\n-            throw new ClassGenException(\"Illegal opcode after wide: \" + opcode);\n-        }\n-        obj.setOpcode(opcode);\n-        obj.initFromFile(bytes, wide); \/\/ Do further initializations, if any\n-        return obj;\n+    \/** @return name of instruction, i.e., opcode name\n+     *\/\n+    public String getName() {\n+        return Const.getOpcodeName(opcode);\n@@ -402,0 +71,1 @@\n+\n@@ -403,1 +73,1 @@\n-     * Sets comparator to be used for equals().\n+     * Long output format:\n@@ -405,1 +75,5 @@\n-     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -407,3 +81,5 @@\n-    @Deprecated\n-    public static void setComparator(final InstructionComparator c) {\n-        cmp = c;\n+    public String toString( final boolean verbose ) {\n+        if (verbose) {\n+            return getName() + \"[\" + opcode + \"](\" + length + \")\";\n+        }\n+        return getName();\n@@ -412,5 +88,0 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected short length = 1; \/\/ Length of instruction in bytes\n@@ -419,7 +90,1 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected short opcode = -1; \/\/ Opcode number\n-\n-    \/**\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * @return mnemonic for instruction in verbose format\n@@ -427,6 +92,3 @@\n-    Instruction() {\n-    }\n-\n-    public Instruction(final short opcode, final short length) {\n-        this.length = length;\n-        this.opcode = opcode;\n+    @Override\n+    public String toString() {\n+        return toString(true);\n@@ -435,7 +97,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    public abstract void accept(Visitor v);\n@@ -444,5 +99,1 @@\n-     * This method also gives right results for instructions whose effect on the stack depends on the constant pool entry\n-     * they reference.\n-     *\n-     * @return Number of words consumed from stack by this instruction, or Constants.UNPREDICTABLE, if this can not be\n-     *         computed statically\n+     * @return mnemonic for instruction with sumbolic references resolved\n@@ -450,2 +101,2 @@\n-    public int consumeStack(final ConstantPoolGen cpg) {\n-        return Const.getConsumeStack(opcode);\n+    public String toString( final ConstantPool cp ) {\n+        return toString(false);\n@@ -454,0 +105,1 @@\n+\n@@ -455,2 +107,3 @@\n-     * Use with caution, since 'BranchInstruction's have a 'target' reference which is not copied correctly (only basic\n-     * types are). This also applies for 'Select' instructions with their multiple branch targets.\n+     * Use with caution, since `BranchInstruction's have a `target' reference which\n+     * is not copied correctly (only basic types are). This also applies for\n+     * `Select' instructions with their multiple branch targets.\n@@ -476,5 +129,0 @@\n-    \/**\n-     * Some instructions may be reused, so don't do anything by default.\n-     *\/\n-    void dispose() {\n-    }\n@@ -483,1 +131,1 @@\n-     * Dumps instruction as byte code to stream out.\n+     * Read needed data (e.g. index) from file.\n@@ -485,2 +133,3 @@\n-     * @param out Output stream\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n+     * @param bytes byte sequence to read from\n+     * @param wide \"wide\" instruction flag\n+     * @throws IOException may be thrown if the implementation needs to read data from the file\n@@ -488,2 +137,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(opcode); \/\/ Common for all instructions\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -492,0 +140,1 @@\n+\n@@ -493,3 +142,8 @@\n-     * Tests for equality, delegated to comparator\n-     *\n-     * @return true if that is an Instruction and has the same opcode\n+     * Read an instruction from (byte code) input stream and return the\n+     * appropiate object.\n+     * <p>\n+     * If the Instruction is defined in {@link InstructionConst}, then the\n+     * singleton instance is returned.\n+     * @param bytes input stream bytes\n+     * @return instruction object being read\n+     * @see InstructionConst#getInstruction(int)\n@@ -497,3 +151,318 @@\n-    @Override\n-    public boolean equals(final Object that) {\n-        return that instanceof Instruction && cmp.equals(this, (Instruction) that);\n+    \/\/ @since 6.0 no longer final\n+    public static Instruction readInstruction( final ByteSequence bytes ) throws IOException {\n+        boolean wide = false;\n+        short opcode = (short) bytes.readUnsignedByte();\n+        Instruction obj = null;\n+        if (opcode == Const.WIDE) { \/\/ Read next opcode after wide byte\n+            wide = true;\n+            opcode = (short) bytes.readUnsignedByte();\n+        }\n+        final Instruction instruction = InstructionConst.getInstruction(opcode);\n+        if (instruction != null) {\n+            return instruction; \/\/ Used predefined immutable object, if available\n+        }\n+\n+        switch (opcode) {\n+            case Const.BIPUSH:\n+                obj = new BIPUSH();\n+                break;\n+            case Const.SIPUSH:\n+                obj = new SIPUSH();\n+                break;\n+            case Const.LDC:\n+                obj = new LDC();\n+                break;\n+            case Const.LDC_W:\n+                obj = new LDC_W();\n+                break;\n+            case Const.LDC2_W:\n+                obj = new LDC2_W();\n+                break;\n+            case Const.ILOAD:\n+                obj = new ILOAD();\n+                break;\n+            case Const.LLOAD:\n+                obj = new LLOAD();\n+                break;\n+            case Const.FLOAD:\n+                obj = new FLOAD();\n+                break;\n+            case Const.DLOAD:\n+                obj = new DLOAD();\n+                break;\n+            case Const.ALOAD:\n+                obj = new ALOAD();\n+                break;\n+            case Const.ILOAD_0:\n+                obj = new ILOAD(0);\n+                break;\n+            case Const.ILOAD_1:\n+                obj = new ILOAD(1);\n+                break;\n+            case Const.ILOAD_2:\n+                obj = new ILOAD(2);\n+                break;\n+            case Const.ILOAD_3:\n+                obj = new ILOAD(3);\n+                break;\n+            case Const.LLOAD_0:\n+                obj = new LLOAD(0);\n+                break;\n+            case Const.LLOAD_1:\n+                obj = new LLOAD(1);\n+                break;\n+            case Const.LLOAD_2:\n+                obj = new LLOAD(2);\n+                break;\n+            case Const.LLOAD_3:\n+                obj = new LLOAD(3);\n+                break;\n+            case Const.FLOAD_0:\n+                obj = new FLOAD(0);\n+                break;\n+            case Const.FLOAD_1:\n+                obj = new FLOAD(1);\n+                break;\n+            case Const.FLOAD_2:\n+                obj = new FLOAD(2);\n+                break;\n+            case Const.FLOAD_3:\n+                obj = new FLOAD(3);\n+                break;\n+            case Const.DLOAD_0:\n+                obj = new DLOAD(0);\n+                break;\n+            case Const.DLOAD_1:\n+                obj = new DLOAD(1);\n+                break;\n+            case Const.DLOAD_2:\n+                obj = new DLOAD(2);\n+                break;\n+            case Const.DLOAD_3:\n+                obj = new DLOAD(3);\n+                break;\n+            case Const.ALOAD_0:\n+                obj = new ALOAD(0);\n+                break;\n+            case Const.ALOAD_1:\n+                obj = new ALOAD(1);\n+                break;\n+            case Const.ALOAD_2:\n+                obj = new ALOAD(2);\n+                break;\n+            case Const.ALOAD_3:\n+                obj = new ALOAD(3);\n+                break;\n+            case Const.ISTORE:\n+                obj = new ISTORE();\n+                break;\n+            case Const.LSTORE:\n+                obj = new LSTORE();\n+                break;\n+            case Const.FSTORE:\n+                obj = new FSTORE();\n+                break;\n+            case Const.DSTORE:\n+                obj = new DSTORE();\n+                break;\n+            case Const.ASTORE:\n+                obj = new ASTORE();\n+                break;\n+            case Const.ISTORE_0:\n+                obj = new ISTORE(0);\n+                break;\n+            case Const.ISTORE_1:\n+                obj = new ISTORE(1);\n+                break;\n+            case Const.ISTORE_2:\n+                obj = new ISTORE(2);\n+                break;\n+            case Const.ISTORE_3:\n+                obj = new ISTORE(3);\n+                break;\n+            case Const.LSTORE_0:\n+                obj = new LSTORE(0);\n+                break;\n+            case Const.LSTORE_1:\n+                obj = new LSTORE(1);\n+                break;\n+            case Const.LSTORE_2:\n+                obj = new LSTORE(2);\n+                break;\n+            case Const.LSTORE_3:\n+                obj = new LSTORE(3);\n+                break;\n+            case Const.FSTORE_0:\n+                obj = new FSTORE(0);\n+                break;\n+            case Const.FSTORE_1:\n+                obj = new FSTORE(1);\n+                break;\n+            case Const.FSTORE_2:\n+                obj = new FSTORE(2);\n+                break;\n+            case Const.FSTORE_3:\n+                obj = new FSTORE(3);\n+                break;\n+            case Const.DSTORE_0:\n+                obj = new DSTORE(0);\n+                break;\n+            case Const.DSTORE_1:\n+                obj = new DSTORE(1);\n+                break;\n+            case Const.DSTORE_2:\n+                obj = new DSTORE(2);\n+                break;\n+            case Const.DSTORE_3:\n+                obj = new DSTORE(3);\n+                break;\n+            case Const.ASTORE_0:\n+                obj = new ASTORE(0);\n+                break;\n+            case Const.ASTORE_1:\n+                obj = new ASTORE(1);\n+                break;\n+            case Const.ASTORE_2:\n+                obj = new ASTORE(2);\n+                break;\n+            case Const.ASTORE_3:\n+                obj = new ASTORE(3);\n+                break;\n+            case Const.IINC:\n+                obj = new IINC();\n+                break;\n+            case Const.IFEQ:\n+                obj = new IFEQ();\n+                break;\n+            case Const.IFNE:\n+                obj = new IFNE();\n+                break;\n+            case Const.IFLT:\n+                obj = new IFLT();\n+                break;\n+            case Const.IFGE:\n+                obj = new IFGE();\n+                break;\n+            case Const.IFGT:\n+                obj = new IFGT();\n+                break;\n+            case Const.IFLE:\n+                obj = new IFLE();\n+                break;\n+            case Const.IF_ICMPEQ:\n+                obj = new IF_ICMPEQ();\n+                break;\n+            case Const.IF_ICMPNE:\n+                obj = new IF_ICMPNE();\n+                break;\n+            case Const.IF_ICMPLT:\n+                obj = new IF_ICMPLT();\n+                break;\n+            case Const.IF_ICMPGE:\n+                obj = new IF_ICMPGE();\n+                break;\n+            case Const.IF_ICMPGT:\n+                obj = new IF_ICMPGT();\n+                break;\n+            case Const.IF_ICMPLE:\n+                obj = new IF_ICMPLE();\n+                break;\n+            case Const.IF_ACMPEQ:\n+                obj = new IF_ACMPEQ();\n+                break;\n+            case Const.IF_ACMPNE:\n+                obj = new IF_ACMPNE();\n+                break;\n+            case Const.GOTO:\n+                obj = new GOTO();\n+                break;\n+            case Const.JSR:\n+                obj = new JSR();\n+                break;\n+            case Const.RET:\n+                obj = new RET();\n+                break;\n+            case Const.TABLESWITCH:\n+                obj = new TABLESWITCH();\n+                break;\n+            case Const.LOOKUPSWITCH:\n+                obj = new LOOKUPSWITCH();\n+                break;\n+            case Const.GETSTATIC:\n+                obj = new GETSTATIC();\n+                break;\n+            case Const.PUTSTATIC:\n+                obj = new PUTSTATIC();\n+                break;\n+            case Const.GETFIELD:\n+                obj = new GETFIELD();\n+                break;\n+            case Const.PUTFIELD:\n+                obj = new PUTFIELD();\n+                break;\n+            case Const.INVOKEVIRTUAL:\n+                obj = new INVOKEVIRTUAL();\n+                break;\n+            case Const.INVOKESPECIAL:\n+                obj = new INVOKESPECIAL();\n+                break;\n+            case Const.INVOKESTATIC:\n+                obj = new INVOKESTATIC();\n+                break;\n+            case Const.INVOKEINTERFACE:\n+                obj = new INVOKEINTERFACE();\n+                break;\n+            case Const.INVOKEDYNAMIC:\n+                obj = new INVOKEDYNAMIC();\n+                break;\n+            case Const.NEW:\n+                obj = new NEW();\n+                break;\n+            case Const.NEWARRAY:\n+                obj = new NEWARRAY();\n+                break;\n+            case Const.ANEWARRAY:\n+                obj = new ANEWARRAY();\n+                break;\n+            case Const.CHECKCAST:\n+                obj = new CHECKCAST();\n+                break;\n+            case Const.INSTANCEOF:\n+                obj = new INSTANCEOF();\n+                break;\n+            case Const.MULTIANEWARRAY:\n+                obj = new MULTIANEWARRAY();\n+                break;\n+            case Const.IFNULL:\n+                obj = new IFNULL();\n+                break;\n+            case Const.IFNONNULL:\n+                obj = new IFNONNULL();\n+                break;\n+            case Const.GOTO_W:\n+                obj = new GOTO_W();\n+                break;\n+            case Const.JSR_W:\n+                obj = new JSR_W();\n+                break;\n+            case Const.BREAKPOINT:\n+                obj = new BREAKPOINT();\n+                break;\n+            case Const.IMPDEP1:\n+                obj = new IMPDEP1();\n+                break;\n+            case Const.IMPDEP2:\n+                obj = new IMPDEP2();\n+                break;\n+            default:\n+                throw new ClassGenException(\"Illegal opcode detected: \" + opcode);\n+\n+        }\n+\n+        if (wide\n+                && !((obj instanceof LocalVariableInstruction) || (obj instanceof IINC) || (obj instanceof RET))) {\n+            throw new ClassGenException(\"Illegal opcode after wide: \" + opcode);\n+        }\n+        obj.setOpcode(opcode);\n+        obj.initFromFile(bytes, wide); \/\/ Do further initializations, if any\n+        return obj;\n@@ -503,1 +472,5 @@\n-     * @return length (in bytes) of instruction\n+     * This method also gives right results for instructions whose\n+     * effect on the stack depends on the constant pool entry they\n+     * reference.\n+     *  @return Number of words consumed from stack by this instruction,\n+     * or Constants.UNPREDICTABLE, if this can not be computed statically\n@@ -505,2 +478,2 @@\n-    public int getLength() {\n-        return length;\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n+        return Const.getConsumeStack(opcode);\n@@ -509,0 +482,1 @@\n+\n@@ -510,1 +484,5 @@\n-     * @return name of instruction, i.e., opcode name\n+     * This method also gives right results for instructions whose\n+     * effect on the stack depends on the constant pool entry they\n+     * reference.\n+     * @return Number of words produced onto stack by this instruction,\n+     * or Constants.UNPREDICTABLE, if this can not be computed statically\n@@ -512,2 +490,2 @@\n-    public String getName() {\n-        return Const.getOpcodeName(opcode);\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        return Const.getProduceStack(opcode);\n@@ -516,0 +494,1 @@\n+\n@@ -523,10 +502,0 @@\n-    \/**\n-     * Gets the hashCode of this object.\n-     *\n-     * @return the hashCode\n-     * @since 6.0\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return opcode;\n-    }\n@@ -535,5 +504,1 @@\n-     * Reads needed data (e.g. index) from file.\n-     *\n-     * @param bytes byte sequence to read from\n-     * @param wide \"wide\" instruction flag\n-     * @throws IOException may be thrown if the implementation needs to read data from the file\n+     * @return length (in bytes) of instruction\n@@ -541,2 +506,2 @@\n-    @SuppressWarnings(\"unused\") \/\/ thrown by subclasses\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    public int getLength() {\n+        return length;\n@@ -545,0 +510,1 @@\n+\n@@ -546,5 +512,1 @@\n-     * This method also gives right results for instructions whose effect on the stack depends on the constant pool entry\n-     * they reference.\n-     *\n-     * @return Number of words produced onto stack by this instruction, or Constants.UNPREDICTABLE, if this can not be\n-     *         computed statically\n+     * Needed in readInstruction and subclasses in this package\n@@ -552,2 +514,2 @@\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        return Const.getProduceStack(opcode);\n+    void setOpcode( final short opcode ) {\n+        this.opcode = opcode;\n@@ -556,0 +518,1 @@\n+\n@@ -558,1 +521,0 @@\n-     *\n@@ -561,1 +523,1 @@\n-    final void setLength(final int length) {\n+    final void setLength( final int length ) {\n@@ -565,2 +527,2 @@\n-    \/**\n-     * Needed in readInstruction and subclasses in this package\n+\n+    \/** Some instructions may be reused, so don't do anything by default.\n@@ -568,2 +530,1 @@\n-    void setOpcode(final short opcode) {\n-        this.opcode = opcode;\n+    void dispose() {\n@@ -572,0 +533,1 @@\n+\n@@ -573,1 +535,33 @@\n-     * @return mnemonic for instruction in verbose format\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    public abstract void accept( Visitor v );\n+\n+\n+    \/** Get Comparator object used in the equals() method to determine\n+     * equality of instructions.\n+     *\n+     * @return currently used comparator for equals()\n+     * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+     *\/\n+    @Deprecated\n+    public static InstructionComparator getComparator() {\n+        return cmp;\n+    }\n+\n+\n+    \/** Set comparator to be used for equals().\n+      * @deprecated (6.0) use the built in comparator, or wrap this class in another object that implements these methods\n+     *\/\n+    @Deprecated\n+    public static void setComparator( final InstructionComparator c ) {\n+        cmp = c;\n+    }\n+\n+\n+    \/** Check for equality, delegated to comparator\n+     * @return true if that is an Instruction and has the same opcode\n@@ -576,2 +570,11 @@\n-    public String toString() {\n-        return toString(true);\n+    public boolean equals( final Object that ) {\n+        return (that instanceof Instruction) ? cmp.equals(this, (Instruction) that) : false;\n+    }\n+\n+    \/** calculate the hashCode of this object\n+     * @return the hashCode\n+     * @since 6.0\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return opcode;\n@@ -581,6 +584,4 @@\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\"\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * Check if the value can fit in a byte (signed)\n+     * @param value the value to check\n+     * @return true if the value is in range\n+     * @since 6.0\n@@ -588,5 +589,2 @@\n-    public String toString(final boolean verbose) {\n-        if (verbose) {\n-            return getName() + \"[\" + opcode + \"](\" + length + \")\";\n-        }\n-        return getName();\n+    public static boolean isValidByte(final int value) {\n+        return value >= Byte.MIN_VALUE && value <= Byte.MAX_VALUE;\n@@ -596,1 +594,4 @@\n-     * @return mnemonic for instruction with sumbolic references resolved\n+     * Check if the value can fit in a short (signed)\n+     * @param value the value to check\n+     * @return true if the value is in range\n+     * @since 6.0\n@@ -598,2 +599,2 @@\n-    public String toString(final ConstantPool cp) {\n-        return toString(false);\n+    public static boolean isValidShort(final int value) {\n+        return value >= Short.MIN_VALUE && value <= Short.MAX_VALUE;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Instruction.java","additions":461,"deletions":460,"binary":false,"changes":921,"status":"modified"},{"patch":"@@ -25,2 +25,4 @@\n- * Equality of instructions isn't clearly to be defined. You might wish, for example, to compare whether instructions\n- * have the same meaning. E.g., whether two INVOKEVIRTUALs describe the same call.\n+ * Equality of instructions isn't clearly to be defined. You might\n+ * wish, for example, to compare whether instructions have the same\n+ * meaning. E.g., whether two INVOKEVIRTUALs describe the same\n+ * call.\n@@ -28,3 +30,4 @@\n- * The DEFAULT comparator however, considers two instructions to be equal if they have same opcode and point to the same\n- * indexes (if any) in the constant pool or the same local variable index. Branch instructions must have the same\n- * target.\n+ * The DEFAULT comparator however, considers two instructions\n+ * to be equal if they have same opcode and point to the same indexes\n+ * (if any) in the constant pool or the same local variable index. Branch\n+ * instructions must have the same target.\n@@ -40,1 +43,1 @@\n-                \/\/ BIs are never equal to make targeters work correctly (BCEL-195)\n+             \/\/ BIs are never equal to make targeters work correctly (BCEL-195)\n@@ -44,8 +47,7 @@\n-            }\n-            if (i1 instanceof ConstantPushInstruction) {\n-                return ((ConstantPushInstruction) i1).getValue().equals(((ConstantPushInstruction) i2).getValue());\n-            }\n-            if (i1 instanceof IndexedInstruction) {\n-                return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2).getIndex();\n-            }\n-            if (i1 instanceof NEWARRAY) {\n+            } else if (i1 instanceof ConstantPushInstruction) {\n+                return ((ConstantPushInstruction) i1).getValue().equals(\n+                        ((ConstantPushInstruction) i2).getValue());\n+            } else if (i1 instanceof IndexedInstruction) {\n+                return ((IndexedInstruction) i1).getIndex() == ((IndexedInstruction) i2)\n+                        .getIndex();\n+            } else if (i1 instanceof NEWARRAY) {\n@@ -53,0 +55,2 @@\n+            } else {\n+                return true;\n@@ -54,1 +58,0 @@\n-            return true;\n@@ -59,1 +62,2 @@\n-    boolean equals(Instruction i1, Instruction i2);\n+\n+    boolean equals( Instruction i1, Instruction i2 );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionComparator.java","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -27,11 +27,13 @@\n- * Contains shareable instruction objects.\n- * <p>\n- * In order to save memory you can use some instructions multiply, since they have an immutable state and are directly\n- * derived from Instruction. I.e. they have no instance fields that could be changed. Since some of these instructions\n- * like ICONST_0 occur very frequently this can save a lot of time and space. This feature is an adaptation of the\n- * FlyWeight design pattern, we just use an array instead of a factory.\n- * <\/p>\n- * <p>\n- * The Instructions can also accessed directly under their names, so it's possible to write\n- * il.append(Instruction.ICONST_0);\n- * <\/p>\n+ * This interface contains shareable instruction objects.\n+ *\n+ * In order to save memory you can use some instructions multiply,\n+ * since they have an immutable state and are directly derived from\n+ * Instruction.  I.e. they have no instance fields that could be\n+ * changed. Since some of these instructions like ICONST_0 occur\n+ * very frequently this can save a lot of time and space. This\n+ * feature is an adaptation of the FlyWeight design pattern, we\n+ * just use an array instead of a factory.\n+ *\n+ * The Instructions can also accessed directly under their names, so\n+ * it's possible to write il.append(Instruction.ICONST_0);\n+ *\n@@ -42,3 +44,5 @@\n-     * Predefined instruction objects.\n-     *\n-     * NOTE these are not currently immutable, because Instruction has mutable protected fields opcode and length.\n+     * Predefined instruction objects\n+     *\/\n+    \/*\n+     * NOTE these are not currently immutable, because Instruction\n+     * has mutable protected fields opcode and length.\n@@ -154,3 +158,2 @@\n-    \/**\n-     * You can use these constants in multiple places safely, if you can guarantee that you will never alter their internal\n-     * values, e.g. call setIndex().\n+    \/** You can use these constants in multiple places safely, if you can guarantee\n+     * that you will never alter their internal values, e.g. call setIndex().\n@@ -172,2 +175,2 @@\n-    \/**\n-     * Get object via its opcode, for immutable instructions like branch instructions entries are set to null.\n+    \/** Get object via its opcode, for immutable instructions like\n+     * branch instructions entries are set to null.\n@@ -175,1 +178,1 @@\n-    static final Instruction[] INSTRUCTIONS = new Instruction[256];\n+    private static final Instruction[] INSTRUCTIONS = new Instruction[256];\n@@ -287,0 +290,2 @@\n+    private InstructionConst() { } \/\/ non-instantiable\n+\n@@ -289,1 +294,0 @@\n-     *\n@@ -296,3 +300,0 @@\n-\n-    private InstructionConst() {\n-    } \/\/ non-instantiable\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionConst.java","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,4 @@\n- * Instances of this class may be used, e.g., to generate typed versions of instructions. Its main purpose is to be used\n- * as the byte code generating backend of a compiler. You can subclass it to add your own create methods.\n+ * Instances of this class may be used, e.g., to generate typed\n+ * versions of instructions. Its main purpose is to be used as the\n+ * byte code generating backend of a compiler. You can subclass it to\n+ * add your own create methods.\n@@ -28,2 +30,2 @@\n- * Note: The static createXXX methods return singleton instances from the {@link InstructionConst} class.\n- * <\/p>\n+ * Note: The static createXXX methods return singleton instances\n+ * from the {@link InstructionConst} class.\n@@ -33,1 +35,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -37,1 +39,4 @@\n-    private static class MethodObject {\n+    \/\/ N.N. These must agree with the order of Constants.T_CHAR through T_LONG\n+    private static final String[] short_names = {\n+            \"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"\n+    };\n@@ -39,4 +44,2 @@\n-        final Type[] argTypes;\n-        final Type resultType;\n-        final String className;\n-        final String name;\n+    private ClassGen cg;\n+    private ConstantPoolGen cp;\n@@ -44,6 +47,3 @@\n-        MethodObject(final String c, final String n, final Type r, final Type[] a) {\n-            this.className = c;\n-            this.name = n;\n-            this.resultType = r;\n-            this.argTypes = a;\n-        }\n+    public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {\n+        this.cg = cg;\n+        this.cp = cp;\n@@ -52,1 +52,0 @@\n-    private static final String APPEND = \"append\";\n@@ -54,1 +53,12 @@\n-    private static final String FQCN_STRING_BUFFER = \"java.lang.StringBuffer\";\n+    \/** Initialize with ClassGen object\n+     *\/\n+    public InstructionFactory(final ClassGen cg) {\n+        this(cg, cg.getConstantPool());\n+    }\n+\n+\n+    \/** Initialize just with ConstantPoolGen object\n+     *\/\n+    public InstructionFactory(final ConstantPoolGen cp) {\n+        this(null, cp);\n+    }\n@@ -56,14 +66,15 @@\n-    \/\/ N.N. These must agree with the order of Constants.T_CHAR through T_LONG\n-    private static final String[] shortNames = {\"C\", \"F\", \"D\", \"B\", \"S\", \"I\", \"L\"};\n-\n-    private static final MethodObject[] appendMethodObjects = {\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.STRING }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.OBJECT }), null, null, \/\/ indices 2, 3\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.BOOLEAN }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.CHAR }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.FLOAT }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.DOUBLE }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }),\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }), \/\/ No append(byte)\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.INT }), \/\/ No append(short)\n-            new MethodObject(FQCN_STRING_BUFFER, APPEND, Type.STRINGBUFFER, new Type[] { Type.LONG })};\n+\n+    \/** Create an invoke instruction. (Except for invokedynamic.)\n+     *\n+     * @param class_name name of the called class\n+     * @param name name of the called method\n+     * @param ret_type return type of method\n+     * @param arg_types argument types of method\n+     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL,\n+     * or INVOKESPECIAL\n+     * @see Const\n+     *\/\n+    public InvokeInstruction createInvoke( final String class_name, final String name,\n+            final Type ret_type, final Type[] arg_types, final short kind ) {\n+        return createInvoke(class_name, name, ret_type, arg_types, kind, kind == Const.INVOKEINTERFACE);\n+    }\n@@ -72,1 +83,10 @@\n-     * @param type type of elements of array, i.e., array.getElementType()\n+     * Creates an invoke instruction. (Except for invokedynamic.)\n+     *\n+     * @param class_name name of the called class\n+     * @param name name of the called method\n+     * @param ret_type return type of method\n+     * @param arg_types argument types of method\n+     * @param kind how to invoke: INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n+     * @param use_interface force use of InterfaceMethodref\n+     * @return A new InvokeInstruction.\n+     * @since 6.5.0\n@@ -74,20 +94,28 @@\n-    public static ArrayInstruction createArrayLoad(final Type type) {\n-        switch (type.getType()) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_BYTE:\n-            return InstructionConst.BALOAD;\n-        case Const.T_CHAR:\n-            return InstructionConst.CALOAD;\n-        case Const.T_SHORT:\n-            return InstructionConst.SALOAD;\n-        case Const.T_INT:\n-            return InstructionConst.IALOAD;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FALOAD;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DALOAD;\n-        case Const.T_LONG:\n-            return InstructionConst.LALOAD;\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.AALOAD;\n+    public InvokeInstruction createInvoke( final String class_name, final String name, final Type ret_type,\n+        final Type[] arg_types, final short kind, final boolean use_interface) {\n+        if (kind != Const.INVOKESPECIAL && kind != Const.INVOKEVIRTUAL && kind != Const.INVOKESTATIC\n+            && kind != Const.INVOKEINTERFACE && kind != Const.INVOKEDYNAMIC) {\n+            throw new IllegalArgumentException(\"Unknown invoke kind: \" + kind);\n+        }\n+        int index;\n+        int nargs = 0;\n+        final String signature = Type.getMethodSignature(ret_type, arg_types);\n+        for (final Type arg_type : arg_types) {\n+            nargs += arg_type.getSize();\n+        }\n+        if (use_interface) {\n+            index = cp.addInterfaceMethodref(class_name, name, signature);\n+        } else {\n+            index = cp.addMethodref(class_name, name, signature);\n+        }\n+        switch (kind) {\n+        case Const.INVOKESPECIAL:\n+            return new INVOKESPECIAL(index);\n+        case Const.INVOKEVIRTUAL:\n+            return new INVOKEVIRTUAL(index);\n+        case Const.INVOKESTATIC:\n+            return new INVOKESTATIC(index);\n+        case Const.INVOKEINTERFACE:\n+            return new INVOKEINTERFACE(index, nargs + 1);\n+        case Const.INVOKEDYNAMIC:\n+            return new INVOKEDYNAMIC(index);\n@@ -95,1 +123,2 @@\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+            \/\/ Can't happen\n+            throw new IllegalStateException(\"Unknown invoke kind: \" + kind);\n@@ -99,2 +128,7 @@\n-    \/**\n-     * @param type type of elements of array, i.e., array.getElementType()\n+    \/** Create an invokedynamic instruction.\n+     *\n+     * @param bootstrap_index index into the bootstrap_methods array\n+     * @param name name of the called method\n+     * @param ret_type return type of method\n+     * @param arg_types argument types of method\n+     * @see Constants\n@@ -102,22 +136,11 @@\n-    public static ArrayInstruction createArrayStore(final Type type) {\n-        switch (type.getType()) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_BYTE:\n-            return InstructionConst.BASTORE;\n-        case Const.T_CHAR:\n-            return InstructionConst.CASTORE;\n-        case Const.T_SHORT:\n-            return InstructionConst.SASTORE;\n-        case Const.T_INT:\n-            return InstructionConst.IASTORE;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FASTORE;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DASTORE;\n-        case Const.T_LONG:\n-            return InstructionConst.LASTORE;\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.AASTORE;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+\/*\n+ * createInvokeDynamic only needed if instrumention code wants to generate\n+ * a new invokedynamic instruction.  I don't think we need.  (markro)\n+ *\n+    public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type,\n+            Type[] arg_types) {\n+        int index;\n+        int nargs = 0;\n+        String signature = Type.getMethodSignature(ret_type, arg_types);\n+        for (int i = 0; i < arg_types.length; i++) {\n+            nargs += arg_types[i].getSize();\n@@ -125,0 +148,4 @@\n+        \/\/ UNDONE - needs to be added to ConstantPoolGen\n+        \/\/index = cp.addInvokeDynamic(bootstrap_index, name, signature);\n+        index = 0;\n+        return new INVOKEDYNAMIC(index);\n@@ -126,0 +153,1 @@\n+ *\/\n@@ -127,14 +155,30 @@\n-    private static ArithmeticInstruction createBinaryDoubleOp(final char op) {\n-        switch (op) {\n-        case '-':\n-            return InstructionConst.DSUB;\n-        case '+':\n-            return InstructionConst.DADD;\n-        case '*':\n-            return InstructionConst.DMUL;\n-        case '\/':\n-            return InstructionConst.DDIV;\n-        case '%':\n-            return InstructionConst.DREM;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+    \/** Create a call to the most popular System.out.println() method.\n+     *\n+     * @param s the string to print\n+     *\/\n+    public InstructionList createPrintln( final String s ) {\n+        final InstructionList il = new InstructionList();\n+        final int out = cp.addFieldref(\"java.lang.System\", \"out\", \"Ljava\/io\/PrintStream;\");\n+        final int println = cp.addMethodref(\"java.io.PrintStream\", \"println\", \"(Ljava\/lang\/String;)V\");\n+        il.append(new GETSTATIC(out));\n+        il.append(new PUSH(cp, s));\n+        il.append(new INVOKEVIRTUAL(println));\n+        return il;\n+    }\n+\n+\n+    \/** Uses PUSH to push a constant value onto the stack.\n+     * @param value must be of type Number, Boolean, Character or String\n+     *\/\n+    public Instruction createConstant( final Object value ) {\n+        PUSH push;\n+        if (value instanceof Number) {\n+            push = new PUSH(cp, (Number) value);\n+        } else if (value instanceof String) {\n+            push = new PUSH(cp, (String) value);\n+        } else if (value instanceof Boolean) {\n+            push = new PUSH(cp, (Boolean) value);\n+        } else if (value instanceof Character) {\n+            push = new PUSH(cp, (Character) value);\n+        } else {\n+            throw new ClassGenException(\"Illegal type: \" + value.getClass());\n@@ -142,0 +186,1 @@\n+        return push.getInstruction();\n@@ -144,14 +189,13 @@\n-    private static ArithmeticInstruction createBinaryFloatOp(final char op) {\n-        switch (op) {\n-        case '-':\n-            return InstructionConst.FSUB;\n-        case '+':\n-            return InstructionConst.FADD;\n-        case '*':\n-            return InstructionConst.FMUL;\n-        case '\/':\n-            return InstructionConst.FDIV;\n-        case '%':\n-            return InstructionConst.FREM;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+    private static class MethodObject {\n+\n+        final Type[] arg_types;\n+        final Type result_type;\n+        final String class_name;\n+        final String name;\n+\n+\n+        MethodObject(final String c, final String n, final Type r, final Type[] a) {\n+            class_name = c;\n+            name = n;\n+            result_type = r;\n+            arg_types = a;\n@@ -161,24 +205,69 @@\n-    private static ArithmeticInstruction createBinaryIntOp(final char first, final String op) {\n-        switch (first) {\n-        case '-':\n-            return InstructionConst.ISUB;\n-        case '+':\n-            return InstructionConst.IADD;\n-        case '%':\n-            return InstructionConst.IREM;\n-        case '*':\n-            return InstructionConst.IMUL;\n-        case '\/':\n-            return InstructionConst.IDIV;\n-        case '&':\n-            return InstructionConst.IAND;\n-        case '|':\n-            return InstructionConst.IOR;\n-        case '^':\n-            return InstructionConst.IXOR;\n-        case '<':\n-            return InstructionConst.ISHL;\n-        case '>':\n-            return op.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+\n+    private InvokeInstruction createInvoke( final MethodObject m, final short kind ) {\n+        return createInvoke(m.class_name, m.name, m.result_type, m.arg_types, kind);\n+    }\n+\n+    private static final MethodObject[] append_mos = {\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.STRING\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.OBJECT\n+            }),\n+            null,\n+            null, \/\/ indices 2, 3\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.BOOLEAN\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.CHAR\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.FLOAT\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.DOUBLE\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.INT\n+            }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, \/\/ No append(byte)\n+                    new Type[] {\n+                        Type.INT\n+                    }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, \/\/ No append(short)\n+                    new Type[] {\n+                        Type.INT\n+                    }),\n+            new MethodObject(\"java.lang.StringBuffer\", \"append\", Type.STRINGBUFFER, new Type[] {\n+                Type.LONG\n+            })\n+    };\n+\n+\n+    private static boolean isString( final Type type ) {\n+        return (type instanceof ObjectType) &&\n+              ((ObjectType) type).getClassName().equals(\"java.lang.String\");\n+    }\n+\n+\n+    public Instruction createAppend( final Type type ) {\n+        final byte t = type.getType();\n+        if (isString(type)) {\n+            return createInvoke(append_mos[0], Const.INVOKEVIRTUAL);\n+        }\n+        switch (t) {\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_FLOAT:\n+            case Const.T_DOUBLE:\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+            case Const.T_LONG:\n+                return createInvoke(append_mos[t], Const.INVOKEVIRTUAL);\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return createInvoke(append_mos[1], Const.INVOKEVIRTUAL);\n+            default:\n+                throw new IllegalArgumentException(\"No append for this type? \" + type);\n@@ -188,2 +277,2 @@\n-    \/**\n-     * Create an invokedynamic instruction.\n+\n+    \/** Create a field instruction.\n@@ -191,4 +280,4 @@\n-     * @param bootstrap_index index into the bootstrap_methods array\n-     * @param name name of the called method\n-     * @param ret_type return type of method\n-     * @param argTypes argument types of method\n+     * @param class_name name of the accessed class\n+     * @param name name of the referenced field\n+     * @param type  type of field\n+     * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC\n@@ -197,0 +286,18 @@\n+    public FieldInstruction createFieldAccess( final String class_name,\n+            final String name, final Type type, final short kind ) {\n+        int index;\n+        final String signature = type.getSignature();\n+        index = cp.addFieldref(class_name, name, signature);\n+        switch (kind) {\n+            case Const.GETFIELD:\n+                return new GETFIELD(index);\n+            case Const.PUTFIELD:\n+                return new PUTFIELD(index);\n+            case Const.GETSTATIC:\n+                return new GETSTATIC(index);\n+            case Const.PUTSTATIC:\n+                return new PUTSTATIC(index);\n+            default:\n+                throw new IllegalArgumentException(\"Unknown getfield kind:\" + kind);\n+        }\n+    }\n@@ -198,8 +305,2 @@\n-    \/*\n-     * createInvokeDynamic only needed if instrumentation code wants to generate a new invokedynamic instruction. I don't\n-     * think we need.\n-     *\n-     * public InvokeInstruction createInvokeDynamic( int bootstrap_index, String name, Type ret_type, Type[] argTypes) {\n-     * int index; int nargs = 0; String signature = Type.getMethodSignature(ret_type, argTypes); for (int i = 0; i <\n-     * argTypes.length; i++) { nargs += argTypes[i].getSize(); } \/\/ UNDONE - needs to be added to ConstantPoolGen \/\/index\n-     * = cp.addInvokeDynamic(bootstrap_index, name, signature); index = 0; return new INVOKEDYNAMIC(index); }\n+\n+    \/** Create reference to `this'\n@@ -207,0 +308,31 @@\n+    public static Instruction createThis() {\n+        return new ALOAD(0);\n+    }\n+\n+\n+    \/** Create typed return\n+     *\/\n+    public static ReturnInstruction createReturn( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.ARETURN;\n+            case Const.T_INT:\n+            case Const.T_SHORT:\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+                return InstructionConst.IRETURN;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FRETURN;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DRETURN;\n+            case Const.T_LONG:\n+                return InstructionConst.LRETURN;\n+            case Const.T_VOID:\n+                return InstructionConst.RETURN;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type: \" + type);\n+        }\n+    }\n+\n@@ -208,1 +340,1 @@\n-    private static ArithmeticInstruction createBinaryLongOp(final char first, final String op) {\n+    private static ArithmeticInstruction createBinaryIntOp( final char first, final String op ) {\n@@ -210,22 +342,86 @@\n-        case '-':\n-            return InstructionConst.LSUB;\n-        case '+':\n-            return InstructionConst.LADD;\n-        case '%':\n-            return InstructionConst.LREM;\n-        case '*':\n-            return InstructionConst.LMUL;\n-        case '\/':\n-            return InstructionConst.LDIV;\n-        case '&':\n-            return InstructionConst.LAND;\n-        case '|':\n-            return InstructionConst.LOR;\n-        case '^':\n-            return InstructionConst.LXOR;\n-        case '<':\n-            return InstructionConst.LSHL;\n-        case '>':\n-            return op.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid operand \" + op);\n+            case '-':\n+                return InstructionConst.ISUB;\n+            case '+':\n+                return InstructionConst.IADD;\n+            case '%':\n+                return InstructionConst.IREM;\n+            case '*':\n+                return InstructionConst.IMUL;\n+            case '\/':\n+                return InstructionConst.IDIV;\n+            case '&':\n+                return InstructionConst.IAND;\n+            case '|':\n+                return InstructionConst.IOR;\n+            case '^':\n+                return InstructionConst.IXOR;\n+            case '<':\n+                return InstructionConst.ISHL;\n+            case '>':\n+                return op.equals(\">>>\") ? InstructionConst.IUSHR : InstructionConst.ISHR;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n+        }\n+    }\n+\n+\n+    private static ArithmeticInstruction createBinaryLongOp( final char first, final String op ) {\n+        switch (first) {\n+            case '-':\n+                return InstructionConst.LSUB;\n+            case '+':\n+                return InstructionConst.LADD;\n+            case '%':\n+                return InstructionConst.LREM;\n+            case '*':\n+                return InstructionConst.LMUL;\n+            case '\/':\n+                return InstructionConst.LDIV;\n+            case '&':\n+                return InstructionConst.LAND;\n+            case '|':\n+                return InstructionConst.LOR;\n+            case '^':\n+                return InstructionConst.LXOR;\n+            case '<':\n+                return InstructionConst.LSHL;\n+            case '>':\n+                return op.equals(\">>>\") ? InstructionConst.LUSHR : InstructionConst.LSHR;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n+        }\n+    }\n+\n+\n+    private static ArithmeticInstruction createBinaryFloatOp( final char op ) {\n+        switch (op) {\n+            case '-':\n+                return InstructionConst.FSUB;\n+            case '+':\n+                return InstructionConst.FADD;\n+            case '*':\n+                return InstructionConst.FMUL;\n+            case '\/':\n+                return InstructionConst.FDIV;\n+            case '%':\n+                return InstructionConst.FREM;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n+        }\n+    }\n+\n+\n+    private static ArithmeticInstruction createBinaryDoubleOp( final char op ) {\n+        switch (op) {\n+            case '-':\n+                return InstructionConst.DSUB;\n+            case '+':\n+                return InstructionConst.DADD;\n+            case '*':\n+                return InstructionConst.DMUL;\n+            case '\/':\n+                return InstructionConst.DDIV;\n+            case '%':\n+                return InstructionConst.DREM;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid operand \" + op);\n@@ -235,0 +431,1 @@\n+\n@@ -240,1 +437,1 @@\n-    public static ArithmeticInstruction createBinaryOperation(final String op, final Type type) {\n+    public static ArithmeticInstruction createBinaryOperation( final String op, final Type type ) {\n@@ -243,13 +440,13 @@\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-        case Const.T_CHAR:\n-            return createBinaryIntOp(first, op);\n-        case Const.T_LONG:\n-            return createBinaryLongOp(first, op);\n-        case Const.T_FLOAT:\n-            return createBinaryFloatOp(first);\n-        case Const.T_DOUBLE:\n-            return createBinaryDoubleOp(first);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+            case Const.T_CHAR:\n+                return createBinaryIntOp(first, op);\n+            case Const.T_LONG:\n+                return createBinaryLongOp(first, op);\n+            case Const.T_FLOAT:\n+                return createBinaryFloatOp(first);\n+            case Const.T_DOUBLE:\n+                return createBinaryDoubleOp(first);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -259,50 +456,0 @@\n-    \/**\n-     * Create branch instruction by given opcode, except LOOKUPSWITCH and TABLESWITCH. For those you should use the SWITCH\n-     * compound instruction.\n-     *\/\n-    public static BranchInstruction createBranchInstruction(final short opcode, final InstructionHandle target) {\n-        switch (opcode) {\n-        case Const.IFEQ:\n-            return new IFEQ(target);\n-        case Const.IFNE:\n-            return new IFNE(target);\n-        case Const.IFLT:\n-            return new IFLT(target);\n-        case Const.IFGE:\n-            return new IFGE(target);\n-        case Const.IFGT:\n-            return new IFGT(target);\n-        case Const.IFLE:\n-            return new IFLE(target);\n-        case Const.IF_ICMPEQ:\n-            return new IF_ICMPEQ(target);\n-        case Const.IF_ICMPNE:\n-            return new IF_ICMPNE(target);\n-        case Const.IF_ICMPLT:\n-            return new IF_ICMPLT(target);\n-        case Const.IF_ICMPGE:\n-            return new IF_ICMPGE(target);\n-        case Const.IF_ICMPGT:\n-            return new IF_ICMPGT(target);\n-        case Const.IF_ICMPLE:\n-            return new IF_ICMPLE(target);\n-        case Const.IF_ACMPEQ:\n-            return new IF_ACMPEQ(target);\n-        case Const.IF_ACMPNE:\n-            return new IF_ACMPNE(target);\n-        case Const.GOTO:\n-            return new GOTO(target);\n-        case Const.JSR:\n-            return new JSR(target);\n-        case Const.IFNULL:\n-            return new IFNULL(target);\n-        case Const.IFNONNULL:\n-            return new IFNONNULL(target);\n-        case Const.GOTO_W:\n-            return new GOTO_W(target);\n-        case Const.JSR_W:\n-            return new JSR_W(target);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\n-        }\n-    }\n@@ -313,2 +460,2 @@\n-    public static StackInstruction createDup(final int size) {\n-        return size == 2 ? InstructionConst.DUP2 : InstructionConst.DUP;\n+    public static StackInstruction createPop( final int size ) {\n+        return (size == 2) ? InstructionConst.POP2 : InstructionConst.POP;\n@@ -317,6 +464,0 @@\n-    \/**\n-     * @param size size of operand, either 1 (int, e.g.) or 2 (double)\n-     *\/\n-    public static StackInstruction createDup_1(final int size) {\n-        return size == 2 ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n-    }\n@@ -327,2 +468,2 @@\n-    public static StackInstruction createDup_2(final int size) {\n-        return size == 2 ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n+    public static StackInstruction createDup( final int size ) {\n+        return (size == 2) ? InstructionConst.DUP2 : InstructionConst.DUP;\n@@ -331,24 +472,0 @@\n-    \/**\n-     * @param index index of local variable\n-     *\/\n-    public static LocalVariableInstruction createLoad(final Type type, final int index) {\n-        switch (type.getType()) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-            return new ILOAD(index);\n-        case Const.T_FLOAT:\n-            return new FLOAD(index);\n-        case Const.T_DOUBLE:\n-            return new DLOAD(index);\n-        case Const.T_LONG:\n-            return new LLOAD(index);\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return new ALOAD(index);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n-        }\n-    }\n@@ -357,1 +474,1 @@\n-     * Create \"null\" value for reference types, 0 for basic types like int\n+     * @param size size of operand, either 1 (int, e.g.) or 2 (double)\n@@ -359,22 +476,2 @@\n-    public static Instruction createNull(final Type type) {\n-        switch (type.getType()) {\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.ACONST_NULL;\n-        case Const.T_INT:\n-        case Const.T_SHORT:\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-            return InstructionConst.ICONST_0;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FCONST_0;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DCONST_0;\n-        case Const.T_LONG:\n-            return InstructionConst.LCONST_0;\n-        case Const.T_VOID:\n-            return InstructionConst.NOP;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type: \" + type);\n-        }\n+    public static StackInstruction createDup_2( final int size ) {\n+        return (size == 2) ? InstructionConst.DUP2_X2 : InstructionConst.DUP_X2;\n@@ -383,0 +480,1 @@\n+\n@@ -386,2 +484,2 @@\n-    public static StackInstruction createPop(final int size) {\n-        return size == 2 ? InstructionConst.POP2 : InstructionConst.POP;\n+    public static StackInstruction createDup_1( final int size ) {\n+        return (size == 2) ? InstructionConst.DUP2_X1 : InstructionConst.DUP_X1;\n@@ -390,0 +488,1 @@\n+\n@@ -391,1 +490,1 @@\n-     * Create typed return\n+     * @param index index of local variable\n@@ -393,1 +492,1 @@\n-    public static ReturnInstruction createReturn(final Type type) {\n+    public static LocalVariableInstruction createStore( final Type type, final int index ) {\n@@ -395,19 +494,17 @@\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return InstructionConst.ARETURN;\n-        case Const.T_INT:\n-        case Const.T_SHORT:\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-            return InstructionConst.IRETURN;\n-        case Const.T_FLOAT:\n-            return InstructionConst.FRETURN;\n-        case Const.T_DOUBLE:\n-            return InstructionConst.DRETURN;\n-        case Const.T_LONG:\n-            return InstructionConst.LRETURN;\n-        case Const.T_VOID:\n-            return InstructionConst.RETURN;\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type: \" + type);\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+                return new ISTORE(index);\n+            case Const.T_FLOAT:\n+                return new FSTORE(index);\n+            case Const.T_DOUBLE:\n+                return new DSTORE(index);\n+            case Const.T_LONG:\n+                return new LSTORE(index);\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return new ASTORE(index);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -417,0 +514,1 @@\n+\n@@ -420,1 +518,1 @@\n-    public static LocalVariableInstruction createStore(final Type type, final int index) {\n+    public static LocalVariableInstruction createLoad( final Type type, final int index ) {\n@@ -422,17 +520,17 @@\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-            return new ISTORE(index);\n-        case Const.T_FLOAT:\n-            return new FSTORE(index);\n-        case Const.T_DOUBLE:\n-            return new DSTORE(index);\n-        case Const.T_LONG:\n-            return new LSTORE(index);\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return new ASTORE(index);\n-        default:\n-            throw new IllegalArgumentException(\"Invalid type \" + type);\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+            case Const.T_SHORT:\n+            case Const.T_INT:\n+                return new ILOAD(index);\n+            case Const.T_FLOAT:\n+                return new FLOAD(index);\n+            case Const.T_DOUBLE:\n+                return new DLOAD(index);\n+            case Const.T_LONG:\n+                return new LLOAD(index);\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return new ALOAD(index);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -442,22 +540,0 @@\n-    \/**\n-     * Create reference to 'this'\n-     *\/\n-    public static Instruction createThis() {\n-        return new ALOAD(0);\n-    }\n-\n-    private static boolean isString(final Type type) {\n-        return type instanceof ObjectType && ((ObjectType) type).getClassName().equals(\"java.lang.String\");\n-    }\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected ClassGen cg;\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected ConstantPoolGen cp;\n@@ -466,1 +542,1 @@\n-     * Initialize with ClassGen object\n+     * @param type type of elements of array, i.e., array.getElementType()\n@@ -468,2 +544,23 @@\n-    public InstructionFactory(final ClassGen cg) {\n-        this(cg, cg.getConstantPool());\n+    public static ArrayInstruction createArrayLoad( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_BOOLEAN:\n+            case Const.T_BYTE:\n+                return InstructionConst.BALOAD;\n+            case Const.T_CHAR:\n+                return InstructionConst.CALOAD;\n+            case Const.T_SHORT:\n+                return InstructionConst.SALOAD;\n+            case Const.T_INT:\n+                return InstructionConst.IALOAD;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FALOAD;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DALOAD;\n+            case Const.T_LONG:\n+                return InstructionConst.LALOAD;\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.AALOAD;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n+        }\n@@ -472,4 +569,0 @@\n-    public InstructionFactory(final ClassGen cg, final ConstantPoolGen cp) {\n-        this.cg = cg;\n-        this.cp = cp;\n-    }\n@@ -478,1 +571,1 @@\n-     * Initialize just with ConstantPoolGen object\n+     * @param type type of elements of array, i.e., array.getElementType()\n@@ -480,24 +573,22 @@\n-    public InstructionFactory(final ConstantPoolGen cp) {\n-        this(null, cp);\n-    }\n-\n-    public Instruction createAppend(final Type type) {\n-        final byte t = type.getType();\n-        if (isString(type)) {\n-            return createInvoke(appendMethodObjects[0], Const.INVOKEVIRTUAL);\n-        }\n-        switch (t) {\n-        case Const.T_BOOLEAN:\n-        case Const.T_CHAR:\n-        case Const.T_FLOAT:\n-        case Const.T_DOUBLE:\n-        case Const.T_BYTE:\n-        case Const.T_SHORT:\n-        case Const.T_INT:\n-        case Const.T_LONG:\n-            return createInvoke(appendMethodObjects[t], Const.INVOKEVIRTUAL);\n-        case Const.T_ARRAY:\n-        case Const.T_OBJECT:\n-            return createInvoke(appendMethodObjects[1], Const.INVOKEVIRTUAL);\n-        default:\n-            throw new IllegalArgumentException(\"No append for this type? \" + type);\n+    public static ArrayInstruction createArrayStore( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_BOOLEAN:\n+            case Const.T_BYTE:\n+                return InstructionConst.BASTORE;\n+            case Const.T_CHAR:\n+                return InstructionConst.CASTORE;\n+            case Const.T_SHORT:\n+                return InstructionConst.SASTORE;\n+            case Const.T_INT:\n+                return InstructionConst.IASTORE;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FASTORE;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DASTORE;\n+            case Const.T_LONG:\n+                return InstructionConst.LASTORE;\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.AASTORE;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type \" + type);\n@@ -508,2 +599,3 @@\n-     * Create conversion operation for two stack operands, this may be an I2C, instruction, e.g., if the operands are basic\n-     * types and CHECKCAST if they are reference types.\n+     * Create conversion operation for two stack operands, this may be an I2C,\n+     * instruction, e.g., if the operands are basic types and CHECKCAST if they\n+     * are reference types.\n@@ -511,5 +603,6 @@\n-    public Instruction createCast(final Type srcType, final Type destType) {\n-        if (srcType instanceof BasicType && destType instanceof BasicType) {\n-            final byte dest = destType.getType();\n-            byte src = srcType.getType();\n-            if (dest == Const.T_LONG && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {\n+    public Instruction createCast( final Type src_type, final Type dest_type ) {\n+        if ((src_type instanceof BasicType) && (dest_type instanceof BasicType)) {\n+            final byte dest = dest_type.getType();\n+            byte src = src_type.getType();\n+            if (dest == Const.T_LONG\n+                    && (src == Const.T_CHAR || src == Const.T_BYTE || src == Const.T_SHORT)) {\n@@ -518,1 +611,2 @@\n-            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + shortNames[src - Const.T_CHAR] + \"2\" + shortNames[dest - Const.T_CHAR];\n+            final String name = \"com.sun.org.apache.bcel.internal.generic.\" + short_names[src - Const.T_CHAR] + \"2\"\n+                    + short_names[dest - Const.T_CHAR];\n@@ -521,1 +615,1 @@\n-                i = (Instruction) Class.forName(name).getDeclaredConstructor().newInstance();;\n+                i = (Instruction) java.lang.Class.forName(name).getDeclaredConstructor().newInstance();\n@@ -526,0 +620,7 @@\n+        } else if ((src_type instanceof ReferenceType) && (dest_type instanceof ReferenceType)) {\n+            if (dest_type instanceof ArrayType) {\n+                return new CHECKCAST(cp.addArrayClass((ArrayType) dest_type));\n+            }\n+            return new CHECKCAST(cp.addClass(((ObjectType) dest_type).getClassName()));\n+        } else {\n+            throw new IllegalArgumentException(\"Cannot cast \" + src_type + \" to \" + dest_type);\n@@ -527,7 +628,0 @@\n-        if (!(srcType instanceof ReferenceType) || !(destType instanceof ReferenceType)) {\n-            throw new IllegalArgumentException(\"Cannot cast \" + srcType + \" to \" + destType);\n-        }\n-        if (destType instanceof ArrayType) {\n-            return new CHECKCAST(cp.addArrayClass((ArrayType) destType));\n-        }\n-        return new CHECKCAST(cp.addClass(((ObjectType) destType).getClassName()));\n@@ -536,6 +630,0 @@\n-    public CHECKCAST createCheckCast(final ReferenceType t) {\n-        if (t instanceof ArrayType) {\n-            return new CHECKCAST(cp.addArrayClass((ArrayType) t));\n-        }\n-        return new CHECKCAST(cp.addClass((ObjectType) t));\n-    }\n@@ -543,19 +631,2 @@\n-    \/**\n-     * Uses PUSH to push a constant value onto the stack.\n-     *\n-     * @param value must be of type Number, Boolean, Character or String\n-     *\/\n-    public Instruction createConstant(final Object value) {\n-        PUSH push;\n-        if (value instanceof Number) {\n-            push = new PUSH(cp, (Number) value);\n-        } else if (value instanceof String) {\n-            push = new PUSH(cp, (String) value);\n-        } else if (value instanceof Boolean) {\n-            push = new PUSH(cp, (Boolean) value);\n-        } else if (value instanceof Character) {\n-            push = new PUSH(cp, (Character) value);\n-        } else {\n-            throw new ClassGenException(\"Illegal type: \" + value.getClass());\n-        }\n-        return push.getInstruction();\n+    public GETFIELD createGetField( final String class_name, final String name, final Type t ) {\n+        return new GETFIELD(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -564,25 +635,3 @@\n-    \/**\n-     * Create a field instruction.\n-     *\n-     * @param className name of the accessed class\n-     * @param name name of the referenced field\n-     * @param type type of field\n-     * @param kind how to access, i.e., GETFIELD, PUTFIELD, GETSTATIC, PUTSTATIC\n-     * @see Const\n-     *\/\n-    public FieldInstruction createFieldAccess(final String className, final String name, final Type type, final short kind) {\n-        int index;\n-        final String signature = type.getSignature();\n-        index = cp.addFieldref(className, name, signature);\n-        switch (kind) {\n-        case Const.GETFIELD:\n-            return new GETFIELD(index);\n-        case Const.PUTFIELD:\n-            return new PUTFIELD(index);\n-        case Const.GETSTATIC:\n-            return new GETSTATIC(index);\n-        case Const.PUTSTATIC:\n-            return new PUTSTATIC(index);\n-        default:\n-            throw new IllegalArgumentException(\"Unknown getfield kind:\" + kind);\n-        }\n+\n+    public GETSTATIC createGetStatic( final String class_name, final String name, final Type t ) {\n+        return new GETSTATIC(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -591,2 +640,3 @@\n-    public GETFIELD createGetField(final String className, final String name, final Type t) {\n-        return new GETFIELD(cp.addFieldref(className, name, t.getSignature()));\n+\n+    public PUTFIELD createPutField( final String class_name, final String name, final Type t ) {\n+        return new PUTFIELD(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -595,2 +645,3 @@\n-    public GETSTATIC createGetStatic(final String className, final String name, final Type t) {\n-        return new GETSTATIC(cp.addFieldref(className, name, t.getSignature()));\n+\n+    public PUTSTATIC createPutStatic( final String class_name, final String name, final Type t ) {\n+        return new PUTSTATIC(cp.addFieldref(class_name, name, t.getSignature()));\n@@ -599,1 +650,2 @@\n-    public INSTANCEOF createInstanceOf(final ReferenceType t) {\n+\n+    public CHECKCAST createCheckCast( final ReferenceType t ) {\n@@ -601,1 +653,1 @@\n-            return new INSTANCEOF(cp.addArrayClass((ArrayType) t));\n+            return new CHECKCAST(cp.addArrayClass((ArrayType) t));\n@@ -603,5 +655,1 @@\n-        return new INSTANCEOF(cp.addClass((ObjectType) t));\n-    }\n-\n-    private InvokeInstruction createInvoke(final MethodObject m, final short kind) {\n-        return createInvoke(m.className, m.name, m.resultType, m.argTypes, kind);\n+        return new CHECKCAST(cp.addClass((ObjectType) t));\n@@ -610,13 +658,0 @@\n-    \/**\n-     * Create an invoke instruction. (Except for invokedynamic.)\n-     *\n-     * @param className name of the called class\n-     * @param name name of the called method\n-     * @param retType return type of method\n-     * @param argTypes argument types of method\n-     * @param kind how to invoke, i.e., INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n-     * @see Const\n-     *\/\n-    public InvokeInstruction createInvoke(final String className, final String name, final Type retType, final Type[] argTypes, final short kind) {\n-        return createInvoke(className, name, retType, argTypes, kind, kind == Const.INVOKEINTERFACE);\n-    }\n@@ -624,43 +659,3 @@\n-    \/**\n-     * Create an invoke instruction. (Except for invokedynamic.)\n-     *\n-     * @param className name of the called class\n-     * @param name name of the called method\n-     * @param retType return type of method\n-     * @param argTypes argument types of method\n-     * @param kind how to invoke: INVOKEINTERFACE, INVOKESTATIC, INVOKEVIRTUAL, or INVOKESPECIAL\n-     * @param useInterface force use of InterfaceMethodref\n-     * @return A new InvokeInstruction.\n-     * @since 6.5.0\n-     *\/\n-    public InvokeInstruction createInvoke(final String className, final String name, final Type retType, final Type[] argTypes, final short kind,\n-        final boolean useInterface) {\n-        if (kind != Const.INVOKESPECIAL && kind != Const.INVOKEVIRTUAL && kind != Const.INVOKESTATIC && kind != Const.INVOKEINTERFACE\n-            && kind != Const.INVOKEDYNAMIC) {\n-            throw new IllegalArgumentException(\"Unknown invoke kind: \" + kind);\n-        }\n-        int index;\n-        int nargs = 0;\n-        final String signature = Type.getMethodSignature(retType, argTypes);\n-        for (final Type argType : argTypes) {\n-            nargs += argType.getSize();\n-        }\n-        if (useInterface) {\n-            index = cp.addInterfaceMethodref(className, name, signature);\n-        } else {\n-            index = cp.addMethodref(className, name, signature);\n-        }\n-        switch (kind) {\n-        case Const.INVOKESPECIAL:\n-            return new INVOKESPECIAL(index);\n-        case Const.INVOKEVIRTUAL:\n-            return new INVOKEVIRTUAL(index);\n-        case Const.INVOKESTATIC:\n-            return new INVOKESTATIC(index);\n-        case Const.INVOKEINTERFACE:\n-            return new INVOKEINTERFACE(index, nargs + 1);\n-        case Const.INVOKEDYNAMIC:\n-            return new INVOKEDYNAMIC(index);\n-        default:\n-            \/\/ Can't happen\n-            throw new IllegalStateException(\"Unknown invoke kind: \" + kind);\n+    public INSTANCEOF createInstanceOf( final ReferenceType t ) {\n+        if (t instanceof ArrayType) {\n+            return new INSTANCEOF(cp.addArrayClass((ArrayType) t));\n@@ -668,0 +663,1 @@\n+        return new INSTANCEOF(cp.addClass((ObjectType) t));\n@@ -670,1 +666,2 @@\n-    public NEW createNew(final ObjectType t) {\n+\n+    public NEW createNew( final ObjectType t ) {\n@@ -674,1 +671,2 @@\n-    public NEW createNew(final String s) {\n+\n+    public NEW createNew( final String s ) {\n@@ -681,1 +679,2 @@\n-     * @return an instruction that creates the corresponding array at runtime, i.e. is an AllocationInstruction\n+     * @return an instruction that creates the corresponding array at runtime,\n+     * i.e. is an AllocationInstruction\n@@ -683,1 +682,1 @@\n-    public Instruction createNewArray(final Type t, final short dim) {\n+    public Instruction createNewArray( final Type t, final short dim ) {\n@@ -687,2 +686,1 @@\n-            }\n-            if (t instanceof ArrayType) {\n+            } else if (t instanceof ArrayType) {\n@@ -690,0 +688,2 @@\n+            } else {\n+                return new NEWARRAY(t.getType());\n@@ -691,1 +691,0 @@\n-            return new NEWARRAY(t.getType());\n@@ -703,3 +702,1 @@\n-     * Create a call to the most popular System.out.println() method.\n-     *\n-     * @param s the string to print\n+     * Create \"null\" value for reference types, 0 for basic types like int\n@@ -707,7 +704,22 @@\n-    public InstructionList createPrintln(final String s) {\n-        final InstructionList il = new InstructionList();\n-        il.append(createGetStatic(\"java.lang.System\", \"out\", Type.getType(\"Ljava\/io\/PrintStream;\")));\n-        il.append(new PUSH(cp, s));\n-        final MethodObject methodObject = new MethodObject(\"java.io.PrintStream\", \"println\", Type.VOID, new Type[] { Type.getType(\"Ljava\/lang\/String;\") });\n-        il.append(createInvoke(methodObject, Const.INVOKEVIRTUAL));\n-        return il;\n+    public static Instruction createNull( final Type type ) {\n+        switch (type.getType()) {\n+            case Const.T_ARRAY:\n+            case Const.T_OBJECT:\n+                return InstructionConst.ACONST_NULL;\n+            case Const.T_INT:\n+            case Const.T_SHORT:\n+            case Const.T_BOOLEAN:\n+            case Const.T_CHAR:\n+            case Const.T_BYTE:\n+                return InstructionConst.ICONST_0;\n+            case Const.T_FLOAT:\n+                return InstructionConst.FCONST_0;\n+            case Const.T_DOUBLE:\n+                return InstructionConst.DCONST_0;\n+            case Const.T_LONG:\n+                return InstructionConst.LCONST_0;\n+            case Const.T_VOID:\n+                return InstructionConst.NOP;\n+            default:\n+                throw new IllegalArgumentException(\"Invalid type: \" + type);\n+        }\n@@ -716,2 +728,50 @@\n-    public PUTFIELD createPutField(final String className, final String name, final Type t) {\n-        return new PUTFIELD(cp.addFieldref(className, name, t.getSignature()));\n+    \/**\n+     * Create branch instruction by given opcode, except LOOKUPSWITCH and\n+     * TABLESWITCH. For those you should use the SWITCH compound instruction.\n+     *\/\n+    public static BranchInstruction createBranchInstruction( final short opcode,\n+            final InstructionHandle target ) {\n+        switch (opcode) {\n+            case Const.IFEQ:\n+                return new IFEQ(target);\n+            case Const.IFNE:\n+                return new IFNE(target);\n+            case Const.IFLT:\n+                return new IFLT(target);\n+            case Const.IFGE:\n+                return new IFGE(target);\n+            case Const.IFGT:\n+                return new IFGT(target);\n+            case Const.IFLE:\n+                return new IFLE(target);\n+            case Const.IF_ICMPEQ:\n+                return new IF_ICMPEQ(target);\n+            case Const.IF_ICMPNE:\n+                return new IF_ICMPNE(target);\n+            case Const.IF_ICMPLT:\n+                return new IF_ICMPLT(target);\n+            case Const.IF_ICMPGE:\n+                return new IF_ICMPGE(target);\n+            case Const.IF_ICMPGT:\n+                return new IF_ICMPGT(target);\n+            case Const.IF_ICMPLE:\n+                return new IF_ICMPLE(target);\n+            case Const.IF_ACMPEQ:\n+                return new IF_ACMPEQ(target);\n+            case Const.IF_ACMPNE:\n+                return new IF_ACMPNE(target);\n+            case Const.GOTO:\n+                return new GOTO(target);\n+            case Const.JSR:\n+                return new JSR(target);\n+            case Const.IFNULL:\n+                return new IFNULL(target);\n+            case Const.IFNONNULL:\n+                return new IFNONNULL(target);\n+            case Const.GOTO_W:\n+                return new GOTO_W(target);\n+            case Const.JSR_W:\n+                return new JSR_W(target);\n+            default:\n+                throw new IllegalArgumentException(\"Invalid opcode: \" + opcode);\n+        }\n@@ -720,2 +780,3 @@\n-    public PUTSTATIC createPutStatic(final String className, final String name, final Type t) {\n-        return new PUTSTATIC(cp.addFieldref(className, name, t.getSignature()));\n+\n+    public void setClassGen( final ClassGen c ) {\n+        cg = c;\n@@ -724,0 +785,1 @@\n+\n@@ -728,3 +790,0 @@\n-    public ConstantPoolGen getConstantPool() {\n-        return cp;\n-    }\n@@ -732,2 +791,2 @@\n-    public void setClassGen(final ClassGen c) {\n-        cg = c;\n+    public void setConstantPool( final ConstantPoolGen c ) {\n+        cp = c;\n@@ -736,2 +795,3 @@\n-    public void setConstantPool(final ConstantPoolGen c) {\n-        cp = c;\n+\n+    public ConstantPoolGen getConstantPool() {\n+        return cp;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionFactory.java","additions":605,"deletions":545,"binary":false,"changes":1150,"status":"modified"},{"patch":"@@ -31,2 +31,3 @@\n- * Instances of this class give users a handle to the instructions contained in an InstructionList. Instruction objects\n- * may be used more than once within a list, this is useful because it saves memory and may be much faster.\n+ * Instances of this class give users a handle to the instructions contained in\n+ * an InstructionList. Instruction objects may be used more than once within a\n+ * list, this is useful because it saves memory and may be much faster.\n@@ -34,3 +35,6 @@\n- * Within an InstructionList an InstructionHandle object is wrapped around all instructions, i.e., it implements a cell\n- * in a doubly-linked list. From the outside only the next and the previous instruction (handle) are accessible. One can\n- * traverse the list via an Enumeration returned by InstructionList.elements().\n+ * Within an InstructionList an InstructionHandle object is wrapped\n+ * around all instructions, i.e., it implements a cell in a\n+ * doubly-linked list. From the outside only the next and the\n+ * previous instruction (handle) are accessible. One\n+ * can traverse the list via an Enumeration returned by\n+ * InstructionList.elements().\n@@ -45,0 +49,10 @@\n+    private InstructionHandle next;\n+    private InstructionHandle prev;\n+    private Instruction instruction;\n+\n+    private int i_position = -1; \/\/ byte code offset of instruction\n+\n+    private Set<InstructionTargeter> targeters;\n+    private Map<Object, Object> attributes;\n+\n+\n@@ -46,1 +60,1 @@\n-     * Empty array.\n+     * Does nothing.\n@@ -48,1 +62,1 @@\n-     * @since 6.6.0\n+     * @deprecated Does nothing as of 6.3.1.\n@@ -50,1 +64,18 @@\n-    public static final InstructionHandle[] EMPTY_ARRAY = {};\n+    @Deprecated\n+    protected void addHandle() {\n+        \/\/ noop\n+    }\n+\n+    public final InstructionHandle getNext() {\n+        return next;\n+    }\n+\n+\n+    public final InstructionHandle getPrev() {\n+        return prev;\n+    }\n+\n+\n+    public final Instruction getInstruction() {\n+        return instruction;\n+    }\n@@ -52,4 +83,0 @@\n-    \/**\n-     * Empty array.\n-     *\/\n-    static final InstructionTargeter[] EMPTY_INSTRUCTION_TARGETER_ARRAY = {};\n@@ -58,1 +85,2 @@\n-     * Factory method.\n+     * Replace current instruction contained in this handle.\n+     * Old instruction is disposed using Instruction.dispose().\n@@ -60,2 +88,11 @@\n-    static InstructionHandle getInstructionHandle(final Instruction i) {\n-        return new InstructionHandle(i);\n+    public void setInstruction( final Instruction i ) { \/\/ Overridden in BranchHandle TODO could be package-protected?\n+        if (i == null) {\n+            throw new ClassGenException(\"Assigning null to handle\");\n+        }\n+        if ((this.getClass() != BranchHandle.class) && (i instanceof BranchInstruction)) {\n+            throw new ClassGenException(\"Assigning branch instruction \" + i + \" to plain handle\");\n+        }\n+        if (instruction != null) {\n+            instruction.dispose();\n+        }\n+        instruction = i;\n@@ -64,4 +101,0 @@\n-    private InstructionHandle next;\n-    private InstructionHandle prev;\n-\n-    private Instruction instruction;\n@@ -70,1 +103,7 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n+     * Temporarily swap the current instruction, without disturbing\n+     * anything. Meant to be used by a debugger, implementing\n+     * breakpoints. Current instruction is returned.\n+     * <p>\n+     * Warning: if this is used on a BranchHandle then some methods such as\n+     * getPosition() will still refer to the original cached instruction, whereas\n+     * other BH methods may affect the cache and the replacement instruction.\n@@ -72,3 +111,7 @@\n-    @Deprecated\n-    protected int i_position = -1; \/\/ byte code offset of instruction\n-    private Set<InstructionTargeter> targeters;\n+    \/\/ See BCEL-273\n+    \/\/ TODO remove this method in any redesign of BCEL\n+    public Instruction swapInstruction( final Instruction i ) {\n+        final Instruction oldInstruction = instruction;\n+        instruction = i;\n+        return oldInstruction;\n+    }\n@@ -76,1 +119,0 @@\n-    private Map<Object, Object> attributes;\n@@ -78,1 +120,1 @@\n-    protected InstructionHandle(final Instruction i) {\n+    \/*private*\/protected InstructionHandle(final Instruction i) {\n@@ -82,4 +124,1 @@\n-    \/**\n-     * Convenience method, simply calls accept() on the contained instruction.\n-     *\n-     * @param v Visitor object\n+    \/** Factory method.\n@@ -87,2 +126,2 @@\n-    public void accept(final Visitor v) {\n-        instruction.accept(v);\n+    static InstructionHandle getInstructionHandle( final Instruction i ) {\n+        return new InstructionHandle(i);\n@@ -91,0 +130,1 @@\n+\n@@ -92,1 +132,4 @@\n-     * Add an attribute to an instruction handle.\n+     * Called by InstructionList.setPositions when setting the position for every\n+     * instruction. In the presence of variable length instructions `setPositions()'\n+     * performs multiple passes over the instruction list to calculate the\n+     * correct (byte) positions and offsets by calling this function.\n@@ -94,2 +137,3 @@\n-     * @param key the key object to store\/retrieve the attribute\n-     * @param attr the attribute to associate with this handle\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n@@ -97,5 +141,3 @@\n-    public void addAttribute(final Object key, final Object attr) {\n-        if (attributes == null) {\n-            attributes = new HashMap<>(3);\n-        }\n-        attributes.put(key, attr);\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        i_position += offset;\n+        return 0;\n@@ -104,4 +146,4 @@\n-    \/**\n-     * Does nothing.\n-     *\n-     * @deprecated Does nothing as of 6.3.1.\n+\n+    \/** @return the position, i.e., the byte code offset of the contained\n+     * instruction. This is accurate only after\n+     * InstructionList.setPositions() has been called.\n@@ -109,3 +151,2 @@\n-    @Deprecated\n-    protected void addHandle() {\n-        \/\/ noop\n+    public int getPosition() {\n+        return i_position;\n@@ -114,2 +155,3 @@\n-    \/**\n-     * Denote this handle is being referenced by t.\n+\n+    \/** Set the position, i.e., the byte code offset of the contained\n+     * instruction.\n@@ -117,6 +159,2 @@\n-    public void addTargeter(final InstructionTargeter t) {\n-        if (targeters == null) {\n-            targeters = new HashSet<>();\n-        }\n-        \/\/ if(!targeters.contains(t))\n-        targeters.add(t);\n+    void setPosition( final int pos ) {\n+        i_position = pos;\n@@ -125,0 +163,1 @@\n+\n@@ -137,4 +176,2 @@\n-    \/**\n-     * Get attribute of an instruction handle.\n-     *\n-     * @param key the key object to store\/retrieve the attribute\n+\n+    \/** Remove all targeters, if any.\n@@ -142,3 +179,3 @@\n-    public Object getAttribute(final Object key) {\n-        if (attributes != null) {\n-            return attributes.get(key);\n+    public void removeAllTargeters() {\n+        if (targeters != null) {\n+            targeters.clear();\n@@ -146,1 +183,0 @@\n-        return null;\n@@ -149,0 +185,1 @@\n+\n@@ -150,1 +187,1 @@\n-     * @return all attributes associated with this handle\n+     * Denote this handle isn't referenced anymore by t.\n@@ -152,3 +189,3 @@\n-    public Collection<Object> getAttributes() {\n-        if (attributes == null) {\n-            attributes = new HashMap<>(3);\n+    public void removeTargeter( final InstructionTargeter t ) {\n+        if (targeters != null) {\n+            targeters.remove(t);\n@@ -156,5 +193,0 @@\n-        return attributes.values();\n-    }\n-\n-    public final Instruction getInstruction() {\n-        return instruction;\n@@ -163,3 +195,0 @@\n-    public final InstructionHandle getNext() {\n-        return next;\n-    }\n@@ -168,2 +197,1 @@\n-     * @return the position, i.e., the byte code offset of the contained instruction. This is accurate only after\n-     *         InstructionList.setPositions() has been called.\n+     * Denote this handle is being referenced by t.\n@@ -171,2 +199,6 @@\n-    public int getPosition() {\n-        return i_position;\n+    public void addTargeter( final InstructionTargeter t ) {\n+        if (targeters == null) {\n+            targeters = new HashSet<>();\n+        }\n+        \/\/if(!targeters.contains(t))\n+        targeters.add(t);\n@@ -175,2 +207,3 @@\n-    public final InstructionHandle getPrev() {\n-        return prev;\n+\n+    public boolean hasTargeters() {\n+        return (targeters != null) && (targeters.size() > 0);\n@@ -179,0 +212,1 @@\n+\n@@ -184,1 +218,1 @@\n-            return EMPTY_INSTRUCTION_TARGETER_ARRAY;\n+            return new InstructionTargeter[0];\n@@ -191,2 +225,5 @@\n-    public boolean hasTargeters() {\n-        return targeters != null && !targeters.isEmpty();\n+\n+    \/** @return a (verbose) string representation of the contained instruction.\n+     *\/\n+    public String toString( final boolean verbose ) {\n+        return Utility.format(i_position, 4, false, ' ') + \": \" + instruction.toString(verbose);\n@@ -195,2 +232,2 @@\n-    \/**\n-     * Remove all targeters, if any.\n+\n+    \/** @return a string representation of the contained instruction.\n@@ -198,3 +235,14 @@\n-    public void removeAllTargeters() {\n-        if (targeters != null) {\n-            targeters.clear();\n+    @Override\n+    public String toString() {\n+        return toString(true);\n+    }\n+\n+\n+    \/** Add an attribute to an instruction handle.\n+     *\n+     * @param key the key object to store\/retrieve the attribute\n+     * @param attr the attribute to associate with this handle\n+     *\/\n+    public void addAttribute( final Object key, final Object attr ) {\n+        if (attributes == null) {\n+            attributes = new HashMap<>(3);\n@@ -202,0 +250,1 @@\n+        attributes.put(key, attr);\n@@ -204,2 +253,2 @@\n-    \/**\n-     * Delete an attribute of an instruction handle.\n+\n+    \/** Delete an attribute of an instruction handle.\n@@ -209,1 +258,1 @@\n-    public void removeAttribute(final Object key) {\n+    public void removeAttribute( final Object key ) {\n@@ -215,2 +264,4 @@\n-    \/**\n-     * Denote this handle isn't referenced anymore by t.\n+\n+    \/** Get attribute of an instruction handle.\n+     *\n+     * @param key the key object to store\/retrieve the attribute\n@@ -218,3 +269,3 @@\n-    public void removeTargeter(final InstructionTargeter t) {\n-        if (targeters != null) {\n-            targeters.remove(t);\n+    public Object getAttribute( final Object key ) {\n+        if (attributes != null) {\n+            return attributes.get(key);\n@@ -222,0 +273,1 @@\n+        return null;\n@@ -224,2 +276,2 @@\n-    \/**\n-     * Replace current instruction contained in this handle. Old instruction is disposed using Instruction.dispose().\n+\n+    \/** @return all attributes associated with this handle\n@@ -227,9 +279,3 @@\n-    public void setInstruction(final Instruction i) { \/\/ Overridden in BranchHandle TODO could be package-protected?\n-        if (i == null) {\n-            throw new ClassGenException(\"Assigning null to handle\");\n-        }\n-        if (this.getClass() != BranchHandle.class && i instanceof BranchInstruction) {\n-            throw new ClassGenException(\"Assigning branch instruction \" + i + \" to plain handle\");\n-        }\n-        if (instruction != null) {\n-            instruction.dispose();\n+    public Collection<Object> getAttributes() {\n+        if (attributes == null) {\n+            attributes = new HashMap<>(3);\n@@ -237,1 +283,10 @@\n-        instruction = i;\n+        return attributes.values();\n+    }\n+\n+\n+    \/** Convenience method, simply calls accept() on the contained instruction.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    public void accept( final Visitor v ) {\n+        instruction.accept(v);\n@@ -240,0 +295,1 @@\n+\n@@ -249,6 +305,0 @@\n-    \/**\n-     * Set the position, i.e., the byte code offset of the contained instruction.\n-     *\/\n-    void setPosition(final int pos) {\n-        i_position = pos;\n-    }\n@@ -264,44 +314,0 @@\n-\n-    \/**\n-     * Temporarily swap the current instruction, without disturbing anything. Meant to be used by a debugger, implementing\n-     * breakpoints. Current instruction is returned.\n-     * <p>\n-     * Warning: if this is used on a BranchHandle then some methods such as getPosition() will still refer to the original\n-     * cached instruction, whereas other BH methods may affect the cache and the replacement instruction.\n-     *\/\n-    \/\/ See BCEL-273\n-    \/\/ TODO remove this method in any redesign of BCEL\n-    public Instruction swapInstruction(final Instruction i) {\n-        final Instruction oldInstruction = instruction;\n-        instruction = i;\n-        return oldInstruction;\n-    }\n-\n-    \/**\n-     * @return a string representation of the contained instruction.\n-     *\/\n-    @Override\n-    public String toString() {\n-        return toString(true);\n-    }\n-\n-    \/**\n-     * @return a (verbose) string representation of the contained instruction.\n-     *\/\n-    public String toString(final boolean verbose) {\n-        return Utility.format(i_position, 4, false, ' ') + \": \" + instruction.toString(verbose);\n-    }\n-\n-    \/**\n-     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n-     * length instructions 'setPositions()' performs multiple passes over the instruction list to calculate the correct\n-     * (byte) positions and offsets by calling this function.\n-     *\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n-     *\/\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        i_position += offset;\n-        return 0;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionHandle.java","additions":164,"deletions":158,"binary":false,"changes":322,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,0 +22,3 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.classfile.Constant;\n+import com.sun.org.apache.bcel.internal.util.ByteSequence;\n@@ -26,1 +29,0 @@\n-import java.util.Arrays;\n@@ -33,4 +35,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.classfile.Constant;\n-import com.sun.org.apache.bcel.internal.util.ByteSequence;\n-\n@@ -38,1 +36,2 @@\n- * This class is a container for a list of <a href=\"Instruction.html\">Instruction<\/a> objects. Instructions can be\n+ * This class is a container for a list of <a\n+ * href=\"Instruction.html\">Instruction<\/a> objects. Instructions can be\n@@ -40,3 +39,4 @@\n- * <a href=\"InstructionHandle.html\">InstructionHandles<\/a> objects that are returned upon append\/insert operations. They\n- * give the user (read only) access to the list structure, such that it can be traversed and manipulated in a controlled\n- * way.\n+ * <a href=\"InstructionHandle.html\">InstructionHandles<\/a> objects that are\n+ * returned upon append\/insert operations. They give the user (read only) access\n+ * to the list structure, such that it can be traversed and manipulated in a\n+ * controlled way.\n@@ -44,1 +44,2 @@\n- * A list is finally dumped to a byte code array with <a href=\"#getByteCode()\">getByteCode<\/a>.\n+ * A list is finally dumped to a byte code array with <a\n+ * href=\"#getByteCode()\">getByteCode<\/a>.\n@@ -49,1 +50,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -53,0 +54,49 @@\n+    private InstructionHandle start = null;\n+    private InstructionHandle end = null;\n+    private int length = 0; \/\/ number of elements in list\n+    private int[] bytePositions; \/\/ byte code offsets corresponding to instructions\n+\n+    \/**\n+     * Create (empty) instruction list.\n+     *\/\n+    public InstructionList() {\n+    }\n+\n+    \/**\n+     * Create instruction list containing one instruction.\n+     *\n+     * @param i\n+     *            initial instruction\n+     *\/\n+    public InstructionList(final Instruction i) {\n+        append(i);\n+    }\n+\n+    \/**\n+     * Create instruction list containing one instruction.\n+     *\n+     * @param i\n+     *            initial instruction\n+     *\/\n+    public InstructionList(final BranchInstruction i) {\n+        append(i);\n+    }\n+\n+    \/**\n+     * Initialize list with (nonnull) compound instruction. Consumes argument\n+     * list, i.e., it becomes empty.\n+     *\n+     * @param c\n+     *            compound instruction (list)\n+     *\/\n+    public InstructionList(final CompoundInstruction c) {\n+        append(c.getInstructionList());\n+    }\n+\n+    \/**\n+     * Test for empty list.\n+     *\/\n+    public boolean isEmpty() {\n+        return start == null;\n+    } \/\/ && end == null\n+\n@@ -54,1 +104,2 @@\n-     * Find the target instruction (handle) that corresponds to the given target position (byte code offset).\n+     * Find the target instruction (handle) that corresponds to the given target\n+     * position (byte code offset).\n@@ -56,4 +107,8 @@\n-     * @param ihs array of instruction handles, i.e. il.getInstructionHandles()\n-     * @param pos array of positions corresponding to ihs, i.e. il.getInstructionPositions()\n-     * @param count length of arrays\n-     * @param target target position to search for\n+     * @param ihs\n+     *            array of instruction handles, i.e. il.getInstructionHandles()\n+     * @param pos\n+     *            array of positions corresponding to ihs, i.e. il.getInstructionPositions()\n+     * @param count\n+     *            length of arrays\n+     * @param target\n+     *            target position to search for\n@@ -62,1 +117,2 @@\n-    public static InstructionHandle findHandle(final InstructionHandle[] ihs, final int[] pos, final int count, final int target) {\n+    public static InstructionHandle findHandle(final InstructionHandle[] ihs,\n+            final int[] pos, final int count, final int target) {\n@@ -69,1 +125,1 @@\n-            final int i = l + r >>> 1;\n+            final int i = (l + r) >>> 1;\n@@ -73,2 +129,1 @@\n-            }\n-            if (target < j) {\n+            } else if (target < j) {\n@@ -83,14 +138,0 @@\n-    private InstructionHandle start;\n-    private InstructionHandle end;\n-    private int length; \/\/ number of elements in list\n-\n-    private int[] bytePositions; \/\/ byte code offsets corresponding to instructions\n-\n-    private List<InstructionListObserver> observers;\n-\n-    \/**\n-     * Create (empty) instruction list.\n-     *\/\n-    public InstructionList() {\n-    }\n-\n@@ -98,1 +139,3 @@\n-     * Create instruction list containing one instruction.\n+     * Get instruction handle for instruction at byte code position pos. This\n+     * only works properly, if the list is freshly initialized from a byte array\n+     * or setPositions() has been called before this method.\n@@ -100,1 +143,3 @@\n-     * @param i initial instruction\n+     * @param pos\n+     *            byte code position to search for\n+     * @return target position's instruction handle if available\n@@ -102,2 +147,10 @@\n-    public InstructionList(final BranchInstruction i) {\n-        append(i);\n+    public InstructionHandle findHandle(final int pos) {\n+        final int[] positions = bytePositions;\n+        InstructionHandle ih = start;\n+        for (int i = 0; i < length; i++) {\n+            if (positions[i] == pos) {\n+                return ih;\n+            }\n+            ih = ih.getNext();\n+        }\n+        return null;\n@@ -109,1 +162,2 @@\n-     * @param code byte array containing the instructions\n+     * @param code\n+     *            byte array containing the instructions\n@@ -142,1 +196,2 @@\n-        bytePositions = Arrays.copyOf(pos, count); \/\/ Trim to proper size\n+        bytePositions = new int[count]; \/\/ Trim to proper size\n+        System.arraycopy(pos, 0, bytePositions, 0, count);\n@@ -149,3 +204,4 @@\n-                int target = bi.getPosition() + bi.getIndex(); \/*\n-                                                                * Byte code position: relative -> absolute.\n-                                                                *\/\n+                int target = bi.getPosition() + bi.getIndex();\n+                \/*\n+                 * Byte code position: relative -> absolute.\n+                 *\/\n@@ -176,1 +232,2 @@\n-     * Initialize list with (nonnull) compound instruction. Consumes argument list, i.e., it becomes empty.\n+     * Append another list after instruction (handle) ih contained in this list.\n+     * Consumes argument list, i.e., it becomes empty.\n@@ -178,1 +235,5 @@\n-     * @param c compound instruction (list)\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to append to this one\n+     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n@@ -180,2 +241,20 @@\n-    public InstructionList(final CompoundInstruction c) {\n-        append(c.getInstructionList());\n+    public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {\n+        if (il == null) {\n+            throw new ClassGenException(\"Appending null InstructionList\");\n+        }\n+        if (il.isEmpty()) {\n+            return ih;\n+        }\n+        final InstructionHandle next = ih.getNext();\n+        final InstructionHandle ret = il.start;\n+        ih.setNext(il.start);\n+        il.start.setPrev(ih);\n+        il.end.setNext(next);\n+        if (next != null) {\n+            next.setPrev(il.end);\n+        } else {\n+            end = il.end; \/\/ Update end ...\n+        }\n+        length += il.length; \/\/ Update length\n+        il.clear();\n+        return ret;\n@@ -185,1 +264,2 @@\n-     * Create instruction list containing one instruction.\n+     * Append another list after instruction i contained in this list. Consumes\n+     * argument list, i.e., it becomes empty.\n@@ -187,8 +267,5 @@\n-     * @param i initial instruction\n-     *\/\n-    public InstructionList(final Instruction i) {\n-        append(i);\n-    }\n-\n-    \/**\n-     * Add observer for this object.\n+     * @param i\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to append to this one\n+     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n@@ -196,3 +273,4 @@\n-    public void addObserver(final InstructionListObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n+    public InstructionHandle append(final Instruction i, final InstructionList il) {\n+        InstructionHandle ih;\n+        if ((ih = findInstruction2(i)) == null) {\n+            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n@@ -200,1 +278,1 @@\n-        observers.add(o);\n+        return append(ih, il);\n@@ -204,1 +282,2 @@\n-     * Append a branch instruction to the end of this list.\n+     * Append another list to this one. Consumes argument list, i.e., it becomes\n+     * empty.\n@@ -206,2 +285,3 @@\n-     * @param i branch instruction to append\n-     * @return branch instruction handle of the appended instruction\n+     * @param il\n+     *            list to append to end of this list\n+     * @return instruction handle of the <B>first<\/B> appended instruction\n@@ -209,4 +289,15 @@\n-    public BranchHandle append(final BranchInstruction i) {\n-        final BranchHandle ih = BranchHandle.getBranchHandle(i);\n-        append(ih);\n-        return ih;\n+    public InstructionHandle append(final InstructionList il) {\n+        if (il == null) {\n+            throw new ClassGenException(\"Appending null InstructionList\");\n+        }\n+        if (il.isEmpty()) {\n+            return null;\n+        }\n+        if (isEmpty()) {\n+            start = il.start;\n+            end = il.end;\n+            length = il.length;\n+            il.clear();\n+            return start;\n+        }\n+        return append(end, il); \/\/ was end.instruction\n@@ -216,1 +307,1 @@\n-     * Append a compound instruction.\n+     * Append an instruction to the end of this list.\n@@ -218,2 +309,2 @@\n-     * @param c The composite instruction (containing an InstructionList)\n-     * @return instruction handle of the first appended instruction\n+     * @param ih\n+     *            instruction to append\n@@ -221,2 +312,11 @@\n-    public InstructionHandle append(final CompoundInstruction c) {\n-        return append(c.getInstructionList());\n+    private void append(final InstructionHandle ih) {\n+        if (isEmpty()) {\n+            start = end = ih;\n+            ih.setNext(ih.setPrev(null));\n+        } else {\n+            end.setNext(ih);\n+            ih.setPrev(end);\n+            ih.setNext(null);\n+            end = ih;\n+        }\n+        length++; \/\/ Update length\n@@ -228,1 +328,2 @@\n-     * @param i instruction to append\n+     * @param i\n+     *            instruction to append\n@@ -238,1 +339,1 @@\n-     * Append a compound instruction, after instruction i.\n+     * Append a branch instruction to the end of this list.\n@@ -240,3 +341,3 @@\n-     * @param i Instruction in list\n-     * @param c The composite instruction (containing an InstructionList)\n-     * @return instruction handle of the first appended instruction\n+     * @param i\n+     *            branch instruction to append\n+     * @return branch instruction handle of the appended instruction\n@@ -244,2 +345,4 @@\n-    public InstructionHandle append(final Instruction i, final CompoundInstruction c) {\n-        return append(i, c.getInstructionList());\n+    public BranchHandle append(final BranchInstruction i) {\n+        final BranchHandle ih = BranchHandle.getBranchHandle(i);\n+        append(ih);\n+        return ih;\n@@ -249,1 +352,2 @@\n-     * Append a single instruction j after another instruction i, which must be in this list of course!\n+     * Append a single instruction j after another instruction i, which must be\n+     * in this list of course!\n@@ -251,2 +355,4 @@\n-     * @param i Instruction in list\n-     * @param j Instruction to append after i in list\n+     * @param i\n+     *            Instruction in list\n+     * @param j\n+     *            Instruction to append after i in list\n@@ -260,16 +366,1 @@\n-     * Append another list after instruction i contained in this list. Consumes argument list, i.e., it becomes empty.\n-     *\n-     * @param i where to append the instruction list\n-     * @param il Instruction list to append to this one\n-     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n-     *\/\n-    public InstructionHandle append(final Instruction i, final InstructionList il) {\n-        InstructionHandle ih;\n-        if ((ih = findInstruction2(i)) == null) {\n-            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n-        }\n-        return append(ih, il);\n-    }\n-\n-    \/**\n-     * Append an instruction to the end of this list.\n+     * Append a compound instruction, after instruction i.\n@@ -277,1 +368,5 @@\n-     * @param ih instruction to append\n+     * @param i\n+     *            Instruction in list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n+     * @return instruction handle of the first appended instruction\n@@ -279,11 +374,2 @@\n-    private void append(final InstructionHandle ih) {\n-        if (isEmpty()) {\n-            start = end = ih;\n-            ih.setNext(ih.setPrev(null));\n-        } else {\n-            end.setNext(ih);\n-            ih.setPrev(end);\n-            ih.setNext(null);\n-            end = ih;\n-        }\n-        length++; \/\/ Update length\n+    public InstructionHandle append(final Instruction i, final CompoundInstruction c) {\n+        return append(i, c.getInstructionList());\n@@ -293,1 +379,1 @@\n-     * Append an instruction after instruction (handle) ih contained in this list.\n+     * Append a compound instruction.\n@@ -295,3 +381,3 @@\n-     * @param ih where to append the instruction list\n-     * @param i Instruction to append\n-     * @return instruction handle pointing to the <B>first<\/B> appended instruction\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n+     * @return instruction handle of the first appended instruction\n@@ -299,6 +385,2 @@\n-    public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {\n-        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n-        final InstructionList il = new InstructionList();\n-        il.append(bh);\n-        append(ih, il);\n-        return bh;\n+    public InstructionHandle append(final CompoundInstruction c) {\n+        return append(c.getInstructionList());\n@@ -310,2 +392,4 @@\n-     * @param ih where to append the instruction list\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -321,2 +405,4 @@\n-     * @param ih where to append the instruction list\n-     * @param i Instruction to append\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param i\n+     *            Instruction to append\n@@ -330,2 +416,1 @@\n-     * Append another list after instruction (handle) ih contained in this list. Consumes argument list, i.e., it becomes\n-     * empty.\n+     * Append an instruction after instruction (handle) ih contained in this list.\n@@ -333,2 +418,4 @@\n-     * @param ih where to append the instruction list\n-     * @param il Instruction list to append to this one\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param i\n+     *            Instruction to append\n@@ -337,1 +424,19 @@\n-    public InstructionHandle append(final InstructionHandle ih, final InstructionList il) {\n+    public BranchHandle append(final InstructionHandle ih, final BranchInstruction i) {\n+        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n+        final InstructionList il = new InstructionList();\n+        il.append(bh);\n+        append(ih, il);\n+        return bh;\n+    }\n+\n+    \/**\n+     * Insert another list before Instruction handle ih contained in this list.\n+     * Consumes argument list, i.e., it becomes empty.\n+     *\n+     * @param ih\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to insert\n+     * @return instruction handle of the first inserted instruction\n+     *\/\n+    public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {\n@@ -339,1 +444,1 @@\n-            throw new ClassGenException(\"Appending null InstructionList\");\n+            throw new ClassGenException(\"Inserting null InstructionList\");\n@@ -344,1 +449,1 @@\n-        final InstructionHandle next = ih.getNext();\n+        final InstructionHandle prev = ih.getPrev();\n@@ -346,5 +451,5 @@\n-        ih.setNext(il.start);\n-        il.start.setPrev(ih);\n-        il.end.setNext(next);\n-        if (next != null) {\n-            next.setPrev(il.end);\n+        ih.setPrev(il.end);\n+        il.end.setNext(ih);\n+        il.start.setPrev(prev);\n+        if (prev != null) {\n+            prev.setNext(il.start);\n@@ -352,1 +457,1 @@\n-            end = il.end; \/\/ Update end ...\n+            start = il.start; \/\/ Update start ...\n@@ -360,1 +465,1 @@\n-     * Append another list to this one. Consumes argument list, i.e., it becomes empty.\n+     * Insert another list.\n@@ -362,2 +467,3 @@\n-     * @param il list to append to end of this list\n-     * @return instruction handle of the <B>first<\/B> appended instruction\n+     * @param il\n+     *            list to insert before start of this list\n+     * @return instruction handle of the first inserted instruction\n@@ -365,7 +471,1 @@\n-    public InstructionHandle append(final InstructionList il) {\n-        if (il == null) {\n-            throw new ClassGenException(\"Appending null InstructionList\");\n-        }\n-        if (il.isEmpty()) {\n-            return null;\n-        }\n+    public InstructionHandle insert(final InstructionList il) {\n@@ -373,4 +473,1 @@\n-            start = il.start;\n-            end = il.end;\n-            length = il.length;\n-            il.clear();\n+            append(il); \/\/ Code is identical for this case\n@@ -379,22 +476,1 @@\n-        return append(end, il); \/\/ was end.instruction\n-    }\n-\n-    private void clear() {\n-        start = end = null;\n-        length = 0;\n-    }\n-\n-    public boolean contains(final Instruction i) {\n-        return findInstruction1(i) != null;\n-    }\n-\n-    public boolean contains(final InstructionHandle i) {\n-        if (i == null) {\n-            return false;\n-        }\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            if (ih == i) {\n-                return true;\n-            }\n-        }\n-        return false;\n+        return insert(start, il);\n@@ -404,1 +480,4 @@\n-     * @return complete, i.e., deep copy of this list\n+     * Insert an instruction at start of this list.\n+     *\n+     * @param ih\n+     *            instruction to insert\n@@ -406,40 +485,9 @@\n-    public InstructionList copy() {\n-        final Map<InstructionHandle, InstructionHandle> map = new HashMap<>();\n-        final InstructionList il = new InstructionList();\n-        \/*\n-         * Pass 1: Make copies of all instructions, append them to the new list and associate old instruction references with\n-         * the new ones, i.e., a 1:1 mapping.\n-         *\/\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            final Instruction c = i.copy(); \/\/ Use clone for shallow copy\n-            if (c instanceof BranchInstruction) {\n-                map.put(ih, il.append((BranchInstruction) c));\n-            } else {\n-                map.put(ih, il.append(c));\n-            }\n-        }\n-        \/*\n-         * Pass 2: Update branch targets.\n-         *\/\n-        InstructionHandle ih = start;\n-        InstructionHandle ch = il.start;\n-        while (ih != null) {\n-            final Instruction i = ih.getInstruction();\n-            final Instruction c = ch.getInstruction();\n-            if (i instanceof BranchInstruction) {\n-                final BranchInstruction bi = (BranchInstruction) i;\n-                final BranchInstruction bc = (BranchInstruction) c;\n-                final InstructionHandle itarget = bi.getTarget(); \/\/ old target\n-                \/\/ New target is in hash map\n-                bc.setTarget(map.get(itarget));\n-                if (bi instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n-                    final InstructionHandle[] itargets = ((Select) bi).getTargets();\n-                    final InstructionHandle[] ctargets = ((Select) bc).getTargets();\n-                    for (int j = 0; j < itargets.length; j++) { \/\/ Update all targets\n-                        ctargets[j] = map.get(itargets[j]);\n-                    }\n-                }\n-            }\n-            ih = ih.getNext();\n-            ch = ch.getNext();\n+    private void insert(final InstructionHandle ih) {\n+        if (isEmpty()) {\n+            start = end = ih;\n+            ih.setNext(ih.setPrev(null));\n+        } else {\n+            start.setPrev(ih);\n+            ih.setNext(start);\n+            ih.setPrev(null);\n+            start = ih;\n@@ -447,1 +495,1 @@\n-        return il;\n+        length++;\n@@ -451,1 +499,2 @@\n-     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n+     * Insert another list before Instruction i contained in this list. Consumes\n+     * argument list, i.e., it becomes empty.\n@@ -453,1 +502,5 @@\n-     * @param i instruction to remove\n+     * @param i\n+     *            where to append the instruction list\n+     * @param il\n+     *            Instruction list to insert\n+     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()\n@@ -455,1 +508,1 @@\n-    public void delete(final Instruction i) throws TargetLostException {\n+    public InstructionHandle insert(final Instruction i, final InstructionList il) {\n@@ -460,145 +513,1 @@\n-        delete(ih);\n-    }\n-\n-    \/**\n-     * Remove instructions from instruction 'from' to instruction 'to' contained in this list. The user must ensure that\n-     * 'from' is an instruction before 'to', or risk havoc. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param from where to start deleting (inclusive)\n-     * @param to where to end deleting (inclusive)\n-     *\/\n-    public void delete(final Instruction from, final Instruction to) throws TargetLostException {\n-        InstructionHandle fromIh;\n-        InstructionHandle toIh;\n-        if ((fromIh = findInstruction1(from)) == null) {\n-            throw new ClassGenException(\"Instruction \" + from + \" is not contained in this list.\");\n-        }\n-        if ((toIh = findInstruction2(to)) == null) {\n-            throw new ClassGenException(\"Instruction \" + to + \" is not contained in this list.\");\n-        }\n-        delete(fromIh, toIh);\n-    }\n-\n-    \/**\n-     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param ih instruction (handle) to remove\n-     *\/\n-    public void delete(final InstructionHandle ih) throws TargetLostException {\n-        remove(ih.getPrev(), ih.getNext());\n-    }\n-\n-    \/**\n-     * Remove instructions from instruction 'from' to instruction 'to' contained in this list. The user must ensure that\n-     * 'from' is an instruction before 'to', or risk havoc. The corresponding Instruction handles must not be reused!\n-     *\n-     * @param from where to start deleting (inclusive)\n-     * @param to where to end deleting (inclusive)\n-     *\/\n-    public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {\n-        remove(from.getPrev(), to.getNext());\n-    }\n-\n-    \/**\n-     * Delete contents of list. Provides better memory utilization, because the system then may reuse the instruction\n-     * handles. This method is typically called right after {@link MethodGen#getMethod()}.\n-     *\/\n-    public void dispose() {\n-        \/\/ Traverse in reverse order, because ih.next is overwritten\n-        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n-            \/\/ Causes BranchInstructions to release target and targeters, because it calls dispose() on the contained instruction.\n-            ih.dispose();\n-        }\n-        clear();\n-    }\n-\n-    \/**\n-     * Get instruction handle for instruction at byte code position pos. This only works properly, if the list is freshly\n-     * initialized from a byte array or setPositions() has been called before this method.\n-     *\n-     * @param pos byte code position to search for\n-     * @return target position's instruction handle if available\n-     *\/\n-    public InstructionHandle findHandle(final int pos) {\n-        final int[] positions = bytePositions;\n-        InstructionHandle ih = start;\n-        for (int i = 0; i < length; i++) {\n-            if (positions[i] == pos) {\n-                return ih;\n-            }\n-            ih = ih.getNext();\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Search for given Instruction reference, start at beginning of list.\n-     *\n-     * @param i instruction to search for\n-     * @return instruction found on success, null otherwise\n-     *\/\n-    private InstructionHandle findInstruction1(final Instruction i) {\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            if (ih.getInstruction() == i) {\n-                return ih;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * Search for given Instruction reference, start at end of list\n-     *\n-     * @param i instruction to search for\n-     * @return instruction found on success, null otherwise\n-     *\/\n-    private InstructionHandle findInstruction2(final Instruction i) {\n-        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n-            if (ih.getInstruction() == i) {\n-                return ih;\n-            }\n-        }\n-        return null;\n-    }\n-\n-    \/**\n-     * When everything is finished, use this method to convert the instruction list into an array of bytes.\n-     *\n-     * @return the byte code ready to be dumped\n-     *\/\n-    public byte[] getByteCode() {\n-        \/\/ Update position indices of instructions\n-        setPositions();\n-        final ByteArrayOutputStream b = new ByteArrayOutputStream();\n-        final DataOutputStream out = new DataOutputStream(b);\n-        try {\n-            for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-                final Instruction i = ih.getInstruction();\n-                i.dump(out); \/\/ Traverse list\n-            }\n-            out.flush();\n-        } catch (final IOException e) {\n-            System.err.println(e);\n-            return Const.EMPTY_BYTE_ARRAY;\n-        }\n-        return b.toByteArray();\n-    }\n-\n-    \/**\n-     * @return end of list\n-     *\/\n-    public InstructionHandle getEnd() {\n-        return end;\n-    }\n-\n-    \/**\n-     * @return array containing all instructions (handles)\n-     *\/\n-    public InstructionHandle[] getInstructionHandles() {\n-        final InstructionHandle[] ihs = new InstructionHandle[length];\n-        InstructionHandle ih = start;\n-        for (int i = 0; i < length; i++) {\n-            ihs[i] = ih;\n-            ih = ih.getNext();\n-        }\n-        return ihs;\n+        return insert(ih, il);\n@@ -608,2 +517,1 @@\n-     * Get positions (offsets) of all instructions in the list. This relies on that the list has been freshly created from\n-     * an byte code array, or that setPositions() has been called. Otherwise this may be inaccurate.\n+     * Insert an instruction at start of this list.\n@@ -611,30 +519,3 @@\n-     * @return array containing all instruction's offset in byte code\n-     *\/\n-    public int[] getInstructionPositions() {\n-        return bytePositions;\n-    }\n-\n-    \/**\n-     * @return an array of instructions without target information for branch instructions.\n-     *\/\n-    public Instruction[] getInstructions() {\n-        final List<Instruction> instructions = new ArrayList<>();\n-        try (ByteSequence bytes = new ByteSequence(getByteCode())) {\n-            while (bytes.available() > 0) {\n-                instructions.add(Instruction.readInstruction(bytes));\n-            }\n-        } catch (final IOException e) {\n-            throw new ClassGenException(e.toString(), e);\n-        }\n-        return instructions.toArray(Instruction.EMPTY_ARRAY);\n-    }\n-\n-    \/**\n-     * @return length of list (Number of instructions, not bytes)\n-     *\/\n-    public int getLength() {\n-        return length;\n-    }\n-\n-    \/**\n-     * @return start of list\n+     * @param i\n+     *            instruction to insert\n+     * @return instruction handle of the inserted instruction\n@@ -642,2 +523,4 @@\n-    public InstructionHandle getStart() {\n-        return start;\n+    public InstructionHandle insert(final Instruction i) {\n+        final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n+        insert(ih);\n+        return ih;\n@@ -649,1 +532,2 @@\n-     * @param i branch instruction to insert\n+     * @param i\n+     *            branch instruction to insert\n@@ -659,1 +543,2 @@\n-     * Insert a compound instruction.\n+     * Insert a single instruction j before another instruction i, which must be\n+     * in this list of course!\n@@ -661,1 +546,4 @@\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param i\n+     *            Instruction in list\n+     * @param j\n+     *            Instruction to insert before i in list\n@@ -664,14 +552,2 @@\n-    public InstructionHandle insert(final CompoundInstruction c) {\n-        return insert(c.getInstructionList());\n-    }\n-\n-    \/**\n-     * Insert an instruction at start of this list.\n-     *\n-     * @param i instruction to insert\n-     * @return instruction handle of the inserted instruction\n-     *\/\n-    public InstructionHandle insert(final Instruction i) {\n-        final InstructionHandle ih = InstructionHandle.getInstructionHandle(i);\n-        insert(ih);\n-        return ih;\n+    public InstructionHandle insert(final Instruction i, final Instruction j) {\n+        return insert(i, new InstructionList(j));\n@@ -683,2 +559,4 @@\n-     * @param i Instruction in list\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param i\n+     *            Instruction in list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -692,1 +570,1 @@\n-     * Insert a single instruction j before another instruction i, which must be in this list of course!\n+     * Insert a compound instruction.\n@@ -694,2 +572,2 @@\n-     * @param i Instruction in list\n-     * @param j Instruction to insert before i in list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -698,35 +576,2 @@\n-    public InstructionHandle insert(final Instruction i, final Instruction j) {\n-        return insert(i, new InstructionList(j));\n-    }\n-\n-    \/**\n-     * Insert another list before Instruction i contained in this list. Consumes argument list, i.e., it becomes empty.\n-     *\n-     * @param i where to append the instruction list\n-     * @param il Instruction list to insert\n-     * @return instruction handle pointing to the first inserted instruction, i.e., il.getStart()\n-     *\/\n-    public InstructionHandle insert(final Instruction i, final InstructionList il) {\n-        InstructionHandle ih;\n-        if ((ih = findInstruction1(i)) == null) {\n-            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n-        }\n-        return insert(ih, il);\n-    }\n-\n-    \/**\n-     * Insert an instruction at start of this list.\n-     *\n-     * @param ih instruction to insert\n-     *\/\n-    private void insert(final InstructionHandle ih) {\n-        if (isEmpty()) {\n-            start = end = ih;\n-            ih.setNext(ih.setPrev(null));\n-        } else {\n-            start.setPrev(ih);\n-            ih.setNext(start);\n-            ih.setPrev(null);\n-            start = ih;\n-        }\n-        length++;\n+    public InstructionHandle insert(final CompoundInstruction c) {\n+        return insert(c.getInstructionList());\n@@ -738,2 +583,4 @@\n-     * @param ih where to insert to the instruction list\n-     * @param i Instruction to insert\n+     * @param ih\n+     *            where to insert to the instruction list\n+     * @param i\n+     *            Instruction to insert\n@@ -742,6 +589,2 @@\n-    public BranchHandle insert(final InstructionHandle ih, final BranchInstruction i) {\n-        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n-        final InstructionList il = new InstructionList();\n-        il.append(bh);\n-        insert(ih, il);\n-        return bh;\n+    public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {\n+        return insert(ih, new InstructionList(i));\n@@ -753,2 +596,4 @@\n-     * @param ih where to insert the instruction list\n-     * @param c The composite instruction (containing an InstructionList)\n+     * @param ih\n+     *            where to insert the instruction list\n+     * @param c\n+     *            The composite instruction (containing an InstructionList)\n@@ -764,42 +609,4 @@\n-     * @param ih where to insert to the instruction list\n-     * @param i Instruction to insert\n-     * @return instruction handle of the first inserted instruction\n-     *\/\n-    public InstructionHandle insert(final InstructionHandle ih, final Instruction i) {\n-        return insert(ih, new InstructionList(i));\n-    }\n-\n-    \/**\n-     * Insert another list before Instruction handle ih contained in this list. Consumes argument list, i.e., it becomes\n-     * empty.\n-     *\n-     * @param ih where to append the instruction list\n-     * @param il Instruction list to insert\n-     * @return instruction handle of the first inserted instruction\n-     *\/\n-    public InstructionHandle insert(final InstructionHandle ih, final InstructionList il) {\n-        if (il == null) {\n-            throw new ClassGenException(\"Inserting null InstructionList\");\n-        }\n-        if (il.isEmpty()) {\n-            return ih;\n-        }\n-        final InstructionHandle prev = ih.getPrev();\n-        final InstructionHandle ret = il.start;\n-        ih.setPrev(il.end);\n-        il.end.setNext(ih);\n-        il.start.setPrev(prev);\n-        if (prev != null) {\n-            prev.setNext(il.start);\n-        } else {\n-            start = il.start; \/\/ Update start ...\n-        }\n-        length += il.length; \/\/ Update length\n-        il.clear();\n-        return ret;\n-    }\n-\n-    \/**\n-     * Insert another list.\n-     *\n-     * @param il list to insert before start of this list\n+     * @param ih\n+     *            where to insert to the instruction list\n+     * @param i\n+     *            Instruction to insert\n@@ -808,54 +615,6 @@\n-    public InstructionHandle insert(final InstructionList il) {\n-        if (isEmpty()) {\n-            append(il); \/\/ Code is identical for this case\n-            return start;\n-        }\n-        return insert(start, il);\n-    }\n-\n-    \/**\n-     * Test for empty list.\n-     *\/\n-    public boolean isEmpty() {\n-        return start == null;\n-    } \/\/ && end == null\n-\n-    \/**\n-     * @return iterator that lists all instructions (handles)\n-     *\/\n-    @Override\n-    public Iterator<InstructionHandle> iterator() {\n-        return new Iterator<InstructionHandle>() {\n-\n-            private InstructionHandle ih = start;\n-\n-            @Override\n-            public boolean hasNext() {\n-                return ih != null;\n-            }\n-\n-            @Override\n-            public InstructionHandle next() throws NoSuchElementException {\n-                if (ih == null) {\n-                    throw new NoSuchElementException();\n-                }\n-                final InstructionHandle i = ih;\n-                ih = ih.getNext();\n-                return i;\n-            }\n-\n-            @Override\n-            public void remove() {\n-                throw new UnsupportedOperationException();\n-            }\n-        };\n-    }\n-\n-    \/**\n-     * Move a single instruction (handle) to a new location.\n-     *\n-     * @param ih moved instruction\n-     * @param target new location of moved instruction\n-     *\/\n-    public void move(final InstructionHandle ih, final InstructionHandle target) {\n-        move(ih, ih, target);\n+    public BranchHandle insert(final InstructionHandle ih, final BranchInstruction i) {\n+        final BranchHandle bh = BranchHandle.getBranchHandle(i);\n+        final InstructionList il = new InstructionList();\n+        il.append(bh);\n+        insert(ih, il);\n+        return bh;\n@@ -865,3 +624,4 @@\n-     * Take all instructions (handles) from \"start\" to \"end\" and append them after the new location \"target\". Of course,\n-     * \"end\" must be after \"start\" and target must not be located withing this range. If you want to move something to the\n-     * start of the list use null as value for target.\n+     * Take all instructions (handles) from \"start\" to \"end\" and append them\n+     * after the new location \"target\". Of course, \"end\" must be after \"start\"\n+     * and target must not be located within this range. If you want to move\n+     * something to the start of the list use null as value for target.\n@@ -869,2 +629,2 @@\n-     * Any instruction targeters pointing to handles within the block, keep their targets.\n-     * <\/p>\n+     * Any instruction targeters pointing to handles within the block, keep\n+     * their targets.\n@@ -872,3 +632,6 @@\n-     * @param start of moved block\n-     * @param end of moved block\n-     * @param target of moved block\n+     * @param start\n+     *            of moved block\n+     * @param end\n+     *            of moved block\n+     * @param target\n+     *            of moved block\n@@ -878,1 +641,1 @@\n-        if (start == null || end == null) {\n+        if ((start == null) || (end == null)) {\n@@ -881,1 +644,1 @@\n-        if (target == start || target == end) {\n+        if ((target == start) || (target == end)) {\n@@ -887,2 +650,1 @@\n-            }\n-            if (ih == target) {\n+            } else if (ih == target) {\n@@ -927,50 +689,1 @@\n-     * Redirect all references from oldTarget to newTarget, i.e., update targets of branch instructions.\n-     *\n-     * @param oldTarget the old target instruction handle\n-     * @param newTarget the new target instruction handle\n-     *\/\n-    public void redirectBranches(final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n-        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n-            final Instruction i = ih.getInstruction();\n-            if (i instanceof BranchInstruction) {\n-                final BranchInstruction b = (BranchInstruction) i;\n-                final InstructionHandle target = b.getTarget();\n-                if (target == oldTarget) {\n-                    b.setTarget(newTarget);\n-                }\n-                if (b instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n-                    final InstructionHandle[] targets = ((Select) b).getTargets();\n-                    for (int j = 0; j < targets.length; j++) {\n-                        if (targets[j] == oldTarget) {\n-                            ((Select) b).setTarget(j, newTarget);\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Redirect all references of exception handlers from oldTarget to newTarget.\n-     *\n-     * @param exceptions array of exception handlers\n-     * @param oldTarget the old target instruction handle\n-     * @param newTarget the new target instruction handle\n-     * @see MethodGen\n-     *\/\n-    public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions, final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n-        for (final CodeExceptionGen exception : exceptions) {\n-            if (exception.getStartPC() == oldTarget) {\n-                exception.setStartPC(newTarget);\n-            }\n-            if (exception.getEndPC() == oldTarget) {\n-                exception.setEndPC(newTarget);\n-            }\n-            if (exception.getHandlerPC() == oldTarget) {\n-                exception.setHandlerPC(newTarget);\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Redirect all references of local variables from oldTarget to newTarget.\n+     * Move a single instruction (handle) to a new location.\n@@ -978,4 +691,4 @@\n-     * @param lg array of local variables\n-     * @param oldTarget the old target instruction handle\n-     * @param newTarget the new target instruction handle\n-     * @see MethodGen\n+     * @param ih\n+     *            moved instruction\n+     * @param target\n+     *            new location of moved instruction\n@@ -983,11 +696,2 @@\n-    public void redirectLocalVariables(final LocalVariableGen[] lg, final InstructionHandle oldTarget, final InstructionHandle newTarget) {\n-        for (final LocalVariableGen element : lg) {\n-            final InstructionHandle start = element.getStart();\n-            final InstructionHandle end = element.getEnd();\n-            if (start == oldTarget) {\n-                element.setStart(newTarget);\n-            }\n-            if (end == oldTarget) {\n-                element.setEnd(newTarget);\n-            }\n-        }\n+    public void move(final InstructionHandle ih, final InstructionHandle target) {\n+        move(ih, ih, target);\n@@ -997,2 +701,3 @@\n-     * Remove from instruction 'prev' to instruction 'next' both contained in this list. Throws TargetLostException when one\n-     * of the removed instruction handles is still being targeted.\n+     * Remove from instruction `prev' to instruction `next' both contained in\n+     * this list. Throws TargetLostException when one of the removed instruction\n+     * handles is still being targeted.\n@@ -1000,2 +705,4 @@\n-     * @param prev where to start deleting (predecessor, exclusive)\n-     * @param next where to end deleting (successor, exclusive)\n+     * @param prev\n+     *            where to start deleting (predecessor, exclusive)\n+     * @param next\n+     *            where to end deleting (successor, exclusive)\n@@ -1006,1 +713,1 @@\n-        if (prev == null && next == null) {\n+        if ((prev == null) && (next == null)) {\n@@ -1028,1 +735,1 @@\n-        final List<InstructionHandle> targetList = new ArrayList<>();\n+        final List<InstructionHandle> target_vec = new ArrayList<>();\n@@ -1037,1 +744,1 @@\n-                targetList.add(ih);\n+                target_vec.add(ih);\n@@ -1045,2 +752,4 @@\n-        if (!targetList.isEmpty()) {\n-            throw new TargetLostException(targetList.toArray(InstructionHandle.EMPTY_ARRAY), buf.toString());\n+        if (!target_vec.isEmpty()) {\n+            final InstructionHandle[] targeted = new InstructionHandle[target_vec.size()];\n+            target_vec.toArray(targeted);\n+            throw new TargetLostException(targeted, buf.toString());\n@@ -1051,1 +760,5 @@\n-     * Remove observer for this object.\n+     * Remove instruction from this list. The corresponding Instruction handles\n+     * must not be reused!\n+     *\n+     * @param ih\n+     *            instruction (handle) to remove\n@@ -1053,3 +766,66 @@\n-    public void removeObserver(final InstructionListObserver o) {\n-        if (observers != null) {\n-            observers.remove(o);\n+    public void delete(final InstructionHandle ih) throws TargetLostException {\n+        remove(ih.getPrev(), ih.getNext());\n+    }\n+\n+    \/**\n+     * Remove instruction from this list. The corresponding Instruction handles must not be reused!\n+     *\n+     * @param i\n+     *            instruction to remove\n+     *\/\n+    public void delete(final Instruction i) throws TargetLostException {\n+        InstructionHandle ih;\n+        if ((ih = findInstruction1(i)) == null) {\n+            throw new ClassGenException(\"Instruction \" + i + \" is not contained in this list.\");\n+        }\n+        delete(ih);\n+    }\n+\n+    \/**\n+     * Remove instructions from instruction `from' to instruction `to' contained\n+     * in this list. The user must ensure that `from' is an instruction before\n+     * `to', or risk havoc. The corresponding Instruction handles must not be\n+     * reused!\n+     *\n+     * @param from\n+     *            where to start deleting (inclusive)\n+     * @param to\n+     *            where to end deleting (inclusive)\n+     *\/\n+    public void delete(final InstructionHandle from, final InstructionHandle to) throws TargetLostException {\n+        remove(from.getPrev(), to.getNext());\n+    }\n+\n+    \/**\n+     * Remove instructions from instruction `from' to instruction `to' contained in this list. The user must ensure that `from' is an instruction before `to',\n+     * or risk havoc. The corresponding Instruction handles must not be reused!\n+     *\n+     * @param from\n+     *            where to start deleting (inclusive)\n+     * @param to\n+     *            where to end deleting (inclusive)\n+     *\/\n+    public void delete(final Instruction from, final Instruction to) throws TargetLostException {\n+        InstructionHandle from_ih;\n+        InstructionHandle to_ih;\n+        if ((from_ih = findInstruction1(from)) == null) {\n+            throw new ClassGenException(\"Instruction \" + from + \" is not contained in this list.\");\n+        }\n+        if ((to_ih = findInstruction2(to)) == null) {\n+            throw new ClassGenException(\"Instruction \" + to + \" is not contained in this list.\");\n+        }\n+        delete(from_ih, to_ih);\n+    }\n+\n+    \/**\n+     * Search for given Instruction reference, start at beginning of list.\n+     *\n+     * @param i\n+     *            instruction to search for\n+     * @return instruction found on success, null otherwise\n+     *\/\n+    private InstructionHandle findInstruction1(final Instruction i) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            if (ih.getInstruction() == i) {\n+                return ih;\n+            }\n@@ -1057,0 +833,1 @@\n+        return null;\n@@ -1060,1 +837,5 @@\n-     * Replace all references to the old constant pool with references to the new constant pool\n+     * Search for given Instruction reference, start at end of list\n+     *\n+     * @param i\n+     *            instruction to search for\n+     * @return instruction found on success, null otherwise\n@@ -1062,1 +843,13 @@\n-    public void replaceConstantPool(final ConstantPoolGen oldCp, final ConstantPoolGen newCp) {\n+    private InstructionHandle findInstruction2(final Instruction i) {\n+        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n+            if (ih.getInstruction() == i) {\n+                return ih;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public boolean contains(final InstructionHandle i) {\n+        if (i == null) {\n+            return false;\n+        }\n@@ -1064,5 +857,2 @@\n-            final Instruction i = ih.getInstruction();\n-            if (i instanceof CPInstruction) {\n-                final CPInstruction ci = (CPInstruction) i;\n-                final Constant c = oldCp.getConstant(ci.getIndex());\n-                ci.setIndex(newCp.addConstant(c, oldCp));\n+            if (ih == i) {\n+                return true;\n@@ -1071,0 +861,5 @@\n+        return false;\n+    }\n+\n+    public boolean contains(final Instruction i) {\n+        return findInstruction1(i) != null;\n@@ -1078,1 +873,2 @@\n-     * Give all instructions their position number (offset in byte stream), i.e., make the list ready to be dumped.\n+     * Give all instructions their position number (offset in byte stream),\n+     * i.e., make the list ready to be dumped.\n@@ -1080,1 +876,2 @@\n-     * @param check Perform sanity checks, e.g. if all targeted instructions really belong to this list\n+     * @param check\n+     *            Perform sanity checks, e.g. if all targeted instructions really belong to this list\n@@ -1083,2 +880,2 @@\n-        int maxAdditionalBytes = 0;\n-        int additionalBytes = 0;\n+        int max_additional_bytes = 0;\n+        int additional_bytes = 0;\n@@ -1097,1 +894,3 @@\n-                        throw new ClassGenException(\"Branch target of \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not in instruction list\");\n+                        throw new ClassGenException(\"Branch target of \"\n+                                + Const.getOpcodeName(i.getOpcode()) + \":\"\n+                                + inst + \" not in instruction list\");\n@@ -1104,1 +903,3 @@\n-                                throw new ClassGenException(\"Branch target of \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not in instruction list\");\n+                                throw new ClassGenException(\"Branch target of \"\n+                                        + Const.getOpcodeName(i.getOpcode()) + \":\"\n+                                        + inst + \" not in instruction list\");\n@@ -1110,1 +911,3 @@\n-                            \"Branch instruction \" + Const.getOpcodeName(i.getOpcode()) + \":\" + inst + \" not contained in BranchHandle.\");\n+                                \"Branch instruction \"\n+                                + Const.getOpcodeName(i.getOpcode()) + \":\"\n+                                + inst + \" not contained in BranchHandle.\");\n@@ -1123,2 +926,3 @@\n-             * Get an estimate about how many additional bytes may be added, because BranchInstructions may have variable length\n-             * depending on the target offset (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).\n+             * Get an estimate about how many additional bytes may be added,\n+             * because BranchInstructions may have variable length depending on the target offset\n+             * (short vs. int) or alignment issues (TABLESWITCH and LOOKUPSWITCH).\n@@ -1127,3 +931,3 @@\n-            case Const.JSR:\n-            case Const.GOTO:\n-                maxAdditionalBytes += 2;\n+                case Const.JSR:\n+                case Const.GOTO:\n+                    max_additional_bytes += 2;\n@@ -1131,3 +935,3 @@\n-            case Const.TABLESWITCH:\n-            case Const.LOOKUPSWITCH:\n-                maxAdditionalBytes += 3;\n+                case Const.TABLESWITCH:\n+                case Const.LOOKUPSWITCH:\n+                    max_additional_bytes += 3;\n@@ -1138,3 +942,4 @@\n-        \/*\n-         * Pass 2: Expand the variable-length (Branch)Instructions depending on the target offset (short or int) and ensure that\n-         * branch targets are within this list.\n+\n+        \/* Pass 2: Expand the variable-length (Branch)Instructions depending on\n+         * the target offset (short or int) and ensure that branch targets are\n+         * within this list.\n@@ -1143,1 +948,1 @@\n-            additionalBytes += ih.updatePosition(additionalBytes, maxAdditionalBytes);\n+            additional_bytes += ih.updatePosition(additional_bytes, max_additional_bytes);\n@@ -1146,1 +951,2 @@\n-         * Pass 3: Update position numbers (which may have changed due to the preceding expansions), like pass 1.\n+         * Pass 3: Update position numbers (which may have changed due to the\n+         * preceding expansions), like pass 1.\n@@ -1160,1 +966,4 @@\n-     * @return length of list (Number of instructions, not bytes)\n+     * When everything is finished, use this method to convert the instruction\n+     * list into an array of bytes.\n+     *\n+     * @return the byte code ready to be dumped\n@@ -1162,2 +971,32 @@\n-    public int size() {\n-        return length;\n+    public byte[] getByteCode() {\n+        \/\/ Update position indices of instructions\n+        setPositions();\n+        final ByteArrayOutputStream b = new ByteArrayOutputStream();\n+        final DataOutputStream out = new DataOutputStream(b);\n+        try {\n+            for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+                final Instruction i = ih.getInstruction();\n+                i.dump(out); \/\/ Traverse list\n+            }\n+            out.flush();\n+        } catch (final IOException e) {\n+            System.err.println(e);\n+            return new byte[0];\n+        }\n+        return b.toByteArray();\n+    }\n+\n+    \/**\n+     * @return an array of instructions without target information for branch\n+     * instructions.\n+     *\/\n+    public Instruction[] getInstructions() {\n+        final List<Instruction> instructions = new ArrayList<>();\n+        try (ByteSequence bytes = new ByteSequence(getByteCode())) {\n+            while (bytes.available() > 0) {\n+                instructions.add(Instruction.readInstruction(bytes));\n+            }\n+        } catch (final IOException e) {\n+            throw new ClassGenException(e.toString(), e);\n+        }\n+        return instructions.toArray(new Instruction[instructions.size()]);\n@@ -1172,1 +1011,2 @@\n-     * @param verbose toggle output format\n+     * @param verbose\n+     *            toggle output format\n@@ -1184,2 +1024,271 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after he has finished editing the object.\n+     * @return iterator that lists all instructions (handles)\n+     *\/\n+    @Override\n+    public Iterator<InstructionHandle> iterator() {\n+        return new Iterator<InstructionHandle>() {\n+\n+            private InstructionHandle ih = start;\n+\n+            @Override\n+            public InstructionHandle next() throws NoSuchElementException {\n+                if (ih == null) {\n+                    throw new NoSuchElementException();\n+                }\n+                final InstructionHandle i = ih;\n+                ih = ih.getNext();\n+                return i;\n+            }\n+\n+            @Override\n+            public void remove() {\n+                throw new UnsupportedOperationException();\n+            }\n+\n+            @Override\n+            public boolean hasNext() {\n+                return ih != null;\n+            }\n+        };\n+    }\n+\n+    \/**\n+     * @return array containing all instructions (handles)\n+     *\/\n+    public InstructionHandle[] getInstructionHandles() {\n+        final InstructionHandle[] ihs = new InstructionHandle[length];\n+        InstructionHandle ih = start;\n+        for (int i = 0; i < length; i++) {\n+            ihs[i] = ih;\n+            ih = ih.getNext();\n+        }\n+        return ihs;\n+    }\n+\n+    \/**\n+     * Get positions (offsets) of all instructions in the list. This relies on\n+     * that the list has been freshly created from an byte code array, or that\n+     * setPositions() has been called. Otherwise this may be inaccurate.\n+     *\n+     * @return array containing all instruction's offset in byte code\n+     *\/\n+    public int[] getInstructionPositions() {\n+        return bytePositions;\n+    }\n+\n+    \/**\n+     * @return complete, i.e., deep copy of this list\n+     *\/\n+    public InstructionList copy() {\n+        final Map<InstructionHandle, InstructionHandle> map = new HashMap<>();\n+        final InstructionList il = new InstructionList();\n+        \/*\n+         * Pass 1: Make copies of all instructions, append them to the new list\n+         * and associate old instruction references with the new ones, i.e., a 1:1 mapping.\n+         *\/\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            final Instruction c = i.copy(); \/\/ Use clone for shallow copy\n+            if (c instanceof BranchInstruction) {\n+                map.put(ih, il.append((BranchInstruction) c));\n+            } else {\n+                map.put(ih, il.append(c));\n+            }\n+        }\n+        \/*\n+         * Pass 2: Update branch targets.\n+         *\/\n+        InstructionHandle ih = start;\n+        InstructionHandle ch = il.start;\n+        while (ih != null) {\n+            final Instruction i = ih.getInstruction();\n+            final Instruction c = ch.getInstruction();\n+            if (i instanceof BranchInstruction) {\n+                final BranchInstruction bi = (BranchInstruction) i;\n+                final BranchInstruction bc = (BranchInstruction) c;\n+                final InstructionHandle itarget = bi.getTarget(); \/\/ old target\n+                \/\/ New target is in hash map\n+                bc.setTarget(map.get(itarget));\n+                if (bi instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n+                    final InstructionHandle[] itargets = ((Select) bi).getTargets();\n+                    final InstructionHandle[] ctargets = ((Select) bc).getTargets();\n+                    for (int j = 0; j < itargets.length; j++) { \/\/ Update all targets\n+                        ctargets[j] = map.get(itargets[j]);\n+                    }\n+                }\n+            }\n+            ih = ih.getNext();\n+            ch = ch.getNext();\n+        }\n+        return il;\n+    }\n+\n+    \/**\n+     * Replace all references to the old constant pool with references to the\n+     * new constant pool\n+     *\/\n+    public void replaceConstantPool(final ConstantPoolGen old_cp, final ConstantPoolGen new_cp) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            if (i instanceof CPInstruction) {\n+                final CPInstruction ci = (CPInstruction) i;\n+                final Constant c = old_cp.getConstant(ci.getIndex());\n+                ci.setIndex(new_cp.addConstant(c, old_cp));\n+            }\n+        }\n+    }\n+\n+    private void clear() {\n+        start = end = null;\n+        length = 0;\n+    }\n+\n+    \/**\n+     * Delete contents of list. Provides better memory utilization, because the\n+     * system then may reuse the instruction handles. This method is typically\n+     * called right after {@link MethodGen#getMethod()}.\n+     *\/\n+    public void dispose() {\n+        \/\/ Traverse in reverse order, because ih.next is overwritten\n+        for (InstructionHandle ih = end; ih != null; ih = ih.getPrev()) {\n+            \/*\n+             * Causes BranchInstructions to release target and targeters,\n+             * because it calls dispose() on the contained instruction.\n+             *\/\n+            ih.dispose();\n+        }\n+        clear();\n+    }\n+\n+    \/**\n+     * @return start of list\n+     *\/\n+    public InstructionHandle getStart() {\n+        return start;\n+    }\n+\n+    \/**\n+     * @return end of list\n+     *\/\n+    public InstructionHandle getEnd() {\n+        return end;\n+    }\n+\n+    \/**\n+     * @return length of list (Number of instructions, not bytes)\n+     *\/\n+    public int getLength() {\n+        return length;\n+    }\n+\n+    \/**\n+     * @return length of list (Number of instructions, not bytes)\n+     *\/\n+    public int size() {\n+        return length;\n+    }\n+\n+    \/**\n+     * Redirect all references from old_target to new_target, i.e., update\n+     * targets of branch instructions.\n+     *\n+     * @param old_target\n+     *            the old target instruction handle\n+     * @param new_target\n+     *            the new target instruction handle\n+     *\/\n+    public void redirectBranches(final InstructionHandle old_target, final InstructionHandle new_target) {\n+        for (InstructionHandle ih = start; ih != null; ih = ih.getNext()) {\n+            final Instruction i = ih.getInstruction();\n+            if (i instanceof BranchInstruction) {\n+                final BranchInstruction b = (BranchInstruction) i;\n+                final InstructionHandle target = b.getTarget();\n+                if (target == old_target) {\n+                    b.setTarget(new_target);\n+                }\n+                if (b instanceof Select) { \/\/ Either LOOKUPSWITCH or TABLESWITCH\n+                    final InstructionHandle[] targets = ((Select) b).getTargets();\n+                    for (int j = 0; j < targets.length; j++) {\n+                        if (targets[j] == old_target) {\n+                            ((Select) b).setTarget(j, new_target);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Redirect all references of local variables from old_target to new_target.\n+     *\n+     * @param lg\n+     *            array of local variables\n+     * @param old_target\n+     *            the old target instruction handle\n+     * @param new_target\n+     *            the new target instruction handle\n+     * @see MethodGen\n+     *\/\n+    public void redirectLocalVariables(final LocalVariableGen[] lg, final InstructionHandle old_target, final InstructionHandle new_target) {\n+        for (final LocalVariableGen element : lg) {\n+            final InstructionHandle start = element.getStart();\n+            final InstructionHandle end = element.getEnd();\n+            if (start == old_target) {\n+                element.setStart(new_target);\n+            }\n+            if (end == old_target) {\n+                element.setEnd(new_target);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Redirect all references of exception handlers from old_target to new_target.\n+     *\n+     * @param exceptions\n+     *            array of exception handlers\n+     * @param old_target\n+     *            the old target instruction handle\n+     * @param new_target\n+     *            the new target instruction handle\n+     * @see MethodGen\n+     *\/\n+    public void redirectExceptionHandlers(final CodeExceptionGen[] exceptions,\n+            final InstructionHandle old_target, final InstructionHandle new_target) {\n+        for (final CodeExceptionGen exception : exceptions) {\n+            if (exception.getStartPC() == old_target) {\n+                exception.setStartPC(new_target);\n+            }\n+            if (exception.getEndPC() == old_target) {\n+                exception.setEndPC(new_target);\n+            }\n+            if (exception.getHandlerPC() == old_target) {\n+                exception.setHandlerPC(new_target);\n+            }\n+        }\n+    }\n+\n+    private List<InstructionListObserver> observers;\n+\n+    \/**\n+     * Add observer for this object.\n+     *\/\n+    public void addObserver(final InstructionListObserver o) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n+    }\n+\n+    \/**\n+     * Remove observer for this object.\n+     *\/\n+    public void removeObserver(final InstructionListObserver o) {\n+        if (observers != null) {\n+            observers.remove(o);\n+        }\n+    }\n+\n+    \/**\n+     * Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be called by the\n+     * user after he has finished editing the object.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionList.java","additions":793,"deletions":684,"binary":false,"changes":1477,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Implement this interface if you're interested in changes to an InstructionList object and register yourself with\n- * addObserver().\n+ * Implement this interface if you're interested in changes to an InstructionList object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(InstructionList list);\n+    void notify( InstructionList list );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionListObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * Denote that a class targets InstructionHandles within an InstructionList. Namely the following implementers:\n+ * Denote that a class targets InstructionHandles within an InstructionList. Namely\n+ * the following implementers:\n@@ -33,2 +34,0 @@\n-    \/\/ static final InstructionTargeter[] EMPTY_ARRAY = new InstructionTargeter[0];\n-\n@@ -43,3 +42,3 @@\n-     * @param oldIh the old handle\n-     * @param newIh the new handle\n-     * @throws ClassGenException if oldIh is not targeted by this object\n+     * @param old_ih the old handle\n+     * @param new_ih the new handle\n+     * @throws ClassGenException if old_ih is not targeted by this object\n@@ -47,1 +46,1 @@\n-    void updateTarget(InstructionHandle oldIh, InstructionHandle newIh) throws ClassGenException;\n+    void updateTarget(InstructionHandle old_ih, InstructionHandle new_ih) throws ClassGenException;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InstructionTargeter.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -34,1 +33,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -36,1 +35,2 @@\n-public abstract class InvokeInstruction extends FieldOrMethod implements ExceptionThrower, StackConsumer, StackProducer {\n+public abstract class InvokeInstruction extends FieldOrMethod implements ExceptionThrower,\n+        StackConsumer, StackProducer {\n@@ -39,1 +39,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -44,0 +45,1 @@\n+\n@@ -51,0 +53,1 @@\n+\n@@ -52,2 +55,25 @@\n-     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n-     *\n+     * @return mnemonic for instruction with symbolic references resolved\n+     *\/\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        final Constant c = cp.getConstant(super.getIndex());\n+        final StringTokenizer tok = new StringTokenizer(cp.constantToString(c));\n+\n+        final String opcodeName = Const.getOpcodeName(super.getOpcode());\n+\n+        final StringBuilder sb = new StringBuilder(opcodeName);\n+        if (tok.hasMoreTokens()) {\n+            sb.append(\" \");\n+            sb.append(tok.nextToken().replace('.', '\/'));\n+            if (tok.hasMoreTokens()) {\n+                sb.append(tok.nextToken());\n+            }\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+\n+    \/**\n+     * Also works for instructions whose stack effect depends on the\n+     * constant pool entry they reference.\n@@ -57,1 +83,1 @@\n-    public int consumeStack(final ConstantPoolGen cpg) {\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n@@ -59,1 +85,1 @@\n-        if (super.getOpcode() == Const.INVOKESTATIC || super.getOpcode() == Const.INVOKEDYNAMIC) {\n+        if ((super.getOpcode() == Const.INVOKESTATIC) || (super.getOpcode() == Const.INVOKEDYNAMIC)) {\n@@ -70,0 +96,1 @@\n+\n@@ -71,1 +98,3 @@\n-     * @return argument types of referenced method.\n+     * Also works for instructions whose stack effect depends on the\n+     * constant pool entry they reference.\n+     * @return Number of words produced onto stack by this instruction\n@@ -73,2 +102,4 @@\n-    public Type[] getArgumentTypes(final ConstantPoolGen cpg) {\n-        return Type.getArgumentTypes(getSignature(cpg));\n+    @Override\n+    public int produceStack( final ConstantPoolGen cpg ) {\n+        final String signature = getSignature(cpg);\n+        return Type.getReturnTypeSize(signature);\n@@ -78,1 +109,4 @@\n-     * This overrides the deprecated version as we know here that the referenced class may legally be an array.\n+     * This overrides the deprecated version as we know here that the referenced class\n+     * may legally be an array.\n+     *\n+     * @deprecated in FieldOrMethod\n@@ -89,8 +123,1 @@\n-        return Utility.pathToPackage(className);\n-    }\n-\n-    \/**\n-     * @return name of referenced method.\n-     *\/\n-    public String getMethodName(final ConstantPoolGen cpg) {\n-        return getName(cpg);\n+        return className.replace('\/', '.');\n@@ -99,9 +126,1 @@\n-    \/**\n-     * @return return type of referenced method.\n-     *\/\n-    public Type getReturnType(final ConstantPoolGen cpg) {\n-        return Type.getReturnType(getSignature(cpg));\n-    }\n-\n-    \/**\n-     * @return return type of referenced method.\n+    \/** @return return type of referenced method.\n@@ -110,1 +129,1 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n+    public Type getType( final ConstantPoolGen cpg ) {\n@@ -114,4 +133,2 @@\n-    \/**\n-     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n-     *\n-     * @return Number of words produced onto stack by this instruction\n+\n+    \/** @return name of referenced method.\n@@ -119,4 +136,2 @@\n-    @Override\n-    public int produceStack(final ConstantPoolGen cpg) {\n-        final String signature = getSignature(cpg);\n-        return Type.getReturnTypeSize(signature);\n+    public String getMethodName( final ConstantPoolGen cpg ) {\n+        return getName(cpg);\n@@ -125,7 +140,0 @@\n-    \/**\n-     * @return mnemonic for instruction with symbolic references resolved\n-     *\/\n-    @Override\n-    public String toString(final ConstantPool cp) {\n-        final Constant c = cp.getConstant(super.getIndex());\n-        final StringTokenizer tok = new StringTokenizer(cp.constantToString(c));\n@@ -133,1 +141,5 @@\n-        final String opcodeName = Const.getOpcodeName(super.getOpcode());\n+    \/** @return return type of referenced method.\n+     *\/\n+    public Type getReturnType( final ConstantPoolGen cpg ) {\n+        return Type.getReturnType(getSignature(cpg));\n+    }\n@@ -135,8 +147,0 @@\n-        final StringBuilder sb = new StringBuilder(opcodeName);\n-        if (tok.hasMoreTokens()) {\n-            sb.append(\" \");\n-            sb.append(Utility.packageToPath(tok.nextToken()));\n-            if (tok.hasMoreTokens()) {\n-                sb.append(tok.nextToken());\n-            }\n-        }\n@@ -144,1 +148,4 @@\n-        return sb.toString();\n+    \/** @return argument types of referenced method.\n+     *\/\n+    public Type[] getArgumentTypes( final ConstantPoolGen cpg ) {\n+        return Type.getArgumentTypes(getSignature(cpg));\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/InvokeInstruction.java","additions":63,"deletions":56,"binary":false,"changes":119,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *\n@@ -33,1 +34,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,0 +40,1 @@\n+\n@@ -42,14 +45,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackProducer(this);\n-        v.visitVariableLengthInstruction(this);\n-        v.visitBranchInstruction(this);\n-        v.visitJsrInstruction(this);\n-        v.visitJSR(this);\n-    }\n@@ -59,1 +48,0 @@\n-     *\n@@ -63,1 +51,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -74,0 +62,1 @@\n+\n@@ -75,1 +64,1 @@\n-    protected int updatePosition(final int offset, final int maxOffset) {\n+    protected int updatePosition( final int offset, final int max_offset ) {\n@@ -78,1 +67,1 @@\n-        if (Math.abs(i) >= Short.MAX_VALUE - maxOffset) { \/\/ to large for short (estimate)\n+        if (Math.abs(i) >= (Short.MAX_VALUE - max_offset)) { \/\/ to large for short (estimate)\n@@ -80,1 +69,1 @@\n-            final short oldLength = (short) super.getLength();\n+            final short old_length = (short) super.getLength();\n@@ -82,1 +71,1 @@\n-            return super.getLength() - oldLength;\n+            return super.getLength() - old_length;\n@@ -86,0 +75,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackProducer(this);\n+        v.visitVariableLengthInstruction(this);\n+        v.visitBranchInstruction(this);\n+        v.visitJsrInstruction(this);\n+        v.visitJSR(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JSR.java","additions":28,"deletions":21,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+ *\n@@ -35,1 +36,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +42,1 @@\n+\n@@ -45,13 +48,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackProducer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitJsrInstruction(this);\n-        v.visitJSR_W(this);\n-    }\n@@ -61,1 +51,0 @@\n-     *\n@@ -65,1 +54,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -71,0 +60,1 @@\n+\n@@ -75,1 +65,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -79,0 +69,17 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackProducer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitJsrInstruction(this);\n+        v.visitJSR_W(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JSR_W.java","additions":24,"deletions":17,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -27,1 +28,7 @@\n-public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch, TypedInstruction, StackProducer {\n+public abstract class JsrInstruction extends BranchInstruction implements UnconditionalBranch,\n+        TypedInstruction, StackProducer {\n+\n+    JsrInstruction(final short opcode, final InstructionHandle target) {\n+        super(opcode, target);\n+    }\n+\n@@ -30,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -35,3 +43,0 @@\n-    JsrInstruction(final short opcode, final InstructionHandle target) {\n-        super(opcode, target);\n-    }\n@@ -39,2 +44,1 @@\n-    \/**\n-     * @return return address type\n+    \/** @return return address type\n@@ -43,1 +47,1 @@\n-    public Type getType(final ConstantPoolGen cp) {\n+    public Type getType( final ConstantPoolGen cp ) {\n@@ -47,0 +51,1 @@\n+\n@@ -48,5 +53,9 @@\n-     * Returns an InstructionHandle to the physical successor of this JsrInstruction. <B>For this method to work, this\n-     * JsrInstruction object must not be shared between multiple InstructionHandle objects!<\/B> Formally, there must not be\n-     * InstructionHandle objects i, j where i != j and i.getInstruction() == this == j.getInstruction().\n-     *\n-     * @return an InstructionHandle to the \"next\" instruction that will be executed when RETurned from a subroutine.\n+     * Returns an InstructionHandle to the physical successor\n+     * of this JsrInstruction. <B>For this method to work,\n+     * this JsrInstruction object must not be shared between\n+     * multiple InstructionHandle objects!<\/B>\n+     * Formally, there must not be InstructionHandle objects\n+     * i, j where i != j and i.getInstruction() == this ==\n+     * j.getInstruction().\n+     * @return an InstructionHandle to the \"next\" instruction that\n+     * will be executed when RETurned from a subroutine.\n@@ -67,1 +76,1 @@\n-            if (ih != null && ih.getInstruction() == this) {\n+            if ((ih != null) && (ih.getInstruction() == this)) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/JsrInstruction.java","additions":23,"deletions":14,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2D.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2F.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/L2I.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LADD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value1, value2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value1, value2\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Load long from array\n+    \/** Load long from array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LALOAD.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LAND.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * LASTORE - Store into long array\n+ * LASTORE -  Store into long array\n+ * <PRE>Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -33,2 +31,1 @@\n-    \/**\n-     * Store long into array\n+    \/** Store long into array\n@@ -40,0 +37,1 @@\n+\n@@ -41,2 +39,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -47,1 +47,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LASTORE.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result &lt;= -1, 0, 1&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt; ..., result &lt;= -1, 0, 1&gt;\n- * <\/PRE>\n@@ -38,0 +36,9 @@\n+\n+    \/** @return Type.LONG\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.LONG;\n+    }\n+\n+\n@@ -39,2 +46,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -45,1 +54,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -51,8 +60,0 @@\n-\n-    \/**\n-     * @return Type.LONG\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.LONG;\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LCMP.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...,\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., <\/PRE>\n+ *\n@@ -32,1 +31,2 @@\n-    private final long value;\n+    private long value;\n+\n@@ -35,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -38,1 +39,0 @@\n-        this(0);\n@@ -41,0 +41,1 @@\n+\n@@ -53,0 +54,15 @@\n+\n+    @Override\n+    public Number getValue() {\n+        return Long.valueOf(value);\n+    }\n+\n+\n+    \/** @return Type.LONG\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.LONG;\n+    }\n+\n+\n@@ -54,2 +70,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -60,1 +78,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -67,13 +85,0 @@\n-\n-    \/**\n-     * @return Type.LONG\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.LONG;\n-    }\n-\n-    @Override\n-    public Number getValue() {\n-        return Long.valueOf(value);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LCONST.java","additions":27,"deletions":22,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -32,3 +32,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., item\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., item<\/PRE>\n+ *\n@@ -40,1 +39,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -45,0 +45,1 @@\n+\n@@ -50,14 +51,10 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitStackProducer(this);\n-        v.visitPushInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitCPInstruction(this);\n-        v.visitLDC(this);\n+\n+    \/\/ Adjust to proper size\n+    protected final void setSize() {\n+        if (super.getIndex() <= com.sun.org.apache.bcel.internal.Const.MAX_BYTE) { \/\/ Fits in one byte?\n+            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC);\n+            super.setLength(2);\n+        } else {\n+            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC_W);\n+            super.setLength(3);\n+        }\n@@ -66,0 +63,1 @@\n+\n@@ -68,1 +66,0 @@\n-     *\n@@ -72,1 +69,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -81,0 +78,4 @@\n+\n+    \/**\n+     * Set the index to constant pool and adjust size.\n+     *\/\n@@ -82,2 +83,3 @@\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_STRING_RESOLUTION);\n+    public final void setIndex( final int index ) {\n+        super.setIndex(index);\n+        setSize();\n@@ -86,0 +88,4 @@\n+\n+    \/**\n+     * Read needed data (e.g. index) from file.\n+     *\/\n@@ -87,13 +93,3 @@\n-    public Type getType(final ConstantPoolGen cpg) {\n-        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n-            return Type.STRING;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n-            return Type.FLOAT;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n-            return Type.INT;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n-            return Type.CLASS;\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n-        }\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(2);\n+        super.setIndex(bytes.readUnsignedByte());\n@@ -102,1 +98,2 @@\n-    public Object getValue(final ConstantPoolGen cpg) {\n+\n+    public Object getValue( final ConstantPoolGen cpg ) {\n@@ -105,14 +102,14 @@\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n-            final int i = ((com.sun.org.apache.bcel.internal.classfile.ConstantString) c).getStringIndex();\n-            c = cpg.getConstantPool().getConstant(i);\n-            return ((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes();\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n-            return Float.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantFloat) c).getBytes());\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n-            return Integer.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantInteger) c).getBytes());\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n-            final int nameIndex = ((com.sun.org.apache.bcel.internal.classfile.ConstantClass) c).getNameIndex();\n-            c = cpg.getConstantPool().getConstant(nameIndex);\n-            return Type.getType(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes());\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n+                final int i = ((com.sun.org.apache.bcel.internal.classfile.ConstantString) c).getStringIndex();\n+                c = cpg.getConstantPool().getConstant(i);\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantFloat) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantInteger) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n+                final int nameIndex = ((com.sun.org.apache.bcel.internal.classfile.ConstantClass) c).getNameIndex();\n+                c = cpg.getConstantPool().getConstant(nameIndex);\n+                return new ObjectType(((com.sun.org.apache.bcel.internal.classfile.ConstantUtf8) c).getBytes());\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n@@ -122,3 +119,1 @@\n-    \/**\n-     * Read needed data (e.g. index) from file.\n-     *\/\n+\n@@ -126,3 +121,13 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(2);\n-        super.setIndex(bytes.readUnsignedByte());\n+    public Type getType( final ConstantPoolGen cpg ) {\n+        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_String:\n+                return Type.STRING;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Float:\n+                return Type.FLOAT;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Integer:\n+                return Type.INT;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Class:\n+                return Type.CLASS;\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+        }\n@@ -131,3 +136,1 @@\n-    \/**\n-     * Set the index to constant pool and adjust size.\n-     *\/\n+\n@@ -135,3 +138,2 @@\n-    public final void setIndex(final int index) {\n-        super.setIndex(index);\n-        setSize();\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_STRING_RESOLUTION);\n@@ -140,9 +142,17 @@\n-    \/\/ Adjust to proper size\n-    protected final void setSize() {\n-        if (super.getIndex() <= com.sun.org.apache.bcel.internal.Const.MAX_BYTE) { \/\/ Fits in one byte?\n-            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC);\n-            super.setLength(2);\n-        } else {\n-            super.setOpcode(com.sun.org.apache.bcel.internal.Const.LDC_W);\n-            super.setLength(3);\n-        }\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitStackProducer(this);\n+        v.visitPushInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitCPInstruction(this);\n+        v.visitLDC(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC.java","additions":81,"deletions":71,"binary":false,"changes":152,"status":"modified"},{"patch":"@@ -26,3 +26,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., item.word1, item.word2\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., item.word1, item.word2<\/PRE>\n+ *\n@@ -34,1 +33,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +39,1 @@\n+\n@@ -43,0 +44,27 @@\n+\n+    @Override\n+    public Type getType( final ConstantPoolGen cpg ) {\n+        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n+                return Type.LONG;\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n+                return Type.DOUBLE;\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown constant type \" + super.getOpcode());\n+        }\n+    }\n+\n+\n+    public Number getValue( final ConstantPoolGen cpg ) {\n+        final com.sun.org.apache.bcel.internal.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());\n+        switch (c.getTag()) {\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantLong) c).getBytes();\n+            case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n+                return ((com.sun.org.apache.bcel.internal.classfile.ConstantDouble) c).getBytes();\n+            default: \/\/ Never reached\n+                throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n+        }\n+    }\n+\n+\n@@ -44,2 +72,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -50,1 +80,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -57,24 +87,0 @@\n-\n-    @Override\n-    public Type getType(final ConstantPoolGen cpg) {\n-        switch (cpg.getConstantPool().getConstant(super.getIndex()).getTag()) {\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n-            return Type.LONG;\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n-            return Type.DOUBLE;\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown constant type \" + super.getOpcode());\n-        }\n-    }\n-\n-    public Number getValue(final ConstantPoolGen cpg) {\n-        final com.sun.org.apache.bcel.internal.classfile.Constant c = cpg.getConstantPool().getConstant(super.getIndex());\n-        switch (c.getTag()) {\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Long:\n-            return Long.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantLong) c).getBytes());\n-        case com.sun.org.apache.bcel.internal.Const.CONSTANT_Double:\n-            return Double.valueOf(((com.sun.org.apache.bcel.internal.classfile.ConstantDouble) c).getBytes());\n-        default: \/\/ Never reached\n-            throw new IllegalArgumentException(\"Unknown or invalid constant type at \" + super.getIndex());\n-        }\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC2_W.java","additions":37,"deletions":31,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., item.word1, item.word2\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., item.word1, item.word2<\/PRE>\n+ *\n@@ -38,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -43,0 +43,1 @@\n+\n@@ -47,0 +48,1 @@\n+\n@@ -51,1 +53,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDC_W.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -27,0 +27,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -28,5 +30,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -41,0 +38,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -42,2 +48,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -48,1 +56,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -56,5 +64,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LDIV.java","additions":16,"deletions":13,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *<PRE>Stack ... -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack ... -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +39,1 @@\n+\n@@ -44,0 +44,1 @@\n+\n@@ -45,2 +46,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -51,1 +54,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LLOAD.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LMUL.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LNEG.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -42,1 +43,3 @@\n-    public LOOKUPSWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle defaultTarget) {\n+\n+    public LOOKUPSWITCH(final int[] match, final InstructionHandle[] targets,\n+            final InstructionHandle defaultTarget) {\n@@ -45,3 +48,3 @@\n-        final short length = (short) (9 + getMatchLength() * 8);\n-        super.setLength(length);\n-        setFixedLength(length);\n+        final short _length = (short) (9 + getMatch_length() * 8);\n+        super.setLength(_length);\n+        setFixed_length(_length);\n@@ -50,14 +53,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitSelect(this);\n-        v.visitLOOKUPSWITCH(this);\n-    }\n@@ -67,1 +56,0 @@\n-     *\n@@ -71,1 +59,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -73,3 +61,3 @@\n-        final int matchLength = getMatchLength();\n-        out.writeInt(matchLength); \/\/ npairs\n-        for (int i = 0; i < matchLength; i++) {\n+        final int _match_length = getMatch_length();\n+        out.writeInt(_match_length); \/\/ npairs\n+        for (int i = 0; i < _match_length; i++) {\n@@ -81,0 +69,1 @@\n+\n@@ -85,1 +74,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -87,10 +76,10 @@\n-        final int matchLength = bytes.readInt();\n-        setMatchLength(matchLength);\n-        final short fixedLength = (short) (9 + matchLength * 8);\n-        setFixedLength(fixedLength);\n-        final short length = (short) (matchLength + super.getPadding());\n-        super.setLength(length);\n-        super.setMatches(new int[matchLength]);\n-        super.setIndices(new int[matchLength]);\n-        super.setTargets(new InstructionHandle[matchLength]);\n-        for (int i = 0; i < matchLength; i++) {\n+        final int _match_length = bytes.readInt();\n+        setMatch_length(_match_length);\n+        final short _fixed_length = (short) (9 + _match_length * 8);\n+        setFixed_length(_fixed_length);\n+        final short _length = (short) (_match_length + super.getPadding());\n+        super.setLength(_length);\n+        super.setMatches(new int[_match_length]);\n+        super.setIndices(new int[_match_length]);\n+        super.setTargets(new InstructionHandle[_match_length]);\n+        for (int i = 0; i < _match_length; i++) {\n@@ -101,0 +90,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitSelect(this);\n+        v.visitLOOKUPSWITCH(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LOOKUPSWITCH.java","additions":42,"deletions":35,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; result<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; result\n- * <\/PRE>\n@@ -39,0 +37,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ARITHMETIC_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -40,2 +47,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +55,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -54,5 +63,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ARITHMETIC_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LREM.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * LRETURN - Return long from method\n+ * LRETURN -  Return long from method\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LRETURN.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSHL.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2 -&gt; ..., result.word1, result.word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ... <\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -34,1 +32,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -40,0 +39,1 @@\n+\n@@ -44,0 +44,1 @@\n+\n@@ -45,2 +46,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -51,1 +54,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSTORE.java","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,0 +26,2 @@\n+ * <PRE>Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;<\/PRE>\n+ *        ..., result.word1, result.word2\n@@ -27,5 +29,0 @@\n- * <PRE>\n- * Stack: ..., value1.word1, value1.word2, value2.word1, value2.word2 -&gt;\n- * <\/PRE>\n- *\n- * ..., result.word1, result.word2\n@@ -39,0 +36,1 @@\n+\n@@ -40,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LSUB.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LUSHR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., value1, value2 -&gt; ..., result<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., value1, value2 -&gt; ..., result\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LXOR.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * This class represents a line number within a method, i.e., give an instruction a line number corresponding to the\n- * source code line.\n+ * This class represents a line number within a method, i.e., give an instruction\n+ * a line number corresponding to the source code line.\n@@ -32,2 +32,2 @@\n- * @see LineNumber\n- * @see MethodGen\n+ * @see     LineNumber\n+ * @see     MethodGen\n@@ -37,2 +37,0 @@\n-    static final LineNumberGen[] EMPTY_ARRAY = {};\n-\n@@ -47,1 +45,1 @@\n-    public LineNumberGen(final InstructionHandle ih, final int srcLine) {\n+    public LineNumberGen(final InstructionHandle ih, final int src_line) {\n@@ -49,1 +47,1 @@\n-        setSourceLine(srcLine);\n+        setSourceLine(src_line);\n@@ -52,8 +50,0 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n-    }\n@@ -65,1 +55,1 @@\n-    public boolean containsTarget(final InstructionHandle ih) {\n+    public boolean containsTarget( final InstructionHandle ih ) {\n@@ -69,2 +59,11 @@\n-    public InstructionHandle getInstruction() {\n-        return ih;\n+\n+    \/**\n+     * @param old_ih old target\n+     * @param new_ih new target\n+     *\/\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        if (old_ih != ih) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but \" + ih + \"}\");\n+        }\n+        setInstruction(new_ih);\n@@ -73,0 +72,1 @@\n+\n@@ -74,1 +74,1 @@\n-     * Get LineNumber attribute.\n+     * Get LineNumber attribute .\n@@ -76,2 +76,2 @@\n-     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n-     * has been called for the instruction list.\n+     * This relies on that the instruction list has already been dumped to byte code or\n+     * or that the `setPositions' methods has been called for the instruction list.\n@@ -83,3 +83,0 @@\n-    public int getSourceLine() {\n-        return srcLine;\n-    }\n@@ -87,1 +84,1 @@\n-    public void setInstruction(final InstructionHandle instructionHandle) { \/\/ TODO could be package-protected?\n+    public void setInstruction( final InstructionHandle instructionHandle ) { \/\/ TODO could be package-protected?\n@@ -93,3 +90,0 @@\n-    public void setSourceLine(final int srcLine) { \/\/ TODO could be package-protected?\n-        this.srcLine = srcLine;\n-    }\n@@ -97,4 +91,0 @@\n-    \/**\n-     * @param oldIh old target\n-     * @param newIh new target\n-     *\/\n@@ -102,3 +92,5 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        if (oldIh != ih) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but \" + ih + \"}\");\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n@@ -106,1 +98,15 @@\n-        setInstruction(newIh);\n+    }\n+\n+\n+    public InstructionHandle getInstruction() {\n+        return ih;\n+    }\n+\n+\n+    public void setSourceLine( final int src_line ) { \/\/ TODO could be package-protected?\n+        this.srcLine = src_line;\n+    }\n+\n+\n+    public int getSourceLine() {\n+        return srcLine;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LineNumberGen.java","additions":43,"deletions":37,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes that an instruction may start the process of loading and resolving the referenced class in the Virtual Machine.\n+ * Denotes that an instruction may start the process of loading and resolving\n+ * the referenced class in the Virtual Machine.\n+ *\n@@ -30,4 +32,4 @@\n-     * Returns the {@link ObjectType} of the referenced class or interface that may be loaded and resolved.\n-     *\n-     * @param cpg A ConstantPoolGen\n-     * @return object type that may be loaded or null if a primitive is referenced\n+     * Returns the ObjectType of the referenced class or interface\n+     * that may be loaded and resolved.\n+     * @return object type that may be loaded or null if a primitive is\n+     * referenced\n@@ -35,1 +37,2 @@\n-    ObjectType getLoadClassType(ConstantPoolGen cpg);\n+    ObjectType getLoadClassType( ConstantPoolGen cpg );\n+\n@@ -38,7 +41,9 @@\n-     * Returns the type associated with this instruction. LoadClass instances are always typed, but this type does not always refer to the type of the class or\n-     * interface that it possibly forces to load. For example, {@link GETFIELD} would return the type of the field and not the type of the class where the field\n-     * is defined. If no class is forced to be loaded, {@code null} is returned. An example for this is an {@link NEWARRAY} instruction that creates an\n-     * {@code int[][]}.\n-     *\n-     * @param cpg A ConstantPoolGen\n-     * @return the type associated with this instruction.\n+     * Returns the type associated with this instruction.\n+     * LoadClass instances are always typed, but this type\n+     * does not always refer to the type of the class or interface\n+     * that it possibly forces to load. For example, GETFIELD would\n+     * return the type of the field and not the type of the class\n+     * where the field is defined.\n+     * If no class is forced to be loaded, <B>null<\/B> is returned.\n+     * An example for this is an ANEWARRAY instruction that creates\n+     * an int[][].\n@@ -47,1 +52,1 @@\n-    Type getType(ConstantPoolGen cpg);\n+    Type getType( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LoadClass.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes an unparameterized instruction to load a value from a local variable, e.g. ILOAD.\n+ * Denotes an unparameterized instruction to load a value from a local\n+ * variable, e.g. ILOAD.\n+ *\n@@ -30,2 +32,3 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n-     * readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n+     * tag and length are defined in readInstruction and initFromFile, respectively.\n@@ -33,2 +36,2 @@\n-    LoadInstruction(final short canonTag, final short cTag) {\n-        super(canonTag, cTag);\n+    LoadInstruction(final short canon_tag, final short c_tag) {\n+        super(canon_tag, c_tag);\n@@ -37,0 +40,1 @@\n+\n@@ -39,1 +43,1 @@\n-     * @param cTag Instruction number for compact version, ALOAD_0, e.g.\n+     * @param c_tag Instruction number for compact version, ALOAD_0, e.g.\n@@ -42,2 +46,2 @@\n-    protected LoadInstruction(final short opcode, final short cTag, final int n) {\n-        super(opcode, cTag, n);\n+    protected LoadInstruction(final short opcode, final short c_tag, final int n) {\n+        super(opcode, c_tag, n);\n@@ -46,0 +50,1 @@\n+\n@@ -47,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -53,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LoadInstruction.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -27,2 +27,4 @@\n- * Represents a local variable within a method. It contains its scope, name and type. The generated LocalVariable object\n- * can be obtained with getLocalVariable which needs the instruction list and the constant pool as parameters.\n+ * Represents a local variable within a method. It contains its\n+ * scope, name and type. The generated LocalVariable object can be obtained\n+ * with getLocalVariable which needs the instruction list and the constant\n+ * pool as parameters.\n@@ -30,2 +32,2 @@\n- * @see LocalVariable\n- * @see MethodGen\n+ * @see     LocalVariable\n+ * @see     MethodGen\n@@ -43,0 +45,1 @@\n+\n@@ -44,2 +47,2 @@\n-     * Generate a local variable that with index 'index'. Note that double and long variables need two indexs. Index indices\n-     * have to be provided by the user.\n+     * Generate a local variable that with index `index'. Note that double and long\n+     * variables need two indexs. Index indices have to be provided by the user.\n@@ -53,3 +56,4 @@\n-    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n-        if (index < 0 || index > Const.MAX_SHORT) {\n-            throw new ClassGenException(\"Invalid index: \" + index);\n+    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,\n+            final InstructionHandle end) {\n+        if ((index < 0) || (index > Const.MAX_SHORT)) {\n+            throw new ClassGenException(\"Invalid index index: \" + index);\n@@ -66,0 +70,1 @@\n+\n@@ -67,2 +72,2 @@\n-     * Generates a local variable that with index 'index'. Note that double and long variables need two indexs. Index\n-     * indices have to be provided by the user.\n+     * Generates a local variable that with index `index'. Note that double and long\n+     * variables need two indexs. Index indices have to be provided by the user.\n@@ -77,2 +82,2 @@\n-    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start, final InstructionHandle end,\n-        final int origIndex) {\n+    public LocalVariableGen(final int index, final String name, final Type type, final InstructionHandle start,\n+            final InstructionHandle end, final int origIndex) {\n@@ -83,8 +88,0 @@\n-    @Override\n-    public Object clone() {\n-        try {\n-            return super.clone();\n-        } catch (final CloneNotSupportedException e) {\n-            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n-        }\n-    }\n@@ -93,1 +90,12 @@\n-     * @return true, if ih is target of this variable\n+     * Gets LocalVariable object.\n+     *\n+     * This relies on that the instruction list has already been dumped to byte code or\n+     * or that the `setPositions' methods has been called for the instruction list.\n+     *\n+     * Note that due to the conversion from byte code offset to InstructionHandle,\n+     * it is impossible to tell the difference between a live range that ends BEFORE\n+     * the last insturction of the method or a live range that ends AFTER the last\n+     * instruction of the method.  Hence the liveToEnd flag to differentiate\n+     * between these two cases.\n+     *\n+     * @param cp constant pool\n@@ -95,3 +103,14 @@\n-    @Override\n-    public boolean containsTarget(final InstructionHandle ih) {\n-        return start == ih || end == ih;\n+    public LocalVariable getLocalVariable( final ConstantPoolGen cp ) {\n+        int start_pc = 0;\n+        int length = 0;\n+        if ((start != null) && (end != null)) {\n+            start_pc = start.getPosition();\n+            length = end.getPosition() - start_pc;\n+            if ((end.getNext() == null) && liveToEnd) {\n+                length += end.getInstruction().getLength();\n+            }\n+        }\n+        final int name_index = cp.addUtf8(name);\n+        final int signature_index = cp.addUtf8(type.getSignature());\n+        return new LocalVariable(start_pc, length, name_index, signature_index, index, cp\n+                .getConstantPool(), origIndex);\n@@ -100,7 +119,0 @@\n-    \/**\n-     * Clear the references from and to this variable when it's removed.\n-     *\/\n-    void dispose() {\n-        setStart(null);\n-        setEnd(null);\n-    }\n@@ -108,10 +120,2 @@\n-    \/**\n-     * We consider to local variables to be equal, if the use the same index and are valid in the same range.\n-     *\/\n-    @Override\n-    public boolean equals(final Object o) {\n-        if (!(o instanceof LocalVariableGen)) {\n-            return false;\n-        }\n-        final LocalVariableGen l = (LocalVariableGen) o;\n-        return l.index == index && l.start == start && l.end == end;\n+    public void setIndex( final int index ) {\n+        this.index = index;\n@@ -120,3 +124,0 @@\n-    public InstructionHandle getEnd() {\n-        return end;\n-    }\n@@ -128,0 +129,11 @@\n+\n+    public int getOrigIndex() {\n+        return origIndex;\n+    }\n+\n+\n+    public void setLiveToEnd( final boolean live_to_end) {\n+        this.liveToEnd = live_to_end;\n+    }\n+\n+\n@@ -132,25 +144,4 @@\n-    \/**\n-     * Gets LocalVariable object.\n-     *\n-     * This relies on that the instruction list has already been dumped to byte code or that the 'setPositions' methods\n-     * has been called for the instruction list.\n-     *\n-     * Note that due to the conversion from byte code offset to InstructionHandle, it is impossible to tell the difference\n-     * between a live range that ends BEFORE the last insturction of the method or a live range that ends AFTER the last\n-     * instruction of the method. Hence the liveToEnd flag to differentiate between these two cases.\n-     *\n-     * @param cp constant pool\n-     *\/\n-    public LocalVariable getLocalVariable(final ConstantPoolGen cp) {\n-        int startPc = 0;\n-        int length = 0;\n-        if (start != null && end != null) {\n-            startPc = start.getPosition();\n-            length = end.getPosition() - startPc;\n-            if (end.getNext() == null && liveToEnd) {\n-                length += end.getInstruction().getLength();\n-            }\n-        }\n-        final int nameIndex = cp.addUtf8(name);\n-        final int signatureIndex = cp.addUtf8(type.getSignature());\n-        return new LocalVariable(startPc, length, nameIndex, signatureIndex, index, cp.getConstantPool(), origIndex);\n+\n+    @Override\n+    public void setName( final String name ) {\n+        this.name = name;\n@@ -159,0 +150,1 @@\n+\n@@ -164,3 +156,0 @@\n-    public int getOrigIndex() {\n-        return origIndex;\n-    }\n@@ -168,2 +157,3 @@\n-    public InstructionHandle getStart() {\n-        return start;\n+    @Override\n+    public void setType( final Type type ) {\n+        this.type = type;\n@@ -172,0 +162,1 @@\n+\n@@ -177,5 +168,8 @@\n-    @Override\n-    public int hashCode() {\n-        \/\/ If the user changes the name or type, problems with the targeter hashmap will occur.\n-        \/\/ Note: index cannot be part of hash as it may be changed by the user.\n-        return name.hashCode() ^ type.hashCode();\n+\n+    public InstructionHandle getStart() {\n+        return start;\n+    }\n+\n+\n+    public InstructionHandle getEnd() {\n+        return end;\n@@ -184,1 +178,8 @@\n-    public void setEnd(final InstructionHandle end) { \/\/ TODO could be package-protected?\n+\n+    public void setStart( final InstructionHandle start ) { \/\/ TODO could be package-protected?\n+        BranchInstruction.notifyTarget(this.start, start, this);\n+        this.start = start;\n+    }\n+\n+\n+    public void setEnd( final InstructionHandle end ) { \/\/ TODO could be package-protected?\n@@ -189,2 +190,20 @@\n-    public void setIndex(final int index) {\n-        this.index = index;\n+\n+    \/**\n+     * @param old_ih old target, either start or end\n+     * @param new_ih new target\n+     *\/\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        boolean targeted = false;\n+        if (start == old_ih) {\n+            targeted = true;\n+            setStart(new_ih);\n+        }\n+        if (end == old_ih) {\n+            targeted = true;\n+            setEnd(new_ih);\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih + \", but {\" + start + \", \" + end\n+                    + \"}\");\n+        }\n@@ -193,2 +212,6 @@\n-    public void setLiveToEnd(final boolean liveToEnd) {\n-        this.liveToEnd = liveToEnd;\n+    \/**\n+     * Clear the references from and to this variable when it's removed.\n+     *\/\n+    void dispose() {\n+        setStart(null);\n+        setEnd(null);\n@@ -197,0 +220,3 @@\n+    \/**\n+     * @return true, if ih is target of this variable\n+     *\/\n@@ -198,2 +224,2 @@\n-    public void setName(final String name) {\n-        this.name = name;\n+    public boolean containsTarget( final InstructionHandle ih ) {\n+        return (start == ih) || (end == ih);\n@@ -202,3 +228,6 @@\n-    public void setStart(final InstructionHandle start) { \/\/ TODO could be package-protected?\n-        BranchInstruction.notifyTarget(this.start, start, this);\n-        this.start = start;\n+\n+    @Override\n+    public int hashCode() {\n+        \/\/ If the user changes the name or type, problems with the targeter hashmap will occur.\n+        \/\/ Note: index cannot be part of hash as it may be changed by the user.\n+        return name.hashCode() ^ type.hashCode();\n@@ -207,0 +236,5 @@\n+\n+    \/**\n+     * We consider to local variables to be equal, if the use the same index and\n+     * are valid in the same range.\n+     *\/\n@@ -208,2 +242,6 @@\n-    public void setType(final Type type) {\n-        this.type = type;\n+    public boolean equals( final Object o ) {\n+        if (!(o instanceof LocalVariableGen)) {\n+            return false;\n+        }\n+        final LocalVariableGen l = (LocalVariableGen) o;\n+        return (l.index == index) && (l.start == start) && (l.end == end);\n@@ -212,0 +250,1 @@\n+\n@@ -217,4 +256,1 @@\n-    \/**\n-     * @param oldIh old target, either start or end\n-     * @param newIh new target\n-     *\/\n+\n@@ -222,12 +258,5 @@\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n-        if (start == oldIh) {\n-            targeted = true;\n-            setStart(newIh);\n-        }\n-        if (end == oldIh) {\n-            targeted = true;\n-            setEnd(newIh);\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh + \", but {\" + start + \", \" + end + \"}\");\n+    public Object clone() {\n+        try {\n+            return super.clone();\n+        } catch (final CloneNotSupportedException e) {\n+            throw new Error(\"Clone Not Supported\"); \/\/ never happens\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableGen.java","additions":137,"deletions":108,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -33,7 +33,2 @@\n-public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction, IndexedInstruction {\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int n = -1; \/\/ index of referenced variable\n+public abstract class LocalVariableInstruction extends Instruction implements TypedInstruction,\n+        IndexedInstruction {\n@@ -41,0 +36,1 @@\n+    private int n = -1; \/\/ index of referenced variable\n@@ -44,0 +40,6 @@\n+\n+    private boolean wide() {\n+        return n > Const.MAX_BYTE;\n+    }\n+\n+\n@@ -45,1 +47,3 @@\n-     * Empty constructor needed for Instruction.readInstruction. Also used by IINC()!\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n+     * tag and length are defined in readInstruction and initFromFile, respectively.\n@@ -47,1 +51,4 @@\n-    LocalVariableInstruction() {\n+    LocalVariableInstruction(final short canon_tag, final short c_tag) {\n+        super();\n+        this.canonTag = canon_tag;\n+        this.cTag = c_tag;\n@@ -50,0 +57,1 @@\n+\n@@ -51,2 +59,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n-     * readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Also used by IINC()!\n@@ -54,3 +62,1 @@\n-    LocalVariableInstruction(final short canonTag, final short cTag) {\n-        this.canonTag = canonTag;\n-        this.cTag = cTag;\n+    LocalVariableInstruction() {\n@@ -59,0 +65,1 @@\n+\n@@ -71,0 +78,1 @@\n+\n@@ -73,1 +81,0 @@\n-     *\n@@ -77,1 +84,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -91,6 +98,0 @@\n-    \/**\n-     * @return canonical tag for instruction, e.g., ALOAD for ALOAD_0\n-     *\/\n-    public short getCanonicalTag() {\n-        return canonTag;\n-    }\n@@ -99,11 +100,1 @@\n-     * @return local variable index (n) referred by this instruction.\n-     *\/\n-    @Override\n-    public final int getIndex() {\n-        return n;\n-    }\n-\n-    \/**\n-     * Returns the type associated with the instruction - in case of ALOAD or ASTORE Type.OBJECT is returned. This is just a\n-     * bit incorrect, because ALOAD and ASTORE may work on every ReferenceType (including Type.NULL) and ASTORE may even\n-     * work on a ReturnaddressType .\n+     * Long output format:\n@@ -111,1 +102,5 @@\n-     * @return type associated with the instruction\n+     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\"\n+     * \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; local variable index&gt;\"&gt;\"\n+     *\n+     * @param verbose long\/short format switch\n+     * @return mnemonic for instruction\n@@ -114,19 +109,5 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        switch (canonTag) {\n-        case Const.ILOAD:\n-        case Const.ISTORE:\n-            return Type.INT;\n-        case Const.LLOAD:\n-        case Const.LSTORE:\n-            return Type.LONG;\n-        case Const.DLOAD:\n-        case Const.DSTORE:\n-            return Type.DOUBLE;\n-        case Const.FLOAD:\n-        case Const.FSTORE:\n-            return Type.FLOAT;\n-        case Const.ALOAD:\n-        case Const.ASTORE:\n-            return Type.OBJECT;\n-        default:\n-            throw new ClassGenException(\"Unknown case in switch\" + canonTag);\n+    public String toString( final boolean verbose ) {\n+        final short _opcode = super.getOpcode();\n+        if (((_opcode >= Const.ILOAD_0) && (_opcode <= Const.ALOAD_3))\n+         || ((_opcode >= Const.ISTORE_0) && (_opcode <= Const.ASTORE_3))) {\n+            return super.toString(verbose);\n@@ -134,0 +115,1 @@\n+        return super.toString(verbose) + \" \" + n;\n@@ -136,0 +118,1 @@\n+\n@@ -138,1 +121,0 @@\n-     *\n@@ -144,1 +126,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -149,2 +131,3 @@\n-            final short opcode = super.getOpcode();\n-            if (opcode >= Const.ILOAD && opcode <= Const.ALOAD || opcode >= Const.ISTORE && opcode <= Const.ASTORE) {\n+            final short _opcode = super.getOpcode();\n+            if (((_opcode >= Const.ILOAD) && (_opcode <= Const.ALOAD))\n+             || ((_opcode >= Const.ISTORE) && (_opcode <= Const.ASTORE))) {\n@@ -153,6 +136,5 @@\n-            } else {\n-                if (opcode <= Const.ALOAD_3) { \/\/ compact load instruction such as ILOAD_2\n-                    n = (opcode - Const.ILOAD_0) % 4;\n-                } else { \/\/ Assert ISTORE_0 <= tag <= ASTORE_3\n-                    n = (opcode - Const.ISTORE_0) % 4;\n-                }\n+            } else if (_opcode <= Const.ALOAD_3) { \/\/ compact load instruction such as ILOAD_2\n+                n = (_opcode - Const.ILOAD_0) % 4;\n+                super.setLength(1);\n+            } else { \/\/ Assert ISTORE_0 <= tag <= ASTORE_3\n+                n = (_opcode - Const.ISTORE_0) % 4;\n@@ -164,0 +146,1 @@\n+\n@@ -165,2 +148,12 @@\n-     * Set the local variable index. also updates opcode and length TODO Why?\n-     *\n+     * @return local variable index (n) referred by this instruction.\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return n;\n+    }\n+\n+\n+    \/**\n+     * Set the local variable index.\n+     * also updates opcode and length\n+     * TODO Why?\n@@ -170,2 +163,2 @@\n-    public void setIndex(final int n) { \/\/ TODO could be package-protected?\n-        if (n < 0 || n > Const.MAX_SHORT) {\n+    public void setIndex( final int n ) { \/\/ TODO could be package-protected?\n+        if ((n < 0) || (n > Const.MAX_SHORT)) {\n@@ -189,5 +182,2 @@\n-    \/**\n-     * Sets the index of the referenced variable (n) only\n-     *\n-     * @since 6.0\n-     * @see #setIndex(int)\n+\n+    \/** @return canonical tag for instruction, e.g., ALOAD for ALOAD_0\n@@ -195,2 +185,2 @@\n-    final void setIndexOnly(final int n) {\n-        this.n = n;\n+    public short getCanonicalTag() {\n+        return canonTag;\n@@ -199,0 +189,1 @@\n+\n@@ -200,7 +191,6 @@\n-     * Long output format:\n-     *\n-     * &lt;name of opcode&gt; \"[\"&lt;opcode number&gt;\"]\" \"(\"&lt;length of instruction&gt;\")\" \"&lt;\"&lt; local variable\n-     * index&gt;\"&gt;\"\n-     *\n-     * @param verbose long\/short format switch\n-     * @return mnemonic for instruction\n+     * Returns the type associated with the instruction -\n+     * in case of ALOAD or ASTORE Type.OBJECT is returned.\n+     * This is just a bit incorrect, because ALOAD and ASTORE\n+     * may work on every ReferenceType (including Type.NULL) and\n+     * ASTORE may even work on a ReturnaddressType .\n+     * @return type associated with the instruction\n@@ -209,4 +199,19 @@\n-    public String toString(final boolean verbose) {\n-        final short opcode = super.getOpcode();\n-        if (opcode >= Const.ILOAD_0 && opcode <= Const.ALOAD_3 || opcode >= Const.ISTORE_0 && opcode <= Const.ASTORE_3) {\n-            return super.toString(verbose);\n+    public Type getType( final ConstantPoolGen cp ) {\n+        switch (canonTag) {\n+            case Const.ILOAD:\n+            case Const.ISTORE:\n+                return Type.INT;\n+            case Const.LLOAD:\n+            case Const.LSTORE:\n+                return Type.LONG;\n+            case Const.DLOAD:\n+            case Const.DSTORE:\n+                return Type.DOUBLE;\n+            case Const.FLOAD:\n+            case Const.FSTORE:\n+                return Type.FLOAT;\n+            case Const.ALOAD:\n+            case Const.ASTORE:\n+                return Type.OBJECT;\n+            default:\n+                throw new ClassGenException(\"Unknown case in switch\" + canonTag);\n@@ -214,1 +219,0 @@\n-        return super.toString(verbose) + \" \" + n;\n@@ -217,2 +221,7 @@\n-    private boolean wide() {\n-        return n > Const.MAX_BYTE;\n+    \/**\n+     * Sets the index of the referenced variable (n) only\n+     * @since 6.0\n+     * @see #setIndex(int)\n+     *\/\n+    final void setIndexOnly(final int n) {\n+        this.n = n;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/LocalVariableInstruction.java","additions":97,"deletions":88,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ...<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ...\n- * <\/PRE>\n@@ -39,0 +37,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NULL_POINTER_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -40,2 +47,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +55,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -51,5 +60,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MONITORENTER.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+ * <PRE>Stack: ..., objectref -&gt; ...<\/PRE>\n@@ -28,3 +29,0 @@\n- * <PRE>\n- * Stack: ..., objectref -&gt; ...\n- * <\/PRE>\n@@ -39,0 +37,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NULL_POINTER_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -40,2 +47,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -46,1 +55,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -51,5 +60,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NULL_POINTER_EXCEPTION};\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MONITOREXIT.java","additions":15,"deletions":11,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+ * <PRE>Stack: ..., count1, [count2, ...] -&gt; ..., arrayref<\/PRE>\n@@ -34,3 +35,0 @@\n- * <PRE>\n- * Stack: ..., count1, [count2, ...] -&gt; ..., arrayref\n- * <\/PRE>\n@@ -38,1 +36,2 @@\n-public class MULTIANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower {\n+public class MULTIANEWARRAY extends CPInstruction implements LoadClass, AllocationInstruction,\n+        ExceptionThrower {\n@@ -42,0 +41,1 @@\n+\n@@ -43,1 +43,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +49,1 @@\n+\n@@ -57,0 +59,1 @@\n+\n@@ -58,4 +61,2 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n@@ -64,7 +65,4 @@\n-    public void accept(final Visitor v) {\n-        v.visitLoadClass(this);\n-        v.visitAllocationInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitTypedInstruction(this);\n-        v.visitCPInstruction(this);\n-        v.visitMULTIANEWARRAY(this);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        out.writeShort(super.getIndex());\n+        out.writeByte(dimensions);\n@@ -73,0 +71,1 @@\n+\n@@ -74,3 +73,1 @@\n-     * Also works for instructions whose stack effect depends on the constant pool entry they reference.\n-     *\n-     * @return Number of words consumed from stack by this instruction\n+     * Read needed data (i.e., no. dimension) from file.\n@@ -79,1 +76,11 @@\n-    public int consumeStack(final ConstantPoolGen cpg) {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.initFromFile(bytes, wide);\n+        dimensions = bytes.readByte();\n+        super.setLength(4);\n+    }\n+\n+\n+    \/**\n+     * @return number of dimensions to be created\n+     *\/\n+    public final short getDimensions() {\n@@ -83,0 +90,1 @@\n+\n@@ -84,3 +92,1 @@\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n+     * @return mnemonic for instruction\n@@ -89,4 +95,2 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        out.writeShort(super.getIndex());\n-        out.writeByte(dimensions);\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + super.getIndex() + \" \" + dimensions;\n@@ -95,0 +99,1 @@\n+\n@@ -96,1 +101,1 @@\n-     * @return number of dimensions to be created\n+     * @return mnemonic for instruction with symbolic references resolved\n@@ -98,1 +103,13 @@\n-    public final short getDimensions() {\n+    @Override\n+    public String toString( final ConstantPool cp ) {\n+        return super.toString(cp) + \" \" + dimensions;\n+    }\n+\n+\n+    \/**\n+     * Also works for instructions whose stack effect depends on the\n+     * constant pool entry they reference.\n+     * @return Number of words consumed from stack by this instruction\n+     *\/\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n@@ -102,0 +119,1 @@\n+\n@@ -104,1 +122,2 @@\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n@@ -108,0 +127,1 @@\n+\n@@ -109,1 +129,1 @@\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n@@ -114,1 +134,1 @@\n-        return t instanceof ObjectType ? (ObjectType) t : null;\n+        return (t instanceof ObjectType) ? (ObjectType) t : null;\n@@ -117,17 +137,0 @@\n-    \/**\n-     * Read needed data (i.e., no. dimension) from file.\n-     *\/\n-    @Override\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.initFromFile(bytes, wide);\n-        dimensions = bytes.readByte();\n-        super.setLength(4);\n-    }\n-\n-    \/**\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + super.getIndex() + \" \" + dimensions;\n-    }\n@@ -136,1 +139,6 @@\n-     * @return mnemonic for instruction with symbolic references resolved\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -139,2 +147,7 @@\n-    public String toString(final ConstantPool cp) {\n-        return super.toString(cp) + \" \" + dimensions;\n+    public void accept( final Visitor v ) {\n+        v.visitLoadClass(this);\n+        v.visitAllocationInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitTypedInstruction(this);\n+        v.visitCPInstruction(this);\n+        v.visitMULTIANEWARRAY(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MULTIANEWARRAY.java","additions":65,"deletions":52,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,9 +22,0 @@\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Objects;\n-import java.util.Stack;\n-\n@@ -49,0 +40,7 @@\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Stack;\n@@ -51,3 +49,4 @@\n- * Template class for building up a method. This is done by defining exception handlers, adding thrown exceptions, local\n- * variables and attributes, whereas the 'LocalVariableTable' and 'LineNumberTable' attributes will be set automatically\n- * for the code. Use stripAttributes() if you don't like this.\n+ * Template class for building up a method. This is done by defining exception\n+ * handlers, adding thrown exceptions, local variables and attributes, whereas\n+ * the `LocalVariableTable' and `LineNumberTable' attributes will be set\n+ * automatically for the code. Use stripAttributes() if you don't like this.\n@@ -55,2 +54,3 @@\n- * While generating code it may be necessary to insert NOP operations. You can use the 'removeNOPs' method to get rid\n- * off them. The resulting method object can be obtained via the 'getMethod()' method.\n+ * While generating code it may be necessary to insert NOP operations. You can\n+ * use the `removeNOPs' method to get rid off them.\n+ * The resulting method object can be obtained via the `getMethod()' method.\n@@ -58,3 +58,3 @@\n- * @see InstructionList\n- * @see Method\n- * @LastModified: Feb 2023\n+ * @see     InstructionList\n+ * @see     Method\n+ * @LastModified: May 2021\n@@ -64,151 +64,0 @@\n-    static final class BranchStack {\n-\n-        private final Stack<BranchTarget> branchTargets = new Stack<>();\n-        private final HashMap<InstructionHandle, BranchTarget> visitedTargets = new HashMap<>();\n-\n-        public BranchTarget pop() {\n-            if (!branchTargets.empty()) {\n-                return branchTargets.pop();\n-            }\n-            return null;\n-        }\n-\n-        public void push(final InstructionHandle target, final int stackDepth) {\n-            if (visited(target)) {\n-                return;\n-            }\n-            branchTargets.push(visit(target, stackDepth));\n-        }\n-\n-        private BranchTarget visit(final InstructionHandle target, final int stackDepth) {\n-            final BranchTarget bt = new BranchTarget(target, stackDepth);\n-            visitedTargets.put(target, bt);\n-            return bt;\n-        }\n-\n-        private boolean visited(final InstructionHandle target) {\n-            return visitedTargets.get(target) != null;\n-        }\n-    }\n-\n-    static final class BranchTarget {\n-\n-        final InstructionHandle target;\n-        final int stackDepth;\n-\n-        BranchTarget(final InstructionHandle target, final int stackDepth) {\n-            this.target = target;\n-            this.stackDepth = stackDepth;\n-        }\n-    }\n-\n-    private static BCELComparator bcelComparator = new BCELComparator() {\n-\n-        @Override\n-        public boolean equals(final Object o1, final Object o2) {\n-            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o1;\n-            final FieldGenOrMethodGen THAT = (FieldGenOrMethodGen) o2;\n-            return Objects.equals(THIS.getName(), THAT.getName()) && Objects.equals(THIS.getSignature(), THAT.getSignature());\n-        }\n-\n-        @Override\n-        public int hashCode(final Object o) {\n-            final FieldGenOrMethodGen THIS = (FieldGenOrMethodGen) o;\n-            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n-        }\n-    };\n-\n-    private static byte[] getByteCodes(final Method method) {\n-        final Code code = method.getCode();\n-        if (code == null) {\n-            throw new IllegalStateException(String.format(\"The method '%s' has no code.\", method));\n-        }\n-        return code.getCode();\n-    }\n-\n-    \/**\n-     * @return Comparison strategy object\n-     *\/\n-    public static BCELComparator getComparator() {\n-        return bcelComparator;\n-    }\n-\n-    \/**\n-     * Computes stack usage of an instruction list by performing control flow analysis.\n-     *\n-     * @return maximum stack depth used by method\n-     *\/\n-    public static int getMaxStack(final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et) {\n-        final BranchStack branchTargets = new BranchStack();\n-        \/*\n-         * Initially, populate the branch stack with the exception handlers, because these aren't (necessarily) branched to\n-         * explicitly. in each case, the stack will have depth 1, containing the exception object.\n-         *\/\n-        for (final CodeExceptionGen element : et) {\n-            final InstructionHandle handlerPc = element.getHandlerPC();\n-            if (handlerPc != null) {\n-                branchTargets.push(handlerPc, 1);\n-            }\n-        }\n-        int stackDepth = 0;\n-        int maxStackDepth = 0;\n-        InstructionHandle ih = il.getStart();\n-        while (ih != null) {\n-            final Instruction instruction = ih.getInstruction();\n-            final short opcode = instruction.getOpcode();\n-            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n-            stackDepth += delta;\n-            if (stackDepth > maxStackDepth) {\n-                maxStackDepth = stackDepth;\n-            }\n-            \/\/ choose the next instruction based on whether current is a branch.\n-            if (instruction instanceof BranchInstruction) {\n-                final BranchInstruction branch = (BranchInstruction) instruction;\n-                if (instruction instanceof Select) {\n-                    \/\/ explore all of the select's targets. the default target is handled below.\n-                    final Select select = (Select) branch;\n-                    final InstructionHandle[] targets = select.getTargets();\n-                    for (final InstructionHandle target : targets) {\n-                        branchTargets.push(target, stackDepth);\n-                    }\n-                    \/\/ nothing to fall through to.\n-                    ih = null;\n-                } else if (!(branch instanceof IfInstruction)) {\n-                    \/\/ if an instruction that comes back to following PC,\n-                    \/\/ push next instruction, with stack depth reduced by 1.\n-                    if (opcode == Const.JSR || opcode == Const.JSR_W) {\n-                        branchTargets.push(ih.getNext(), stackDepth - 1);\n-                    }\n-                    ih = null;\n-                }\n-                \/\/ for all branches, the target of the branch is pushed on the branch stack.\n-                \/\/ conditional branches have a fall through case, selects don't, and\n-                \/\/ jsr\/jsr_w return to the next instruction.\n-                branchTargets.push(branch.getTarget(), stackDepth);\n-            } else \/\/ check for instructions that terminate the method.\n-            if (opcode == Const.ATHROW || opcode == Const.RET || opcode >= Const.IRETURN && opcode <= Const.RETURN) {\n-                ih = null;\n-            }\n-            \/\/ normal case, go to the next instruction.\n-            if (ih != null) {\n-                ih = ih.getNext();\n-            }\n-            \/\/ if we have no more instructions, see if there are any deferred branches to explore.\n-            if (ih == null) {\n-                final BranchTarget bt = branchTargets.pop();\n-                if (bt != null) {\n-                    ih = bt.target;\n-                    stackDepth = bt.stackDepth;\n-                }\n-            }\n-        }\n-        return maxStackDepth;\n-    }\n-\n-    \/**\n-     * @param comparator Comparison strategy object\n-     *\/\n-    public static void setComparator(final BCELComparator comparator) {\n-        bcelComparator = comparator;\n-    }\n-\n@@ -221,1 +70,0 @@\n-\n@@ -223,1 +71,1 @@\n-    private LocalVariableTypeTable localVariableTypeTable;\n+    private LocalVariableTypeTable localVariableTypeTable = null;\n@@ -225,1 +73,0 @@\n-\n@@ -227,1 +74,0 @@\n-\n@@ -229,1 +75,0 @@\n-\n@@ -231,1 +76,0 @@\n-\n@@ -235,0 +79,4 @@\n+    private boolean hasParameterAnnotations = false;\n+    private boolean haveUnpackedParameterAnnotations = false;\n+\n+    private static BCELComparator bcelComparator = new BCELComparator() {\n@@ -236,1 +84,7 @@\n-    private boolean hasParameterAnnotations;\n+        @Override\n+        public boolean equals( final Object o1, final Object o2 ) {\n+            final MethodGen THIS = (MethodGen) o1;\n+            final MethodGen THAT = (MethodGen) o2;\n+            return Objects.equals(THIS.getName(), THAT.getName())\n+                    && Objects.equals(THIS.getSignature(), THAT.getSignature());\n+        }\n@@ -238,1 +92,0 @@\n-    private boolean haveUnpackedParameterAnnotations;\n@@ -240,1 +93,7 @@\n-    private List<MethodObserver> observers;\n+        @Override\n+        public int hashCode( final Object o ) {\n+            final MethodGen THIS = (MethodGen) o;\n+            return THIS.getSignature().hashCode() ^ THIS.getName().hashCode();\n+        }\n+    };\n+\n@@ -243,3 +102,5 @@\n-     * Declare method. If the method is non-static the constructor automatically declares a local variable '$this' in slot\n-     * 0. The actual code is contained in the 'il' parameter, which may further manipulated by the user. But they must take\n-     * care not to remove any instruction (handles) that are still referenced from this object.\n+     * Declare method. If the method is non-static the constructor\n+     * automatically declares a local variable `$this' in slot 0. The\n+     * actual code is contained in the `il' parameter, which may further\n+     * manipulated by the user. But he must take care not to remove any\n+     * instruction (handles) that are still referenced from this object.\n@@ -247,2 +108,3 @@\n-     * For example one may not add a local variable and later remove the instructions it refers to without causing havoc. It\n-     * is safe however if you remove that local variable, too.\n+     * For example one may not add a local variable and later remove the\n+     * instructions it refers to without causing havoc. It is safe\n+     * however if you remove that local variable, too.\n@@ -250,2 +112,2 @@\n-     * @param accessFlags access qualifiers\n-     * @param returnType method type\n+     * @param access_flags access qualifiers\n+     * @param return_type  method type\n@@ -253,2 +115,3 @@\n-     * @param argNames argument names (if this is null, default names will be provided for them)\n-     * @param methodName name of method\n+     * @param argNames argument names (if this is null, default names will be provided\n+     * for them)\n+     * @param method_name name of method\n@@ -256,1 +119,2 @@\n-     * @param il instruction list associated with this method, may be null only for abstract or native methods\n+     * @param il instruction list associated with this method, may be null only for\n+     * abstract or native methods\n@@ -259,4 +123,4 @@\n-    public MethodGen(final int accessFlags, final Type returnType, final Type[] argTypes, String[] argNames, final String methodName, final String className,\n-        final InstructionList il, final ConstantPoolGen cp) {\n-        super(accessFlags);\n-        setType(returnType);\n+    public MethodGen(final int access_flags, final Type return_type, final Type[] argTypes, String[] argNames,\n+            final String method_name, final String className, final InstructionList il, final ConstantPoolGen cp) {\n+        super(access_flags);\n+        setType(return_type);\n@@ -265,1 +129,1 @@\n-        setName(methodName);\n+        setName(method_name);\n@@ -275,2 +139,1 @@\n-            \/*\n-             * Add local variables, namely the implicit 'this' and the arguments\n+            \/* Add local variables, namely the implicit `this' and the arguments\n@@ -278,2 +141,2 @@\n-            if (!isStatic() && className != null) { \/\/ Instance method -> 'this' is local var 0\n-                addLocalVariable(\"this\", ObjectType.getInstance(className), start, end);\n+            if (!isStatic() && (className != null)) { \/\/ Instance method -> `this' is local var 0\n+                addLocalVariable(\"this\",  ObjectType.getInstance(className), start, end);\n@@ -284,2 +147,2 @@\n-            for (final Type argType : argTypes) {\n-                if (Type.VOID == argType) {\n+            for (final Type arg_type : argTypes) {\n+                if (Type.VOID == arg_type) {\n@@ -291,1 +154,2 @@\n-                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size + \" vs. \" + argNames.length);\n+                    throw new ClassGenException(\"Mismatch in argument array lengths: \" + size\n+                            + \" vs. \" + argNames.length);\n@@ -308,0 +172,1 @@\n+\n@@ -316,2 +181,2 @@\n-        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()), Type.getArgumentTypes(method.getSignature()),\n-            null \/* may be overridden anyway *\/\n+        this(method.getAccessFlags(), Type.getReturnType(method.getSignature()),\n+            Type.getArgumentTypes(method.getSignature()), null \/* may be overridden anyway *\/\n@@ -319,1 +184,4 @@\n-            (method.getAccessFlags() & (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0 ? new InstructionList(getByteCodes(method)) : null, cp);\n+            ((method.getAccessFlags() & (Const.ACC_ABSTRACT | Const.ACC_NATIVE)) == 0)\n+                ? new InstructionList(getByteCodes(method))\n+                : null,\n+            cp);\n@@ -331,1 +199,1 @@\n-                        ObjectType cType = null;\n+                        ObjectType c_type = null;\n@@ -333,2 +201,3 @@\n-                            final String cen = method.getConstantPool().getConstantString(type, Const.CONSTANT_Class);\n-                            cType = ObjectType.getInstance(cen);\n+                            final String cen = method.getConstantPool().getConstantString(type,\n+                                    Const.CONSTANT_Class);\n+                            c_type =  ObjectType.getInstance(cen);\n@@ -336,1 +205,1 @@\n-                        final int endPc = ce.getEndPC();\n+                        final int end_pc = ce.getEndPC();\n@@ -339,1 +208,1 @@\n-                        if (length == endPc) { \/\/ May happen, because end_pc is exclusive\n+                        if (length == end_pc) { \/\/ May happen, because end_pc is exclusive\n@@ -342,1 +211,1 @@\n-                            end = il.findHandle(endPc);\n+                            end = il.findHandle(end_pc);\n@@ -345,1 +214,2 @@\n-                        addExceptionHandler(il.findHandle(ce.getStartPC()), end, il.findHandle(ce.getHandlerPC()), cType);\n+                        addExceptionHandler(il.findHandle(ce.getStartPC()), end,\n+                                il.findHandle(ce.getHandlerPC()), c_type);\n@@ -348,3 +218,3 @@\n-                final Attribute[] cAttributes = c.getAttributes();\n-                for (final Attribute cAttribute : cAttributes) {\n-                    a = cAttribute;\n+                final Attribute[] c_attributes = c.getAttributes();\n+                for (final Attribute c_attribute : c_attributes) {\n+                    a = c_attribute;\n@@ -352,1 +222,2 @@\n-                        ((LineNumberTable) a).forEach(l -> {\n+                        final LineNumber[] ln = ((LineNumberTable) a).getLineNumberTable();\n+                        for (final LineNumber l : ln) {\n@@ -357,1 +228,1 @@\n-                        });\n+                        }\n@@ -367,1 +238,4 @@\n-                Collections.addAll(throwsList, ((ExceptionTable) a).getExceptionNames());\n+                final String[] names = ((ExceptionTable) a).getExceptionNames();\n+                for (final String name2 : names) {\n+                    addException(name2);\n+                }\n@@ -370,1 +244,4 @@\n-                runtimeAnnotations.forEach(element -> addAnnotationEntry(new AnnotationEntryGen(element, cp, false)));\n+                final AnnotationEntry[] aes = runtimeAnnotations.getAnnotationEntries();\n+                for (final AnnotationEntry element : aes) {\n+                    addAnnotationEntry(new AnnotationEntryGen(element, cp, false));\n+                }\n@@ -377,26 +254,0 @@\n-    \/**\n-     * @since 6.0\n-     *\/\n-    public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        addAll(AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries()));\n-    }\n-\n-    \/**\n-     * Add an attribute to the code. Currently, the JVM knows about the LineNumberTable, LocalVariableTable and StackMap\n-     * attributes, where the former two will be generated automatically and the latter is used for the MIDP only. Other\n-     * attributes will be ignored by the JVM but do no harm.\n-     *\n-     * @param a attribute to be added\n-     *\/\n-    public void addCodeAttribute(final Attribute a) {\n-        codeAttrsList.add(a);\n-    }\n-\n-    \/**\n-     * Add an exception possibly thrown by this method.\n-     *\n-     * @param className (fully qualified) name of exception\n-     *\/\n-    public void addException(final String className) {\n-        throwsList.add(className);\n-    }\n@@ -404,14 +255,4 @@\n-    \/**\n-     * Add an exception handler, i.e., specify region where a handler is active and an instruction where the actual handling\n-     * is done.\n-     *\n-     * @param startPc Start of region (inclusive)\n-     * @param endPc End of region (inclusive)\n-     * @param handlerPc Where handling is done\n-     * @param catchType class type of handled exception or null if any exception is handled\n-     * @return new exception handler object\n-     *\/\n-    public CodeExceptionGen addExceptionHandler(final InstructionHandle startPc, final InstructionHandle endPc, final InstructionHandle handlerPc,\n-        final ObjectType catchType) {\n-        if (startPc == null || endPc == null || handlerPc == null) {\n-            throw new ClassGenException(\"Exception handler target is null instruction\");\n+    private static byte[] getByteCodes(final Method method) {\n+        final Code code = method.getCode();\n+        if (code == null) {\n+            throw new IllegalStateException(String.format(\"The method '%s' has no code.\", method));\n@@ -419,16 +260,1 @@\n-        final CodeExceptionGen c = new CodeExceptionGen(startPc, endPc, handlerPc, catchType);\n-        exceptionList.add(c);\n-        return c;\n-    }\n-\n-    \/**\n-     * Give an instruction a line number corresponding to the source code line.\n-     *\n-     * @param ih instruction to tag\n-     * @return new line number object\n-     * @see LineNumber\n-     *\/\n-    public LineNumberGen addLineNumber(final InstructionHandle ih, final int srcLine) {\n-        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n-        lineNumberList.add(l);\n-        return l;\n+        return code.getCode();\n@@ -438,1 +264,1 @@\n-     * Adds a local variable to this method and assigns an index automatically.\n+     * Adds a local variable to this method.\n@@ -442,2 +268,5 @@\n-     * @param start from where the variable is valid, if this is null, it is valid from the start\n-     * @param end until where the variable is valid, if this is null, it is valid to the end\n+     * @param slot the index of the local variable, if type is long or double, the next available\n+     * index is slot+2\n+     * @param start from where the variable is valid\n+     * @param end until where the variable is valid\n+     * @param orig_index the index of the local variable prior to any modifications\n@@ -447,2 +276,19 @@\n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final InstructionHandle start, final InstructionHandle end) {\n-        return addLocalVariable(name, type, maxLocals, start, end);\n+    public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,\n+            final InstructionHandle start, final InstructionHandle end, final int orig_index ) {\n+        final byte t = type.getType();\n+        if (t != Const.T_ADDRESS) {\n+            final int add = type.getSize();\n+            if (slot + add > maxLocals) {\n+                maxLocals = slot + add;\n+            }\n+            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, orig_index);\n+            int i;\n+            if ((i = variableList.indexOf(l)) >= 0) {\n+                variableList.set(i, l);\n+            } else {\n+                variableList.add(l);\n+            }\n+            return l;\n+        }\n+        throw new IllegalArgumentException(\"Can not use \" + type\n+                + \" as type for local variable\");\n@@ -451,0 +297,1 @@\n+\n@@ -456,1 +303,2 @@\n-     * @param slot the index of the local variable, if type is long or double, the next available index is slot+2\n+     * @param slot the index of the local variable, if type is long or double, the next available\n+     * index is slot+2\n@@ -462,1 +310,2 @@\n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end) {\n+    public LocalVariableGen addLocalVariable( final String name, final Type type, final int slot,\n+            final InstructionHandle start, final InstructionHandle end ) {\n@@ -467,1 +316,1 @@\n-     * Adds a local variable to this method.\n+     * Adds a local variable to this method and assigns an index automatically.\n@@ -471,4 +320,4 @@\n-     * @param slot the index of the local variable, if type is long or double, the next available index is slot+2\n-     * @param start from where the variable is valid\n-     * @param end until where the variable is valid\n-     * @param origIndex the index of the local variable prior to any modifications\n+     * @param start from where the variable is valid, if this is null,\n+     * it is valid from the start\n+     * @param end until where the variable is valid, if this is null,\n+     * it is valid to the end\n@@ -478,18 +327,3 @@\n-    public LocalVariableGen addLocalVariable(final String name, final Type type, final int slot, final InstructionHandle start, final InstructionHandle end,\n-        final int origIndex) {\n-        final byte t = type.getType();\n-        if (t != Const.T_ADDRESS) {\n-            final int add = type.getSize();\n-            if (slot + add > maxLocals) {\n-                maxLocals = slot + add;\n-            }\n-            final LocalVariableGen l = new LocalVariableGen(slot, name, type, start, end, origIndex);\n-            int i;\n-            if ((i = variableList.indexOf(l)) >= 0) {\n-                variableList.set(i, l);\n-            } else {\n-                variableList.add(l);\n-            }\n-            return l;\n-        }\n-        throw new IllegalArgumentException(\"Can not use \" + type + \" as type for local variable\");\n+    public LocalVariableGen addLocalVariable( final String name, final Type type, final InstructionHandle start,\n+            final InstructionHandle end ) {\n+        return addLocalVariable(name, type, maxLocals, start, end);\n@@ -498,0 +332,1 @@\n+\n@@ -499,1 +334,2 @@\n-     * Add observer for this object.\n+     * Remove a local variable, its slot will not be reused, if you do not use\n+     * addLocalVariable with an explicit index argument.\n@@ -501,5 +337,2 @@\n-    public void addObserver(final MethodObserver o) {\n-        if (observers == null) {\n-            observers = new ArrayList<>();\n-        }\n-        observers.add(o);\n+    public void removeLocalVariable(final LocalVariableGen l) {\n+        variableList.remove(l);\n@@ -508,17 +341,0 @@\n-    public void addParameterAnnotation(final int parameterIndex, final AnnotationEntryGen annotation) {\n-        ensureExistingParameterAnnotationsUnpacked();\n-        if (!hasParameterAnnotations) {\n-            @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-            final List<AnnotationEntryGen>[] parmList = (List<AnnotationEntryGen>[])new List[argTypes.length];\n-            paramAnnotations = parmList;\n-            hasParameterAnnotations = true;\n-        }\n-        final List<AnnotationEntryGen> existingAnnotations = paramAnnotations[parameterIndex];\n-        if (existingAnnotations != null) {\n-            existingAnnotations.add(annotation);\n-        } else {\n-            final List<AnnotationEntryGen> l = new ArrayList<>();\n-            l.add(annotation);\n-            paramAnnotations[parameterIndex] = l;\n-        }\n-    }\n@@ -527,1 +343,1 @@\n-     * @since 6.0\n+     * Remove all local variables.\n@@ -529,14 +345,2 @@\n-    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        if (!hasParameterAnnotations) {\n-            return;\n-        }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n-        if (attrs != null) {\n-            addAll(attrs);\n-        }\n-    }\n-\n-    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n-        addAll(attrs);\n-        return attrs;\n+    public void removeLocalVariables() {\n+        variableList.clear();\n@@ -545,8 +349,0 @@\n-    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n-        if (!hasParameterAnnotations) {\n-            return Attribute.EMPTY_ARRAY;\n-        }\n-        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n-        addAll(attrs);\n-        return attrs;\n-    }\n@@ -554,10 +350,16 @@\n-    private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n-        final LocalVariable[] lv = lvt.getLocalVariableTable();\n-        for (final LocalVariable element : localVariableTypeTable.getLocalVariableTypeTable()) {\n-            for (final LocalVariable l : lv) {\n-                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n-                    element.setLength(l.getLength());\n-                    element.setStartPC(l.getStartPC());\n-                    element.setIndex(l.getIndex());\n-                    break;\n-                }\n+    \/*\n+     * If the range of the variable has not been set yet, it will be set to be valid from\n+     * the start to the end of the instruction list.\n+     *\n+     * @return array of declared local variables sorted by index\n+     *\/\n+    public LocalVariableGen[] getLocalVariables() {\n+        final int size = variableList.size();\n+        final LocalVariableGen[] lg = new LocalVariableGen[size];\n+        variableList.toArray(lg);\n+        for (int i = 0; i < size; i++) {\n+            if ((lg[i].getStart() == null) && (il != null)) {\n+                lg[i].setStart(il.getStart());\n+            }\n+            if ((lg[i].getEnd() == null) && (il != null)) {\n+                lg[i].setEnd(il.getEnd());\n@@ -566,0 +368,4 @@\n+        if (size > 1) {\n+            Arrays.sort(lg, (o1, o2) -> o1.getIndex() - o2.getIndex());\n+        }\n+        return lg;\n@@ -568,0 +374,1 @@\n+\n@@ -569,1 +376,1 @@\n-     * @return deep copy of this method\n+     * @return `LocalVariableTable' attribute of all the local variables of this method.\n@@ -571,6 +378,6 @@\n-    public MethodGen copy(final String className, final ConstantPoolGen cp) {\n-        final Method m = ((MethodGen) clone()).getMethod();\n-        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n-        if (super.getConstantPool() != cp) {\n-            mg.setConstantPool(cp);\n-            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n+    public LocalVariableTable getLocalVariableTable( final ConstantPoolGen cp ) {\n+        final LocalVariableGen[] lg = getLocalVariables();\n+        final int size = lg.length;\n+        final LocalVariable[] lv = new LocalVariable[size];\n+        for (int i = 0; i < size; i++) {\n+            lv[i] = lg[i].getLocalVariable(cp);\n@@ -578,1 +385,2 @@\n-        return mg;\n+        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp\n+                .getConstantPool());\n@@ -582,4 +390,1 @@\n-     * Goes through the attributes on the method and identifies any that are RuntimeParameterAnnotations, extracting their\n-     * contents and storing them as parameter annotations. There are two kinds of parameter annotation - visible and\n-     * invisible. Once they have been unpacked, these attributes are deleted. (The annotations will be rebuilt as attributes\n-     * when someone builds a Method object out of this MethodGen object).\n+     * @return `LocalVariableTypeTable' attribute of this method.\n@@ -587,42 +392,2 @@\n-    private void ensureExistingParameterAnnotationsUnpacked() {\n-        if (haveUnpackedParameterAnnotations) {\n-            return;\n-        }\n-        \/\/ Find attributes that contain parameter annotation data\n-        final Attribute[] attrs = getAttributes();\n-        ParameterAnnotations paramAnnVisAttr = null;\n-        ParameterAnnotations paramAnnInvisAttr = null;\n-        for (final Attribute attribute : attrs) {\n-            if (attribute instanceof ParameterAnnotations) {\n-                \/\/ Initialize paramAnnotations\n-                if (!hasParameterAnnotations) {\n-                    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-                    final List<AnnotationEntryGen>[] parmList = (List<AnnotationEntryGen>[])new List[argTypes.length];\n-                    paramAnnotations = parmList;\n-                    Arrays.setAll(paramAnnotations, i -> new ArrayList<>());\n-                }\n-                hasParameterAnnotations = true;\n-                final ParameterAnnotations rpa = (ParameterAnnotations) attribute;\n-                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n-                    paramAnnVisAttr = rpa;\n-                } else {\n-                    paramAnnInvisAttr = rpa;\n-                }\n-                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n-                for (int j = 0; j < parameterAnnotationEntries.length; j++) {\n-                    \/\/ This returns Annotation[] ...\n-                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n-                    \/\/ ... which needs transforming into an AnnotationGen[] ...\n-                    final List<AnnotationEntryGen> mutable = makeMutableVersion(immutableArray.getAnnotationEntries());\n-                    \/\/ ... then add these to any we already know about\n-                    paramAnnotations[j].addAll(mutable);\n-                }\n-            }\n-        }\n-        if (paramAnnVisAttr != null) {\n-            removeAttribute(paramAnnVisAttr);\n-        }\n-        if (paramAnnInvisAttr != null) {\n-            removeAttribute(paramAnnInvisAttr);\n-        }\n-        haveUnpackedParameterAnnotations = true;\n+    public LocalVariableTypeTable getLocalVariableTypeTable() {\n+        return localVariableTypeTable;\n@@ -632,2 +397,1 @@\n-     * Return value as defined by given BCELComparator strategy. By default two MethodGen objects are said to be equal when\n-     * their names and signatures are equal.\n+     * Give an instruction a line number corresponding to the source code line.\n@@ -635,1 +399,3 @@\n-     * @see Object#equals(Object)\n+     * @param ih instruction to tag\n+     * @return new line number object\n+     * @see LineNumber\n@@ -637,3 +403,4 @@\n-    @Override\n-    public boolean equals(final Object obj) {\n-        return bcelComparator.equals(this, obj);\n+    public LineNumberGen addLineNumber( final InstructionHandle ih, final int srcLine ) {\n+        final LineNumberGen l = new LineNumberGen(ih, srcLine);\n+        lineNumberList.add(l);\n+        return l;\n@@ -642,2 +409,1 @@\n-    \/\/ J5TODO: Should paramAnnotations be an array of arrays? Rather than an array of lists, this\n-    \/\/ is more likely to suggest to the caller it is readonly (which a List does not).\n+\n@@ -645,3 +411,1 @@\n-     * Return a list of AnnotationGen objects representing parameter annotations\n-     *\n-     * @since 6.0\n+     * Remove a line number.\n@@ -649,6 +413,2 @@\n-    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) {\n-        ensureExistingParameterAnnotationsUnpacked();\n-        if (!hasParameterAnnotations || i > argTypes.length) {\n-            return null;\n-        }\n-        return paramAnnotations[i];\n+    public void removeLineNumber( final LineNumberGen l ) {\n+        lineNumberList.remove(l);\n@@ -657,3 +417,0 @@\n-    public String getArgumentName(final int i) {\n-        return argNames[i];\n-    }\n@@ -661,2 +418,5 @@\n-    public String[] getArgumentNames() {\n-        return argNames.clone();\n+    \/**\n+     * Remove all line numbers.\n+     *\/\n+    public void removeLineNumbers() {\n+        lineNumberList.clear();\n@@ -665,2 +425,8 @@\n-    public Type getArgumentType(final int i) {\n-        return argTypes[i];\n+\n+    \/*\n+     * @return array of line numbers\n+     *\/\n+    public LineNumberGen[] getLineNumbers() {\n+        final LineNumberGen[] lg = new LineNumberGen[lineNumberList.size()];\n+        lineNumberList.toArray(lg);\n+        return lg;\n@@ -669,2 +435,12 @@\n-    public Type[] getArgumentTypes() {\n-        return argTypes.clone();\n+\n+    \/**\n+     * @return `LineNumberTable' attribute of all the local variables of this method.\n+     *\/\n+    public LineNumberTable getLineNumberTable( final ConstantPoolGen cp ) {\n+        final int size = lineNumberList.size();\n+        final LineNumber[] ln = new LineNumber[size];\n+        for (int i = 0; i < size; i++) {\n+            ln[i] = lineNumberList.get(i).getLineNumber();\n+        }\n+        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp\n+                .getConstantPool());\n@@ -673,0 +449,1 @@\n+\n@@ -674,1 +451,9 @@\n-     * @return class that contains this method\n+     * Add an exception handler, i.e., specify region where a handler is active and an\n+     * instruction where the actual handling is done.\n+     *\n+     * @param start_pc Start of region (inclusive)\n+     * @param end_pc End of region (inclusive)\n+     * @param handler_pc Where handling is done\n+     * @param catch_type class type of handled exception or null if any\n+     * exception is handled\n+     * @return new exception handler object\n@@ -676,2 +461,8 @@\n-    public String getClassName() {\n-        return className;\n+    public CodeExceptionGen addExceptionHandler( final InstructionHandle start_pc,\n+            final InstructionHandle end_pc, final InstructionHandle handler_pc, final ObjectType catch_type ) {\n+        if ((start_pc == null) || (end_pc == null) || (handler_pc == null)) {\n+            throw new ClassGenException(\"Exception handler target is null instruction\");\n+        }\n+        final CodeExceptionGen c = new CodeExceptionGen(start_pc, end_pc, handler_pc, catch_type);\n+        exceptionList.add(c);\n+        return c;\n@@ -680,0 +471,1 @@\n+\n@@ -681,1 +473,1 @@\n-     * @return all attributes of this method.\n+     * Remove an exception handler.\n@@ -683,2 +475,2 @@\n-    public Attribute[] getCodeAttributes() {\n-        return codeAttrsList.toArray(Attribute.EMPTY_ARRAY);\n+    public void removeExceptionHandler( final CodeExceptionGen c ) {\n+        exceptionList.remove(c);\n@@ -687,0 +479,1 @@\n+\n@@ -688,1 +481,1 @@\n-     * @return code exceptions for 'Code' attribute\n+     * Remove all line numbers.\n@@ -690,5 +483,2 @@\n-    private CodeException[] getCodeExceptions() {\n-        final int size = exceptionList.size();\n-        final CodeException[] cExc = new CodeException[size];\n-        Arrays.setAll(cExc, i -> exceptionList.get(i).getCodeException(super.getConstantPool()));\n-        return cExc;\n+    public void removeExceptionHandlers() {\n+        exceptionList.clear();\n@@ -697,0 +487,1 @@\n+\n@@ -701,1 +492,3 @@\n-        return exceptionList.toArray(CodeExceptionGen.EMPTY_ARRAY);\n+        final CodeExceptionGen[] cg = new CodeExceptionGen[exceptionList.size()];\n+        exceptionList.toArray(cg);\n+        return cg;\n@@ -704,2 +497,3 @@\n-    \/*\n-     * @return array of thrown exceptions\n+\n+    \/**\n+     * @return code exceptions for `Code' attribute\n@@ -707,2 +501,8 @@\n-    public String[] getExceptions() {\n-        return throwsList.toArray(Const.EMPTY_STRING_ARRAY);\n+    private CodeException[] getCodeExceptions() {\n+        final int size = exceptionList.size();\n+        final CodeException[] c_exc = new CodeException[size];\n+        for (int i = 0; i < size; i++) {\n+            final CodeExceptionGen c =  exceptionList.get(i);\n+            c_exc[i] = c.getCodeException(super.getConstantPool());\n+        }\n+        return c_exc;\n@@ -711,0 +511,1 @@\n+\n@@ -712,1 +513,3 @@\n-     * @return 'Exceptions' attribute of all the exceptions thrown by this method.\n+     * Add an exception possibly thrown by this method.\n+     *\n+     * @param className (fully qualified) name of exception\n@@ -714,5 +517,2 @@\n-    private ExceptionTable getExceptionTable(final ConstantPoolGen cp) {\n-        final int size = throwsList.size();\n-        final int[] ex = new int[size];\n-        Arrays.setAll(ex, i -> cp.addClass(throwsList.get(i)));\n-        return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, ex, cp.getConstantPool());\n+    public void addException( final String className ) {\n+        throwsList.add(className);\n@@ -721,3 +521,0 @@\n-    public InstructionList getInstructionList() {\n-        return il;\n-    }\n@@ -725,2 +522,2 @@\n-    \/*\n-     * @return array of line numbers\n+    \/**\n+     * Remove an exception.\n@@ -728,2 +525,2 @@\n-    public LineNumberGen[] getLineNumbers() {\n-        return lineNumberList.toArray(LineNumberGen.EMPTY_ARRAY);\n+    public void removeException( final String c ) {\n+        throwsList.remove(c);\n@@ -732,0 +529,1 @@\n+\n@@ -733,1 +531,1 @@\n-     * @return 'LineNumberTable' attribute of all the local variables of this method.\n+     * Remove all exceptions.\n@@ -735,5 +533,2 @@\n-    public LineNumberTable getLineNumberTable(final ConstantPoolGen cp) {\n-        final int size = lineNumberList.size();\n-        final LineNumber[] ln = new LineNumber[size];\n-        Arrays.setAll(ln, i -> lineNumberList.get(i).getLineNumber());\n-        return new LineNumberTable(cp.addUtf8(\"LineNumberTable\"), 2 + ln.length * 4, ln, cp.getConstantPool());\n+    public void removeExceptions() {\n+        throwsList.clear();\n@@ -742,0 +537,1 @@\n+\n@@ -743,4 +539,1 @@\n-     * If the range of the variable has not been set yet, it will be set to be valid from the start to the end of the\n-     * instruction list.\n-     *\n-     * @return array of declared local variables sorted by index\n+     * @return array of thrown exceptions\n@@ -748,4 +541,11 @@\n-    public LocalVariableGen[] getLocalVariables() {\n-        final int size = variableList.size();\n-        final LocalVariableGen[] lg = new LocalVariableGen[size];\n-        variableList.toArray(lg);\n+    public String[] getExceptions() {\n+        return throwsList.toArray(new String[0]);\n+    }\n+\n+\n+    \/**\n+     * @return `Exceptions' attribute of all the exceptions thrown by this method.\n+     *\/\n+    private ExceptionTable getExceptionTable( final ConstantPoolGen cp ) {\n+        final int size = throwsList.size();\n+        final int[] ex = new int[size];\n@@ -753,6 +553,1 @@\n-            if (lg[i].getStart() == null && il != null) {\n-                lg[i].setStart(il.getStart());\n-            }\n-            if (lg[i].getEnd() == null && il != null) {\n-                lg[i].setEnd(il.getEnd());\n-            }\n+            ex[i] = cp.addClass(throwsList.get(i));\n@@ -760,4 +555,1 @@\n-        if (size > 1) {\n-            Arrays.sort(lg, Comparator.comparingInt(LocalVariableGen::getIndex));\n-        }\n-        return lg;\n+        return new ExceptionTable(cp.addUtf8(\"Exceptions\"), 2 + 2 * size, ex, cp.getConstantPool());\n@@ -766,0 +558,1 @@\n+\n@@ -767,1 +560,7 @@\n-     * @return 'LocalVariableTable' attribute of all the local variables of this method.\n+     * Add an attribute to the code. Currently, the JVM knows about the\n+     * LineNumberTable, LocalVariableTable and StackMap attributes,\n+     * where the former two will be generated automatically and the\n+     * latter is used for the MIDP only. Other attributes will be\n+     * ignored by the JVM but do no harm.\n+     *\n+     * @param a attribute to be added\n@@ -769,6 +568,2 @@\n-    public LocalVariableTable getLocalVariableTable(final ConstantPoolGen cp) {\n-        final LocalVariableGen[] lg = getLocalVariables();\n-        final int size = lg.length;\n-        final LocalVariable[] lv = new LocalVariable[size];\n-        Arrays.setAll(lv, i -> lg[i].getLocalVariable(cp));\n-        return new LocalVariableTable(cp.addUtf8(\"LocalVariableTable\"), 2 + lv.length * 10, lv, cp.getConstantPool());\n+    public void addCodeAttribute( final Attribute a ) {\n+        codeAttrsList.add(a);\n@@ -777,0 +572,1 @@\n+\n@@ -778,1 +574,1 @@\n-     * @return 'LocalVariableTypeTable' attribute of this method.\n+     * Remove the LocalVariableTypeTable\n@@ -780,2 +576,2 @@\n-    public LocalVariableTypeTable getLocalVariableTypeTable() {\n-        return localVariableTypeTable;\n+    public void removeLocalVariableTypeTable( ) {\n+        localVariableTypeTable = null;\n@@ -784,2 +580,5 @@\n-    public int getMaxLocals() {\n-        return maxLocals;\n+    \/**\n+     * Remove a code attribute.\n+     *\/\n+    public void removeCodeAttribute( final Attribute a ) {\n+        codeAttrsList.remove(a);\n@@ -788,3 +587,0 @@\n-    public int getMaxStack() {\n-        return maxStack;\n-    }\n@@ -793,4 +589,1 @@\n-     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively, before calling this method\n-     * (the same applies for max locals).\n-     *\n-     * @return method object\n+     * Remove all code attributes.\n@@ -798,10 +591,87 @@\n-    public Method getMethod() {\n-        final String signature = getSignature();\n-        final ConstantPoolGen cp = super.getConstantPool();\n-        final int nameIndex = cp.addUtf8(super.getName());\n-        final int signatureIndex = cp.addUtf8(signature);\n-        \/*\n-         * Also updates positions of instructions, i.e., their indices\n-         *\/\n-        final byte[] byteCode = il != null ? il.getByteCode() : null;\n-        LineNumberTable lnt = null;\n+    public void removeCodeAttributes() {\n+        localVariableTypeTable = null;\n+        codeAttrsList.clear();\n+    }\n+\n+\n+    \/**\n+     * @return all attributes of this method.\n+     *\/\n+    public Attribute[] getCodeAttributes() {\n+        return codeAttrsList.toArray(new Attribute[0]);\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void addAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+    }\n+\n+    \/**\n+     * @since 6.0\n+     *\/\n+    public void addParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        if (!hasParameterAnnotations) {\n+            return;\n+        }\n+        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n+        if (attrs != null) {\n+            for (final Attribute attr : attrs) {\n+                addAttribute(attr);\n+            }\n+        }\n+    }\n+\n+    private Attribute[] addRuntimeAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        final Attribute[] attrs = AnnotationEntryGen.getAnnotationAttributes(cp, super.getAnnotationEntries());\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+        return attrs;\n+    }\n+\n+    private Attribute[] addRuntimeParameterAnnotationsAsAttribute(final ConstantPoolGen cp) {\n+        if (!hasParameterAnnotations) {\n+            return new Attribute[0];\n+        }\n+        final Attribute[] attrs = AnnotationEntryGen.getParameterAnnotationAttributes(cp, paramAnnotations);\n+        for (final Attribute attr : attrs) {\n+            addAttribute(attr);\n+        }\n+        return attrs;\n+    }\n+\n+    \/**\n+     * Would prefer to make this private, but need a way to test if client is\n+     * using BCEL version 6.5.0 or later that contains fix for BCEL-329.\n+     * @since 6.5.0\n+     *\/\n+    public void removeRuntimeAttributes(final Attribute[] attrs) {\n+        for (final Attribute attr : attrs) {\n+            removeAttribute(attr);\n+        }\n+    }\n+\n+\n+    \/**\n+     * Get method object. Never forget to call setMaxStack() or setMaxStack(max), respectively,\n+     * before calling this method (the same applies for max locals).\n+     *\n+     * @return method object\n+     *\/\n+    public Method getMethod() {\n+        final String signature = getSignature();\n+        final ConstantPoolGen _cp = super.getConstantPool();\n+        final int name_index = _cp.addUtf8(super.getName());\n+        final int signature_index = _cp.addUtf8(signature);\n+        \/* Also updates positions of instructions, i.e., their indices\n+         *\/\n+        byte[] byte_code = null;\n+        if (il != null) {\n+            byte_code = il.getByteCode();\n+        }\n+        LineNumberTable lnt = null;\n@@ -809,2 +679,1 @@\n-        \/*\n-         * Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)\n+        \/* Create LocalVariableTable and LineNumberTable attributes (for debuggers, e.g.)\n@@ -812,3 +681,3 @@\n-        if (!variableList.isEmpty() && !stripAttributes) {\n-            updateLocalVariableTable(getLocalVariableTable(cp));\n-            addCodeAttribute(lvt = getLocalVariableTable(cp));\n+        if ((variableList.size() > 0) && !stripAttributes) {\n+            updateLocalVariableTable(getLocalVariableTable(_cp));\n+            addCodeAttribute(lvt = getLocalVariableTable(_cp));\n@@ -817,2 +686,1 @@\n-            \/\/ LocalVariable length in LocalVariableTypeTable is not updated automatically. It's a difference with\n-            \/\/ LocalVariableTable.\n+            \/\/ LocalVariable length in LocalVariableTypeTable is not updated automatically. It's a difference with LocalVariableTable.\n@@ -824,2 +692,2 @@\n-        if (!lineNumberList.isEmpty() && !stripAttributes) {\n-            addCodeAttribute(lnt = getLineNumberTable(cp));\n+        if ((lineNumberList.size() > 0) && !stripAttributes) {\n+            addCodeAttribute(lnt = getLineNumberTable(_cp));\n@@ -827,3 +695,2 @@\n-        final Attribute[] codeAttrs = getCodeAttributes();\n-        \/*\n-         * Each attribute causes 6 additional header bytes\n+        final Attribute[] code_attrs = getCodeAttributes();\n+        \/* Each attribute causes 6 additional header bytes\n@@ -831,3 +698,3 @@\n-        int attrsLen = 0;\n-        for (final Attribute codeAttr : codeAttrs) {\n-            attrsLen += codeAttr.getLength() + 6;\n+        int attrs_len = 0;\n+        for (final Attribute code_attr : code_attrs) {\n+            attrs_len += code_attr.getLength() + 6;\n@@ -835,2 +702,2 @@\n-        final CodeException[] cExc = getCodeExceptions();\n-        final int excLen = cExc.length * 8; \/\/ Every entry takes 8 bytes\n+        final CodeException[] c_exc = getCodeExceptions();\n+        final int exc_len = c_exc.length * 8; \/\/ Every entry takes 8 bytes\n@@ -838,1 +705,1 @@\n-        if (byteCode != null && !isAbstract() && !isNative()) {\n+        if ((il != null) && !isAbstract() && !isNative()) {\n@@ -846,4 +713,4 @@\n-            code = new Code(cp.addUtf8(\"Code\"), 8 + byteCode.length + \/\/ prologue byte code\n-                2 + excLen + \/\/ exceptions\n-                2 + attrsLen, \/\/ attributes\n-                maxStack, maxLocals, byteCode, cExc, codeAttrs, cp.getConstantPool());\n+            code = new Code(_cp.addUtf8(\"Code\"), 8 + byte_code.length + \/\/ prologue byte code\n+                    2 + exc_len + \/\/ exceptions\n+                    2 + attrs_len, \/\/ attributes\n+                    maxStack, maxLocals, byte_code, c_exc, code_attrs, _cp.getConstantPool());\n@@ -852,2 +719,2 @@\n-        final Attribute[] annotations = addRuntimeAnnotationsAsAttribute(cp);\n-        final Attribute[] parameterAnnotations = addRuntimeParameterAnnotationsAsAttribute(cp);\n+        final Attribute[] annotations = addRuntimeAnnotationsAsAttribute(_cp);\n+        final Attribute[] parameterAnnotations = addRuntimeParameterAnnotationsAsAttribute(_cp);\n@@ -855,3 +722,3 @@\n-        if (!throwsList.isEmpty()) {\n-            addAttribute(et = getExceptionTable(cp));\n-            \/\/ Add 'Exceptions' if there are \"throws\" clauses\n+        if (throwsList.size() > 0) {\n+            addAttribute(et = getExceptionTable(_cp));\n+            \/\/ Add `Exceptions' if there are \"throws\" clauses\n@@ -859,1 +726,2 @@\n-        final Method m = new Method(super.getAccessFlags(), nameIndex, signatureIndex, getAttributes(), cp.getConstantPool());\n+        final Method m = new Method(super.getAccessFlags(), name_index, signature_index, getAttributes(), _cp\n+                .getConstantPool());\n@@ -881,2 +749,16 @@\n-    public Type getReturnType() {\n-        return getType();\n+    private void updateLocalVariableTable(final LocalVariableTable a) {\n+        final LocalVariable[] lv = a.getLocalVariableTable();\n+        removeLocalVariables();\n+        for (final LocalVariable l : lv) {\n+            InstructionHandle start = il.findHandle(l.getStartPC());\n+            final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());\n+            \/\/ Repair malformed handles\n+            if (null == start) {\n+                start = il.getStart();\n+            }\n+            \/\/ end == null => live to end of method\n+            \/\/ Since we are recreating the LocalVaraible, we must\n+            \/\/ propagate the orig_index to new copy.\n+            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l\n+                    .getIndex(), start, end, l.getOrigIndex());\n+        }\n@@ -885,3 +767,14 @@\n-    @Override\n-    public String getSignature() {\n-        return Type.getMethodSignature(super.getType(), argTypes);\n+    private void adjustLocalVariableTypeTable(final LocalVariableTable lvt) {\n+        final LocalVariable[] lv = lvt.getLocalVariableTable();\n+        final LocalVariable[] lvg = localVariableTypeTable.getLocalVariableTypeTable();\n+\n+        for (final LocalVariable element : lvg) {\n+            for (final LocalVariable l : lv) {\n+                if (element.getName().equals(l.getName()) && element.getIndex() == l.getOrigIndex()) {\n+                    element.setLength(l.getLength());\n+                    element.setStartPC(l.getStartPC());\n+                    element.setIndex(l.getIndex());\n+                    break;\n+                }\n+            }\n+        }\n@@ -890,0 +783,1 @@\n+\n@@ -891,4 +785,3 @@\n-     * Return value as defined by given BCELComparator strategy. By default return the hashcode of the method's name XOR\n-     * signature.\n-     *\n-     * @see Object#hashCode()\n+     * Remove all NOPs from the instruction list (if possible) and update every\n+     * object referring to them, i.e., branch instructions, local variables and\n+     * exception handlers.\n@@ -896,9 +789,19 @@\n-    @Override\n-    public int hashCode() {\n-        return bcelComparator.hashCode(this);\n-    }\n-\n-    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray) {\n-        final List<AnnotationEntryGen> result = new ArrayList<>();\n-        for (final AnnotationEntry element : mutableArray) {\n-            result.add(new AnnotationEntryGen(element, getConstantPool(), false));\n+    public void removeNOPs() {\n+        if (il != null) {\n+            InstructionHandle next;\n+            \/* Check branch instructions.\n+             *\/\n+            for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {\n+                next = ih.getNext();\n+                if ((next != null) && (ih.getInstruction() instanceof NOP)) {\n+                    try {\n+                        il.delete(ih);\n+                    } catch (final TargetLostException e) {\n+                        for (final InstructionHandle target : e.getTargets()) {\n+                            for (final InstructionTargeter targeter : target.getTargeters()) {\n+                                targeter.updateTarget(target, next);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n@@ -906,1 +809,0 @@\n-        return result;\n@@ -909,0 +811,1 @@\n+\n@@ -910,1 +813,1 @@\n-     * Remove a code attribute.\n+     * Set maximum number of local variables.\n@@ -912,2 +815,2 @@\n-    public void removeCodeAttribute(final Attribute a) {\n-        codeAttrsList.remove(a);\n+    public void setMaxLocals( final int m ) {\n+        maxLocals = m;\n@@ -916,6 +819,3 @@\n-    \/**\n-     * Remove all code attributes.\n-     *\/\n-    public void removeCodeAttributes() {\n-        localVariableTypeTable = null;\n-        codeAttrsList.clear();\n+\n+    public int getMaxLocals() {\n+        return maxLocals;\n@@ -924,0 +824,1 @@\n+\n@@ -925,1 +826,1 @@\n-     * Remove an exception.\n+     * Set maximum stack size for this method.\n@@ -927,2 +828,2 @@\n-    public void removeException(final String c) {\n-        throwsList.remove(c);\n+    public void setMaxStack( final int m ) { \/\/ TODO could be package-protected?\n+        maxStack = m;\n@@ -931,5 +832,3 @@\n-    \/**\n-     * Remove an exception handler.\n-     *\/\n-    public void removeExceptionHandler(final CodeExceptionGen c) {\n-        exceptionList.remove(c);\n+\n+    public int getMaxStack() {\n+        return maxStack;\n@@ -938,2 +837,2 @@\n-    \/**\n-     * Remove all line numbers.\n+\n+    \/** @return class that contains this method\n@@ -941,2 +840,2 @@\n-    public void removeExceptionHandlers() {\n-        exceptionList.clear();\n+    public String getClassName() {\n+        return className;\n@@ -945,5 +844,3 @@\n-    \/**\n-     * Remove all exceptions.\n-     *\/\n-    public void removeExceptions() {\n-        throwsList.clear();\n+\n+    public void setClassName( final String class_name ) { \/\/ TODO could be package-protected?\n+        this.className = class_name;\n@@ -952,5 +849,3 @@\n-    \/**\n-     * Remove a line number.\n-     *\/\n-    public void removeLineNumber(final LineNumberGen l) {\n-        lineNumberList.remove(l);\n+\n+    public void setReturnType( final Type return_type ) {\n+        setType(return_type);\n@@ -959,5 +854,3 @@\n-    \/**\n-     * Remove all line numbers.\n-     *\/\n-    public void removeLineNumbers() {\n-        lineNumberList.clear();\n+\n+    public Type getReturnType() {\n+        return getType();\n@@ -966,6 +859,3 @@\n-    \/**\n-     * Remove a local variable, its slot will not be reused, if you do not use addLocalVariable with an explicit index\n-     * argument.\n-     *\/\n-    public void removeLocalVariable(final LocalVariableGen l) {\n-        variableList.remove(l);\n+\n+    public void setArgumentTypes( final Type[] arg_types ) {\n+        this.argTypes = arg_types;\n@@ -974,5 +864,3 @@\n-    \/**\n-     * Remove all local variables.\n-     *\/\n-    public void removeLocalVariables() {\n-        variableList.clear();\n+\n+    public Type[] getArgumentTypes() {\n+        return argTypes.clone();\n@@ -981,5 +869,3 @@\n-    \/**\n-     * Remove the LocalVariableTypeTable\n-     *\/\n-    public void removeLocalVariableTypeTable() {\n-        localVariableTypeTable = null;\n+\n+    public void setArgumentType( final int i, final Type type ) {\n+        argTypes[i] = type;\n@@ -988,25 +874,3 @@\n-    \/**\n-     * Remove all NOPs from the instruction list (if possible) and update every object referring to them, i.e., branch\n-     * instructions, local variables and exception handlers.\n-     *\/\n-    public void removeNOPs() {\n-        if (il != null) {\n-            InstructionHandle next;\n-            \/*\n-             * Check branch instructions.\n-             *\/\n-            for (InstructionHandle ih = il.getStart(); ih != null; ih = next) {\n-                next = ih.getNext();\n-                if (next != null && ih.getInstruction() instanceof NOP) {\n-                    try {\n-                        il.delete(ih);\n-                    } catch (final TargetLostException e) {\n-                        for (final InstructionHandle target : e.getTargets()) {\n-                            for (final InstructionTargeter targeter : target.getTargeters()) {\n-                                targeter.updateTarget(target, next);\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n+\n+    public Type getArgumentType( final int i ) {\n+        return argTypes[i];\n@@ -1015,7 +879,3 @@\n-    \/**\n-     * Remove observer for this object.\n-     *\/\n-    public void removeObserver(final MethodObserver o) {\n-        if (observers != null) {\n-            observers.remove(o);\n-        }\n+\n+    public void setArgumentNames( final String[] arg_names ) {\n+        this.argNames = arg_names;\n@@ -1024,10 +884,3 @@\n-    \/**\n-     * Would prefer to make this private, but need a way to test if client is using BCEL version 6.5.0 or later that\n-     * contains fix for BCEL-329.\n-     *\n-     * @since 6.5.0\n-     *\/\n-    public void removeRuntimeAttributes(final Attribute[] attrs) {\n-        for (final Attribute attr : attrs) {\n-            removeAttribute(attr);\n-        }\n+\n+    public String[] getArgumentNames() {\n+        return argNames.clone();\n@@ -1036,1 +889,2 @@\n-    public void setArgumentName(final int i, final String name) {\n+\n+    public void setArgumentName( final int i, final String name ) {\n@@ -1040,3 +894,0 @@\n-    public void setArgumentNames(final String[] argNames) {\n-        this.argNames = argNames;\n-    }\n@@ -1044,2 +895,2 @@\n-    public void setArgumentType(final int i, final Type type) {\n-        argTypes[i] = type;\n+    public String getArgumentName( final int i ) {\n+        return argNames[i];\n@@ -1048,3 +899,0 @@\n-    public void setArgumentTypes(final Type[] argTypes) {\n-        this.argTypes = argTypes;\n-    }\n@@ -1052,2 +900,2 @@\n-    public void setClassName(final String className) { \/\/ TODO could be package-protected?\n-        this.className = className;\n+    public InstructionList getInstructionList() {\n+        return il;\n@@ -1056,1 +904,2 @@\n-    public void setInstructionList(final InstructionList il) { \/\/ TODO could be package-protected?\n+\n+    public void setInstructionList( final InstructionList il ) { \/\/ TODO could be package-protected?\n@@ -1060,0 +909,7 @@\n+\n+    @Override\n+    public String getSignature() {\n+        return Type.getMethodSignature(super.getType(), argTypes);\n+    }\n+\n+\n@@ -1061,1 +917,1 @@\n-     * Compute maximum number of local variables.\n+     * Computes max. stack size by performing control flow analysis.\n@@ -1063,1 +919,1 @@\n-    public void setMaxLocals() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n+    public void setMaxStack() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n@@ -1065,1 +921,13 @@\n-            int max = isStatic() ? 0 : 1;\n+            maxStack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());\n+        } else {\n+            maxStack = 0;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Compute maximum number of local variables.\n+     *\/\n+    public void setMaxLocals() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n+        if (il != null) {\n+            int max = isStatic() ? 0 : 1;\n@@ -1067,2 +935,2 @@\n-                for (final Type argType : argTypes) {\n-                    max += argType.getSize();\n+                for (final Type arg_type : argTypes) {\n+                    max += arg_type.getSize();\n@@ -1073,2 +941,4 @@\n-                if (ins instanceof LocalVariableInstruction || ins instanceof RET || ins instanceof IINC) {\n-                    final int index = ((IndexedInstruction) ins).getIndex() + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();\n+                if ((ins instanceof LocalVariableInstruction) || (ins instanceof RET)\n+                        || (ins instanceof IINC)) {\n+                    final int index = ((IndexedInstruction) ins).getIndex()\n+                            + ((TypedInstruction) ins).getType(super.getConstantPool()).getSize();\n@@ -1086,2 +956,3 @@\n-    \/**\n-     * Set maximum number of local variables.\n+\n+    \/** Do not\/Do produce attributes code attributesLineNumberTable and\n+     * LocalVariableTable, like javac -O\n@@ -1089,2 +960,2 @@\n-    public void setMaxLocals(final int m) {\n-        maxLocals = m;\n+    public void stripAttributes( final boolean flag ) {\n+        stripAttributes = flag;\n@@ -1093,0 +964,48 @@\n+    static final class BranchTarget {\n+\n+        final InstructionHandle target;\n+        final int stackDepth;\n+\n+\n+        BranchTarget(final InstructionHandle target, final int stackDepth) {\n+            this.target = target;\n+            this.stackDepth = stackDepth;\n+        }\n+    }\n+\n+    static final class BranchStack {\n+\n+        private final Stack<BranchTarget> branchTargets = new Stack<>();\n+        private final Map<InstructionHandle, BranchTarget> visitedTargets = new HashMap<>();\n+\n+\n+        public void push( final InstructionHandle target, final int stackDepth ) {\n+            if (visited(target)) {\n+                return;\n+            }\n+            branchTargets.push(visit(target, stackDepth));\n+        }\n+\n+\n+        public BranchTarget pop() {\n+            if (!branchTargets.empty()) {\n+                final BranchTarget bt = branchTargets.pop();\n+                return bt;\n+            }\n+            return null;\n+        }\n+\n+\n+        private BranchTarget visit( final InstructionHandle target, final int stackDepth ) {\n+            final BranchTarget bt = new BranchTarget(target, stackDepth);\n+            visitedTargets.put(target, bt);\n+            return bt;\n+        }\n+\n+\n+        private boolean visited( final InstructionHandle target ) {\n+            return visitedTargets.get(target) != null;\n+        }\n+    }\n+\n+\n@@ -1094,1 +1013,3 @@\n-     * Computes max. stack size by performing control flow analysis.\n+     * Computes stack usage of an instruction list by performing control flow analysis.\n+     *\n+     * @return maximum stack depth used by method\n@@ -1096,5 +1017,67 @@\n-    public void setMaxStack() { \/\/ TODO could be package-protected? (some tests would need repackaging)\n-        if (il != null) {\n-            maxStack = getMaxStack(super.getConstantPool(), il, getExceptionHandlers());\n-        } else {\n-            maxStack = 0;\n+    public static int getMaxStack( final ConstantPoolGen cp, final InstructionList il, final CodeExceptionGen[] et ) {\n+        final BranchStack branchTargets = new BranchStack();\n+        \/* Initially, populate the branch stack with the exception\n+         * handlers, because these aren't (necessarily) branched to\n+         * explicitly. in each case, the stack will have depth 1,\n+         * containing the exception object.\n+         *\/\n+        for (final CodeExceptionGen element : et) {\n+            final InstructionHandle handler_pc = element.getHandlerPC();\n+            if (handler_pc != null) {\n+                branchTargets.push(handler_pc, 1);\n+            }\n+        }\n+        int stackDepth = 0;\n+        int maxStackDepth = 0;\n+        InstructionHandle ih = il.getStart();\n+        while (ih != null) {\n+            final Instruction instruction = ih.getInstruction();\n+            final short opcode = instruction.getOpcode();\n+            final int delta = instruction.produceStack(cp) - instruction.consumeStack(cp);\n+            stackDepth += delta;\n+            if (stackDepth > maxStackDepth) {\n+                maxStackDepth = stackDepth;\n+            }\n+            \/\/ choose the next instruction based on whether current is a branch.\n+            if (instruction instanceof BranchInstruction) {\n+                final BranchInstruction branch = (BranchInstruction) instruction;\n+                if (instruction instanceof Select) {\n+                    \/\/ explore all of the select's targets. the default target is handled below.\n+                    final Select select = (Select) branch;\n+                    final InstructionHandle[] targets = select.getTargets();\n+                    for (final InstructionHandle target : targets) {\n+                        branchTargets.push(target, stackDepth);\n+                    }\n+                    \/\/ nothing to fall through to.\n+                    ih = null;\n+                } else if (!(branch instanceof IfInstruction)) {\n+                    \/\/ if an instruction that comes back to following PC,\n+                    \/\/ push next instruction, with stack depth reduced by 1.\n+                    if (opcode == Const.JSR || opcode == Const.JSR_W) {\n+                        branchTargets.push(ih.getNext(), stackDepth - 1);\n+                    }\n+                    ih = null;\n+                }\n+                \/\/ for all branches, the target of the branch is pushed on the branch stack.\n+                \/\/ conditional branches have a fall through case, selects don't, and\n+                \/\/ jsr\/jsr_w return to the next instruction.\n+                branchTargets.push(branch.getTarget(), stackDepth);\n+            } else {\n+                \/\/ check for instructions that terminate the method.\n+                if (opcode == Const.ATHROW || opcode == Const.RET\n+                        || (opcode >= Const.IRETURN && opcode <= Const.RETURN)) {\n+                    ih = null;\n+                }\n+            }\n+            \/\/ normal case, go to the next instruction.\n+            if (ih != null) {\n+                ih = ih.getNext();\n+            }\n+            \/\/ if we have no more instructions, see if there are any deferred branches to explore.\n+            if (ih == null) {\n+                final BranchTarget bt = branchTargets.pop();\n+                if (bt != null) {\n+                    ih = bt.target;\n+                    stackDepth = bt.stackDepth;\n+                }\n+            }\n@@ -1102,0 +1085,1 @@\n+        return maxStackDepth;\n@@ -1104,2 +1088,4 @@\n-    \/**\n-     * Set maximum stack size for this method.\n+    private List<MethodObserver> observers;\n+\n+\n+    \/** Add observer for this object.\n@@ -1107,2 +1093,5 @@\n-    public void setMaxStack(final int m) { \/\/ TODO could be package-protected?\n-        maxStack = m;\n+    public void addObserver( final MethodObserver o ) {\n+        if (observers == null) {\n+            observers = new ArrayList<>();\n+        }\n+        observers.add(o);\n@@ -1111,2 +1100,7 @@\n-    public void setReturnType(final Type returnType) {\n-        setType(returnType);\n+\n+    \/** Remove observer for this object.\n+     *\/\n+    public void removeObserver( final MethodObserver o ) {\n+        if (observers != null) {\n+            observers.remove(o);\n+        }\n@@ -1115,2 +1109,4 @@\n-    \/**\n-     * Do not\/Do produce attributes code attributesLineNumberTable and LocalVariableTable, like javac -O\n+\n+    \/** Call notify() method on all observers. This method is not called\n+     * automatically whenever the state has changed, but has to be\n+     * called by the user after he has finished editing the object.\n@@ -1118,2 +1114,6 @@\n-    public void stripAttributes(final boolean flag) {\n-        stripAttributes = flag;\n+    public void update() {\n+        if (observers != null) {\n+            for (final MethodObserver observer : observers) {\n+                observer.notify(this);\n+            }\n+        }\n@@ -1122,0 +1122,1 @@\n+\n@@ -1123,2 +1124,2 @@\n-     * Return string representation close to declaration format, 'public static void main(String[]) throws IOException',\n-     * e.g.\n+     * Return string representation close to declaration format,\n+     * `public static void main(String[]) throws IOException', e.g.\n@@ -1132,1 +1133,2 @@\n-        signature = Utility.methodSignatureToString(signature, super.getName(), access, true, getLocalVariableTable(super.getConstantPool()));\n+        signature = Utility.methodSignatureToString(signature, super.getName(), access, true,\n+                getLocalVariableTable(super.getConstantPool()));\n@@ -1135,1 +1137,1 @@\n-            if (!(a instanceof Code || a instanceof ExceptionTable)) {\n+            if (!((a instanceof Code) || (a instanceof ExceptionTable))) {\n@@ -1140,1 +1142,1 @@\n-        if (!throwsList.isEmpty()) {\n+        if (throwsList.size() > 0) {\n@@ -1148,0 +1150,15 @@\n+\n+    \/** @return deep copy of this method\n+     *\/\n+    public MethodGen copy( final String className, final ConstantPoolGen cp ) {\n+        final Method m = ((MethodGen) clone()).getMethod();\n+        final MethodGen mg = new MethodGen(m, className, super.getConstantPool());\n+        if (super.getConstantPool() != cp) {\n+            mg.setConstantPool(cp);\n+            mg.getInstructionList().replaceConstantPool(super.getConstantPool(), cp);\n+        }\n+        return mg;\n+    }\n+\n+    \/\/J5TODO: Should paramAnnotations be an array of arrays? Rather than an array of lists, this\n+    \/\/ is more likely to suggest to the caller it is readonly (which a List does not).\n@@ -1149,2 +1166,2 @@\n-     * Call notify() method on all observers. This method is not called automatically whenever the state has changed, but\n-     * has to be called by the user after they have finished editing the object.\n+     * Return a list of AnnotationGen objects representing parameter annotations\n+     * @since 6.0\n@@ -1152,5 +1169,4 @@\n-    public void update() {\n-        if (observers != null) {\n-            for (final MethodObserver observer : observers) {\n-                observer.notify(this);\n-            }\n+    public List<AnnotationEntryGen> getAnnotationsOnParameter(final int i) {\n+        ensureExistingParameterAnnotationsUnpacked();\n+        if (!hasParameterAnnotations || i > argTypes.length) {\n+            return null;\n@@ -1158,0 +1174,1 @@\n+        return paramAnnotations[i];\n@@ -1160,8 +1177,47 @@\n-    private void updateLocalVariableTable(final LocalVariableTable a) {\n-        removeLocalVariables();\n-        for (final LocalVariable l : a.getLocalVariableTable()) {\n-            InstructionHandle start = il.findHandle(l.getStartPC());\n-            final InstructionHandle end = il.findHandle(l.getStartPC() + l.getLength());\n-            \/\/ Repair malformed handles\n-            if (null == start) {\n-                start = il.getStart();\n+    \/**\n+     * Goes through the attributes on the method and identifies any that are\n+     * RuntimeParameterAnnotations, extracting their contents and storing them\n+     * as parameter annotations. There are two kinds of parameter annotation -\n+     * visible and invisible. Once they have been unpacked, these attributes are\n+     * deleted. (The annotations will be rebuilt as attributes when someone\n+     * builds a Method object out of this MethodGen object).\n+     *\/\n+    private void ensureExistingParameterAnnotationsUnpacked()\n+    {\n+        if (haveUnpackedParameterAnnotations) {\n+            return;\n+        }\n+        \/\/ Find attributes that contain parameter annotation data\n+        final Attribute[] attrs = getAttributes();\n+        ParameterAnnotations paramAnnVisAttr = null;\n+        ParameterAnnotations paramAnnInvisAttr = null;\n+        for (final Attribute attribute : attrs) {\n+            if (attribute instanceof ParameterAnnotations)\n+            {\n+                \/\/ Initialize paramAnnotations\n+                if (!hasParameterAnnotations)\n+                {\n+                    @SuppressWarnings({\"rawtypes\", \"unchecked\"}) \/\/ OK\n+                    final List<AnnotationEntryGen>[] parmList = new List[argTypes.length];\n+                    paramAnnotations = parmList;\n+                    for (int j = 0; j < argTypes.length; j++) {\n+                        paramAnnotations[j] = new ArrayList<>();\n+                    }\n+                }\n+                hasParameterAnnotations = true;\n+                final ParameterAnnotations rpa = (ParameterAnnotations) attribute;\n+                if (rpa instanceof RuntimeVisibleParameterAnnotations) {\n+                    paramAnnVisAttr = rpa;\n+                } else {\n+                    paramAnnInvisAttr = rpa;\n+                }\n+                final ParameterAnnotationEntry[] parameterAnnotationEntries = rpa.getParameterAnnotationEntries();\n+                for (int j = 0; j < parameterAnnotationEntries.length; j++)\n+                {\n+                    \/\/ This returns Annotation[] ...\n+                    final ParameterAnnotationEntry immutableArray = rpa.getParameterAnnotationEntries()[j];\n+                    \/\/ ... which needs transforming into an AnnotationGen[] ...\n+                    final List<AnnotationEntryGen> mutable = makeMutableVersion(immutableArray.getAnnotationEntries());\n+                    \/\/ ... then add these to any we already know about\n+                    paramAnnotations[j].addAll(mutable);\n+                }\n@@ -1169,4 +1225,0 @@\n-            \/\/ end == null => live to end of method\n-            \/\/ Since we are recreating the LocalVaraible, we must\n-            \/\/ propagate the orig_index to new copy.\n-            addLocalVariable(l.getName(), Type.getType(l.getSignature()), l.getIndex(), start, end, l.getOrigIndex());\n@@ -1174,0 +1226,81 @@\n+        if (paramAnnVisAttr != null) {\n+            removeAttribute(paramAnnVisAttr);\n+        }\n+        if (paramAnnInvisAttr != null) {\n+            removeAttribute(paramAnnInvisAttr);\n+        }\n+        haveUnpackedParameterAnnotations = true;\n+    }\n+\n+    private List<AnnotationEntryGen> makeMutableVersion(final AnnotationEntry[] mutableArray)\n+    {\n+        final List<AnnotationEntryGen> result = new ArrayList<>();\n+        for (final AnnotationEntry element : mutableArray) {\n+            result.add(new AnnotationEntryGen(element, getConstantPool(),\n+                    false));\n+        }\n+        return result;\n+    }\n+\n+    public void addParameterAnnotation(final int parameterIndex,\n+            final AnnotationEntryGen annotation)\n+    {\n+        ensureExistingParameterAnnotationsUnpacked();\n+        if (!hasParameterAnnotations)\n+        {\n+            @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n+            final List<AnnotationEntryGen>[] parmList = new List[argTypes.length];\n+            paramAnnotations = parmList;\n+            hasParameterAnnotations = true;\n+        }\n+        final List<AnnotationEntryGen> existingAnnotations = paramAnnotations[parameterIndex];\n+        if (existingAnnotations != null)\n+        {\n+            existingAnnotations.add(annotation);\n+        }\n+        else\n+        {\n+            final List<AnnotationEntryGen> l = new ArrayList<>();\n+            l.add(annotation);\n+            paramAnnotations[parameterIndex] = l;\n+        }\n+    }\n+\n+    \/**\n+     * @return Comparison strategy object\n+     *\/\n+    public static BCELComparator getComparator() {\n+        return bcelComparator;\n+    }\n+\n+\n+    \/**\n+     * @param comparator Comparison strategy object\n+     *\/\n+    public static void setComparator( final BCELComparator comparator ) {\n+        bcelComparator = comparator;\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default two MethodGen objects are said to be equal when\n+     * their names and signatures are equal.\n+     *\n+     * @see java.lang.Object#equals(java.lang.Object)\n+     *\/\n+    @Override\n+    public boolean equals( final Object obj ) {\n+        return bcelComparator.equals(this, obj);\n+    }\n+\n+\n+    \/**\n+     * Return value as defined by given BCELComparator strategy.\n+     * By default return the hashcode of the method's name XOR signature.\n+     *\n+     * @see java.lang.Object#hashCode()\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return bcelComparator.hashCode(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MethodGen.java","additions":859,"deletions":726,"binary":false,"changes":1585,"status":"modified"},{"patch":"@@ -25,2 +25,3 @@\n- * Implement this interface if you're interested in changes to a MethodGen object and register yourself with\n- * addObserver().\n+ * Implement this interface if you're interested in changes to a MethodGen object\n+ * and register yourself with addObserver().\n+ *\n@@ -30,1 +31,1 @@\n-    void notify(MethodGen method);\n+    void notify( MethodGen method );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/MethodObserver.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+ * <PRE>Stack: ... -&gt; ..., objectref<\/PRE>\n@@ -29,3 +30,0 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., objectref\n- * <\/PRE>\n@@ -33,1 +31,2 @@\n-public class NEW extends CPInstruction implements LoadClass, AllocationInstruction, ExceptionThrower, StackProducer {\n+public class NEW extends CPInstruction implements LoadClass, AllocationInstruction,\n+        ExceptionThrower, StackProducer {\n@@ -36,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -41,0 +41,1 @@\n+\n@@ -45,0 +46,15 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION,\n+            ExceptionConst.ILLEGAL_ACCESS_ERROR,\n+            ExceptionConst.INSTANTIATION_ERROR);\n+    }\n+\n+\n+    @Override\n+    public ObjectType getLoadClassType( final ConstantPoolGen cpg ) {\n+        return (ObjectType) getType(cpg);\n+    }\n+\n+\n@@ -46,2 +62,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -52,1 +70,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -61,11 +79,0 @@\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_CLASS_AND_INTERFACE_RESOLUTION, ExceptionConst.ILLEGAL_ACCESS_ERROR,\n-            ExceptionConst.INSTANTIATION_ERROR);\n-    }\n-\n-    @Override\n-    public ObjectType getLoadClassType(final ConstantPoolGen cpg) {\n-        return (ObjectType) getType(cpg);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NEW.java","additions":26,"deletions":19,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -30,6 +30,2 @@\n- * NEWARRAY - Create new array of basic type (int, short, ...)\n- *\n- * <PRE>\n- * Stack: ..., count -&gt; ..., arrayref\n- * <\/PRE>\n- *\n+ * NEWARRAY -  Create new array of basic type (int, short, ...)\n+ * <PRE>Stack: ..., count -&gt; ..., arrayref<\/PRE>\n@@ -37,0 +33,1 @@\n+ *\n@@ -39,1 +36,2 @@\n-public class NEWARRAY extends Instruction implements AllocationInstruction, ExceptionThrower, StackProducer {\n+public class NEWARRAY extends Instruction implements AllocationInstruction, ExceptionThrower,\n+        StackProducer {\n@@ -43,0 +41,1 @@\n+\n@@ -44,1 +43,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -49,3 +49,0 @@\n-    public NEWARRAY(final BasicType type) {\n-        this(type.getType());\n-    }\n@@ -58,12 +55,3 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitAllocationInstruction(this);\n-        v.visitExceptionThrower(this);\n-        v.visitStackProducer(this);\n-        v.visitNEWARRAY(this);\n+\n+    public NEWARRAY(final BasicType type) {\n+        this(type.getType());\n@@ -72,0 +60,1 @@\n+\n@@ -74,1 +63,0 @@\n-     *\n@@ -78,1 +66,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -83,3 +71,6 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION};\n+\n+    \/**\n+     * @return numeric code for basic element type\n+     *\/\n+    public final byte getTypecode() {\n+        return type;\n@@ -88,0 +79,1 @@\n+\n@@ -95,0 +87,1 @@\n+\n@@ -96,1 +89,1 @@\n-     * @return numeric code for basic element type\n+     * @return mnemonic for instruction\n@@ -98,2 +91,3 @@\n-    public final byte getTypecode() {\n-        return type;\n+    @Override\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + com.sun.org.apache.bcel.internal.Const.getTypeName(type);\n@@ -102,0 +96,1 @@\n+\n@@ -106,1 +101,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -111,0 +106,9 @@\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.NEGATIVE_ARRAY_SIZE_EXCEPTION\n+        };\n+    }\n+\n+\n@@ -112,1 +116,6 @@\n-     * @return mnemonic for instruction\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -115,2 +124,5 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + com.sun.org.apache.bcel.internal.Const.getTypeName(type);\n+    public void accept( final Visitor v ) {\n+        v.visitAllocationInstruction(this);\n+        v.visitExceptionThrower(this);\n+        v.visitStackProducer(this);\n+        v.visitNEWARRAY(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NEWARRAY.java","additions":47,"deletions":35,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -33,0 +34,1 @@\n+\n@@ -34,2 +36,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -40,1 +44,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NOP.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,2 @@\n- * Super class for FieldOrMethod and INVOKEDYNAMIC, since they both have names and signatures\n+ * Super class for FieldOrMethod and INVOKEDYNAMIC, since they both have\n+ * names and signatures\n@@ -37,0 +38,1 @@\n+        super();\n@@ -43,9 +45,0 @@\n-    \/**\n-     * @return name of referenced method\/field.\n-     *\/\n-    public String getName(final ConstantPoolGen cpg) {\n-        final ConstantPool cp = cpg.getConstantPool();\n-        final ConstantNameAndType cnat = getNameAndType(cpg);\n-        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n-    }\n-\n@@ -55,1 +48,1 @@\n-        return (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n+        return  (ConstantNameAndType) cp.getConstant(cmr.getNameAndTypeIndex());\n@@ -57,3 +50,1 @@\n-\n-    \/**\n-     * @return signature of referenced method\/field.\n+    \/** @return signature of referenced method\/field.\n@@ -67,0 +58,8 @@\n+    \/** @return name of referenced method\/field.\n+     *\/\n+    public String getName(final ConstantPoolGen cpg) {\n+        final ConstantPool cp = cpg.getConstantPool();\n+        final ConstantNameAndType cnat = getNameAndType(cpg);\n+        return ((ConstantUtf8) cp.getConstant(cnat.getNameIndex())).getBytes();\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NameSignatureInstruction.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denote entity that has both name and type. This is true for local variables, methods and fields.\n+ * Denote entity that has both name and type. This is true for local variables,\n+ * methods and fields.\n+ *\n@@ -31,0 +33,1 @@\n+\n@@ -33,1 +36,0 @@\n-    void setName(String name);\n@@ -35,1 +37,4 @@\n-    void setType(Type type);\n+    void setName( String name );\n+\n+\n+    void setType( Type type );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/NamedAndTyped.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -31,0 +30,1 @@\n+ *\n@@ -34,0 +34,2 @@\n+    private final String className; \/\/ Class name of type\n+\n@@ -35,4 +37,0 @@\n-     * Constructs a new instance.\n-     *\n-     * @param className fully qualified class name, e.g. java.lang.String\n-     * @return a new instance.\n@@ -45,2 +43,0 @@\n-    private final String className; \/\/ Class name of type\n-\n@@ -48,2 +44,0 @@\n-     * Constructs a new instance.\n-     *\n@@ -53,16 +47,2 @@\n-        super(Const.T_REFERENCE, \"L\" + Utility.packageToPath(className) + \";\");\n-        this.className = Utility.pathToPackage(className);\n-    }\n-\n-    \/**\n-     * Java Virtual Machine Specification edition 2,  5.4.4 Access Control\n-     *\n-     * @throws ClassNotFoundException if the class referenced by this type can't be found\n-     *\/\n-    public boolean accessibleTo(final ObjectType accessor) throws ClassNotFoundException {\n-        final JavaClass jc = Repository.lookupClass(className);\n-        if (jc.isPublic()) {\n-            return true;\n-        }\n-        final JavaClass acc = Repository.lookupClass(accessor.className);\n-        return acc.getPackageName().equals(jc.getPackageName());\n+        super(Const.T_REFERENCE, \"L\" + className.replace('.', '\/') + \";\");\n+        this.className = className.replace('\/', '.');\n@@ -71,7 +51,0 @@\n-    \/**\n-     * @return true if both type objects refer to the same class.\n-     *\/\n-    @Override\n-    public boolean equals(final Object type) {\n-        return type instanceof ObjectType && ((ObjectType) type).className.equals(className);\n-    }\n@@ -79,2 +52,1 @@\n-    \/**\n-     * @return name of referenced class\n+    \/** @return name of referenced class\n@@ -82,1 +54,0 @@\n-    @Override\n@@ -87,2 +58,2 @@\n-    \/**\n-     * @return a hash code value for the object.\n+\n+    \/** @return a hash code value for the object.\n@@ -95,0 +66,11 @@\n+\n+    \/** @return true if both type objects refer to the same class.\n+     *\/\n+    @Override\n+    public boolean equals( final Object type ) {\n+        return (type instanceof ObjectType)\n+                ? ((ObjectType) type).className.equals(className)\n+                : false;\n+    }\n+\n+\n@@ -96,3 +78,5 @@\n-     * If \"this\" doesn't reference a class, it references an interface or a non-existant entity.\n-     * @deprecated (since 6.0) this method returns an inaccurate result if the class or interface referenced cannot be\n-     *             found: use referencesClassExact() instead\n+     * If \"this\" doesn't reference a class, it references an interface\n+     * or a non-existant entity.\n+     * @deprecated (since 6.0) this method returns an inaccurate result\n+     *   if the class or interface referenced cannot\n+     *   be found: use referencesClassExact() instead\n@@ -110,10 +94,0 @@\n-    \/**\n-     * Return true if this type references a class, false if it references an interface.\n-     *\n-     * @return true if the type references a class, false if it references an interface\n-     * @throws ClassNotFoundException if the class or interface referenced by this type can't be found\n-     *\/\n-    public boolean referencesClassExact() throws ClassNotFoundException {\n-        final JavaClass jc = Repository.lookupClass(className);\n-        return jc.isClass();\n-    }\n@@ -122,4 +96,5 @@\n-     * If \"this\" doesn't reference an interface, it references a class or a non-existant entity.\n-     *\n-     * @deprecated (since 6.0) this method returns an inaccurate result if the class or interface referenced cannot be\n-     *             found: use referencesInterfaceExact() instead\n+     * If \"this\" doesn't reference an interface, it references a class\n+     * or a non-existant entity.\n+     * @deprecated (since 6.0) this method returns an inaccurate result\n+     *   if the class or interface referenced cannot\n+     *   be found: use referencesInterfaceExact() instead\n@@ -137,0 +112,1 @@\n+\n@@ -138,4 +114,20 @@\n-     * Return true if this type references an interface, false if it references a class.\n-     *\n-     * @return true if the type references an interface, false if it references a class\n-     * @throws ClassNotFoundException if the class or interface referenced by this type can't be found\n+     * Return true if this type references a class,\n+     * false if it references an interface.\n+     * @return true if the type references a class, false if\n+     *   it references an interface\n+     * @throws ClassNotFoundException if the class or interface\n+     *   referenced by this type can't be found\n+     *\/\n+    public boolean referencesClassExact() throws ClassNotFoundException {\n+        final JavaClass jc = Repository.lookupClass(className);\n+        return jc.isClass();\n+    }\n+\n+\n+    \/**\n+     * Return true if this type references an interface,\n+     * false if it references a class.\n+     * @return true if the type references an interface, false if\n+     *   it references a class\n+     * @throws ClassNotFoundException if the class or interface\n+     *   referenced by this type can't be found\n@@ -148,0 +140,1 @@\n+\n@@ -150,2 +143,2 @@\n-     *\n-     * @throws ClassNotFoundException if any of this class's superclasses can't be found\n+     * @throws ClassNotFoundException if any of this class's superclasses\n+     *  can't be found\n@@ -153,1 +146,1 @@\n-    public boolean subclassOf(final ObjectType superclass) throws ClassNotFoundException {\n+    public boolean subclassOf( final ObjectType superclass ) throws ClassNotFoundException {\n@@ -159,0 +152,15 @@\n+\n+\n+    \/**\n+     * Java Virtual Machine Specification edition 2,  5.4.4 Access Control\n+     * @throws ClassNotFoundException if the class referenced by this type\n+     *   can't be found\n+     *\/\n+    public boolean accessibleTo( final ObjectType accessor ) throws ClassNotFoundException {\n+        final JavaClass jc = Repository.lookupClass(className);\n+        if (jc.isPublic()) {\n+            return true;\n+        }\n+        final JavaClass acc = Repository.lookupClass(accessor.className);\n+        return acc.getPackageName().equals(jc.getPackageName());\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ObjectType.java","additions":69,"deletions":61,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., word -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., word -&gt; ...<\/PRE>\n+ *\n@@ -37,0 +36,1 @@\n+\n@@ -38,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/POP.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,3 +27,2 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ..., word2, word1 -&gt; ...<\/PRE>\n+ *\n@@ -37,0 +36,1 @@\n+\n@@ -38,2 +38,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +46,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/POP2.java","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,2 +23,0 @@\n-import java.util.Objects;\n-\n@@ -28,2 +26,4 @@\n- * Wrapper class for push operations, which are implemented either as BIPUSH, LDC or xCONST_n instructions.\n- * @LastModified: Feb 2023\n+ * Wrapper class for push operations, which are implemented either as BIPUSH,\n+ * LDC or xCONST_n instructions.\n+ *\n+ * @LastModified: Jan 2020\n@@ -33,1 +33,2 @@\n-    private final Instruction instruction;\n+    private Instruction instruction;\n+\n@@ -36,1 +37,1 @@\n-     * Pushes an array type constant, for example {@code int[].class}, {@code String[].class}, and so on.\n+     * This constructor also applies for values of type short, char, byte\n@@ -38,3 +39,2 @@\n-     * @param cp generated constant pool.\n-     * @param value to be pushed.\n-     * @since 6.7.0\n+     * @param cp Constant pool\n+     * @param value to be pushed\n@@ -42,3 +42,7 @@\n-    public PUSH(final ConstantPoolGen cp, final ArrayType value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n+    public PUSH(final ConstantPoolGen cp, final int value) {\n+        if ((value >= -1) && (value <= 5)) {\n+            instruction = InstructionConst.getInstruction(Const.ICONST_0 + value);\n+        } else if (Instruction.isValidByte(value)) {\n+            instruction = new BIPUSH((byte) value);\n+        } else if (Instruction.isValidShort(value)) {\n+            instruction = new SIPUSH((short) value);\n@@ -46,1 +50,1 @@\n-            instruction = new LDC(cp.addArrayClass(value));\n+            instruction = new LDC(cp.addInteger(value));\n@@ -50,1 +54,2 @@\n-   \/**\n+\n+    \/**\n@@ -55,1 +60,0 @@\n-        Objects.requireNonNull(cp, \"cp\");\n@@ -59,0 +63,1 @@\n+\n@@ -63,2 +68,10 @@\n-    public PUSH(final ConstantPoolGen cp, final Boolean value) {\n-        this(cp, value.booleanValue());\n+    public PUSH(final ConstantPoolGen cp, final float value) {\n+        if (value == 0.0) {\n+            instruction = InstructionConst.FCONST_0;\n+        } else if (value == 1.0) {\n+            instruction = InstructionConst.FCONST_1;\n+        } else if (value == 2.0) {\n+            instruction = InstructionConst.FCONST_2;\n+        } else {\n+            instruction = new LDC(cp.addFloat(value));\n+        }\n@@ -67,0 +80,1 @@\n+\n@@ -68,3 +82,0 @@\n-     * creates a push object from a Character value. Warning: Make sure not to attempt to allow autoboxing to create this\n-     * value parameter, as an alternative constructor will be called\n-     *\n@@ -74,2 +85,8 @@\n-    public PUSH(final ConstantPoolGen cp, final Character value) {\n-        this(cp, value.charValue());\n+    public PUSH(final ConstantPoolGen cp, final long value) {\n+        if (value == 0) {\n+            instruction = InstructionConst.LCONST_0;\n+        } else if (value == 1) {\n+            instruction = InstructionConst.LCONST_1;\n+        } else {\n+            instruction = new LDC2_W(cp.addLong(value));\n+        }\n@@ -78,0 +95,1 @@\n+\n@@ -92,15 +110,0 @@\n-    \/**\n-     * @param cp Constant pool\n-     * @param value to be pushed\n-     *\/\n-    public PUSH(final ConstantPoolGen cp, final float value) {\n-        if (value == 0.0) {\n-            instruction = InstructionConst.FCONST_0;\n-        } else if (value == 1.0) {\n-            instruction = InstructionConst.FCONST_1;\n-        } else if (value == 2.0) {\n-            instruction = InstructionConst.FCONST_2;\n-        } else {\n-            instruction = new LDC(cp.addFloat(value));\n-        }\n-    }\n@@ -109,2 +112,0 @@\n-     * This constructor also applies for values of type short, char, byte\n-     *\n@@ -114,7 +115,3 @@\n-    public PUSH(final ConstantPoolGen cp, final int value) {\n-        if (value >= -1 && value <= 5) {\n-            instruction = InstructionConst.getInstruction(Const.ICONST_0 + value);\n-        } else if (Instruction.isValidByte(value)) {\n-            instruction = new BIPUSH((byte) value);\n-        } else if (Instruction.isValidShort(value)) {\n-            instruction = new SIPUSH((short) value);\n+    public PUSH(final ConstantPoolGen cp, final String value) {\n+        if (value == null) {\n+            instruction = InstructionConst.ACONST_NULL;\n@@ -122,1 +119,1 @@\n-            instruction = new LDC(cp.addInteger(value));\n+            instruction = new LDC(cp.addString(value));\n@@ -127,2 +124,4 @@\n-     * @param cp Constant pool\n-     * @param value to be pushed\n+     *\n+     * @param cp\n+     * @param value\n+     * @since 6.0\n@@ -130,5 +129,3 @@\n-    public PUSH(final ConstantPoolGen cp, final long value) {\n-        if (value == 0) {\n-            instruction = InstructionConst.LCONST_0;\n-        } else if (value == 1) {\n-            instruction = InstructionConst.LCONST_1;\n+    public PUSH(final ConstantPoolGen cp, final ObjectType value) {\n+        if (value == null) {\n+            instruction = InstructionConst.ACONST_NULL;\n@@ -136,1 +133,1 @@\n-            instruction = new LDC2_W(cp.addLong(value));\n+            instruction = new LDC(cp.addClass(value));\n@@ -145,1 +142,1 @@\n-        if (value instanceof Integer || value instanceof Short || value instanceof Byte) {\n+        if ((value instanceof Integer) || (value instanceof Short) || (value instanceof Byte)) {\n@@ -158,0 +155,1 @@\n+\n@@ -159,0 +157,2 @@\n+     * creates a push object from a Character value. Warning: Make sure not to attempt to allow\n+     * autoboxing to create this value parameter, as an alternative constructor will be called\n@@ -160,3 +160,2 @@\n-     * @param cp\n-     * @param value\n-     * @since 6.0\n+     * @param cp Constant pool\n+     * @param value to be pushed\n@@ -164,6 +163,2 @@\n-    public PUSH(final ConstantPoolGen cp, final ObjectType value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n-        } else {\n-            instruction = new LDC(cp.addClass(value));\n-        }\n+    public PUSH(final ConstantPoolGen cp, final Character value) {\n+        this(cp, value.charValue());\n@@ -172,0 +167,1 @@\n+\n@@ -176,6 +172,2 @@\n-    public PUSH(final ConstantPoolGen cp, final String value) {\n-        if (value == null) {\n-            instruction = InstructionConst.ACONST_NULL;\n-        } else {\n-            instruction = new LDC(cp.addString(value));\n-        }\n+    public PUSH(final ConstantPoolGen cp, final Boolean value) {\n+        this(cp, value.booleanValue());\n@@ -184,3 +176,0 @@\n-    public Instruction getInstruction() {\n-        return instruction;\n-    }\n@@ -193,0 +182,6 @@\n+\n+    public Instruction getInstruction() {\n+        return instruction;\n+    }\n+\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUSH.java","additions":70,"deletions":75,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -29,5 +29,1 @@\n- *\n- * <PRE>\n- * Stack: ..., objectref, value -&gt; ...\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., objectref, value -&gt; ...<\/PRE>\n@@ -35,0 +31,1 @@\n+ * <PRE>Stack: ..., objectref, value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -36,3 +33,0 @@\n- * <PRE>\n- * Stack: ..., objectref, value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -43,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +43,1 @@\n+\n@@ -52,0 +48,15 @@\n+\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg) + 1;\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.NULL_POINTER_EXCEPTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +64,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +72,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,11 +83,0 @@\n-\n-    @Override\n-    public int consumeStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg) + 1;\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.NULL_POINTER_EXCEPTION,\n-            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUTFIELD.java","additions":25,"deletions":23,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -29,5 +29,1 @@\n- *\n- * <PRE>\n- * Stack: ..., value -&gt; ...\n- * <\/PRE>\n- *\n+ * <PRE>Stack: ..., value -&gt; ...<\/PRE>\n@@ -35,0 +31,1 @@\n+ * <PRE>Stack: ..., value.word1, value.word2 -&gt; ...<\/PRE>\n@@ -36,3 +33,0 @@\n- * <PRE>\n- * Stack: ..., value.word1, value.word2 -&gt; ...\n- * <\/PRE>\n@@ -43,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -48,0 +43,1 @@\n+\n@@ -52,0 +48,14 @@\n+\n+    @Override\n+    public int consumeStack( final ConstantPoolGen cpg ) {\n+        return getFieldSize(cpg);\n+    }\n+\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION,\n+            ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n+    }\n+\n+\n@@ -53,2 +63,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -59,1 +71,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n@@ -70,10 +82,0 @@\n-\n-    @Override\n-    public int consumeStack(final ConstantPoolGen cpg) {\n-        return getFieldSize(cpg);\n-    }\n-\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return ExceptionConst.createExceptions(ExceptionConst.EXCS.EXCS_FIELD_AND_METHOD_RESOLUTION, ExceptionConst.INCOMPATIBLE_CLASS_CHANGE_ERROR);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PUTSTATIC.java","additions":24,"deletions":22,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * Denotes an unparameterized instruction to pop a value on top from the stack, such as ISTORE, POP, PUTSTATIC.\n+ * Denotes an unparameterized instruction to pop a value on top from the stack,\n+ * such as ISTORE, POP, PUTSTATIC.\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PopInstruction.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -25,3 +25,2 @@\n- * Denotes an unparameterized instruction to produce a value on top of the stack, such as ILOAD, LDC, SIPUSH, DUP,\n- * ICONST, etc.\n- *\n+ * Denotes an unparameterized instruction to produce a value on top of the stack,\n+ * such as ILOAD, LDC, SIPUSH, DUP, ICONST, etc.\n@@ -29,0 +28,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/PushInstruction.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,3 +32,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ...\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ...<\/PRE>\n+ *\n@@ -41,0 +40,1 @@\n+\n@@ -42,1 +42,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -47,0 +48,1 @@\n+\n@@ -52,10 +54,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitRET(this);\n-    }\n@@ -65,1 +57,0 @@\n-     *\n@@ -69,1 +60,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -81,7 +72,0 @@\n-    \/**\n-     * @return index of local variable containg the return address\n-     *\/\n-    @Override\n-    public final int getIndex() {\n-        return index;\n-    }\n@@ -89,6 +73,7 @@\n-    \/**\n-     * @return return address type\n-     *\/\n-    @Override\n-    public Type getType(final ConstantPoolGen cp) {\n-        return ReturnaddressType.NO_TARGET;\n+    private void setWide() {\n+        wide = index > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n+        if (wide) {\n+            super.setLength(4); \/\/ Including the wide byte\n+        } else {\n+            super.setLength(2);\n+        }\n@@ -97,0 +82,1 @@\n+\n@@ -101,1 +87,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -112,0 +98,10 @@\n+\n+    \/**\n+     * @return index of local variable containg the return address\n+     *\/\n+    @Override\n+    public final int getIndex() {\n+        return index;\n+    }\n+\n+\n@@ -116,1 +112,1 @@\n-    public final void setIndex(final int n) {\n+    public final void setIndex( final int n ) {\n@@ -124,8 +120,0 @@\n-    private void setWide() {\n-        wide = index > com.sun.org.apache.bcel.internal.Const.MAX_BYTE;\n-        if (wide) {\n-            super.setLength(4); \/\/ Including the wide byte\n-        } else {\n-            super.setLength(2);\n-        }\n-    }\n@@ -137,1 +125,1 @@\n-    public String toString(final boolean verbose) {\n+    public String toString( final boolean verbose ) {\n@@ -140,0 +128,22 @@\n+\n+\n+    \/** @return return address type\n+     *\/\n+    @Override\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return ReturnaddressType.NO_TARGET;\n+    }\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitRET(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/RET.java","additions":50,"deletions":40,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -25,1 +25,2 @@\n- * RETURN - Return from void method\n+ * RETURN -  Return from void method\n+ * <PRE>Stack: ... -&gt; &lt;empty&gt;<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ... -&gt; &lt;empty&gt;\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/RETURN.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+ *\n@@ -32,7 +33,0 @@\n-    \/**\n-     * Class is non-abstract but not instantiable from the outside\n-     *\/\n-    ReferenceType() {\n-        super(Const.T_OBJECT, \"<null object>\");\n-    }\n-\n@@ -43,10 +37,2 @@\n-    \/**\n-     * This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an\n-     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n-     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n-     * \"this\" or t is an ArrayType, then Type.OBJECT is returned. If \"this\" or t is a ReferenceType referencing an\n-     * interface, then Type.OBJECT is returned. If not all of the two classes' superclasses cannot be found, \"null\" is\n-     * returned. See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n-     *\n-     * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has slightly changed semantics.\n-     * @throws ClassNotFoundException on failure to find superclasses of this type, or the type passed as a parameter\n+\n+    \/** Class is non-abstract but not instantiable from the outside\n@@ -54,18 +40,2 @@\n-    @Deprecated\n-    public ReferenceType firstCommonSuperclass(final ReferenceType t) throws ClassNotFoundException {\n-        if (this.equals(Type.NULL)) {\n-            return t;\n-        }\n-        if (t.equals(Type.NULL) || this.equals(t)) {\n-            return this;\n-            \/*\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n-             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n-             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n-             *\/\n-        }\n-        if (this instanceof ArrayType || t instanceof ArrayType) {\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n-        }\n-        return getFirstCommonSuperclassInternal(t);\n+    ReferenceType() {\n+        super(Const.T_OBJECT, \"<null object>\");\n@@ -74,0 +44,1 @@\n+\n@@ -75,8 +46,6 @@\n-     * This commutative operation returns the first common superclass (narrowest ReferenceType referencing a class, not an\n-     * interface). If one of the types is a superclass of the other, the former is returned. If \"this\" is Type.NULL, then t\n-     * is returned. If t is Type.NULL, then \"this\" is returned. If \"this\" equals t ['this.equals(t)'] \"this\" is returned. If\n-     * \"this\" or t is an ArrayType, then Type.OBJECT is returned; unless their dimensions match. Then an ArrayType of the\n-     * same number of dimensions is returned, with its basic type being the first common super class of the basic types of\n-     * \"this\" and t. If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned. If not all of\n-     * the two classes' superclasses cannot be found, \"null\" is returned. See the JVM specification edition 2, \"4.9.2 The\n-     * Bytecode Verifier\".\n+     * Return true iff this type is castable to another type t as defined in\n+     * the JVM specification.  The case where this is Type.NULL is not\n+     * defined (see the CHECKCAST definition in the JVM specification).\n+     * However, because e.g. CHECKCAST doesn't throw a\n+     * ClassCastException when casting a null reference to any Object,\n+     * true is returned in this case.\n@@ -84,1 +53,2 @@\n-     * @throws ClassNotFoundException on failure to find superclasses of this type, or the type passed as a parameter\n+     * @throws ClassNotFoundException if any classes or interfaces required\n+     *  to determine assignment compatibility can't be found\n@@ -86,1 +56,1 @@\n-    public ReferenceType getFirstCommonSuperclass(final ReferenceType t) throws ClassNotFoundException {\n+    public boolean isCastableTo( final Type t ) throws ClassNotFoundException {\n@@ -88,23 +58,1 @@\n-            return t;\n-        }\n-        if (t.equals(Type.NULL) || this.equals(t)) {\n-            return this;\n-            \/*\n-             * TODO: Above sounds a little arbitrary. On the other hand, there is no object referenced by Type.NULL so we can also\n-             * say all the objects referenced by Type.NULL were derived from java.lang.Object. However, the Java Language's\n-             * \"instanceof\" operator proves us wrong: \"null\" is not referring to an instance of java.lang.Object :)\n-             *\/\n-        }\n-        \/* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> *\/\n-        if (this instanceof ArrayType && t instanceof ArrayType) {\n-            final ArrayType arrType1 = (ArrayType) this;\n-            final ArrayType arrType2 = (ArrayType) t;\n-            if (arrType1.getDimensions() == arrType2.getDimensions() && arrType1.getBasicType() instanceof ObjectType\n-                && arrType2.getBasicType() instanceof ObjectType) {\n-                return new ArrayType(((ObjectType) arrType1.getBasicType()).getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()),\n-                    arrType1.getDimensions());\n-            }\n-        }\n-        if (this instanceof ArrayType || t instanceof ArrayType) {\n-            return Type.OBJECT;\n-            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+            return t instanceof ReferenceType; \/\/ If this is ever changed in isAssignmentCompatible()\n@@ -112,1 +60,4 @@\n-        return getFirstCommonSuperclassInternal(t);\n+        return isAssignmentCompatibleWith(t);\n+        \/* Yes, it's true: It's the same definition.\n+         * See vmspec2 AASTORE \/ CHECKCAST definitions.\n+         *\/\n@@ -115,33 +66,0 @@\n-    private ReferenceType getFirstCommonSuperclassInternal(final ReferenceType t) throws ClassNotFoundException {\n-        if (this instanceof ObjectType && ((ObjectType) this).referencesInterfaceExact()\n-            || t instanceof ObjectType && ((ObjectType) t).referencesInterfaceExact()) {\n-            return Type.OBJECT;\n-            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n-            \/\/ make class file verification a bit stronger here by using the notion of\n-            \/\/ superinterfaces or even castability or assignment compatibility.\n-        }\n-        \/\/ this and t are ObjectTypes, see above.\n-        final ObjectType thiz = (ObjectType) this;\n-        final ObjectType other = (ObjectType) t;\n-        final JavaClass[] thizSups = Repository.getSuperClasses(thiz.getClassName());\n-        final JavaClass[] otherSups = Repository.getSuperClasses(other.getClassName());\n-        if (thizSups == null || otherSups == null) {\n-            return null;\n-        }\n-        \/\/ Waaahh...\n-        final JavaClass[] thisSups = new JavaClass[thizSups.length + 1];\n-        final JavaClass[] tSups = new JavaClass[otherSups.length + 1];\n-        System.arraycopy(thizSups, 0, thisSups, 1, thizSups.length);\n-        System.arraycopy(otherSups, 0, tSups, 1, otherSups.length);\n-        thisSups[0] = Repository.lookupClass(thiz.getClassName());\n-        tSups[0] = Repository.lookupClass(other.getClassName());\n-        for (final JavaClass tSup : tSups) {\n-            for (final JavaClass thisSup : thisSups) {\n-                if (thisSup.equals(tSup)) {\n-                    return ObjectType.getInstance(thisSup.getClassName());\n-                }\n-            }\n-        }\n-        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n-        return null;\n-    }\n@@ -150,5 +68,5 @@\n-     * Return true iff this is assignment compatible with another type t as defined in the JVM specification; see the\n-     * AASTORE definition there.\n-     *\n-     * @throws ClassNotFoundException if any classes or interfaces required to determine assignment compatibility can't be\n-     *         found\n+     * Return true iff this is assignment compatible with another type t\n+     * as defined in the JVM specification; see the AASTORE definition\n+     * there.\n+     * @throws ClassNotFoundException if any classes or interfaces required\n+     *  to determine assignment compatibility can't be found\n@@ -156,1 +74,1 @@\n-    public boolean isAssignmentCompatibleWith(final Type t) throws ClassNotFoundException {\n+    public boolean isAssignmentCompatibleWith( final Type t ) throws ClassNotFoundException {\n@@ -162,1 +80,1 @@\n-            return true; \/\/ This is not explicitly stated, but clear. Isn't it?\n+            return true; \/\/ This is not explicitely stated, but clear. Isn't it?\n@@ -164,2 +82,1 @@\n-        \/*\n-         * If this is a class type then\n+        \/* If this is a class type then\n@@ -167,3 +84,3 @@\n-        if (this instanceof ObjectType && ((ObjectType) this).referencesClassExact()) {\n-            \/*\n-             * If T is a class type, then this must be the same class as T, or this must be a subclass of T;\n+        if ((this instanceof ObjectType) && (((ObjectType) this).referencesClassExact())) {\n+            \/* If T is a class type, then this must be the same class as T,\n+             or this must be a subclass of T;\n@@ -171,3 +88,8 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact()\n-                && (this.equals(T) || Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n+                if (this.equals(T)) {\n+                    return true;\n+                }\n+                if (Repository.instanceOf(((ObjectType) this).getClassName(), ((ObjectType) T)\n+                        .getClassName())) {\n+                    return true;\n+                }\n@@ -175,2 +97,1 @@\n-            \/*\n-             * If T is an interface type, this must implement interface T.\n+            \/* If T is an interface type, this must implement interface T.\n@@ -178,3 +99,5 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()\n-                && Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName())) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n+                if (Repository.implementationOf(((ObjectType) this).getClassName(),\n+                        ((ObjectType) T).getClassName())) {\n+                    return true;\n+                }\n@@ -183,2 +106,1 @@\n-        \/*\n-         * If this is an interface type, then:\n+        \/* If this is an interface type, then:\n@@ -186,3 +108,2 @@\n-        if (this instanceof ObjectType && ((ObjectType) this).referencesInterfaceExact()) {\n-            \/*\n-             * If T is a class type, then T must be Object (2.4.7).\n+        if ((this instanceof ObjectType) && (((ObjectType) this).referencesInterfaceExact())) {\n+            \/* If T is a class type, then T must be Object (2.4.7).\n@@ -190,2 +111,4 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n+                if (T.equals(Type.OBJECT)) {\n+                    return true;\n+                }\n@@ -193,2 +116,2 @@\n-            \/*\n-             * If T is an interface type, then T must be the same interface as this or a superinterface of this (2.13.2).\n+            \/* If T is an interface type, then T must be the same interface\n+             * as this or a superinterface of this (2.13.2).\n@@ -196,3 +119,8 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()\n-                && (this.equals(T) || Repository.implementationOf(((ObjectType) this).getClassName(), ((ObjectType) T).getClassName()))) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n+                if (this.equals(T)) {\n+                    return true;\n+                }\n+                if (Repository.implementationOf(((ObjectType) this).getClassName(),\n+                        ((ObjectType) T).getClassName())) {\n+                    return true;\n+                }\n@@ -201,2 +129,2 @@\n-        \/*\n-         * If this is an array type, namely, the type SC[], that is, an array of components of type SC, then:\n+        \/* If this is an array type, namely, the type SC[], that is, an\n+         * array of components of type SC, then:\n@@ -205,2 +133,1 @@\n-            \/*\n-             * If T is a class type, then T must be Object (2.4.7).\n+            \/* If T is a class type, then T must be Object (2.4.7).\n@@ -208,2 +135,4 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesClassExact() && T.equals(Type.OBJECT)) {\n-                return true;\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesClassExact())) {\n+                if (T.equals(Type.OBJECT)) {\n+                    return true;\n+                }\n@@ -211,2 +140,2 @@\n-            \/*\n-             * If T is an array type TC[], that is, an array of components of type TC, then one of the following must be true:\n+            \/* If T is an array type TC[], that is, an array of components\n+             * of type TC, then one of the following must be true:\n@@ -215,2 +144,1 @@\n-                \/*\n-                 * TC and SC are the same primitive type (2.4.1).\n+                \/* TC and SC are the same primitive type (2.4.1).\n@@ -223,2 +151,2 @@\n-                \/*\n-                 * TC and SC are reference types (2.4.6), and type SC is assignable to TC by these runtime rules.\n+                \/* TC and SC are reference types (2.4.6), and type SC is\n+                 * assignable to TC by these runtime rules.\n@@ -226,1 +154,2 @@\n-                if (tc instanceof ReferenceType && sc instanceof ReferenceType && ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {\n+                if (tc instanceof ReferenceType && sc instanceof ReferenceType\n+                        && ((ReferenceType) sc).isAssignmentCompatibleWith(tc)) {\n@@ -236,1 +165,1 @@\n-            if (T instanceof ObjectType && ((ObjectType) T).referencesInterfaceExact()) {\n+            if ((T instanceof ObjectType) && (((ObjectType) T).referencesInterfaceExact())) {\n@@ -247,0 +176,1 @@\n+\n@@ -248,3 +178,13 @@\n-     * Return true iff this type is castable to another type t as defined in the JVM specification. The case where this is\n-     * Type.NULL is not defined (see the CHECKCAST definition in the JVM specification). However, because e.g. CHECKCAST\n-     * doesn't throw a ClassCastException when casting a null reference to any Object, true is returned in this case.\n+     * This commutative operation returns the first common superclass (narrowest ReferenceType\n+     * referencing a class, not an interface).\n+     * If one of the types is a superclass of the other, the former is returned.\n+     * If \"this\" is Type.NULL, then t is returned.\n+     * If t is Type.NULL, then \"this\" is returned.\n+     * If \"this\" equals t ['this.equals(t)'] \"this\" is returned.\n+     * If \"this\" or t is an ArrayType, then Type.OBJECT is returned;\n+     * unless their dimensions match. Then an ArrayType of the same\n+     * number of dimensions is returned, with its basic type being the\n+     * first common super class of the basic types of \"this\" and t.\n+     * If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.\n+     * If not all of the two classes' superclasses cannot be found, \"null\" is returned.\n+     * See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n@@ -252,2 +192,2 @@\n-     * @throws ClassNotFoundException if any classes or interfaces required to determine assignment compatibility can't be\n-     *         found\n+     * @throws ClassNotFoundException on failure to find superclasses of this\n+     *  type, or the type passed as a parameter\n@@ -255,1 +195,1 @@\n-    public boolean isCastableTo(final Type t) throws ClassNotFoundException {\n+    public ReferenceType getFirstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {\n@@ -257,1 +197,1 @@\n-            return t instanceof ReferenceType; \/\/ If this is ever changed in isAssignmentCompatible()\n+            return t;\n@@ -259,4 +199,132 @@\n-        return isAssignmentCompatibleWith(t);\n-        \/*\n-         * Yes, it's true: It's the same definition. See vmspec2 AASTORE \/ CHECKCAST definitions.\n-         *\/\n+        if (t.equals(Type.NULL)) {\n+            return this;\n+        }\n+        if (this.equals(t)) {\n+            return this;\n+            \/*\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is\n+             * no object referenced by Type.NULL so we can also say all the objects\n+             * referenced by Type.NULL were derived from java.lang.Object.\n+             * However, the Java Language's \"instanceof\" operator proves us wrong:\n+             * \"null\" is not referring to an instance of java.lang.Object :)\n+             *\/\n+        }\n+        \/* This code is from a bug report by Konstantin Shagin <konst@cs.technion.ac.il> *\/\n+        if ((this instanceof ArrayType) && (t instanceof ArrayType)) {\n+            final ArrayType arrType1 = (ArrayType) this;\n+            final ArrayType arrType2 = (ArrayType) t;\n+            if ((arrType1.getDimensions() == arrType2.getDimensions())\n+                    && arrType1.getBasicType() instanceof ObjectType\n+                    && arrType2.getBasicType() instanceof ObjectType) {\n+                return new ArrayType(((ObjectType) arrType1.getBasicType())\n+                        .getFirstCommonSuperclass((ObjectType) arrType2.getBasicType()), arrType1\n+                        .getDimensions());\n+            }\n+        }\n+        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {\n+            return Type.OBJECT;\n+            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+        }\n+        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterfaceExact())\n+                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterfaceExact())) {\n+            return Type.OBJECT;\n+            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n+            \/\/ make class file verification a bit stronger here by using the notion of\n+            \/\/ superinterfaces or even castability or assignment compatibility.\n+        }\n+        \/\/ this and t are ObjectTypes, see above.\n+        final ObjectType thiz = (ObjectType) this;\n+        final ObjectType other = (ObjectType) t;\n+        final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());\n+        final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());\n+        if ((thiz_sups == null) || (other_sups == null)) {\n+            return null;\n+        }\n+        \/\/ Waaahh...\n+        final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];\n+        final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];\n+        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);\n+        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);\n+        this_sups[0] = Repository.lookupClass(thiz.getClassName());\n+        t_sups[0] = Repository.lookupClass(other.getClassName());\n+        for (final JavaClass t_sup : t_sups) {\n+            for (final JavaClass this_sup : this_sups) {\n+                if (this_sup.equals(t_sup)) {\n+                    return ObjectType.getInstance(this_sup.getClassName());\n+                }\n+            }\n+        }\n+        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n+        return null;\n+    }\n+\n+    \/**\n+     * This commutative operation returns the first common superclass (narrowest ReferenceType\n+     * referencing a class, not an interface).\n+     * If one of the types is a superclass of the other, the former is returned.\n+     * If \"this\" is Type.NULL, then t is returned.\n+     * If t is Type.NULL, then \"this\" is returned.\n+     * If \"this\" equals t ['this.equals(t)'] \"this\" is returned.\n+     * If \"this\" or t is an ArrayType, then Type.OBJECT is returned.\n+     * If \"this\" or t is a ReferenceType referencing an interface, then Type.OBJECT is returned.\n+     * If not all of the two classes' superclasses cannot be found, \"null\" is returned.\n+     * See the JVM specification edition 2, \"4.9.2 The Bytecode Verifier\".\n+     *\n+     * @deprecated use getFirstCommonSuperclass(ReferenceType t) which has\n+     *             slightly changed semantics.\n+     * @throws ClassNotFoundException on failure to find superclasses of this\n+     *  type, or the type passed as a parameter\n+     *\/\n+    @Deprecated\n+    public ReferenceType firstCommonSuperclass( final ReferenceType t ) throws ClassNotFoundException {\n+        if (this.equals(Type.NULL)) {\n+            return t;\n+        }\n+        if (t.equals(Type.NULL)) {\n+            return this;\n+        }\n+        if (this.equals(t)) {\n+            return this;\n+            \/*\n+             * TODO: Above sounds a little arbitrary. On the other hand, there is\n+             * no object referenced by Type.NULL so we can also say all the objects\n+             * referenced by Type.NULL were derived from java.lang.Object.\n+             * However, the Java Language's \"instanceof\" operator proves us wrong:\n+             * \"null\" is not referring to an instance of java.lang.Object :)\n+             *\/\n+        }\n+        if ((this instanceof ArrayType) || (t instanceof ArrayType)) {\n+            return Type.OBJECT;\n+            \/\/ TODO: Is there a proof of OBJECT being the direct ancestor of every ArrayType?\n+        }\n+        if (((this instanceof ObjectType) && ((ObjectType) this).referencesInterface())\n+                || ((t instanceof ObjectType) && ((ObjectType) t).referencesInterface())) {\n+            return Type.OBJECT;\n+            \/\/ TODO: The above line is correct comparing to the vmspec2. But one could\n+            \/\/ make class file verification a bit stronger here by using the notion of\n+            \/\/ superinterfaces or even castability or assignment compatibility.\n+        }\n+        \/\/ this and t are ObjectTypes, see above.\n+        final ObjectType thiz = (ObjectType) this;\n+        final ObjectType other = (ObjectType) t;\n+        final JavaClass[] thiz_sups = Repository.getSuperClasses(thiz.getClassName());\n+        final JavaClass[] other_sups = Repository.getSuperClasses(other.getClassName());\n+        if ((thiz_sups == null) || (other_sups == null)) {\n+            return null;\n+        }\n+        \/\/ Waaahh...\n+        final JavaClass[] this_sups = new JavaClass[thiz_sups.length + 1];\n+        final JavaClass[] t_sups = new JavaClass[other_sups.length + 1];\n+        System.arraycopy(thiz_sups, 0, this_sups, 1, thiz_sups.length);\n+        System.arraycopy(other_sups, 0, t_sups, 1, other_sups.length);\n+        this_sups[0] = Repository.lookupClass(thiz.getClassName());\n+        t_sups[0] = Repository.lookupClass(other.getClassName());\n+        for (final JavaClass t_sup : t_sups) {\n+            for (final JavaClass this_sup : this_sups) {\n+                if (this_sup.equals(t_sup)) {\n+                    return ObjectType.getInstance(this_sup.getClassName());\n+                }\n+            }\n+        }\n+        \/\/ Huh? Did you ask for Type.OBJECT's superclass??\n+        return null;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReferenceType.java","additions":227,"deletions":159,"binary":false,"changes":386,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -31,1 +31,2 @@\n-public abstract class ReturnInstruction extends Instruction implements ExceptionThrower, TypedInstruction, StackConsumer {\n+public abstract class ReturnInstruction extends Instruction implements ExceptionThrower,\n+        TypedInstruction, StackConsumer {\n@@ -34,1 +35,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -39,0 +41,1 @@\n+\n@@ -46,4 +49,0 @@\n-    @Override\n-    public Class<?>[] getExceptions() {\n-        return new Class<?>[] {ExceptionConst.ILLEGAL_MONITOR_STATE};\n-    }\n@@ -52,16 +51,16 @@\n-        final short opcode = super.getOpcode();\n-        switch (opcode) {\n-        case Const.IRETURN:\n-            return Type.INT;\n-        case Const.LRETURN:\n-            return Type.LONG;\n-        case Const.FRETURN:\n-            return Type.FLOAT;\n-        case Const.DRETURN:\n-            return Type.DOUBLE;\n-        case Const.ARETURN:\n-            return Type.OBJECT;\n-        case Const.RETURN:\n-            return Type.VOID;\n-        default: \/\/ Never reached\n-            throw new ClassGenException(\"Unknown type \" + opcode);\n+        final short _opcode = super.getOpcode();\n+        switch (_opcode) {\n+            case Const.IRETURN:\n+                return Type.INT;\n+            case Const.LRETURN:\n+                return Type.LONG;\n+            case Const.FRETURN:\n+                return Type.FLOAT;\n+            case Const.DRETURN:\n+                return Type.DOUBLE;\n+            case Const.ARETURN:\n+                return Type.OBJECT;\n+            case Const.RETURN:\n+                return Type.VOID;\n+            default: \/\/ Never reached\n+                throw new ClassGenException(\"Unknown type \" + _opcode);\n@@ -71,2 +70,10 @@\n-    \/**\n-     * @return type associated with the instruction\n+\n+    @Override\n+    public Class<?>[] getExceptions() {\n+        return new Class<?>[] {\n+            ExceptionConst.ILLEGAL_MONITOR_STATE\n+        };\n+    }\n+\n+\n+    \/** @return type associated with the instruction\n@@ -75,1 +82,1 @@\n-    public Type getType(final ConstantPoolGen cp) {\n+    public Type getType( final ConstantPoolGen cp ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReturnInstruction.java","additions":34,"deletions":27,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+\n@@ -43,0 +44,1 @@\n+\n@@ -51,0 +53,12 @@\n+\n+    \/** @return a hash code value for the object.\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        if (returnTarget == null) {\n+            return 0;\n+        }\n+        return returnTarget.hashCode();\n+    }\n+\n+\n@@ -55,1 +69,1 @@\n-    public boolean equals(final Object rat) {\n+    public boolean equals( final Object rat ) {\n@@ -66,0 +80,1 @@\n+\n@@ -72,11 +87,0 @@\n-\n-    \/**\n-     * @return a hash code value for the object.\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        if (returnTarget == null) {\n-            return 0;\n-        }\n-        return returnTarget.hashCode();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/ReturnaddressType.java","additions":16,"deletions":12,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index -&gt; ..., value<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index -&gt; ..., value\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SALOAD.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., arrayref, index, value -&gt; ...<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., arrayref, index, value -&gt; ...\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SASTORE.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,3 +31,2 @@\n- * <PRE>\n- * Stack: ... -&gt; ..., value\n- * <\/PRE>\n+ * <PRE>Stack: ... -&gt; ..., value<\/PRE>\n+ *\n@@ -39,0 +38,1 @@\n+\n@@ -40,1 +40,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -45,0 +46,1 @@\n+\n@@ -50,0 +52,1 @@\n+\n@@ -51,4 +54,1 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n+     * Dump instruction as short code to stream out.\n@@ -57,6 +57,3 @@\n-    public void accept(final Visitor v) {\n-        v.visitPushInstruction(this);\n-        v.visitStackProducer(this);\n-        v.visitTypedInstruction(this);\n-        v.visitConstantPushInstruction(this);\n-        v.visitSIPUSH(this);\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        super.dump(out);\n+        out.writeShort(b);\n@@ -65,0 +62,1 @@\n+\n@@ -66,1 +64,1 @@\n-     * Dump instruction as short code to stream out.\n+     * @return mnemonic for instruction\n@@ -69,3 +67,2 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n-        super.dump(out);\n-        out.writeShort(b);\n+    public String toString( final boolean verbose ) {\n+        return super.toString(verbose) + \" \" + b;\n@@ -74,0 +71,1 @@\n+\n@@ -75,1 +73,1 @@\n-     * @return Type.SHORT\n+     * Read needed data (e.g. index) from file.\n@@ -78,2 +76,3 @@\n-    public Type getType(final ConstantPoolGen cp) {\n-        return Type.SHORT;\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        super.setLength(3);\n+        b = bytes.readShort();\n@@ -82,0 +81,1 @@\n+\n@@ -87,2 +87,2 @@\n-    \/**\n-     * Read needed data (e.g. index) from file.\n+\n+    \/** @return Type.SHORT\n@@ -91,3 +91,2 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        super.setLength(3);\n-        b = bytes.readShort();\n+    public Type getType( final ConstantPoolGen cp ) {\n+        return Type.SHORT;\n@@ -96,0 +95,1 @@\n+\n@@ -97,1 +97,6 @@\n-     * @return mnemonic for instruction\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n@@ -100,2 +105,6 @@\n-    public String toString(final boolean verbose) {\n-        return super.toString(verbose) + \" \" + b;\n+    public void accept( final Visitor v ) {\n+        v.visitPushInstruction(this);\n+        v.visitStackProducer(this);\n+        v.visitTypedInstruction(this);\n+        v.visitConstantPushInstruction(this);\n+        v.visitSIPUSH(this);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SIPUSH.java","additions":38,"deletions":29,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ * <PRE>Stack: ..., word2, word1 -&gt; ..., word1, word2<\/PRE>\n@@ -27,3 +28,0 @@\n- * <PRE>\n- * Stack: ..., word2, word1 -&gt; ..., word1, word2\n- * <\/PRE>\n@@ -37,0 +35,1 @@\n+\n@@ -38,2 +37,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -44,1 +45,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SWAP.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -24,2 +24,0 @@\n-import java.util.Arrays;\n-\n@@ -27,2 +25,4 @@\n- * SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or TABLESWITCH instruction, depending on\n- * whether the match values (int[]) can be sorted with no gaps between the numbers.\n+ * SWITCH - Branch depending on int value, generates either LOOKUPSWITCH or\n+ * TABLESWITCH instruction, depending on whether the match values (int[]) can be\n+ * sorted with no gaps between the numbers.\n+ *\n@@ -32,0 +32,6 @@\n+    private int[] match;\n+    private InstructionHandle[] targets;\n+    private Select instruction;\n+    private int matchLength;\n+\n+\n@@ -33,1 +39,13 @@\n-     * @return match is sorted in ascending order with no gap bigger than maxGap?\n+     * Template for switch() constructs. If the match array can be\n+     * sorted in ascending order with gaps no larger than max_gap\n+     * between the numbers, a TABLESWITCH instruction is generated, and\n+     * a LOOKUPSWITCH otherwise. The former may be more efficient, but\n+     * needs more space.\n+     *\n+     * Note, that the key array always will be sorted, though we leave\n+     * the original arrays unaltered.\n+     *\n+     * @param match array of match values (case 2: ... case 7: ..., etc.)\n+     * @param targets the instructions to be branched to for each case\n+     * @param target the default target\n+     * @param max_gap maximum gap that may between case branches\n@@ -35,1 +53,29 @@\n-    private static boolean matchIsOrdered(final int[] match, final int matchLength, final int maxGap) {\n+    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int max_gap) {\n+        this.match = match.clone();\n+        this.targets = targets.clone();\n+        if ((matchLength = match.length) < 2) {\n+            instruction = new TABLESWITCH(match, targets, target);\n+        } else {\n+            sort(0, matchLength - 1);\n+            if (matchIsOrdered(max_gap)) {\n+                fillup(max_gap, target);\n+                instruction = new TABLESWITCH(this.match, this.targets, target);\n+            } else {\n+                instruction = new LOOKUPSWITCH(this.match, this.targets, target);\n+            }\n+        }\n+    }\n+\n+\n+    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n+        this(match, targets, target, 1);\n+    }\n+\n+\n+    private void fillup( final int max_gap, final InstructionHandle target ) {\n+        final int max_size = matchLength + matchLength * max_gap;\n+        final int[] m_vec = new int[max_size];\n+        final InstructionHandle[] t_vec = new InstructionHandle[max_size];\n+        int count = 1;\n+        m_vec[0] = match[0];\n+        t_vec[0] = targets[0];\n@@ -37,2 +83,6 @@\n-            if (match[i] - match[i - 1] > maxGap) {\n-                return false;\n+            final int prev = match[i - 1];\n+            final int gap = match[i] - prev;\n+            for (int j = 1; j < gap; j++) {\n+                m_vec[count] = prev + j;\n+                t_vec[count] = target;\n+                count++;\n@@ -40,0 +90,3 @@\n+            m_vec[count] = match[i];\n+            t_vec[count] = targets[i];\n+            count++;\n@@ -41,1 +94,4 @@\n-        return true;\n+        match = new int[count];\n+        targets = new InstructionHandle[count];\n+        System.arraycopy(m_vec, 0, match, 0, count);\n+        System.arraycopy(t_vec, 0, targets, 0, count);\n@@ -44,0 +100,1 @@\n+\n@@ -45,1 +102,1 @@\n-     * Sorts match and targets array with QuickSort.\n+     * Sort match and targets array with QuickSort.\n@@ -47,1 +104,1 @@\n-    private static void sort(final int l, final int r, final int[] match, final InstructionHandle[] targets) {\n+    private void sort( final int l, final int r ) {\n@@ -51,1 +108,1 @@\n-        final int m = match[l + r >>> 1];\n+        final int m = match[(l + r) >>> 1];\n@@ -72,1 +129,1 @@\n-            sort(l, j, match, targets);\n+            sort(l, j);\n@@ -75,1 +132,1 @@\n-            sort(i, r, match, targets);\n+            sort(i, r);\n@@ -79,5 +136,0 @@\n-    private final Select instruction;\n-\n-    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target) {\n-        this(match, targets, target, 1);\n-    }\n@@ -86,10 +138,1 @@\n-     * Template for switch() constructs. If the match array can be sorted in ascending order with gaps no larger than\n-     * maxGap between the numbers, a TABLESWITCH instruction is generated, and a LOOKUPSWITCH otherwise. The former may be\n-     * more efficient, but needs more space.\n-     *\n-     * Note, that the key array always will be sorted, though we leave the original arrays unaltered.\n-     *\n-     * @param match array of match values (case 2: ... case 7: ..., etc.)\n-     * @param targets the instructions to be branched to for each case\n-     * @param target the default target\n-     * @param maxGap maximum gap that may between case branches\n+     * @return match is sorted in ascending order with no gap bigger than max_gap?\n@@ -97,30 +140,4 @@\n-    public SWITCH(final int[] match, final InstructionHandle[] targets, final InstructionHandle target, final int maxGap) {\n-        int[] matchClone = match.clone();\n-        final InstructionHandle[] targetsClone = targets.clone();\n-        final int matchLength = match.length;\n-        if (matchLength < 2) {\n-            instruction = new TABLESWITCH(match, targets, target);\n-        } else {\n-            sort(0, matchLength - 1, matchClone, targetsClone);\n-            if (matchIsOrdered(matchClone, matchLength, maxGap)) {\n-                final int maxSize = matchLength + matchLength * maxGap;\n-                final int[] mVec = new int[maxSize];\n-                final InstructionHandle[] tVec = new InstructionHandle[maxSize];\n-                int count = 1;\n-                mVec[0] = match[0];\n-                tVec[0] = targets[0];\n-                for (int i = 1; i < matchLength; i++) {\n-                    final int prev = match[i - 1];\n-                    final int gap = match[i] - prev;\n-                    for (int j = 1; j < gap; j++) {\n-                        mVec[count] = prev + j;\n-                        tVec[count] = target;\n-                        count++;\n-                    }\n-                    mVec[count] = match[i];\n-                    tVec[count] = targets[i];\n-                    count++;\n-                }\n-                instruction = new TABLESWITCH(Arrays.copyOf(mVec, count), Arrays.copyOf(tVec, count), target);\n-            } else {\n-                instruction = new LOOKUPSWITCH(matchClone, targetsClone, target);\n+    private boolean matchIsOrdered( final int max_gap ) {\n+        for (int i = 1; i < matchLength; i++) {\n+            if (match[i] - match[i - 1] > max_gap) {\n+                return false;\n@@ -129,0 +146,1 @@\n+        return true;\n@@ -131,3 +149,0 @@\n-    public Instruction getInstruction() {\n-        return instruction;\n-    }\n@@ -139,0 +154,5 @@\n+\n+\n+    public Instruction getInstruction() {\n+        return instruction;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SWITCH.java","additions":82,"deletions":62,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -30,2 +30,1 @@\n- * <p>\n- * We use our super's {@code target} property as the default target.\n+ * <p>We use our super's {@code target} property as the default target.\n@@ -38,1 +37,2 @@\n-public abstract class Select extends BranchInstruction implements VariableLengthInstruction, StackConsumer \/* @since 6.0 *\/, StackProducer {\n+public abstract class Select extends BranchInstruction implements VariableLengthInstruction,\n+        StackConsumer \/* @since 6.0 *\/, StackProducer {\n@@ -40,17 +40,6 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int[] match; \/\/ matches, i.e., case 1: ... TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int[] indices; \/\/ target offsets TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected InstructionHandle[] targets; \/\/ target objects in instruction list TODO could be package-protected?\n+    private int[] match; \/\/ matches, i.e., case 1: ... TODO could be package-protected?\n+    private int[] indices; \/\/ target offsets TODO could be package-protected?\n+    private InstructionHandle[] targets; \/\/ target objects in instruction list TODO could be package-protected?\n+    private int fixed_length; \/\/ fixed length defined by subclasses TODO could be package-protected?\n+    private int match_length; \/\/ number of cases TODO could be package-protected?\n+    private int padding = 0; \/\/ number of pad bytes for alignment TODO could be package-protected?\n@@ -59,19 +48,2 @@\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int fixed_length; \/\/ fixed length defined by subclasses TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int match_length; \/\/ number of cases TODO could be package-protected?\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected int padding; \/\/ number of pad bytes for alignment TODO could be package-protected?\n-\n-    \/**\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -82,0 +54,1 @@\n+\n@@ -83,1 +56,2 @@\n-     * (Match, target) pairs for switch. 'Match' and 'targets' must have the same length of course.\n+     * (Match, target) pairs for switch.\n+     * `Match' and `targets' must have the same length of course.\n@@ -100,1 +74,2 @@\n-            throw new ClassGenException(\"Match and target array have not the same length: Match length: \" + match.length + \" Target length: \" + targets.length);\n+            throw new ClassGenException(\"Match and target array have not the same length: Match length: \" +\n+                match.length + \" Target length: \" + targets.length);\n@@ -105,0 +80,14 @@\n+\n+    \/**\n+     * Since this is a variable length instruction, it may shift the following\n+     * instructions which then need to update their position.\n+     *\n+     * Called by InstructionList.setPositions when setting the position for every\n+     * instruction. In the presence of variable length instructions `setPositions'\n+     * performs multiple passes over the instruction list to calculate the\n+     * correct (byte) positions and offsets by calling this function.\n+     *\n+     * @param offset additional offset caused by preceding (variable length) instructions\n+     * @param max_offset the maximum offset that may be caused by these instructions\n+     * @return additional offset caused by possible change of this instruction's length\n+     *\/\n@@ -106,6 +95,91 @@\n-    protected Object clone() throws CloneNotSupportedException {\n-        final Select copy = (Select) super.clone();\n-        copy.match = match.clone();\n-        copy.indices = indices.clone();\n-        copy.targets = targets.clone();\n-        return copy;\n+    protected int updatePosition( final int offset, final int max_offset ) {\n+        setPosition(getPosition() + offset); \/\/ Additional offset caused by preceding SWITCHs, GOTOs, etc.\n+        final short old_length = (short) super.getLength();\n+        \/* Alignment on 4-byte-boundary, + 1, because of tag byte.\n+         *\/\n+        padding = (4 - ((getPosition() + 1) % 4)) % 4;\n+        super.setLength((short) (fixed_length + padding)); \/\/ Update length\n+        return super.getLength() - old_length;\n+    }\n+\n+\n+    \/**\n+     * Dump instruction as byte code to stream out.\n+     * @param out Output stream\n+     *\/\n+    @Override\n+    public void dump( final DataOutputStream out ) throws IOException {\n+        out.writeByte(super.getOpcode());\n+        for (int i = 0; i < padding; i++) {\n+            out.writeByte(0);\n+        }\n+        super.setIndex(getTargetOffset()); \/\/ Write default target offset\n+        out.writeInt(super.getIndex());\n+    }\n+\n+\n+    \/**\n+     * Read needed data (e.g. index) from file.\n+     *\/\n+    @Override\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n+        padding = (4 - (bytes.getIndex() % 4)) % 4; \/\/ Compute number of pad bytes\n+        for (int i = 0; i < padding; i++) {\n+            bytes.readByte();\n+        }\n+        \/\/ Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)\n+        super.setIndex(bytes.readInt());\n+    }\n+\n+\n+    \/**\n+     * @return mnemonic for instruction\n+     *\/\n+    @Override\n+    public String toString( final boolean verbose ) {\n+        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n+        if (verbose) {\n+            for (int i = 0; i < match_length; i++) {\n+                String s = \"null\";\n+                if (targets[i] != null) {\n+                    s = targets[i].getInstruction().toString();\n+                }\n+                buf.append(\"(\").append(match[i]).append(\", \").append(s).append(\" = {\").append(\n+                        indices[i]).append(\"})\");\n+            }\n+        } else {\n+            buf.append(\" ...\");\n+        }\n+        return buf.toString();\n+    }\n+\n+\n+    \/**\n+     * Set branch target for `i'th case\n+     *\/\n+    public void setTarget( final int i, final InstructionHandle target ) { \/\/ TODO could be package-protected?\n+        notifyTarget(targets[i], target, this);\n+        targets[i] = target;\n+    }\n+\n+\n+    \/**\n+     * @param old_ih old target\n+     * @param new_ih new target\n+     *\/\n+    @Override\n+    public void updateTarget( final InstructionHandle old_ih, final InstructionHandle new_ih ) {\n+        boolean targeted = false;\n+        if (super.getTarget() == old_ih) {\n+            targeted = true;\n+            setTarget(new_ih);\n+        }\n+        for (int i = 0; i < targets.length; i++) {\n+            if (targets[i] == old_ih) {\n+                targeted = true;\n+                setTarget(i, new_ih);\n+            }\n+        }\n+        if (!targeted) {\n+            throw new ClassGenException(\"Not targeting \" + old_ih);\n+        }\n@@ -114,0 +188,1 @@\n+\n@@ -118,1 +193,1 @@\n-    public boolean containsTarget(final InstructionHandle ih) {\n+    public boolean containsTarget( final InstructionHandle ih ) {\n@@ -130,0 +205,11 @@\n+\n+    @Override\n+    protected Object clone() throws CloneNotSupportedException {\n+        final Select copy = (Select) super.clone();\n+        copy.match = match.clone();\n+        copy.indices = indices.clone();\n+        copy.targets = targets.clone();\n+        return copy;\n+    }\n+\n+\n@@ -141,14 +227,0 @@\n-    \/**\n-     * Dump instruction as byte code to stream out.\n-     *\n-     * @param out Output stream\n-     *\/\n-    @Override\n-    public void dump(final DataOutputStream out) throws IOException {\n-        out.writeByte(super.getOpcode());\n-        for (int i = 0; i < padding; i++) {\n-            out.writeByte(0);\n-        }\n-        super.setIndex(getTargetOffset()); \/\/ Write default target offset\n-        out.writeInt(super.getIndex());\n-    }\n@@ -157,2 +229,1 @@\n-     * @return the fixed_length\n-     * @since 6.0\n+     * @return array of match indices\n@@ -160,2 +231,2 @@\n-    final int getFixedLength() {\n-        return fixed_length;\n+    public int[] getMatchs() {\n+        return match;\n@@ -164,0 +235,1 @@\n+\n@@ -171,0 +243,1 @@\n+\n@@ -172,2 +245,1 @@\n-     * @return index entry from indices\n-     * @since 6.0\n+     * @return array of match targets\n@@ -175,2 +247,2 @@\n-    final int getIndices(final int index) {\n-        return indices[index];\n+    public InstructionHandle[] getTargets() {\n+        return targets;\n@@ -187,7 +259,0 @@\n-    \/**\n-     * @return the match_length\n-     * @since 6.0\n-     *\/\n-    final int getMatchLength() {\n-        return match_length;\n-    }\n@@ -196,9 +261,1 @@\n-     * @return array of match indices\n-     *\/\n-    public int[] getMatchs() {\n-        return match;\n-    }\n-\n-    \/**\n-     *\n-     * @return the padding\n+     * @return index entry from indices\n@@ -207,2 +264,2 @@\n-    final int getPadding() {\n-        return padding;\n+    final int getIndices(final int index) {\n+        return indices[index];\n@@ -219,0 +276,1 @@\n+\n@@ -220,1 +278,2 @@\n-     * @return array of match targets\n+     * @return the fixed_length\n+     * @since 6.0\n@@ -222,2 +281,2 @@\n-    public InstructionHandle[] getTargets() {\n-        return targets;\n+    final int getFixed_length() {\n+        return fixed_length;\n@@ -226,0 +285,1 @@\n+\n@@ -227,1 +287,2 @@\n-     * Read needed data (e.g. index) from file.\n+     * @param fixed_length the fixed_length to set\n+     * @since 6.0\n@@ -229,8 +290,2 @@\n-    @Override\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n-        padding = (4 - bytes.getIndex() % 4) % 4; \/\/ Compute number of pad bytes\n-        for (int i = 0; i < padding; i++) {\n-            bytes.readByte();\n-        }\n-        \/\/ Default branch target common for both cases (TABLESWITCH, LOOKUPSWITCH)\n-        super.setIndex(bytes.readInt());\n+    final void setFixed_length(final int fixed_length) {\n+        this.fixed_length = fixed_length;\n@@ -239,0 +294,1 @@\n+\n@@ -240,1 +296,1 @@\n-     * @param fixedLength the fixed_length to set\n+     * @return the match_length\n@@ -243,2 +299,2 @@\n-    final void setFixedLength(final int fixedLength) {\n-        this.fixed_length = fixedLength;\n+    final int getMatch_length() {\n+        return match_length;\n@@ -247,5 +303,0 @@\n-    \/** @since 6.0 *\/\n-    final int setIndices(final int i, final int value) {\n-        indices[i] = value;\n-        return value; \/\/ Allow use in nested calls\n-    }\n@@ -254,2 +305,1 @@\n-     *\n-     * @param array\n+     * @param match_length the match_length to set\n@@ -258,2 +308,3 @@\n-    final void setIndices(final int[] array) {\n-        indices = array;\n+    final int setMatch_length(final int match_length) {\n+        this.match_length = match_length;\n+        return match_length;\n@@ -277,2 +328,2 @@\n-    final void setMatches(final int[] array) {\n-        match = array;\n+    final void setIndices(final int[] array) {\n+        indices = array;\n@@ -282,1 +333,2 @@\n-     * @param matchLength the match_length to set\n+     *\n+     * @param array\n@@ -285,11 +337,2 @@\n-    final int setMatchLength(final int matchLength) {\n-        this.match_length = matchLength;\n-        return matchLength;\n-    }\n-\n-    \/**\n-     * Set branch target for 'i'th case\n-     *\/\n-    public void setTarget(final int i, final InstructionHandle target) { \/\/ TODO could be package-protected?\n-        notifyTarget(targets[i], target, this);\n-        targets[i] = target;\n+    final void setMatches(final int[] array) {\n+        match = array;\n@@ -308,22 +351,0 @@\n-     * @return mnemonic for instruction\n-     *\/\n-    @Override\n-    public String toString(final boolean verbose) {\n-        final StringBuilder buf = new StringBuilder(super.toString(verbose));\n-        if (verbose) {\n-            for (int i = 0; i < match_length; i++) {\n-                String s = \"null\";\n-                if (targets[i] != null) {\n-                    s = targets[i].getInstruction().toString();\n-                }\n-                buf.append(\"(\").append(match[i]).append(\", \").append(s).append(\" = {\").append(indices[i]).append(\"})\");\n-            }\n-        } else {\n-            buf.append(\" ...\");\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Since this is a variable length instruction, it may shift the following instructions which then need to update their\n-     * position.\n@@ -331,7 +352,2 @@\n-     * Called by InstructionList.setPositions when setting the position for every instruction. In the presence of variable\n-     * length instructions 'setPositions' performs multiple passes over the instruction list to calculate the correct (byte)\n-     * positions and offsets by calling this function.\n-     *\n-     * @param offset additional offset caused by preceding (variable length) instructions\n-     * @param maxOffset the maximum offset that may be caused by these instructions\n-     * @return additional offset caused by possible change of this instruction's length\n+     * @return the padding\n+     * @since 6.0\n@@ -339,10 +355,2 @@\n-    @Override\n-    protected int updatePosition(final int offset, final int maxOffset) {\n-        setPosition(getPosition() + offset); \/\/ Additional offset caused by preceding SWITCHs, GOTOs, etc.\n-        final short oldLength = (short) super.getLength();\n-        \/*\n-         * Alignment on 4-byte-boundary, + 1, because of tag byte.\n-         *\/\n-        padding = (4 - (getPosition() + 1) % 4) % 4;\n-        super.setLength((short) (fixed_length + padding)); \/\/ Update length\n-        return super.getLength() - oldLength;\n+    final int getPadding() {\n+        return padding;\n@@ -351,20 +359,5 @@\n-    \/**\n-     * @param oldIh old target\n-     * @param newIh new target\n-     *\/\n-    @Override\n-    public void updateTarget(final InstructionHandle oldIh, final InstructionHandle newIh) {\n-        boolean targeted = false;\n-        if (super.getTarget() == oldIh) {\n-            targeted = true;\n-            setTarget(newIh);\n-        }\n-        for (int i = 0; i < targets.length; i++) {\n-            if (targets[i] == oldIh) {\n-                targeted = true;\n-                setTarget(i, newIh);\n-            }\n-        }\n-        if (!targeted) {\n-            throw new ClassGenException(\"Not targeting \" + oldIh);\n-        }\n+\n+    \/** @since 6.0 *\/\n+    final int setIndices(final int i, final int value) {\n+        indices[i] = value;\n+        return value;  \/\/ Allow use in nested calls\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Select.java","additions":178,"deletions":185,"binary":false,"changes":363,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-public class SimpleElementValueGen extends ElementValueGen {\n+public class SimpleElementValueGen extends ElementValueGen\n+{\n@@ -42,1 +43,1 @@\n-    private final int idx;\n+    private int idx;\n@@ -44,1 +45,8 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final boolean value) {\n+    \/\/ ctors for each supported type... type could be inferred but for now lets\n+    \/\/ force it to be passed\n+    \/**\n+     * Protected ctor used for deserialization, doesn't *put* an entry in the\n+     * constant pool, assumes the one at the supplied index is correct.\n+     *\/\n+    protected SimpleElementValueGen(final int type, final int idx, final ConstantPoolGen cpGen)\n+    {\n@@ -46,5 +54,1 @@\n-        if (value) {\n-            idx = getConstantPool().addInteger(1);\n-        } else {\n-            idx = getConstantPool().addInteger(0);\n-        }\n+        this.idx = idx;\n@@ -53,1 +57,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final byte value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final int value)\n+    {\n@@ -58,1 +63,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final char value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final long value)\n+    {\n@@ -60,1 +66,1 @@\n-        idx = getConstantPool().addInteger(value);\n+        idx = getConstantPool().addLong(value);\n@@ -63,1 +69,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final double value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final double value)\n+    {\n@@ -68,1 +75,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final float value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final float value)\n+    {\n@@ -73,1 +81,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final int value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final short value)\n+    {\n@@ -78,1 +87,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final long value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final byte value)\n+    {\n@@ -80,1 +90,1 @@\n-        idx = getConstantPool().addLong(value);\n+        idx = getConstantPool().addInteger(value);\n@@ -83,1 +93,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final short value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final char value)\n+    {\n@@ -88,1 +99,2 @@\n-    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final String value) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final boolean value)\n+    {\n@@ -90,1 +102,5 @@\n-        idx = getConstantPool().addUtf8(value);\n+        if (value) {\n+            idx = getConstantPool().addInteger(1);\n+        } else {\n+            idx = getConstantPool().addInteger(0);\n+        }\n@@ -93,7 +109,2 @@\n-    \/\/ ctors for each supported type... type could be inferred but for now lets\n-    \/\/ force it to be passed\n-    \/**\n-     * Protected ctor used for deserialization, doesn't *put* an entry in the constant pool, assumes the one at the supplied\n-     * index is correct.\n-     *\/\n-    protected SimpleElementValueGen(final int type, final int idx, final ConstantPoolGen cpGen) {\n+    public SimpleElementValueGen(final int type, final ConstantPoolGen cpGen, final String value)\n+    {\n@@ -101,1 +112,1 @@\n-        this.idx = idx;\n+        idx = getConstantPool().addUtf8(value);\n@@ -105,2 +116,3 @@\n-     * The boolean controls whether we copy info from the 'old' constant pool to the 'new'. You need to use this ctor if the\n-     * annotation is being copied from one file to another.\n+     * The boolean controls whether we copy info from the 'old' constant pool to\n+     * the 'new'. You need to use this ctor if the annotation is being copied\n+     * from one file to another.\n@@ -108,1 +120,3 @@\n-    public SimpleElementValueGen(final SimpleElementValue value, final ConstantPoolGen cpool, final boolean copyPoolEntries) {\n+    public SimpleElementValueGen(final SimpleElementValue value,\n+            final ConstantPoolGen cpool, final boolean copyPoolEntries)\n+    {\n@@ -110,1 +124,2 @@\n-        if (!copyPoolEntries) {\n+        if (!copyPoolEntries)\n+        {\n@@ -114,2 +129,5 @@\n-        } else {\n-            switch (value.getElementValueType()) {\n+        }\n+        else\n+        {\n+            switch (value.getElementValueType())\n+            {\n@@ -138,1 +156,2 @@\n-                if (value.getValueBoolean()) {\n+                if (value.getValueBoolean())\n+                {\n@@ -140,1 +159,3 @@\n-                } else {\n+                }\n+                else\n+                {\n@@ -148,1 +169,2 @@\n-                throw new IllegalArgumentException(\"SimpleElementValueGen class does not know how to copy this type \" + super.getElementValueType());\n+                throw new IllegalArgumentException(\n+                    \"SimpleElementValueGen class does not know how to copy this type \" + super.getElementValueType());\n@@ -153,20 +175,0 @@\n-    @Override\n-    public void dump(final DataOutputStream dos) throws IOException {\n-        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n-        switch (super.getElementValueType()) {\n-        case PRIMITIVE_INT:\n-        case PRIMITIVE_BYTE:\n-        case PRIMITIVE_CHAR:\n-        case PRIMITIVE_FLOAT:\n-        case PRIMITIVE_LONG:\n-        case PRIMITIVE_BOOLEAN:\n-        case PRIMITIVE_SHORT:\n-        case PRIMITIVE_DOUBLE:\n-        case STRING:\n-            dos.writeShort(idx);\n-            break;\n-        default:\n-            throw new IllegalStateException(\"SimpleElementValueGen doesnt know how to write out type \" + super.getElementValueType());\n-        }\n-    }\n-\n@@ -177,1 +179,2 @@\n-    public ElementValue getElementValue() {\n+    public ElementValue getElementValue()\n+    {\n@@ -181,1 +184,2 @@\n-    public int getIndex() {\n+    public int getIndex()\n+    {\n@@ -185,3 +189,5 @@\n-    public int getValueInt() {\n-        if (super.getElementValueType() != PRIMITIVE_INT) {\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+    public String getValueString()\n+    {\n+        if (super.getElementValueType() != STRING) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n@@ -189,1 +195,1 @@\n-        final ConstantInteger c = (ConstantInteger) getConstantPool().getConstant(idx);\n+        final ConstantUtf8 c = (ConstantUtf8) getConstantPool().getConstant(idx);\n@@ -193,3 +199,5 @@\n-    public String getValueString() {\n-        if (super.getElementValueType() != STRING) {\n-            throw new IllegalStateException(\"Dont call getValueString() on a non STRING ElementValue\");\n+    public int getValueInt()\n+    {\n+        if (super.getElementValueType() != PRIMITIVE_INT) {\n+            throw new IllegalStateException(\n+                    \"Dont call getValueString() on a non STRING ElementValue\");\n@@ -197,1 +205,1 @@\n-        final ConstantUtf8 c = (ConstantUtf8) getConstantPool().getConstant(idx);\n+        final ConstantInteger c = (ConstantInteger) getConstantPool().getConstant(idx);\n@@ -203,2 +211,4 @@\n-    public String stringifyValue() {\n-        switch (super.getElementValueType()) {\n+    public String stringifyValue()\n+    {\n+        switch (super.getElementValueType())\n+        {\n@@ -236,1 +246,25 @@\n-            throw new IllegalStateException(\"SimpleElementValueGen class does not know how to stringify type \" + super.getElementValueType());\n+            throw new IllegalStateException(\n+                \"SimpleElementValueGen class does not know how to stringify type \" + super.getElementValueType());\n+        }\n+    }\n+\n+    @Override\n+    public void dump(final DataOutputStream dos) throws IOException\n+    {\n+        dos.writeByte(super.getElementValueType()); \/\/ u1 kind of value\n+        switch (super.getElementValueType())\n+        {\n+        case PRIMITIVE_INT:\n+        case PRIMITIVE_BYTE:\n+        case PRIMITIVE_CHAR:\n+        case PRIMITIVE_FLOAT:\n+        case PRIMITIVE_LONG:\n+        case PRIMITIVE_BOOLEAN:\n+        case PRIMITIVE_SHORT:\n+        case PRIMITIVE_DOUBLE:\n+        case STRING:\n+            dos.writeShort(idx);\n+            break;\n+        default:\n+            throw new IllegalStateException(\n+                \"SimpleElementValueGen doesnt know how to write out type \" + super.getElementValueType());\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/SimpleElementValueGen.java","additions":103,"deletions":69,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -29,2 +30,1 @@\n-    \/**\n-     * @return how many words are consumed from stack\n+    \/** @return how many words are consumed from stack\n@@ -32,1 +32,1 @@\n-    int consumeStack(ConstantPoolGen cpg);\n+    int consumeStack( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackConsumer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+ *\n@@ -30,1 +31,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -35,0 +37,1 @@\n+\n@@ -42,2 +45,2 @@\n-    \/**\n-     * @return Type.UNKNOWN\n+\n+    \/** @return Type.UNKNOWN\n@@ -45,1 +48,1 @@\n-    public Type getType(final ConstantPoolGen cp) {\n+    public Type getType( final ConstantPoolGen cp ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackInstruction.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes an instruction that may produce a value on top of the stack (this excludes DUP_X1, e.g.)\n+ * Denote an instruction that may produce a value on top of the stack\n+ * (this excludes DUP_X1, e.g.)\n+ *\n@@ -29,2 +31,1 @@\n-    \/**\n-     * @return how many words are produced on stack\n+    \/** @return how many words are produced on stack\n@@ -32,1 +33,1 @@\n-    int produceStack(ConstantPoolGen cpg);\n+    int produceStack( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StackProducer.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Denotes an unparameterized instruction to store a value into a local variable, e.g. ISTORE.\n+ * Denotes an unparameterized instruction to store a value into a local variable,\n+ * e.g. ISTORE.\n+ *\n@@ -30,2 +32,3 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise. tag and length are defined in\n-     * readInstruction and initFromFile, respectively.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n+     * tag and length are defined in readInstruction and initFromFile, respectively.\n@@ -33,2 +36,2 @@\n-    StoreInstruction(final short canonTag, final short cTag) {\n-        super(canonTag, cTag);\n+    StoreInstruction(final short canon_tag, final short c_tag) {\n+        super(canon_tag, c_tag);\n@@ -37,0 +40,1 @@\n+\n@@ -39,1 +43,1 @@\n-     * @param cTag Instruction number for compact version, ASTORE_0, e.g.\n+     * @param c_tag Instruction number for compact version, ASTORE_0, e.g.\n@@ -42,2 +46,2 @@\n-    protected StoreInstruction(final short opcode, final short cTag, final int n) {\n-        super(opcode, cTag, n);\n+    protected StoreInstruction(final short opcode, final short c_tag, final int n) {\n+        super(opcode, c_tag, n);\n@@ -46,0 +50,1 @@\n+\n@@ -47,2 +52,4 @@\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n@@ -53,1 +60,1 @@\n-    public void accept(final Visitor v) {\n+    public void accept( final Visitor v ) {\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/StoreInstruction.java","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -37,1 +37,2 @@\n-     * Empty constructor needed for Instruction.readInstruction. Not to be used otherwise.\n+     * Empty constructor needed for Instruction.readInstruction.\n+     * Not to be used otherwise.\n@@ -42,0 +43,1 @@\n+\n@@ -43,1 +45,2 @@\n-     * @param match sorted array of match values, match[0] must be low value, match[match_length - 1] high value\n+     * @param match sorted array of match values, match[0] must be low value,\n+     * match[match_length - 1] high value\n@@ -50,3 +53,3 @@\n-        final short length = (short) (13 + getMatchLength() * 4);\n-        super.setLength(length);\n-        setFixedLength(length);\n+        final short _length = (short) (13 + getMatch_length() * 4);\n+        super.setLength(_length);\n+        setFixed_length(_length);\n@@ -55,14 +58,0 @@\n-    \/**\n-     * Call corresponding visitor method(s). The order is: Call visitor methods of implemented interfaces first, then call\n-     * methods according to the class hierarchy in descending order, i.e., the most specific visitXXX() call comes last.\n-     *\n-     * @param v Visitor object\n-     *\/\n-    @Override\n-    public void accept(final Visitor v) {\n-        v.visitVariableLengthInstruction(this);\n-        v.visitStackConsumer(this);\n-        v.visitBranchInstruction(this);\n-        v.visitSelect(this);\n-        v.visitTABLESWITCH(this);\n-    }\n@@ -72,1 +61,0 @@\n-     *\n@@ -76,1 +64,1 @@\n-    public void dump(final DataOutputStream out) throws IOException {\n+    public void dump( final DataOutputStream out ) throws IOException {\n@@ -78,2 +66,2 @@\n-        final int matchLength = getMatchLength();\n-        final int low = matchLength > 0 ? super.getMatch(0) : 0;\n+        final int _match_length = getMatch_length();\n+        final int low = (_match_length > 0) ? super.getMatch(0) : 0;\n@@ -81,1 +69,1 @@\n-        final int high = matchLength > 0 ? super.getMatch(matchLength - 1) : 0;\n+        final int high = (_match_length > 0) ? super.getMatch(_match_length - 1) : 0;\n@@ -83,1 +71,1 @@\n-        for (int i = 0; i < matchLength; i++) {\n+        for (int i = 0; i < _match_length; i++) {\n@@ -88,0 +76,1 @@\n+\n@@ -92,1 +81,1 @@\n-    protected void initFromFile(final ByteSequence bytes, final boolean wide) throws IOException {\n+    protected void initFromFile( final ByteSequence bytes, final boolean wide ) throws IOException {\n@@ -96,9 +85,9 @@\n-        final int matchLength = high - low + 1;\n-        setMatchLength(matchLength);\n-        final short fixedLength = (short) (13 + matchLength * 4);\n-        setFixedLength(fixedLength);\n-        super.setLength((short) (fixedLength + super.getPadding()));\n-        super.setMatches(new int[matchLength]);\n-        super.setIndices(new int[matchLength]);\n-        super.setTargets(new InstructionHandle[matchLength]);\n-        for (int i = 0; i < matchLength; i++) {\n+        final int _match_length = high - low + 1;\n+        setMatch_length(_match_length);\n+        final short _fixed_length = (short) (13 + _match_length * 4);\n+        setFixed_length(_fixed_length);\n+        super.setLength((short) (_fixed_length + super.getPadding()));\n+        super.setMatches(new int[_match_length]);\n+        super.setIndices(new int[_match_length]);\n+        super.setTargets(new InstructionHandle[_match_length]);\n+        for (int i = 0; i < _match_length; i++) {\n@@ -109,0 +98,18 @@\n+\n+\n+    \/**\n+     * Call corresponding visitor method(s). The order is:\n+     * Call visitor methods of implemented interfaces first, then\n+     * call methods according to the class hierarchy in descending order,\n+     * i.e., the most specific visitXXX() call comes last.\n+     *\n+     * @param v Visitor object\n+     *\/\n+    @Override\n+    public void accept( final Visitor v ) {\n+        v.visitVariableLengthInstruction(this);\n+        v.visitStackConsumer(this);\n+        v.visitBranchInstruction(this);\n+        v.visitSelect(this);\n+        v.visitTABLESWITCH(this);\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TABLESWITCH.java","additions":42,"deletions":35,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -24,3 +25,4 @@\n- * Thrown by InstructionList.remove() when one or multiple disposed instructions are still being referenced by an\n- * InstructionTargeter object. I.e. the InstructionTargeter has to be notified that (one of) the InstructionHandle it is\n- * referencing is being removed from the InstructionList and thus not valid anymore.\n+ * Thrown by InstructionList.remove() when one or multiple disposed instructions\n+ * are still being referenced by an InstructionTargeter object. I.e. the\n+ * InstructionTargeter has to be notified that (one of) the InstructionHandle it\n+ * is referencing is being removed from the InstructionList and thus not valid anymore.\n@@ -28,4 +30,3 @@\n- * <p>\n- * Making this an exception instead of a return value forces the user to handle these case explicitly in a try { ... }\n- * catch. The following code illustrates how this may be done:\n- * <\/p>\n+ * <p>Making this an exception instead of a return value forces the user to handle\n+ * these case explicitely in a try { ... } catch. The following code illustrates\n+ * how this may be done:<\/p>\n@@ -49,1 +50,0 @@\n- * @LastModified: Feb 2023\n@@ -56,0 +56,1 @@\n+\n@@ -61,0 +62,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TargetLostException.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -23,1 +23,0 @@\n-import java.util.Arrays;\n@@ -25,1 +24,0 @@\n-import java.util.Objects;\n@@ -32,2 +30,3 @@\n- * Abstract super class for all possible java types, namely basic types such as int, object types like String and array\n- * types, e.g. int[]\n+ * Abstract super class for all possible java types, namely basic types\n+ * such as int, object types like String and array types, e.g. int[]\n+ *\n@@ -38,0 +37,2 @@\n+    private final byte type;\n+    private String signature; \/\/ signature for the type\n@@ -42,1 +43,0 @@\n-\n@@ -56,5 +56,1 @@\n-\n-    \/**\n-     * Empty array.\n-     *\/\n-    public static final Type[] NO_ARGS = {};\n+    public static final Type[] NO_ARGS = new Type[0]; \/\/ EMPTY, so immutable\n@@ -63,1 +59,0 @@\n-\n@@ -67,1 +62,0 @@\n-    private static final ThreadLocal<Integer> CONSUMED_CHARS = ThreadLocal.withInitial(() -> Integer.valueOf(0));\n@@ -69,3 +63,3 @@\n-    \/\/ int consumed_chars=0; \/\/ Remember position in string, see getArgumentTypes\n-    static int consumed(final int coded) {\n-        return coded >> 2;\n+    protected Type(final byte t, final String s) {\n+        type = t;\n+        signature = s;\n@@ -74,2 +68,7 @@\n-    static int encode(final int size, final int consumed) {\n-        return consumed << 2 | size;\n+\n+    \/**\n+     * @return hashcode of Type\n+     *\/\n+    @Override\n+    public int hashCode() {\n+        return type ^ signature.hashCode();\n@@ -78,0 +77,1 @@\n+\n@@ -79,4 +79,1 @@\n-     * Convert arguments of a method (signature) to an array of Type objects.\n-     *\n-     * @param signature signature string such as (Ljava\/lang\/String;)V\n-     * @return array of argument types\n+     * @return whether the Types are equal\n@@ -84,16 +81,34 @@\n-    public static Type[] getArgumentTypes(final String signature) {\n-        final List<Type> vec = new ArrayList<>();\n-        int index;\n-        try {\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n-            index = signature.indexOf('(') + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            while (signature.charAt(index) != ')') {\n-                vec.add(getType(signature.substring(index)));\n-                \/\/ corrected concurrent private static field acess\n-                index += unwrap(CONSUMED_CHARS); \/\/ update position\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+    @Override\n+    public boolean equals(final Object o) {\n+          if (o instanceof Type) {\n+              final Type t = (Type)o;\n+              return (type == t.type) && signature.equals(t.signature);\n+          }\n+          return false;\n+    }\n+\n+\n+    \/**\n+     * @return signature for given type.\n+     *\/\n+    public String getSignature() {\n+        return signature;\n+    }\n+\n+\n+    \/**\n+     * @return type as defined in Constants\n+     *\/\n+    public byte getType() {\n+        return type;\n+    }\n+\n+    \/**\n+     * boolean, short and char variable are considered as int in the stack or local variable area.\n+     * Returns {@link Type#INT} for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise\n+     * returns the given type.\n+     * @since 6.0\n+     *\/\n+    public Type normalizeForStackOrLocal() {\n+        if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {\n+            return Type.INT;\n@@ -101,3 +116,1 @@\n-        final Type[] types = new Type[vec.size()];\n-        vec.toArray(types);\n-        return types;\n+        return this;\n@@ -106,16 +119,12 @@\n-    static int getArgumentTypesSize(final String signature) {\n-        int res = 0;\n-        int index;\n-        try {\n-            \/\/ Skip any type arguments to read argument declarations between '(' and ')'\n-            index = signature.indexOf('(') + 1;\n-            if (index <= 0) {\n-                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n-            }\n-            while (signature.charAt(index) != ')') {\n-                final int coded = getTypeSize(signature.substring(index));\n-                res += size(coded);\n-                index += consumed(coded);\n-            }\n-        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n-            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n+    \/**\n+     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)\n+     *\/\n+    public int getSize() {\n+        switch (type) {\n+            case Const.T_DOUBLE:\n+            case Const.T_LONG:\n+                return 2;\n+            case Const.T_VOID:\n+                return 0;\n+            default:\n+                return 1;\n@@ -123,1 +132,0 @@\n-        return res;\n@@ -126,0 +134,1 @@\n+\n@@ -127,1 +136,12 @@\n-     * Convert type to Java method signature, e.g. int[] f(java.lang.String x) becomes (Ljava\/lang\/String;)[I\n+     * @return Type string, e.g. `int[]'\n+     *\/\n+    @Override\n+    public String toString() {\n+        return ((this.equals(Type.NULL) || (type >= Const.T_UNKNOWN))) ? signature : Utility\n+                .signatureToString(signature, false);\n+    }\n+\n+\n+    \/**\n+     * Convert type to Java method signature, e.g. int[] f(java.lang.String x)\n+     * becomes (Ljava\/lang\/String;)[I\n@@ -129,2 +149,2 @@\n-     * @param returnType what the method returns\n-     * @param argTypes what are the argument types\n+     * @param return_type what the method returns\n+     * @param arg_types what are the argument types\n@@ -133,1 +153,1 @@\n-    public static String getMethodSignature(final Type returnType, final Type[] argTypes) {\n+    public static String getMethodSignature( final Type return_type, final Type[] arg_types ) {\n@@ -135,3 +155,3 @@\n-        if (argTypes != null) {\n-            for (final Type argType : argTypes) {\n-                buf.append(argType.getSignature());\n+        if (arg_types != null) {\n+            for (final Type arg_type : arg_types) {\n+                buf.append(arg_type.getSignature());\n@@ -141,1 +161,1 @@\n-        buf.append(returnType.getSignature());\n+        buf.append(return_type.getSignature());\n@@ -145,0 +165,52 @@\n+    private static final ThreadLocal<Integer> consumed_chars = new ThreadLocal<Integer>() {\n+\n+        @Override\n+        protected Integer initialValue() {\n+            return Integer.valueOf(0);\n+        }\n+    };\/\/int consumed_chars=0; \/\/ Remember position in string, see getArgumentTypes\n+\n+\n+    private static int unwrap( final ThreadLocal<Integer> tl ) {\n+        return tl.get().intValue();\n+    }\n+\n+\n+    private static void wrap( final ThreadLocal<Integer> tl, final int value ) {\n+        tl.set(Integer.valueOf(value));\n+    }\n+\n+\n+    \/**\n+     * Convert signature to a Type object.\n+     * @param signature signature string such as Ljava\/lang\/String;\n+     * @return type object\n+     *\/\n+    \/\/ @since 6.0 no longer final\n+    public static Type getType( final String signature ) throws StringIndexOutOfBoundsException {\n+        final byte type = Utility.typeOfSignature(signature);\n+        if (type <= Const.T_VOID) {\n+            \/\/corrected concurrent private static field acess\n+            wrap(consumed_chars, 1);\n+            return BasicType.getType(type);\n+        } else if (type == Const.T_ARRAY) {\n+            int dim = 0;\n+            do { \/\/ Count dimensions\n+                dim++;\n+            } while (signature.charAt(dim) == '[');\n+            \/\/ Recurse, but just once, if the signature is ok\n+            final Type t = getType(signature.substring(dim));\n+            \/\/corrected concurrent private static field acess\n+            \/\/  consumed_chars += dim; \/\/ update counter - is replaced by\n+            final int _temp = unwrap(consumed_chars) + dim;\n+            wrap(consumed_chars, _temp);\n+            return new ArrayType(t, dim);\n+        } else { \/\/ type == T_REFERENCE\n+            \/\/ Utility.typeSignatureToString understands how to parse generic types.\n+            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n+            wrap(consumed_chars, parsedSignature.length() + 2); \/\/ \"Lblabla;\" `L' and `;' are removed\n+            return ObjectType.getInstance(parsedSignature.replace('\/', '.'));\n+        }\n+    }\n+\n+\n@@ -151,1 +223,1 @@\n-    public static Type getReturnType(final String signature) {\n+    public static Type getReturnType( final String signature ) {\n@@ -153,1 +225,1 @@\n-            \/\/ Read return type after ')'\n+            \/\/ Read return type after `)'\n@@ -161,15 +233,0 @@\n-    static int getReturnTypeSize(final String signature) {\n-        final int index = signature.lastIndexOf(')') + 1;\n-        return Type.size(getTypeSize(signature.substring(index)));\n-    }\n-\n-    public static String getSignature(final java.lang.reflect.Method meth) {\n-        final StringBuilder sb = new StringBuilder(\"(\");\n-        final Class<?>[] params = meth.getParameterTypes(); \/\/ avoid clone\n-        for (final Class<?> param : params) {\n-            sb.append(getType(param).getSignature());\n-        }\n-        sb.append(\")\");\n-        sb.append(getType(meth.getReturnType()).getSignature());\n-        return sb.toString();\n-    }\n@@ -178,4 +235,3 @@\n-     * Convert runtime java.lang.Class to BCEL Type object.\n-     *\n-     * @param cls Java class\n-     * @return corresponding Type object\n+     * Convert arguments of a method (signature) to an array of Type objects.\n+     * @param signature signature string such as (Ljava\/lang\/String;)V\n+     * @return array of argument types\n@@ -183,37 +239,17 @@\n-    public static Type getType(final Class<?> cls) {\n-        Objects.requireNonNull(cls, \"cls\");\n-        \/*\n-         * That's an amzingly easy case, because getName() returns the signature. That's what we would have liked anyway.\n-         *\/\n-        if (cls.isArray()) {\n-            return getType(cls.getName());\n-        }\n-        if (!cls.isPrimitive()) { \/\/ \"Real\" class\n-            return ObjectType.getInstance(cls.getName());\n-        }\n-        if (cls == Integer.TYPE) {\n-            return INT;\n-        }\n-        if (cls == Void.TYPE) {\n-            return VOID;\n-        }\n-        if (cls == Double.TYPE) {\n-            return DOUBLE;\n-        }\n-        if (cls == Float.TYPE) {\n-            return FLOAT;\n-        }\n-        if (cls == Boolean.TYPE) {\n-            return BOOLEAN;\n-        }\n-        if (cls == Byte.TYPE) {\n-            return BYTE;\n-        }\n-        if (cls == Short.TYPE) {\n-            return SHORT;\n-        }\n-        if (cls == Long.TYPE) {\n-            return LONG;\n-        }\n-        if (cls == Character.TYPE) {\n-            return CHAR;\n+    public static Type[] getArgumentTypes( final String signature ) {\n+        final List<Type> vec = new ArrayList<>();\n+        int index;\n+        Type[] types;\n+        try {\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n+            index = signature.indexOf('(') + 1;\n+            if (index <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            while (signature.charAt(index) != ')') {\n+                vec.add(getType(signature.substring(index)));\n+                \/\/corrected concurrent private static field acess\n+                index += unwrap(consumed_chars); \/\/ update position\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n@@ -221,1 +257,3 @@\n-        throw new IllegalStateException(\"Unknown primitive type \" + cls);\n+        types = new Type[vec.size()];\n+        vec.toArray(types);\n+        return types;\n@@ -224,5 +262,4 @@\n-    \/**\n-     * Convert signature to a Type object.\n-     *\n-     * @param signature signature string such as Ljava\/lang\/String;\n-     * @return type object\n+\n+    \/** Convert runtime java.lang.Class to BCEL Type object.\n+     * @param cl Java class\n+     * @return corresponding Type object\n@@ -230,6 +267,3 @@\n-    public static Type getType(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= Const.T_VOID) {\n-            \/\/ corrected concurrent private static field acess\n-            wrap(CONSUMED_CHARS, 1);\n-            return BasicType.getType(type);\n+    public static Type getType( final java.lang.Class<?> cl ) {\n+        if (cl == null) {\n+            throw new IllegalArgumentException(\"Class must not be null\");\n@@ -237,5 +271,31 @@\n-        if (type != Const.T_ARRAY) { \/\/ type == T_REFERENCE\n-            \/\/ Utility.typeSignatureToString understands how to parse generic types.\n-            final String parsedSignature = Utility.typeSignatureToString(signature, false);\n-            wrap(CONSUMED_CHARS, parsedSignature.length() + 2); \/\/ \"Lblabla;\" 'L' and ';' are removed\n-            return ObjectType.getInstance(Utility.pathToPackage(parsedSignature));\n+        \/* That's an amzingly easy case, because getName() returns\n+         * the signature. That's what we would have liked anyway.\n+         *\/\n+        if (cl.isArray()) {\n+            return getType(cl.getName());\n+        } else if (cl.isPrimitive()) {\n+            if (cl == Integer.TYPE) {\n+                return INT;\n+            } else if (cl == Void.TYPE) {\n+                return VOID;\n+            } else if (cl == Double.TYPE) {\n+                return DOUBLE;\n+            } else if (cl == Float.TYPE) {\n+                return FLOAT;\n+            } else if (cl == Boolean.TYPE) {\n+                return BOOLEAN;\n+            } else if (cl == Byte.TYPE) {\n+                return BYTE;\n+            } else if (cl == Short.TYPE) {\n+                return SHORT;\n+            } else if (cl == Byte.TYPE) {\n+                return BYTE;\n+            } else if (cl == Long.TYPE) {\n+                return LONG;\n+            } else if (cl == Character.TYPE) {\n+                return CHAR;\n+            } else {\n+                throw new IllegalStateException(\"Unknown primitive type \" + cl);\n+            }\n+        } else { \/\/ \"Real\" class\n+            return ObjectType.getInstance(cl.getName());\n@@ -243,11 +303,0 @@\n-        int dim = 0;\n-        do { \/\/ Count dimensions\n-            dim++;\n-        } while (signature.charAt(dim) == '[');\n-        \/\/ Recurse, but just once, if the signature is ok\n-        final Type t = getType(signature.substring(dim));\n-        \/\/ corrected concurrent private static field acess\n-        \/\/ consumed_chars += dim; \/\/ update counter - is replaced by\n-        final int temp = unwrap(CONSUMED_CHARS) + dim;\n-        wrap(CONSUMED_CHARS, temp);\n-        return new ArrayType(t, dim);\n@@ -256,0 +305,1 @@\n+\n@@ -258,1 +308,0 @@\n-     *\n@@ -262,1 +311,1 @@\n-    public static Type[] getTypes(final Class<?>[] classes) {\n+    public static Type[] getTypes( final java.lang.Class<?>[] classes ) {\n@@ -264,1 +313,3 @@\n-        Arrays.setAll(ret, i -> getType(classes[i]));\n+        for (int i = 0; i < ret.length; i++) {\n+            ret[i] = getType(classes[i]);\n+        }\n@@ -268,17 +319,6 @@\n-    static int getTypeSize(final String signature) throws StringIndexOutOfBoundsException {\n-        final byte type = Utility.typeOfSignature(signature);\n-        if (type <= Const.T_VOID) {\n-            return encode(BasicType.getType(type).getSize(), 1);\n-        }\n-        if (type == Const.T_ARRAY) {\n-            int dim = 0;\n-            do { \/\/ Count dimensions\n-                dim++;\n-            } while (signature.charAt(dim) == '[');\n-            \/\/ Recurse, but just once, if the signature is ok\n-            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n-            return encode(1, dim + consumed);\n-        }\n-        final int index = signature.indexOf(';'); \/\/ Look for closing ';'\n-        if (index < 0) {\n-            throw new ClassFormatException(\"Invalid signature: \" + signature);\n+\n+    public static String getSignature( final java.lang.reflect.Method meth ) {\n+        final StringBuilder sb = new StringBuilder(\"(\");\n+        final Class<?>[] params = meth.getParameterTypes(); \/\/ avoid clone\n+        for (final Class<?> param : params) {\n+            sb.append(getType(param).getSignature());\n@@ -286,1 +326,3 @@\n-        return encode(1, index + 1);\n+        sb.append(\")\");\n+        sb.append(getType(meth.getReturnType()).getSignature());\n+        return sb.toString();\n@@ -293,6 +335,2 @@\n-    private static int unwrap(final ThreadLocal<Integer> tl) {\n-        return tl.get().intValue();\n-    }\n-\n-    private static void wrap(final ThreadLocal<Integer> tl, final int value) {\n-        tl.set(Integer.valueOf(value));\n+    static int consumed(final int coded) {\n+        return coded >> 2;\n@@ -301,15 +339,2 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected byte type; \/\/ TODO should be final (and private)\n-\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access directly, use getter\/setter\n-     *\/\n-    @Deprecated\n-    protected String signature; \/\/ signature for the type TODO should be private\n-\n-    protected Type(final byte type, final String signature) {\n-        this.type = type;\n-        this.signature = signature;\n+    static int encode(final int size, final int consumed) {\n+        return consumed << 2 | size;\n@@ -318,8 +343,16 @@\n-    \/**\n-     * @return whether the Types are equal\n-     *\/\n-    @Override\n-    public boolean equals(final Object o) {\n-        if (o instanceof Type) {\n-            final Type t = (Type) o;\n-            return type == t.type && signature.equals(t.signature);\n+    static int getArgumentTypesSize( final String signature ) {\n+        int res = 0;\n+        int index;\n+        try {\n+            \/\/ Skip any type arguments to read argument declarations between `(' and `)'\n+            index = signature.indexOf('(') + 1;\n+            if (index <= 0) {\n+                throw new ClassFormatException(\"Invalid method signature: \" + signature);\n+            }\n+            while (signature.charAt(index) != ')') {\n+                final int coded = getTypeSize(signature.substring(index));\n+                res += size(coded);\n+                index += consumed(coded);\n+            }\n+        } catch (final StringIndexOutOfBoundsException e) { \/\/ Should never occur\n+            throw new ClassFormatException(\"Invalid method signature: \" + signature, e);\n@@ -327,12 +360,1 @@\n-        return false;\n-    }\n-\n-    public String getClassName() {\n-        return toString();\n-    }\n-\n-    \/**\n-     * @return signature for given type.\n-     *\/\n-    public String getSignature() {\n-        return signature;\n+        return res;\n@@ -341,12 +363,18 @@\n-    \/**\n-     * @return stack size of this type (2 for long and double, 0 for void, 1 otherwise)\n-     *\/\n-    public int getSize() {\n-        switch (type) {\n-        case Const.T_DOUBLE:\n-        case Const.T_LONG:\n-            return 2;\n-        case Const.T_VOID:\n-            return 0;\n-        default:\n-            return 1;\n+    static int getTypeSize( final String signature ) throws StringIndexOutOfBoundsException {\n+        final byte type = Utility.typeOfSignature(signature);\n+        if (type <= Const.T_VOID) {\n+            return encode(BasicType.getType(type).getSize(), 1);\n+        } else if (type == Const.T_ARRAY) {\n+            int dim = 0;\n+            do { \/\/ Count dimensions\n+                dim++;\n+            } while (signature.charAt(dim) == '[');\n+            \/\/ Recurse, but just once, if the signature is ok\n+            final int consumed = consumed(getTypeSize(signature.substring(dim)));\n+            return encode(1, dim + consumed);\n+        } else { \/\/ type == T_REFERENCE\n+            final int index = signature.indexOf(';'); \/\/ Look for closing `;'\n+            if (index < 0) {\n+                throw new ClassFormatException(\"Invalid signature: \" + signature);\n+            }\n+            return encode(1, index + 1);\n@@ -356,6 +384,0 @@\n-    \/**\n-     * @return type as defined in Constants\n-     *\/\n-    public byte getType() {\n-        return type;\n-    }\n@@ -363,6 +385,3 @@\n-    \/**\n-     * @return hashcode of Type\n-     *\/\n-    @Override\n-    public int hashCode() {\n-        return type ^ signature.hashCode();\n+    static int getReturnTypeSize(final String signature) {\n+        final int index = signature.lastIndexOf(')') + 1;\n+        return Type.size(getTypeSize(signature.substring(index)));\n@@ -371,12 +390,0 @@\n-    \/**\n-     * boolean, short and char variable are considered as int in the stack or local variable area. Returns {@link Type#INT}\n-     * for {@link Type#BOOLEAN}, {@link Type#SHORT} or {@link Type#CHAR}, otherwise returns the given type.\n-     *\n-     * @since 6.0\n-     *\/\n-    public Type normalizeForStackOrLocal() {\n-        if (this == Type.BOOLEAN || this == Type.BYTE || this == Type.SHORT || this == Type.CHAR) {\n-            return Type.INT;\n-        }\n-        return this;\n-    }\n@@ -385,2 +392,3 @@\n-     * Currently only used by the ArrayType constructor. The signature has a complicated dependency on other parameter so\n-     * it's tricky to do it in a call to the super ctor.\n+     * Currently only used by the ArrayType constructor.\n+     * The signature has a complicated dependency on other parameter\n+     * so it's tricky to do it in a call to the super ctor.\n@@ -391,8 +399,0 @@\n-\n-    \/**\n-     * @return Type string, e.g. 'int[]'\n-     *\/\n-    @Override\n-    public String toString() {\n-        return this.equals(Type.NULL) || type >= Const.T_UNKNOWN ? signature : Utility.signatureToString(signature, false);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Type.java","additions":259,"deletions":259,"binary":false,"changes":518,"status":"modified"},{"patch":"@@ -25,1 +25,3 @@\n- * Get the type associated with an instruction, int for ILOAD, or the type of the field of a PUTFIELD instruction, e.g..\n+ * Get the type associated with an instruction, int for ILOAD, or the type\n+ * of the field of a PUTFIELD instruction, e.g..\n+ *\n@@ -29,1 +31,1 @@\n-    Type getType(ConstantPoolGen cpg);\n+    Type getType( ConstantPoolGen cpg );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/TypedInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/UnconditionalBranch.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,2 +25,2 @@\n- * Denotes an instruction to be a variable length instruction, such as GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n- *\n+ * Denotes an instruction to be a variable length instruction, such as\n+ * GOTO, JSR, LOOKUPSWITCH and TABLESWITCH.\n@@ -28,0 +28,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/VariableLengthInstruction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,2 +25,5 @@\n- * Interface implementing the Visitor pattern programming style. I.e., a class that implements this interface can handle\n- * all types of instructions with the properly typed methods just by calling the accept() method.\n+ * Interface implementing the Visitor pattern programming style.\n+ * I.e., a class that implements this interface can handle all types of\n+ * instructions with the properly typed methods just by calling the accept()\n+ * method.\n+ *\n@@ -30,1 +33,136 @@\n-    void visitAALOAD(AALOAD obj);\n+    void visitStackInstruction( StackInstruction obj );\n+\n+\n+    void visitLocalVariableInstruction( LocalVariableInstruction obj );\n+\n+\n+    void visitBranchInstruction( BranchInstruction obj );\n+\n+\n+    void visitLoadClass( LoadClass obj );\n+\n+\n+    void visitFieldInstruction( FieldInstruction obj );\n+\n+\n+    void visitIfInstruction( IfInstruction obj );\n+\n+\n+    void visitConversionInstruction( ConversionInstruction obj );\n+\n+\n+    void visitPopInstruction( PopInstruction obj );\n+\n+\n+    void visitStoreInstruction( StoreInstruction obj );\n+\n+\n+    void visitTypedInstruction( TypedInstruction obj );\n+\n+\n+    void visitSelect( Select obj );\n+\n+\n+    void visitJsrInstruction( JsrInstruction obj );\n+\n+\n+    void visitGotoInstruction( GotoInstruction obj );\n+\n+\n+    void visitUnconditionalBranch( UnconditionalBranch obj );\n+\n+\n+    void visitPushInstruction( PushInstruction obj );\n+\n+\n+    void visitArithmeticInstruction( ArithmeticInstruction obj );\n+\n+\n+    void visitCPInstruction( CPInstruction obj );\n+\n+\n+    void visitInvokeInstruction( InvokeInstruction obj );\n+\n+\n+    void visitArrayInstruction( ArrayInstruction obj );\n+\n+\n+    void visitAllocationInstruction( AllocationInstruction obj );\n+\n+\n+    void visitReturnInstruction( ReturnInstruction obj );\n+\n+\n+    void visitFieldOrMethod( FieldOrMethod obj );\n+\n+\n+    void visitConstantPushInstruction( ConstantPushInstruction obj );\n+\n+\n+    void visitExceptionThrower( ExceptionThrower obj );\n+\n+\n+    void visitLoadInstruction( LoadInstruction obj );\n+\n+\n+    void visitVariableLengthInstruction( VariableLengthInstruction obj );\n+\n+\n+    void visitStackProducer( StackProducer obj );\n+\n+\n+    void visitStackConsumer( StackConsumer obj );\n+\n+\n+    void visitACONST_NULL( ACONST_NULL obj );\n+\n+\n+    void visitGETSTATIC( GETSTATIC obj );\n+\n+\n+    void visitIF_ICMPLT( IF_ICMPLT obj );\n+\n+\n+    void visitMONITOREXIT( MONITOREXIT obj );\n+\n+\n+    void visitIFLT( IFLT obj );\n+\n+\n+    void visitLSTORE( LSTORE obj );\n+\n+\n+    void visitPOP2( POP2 obj );\n+\n+\n+    void visitBASTORE( BASTORE obj );\n+\n+\n+    void visitISTORE( ISTORE obj );\n+\n+\n+    void visitCHECKCAST( CHECKCAST obj );\n+\n+\n+    void visitFCMPG( FCMPG obj );\n+\n+\n+    void visitI2F( I2F obj );\n+\n+\n+    void visitATHROW( ATHROW obj );\n+\n+\n+    void visitDCMPL( DCMPL obj );\n+\n+\n+    void visitARRAYLENGTH( ARRAYLENGTH obj );\n+\n+\n+    void visitDUP( DUP obj );\n+\n+\n+    void visitINVOKESTATIC( INVOKESTATIC obj );\n+\n+\n+    void visitLCONST( LCONST obj );\n@@ -32,1 +170,0 @@\n-    void visitAASTORE(AASTORE obj);\n@@ -34,1 +171,1 @@\n-    void visitACONST_NULL(ACONST_NULL obj);\n+    void visitDREM( DREM obj );\n@@ -36,1 +173,0 @@\n-    void visitAllocationInstruction(AllocationInstruction obj);\n@@ -38,1 +174,1 @@\n-    void visitALOAD(ALOAD obj);\n+    void visitIFGE( IFGE obj );\n@@ -40,1 +176,0 @@\n-    void visitANEWARRAY(ANEWARRAY obj);\n@@ -42,1 +177,1 @@\n-    void visitARETURN(ARETURN obj);\n+    void visitCALOAD( CALOAD obj );\n@@ -44,1 +179,0 @@\n-    void visitArithmeticInstruction(ArithmeticInstruction obj);\n@@ -46,1 +180,1 @@\n-    void visitArrayInstruction(ArrayInstruction obj);\n+    void visitLASTORE( LASTORE obj );\n@@ -48,1 +182,0 @@\n-    void visitARRAYLENGTH(ARRAYLENGTH obj);\n@@ -50,1 +183,1 @@\n-    void visitASTORE(ASTORE obj);\n+    void visitI2D( I2D obj );\n@@ -52,1 +185,0 @@\n-    void visitATHROW(ATHROW obj);\n@@ -54,1 +186,1 @@\n-    void visitBALOAD(BALOAD obj);\n+    void visitDADD( DADD obj );\n@@ -56,1 +188,0 @@\n-    void visitBASTORE(BASTORE obj);\n@@ -58,1 +189,1 @@\n-    void visitBIPUSH(BIPUSH obj);\n+    void visitINVOKESPECIAL( INVOKESPECIAL obj );\n@@ -60,1 +191,0 @@\n-    void visitBranchInstruction(BranchInstruction obj);\n@@ -62,1 +192,1 @@\n-    void visitBREAKPOINT(BREAKPOINT obj);\n+    void visitIAND( IAND obj );\n@@ -64,1 +194,0 @@\n-    void visitCALOAD(CALOAD obj);\n@@ -66,1 +195,1 @@\n-    void visitCASTORE(CASTORE obj);\n+    void visitPUTFIELD( PUTFIELD obj );\n@@ -68,1 +197,0 @@\n-    void visitCHECKCAST(CHECKCAST obj);\n@@ -70,1 +198,1 @@\n-    void visitConstantPushInstruction(ConstantPushInstruction obj);\n+    void visitILOAD( ILOAD obj );\n@@ -72,1 +200,0 @@\n-    void visitConversionInstruction(ConversionInstruction obj);\n@@ -74,1 +201,1 @@\n-    void visitCPInstruction(CPInstruction obj);\n+    void visitDLOAD( DLOAD obj );\n@@ -76,1 +203,0 @@\n-    void visitD2F(D2F obj);\n@@ -78,1 +204,1 @@\n-    void visitD2I(D2I obj);\n+    void visitDCONST( DCONST obj );\n@@ -80,1 +206,0 @@\n-    void visitD2L(D2L obj);\n@@ -82,1 +207,1 @@\n-    void visitDADD(DADD obj);\n+    void visitNEW( NEW obj );\n@@ -84,1 +209,0 @@\n-    void visitDALOAD(DALOAD obj);\n@@ -86,1 +210,1 @@\n-    void visitDASTORE(DASTORE obj);\n+    void visitIFNULL( IFNULL obj );\n@@ -88,1 +212,0 @@\n-    void visitDCMPG(DCMPG obj);\n@@ -90,1 +213,1 @@\n-    void visitDCMPL(DCMPL obj);\n+    void visitLSUB( LSUB obj );\n@@ -92,1 +215,0 @@\n-    void visitDCONST(DCONST obj);\n@@ -94,1 +216,1 @@\n-    void visitDDIV(DDIV obj);\n+    void visitL2I( L2I obj );\n@@ -96,1 +218,0 @@\n-    void visitDLOAD(DLOAD obj);\n@@ -98,1 +219,1 @@\n-    void visitDMUL(DMUL obj);\n+    void visitISHR( ISHR obj );\n@@ -100,1 +221,0 @@\n-    void visitDNEG(DNEG obj);\n@@ -102,1 +222,1 @@\n-    void visitDREM(DREM obj);\n+    void visitTABLESWITCH( TABLESWITCH obj );\n@@ -104,1 +224,0 @@\n-    void visitDRETURN(DRETURN obj);\n@@ -106,1 +225,1 @@\n-    void visitDSTORE(DSTORE obj);\n+    void visitIINC( IINC obj );\n@@ -108,1 +227,0 @@\n-    void visitDSUB(DSUB obj);\n@@ -110,1 +228,1 @@\n-    void visitDUP(DUP obj);\n+    void visitDRETURN( DRETURN obj );\n@@ -112,1 +230,0 @@\n-    void visitDUP_X1(DUP_X1 obj);\n@@ -114,1 +231,1 @@\n-    void visitDUP_X2(DUP_X2 obj);\n+    void visitFSTORE( FSTORE obj );\n@@ -116,1 +233,0 @@\n-    void visitDUP2(DUP2 obj);\n@@ -118,1 +234,1 @@\n-    void visitDUP2_X1(DUP2_X1 obj);\n+    void visitDASTORE( DASTORE obj );\n@@ -120,1 +236,0 @@\n-    void visitDUP2_X2(DUP2_X2 obj);\n@@ -122,1 +237,1 @@\n-    void visitExceptionThrower(ExceptionThrower obj);\n+    void visitIALOAD( IALOAD obj );\n@@ -124,1 +239,0 @@\n-    void visitF2D(F2D obj);\n@@ -126,1 +240,1 @@\n-    void visitF2I(F2I obj);\n+    void visitDDIV( DDIV obj );\n@@ -128,1 +242,0 @@\n-    void visitF2L(F2L obj);\n@@ -130,1 +243,1 @@\n-    void visitFADD(FADD obj);\n+    void visitIF_ICMPGE( IF_ICMPGE obj );\n@@ -132,1 +245,0 @@\n-    void visitFALOAD(FALOAD obj);\n@@ -134,1 +246,1 @@\n-    void visitFASTORE(FASTORE obj);\n+    void visitLAND( LAND obj );\n@@ -136,1 +248,0 @@\n-    void visitFCMPG(FCMPG obj);\n@@ -138,1 +249,1 @@\n-    void visitFCMPL(FCMPL obj);\n+    void visitIDIV( IDIV obj );\n@@ -140,1 +251,0 @@\n-    void visitFCONST(FCONST obj);\n@@ -142,1 +252,1 @@\n-    void visitFDIV(FDIV obj);\n+    void visitLOR( LOR obj );\n@@ -144,1 +254,0 @@\n-    void visitFieldInstruction(FieldInstruction obj);\n@@ -146,1 +255,1 @@\n-    void visitFieldOrMethod(FieldOrMethod obj);\n+    void visitCASTORE( CASTORE obj );\n@@ -148,1 +257,0 @@\n-    void visitFLOAD(FLOAD obj);\n@@ -150,1 +258,1 @@\n-    void visitFMUL(FMUL obj);\n+    void visitFREM( FREM obj );\n@@ -152,1 +260,0 @@\n-    void visitFNEG(FNEG obj);\n@@ -154,1 +261,1 @@\n-    void visitFREM(FREM obj);\n+    void visitLDC( LDC obj );\n@@ -156,1 +263,0 @@\n-    void visitFRETURN(FRETURN obj);\n@@ -158,1 +264,1 @@\n-    void visitFSTORE(FSTORE obj);\n+    void visitBIPUSH( BIPUSH obj );\n@@ -160,1 +266,0 @@\n-    void visitFSUB(FSUB obj);\n@@ -162,1 +267,1 @@\n-    void visitGETFIELD(GETFIELD obj);\n+    void visitDSTORE( DSTORE obj );\n@@ -164,1 +269,0 @@\n-    void visitGETSTATIC(GETSTATIC obj);\n@@ -166,1 +270,1 @@\n-    void visitGOTO(GOTO obj);\n+    void visitF2L( F2L obj );\n@@ -168,1 +272,0 @@\n-    void visitGOTO_W(GOTO_W obj);\n@@ -170,1 +273,1 @@\n-    void visitGotoInstruction(GotoInstruction obj);\n+    void visitFMUL( FMUL obj );\n@@ -172,1 +275,0 @@\n-    void visitI2B(I2B obj);\n@@ -174,1 +276,1 @@\n-    void visitI2C(I2C obj);\n+    void visitLLOAD( LLOAD obj );\n@@ -176,1 +278,0 @@\n-    void visitI2D(I2D obj);\n@@ -178,1 +279,1 @@\n-    void visitI2F(I2F obj);\n+    void visitJSR( JSR obj );\n@@ -180,1 +281,0 @@\n-    void visitI2L(I2L obj);\n@@ -182,1 +282,1 @@\n-    void visitI2S(I2S obj);\n+    void visitFSUB( FSUB obj );\n@@ -184,1 +284,0 @@\n-    void visitIADD(IADD obj);\n@@ -186,1 +285,1 @@\n-    void visitIALOAD(IALOAD obj);\n+    void visitSASTORE( SASTORE obj );\n@@ -188,1 +287,0 @@\n-    void visitIAND(IAND obj);\n@@ -190,1 +288,1 @@\n-    void visitIASTORE(IASTORE obj);\n+    void visitALOAD( ALOAD obj );\n@@ -192,1 +290,0 @@\n-    void visitICONST(ICONST obj);\n@@ -194,1 +291,1 @@\n-    void visitIDIV(IDIV obj);\n+    void visitDUP2_X2( DUP2_X2 obj );\n@@ -196,1 +293,0 @@\n-    void visitIF_ACMPEQ(IF_ACMPEQ obj);\n@@ -198,1 +294,1 @@\n-    void visitIF_ACMPNE(IF_ACMPNE obj);\n+    void visitRETURN( RETURN obj );\n@@ -200,1 +296,0 @@\n-    void visitIF_ICMPEQ(IF_ICMPEQ obj);\n@@ -202,1 +297,1 @@\n-    void visitIF_ICMPGE(IF_ICMPGE obj);\n+    void visitDALOAD( DALOAD obj );\n@@ -204,1 +299,0 @@\n-    void visitIF_ICMPGT(IF_ICMPGT obj);\n@@ -206,1 +300,1 @@\n-    void visitIF_ICMPLE(IF_ICMPLE obj);\n+    void visitSIPUSH( SIPUSH obj );\n@@ -208,1 +302,0 @@\n-    void visitIF_ICMPLT(IF_ICMPLT obj);\n@@ -210,1 +303,1 @@\n-    void visitIF_ICMPNE(IF_ICMPNE obj);\n+    void visitDSUB( DSUB obj );\n@@ -212,1 +305,0 @@\n-    void visitIFEQ(IFEQ obj);\n@@ -214,1 +306,1 @@\n-    void visitIFGE(IFGE obj);\n+    void visitL2F( L2F obj );\n@@ -216,1 +308,0 @@\n-    void visitIFGT(IFGT obj);\n@@ -218,1 +309,1 @@\n-    void visitIfInstruction(IfInstruction obj);\n+    void visitIF_ICMPGT( IF_ICMPGT obj );\n@@ -220,1 +311,0 @@\n-    void visitIFLE(IFLE obj);\n@@ -222,1 +312,1 @@\n-    void visitIFLT(IFLT obj);\n+    void visitF2D( F2D obj );\n@@ -224,1 +314,0 @@\n-    void visitIFNE(IFNE obj);\n@@ -226,1 +315,1 @@\n-    void visitIFNONNULL(IFNONNULL obj);\n+    void visitI2L( I2L obj );\n@@ -228,1 +317,0 @@\n-    void visitIFNULL(IFNULL obj);\n@@ -230,1 +318,1 @@\n-    void visitIINC(IINC obj);\n+    void visitIF_ACMPNE( IF_ACMPNE obj );\n@@ -232,1 +320,0 @@\n-    void visitILOAD(ILOAD obj);\n@@ -234,1 +321,1 @@\n-    void visitIMPDEP1(IMPDEP1 obj);\n+    void visitPOP( POP obj );\n@@ -236,1 +323,0 @@\n-    void visitIMPDEP2(IMPDEP2 obj);\n@@ -238,1 +324,1 @@\n-    void visitIMUL(IMUL obj);\n+    void visitI2S( I2S obj );\n@@ -240,1 +326,0 @@\n-    void visitINEG(INEG obj);\n@@ -242,1 +327,125 @@\n-    void visitINSTANCEOF(INSTANCEOF obj);\n+    void visitIFEQ( IFEQ obj );\n+\n+\n+    void visitSWAP( SWAP obj );\n+\n+\n+    void visitIOR( IOR obj );\n+\n+\n+    void visitIREM( IREM obj );\n+\n+\n+    void visitIASTORE( IASTORE obj );\n+\n+\n+    void visitNEWARRAY( NEWARRAY obj );\n+\n+\n+    void visitINVOKEINTERFACE( INVOKEINTERFACE obj );\n+\n+\n+    void visitINEG( INEG obj );\n+\n+\n+    void visitLCMP( LCMP obj );\n+\n+\n+    void visitJSR_W( JSR_W obj );\n+\n+\n+    void visitMULTIANEWARRAY( MULTIANEWARRAY obj );\n+\n+\n+    void visitDUP_X2( DUP_X2 obj );\n+\n+\n+    void visitSALOAD( SALOAD obj );\n+\n+\n+    void visitIFNONNULL( IFNONNULL obj );\n+\n+\n+    void visitDMUL( DMUL obj );\n+\n+\n+    void visitIFNE( IFNE obj );\n+\n+\n+    void visitIF_ICMPLE( IF_ICMPLE obj );\n+\n+\n+    void visitLDC2_W( LDC2_W obj );\n+\n+\n+    void visitGETFIELD( GETFIELD obj );\n+\n+\n+    void visitLADD( LADD obj );\n+\n+\n+    void visitNOP( NOP obj );\n+\n+\n+    void visitFALOAD( FALOAD obj );\n+\n+\n+    void visitINSTANCEOF( INSTANCEOF obj );\n+\n+\n+    void visitIFLE( IFLE obj );\n+\n+\n+    void visitLXOR( LXOR obj );\n+\n+\n+    void visitLRETURN( LRETURN obj );\n+\n+\n+    void visitFCONST( FCONST obj );\n+\n+\n+    void visitIUSHR( IUSHR obj );\n+\n+\n+    void visitBALOAD( BALOAD obj );\n+\n+\n+    void visitDUP2( DUP2 obj );\n+\n+\n+    void visitIF_ACMPEQ( IF_ACMPEQ obj );\n+\n+\n+    void visitIMPDEP1( IMPDEP1 obj );\n+\n+\n+    void visitMONITORENTER( MONITORENTER obj );\n+\n+\n+    void visitLSHL( LSHL obj );\n+\n+\n+    void visitDCMPG( DCMPG obj );\n+\n+\n+    void visitD2L( D2L obj );\n+\n+\n+    void visitIMPDEP2( IMPDEP2 obj );\n+\n+\n+    void visitL2D( L2D obj );\n+\n+\n+    void visitRET( RET obj );\n+\n+\n+    void visitIFGT( IFGT obj );\n+\n+\n+    void visitIXOR( IXOR obj );\n+\n+\n+    void visitINVOKEVIRTUAL( INVOKEVIRTUAL obj );\n+\n@@ -247,1 +456,11 @@\n-    void visitINVOKEDYNAMIC(INVOKEDYNAMIC obj);\n+    void visitINVOKEDYNAMIC( INVOKEDYNAMIC obj );\n+\n+\n+    void visitFASTORE( FASTORE obj );\n+\n+\n+    void visitIRETURN( IRETURN obj );\n+\n+\n+    void visitIF_ICMPNE( IF_ICMPNE obj );\n+\n@@ -249,1 +468,1 @@\n-    void visitInvokeInstruction(InvokeInstruction obj);\n+    void visitFLOAD( FLOAD obj );\n@@ -251,1 +470,0 @@\n-    void visitINVOKEINTERFACE(INVOKEINTERFACE obj);\n@@ -253,1 +471,1 @@\n-    void visitINVOKESPECIAL(INVOKESPECIAL obj);\n+    void visitLDIV( LDIV obj );\n@@ -255,1 +473,0 @@\n-    void visitINVOKESTATIC(INVOKESTATIC obj);\n@@ -257,1 +474,1 @@\n-    void visitINVOKEVIRTUAL(INVOKEVIRTUAL obj);\n+    void visitPUTSTATIC( PUTSTATIC obj );\n@@ -259,1 +476,0 @@\n-    void visitIOR(IOR obj);\n@@ -261,1 +477,1 @@\n-    void visitIREM(IREM obj);\n+    void visitAALOAD( AALOAD obj );\n@@ -263,1 +479,0 @@\n-    void visitIRETURN(IRETURN obj);\n@@ -265,1 +480,1 @@\n-    void visitISHL(ISHL obj);\n+    void visitD2I( D2I obj );\n@@ -267,1 +482,0 @@\n-    void visitISHR(ISHR obj);\n@@ -269,1 +483,1 @@\n-    void visitISTORE(ISTORE obj);\n+    void visitIF_ICMPEQ( IF_ICMPEQ obj );\n@@ -271,1 +485,0 @@\n-    void visitISUB(ISUB obj);\n@@ -273,1 +486,1 @@\n-    void visitIUSHR(IUSHR obj);\n+    void visitAASTORE( AASTORE obj );\n@@ -275,1 +488,0 @@\n-    void visitIXOR(IXOR obj);\n@@ -277,1 +489,1 @@\n-    void visitJSR(JSR obj);\n+    void visitARETURN( ARETURN obj );\n@@ -279,1 +491,0 @@\n-    void visitJSR_W(JSR_W obj);\n@@ -281,1 +492,1 @@\n-    void visitJsrInstruction(JsrInstruction obj);\n+    void visitDUP2_X1( DUP2_X1 obj );\n@@ -283,1 +494,0 @@\n-    void visitL2D(L2D obj);\n@@ -285,1 +495,1 @@\n-    void visitL2F(L2F obj);\n+    void visitFNEG( FNEG obj );\n@@ -287,1 +497,0 @@\n-    void visitL2I(L2I obj);\n@@ -289,1 +498,1 @@\n-    void visitLADD(LADD obj);\n+    void visitGOTO_W( GOTO_W obj );\n@@ -291,1 +500,0 @@\n-    void visitLALOAD(LALOAD obj);\n@@ -293,1 +501,1 @@\n-    void visitLAND(LAND obj);\n+    void visitD2F( D2F obj );\n@@ -295,1 +503,0 @@\n-    void visitLASTORE(LASTORE obj);\n@@ -297,1 +504,1 @@\n-    void visitLCMP(LCMP obj);\n+    void visitGOTO( GOTO obj );\n@@ -299,1 +506,0 @@\n-    void visitLCONST(LCONST obj);\n@@ -301,1 +507,1 @@\n-    void visitLDC(LDC obj);\n+    void visitISUB( ISUB obj );\n@@ -303,1 +509,0 @@\n-    void visitLDC2_W(LDC2_W obj);\n@@ -305,1 +510,1 @@\n-    void visitLDIV(LDIV obj);\n+    void visitF2I( F2I obj );\n@@ -307,1 +512,0 @@\n-    void visitLLOAD(LLOAD obj);\n@@ -309,1 +513,1 @@\n-    void visitLMUL(LMUL obj);\n+    void visitDNEG( DNEG obj );\n@@ -311,1 +515,0 @@\n-    void visitLNEG(LNEG obj);\n@@ -313,1 +516,1 @@\n-    void visitLoadClass(LoadClass obj);\n+    void visitICONST( ICONST obj );\n@@ -315,1 +518,0 @@\n-    void visitLoadInstruction(LoadInstruction obj);\n@@ -317,1 +519,1 @@\n-    void visitLocalVariableInstruction(LocalVariableInstruction obj);\n+    void visitFDIV( FDIV obj );\n@@ -319,1 +521,0 @@\n-    void visitLOOKUPSWITCH(LOOKUPSWITCH obj);\n@@ -321,1 +522,1 @@\n-    void visitLOR(LOR obj);\n+    void visitI2B( I2B obj );\n@@ -323,1 +524,0 @@\n-    void visitLREM(LREM obj);\n@@ -325,1 +525,1 @@\n-    void visitLRETURN(LRETURN obj);\n+    void visitLNEG( LNEG obj );\n@@ -327,1 +527,0 @@\n-    void visitLSHL(LSHL obj);\n@@ -329,1 +528,1 @@\n-    void visitLSHR(LSHR obj);\n+    void visitLREM( LREM obj );\n@@ -331,1 +530,0 @@\n-    void visitLSTORE(LSTORE obj);\n@@ -333,1 +531,1 @@\n-    void visitLSUB(LSUB obj);\n+    void visitIMUL( IMUL obj );\n@@ -335,1 +533,0 @@\n-    void visitLUSHR(LUSHR obj);\n@@ -337,1 +534,1 @@\n-    void visitLXOR(LXOR obj);\n+    void visitIADD( IADD obj );\n@@ -339,1 +536,0 @@\n-    void visitMONITORENTER(MONITORENTER obj);\n@@ -341,1 +537,1 @@\n-    void visitMONITOREXIT(MONITOREXIT obj);\n+    void visitLSHR( LSHR obj );\n@@ -343,1 +539,0 @@\n-    void visitMULTIANEWARRAY(MULTIANEWARRAY obj);\n@@ -345,1 +540,1 @@\n-    void visitNEW(NEW obj);\n+    void visitLOOKUPSWITCH( LOOKUPSWITCH obj );\n@@ -347,1 +542,0 @@\n-    void visitNEWARRAY(NEWARRAY obj);\n@@ -349,1 +543,1 @@\n-    void visitNOP(NOP obj);\n+    void visitDUP_X1( DUP_X1 obj );\n@@ -351,1 +545,0 @@\n-    void visitPOP(POP obj);\n@@ -353,1 +546,1 @@\n-    void visitPOP2(POP2 obj);\n+    void visitFCMPL( FCMPL obj );\n@@ -355,1 +548,0 @@\n-    void visitPopInstruction(PopInstruction obj);\n@@ -357,1 +549,1 @@\n-    void visitPushInstruction(PushInstruction obj);\n+    void visitI2C( I2C obj );\n@@ -359,1 +551,0 @@\n-    void visitPUTFIELD(PUTFIELD obj);\n@@ -361,1 +552,1 @@\n-    void visitPUTSTATIC(PUTSTATIC obj);\n+    void visitLMUL( LMUL obj );\n@@ -363,1 +554,0 @@\n-    void visitRET(RET obj);\n@@ -365,1 +555,1 @@\n-    void visitRETURN(RETURN obj);\n+    void visitLUSHR( LUSHR obj );\n@@ -367,1 +557,0 @@\n-    void visitReturnInstruction(ReturnInstruction obj);\n@@ -369,1 +558,1 @@\n-    void visitSALOAD(SALOAD obj);\n+    void visitISHL( ISHL obj );\n@@ -371,1 +560,0 @@\n-    void visitSASTORE(SASTORE obj);\n@@ -373,1 +561,1 @@\n-    void visitSelect(Select obj);\n+    void visitLALOAD( LALOAD obj );\n@@ -375,1 +563,0 @@\n-    void visitSIPUSH(SIPUSH obj);\n@@ -377,1 +564,1 @@\n-    void visitStackConsumer(StackConsumer obj);\n+    void visitASTORE( ASTORE obj );\n@@ -379,1 +566,0 @@\n-    void visitStackInstruction(StackInstruction obj);\n@@ -381,1 +567,1 @@\n-    void visitStackProducer(StackProducer obj);\n+    void visitANEWARRAY( ANEWARRAY obj );\n@@ -383,1 +569,0 @@\n-    void visitStoreInstruction(StoreInstruction obj);\n@@ -385,1 +570,1 @@\n-    void visitSWAP(SWAP obj);\n+    void visitFRETURN( FRETURN obj );\n@@ -387,1 +572,0 @@\n-    void visitTABLESWITCH(TABLESWITCH obj);\n@@ -389,1 +573,1 @@\n-    void visitTypedInstruction(TypedInstruction obj);\n+    void visitFADD( FADD obj );\n@@ -391,1 +575,0 @@\n-    void visitUnconditionalBranch(UnconditionalBranch obj);\n@@ -393,1 +576,1 @@\n-    void visitVariableLengthInstruction(VariableLengthInstruction obj);\n+    void visitBREAKPOINT( BREAKPOINT obj );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/generic\/Visitor.java","additions":366,"deletions":183,"binary":false,"changes":549,"status":"modified"},{"patch":"@@ -1,148 +0,0 @@\n-\/*\n- * reserved comment block\n- * DO NOT REMOVE OR ALTER!\n- *\/\n-\/*\n- * Licensed to the Apache Software Foundation (ASF) under one or more\n- * contributor license agreements.  See the NOTICE file distributed with\n- * this work for additional information regarding copyright ownership.\n- * The ASF licenses this file to You under the Apache License, Version 2.0\n- * (the \"License\"); you may not use this file except in compliance with\n- * the License.  You may obtain a copy of the License at\n- *\n- *      http:\/\/www.apache.org\/licenses\/LICENSE-2.0\n- *\n- *  Unless required by applicable law or agreed to in writing, software\n- *  distributed under the License is distributed on an \"AS IS\" BASIS,\n- *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- *  See the License for the specific language governing permissions and\n- *  limitations under the License.\n- *\/\n-\n-package com.sun.org.apache.bcel.internal.util;\n-\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.classfile.ClassFormatException;\n-\n-\/**\n- * Argument validation.\n- *\n- * @since 6.7.0\n- *\/\n-public class Args {\n-\n-    \/**\n-     * Requires a specific value.\n-     *\n-     * @param value    The value to test.\n-     * @param required The required value.\n-     * @param message  The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int require(final int value, final int required, final String message) {\n-        if (value != required) {\n-            throw new ClassFormatException(String.format(\"%s [Value must be 0: %,d]\", message, value));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a 0 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int require0(final int value, final String message) {\n-        return require(value, 0, message);\n-    }\n-\n-    \/**\n-     * Requires a u1 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU1(final int value, final String message) {\n-        if (value < 0 || value > Const.MAX_BYTE) {\n-            throw new ClassFormatException(String.format(\"%s [Value out of range (0 - %,d) for type u1: %,d]\", message, Const.MAX_BYTE, value));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a u2 value of at least {@code min} and not above {@code max}.\n-     *\n-     * @param value   The value to test.\n-     * @param min     The minimum required u2 value.\n-     * @param max     The maximum required u2 value.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU2(final int value, final int min, final int max, final String message) {\n-        if (max > Const.MAX_SHORT) {\n-            throw new IllegalArgumentException(String.format(\"%s programming error: max %,d > %,d\", message, max, Const.MAX_SHORT));\n-        }\n-        if (min < 0) {\n-            throw new IllegalArgumentException(String.format(\"%s programming error: min %,d < 0\", message, min));\n-        }\n-        if (value < min || value > max) {\n-            throw new ClassFormatException(String.format(\"%s [Value out of range (%,d - %,d) for type u2: %,d]\", message, min, Const.MAX_SHORT, value));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a u2 value of at least {@code min}.\n-     *\n-     * @param value   The value to test.\n-     * @param min     The minimum required value.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU2(final int value, final int min, final String message) {\n-        return requireU2(value, min, Const.MAX_SHORT, message);\n-    }\n-\n-    \/**\n-     * Requires a u2 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU2(final int value, final String message) {\n-        return requireU2(value, 0, message);\n-    }\n-\n-    \/**\n-     * Requires a u4 value of at least {@code min}.\n-     *\n-     * @param value   The value to test.\n-     * @param min     The minimum required value.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU4(final int value, final int min, final String message) {\n-        if (min < 0) {\n-            throw new IllegalArgumentException(String.format(\"%s programming error: min %,d < 0\", message, min));\n-        }\n-        if (value < min) {\n-            throw new ClassFormatException(\n-                    String.format(\"%s [Value out of range (%,d - %,d) for type u2: %,d]\", message, min, Integer.MAX_VALUE, value & 0xFFFFFFFFL));\n-        }\n-        return value;\n-    }\n-\n-    \/**\n-     * Requires a u4 value.\n-     *\n-     * @param value   The value to test.\n-     * @param message The message prefix\n-     * @return The value to test.\n-     *\/\n-    public static int requireU4(final int value, final String message) {\n-        return requireU4(value, 0, message);\n-    }\n-}\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Args.java","additions":0,"deletions":148,"binary":false,"changes":148,"status":"deleted"},{"patch":"@@ -24,2 +24,2 @@\n-import java.io.Closeable;\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n@@ -27,2 +27,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n@@ -35,0 +33,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.ConstantUtf8;\n@@ -41,0 +40,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.LocalVariable;\n@@ -47,0 +47,2 @@\n+ *\n+ *\n@@ -48,1 +50,1 @@\n-final class AttributeHTML implements Closeable {\n+final class AttributeHTML {\n@@ -50,5 +52,5 @@\n-    private final String className; \/\/ name of current class\n-    private final PrintWriter printWriter; \/\/ file to write to\n-    private int attrCount;\n-    private final ConstantHTML constantHtml;\n-    private final ConstantPool constantPool;\n+    private final String class_name; \/\/ name of current class\n+    private final PrintWriter file; \/\/ file to write to\n+    private int attr_count = 0;\n+    private final ConstantHTML constant_html;\n+    private final ConstantPool constant_pool;\n@@ -56,10 +58,8 @@\n-    AttributeHTML(final String dir, final String className, final ConstantPool constantPool, final ConstantHTML constantHtml, final Charset charset)\n-        throws FileNotFoundException, UnsupportedEncodingException {\n-        this.className = className;\n-        this.constantPool = constantPool;\n-        this.constantHtml = constantHtml;\n-        printWriter = new PrintWriter(dir + className + \"_attributes.html\", charset.name());\n-        printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-        printWriter.print(charset.name());\n-        printWriter.println(\"\\\"><\/head>\");\n-        printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+\n+    AttributeHTML(final String dir, final String class_name, final ConstantPool constant_pool,\n+            final ConstantHTML constant_html) throws IOException {\n+        this.class_name = class_name;\n+        this.constant_pool = constant_pool;\n+        this.constant_html = constant_html;\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_attributes.html\"));\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n@@ -68,4 +68,4 @@\n-    @Override\n-    public void close() {\n-        printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n-        printWriter.close();\n+\n+    private String codeLink( final int link, final int method_number ) {\n+        return \"<A HREF=\\\"\" + class_name + \"_code.html#code\" + method_number + \"@\" + link\n+                + \"\\\" TARGET=Code>\" + link + \"<\/A>\";\n@@ -74,2 +74,4 @@\n-    private String codeLink(final int link, final int methodNumber) {\n-        return \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + link + \"\\\" TARGET=Code>\" + link + \"<\/A>\";\n+\n+    void close() {\n+        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+        file.close();\n@@ -78,1 +80,2 @@\n-    void writeAttribute(final Attribute attribute, final String anchor) {\n+\n+    void writeAttribute( final Attribute attribute, final String anchor ) {\n@@ -82,1 +85,2 @@\n-    void writeAttribute(final Attribute attribute, final String anchor, final int methodNumber) {\n+\n+    void writeAttribute( final Attribute attribute, final String anchor, final int method_number ) {\n@@ -88,3 +92,3 @@\n-        attrCount++; \/\/ Increment number of attributes found so far\n-        if (attrCount % 2 == 0) {\n-            printWriter.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n+        attr_count++; \/\/ Increment number of attributes found so far\n+        if (attr_count % 2 == 0) {\n+            file.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n@@ -92,1 +96,1 @@\n-            printWriter.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n+            file.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n@@ -94,3 +98,3 @@\n-        printWriter.println(\"<H4><A NAME=\\\"\" + anchor + \"\\\">\" + attrCount + \" \" + Const.getAttributeName(tag) + \"<\/A><\/H4>\");\n-        \/*\n-         * Handle different attributes\n+        file.println(\"<H4><A NAME=\\\"\" + anchor + \"\\\">\" + attr_count + \" \" + Const.getAttributeName(tag)\n+                + \"<\/A><\/H4>\");\n+        \/* Handle different attributes\n@@ -99,17 +103,61 @@\n-        case Const.ATTR_CODE:\n-            final Code c = (Code) attribute;\n-            \/\/ Some directly printable values\n-            printWriter.print(\"<UL><LI>Maximum stack size = \" + c.getMaxStack() + \"<\/LI>\\n<LI>Number of local variables = \" + c.getMaxLocals()\n-                + \"<\/LI>\\n<LI><A HREF=\\\"\" + className + \"_code.html#method\" + methodNumber + \"\\\" TARGET=Code>Byte code<\/A><\/LI><\/UL>\\n\");\n-            \/\/ Get handled exceptions and list them\n-            final CodeException[] ce = c.getExceptionTable();\n-            final int len = ce.length;\n-            if (len > 0) {\n-                printWriter.print(\"<P><B>Exceptions handled<\/B><UL>\");\n-                for (final CodeException cex : ce) {\n-                    final int catchType = cex.getCatchType(); \/\/ Index in constant pool\n-                    printWriter.print(\"<LI>\");\n-                    if (catchType != 0) {\n-                        printWriter.print(constantHtml.referenceConstant(catchType)); \/\/ Create Link to _cp.html\n-                    } else {\n-                        printWriter.print(\"Any Exception\");\n+            case Const.ATTR_CODE:\n+                final Code c = (Code) attribute;\n+                \/\/ Some directly printable values\n+                file.print(\"<UL><LI>Maximum stack size = \" + c.getMaxStack()\n+                        + \"<\/LI>\\n<LI>Number of local variables = \" + c.getMaxLocals()\n+                        + \"<\/LI>\\n<LI><A HREF=\\\"\" + class_name + \"_code.html#method\"\n+                        + method_number + \"\\\" TARGET=Code>Byte code<\/A><\/LI><\/UL>\\n\");\n+                \/\/ Get handled exceptions and list them\n+                final CodeException[] ce = c.getExceptionTable();\n+                final int len = ce.length;\n+                if (len > 0) {\n+                    file.print(\"<P><B>Exceptions handled<\/B><UL>\");\n+                    for (final CodeException cex : ce) {\n+                        final int catch_type = cex.getCatchType(); \/\/ Index in constant pool\n+                        file.print(\"<LI>\");\n+                        if (catch_type != 0) {\n+                            file.print(constant_html.referenceConstant(catch_type)); \/\/ Create Link to _cp.html\n+                        } else {\n+                            file.print(\"Any Exception\");\n+                        }\n+                        file.print(\"<BR>(Ranging from lines \"\n+                                + codeLink(cex.getStartPC(), method_number) + \" to \"\n+                                + codeLink(cex.getEndPC(), method_number) + \", handled at line \"\n+                                + codeLink(cex.getHandlerPC(), method_number) + \")<\/LI>\");\n+                    }\n+                    file.print(\"<\/UL>\");\n+                }\n+                break;\n+            case Const.ATTR_CONSTANT_VALUE:\n+                index = ((ConstantValue) attribute).getConstantValueIndex();\n+                \/\/ Reference _cp.html\n+                file.print(\"<UL><LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=\\\"ConstantPool\\\">Constant value index(\" + index\n+                        + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.ATTR_SOURCE_FILE:\n+                index = ((SourceFile) attribute).getSourceFileIndex();\n+                \/\/ Reference _cp.html\n+                file.print(\"<UL><LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=\\\"ConstantPool\\\">Source file index(\" + index + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.ATTR_EXCEPTIONS:\n+                \/\/ List thrown exceptions\n+                final int[] indices = ((ExceptionTable) attribute).getExceptionIndexTable();\n+                file.print(\"<UL>\");\n+                for (final int indice : indices) {\n+                    file.print(\"<LI><A HREF=\\\"\" + class_name + \"_cp.html#cp\" + indice\n+                            + \"\\\" TARGET=\\\"ConstantPool\\\">Exception class index(\" + indice\n+                            + \")<\/A>\\n\");\n+                }\n+                file.print(\"<\/UL>\\n\");\n+                break;\n+            case Const.ATTR_LINE_NUMBER_TABLE:\n+                final LineNumber[] line_numbers = ((LineNumberTable) attribute).getLineNumberTable();\n+                \/\/ List line number pairs\n+                file.print(\"<P>\");\n+                for (int i = 0; i < line_numbers.length; i++) {\n+                    file.print(\"(\" + line_numbers[i].getStartPC() + \",&nbsp;\"\n+                            + line_numbers[i].getLineNumber() + \")\");\n+                    if (i < line_numbers.length - 1) {\n+                        file.print(\", \"); \/\/ breakable\n@@ -117,2 +165,0 @@\n-                    printWriter.print(\"<BR>(Ranging from lines \" + codeLink(cex.getStartPC(), methodNumber) + \" to \" + codeLink(cex.getEndPC(), methodNumber)\n-                        + \", handled at line \" + codeLink(cex.getHandlerPC(), methodNumber) + \")<\/LI>\");\n@@ -120,33 +166,18 @@\n-                printWriter.print(\"<\/UL>\");\n-            }\n-            break;\n-        case Const.ATTR_CONSTANT_VALUE:\n-            index = ((ConstantValue) attribute).getConstantValueIndex();\n-            \/\/ Reference _cp.html\n-            printWriter\n-                .print(\"<UL><LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=\\\"ConstantPool\\\">Constant value index(\" + index + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.ATTR_SOURCE_FILE:\n-            index = ((SourceFile) attribute).getSourceFileIndex();\n-            \/\/ Reference _cp.html\n-            printWriter\n-                .print(\"<UL><LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=\\\"ConstantPool\\\">Source file index(\" + index + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.ATTR_EXCEPTIONS:\n-            \/\/ List thrown exceptions\n-            final int[] indices = ((ExceptionTable) attribute).getExceptionIndexTable();\n-            printWriter.print(\"<UL>\");\n-            for (final int indice : indices) {\n-                printWriter\n-                    .print(\"<LI><A HREF=\\\"\" + className + \"_cp.html#cp\" + indice + \"\\\" TARGET=\\\"ConstantPool\\\">Exception class index(\" + indice + \")<\/A>\\n\");\n-            }\n-            printWriter.print(\"<\/UL>\\n\");\n-            break;\n-        case Const.ATTR_LINE_NUMBER_TABLE:\n-            final LineNumber[] lineNumbers = ((LineNumberTable) attribute).getLineNumberTable();\n-            \/\/ List line number pairs\n-            printWriter.print(\"<P>\");\n-            for (int i = 0; i < lineNumbers.length; i++) {\n-                printWriter.print(\"(\" + lineNumbers[i].getStartPC() + \",&nbsp;\" + lineNumbers[i].getLineNumber() + \")\");\n-                if (i < lineNumbers.length - 1) {\n-                    printWriter.print(\", \"); \/\/ breakable\n+                break;\n+            case Const.ATTR_LOCAL_VARIABLE_TABLE:\n+                final LocalVariable[] vars = ((LocalVariableTable) attribute).getLocalVariableTable();\n+                \/\/ List name, range and type\n+                file.print(\"<UL>\");\n+                for (final LocalVariable var : vars) {\n+                    index = var.getSignatureIndex();\n+                    String signature = ((ConstantUtf8) constant_pool.getConstant(index,\n+                            Const.CONSTANT_Utf8)).getBytes();\n+                    signature = Utility.signatureToString(signature, false);\n+                    final int start = var.getStartPC();\n+                    final int end = start + var.getLength();\n+                    file.println(\"<LI>\" + Class2HTML.referenceType(signature) + \"&nbsp;<B>\"\n+                            + var.getName() + \"<\/B> in slot %\" + var.getIndex()\n+                            + \"<BR>Valid from lines \" + \"<A HREF=\\\"\" + class_name\n+                            + \"_code.html#code\" + method_number + \"@\" + start + \"\\\" TARGET=Code>\"\n+                            + start + \"<\/A> to \" + \"<A HREF=\\\"\" + class_name + \"_code.html#code\"\n+                            + method_number + \"@\" + end + \"\\\" TARGET=Code>\" + end + \"<\/A><\/LI>\");\n@@ -154,28 +185,22 @@\n-            }\n-            break;\n-        case Const.ATTR_LOCAL_VARIABLE_TABLE:\n-            \/\/ List name, range and type\n-            printWriter.print(\"<UL>\");\n-            ((LocalVariableTable) attribute).forEach(var -> {\n-                final int sigIdx = var.getSignatureIndex();\n-                String signature = constantPool.getConstantUtf8(sigIdx).getBytes();\n-                signature = Utility.signatureToString(signature, false);\n-                final int start = var.getStartPC();\n-                final int end = start + var.getLength();\n-                printWriter.println(\"<LI>\" + Class2HTML.referenceType(signature) + \"&nbsp;<B>\" + var.getName() + \"<\/B> in slot %\" + var.getIndex()\n-                    + \"<BR>Valid from lines \" + \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + start + \"\\\" TARGET=Code>\" + start\n-                    + \"<\/A> to \" + \"<A HREF=\\\"\" + className + \"_code.html#code\" + methodNumber + \"@\" + end + \"\\\" TARGET=Code>\" + end + \"<\/A><\/LI>\");\n-            });\n-            printWriter.print(\"<\/UL>\\n\");\n-            break;\n-        case Const.ATTR_INNER_CLASSES:\n-            \/\/ List inner classes\n-            printWriter.print(\"<UL>\");\n-            for (final InnerClass clazz : ((InnerClasses) attribute).getInnerClasses()) {\n-                final String name;\n-                final String access;\n-                index = clazz.getInnerNameIndex();\n-                if (index > 0) {\n-                    name = constantPool.getConstantUtf8(index).getBytes();\n-                } else {\n-                    name = \"&lt;anonymous&gt;\";\n+                file.print(\"<\/UL>\\n\");\n+                break;\n+            case Const.ATTR_INNER_CLASSES:\n+                final InnerClass[] classes = ((InnerClasses) attribute).getInnerClasses();\n+                \/\/ List inner classes\n+                file.print(\"<UL>\");\n+                for (final InnerClass classe : classes) {\n+                    String name;\n+                    String access;\n+                    index = classe.getInnerNameIndex();\n+                    if (index > 0) {\n+                        name = ((ConstantUtf8) constant_pool.getConstant(index, Const.CONSTANT_Utf8))\n+                                .getBytes();\n+                    } else {\n+                        name = \"&lt;anonymous&gt;\";\n+                    }\n+                    access = Utility.accessToString(classe.getInnerAccessFlags());\n+                    file.print(\"<LI><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT> \"\n+                            + constant_html.referenceConstant(classe.getInnerClassIndex())\n+                            + \" in&nbsp;class \"\n+                            + constant_html.referenceConstant(classe.getOuterClassIndex())\n+                            + \" named \" + name + \"<\/LI>\\n\");\n@@ -183,8 +208,4 @@\n-                access = Utility.accessToString(clazz.getInnerAccessFlags());\n-                printWriter.print(\"<LI><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT> \" + constantHtml.referenceConstant(clazz.getInnerClassIndex())\n-                    + \" in&nbsp;class \" + constantHtml.referenceConstant(clazz.getOuterClassIndex()) + \" named \" + name + \"<\/LI>\\n\");\n-            }\n-            printWriter.print(\"<\/UL>\\n\");\n-            break;\n-        default: \/\/ Such as Unknown attribute or Deprecated\n-            printWriter.print(\"<P>\" + attribute);\n+                file.print(\"<\/UL>\\n\");\n+                break;\n+            default: \/\/ Such as Unknown attribute or Deprecated\n+                file.print(\"<P>\" + attribute);\n@@ -192,2 +213,2 @@\n-        printWriter.println(\"<\/TD><\/TR>\");\n-        printWriter.flush();\n+        file.println(\"<\/TD><\/TR>\");\n+        file.flush();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/AttributeHTML.java","additions":146,"deletions":125,"binary":false,"changes":271,"status":"modified"},{"patch":"@@ -38,1 +38,2 @@\n-    boolean equals(Object THIS, Object THAT);\n+    boolean equals( Object THIS, Object THAT );\n+\n@@ -46,1 +47,1 @@\n-    int hashCode(Object THIS);\n+    int hashCode( Object THIS );\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELComparator.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,1 +63,2 @@\n- * Factory creates il.append() statements, and sets instruction targets. A helper class for BCELifier.\n+ * Factory creates il.append() statements, and sets instruction targets.\n+ * A helper class for BCELifier.\n@@ -66,1 +67,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -70,4 +71,4 @@\n-    private static final String CONSTANT_PREFIX = Const.class.getSimpleName() + \".\";\n-    private final MethodGen methodGen;\n-    private final PrintWriter printWriter;\n-    private final ConstantPoolGen constantPoolGen;\n+    private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+\".\";\n+    private final MethodGen _mg;\n+    private final PrintWriter _out;\n+    private final ConstantPoolGen _cp;\n@@ -75,4 +76,0 @@\n-    private final Map<Instruction, InstructionHandle> branchMap = new HashMap<>();\n-\n-    \/\/ Memorize BranchInstructions that need an update\n-    private final List<BranchInstruction> branches = new ArrayList<>();\n@@ -81,3 +78,3 @@\n-        methodGen = mg;\n-        constantPoolGen = mg.getConstantPool();\n-        printWriter = out;\n+        _mg = mg;\n+        _cp = mg.getConstantPool();\n+        _out = out;\n@@ -86,37 +83,1 @@\n-    private void createConstant(final Object value) {\n-        String embed = value.toString();\n-        if (value instanceof String) {\n-            embed = '\"' + Utility.convertString(embed) + '\"';\n-        } else if (value instanceof Character) {\n-            embed = \"(char)0x\" + Integer.toHexString(((Character) value).charValue());\n-        } else if (value instanceof Float) {\n-            final Float f = (Float) value;\n-            if (Float.isNaN(f)) {\n-                embed = \"Float.NaN\";\n-            } else if (f == Float.POSITIVE_INFINITY) {\n-                embed = \"Float.POSITIVE_INFINITY\";\n-            } else if (f == Float.NEGATIVE_INFINITY) {\n-                embed = \"Float.NEGATIVE_INFINITY\";\n-            } else {\n-                embed += \"f\";\n-            }\n-        }  else if (value instanceof Double) {\n-            final Double d = (Double) value;\n-            if (Double.isNaN(d)) {\n-                embed = \"Double.NaN\";\n-            } else if (d == Double.POSITIVE_INFINITY) {\n-                embed = \"Double.POSITIVE_INFINITY\";\n-            } else if (d == Double.NEGATIVE_INFINITY) {\n-                embed = \"Double.NEGATIVE_INFINITY\";\n-            } else {\n-                embed += \"d\";\n-            }\n-        } else if (value instanceof Long) {\n-            embed += \"L\";\n-        } else if (value instanceof ObjectType) {\n-            final ObjectType ot = (ObjectType) value;\n-            embed = \"new ObjectType(\\\"\" + ot.getClassName() + \"\\\")\";\n-        } else if (value instanceof ArrayType) {\n-            final ArrayType at = (ArrayType) value;\n-            embed = \"new ArrayType(\" + BCELifier.printType(at.getBasicType()) + \", \" + at.getDimensions() + \")\";\n-        }\n+    private final Map<Instruction, InstructionHandle> branch_map = new HashMap<>();\n@@ -124,2 +85,0 @@\n-        printWriter.println(\"il.append(new PUSH(_cp, \" + embed + \"));\");\n-    }\n@@ -128,2 +87,3 @@\n-        if (!methodGen.isAbstract() && !methodGen.isNative()) {\n-            for (InstructionHandle ih = methodGen.getInstructionList().getStart(); ih != null; ih = ih.getNext()) {\n+        if (!_mg.isAbstract() && !_mg.isNative()) {\n+            for (InstructionHandle ih = _mg.getInstructionList().getStart(); ih != null; ih = ih\n+                    .getNext()) {\n@@ -132,1 +92,1 @@\n-                    branchMap.put(i, ih); \/\/ memorize container\n+                    branch_map.put(i, ih); \/\/ memorize container\n@@ -136,1 +96,1 @@\n-                        printWriter.println(\"    InstructionHandle ih_\" + ih.getPosition() + \";\");\n+                        _out.println(\"    InstructionHandle ih_\" + ih.getPosition() + \";\");\n@@ -138,1 +98,1 @@\n-                        printWriter.print(\"    InstructionHandle ih_\" + ih.getPosition() + \" = \");\n+                        _out.print(\"    InstructionHandle ih_\" + ih.getPosition() + \" = \");\n@@ -141,1 +101,1 @@\n-                    printWriter.print(\"    \");\n+                    _out.print(\"    \");\n@@ -152,15 +112,10 @@\n-    private void updateBranchTargets() {\n-        branches.forEach(bi -> {\n-            final BranchHandle bh = (BranchHandle) branchMap.get(bi);\n-            final int pos = bh.getPosition();\n-            final String name = bi.getName() + \"_\" + pos;\n-            int targetPos = bh.getTarget().getPosition();\n-            printWriter.println(\"    \" + name + \".setTarget(ih_\" + targetPos + \");\");\n-            if (bi instanceof Select) {\n-                final InstructionHandle[] ihs = ((Select) bi).getTargets();\n-                for (int j = 0; j < ihs.length; j++) {\n-                    targetPos = ihs[j].getPosition();\n-                    printWriter.println(\"    \" + name + \".setTarget(\" + j + \", ih_\" + targetPos + \");\");\n-                }\n-            }\n-        });\n+\n+    private boolean visitInstruction( final Instruction i ) {\n+        final short opcode = i.getOpcode();\n+        if ((InstructionConst.getInstruction(opcode) != null)\n+                && !(i instanceof ConstantPushInstruction) && !(i instanceof ReturnInstruction)) { \/\/ Handled below\n+            _out.println(\"il.append(InstructionConst.\"\n+                    + i.getName().toUpperCase(Locale.ENGLISH) + \");\");\n+            return true;\n+        }\n+        return false;\n@@ -169,6 +124,12 @@\n-    private void updateExceptionHandlers() {\n-        final CodeExceptionGen[] handlers = methodGen.getExceptionHandlers();\n-        for (final CodeExceptionGen h : handlers) {\n-            final String type = h.getCatchType() == null ? \"null\" : BCELifier.printType(h.getCatchType());\n-            printWriter.println(\"    method.addExceptionHandler(\" + \"ih_\" + h.getStartPC().getPosition() + \", \" + \"ih_\" + h.getEndPC().getPosition() + \", \"\n-                + \"ih_\" + h.getHandlerPC().getPosition() + \", \" + type + \");\");\n+\n+    @Override\n+    public void visitLocalVariableInstruction( final LocalVariableInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final Type type = i.getType(_cp);\n+        if (opcode == Const.IINC) {\n+            _out.println(\"il.append(new IINC(\" + i.getIndex() + \", \" + ((IINC) i).getIncrement()\n+                    + \"));\");\n+        } else {\n+            final String kind = (opcode < Const.ISTORE) ? \"Load\" : \"Store\";\n+            _out.println(\"il.append(_factory.create\" + kind + \"(\" + BCELifier.printType(type)\n+                    + \", \" + i.getIndex() + \"));\");\n@@ -178,0 +139,37 @@\n+\n+    @Override\n+    public void visitArrayInstruction( final ArrayInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final Type type = i.getType(_cp);\n+        final String kind = (opcode < Const.IASTORE) ? \"Load\" : \"Store\";\n+        _out.println(\"il.append(_factory.createArray\" + kind + \"(\" + BCELifier.printType(type)\n+                + \"));\");\n+    }\n+\n+\n+    @Override\n+    public void visitFieldInstruction( final FieldInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final String class_name = i.getReferenceType(_cp).getSignature();\n+        final String field_name = i.getFieldName(_cp);\n+        final Type type = i.getFieldType(_cp);\n+        _out.println(\"il.append(_factory.createFieldAccess(\\\"\" + class_name + \"\\\", \\\"\" + field_name\n+                + \"\\\", \" + BCELifier.printType(type) + \", \" + CONSTANT_PREFIX\n+                + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n+    }\n+\n+\n+    @Override\n+    public void visitInvokeInstruction( final InvokeInstruction i ) {\n+        final short opcode = i.getOpcode();\n+        final String class_name = i.getReferenceType(_cp).getSignature();\n+        final String method_name = i.getMethodName(_cp);\n+        final Type type = i.getReturnType(_cp);\n+        final Type[] arg_types = i.getArgumentTypes(_cp);\n+        _out.println(\"il.append(_factory.createInvoke(\\\"\" + class_name + \"\\\", \\\"\" + method_name\n+                + \"\\\", \" + BCELifier.printType(type) + \", \"\n+                + BCELifier.printArgumentTypes(arg_types) + \", \" + CONSTANT_PREFIX\n+                + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n+    }\n+\n+\n@@ -180,1 +178,1 @@\n-    public void visitAllocationInstruction(final AllocationInstruction i) {\n+    public void visitAllocationInstruction( final AllocationInstruction i ) {\n@@ -183,1 +181,1 @@\n-            type = ((CPInstruction) i).getType(constantPoolGen);\n+            type = ((CPInstruction) i).getType(_cp);\n@@ -190,16 +188,34 @@\n-        case Const.NEW:\n-            printWriter.println(\"il.append(_factory.createNew(\\\"\" + ((ObjectType) type).getClassName() + \"\\\"));\");\n-            break;\n-        case Const.MULTIANEWARRAY:\n-            dim = ((MULTIANEWARRAY) i).getDimensions();\n-            \/\/$FALL-THROUGH$\n-        case Const.NEWARRAY:\n-            if (type instanceof ArrayType) {\n-                type = ((ArrayType) type).getBasicType();\n-            }\n-            \/\/$FALL-THROUGH$\n-        case Const.ANEWARRAY:\n-            printWriter.println(\"il.append(_factory.createNewArray(\" + BCELifier.printType(type) + \", (short) \" + dim + \"));\");\n-            break;\n-        default:\n-            throw new IllegalArgumentException(\"Unhandled opcode: \" + opcode);\n+            case Const.NEW:\n+                _out.println(\"il.append(_factory.createNew(\\\"\" + ((ObjectType) type).getClassName()\n+                        + \"\\\"));\");\n+                break;\n+            case Const.MULTIANEWARRAY:\n+                dim = ((MULTIANEWARRAY) i).getDimensions();\n+                \/\/$FALL-THROUGH$\n+            case Const.ANEWARRAY:\n+            case Const.NEWARRAY:\n+                if (type instanceof ArrayType) {\n+                    type = ((ArrayType) type).getBasicType();\n+                }\n+                _out.println(\"il.append(_factory.createNewArray(\" + BCELifier.printType(type)\n+                        + \", (short) \" + dim + \"));\");\n+                break;\n+            default:\n+                throw new IllegalArgumentException(\"Unhandled opcode: \" + opcode);\n+        }\n+    }\n+\n+\n+    private void createConstant( final Object value ) {\n+        String embed = value.toString();\n+        if (value instanceof String) {\n+            embed = '\"' + Utility.convertString(embed) + '\"';\n+        } else if (value instanceof Character) {\n+            embed = \"(char)0x\" + Integer.toHexString(((Character) value).charValue());\n+        } else if (value instanceof Float) {\n+            embed += \"f\";\n+        } else if (value instanceof Long) {\n+            embed += \"L\";\n+        } else if (value instanceof ObjectType) {\n+            final ObjectType ot = (ObjectType) value;\n+            embed = \"new ObjectType(\\\"\"+ot.getClassName()+\"\\\")\";\n@@ -207,0 +223,2 @@\n+\n+        _out.println(\"il.append(new PUSH(_cp, \" + embed + \"));\");\n@@ -209,0 +227,1 @@\n+\n@@ -210,5 +229,14 @@\n-    public void visitArrayInstruction(final ArrayInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final Type type = i.getType(constantPoolGen);\n-        final String kind = opcode < Const.IASTORE ? \"Load\" : \"Store\";\n-        printWriter.println(\"il.append(_factory.createArray\" + kind + \"(\" + BCELifier.printType(type) + \"));\");\n+    public void visitLDC( final LDC i ) {\n+        createConstant(i.getValue(_cp));\n+    }\n+\n+\n+    @Override\n+    public void visitLDC2_W( final LDC2_W i ) {\n+        createConstant(i.getValue(_cp));\n+    }\n+\n+\n+    @Override\n+    public void visitConstantPushInstruction( final ConstantPushInstruction i ) {\n+        createConstant(i.getValue());\n@@ -217,0 +245,8 @@\n+\n+    @Override\n+    public void visitINSTANCEOF( final INSTANCEOF i ) {\n+        final Type type = i.getType(_cp);\n+        _out.println(\"il.append(new INSTANCEOF(_cp.addClass(\" + BCELifier.printType(type) + \")));\");\n+    }\n+\n+\n@@ -218,2 +254,19 @@\n-    public void visitBranchInstruction(final BranchInstruction bi) {\n-        final BranchHandle bh = (BranchHandle) branchMap.get(bi);\n+    public void visitCHECKCAST( final CHECKCAST i ) {\n+        final Type type = i.getType(_cp);\n+        _out.println(\"il.append(_factory.createCheckCast(\" + BCELifier.printType(type) + \"));\");\n+    }\n+\n+\n+    @Override\n+    public void visitReturnInstruction( final ReturnInstruction i ) {\n+        final Type type = i.getType(_cp);\n+        _out.println(\"il.append(_factory.createReturn(\" + BCELifier.printType(type) + \"));\");\n+    }\n+\n+    \/\/ Memorize BranchInstructions that need an update\n+    private final List<BranchInstruction> branches = new ArrayList<>();\n+\n+\n+    @Override\n+    public void visitBranchInstruction( final BranchInstruction bi ) {\n+        final BranchHandle bh = (BranchHandle) branch_map.get(bi);\n@@ -234,1 +287,2 @@\n-            printWriter.print(\"Select \" + name + \" = new \" + bi.getName().toUpperCase(Locale.ENGLISH) + \"(\" + args + \", new InstructionHandle[] { \");\n+            _out.print(\"Select \" + name + \" = new \" + bi.getName().toUpperCase(Locale.ENGLISH)\n+                    + \"(\" + args + \", new InstructionHandle[] { \");\n@@ -236,1 +290,1 @@\n-                printWriter.print(\"null\");\n+                _out.print(\"null\");\n@@ -238,1 +292,1 @@\n-                    printWriter.print(\", \");\n+                    _out.print(\", \");\n@@ -241,1 +295,1 @@\n-            printWriter.println(\" }, null);\");\n+            _out.println(\" }, null);\");\n@@ -243,1 +297,1 @@\n-            final int tPos = bh.getTarget().getPosition();\n+            final int t_pos = bh.getTarget().getPosition();\n@@ -245,2 +299,2 @@\n-            if (pos > tPos) {\n-                target = \"ih_\" + tPos;\n+            if (pos > t_pos) {\n+                target = \"ih_\" + t_pos;\n@@ -251,2 +305,3 @@\n-            printWriter.println(\"    BranchInstruction \" + name + \" = _factory.createBranchInstruction(\" + CONSTANT_PREFIX\n-                + bi.getName().toUpperCase(Locale.ENGLISH) + \", \" + target + \");\");\n+            _out.println(\"    BranchInstruction \" + name + \" = _factory.createBranchInstruction(\"\n+                    + CONSTANT_PREFIX + bi.getName().toUpperCase(Locale.ENGLISH) + \", \" + target\n+                    + \");\");\n@@ -255,1 +310,1 @@\n-            printWriter.println(\"    ih_\" + pos + \" = il.append(\" + name + \");\");\n+            _out.println(\"    ih_\" + pos + \" = il.append(\" + name + \");\");\n@@ -257,1 +312,1 @@\n-            printWriter.println(\"    il.append(\" + name + \");\");\n+            _out.println(\"    il.append(\" + name + \");\");\n@@ -261,10 +316,0 @@\n-    @Override\n-    public void visitCHECKCAST(final CHECKCAST i) {\n-        final Type type = i.getType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createCheckCast(\" + BCELifier.printType(type) + \"));\");\n-    }\n-\n-    @Override\n-    public void visitConstantPushInstruction(final ConstantPushInstruction i) {\n-        createConstant(i.getValue());\n-    }\n@@ -273,7 +318,2 @@\n-    public void visitFieldInstruction(final FieldInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final String className = i.getReferenceType(constantPoolGen).getClassName();\n-        final String fieldName = i.getFieldName(constantPoolGen);\n-        final Type type = i.getFieldType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createFieldAccess(\\\"\" + className + \"\\\", \\\"\" + fieldName + \"\\\", \" + BCELifier.printType(type) + \", \"\n-            + CONSTANT_PREFIX + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n+    public void visitRET( final RET i ) {\n+        _out.println(\"il.append(new RET(\" + i.getIndex() + \")));\");\n@@ -282,5 +322,0 @@\n-    @Override\n-    public void visitINSTANCEOF(final INSTANCEOF i) {\n-        final Type type = i.getType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createInstanceOf(\" + BCELifier.printType(type) + \"));\");\n-    }\n@@ -288,5 +323,14 @@\n-    private boolean visitInstruction(final Instruction i) {\n-        final short opcode = i.getOpcode();\n-        if (InstructionConst.getInstruction(opcode) != null && !(i instanceof ConstantPushInstruction) && !(i instanceof ReturnInstruction)) { \/\/ Handled below\n-            printWriter.println(\"il.append(InstructionConst.\" + i.getName().toUpperCase(Locale.ENGLISH) + \");\");\n-            return true;\n+    private void updateBranchTargets() {\n+        for (final BranchInstruction bi : branches) {\n+            final BranchHandle bh = (BranchHandle) branch_map.get(bi);\n+            final int pos = bh.getPosition();\n+            final String name = bi.getName() + \"_\" + pos;\n+            int t_pos = bh.getTarget().getPosition();\n+            _out.println(\"    \" + name + \".setTarget(ih_\" + t_pos + \");\");\n+            if (bi instanceof Select) {\n+                final InstructionHandle[] ihs = ((Select) bi).getTargets();\n+                for (int j = 0; j < ihs.length; j++) {\n+                    t_pos = ihs[j].getPosition();\n+                    _out.println(\"    \" + name + \".setTarget(\" + j + \", ih_\" + t_pos + \");\");\n+                }\n+            }\n@@ -294,1 +338,0 @@\n-        return false;\n@@ -297,10 +340,0 @@\n-    @Override\n-    public void visitInvokeInstruction(final InvokeInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final String className = i.getReferenceType(constantPoolGen).getClassName();\n-        final String methodName = i.getMethodName(constantPoolGen);\n-        final Type type = i.getReturnType(constantPoolGen);\n-        final Type[] argTypes = i.getArgumentTypes(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createInvoke(\\\"\" + className + \"\\\", \\\"\" + methodName + \"\\\", \" + BCELifier.printType(type) + \", \"\n-            + BCELifier.printArgumentTypes(argTypes) + \", \" + CONSTANT_PREFIX + Const.getOpcodeName(opcode).toUpperCase(Locale.ENGLISH) + \"));\");\n-    }\n@@ -308,19 +341,8 @@\n-    @Override\n-    public void visitLDC(final LDC i) {\n-        createConstant(i.getValue(constantPoolGen));\n-    }\n-\n-    @Override\n-    public void visitLDC2_W(final LDC2_W i) {\n-        createConstant(i.getValue(constantPoolGen));\n-    }\n-\n-    @Override\n-    public void visitLocalVariableInstruction(final LocalVariableInstruction i) {\n-        final short opcode = i.getOpcode();\n-        final Type type = i.getType(constantPoolGen);\n-        if (opcode == Const.IINC) {\n-            printWriter.println(\"il.append(new IINC(\" + i.getIndex() + \", \" + ((IINC) i).getIncrement() + \"));\");\n-        } else {\n-            final String kind = opcode < Const.ISTORE ? \"Load\" : \"Store\";\n-            printWriter.println(\"il.append(_factory.create\" + kind + \"(\" + BCELifier.printType(type) + \", \" + i.getIndex() + \"));\");\n+    private void updateExceptionHandlers() {\n+        final CodeExceptionGen[] handlers = _mg.getExceptionHandlers();\n+        for (final CodeExceptionGen h : handlers) {\n+            final String type = (h.getCatchType() == null) ? \"null\" : BCELifier.printType(h\n+                    .getCatchType());\n+            _out.println(\"    method.addExceptionHandler(\" + \"ih_\" + h.getStartPC().getPosition()\n+                    + \", \" + \"ih_\" + h.getEndPC().getPosition() + \", \" + \"ih_\"\n+                    + h.getHandlerPC().getPosition() + \", \" + type + \");\");\n@@ -329,11 +351,0 @@\n-\n-    @Override\n-    public void visitRET(final RET i) {\n-        printWriter.println(\"il.append(new RET(\" + i.getIndex() + \"));\");\n-    }\n-\n-    @Override\n-    public void visitReturnInstruction(final ReturnInstruction i) {\n-        final Type type = i.getType(constantPoolGen);\n-        printWriter.println(\"il.append(_factory.createReturn(\" + BCELifier.printType(type) + \"));\");\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELFactory.java","additions":195,"deletions":184,"binary":false,"changes":379,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -25,1 +26,0 @@\n-import java.io.OutputStreamWriter;\n@@ -27,1 +27,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -34,1 +33,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.ExceptionTable;\n@@ -45,3 +43,5 @@\n- * This class takes a given JavaClass object and converts it to a Java program that creates that very class using BCEL.\n- * This gives new users of BCEL a useful example showing how things are done with BCEL. It does not cover all features\n- * of BCEL, but tries to mimic hand-written code as close as possible.\n+ * This class takes a given JavaClass object and converts it to a\n+ * Java program that creates that very class using BCEL. This\n+ * gives new users of BCEL a useful example showing how things\n+ * are done with BCEL. It does not cover all features of BCEL,\n+ * but tries to mimic hand-written code as close as possible.\n@@ -49,1 +49,0 @@\n- * @LastModified: Feb 2023\n@@ -57,1 +56,3 @@\n-        UNKNOWN, CLASS, METHOD,\n+        UNKNOWN,\n+        CLASS,\n+        METHOD,\n@@ -63,1 +64,1 @@\n-    private static final String CONSTANT_PREFIX = Const.class.getSimpleName() + \".\";\n+    private static final String CONSTANT_PREFIX = Const.class.getSimpleName()+\".\";\n@@ -65,7 +66,11 @@\n-    \/\/ Needs to be accessible from unit test code\n-    static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {\n-        JavaClass javaClass;\n-        if ((javaClass = Repository.lookupClass(name)) == null) {\n-            javaClass = new ClassParser(name).parse(); \/\/ May throw IOException\n-        }\n-        return javaClass;\n+    private final JavaClass _clazz;\n+    private final PrintWriter _out;\n+    private final ConstantPoolGen _cp;\n+\n+    \/** @param clazz Java class to \"decompile\"\n+     * @param out where to output Java program\n+     *\/\n+    public BCELifier(final JavaClass clazz, final OutputStream out) {\n+        _clazz = clazz;\n+        _out = new PrintWriter(out);\n+        _cp = new ConstantPoolGen(_clazz.getConstantPool());\n@@ -74,2 +79,2 @@\n-    \/**\n-     * Default main method\n+\n+    \/** Start Java code generation\n@@ -77,8 +82,3 @@\n-    public static void _main(final String[] argv) throws Exception {\n-        if (argv.length != 1) {\n-            System.out.println(\"Usage: BCELifier className\");\n-            System.out.println(\"\\tThe class must exist on the classpath\");\n-            return;\n-        }\n-        final BCELifier bcelifier = new BCELifier(getJavaClass(argv[0]), System.out);\n-        bcelifier.start();\n+    public void start() {\n+        visitJavaClass(_clazz);\n+        _out.flush();\n@@ -87,3 +87,11 @@\n-    static String printArgumentTypes(final Type[] argTypes) {\n-        if (argTypes.length == 0) {\n-            return \"Type.NO_ARGS\";\n+\n+    @Override\n+    public void visitJavaClass( final JavaClass clazz ) {\n+        String class_name = clazz.getClassName();\n+        final String super_name = clazz.getSuperclassName();\n+        final String package_name = clazz.getPackageName();\n+        final String inter = Utility.printArray(clazz.getInterfaceNames(), false, true);\n+        if (!\"\".equals(package_name)) {\n+            class_name = class_name.substring(package_name.length() + 1);\n+            _out.println(\"package \" + package_name + \";\");\n+            _out.println();\n@@ -91,5 +99,30 @@\n-        final StringBuilder args = new StringBuilder();\n-        for (int i = 0; i < argTypes.length; i++) {\n-            args.append(printType(argTypes[i]));\n-            if (i < argTypes.length - 1) {\n-                args.append(\", \");\n+        _out.println(\"import \" + BASE_PACKAGE + \".generic.*;\");\n+        _out.println(\"import \" + BASE_PACKAGE + \".classfile.*;\");\n+        _out.println(\"import \" + BASE_PACKAGE + \".*;\");\n+        _out.println(\"import java.io.*;\");\n+        _out.println();\n+        _out.println(\"public class \" + class_name + \"Creator {\");\n+        _out.println(\"  private InstructionFactory _factory;\");\n+        _out.println(\"  private ConstantPoolGen    _cp;\");\n+        _out.println(\"  private ClassGen           _cg;\");\n+        _out.println();\n+        _out.println(\"  public \" + class_name + \"Creator() {\");\n+        _out.println(\"    _cg = new ClassGen(\\\"\"\n+                + ((\"\".equals(package_name)) ? class_name : package_name + \".\" + class_name)\n+                + \"\\\", \\\"\" + super_name + \"\\\", \" + \"\\\"\" + clazz.getSourceFileName() + \"\\\", \"\n+                + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + \", \"\n+                + \"new String[] { \" + inter + \" });\");\n+        _out.println(\"    _cg.setMajor(\" + clazz.getMajor() +\");\");\n+        _out.println(\"    _cg.setMinor(\" + clazz.getMinor() +\");\");\n+        _out.println();\n+        _out.println(\"    _cp = _cg.getConstantPool();\");\n+        _out.println(\"    _factory = new InstructionFactory(_cg, _cp);\");\n+        _out.println(\"  }\");\n+        _out.println();\n+        printCreate();\n+        final Field[] fields = clazz.getFields();\n+        if (fields.length > 0) {\n+            _out.println(\"  private void createFields() {\");\n+            _out.println(\"    FieldGen field;\");\n+            for (final Field field : fields) {\n+                field.accept(this);\n@@ -97,0 +130,2 @@\n+            _out.println(\"  }\");\n+            _out.println();\n@@ -98,1 +133,68 @@\n-        return \"new Type[] { \" + args.toString() + \" }\";\n+        final Method[] methods = clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            _out.println(\"  private void createMethod_\" + i + \"() {\");\n+            methods[i].accept(this);\n+            _out.println(\"  }\");\n+            _out.println();\n+        }\n+        printMain();\n+        _out.println(\"}\");\n+    }\n+\n+\n+    private void printCreate() {\n+        _out.println(\"  public void create(OutputStream out) throws IOException {\");\n+        final Field[] fields = _clazz.getFields();\n+        if (fields.length > 0) {\n+            _out.println(\"    createFields();\");\n+        }\n+        final Method[] methods = _clazz.getMethods();\n+        for (int i = 0; i < methods.length; i++) {\n+            _out.println(\"    createMethod_\" + i + \"();\");\n+        }\n+        _out.println(\"    _cg.getJavaClass().dump(out);\");\n+        _out.println(\"  }\");\n+        _out.println();\n+    }\n+\n+\n+    private void printMain() {\n+        final String class_name = _clazz.getClassName();\n+        _out.println(\"  public static void main(String[] args) throws Exception {\");\n+        _out.println(\"    \" + class_name + \"Creator creator = new \" + class_name + \"Creator();\");\n+        _out.println(\"    creator.create(new FileOutputStream(\\\"\" + class_name + \".class\\\"));\");\n+        _out.println(\"  }\");\n+    }\n+\n+\n+    @Override\n+    public void visitField( final Field field ) {\n+        _out.println();\n+        _out.println(\"    field = new FieldGen(\" + printFlags(field.getAccessFlags()) + \", \"\n+                + printType(field.getSignature()) + \", \\\"\" + field.getName() + \"\\\", _cp);\");\n+        final ConstantValue cv = field.getConstantValue();\n+        if (cv != null) {\n+            final String value = cv.toString();\n+            _out.println(\"    field.setInitValue(\" + value + \")\");\n+        }\n+        _out.println(\"    _cg.addField(field.getField());\");\n+    }\n+\n+\n+    @Override\n+    public void visitMethod( final Method method ) {\n+        final MethodGen mg = new MethodGen(method, _clazz.getClassName(), _cp);\n+        _out.println(\"    InstructionList il = new InstructionList();\");\n+        _out.println(\"    MethodGen method = new MethodGen(\"\n+                + printFlags(method.getAccessFlags(), FLAGS.METHOD) + \", \"\n+                + printType(mg.getReturnType()) + \", \"\n+                + printArgumentTypes(mg.getArgumentTypes()) + \", \"\n+                + \"new String[] { \" + Utility.printArray(mg.getArgumentNames(), false, true)\n+                + \" }, \\\"\" + method.getName() + \"\\\", \\\"\" + _clazz.getClassName() + \"\\\", il, _cp);\");\n+        _out.println();\n+        final BCELFactory factory = new BCELFactory(mg, _out);\n+        factory.start();\n+        _out.println(\"    method.setMaxStack();\");\n+        _out.println(\"    method.setMaxLocals();\");\n+        _out.println(\"    _cg.addMethod(method.getMethod());\");\n+        _out.println(\"    il.dispose();\");\n@@ -101,1 +203,2 @@\n-    static String printFlags(final int flags) {\n+\n+    static String printFlags( final int flags ) {\n@@ -107,1 +210,0 @@\n-     *\n@@ -113,1 +215,1 @@\n-    public static String printFlags(final int flags, final FLAGS location) {\n+    public static String printFlags( final int flags, final FLAGS location ) {\n@@ -120,8 +222,6 @@\n-                if (pow == Const.ACC_SYNCHRONIZED && location == FLAGS.CLASS) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_SUPER | \");\n-                } else if (pow == Const.ACC_VOLATILE && location == FLAGS.METHOD) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_BRIDGE | \");\n-                } else if (pow == Const.ACC_TRANSIENT && location == FLAGS.METHOD) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_VARARGS | \");\n-                } else if (i < Const.ACCESS_NAMES_LENGTH) {\n-                    buf.append(CONSTANT_PREFIX).append(\"ACC_\").append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH)).append(\" | \");\n+                if ((pow == Const.ACC_SYNCHRONIZED) && (location == FLAGS.CLASS)) {\n+                    buf.append(CONSTANT_PREFIX+\"ACC_SUPER | \");\n+                } else if ((pow == Const.ACC_VOLATILE) && (location == FLAGS.METHOD)) {\n+                    buf.append(CONSTANT_PREFIX+\"ACC_BRIDGE | \");\n+                } else if ((pow == Const.ACC_TRANSIENT) && (location == FLAGS.METHOD)) {\n+                    buf.append(CONSTANT_PREFIX+\"ACC_VARARGS | \");\n@@ -129,1 +229,7 @@\n-                    buf.append(String.format(CONSTANT_PREFIX + \"ACC_BIT %x | \", pow));\n+                    if (i < Const.ACCESS_NAMES_LENGTH) {\n+                        buf.append(CONSTANT_PREFIX+\"ACC_\")\n+                                .append(Const.getAccessName(i).toUpperCase(Locale.ENGLISH))\n+                                .append( \" | \");\n+                    } else {\n+                        buf.append(String.format (CONSTANT_PREFIX+\"ACC_BIT %x | \", pow));\n+                    }\n@@ -138,14 +244,4 @@\n-    static String printType(final String signature) {\n-        final Type type = Type.getType(signature);\n-        final byte t = type.getType();\n-        if (t <= Const.T_VOID) {\n-            return \"Type.\" + Const.getTypeName(t).toUpperCase(Locale.ENGLISH);\n-        }\n-        if (type.toString().equals(\"java.lang.String\")) {\n-            return \"Type.STRING\";\n-        }\n-        if (type.toString().equals(\"java.lang.Object\")) {\n-            return \"Type.OBJECT\";\n-        }\n-        if (type.toString().equals(\"java.lang.StringBuffer\")) {\n-            return \"Type.STRINGBUFFER\";\n+\n+    static String printArgumentTypes( final Type[] arg_types ) {\n+        if (arg_types.length == 0) {\n+            return \"Type.NO_ARGS\";\n@@ -153,3 +249,6 @@\n-        if (type instanceof ArrayType) {\n-            final ArrayType at = (ArrayType) type;\n-            return \"new ArrayType(\" + printType(at.getBasicType()) + \", \" + at.getDimensions() + \")\";\n+        final StringBuilder args = new StringBuilder();\n+        for (int i = 0; i < arg_types.length; i++) {\n+            args.append(printType(arg_types[i]));\n+            if (i < arg_types.length - 1) {\n+                args.append(\", \");\n+            }\n@@ -157,1 +256,1 @@\n-        return \"new ObjectType(\\\"\" + Utility.signatureToString(signature, false) + \"\\\")\";\n+        return \"new Type[] { \" + args.toString() + \" }\";\n@@ -160,1 +259,2 @@\n-    static String printType(final Type type) {\n+\n+    static String printType( final Type type ) {\n@@ -164,3 +264,0 @@\n-    private final JavaClass clazz;\n-\n-    private final PrintWriter printWriter;\n@@ -168,23 +265,17 @@\n-    private final ConstantPoolGen constantPoolGen;\n-\n-    \/**\n-     * Constructs a new instance.\n-     *\n-     * @param clazz Java class to \"decompile\".\n-     * @param out where to print the Java program in UTF-8.\n-     *\/\n-    public BCELifier(final JavaClass clazz, final OutputStream out) {\n-        this.clazz = clazz;\n-        this.printWriter = new PrintWriter(new OutputStreamWriter(out, StandardCharsets.UTF_8), false);\n-        this.constantPoolGen = new ConstantPoolGen(this.clazz.getConstantPool());\n-    }\n-\n-    private void printCreate() {\n-        printWriter.println(\"  public void create(OutputStream out) throws IOException {\");\n-        final Field[] fields = clazz.getFields();\n-        if (fields.length > 0) {\n-            printWriter.println(\"    createFields();\");\n-        }\n-        final Method[] methods = clazz.getMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            printWriter.println(\"    createMethod_\" + i + \"();\");\n+    static String printType( final String signature ) {\n+        final Type type = Type.getType(signature);\n+        final byte t = type.getType();\n+        if (t <= Const.T_VOID) {\n+            return \"Type.\" + Const.getTypeName(t).toUpperCase(Locale.ENGLISH);\n+        } else if (type.toString().equals(\"java.lang.String\")) {\n+            return \"Type.STRING\";\n+        } else if (type.toString().equals(\"java.lang.Object\")) {\n+            return \"Type.OBJECT\";\n+        } else if (type.toString().equals(\"java.lang.StringBuffer\")) {\n+            return \"Type.STRINGBUFFER\";\n+        } else if (type instanceof ArrayType) {\n+            final ArrayType at = (ArrayType) type;\n+            return \"new ArrayType(\" + printType(at.getBasicType()) + \", \" + at.getDimensions()\n+                    + \")\";\n+        } else {\n+            return \"new ObjectType(\\\"\" + Utility.signatureToString(signature, false) + \"\\\")\";\n@@ -192,3 +283,0 @@\n-        printWriter.println(\"    _cg.getJavaClass().dump(out);\");\n-        printWriter.println(\"  }\");\n-        printWriter.println();\n@@ -197,7 +285,0 @@\n-    private void printMain() {\n-        final String className = clazz.getClassName();\n-        printWriter.println(\"  public static void main(String[] args) throws Exception {\");\n-        printWriter.println(\"    \" + className + \"Creator creator = new \" + className + \"Creator();\");\n-        printWriter.println(\"    creator.create(new FileOutputStream(\\\"\" + className + \".class\\\"));\");\n-        printWriter.println(\"  }\");\n-    }\n@@ -205,2 +286,1 @@\n-    \/**\n-     * Start Java code generation\n+    \/** Default main method\n@@ -208,33 +288,5 @@\n-    public void start() {\n-        visitJavaClass(clazz);\n-        printWriter.flush();\n-    }\n-\n-    @Override\n-    public void visitField(final Field field) {\n-        printWriter.println();\n-        printWriter.println(\n-            \"    field = new FieldGen(\" + printFlags(field.getAccessFlags()) + \", \" + printType(field.getSignature()) + \", \\\"\" + field.getName() + \"\\\", _cp);\");\n-        final ConstantValue cv = field.getConstantValue();\n-        if (cv != null) {\n-            printWriter.print(\"    field.setInitValue(\");\n-            if (field.getType() == Type.CHAR) {\n-                printWriter.print(\"(char)\");\n-            }\n-            if (field.getType() == Type.SHORT) {\n-                printWriter.print(\"(short)\");\n-            }\n-            if (field.getType() == Type.BYTE) {\n-                printWriter.print(\"(byte)\");\n-            }\n-            printWriter.print(cv);\n-            if (field.getType() == Type.LONG) {\n-                printWriter.print(\"L\");\n-            }\n-            if (field.getType() == Type.FLOAT) {\n-                printWriter.print(\"F\");\n-            }\n-            if (field.getType() == Type.DOUBLE) {\n-                printWriter.print(\"D\");\n-            }\n-            printWriter.println(\");\");\n+    public static void main( final String[] argv ) throws Exception {\n+        if (argv.length != 1) {\n+            System.out.println(\"Usage: BCELifier classname\");\n+            System.out.println(\"\\tThe class must exist on the classpath\");\n+            return;\n@@ -242,1 +294,3 @@\n-        printWriter.println(\"    _cg.addField(field.getField());\");\n+        final JavaClass java_class = getJavaClass(argv[0]);\n+        final BCELifier bcelifier = new BCELifier(java_class, System.out);\n+        bcelifier.start();\n@@ -245,52 +299,0 @@\n-    @Override\n-    public void visitJavaClass(final JavaClass clazz) {\n-        String className = clazz.getClassName();\n-        final String superName = clazz.getSuperclassName();\n-        final String packageName = clazz.getPackageName();\n-        final String inter = Utility.printArray(clazz.getInterfaceNames(), false, true);\n-        if (packageName != null && !packageName.trim().isEmpty()) {\n-            className = className.substring(packageName.length() + 1);\n-            printWriter.println(\"package \" + packageName + \";\");\n-            printWriter.println();\n-        }\n-        printWriter.println(\"import \" + BASE_PACKAGE + \".generic.*;\");\n-        printWriter.println(\"import \" + BASE_PACKAGE + \".classfile.*;\");\n-        printWriter.println(\"import \" + BASE_PACKAGE + \".*;\");\n-        printWriter.println(\"import java.io.*;\");\n-        printWriter.println();\n-        printWriter.println(\"public class \" + className + \"Creator {\");\n-        printWriter.println(\"  private InstructionFactory _factory;\");\n-        printWriter.println(\"  private ConstantPoolGen    _cp;\");\n-        printWriter.println(\"  private ClassGen           _cg;\");\n-        printWriter.println();\n-        printWriter.println(\"  public \" + className + \"Creator() {\");\n-        printWriter.println(\"    _cg = new ClassGen(\\\"\" + (packageName.isEmpty() ? className : packageName + \".\" + className) + \"\\\", \\\"\" + superName\n-            + \"\\\", \" + \"\\\"\" + clazz.getSourceFileName() + \"\\\", \" + printFlags(clazz.getAccessFlags(), FLAGS.CLASS) + \", \" + \"new String[] { \" + inter + \" });\");\n-        printWriter.println(\"    _cg.setMajor(\" + clazz.getMajor() + \");\");\n-        printWriter.println(\"    _cg.setMinor(\" + clazz.getMinor() + \");\");\n-        printWriter.println();\n-        printWriter.println(\"    _cp = _cg.getConstantPool();\");\n-        printWriter.println(\"    _factory = new InstructionFactory(_cg, _cp);\");\n-        printWriter.println(\"  }\");\n-        printWriter.println();\n-        printCreate();\n-        final Field[] fields = clazz.getFields();\n-        if (fields.length > 0) {\n-            printWriter.println(\"  private void createFields() {\");\n-            printWriter.println(\"    FieldGen field;\");\n-            for (final Field field : fields) {\n-                field.accept(this);\n-            }\n-            printWriter.println(\"  }\");\n-            printWriter.println();\n-        }\n-        final Method[] methods = clazz.getMethods();\n-        for (int i = 0; i < methods.length; i++) {\n-            printWriter.println(\"  private void createMethod_\" + i + \"() {\");\n-            methods[i].accept(this);\n-            printWriter.println(\"  }\");\n-            printWriter.println();\n-        }\n-        printMain();\n-        printWriter.println(\"}\");\n-    }\n@@ -298,15 +300,5 @@\n-    @Override\n-    public void visitMethod(final Method method) {\n-        final MethodGen mg = new MethodGen(method, clazz.getClassName(), constantPoolGen);\n-        printWriter.println(\"    InstructionList il = new InstructionList();\");\n-        printWriter.println(\"    MethodGen method = new MethodGen(\" + printFlags(method.getAccessFlags(), FLAGS.METHOD) + \", \" + printType(mg.getReturnType())\n-            + \", \" + printArgumentTypes(mg.getArgumentTypes()) + \", \" + \"new String[] { \" + Utility.printArray(mg.getArgumentNames(), false, true) + \" }, \\\"\"\n-            + method.getName() + \"\\\", \\\"\" + clazz.getClassName() + \"\\\", il, _cp);\");\n-        final ExceptionTable exceptionTable = method.getExceptionTable();\n-        if (exceptionTable != null) {\n-            final String[] exceptionNames = exceptionTable.getExceptionNames();\n-            for (final String exceptionName : exceptionNames) {\n-                printWriter.print(\"    method.addException(\\\"\");\n-                printWriter.print(exceptionName);\n-                printWriter.println(\"\\\");\");\n-            }\n+    \/\/ Needs to be accessible from unit test code\n+    static JavaClass getJavaClass(final String name) throws ClassNotFoundException, IOException {\n+        JavaClass java_class;\n+        if ((java_class = Repository.lookupClass(name)) == null) {\n+            java_class = new ClassParser(name).parse(); \/\/ May throw IOException\n@@ -314,7 +306,1 @@\n-        printWriter.println();\n-        final BCELFactory factory = new BCELFactory(mg, printWriter);\n-        factory.start();\n-        printWriter.println(\"    method.setMaxStack();\");\n-        printWriter.println(\"    method.setMaxLocals();\");\n-        printWriter.println(\"    _cg.addMethod(method.getMethod());\");\n-        printWriter.println(\"    il.dispose();\");\n+        return java_class;\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/BCELifier.java","additions":199,"deletions":213,"binary":false,"changes":412,"status":"modified"},{"patch":"@@ -28,2 +28,4 @@\n- * Utility class that implements a sequence of bytes which can be read via the 'readByte()' method. This is used to\n- * implement a wrapper for the Java byte code stream to gain some more readability.\n+ * Utility class that implements a sequence of bytes which can be read\n+ * via the `readByte()' method. This is used to implement a wrapper for the\n+ * Java byte code stream to gain some more readability.\n+ *\n@@ -33,0 +35,18 @@\n+    private final ByteArrayStream byteStream;\n+\n+\n+    public ByteSequence(final byte[] bytes) {\n+        super(new ByteArrayStream(bytes));\n+        byteStream = (ByteArrayStream) in;\n+    }\n+\n+\n+    public int getIndex() {\n+        return byteStream.getPosition();\n+    }\n+\n+\n+    void unreadByte() {\n+        byteStream.unreadByte();\n+    }\n+\n@@ -50,15 +70,0 @@\n-\n-    private final ByteArrayStream byteStream;\n-\n-    public ByteSequence(final byte[] bytes) {\n-        super(new ByteArrayStream(bytes));\n-        byteStream = (ByteArrayStream) in;\n-    }\n-\n-    public int getIndex() {\n-        return byteStream.getPosition();\n-    }\n-\n-    void unreadByte() {\n-        byteStream.unreadByte();\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ByteSequence.java","additions":22,"deletions":17,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n@@ -26,3 +26,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n-import java.nio.charset.StandardCharsets;\n@@ -43,1 +40,2 @@\n- * Given a JavaClass object \"class\" that is in package \"package\" five files will be created in the specified directory.\n+ * Given a JavaClass object \"class\" that is in package \"package\" five files\n+ * will be created in the specified directory.\n@@ -46,5 +44,6 @@\n- * <LI>\"package\".\"class\".html as the main file which defines the frames for the following subfiles.\n- * <LI>\"package\".\"class\"_attributes.html contains all (known) attributes found in the file\n- * <LI>\"package\".\"class\"_cp.html contains the constant pool\n- * <LI>\"package\".\"class\"_code.html contains the byte code\n- * <LI>\"package\".\"class\"_methods.html contains references to all methods and fields of the class\n+ * <LI> \"package\".\"class\".html as the main file which defines the frames for\n+ * the following subfiles.\n+ * <LI>  \"package\".\"class\"_attributes.html contains all (known) attributes found in the file\n+ * <LI>  \"package\".\"class\"_cp.html contains the constant pool\n+ * <LI>  \"package\".\"class\"_code.html contains the byte code\n+ * <LI>  \"package\".\"class\"_methods.html contains references to all methods and fields of the class\n@@ -53,2 +52,3 @@\n- * All subfiles reference each other appropriately, e.g. clicking on a method in the Method's frame will jump to the\n- * appropriate method in the Code frame.\n+ * All subfiles reference each other appropriately, e.g. clicking on a\n+ * method in the Method's frame will jump to the appropriate method in\n+ * the Code frame.\n@@ -56,1 +56,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: Jan 2020\n@@ -60,4 +60,7 @@\n-    private static String classPackage; \/\/ name of package, unclean to make it static, but ...\n-    private static String className; \/\/ name of current class, dito\n-    private static ConstantPool constantPool;\n-    private static final Set<String> basicTypes = new HashSet<>();\n+    private final JavaClass java_class; \/\/ current class object\n+    private final String dir;\n+    private static String class_package; \/\/ name of package, unclean to make it static, but ...\n+    private static String class_name; \/\/ name of current class, dito\n+    private static ConstantPool constant_pool;\n+    private static final Set<String> basic_types = new HashSet<>();\n+\n@@ -65,9 +68,9 @@\n-        basicTypes.add(\"int\");\n-        basicTypes.add(\"short\");\n-        basicTypes.add(\"boolean\");\n-        basicTypes.add(\"void\");\n-        basicTypes.add(\"char\");\n-        basicTypes.add(\"byte\");\n-        basicTypes.add(\"long\");\n-        basicTypes.add(\"double\");\n-        basicTypes.add(\"float\");\n+        basic_types.add(\"int\");\n+        basic_types.add(\"short\");\n+        basic_types.add(\"boolean\");\n+        basic_types.add(\"void\");\n+        basic_types.add(\"char\");\n+        basic_types.add(\"byte\");\n+        basic_types.add(\"long\");\n+        basic_types.add(\"double\");\n+        basic_types.add(\"float\");\n@@ -76,2 +79,37 @@\n-    public static void _main(final String[] argv) throws IOException {\n-        final String[] fileName = new String[argv.length];\n+    \/**\n+     * Write contents of the given JavaClass into HTML files.\n+     *\n+     * @param java_class The class to write\n+     * @param dir The directory to put the files in\n+     *\/\n+    public Class2HTML(final JavaClass java_class, final String dir) throws IOException {\n+        final Method[] methods = java_class.getMethods();\n+        this.java_class = java_class;\n+        this.dir = dir;\n+        class_name = java_class.getClassName(); \/\/ Remember full name\n+        constant_pool = java_class.getConstantPool();\n+        \/\/ Get package name by tacking off everything after the last `.'\n+        final int index = class_name.lastIndexOf('.');\n+        if (index > -1) {\n+            class_package = class_name.substring(0, index);\n+        } else {\n+            class_package = \"\"; \/\/ default package\n+        }\n+        final ConstantHTML constant_html = new ConstantHTML(dir, class_name, class_package, methods,\n+                constant_pool);\n+        \/* Attributes can't be written in one step, so we just open a file\n+         * which will be written consequently.\n+         *\/\n+        final AttributeHTML attribute_html = new AttributeHTML(dir, class_name, constant_pool,\n+                constant_html);\n+        new MethodHTML(dir, class_name, methods, java_class.getFields(),\n+                constant_html, attribute_html);\n+        \/\/ Write main file (with frames, yuk)\n+        writeMainHTML(attribute_html);\n+        new CodeHTML(dir, class_name, methods, constant_pool, constant_html);\n+        attribute_html.close();\n+    }\n+\n+\n+    public static void main( final String[] argv ) throws IOException {\n+        final String[] file_name = new String[argv.length];\n@@ -80,2 +118,2 @@\n-        JavaClass javaClass = null;\n-        String zipFile = null;\n+        JavaClass java_class = null;\n+        String zip_file = null;\n@@ -84,2 +122,1 @@\n-        \/*\n-         * Parse command line arguments.\n+        \/* Parse command line arguments.\n@@ -97,2 +134,4 @@\n-                        if (!created && !store.isDirectory()) {\n-                            System.out.println(\"Tried to create the directory \" + dir + \" but failed\");\n+                        if (!created) {\n+                            if (!store.isDirectory()) {\n+                                System.out.println(\"Tried to create the directory \" + dir + \" but failed\");\n+                            }\n@@ -102,1 +141,1 @@\n-                    zipFile = argv[++i];\n+                    zip_file = argv[++i];\n@@ -107,1 +146,1 @@\n-                fileName[files++] = argv[i];\n+                file_name[files++] = argv[i];\n@@ -114,3 +153,3 @@\n-                System.out.print(\"Processing \" + fileName[i] + \"...\");\n-                if (zipFile == null) {\n-                    parser = new ClassParser(fileName[i]); \/\/ Create parser object from file\n+                System.out.print(\"Processing \" + file_name[i] + \"...\");\n+                if (zip_file == null) {\n+                    parser = new ClassParser(file_name[i]); \/\/ Create parser object from file\n@@ -118,1 +157,1 @@\n-                    parser = new ClassParser(zipFile, fileName[i]); \/\/ Create parser object from zip file\n+                    parser = new ClassParser(zip_file, file_name[i]); \/\/ Create parser object from zip file\n@@ -120,2 +159,2 @@\n-                javaClass = parser.parse();\n-                new Class2HTML(javaClass, dir);\n+                java_class = parser.parse();\n+                new Class2HTML(java_class, dir);\n@@ -128,1 +167,2 @@\n-     * Utility method that converts a class reference in the constant pool, i.e., an index to a string.\n+     * Utility method that converts a class reference in the constant pool,\n+     * i.e., an index to a string.\n@@ -131,1 +171,1 @@\n-        String str = constantPool.getConstantString(index, Const.CONSTANT_Class);\n+        String str = constant_pool.getConstantString(index, Const.CONSTANT_Class);\n@@ -133,2 +173,3 @@\n-        str = Utility.compactClassName(str, classPackage + \".\", true);\n-        return \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + str + \"<\/A>\";\n+        str = Utility.compactClassName(str, class_package + \".\", true);\n+        return \"<A HREF=\\\"\" + class_name + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + str\n+                + \"<\/A>\";\n@@ -137,3 +178,4 @@\n-    static String referenceType(final String type) {\n-        String shortType = Utility.compactClassName(type);\n-        shortType = Utility.compactClassName(shortType, classPackage + \".\", true);\n+\n+    static String referenceType( final String type ) {\n+        String short_type = Utility.compactClassName(type);\n+        short_type = Utility.compactClassName(short_type, class_package + \".\", true);\n@@ -141,1 +183,1 @@\n-        String baseType = type;\n+        String base_type = type;\n@@ -143,1 +185,1 @@\n-            baseType = type.substring(0, index); \/\/ Tack of the '['\n+            base_type = type.substring(0, index); \/\/ Tack of the `['\n@@ -146,1 +188,1 @@\n-        if (basicTypes.contains(baseType)) {\n+        if (basic_types.contains(base_type)) {\n@@ -149,1 +191,1 @@\n-        return \"<A HREF=\\\"\" + baseType + \".html\\\" TARGET=_top>\" + shortType + \"<\/A>\";\n+        return \"<A HREF=\\\"\" + base_type + \".html\\\" TARGET=_top>\" + short_type + \"<\/A>\";\n@@ -152,1 +194,2 @@\n-    static String toHTML(final String str) {\n+\n+    static String toHTML( final String str ) {\n@@ -157,14 +200,14 @@\n-            case '<':\n-                buf.append(\"&lt;\");\n-                break;\n-            case '>':\n-                buf.append(\"&gt;\");\n-                break;\n-            case '\\n':\n-                buf.append(\"\\\\n\");\n-                break;\n-            case '\\r':\n-                buf.append(\"\\\\r\");\n-                break;\n-            default:\n-                buf.append(ch);\n+                case '<':\n+                    buf.append(\"&lt;\");\n+                    break;\n+                case '>':\n+                    buf.append(\"&gt;\");\n+                    break;\n+                case '\\n':\n+                    buf.append(\"\\\\n\");\n+                    break;\n+                case '\\r':\n+                    buf.append(\"\\\\r\");\n+                    break;\n+                default:\n+                    buf.append(ch);\n@@ -176,39 +219,0 @@\n-    private final JavaClass javaClass; \/\/ current class object\n-\n-    private final String dir;\n-\n-    \/**\n-     * Write contents of the given JavaClass into HTML files.\n-     *\n-     * @param javaClass The class to write\n-     * @param dir The directory to put the files in\n-     * @throws IOException Thrown when an I\/O exception of some sort has occurred.\n-     *\/\n-    public Class2HTML(final JavaClass javaClass, final String dir) throws IOException {\n-        this(javaClass, dir, StandardCharsets.UTF_8);\n-    }\n-\n-    private Class2HTML(final JavaClass javaClass, final String dir, final Charset charset) throws IOException {\n-        final Method[] methods = javaClass.getMethods();\n-        this.javaClass = javaClass;\n-        this.dir = dir;\n-        className = javaClass.getClassName(); \/\/ Remember full name\n-        constantPool = javaClass.getConstantPool();\n-        \/\/ Get package name by tacking off everything after the last '.'\n-        final int index = className.lastIndexOf('.');\n-        if (index > -1) {\n-            classPackage = className.substring(0, index);\n-        } else {\n-            classPackage = \"\"; \/\/ default package\n-        }\n-        final ConstantHTML constantHtml = new ConstantHTML(dir, className, classPackage, methods, constantPool, charset);\n-        \/*\n-         * Attributes can't be written in one step, so we just open a file which will be written consequently.\n-         *\/\n-        try (AttributeHTML attributeHtml = new AttributeHTML(dir, className, constantPool, constantHtml, charset)) {\n-            new MethodHTML(dir, className, methods, javaClass.getFields(), constantHtml, attributeHtml, charset);\n-            \/\/ Write main file (with frames, yuk)\n-            writeMainHTML(attributeHtml, charset);\n-            new CodeHTML(dir, className, methods, constantPool, constantHtml, charset);\n-        }\n-    }\n@@ -216,9 +220,12 @@\n-    private void writeMainHTML(final AttributeHTML attributeHtml, final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n-        try (PrintWriter file = new PrintWriter(dir + className + \".html\", charset.name())) {\n-            file.println(\"<HTML>\\n\" + \"<HEAD><TITLE>Documentation for \" + className + \"<\/TITLE>\" + \"<\/HEAD>\\n\" + \"<FRAMESET BORDER=1 cols=\\\"30%,*\\\">\\n\"\n-                + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"ConstantPool\\\" SRC=\\\"\" + className + \"_cp.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n-                + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Attributes\\\" SRC=\\\"\" + className + \"_attributes.html\"\n-                + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \" + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET>\\n\"\n-                + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"Code\\\" SRC=\\\"\" + className + \"_code.html\\\"\\n MARGINWIDTH=0 \"\n-                + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Methods\\\" SRC=\\\"\" + className + \"_methods.html\\\"\\n MARGINWIDTH=0 \"\n-                + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET><\/FRAMESET><\/HTML>\");\n+    private void writeMainHTML( final AttributeHTML attribute_html ) throws IOException {\n+        try (PrintWriter file = new PrintWriter(new FileOutputStream(dir + class_name + \".html\"))) {\n+            file.println(\"<HTML>\\n\" + \"<HEAD><TITLE>Documentation for \" + class_name + \"<\/TITLE>\" + \"<\/HEAD>\\n\"\n+                    + \"<FRAMESET BORDER=1 cols=\\\"30%,*\\\">\\n\" + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\"\n+                    + \"<FRAME NAME=\\\"ConstantPool\\\" SRC=\\\"\" + class_name + \"_cp.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n+                    + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<FRAME NAME=\\\"Attributes\\\" SRC=\\\"\"\n+                    + class_name + \"_attributes.html\" + \"\\\"\\n MARGINWIDTH=\\\"0\\\" \"\n+                    + \"MARGINHEIGHT=\\\"0\\\" FRAMEBORDER=\\\"1\\\" SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET>\\n\"\n+                    + \"<FRAMESET BORDER=1 rows=\\\"80%,*\\\">\\n\" + \"<FRAME NAME=\\\"Code\\\" SRC=\\\"\" + class_name\n+                    + \"_code.html\\\"\\n MARGINWIDTH=0 \" + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\"\n+                    + \"<FRAME NAME=\\\"Methods\\\" SRC=\\\"\" + class_name + \"_methods.html\\\"\\n MARGINWIDTH=0 \"\n+                    + \"MARGINHEIGHT=0 FRAMEBORDER=1 SCROLLING=\\\"AUTO\\\">\\n\" + \"<\/FRAMESET><\/FRAMESET><\/HTML>\");\n@@ -226,1 +233,1 @@\n-        final Attribute[] attributes = javaClass.getAttributes();\n+        final Attribute[] attributes = java_class.getAttributes();\n@@ -228,1 +235,1 @@\n-            attributeHtml.writeAttribute(attributes[i], \"class\" + i);\n+            attribute_html.writeAttribute(attributes[i], \"class\" + i);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Class2HTML.java","additions":126,"deletions":119,"binary":false,"changes":245,"status":"modified"},{"patch":"@@ -27,1 +27,3 @@\n- * Utility class implementing a (typesafe) queue of JavaClass objects.\n+ * Utility class implementing a (typesafe) queue of JavaClass\n+ * objects.\n+ *\n@@ -32,5 +34,7 @@\n-    \/**\n-     * @deprecated (since 6.0) will be made private; do not access\n-     *\/\n-    @Deprecated\n-    protected LinkedList<JavaClass> vec = new LinkedList<>(); \/\/ TODO not used externally\n+    private final LinkedList<JavaClass> vec = new LinkedList<>();\n+\n+\n+    public void enqueue( final JavaClass clazz ) {\n+        vec.addLast(clazz);\n+    }\n+\n@@ -42,0 +46,1 @@\n+\n@@ -46,3 +51,0 @@\n-    public void enqueue(final JavaClass clazz) {\n-        vec.addLast(clazz);\n-    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassQueue.java","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * reserved comment block\n+ * DO NOT REMOVE OR ALTER!\n@@ -23,1 +24,1 @@\n-import com.sun.org.apache.bcel.internal.Const;\n+import java.util.Collection;\n@@ -30,1 +31,3 @@\n- * Utility class implementing a (type-safe) set of JavaClass objects. Since JavaClass has no equals() method, the name of the class is used for comparison.\n+ * Utility class implementing a (typesafe) set of JavaClass objects.\n+ * Since JavaClass has no equals() method, the name of the class is\n+ * used for comparison.\n@@ -33,1 +36,0 @@\n- * @LastModified: Feb 2023\n@@ -39,2 +41,8 @@\n-    public boolean add(final JavaClass clazz) {\n-        return map.putIfAbsent(clazz.getClassName(), clazz) != null;\n+\n+    public boolean add( final JavaClass clazz ) {\n+        boolean result = false;\n+        if (!map.containsKey(clazz.getClassName())) {\n+            result = true;\n+            map.put(clazz.getClassName(), clazz);\n+        }\n+        return result;\n@@ -43,0 +51,6 @@\n+\n+    public void remove( final JavaClass clazz ) {\n+        map.remove(clazz.getClassName());\n+    }\n+\n+\n@@ -47,3 +61,0 @@\n-    public String[] getClassNames() {\n-        return map.keySet().toArray(Const.EMPTY_STRING_ARRAY);\n-    }\n@@ -51,2 +62,5 @@\n-    public void remove(final JavaClass clazz) {\n-        map.remove(clazz.getClassName());\n+    public JavaClass[] toArray() {\n+        final Collection<JavaClass> values = map.values();\n+        final JavaClass[] classes = new JavaClass[values.size()];\n+        values.toArray(classes);\n+        return classes;\n@@ -55,2 +69,3 @@\n-    public JavaClass[] toArray() {\n-        return map.values().toArray(JavaClass.EMPTY_ARRAY);\n+\n+    public String[] getClassNames() {\n+        return map.keySet().toArray(new String[map.size()]);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassSet.java","additions":28,"deletions":13,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -37,2 +37,3 @@\n-    public boolean empty() {\n-        return stack.empty();\n+\n+    public void push( final JavaClass clazz ) {\n+        stack.push(clazz);\n@@ -41,0 +42,1 @@\n+\n@@ -45,3 +47,0 @@\n-    public void push(final JavaClass clazz) {\n-        stack.push(clazz);\n-    }\n@@ -52,0 +51,5 @@\n+\n+\n+    public boolean empty() {\n+        return stack.empty();\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ClassStack.java","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -24,0 +24,1 @@\n+import java.io.FileOutputStream;\n@@ -26,1 +27,0 @@\n-import java.nio.charset.Charset;\n@@ -39,0 +39,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.LocalVariable;\n@@ -45,0 +46,2 @@\n+ *\n+ *\n@@ -48,1 +51,0 @@\n-    private static boolean wide;\n@@ -50,2 +52,2 @@\n-    \/\/ private Method[] methods; \/\/ Methods to print\n-    private final PrintWriter printWriter; \/\/ file to write to\n+\/\/    private Method[] methods; \/\/ Methods to print\n+    private final PrintWriter file; \/\/ file to write to\n@@ -55,0 +57,1 @@\n+    private static boolean wide = false;\n@@ -56,3 +59,4 @@\n-    CodeHTML(final String dir, final String className, final Method[] methods, final ConstantPool constantPool, final ConstantHTML constantHtml,\n-        final Charset charset) throws IOException {\n-        this.className = className;\n+\n+    CodeHTML(final String dir, final String class_name, final Method[] methods, final ConstantPool constant_pool,\n+            final ConstantHTML constant_html) throws IOException {\n+        this.className = class_name;\n@@ -60,12 +64,6 @@\n-        this.constantPool = constantPool;\n-        this.constantHtml = constantHtml;\n-        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_code.html\", charset.name())) {\n-            printWriter = newPrintWriter;\n-            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-            printWriter.print(charset.name());\n-            printWriter.println(\"\\\"><\/head>\");\n-            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\">\");\n-            for (int i = 0; i < methods.length; i++) {\n-                writeMethod(methods[i], i);\n-            }\n-            printWriter.println(\"<\/BODY><\/HTML>\");\n+        this.constantPool = constant_pool;\n+        this.constantHtml = constant_html;\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_code.html\"));\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\">\");\n+        for (int i = 0; i < methods.length; i++) {\n+            writeMethod(methods[i], i);\n@@ -73,0 +71,2 @@\n+        file.println(\"<\/BODY><\/HTML>\");\n+        file.close();\n@@ -75,0 +75,1 @@\n+\n@@ -76,1 +77,2 @@\n-     * Disassemble a stream of byte codes and return the string representation.\n+     * Disassemble a stream of byte codes and return the\n+     * string representation.\n@@ -78,1 +80,1 @@\n-     * @param stream data input stream\n+     * @param  stream data input stream\n@@ -81,1 +83,1 @@\n-    private String codeToHTML(final ByteSequence bytes, final int methodNumber) throws IOException {\n+    private String codeToHTML( final ByteSequence bytes, final int method_number ) throws IOException {\n@@ -85,1 +87,1 @@\n-        int defaultOffset = 0;\n+        int default_offset = 0;\n@@ -89,1 +91,1 @@\n-        int classIndex;\n+        int class_index;\n@@ -92,2 +94,2 @@\n-        int[] jumpTable;\n-        int noPadBytes = 0;\n+        int[] jump_table;\n+        int no_pad_bytes = 0;\n@@ -97,2 +99,2 @@\n-        \/*\n-         * Special case: Skip (0-3) padding bytes, i.e., the following bytes are 4-byte-aligned\n+        \/* Special case: Skip (0-3) padding bytes, i.e., the\n+         * following bytes are 4-byte-aligned\n@@ -100,1 +102,1 @@\n-        if (opcode == Const.TABLESWITCH || opcode == Const.LOOKUPSWITCH) {\n+        if ((opcode == Const.TABLESWITCH) || (opcode == Const.LOOKUPSWITCH)) {\n@@ -102,2 +104,2 @@\n-            noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n-            for (int i = 0; i < noPadBytes; i++) {\n+            no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n+            for (int i = 0; i < no_pad_bytes; i++) {\n@@ -107,1 +109,1 @@\n-            defaultOffset = bytes.readInt();\n+            default_offset = bytes.readInt();\n@@ -110,131 +112,17 @@\n-        case Const.TABLESWITCH:\n-            low = bytes.readInt();\n-            high = bytes.readInt();\n-            offset = bytes.getIndex() - 12 - noPadBytes - 1;\n-            defaultOffset += offset;\n-            buf.append(\"<TABLE BORDER=1><TR>\");\n-            \/\/ Print switch indices in first row (and default)\n-            jumpTable = new int[high - low + 1];\n-            for (int i = 0; i < jumpTable.length; i++) {\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(\"<TH>\").append(low + i).append(\"<\/TH>\");\n-            }\n-            buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n-            \/\/ Print target and default indices in second row\n-            for (final int element : jumpTable) {\n-                buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(element).append(\"\\\">\").append(element).append(\"<\/A><\/TD>\");\n-            }\n-            buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(defaultOffset).append(\"\\\">\").append(defaultOffset)\n-                .append(\"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n-            break;\n-        \/*\n-         * Lookup switch has variable length arguments.\n-         *\/\n-        case Const.LOOKUPSWITCH:\n-            final int npairs = bytes.readInt();\n-            offset = bytes.getIndex() - 8 - noPadBytes - 1;\n-            jumpTable = new int[npairs];\n-            defaultOffset += offset;\n-            buf.append(\"<TABLE BORDER=1><TR>\");\n-            \/\/ Print switch indices in first row (and default)\n-            for (int i = 0; i < npairs; i++) {\n-                final int match = bytes.readInt();\n-                jumpTable[i] = offset + bytes.readInt();\n-                buf.append(\"<TH>\").append(match).append(\"<\/TH>\");\n-            }\n-            buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n-            \/\/ Print target and default indices in second row\n-            for (int i = 0; i < npairs; i++) {\n-                buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(jumpTable[i]).append(\"\\\">\").append(jumpTable[i])\n-                    .append(\"<\/A><\/TD>\");\n-            }\n-            buf.append(\"<TD><A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(defaultOffset).append(\"\\\">\").append(defaultOffset)\n-                .append(\"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n-            break;\n-        \/*\n-         * Two address bytes + offset from start of byte stream form the jump target.\n-         *\/\n-        case Const.GOTO:\n-        case Const.IFEQ:\n-        case Const.IFGE:\n-        case Const.IFGT:\n-        case Const.IFLE:\n-        case Const.IFLT:\n-        case Const.IFNE:\n-        case Const.IFNONNULL:\n-        case Const.IFNULL:\n-        case Const.IF_ACMPEQ:\n-        case Const.IF_ACMPNE:\n-        case Const.IF_ICMPEQ:\n-        case Const.IF_ICMPGE:\n-        case Const.IF_ICMPGT:\n-        case Const.IF_ICMPLE:\n-        case Const.IF_ICMPLT:\n-        case Const.IF_ICMPNE:\n-        case Const.JSR:\n-            index = bytes.getIndex() + bytes.readShort() - 1;\n-            buf.append(\"<A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(index).append(\"\\\">\").append(index).append(\"<\/A>\");\n-            break;\n-        \/*\n-         * Same for 32-bit wide jumps\n-         *\/\n-        case Const.GOTO_W:\n-        case Const.JSR_W:\n-            final int windex = bytes.getIndex() + bytes.readInt() - 1;\n-            buf.append(\"<A HREF=\\\"#code\").append(methodNumber).append(\"@\").append(windex).append(\"\\\">\").append(windex).append(\"<\/A>\");\n-            break;\n-        \/*\n-         * Index byte references local variable (register)\n-         *\/\n-        case Const.ALOAD:\n-        case Const.ASTORE:\n-        case Const.DLOAD:\n-        case Const.DSTORE:\n-        case Const.FLOAD:\n-        case Const.FSTORE:\n-        case Const.ILOAD:\n-        case Const.ISTORE:\n-        case Const.LLOAD:\n-        case Const.LSTORE:\n-        case Const.RET:\n-            if (wide) {\n-                vindex = bytes.readShort();\n-                wide = false; \/\/ Clear flag\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-            }\n-            buf.append(\"%\").append(vindex);\n-            break;\n-        \/*\n-         * Remember wide byte which is used to form a 16-bit address in the following instruction. Relies on that the method is\n-         * called again with the following opcode.\n-         *\/\n-        case Const.WIDE:\n-            wide = true;\n-            buf.append(\"(wide)\");\n-            break;\n-        \/*\n-         * Array of basic type.\n-         *\/\n-        case Const.NEWARRAY:\n-            buf.append(\"<FONT COLOR=\\\"#00FF00\\\">\").append(Const.getTypeName(bytes.readByte())).append(\"<\/FONT>\");\n-            break;\n-        \/*\n-         * Access object\/class fields.\n-         *\/\n-        case Const.GETFIELD:\n-        case Const.GETSTATIC:\n-        case Const.PUTFIELD:\n-        case Const.PUTSTATIC:\n-            index = bytes.readShort();\n-            final ConstantFieldref c1 = constantPool.getConstant(index, Const.CONSTANT_Fieldref, ConstantFieldref.class);\n-            classIndex = c1.getClassIndex();\n-            name = constantPool.getConstantString(classIndex, Const.CONSTANT_Class);\n-            name = Utility.compactClassName(name, false);\n-            index = c1.getNameAndTypeIndex();\n-            final String fieldName = constantPool.constantToString(index, Const.CONSTANT_NameAndType);\n-            if (name.equals(className)) { \/\/ Local field\n-                buf.append(\"<A HREF=\\\"\").append(className).append(\"_methods.html#field\").append(fieldName).append(\"\\\" TARGET=Methods>\").append(fieldName)\n-                    .append(\"<\/A>\\n\");\n-            } else {\n-                buf.append(constantHtml.referenceConstant(classIndex)).append(\".\").append(fieldName);\n+            case Const.TABLESWITCH:\n+                low = bytes.readInt();\n+                high = bytes.readInt();\n+                offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n+                default_offset += offset;\n+                buf.append(\"<TABLE BORDER=1><TR>\");\n+                \/\/ Print switch indices in first row (and default)\n+                jump_table = new int[high - low + 1];\n+                for (int i = 0; i < jump_table.length; i++) {\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(\"<TH>\").append(low + i).append(\"<\/TH>\");\n+                }\n+                buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n+                \/\/ Print target and default indices in second row\n+            for (final int element : jump_table) {\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                        element).append(\"\\\">\").append(element).append(\"<\/A><\/TD>\");\n@@ -242,23 +130,140 @@\n-            break;\n-        \/*\n-         * Operands are references to classes in constant pool\n-         *\/\n-        case Const.CHECKCAST:\n-        case Const.INSTANCEOF:\n-        case Const.NEW:\n-            index = bytes.readShort();\n-            buf.append(constantHtml.referenceConstant(index));\n-            break;\n-        \/*\n-         * Operands are references to methods in constant pool\n-         *\/\n-        case Const.INVOKESPECIAL:\n-        case Const.INVOKESTATIC:\n-        case Const.INVOKEVIRTUAL:\n-        case Const.INVOKEINTERFACE:\n-        case Const.INVOKEDYNAMIC:\n-            final int mIndex = bytes.readShort();\n-            String str;\n-            if (opcode == Const.INVOKEINTERFACE) { \/\/ Special treatment needed\n-                bytes.readUnsignedByte(); \/\/ Redundant\n-                bytes.readUnsignedByte(); \/\/ Reserved\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                        default_offset).append(\"\\\">\").append(default_offset).append(\n+                        \"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n+                break;\n+            \/* Lookup switch has variable length arguments.\n+             *\/\n+            case Const.LOOKUPSWITCH:\n+                final int npairs = bytes.readInt();\n+                offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n+                jump_table = new int[npairs];\n+                default_offset += offset;\n+                buf.append(\"<TABLE BORDER=1><TR>\");\n+                \/\/ Print switch indices in first row (and default)\n+                for (int i = 0; i < npairs; i++) {\n+                    final int match = bytes.readInt();\n+                    jump_table[i] = offset + bytes.readInt();\n+                    buf.append(\"<TH>\").append(match).append(\"<\/TH>\");\n+                }\n+                buf.append(\"<TH>default<\/TH><\/TR>\\n<TR>\");\n+                \/\/ Print target and default indices in second row\n+                for (int i = 0; i < npairs; i++) {\n+                    buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                            jump_table[i]).append(\"\\\">\").append(jump_table[i]).append(\"<\/A><\/TD>\");\n+                }\n+                buf.append(\"<TD><A HREF=\\\"#code\").append(method_number).append(\"@\").append(\n+                        default_offset).append(\"\\\">\").append(default_offset).append(\n+                        \"<\/A><\/TD><\/TR>\\n<\/TABLE>\\n\");\n+                break;\n+            \/* Two address bytes + offset from start of byte stream form the\n+             * jump target.\n+             *\/\n+            case Const.GOTO:\n+            case Const.IFEQ:\n+            case Const.IFGE:\n+            case Const.IFGT:\n+            case Const.IFLE:\n+            case Const.IFLT:\n+            case Const.IFNE:\n+            case Const.IFNONNULL:\n+            case Const.IFNULL:\n+            case Const.IF_ACMPEQ:\n+            case Const.IF_ACMPNE:\n+            case Const.IF_ICMPEQ:\n+            case Const.IF_ICMPGE:\n+            case Const.IF_ICMPGT:\n+            case Const.IF_ICMPLE:\n+            case Const.IF_ICMPLT:\n+            case Const.IF_ICMPNE:\n+            case Const.JSR:\n+                index = bytes.getIndex() + bytes.readShort() - 1;\n+                buf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(index)\n+                        .append(\"\\\">\").append(index).append(\"<\/A>\");\n+                break;\n+            \/* Same for 32-bit wide jumps\n+             *\/\n+            case Const.GOTO_W:\n+            case Const.JSR_W:\n+                final int windex = bytes.getIndex() + bytes.readInt() - 1;\n+                buf.append(\"<A HREF=\\\"#code\").append(method_number).append(\"@\").append(windex)\n+                        .append(\"\\\">\").append(windex).append(\"<\/A>\");\n+                break;\n+            \/* Index byte references local variable (register)\n+             *\/\n+            case Const.ALOAD:\n+            case Const.ASTORE:\n+            case Const.DLOAD:\n+            case Const.DSTORE:\n+            case Const.FLOAD:\n+            case Const.FSTORE:\n+            case Const.ILOAD:\n+            case Const.ISTORE:\n+            case Const.LLOAD:\n+            case Const.LSTORE:\n+            case Const.RET:\n+                if (wide) {\n+                    vindex = bytes.readShort();\n+                    wide = false; \/\/ Clear flag\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                }\n+                buf.append(\"%\").append(vindex);\n+                break;\n+            \/*\n+             * Remember wide byte which is used to form a 16-bit address in the\n+             * following instruction. Relies on that the method is called again with\n+             * the following opcode.\n+             *\/\n+            case Const.WIDE:\n+                wide = true;\n+                buf.append(\"(wide)\");\n+                break;\n+            \/* Array of basic type.\n+             *\/\n+            case Const.NEWARRAY:\n+                buf.append(\"<FONT COLOR=\\\"#00FF00\\\">\").append(Const.getTypeName(bytes.readByte())).append(\n+                        \"<\/FONT>\");\n+                break;\n+            \/* Access object\/class fields.\n+             *\/\n+            case Const.GETFIELD:\n+            case Const.GETSTATIC:\n+            case Const.PUTFIELD:\n+            case Const.PUTSTATIC:\n+                index = bytes.readShort();\n+                final ConstantFieldref c1 = (ConstantFieldref) constantPool.getConstant(index,\n+                        Const.CONSTANT_Fieldref);\n+                class_index = c1.getClassIndex();\n+                name = constantPool.getConstantString(class_index, Const.CONSTANT_Class);\n+                name = Utility.compactClassName(name, false);\n+                index = c1.getNameAndTypeIndex();\n+                final String field_name = constantPool.constantToString(index, Const.CONSTANT_NameAndType);\n+                if (name.equals(className)) { \/\/ Local field\n+                    buf.append(\"<A HREF=\\\"\").append(className).append(\"_methods.html#field\")\n+                            .append(field_name).append(\"\\\" TARGET=Methods>\").append(field_name)\n+                            .append(\"<\/A>\\n\");\n+                } else {\n+                    buf.append(constantHtml.referenceConstant(class_index)).append(\".\").append(\n+                            field_name);\n+                }\n+                break;\n+            \/* Operands are references to classes in constant pool\n+             *\/\n+            case Const.CHECKCAST:\n+            case Const.INSTANCEOF:\n+            case Const.NEW:\n+                index = bytes.readShort();\n+                buf.append(constantHtml.referenceConstant(index));\n+                break;\n+            \/* Operands are references to methods in constant pool\n+             *\/\n+            case Const.INVOKESPECIAL:\n+            case Const.INVOKESTATIC:\n+            case Const.INVOKEVIRTUAL:\n+            case Const.INVOKEINTERFACE:\n+            case Const.INVOKEDYNAMIC:\n+                final int m_index = bytes.readShort();\n+                String str;\n+                if (opcode == Const.INVOKEINTERFACE) { \/\/ Special treatment needed\n+                    bytes.readUnsignedByte(); \/\/ Redundant\n+                    bytes.readUnsignedByte(); \/\/ Reserved\n@@ -267,32 +272,21 @@\n-                final ConstantInterfaceMethodref c = constantPool.getConstant(mIndex, Const.CONSTANT_InterfaceMethodref, ConstantInterfaceMethodref.class);\n-                classIndex = c.getClassIndex();\n-                index = c.getNameAndTypeIndex();\n-                name = Class2HTML.referenceClass(classIndex);\n-            } else if (opcode == Const.INVOKEDYNAMIC) { \/\/ Special treatment needed\n-                bytes.readUnsignedByte(); \/\/ Reserved\n-                bytes.readUnsignedByte(); \/\/ Reserved\n-                final ConstantInvokeDynamic c = constantPool.getConstant(mIndex, Const.CONSTANT_InvokeDynamic, ConstantInvokeDynamic.class);\n-                index = c.getNameAndTypeIndex();\n-                name = \"#\" + c.getBootstrapMethodAttrIndex();\n-            } else {\n-                \/\/ UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to\n-                \/\/ reference EITHER a Methodref OR an InterfaceMethodref.\n-                \/\/ Not sure if that affects this code or not. (markro)\n-                final ConstantMethodref c = constantPool.getConstant(mIndex, Const.CONSTANT_Methodref, ConstantMethodref.class);\n-                classIndex = c.getClassIndex();\n-                index = c.getNameAndTypeIndex();\n-                name = Class2HTML.referenceClass(classIndex);\n-            }\n-            str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(index, Const.CONSTANT_NameAndType)));\n-            \/\/ Get signature, i.e., types\n-            final ConstantNameAndType c2 = constantPool.getConstant(index, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-            signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n-            final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n-            final String type = Utility.methodSignatureReturnType(signature, false);\n-            buf.append(name).append(\".<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(mIndex).append(\"\\\" TARGET=ConstantPool>\").append(str)\n-                .append(\"<\/A>\").append(\"(\");\n-            \/\/ List arguments\n-            for (int i = 0; i < args.length; i++) {\n-                buf.append(Class2HTML.referenceType(args[i]));\n-                if (i < args.length - 1) {\n-                    buf.append(\", \");\n+                    final ConstantInterfaceMethodref c = (ConstantInterfaceMethodref) constantPool\n+                            .getConstant(m_index, Const.CONSTANT_InterfaceMethodref);\n+                    class_index = c.getClassIndex();\n+                    index = c.getNameAndTypeIndex();\n+                    name = Class2HTML.referenceClass(class_index);\n+                } else if (opcode == Const.INVOKEDYNAMIC) { \/\/ Special treatment needed\n+                    bytes.readUnsignedByte(); \/\/ Reserved\n+                    bytes.readUnsignedByte(); \/\/ Reserved\n+                    final ConstantInvokeDynamic c = (ConstantInvokeDynamic) constantPool\n+                            .getConstant(m_index, Const.CONSTANT_InvokeDynamic);\n+                    index = c.getNameAndTypeIndex();\n+                    name = \"#\" + c.getBootstrapMethodAttrIndex();\n+                } else {\n+                    \/\/ UNDONE: Java8 now allows INVOKESPECIAL and INVOKESTATIC to\n+                    \/\/ reference EITHER a Methodref OR an InterfaceMethodref.\n+                    \/\/ Not sure if that affects this code or not.  (markro)\n+                    final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(m_index,\n+                            Const.CONSTANT_Methodref);\n+                    class_index = c.getClassIndex();\n+                    index = c.getNameAndTypeIndex();\n+                name = Class2HTML.referenceClass(class_index);\n@@ -300,62 +294,84 @@\n-            }\n-            \/\/ Attach return type\n-            buf.append(\"):\").append(Class2HTML.referenceType(type));\n-            break;\n-        \/*\n-         * Operands are references to items in constant pool\n-         *\/\n-        case Const.LDC_W:\n-        case Const.LDC2_W:\n-            index = bytes.readShort();\n-            buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\")\n-                .append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n-            break;\n-        case Const.LDC:\n-            index = bytes.readUnsignedByte();\n-            buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index).append(\"\\\" TARGET=\\\"ConstantPool\\\">\")\n-                .append(Class2HTML.toHTML(constantPool.constantToString(index, constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n-            break;\n-        \/*\n-         * Array of references.\n-         *\/\n-        case Const.ANEWARRAY:\n-            index = bytes.readShort();\n-            buf.append(constantHtml.referenceConstant(index));\n-            break;\n-        \/*\n-         * Multidimensional array of references.\n-         *\/\n-        case Const.MULTIANEWARRAY:\n-            index = bytes.readShort();\n-            final int dimensions = bytes.readByte();\n-            buf.append(constantHtml.referenceConstant(index)).append(\":\").append(dimensions).append(\"-dimensional\");\n-            break;\n-        \/*\n-         * Increment local variable.\n-         *\/\n-        case Const.IINC:\n-            if (wide) {\n-                vindex = bytes.readShort();\n-                constant = bytes.readShort();\n-                wide = false;\n-            } else {\n-                vindex = bytes.readUnsignedByte();\n-                constant = bytes.readByte();\n-            }\n-            buf.append(\"%\").append(vindex).append(\" \").append(constant);\n-            break;\n-        default:\n-            if (Const.getNoOfOperands(opcode) > 0) {\n-                for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n-                    switch (Const.getOperandType(opcode, i)) {\n-                    case Const.T_BYTE:\n-                        buf.append(bytes.readUnsignedByte());\n-                        break;\n-                    case Const.T_SHORT: \/\/ Either branch or index\n-                        buf.append(bytes.readShort());\n-                        break;\n-                    case Const.T_INT:\n-                        buf.append(bytes.readInt());\n-                        break;\n-                    default: \/\/ Never reached\n-                        throw new IllegalStateException(\"Unreachable default case reached! \" + Const.getOperandType(opcode, i));\n+                str = Class2HTML.toHTML(constantPool.constantToString(constantPool.getConstant(\n+                        index, Const.CONSTANT_NameAndType)));\n+                \/\/ Get signature, i.e., types\n+                final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(index,\n+                        Const.CONSTANT_NameAndType);\n+                signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n+                final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n+                final String type = Utility.methodSignatureReturnType(signature, false);\n+                buf.append(name).append(\".<A HREF=\\\"\").append(className).append(\"_cp.html#cp\")\n+                        .append(m_index).append(\"\\\" TARGET=ConstantPool>\").append(str).append(\n+                                \"<\/A>\").append(\"(\");\n+                \/\/ List arguments\n+                for (int i = 0; i < args.length; i++) {\n+                    buf.append(Class2HTML.referenceType(args[i]));\n+                    if (i < args.length - 1) {\n+                        buf.append(\", \");\n+                    }\n+                }\n+                \/\/ Attach return type\n+                buf.append(\"):\").append(Class2HTML.referenceType(type));\n+                break;\n+            \/* Operands are references to items in constant pool\n+             *\/\n+            case Const.LDC_W:\n+            case Const.LDC2_W:\n+                index = bytes.readShort();\n+                buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index)\n+                        .append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(\n+                                Class2HTML.toHTML(constantPool.constantToString(index,\n+                                        constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n+                break;\n+            case Const.LDC:\n+                index = bytes.readUnsignedByte();\n+                buf.append(\"<A HREF=\\\"\").append(className).append(\"_cp.html#cp\").append(index)\n+                        .append(\"\\\" TARGET=\\\"ConstantPool\\\">\").append(\n+                                Class2HTML.toHTML(constantPool.constantToString(index,\n+                                        constantPool.getConstant(index).getTag()))).append(\"<\/a>\");\n+                break;\n+            \/* Array of references.\n+             *\/\n+            case Const.ANEWARRAY:\n+                index = bytes.readShort();\n+                buf.append(constantHtml.referenceConstant(index));\n+                break;\n+            \/* Multidimensional array of references.\n+             *\/\n+            case Const.MULTIANEWARRAY:\n+                index = bytes.readShort();\n+                final int dimensions = bytes.readByte();\n+                buf.append(constantHtml.referenceConstant(index)).append(\":\").append(dimensions)\n+                        .append(\"-dimensional\");\n+                break;\n+            \/* Increment local variable.\n+             *\/\n+            case Const.IINC:\n+                if (wide) {\n+                    vindex = bytes.readShort();\n+                    constant = bytes.readShort();\n+                    wide = false;\n+                } else {\n+                    vindex = bytes.readUnsignedByte();\n+                    constant = bytes.readByte();\n+                }\n+                buf.append(\"%\").append(vindex).append(\" \").append(constant);\n+                break;\n+            default:\n+                if (Const.getNoOfOperands(opcode) > 0) {\n+                    for (int i = 0; i < Const.getOperandTypeCount(opcode); i++) {\n+                        switch (Const.getOperandType(opcode, i)) {\n+                            case Const.T_BYTE:\n+                                buf.append(bytes.readUnsignedByte());\n+                                break;\n+                            case Const.T_SHORT: \/\/ Either branch or index\n+                                buf.append(bytes.readShort());\n+                                break;\n+                            case Const.T_INT:\n+                                buf.append(bytes.readInt());\n+                                break;\n+                            default: \/\/ Never reached\n+                                throw new IllegalStateException(\n+                                        \"Unreachable default case reached! \" +\n+                                                Const.getOperandType(opcode, i));\n+                        }\n+                        buf.append(\"&nbsp;\");\n@@ -363,1 +379,0 @@\n-                    buf.append(\"&nbsp;\");\n@@ -365,1 +380,0 @@\n-            }\n@@ -371,0 +385,1 @@\n+\n@@ -372,2 +387,2 @@\n-     * Find all target addresses in code, so that they can be marked with &lt;A NAME = ...&gt;. Target addresses are kept in\n-     * an BitSet object.\n+     * Find all target addresses in code, so that they can be marked\n+     * with &lt;A NAME = ...&gt;. Target addresses are kept in an BitSet object.\n@@ -375,1 +390,1 @@\n-    private void findGotos(final ByteSequence bytes, final Code code) throws IOException {\n+    private void findGotos( final ByteSequence bytes, final Code code ) throws IOException {\n@@ -379,3 +394,2 @@\n-        \/*\n-         * First get Code attribute from method and the exceptions handled (try .. catch) in this method. We only need the line\n-         * number here.\n+        \/* First get Code attribute from method and the exceptions handled\n+         * (try .. catch) in this method. We only need the line number here.\n@@ -394,1 +408,3 @@\n-                    ((LocalVariableTable) attribute).forEach(var -> {\n+                    final LocalVariable[] vars = ((LocalVariableTable) attribute)\n+                            .getLocalVariableTable();\n+                    for (final LocalVariable var : vars) {\n@@ -396,0 +412,1 @@\n+                        final int end = start + var.getLength();\n@@ -397,2 +414,2 @@\n-                        gotoSet.set(start + var.getLength());\n-                    });\n+                        gotoSet.set(end);\n+                    }\n@@ -404,1 +421,1 @@\n-        while (bytes.available() > 0) {\n+        for (; bytes.available() > 0;) {\n@@ -406,1 +423,1 @@\n-            \/\/ System.out.println(getOpcodeName(opcode));\n+            \/\/System.out.println(getOpcodeName(opcode));\n@@ -408,21 +425,9 @@\n-            case Const.TABLESWITCH:\n-            case Const.LOOKUPSWITCH:\n-                \/\/ bytes.readByte(); \/\/ Skip already read byte\n-                final int remainder = bytes.getIndex() % 4;\n-                final int noPadBytes = remainder == 0 ? 0 : 4 - remainder;\n-                int defaultOffset;\n-                int offset;\n-                for (int j = 0; j < noPadBytes; j++) {\n-                    bytes.readByte();\n-                }\n-                \/\/ Both cases have a field default_offset in common\n-                defaultOffset = bytes.readInt();\n-                if (opcode == Const.TABLESWITCH) {\n-                    final int low = bytes.readInt();\n-                    final int high = bytes.readInt();\n-                    offset = bytes.getIndex() - 12 - noPadBytes - 1;\n-                    defaultOffset += offset;\n-                    gotoSet.set(defaultOffset);\n-                    for (int j = 0; j < high - low + 1; j++) {\n-                        index = offset + bytes.readInt();\n-                        gotoSet.set(index);\n+                case Const.TABLESWITCH:\n+                case Const.LOOKUPSWITCH:\n+                    \/\/bytes.readByte(); \/\/ Skip already read byte\n+                    final int remainder = bytes.getIndex() % 4;\n+                    final int no_pad_bytes = (remainder == 0) ? 0 : 4 - remainder;\n+                    int default_offset;\n+                    int offset;\n+                    for (int j = 0; j < no_pad_bytes; j++) {\n+                        bytes.readByte();\n@@ -430,6 +435,18 @@\n-                } else { \/\/ LOOKUPSWITCH\n-                    final int npairs = bytes.readInt();\n-                    offset = bytes.getIndex() - 8 - noPadBytes - 1;\n-                    defaultOffset += offset;\n-                    gotoSet.set(defaultOffset);\n-                    for (int j = 0; j < npairs; j++) {\n+                    \/\/ Both cases have a field default_offset in common\n+                    default_offset = bytes.readInt();\n+                    if (opcode == Const.TABLESWITCH) {\n+                        final int low = bytes.readInt();\n+                        final int high = bytes.readInt();\n+                        offset = bytes.getIndex() - 12 - no_pad_bytes - 1;\n+                        default_offset += offset;\n+                        gotoSet.set(default_offset);\n+                        for (int j = 0; j < (high - low + 1); j++) {\n+                            index = offset + bytes.readInt();\n+                            gotoSet.set(index);\n+                        }\n+                    } else { \/\/ LOOKUPSWITCH\n+                        final int npairs = bytes.readInt();\n+                        offset = bytes.getIndex() - 8 - no_pad_bytes - 1;\n+                        default_offset += offset;\n+                        gotoSet.set(default_offset);\n+                        for (int j = 0; j < npairs; j++) {\n@@ -437,3 +454,4 @@\n-                        bytes.readInt();\n-                        index = offset + bytes.readInt();\n-                        gotoSet.set(index);\n+                            bytes.readInt();\n+                            index = offset + bytes.readInt();\n+                            gotoSet.set(index);\n+                        }\n@@ -441,33 +459,32 @@\n-                }\n-                break;\n-            case Const.GOTO:\n-            case Const.IFEQ:\n-            case Const.IFGE:\n-            case Const.IFGT:\n-            case Const.IFLE:\n-            case Const.IFLT:\n-            case Const.IFNE:\n-            case Const.IFNONNULL:\n-            case Const.IFNULL:\n-            case Const.IF_ACMPEQ:\n-            case Const.IF_ACMPNE:\n-            case Const.IF_ICMPEQ:\n-            case Const.IF_ICMPGE:\n-            case Const.IF_ICMPGT:\n-            case Const.IF_ICMPLE:\n-            case Const.IF_ICMPLT:\n-            case Const.IF_ICMPNE:\n-            case Const.JSR:\n-                \/\/ bytes.readByte(); \/\/ Skip already read byte\n-                index = bytes.getIndex() + bytes.readShort() - 1;\n-                gotoSet.set(index);\n-                break;\n-            case Const.GOTO_W:\n-            case Const.JSR_W:\n-                \/\/ bytes.readByte(); \/\/ Skip already read byte\n-                index = bytes.getIndex() + bytes.readInt() - 1;\n-                gotoSet.set(index);\n-                break;\n-            default:\n-                bytes.unreadByte();\n-                codeToHTML(bytes, 0); \/\/ Ignore output\n+                    break;\n+                case Const.GOTO:\n+                case Const.IFEQ:\n+                case Const.IFGE:\n+                case Const.IFGT:\n+                case Const.IFLE:\n+                case Const.IFLT:\n+                case Const.IFNE:\n+                case Const.IFNONNULL:\n+                case Const.IFNULL:\n+                case Const.IF_ACMPEQ:\n+                case Const.IF_ACMPNE:\n+                case Const.IF_ICMPEQ:\n+                case Const.IF_ICMPGE:\n+                case Const.IF_ICMPGT:\n+                case Const.IF_ICMPLE:\n+                case Const.IF_ICMPLT:\n+                case Const.IF_ICMPNE:\n+                case Const.JSR:\n+                    \/\/bytes.readByte(); \/\/ Skip already read byte\n+                    index = bytes.getIndex() + bytes.readShort() - 1;\n+                    gotoSet.set(index);\n+                    break;\n+                case Const.GOTO_W:\n+                case Const.JSR_W:\n+                    \/\/bytes.readByte(); \/\/ Skip already read byte\n+                    index = bytes.getIndex() + bytes.readInt() - 1;\n+                    gotoSet.set(index);\n+                    break;\n+                default:\n+                    bytes.unreadByte();\n+                    codeToHTML(bytes, 0); \/\/ Ignore output\n@@ -478,0 +495,1 @@\n+\n@@ -481,1 +499,1 @@\n-    private void writeMethod(final Method method, final int methodNumber) throws IOException {\n+    private void writeMethod( final Method method, final int method_number ) throws IOException {\n@@ -490,1 +508,1 @@\n-        final String htmlName = Class2HTML.toHTML(name);\n+        final String html_name = Class2HTML.toHTML(name);\n@@ -496,2 +514,4 @@\n-        printWriter.print(\"<P><B><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT>&nbsp;\" + \"<A NAME=method\" + methodNumber + \">\" + Class2HTML.referenceType(type)\n-            + \"<\/A>&nbsp<A HREF=\\\"\" + className + \"_methods.html#method\" + methodNumber + \"\\\" TARGET=Methods>\" + htmlName + \"<\/A>(\");\n+        file.print(\"<P><B><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT>&nbsp;\" + \"<A NAME=method\"\n+                + method_number + \">\" + Class2HTML.referenceType(type) + \"<\/A>&nbsp<A HREF=\\\"\"\n+                + className + \"_methods.html#method\" + method_number + \"\\\" TARGET=Methods>\"\n+                + html_name + \"<\/A>(\");\n@@ -499,1 +519,1 @@\n-            printWriter.print(Class2HTML.referenceType(args[i]));\n+            file.print(Class2HTML.referenceType(args[i]));\n@@ -501,1 +521,1 @@\n-                printWriter.print(\",&nbsp;\");\n+                file.print(\",&nbsp;\");\n@@ -504,1 +524,1 @@\n-        printWriter.println(\")<\/B><\/P>\");\n+        file.println(\")<\/B><\/P>\");\n@@ -508,1 +528,1 @@\n-            printWriter.print(\"<H4>Attributes<\/H4><UL>\\n\");\n+            file.print(\"<H4>Attributes<\/H4><UL>\\n\");\n@@ -512,2 +532,3 @@\n-                    printWriter.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#method\" + methodNumber + \"@\" + i + \"\\\" TARGET=Attributes>\"\n-                        + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n+                    file.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#method\"\n+                            + method_number + \"@\" + i + \"\\\" TARGET=Attributes>\"\n+                            + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n@@ -515,1 +536,1 @@\n-                    printWriter.print(\"<LI>\" + attributes[i] + \"<\/LI>\");\n+                    file.print(\"<LI>\" + attributes[i] + \"<\/LI>\");\n@@ -521,1 +542,1 @@\n-                    printWriter.print(\"<UL>\");\n+                    file.print(\"<UL>\");\n@@ -524,2 +545,3 @@\n-                        printWriter.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#\" + \"method\" + methodNumber + \"@\" + i + \"@\" + j\n-                            + \"\\\" TARGET=Attributes>\" + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n+                        file.print(\"<LI><A HREF=\\\"\" + className + \"_attributes.html#\" + \"method\"\n+                                + method_number + \"@\" + i + \"@\" + j + \"\\\" TARGET=Attributes>\"\n+                                + Const.getAttributeName(tag) + \"<\/A><\/LI>\\n\");\n@@ -527,1 +549,1 @@\n-                    printWriter.print(\"<\/UL>\");\n+                    file.print(\"<\/UL>\");\n@@ -530,1 +552,1 @@\n-            printWriter.println(\"<\/UL>\");\n+            file.println(\"<\/UL>\");\n@@ -533,1 +555,1 @@\n-            \/\/ System.out.println(name + \"\\n\" + Utility.codeToString(code, constantPool, 0, -1));\n+            \/\/System.out.println(name + \"\\n\" + Utility.codeToString(code, constantPool, 0, -1));\n@@ -539,2 +561,3 @@\n-                printWriter.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Byte<BR>offset<\/TH>\" + \"<TH ALIGN=LEFT>Instruction<\/TH><TH ALIGN=LEFT>Argument<\/TH>\");\n-                while (stream.available() > 0) {\n+                file.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Byte<BR>offset<\/TH>\"\n+                        + \"<TH ALIGN=LEFT>Instruction<\/TH><TH ALIGN=LEFT>Argument<\/TH>\");\n+                for (; stream.available() > 0;) {\n@@ -542,1 +565,1 @@\n-                    final String str = codeToHTML(stream, methodNumber);\n+                    final String str = codeToHTML(stream, method_number);\n@@ -545,2 +568,2 @@\n-                     * Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every line is very\n-                     * inefficient!\n+                     * Set an anchor mark if this line is targetted by a goto, jsr, etc. Defining an anchor for every\n+                     * line is very inefficient!\n@@ -549,1 +572,1 @@\n-                        anchor = \"<A NAME=code\" + methodNumber + \"@\" + offset + \"><\/A>\";\n+                        anchor = \"<A NAME=code\" + method_number + \"@\" + offset + \"><\/A>\";\n@@ -553,1 +576,1 @@\n-                        anchor2 = \"<A NAME=code\" + methodNumber + \"@\" + code.length + \">\" + offset + \"<\/A>\";\n+                        anchor2 = \"<A NAME=code\" + method_number + \"@\" + code.length + \">\" + offset + \"<\/A>\";\n@@ -557,1 +580,1 @@\n-                    printWriter.println(\"<TR VALIGN=TOP><TD>\" + anchor2 + \"<\/TD><TD>\" + anchor + str + \"<\/TR>\");\n+                    file.println(\"<TR VALIGN=TOP><TD>\" + anchor2 + \"<\/TD><TD>\" + anchor + str + \"<\/TR>\");\n@@ -561,2 +584,2 @@\n-            printWriter.println(\"<TR><TD> <\/A><\/TD><\/TR>\");\n-            printWriter.println(\"<\/TABLE>\");\n+            file.println(\"<TR><TD> <\/A><\/TD><\/TR>\");\n+            file.println(\"<\/TABLE>\");\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/CodeHTML.java","additions":406,"deletions":383,"binary":false,"changes":789,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n@@ -26,2 +27,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n@@ -43,0 +42,2 @@\n+ *\n+ *\n@@ -49,1 +50,1 @@\n-    private final PrintWriter printWriter; \/\/ file to write to\n+    private final PrintWriter file; \/\/ file to write to\n@@ -54,5 +55,6 @@\n-    ConstantHTML(final String dir, final String className, final String classPackage, final Method[] methods, final ConstantPool constantPool,\n-        final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n-        this.className = className;\n-        this.classPackage = classPackage;\n-        this.constantPool = constantPool;\n+\n+    ConstantHTML(final String dir, final String class_name, final String class_package, final Method[] methods,\n+            final ConstantPool constant_pool) throws IOException {\n+        this.className = class_name;\n+        this.classPackage = class_package;\n+        this.constantPool = constant_pool;\n@@ -60,20 +62,11 @@\n-        this.constants = constantPool.getConstantPool();\n-        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_cp.html\", charset.name())) {\n-            printWriter = newPrintWriter;\n-            constantRef = new String[constants.length];\n-            constantRef[0] = \"&lt;unknown&gt;\";\n-            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-            printWriter.print(charset.name());\n-            printWriter.println(\"\\\"><\/head>\");\n-            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n-            \/\/ Loop through constants, constants[0] is reserved\n-            for (int i = 1; i < constants.length; i++) {\n-                if (i % 2 == 0) {\n-                    printWriter.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n-                } else {\n-                    printWriter.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n-                }\n-                if (constants[i] != null) {\n-                    writeConstant(i);\n-                }\n-                printWriter.print(\"<\/TD><\/TR>\\n\");\n+        constants = constant_pool.getConstantPool();\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_cp.html\"));\n+        constantRef = new String[constants.length];\n+        constantRef[0] = \"&lt;unknown&gt;\";\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+        \/\/ Loop through constants, constants[0] is reserved\n+        for (int i = 1; i < constants.length; i++) {\n+            if (i % 2 == 0) {\n+                file.print(\"<TR BGCOLOR=\\\"#C0C0C0\\\"><TD>\");\n+            } else {\n+                file.print(\"<TR BGCOLOR=\\\"#A0A0A0\\\"><TD>\");\n@@ -81,9 +74,2 @@\n-            printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n-        }\n-    }\n-\n-    private int getMethodNumber(final String str) {\n-        for (int i = 0; i < methods.length; i++) {\n-            final String cmp = methods[i].getName() + methods[i].getSignature();\n-            if (cmp.equals(str)) {\n-                return i;\n+            if (constants[i] != null) {\n+                writeConstant(i);\n@@ -91,0 +77,1 @@\n+            file.print(\"<\/TD><\/TR>\\n\");\n@@ -92,1 +79,2 @@\n-        return -1;\n+        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+        file.close();\n@@ -95,1 +83,2 @@\n-    String referenceConstant(final int index) {\n+\n+    String referenceConstant( final int index ) {\n@@ -99,1 +88,2 @@\n-    private void writeConstant(final int index) {\n+\n+    private void writeConstant( final int index ) {\n@@ -101,2 +91,2 @@\n-        int classIndex;\n-        int nameIndex;\n+        int class_index;\n+        int name_index;\n@@ -105,3 +95,3 @@\n-        printWriter.println(\"<H4> <A NAME=cp\" + index + \">\" + index + \"<\/A> \" + Const.getConstantName(tag) + \"<\/H4>\");\n-        \/*\n-         * For every constant type get the needed parameters and print them appropriately\n+        file.println(\"<H4> <A NAME=cp\" + index + \">\" + index + \"<\/A> \" + Const.getConstantName(tag)\n+                + \"<\/H4>\");\n+        \/* For every constant type get the needed parameters and print them appropiately\n@@ -110,32 +100,13 @@\n-        case Const.CONSTANT_InterfaceMethodref:\n-        case Const.CONSTANT_Methodref:\n-            \/\/ Get class_index and name_and_type_index, depending on type\n-            if (tag == Const.CONSTANT_Methodref) {\n-                final ConstantMethodref c = constantPool.getConstant(index, Const.CONSTANT_Methodref, ConstantMethodref.class);\n-                classIndex = c.getClassIndex();\n-                nameIndex = c.getNameAndTypeIndex();\n-            } else {\n-                final ConstantInterfaceMethodref c1 = constantPool.getConstant(index, Const.CONSTANT_InterfaceMethodref, ConstantInterfaceMethodref.class);\n-                classIndex = c1.getClassIndex();\n-                nameIndex = c1.getNameAndTypeIndex();\n-            }\n-            \/\/ Get method name and its class\n-            final String methodName = constantPool.constantToString(nameIndex, Const.CONSTANT_NameAndType);\n-            final String htmlMethodName = Class2HTML.toHTML(methodName);\n-            \/\/ Partially compacted class name, i.e., \/ -> .\n-            final String methodClass = constantPool.constantToString(classIndex, Const.CONSTANT_Class);\n-            String shortMethodClass = Utility.compactClassName(methodClass); \/\/ I.e., remove java.lang.\n-            shortMethodClass = Utility.compactClassName(shortMethodClass, classPackage + \".\", true); \/\/ Remove class package prefix\n-            \/\/ Get method signature\n-            final ConstantNameAndType c2 = constantPool.getConstant(nameIndex, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-            final String signature = constantPool.constantToString(c2.getSignatureIndex(), Const.CONSTANT_Utf8);\n-            \/\/ Get array of strings containing the argument types\n-            final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n-            \/\/ Get return type string\n-            final String type = Utility.methodSignatureReturnType(signature, false);\n-            final String retType = Class2HTML.referenceType(type);\n-            final StringBuilder buf = new StringBuilder(\"(\");\n-            for (int i = 0; i < args.length; i++) {\n-                buf.append(Class2HTML.referenceType(args[i]));\n-                if (i < args.length - 1) {\n-                    buf.append(\",&nbsp;\");\n+            case Const.CONSTANT_InterfaceMethodref:\n+            case Const.CONSTANT_Methodref:\n+                \/\/ Get class_index and name_and_type_index, depending on type\n+                if (tag == Const.CONSTANT_Methodref) {\n+                    final ConstantMethodref c = (ConstantMethodref) constantPool.getConstant(index,\n+                            Const.CONSTANT_Methodref);\n+                    class_index = c.getClassIndex();\n+                    name_index = c.getNameAndTypeIndex();\n+                } else {\n+                    final ConstantInterfaceMethodref c1 = (ConstantInterfaceMethodref) constantPool\n+                            .getConstant(index, Const.CONSTANT_InterfaceMethodref);\n+                    class_index = c1.getClassIndex();\n+                    name_index = c1.getNameAndTypeIndex();\n@@ -143,58 +114,109 @@\n-            }\n-            buf.append(\")\");\n-            final String argTypes = buf.toString();\n-            if (methodClass.equals(className)) {\n-                ref = \"<A HREF=\\\"\" + className + \"_code.html#method\" + getMethodNumber(methodName + signature) + \"\\\" TARGET=Code>\" + htmlMethodName + \"<\/A>\";\n-            } else {\n-                ref = \"<A HREF=\\\"\" + methodClass + \".html\" + \"\\\" TARGET=_top>\" + shortMethodClass + \"<\/A>.\" + htmlMethodName;\n-            }\n-            constantRef[index] = retType + \"&nbsp;<A HREF=\\\"\" + className + \"_cp.html#cp\" + classIndex + \"\\\" TARGET=Constants>\" + shortMethodClass\n-                + \"<\/A>.<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + htmlMethodName + \"<\/A>&nbsp;\" + argTypes;\n-            printWriter.println(\"<P><TT>\" + retType + \"&nbsp;\" + ref + argTypes + \"&nbsp;<\/TT>\\n<UL>\" + \"<LI><A HREF=\\\"#cp\" + classIndex + \"\\\">Class index(\"\n-                + classIndex + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">NameAndType index(\" + nameIndex + \")<\/A><\/UL>\");\n-            break;\n-        case Const.CONSTANT_Fieldref:\n-            \/\/ Get class_index and name_and_type_index\n-            final ConstantFieldref c3 = constantPool.getConstant(index, Const.CONSTANT_Fieldref, ConstantFieldref.class);\n-            classIndex = c3.getClassIndex();\n-            nameIndex = c3.getNameAndTypeIndex();\n-            \/\/ Get method name and its class (compacted)\n-            final String fieldClass = constantPool.constantToString(classIndex, Const.CONSTANT_Class);\n-            String shortFieldClass = Utility.compactClassName(fieldClass); \/\/ I.e., remove java.lang.\n-            shortFieldClass = Utility.compactClassName(shortFieldClass, classPackage + \".\", true); \/\/ Remove class package prefix\n-            final String fieldName = constantPool.constantToString(nameIndex, Const.CONSTANT_NameAndType);\n-            if (fieldClass.equals(className)) {\n-                ref = \"<A HREF=\\\"\" + fieldClass + \"_methods.html#field\" + fieldName + \"\\\" TARGET=Methods>\" + fieldName + \"<\/A>\";\n-            } else {\n-                ref = \"<A HREF=\\\"\" + fieldClass + \".html\\\" TARGET=_top>\" + shortFieldClass + \"<\/A>.\" + fieldName + \"\\n\";\n-            }\n-            constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + classIndex + \"\\\" TARGET=Constants>\" + shortFieldClass + \"<\/A>.<A HREF=\\\"\"\n-                + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + fieldName + \"<\/A>\";\n-            printWriter.println(\"<P><TT>\" + ref + \"<\/TT><BR>\\n\" + \"<UL>\" + \"<LI><A HREF=\\\"#cp\" + classIndex + \"\\\">Class(\" + classIndex + \")<\/A><BR>\\n\"\n-                + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">NameAndType(\" + nameIndex + \")<\/A><\/UL>\");\n-            break;\n-        case Const.CONSTANT_Class:\n-            final ConstantClass c4 = constantPool.getConstant(index, Const.CONSTANT_Class, ConstantClass.class);\n-            nameIndex = c4.getNameIndex();\n-            final String className2 = constantPool.constantToString(index, tag); \/\/ \/ -> .\n-            String shortClassName = Utility.compactClassName(className2); \/\/ I.e., remove java.lang.\n-            shortClassName = Utility.compactClassName(shortClassName, classPackage + \".\", true); \/\/ Remove class package prefix\n-            ref = \"<A HREF=\\\"\" + className2 + \".html\\\" TARGET=_top>\" + shortClassName + \"<\/A>\";\n-            constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\" + shortClassName + \"<\/A>\";\n-            printWriter.println(\"<P><TT>\" + ref + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">Name index(\" + nameIndex + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.CONSTANT_String:\n-            final ConstantString c5 = constantPool.getConstant(index, Const.CONSTANT_String, ConstantString.class);\n-            nameIndex = c5.getStringIndex();\n-            final String str = Class2HTML.toHTML(constantPool.constantToString(index, tag));\n-            printWriter.println(\"<P><TT>\" + str + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex + \"\\\">Name index(\" + nameIndex + \")<\/A><\/UL>\\n\");\n-            break;\n-        case Const.CONSTANT_NameAndType:\n-            final ConstantNameAndType c6 = constantPool.getConstant(index, Const.CONSTANT_NameAndType, ConstantNameAndType.class);\n-            nameIndex = c6.getNameIndex();\n-            final int signatureIndex = c6.getSignatureIndex();\n-            printWriter.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + nameIndex\n-                + \"\\\">Name index(\" + nameIndex + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + signatureIndex + \"\\\">Signature index(\" + signatureIndex + \")<\/A><\/UL>\\n\");\n-            break;\n-        default:\n-            printWriter.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT>\\n\");\n+                \/\/ Get method name and its class\n+                final String method_name = constantPool.constantToString(name_index,\n+                        Const.CONSTANT_NameAndType);\n+                final String html_method_name = Class2HTML.toHTML(method_name);\n+                \/\/ Partially compacted class name, i.e., \/ -> .\n+                final String method_class = constantPool.constantToString(class_index, Const.CONSTANT_Class);\n+                String short_method_class = Utility.compactClassName(method_class); \/\/ I.e., remove java.lang.\n+                short_method_class = Utility.compactClassName(short_method_class, classPackage\n+                        + \".\", true); \/\/ Remove class package prefix\n+                \/\/ Get method signature\n+                final ConstantNameAndType c2 = (ConstantNameAndType) constantPool.getConstant(\n+                        name_index, Const.CONSTANT_NameAndType);\n+                final String signature = constantPool.constantToString(c2.getSignatureIndex(),\n+                        Const.CONSTANT_Utf8);\n+                \/\/ Get array of strings containing the argument types\n+                final String[] args = Utility.methodSignatureArgumentTypes(signature, false);\n+                \/\/ Get return type string\n+                final String type = Utility.methodSignatureReturnType(signature, false);\n+                final String ret_type = Class2HTML.referenceType(type);\n+                final StringBuilder buf = new StringBuilder(\"(\");\n+                for (int i = 0; i < args.length; i++) {\n+                    buf.append(Class2HTML.referenceType(args[i]));\n+                    if (i < args.length - 1) {\n+                        buf.append(\",&nbsp;\");\n+                    }\n+                }\n+                buf.append(\")\");\n+                final String arg_types = buf.toString();\n+                if (method_class.equals(className)) {\n+                    ref = \"<A HREF=\\\"\" + className + \"_code.html#method\"\n+                            + getMethodNumber(method_name + signature) + \"\\\" TARGET=Code>\"\n+                            + html_method_name + \"<\/A>\";\n+                } else {\n+                    ref = \"<A HREF=\\\"\" + method_class + \".html\" + \"\\\" TARGET=_top>\"\n+                            + short_method_class + \"<\/A>.\" + html_method_name;\n+                }\n+                constantRef[index] = ret_type + \"&nbsp;<A HREF=\\\"\" + className + \"_cp.html#cp\"\n+                        + class_index + \"\\\" TARGET=Constants>\" + short_method_class\n+                        + \"<\/A>.<A HREF=\\\"\" + className + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=ConstantPool>\" + html_method_name + \"<\/A>&nbsp;\" + arg_types;\n+                file.println(\"<P><TT>\" + ret_type + \"&nbsp;\" + ref + arg_types\n+                        + \"&nbsp;<\/TT>\\n<UL>\" + \"<LI><A HREF=\\\"#cp\" + class_index\n+                        + \"\\\">Class index(\" + class_index + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\"\n+                        + name_index + \"\\\">NameAndType index(\" + name_index + \")<\/A><\/UL>\");\n+                break;\n+            case Const.CONSTANT_Fieldref:\n+                \/\/ Get class_index and name_and_type_index\n+                final ConstantFieldref c3 = (ConstantFieldref) constantPool.getConstant(index,\n+                        Const.CONSTANT_Fieldref);\n+                class_index = c3.getClassIndex();\n+                name_index = c3.getNameAndTypeIndex();\n+                \/\/ Get method name and its class (compacted)\n+                final String field_class = constantPool.constantToString(class_index, Const.CONSTANT_Class);\n+                String short_field_class = Utility.compactClassName(field_class); \/\/ I.e., remove java.lang.\n+                short_field_class = Utility.compactClassName(short_field_class,\n+                        classPackage + \".\", true); \/\/ Remove class package prefix\n+                final String field_name = constantPool\n+                        .constantToString(name_index, Const.CONSTANT_NameAndType);\n+                if (field_class.equals(className)) {\n+                    ref = \"<A HREF=\\\"\" + field_class + \"_methods.html#field\" + field_name\n+                            + \"\\\" TARGET=Methods>\" + field_name + \"<\/A>\";\n+                } else {\n+                    ref = \"<A HREF=\\\"\" + field_class + \".html\\\" TARGET=_top>\" + short_field_class\n+                            + \"<\/A>.\" + field_name + \"\\n\";\n+                }\n+                constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + class_index\n+                        + \"\\\" TARGET=Constants>\" + short_field_class + \"<\/A>.<A HREF=\\\"\"\n+                        + className + \"_cp.html#cp\" + index + \"\\\" TARGET=ConstantPool>\"\n+                        + field_name + \"<\/A>\";\n+                file.println(\"<P><TT>\" + ref + \"<\/TT><BR>\\n\" + \"<UL>\" + \"<LI><A HREF=\\\"#cp\"\n+                        + class_index + \"\\\">Class(\" + class_index + \")<\/A><BR>\\n\"\n+                        + \"<LI><A HREF=\\\"#cp\" + name_index + \"\\\">NameAndType(\" + name_index\n+                        + \")<\/A><\/UL>\");\n+                break;\n+            case Const.CONSTANT_Class:\n+                final ConstantClass c4 = (ConstantClass) constantPool.getConstant(index, Const.CONSTANT_Class);\n+                name_index = c4.getNameIndex();\n+                final String class_name2 = constantPool.constantToString(index, tag); \/\/ \/ -> .\n+                String short_class_name = Utility.compactClassName(class_name2); \/\/ I.e., remove java.lang.\n+                short_class_name = Utility.compactClassName(short_class_name, classPackage + \".\",\n+                        true); \/\/ Remove class package prefix\n+                ref = \"<A HREF=\\\"\" + class_name2 + \".html\\\" TARGET=_top>\" + short_class_name\n+                        + \"<\/A>\";\n+                constantRef[index] = \"<A HREF=\\\"\" + className + \"_cp.html#cp\" + index\n+                        + \"\\\" TARGET=ConstantPool>\" + short_class_name + \"<\/A>\";\n+                file.println(\"<P><TT>\" + ref + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index\n+                        + \"\\\">Name index(\" + name_index + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.CONSTANT_String:\n+                final ConstantString c5 = (ConstantString) constantPool.getConstant(index,\n+                        Const.CONSTANT_String);\n+                name_index = c5.getStringIndex();\n+                final String str = Class2HTML.toHTML(constantPool.constantToString(index, tag));\n+                file.println(\"<P><TT>\" + str + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index\n+                        + \"\\\">Name index(\" + name_index + \")<\/A><\/UL>\\n\");\n+                break;\n+            case Const.CONSTANT_NameAndType:\n+                final ConstantNameAndType c6 = (ConstantNameAndType) constantPool.getConstant(index,\n+                        Const.CONSTANT_NameAndType);\n+                name_index = c6.getNameIndex();\n+                final int signature_index = c6.getSignatureIndex();\n+                file.println(\"<P><TT>\"\n+                        + Class2HTML.toHTML(constantPool.constantToString(index, tag))\n+                        + \"<\/TT><UL>\" + \"<LI><A HREF=\\\"#cp\" + name_index + \"\\\">Name index(\"\n+                        + name_index + \")<\/A>\\n\" + \"<LI><A HREF=\\\"#cp\" + signature_index\n+                        + \"\\\">Signature index(\" + signature_index + \")<\/A><\/UL>\\n\");\n+                break;\n+            default:\n+                file.println(\"<P><TT>\" + Class2HTML.toHTML(constantPool.constantToString(index, tag)) + \"<\/TT>\\n\");\n@@ -203,0 +225,11 @@\n+\n+\n+    private int getMethodNumber( final String str ) {\n+        for (int i = 0; i < methods.length; i++) {\n+            final String cmp = methods[i].getName() + methods[i].getSignature();\n+            if (cmp.equals(str)) {\n+                return i;\n+            }\n+        }\n+        return -1;\n+    }\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ConstantHTML.java","additions":169,"deletions":136,"binary":false,"changes":305,"status":"modified"},{"patch":"@@ -23,0 +23,4 @@\n+import com.sun.org.apache.bcel.internal.Const;\n+import com.sun.org.apache.bcel.internal.generic.ClassGenException;\n+import com.sun.org.apache.bcel.internal.generic.InstructionHandle;\n+import com.sun.org.apache.bcel.internal.generic.InstructionList;\n@@ -24,1 +28,0 @@\n-import java.util.Arrays;\n@@ -33,5 +36,0 @@\n-import com.sun.org.apache.bcel.internal.Const;\n-import com.sun.org.apache.bcel.internal.generic.ClassGenException;\n-import com.sun.org.apache.bcel.internal.generic.InstructionHandle;\n-import com.sun.org.apache.bcel.internal.generic.InstructionList;\n-\n@@ -39,3 +37,5 @@\n- * InstructionFinder is a tool to search for given instructions patterns, i.e., match sequences of instructions in an\n- * instruction list via regular expressions. This can be used, e.g., in order to implement a peep hole optimizer that\n- * looks for code patterns and replaces them with faster equivalents.\n+ * InstructionFinder is a tool to search for given instructions patterns, i.e.,\n+ * match sequences of instructions in an instruction list via regular\n+ * expressions. This can be used, e.g., in order to implement a peep hole\n+ * optimizer that looks for code patterns and replaces them with faster\n+ * equivalents.\n@@ -44,1 +44,2 @@\n- * This class internally uses the java.util.regex package to search for regular expressions.\n+ * This class internally uses the java.util.regex\n+ * package to search for regular expressions.\n@@ -70,14 +71,0 @@\n-    \/**\n-     * Code patterns found may be checked using an additional user-defined constraint object whether they really match the\n-     * needed criterion. I.e., check constraints that can not expressed with regular expressions.\n-     *\n-     *\/\n-    public interface CodeConstraint {\n-\n-        \/**\n-         * @param match array of instructions matching the requested pattern\n-         * @return true if the matched area is really useful\n-         *\/\n-        boolean checkCode(InstructionHandle[] match);\n-    }\n-\n@@ -87,153 +74,0 @@\n-\n-    \/\/ Initialize pattern map\n-    static {\n-        map.put(\"arithmeticinstruction\",\n-            \"(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)\");\n-        map.put(\"invokeinstruction\", \"(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)\");\n-        map.put(\"arrayinstruction\",\n-            \"(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)\");\n-        map.put(\"gotoinstruction\", \"(goto|goto_w)\");\n-        map.put(\"conversioninstruction\", \"(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)\");\n-        map.put(\"localvariableinstruction\", \"(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)\");\n-        map.put(\"loadinstruction\", \"(fload|dload|lload|iload|aload)\");\n-        map.put(\"fieldinstruction\", \"(getfield|putstatic|getstatic|putfield)\");\n-        map.put(\"cpinstruction\",\n-            \"(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)\");\n-        map.put(\"stackinstruction\", \"(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)\");\n-        map.put(\"branchinstruction\",\n-            \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n-        map.put(\"returninstruction\", \"(lreturn|ireturn|freturn|dreturn|areturn|return)\");\n-        map.put(\"storeinstruction\", \"(istore|fstore|dstore|astore|lstore)\");\n-        map.put(\"select\", \"(tableswitch|lookupswitch)\");\n-        map.put(\"ifinstruction\",\n-            \"(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)\");\n-        map.put(\"jsrinstruction\", \"(jsr|jsr_w)\");\n-        map.put(\"variablelengthinstruction\", \"(tableswitch|jsr|goto|lookupswitch)\");\n-        map.put(\"unconditionalbranch\", \"(goto|jsr|jsr_w|athrow|goto_w)\");\n-        map.put(\"constantpushinstruction\", \"(dconst|bipush|sipush|fconst|iconst|lconst)\");\n-        map.put(\"typedinstruction\",\n-            \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)\");\n-        map.put(\"popinstruction\", \"(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)\");\n-        map.put(\"allocationinstruction\", \"(multianewarray|new|anewarray|newarray)\");\n-        map.put(\"indexedinstruction\",\n-            \"(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)\");\n-        map.put(\"pushinstruction\", \"(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)\");\n-        map.put(\"stackproducer\",\n-            \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)\");\n-        map.put(\"stackconsumer\",\n-            \"(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)\");\n-        map.put(\"exceptionthrower\",\n-            \"(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)\");\n-        map.put(\"loadclass\",\n-            \"(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)\");\n-        map.put(\"instructiontargeter\",\n-            \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n-        \/\/ Some aliases\n-        map.put(\"if_icmp\", \"(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)\");\n-        map.put(\"if_acmp\", \"(if_acmpeq|if_acmpne)\");\n-        map.put(\"if\", \"(ifeq|ifne|iflt|ifge|ifgt|ifle)\");\n-        \/\/ Precompile some aliases first\n-        map.put(\"iconst\", precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));\n-        map.put(\"lconst\", new String(new char[] {'(', makeChar(Const.LCONST_0), '|', makeChar(Const.LCONST_1), ')'}));\n-        map.put(\"dconst\", new String(new char[] {'(', makeChar(Const.DCONST_0), '|', makeChar(Const.DCONST_1), ')'}));\n-        map.put(\"fconst\", new String(new char[] {'(', makeChar(Const.FCONST_0), '|', makeChar(Const.FCONST_1), '|', makeChar(Const.FCONST_2), ')'}));\n-        map.put(\"lload\", precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));\n-        map.put(\"iload\", precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));\n-        map.put(\"dload\", precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));\n-        map.put(\"fload\", precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));\n-        map.put(\"aload\", precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));\n-        map.put(\"lstore\", precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));\n-        map.put(\"istore\", precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));\n-        map.put(\"dstore\", precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));\n-        map.put(\"fstore\", precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));\n-        map.put(\"astore\", precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));\n-        \/\/ Compile strings\n-        map.forEach((key, value) -> {\n-            final char ch = value.charAt(1); \/\/ Omit already precompiled patterns\n-            if (ch < OFFSET) {\n-                map.put(key, compilePattern(value)); \/\/ precompile all patterns\n-            }\n-        });\n-        \/\/ Add instruction alias to match anything\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = 0; i < NO_OPCODES; i++) {\n-            if (Const.getNoOfOperands(i) != Const.UNDEFINED) { \/\/ Not an invalid opcode\n-                buf.append(makeChar(i));\n-                if (i < NO_OPCODES - 1) {\n-                    buf.append('|');\n-                }\n-            }\n-        }\n-        buf.append(')');\n-        map.put(\"instruction\", buf.toString());\n-    }\n-\n-    \/**\n-     * Replace symbolic names of instructions with the appropriate character and remove all white space from string. Meta\n-     * characters such as +, * are ignored.\n-     *\n-     * @param pattern The pattern to compile\n-     * @return translated regular expression string\n-     *\/\n-    private static String compilePattern(final String pattern) {\n-        \/\/ Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues\n-        final String lower = pattern.toLowerCase(Locale.ENGLISH);\n-        final StringBuilder buf = new StringBuilder();\n-        final int size = pattern.length();\n-        for (int i = 0; i < size; i++) {\n-            char ch = lower.charAt(i);\n-            if (Character.isLetterOrDigit(ch)) {\n-                final StringBuilder name = new StringBuilder();\n-                while ((Character.isLetterOrDigit(ch) || ch == '_') && i < size) {\n-                    name.append(ch);\n-                    if (++i >= size) {\n-                        break;\n-                    }\n-                    ch = lower.charAt(i);\n-                }\n-                i--;\n-                buf.append(mapName(name.toString()));\n-            } else if (!Character.isWhitespace(ch)) {\n-                buf.append(ch);\n-            }\n-        }\n-        return buf.toString();\n-    }\n-\n-    \/**\n-     * Convert opcode number to char.\n-     *\/\n-    private static char makeChar(final short opcode) {\n-        return (char) (opcode + OFFSET);\n-    }\n-\n-    \/**\n-     * Map symbolic instruction names like \"getfield\" to a single character.\n-     *\n-     * @param pattern instruction pattern in lower case\n-     * @return encoded string for a pattern such as \"BranchInstruction\".\n-     *\/\n-    private static String mapName(final String pattern) {\n-        final String result = map.get(pattern);\n-        if (result != null) {\n-            return result;\n-        }\n-        for (short i = 0; i < NO_OPCODES; i++) {\n-            if (pattern.equals(Const.getOpcodeName(i))) {\n-                return String.valueOf(makeChar(i));\n-            }\n-        }\n-        throw new IllegalArgumentException(\"Instruction unknown: \" + pattern);\n-    }\n-\n-    private static String precompile(final short from, final short to, final short extra) {\n-        final StringBuilder buf = new StringBuilder(\"(\");\n-        for (short i = from; i <= to; i++) {\n-            buf.append(makeChar(i));\n-            buf.append('|');\n-        }\n-        buf.append(makeChar(extra));\n-        buf.append(\")\");\n-        return buf.toString();\n-    }\n-\n@@ -241,1 +75,0 @@\n-\n@@ -243,1 +76,0 @@\n-\n@@ -246,0 +78,1 @@\n+\n@@ -248,1 +81,2 @@\n-     * @param il instruction list to search for given patterns\n+     * @param il\n+     *          instruction list to search for given patterns\n@@ -255,13 +89,0 @@\n-    \/**\n-     * @return the inquired instruction list\n-     *\/\n-    public final InstructionList getInstructionList() {\n-        return il;\n-    }\n-\n-    \/**\n-     * @return the matched piece of code as an array of instruction (handles)\n-     *\/\n-    private InstructionHandle[] getMatch(final int matchedFrom, final int matchLength) {\n-        return Arrays.copyOfRange(handles, matchedFrom, matchedFrom + matchLength);\n-    }\n@@ -270,1 +91,2 @@\n-     * Reread the instruction list, e.g., after you've altered the list upon a match.\n+     * Reread the instruction list, e.g., after you've altered the list upon a\n+     * match.\n@@ -283,0 +105,1 @@\n+\n@@ -284,1 +107,1 @@\n-     * Start search beginning from the start of the given instruction list.\n+     * Map symbolic instruction names like \"getfield\" to a single character.\n@@ -286,2 +109,3 @@\n-     * @param pattern the instruction pattern to search for, where case is ignored\n-     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     * @param pattern\n+     *          instruction pattern in lower case\n+     * @return encoded string for a pattern such as \"BranchInstruction\".\n@@ -289,2 +113,11 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern) {\n-        return search(pattern, il.getStart(), null);\n+    private static String mapName( final String pattern ) {\n+        final String result = map.get(pattern);\n+        if (result != null) {\n+            return result;\n+        }\n+        for (short i = 0; i < NO_OPCODES; i++) {\n+            if (pattern.equals(Const.getOpcodeName(i))) {\n+                return \"\" + makeChar(i);\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Instruction unknown: \" + pattern);\n@@ -293,0 +126,1 @@\n+\n@@ -294,1 +128,3 @@\n-     * Start search beginning from the start of the given instruction list. Check found matches with the constraint object.\n+     * Replace symbolic names of instructions with the appropiate character and\n+     * remove all white space from string. Meta characters such as +, * are\n+     * ignored.\n@@ -296,3 +132,3 @@\n-     * @param pattern the instruction pattern to search for, case is ignored\n-     * @param constraint constraints to be checked on matching code\n-     * @return instruction handle or 'null' if the match failed\n+     * @param pattern\n+     *          The pattern to compile\n+     * @return translated regular expression string\n@@ -300,2 +136,24 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern, final CodeConstraint constraint) {\n-        return search(pattern, il.getStart(), constraint);\n+    private static String compilePattern( final String pattern ) {\n+        \/\/Bug: BCEL-77 - Instructions are assumed to be english, to avoid odd Locale issues\n+        final String lower = pattern.toLowerCase(Locale.ENGLISH);\n+        final StringBuilder buf = new StringBuilder();\n+        final int size = pattern.length();\n+        for (int i = 0; i < size; i++) {\n+            char ch = lower.charAt(i);\n+            if (Character.isLetterOrDigit(ch)) {\n+                final StringBuilder name = new StringBuilder();\n+                while ((Character.isLetterOrDigit(ch) || ch == '_') && i < size) {\n+                    name.append(ch);\n+                    if (++i < size) {\n+                        ch = lower.charAt(i);\n+                    } else {\n+                        break;\n+                    }\n+                }\n+                i--;\n+                buf.append(mapName(name.toString()));\n+            } else if (!Character.isWhitespace(ch)) {\n+                buf.append(ch);\n+            }\n+        }\n+        return buf.toString();\n@@ -304,0 +162,1 @@\n+\n@@ -305,5 +164,1 @@\n-     * Start search beginning from 'from'.\n-     *\n-     * @param pattern the instruction pattern to search for, where case is ignored\n-     * @param from where to start the search in the instruction list\n-     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     * @return the matched piece of code as an array of instruction (handles)\n@@ -311,2 +166,4 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from) {\n-        return search(pattern, from, null);\n+    private InstructionHandle[] getMatch( final int matched_from, final int match_length ) {\n+        final InstructionHandle[] match = new InstructionHandle[match_length];\n+        System.arraycopy(handles, matched_from, match, 0, match_length);\n+        return match;\n@@ -315,0 +172,1 @@\n+\n@@ -316,4 +174,6 @@\n-     * Search for the given pattern in the instruction list. You can search for any valid opcode via its symbolic name, e.g.\n-     * \"istore\". You can also use a super class or an interface name to match a whole set of instructions, e.g.\n-     * \"BranchInstruction\" or \"LoadInstruction\". \"istore\" is also an alias for all \"istore_x\" instructions. Additional\n-     * aliases are \"if\" for \"ifxx\", \"if_icmp\" for \"if_icmpxx\", \"if_acmp\" for \"if_acmpxx\".\n+     * Search for the given pattern in the instruction list. You can search for\n+     * any valid opcode via its symbolic name, e.g. \"istore\". You can also use a\n+     * super class or an interface name to match a whole set of instructions, e.g.\n+     * \"BranchInstruction\" or \"LoadInstruction\". \"istore\" is also an alias for all\n+     * \"istore_x\" instructions. Additional aliases are \"if\" for \"ifxx\", \"if_icmp\"\n+     * for \"if_icmpxx\", \"if_acmp\" for \"if_acmpxx\".\n@@ -321,2 +181,2 @@\n-     * Consecutive instruction names must be separated by white space which will be removed during the compilation of the\n-     * pattern.\n+     * Consecutive instruction names must be separated by white space which will\n+     * be removed during the compilation of the pattern.\n@@ -324,1 +184,2 @@\n-     * For the rest the usual pattern matching rules for regular expressions apply.\n+     * For the rest the usual pattern matching rules for regular expressions\n+     * apply.\n@@ -333,2 +194,3 @@\n-     * If you alter the instruction list upon a match such that other matching areas are affected, you should call reread()\n-     * to update the finder and call search() again, because the matches are cached.\n+     * If you alter the instruction list upon a match such that other matching\n+     * areas are affected, you should call reread() to update the finder and call\n+     * search() again, because the matches are cached.\n@@ -336,4 +198,9 @@\n-     * @param pattern the instruction pattern to search for, where case is ignored\n-     * @param from where to start the search in the instruction list\n-     * @param constraint optional CodeConstraint to check the found code pattern for user-defined constraints\n-     * @return iterator of matches where e.nextElement() returns an array of instruction handles describing the matched area\n+     * @param pattern\n+     *          the instruction pattern to search for, where case is ignored\n+     * @param from\n+     *          where to start the search in the instruction list\n+     * @param constraint\n+     *          optional CodeConstraint to check the found code pattern for\n+     *          user-defined constraints\n+     * @return iterator of matches where e.nextElement() returns an array of\n+     *         instruction handles describing the matched area\n@@ -341,1 +208,2 @@\n-    public final Iterator<InstructionHandle[]> search(final String pattern, final InstructionHandle from, final CodeConstraint constraint) {\n+    public final Iterator<InstructionHandle[]> search( final String pattern,\n+            final InstructionHandle from, final CodeConstraint constraint ) {\n@@ -351,1 +219,2 @@\n-            throw new ClassGenException(\"Instruction handle \" + from + \" not found in instruction list.\");\n+            throw new ClassGenException(\"Instruction handle \" + from\n+                    + \" not found in instruction list.\");\n@@ -361,1 +230,1 @@\n-            if (constraint == null || constraint.checkCode(match)) {\n+            if ((constraint == null) || constraint.checkCode(match)) {\n@@ -369,0 +238,163 @@\n+\n+    \/**\n+     * Start search beginning from the start of the given instruction list.\n+     *\n+     * @param pattern\n+     *          the instruction pattern to search for, where case is ignored\n+     * @return iterator of matches where e.nextElement() returns an array of\n+     *         instruction handles describing the matched area\n+     *\/\n+    public final Iterator<InstructionHandle[]> search( final String pattern ) {\n+        return search(pattern, il.getStart(), null);\n+    }\n+\n+\n+    \/**\n+     * Start search beginning from `from'.\n+     *\n+     * @param pattern\n+     *          the instruction pattern to search for, where case is ignored\n+     * @param from\n+     *          where to start the search in the instruction list\n+     * @return iterator of matches where e.nextElement() returns an array of\n+     *         instruction handles describing the matched area\n+     *\/\n+    public final Iterator<InstructionHandle[]> search( final String pattern,\n+            final InstructionHandle from ) {\n+        return search(pattern, from, null);\n+    }\n+\n+\n+    \/**\n+     * Start search beginning from the start of the given instruction list. Check\n+     * found matches with the constraint object.\n+     *\n+     * @param pattern\n+     *          the instruction pattern to search for, case is ignored\n+     * @param constraint\n+     *          constraints to be checked on matching code\n+     * @return instruction handle or `null' if the match failed\n+     *\/\n+    public final Iterator<InstructionHandle[]> search( final String pattern,\n+            final CodeConstraint constraint ) {\n+        return search(pattern, il.getStart(), constraint);\n+    }\n+\n+\n+    \/**\n+     * Convert opcode number to char.\n+     *\/\n+    private static char makeChar( final short opcode ) {\n+        return (char) (opcode + OFFSET);\n+    }\n+\n+\n+    \/**\n+     * @return the inquired instruction list\n+     *\/\n+    public final InstructionList getInstructionList() {\n+        return il;\n+    }\n+\n+    \/**\n+     * Code patterns found may be checked using an additional user-defined\n+     * constraint object whether they really match the needed criterion. I.e.,\n+     * check constraints that can not expressed with regular expressions.\n+     *\n+     *\/\n+    public interface CodeConstraint {\n+\n+        \/**\n+         * @param match\n+         *          array of instructions matching the requested pattern\n+         * @return true if the matched area is really useful\n+         *\/\n+        boolean checkCode( InstructionHandle[] match );\n+    }\n+\n+    \/\/ Initialize pattern map\n+    static {\n+        map.put(\"arithmeticinstruction\",\"(irem|lrem|iand|ior|ineg|isub|lneg|fneg|fmul|ldiv|fadd|lxor|frem|idiv|land|ixor|ishr|fsub|lshl|fdiv|iadd|lor|dmul|lsub|ishl|imul|lmul|lushr|dneg|iushr|lshr|ddiv|drem|dadd|ladd|dsub)\");\n+        map.put(\"invokeinstruction\", \"(invokevirtual|invokeinterface|invokestatic|invokespecial|invokedynamic)\");\n+        map.put(\"arrayinstruction\", \"(baload|aastore|saload|caload|fastore|lastore|iaload|castore|iastore|aaload|bastore|sastore|faload|laload|daload|dastore)\");\n+        map.put(\"gotoinstruction\", \"(goto|goto_w)\");\n+        map.put(\"conversioninstruction\", \"(d2l|l2d|i2s|d2i|l2i|i2b|l2f|d2f|f2i|i2d|i2l|f2d|i2c|f2l|i2f)\");\n+        map.put(\"localvariableinstruction\",\"(fstore|iinc|lload|dstore|dload|iload|aload|astore|istore|fload|lstore)\");\n+        map.put(\"loadinstruction\", \"(fload|dload|lload|iload|aload)\");\n+        map.put(\"fieldinstruction\", \"(getfield|putstatic|getstatic|putfield)\");\n+        map.put(\"cpinstruction\", \"(ldc2_w|invokeinterface|invokedynamic|multianewarray|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|ldc_w|invokestatic|invokevirtual|putfield|ldc|new|anewarray)\");\n+        map.put(\"stackinstruction\", \"(dup2|swap|dup2_x2|pop|pop2|dup|dup2_x1|dup_x2|dup_x1)\");\n+        map.put(\"branchinstruction\", \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n+        map.put(\"returninstruction\", \"(lreturn|ireturn|freturn|dreturn|areturn|return)\");\n+        map.put(\"storeinstruction\", \"(istore|fstore|dstore|astore|lstore)\");\n+        map.put(\"select\", \"(tableswitch|lookupswitch)\");\n+        map.put(\"ifinstruction\", \"(ifeq|ifgt|if_icmpne|if_icmpeq|ifge|ifnull|ifne|if_icmple|if_icmpge|if_acmpeq|if_icmplt|if_acmpne|ifnonnull|iflt|if_icmpgt|ifle)\");\n+        map.put(\"jsrinstruction\", \"(jsr|jsr_w)\");\n+        map.put(\"variablelengthinstruction\", \"(tableswitch|jsr|goto|lookupswitch)\");\n+        map.put(\"unconditionalbranch\", \"(goto|jsr|jsr_w|athrow|goto_w)\");\n+        map.put(\"constantpushinstruction\", \"(dconst|bipush|sipush|fconst|iconst|lconst)\");\n+        map.put(\"typedinstruction\", \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dastore|ret|f2d|f2i|drem|iinc|i2c|checkcast|frem|lreturn|astore|lushr|daload|dneg|fastore|istore|lshl|ldiv|lstore|areturn|ishr|ldc_w|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|faload|sipush|iushr|caload|instanceof|invokespecial|putfield|fmul|ireturn|laload|d2f|lneg|ixor|i2l|fdiv|lastore|multianewarray|i2b|getstatic|i2d|putstatic|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|freturn|ldc|aconst_null|castore|lmul|ldc2_w|dadd|iconst|f2l|ddiv|dstore|land|jsr|anewarray|dmul|bipush|dsub|sastore|d2i|i2s|lshr|iadd|l2i|lload|bastore|fstore|fneg|iload|fadd|baload|fconst|ior|ineg|dreturn|l2f|lconst|getfield|invokevirtual|invokestatic|iastore)\");\n+        map.put(\"popinstruction\", \"(fstore|dstore|pop|pop2|astore|putstatic|istore|lstore)\");\n+        map.put(\"allocationinstruction\", \"(multianewarray|new|anewarray|newarray)\");\n+        map.put(\"indexedinstruction\", \"(lload|lstore|fload|ldc2_w|invokeinterface|invokedynamic|multianewarray|astore|dload|putstatic|instanceof|getstatic|checkcast|getfield|invokespecial|dstore|istore|iinc|ldc_w|ret|fstore|invokestatic|iload|putfield|invokevirtual|ldc|new|aload|anewarray)\");\n+        map.put(\"pushinstruction\", \"(dup|lload|dup2|bipush|fload|ldc2_w|sipush|lconst|fconst|dload|getstatic|ldc_w|aconst_null|dconst|iload|ldc|iconst|aload)\");\n+        map.put(\"stackproducer\", \"(imul|lsub|aload|fload|lor|new|aaload|fcmpg|iand|iaload|lrem|idiv|d2l|isub|dcmpg|dup|f2d|f2i|drem|i2c|checkcast|frem|lushr|daload|dneg|lshl|ldiv|ishr|ldc_w|invokeinterface|invokedynamic|lxor|ishl|l2d|i2f|faload|sipush|iushr|caload|instanceof|invokespecial|fmul|laload|d2f|lneg|ixor|i2l|fdiv|getstatic|i2b|swap|i2d|dup2|fcmpl|saload|ladd|irem|dload|jsr_w|dconst|dcmpl|fsub|ldc|arraylength|aconst_null|tableswitch|lmul|ldc2_w|iconst|dadd|f2l|ddiv|land|jsr|anewarray|dmul|bipush|dsub|d2i|newarray|i2s|lshr|iadd|lload|l2i|fneg|iload|fadd|baload|fconst|lookupswitch|ior|ineg|lconst|l2f|getfield|invokevirtual|invokestatic)\");\n+        map.put(\"stackconsumer\", \"(imul|lsub|lor|iflt|fcmpg|if_icmpgt|iand|ifeq|if_icmplt|lrem|ifnonnull|idiv|d2l|isub|dcmpg|dastore|if_icmpeq|f2d|f2i|drem|i2c|checkcast|frem|lreturn|astore|lushr|pop2|monitorexit|dneg|fastore|istore|lshl|ldiv|lstore|areturn|if_icmpge|ishr|monitorenter|invokeinterface|invokedynamic|aastore|lxor|ishl|l2d|i2f|return|iushr|instanceof|invokespecial|fmul|ireturn|d2f|lneg|ixor|pop|i2l|ifnull|fdiv|lastore|i2b|if_acmpeq|ifge|swap|i2d|putstatic|fcmpl|ladd|irem|dcmpl|fsub|freturn|ifgt|castore|lmul|dadd|f2l|ddiv|dstore|land|if_icmpne|if_acmpne|dmul|dsub|sastore|ifle|d2i|i2s|lshr|iadd|l2i|bastore|fstore|fneg|fadd|ior|ineg|ifne|dreturn|l2f|if_icmple|getfield|invokevirtual|invokestatic|iastore)\");\n+        map.put(\"exceptionthrower\",\"(irem|lrem|laload|putstatic|baload|dastore|areturn|getstatic|ldiv|anewarray|iastore|castore|idiv|saload|lastore|fastore|putfield|lreturn|caload|getfield|return|aastore|freturn|newarray|instanceof|multianewarray|athrow|faload|iaload|aaload|dreturn|monitorenter|checkcast|bastore|arraylength|new|invokevirtual|sastore|ldc_w|ireturn|invokespecial|monitorexit|invokeinterface|invokedynamic|ldc|invokestatic|daload)\");\n+        map.put(\"loadclass\", \"(multianewarray|invokeinterface|invokedynamic|instanceof|invokespecial|putfield|checkcast|putstatic|invokevirtual|new|getstatic|invokestatic|getfield|anewarray)\");\n+        map.put(\"instructiontargeter\", \"(ifle|if_acmpne|if_icmpeq|if_acmpeq|ifnonnull|goto_w|iflt|ifnull|if_icmpne|tableswitch|if_icmple|ifeq|if_icmplt|jsr_w|if_icmpgt|ifgt|jsr|goto|ifne|ifge|lookupswitch|if_icmpge)\");\n+        \/\/ Some aliases\n+        map.put(\"if_icmp\", \"(if_icmpne|if_icmpeq|if_icmple|if_icmpge|if_icmplt|if_icmpgt)\");\n+        map.put(\"if_acmp\", \"(if_acmpeq|if_acmpne)\");\n+        map.put(\"if\", \"(ifeq|ifne|iflt|ifge|ifgt|ifle)\");\n+        \/\/ Precompile some aliases first\n+        map.put(\"iconst\", precompile(Const.ICONST_0, Const.ICONST_5, Const.ICONST_M1));\n+        map.put(\"lconst\", new String(new char[] { '(', makeChar(Const.LCONST_0), '|', makeChar(Const.LCONST_1), ')' }));\n+        map.put(\"dconst\", new String(new char[] { '(', makeChar(Const.DCONST_0), '|', makeChar(Const.DCONST_1), ')' }));\n+        map.put(\"fconst\", new String(new char[] { '(', makeChar(Const.FCONST_0), '|', makeChar(Const.FCONST_1), '|', makeChar(Const.FCONST_2), ')' }));\n+        map.put(\"lload\", precompile(Const.LLOAD_0, Const.LLOAD_3, Const.LLOAD));\n+        map.put(\"iload\", precompile(Const.ILOAD_0, Const.ILOAD_3, Const.ILOAD));\n+        map.put(\"dload\", precompile(Const.DLOAD_0, Const.DLOAD_3, Const.DLOAD));\n+        map.put(\"fload\", precompile(Const.FLOAD_0, Const.FLOAD_3, Const.FLOAD));\n+        map.put(\"aload\", precompile(Const.ALOAD_0, Const.ALOAD_3, Const.ALOAD));\n+        map.put(\"lstore\", precompile(Const.LSTORE_0, Const.LSTORE_3, Const.LSTORE));\n+        map.put(\"istore\", precompile(Const.ISTORE_0, Const.ISTORE_3, Const.ISTORE));\n+        map.put(\"dstore\", precompile(Const.DSTORE_0, Const.DSTORE_3, Const.DSTORE));\n+        map.put(\"fstore\", precompile(Const.FSTORE_0, Const.FSTORE_3, Const.FSTORE));\n+        map.put(\"astore\", precompile(Const.ASTORE_0, Const.ASTORE_3, Const.ASTORE));\n+        \/\/ Compile strings\n+        for (final Map.Entry<String, String> entry : map.entrySet()) {\n+            final String key = entry.getKey();\n+            final String value = entry.getValue();\n+            final char ch = value.charAt(1); \/\/ Omit already precompiled patterns\n+            if (ch < OFFSET) {\n+                map.put(key, compilePattern(value)); \/\/ precompile all patterns\n+            }\n+        }\n+        \/\/ Add instruction alias to match anything\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        for (short i = 0; i < NO_OPCODES; i++) {\n+            if (Const.getNoOfOperands(i) != Const.UNDEFINED) { \/\/ Not an invalid opcode\n+                buf.append(makeChar(i));\n+                if (i < NO_OPCODES - 1) {\n+                    buf.append('|');\n+                }\n+            }\n+        }\n+        buf.append(')');\n+        map.put(\"instruction\", buf.toString());\n+    }\n+\n+\n+    private static String precompile( final short from, final short to, final short extra ) {\n+        final StringBuilder buf = new StringBuilder(\"(\");\n+        for (short i = from; i <= to; i++) {\n+            buf.append(makeChar(i));\n+            buf.append('|');\n+        }\n+        buf.append(makeChar(extra));\n+        buf.append(\")\");\n+        return buf.toString();\n+    }\n+\n+\n@@ -376,0 +408,1 @@\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/InstructionFinder.java","additions":261,"deletions":228,"binary":false,"changes":489,"status":"modified"},{"patch":"@@ -24,1 +24,2 @@\n-import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n@@ -26,2 +27,0 @@\n-import java.io.UnsupportedEncodingException;\n-import java.nio.charset.Charset;\n@@ -32,0 +31,1 @@\n+import com.sun.org.apache.bcel.internal.classfile.ConstantValue;\n@@ -39,0 +39,2 @@\n+ *\n+ *\n@@ -43,1 +45,1 @@\n-    private final PrintWriter printWriter; \/\/ file to write to\n+    private final PrintWriter file; \/\/ file to write to\n@@ -45,1 +47,1 @@\n-    private final AttributeHTML attributeHtml;\n+    private final AttributeHTML attribute_html;\n@@ -47,22 +49,19 @@\n-    MethodHTML(final String dir, final String className, final Method[] methods, final Field[] fields, final ConstantHTML constantHtml,\n-        final AttributeHTML attributeHtml, final Charset charset) throws FileNotFoundException, UnsupportedEncodingException {\n-        this.className = className;\n-        this.attributeHtml = attributeHtml;\n-        this.constantHtml = constantHtml;\n-        try (PrintWriter newPrintWriter = new PrintWriter(dir + className + \"_methods.html\", charset.name())) {\n-            printWriter = newPrintWriter;\n-            printWriter.print(\"<HTML><head><meta charset=\\\"\");\n-            printWriter.print(charset.name());\n-            printWriter.println(\"\\\"><\/head>\");\n-            printWriter.println(\"<BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n-            printWriter.println(\"<TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH><TH ALIGN=LEFT>Type<\/TH>\" + \"<TH ALIGN=LEFT>Field&nbsp;name<\/TH><\/TR>\");\n-            for (final Field field : fields) {\n-                writeField(field);\n-            }\n-            printWriter.println(\"<\/TABLE>\");\n-            printWriter.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH>\"\n-                + \"<TH ALIGN=LEFT>Return&nbsp;type<\/TH><TH ALIGN=LEFT>Method&nbsp;name<\/TH>\" + \"<TH ALIGN=LEFT>Arguments<\/TH><\/TR>\");\n-            for (int i = 0; i < methods.length; i++) {\n-                writeMethod(methods[i], i);\n-            }\n-            printWriter.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+\n+    MethodHTML(final String dir, final String class_name, final Method[] methods, final Field[] fields,\n+            final ConstantHTML constant_html, final AttributeHTML attribute_html) throws IOException {\n+        this.className = class_name;\n+        this.attribute_html = attribute_html;\n+        this.constantHtml = constant_html;\n+        file = new PrintWriter(new FileOutputStream(dir + class_name + \"_methods.html\"));\n+        file.println(\"<HTML><BODY BGCOLOR=\\\"#C0C0C0\\\"><TABLE BORDER=0>\");\n+        file.println(\"<TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH><TH ALIGN=LEFT>Type<\/TH>\"\n+                + \"<TH ALIGN=LEFT>Field&nbsp;name<\/TH><\/TR>\");\n+        for (final Field field : fields) {\n+            writeField(field);\n+        }\n+        file.println(\"<\/TABLE>\");\n+        file.println(\"<TABLE BORDER=0><TR><TH ALIGN=LEFT>Access&nbsp;flags<\/TH>\"\n+                + \"<TH ALIGN=LEFT>Return&nbsp;type<\/TH><TH ALIGN=LEFT>Method&nbsp;name<\/TH>\"\n+                + \"<TH ALIGN=LEFT>Arguments<\/TH><\/TR>\");\n+        for (int i = 0; i < methods.length; i++) {\n+            writeMethod(methods[i], i);\n@@ -70,0 +69,2 @@\n+        file.println(\"<\/TABLE><\/BODY><\/HTML>\");\n+        file.close();\n@@ -72,0 +73,1 @@\n+\n@@ -76,0 +78,1 @@\n+     * @throws java.io.IOException\n@@ -77,1 +80,1 @@\n-    private void writeField(final Field field) {\n+    private void writeField( final Field field ) throws IOException {\n@@ -83,2 +86,3 @@\n-        printWriter.print(\"<TR><TD><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT><\/TD>\\n<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD><A NAME=\\\"field\"\n-            + name + \"\\\">\" + name + \"<\/A><\/TD>\");\n+        file.print(\"<TR><TD><FONT COLOR=\\\"#FF0000\\\">\" + access + \"<\/FONT><\/TD>\\n<TD>\"\n+                + Class2HTML.referenceType(type) + \"<\/TD><TD><A NAME=\\\"field\" + name + \"\\\">\" + name\n+                + \"<\/A><\/TD>\");\n@@ -88,1 +92,1 @@\n-            attributeHtml.writeAttribute(attributes[i], name + \"@\" + i);\n+            attribute_html.writeAttribute(attributes[i], name + \"@\" + i);\n@@ -92,1 +96,1 @@\n-                final String str = attributes[i].toString();\n+                final String str = ((ConstantValue) attributes[i]).toString();\n@@ -94,1 +98,2 @@\n-                printWriter.print(\"<TD>= <A HREF=\\\"\" + className + \"_attributes.html#\" + name + \"@\" + i + \"\\\" TARGET=\\\"Attributes\\\">\" + str + \"<\/TD>\\n\");\n+                file.print(\"<TD>= <A HREF=\\\"\" + className + \"_attributes.html#\" + name + \"@\" + i\n+                        + \"\\\" TARGET=\\\"Attributes\\\">\" + str + \"<\/TD>\\n\");\n@@ -98,1 +103,1 @@\n-        printWriter.println(\"<\/TR>\");\n+        file.println(\"<\/TR>\");\n@@ -101,1 +106,2 @@\n-    private void writeMethod(final Method method, final int methodNumber) {\n+\n+    private void writeMethod( final Method method, final int method_number ) {\n@@ -110,1 +116,1 @@\n-        String htmlName;\n+        String html_name;\n@@ -115,2 +121,2 @@\n-        \/*\n-         * HTML doesn't like names like <clinit> and spaces are places to break lines. Both we don't want...\n+        \/* HTML doesn't like names like <clinit> and spaces are places to break\n+         * lines. Both we don't want...\n@@ -119,4 +125,6 @@\n-        htmlName = Class2HTML.toHTML(name);\n-        printWriter.print(\"<TR VALIGN=TOP><TD><FONT COLOR=\\\"#FF0000\\\"><A NAME=method\" + methodNumber + \">\" + access + \"<\/A><\/FONT><\/TD>\");\n-        printWriter.print(\"<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD>\" + \"<A HREF=\" + className + \"_code.html#method\" + methodNumber + \" TARGET=Code>\"\n-            + htmlName + \"<\/A><\/TD>\\n<TD>(\");\n+        html_name = Class2HTML.toHTML(name);\n+        file.print(\"<TR VALIGN=TOP><TD><FONT COLOR=\\\"#FF0000\\\"><A NAME=method\" + method_number\n+                + \">\" + access + \"<\/A><\/FONT><\/TD>\");\n+        file.print(\"<TD>\" + Class2HTML.referenceType(type) + \"<\/TD><TD>\" + \"<A HREF=\" + className\n+                + \"_code.html#method\" + method_number + \" TARGET=Code>\" + html_name\n+                + \"<\/A><\/TD>\\n<TD>(\");\n@@ -124,1 +132,1 @@\n-            printWriter.print(Class2HTML.referenceType(args[i]));\n+            file.print(Class2HTML.referenceType(args[i]));\n@@ -126,1 +134,1 @@\n-                printWriter.print(\", \");\n+                file.print(\", \");\n@@ -129,1 +137,1 @@\n-        printWriter.print(\")<\/TD><\/TR>\");\n+        file.print(\")<\/TD><\/TR>\");\n@@ -132,1 +140,2 @@\n-            attributeHtml.writeAttribute(attributes[i], \"method\" + methodNumber + \"@\" + i, methodNumber);\n+            attribute_html.writeAttribute(attributes[i], \"method\" + method_number + \"@\" + i,\n+                    method_number);\n@@ -135,1 +144,1 @@\n-                printWriter.print(\"<TR VALIGN=TOP><TD COLSPAN=2><\/TD><TH ALIGN=LEFT>throws<\/TH><TD>\");\n+                file.print(\"<TR VALIGN=TOP><TD COLSPAN=2><\/TD><TH ALIGN=LEFT>throws<\/TH><TD>\");\n@@ -138,1 +147,1 @@\n-                    printWriter.print(constantHtml.referenceConstant(exceptions[j]));\n+                    file.print(constantHtml.referenceConstant(exceptions[j]));\n@@ -140,1 +149,1 @@\n-                        printWriter.print(\", \");\n+                        file.print(\", \");\n@@ -143,1 +152,1 @@\n-                printWriter.println(\"<\/TD><\/TR>\");\n+                file.println(\"<\/TD><\/TR>\");\n@@ -145,3 +154,4 @@\n-                final Attribute[] attributeArray = ((Code) attributes[i]).getAttributes();\n-                for (int j = 0; j < attributeArray.length; j++) {\n-                    attributeHtml.writeAttribute(attributeArray[j], \"method\" + methodNumber + \"@\" + i + \"@\" + j, methodNumber);\n+                final Attribute[] c_a = ((Code) attributes[i]).getAttributes();\n+                for (int j = 0; j < c_a.length; j++) {\n+                    attribute_html.writeAttribute(c_a[j], \"method\" + method_number + \"@\" + i + \"@\"\n+                            + j, method_number);\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/MethodHTML.java","additions":63,"deletions":53,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+import java.util.Iterator;\n@@ -56,0 +57,3 @@\n+     *\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -57,2 +61,1 @@\n-    @SuppressWarnings(\"resource\") \/\/ See #close()\n-    public ModularRuntimeImage() {\n+    public ModularRuntimeImage() throws IOException {\n@@ -65,1 +68,2 @@\n-     * @param javaHome Path to a Java 9 or greater home.\n+     * @param javaHome\n+     *            Path to a Java 9 or greater home.\n@@ -67,1 +71,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -73,1 +78,1 @@\n-        this.classLoader = URLClassLoader.newInstance(new URL[] {jrtFsPath.toUri().toURL()});\n+        this.classLoader = new URLClassLoader(new URL[] {jrtFsPath.toUri().toURL() });\n@@ -92,4 +97,0 @@\n-    public FileSystem getFileSystem() {\n-        return fileSystem;\n-    }\n-\n@@ -99,1 +100,2 @@\n-     * @param dirPath directory path.\n+     * @param dirPath\n+     *            directory path.\n@@ -101,1 +103,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -106,1 +109,4 @@\n-            ds.forEach(list::add);\n+            final Iterator<Path> iterator = ds.iterator();\n+            while (iterator.hasNext()) {\n+                list.add(iterator.next());\n+            }\n@@ -114,1 +120,2 @@\n-     * @param dirName directory path.\n+     * @param dirName\n+     *            directory path.\n@@ -116,1 +123,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -126,1 +134,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -136,1 +145,2 @@\n-     * @throws IOException an I\/O error occurs accessing the file system\n+     * @throws IOException\n+     *             an I\/O error occurs accessing the file system\n@@ -142,0 +152,4 @@\n+    public FileSystem getFileSystem() {\n+        return fileSystem;\n+    }\n+\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/ModularRuntimeImage.java","additions":30,"deletions":16,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,2 +25,3 @@\n- * Abstract definition of a class repository. Instances may be used to load classes from different sources and may be\n- * used in the Repository.setRepository method.\n+ * Abstract definition of a class repository. Instances may be used\n+ * to load classes from different sources and may be used in the\n+ * Repository.setRepository method.\n@@ -28,2 +29,2 @@\n- * @see org.apache.bcel.Repository\n- * @LastModified: Feb 2023\n+ * @see com.sun.org.apache.bcel.internal.Repository\n+ * @LastModified: Jan 2020\n@@ -34,1 +35,1 @@\n-     * Clears all entries from cache.\n+     * Stores the provided class under \"clazz.getClassName()\"\n@@ -36,1 +37,1 @@\n-    void clear();\n+    void storeClass(JavaClass clazz);\n@@ -39,1 +40,1 @@\n-     * Finds the class with the name provided, if the class isn't there, return NULL.\n+     * Removes class from repository\n@@ -41,1 +42,1 @@\n-    JavaClass findClass(String className);\n+    void removeClass(JavaClass clazz);\n@@ -44,3 +45,1 @@\n-     * Finds the JavaClass instance for the given run-time class object.\n-     *\n-     * @throws ClassNotFoundException if the class can't be found.\n+     * Finds the class with the name provided, if the class isn't there, return NULL.\n@@ -48,1 +47,1 @@\n-    JavaClass loadClass(Class<?> clazz) throws ClassNotFoundException;\n+    JavaClass findClass(String className);\n@@ -52,2 +51,0 @@\n-     *\n-     * @throws ClassNotFoundException if the class can't be found.\n@@ -55,1 +52,1 @@\n-    JavaClass loadClass(String className) throws ClassNotFoundException;\n+    JavaClass loadClass(String className) throws java.lang.ClassNotFoundException;\n@@ -58,1 +55,1 @@\n-     * Removes class from repository\n+     * Finds the JavaClass instance for the given run-time class object\n@@ -60,1 +57,1 @@\n-    void removeClass(JavaClass clazz);\n+    JavaClass loadClass(Class<?> clazz) throws java.lang.ClassNotFoundException;\n@@ -63,1 +60,1 @@\n-     * Stores the provided class under \"clazz.getClassName()\"\n+     * Clears all entries from cache.\n@@ -65,1 +62,1 @@\n-    void storeClass(JavaClass clazz);\n+    void clear();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/Repository.java","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import com.sun.org.apache.bcel.internal.classfile.Utility;\n@@ -33,7 +32,7 @@\n- * This repository is used in situations where a Class is created outside the realm of a ClassLoader. Classes are loaded\n- * from the file systems using the paths specified in the given class path. By default, this is the value returned by\n- * ClassPath.getClassPath().\n- * <p>\n- * This repository uses a factory design, allowing it to maintain a collection of different classpaths, and as such It\n- * is designed to be used as a singleton per classpath.\n- * <\/p>\n+ * This repository is used in situations where a Class is created outside the\n+ * realm of a ClassLoader. Classes are loaded from the file systems using the\n+ * paths specified in the given class path. By default, this is the value\n+ * returned by ClassPath.getClassPath(). <br>\n+ * This repository uses a factory design, allowing it to maintain a collection\n+ * of different classpaths, and as such It is designed to be used as a singleton\n+ * per classpath.\n@@ -43,1 +42,1 @@\n- * @LastModified: Feb 2023\n+ * @LastModified: May 2021\n@@ -58,1 +57,1 @@\n-     * Clear all entries from cache.\n+     * Store a new JavaClass instance into this Repository.\n@@ -61,2 +60,11 @@\n-    public void clear() {\n-        loadedClasses.clear();\n+    public void storeClass(final JavaClass clazz) {\n+        loadedClasses.put(clazz.getClassName(), new SoftReference<>(clazz));\n+        clazz.setRepository(this);\n+        }\n+\n+    \/**\n+     * Remove class from repository\n+     *\/\n+    @Override\n+    public void removeClass(final JavaClass clazz) {\n+        loadedClasses.remove(clazz.getClassName());\n@@ -71,1 +79,4 @@\n-        return ref == null ? null : ref.get();\n+        if (ref == null) {\n+            return null;\n+}\n+        return ref.get();\n@@ -75,1 +86,6 @@\n-     * Remove class from repository\n+     * Finds a JavaClass object by name. If it is already in this Repository, the\n+     * Repository version is returned.\n+     *\n+     * @param className the name of the class\n+     * @return the JavaClass object\n+     * @throws ClassNotFoundException if the class is not in the Repository\n@@ -78,2 +94,3 @@\n-    public void removeClass(final JavaClass clazz) {\n-        loadedClasses.remove(clazz.getClassName());\n+    public JavaClass loadClass(String className) throws ClassNotFoundException {\n+        if ((className == null) || className.isEmpty()) {\n+            throw new IllegalArgumentException(\"Invalid class name \" + className);\n@@ -81,0 +98,5 @@\n+        className = className.replace('\/', '.'); \/\/ Just in case, canonical form\n+        final JavaClass clazz = findClass(className);\n+        if (clazz != null) {\n+            return clazz;\n+        }\n@@ -82,8 +104,3 @@\n-    \/**\n-     * Store a new JavaClass instance into this Repository.\n-     *\/\n-    @Override\n-    public void storeClass(final JavaClass clazz) {\n-        \/\/ Not calling super.storeClass because this subclass maintains the mapping.\n-        loadedClasses.put(clazz.getClassName(), new SoftReference<>(clazz));\n-        clazz.setRepository(this);\n+        IOException e = new IOException(\"Couldn't find: \" + className + \".class\");\n+        throw new ClassNotFoundException(\"Exception while looking for class \" +\n+                className + \": \" + e, e);\n@@ -93,3 +110,5 @@\n-     * Finds the JavaClass object for a runtime Class object. If a class with the same name is already in this Repository,\n-     * the Repository version is returned. Otherwise, getResourceAsStream() is called on the Class object to find the\n-     * class's representation. If the representation is found, it is added to the Repository.\n+     * Find the JavaClass object for a runtime Class object. If a class with the\n+     * same name is already in this Repository, the Repository version is\n+     * returned. Otherwise, getResourceAsStream() is called on the Class object\n+     * to find the class's representation. If the representation is found, it is\n+     * added to the Repository.\n@@ -100,1 +119,2 @@\n-     * @throws ClassNotFoundException if the class is not in the Repository, and its representation could not be found\n+     * @throws ClassNotFoundException if the class is not in the Repository, and\n+     * its representation could not be found\n@@ -108,1 +128,1 @@\n-        }\n+    }\n@@ -114,3 +134,3 @@\n-\n-        try (InputStream clsStream = clazz.getResourceAsStream(name + JavaClass.EXTENSION)) {\n-            return loadClass(clsStream, className);\n+        JavaClass cls = null;\n+        try (InputStream clsStream = clazz.getResourceAsStream(name + \".class\")) {\n+            return cls = loadClass(clsStream, className);\n@@ -118,1 +138,1 @@\n-            return null;\n+            return cls;\n@@ -120,0 +140,1 @@\n+\n@@ -122,1 +143,3 @@\n-    private JavaClass loadClass(final InputStream inputStream, final String className) throws ClassNotFoundException {\n+\n+    private JavaClass loadClass(final InputStream is, final String className)\n+            throws ClassNotFoundException {\n@@ -124,2 +147,2 @@\n-            if (inputStream != null) {\n-                final ClassParser parser = new ClassParser(inputStream, className);\n+            if (is != null) {\n+                final ClassParser parser = new ClassParser(is, className);\n@@ -131,1 +154,10 @@\n-            throw new ClassNotFoundException(\"Exception while looking for class \" + className + \": \" + e, e);\n+            throw new ClassNotFoundException(\"Exception while looking for class \"\n+                    + className + \": \" + e, e);\n+        } finally {\n+            if (is != null) {\n+                try {\n+                    is.close();\n+                } catch (final IOException e) {\n+                    \/\/ ignored\n+                }\n+            }\n@@ -133,1 +165,2 @@\n-        throw new ClassNotFoundException(\"ClassRepository could not load \" + className);\n+        throw new ClassNotFoundException(\"SyntheticRepository could not load \"\n+                + className);\n@@ -137,6 +170,1 @@\n-     * Finds a JavaClass object by name. If it is already in this Repository, the Repository version is returned. Otherwise,\n-     * the Repository's classpath is searched for the class (and it is added to the Repository if found).\n-     *\n-     * @param className the name of the class\n-     * @return the JavaClass object\n-     * @throws ClassNotFoundException if the class is not in the Repository, and could not be found on the classpath\n+     * Clear all entries from cache.\n@@ -145,12 +173,2 @@\n-    public JavaClass loadClass(String className) throws ClassNotFoundException {\n-        if (className == null || className.isEmpty()) {\n-            throw new IllegalArgumentException(\"Invalid class name \" + className);\n-        }\n-        className = Utility.pathToPackage(className); \/\/ Just in case, canonical form\n-        final JavaClass clazz = findClass(className);\n-        if (clazz != null) {\n-            return clazz;\n-        }\n-        IOException e = new IOException(\"Couldn't find: \" + className + \".class\");\n-        throw new ClassNotFoundException(\"Exception while looking for class \" +\n-                className + \": \" + e, e);\n+    public void clear() {\n+        loadedClasses.clear();\n","filename":"src\/java.xml\/share\/classes\/com\/sun\/org\/apache\/bcel\/internal\/util\/SyntheticRepository.java","additions":75,"deletions":57,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -1,57 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.xml.internal;\n-\n-import java.util.Arrays;\n-\n-\/**\n- * General utility. Use JdkXmlUtils for XML processing related functions.\n- *\/\n-public class Utils {\n-    \/**\n-     * Creates a new array with copies of the original array and additional items\n-     * appended to the end of it.\n-     *\n-     * @param original the original array\n-     * @param items items to be appended to the original array\n-     * @return a new array with copies of the original array and additional items\n-     *\/\n-    public static Class<?>[] arraysAppend(final Class<?>[] original, final Class<?>... items) {\n-        if (original == null && items == null) {\n-            return null;\n-        }\n-        if (items == null) {\n-            return Arrays.copyOf(original, original.length);\n-        }\n-        if (original == null) {\n-            return Arrays.copyOf(items, items.length);\n-        }\n-\n-        Class<?>[] result = Arrays.copyOf(original, original.length + items.length);\n-        System.arraycopy(items, 0, result, original.length, items.length);\n-        return result;\n-    }\n-}\n","filename":"src\/java.xml\/share\/classes\/jdk\/xml\/internal\/Utils.java","additions":0,"deletions":57,"binary":false,"changes":57,"status":"deleted"},{"patch":"@@ -1,1 +1,1 @@\n-## Apache Commons Byte Code Engineering Library (BCEL) Version 6.7.0\n+## Apache Commons Byte Code Engineering Library (BCEL) Version 6.5.0\n@@ -7,1 +7,1 @@\n-    Copyright 2004-2022 The Apache Software Foundation\n+    Copyright 2004-2020 The Apache Software Foundation\n","filename":"src\/java.xml\/share\/legal\/bcel.md","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -124,3 +124,0 @@\n-      if (vptrAddress == null) {\n-        return false;\n-      }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/memory\/FileMapInfo.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1631,2 +1631,1 @@\n-                || lower.startsWith(\"file:\")\n-                || lower.startsWith(\"ftp:\"))) {\n+                || lower.startsWith(\"file:\"))) {\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlDocletWriter.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-ui.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n@@ -23,1 +23,1 @@\n-var version = $.ui.version = \"1.13.2\";\n+var version = $.ui.version = \"1.13.1\";\n@@ -27,1 +27,1 @@\n- * jQuery UI Widget 1.13.2\n+ * jQuery UI Widget 1.13.1\n@@ -769,1 +769,1 @@\n- * jQuery UI Position 1.13.2\n+ * jQuery UI Position 1.13.1\n@@ -1266,1 +1266,1 @@\n- * jQuery UI Keycode 1.13.2\n+ * jQuery UI Keycode 1.13.1\n@@ -1301,1 +1301,1 @@\n- * jQuery UI Unique ID 1.13.2\n+ * jQuery UI Unique ID 1.13.1\n@@ -1369,1 +1369,1 @@\n- * jQuery UI Menu 1.13.2\n+ * jQuery UI Menu 1.13.1\n@@ -1388,1 +1388,1 @@\n-\tversion: \"1.13.2\",\n+\tversion: \"1.13.1\",\n@@ -2060,1 +2060,1 @@\n- * jQuery UI Autocomplete 1.13.2\n+ * jQuery UI Autocomplete 1.13.1\n@@ -2079,1 +2079,1 @@\n-\tversion: \"1.13.2\",\n+\tversion: \"1.13.1\",\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-ui.js","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-ui.min.css","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-\/*! jQuery UI - v1.13.2 - 2023-02-27\n+\/*! jQuery UI - v1.13.1 - 2022-05-12\n@@ -6,1 +6,1 @@\n-!function(t){\"use strict\";\"function\"==typeof define&&define.amd?define([\"jquery\"],t):t(jQuery)}(function(x){\"use strict\";x.ui=x.ui||{};x.ui.version=\"1.13.2\";var n,i=0,l=Array.prototype.hasOwnProperty,a=Array.prototype.slice;x.cleanData=(n=x.cleanData,function(t){for(var e,i,s=0;null!=(i=t[s]);s++)(e=x._data(i,\"events\"))&&e.remove&&x(i).triggerHandler(\"remove\");n(t)}),x.widget=function(t,i,e){var s,n,o,l={},a=t.split(\".\")[0],r=a+\"-\"+(t=t.split(\".\")[1]);return e||(e=i,i=x.Widget),Array.isArray(e)&&(e=x.extend.apply(null,[{}].concat(e))),x.expr.pseudos[r.toLowerCase()]=function(t){return!!x.data(t,r)},x[a]=x[a]||{},s=x[a][t],n=x[a][t]=function(t,e){if(!this||!this._createWidget)return new n(t,e);arguments.length&&this._createWidget(t,e)},x.extend(n,s,{version:e.version,_proto:x.extend({},e),_childConstructors:[]}),(o=new i).options=x.widget.extend({},o.options),x.each(e,function(e,s){function n(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}l[e]=\"function\"==typeof s?function(){var t,e=this._super,i=this._superApply;return this._super=n,this._superApply=o,t=s.apply(this,arguments),this._super=e,this._superApply=i,t}:s}),n.prototype=x.widget.extend(o,{widgetEventPrefix:s&&o.widgetEventPrefix||t},l,{constructor:n,namespace:a,widgetName:t,widgetFullName:r}),s?(x.each(s._childConstructors,function(t,e){var i=e.prototype;x.widget(i.namespace+\".\"+i.widgetName,n,e._proto)}),delete s._childConstructors):i._childConstructors.push(n),x.widget.bridge(t,n),n},x.widget.extend=function(t){for(var e,i,s=a.call(arguments,1),n=0,o=s.length;n<o;n++)for(e in s[n])i=s[n][e],l.call(s[n],e)&&void 0!==i&&(x.isPlainObject(i)?t[e]=x.isPlainObject(t[e])?x.widget.extend({},t[e],i):x.widget.extend({},i):t[e]=i);return t},x.widget.bridge=function(o,e){var l=e.prototype.widgetFullName||o;x.fn[o]=function(i){var t=\"string\"==typeof i,s=a.call(arguments,1),n=this;return t?this.length||\"instance\"!==i?this.each(function(){var t,e=x.data(this,l);return\"instance\"===i?(n=e,!1):e?\"function\"!=typeof e[i]||\"_\"===i.charAt(0)?x.error(\"no such method '\"+i+\"' for \"+o+\" widget instance\"):(t=e[i].apply(e,s))!==e&&void 0!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!1):void 0:x.error(\"cannot call methods on \"+o+\" prior to initialization; attempted to call method '\"+i+\"'\")}):n=void 0:(s.length&&(i=x.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=x.data(this,l);t?(t.option(i||{}),t._init&&t._init()):x.data(this,l,new e(i,this))})),n}},x.Widget=function(){},x.Widget._childConstructors=[],x.Widget.prototype={widgetName:\"widget\",widgetEventPrefix:\"\",defaultElement:\"<div>\",options:{classes:{},disabled:!1,create:null},_createWidget:function(t,e){e=x(e||this.defaultElement||this)[0],this.element=x(e),this.uuid=i++,this.eventNamespace=\".\"+this.widgetName+this.uuid,this.bindings=x(),this.hoverable=x(),this.focusable=x(),this.classesElementLookup={},e!==this&&(x.data(e,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===e&&this.destroy()}}),this.document=x(e.style?e.ownerDocument:e.document||e),this.window=x(this.document[0].defaultView||this.document[0].parentWindow)),this.options=x.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger(\"create\",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:x.noop,_create:x.noop,_init:x.noop,destroy:function(){var i=this;this._destroy(),x.each(this.classesElementLookup,function(t,e){i._removeClass(e,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr(\"aria-disabled\"),this.bindings.off(this.eventNamespace)},_destroy:x.noop,widget:function(){return this.element},option:function(t,e){var i,s,n,o=t;if(0===arguments.length)return x.widget.extend({},this.options);if(\"string\"==typeof t)if(o={},t=(i=t.split(\".\")).shift(),i.length){for(s=o[t]=x.widget.extend({},this.options[t]),n=0;n<i.length-1;n++)s[i[n]]=s[i[n]]||{},s=s[i[n]];if(t=i.pop(),1===arguments.length)return void 0===s[t]?null:s[t];s[t]=e}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=e}return this._setOptions(o),this},_setOptions:function(t){for(var e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return\"classes\"===t&&this._setOptionClasses(e),this.options[t]=e,\"disabled\"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(t){var e,i,s;for(e in t)s=this.classesElementLookup[e],t[e]!==this.options.classes[e]&&s&&s.length&&(i=x(s.get()),this._removeClass(s,e),i.addClass(this._classes({element:i,keys:e,classes:t,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+\"-disabled\",null,!!t),t&&(this._removeClass(this.hoverable,null,\"ui-state-hover\"),this._removeClass(this.focusable,null,\"ui-state-focus\"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(n){var o=[],l=this;function t(t,e){for(var i,s=0;s<t.length;s++)i=l.classesElementLookup[t[s]]||x(),i=n.add?(function(){var i=[];n.element.each(function(t,e){x.map(l.classesElementLookup,function(t){return t}).some(function(t){return t.is(e)})||i.push(e)}),l._on(x(i),{remove:\"_untrackClassesElement\"})}(),x(x.uniqueSort(i.get().concat(n.element.get())))):x(i.not(n.element).get()),l.classesElementLookup[t[s]]=i,o.push(t[s]),e&&n.classes[t[s]]&&o.push(n.classes[t[s]])}return(n=x.extend({element:this.element,classes:this.options.classes||{}},n)).keys&&t(n.keys.match(\/\\S+\/g)||[],!0),n.extra&&t(n.extra.match(\/\\S+\/g)||[]),o.join(\" \")},_untrackClassesElement:function(i){var s=this;x.each(s.classesElementLookup,function(t,e){-1!==x.inArray(i.target,e)&&(s.classesElementLookup[t]=x(e.not(i.target).get()))}),this._off(x(i.target))},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){var n=\"string\"==typeof t||null===t,i={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s=\"boolean\"==typeof s?s:i};return i.element.toggleClass(this._classes(i),s),this},_on:function(n,o,t){var l,a=this;\"boolean\"!=typeof n&&(t=o,o=n,n=!1),t?(o=l=x(o),this.bindings=this.bindings.add(o)):(t=o,o=this.element,l=this.widget()),x.each(t,function(t,e){function i(){if(n||!0!==a.options.disabled&&!x(this).hasClass(\"ui-state-disabled\"))return(\"string\"==typeof e?a[e]:e).apply(a,arguments)}\"string\"!=typeof e&&(i.guid=e.guid=e.guid||i.guid||x.guid++);var s=t.match(\/^([\\w:-]*)\\s*(.*)$\/),t=s[1]+a.eventNamespace,s=s[2];s?l.on(t,s,i):o.on(t,i)})},_off:function(t,e){e=(e||\"\").split(\" \").join(this.eventNamespace+\" \")+this.eventNamespace,t.off(e),this.bindings=x(this.bindings.not(t).get()),this.focusable=x(this.focusable.not(t).get()),this.hoverable=x(this.hoverable.not(t).get())},_delay:function(t,e){var i=this;return setTimeout(function(){return(\"string\"==typeof t?i[t]:t).apply(i,arguments)},e||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-hover\")},mouseleave:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-hover\")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-focus\")},focusout:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-focus\")}})},_trigger:function(t,e,i){var s,n,o=this.options[t];if(i=i||{},(e=x.Event(e)).type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),e.target=this.element[0],n=e.originalEvent)for(s in n)s in e||(e[s]=n[s]);return this.element.trigger(e,i),!(\"function\"==typeof o&&!1===o.apply(this.element[0],[e].concat(i))||e.isDefaultPrevented())}},x.each({show:\"fadeIn\",hide:\"fadeOut\"},function(o,l){x.Widget.prototype[\"_\"+o]=function(e,t,i){var s,n=(t=\"string\"==typeof t?{effect:t}:t)?!0!==t&&\"number\"!=typeof t&&t.effect||l:o;\"number\"==typeof(t=t||{})?t={duration:t}:!0===t&&(t={}),s=!x.isEmptyObject(t),t.complete=i,t.delay&&e.delay(t.delay),s&&x.effects&&x.effects.effect[n]?e[o](t):n!==o&&e[n]?e[n](t.duration,t.easing,i):e.queue(function(t){x(this)[o](),i&&i.call(e[0]),t()})}});var s,C,E,o,r,u,h,c,k;x.widget;function T(t,e,i){return[parseFloat(t[0])*(c.test(t[0])?e\/100:1),parseFloat(t[1])*(c.test(t[1])?i\/100:1)]}function A(t,e){return parseInt(x.css(t,e),10)||0}function W(t){return null!=t&&t===t.window}C=Math.max,E=Math.abs,o=\/left|center|right\/,r=\/top|center|bottom\/,u=\/[\\+\\-]\\d+(\\.[\\d]+)?%?\/,h=\/^\\w+\/,c=\/%$\/,k=x.fn.position,x.position={scrollbarWidth:function(){if(void 0!==s)return s;var t,e=x(\"<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'><\/div><\/div>\"),i=e.children()[0];return x(\"body\").append(e),t=i.offsetWidth,e.css(\"overflow\",\"scroll\"),t===(i=i.offsetWidth)&&(i=e[0].clientWidth),e.remove(),s=t-i},getScrollInfo:function(t){var e=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-x\"),i=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-y\"),e=\"scroll\"===e||\"auto\"===e&&t.width<t.element[0].scrollWidth;return{width:\"scroll\"===i||\"auto\"===i&&t.height<t.element[0].scrollHeight?x.position.scrollbarWidth():0,height:e?x.position.scrollbarWidth():0}},getWithinInfo:function(t){var e=x(t||window),i=W(e[0]),s=!!e[0]&&9===e[0].nodeType;return{element:e,isWindow:i,isDocument:s,offset:!i&&!s?x(t).offset():{left:0,top:0},scrollLeft:e.scrollLeft(),scrollTop:e.scrollTop(),width:e.outerWidth(),height:e.outerHeight()}}},x.fn.position=function(c){if(!c||!c.of)return k.apply(this,arguments);var d,f,m,p,v,t,g=\"string\"==typeof(c=x.extend({},c)).of?x(document).find(c.of):x(c.of),_=x.position.getWithinInfo(c.within),y=x.position.getScrollInfo(_),b=(c.collision||\"flip\").split(\" \"),w={},e=9===(t=(e=g)[0]).nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:W(t)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:t.preventDefault?{width:0,height:0,offset:{top:t.pageY,left:t.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()};return g[0].preventDefault&&(c.at=\"left top\"),f=e.width,m=e.height,v=x.extend({},p=e.offset),x.each([\"my\",\"at\"],function(){var t,e,i=(c[this]||\"\").split(\" \");(i=1===i.length?o.test(i[0])?i.concat([\"center\"]):r.test(i[0])?[\"center\"].concat(i):[\"center\",\"center\"]:i)[0]=o.test(i[0])?i[0]:\"center\",i[1]=r.test(i[1])?i[1]:\"center\",t=u.exec(i[0]),e=u.exec(i[1]),w[this]=[t?t[0]:0,e?e[0]:0],c[this]=[h.exec(i[0])[0],h.exec(i[1])[0]]}),1===b.length&&(b[1]=b[0]),\"right\"===c.at[0]?v.left+=f:\"center\"===c.at[0]&&(v.left+=f\/2),\"bottom\"===c.at[1]?v.top+=m:\"center\"===c.at[1]&&(v.top+=m\/2),d=T(w.at,f,m),v.left+=d[0],v.top+=d[1],this.each(function(){var i,t,l=x(this),a=l.outerWidth(),r=l.outerHeight(),e=A(this,\"marginLeft\"),s=A(this,\"marginTop\"),n=a+e+A(this,\"marginRight\")+y.width,o=r+s+A(this,\"marginBottom\")+y.height,u=x.extend({},v),h=T(w.my,l.outerWidth(),l.outerHeight());\"right\"===c.my[0]?u.left-=a:\"center\"===c.my[0]&&(u.left-=a\/2),\"bottom\"===c.my[1]?u.top-=r:\"center\"===c.my[1]&&(u.top-=r\/2),u.left+=h[0],u.top+=h[1],i={marginLeft:e,marginTop:s},x.each([\"left\",\"top\"],function(t,e){x.ui.position[b[t]]&&x.ui.position[b[t]][e](u,{targetWidth:f,targetHeight:m,elemWidth:a,elemHeight:r,collisionPosition:i,collisionWidth:n,collisionHeight:o,offset:[d[0]+h[0],d[1]+h[1]],my:c.my,at:c.at,within:_,elem:l})}),c.using&&(t=function(t){var e=p.left-u.left,i=e+f-a,s=p.top-u.top,n=s+m-r,o={target:{element:g,left:p.left,top:p.top,width:f,height:m},element:{element:l,left:u.left,top:u.top,width:a,height:r},horizontal:i<0?\"left\":0<e?\"right\":\"center\",vertical:n<0?\"top\":0<s?\"bottom\":\"middle\"};f<a&&E(e+i)<f&&(o.horizontal=\"center\"),m<r&&E(s+n)<m&&(o.vertical=\"middle\"),C(E(e),E(i))>C(E(s),E(n))?o.important=\"horizontal\":o.important=\"vertical\",c.using.call(this,t,o)}),l.offset(x.extend(u,{using:t}))})},x.ui.position={fit:{left:function(t,e){var i=e.within,s=i.isWindow?i.scrollLeft:i.offset.left,n=i.width,o=t.left-e.collisionPosition.marginLeft,l=s-o,a=o+e.collisionWidth-n-s;e.collisionWidth>n?0<l&&a<=0?(i=t.left+l+e.collisionWidth-n-s,t.left+=l-i):t.left=!(0<a&&l<=0)&&a<l?s+n-e.collisionWidth:s:0<l?t.left+=l:0<a?t.left-=a:t.left=C(t.left-o,t.left)},top:function(t,e){var i=e.within,s=i.isWindow?i.scrollTop:i.offset.top,n=e.within.height,o=t.top-e.collisionPosition.marginTop,l=s-o,a=o+e.collisionHeight-n-s;e.collisionHeight>n?0<l&&a<=0?(i=t.top+l+e.collisionHeight-n-s,t.top+=l-i):t.top=!(0<a&&l<=0)&&a<l?s+n-e.collisionHeight:s:0<l?t.top+=l:0<a?t.top-=a:t.top=C(t.top-o,t.top)}},flip:{left:function(t,e){var i=e.within,s=i.offset.left+i.scrollLeft,n=i.width,o=i.isWindow?i.scrollLeft:i.offset.left,l=t.left-e.collisionPosition.marginLeft,a=l-o,r=l+e.collisionWidth-n-o,u=\"left\"===e.my[0]?-e.elemWidth:\"right\"===e.my[0]?e.elemWidth:0,i=\"left\"===e.at[0]?e.targetWidth:\"right\"===e.at[0]?-e.targetWidth:0,l=-2*e.offset[0];a<0?((s=t.left+u+i+l+e.collisionWidth-n-s)<0||s<E(a))&&(t.left+=u+i+l):0<r&&(0<(o=t.left-e.collisionPosition.marginLeft+u+i+l-o)||E(o)<r)&&(t.left+=u+i+l)},top:function(t,e){var i=e.within,s=i.offset.top+i.scrollTop,n=i.height,o=i.isWindow?i.scrollTop:i.offset.top,l=t.top-e.collisionPosition.marginTop,a=l-o,r=l+e.collisionHeight-n-o,u=\"top\"===e.my[1]?-e.elemHeight:\"bottom\"===e.my[1]?e.elemHeight:0,i=\"top\"===e.at[1]?e.targetHeight:\"bottom\"===e.at[1]?-e.targetHeight:0,l=-2*e.offset[1];a<0?((s=t.top+u+i+l+e.collisionHeight-n-s)<0||s<E(a))&&(t.top+=u+i+l):0<r&&(0<(o=t.top-e.collisionPosition.marginTop+u+i+l-o)||E(o)<r)&&(t.top+=u+i+l)}},flipfit:{left:function(){x.ui.position.flip.left.apply(this,arguments),x.ui.position.fit.left.apply(this,arguments)},top:function(){x.ui.position.flip.top.apply(this,arguments),x.ui.position.fit.top.apply(this,arguments)}}};var t;x.ui.position,x.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},x.fn.extend({uniqueId:(t=0,function(){return this.each(function(){this.id||(this.id=\"ui-id-\"+ ++t)})}),removeUniqueId:function(){return this.each(function(){\/^ui-id-\\d+$\/.test(this.id)&&x(this).removeAttr(\"id\")})}}),x.ui.safeActiveElement=function(e){var i;try{i=e.activeElement}catch(t){i=e.body}return i=!(i=i||e.body).nodeName?e.body:i},x.widget(\"ui.menu\",{version:\"1.13.2\",defaultElement:\"<ul>\",delay:300,options:{icons:{submenu:\"ui-icon-caret-1-e\"},items:\"> *\",menus:\"ul\",position:{my:\"left top\",at:\"right top\"},role:\"menu\",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.lastMousePosition={x:null,y:null},this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass(\"ui-menu\",\"ui-widget ui-widget-content\"),this._on({\"mousedown .ui-menu-item\":function(t){t.preventDefault(),this._activateItem(t)},\"click .ui-menu-item\":function(t){var e=x(t.target),i=x(x.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&e.not(\".ui-state-disabled\").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),e.has(\".ui-menu\").length?this.expand(t):!this.element.is(\":focus\")&&i.closest(\".ui-menu\").length&&(this.element.trigger(\"focus\",[!0]),this.active&&1===this.active.parents(\".ui-menu\").length&&clearTimeout(this.timer)))},\"mouseenter .ui-menu-item\":\"_activateItem\",\"mousemove .ui-menu-item\":\"_activateItem\",mouseleave:\"collapseAll\",\"mouseleave .ui-menu\":\"collapseAll\",focus:function(t,e){var i=this.active||this._menuItems().first();e||this.focus(t,i)},blur:function(t){this._delay(function(){x.contains(this.element[0],x.ui.safeActiveElement(this.document[0]))||this.collapseAll(t)})},keydown:\"_keydown\"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t,!0),this.mouseHandled=!1}})},_activateItem:function(t){var e,i;this.previousFilter||t.clientX===this.lastMousePosition.x&&t.clientY===this.lastMousePosition.y||(this.lastMousePosition={x:t.clientX,y:t.clientY},e=x(t.target).closest(\".ui-menu-item\"),i=x(t.currentTarget),e[0]===i[0]&&(i.is(\".ui-state-active\")||(this._removeClass(i.siblings().children(\".ui-state-active\"),null,\"ui-state-active\"),this.focus(t,i))))},_destroy:function(){var t=this.element.find(\".ui-menu-item\").removeAttr(\"role aria-disabled\").children(\".ui-menu-item-wrapper\").removeUniqueId().removeAttr(\"tabIndex role aria-haspopup\");this.element.removeAttr(\"aria-activedescendant\").find(\".ui-menu\").addBack().removeAttr(\"role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex\").removeUniqueId().show(),t.children().each(function(){var t=x(this);t.data(\"ui-menu-submenu-caret\")&&t.remove()})},_keydown:function(t){var e,i,s,n=!0;switch(t.keyCode){case x.ui.keyCode.PAGE_UP:this.previousPage(t);break;case x.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case x.ui.keyCode.HOME:this._move(\"first\",\"first\",t);break;case x.ui.keyCode.END:this._move(\"last\",\"last\",t);break;case x.ui.keyCode.UP:this.previous(t);break;case x.ui.keyCode.DOWN:this.next(t);break;case x.ui.keyCode.LEFT:this.collapse(t);break;case x.ui.keyCode.RIGHT:this.active&&!this.active.is(\".ui-state-disabled\")&&this.expand(t);break;case x.ui.keyCode.ENTER:case x.ui.keyCode.SPACE:this._activate(t);break;case x.ui.keyCode.ESCAPE:this.collapse(t);break;default:e=this.previousFilter||\"\",s=n=!1,i=96<=t.keyCode&&t.keyCode<=105?(t.keyCode-96).toString():String.fromCharCode(t.keyCode),clearTimeout(this.filterTimer),i===e?s=!0:i=e+i,e=this._filterMenuItems(i),(e=s&&-1!==e.index(this.active.next())?this.active.nextAll(\".ui-menu-item\"):e).length||(i=String.fromCharCode(t.keyCode),e=this._filterMenuItems(i)),e.length?(this.focus(t,e),this.previousFilter=i,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}n&&t.preventDefault()},_activate:function(t){this.active&&!this.active.is(\".ui-state-disabled\")&&(this.active.children(\"[aria-haspopup='true']\").length?this.expand(t):this.select(t))},refresh:function(){var t,e,s=this,n=this.options.icons.submenu,i=this.element.find(this.options.menus);this._toggleClass(\"ui-menu-icons\",null,!!this.element.find(\".ui-icon\").length),e=i.filter(\":not(.ui-menu)\").hide().attr({role:this.options.role,\"aria-hidden\":\"true\",\"aria-expanded\":\"false\"}).each(function(){var t=x(this),e=t.prev(),i=x(\"<span>\").data(\"ui-menu-submenu-caret\",!0);s._addClass(i,\"ui-menu-icon\",\"ui-icon \"+n),e.attr(\"aria-haspopup\",\"true\").prepend(i),t.attr(\"aria-labelledby\",e.attr(\"id\"))}),this._addClass(e,\"ui-menu\",\"ui-widget ui-widget-content ui-front\"),(t=i.add(this.element).find(this.options.items)).not(\".ui-menu-item\").each(function(){var t=x(this);s._isDivider(t)&&s._addClass(t,\"ui-menu-divider\",\"ui-widget-content\")}),i=(e=t.not(\".ui-menu-item, .ui-menu-divider\")).children().not(\".ui-menu\").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(e,\"ui-menu-item\")._addClass(i,\"ui-menu-item-wrapper\"),t.filter(\".ui-state-disabled\").attr(\"aria-disabled\",\"true\"),this.active&&!x.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:\"menuitem\",listbox:\"option\"}[this.options.role]},_setOption:function(t,e){var i;\"icons\"===t&&(i=this.element.find(\".ui-menu-icon\"),this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr(\"aria-disabled\",String(t)),this._toggleClass(null,\"ui-state-disabled\",!!t)},focus:function(t,e){var i;this.blur(t,t&&\"focus\"===t.type),this._scrollIntoView(e),this.active=e.first(),i=this.active.children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),this.options.role&&this.element.attr(\"aria-activedescendant\",i.attr(\"id\")),i=this.active.parent().closest(\".ui-menu-item\").children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),t&&\"keydown\"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),(i=e.children(\".ui-menu\")).length&&t&&\/^mouse\/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger(\"focus\",t,{item:e})},_scrollIntoView:function(t){var e,i,s;this._hasScroll()&&(i=parseFloat(x.css(this.activeMenu[0],\"borderTopWidth\"))||0,s=parseFloat(x.css(this.activeMenu[0],\"paddingTop\"))||0,e=t.offset().top-this.activeMenu.offset().top-i-s,i=this.activeMenu.scrollTop(),s=this.activeMenu.height(),t=t.outerHeight(),e<0?this.activeMenu.scrollTop(i+e):s<e+t&&this.activeMenu.scrollTop(i+e-s+t))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(\".ui-menu-item-wrapper\"),null,\"ui-state-active\"),this._trigger(\"blur\",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),\"true\"===t.attr(\"aria-hidden\")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(t){var e=x.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(\".ui-menu\").not(t.parents(\".ui-menu\")).hide().attr(\"aria-hidden\",\"true\"),t.show().removeAttr(\"aria-hidden\").attr(\"aria-expanded\",\"true\").position(e)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var t=i?this.element:x(e&&e.target).closest(this.element.find(\".ui-menu\"));t.length||(t=this.element),this._close(t),this.blur(e),this._removeClass(t.find(\".ui-state-active\"),null,\"ui-state-active\"),this.activeMenu=t},i?0:this.delay)},_close:function(t){(t=t||(this.active?this.active.parent():this.element)).find(\".ui-menu\").hide().attr(\"aria-hidden\",\"true\").attr(\"aria-expanded\",\"false\")},_closeOnDocumentClick:function(t){return!x(t.target).closest(\".ui-menu\").length},_isDivider:function(t){return!\/[^\\-\\u2014\\u2013\\s]\/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(\".ui-menu-item\",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this._menuItems(this.active.children(\".ui-menu\")).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move(\"next\",\"first\",t)},previous:function(t){this._move(\"prev\",\"last\",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(\".ui-menu-item\").length},isLastItem:function(){return this.active&&!this.active.nextAll(\".ui-menu-item\").length},_menuItems:function(t){return(t||this.element).find(this.options.items).filter(\".ui-menu-item\")},_move:function(t,e,i){var s;(s=this.active?\"first\"===t||\"last\"===t?this.active[\"first\"===t?\"prevAll\":\"nextAll\"](\".ui-menu-item\").last():this.active[t+\"All\"](\".ui-menu-item\").first():s)&&s.length&&this.active||(s=this._menuItems(this.activeMenu)[e]()),this.focus(i,s)},nextPage:function(t){var e,i,s;this.active?this.isLastItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.nextAll(\".ui-menu-item\").each(function(){return(e=x(this)).offset().top-i-s<0}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu)[this.active?\"last\":\"first\"]())):this.next(t)},previousPage:function(t){var e,i,s;this.active?this.isFirstItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.prevAll(\".ui-menu-item\").each(function(){return 0<(e=x(this)).offset().top-i+s}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu).first())):this.next(t)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop(\"scrollHeight\")},select:function(t){this.active=this.active||x(t.target).closest(\".ui-menu-item\");var e={item:this.active};this.active.has(\".ui-menu\").length||this.collapseAll(t,!0),this._trigger(\"select\",t,e)},_filterMenuItems:function(t){var t=t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\"),e=new RegExp(\"^\"+t,\"i\");return this.activeMenu.find(this.options.items).filter(\".ui-menu-item\").filter(function(){return e.test(String.prototype.trim.call(x(this).children(\".ui-menu-item-wrapper\").text()))})}});x.widget(\"ui.autocomplete\",{version:\"1.13.2\",defaultElement:\"<input>\",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:\"left top\",at:\"left bottom\",collision:\"none\"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,liveRegionTimer:null,_create:function(){var i,s,n,t=this.element[0].nodeName.toLowerCase(),e=\"textarea\"===t,t=\"input\"===t;this.isMultiLine=e||!t&&this._isContentEditable(this.element),this.valueMethod=this.element[e||t?\"val\":\"text\"],this.isNewMenu=!0,this._addClass(\"ui-autocomplete-input\"),this.element.attr(\"autocomplete\",\"off\"),this._on(this.element,{keydown:function(t){if(this.element.prop(\"readOnly\"))s=n=i=!0;else{s=n=i=!1;var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:i=!0,this._move(\"previousPage\",t);break;case e.PAGE_DOWN:i=!0,this._move(\"nextPage\",t);break;case e.UP:i=!0,this._keyEvent(\"previous\",t);break;case e.DOWN:i=!0,this._keyEvent(\"next\",t);break;case e.ENTER:this.menu.active&&(i=!0,t.preventDefault(),this.menu.select(t));break;case e.TAB:this.menu.active&&this.menu.select(t);break;case e.ESCAPE:this.menu.element.is(\":visible\")&&(this.isMultiLine||this._value(this.term),this.close(t),t.preventDefault());break;default:s=!0,this._searchTimeout(t)}}},keypress:function(t){if(i)return i=!1,void(this.isMultiLine&&!this.menu.element.is(\":visible\")||t.preventDefault());if(!s){var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:this._move(\"previousPage\",t);break;case e.PAGE_DOWN:this._move(\"nextPage\",t);break;case e.UP:this._keyEvent(\"previous\",t);break;case e.DOWN:this._keyEvent(\"next\",t)}}},input:function(t){if(n)return n=!1,void t.preventDefault();this._searchTimeout(t)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){clearTimeout(this.searching),this.close(t),this._change(t)}}),this._initSource(),this.menu=x(\"<ul>\").appendTo(this._appendTo()).menu({role:null}).hide().attr({unselectable:\"on\"}).menu(\"instance\"),this._addClass(this.menu.element,\"ui-autocomplete\",\"ui-front\"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault()},menufocus:function(t,e){var i,s;if(this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&\/^mouse\/.test(t.originalEvent.type)))return this.menu.blur(),void this.document.one(\"mousemove\",function(){x(t.target).trigger(t.originalEvent)});s=e.item.data(\"ui-autocomplete-item\"),!1!==this._trigger(\"focus\",t,{item:s})&&t.originalEvent&&\/^key\/.test(t.originalEvent.type)&&this._value(s.value),(i=e.item.attr(\"aria-label\")||s.value)&&String.prototype.trim.call(i).length&&(clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(i))},100))},menuselect:function(t,e){var i=e.item.data(\"ui-autocomplete-item\"),s=this.previous;this.element[0]!==x.ui.safeActiveElement(this.document[0])&&(this.element.trigger(\"focus\"),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger(\"select\",t,{item:i})&&this._value(i.value),this.term=this._value(),this.close(t),this.selectedItem=i}}),this.liveRegion=x(\"<div>\",{role:\"status\",\"aria-live\":\"assertive\",\"aria-relevant\":\"additions\"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,\"ui-helper-hidden-accessible\"),this._on(this.window,{beforeunload:function(){this.element.removeAttr(\"autocomplete\")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr(\"autocomplete\"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),\"source\"===t&&this._initSource(),\"appendTo\"===t&&this.menu.element.appendTo(this._appendTo()),\"disabled\"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(t){var e=this.menu.element[0];return t.target===this.element[0]||t.target===e||x.contains(e,t.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var t=this.options.appendTo;return t=!(t=!(t=t&&(t.jquery||t.nodeType?x(t):this.document.find(t).eq(0)))||!t[0]?this.element.closest(\".ui-front, dialog\"):t).length?this.document[0].body:t},_initSource:function(){var i,s,n=this;Array.isArray(this.options.source)?(i=this.options.source,this.source=function(t,e){e(x.ui.autocomplete.filter(i,t.term))}):\"string\"==typeof this.options.source?(s=this.options.source,this.source=function(t,e){n.xhr&&n.xhr.abort(),n.xhr=x.ajax({url:s,data:t,dataType:\"json\",success:function(t){e(t)},error:function(){e([])}})}):this.source=this.options.source},_searchTimeout:function(s){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),e=this.menu.element.is(\":visible\"),i=s.altKey||s.ctrlKey||s.metaKey||s.shiftKey;t&&(e||i)||(this.selectedItem=null,this.search(null,s))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):!1!==this._trigger(\"search\",e)?this._search(t):void 0},_search:function(t){this.pending++,this._addClass(\"ui-autocomplete-loading\"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass(\"ui-autocomplete-loading\")}.bind(this)},__response:function(t){t=t&&this._normalize(t),this._trigger(\"response\",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger(\"open\")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,\"mousedown\"),this.menu.element.is(\":visible\")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger(\"close\",t))},_change:function(t){this.previous!==this._value()&&this._trigger(\"change\",t,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:x.map(t,function(t){return\"string\"==typeof t?{label:t,value:t}:x.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var e=this.menu.element.empty();this._renderMenu(e,t),this.isNewMenu=!0,this.menu.refresh(),e.show(),this._resizeMenu(),e.position(x.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:\"_closeOnClickOutside\"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width(\"\").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(i,t){var s=this;x.each(t,function(t,e){s._renderItemData(i,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data(\"ui-autocomplete-item\",e)},_renderItem:function(t,e){return x(\"<li>\").append(x(\"<div>\").text(e.label)).appendTo(t)},_move:function(t,e){if(this.menu.element.is(\":visible\"))return this.menu.isFirstItem()&&\/^previous\/.test(t)||this.menu.isLastItem()&&\/^next\/.test(t)?(this.isMultiLine||this._value(this.term),void this.menu.blur()):void this.menu[t](e);this.search(null,e)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){this.isMultiLine&&!this.menu.element.is(\":visible\")||(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop(\"contentEditable\");return\"inherit\"===e?this._isContentEditable(t.parent()):\"true\"===e}}),x.extend(x.ui.autocomplete,{escapeRegex:function(t){return t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\")},filter:function(t,e){var i=new RegExp(x.ui.autocomplete.escapeRegex(e),\"i\");return x.grep(t,function(t){return i.test(t.label||t.value||t)})}}),x.widget(\"ui.autocomplete\",x.ui.autocomplete,{options:{messages:{noResults:\"No search results.\",results:function(t){return t+(1<t?\" results are\":\" result is\")+\" available, use up and down arrow keys to navigate.\"}}},__response:function(t){var e;this._superApply(arguments),this.options.disabled||this.cancelSearch||(e=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(e))},100))}});x.ui.autocomplete});\n\\ No newline at end of file\n+!function(t){\"use strict\";\"function\"==typeof define&&define.amd?define([\"jquery\"],t):t(jQuery)}(function(x){\"use strict\";x.ui=x.ui||{};x.ui.version=\"1.13.1\";var n,i=0,l=Array.prototype.hasOwnProperty,a=Array.prototype.slice;x.cleanData=(n=x.cleanData,function(t){for(var e,i,s=0;null!=(i=t[s]);s++)(e=x._data(i,\"events\"))&&e.remove&&x(i).triggerHandler(\"remove\");n(t)}),x.widget=function(t,i,e){var s,n,o,l={},a=t.split(\".\")[0],r=a+\"-\"+(t=t.split(\".\")[1]);return e||(e=i,i=x.Widget),Array.isArray(e)&&(e=x.extend.apply(null,[{}].concat(e))),x.expr.pseudos[r.toLowerCase()]=function(t){return!!x.data(t,r)},x[a]=x[a]||{},s=x[a][t],n=x[a][t]=function(t,e){if(!this||!this._createWidget)return new n(t,e);arguments.length&&this._createWidget(t,e)},x.extend(n,s,{version:e.version,_proto:x.extend({},e),_childConstructors:[]}),(o=new i).options=x.widget.extend({},o.options),x.each(e,function(e,s){function n(){return i.prototype[e].apply(this,arguments)}function o(t){return i.prototype[e].apply(this,t)}l[e]=\"function\"==typeof s?function(){var t,e=this._super,i=this._superApply;return this._super=n,this._superApply=o,t=s.apply(this,arguments),this._super=e,this._superApply=i,t}:s}),n.prototype=x.widget.extend(o,{widgetEventPrefix:s&&o.widgetEventPrefix||t},l,{constructor:n,namespace:a,widgetName:t,widgetFullName:r}),s?(x.each(s._childConstructors,function(t,e){var i=e.prototype;x.widget(i.namespace+\".\"+i.widgetName,n,e._proto)}),delete s._childConstructors):i._childConstructors.push(n),x.widget.bridge(t,n),n},x.widget.extend=function(t){for(var e,i,s=a.call(arguments,1),n=0,o=s.length;n<o;n++)for(e in s[n])i=s[n][e],l.call(s[n],e)&&void 0!==i&&(x.isPlainObject(i)?t[e]=x.isPlainObject(t[e])?x.widget.extend({},t[e],i):x.widget.extend({},i):t[e]=i);return t},x.widget.bridge=function(o,e){var l=e.prototype.widgetFullName||o;x.fn[o]=function(i){var t=\"string\"==typeof i,s=a.call(arguments,1),n=this;return t?this.length||\"instance\"!==i?this.each(function(){var t,e=x.data(this,l);return\"instance\"===i?(n=e,!1):e?\"function\"!=typeof e[i]||\"_\"===i.charAt(0)?x.error(\"no such method '\"+i+\"' for \"+o+\" widget instance\"):(t=e[i].apply(e,s))!==e&&void 0!==t?(n=t&&t.jquery?n.pushStack(t.get()):t,!1):void 0:x.error(\"cannot call methods on \"+o+\" prior to initialization; attempted to call method '\"+i+\"'\")}):n=void 0:(s.length&&(i=x.widget.extend.apply(null,[i].concat(s))),this.each(function(){var t=x.data(this,l);t?(t.option(i||{}),t._init&&t._init()):x.data(this,l,new e(i,this))})),n}},x.Widget=function(){},x.Widget._childConstructors=[],x.Widget.prototype={widgetName:\"widget\",widgetEventPrefix:\"\",defaultElement:\"<div>\",options:{classes:{},disabled:!1,create:null},_createWidget:function(t,e){e=x(e||this.defaultElement||this)[0],this.element=x(e),this.uuid=i++,this.eventNamespace=\".\"+this.widgetName+this.uuid,this.bindings=x(),this.hoverable=x(),this.focusable=x(),this.classesElementLookup={},e!==this&&(x.data(e,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===e&&this.destroy()}}),this.document=x(e.style?e.ownerDocument:e.document||e),this.window=x(this.document[0].defaultView||this.document[0].parentWindow)),this.options=x.widget.extend({},this.options,this._getCreateOptions(),t),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger(\"create\",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:x.noop,_create:x.noop,_init:x.noop,destroy:function(){var i=this;this._destroy(),x.each(this.classesElementLookup,function(t,e){i._removeClass(e,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr(\"aria-disabled\"),this.bindings.off(this.eventNamespace)},_destroy:x.noop,widget:function(){return this.element},option:function(t,e){var i,s,n,o=t;if(0===arguments.length)return x.widget.extend({},this.options);if(\"string\"==typeof t)if(o={},t=(i=t.split(\".\")).shift(),i.length){for(s=o[t]=x.widget.extend({},this.options[t]),n=0;n<i.length-1;n++)s[i[n]]=s[i[n]]||{},s=s[i[n]];if(t=i.pop(),1===arguments.length)return void 0===s[t]?null:s[t];s[t]=e}else{if(1===arguments.length)return void 0===this.options[t]?null:this.options[t];o[t]=e}return this._setOptions(o),this},_setOptions:function(t){for(var e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return\"classes\"===t&&this._setOptionClasses(e),this.options[t]=e,\"disabled\"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(t){var e,i,s;for(e in t)s=this.classesElementLookup[e],t[e]!==this.options.classes[e]&&s&&s.length&&(i=x(s.get()),this._removeClass(s,e),i.addClass(this._classes({element:i,keys:e,classes:t,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+\"-disabled\",null,!!t),t&&(this._removeClass(this.hoverable,null,\"ui-state-hover\"),this._removeClass(this.focusable,null,\"ui-state-focus\"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(n){var o=[],l=this;function t(t,e){for(var i,s=0;s<t.length;s++)i=l.classesElementLookup[t[s]]||x(),i=n.add?(function(){var i=[];n.element.each(function(t,e){x.map(l.classesElementLookup,function(t){return t}).some(function(t){return t.is(e)})||i.push(e)}),l._on(x(i),{remove:\"_untrackClassesElement\"})}(),x(x.uniqueSort(i.get().concat(n.element.get())))):x(i.not(n.element).get()),l.classesElementLookup[t[s]]=i,o.push(t[s]),e&&n.classes[t[s]]&&o.push(n.classes[t[s]])}return(n=x.extend({element:this.element,classes:this.options.classes||{}},n)).keys&&t(n.keys.match(\/\\S+\/g)||[],!0),n.extra&&t(n.extra.match(\/\\S+\/g)||[]),o.join(\" \")},_untrackClassesElement:function(i){var s=this;x.each(s.classesElementLookup,function(t,e){-1!==x.inArray(i.target,e)&&(s.classesElementLookup[t]=x(e.not(i.target).get()))}),this._off(x(i.target))},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){var n=\"string\"==typeof t||null===t,i={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s=\"boolean\"==typeof s?s:i};return i.element.toggleClass(this._classes(i),s),this},_on:function(n,o,t){var l,a=this;\"boolean\"!=typeof n&&(t=o,o=n,n=!1),t?(o=l=x(o),this.bindings=this.bindings.add(o)):(t=o,o=this.element,l=this.widget()),x.each(t,function(t,e){function i(){if(n||!0!==a.options.disabled&&!x(this).hasClass(\"ui-state-disabled\"))return(\"string\"==typeof e?a[e]:e).apply(a,arguments)}\"string\"!=typeof e&&(i.guid=e.guid=e.guid||i.guid||x.guid++);var s=t.match(\/^([\\w:-]*)\\s*(.*)$\/),t=s[1]+a.eventNamespace,s=s[2];s?l.on(t,s,i):o.on(t,i)})},_off:function(t,e){e=(e||\"\").split(\" \").join(this.eventNamespace+\" \")+this.eventNamespace,t.off(e),this.bindings=x(this.bindings.not(t).get()),this.focusable=x(this.focusable.not(t).get()),this.hoverable=x(this.hoverable.not(t).get())},_delay:function(t,e){var i=this;return setTimeout(function(){return(\"string\"==typeof t?i[t]:t).apply(i,arguments)},e||0)},_hoverable:function(t){this.hoverable=this.hoverable.add(t),this._on(t,{mouseenter:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-hover\")},mouseleave:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-hover\")}})},_focusable:function(t){this.focusable=this.focusable.add(t),this._on(t,{focusin:function(t){this._addClass(x(t.currentTarget),null,\"ui-state-focus\")},focusout:function(t){this._removeClass(x(t.currentTarget),null,\"ui-state-focus\")}})},_trigger:function(t,e,i){var s,n,o=this.options[t];if(i=i||{},(e=x.Event(e)).type=(t===this.widgetEventPrefix?t:this.widgetEventPrefix+t).toLowerCase(),e.target=this.element[0],n=e.originalEvent)for(s in n)s in e||(e[s]=n[s]);return this.element.trigger(e,i),!(\"function\"==typeof o&&!1===o.apply(this.element[0],[e].concat(i))||e.isDefaultPrevented())}},x.each({show:\"fadeIn\",hide:\"fadeOut\"},function(o,l){x.Widget.prototype[\"_\"+o]=function(e,t,i){var s,n=(t=\"string\"==typeof t?{effect:t}:t)?!0!==t&&\"number\"!=typeof t&&t.effect||l:o;\"number\"==typeof(t=t||{})?t={duration:t}:!0===t&&(t={}),s=!x.isEmptyObject(t),t.complete=i,t.delay&&e.delay(t.delay),s&&x.effects&&x.effects.effect[n]?e[o](t):n!==o&&e[n]?e[n](t.duration,t.easing,i):e.queue(function(t){x(this)[o](),i&&i.call(e[0]),t()})}});var s,C,E,o,r,u,h,c,k;x.widget;function T(t,e,i){return[parseFloat(t[0])*(c.test(t[0])?e\/100:1),parseFloat(t[1])*(c.test(t[1])?i\/100:1)]}function A(t,e){return parseInt(x.css(t,e),10)||0}function W(t){return null!=t&&t===t.window}C=Math.max,E=Math.abs,o=\/left|center|right\/,r=\/top|center|bottom\/,u=\/[\\+\\-]\\d+(\\.[\\d]+)?%?\/,h=\/^\\w+\/,c=\/%$\/,k=x.fn.position,x.position={scrollbarWidth:function(){if(void 0!==s)return s;var t,e=x(\"<div style='display:block;position:absolute;width:200px;height:200px;overflow:hidden;'><div style='height:300px;width:auto;'><\/div><\/div>\"),i=e.children()[0];return x(\"body\").append(e),t=i.offsetWidth,e.css(\"overflow\",\"scroll\"),t===(i=i.offsetWidth)&&(i=e[0].clientWidth),e.remove(),s=t-i},getScrollInfo:function(t){var e=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-x\"),i=t.isWindow||t.isDocument?\"\":t.element.css(\"overflow-y\"),e=\"scroll\"===e||\"auto\"===e&&t.width<t.element[0].scrollWidth;return{width:\"scroll\"===i||\"auto\"===i&&t.height<t.element[0].scrollHeight?x.position.scrollbarWidth():0,height:e?x.position.scrollbarWidth():0}},getWithinInfo:function(t){var e=x(t||window),i=W(e[0]),s=!!e[0]&&9===e[0].nodeType;return{element:e,isWindow:i,isDocument:s,offset:!i&&!s?x(t).offset():{left:0,top:0},scrollLeft:e.scrollLeft(),scrollTop:e.scrollTop(),width:e.outerWidth(),height:e.outerHeight()}}},x.fn.position=function(c){if(!c||!c.of)return k.apply(this,arguments);var d,f,m,p,v,t,g=\"string\"==typeof(c=x.extend({},c)).of?x(document).find(c.of):x(c.of),_=x.position.getWithinInfo(c.within),y=x.position.getScrollInfo(_),b=(c.collision||\"flip\").split(\" \"),w={},e=9===(t=(e=g)[0]).nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:W(t)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:t.preventDefault?{width:0,height:0,offset:{top:t.pageY,left:t.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()};return g[0].preventDefault&&(c.at=\"left top\"),f=e.width,m=e.height,v=x.extend({},p=e.offset),x.each([\"my\",\"at\"],function(){var t,e,i=(c[this]||\"\").split(\" \");(i=1===i.length?o.test(i[0])?i.concat([\"center\"]):r.test(i[0])?[\"center\"].concat(i):[\"center\",\"center\"]:i)[0]=o.test(i[0])?i[0]:\"center\",i[1]=r.test(i[1])?i[1]:\"center\",t=u.exec(i[0]),e=u.exec(i[1]),w[this]=[t?t[0]:0,e?e[0]:0],c[this]=[h.exec(i[0])[0],h.exec(i[1])[0]]}),1===b.length&&(b[1]=b[0]),\"right\"===c.at[0]?v.left+=f:\"center\"===c.at[0]&&(v.left+=f\/2),\"bottom\"===c.at[1]?v.top+=m:\"center\"===c.at[1]&&(v.top+=m\/2),d=T(w.at,f,m),v.left+=d[0],v.top+=d[1],this.each(function(){var i,t,l=x(this),a=l.outerWidth(),r=l.outerHeight(),e=A(this,\"marginLeft\"),s=A(this,\"marginTop\"),n=a+e+A(this,\"marginRight\")+y.width,o=r+s+A(this,\"marginBottom\")+y.height,u=x.extend({},v),h=T(w.my,l.outerWidth(),l.outerHeight());\"right\"===c.my[0]?u.left-=a:\"center\"===c.my[0]&&(u.left-=a\/2),\"bottom\"===c.my[1]?u.top-=r:\"center\"===c.my[1]&&(u.top-=r\/2),u.left+=h[0],u.top+=h[1],i={marginLeft:e,marginTop:s},x.each([\"left\",\"top\"],function(t,e){x.ui.position[b[t]]&&x.ui.position[b[t]][e](u,{targetWidth:f,targetHeight:m,elemWidth:a,elemHeight:r,collisionPosition:i,collisionWidth:n,collisionHeight:o,offset:[d[0]+h[0],d[1]+h[1]],my:c.my,at:c.at,within:_,elem:l})}),c.using&&(t=function(t){var e=p.left-u.left,i=e+f-a,s=p.top-u.top,n=s+m-r,o={target:{element:g,left:p.left,top:p.top,width:f,height:m},element:{element:l,left:u.left,top:u.top,width:a,height:r},horizontal:i<0?\"left\":0<e?\"right\":\"center\",vertical:n<0?\"top\":0<s?\"bottom\":\"middle\"};f<a&&E(e+i)<f&&(o.horizontal=\"center\"),m<r&&E(s+n)<m&&(o.vertical=\"middle\"),C(E(e),E(i))>C(E(s),E(n))?o.important=\"horizontal\":o.important=\"vertical\",c.using.call(this,t,o)}),l.offset(x.extend(u,{using:t}))})},x.ui.position={fit:{left:function(t,e){var i=e.within,s=i.isWindow?i.scrollLeft:i.offset.left,n=i.width,o=t.left-e.collisionPosition.marginLeft,l=s-o,a=o+e.collisionWidth-n-s;e.collisionWidth>n?0<l&&a<=0?(i=t.left+l+e.collisionWidth-n-s,t.left+=l-i):t.left=!(0<a&&l<=0)&&a<l?s+n-e.collisionWidth:s:0<l?t.left+=l:0<a?t.left-=a:t.left=C(t.left-o,t.left)},top:function(t,e){var i=e.within,s=i.isWindow?i.scrollTop:i.offset.top,n=e.within.height,o=t.top-e.collisionPosition.marginTop,l=s-o,a=o+e.collisionHeight-n-s;e.collisionHeight>n?0<l&&a<=0?(i=t.top+l+e.collisionHeight-n-s,t.top+=l-i):t.top=!(0<a&&l<=0)&&a<l?s+n-e.collisionHeight:s:0<l?t.top+=l:0<a?t.top-=a:t.top=C(t.top-o,t.top)}},flip:{left:function(t,e){var i=e.within,s=i.offset.left+i.scrollLeft,n=i.width,o=i.isWindow?i.scrollLeft:i.offset.left,l=t.left-e.collisionPosition.marginLeft,a=l-o,r=l+e.collisionWidth-n-o,u=\"left\"===e.my[0]?-e.elemWidth:\"right\"===e.my[0]?e.elemWidth:0,i=\"left\"===e.at[0]?e.targetWidth:\"right\"===e.at[0]?-e.targetWidth:0,l=-2*e.offset[0];a<0?((s=t.left+u+i+l+e.collisionWidth-n-s)<0||s<E(a))&&(t.left+=u+i+l):0<r&&(0<(o=t.left-e.collisionPosition.marginLeft+u+i+l-o)||E(o)<r)&&(t.left+=u+i+l)},top:function(t,e){var i=e.within,s=i.offset.top+i.scrollTop,n=i.height,o=i.isWindow?i.scrollTop:i.offset.top,l=t.top-e.collisionPosition.marginTop,a=l-o,r=l+e.collisionHeight-n-o,u=\"top\"===e.my[1]?-e.elemHeight:\"bottom\"===e.my[1]?e.elemHeight:0,i=\"top\"===e.at[1]?e.targetHeight:\"bottom\"===e.at[1]?-e.targetHeight:0,l=-2*e.offset[1];a<0?((s=t.top+u+i+l+e.collisionHeight-n-s)<0||s<E(a))&&(t.top+=u+i+l):0<r&&(0<(o=t.top-e.collisionPosition.marginTop+u+i+l-o)||E(o)<r)&&(t.top+=u+i+l)}},flipfit:{left:function(){x.ui.position.flip.left.apply(this,arguments),x.ui.position.fit.left.apply(this,arguments)},top:function(){x.ui.position.flip.top.apply(this,arguments),x.ui.position.fit.top.apply(this,arguments)}}};var t;x.ui.position,x.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},x.fn.extend({uniqueId:(t=0,function(){return this.each(function(){this.id||(this.id=\"ui-id-\"+ ++t)})}),removeUniqueId:function(){return this.each(function(){\/^ui-id-\\d+$\/.test(this.id)&&x(this).removeAttr(\"id\")})}}),x.ui.safeActiveElement=function(e){var i;try{i=e.activeElement}catch(t){i=e.body}return i=!(i=i||e.body).nodeName?e.body:i},x.widget(\"ui.menu\",{version:\"1.13.1\",defaultElement:\"<ul>\",delay:300,options:{icons:{submenu:\"ui-icon-caret-1-e\"},items:\"> *\",menus:\"ul\",position:{my:\"left top\",at:\"right top\"},role:\"menu\",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.lastMousePosition={x:null,y:null},this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass(\"ui-menu\",\"ui-widget ui-widget-content\"),this._on({\"mousedown .ui-menu-item\":function(t){t.preventDefault(),this._activateItem(t)},\"click .ui-menu-item\":function(t){var e=x(t.target),i=x(x.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&e.not(\".ui-state-disabled\").length&&(this.select(t),t.isPropagationStopped()||(this.mouseHandled=!0),e.has(\".ui-menu\").length?this.expand(t):!this.element.is(\":focus\")&&i.closest(\".ui-menu\").length&&(this.element.trigger(\"focus\",[!0]),this.active&&1===this.active.parents(\".ui-menu\").length&&clearTimeout(this.timer)))},\"mouseenter .ui-menu-item\":\"_activateItem\",\"mousemove .ui-menu-item\":\"_activateItem\",mouseleave:\"collapseAll\",\"mouseleave .ui-menu\":\"collapseAll\",focus:function(t,e){var i=this.active||this._menuItems().first();e||this.focus(t,i)},blur:function(t){this._delay(function(){x.contains(this.element[0],x.ui.safeActiveElement(this.document[0]))||this.collapseAll(t)})},keydown:\"_keydown\"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t,!0),this.mouseHandled=!1}})},_activateItem:function(t){var e,i;this.previousFilter||t.clientX===this.lastMousePosition.x&&t.clientY===this.lastMousePosition.y||(this.lastMousePosition={x:t.clientX,y:t.clientY},e=x(t.target).closest(\".ui-menu-item\"),i=x(t.currentTarget),e[0]===i[0]&&(i.is(\".ui-state-active\")||(this._removeClass(i.siblings().children(\".ui-state-active\"),null,\"ui-state-active\"),this.focus(t,i))))},_destroy:function(){var t=this.element.find(\".ui-menu-item\").removeAttr(\"role aria-disabled\").children(\".ui-menu-item-wrapper\").removeUniqueId().removeAttr(\"tabIndex role aria-haspopup\");this.element.removeAttr(\"aria-activedescendant\").find(\".ui-menu\").addBack().removeAttr(\"role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex\").removeUniqueId().show(),t.children().each(function(){var t=x(this);t.data(\"ui-menu-submenu-caret\")&&t.remove()})},_keydown:function(t){var e,i,s,n=!0;switch(t.keyCode){case x.ui.keyCode.PAGE_UP:this.previousPage(t);break;case x.ui.keyCode.PAGE_DOWN:this.nextPage(t);break;case x.ui.keyCode.HOME:this._move(\"first\",\"first\",t);break;case x.ui.keyCode.END:this._move(\"last\",\"last\",t);break;case x.ui.keyCode.UP:this.previous(t);break;case x.ui.keyCode.DOWN:this.next(t);break;case x.ui.keyCode.LEFT:this.collapse(t);break;case x.ui.keyCode.RIGHT:this.active&&!this.active.is(\".ui-state-disabled\")&&this.expand(t);break;case x.ui.keyCode.ENTER:case x.ui.keyCode.SPACE:this._activate(t);break;case x.ui.keyCode.ESCAPE:this.collapse(t);break;default:e=this.previousFilter||\"\",s=n=!1,i=96<=t.keyCode&&t.keyCode<=105?(t.keyCode-96).toString():String.fromCharCode(t.keyCode),clearTimeout(this.filterTimer),i===e?s=!0:i=e+i,e=this._filterMenuItems(i),(e=s&&-1!==e.index(this.active.next())?this.active.nextAll(\".ui-menu-item\"):e).length||(i=String.fromCharCode(t.keyCode),e=this._filterMenuItems(i)),e.length?(this.focus(t,e),this.previousFilter=i,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}n&&t.preventDefault()},_activate:function(t){this.active&&!this.active.is(\".ui-state-disabled\")&&(this.active.children(\"[aria-haspopup='true']\").length?this.expand(t):this.select(t))},refresh:function(){var t,e,s=this,n=this.options.icons.submenu,i=this.element.find(this.options.menus);this._toggleClass(\"ui-menu-icons\",null,!!this.element.find(\".ui-icon\").length),e=i.filter(\":not(.ui-menu)\").hide().attr({role:this.options.role,\"aria-hidden\":\"true\",\"aria-expanded\":\"false\"}).each(function(){var t=x(this),e=t.prev(),i=x(\"<span>\").data(\"ui-menu-submenu-caret\",!0);s._addClass(i,\"ui-menu-icon\",\"ui-icon \"+n),e.attr(\"aria-haspopup\",\"true\").prepend(i),t.attr(\"aria-labelledby\",e.attr(\"id\"))}),this._addClass(e,\"ui-menu\",\"ui-widget ui-widget-content ui-front\"),(t=i.add(this.element).find(this.options.items)).not(\".ui-menu-item\").each(function(){var t=x(this);s._isDivider(t)&&s._addClass(t,\"ui-menu-divider\",\"ui-widget-content\")}),i=(e=t.not(\".ui-menu-item, .ui-menu-divider\")).children().not(\".ui-menu\").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(e,\"ui-menu-item\")._addClass(i,\"ui-menu-item-wrapper\"),t.filter(\".ui-state-disabled\").attr(\"aria-disabled\",\"true\"),this.active&&!x.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:\"menuitem\",listbox:\"option\"}[this.options.role]},_setOption:function(t,e){var i;\"icons\"===t&&(i=this.element.find(\".ui-menu-icon\"),this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr(\"aria-disabled\",String(t)),this._toggleClass(null,\"ui-state-disabled\",!!t)},focus:function(t,e){var i;this.blur(t,t&&\"focus\"===t.type),this._scrollIntoView(e),this.active=e.first(),i=this.active.children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),this.options.role&&this.element.attr(\"aria-activedescendant\",i.attr(\"id\")),i=this.active.parent().closest(\".ui-menu-item\").children(\".ui-menu-item-wrapper\"),this._addClass(i,null,\"ui-state-active\"),t&&\"keydown\"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),(i=e.children(\".ui-menu\")).length&&t&&\/^mouse\/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger(\"focus\",t,{item:e})},_scrollIntoView:function(t){var e,i,s;this._hasScroll()&&(i=parseFloat(x.css(this.activeMenu[0],\"borderTopWidth\"))||0,s=parseFloat(x.css(this.activeMenu[0],\"paddingTop\"))||0,e=t.offset().top-this.activeMenu.offset().top-i-s,i=this.activeMenu.scrollTop(),s=this.activeMenu.height(),t=t.outerHeight(),e<0?this.activeMenu.scrollTop(i+e):s<e+t&&this.activeMenu.scrollTop(i+e-s+t))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(\".ui-menu-item-wrapper\"),null,\"ui-state-active\"),this._trigger(\"blur\",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),\"true\"===t.attr(\"aria-hidden\")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(t){var e=x.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(\".ui-menu\").not(t.parents(\".ui-menu\")).hide().attr(\"aria-hidden\",\"true\"),t.show().removeAttr(\"aria-hidden\").attr(\"aria-expanded\",\"true\").position(e)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var t=i?this.element:x(e&&e.target).closest(this.element.find(\".ui-menu\"));t.length||(t=this.element),this._close(t),this.blur(e),this._removeClass(t.find(\".ui-state-active\"),null,\"ui-state-active\"),this.activeMenu=t},i?0:this.delay)},_close:function(t){(t=t||(this.active?this.active.parent():this.element)).find(\".ui-menu\").hide().attr(\"aria-hidden\",\"true\").attr(\"aria-expanded\",\"false\")},_closeOnDocumentClick:function(t){return!x(t.target).closest(\".ui-menu\").length},_isDivider:function(t){return!\/[^\\-\\u2014\\u2013\\s]\/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(\".ui-menu-item\",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this._menuItems(this.active.children(\".ui-menu\")).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move(\"next\",\"first\",t)},previous:function(t){this._move(\"prev\",\"last\",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(\".ui-menu-item\").length},isLastItem:function(){return this.active&&!this.active.nextAll(\".ui-menu-item\").length},_menuItems:function(t){return(t||this.element).find(this.options.items).filter(\".ui-menu-item\")},_move:function(t,e,i){var s;(s=this.active?\"first\"===t||\"last\"===t?this.active[\"first\"===t?\"prevAll\":\"nextAll\"](\".ui-menu-item\").last():this.active[t+\"All\"](\".ui-menu-item\").first():s)&&s.length&&this.active||(s=this._menuItems(this.activeMenu)[e]()),this.focus(i,s)},nextPage:function(t){var e,i,s;this.active?this.isLastItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.nextAll(\".ui-menu-item\").each(function(){return(e=x(this)).offset().top-i-s<0}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu)[this.active?\"last\":\"first\"]())):this.next(t)},previousPage:function(t){var e,i,s;this.active?this.isFirstItem()||(this._hasScroll()?(i=this.active.offset().top,s=this.element.innerHeight(),0===x.fn.jquery.indexOf(\"3.2.\")&&(s+=this.element[0].offsetHeight-this.element.outerHeight()),this.active.prevAll(\".ui-menu-item\").each(function(){return 0<(e=x(this)).offset().top-i+s}),this.focus(t,e)):this.focus(t,this._menuItems(this.activeMenu).first())):this.next(t)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop(\"scrollHeight\")},select:function(t){this.active=this.active||x(t.target).closest(\".ui-menu-item\");var e={item:this.active};this.active.has(\".ui-menu\").length||this.collapseAll(t,!0),this._trigger(\"select\",t,e)},_filterMenuItems:function(t){var t=t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\"),e=new RegExp(\"^\"+t,\"i\");return this.activeMenu.find(this.options.items).filter(\".ui-menu-item\").filter(function(){return e.test(String.prototype.trim.call(x(this).children(\".ui-menu-item-wrapper\").text()))})}});x.widget(\"ui.autocomplete\",{version:\"1.13.1\",defaultElement:\"<input>\",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:\"left top\",at:\"left bottom\",collision:\"none\"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,liveRegionTimer:null,_create:function(){var i,s,n,t=this.element[0].nodeName.toLowerCase(),e=\"textarea\"===t,t=\"input\"===t;this.isMultiLine=e||!t&&this._isContentEditable(this.element),this.valueMethod=this.element[e||t?\"val\":\"text\"],this.isNewMenu=!0,this._addClass(\"ui-autocomplete-input\"),this.element.attr(\"autocomplete\",\"off\"),this._on(this.element,{keydown:function(t){if(this.element.prop(\"readOnly\"))s=n=i=!0;else{s=n=i=!1;var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:i=!0,this._move(\"previousPage\",t);break;case e.PAGE_DOWN:i=!0,this._move(\"nextPage\",t);break;case e.UP:i=!0,this._keyEvent(\"previous\",t);break;case e.DOWN:i=!0,this._keyEvent(\"next\",t);break;case e.ENTER:this.menu.active&&(i=!0,t.preventDefault(),this.menu.select(t));break;case e.TAB:this.menu.active&&this.menu.select(t);break;case e.ESCAPE:this.menu.element.is(\":visible\")&&(this.isMultiLine||this._value(this.term),this.close(t),t.preventDefault());break;default:s=!0,this._searchTimeout(t)}}},keypress:function(t){if(i)return i=!1,void(this.isMultiLine&&!this.menu.element.is(\":visible\")||t.preventDefault());if(!s){var e=x.ui.keyCode;switch(t.keyCode){case e.PAGE_UP:this._move(\"previousPage\",t);break;case e.PAGE_DOWN:this._move(\"nextPage\",t);break;case e.UP:this._keyEvent(\"previous\",t);break;case e.DOWN:this._keyEvent(\"next\",t)}}},input:function(t){if(n)return n=!1,void t.preventDefault();this._searchTimeout(t)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){clearTimeout(this.searching),this.close(t),this._change(t)}}),this._initSource(),this.menu=x(\"<ul>\").appendTo(this._appendTo()).menu({role:null}).hide().attr({unselectable:\"on\"}).menu(\"instance\"),this._addClass(this.menu.element,\"ui-autocomplete\",\"ui-front\"),this._on(this.menu.element,{mousedown:function(t){t.preventDefault()},menufocus:function(t,e){var i,s;if(this.isNewMenu&&(this.isNewMenu=!1,t.originalEvent&&\/^mouse\/.test(t.originalEvent.type)))return this.menu.blur(),void this.document.one(\"mousemove\",function(){x(t.target).trigger(t.originalEvent)});s=e.item.data(\"ui-autocomplete-item\"),!1!==this._trigger(\"focus\",t,{item:s})&&t.originalEvent&&\/^key\/.test(t.originalEvent.type)&&this._value(s.value),(i=e.item.attr(\"aria-label\")||s.value)&&String.prototype.trim.call(i).length&&(clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(i))},100))},menuselect:function(t,e){var i=e.item.data(\"ui-autocomplete-item\"),s=this.previous;this.element[0]!==x.ui.safeActiveElement(this.document[0])&&(this.element.trigger(\"focus\"),this.previous=s,this._delay(function(){this.previous=s,this.selectedItem=i})),!1!==this._trigger(\"select\",t,{item:i})&&this._value(i.value),this.term=this._value(),this.close(t),this.selectedItem=i}}),this.liveRegion=x(\"<div>\",{role:\"status\",\"aria-live\":\"assertive\",\"aria-relevant\":\"additions\"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,\"ui-helper-hidden-accessible\"),this._on(this.window,{beforeunload:function(){this.element.removeAttr(\"autocomplete\")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr(\"autocomplete\"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),\"source\"===t&&this._initSource(),\"appendTo\"===t&&this.menu.element.appendTo(this._appendTo()),\"disabled\"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(t){var e=this.menu.element[0];return t.target===this.element[0]||t.target===e||x.contains(e,t.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var t=this.options.appendTo;return t=!(t=!(t=t&&(t.jquery||t.nodeType?x(t):this.document.find(t).eq(0)))||!t[0]?this.element.closest(\".ui-front, dialog\"):t).length?this.document[0].body:t},_initSource:function(){var i,s,n=this;Array.isArray(this.options.source)?(i=this.options.source,this.source=function(t,e){e(x.ui.autocomplete.filter(i,t.term))}):\"string\"==typeof this.options.source?(s=this.options.source,this.source=function(t,e){n.xhr&&n.xhr.abort(),n.xhr=x.ajax({url:s,data:t,dataType:\"json\",success:function(t){e(t)},error:function(){e([])}})}):this.source=this.options.source},_searchTimeout:function(s){clearTimeout(this.searching),this.searching=this._delay(function(){var t=this.term===this._value(),e=this.menu.element.is(\":visible\"),i=s.altKey||s.ctrlKey||s.metaKey||s.shiftKey;t&&(e||i)||(this.selectedItem=null,this.search(null,s))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):!1!==this._trigger(\"search\",e)?this._search(t):void 0},_search:function(t){this.pending++,this._addClass(\"ui-autocomplete-loading\"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass(\"ui-autocomplete-loading\")}.bind(this)},__response:function(t){t=t&&this._normalize(t),this._trigger(\"response\",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger(\"open\")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,\"mousedown\"),this.menu.element.is(\":visible\")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger(\"close\",t))},_change:function(t){this.previous!==this._value()&&this._trigger(\"change\",t,{item:this.selectedItem})},_normalize:function(t){return t.length&&t[0].label&&t[0].value?t:x.map(t,function(t){return\"string\"==typeof t?{label:t,value:t}:x.extend({},t,{label:t.label||t.value,value:t.value||t.label})})},_suggest:function(t){var e=this.menu.element.empty();this._renderMenu(e,t),this.isNewMenu=!0,this.menu.refresh(),e.show(),this._resizeMenu(),e.position(x.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:\"_closeOnClickOutside\"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width(\"\").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(i,t){var s=this;x.each(t,function(t,e){s._renderItemData(i,e)})},_renderItemData:function(t,e){return this._renderItem(t,e).data(\"ui-autocomplete-item\",e)},_renderItem:function(t,e){return x(\"<li>\").append(x(\"<div>\").text(e.label)).appendTo(t)},_move:function(t,e){if(this.menu.element.is(\":visible\"))return this.menu.isFirstItem()&&\/^previous\/.test(t)||this.menu.isLastItem()&&\/^next\/.test(t)?(this.isMultiLine||this._value(this.term),void this.menu.blur()):void this.menu[t](e);this.search(null,e)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){this.isMultiLine&&!this.menu.element.is(\":visible\")||(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop(\"contentEditable\");return\"inherit\"===e?this._isContentEditable(t.parent()):\"true\"===e}}),x.extend(x.ui.autocomplete,{escapeRegex:function(t){return t.replace(\/[\\-\\[\\]{}()*+?.,\\\\\\^$|#\\s]\/g,\"\\\\$&\")},filter:function(t,e){var i=new RegExp(x.ui.autocomplete.escapeRegex(e),\"i\");return x.grep(t,function(t){return i.test(t.label||t.value||t)})}}),x.widget(\"ui.autocomplete\",x.ui.autocomplete,{options:{messages:{noResults:\"No search results.\",results:function(t){return t+(1<t?\" results are\":\" result is\")+\" available, use up and down arrow keys to navigate.\"}}},__response:function(t){var e;this._superApply(arguments),this.options.disabled||this.cancelSearch||(e=t&&t.length?this.options.messages.results(t.length):this.options.messages.noResults,clearTimeout(this.liveRegionTimer),this.liveRegionTimer=this._delay(function(){this.liveRegion.html(x(\"<div>\").text(e))},100))}});x.ui.autocomplete});\n\\ No newline at end of file\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/jquery\/jquery-ui.min.js","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,1 +1,1 @@\n-## jQuery UI v1.13.2\n+## jQuery UI v1.12.1\n","filename":"src\/jdk.javadoc\/share\/legal\/jqueryUI.md","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2578,4 +2578,1 @@\n-                    throw new ZipException(String.format(\n-                            \"Invalid CEN header (invalid extra data field size for \" +\n-                                    \"tag: 0x%04x size: %d)\",\n-                            tag, sz));\n+                    throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n@@ -2585,9 +2582,0 @@\n-                    \/\/ if ZIP64_EXTID blocksize == 0, which may occur with some older\n-                    \/\/ versions of Apache Ant and Commons Compress, validate csize\n-                    \/\/ size, and locoff to make sure the fields != ZIP64_MAGICVAL\n-                    if (sz == 0) {\n-                        if (csize == ZIP64_MINVAL || size == ZIP64_MINVAL || locoff == ZIP64_MINVAL) {\n-                            throw new ZipException(\"Invalid CEN header (invalid zip64 extra data field size)\");\n-                        }\n-                        break;\n-                    }\n","filename":"src\/jdk.zipfs\/share\/classes\/jdk\/nio\/zipfs\/ZipFileSystem.java","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263,8313877 generic-x64,generic-i586,generic-ppc64le\n+compiler\/rtm\/locking\/TestRTMAbortThreshold.java 8183263 generic-x64,generic-i586\n@@ -127,1 +127,1 @@\n-compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263,8313877 generic-x64,generic-i586,generic-ppc64le\n+compiler\/rtm\/locking\/TestRTMSpinLoopCount.java 8183263 generic-x64,generic-i586\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223,8274106 macosx-aarch64,linux-all,solaris-all,windows-all\n+java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 7099223 linux-all,solaris-all,windows-all\n@@ -739,0 +739,1 @@\n+java\/awt\/GraphicsDevice\/DisplayModes\/CycleDMImage.java 8274106 macosx-aarch64\n@@ -862,1 +863,0 @@\n-jdk\/jfr\/event\/sampling\/TestStackFrameLineNumbers.java           8313802    linux-all,windows-all\n@@ -866,1 +866,1 @@\n-\n+ \n","filename":"test\/jdk\/ProblemList.txt","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,2 @@\n+import java.net.ServerSocket;\n+import java.util.regex.Matcher;\n@@ -128,0 +130,6 @@\n+        \/\/ find a free port\n+        ServerSocket ss = new ServerSocket(0);\n+        int port = ss.getLocalPort();\n+        ss.close();\n+        String address = String.valueOf(port);\n+\n@@ -133,1 +141,1 @@\n-                              \",address=0\" +\n+                              \",address=\" + address +\n","filename":"test\/jdk\/com\/sun\/jdi\/OptionTest.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2018, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.net.ServerSocket;\n@@ -43,2 +44,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -54,3 +53,0 @@\n-    \/* port the debuggee is listening on *\/\n-    private static String address;\n-\n@@ -73,1 +69,1 @@\n-     * Launch a server debuggee, detect debuggee listening port\n+     * Launch a server debuggee with the given address\n@@ -75,1 +71,1 @@\n-    private static Process launch(String class_name) throws Exception {\n+    private static Process launch(String address, String class_name) throws Exception {\n@@ -77,1 +73,2 @@\n-            \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=0\",\n+            \"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=\"\n+                + address,\n@@ -98,3 +95,0 @@\n-    \/* warm-up predicate for debuggee *\/\n-    private static Pattern listenRegexp = Pattern.compile(\"Listening for transport \\\\b(.+)\\\\b at address: \\\\b(.+)\\\\b\");\n-\n@@ -102,7 +96,1 @@\n-        Matcher m = listenRegexp.matcher(line);\n-        if (!m.matches()) {\n-            return false;\n-        }\n-        \/\/ address is 2nd group\n-        address = m.group(2);\n-        return true;\n+        return line.startsWith(\"Listening for transport dt_socket\");\n@@ -118,2 +106,2 @@\n-     * - Launch a server debuggee: server=y,suspend=y,address=0\n-     * - detect the port debuggee is listening on\n+     * - pick a TCP port\n+     * - Launch a server debuggee: server=y,suspend=y,address=${port}\n@@ -124,0 +112,7 @@\n+        \/\/ find a free port\n+        ServerSocket ss = new ServerSocket(0);\n+        int port = ss.getLocalPort();\n+        ss.close();\n+\n+        String address = String.valueOf(port);\n+\n@@ -125,1 +120,1 @@\n-        Process process = launch(\"Exit0\");\n+        Process process = launch(address, \"Exit0\");\n@@ -132,1 +127,1 @@\n-        port_arg.setValue(address);\n+        port_arg.setValue(port);\n","filename":"test\/jdk\/com\/sun\/jdi\/RunToExit.java","additions":18,"deletions":23,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,186 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 4394789\n-  @summary KeyboardFocusManager.upFocusCycle is not working for Swing properly\n-  @key headful\n-  @run main AsyncUpFocusCycleTest\n-*\/\n-\n-\n-import javax.swing.DefaultFocusManager;\n-import javax.swing.JButton;\n-import javax.swing.JFrame;\n-import java.awt.AWTException;\n-import java.awt.BorderLayout;\n-import java.awt.Color;\n-import java.awt.Container;\n-import java.awt.DefaultKeyboardFocusManager;\n-import java.awt.EventQueue;\n-import java.awt.Insets;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.event.FocusAdapter;\n-import java.awt.event.FocusEvent;\n-import java.awt.event.InputEvent;\n-import java.lang.reflect.InvocationTargetException;\n-\n-public class AsyncUpFocusCycleTest {\n-    volatile boolean isFailed = true;\n-    Object sema = new Object();\n-    JFrame frame;\n-    Point location;\n-    JButton button;\n-    Insets insets;\n-    int width;\n-\n-    public void start() throws InterruptedException,\n-            InvocationTargetException {\n-        try {\n-            Robot robot = new Robot();\n-            robot.mouseMove(100, 100);\n-\n-            EventQueue.invokeAndWait(() -> {\n-                frame = new JFrame(\"AsyncUpFocusCycleTest\") {\n-                    public void requestFocus() {\n-                        boolean ret = super.requestFocus(false);\n-                        System.err.println(\"requestFocus() on Frame \" + ret);\n-                    }\n-\n-                    protected boolean requestFocus(boolean temporary) {\n-                        boolean ret = super.requestFocus(temporary);\n-                        System.err.println(\"requestFocus(\" + temporary + \") on Frame \" + ret);\n-                        return ret;\n-                    }\n-\n-                    public boolean requestFocusInWindow() {\n-                        boolean ret = super.requestFocusInWindow();\n-                        System.err.println(\"requestFocusInWindow() on Frame \" + ret);\n-                        return ret;\n-                    }\n-\n-                    protected boolean requestFocusInWindow(boolean temporary) {\n-                        boolean ret = super.requestFocusInWindow(temporary);\n-                        System.err.println(\"requestFocusInWindow(\" + temporary + \") on Frame \" + ret);\n-                        return ret;\n-                    }\n-                };\n-\n-                Container container1 = frame.getContentPane();\n-                container1.setBackground(Color.yellow);\n-\n-                button = new JButton(\"Button\") {\n-                    public void requestFocus() {\n-                        boolean ret = super.requestFocus(false);\n-                        System.err.println(\"requestFocus() on Button \" + ret);\n-                    }\n-\n-                    public boolean requestFocus(boolean temporary) {\n-                        boolean ret = super.requestFocus(temporary);\n-                        System.err.println(\"requestFocus(\" + temporary + \") on Button \" + ret);\n-                        return ret;\n-                    }\n-\n-                    public boolean requestFocusInWindow() {\n-                        boolean ret = super.requestFocusInWindow();\n-                        System.err.println(\"requestFocusInWindow() on Button \" + ret);\n-                        return ret;\n-                    }\n-\n-                    protected boolean requestFocusInWindow(boolean temporary) {\n-                        boolean ret = super.requestFocusInWindow(temporary);\n-                        System.err.println(\"requestFocusInWindow(\" + temporary + \") on Button \" + ret);\n-                        return ret;\n-                    }\n-                };\n-                button.addFocusListener(new FocusAdapter() {\n-                    public void focusGained(FocusEvent fe) {\n-                        System.out.println(\"Button receive focus\");\n-                        frame.addFocusListener(new FocusAdapter() {\n-                            public void focusGained(FocusEvent fe) {\n-                                System.out.println(\"Frame receive focus\");\n-                                synchronized (sema) {\n-                                    isFailed = false;\n-                                    sema.notifyAll();\n-                                }\n-                            }\n-                        });\n-                    }\n-                });\n-                container1.add(new JButton(\"empty button\"), BorderLayout.WEST);\n-                container1.add(button, BorderLayout.EAST);\n-                frame.setBounds(0, 0, 300, 300);\n-                frame.setVisible(true);\n-            });\n-\n-            robot.delay(2000);\n-            robot.waitForIdle();\n-\n-            EventQueue.invokeAndWait(() -> {\n-                location = frame.getLocationOnScreen();\n-                insets = frame.getInsets();\n-                width = frame.getWidth();\n-            });\n-\n-            robot.mouseMove(location.x + width \/ 2, location.y + insets.top \/ 2);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            DefaultKeyboardFocusManager manager = new DefaultFocusManager();\n-            robot.delay(1000);\n-            EventQueue.invokeAndWait(button::requestFocus);\n-            robot.delay(1000);\n-            EventQueue.invokeAndWait(() -> {\n-                manager.upFocusCycle(button);\n-            });\n-\n-            try {\n-                synchronized (sema) {\n-                    sema.wait(5000);\n-                }\n-\n-                if (isFailed) {\n-                    System.out.println(\"Test FAILED\");\n-                    throw new RuntimeException(\"Test FAILED\");\n-                } else {\n-                    System.out.println(\"Test PASSED\");\n-                }\n-            } catch (InterruptedException ie) {\n-                throw new RuntimeException(\"Test was interrupted\");\n-            }\n-        } catch (AWTException e) {\n-            System.out.println(\"Problem creating Robot.\");\n-        } finally {\n-            if (frame != null) {\n-                EventQueue.invokeAndWait(frame::dispose);\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException {\n-        AsyncUpFocusCycleTest test = new AsyncUpFocusCycleTest();\n-        test.start();\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Focus\/AsyncUpFocusCycleTest.java","additions":0,"deletions":186,"binary":false,"changes":186,"status":"deleted"},{"patch":"@@ -1,307 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 4525962\n-  @summary Opposite component calculated inaccurately\n-  @key headful\n-  @run main ClearMostRecentFocusOwnerTest\n-*\/\n-\n-import java.awt.AWTEvent;\n-import java.awt.AWTException;\n-import java.awt.Button;\n-import java.awt.Component;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.FlowLayout;\n-import java.awt.Frame;\n-import java.awt.Insets;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.Toolkit;\n-\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.FocusEvent;\n-import java.awt.event.InputEvent;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.atomic.AtomicBoolean;\n-\n-public class ClearMostRecentFocusOwnerTest implements AWTEventListener {\n-    final static int ROBOT_DELAY = 50;\n-    volatile Frame firstFrame;\n-    volatile Frame secondFrame;\n-    volatile Button actionButton;\n-    volatile Button btnToRemove;\n-    volatile Button btnToHide;\n-    volatile Button btnToDisable;\n-    volatile Button btnToNonFocusable;\n-    volatile Panel pnlToHide;\n-    volatile Button btnInPanel;\n-\n-    Robot robot;\n-\n-    volatile Component opposite = null;\n-    volatile Component focusOwner = null;\n-    volatile Object monitor = null;\n-\n-    public void init() throws InterruptedException,\n-            InvocationTargetException {\n-        try {\n-            robot = new Robot();\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"Can not create awt-robot.\");\n-        }\n-        EventQueue.invokeAndWait(() -> {\n-            firstFrame = new Frame(\"The First Frame\");\n-            firstFrame.setName(\"\\\"1st Frame\\\"\");\n-            secondFrame = new Frame(\"The Second Frame\");\n-            secondFrame.setName(\"\\\"2nd Frame\\\"\");\n-            pnlToHide = new Panel();\n-            pnlToHide.setName(\"Panel\");\n-            actionButton = new Button(\"Action Button\");\n-            actionButton.setName(\"\\\"\" + actionButton.getLabel() + \"\\\"\");\n-            btnToRemove = new Button(\"To Remove\");\n-            btnToRemove.setName(\"\\\"\" + btnToRemove.getLabel() + \"\\\"\");\n-            btnToHide = new Button(\"ToHide\");\n-            btnToHide.setName(\"\\\"\" + btnToHide.getLabel() + \"\\\"\");\n-            btnToDisable = new Button(\"To Disable\");\n-            btnToDisable.setName(\"\\\"\" + btnToDisable.getLabel() + \"\\\"\");\n-            btnToNonFocusable = new Button(\"To setFocusable(false)\");\n-            btnToNonFocusable.setName(\"\\\"\" + btnToNonFocusable.getLabel() + \"\\\"\");\n-            btnInPanel = new Button(\"Int Panel\");\n-            btnInPanel.setName(\"\\\"\" + btnInPanel.getLabel() + \"\\\"\");\n-\n-            firstFrame.add(actionButton);\n-\n-            secondFrame.setLayout(new FlowLayout());\n-            secondFrame.add(btnToRemove);\n-            secondFrame.add(btnToHide);\n-            secondFrame.add(btnToDisable);\n-            secondFrame.add(btnToNonFocusable);\n-            secondFrame.add(pnlToHide);\n-            pnlToHide.add(btnInPanel);\n-\n-            firstFrame.pack();\n-            firstFrame.setVisible(true);\n-            secondFrame.pack();\n-            secondFrame.setLocation(0, firstFrame.getHeight() + 50);\n-            secondFrame.setVisible(true);\n-        });\n-    }\n-\n-    public void start() throws InterruptedException, InvocationTargetException {\n-        try {\n-            Toolkit.getDefaultToolkit().\n-                    addAWTEventListener(this,\n-                            AWTEvent.FOCUS_EVENT_MASK);\n-\n-            makeFocusOwner(btnToRemove);\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(false);\n-                secondFrame.remove(btnToRemove);\n-            });\n-            makeFocusOwner(actionButton);\n-            opposite = null;\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(true);\n-            });\n-            makeActiveFrame(secondFrame);\n-            if (opposite != btnToHide) {\n-                System.out.println(\"opposite = \" + opposite);\n-                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.remove().\");\n-            }\n-\n-            makeFocusOwner(btnToHide);\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(false);\n-                btnToHide.setVisible(false);\n-            });\n-            makeFocusOwner(actionButton);\n-            opposite = null;\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(true);\n-            });\n-            makeActiveFrame(secondFrame);\n-            if (opposite != btnToDisable) {\n-                System.out.println(\"opposite = \" + opposite);\n-                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.setVisible(false).\");\n-            }\n-\n-            makeFocusOwner(btnToDisable);\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(false);\n-                btnToDisable.setEnabled(false);\n-            });\n-            makeFocusOwner(actionButton);\n-            opposite = null;\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(true);\n-            });\n-            makeActiveFrame(secondFrame);\n-            if (opposite != btnToNonFocusable) {\n-                System.out.println(\"opposite = \" + opposite);\n-                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.rsetEnabled(false).\");\n-            }\n-\n-            makeFocusOwner(btnToNonFocusable);\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(false);\n-                btnToNonFocusable.setFocusable(false);\n-            });\n-            makeFocusOwner(actionButton);\n-            opposite = null;\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(true);\n-            });\n-            makeActiveFrame(secondFrame);\n-            if (opposite != btnInPanel) {\n-                System.out.println(\"opposite = \" + opposite);\n-                throw new RuntimeException(\"Test FAILED: wrong opposite after Component.setFocusable(false).\");\n-            }\n-\n-            makeFocusOwner(btnInPanel);\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(false);\n-                pnlToHide.setVisible(false);\n-            });\n-            makeFocusOwner(actionButton);\n-            opposite = null;\n-            EventQueue.invokeAndWait(() -> {\n-                secondFrame.setVisible(true);\n-            });\n-            makeActiveFrame(secondFrame);\n-            if (opposite == btnInPanel) {\n-                System.out.println(\"opposite = \" + opposite);\n-                throw new RuntimeException(\"Test FAILED: wrong opposite after Container.setVisible(false).\");\n-            }\n-        } finally {\n-            if (firstFrame != null) {\n-                EventQueue.invokeAndWait(firstFrame::dispose);\n-            }\n-            if (secondFrame != null) {\n-                EventQueue.invokeAndWait(secondFrame::dispose);\n-            }\n-\n-        }\n-    }\n-\n-    public void eventDispatched(AWTEvent event) {\n-        switch (event.getID()) {\n-            case FocusEvent.FOCUS_GAINED:\n-                if (focusOwner == ((FocusEvent) event).getComponent()\n-                        && monitor != null) {\n-                    synchronized (monitor) {\n-                        monitor.notify();\n-                    }\n-                }\n-                break;\n-            case FocusEvent.FOCUS_LOST:\n-                opposite = ((FocusEvent) event).getOppositeComponent();\n-                break;\n-        }\n-        System.out.println(event);\n-    }\n-\n-    void clickOnComponent(Component comp) throws InterruptedException,\n-            InvocationTargetException {\n-        System.err.println(\"clickOnComopnent \" + comp.getName());\n-        robot.delay(3000);\n-        int[] point = new int[2];\n-        EventQueue.invokeAndWait(() -> {\n-            Point origin = comp.getLocationOnScreen();\n-            Dimension dim = comp.getSize();\n-            point[0] = origin.x + (int) dim.getWidth() \/ 2;\n-            point[1] = origin.y + (int) dim.getHeight() \/ 2;\n-        });\n-        robot.mouseMove(point[0], point[1]);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        robot.delay(ROBOT_DELAY);\n-        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-    }\n-\n-    void makeFocusOwner(Component comp) throws InterruptedException,\n-            InvocationTargetException {\n-        AtomicBoolean isOwner = new AtomicBoolean(false);\n-        EventQueue.invokeAndWait(() -> {\n-            isOwner.set(comp.isFocusOwner());\n-        });\n-        if (!isOwner.get()) {\n-            clickOnComponent(comp);\n-            try {\n-                EventQueue.invokeAndWait(() -> {\n-                    isOwner.set(comp.isFocusOwner());\n-                });\n-                if (!isOwner.get()) {\n-                    monitor = new Object();\n-                    focusOwner = comp;\n-                    synchronized (monitor) {\n-                        monitor.wait(3000);\n-                    }\n-                }\n-            } catch (InterruptedException ie) {\n-                throw new RuntimeException(\"Test was interrupted.\");\n-            }\n-        }\n-        EventQueue.invokeAndWait(() -> {\n-            isOwner.set(comp.isFocusOwner());\n-        });\n-        if (!isOwner.get()) {\n-            throw new RuntimeException(\"Test can not make \"\n-                    + comp.getName() + \" a focus owner.\");\n-        }\n-    }\n-\n-    void makeActiveFrame(Frame frame) throws InvocationTargetException,\n-            InterruptedException {\n-        robot.delay(3000);\n-        if (!frame.isActive()) {\n-            System.err.println(\"frame is not active\");\n-            int[] point = new int[2];\n-            EventQueue.invokeAndWait(() -> {\n-                Point origin = frame.getLocationOnScreen();\n-                Insets ins = frame.getInsets();\n-                point[0] = origin.x + frame.getWidth() \/ 2;\n-                point[1] = origin.y + ins.top \/ 2;\n-            });\n-            robot.mouseMove(point[0], point[1]);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.delay(ROBOT_DELAY);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-        }\n-        robot.delay(3000);\n-        EventQueue.invokeAndWait(() -> {\n-            if (!frame.isActive()) {\n-                throw new RuntimeException(\"Test can not activate \" + frame.getName() + \".\");\n-            }\n-        });\n-    }\n-\n-    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n-        ClearMostRecentFocusOwnerTest test = new ClearMostRecentFocusOwnerTest();\n-        test.init();\n-        test.start();\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Focus\/ClearMostRecentFocusOwnerTest.java","additions":0,"deletions":307,"binary":false,"changes":307,"status":"deleted"},{"patch":"@@ -1,232 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-@test\n-@bug 4715649\n-@summary Tests that KEY_TYPED event for Tab key arrives if Tab key is not focus traversal key\n-@key headful\n-@run main ConsumedTabKeyTest\n-*\/\n-\n-import java.awt.AWTEvent;\n-import java.awt.BorderLayout;\n-import java.awt.Button;\n-import java.awt.EventQueue;\n-import java.awt.FlowLayout;\n-import java.awt.Frame;\n-import java.awt.Panel;\n-import java.awt.Robot;\n-import java.awt.TextField;\n-import java.awt.Toolkit;\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.FocusAdapter;\n-import java.awt.event.FocusEvent;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-import java.lang.reflect.InvocationTargetException;\n-\n-public class ConsumedTabKeyTest extends Panel {\n-    TextField text;\n-    Button button = new Button(\"none\");\n-    Semaphore focusSema = new Semaphore();\n-    Semaphore releaseSema = new Semaphore();\n-    Semaphore buttonFocusSema = new Semaphore();\n-    Robot robot;\n-    volatile boolean keyTyped;\n-    volatile boolean hasFocus;\n-    static Frame frame;\n-\n-    public void init() {\n-        this.setLayout(new FlowLayout());\n-        text = new TextField();\n-\n-        text.addFocusListener(new FocusAdapter() {\n-            public void focusGained(FocusEvent e) {\n-                focusSema.raise();\n-            }\n-        });\n-        button.addFocusListener(new FocusAdapter() {\n-            public void focusGained(FocusEvent e) {\n-                buttonFocusSema.raise();\n-            }\n-        });\n-        add(text);\n-        add(button);\n-        setSize(200, 200);\n-        setVisible(true);\n-        validate();\n-        Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {\n-            public void eventDispatched(AWTEvent e) {\n-                if (e.getID() == KeyEvent.KEY_RELEASED) {\n-                    releaseSema.raise();\n-                }\n-                if (e.getID() == KeyEvent.KEY_TYPED) {\n-                    keyTyped = true;\n-                }\n-            }\n-        }, InputEvent.KEY_EVENT_MASK);\n-        try {\n-            robot = new Robot();\n-        } catch (Exception re) {\n-            throw new RuntimeException(\"Couldn't create Robot\");\n-        }\n-    }\n-\n-    public void start() throws InterruptedException,\n-            InvocationTargetException {\n-        EventQueue.invokeAndWait(() -> {\n-            if (!text.isFocusOwner()) {\n-                text.requestFocus();\n-            }\n-\n-            text.setFocusTraversalKeysEnabled(false);\n-        });\n-\n-        try {\n-            focusSema.doWait(1000);\n-        } catch (InterruptedException ie1) {\n-            throw new RuntimeException(\"Interrupted\");\n-        }\n-\n-        EventQueue.invokeAndWait(() -> {\n-            hasFocus = text.isFocusOwner();\n-        });\n-\n-        if (!focusSema.getState() && !hasFocus) {\n-            throw new RuntimeException(\"Text didn't receive focus\");\n-        }\n-\n-        robot.keyPress(KeyEvent.VK_TAB);\n-        robot.keyRelease(KeyEvent.VK_TAB);\n-        try {\n-            releaseSema.doWait(1000);\n-        } catch (InterruptedException ie2) {\n-            throw new RuntimeException(\"Interrupted\");\n-        }\n-\n-        if (!releaseSema.getState()) {\n-            throw new RuntimeException(\"KEY_RELEASED hasn't arrived\");\n-        }\n-\n-        if (!keyTyped) {\n-            throw new RuntimeException(\"KEY_TYPED for Tab key hasn't arrived\");\n-        }\n-\n-        EventQueue.invokeAndWait(() -> {\n-            text.setFocusTraversalKeysEnabled(true);\n-        });\n-\n-        releaseSema.setState(false);\n-        robot.keyPress(KeyEvent.VK_TAB);\n-        robot.keyRelease(KeyEvent.VK_TAB);\n-        try {\n-            buttonFocusSema.doWait(1000);\n-            releaseSema.doWait(1000);\n-        } catch (InterruptedException ie2) {\n-            throw new RuntimeException(\"Interrupted\");\n-        }\n-\n-        EventQueue.invokeAndWait(() -> {\n-            hasFocus = button.isFocusOwner();\n-        });\n-\n-        if (!buttonFocusSema.getState() && !hasFocus) {\n-            throw new RuntimeException(\"Button hasn't received focus\");\n-        }\n-        keyTyped = false;\n-        releaseSema.setState(false);\n-        robot.keyPress(KeyEvent.VK_A);\n-        robot.keyRelease(KeyEvent.VK_A);\n-        try {\n-            releaseSema.doWait(1000);\n-        } catch (InterruptedException ie2) {\n-            throw new RuntimeException(\"Interrupted\");\n-        }\n-\n-        if (!releaseSema.getState()) {\n-            throw new RuntimeException(\"KEY_RELEASED hasn't arrived\");\n-        }\n-        if (!keyTyped) {\n-            throw new RuntimeException(\"KEY_TYPED for A key hasn't arrived\");\n-        }\n-        System.err.println(\"PASSED\");\n-    }\n-\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException {\n-        ConsumedTabKeyTest test = new ConsumedTabKeyTest();\n-\n-        try {\n-            EventQueue.invokeAndWait(() -> {\n-                frame = new Frame(\"InvocationTargetException\");\n-                frame.setLayout(new BorderLayout());\n-                frame.add(test, BorderLayout.CENTER);\n-                test.init();\n-                frame.setLocationRelativeTo(null);\n-                frame.pack();\n-                frame.setVisible(true);\n-            });\n-            test.start();\n-        } finally {\n-            if (frame != null) {\n-                EventQueue.invokeAndWait(frame::dispose);\n-            }\n-        }\n-    }\n-}\n-\n-class Semaphore {\n-    boolean state = false;\n-    int waiting = 0;\n-\n-    public void doWait(int timeout) throws InterruptedException {\n-        synchronized (this) {\n-            if (state) return;\n-            waiting++;\n-            wait(timeout);\n-            waiting--;\n-        }\n-    }\n-\n-    public void raise() {\n-        synchronized (this) {\n-            state = true;\n-            if (waiting > 0) {\n-                notifyAll();\n-            }\n-        }\n-    }\n-\n-    public boolean getState() {\n-        synchronized (this) {\n-            return state;\n-        }\n-    }\n-\n-    public void setState(boolean newState) {\n-        synchronized (this) {\n-            state = newState;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Focus\/ConsumedTabKeyTest.java","additions":0,"deletions":232,"binary":false,"changes":232,"status":"deleted"},{"patch":"@@ -1,124 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 4846162 4626092\n-  @summary (Key|Window|Focus)Events should not be retargeted when dispatchEvent() is called directly.\n-  @run main EventRetargetTest\n-*\/\n-\n-import java.awt.AWTEvent;\n-import java.awt.Component;\n-import java.awt.Toolkit;\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.FocusAdapter;\n-import java.awt.event.FocusEvent;\n-import java.awt.event.KeyAdapter;\n-import java.awt.event.KeyEvent;\n-\n-public class EventRetargetTest {\n-    boolean isKEProcessed1;\n-    boolean isKEProcessed2;\n-    boolean isKEProcessed3;\n-    boolean isFEProcessed1;\n-    boolean isFEProcessed2;\n-    boolean isFEProcessed3;\n-\n-    public void start () {\n-        final Component comp = new Component() {\n-                public boolean isShowing() {\n-                    return true;\n-                }\n-\n-                public boolean isVisible() {\n-                    return true;\n-                }\n-\n-                public boolean isDisplayable() {\n-                    return true;\n-                }\n-\n-                protected void processKeyEvent(KeyEvent e) {\n-                    System.err.println(\"processKeyEvent >> \" + e);\n-                    isKEProcessed1 = true;\n-                    super.processKeyEvent(e);\n-                }\n-\n-                protected void processFocusEvent(FocusEvent e) {\n-                    System.err.println(\"processFocusEvent >> \" + e);\n-                    isFEProcessed1 = true;\n-                    super.processFocusEvent(e);\n-                }\n-            };\n-        Toolkit.getDefaultToolkit().addAWTEventListener(new AWTEventListener() {\n-                public void eventDispatched(AWTEvent e) {\n-                    if (e instanceof KeyEvent) {\n-                        isKEProcessed2 = (e.getSource() == comp);\n-                    }\n-                    else if (e instanceof FocusEvent) {\n-                        isFEProcessed2 = (e.getSource() == comp);\n-                    }\n-                    System.err.println(\"Toolkit >> \" + e);\n-                }\n-            }, AWTEvent.KEY_EVENT_MASK | AWTEvent.FOCUS_EVENT_MASK);\n-\n-        comp.addKeyListener(new KeyAdapter() {\n-                public void keyTyped(KeyEvent e) {\n-                    isKEProcessed3 = true;\n-                    System.err.println(\"Listener >> \" + e);\n-                }\n-            });\n-        comp.addFocusListener(new FocusAdapter() {\n-                public void focusGained(FocusEvent e) {\n-                    isFEProcessed3 = true;\n-                    System.err.println(\"Listener >> \" + e);\n-                }\n-            });\n-\n-        KeyEvent ke = new KeyEvent(comp, KeyEvent.KEY_TYPED, System.currentTimeMillis(), 0,\n-                                   KeyEvent.VK_UNDEFINED, 'a');\n-        comp.dispatchEvent(ke);\n-\n-        if (!(isKEProcessed1 && isKEProcessed2 && isKEProcessed3)) {\n-            System.err.println(\"(\" + isKEProcessed1 + \",\" + isKEProcessed2\n-                    + \",\" + isKEProcessed3 + \")\");\n-            throw new RuntimeException(\"KeyEvent is not correctly retargeted.\");\n-        }\n-\n-        FocusEvent fe = new FocusEvent(comp, FocusEvent.FOCUS_GAINED,\n-                                       false, null);\n-        comp.dispatchEvent(fe);\n-\n-        if (!(isFEProcessed1 && isFEProcessed2 && isFEProcessed3)) {\n-            System.err.println(\"(\" + isFEProcessed1 + \",\"\n-                    + isFEProcessed2 + \",\" + isFEProcessed3 + \")\");\n-            throw new RuntimeException(\"FocusEvent is not correctly retargeted.\");\n-        }\n-    }\n-\n-    public static void main(String[] args) {\n-        EventRetargetTest test = new EventRetargetTest();\n-        test.start();\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Focus\/EventRetargetTest.java","additions":0,"deletions":124,"binary":false,"changes":124,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 5072554\n-  @summary Tests that vetoing focus doesn't generate extra PropertyChange notification.\n-  @key headful\n-  @run main ExtraPropChangeNotifVetoingTest\n-*\/\n-\n-import java.awt.AWTException;\n-import java.awt.BorderLayout;\n-import java.awt.Button;\n-import java.awt.EventQueue;\n-import java.awt.FlowLayout;\n-import java.awt.Frame;\n-import java.awt.KeyboardFocusManager;\n-import java.awt.Panel;\n-import java.awt.Robot;\n-import java.beans.PropertyChangeEvent;\n-import java.beans.PropertyVetoException;\n-import java.beans.VetoableChangeListener;\n-import java.lang.reflect.InvocationTargetException;\n-\n-public class ExtraPropChangeNotifVetoingTest extends Panel {\n-    Button one = new Button(\"One\");\n-    Button two = new Button(\"Two\");\n-    Robot robot;\n-    static Frame frame;\n-\n-    int i = 0;\n-\n-    public void init() {\n-        try {\n-            robot = new Robot();\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"Error: unable to create robot\", e);\n-        }\n-\n-        setLayout(new FlowLayout());\n-        add(one);\n-        add(two);\n-\n-        KeyboardFocusManager.getCurrentKeyboardFocusManager().\n-                addVetoableChangeListener(\"permanentFocusOwner\",\n-                        new VetoableChangeListener() {\n-                    public void vetoableChange(PropertyChangeEvent e) throws PropertyVetoException {\n-                        System.out.println((i++) + \". Old=\" + e.getOldValue() + \", New=\" + e.getNewValue());\n-\n-                        if (e.getOldValue() == e.getNewValue()) {\n-                            throw new RuntimeException(\"Test failed!\");\n-                        }\n-\n-                        if (e.getNewValue() == two) {\n-                            System.out.println(\"VETOING\");\n-                            throw new PropertyVetoException(\"vetoed\", e);\n-                        }\n-                    }\n-                });\n-        setVisible(true);\n-    }\n-\n-    public void start() throws InterruptedException, InvocationTargetException {\n-        EventQueue.invokeAndWait(one::requestFocusInWindow);\n-        robot.waitForIdle();\n-        robot.delay(200);\n-        EventQueue.invokeAndWait(two::requestFocusInWindow);\n-        robot.waitForIdle();\n-        robot.delay(200);\n-    }\n-\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException {\n-        ExtraPropChangeNotifVetoingTest test = new ExtraPropChangeNotifVetoingTest();\n-        try {\n-            EventQueue.invokeAndWait(() -> {\n-                frame = new Frame(\"ExtraPropChangeNotifVetoingTest\");\n-                frame.setLayout(new BorderLayout());\n-                frame.add(test, BorderLayout.CENTER);\n-                test.init();\n-                frame.setLocationRelativeTo(null);\n-                frame.pack();\n-                frame.setVisible(true);\n-            });\n-            test.start();\n-        } finally {\n-            if (frame != null) {\n-                EventQueue.invokeAndWait(frame::dispose);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/Focus\/ExtraPropChangeNotifVetoingTest.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,127 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import javax.swing.JFrame;\n-import javax.swing.JPanel;\n-import javax.swing.JTree;\n-import java.awt.EventQueue;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import java.awt.Robot;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureEvent;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragSource;\n-import java.awt.event.InputEvent;\n-\n-\/*\n-  @test\n-  @bug 4273712 4396746\n-  @summary tests that mouse exit event doesn't trigger drag\n-  @key headful\n-  @run main MouseExitGestureTriggerTest\n-*\/\n-\n-public class MouseExitGestureTriggerTest {\n-\n-    boolean recognized = false;\n-    volatile JFrame frame;\n-    volatile JPanel panel;\n-    volatile JTree tree;\n-    volatile DragSource dragSource;\n-    volatile Point srcPoint;\n-    volatile Rectangle r;\n-    volatile DragGestureListener dgl;\n-    static final int FRAME_ACTIVATION_TIMEOUT = 2000;\n-    static final int RECOGNITION_TIMEOUT = 1000;\n-\n-    public static void main(String[] args) throws Exception {\n-        MouseExitGestureTriggerTest test = new MouseExitGestureTriggerTest();\n-        EventQueue.invokeAndWait(test::init);\n-        try {\n-            test.start();\n-        } finally {\n-            EventQueue.invokeAndWait(() -> {\n-                if (test.frame != null) {\n-                    test.frame.dispose();\n-                }\n-            });\n-        }\n-    }\n-\n-    public void init() {\n-        frame = new JFrame(\"MouseExitGestureTriggerTest\");\n-        panel = new JPanel();\n-        tree = new JTree();\n-\n-        dragSource = DragSource.getDefaultDragSource();\n-        dgl = new DragGestureListener() {\n-            public void dragGestureRecognized(DragGestureEvent dge) {\n-                Thread.dumpStack();\n-                recognized = true;\n-            }\n-        };\n-\n-        tree.setEditable(true);\n-        dragSource.createDefaultDragGestureRecognizer(tree,\n-                                                      DnDConstants.ACTION_MOVE,\n-                                                      dgl);\n-        panel.add(tree);\n-        frame.getContentPane().add(panel);\n-        frame.setLocation(200, 200);\n-\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public void start() throws Exception {\n-        final Robot robot = new Robot();\n-        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n-\n-        clickRootNode(robot);\n-        clickRootNode(robot);\n-        clickRootNode(robot);\n-\n-        Thread.sleep(RECOGNITION_TIMEOUT);\n-\n-        EventQueue.invokeAndWait(() -> {\n-            if (recognized) {\n-                throw new RuntimeException(\"Mouse exit event triggered drag\");\n-            }\n-        });\n-    }\n-\n-    void clickRootNode(final Robot robot) throws Exception {\n-        EventQueue.invokeAndWait(() -> {\n-            srcPoint = tree.getLocationOnScreen();\n-            r = tree.getRowBounds(0);\n-        });\n-        srcPoint.translate(r.x + 2 * r.width \/3 , r.y + r.height \/ 2);\n-        robot.mouseMove(srcPoint.x ,srcPoint.y);\n-\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        Thread.sleep(10);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        Thread.sleep(10);\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/dnd\/MouseExitGestureTriggerTest.java","additions":0,"deletions":127,"binary":false,"changes":127,"status":"deleted"},{"patch":"@@ -1,494 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.AWTEvent;\n-import java.awt.Component;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.Graphics;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.Toolkit;\n-import java.awt.datatransfer.DataFlavor;\n-import java.awt.datatransfer.SystemFlavorMap;\n-import java.awt.datatransfer.Transferable;\n-import java.awt.datatransfer.UnsupportedFlavorException;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureEvent;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragGestureRecognizer;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceAdapter;\n-import java.awt.dnd.DragSourceDropEvent;\n-import java.awt.dnd.DragSourceListener;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetContext;\n-import java.awt.dnd.DropTargetDragEvent;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.awt.dnd.DropTargetEvent;\n-import java.awt.dnd.DropTargetListener;\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-import java.awt.event.MouseEvent;\n-import java.io.ByteArrayInputStream;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.InputStreamReader;\n-import java.io.Reader;\n-\n-\/*\n-  @test\n-  @bug 4746177\n-  @summary tests that data types exported by Netscape 6.2 are supported\n-  @requires (os.family != \"windows\")\n-  @key headful\n-  @run main MozillaDnDTest\n-*\/\n-\n-public class MozillaDnDTest {\n-\n-    public static final int CODE_NOT_RETURNED = -1;\n-    public static final int CODE_OK = 0;\n-    public static final int CODE_FAILURE = 1;\n-    public static final String DATA = \"www.sun.com\";\n-\n-    private int returnCode = CODE_NOT_RETURNED;\n-\n-    volatile Frame frame;\n-    volatile Robot robot;\n-    volatile Panel panel;\n-    volatile Point p;\n-    volatile Dimension d;\n-\n-    public static void main(String[] args) throws Exception {\n-        MozillaDnDTest test = new MozillaDnDTest();\n-        if (args.length > 0) {\n-            test.run(args);\n-        } else {\n-            EventQueue.invokeAndWait(test::init);\n-            try {\n-                test.start();\n-            } finally {\n-                EventQueue.invokeAndWait(() -> {\n-                    if (test.frame != null) {\n-                        test.frame.dispose();\n-                    }\n-                });\n-            }\n-        }\n-    }\n-\n-    public void run(String[] args) {\n-        try {\n-            if (args.length != 4) {\n-                throw new RuntimeException(\"Incorrect command line arguments.\");\n-            }\n-\n-            int x = Integer.parseInt(args[0]);\n-            int y = Integer.parseInt(args[1]);\n-            int w = Integer.parseInt(args[2]);\n-            int h = Integer.parseInt(args[3]);\n-\n-            panel = new DragSourcePanel();\n-            frame = new Frame();\n-\n-            frame.setTitle(\"DragSource frame\");\n-            frame.setLocation(300, 200);\n-            frame.add(panel);\n-            frame.pack();\n-            frame.setVisible(true);\n-\n-            Util.waitForInit();\n-\n-            Point sourcePoint = panel.getLocationOnScreen();\n-            Dimension d = panel.getSize();\n-            sourcePoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-            Point targetPoint = new Point(x + w \/ 2, y + h \/ 2);\n-\n-            robot = new Robot();\n-\n-            if (!Util.pointInComponent(robot, sourcePoint, panel)) {\n-                System.err.println(\"WARNING: Couldn't locate \" + panel +\n-                                   \" at point \" + sourcePoint);\n-                System.exit(MozillaDnDTest.CODE_OK);\n-            }\n-\n-            robot.mouseMove(sourcePoint.x, sourcePoint.y);\n-            robot.keyPress(KeyEvent.VK_CONTROL);\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n-            for (; !sourcePoint.equals(targetPoint);\n-                 sourcePoint.translate(sign(targetPoint.x - sourcePoint.x),\n-                                       sign(targetPoint.y - sourcePoint.y))) {\n-                robot.mouseMove(sourcePoint.x, sourcePoint.y);\n-                Thread.sleep(50);\n-            }\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-            robot.keyRelease(KeyEvent.VK_CONTROL);\n-\n-        } catch (Throwable e) {\n-            e.printStackTrace();\n-            System.exit(MozillaDnDTest.CODE_FAILURE);\n-        }\n-    }\n-\n-    public static int sign(int n) {\n-        return n < 0 ? -1 : n == 0 ? 0 : 1;\n-    }\n-\n-    public void init() {\n-        frame = new Frame();\n-        panel = new DropTargetPanel();\n-\n-        frame.setTitle(\"DropTarget frame\");\n-        frame.setLocation(10, 200);\n-        frame.add(panel);\n-\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public void start() {\n-        \/\/ Solaris\/Linux-only test\n-        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-        try {\n-            Util.waitForInit();\n-            EventQueue.invokeAndWait(() -> {\n-                p = panel.getLocationOnScreen();\n-                d = panel.getSize();\n-            });\n-\n-            Robot robot = new Robot();\n-            Point pp = new Point(p);\n-            pp.translate(d.width \/ 2, d.height \/ 2);\n-            if (!Util.pointInComponent(robot, pp, panel)) {\n-                System.err.println(\"WARNING: Couldn't locate \" + panel +\n-                                   \" at point \" + pp);\n-                return;\n-            }\n-\n-            String javaPath = System.getProperty(\"java.home\", \"\");\n-            String command = javaPath + File.separator + \"bin\" +\n-                File.separator + \"java -cp \" + System.getProperty(\"test.classes\", \".\") +\n-                \" MozillaDnDTest \" +\n-                p.x + \" \" + p.y + \" \" + d.width + \" \" + d.height;\n-\n-            Process process = Runtime.getRuntime().exec(command);\n-            ProcessResults pres = ProcessResults.doWaitFor(process);\n-            returnCode = pres.exitValue;\n-\n-            if (pres.stderr != null && pres.stderr.length() > 0) {\n-                System.err.println(\"========= Child VM System.err ========\");\n-                System.err.print(pres.stderr);\n-                System.err.println(\"======================================\");\n-            }\n-\n-            if (pres.stdout != null && pres.stdout.length() > 0) {\n-                System.err.println(\"========= Child VM System.out ========\");\n-                System.err.print(pres.stdout);\n-                System.err.println(\"======================================\");\n-            }\n-\n-        } catch (Throwable e) {\n-            e.printStackTrace();\n-        }\n-        switch (returnCode) {\n-        case CODE_NOT_RETURNED:\n-            System.err.println(\"Child VM: failed to start\");\n-            break;\n-        case CODE_OK:\n-            System.err.println(\"Child VM: normal termination\");\n-            break;\n-        case CODE_FAILURE:\n-            System.err.println(\"Child VM: abnormal termination\");\n-            break;\n-        }\n-        if (returnCode != CODE_OK) {\n-            throw new RuntimeException(\"The test failed.\");\n-        }\n-    }\n-}\n-\n-class Util implements AWTEventListener {\n-    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n-    public static final Object SYNC_LOCK = new Object();\n-    private Component clickedComponent = null;\n-    private static final int PAINT_TIMEOUT = 10000;\n-    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n-    private static final Util util = new Util();\n-\n-    static {\n-        tk.addAWTEventListener(util, 0xFFFFFFFF);\n-    }\n-\n-    private void reset() {\n-        clickedComponent = null;\n-    }\n-\n-    public void eventDispatched(AWTEvent e) {\n-        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n-            clickedComponent = (Component)e.getSource();\n-            synchronized (SYNC_LOCK) {\n-                SYNC_LOCK.notifyAll();\n-            }\n-        }\n-    }\n-\n-    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        return util.isPointInComponent(robot, p, comp);\n-    }\n-\n-    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        tk.sync();\n-        robot.waitForIdle();\n-        reset();\n-        robot.mouseMove(p.x, p.y);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        synchronized (SYNC_LOCK) {\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n-        }\n-\n-        Component c = clickedComponent;\n-\n-        while (c != null && c != comp) {\n-            c = c.getParent();\n-        }\n-\n-        return c == comp;\n-    }\n-\n-    public static void waitForInit() throws InterruptedException {\n-        final Frame f = new Frame() {\n-                public void paint(Graphics g) {\n-                    dispose();\n-                    synchronized (SYNC_LOCK) {\n-                        SYNC_LOCK.notifyAll();\n-                    }\n-                }\n-            };\n-        f.setBounds(600, 400, 200, 200);\n-        synchronized (SYNC_LOCK) {\n-            f.setVisible(true);\n-            SYNC_LOCK.wait(PAINT_TIMEOUT);\n-        }\n-        tk.sync();\n-    }\n-}\n-\n-class ProcessResults {\n-    public int exitValue;\n-    public String stdout;\n-    public String stderr;\n-\n-    public ProcessResults() {\n-        exitValue = -1;\n-        stdout = \"\";\n-        stderr = \"\";\n-    }\n-\n-    \/**\n-     * Method to perform a \"wait\" for a process and return its exit value.\n-     * This is a workaround for <code>Process.waitFor()<\/code> never returning.\n-     *\/\n-    public static ProcessResults doWaitFor(Process p) {\n-        ProcessResults pres = new ProcessResults();\n-\n-        InputStream in = null;\n-        InputStream err = null;\n-\n-        try {\n-            in = p.getInputStream();\n-            err = p.getErrorStream();\n-\n-            boolean finished = false;\n-\n-            while (!finished) {\n-                try {\n-                    while (in.available() > 0) {\n-                        pres.stdout += (char)in.read();\n-                    }\n-                    while (err.available() > 0) {\n-                        pres.stderr += (char)err.read();\n-                    }\n-                    \/\/ Ask the process for its exitValue. If the process\n-                    \/\/ is not finished, an IllegalThreadStateException\n-                    \/\/ is thrown. If it is finished, we fall through and\n-                    \/\/ the variable finished is set to true.\n-                    pres.exitValue = p.exitValue();\n-                    finished = true;\n-                }\n-                catch (IllegalThreadStateException e) {\n-                    \/\/ Process is not finished yet;\n-                    \/\/ Sleep a little to save on CPU cycles\n-                    Thread.currentThread().sleep(500);\n-                }\n-            }\n-            if (in != null) in.close();\n-            if (err != null) err.close();\n-        }\n-        catch (Throwable e) {\n-            System.err.println(\"doWaitFor(): unexpected exception\");\n-            e.printStackTrace();\n-        }\n-        return pres;\n-    }\n-}\n-\n-class DragSourcePanel extends Panel {\n-    static final Dimension preferredDimension = new Dimension(200, 200);\n-    static final DataFlavor df = new DataFlavor(\"application\/mozilla-test-flavor\",\n-                                                null);\n-    final DragSource ds = DragSource.getDefaultDragSource();\n-    final Transferable t = new Transferable() {\n-            final DataFlavor[] flavors = new DataFlavor[] { df };\n-            public DataFlavor[] getTransferDataFlavors() {\n-                return flavors;\n-            }\n-            public boolean isDataFlavorSupported(DataFlavor flav) {\n-                return df.equals(flav);\n-            }\n-            public Object getTransferData(DataFlavor flav)\n-              throws IOException, UnsupportedFlavorException {\n-                if (!isDataFlavorSupported(flav)) {\n-                    throw new UnsupportedFlavorException(flav);\n-                }\n-                byte[] bytes = MozillaDnDTest.DATA.getBytes(\"ASCII\");\n-                return new ByteArrayInputStream(bytes);\n-            }\n-        };\n-    final DragSourceListener dsl = new DragSourceAdapter() {\n-            public void dragDropEnd(DragSourceDropEvent dsde) {\n-                System.exit(MozillaDnDTest.CODE_OK);\n-            }\n-        };\n-    final DragGestureListener dgl = new DragGestureListener() {\n-            public void dragGestureRecognized(DragGestureEvent dge) {\n-                dge.startDrag(null, t, dsl);\n-            }\n-        };\n-    final DragGestureRecognizer dgr =\n-        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n-                                              dgl);\n-    static {\n-        SystemFlavorMap sfm =\n-            (SystemFlavorMap)SystemFlavorMap.getDefaultFlavorMap();\n-        String[] natives = new String[] {\n-            \"_NETSCAPE_URL\",\n-            \"text\/plain\",\n-            \"text\/unicode\",\n-            \"text\/x-moz-url\",\n-            \"text\/html\"\n-        };\n-        sfm.setNativesForFlavor(df, natives);\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-}\n-\n-class DropTargetPanel extends Panel implements DropTargetListener {\n-\n-    final Dimension preferredDimension = new Dimension(200, 200);\n-    final DropTarget dt = new DropTarget(this, this);\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-\n-    public void dragEnter(DropTargetDragEvent dtde) {\n-        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n-    }\n-\n-    public void dragExit(DropTargetEvent dte) {}\n-\n-    public void dragOver(DropTargetDragEvent dtde) {\n-        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n-    }\n-\n-    public String getTransferString(Transferable t) {\n-        String string = null;\n-        DataFlavor[] dfs = t.getTransferDataFlavors();\n-        for (int i = 0; i < dfs.length; i++) {\n-            if (\"text\".equals(dfs[i].getPrimaryType()) ||\n-                DataFlavor.stringFlavor.equals(dfs[i])) {\n-                try {\n-                    Object o = t.getTransferData(dfs[i]);\n-                    if (o instanceof InputStream ||\n-                        o instanceof Reader) {\n-                        Reader reader = null;\n-                        if (o instanceof InputStream) {\n-                            InputStream is = (InputStream)o;\n-                            reader = new InputStreamReader(is);\n-                        } else {\n-                            reader = (Reader)o;\n-                        }\n-                        StringBuffer buf = new StringBuffer();\n-                        for (int c = reader.read(); c != -1; c = reader.read()) {\n-                            buf.append((char)c);\n-                        }\n-                        reader.close();\n-                        string = buf.toString();\n-                        break;\n-                    } else if (o instanceof String) {\n-                        string = (String)o;\n-                        break;\n-                    }\n-                } catch (Exception e) {\n-                    \/\/ ignore.\n-                }\n-            }\n-        }\n-        return string;\n-     }\n-\n-    public void drop(DropTargetDropEvent dtde) {\n-        DropTargetContext dtc = dtde.getDropTargetContext();\n-\n-        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n-            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n-        } else {\n-            dtde.rejectDrop();\n-            return;\n-        }\n-\n-        Transferable t = dtde.getTransferable();\n-        String str = getTransferString(t);\n-        dtde.dropComplete(true);\n-\n-        if (!MozillaDnDTest.DATA.equals(str)) {\n-            throw new RuntimeException(\"Drop data:\" + str);\n-        }\n-    }\n-\n-    public void dropActionChanged(DropTargetDragEvent dtde) {}\n-}\n","filename":"test\/jdk\/java\/awt\/dnd\/MozillaDnDTest.java","additions":0,"deletions":494,"binary":false,"changes":494,"status":"deleted"},{"patch":"@@ -1,415 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Button;\n-import java.awt.Color;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.GridLayout;\n-import java.awt.List;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.datatransfer.DataFlavor;\n-import java.awt.datatransfer.Transferable;\n-import java.awt.datatransfer.UnsupportedFlavorException;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureEvent;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceDragEvent;\n-import java.awt.dnd.DragSourceDropEvent;\n-import java.awt.dnd.DragSourceEvent;\n-import java.awt.dnd.DragSourceListener;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetContext;\n-import java.awt.dnd.DropTargetDragEvent;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.awt.dnd.DropTargetEvent;\n-import java.awt.dnd.DropTargetListener;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-import java.io.File;\n-import java.io.InputStream;\n-import java.io.Serializable;\n-\n-\/*\n-  @test\n-  @bug 4399700\n-  @summary tests that drop transfer data can be requested in several data flavors.\n-  @key headful\n-  @run main MultiDataFlavorDropTest\n-*\/\n-\n-public class MultiDataFlavorDropTest {\n-\n-    public static final int CODE_NOT_RETURNED = -1;\n-    public static final int CODE_OK = 0;\n-    public static final int CODE_FAILURE = 1;\n-    public static final int FRAME_ACTIVATION_TIMEOUT = 2000;\n-    public static final int DROP_TIMEOUT = 10000;\n-    public static final int DROP_COMPLETION_TIMEOUT = 1000;\n-\n-    private int returnCode = CODE_NOT_RETURNED;\n-\n-    volatile Frame frame;\n-    volatile Robot robot;\n-    volatile Panel panel;\n-    volatile Point p;\n-    volatile Dimension d;\n-\n-    public static void main(String[] args) throws Exception {\n-        MultiDataFlavorDropTest test = new MultiDataFlavorDropTest();\n-        if (args.length > 0) {\n-            test.run(args);\n-        } else {\n-            EventQueue.invokeAndWait(test::init);\n-            try {\n-                test.start();\n-            } finally {\n-                EventQueue.invokeAndWait(() -> {\n-                    if (test.frame != null) {\n-                        test.frame.dispose();\n-                    }\n-                });\n-            }\n-        }\n-    }\n-\n-    public void run(String[] args) {\n-        try {\n-            if (args.length != 4) {\n-                throw new RuntimeException(\"Incorrect command line arguments.\");\n-            }\n-\n-            int x = Integer.parseInt(args[0]);\n-            int y = Integer.parseInt(args[1]);\n-            int w = Integer.parseInt(args[2]);\n-            int h = Integer.parseInt(args[3]);\n-\n-            Transferable t = new TransferableNumber();\n-            panel = new DragSourcePanel(t);\n-\n-            frame = new Frame();\n-            frame.setTitle(\"DragSource frame\");\n-            frame.setLocation(300, 200);\n-            frame.add(panel);\n-            frame.pack();\n-            frame.setVisible(true);\n-\n-            Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n-\n-            Point sourcePoint = panel.getLocationOnScreen();\n-            Dimension d = panel.getSize();\n-            sourcePoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-            Point targetPoint = new Point(x + w \/ 2, y + h \/ 2);\n-\n-            robot = new Robot();\n-            robot.mouseMove(sourcePoint.x, sourcePoint.y);\n-            robot.keyPress(KeyEvent.VK_CONTROL);\n-            robot.mousePress(InputEvent.BUTTON1_MASK);\n-            for (; !sourcePoint.equals(targetPoint);\n-                 sourcePoint.translate(sign(targetPoint.x - sourcePoint.x),\n-                         sign(targetPoint.y - sourcePoint.y))) {\n-                robot.mouseMove(sourcePoint.x, sourcePoint.y);\n-                Thread.sleep(10);\n-            }\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-            robot.keyRelease(KeyEvent.VK_CONTROL);\n-\n-            synchronized (t) {\n-                t.wait(DROP_TIMEOUT);\n-            }\n-\n-            Thread.sleep(DROP_COMPLETION_TIMEOUT);\n-\n-        } catch (Throwable e) {\n-            e.printStackTrace();\n-            System.exit(MultiDataFlavorDropTest.CODE_FAILURE);\n-        }\n-        System.exit(MultiDataFlavorDropTest.CODE_OK);\n-    }\n-\n-    public static int sign(int n) {\n-        return n < 0 ? -1 : n == 0 ? 0 : 1;\n-    }\n-\n-    public void init() {\n-        frame = new Frame();\n-        panel = new DropTargetPanel();\n-\n-        frame.setTitle(\"MultiDataFlavorDropTest\");\n-        frame.setLocation(10, 200);\n-        frame.add(panel);\n-\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public void start() throws Exception {\n-        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n-\n-        EventQueue.invokeAndWait(() -> {\n-            p = panel.getLocationOnScreen();\n-            d = panel.getSize();\n-        });\n-\n-        String javaPath = System.getProperty(\"java.home\", \"\");\n-        String command = javaPath + File.separator + \"bin\" +\n-                File.separator + \"java -cp \" + System.getProperty(\"test.classes\", \".\") +\n-                \" MultiDataFlavorDropTest \" +\n-                p.x + \" \" + p.y + \" \" + d.width + \" \" + d.height;\n-\n-        Process process = Runtime.getRuntime().exec(command);\n-        returnCode = process.waitFor();\n-\n-        InputStream errorStream = process.getErrorStream();\n-        int count = errorStream.available();\n-        if (count > 0) {\n-            byte[] b = new byte[count];\n-            errorStream.read(b);\n-            System.err.println(\"========= Child VM System.err ========\");\n-            System.err.print(new String(b));\n-            System.err.println(\"======================================\");\n-        }\n-\n-        switch (returnCode) {\n-            case CODE_NOT_RETURNED:\n-                System.err.println(\"Child VM: failed to start\");\n-                break;\n-            case CODE_OK:\n-                System.err.println(\"Child VM: normal termination\");\n-                break;\n-            case CODE_FAILURE:\n-                System.err.println(\"Child VM: abnormal termination\");\n-                break;\n-        }\n-        if (returnCode != CODE_OK) {\n-            throw new RuntimeException(\"The test failed.\");\n-        }\n-    }\n-}\n-\n-class DragSourceButton extends Button implements Serializable,\n-                                                 DragGestureListener,\n-                                                 DragSourceListener {\n-\n-    final Transferable transferable;\n-\n-    public DragSourceButton(Transferable t) {\n-        super(\"DragSourceButton\");\n-\n-        this.transferable = t;\n-        DragSource ds = DragSource.getDefaultDragSource();\n-        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n-                                              this);\n-    }\n-\n-    public void dragGestureRecognized(DragGestureEvent dge) {\n-        dge.startDrag(null, transferable, this);\n-    }\n-\n-    public void dragEnter(DragSourceDragEvent dsde) {}\n-\n-    public void dragExit(DragSourceEvent dse) {}\n-\n-    public void dragOver(DragSourceDragEvent dsde) {}\n-\n-    public void dragDropEnd(DragSourceDropEvent dsde) {}\n-\n-    public void dropActionChanged(DragSourceDragEvent dsde) {}\n-}\n-\n-class IntegerDataFlavor extends DataFlavor {\n-\n-    private final int number;\n-\n-    public IntegerDataFlavor(int n) throws ClassNotFoundException {\n-        super(\"application\/integer-\" + n +\n-              \"; class=java.lang.Integer\");\n-        this.number = n;\n-    }\n-\n-    public int getNumber() {\n-        return number;\n-    }\n-}\n-\n-class TransferableNumber implements Transferable {\n-\n-    private int transferDataRequestCount = 0;\n-    public static final int NUM_DATA_FLAVORS = 5;\n-    static final DataFlavor[] supportedFlavors =\n-        new DataFlavor[NUM_DATA_FLAVORS];\n-\n-    static {\n-        try {\n-            for (int i = 0; i < NUM_DATA_FLAVORS; i++) {\n-                supportedFlavors[i] =\n-                    new IntegerDataFlavor(i);\n-            }\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    public DataFlavor[] getTransferDataFlavors() {\n-        return supportedFlavors;\n-    }\n-\n-    public boolean isDataFlavorSupported(DataFlavor flavor) {\n-        if (flavor instanceof IntegerDataFlavor) {\n-            IntegerDataFlavor integerFlavor = (IntegerDataFlavor)flavor;\n-            int flavorNumber = integerFlavor.getNumber();\n-            if (flavorNumber >= 0 && flavorNumber < NUM_DATA_FLAVORS) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    public Object getTransferData(DataFlavor flavor)\n-      throws UnsupportedFlavorException {\n-\n-        if (!isDataFlavorSupported(flavor)) {\n-            throw new UnsupportedFlavorException(flavor);\n-        }\n-\n-        transferDataRequestCount++;\n-\n-        if (transferDataRequestCount >= NUM_DATA_FLAVORS) {\n-            synchronized (this) {\n-                this.notifyAll();\n-            }\n-        }\n-\n-        IntegerDataFlavor integerFlavor = (IntegerDataFlavor)flavor;\n-        return new Integer(integerFlavor.getNumber());\n-    }\n-}\n-\n-class DragSourcePanel extends Panel {\n-\n-    final Dimension preferredDimension = new Dimension(200, 200);\n-\n-    public DragSourcePanel(Transferable t) {\n-        setLayout(new GridLayout(1, 1));\n-        add(new DragSourceButton(t));\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-}\n-\n-class DropTargetPanel extends Panel implements DropTargetListener {\n-\n-    final Dimension preferredDimension = new Dimension(200, 200);\n-\n-    public DropTargetPanel() {\n-        setBackground(Color.green);\n-        setDropTarget(new DropTarget(this, this));\n-        setLayout(new GridLayout(1, 1));\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-\n-    public void dragEnter(DropTargetDragEvent dtde) {\n-        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n-    }\n-\n-    public void dragExit(DropTargetEvent dte) {}\n-\n-    public void dragOver(DropTargetDragEvent dtde) {\n-        dtde.acceptDrag(DnDConstants.ACTION_COPY);\n-    }\n-\n-    public void drop(DropTargetDropEvent dtde) {\n-        DropTargetContext dtc = dtde.getDropTargetContext();\n-\n-        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n-            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n-        } else {\n-            dtde.rejectDrop();\n-            return;\n-        }\n-\n-        removeAll();\n-        final List list = new List();\n-        add(list);\n-\n-        Transferable t = dtde.getTransferable();\n-        DataFlavor[] dfs = t.getTransferDataFlavors();\n-\n-        if (dfs.length != TransferableNumber.NUM_DATA_FLAVORS) {\n-            throw new RuntimeException(\"FAILED: Incorrect number of data flavors.\");\n-        }\n-\n-        for (int i = 0; i < dfs.length; i++) {\n-\n-            DataFlavor flavor = dfs[i];\n-            Integer transferNumber = null;\n-\n-            if (flavor.getRepresentationClass().equals(Integer.class)) {\n-                try {\n-                    transferNumber = (Integer)t.getTransferData(flavor);\n-                } catch (Exception e) {\n-                    e.printStackTrace();\n-                    throw new RuntimeException(\"FAILED: Cannot get data: \" +\n-                                               flavor.getMimeType());\n-                }\n-            }\n-\n-            boolean supportedFlavor = false;\n-            for (int j = 0; j < TransferableNumber.NUM_DATA_FLAVORS; j++) {\n-                int number = (i + j) % TransferableNumber.NUM_DATA_FLAVORS;\n-                try {\n-                    if (flavor.equals(new IntegerDataFlavor(number))) {\n-                        if (!(new Integer(number).equals(transferNumber))) {\n-                            throw new RuntimeException(\"FAILED: Invalid data \\n\" +\n-                                                       \"\\tflavor : \" + flavor +\n-                                                       \"\\tdata   : \" + transferNumber);\n-                        }\n-                        supportedFlavor = true;\n-                        break;\n-                    }\n-                } catch (ClassNotFoundException cannotHappen) {\n-                }\n-            }\n-            if (!supportedFlavor) {\n-                throw new RuntimeException(\"FAILED: Invalid flavor: \" + flavor);\n-            }\n-\n-            list.add(transferNumber + \":\" + flavor.getMimeType());\n-        }\n-\n-        dtc.dropComplete(true);\n-        validate();\n-    }\n-\n-    public void dropActionChanged(DropTargetDragEvent dtde) {}\n-}\n","filename":"test\/jdk\/java\/awt\/dnd\/MultiDataFlavorDropTest.java","additions":0,"deletions":415,"binary":false,"changes":415,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.Label;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.datatransfer.DataFlavor;\n-import java.awt.datatransfer.Transferable;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetContext;\n-import java.awt.dnd.DropTargetDragEvent;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.awt.dnd.DropTargetEvent;\n-import java.awt.dnd.DropTargetListener;\n-import java.awt.event.InputEvent;\n-\n-\/*\n-  @test\n-  @bug 4399700\n-  @summary tests that Motif drag support for label widget doesn't cause\n-           crash when used for drag and drop from label to Java drop target\n-  @key headful\n-  @run main NativeDragJavaDropTest\n-*\/\n-\n-public class NativeDragJavaDropTest {\n-\n-    volatile Frame frame;\n-    volatile DropTargetLabel label;\n-    volatile Point p;\n-    volatile Dimension d;\n-    public static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n-    public static final int DRAG_START_TIMEOUT = 500;\n-    public static final int DROP_COMPLETION_TIMEOUT = 2000;\n-\n-    public static void main(String[] args) throws Exception {\n-        NativeDragJavaDropTest test = new NativeDragJavaDropTest();\n-        EventQueue.invokeAndWait(test::init);\n-        try {\n-            test.start();\n-        } finally {\n-            EventQueue.invokeAndWait(() -> {\n-                if (test.frame != null) {\n-                    test.frame.dispose();\n-                }\n-            });\n-        }\n-    }\n-\n-    public void init() {\n-        frame = new Frame();\n-        label = new DropTargetLabel();\n-        frame.setTitle(\"NativeDragJavaDropTest\");\n-        frame.setLocation(200, 200);\n-        frame.add(label);\n-\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public void start() throws Exception {\n-        Robot robot = new Robot();\n-        robot.waitForIdle();\n-        Thread.sleep(FRAME_ACTIVATION_TIMEOUT);\n-\n-        EventQueue.invokeAndWait(() -> {\n-            p = label.getLocationOnScreen();\n-            d = label.getSize();\n-        });\n-\n-        p.translate(d.width \/ 2, d.height \/ 2);\n-\n-        robot.mouseMove(p.x, p.y);\n-        robot.mousePress(InputEvent.BUTTON2_MASK);\n-\n-        Thread.sleep(DRAG_START_TIMEOUT);\n-\n-        robot.mouseRelease(InputEvent.BUTTON2_MASK);\n-\n-        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n-    }\n-}\n-\n-class DropTargetLabel extends Label implements DropTargetListener {\n-\n-    final Dimension preferredDimension = new Dimension(200, 100);\n-\n-    public DropTargetLabel() {\n-        super(\"Label\");\n-        setDropTarget(new DropTarget(this, this));\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-\n-    public void dragEnter(DropTargetDragEvent dtde) {}\n-\n-    public void dragExit(DropTargetEvent dte) {}\n-\n-    public void dragOver(DropTargetDragEvent dtde) {}\n-\n-    public void dropActionChanged(DropTargetDragEvent dtde) {}\n-\n-    public void drop(DropTargetDropEvent dtde) {\n-        DropTargetContext dtc = dtde.getDropTargetContext();\n-\n-        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n-            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n-        } else {\n-            dtde.rejectDrop();\n-        }\n-\n-        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n-\n-        if (dfs != null && dfs.length >= 1) {\n-            Transferable transfer = dtde.getTransferable();\n-\n-            try {\n-                Object obj = (Object)transfer.getTransferData(dfs[0]);\n-            } catch (Throwable e) {\n-                e.printStackTrace();\n-                dtc.dropComplete(false);\n-            }\n-        }\n-        dtc.dropComplete(true);\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/dnd\/NativeDragJavaDropTest.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,492 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.awt.AWTEvent;\n-import java.awt.BorderLayout;\n-import java.awt.Button;\n-import java.awt.Color;\n-import java.awt.Component;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.Graphics;\n-import java.awt.GridLayout;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.Toolkit;\n-import java.awt.datatransfer.DataFlavor;\n-import java.awt.datatransfer.Transferable;\n-import java.awt.datatransfer.UnsupportedFlavorException;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureEvent;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceDragEvent;\n-import java.awt.dnd.DragSourceDropEvent;\n-import java.awt.dnd.DragSourceEvent;\n-import java.awt.dnd.DragSourceListener;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetContext;\n-import java.awt.dnd.DropTargetDragEvent;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.awt.dnd.DropTargetEvent;\n-import java.awt.dnd.DropTargetListener;\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-import java.awt.event.MouseEvent;\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.ObjectInputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.Serializable;\n-\n-\/*\n-  @test\n-  @bug 4389284\n-  @summary tests that drop targets registered on nested heavyweight\n-           components work properly\n-  @key headful\n-  @run main NestedHeavyweightDropTargetTest\n-*\/\n-\n-public class NestedHeavyweightDropTargetTest {\n-\n-    volatile Frame frame;\n-    volatile DragSourceButton dragSourceButton;\n-    volatile DropTargetPanel dropTargetPanel;\n-    volatile InnerDropTargetPanel innerDropTargetPanel;\n-    volatile Button button;\n-    volatile Dimension d;\n-    volatile Point srcPoint;\n-    volatile Point dstPoint;\n-\n-    static final int DROP_COMPLETION_TIMEOUT = 1000;\n-\n-    public static void main(String[] args) throws Exception {\n-        NestedHeavyweightDropTargetTest test = new NestedHeavyweightDropTargetTest();\n-        EventQueue.invokeAndWait(test::init);\n-        try {\n-            test.start();\n-        } finally {\n-            EventQueue.invokeAndWait(() -> {\n-                if (test.frame != null) {\n-                    test.frame.dispose();\n-                }\n-            });\n-        }\n-    }\n-\n-    public void init() {\n-        frame = new Frame();\n-        dragSourceButton = new DragSourceButton();\n-        dropTargetPanel = new DropTargetPanel();\n-        innerDropTargetPanel = new InnerDropTargetPanel();\n-        button = new Button(\"button\");\n-        button.setBackground(Color.red);\n-\n-        innerDropTargetPanel.setLayout(new GridLayout(3, 1));\n-        innerDropTargetPanel.add(button);\n-        innerDropTargetPanel.setBackground(Color.yellow);\n-\n-        dropTargetPanel.setLayout(new GridLayout(2, 1));\n-        dropTargetPanel.add(innerDropTargetPanel);\n-        dropTargetPanel.setBackground(Color.green);\n-\n-        frame.setTitle(\"NestedHeavyweightDropTargetTest\");\n-        frame.setLocation(200, 200);\n-        frame.setLayout(new BorderLayout());\n-        frame.add(dropTargetPanel, BorderLayout.CENTER);\n-        frame.add(dragSourceButton, BorderLayout.SOUTH);\n-\n-        frame.pack();\n-\n-        innerDropTargetPanel.setDropTarget(new DropTarget(innerDropTargetPanel, innerDropTargetPanel));\n-        dropTargetPanel.setDropTarget(new DropTarget(dropTargetPanel, dropTargetPanel));\n-\n-        frame.setVisible(true);\n-    }\n-\n-    public void start() throws Exception {\n-        Robot robot = new Robot();\n-        Util.waitForInit();\n-\n-        test1(robot);\n-        test2(robot);\n-    }\n-\n-    public static int sign(int n) {\n-        return n < 0 ? -1 : n == 0 ? 0 : 1;\n-    }\n-\n-    public void test1(Robot robot) throws Exception {\n-        innerDropTargetPanel.setDragEnterTriggered(false);\n-        innerDropTargetPanel.setDragOverTriggered(false);\n-        innerDropTargetPanel.setDragExitTriggered(false);\n-        innerDropTargetPanel.setDropTriggered(false);\n-\n-        EventQueue.invokeAndWait(() -> {\n-            srcPoint = dragSourceButton.getLocationOnScreen();\n-            d = dragSourceButton.getSize();\n-        });\n-\n-        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-        if (!Util.pointInComponent(robot, srcPoint, dragSourceButton)) {\n-            System.err.println(\"WARNING: Couldn't locate \" + dragSourceButton +\n-                               \" at point \" + srcPoint);\n-            return;\n-        }\n-\n-        EventQueue.invokeAndWait(() -> {\n-            dstPoint = innerDropTargetPanel.getLocationOnScreen();\n-            d = innerDropTargetPanel.getSize();\n-        });\n-\n-        dstPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-        if (!Util.pointInComponent(robot, dstPoint, innerDropTargetPanel)) {\n-            System.err.println(\"WARNING: Couldn't locate \" + innerDropTargetPanel +\n-                               \" at point \" + dstPoint);\n-            return;\n-        }\n-\n-        robot.mouseMove(srcPoint.x, srcPoint.y);\n-        robot.keyPress(KeyEvent.VK_CONTROL);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        for (;!srcPoint.equals(dstPoint);\n-             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n-                                sign(dstPoint.y - srcPoint.y))) {\n-            robot.mouseMove(srcPoint.x, srcPoint.y);\n-            Thread.sleep(10);\n-        }\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        robot.keyRelease(KeyEvent.VK_CONTROL);\n-\n-        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n-\n-        if (!innerDropTargetPanel.isDragEnterTriggered()) {\n-            throw new RuntimeException(\"child dragEnter() not triggered\");\n-        }\n-\n-        if (!innerDropTargetPanel.isDragOverTriggered()) {\n-            throw new RuntimeException(\"child dragOver() not triggered\");\n-        }\n-\n-        if (!innerDropTargetPanel.isDropTriggered()) {\n-            throw new RuntimeException(\"child drop() not triggered\");\n-        }\n-    }\n-\n-    public void test2(Robot robot) throws Exception {\n-        innerDropTargetPanel.setDragEnterTriggered(false);\n-        innerDropTargetPanel.setDragOverTriggered(false);\n-        innerDropTargetPanel.setDragExitTriggered(false);\n-        innerDropTargetPanel.setDropTriggered(false);\n-\n-        EventQueue.invokeAndWait(() -> {\n-            srcPoint = dragSourceButton.getLocationOnScreen();\n-            d = dragSourceButton.getSize();\n-        });\n-        srcPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-        if (!Util.pointInComponent(robot, srcPoint, dragSourceButton)) {\n-            System.err.println(\"WARNING: Couldn't locate \" + dragSourceButton +\n-                               \" at point \" + srcPoint);\n-            return;\n-        }\n-\n-        EventQueue.invokeAndWait(() -> {\n-            dstPoint = button.getLocationOnScreen();\n-            d = button.getSize();\n-        });\n-\n-        dstPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-        if (!Util.pointInComponent(robot, dstPoint, button)) {\n-            System.err.println(\"WARNING: Couldn't locate \" + button +\n-                               \" at point \" + dstPoint);\n-            return;\n-        }\n-\n-        robot.mouseMove(srcPoint.x, srcPoint.y);\n-        robot.keyPress(KeyEvent.VK_CONTROL);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        for (;!srcPoint.equals(dstPoint);\n-             srcPoint.translate(sign(dstPoint.x - srcPoint.x),\n-                                sign(dstPoint.y - srcPoint.y))) {\n-            robot.mouseMove(srcPoint.x, srcPoint.y);\n-            Thread.sleep(10);\n-        }\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        robot.keyRelease(KeyEvent.VK_CONTROL);\n-\n-        Thread.sleep(DROP_COMPLETION_TIMEOUT);\n-\n-        if (!innerDropTargetPanel.isDragEnterTriggered()) {\n-            throw new RuntimeException(\"child dragEnter() not triggered\");\n-        }\n-\n-        if (!innerDropTargetPanel.isDragOverTriggered()) {\n-            throw new RuntimeException(\"child dragOver() not triggered\");\n-        }\n-\n-        if (!innerDropTargetPanel.isDropTriggered()) {\n-            throw new RuntimeException(\"child drop() not triggered\");\n-        }\n-    }\n-}\n-\n-class Util implements AWTEventListener {\n-    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n-    public static final Object SYNC_LOCK = new Object();\n-    private Component clickedComponent = null;\n-    private static final int PAINT_TIMEOUT = 10000;\n-    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n-    private static final Util util = new Util();\n-\n-    static {\n-        tk.addAWTEventListener(util, 0xFFFFFFFF);\n-    }\n-\n-    private void reset() {\n-        clickedComponent = null;\n-    }\n-\n-    public void eventDispatched(AWTEvent e) {\n-        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n-            clickedComponent = (Component)e.getSource();\n-            synchronized (SYNC_LOCK) {\n-                SYNC_LOCK.notifyAll();\n-            }\n-        }\n-    }\n-\n-    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        return util.isPointInComponent(robot, p, comp);\n-    }\n-\n-    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        tk.sync();\n-        robot.waitForIdle();\n-        reset();\n-        robot.mouseMove(p.x, p.y);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        synchronized (SYNC_LOCK) {\n-            robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n-        }\n-\n-        Component c = clickedComponent;\n-\n-        while (c != null && c != comp) {\n-            c = c.getParent();\n-        }\n-\n-        return c == comp;\n-    }\n-\n-    public static void waitForInit() throws InterruptedException {\n-        final Frame f = new Frame() {\n-                public void paint(Graphics g) {\n-                    dispose();\n-                    synchronized (SYNC_LOCK) {\n-                        SYNC_LOCK.notifyAll();\n-                    }\n-                }\n-            };\n-        f.setBounds(600, 400, 200, 200);\n-        synchronized (SYNC_LOCK) {\n-            f.setVisible(true);\n-            SYNC_LOCK.wait(PAINT_TIMEOUT);\n-        }\n-        tk.sync();\n-    }\n-}\n-\n-class DragSourceButton extends Button implements Serializable,\n-                                                 Transferable,\n-                                                 DragGestureListener,\n-                                                 DragSourceListener {\n-    private final DataFlavor dataflavor =\n-        new DataFlavor(Button.class, \"DragSourceButton\");\n-\n-    public DragSourceButton() {\n-        this(\"DragSourceButton\");\n-    }\n-\n-    public DragSourceButton(String str) {\n-        super(str);\n-\n-        DragSource ds = DragSource.getDefaultDragSource();\n-        ds.createDefaultDragGestureRecognizer(this, DnDConstants.ACTION_COPY,\n-                                              this);\n-    }\n-\n-    public void dragGestureRecognized(DragGestureEvent dge) {\n-        dge.startDrag(null, this, this);\n-    }\n-\n-    public void dragEnter(DragSourceDragEvent dsde) {}\n-\n-    public void dragExit(DragSourceEvent dse) {}\n-\n-    public void dragOver(DragSourceDragEvent dsde) {}\n-\n-    public void dragDropEnd(DragSourceDropEvent dsde) {}\n-\n-    public void dropActionChanged(DragSourceDragEvent dsde) {}\n-\n-    public Object getTransferData(DataFlavor flavor)\n-      throws UnsupportedFlavorException, IOException {\n-\n-        if (!isDataFlavorSupported(flavor)) {\n-            throw new UnsupportedFlavorException(flavor);\n-        }\n-\n-        Object retObj = null;\n-\n-        ByteArrayOutputStream baoStream = new ByteArrayOutputStream();\n-        ObjectOutputStream ooStream = new ObjectOutputStream(baoStream);\n-        ooStream.writeObject(this);\n-\n-        ByteArrayInputStream baiStream = new ByteArrayInputStream(baoStream.toByteArray());\n-        ObjectInputStream ois = new ObjectInputStream(baiStream);\n-        try {\n-            retObj = ois.readObject();\n-        } catch (ClassNotFoundException e) {\n-            e.printStackTrace();\n-            throw new RuntimeException(e.toString());\n-        }\n-\n-        return retObj;\n-    }\n-\n-    public DataFlavor[] getTransferDataFlavors() {\n-        return new DataFlavor[] { dataflavor };\n-    }\n-\n-    public boolean isDataFlavorSupported(DataFlavor dflavor) {\n-        return dataflavor.equals(dflavor);\n-    }\n-}\n-\n-class InnerDropTargetPanel extends DropTargetPanel {\n-    private boolean dragEnterTriggered = false;\n-    private boolean dragOverTriggered = false;\n-    private boolean dragExitTriggered = false;\n-    private boolean dropTriggered = false;\n-\n-    public void dragEnter(DropTargetDragEvent dtde) {\n-        setDragEnterTriggered(true);\n-    }\n-\n-    public void dragExit(DropTargetEvent dte) {\n-        setDragExitTriggered(true);\n-    }\n-\n-    public void dragOver(DropTargetDragEvent dtde) {\n-        setDragOverTriggered(true);\n-    }\n-\n-    public void dropActionChanged(DropTargetDragEvent dtde) {}\n-\n-    public void drop(DropTargetDropEvent dtde) {\n-        setDropTriggered(true);\n-        dtde.rejectDrop();\n-    }\n-\n-    public boolean isDragEnterTriggered() {\n-        return dragEnterTriggered;\n-    }\n-\n-    public boolean isDragOverTriggered() {\n-        return dragOverTriggered;\n-    }\n-\n-    public boolean isDragExitTriggered() {\n-        return dragExitTriggered;\n-    }\n-\n-    public boolean isDropTriggered() {\n-        return dropTriggered;\n-    }\n-\n-    public void setDragEnterTriggered(boolean b) {\n-        dragEnterTriggered = b;\n-    }\n-\n-    public void setDragOverTriggered(boolean b) {\n-        dragOverTriggered = b;\n-    }\n-\n-    public void setDragExitTriggered(boolean b) {\n-        dragExitTriggered = b;\n-    }\n-\n-    public void setDropTriggered(boolean b) {\n-        dropTriggered = b;\n-    }\n-}\n-\n-class DropTargetPanel extends Panel implements DropTargetListener {\n-\n-    public void dragEnter(DropTargetDragEvent dtde) {}\n-\n-    public void dragExit(DropTargetEvent dte) {}\n-\n-    public void dragOver(DropTargetDragEvent dtde) {}\n-\n-    public void dropActionChanged(DropTargetDragEvent dtde) {}\n-\n-    public void drop(DropTargetDropEvent dtde) {\n-        DropTargetContext dtc = dtde.getDropTargetContext();\n-\n-        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n-            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n-        } else {\n-            dtde.rejectDrop();\n-        }\n-\n-        DataFlavor[] dfs = dtde.getCurrentDataFlavors();\n-        Component comp = null;\n-\n-        if (dfs != null && dfs.length >= 1) {\n-            Transferable transfer = dtde.getTransferable();\n-\n-            try {\n-                comp = (Component)transfer.getTransferData(dfs[0]);\n-            } catch (Throwable e) {\n-                e.printStackTrace();\n-                dtc.dropComplete(false);\n-            }\n-        }\n-        dtc.dropComplete(true);\n-\n-        add(comp);\n-    }\n-}\n","filename":"test\/jdk\/java\/awt\/dnd\/NestedHeavyweightDropTargetTest.java","additions":0,"deletions":492,"binary":false,"changes":492,"status":"deleted"},{"patch":"@@ -1,203 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 4887150\n-  @summary tests that after performing COPY drop, MOVE drop can be performed too\n-  @key headful\n-  @run main NextDropActionTest\n-*\/\n-\n-import java.awt.AWTException;\n-import java.awt.Component;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.datatransfer.StringSelection;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceAdapter;\n-import java.awt.dnd.DragSourceDropEvent;\n-import java.awt.dnd.DragSourceListener;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetAdapter;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.awt.dnd.DropTargetListener;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-import java.lang.reflect.InvocationTargetException;\n-\n-\n-public class NextDropActionTest {\n-    private final long WAIT_TIMEOUT = 30000;\n-    private volatile boolean failed;\n-    private volatile boolean firstEnd;\n-    private volatile boolean secondEnd;\n-    private final Object LOCK = new Object();\n-    private Frame frame;\n-    private Panel panel;\n-\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException, AWTException {\n-        NextDropActionTest nextDropActionTest = new NextDropActionTest();\n-        nextDropActionTest.start();\n-    }\n-\n-    public void start() throws InterruptedException,\n-            InvocationTargetException, AWTException {\n-\n-        EventQueue.invokeAndWait(() -> {\n-            panel = new Panel();\n-            frame = new Frame(\"NextDropActionTest\");\n-            frame.add(panel);\n-            frame.setBounds(300, 300, 300, 300);\n-            frame.setLocationRelativeTo(null);\n-            frame.setVisible(true);\n-            frame.validate();\n-        });\n-\n-        try {\n-            Robot robot = new Robot();\n-            robot.waitForIdle();\n-            robot.delay(1000);\n-\n-            final DragSourceListener dsl = new DragSourceAdapter() {\n-                boolean firstCall = true;\n-                public void dragDropEnd(DragSourceDropEvent e) {\n-                    System.err.println(\"DragSourseListener.dragDropEnd(): \" +\n-                            \" firstCall=\" + firstCall +\n-                            \" drop action=\" + e.getDropAction());\n-                    if (firstCall) {\n-                        firstCall = false;\n-                        synchronized (LOCK) {\n-                            firstEnd = true;\n-                            LOCK.notifyAll();\n-                        }\n-                        return;\n-                    }\n-                    if (e.getDropAction() != DnDConstants.ACTION_MOVE) {\n-                        System.err.println(\"FAILURE: wrong drop action:\"\n-                                + e.getDropAction());\n-                        failed = true;\n-                    }\n-                    synchronized (LOCK) {\n-                        secondEnd = true;\n-                        LOCK.notifyAll();\n-                    }\n-                }\n-            };\n-\n-            DragGestureListener dgl = dge ->\n-                    dge.startDrag(null, new StringSelection(\"test\"), dsl);\n-\n-            new DragSource().createDefaultDragGestureRecognizer(panel,\n-                    DnDConstants.ACTION_COPY_OR_MOVE, dgl);\n-\n-            DropTargetListener dtl = new DropTargetAdapter() {\n-                public void drop(DropTargetDropEvent e) {\n-                    System.err.println(\"DropTargetListener.drop(): \" +\n-                            \"accepting the user drop action=\" + e.getDropAction());\n-                    e.acceptDrop(e.getDropAction());\n-                    e.dropComplete(true);\n-                }\n-            };\n-\n-            new DropTarget(frame, DnDConstants.ACTION_COPY_OR_MOVE, dtl);\n-\n-            Point startPoint = new Point(Util.blockTillDisplayed(panel));\n-            startPoint.translate(50, 50);\n-            Point endPoint = new Point(startPoint.x\n-                    + DragSource.getDragThreshold() + 10,\n-                    startPoint.y + DragSource.getDragThreshold() + 10);\n-\n-            synchronized (LOCK) {\n-                robot.keyPress(KeyEvent.VK_CONTROL);\n-                Util.doDragDrop(robot, startPoint, endPoint);\n-                robot.keyRelease(KeyEvent.VK_CONTROL);\n-                LOCK.wait(WAIT_TIMEOUT);\n-            }\n-            if (!firstEnd) {\n-                System.err.println(\"DragSourseListener.dragDropEnd() \" +\n-                        \"was not called, returning\");\n-                return;\n-            }\n-\n-            synchronized (LOCK) {\n-                Util.doDragDrop(robot, startPoint, endPoint);\n-                LOCK.wait(WAIT_TIMEOUT);\n-            }\n-            if (!secondEnd) {\n-                System.err.println(\"DragSourseListener.dragDropEnd() \" +\n-                        \"was not called, returning\");\n-                return;\n-            }\n-        } finally {\n-            if (frame != null) {\n-                EventQueue.invokeAndWait(() -> frame.dispose());\n-            }\n-        }\n-\n-        if (failed) {\n-            throw new RuntimeException(\"wrong next drop action!\");\n-        }\n-\n-        System.err.println(\"test passed!\");\n-     }\n-}\n-\n-class Util {\n-    public static int sign(int n) {\n-        return n < 0 ? -1 : n == 0 ? 0 : 1;\n-    }\n-\n-    public static void doDragDrop(Robot robot, Point startPoint, Point endPoint) {\n-       robot.mouseMove(startPoint.x, startPoint.y);\n-       robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-       for (Point p = new Point(startPoint); !p.equals(endPoint);\n-                p.translate(Util.sign(endPoint.x - p.x),\n-                            Util.sign(endPoint.y - p.y))) {\n-           robot.mouseMove(p.x, p.y);\n-           robot.delay(100);\n-       }\n-       robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-    }\n-\n-    public static Point blockTillDisplayed(Component comp) {\n-        Point p = null;\n-        while (p == null) {\n-            try {\n-                p = comp.getLocationOnScreen();\n-            } catch (IllegalStateException e) {\n-                try {\n-                    Thread.sleep(1000);\n-                } catch (InterruptedException ie) {\n-                }\n-            }\n-        }\n-        return p;\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/dnd\/NextDropActionTest\/NextDropActionTest.java","additions":0,"deletions":203,"binary":false,"changes":203,"status":"deleted"},{"patch":"@@ -1,225 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 4702735\n-  @summary tests that a dragEnter is called even if the source doesn't\n-           export data in native formats.\n-  @key headful\n-  @run main NoFormatsDragEnterTest\n-*\/\n-\n-import java.awt.AWTException;\n-import java.awt.Canvas;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.GridLayout;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.datatransfer.DataFlavor;\n-import java.awt.datatransfer.Transferable;\n-import java.awt.datatransfer.UnsupportedFlavorException;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureEvent;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceAdapter;\n-import java.awt.dnd.DragSourceListener;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetDragEvent;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.awt.dnd.DropTargetEvent;\n-import java.awt.dnd.DropTargetListener;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-\n-\n-public class NoFormatsDragEnterTest {\n-\n-    Frame frame;\n-    DragSourcePanel dragSourcePanel;\n-    DropTargetPanel dropTargetPanel;\n-\n-    static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n-    static final int DROP_COMPLETION_TIMEOUT = 1000;\n-\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException, AWTException {\n-        NoFormatsDragEnterTest noFormatsDragEnterTest = new NoFormatsDragEnterTest();\n-        EventQueue.invokeAndWait(noFormatsDragEnterTest::init);\n-        noFormatsDragEnterTest.start();\n-    }\n-\n-    public void init() {\n-        frame = new Frame();\n-        dragSourcePanel = new DragSourcePanel();\n-        dropTargetPanel = new DropTargetPanel();\n-\n-        frame.setTitle(\"NoFormatsDragEnterTest\");\n-        frame.setLayout(new GridLayout(2, 1));\n-        frame.add(dragSourcePanel);\n-        frame.add(dropTargetPanel);\n-        frame.pack();\n-        frame.setLocationRelativeTo(null);\n-        frame.setVisible(true);\n-        frame.validate();\n-    }\n-\n-    public void start() throws AWTException, InterruptedException,\n-            InvocationTargetException {\n-        try {\n-            Robot robot = new Robot();\n-            robot.waitForIdle();\n-            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n-\n-            final Point srcPoint = dragSourcePanel.getLocationOnScreen();\n-            Dimension d = dragSourcePanel.getSize();\n-            srcPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-            final Point dstPoint = dropTargetPanel.getLocationOnScreen();\n-            d = dropTargetPanel.getSize();\n-            dstPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-            robot.mouseMove(srcPoint.x, srcPoint.y);\n-            robot.keyPress(KeyEvent.VK_CONTROL);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            for (Point curPoint = new Point(srcPoint);\n-                 !curPoint.equals(dstPoint);\n-                 curPoint.translate(sign(dstPoint.x - curPoint.x),\n-                                    sign(dstPoint.y - curPoint.y))) {\n-                robot.mouseMove(curPoint.x, curPoint.y);\n-                robot.delay(100);\n-            }\n-            robot.keyRelease(KeyEvent.VK_CONTROL);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            robot.delay(DROP_COMPLETION_TIMEOUT);\n-        } finally {\n-            if (frame != null) {\n-                EventQueue.invokeAndWait(() -> frame.dispose());\n-            }\n-        }\n-\n-        if (!dropTargetPanel.passed()) {\n-            throw new RuntimeException(\"Drop doesn't happen.\");\n-        }\n-    }\n-\n-    public static int sign(int n) {\n-        return n < 0 ? -1 : n > 0 ? 1 : 0;\n-    }\n-}\n-\n-class DragSourcePanel extends Canvas implements DragGestureListener {\n-\n-    private final Dimension preferredDimension = new Dimension(200, 100);\n-    private final DragSourceListener listener = new DragSourceAdapter() {};\n-\n-    public DragSourcePanel() {\n-        DragSource ds = DragSource.getDefaultDragSource();\n-        ds.createDefaultDragGestureRecognizer(this,\n-                                              DnDConstants.ACTION_COPY_OR_MOVE,\n-                                              this);\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-\n-    public void dragGestureRecognized(DragGestureEvent dge) {\n-        dge.startDrag(null, new TestTransferable(), listener);\n-    }\n-}\n-\n-class TestTransferable implements Transferable {\n-\n-    public static DataFlavor dataFlavor = null;\n-    static final Object data = new Object();\n-\n-    static {\n-        DataFlavor df = null;\n-        try {\n-            df = new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType +\n-                                \"; class=java.lang.Object\");\n-        } catch (ClassNotFoundException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-        dataFlavor = df;\n-    }\n-\n-    public DataFlavor[] getTransferDataFlavors() {\n-        return new DataFlavor[] { dataFlavor };\n-    }\n-\n-    public boolean isDataFlavorSupported(DataFlavor df) {\n-        return dataFlavor.equals(df);\n-    }\n-\n-    public Object getTransferData(DataFlavor df)\n-      throws UnsupportedFlavorException, IOException {\n-        if (!isDataFlavorSupported(df)) {\n-            throw new UnsupportedFlavorException(df);\n-        }\n-        return data;\n-    }\n-}\n-\n-class DropTargetPanel extends Canvas implements DropTargetListener {\n-\n-    private final Dimension preferredDimension = new Dimension(200, 100);\n-    private boolean dragEnterTriggered = false;\n-    private boolean dragOverTriggered = false;\n-\n-    public DropTargetPanel() {\n-        setDropTarget(new DropTarget(this, this));\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-\n-    public void dragEnter(DropTargetDragEvent dtde) {\n-        dragEnterTriggered = true;\n-    }\n-\n-    public void dragExit(DropTargetEvent dte) {}\n-\n-    public void dragOver(DropTargetDragEvent dtde) {\n-        dragOverTriggered = true;\n-    }\n-\n-    public void dropActionChanged(DropTargetDragEvent dtde) {}\n-\n-    public void drop(DropTargetDropEvent dtde) {\n-        dtde.rejectDrop();\n-    }\n-\n-    public boolean passed() {\n-        \/\/ asserts that dragEnter has been called if dragOver has been called.\n-        return !dragOverTriggered || dragEnterTriggered;\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/dnd\/NoFormatsDragEnterTest\/NoFormatsDragEnterTest.java","additions":0,"deletions":225,"binary":false,"changes":225,"status":"deleted"},{"patch":"@@ -1,297 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 4473062\n-  @summary tests that a drop happens even if the source doesn't export\n-           data in native formats.\n-  @key headful\n-  @run main NoFormatsDropTest\n-*\/\n-\n-import java.awt.AWTEvent;\n-import java.awt.AWTException;\n-import java.awt.Component;\n-import java.awt.Dimension;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.GridLayout;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.datatransfer.DataFlavor;\n-import java.awt.datatransfer.Transferable;\n-import java.awt.datatransfer.UnsupportedFlavorException;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureEvent;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceAdapter;\n-import java.awt.dnd.DragSourceListener;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetContext;\n-import java.awt.dnd.DropTargetDragEvent;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.awt.dnd.DropTargetEvent;\n-import java.awt.dnd.DropTargetListener;\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.InputEvent;\n-import java.awt.event.KeyEvent;\n-import java.awt.event.MouseEvent;\n-import java.io.IOException;\n-import java.lang.reflect.InvocationTargetException;\n-\n-public class NoFormatsDropTest implements AWTEventListener {\n-\n-    Frame frame;\n-    DragSourcePanel dragSourcePanel;\n-    DropTargetPanel dropTargetPanel;\n-\n-    static final int FRAME_ACTIVATION_TIMEOUT = 1000;\n-    static final int DROP_COMPLETION_TIMEOUT = 1000;\n-    static final int MOUSE_RELEASE_TIMEOUT = 1000;\n-    static final Object SYNC_LOCK = new Object();\n-\n-    Component clickedComponent = null;\n-\n-    public static void main(String[] args) throws InterruptedException,\n-            InvocationTargetException, AWTException {\n-        NoFormatsDropTest noFormatsDropTest = new NoFormatsDropTest();\n-        EventQueue.invokeAndWait(noFormatsDropTest::init);\n-        noFormatsDropTest.start();\n-    }\n-\n-    public void init() {\n-        frame = new Frame();\n-        dragSourcePanel = new DragSourcePanel();\n-        dropTargetPanel = new DropTargetPanel();\n-\n-        frame.setTitle(\"NoFormatsDropTest\");\n-        frame.setLayout(new GridLayout(2, 1));\n-        frame.add(dragSourcePanel);\n-        frame.add(dropTargetPanel);\n-\n-        frame.getToolkit().addAWTEventListener(this, AWTEvent.MOUSE_EVENT_MASK);\n-        frame.pack();\n-        frame.setLocationRelativeTo(null);\n-        frame.setVisible(true);\n-        frame.validate();\n-    }\n-\n-    public void start() throws InterruptedException, AWTException,\n-            InvocationTargetException {\n-        try {\n-            Robot robot = new Robot();\n-            robot.setAutoWaitForIdle(true);\n-            robot.delay(FRAME_ACTIVATION_TIMEOUT);\n-\n-            final Point srcPoint = dragSourcePanel.getLocationOnScreen();\n-            Dimension d = dragSourcePanel.getSize();\n-            srcPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-            if (!pointInComponent(robot, srcPoint, dragSourcePanel)) {\n-                System.err.println(\"WARNING: Couldn't locate source panel.\");\n-                return;\n-            }\n-\n-            final Point dstPoint = dropTargetPanel.getLocationOnScreen();\n-            d = dropTargetPanel.getSize();\n-            dstPoint.translate(d.width \/ 2, d.height \/ 2);\n-\n-            if (!pointInComponent(robot, dstPoint, dropTargetPanel)) {\n-                System.err.println(\"WARNING: Couldn't locate target panel.\");\n-                return;\n-            }\n-\n-            robot.mouseMove(srcPoint.x, srcPoint.y);\n-            robot.keyPress(KeyEvent.VK_CONTROL);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            for (Point curPoint = new Point(srcPoint);\n-                 !curPoint.equals(dstPoint);\n-                 curPoint.translate(sign(dstPoint.x - curPoint.x),\n-                                    sign(dstPoint.y - curPoint.y))) {\n-                robot.mouseMove(curPoint.x, curPoint.y);\n-                robot.delay(100);\n-            }\n-            robot.keyRelease(KeyEvent.VK_CONTROL);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            robot.delay(DROP_COMPLETION_TIMEOUT);\n-        } finally {\n-            if (frame != null) {\n-                EventQueue.invokeAndWait(() -> frame.dispose());\n-            }\n-        }\n-\n-        if (!dropTargetPanel.passed()) {\n-            throw new RuntimeException(\"Drop doesn't happen.\");\n-        }\n-    }\n-\n-    public static int sign(int n) {\n-        return n < 0 ? -1 : n > 0 ? 1 : 0;\n-    }\n-\n-    public void reset() {\n-        clickedComponent = null;\n-    }\n-\n-    public void eventDispatched(AWTEvent e) {\n-        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n-            clickedComponent = (Component)e.getSource();\n-            synchronized (SYNC_LOCK) {\n-                SYNC_LOCK.notifyAll();\n-            }\n-        }\n-    }\n-\n-    boolean pointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        robot.waitForIdle();\n-        reset();\n-        robot.mouseMove(p.x, p.y);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        synchronized (SYNC_LOCK) {\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n-        }\n-\n-        Component c = clickedComponent;\n-\n-        while (c != null && c != comp) {\n-            c = c.getParent();\n-        }\n-\n-        return c == comp;\n-    }\n-}\n-\n-class DragSourcePanel extends Panel implements DragGestureListener {\n-\n-    private final Dimension preferredDimension = new Dimension(200, 100);\n-    private final DragSourceListener listener = new DragSourceAdapter() {};\n-\n-    public DragSourcePanel() {\n-        DragSource ds = DragSource.getDefaultDragSource();\n-        ds.createDefaultDragGestureRecognizer(this,\n-                                              DnDConstants.ACTION_COPY_OR_MOVE,\n-                                              this);\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-\n-    public void dragGestureRecognized(DragGestureEvent dge) {\n-        dge.startDrag(null, new TestTransferable(), listener);\n-    }\n-}\n-\n-class TestTransferable implements Transferable {\n-\n-    public static DataFlavor dataFlavor = null;\n-    static final Object data = new Object();\n-\n-    static {\n-        DataFlavor df = null;\n-        try {\n-            df = new DataFlavor(DataFlavor.javaJVMLocalObjectMimeType +\n-                                \"; class=java.lang.Object\");\n-        } catch (ClassNotFoundException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-        dataFlavor = df;\n-    }\n-\n-    public DataFlavor[] getTransferDataFlavors() {\n-        return new DataFlavor[] { dataFlavor };\n-    }\n-\n-    public boolean isDataFlavorSupported(DataFlavor df) {\n-        return dataFlavor.equals(df);\n-    }\n-\n-    public Object getTransferData(DataFlavor df)\n-      throws UnsupportedFlavorException, IOException {\n-        if (!isDataFlavorSupported(df)) {\n-            throw new UnsupportedFlavorException(df);\n-        }\n-        return data;\n-    }\n-}\n-\n-class DropTargetPanel extends Panel implements DropTargetListener {\n-\n-    final Dimension preferredDimension = new Dimension(200, 100);\n-    boolean passed = false;\n-\n-    public DropTargetPanel() {\n-        setDropTarget(new DropTarget(this, this));\n-    }\n-\n-    public Dimension getPreferredSize() {\n-        return preferredDimension;\n-    }\n-\n-    public void dragEnter(DropTargetDragEvent dtde) {}\n-\n-    public void dragExit(DropTargetEvent dte) {}\n-\n-    public void dragOver(DropTargetDragEvent dtde) {}\n-\n-    public void dropActionChanged(DropTargetDragEvent dtde) {}\n-\n-    public void drop(DropTargetDropEvent dtde) {\n-        DropTargetContext dtc = dtde.getDropTargetContext();\n-\n-        if ((dtde.getSourceActions() & DnDConstants.ACTION_COPY) != 0) {\n-            dtde.acceptDrop(DnDConstants.ACTION_COPY);\n-        } else {\n-            dtde.rejectDrop();\n-        }\n-\n-        Transferable transfer = dtde.getTransferable();\n-\n-        if (transfer.isDataFlavorSupported(TestTransferable.dataFlavor)) {\n-            try {\n-                Object data =\n-                    transfer.getTransferData(TestTransferable.dataFlavor);\n-                passed = true;\n-                dtc.dropComplete(true);\n-            } catch (IOException e) {\n-                e.printStackTrace();\n-                dtc.dropComplete(false);\n-            } catch (UnsupportedFlavorException e) {\n-                e.printStackTrace();\n-                dtc.dropComplete(false);\n-            }\n-        } else {\n-            dtc.dropComplete(false);\n-        }\n-    }\n-\n-    boolean passed() {\n-        return passed;\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/dnd\/NoFormatsDropTest\/NoFormatsDropTest.java","additions":0,"deletions":297,"binary":false,"changes":297,"status":"deleted"},{"patch":"@@ -1,217 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @bug 4874092\n-  @summary tests that DragSourceListener.dragExit() is not called if the mouse\n-           is not dragged over any drop site\n-  @key headful\n-  @run main NoTargetNoDragExitTest\n-*\/\n-\n-import java.awt.AWTEvent;\n-import java.awt.Component;\n-import java.awt.EventQueue;\n-import java.awt.Frame;\n-import java.awt.Graphics;\n-import java.awt.Panel;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.Toolkit;\n-import java.awt.datatransfer.StringSelection;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceAdapter;\n-import java.awt.dnd.DragSourceDropEvent;\n-import java.awt.dnd.DragSourceEvent;\n-import java.awt.dnd.DragSourceListener;\n-import java.awt.event.AWTEventListener;\n-import java.awt.event.InputEvent;\n-import java.awt.event.MouseEvent;\n-\n-\n-public class NoTargetNoDragExitTest {\n-    private volatile boolean failed;\n-    private volatile boolean end;\n-    private final Object LOCK = new Object();\n-    private Frame frame;\n-    private Panel panel;\n-\n-    public static void main(String[] args) throws Exception {\n-        NoTargetNoDragExitTest noTargetNoDragExitTest = new NoTargetNoDragExitTest();\n-        EventQueue.invokeAndWait(noTargetNoDragExitTest::init);\n-        noTargetNoDragExitTest.start();\n-    }\n-\n-    public void init() {\n-        frame = new Frame(\"NoTargetNoDragExitTest\");\n-        panel = new Panel();\n-        frame.add(panel);\n-        frame.setSize(300, 300);\n-        frame.setLocationRelativeTo(null);\n-        frame.setVisible(true);\n-        frame.validate();\n-    }\n-\n-    public void start() throws Exception {\n-        try {\n-            Robot robot = new Robot();\n-            robot.waitForIdle();\n-            robot.delay(1000);\n-\n-            final DragSourceListener dsl = new DragSourceAdapter() {\n-                public void dragExit(DragSourceEvent e) {\n-                    failed = true;\n-                    System.err.println(\"FAILURE: DragSourceListener.dragExit() called!\");\n-                }\n-                public void dragDropEnd(DragSourceDropEvent e) {\n-                    System.err.println(\"DragSourceListener.dragDropEnd()\");\n-                    synchronized (LOCK) {\n-                        end = true;\n-                        LOCK.notifyAll();\n-                    }\n-                }\n-            };\n-\n-            DragGestureListener dgl = dge ->\n-                    dge.startDrag(null, new StringSelection(\"NoTargetNoDragExitTest\"), dsl);\n-\n-            new DragSource().createDefaultDragGestureRecognizer(panel,\n-                    DnDConstants.ACTION_COPY_OR_MOVE, dgl);\n-\n-            Point startPoint = frame.getLocationOnScreen();\n-            startPoint.translate(50, 50);\n-            Point endPoint = new Point(startPoint.x + 100, startPoint.y + 100);\n-\n-            Util.waitForInit();\n-\n-            if (!Util.pointInComponent(robot, startPoint, frame)) {\n-                System.err.println(\"WARNING: Could not locate \" + frame +\n-                        \" at point \" + startPoint);\n-                return;\n-            }\n-\n-            robot.mouseMove(startPoint.x, startPoint.y);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            for (Point p = new Point(startPoint); !p.equals(endPoint);\n-                 p.translate(Util.sign(endPoint.x - p.x),\n-                         Util.sign(endPoint.y - p.y))) {\n-                robot.mouseMove(p.x, p.y);\n-                robot.delay(100);\n-            }\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            synchronized (LOCK) {\n-                while (!end) {\n-                    LOCK.wait();\n-                }\n-            }\n-        } finally {\n-            if (frame != null) {\n-                EventQueue.invokeAndWait(() -> frame.dispose());\n-            }\n-        }\n-\n-        if (failed) {\n-            throw new RuntimeException(\"DragSourceListener.dragExit() called!\");\n-        }\n-\n-        System.err.println(\"test passed!\");\n-     }\n-}\n-\n-\n-class Util implements AWTEventListener {\n-    private static final Toolkit tk = Toolkit.getDefaultToolkit();\n-    private static final Object SYNC_LOCK = new Object();\n-    private Component clickedComponent = null;\n-    private static final int PAINT_TIMEOUT = 10000;\n-    private static final int MOUSE_RELEASE_TIMEOUT = 10000;\n-    private static final Util util = new Util();\n-\n-    static {\n-        tk.addAWTEventListener(util, 0xFFFFFFFF);\n-    }\n-\n-    private void reset() {\n-        clickedComponent = null;\n-    }\n-\n-    public void eventDispatched(AWTEvent e) {\n-        if (e.getID() == MouseEvent.MOUSE_RELEASED) {\n-            clickedComponent = (Component)e.getSource();\n-            synchronized (SYNC_LOCK) {\n-                SYNC_LOCK.notifyAll();\n-            }\n-        }\n-    }\n-\n-    public static boolean pointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        return util.isPointInComponent(robot, p, comp);\n-    }\n-\n-    private boolean isPointInComponent(Robot robot, Point p, Component comp)\n-      throws InterruptedException {\n-        tk.sync();\n-        robot.waitForIdle();\n-        reset();\n-        robot.mouseMove(p.x, p.y);\n-        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-        synchronized (SYNC_LOCK) {\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            SYNC_LOCK.wait(MOUSE_RELEASE_TIMEOUT);\n-        }\n-\n-        Component c = clickedComponent;\n-\n-        while (c != null && c != comp) {\n-            c = c.getParent();\n-        }\n-\n-        return c == comp;\n-    }\n-\n-    public static void waitForInit() throws InterruptedException {\n-        final Frame f = new Frame() {\n-                public void paint(Graphics g) {\n-                    dispose();\n-                    synchronized (SYNC_LOCK) {\n-                        SYNC_LOCK.notifyAll();\n-                    }\n-                }\n-            };\n-        f.setBounds(600, 400, 200, 200);\n-        synchronized (SYNC_LOCK) {\n-            f.setVisible(true);\n-            SYNC_LOCK.wait(PAINT_TIMEOUT);\n-        }\n-        tk.sync();\n-    }\n-\n-    public static int sign(int n) {\n-        return n < 0 ? -1 : n == 0 ? 0 : 1;\n-    }\n-}\n\\ No newline at end of file\n","filename":"test\/jdk\/java\/awt\/dnd\/NoTargetNoDragExitTest\/NoTargetNoDragExitTest.java","additions":0,"deletions":217,"binary":false,"changes":217,"status":"deleted"},{"patch":"@@ -1,120 +0,0 @@\n-\/*\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-  @test\n-  @key headful\n-  @bug 4187912\n-  @summary Test that some incorrectly written DnD code cannot hang the app\n-  @run main NotReallySerializableTest\n-*\/\n-\n-import java.awt.Button;\n-import java.awt.Cursor;\n-import java.awt.Point;\n-import java.awt.Toolkit;\n-import java.awt.datatransfer.StringSelection;\n-import java.awt.dnd.DnDConstants;\n-import java.awt.dnd.DragGestureEvent;\n-import java.awt.dnd.DragGestureListener;\n-import java.awt.dnd.DragGestureRecognizer;\n-import java.awt.dnd.DragSource;\n-import java.awt.dnd.DragSourceAdapter;\n-import java.awt.dnd.DragSourceContext;\n-import java.awt.dnd.DropTarget;\n-import java.awt.dnd.DropTargetAdapter;\n-import java.awt.dnd.DropTargetDropEvent;\n-import java.io.IOException;\n-import java.io.ObjectOutputStream;\n-import java.io.OutputStream;\n-import java.io.Serializable;\n-import java.util.ArrayList;\n-\n-\n-public class NotReallySerializableTest {\n-    public static void main(String[] args) throws IOException {\n-        Toolkit tk = Toolkit.getDefaultToolkit();\n-\n-        DragGestureRecognizer dgr = tk.createDragGestureRecognizer\n-                (java.awt.dnd.MouseDragGestureRecognizer.class,\n-                        DragSource.getDefaultDragSource(), new Button(),\n-                        DnDConstants.ACTION_LINK, new TrickDragGestureListener());\n-        DragGestureEvent dge = new DragGestureEvent\n-                (dgr, DnDConstants.ACTION_LINK, new Point(0, 0),\n-                        new TrickList());\n-        DragSourceContext dsc = new DragSourceContext(dge,\n-                Cursor.getPredefinedCursor(Cursor.MOVE_CURSOR),\n-                null, null, new TrickTransferable(),\n-                new TrickDragSourceListener());\n-        DropTarget dt = new DropTarget(new Button(),\n-                new TrickDropTargetListener());\n-\n-        ObjectOutputStream stream = new ObjectOutputStream\n-                (new OutputStream() {\n-                    public void write(int b) {}\n-                });\n-\n-        stream.writeObject(dgr);\n-        stream.writeObject(dge);\n-        stream.writeObject(dsc);\n-        stream.writeObject(dt);\n-\n-        System.out.println(\"test passed\");\n-    }\n-}\n-\n-class TrickList extends ArrayList implements Serializable {\n-    Object trick = new Object();\n-\n-    TrickList() {\n-        add(trick);\n-    }\n-}\n-\n-class TrickDragGestureListener implements DragGestureListener, Serializable {\n-    Object trick = new Object();\n-\n-    public void dragGestureRecognized(DragGestureEvent dge) {}\n-}\n-\n-class TrickTransferable extends StringSelection implements Serializable {\n-    Object trick = new Object();\n-\n-    TrickTransferable() {\n-        super(\"\");\n-    }\n-}\n-\n-class TrickDragSourceListener extends DragSourceAdapter\n-    implements Serializable\n-{\n-    Object trick = new Object();\n-}\n-\n-class TrickDropTargetListener extends DropTargetAdapter\n-    implements Serializable\n-{\n-    Object trick = new Object();\n-\n-    public void drop(DropTargetDropEvent dtde) {}\n-}\n","filename":"test\/jdk\/java\/awt\/dnd\/NotReallySerializableTest\/NotReallySerializableTest.java","additions":0,"deletions":120,"binary":false,"changes":120,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,1 +25,0 @@\n- * @test\n@@ -30,1 +29,1 @@\n- * @run main\/manual InitToBlack\n+ * @run applet\/manual=yesno InitToBlack.html\n@@ -33,18 +32,3 @@\n-import java.awt.BorderLayout;\n-import java.awt.Graphics;\n-import java.awt.Graphics2D;\n-import java.awt.print.Book;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-import java.awt.print.PrinterJob;\n-import java.lang.reflect.InvocationTargetException;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-import javax.swing.JButton;\n-import javax.swing.JDialog;\n-import javax.swing.JFrame;\n-import javax.swing.JLabel;\n-import javax.swing.JPanel;\n-import javax.swing.JTextArea;\n-import javax.swing.SwingUtilities;\n+import java.awt.*;\n+import java.awt.print.*;\n+import java.applet.Applet;\n@@ -52,1 +36,1 @@\n-public class InitToBlack implements Printable {\n+public class InitToBlack extends Applet implements Printable {\n@@ -54,17 +38,1 @@\n-    private static volatile JFrame frame;\n-    private static volatile boolean testResult = false;\n-    private static volatile CountDownLatch printButtonCountDownLatch =\n-            new CountDownLatch(1);\n-    private static volatile CountDownLatch CountDownLatch =\n-            new CountDownLatch(1);\n-    private static volatile String failureReason;\n-\n-    @Override\n-    public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n-        Graphics2D g2d = (Graphics2D) graphics;\n-        g2d.translate(pageFormat.getImageableX(), pageFormat.getImageableY());\n-        graphics.drawString(\"Test Passes\", 200, 200);\n-        return PAGE_EXISTS;\n-    }\n-\n-    private void test() {\n+    public void init() {\n@@ -72,4 +40,0 @@\n-        if (pjob.getPrintService() == null) {\n-            System.out.println(\"There is no printer configured on this system\");\n-            return;\n-        }\n@@ -88,59 +52,3 @@\n-    private static void createTestUI() {\n-        frame = new JFrame(\"Test InitToBlack\");\n-        String INSTRUCTION = \"Aim: This test checks whether the default foreground color on a printer\\n\" +\n-                \"graphics object is black so that rendering will appear without having\\n\" +\n-                \"to execute setColor.\\n\" +\n-                \"Step:\\n\" +\n-                \"1) Click on the \\\"Print\\\" button. Check whether page is printed on the printer.\\n\" +\n-                \"2) Check whether \\\"Test Passes\\\" is printed on the page and it should be in\\n\" +\n-                \"black color. If yes then press \\\"Pass\\\" button else press \\\"Fail\\\" button.\\n\";\n-        JTextArea instructionTextArea = new JTextArea(INSTRUCTION, 4, 40);\n-        instructionTextArea.setEditable(false);\n-\n-        JPanel buttonPanel = new JPanel();\n-        JButton printButton = new JButton(\"Print\");\n-        printButton.addActionListener((ae) -> {\n-            InitToBlack initToBlack = new InitToBlack();\n-            initToBlack.test();\n-            printButtonCountDownLatch.countDown();\n-        });\n-\n-        JButton passButton = new JButton(\"Pass\");\n-        passButton.addActionListener((ae) -> {\n-            testResult = true;\n-            CountDownLatch.countDown();\n-            frame.dispose();\n-        });\n-        JButton failButton = new JButton(\"Fail\");\n-        failButton.addActionListener((ae) -> {\n-            getFailureReason();\n-            frame.dispose();\n-        });\n-        buttonPanel.add(printButton);\n-        buttonPanel.add(passButton);\n-        buttonPanel.add(failButton);\n-\n-        JPanel panel = new JPanel(new BorderLayout());\n-        panel.add(instructionTextArea, BorderLayout.CENTER);\n-        panel.add(buttonPanel, BorderLayout.SOUTH);\n-\n-        frame.add(panel);\n-        frame.setLocationRelativeTo(null);\n-        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public static void getFailureReason() {\n-        final JDialog dialog = new JDialog();\n-        dialog.setTitle(\"Read testcase failure reason\");\n-        JPanel jPanel = new JPanel(new BorderLayout());\n-        JTextArea jTextArea = new JTextArea(5, 20);\n-\n-        JButton okButton = new JButton(\"Ok\");\n-        okButton.addActionListener((ae) -> {\n-            failureReason = jTextArea.getText();\n-            testResult = false;\n-            CountDownLatch.countDown();\n-            dialog.dispose();\n-        });\n+    public int print(Graphics g, PageFormat pf, int pageIndex) {\n+        Graphics2D g2d = (Graphics2D) g;\n+        g2d.translate(pf.getImageableX(), pf.getImageableY());\n@@ -148,3 +56,1 @@\n-        jPanel.add(new JLabel(\"Enter the testcase failed reason below and \" +\n-                \"click OK button\", JLabel.CENTER), BorderLayout.NORTH);\n-        jPanel.add(jTextArea, BorderLayout.CENTER);\n+        g.drawString(\"Test Passes\", 200, 200);\n@@ -152,8 +58,1 @@\n-        JPanel okayBtnPanel = new JPanel();\n-        okayBtnPanel.add(okButton);\n-\n-        jPanel.add(okayBtnPanel, BorderLayout.SOUTH);\n-        dialog.add(jPanel);\n-        dialog.setLocationRelativeTo(null);\n-        dialog.pack();\n-        dialog.setVisible(true);\n+        return PAGE_EXISTS;\n@@ -162,16 +61,3 @@\n-    public static void main(String[] args) throws InterruptedException, InvocationTargetException {\n-        SwingUtilities.invokeAndWait(InitToBlack::createTestUI);\n-        if (!printButtonCountDownLatch.await(2, TimeUnit.MINUTES)) {\n-            throw new RuntimeException(\"Timeout: User did not perform action \" +\n-                    \"on Print button.\");\n-        }\n-        if (!CountDownLatch.await(2, TimeUnit.MINUTES)) {\n-            throw new RuntimeException(\"Timeout : User did not decide \" +\n-                    \"whether test passed or failed\");\n-        }\n-\n-        if (!testResult) {\n-            throw new RuntimeException(\"Test failed : \" + failureReason);\n-        } else {\n-            System.out.println(\"Test Passed\");\n-        }\n+    public static void main(String[] args) {\n+        new InitToBlack().init();\n+        System.exit(0);\n","filename":"test\/jdk\/java\/awt\/print\/PrinterJob\/InitToBlack.java","additions":15,"deletions":129,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 4770745 6218846 6218848 6237956 8313765\n+ * @bug 4770745 6218846 6218848 6237956\n@@ -116,3 +116,2 @@\n-        bad[cenpos+CENEXT]   = (byte)0xff;\n-        bad[cenpos+CENEXT+1] = (byte)0xff;\n-        checkZipException(bad, \".*extra data field size too long.*\");\n+        bad[cenpos+CENEXT]++;\n+        checkZipException(bad, \".*invalid zip64 extra data field size.*\");\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CorruptedZipFiles.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,940 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.io.IOException;\n-import java.net.URI;\n-import java.nio.file.FileSystem;\n-import java.nio.file.FileSystems;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.Formatter;\n-import java.util.Map;\n-import java.util.stream.Stream;\n-import java.util.zip.ZipFile;\n-\n-\/* @test\n- * @bug 8313765\n- * @summary Validate that a Zip File with an Extra Header with a data size\n- * of 0 can be read.\n- * @run main ReadNonStandardExtraHeadersTest\n- *\/\n-public class ReadNonStandardExtraHeadersTest {\n-\n-    \/*\n-     * Byte array holding a ZIP file which contains an\n-     * Extra field header which has a data size of 0.\n-     *\n-     * ---------------#1--------------------\n-     * [Central Directory Header]\n-     *   0x664: Signature        : 0x02014b50\n-     *   0x668: Created Zip Spec :        0xa [1.0]\n-     *   0x669: Created OS       :        0x0 [MS-DOS]\n-     *   0x66a: VerMadeby        :        0xa [0, 1.0]\n-     *   0x66b: VerExtract       :        0xa [1.0]\n-     *   0x66c: Flag             :      0x800\n-     *   0x66e: Method           :        0x0 [STORED]\n-     *   0x670: Last Mod Time    : 0x385ca437 [Thu Feb 28 20:33:46 EST 2008]\n-     *   0x674: CRC              : 0x694c6952\n-     *   0x678: Compressed Size  :      0x624\n-     *   0x67c: Uncompressed Size:      0x624\n-     *   0x680: Name Length      :       0x1b\n-     *   0x682: Extra Length     :        0x7\n-     *          ->[tag=cafe, size=0]\n-     *   0x684: Comment Length   :        0x0\n-     *   0x686: Disk Start       :        0x0\n-     *   0x688: Attrs            :        0x0\n-     *   0x68a: AttrsEx          :        0x0\n-     *   0x68e: Loc Header Offset:        0x0\n-     *   0x692: File Name        : res\/drawable\/size_48x48.jpg\n-     *\n-     * [Local File Header]\n-     *     0x0: Signature   :   0x04034b50\n-     *     0x4: Version     :          0xa    [1.0]\n-     *     0x6: Flag        :        0x800\n-     *     0x8: Method      :          0x0    [STORED]\n-     *     0xa: LastMTime   :   0x385ca437    [Thu Feb 28 20:33:46 EST 2008]\n-     *     0xe: CRC         :   0x694c6952\n-     *    0x12: CSize       :        0x624\n-     *    0x16: Size        :        0x624\n-     *    0x1a: Name Length :         0x1b    [res\/drawable\/size_48x48.jpg]\n-     *    0x1c: ExtraLength :          0x7\n-     *          ->[tag=cafe, size=0]\n-     *    0x1e: File Name  : [res\/drawable\/size_48x48.jpg]\n-     *  [End Central Directory Header]\n-     *    Signature   :   0x06054b50\n-     *    ENDCEN Off  :        0x6b4\n-     *    Disk Entries:          0x1\n-     *    Total Entries:         0x1\n-     *    CEN Size    :         0x50\n-     *    Offset CEN  :        0x664\n-     *    Comment Len :          0x0 []\n-     *\/\n-    public static byte[] VALID_APK_FILE = {\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0xa, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x37, (byte) 0xa4, (byte) 0x5c, (byte) 0x38, (byte) 0x52, (byte) 0x69,\n-            (byte) 0x4c, (byte) 0x69, (byte) 0x24, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x24, (byte) 0x6,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x1b, (byte) 0x0, (byte) 0x7, (byte) 0x0, (byte) 0x72, (byte) 0x65,\n-            (byte) 0x73, (byte) 0x2f, (byte) 0x64, (byte) 0x72, (byte) 0x61, (byte) 0x77, (byte) 0x61, (byte) 0x62,\n-            (byte) 0x6c, (byte) 0x65, (byte) 0x2f, (byte) 0x73, (byte) 0x69, (byte) 0x7a, (byte) 0x65, (byte) 0x5f,\n-            (byte) 0x34, (byte) 0x38, (byte) 0x78, (byte) 0x34, (byte) 0x38, (byte) 0x2e, (byte) 0x6a, (byte) 0x70,\n-            (byte) 0x67, (byte) 0xfe, (byte) 0xca, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0xff, (byte) 0xd8, (byte) 0xff, (byte) 0xe0, (byte) 0x0, (byte) 0x10, (byte) 0x4a, (byte) 0x46,\n-            (byte) 0x49, (byte) 0x46, (byte) 0x0, (byte) 0x1, (byte) 0x1, (byte) 0x1, (byte) 0x0, (byte) 0x48,\n-            (byte) 0x0, (byte) 0x48, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xfe, (byte) 0x0, (byte) 0x16,\n-            (byte) 0x28, (byte) 0x63, (byte) 0x29, (byte) 0x20, (byte) 0x32, (byte) 0x30, (byte) 0x30, (byte) 0x37,\n-            (byte) 0x20, (byte) 0x50, (byte) 0x68, (byte) 0x69, (byte) 0x6c, (byte) 0x20, (byte) 0x44, (byte) 0x75,\n-            (byte) 0x62, (byte) 0x61, (byte) 0x63, (byte) 0x68, (byte) 0xff, (byte) 0xdb, (byte) 0x0, (byte) 0x43,\n-            (byte) 0x0, (byte) 0x6, (byte) 0x4, (byte) 0x5, (byte) 0x6, (byte) 0x5, (byte) 0x4, (byte) 0x6,\n-            (byte) 0x6, (byte) 0x5, (byte) 0x6, (byte) 0x7, (byte) 0x7, (byte) 0x6, (byte) 0x8, (byte) 0xa,\n-            (byte) 0x10, (byte) 0xa, (byte) 0xa, (byte) 0x9, (byte) 0x9, (byte) 0xa, (byte) 0x14, (byte) 0xe,\n-            (byte) 0xf, (byte) 0xc, (byte) 0x10, (byte) 0x17, (byte) 0x14, (byte) 0x18, (byte) 0x18, (byte) 0x17,\n-            (byte) 0x14, (byte) 0x16, (byte) 0x16, (byte) 0x1a, (byte) 0x1d, (byte) 0x25, (byte) 0x1f, (byte) 0x1a,\n-            (byte) 0x1b, (byte) 0x23, (byte) 0x1c, (byte) 0x16, (byte) 0x16, (byte) 0x20, (byte) 0x2c, (byte) 0x20,\n-            (byte) 0x23, (byte) 0x26, (byte) 0x27, (byte) 0x29, (byte) 0x2a, (byte) 0x29, (byte) 0x19, (byte) 0x1f,\n-            (byte) 0x2d, (byte) 0x30, (byte) 0x2d, (byte) 0x28, (byte) 0x30, (byte) 0x25, (byte) 0x28, (byte) 0x29,\n-            (byte) 0x28, (byte) 0xff, (byte) 0xdb, (byte) 0x0, (byte) 0x43, (byte) 0x1, (byte) 0x7, (byte) 0x7,\n-            (byte) 0x7, (byte) 0xa, (byte) 0x8, (byte) 0xa, (byte) 0x13, (byte) 0xa, (byte) 0xa, (byte) 0x13,\n-            (byte) 0x28, (byte) 0x1a, (byte) 0x16, (byte) 0x1a, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28,\n-            (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28,\n-            (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28,\n-            (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28,\n-            (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28,\n-            (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28,\n-            (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0x28, (byte) 0xff, (byte) 0xc0,\n-            (byte) 0x0, (byte) 0x11, (byte) 0x8, (byte) 0x0, (byte) 0x30, (byte) 0x0, (byte) 0x30, (byte) 0x3,\n-            (byte) 0x1, (byte) 0x11, (byte) 0x0, (byte) 0x2, (byte) 0x11, (byte) 0x1, (byte) 0x3, (byte) 0x11,\n-            (byte) 0x1, (byte) 0xff, (byte) 0xc4, (byte) 0x0, (byte) 0x1b, (byte) 0x0, (byte) 0x0, (byte) 0x2,\n-            (byte) 0x2, (byte) 0x3, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x4, (byte) 0x5,\n-            (byte) 0x6, (byte) 0x7, (byte) 0x1, (byte) 0x3, (byte) 0x8, (byte) 0x2, (byte) 0xff, (byte) 0xc4,\n-            (byte) 0x0, (byte) 0x2e, (byte) 0x10, (byte) 0x0, (byte) 0x2, (byte) 0x2, (byte) 0x1, (byte) 0x2,\n-            (byte) 0x4, (byte) 0x4, (byte) 0x5, (byte) 0x4, (byte) 0x3, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x2, (byte) 0x3, (byte) 0x4, (byte) 0x11,\n-            (byte) 0x0, (byte) 0x5, (byte) 0x6, (byte) 0x12, (byte) 0x21, (byte) 0x31, (byte) 0x41, (byte) 0x51,\n-            (byte) 0x61, (byte) 0x71, (byte) 0x7, (byte) 0x13, (byte) 0x22, (byte) 0x42, (byte) 0x91, (byte) 0x33,\n-            (byte) 0x62, (byte) 0x81, (byte) 0xa1, (byte) 0x52, (byte) 0xd1, (byte) 0xf0, (byte) 0xff, (byte) 0xc4,\n-            (byte) 0x0, (byte) 0x1b, (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x5, (byte) 0x1, (byte) 0x1,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x6, (byte) 0x2, (byte) 0x3, (byte) 0x4, (byte) 0x5,\n-            (byte) 0x7, (byte) 0x1, (byte) 0x0, (byte) 0xff, (byte) 0xc4, (byte) 0x0, (byte) 0x33, (byte) 0x11,\n-            (byte) 0x0, (byte) 0x1, (byte) 0x3, (byte) 0x2, (byte) 0x4, (byte) 0x4, (byte) 0x4, (byte) 0x4,\n-            (byte) 0x5, (byte) 0x5, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x1, (byte) 0x0, (byte) 0x2, (byte) 0x3, (byte) 0x4, (byte) 0x11, (byte) 0x5, (byte) 0x12,\n-            (byte) 0x21, (byte) 0x31, (byte) 0x13, (byte) 0x51, (byte) 0x61, (byte) 0x71, (byte) 0x6, (byte) 0x32,\n-            (byte) 0x41, (byte) 0x81, (byte) 0x91, (byte) 0xa1, (byte) 0xb1, (byte) 0xc1, (byte) 0x7, (byte) 0x14,\n-            (byte) 0x42, (byte) 0xd1, (byte) 0xf0, (byte) 0x22, (byte) 0x33, (byte) 0x62, (byte) 0xa2, (byte) 0xf1,\n-            (byte) 0xff, (byte) 0xda, (byte) 0x0, (byte) 0xc, (byte) 0x3, (byte) 0x1, (byte) 0x0, (byte) 0x2,\n-            (byte) 0x11, (byte) 0x3, (byte) 0x11, (byte) 0x0, (byte) 0x3f, (byte) 0x0, (byte) 0xb4, (byte) 0x11,\n-            (byte) 0xf4, (byte) 0x4c, (byte) 0xa, (byte) 0x12, (byte) 0x7b, (byte) 0x16, (byte) 0x2e, (byte) 0x5d,\n-            (byte) 0xaf, (byte) 0x46, (byte) 0xac, (byte) 0x96, (byte) 0x6e, (byte) 0xcf, (byte) 0x1c, (byte) 0x10,\n-            (byte) 0x46, (byte) 0x32, (byte) 0xd2, (byte) 0x48, (byte) 0xd8, (byte) 0x3, (byte) 0x48, (byte) 0x96,\n-            (byte) 0x46, (byte) 0x44, (byte) 0xd2, (byte) 0xf7, (byte) 0x9b, (byte) 0x0, (byte) 0x91, (byte) 0x5,\n-            (byte) 0x24, (byte) 0xd5, (byte) 0x52, (byte) 0x8, (byte) 0x60, (byte) 0x69, (byte) 0x73, (byte) 0x8e,\n-            (byte) 0xc0, (byte) 0x6f, (byte) 0xfc, (byte) 0xfa, (byte) 0x28, (byte) 0x26, (byte) 0xe5, (byte) 0xf1,\n-            (byte) 0x5f, (byte) 0x6b, (byte) 0x82, (byte) 0x52, (byte) 0x9b, (byte) 0x7d, (byte) 0x3b, (byte) 0x17,\n-            (byte) 0x0, (byte) 0x38, (byte) 0xe7, (byte) 0x62, (byte) 0x22, (byte) 0x53, (byte) 0xea, (byte) 0x32,\n-            (byte) 0x9, (byte) 0xfc, (byte) 0x81, (byte) 0xaa, (byte) 0x19, (byte) 0xfc, (byte) 0x43, (byte) 0x13,\n-            (byte) 0xd, (byte) 0xa3, (byte) 0x69, (byte) 0x77, (byte) 0xcb, (byte) 0xf7, (byte) 0x47, (byte) 0xb4,\n-            (byte) 0x1f, (byte) 0x86, (byte) 0x95, (byte) 0xd3, (byte) 0xb7, (byte) 0x35, (byte) 0x4c, (byte) 0xad,\n-            (byte) 0x8f, (byte) 0xa5, (byte) 0xb3, (byte) 0x1f, (byte) 0x7d, (byte) 0x40, (byte) 0xf8, (byte) 0x12,\n-            (byte) 0x8a, (byte) 0xd9, (byte) 0x7e, (byte) 0x26, (byte) 0x6d, (byte) 0xb7, (byte) 0x98, (byte) 0x8b,\n-            (byte) 0x95, (byte) 0x2c, (byte) 0xd3, (byte) 0x3, (byte) 0xbc, (byte) 0x9f, (byte) 0xaa, (byte) 0x8b,\n-            (byte) 0xee, (byte) 0x40, (byte) 0xc8, (byte) 0xfc, (byte) 0x6b, (byte) 0xb4, (byte) 0xf8, (byte) 0xfc,\n-            (byte) 0x52, (byte) 0x7f, (byte) 0x71, (byte) 0xa5, (byte) 0xbd, (byte) 0x77, (byte) 0x1e, (byte) 0xff,\n-            (byte) 0x0, (byte) 0xf1, (byte) 0x7b, (byte) 0x10, (byte) 0xfc, (byte) 0x34, (byte) 0xc4, (byte) 0x29,\n-            (byte) 0x9b, (byte) 0x9e, (byte) 0x9a, (byte) 0x46, (byte) 0xcb, (byte) 0xd3, (byte) 0xca, (byte) 0xef,\n-            (byte) 0x6b, (byte) 0x92, (byte) 0xf, (byte) 0xc4, (byte) 0x29, (byte) 0xd4, (byte) 0x13, (byte) 0x47,\n-            (byte) 0x62, (byte) 0x14, (byte) 0x9a, (byte) 0x9, (byte) 0x12, (byte) 0x58, (byte) 0x9c, (byte) 0x73,\n-            (byte) 0x2b, (byte) 0xa1, (byte) 0x4, (byte) 0x30, (byte) 0xf3, (byte) 0x7, (byte) 0x57, (byte) 0xac,\n-            (byte) 0x7b, (byte) 0x5e, (byte) 0xd0, (byte) 0xe6, (byte) 0x9b, (byte) 0x82, (byte) 0x80, (byte) 0x24,\n-            (byte) 0x82, (byte) 0x48, (byte) 0x1e, (byte) 0x62, (byte) 0x95, (byte) 0xa5, (byte) 0xae, (byte) 0x1a,\n-            (byte) 0x10, (byte) 0x45, (byte) 0x88, (byte) 0x3d, (byte) 0x42, (byte) 0xf7, (byte) 0x83, (byte) 0xae,\n-            (byte) 0xdd, (byte) 0x75, (byte) 0xa1, (byte) 0x2, (byte) 0xd2, (byte) 0x47, (byte) 0x1a, (byte) 0x33,\n-            (byte) 0xbb, (byte) 0x5, (byte) 0x45, (byte) 0x5, (byte) 0x99, (byte) 0x89, (byte) 0xc0, (byte) 0x0,\n-            (byte) 0x77, (byte) 0x27, (byte) 0x49, (byte) 0xce, (byte) 0x0, (byte) 0xb9, (byte) 0x53, (byte) 0xcc,\n-            (byte) 0x2e, (byte) 0x71, (byte) 0xb0, (byte) 0x17, (byte) 0x25, (byte) 0x73, (byte) 0xff, (byte) 0x0,\n-            (byte) 0x1d, (byte) 0x71, (byte) 0x54, (byte) 0xfc, (byte) 0x4f, (byte) 0xba, (byte) 0x30, (byte) 0x46,\n-            (byte) 0x64, (byte) 0xdb, (byte) 0x21, (byte) 0x62, (byte) 0x2b, (byte) 0xc5, (byte) 0xdb, (byte) 0x3f,\n-            (byte) 0xbd, (byte) 0x87, (byte) 0xf9, (byte) 0x1f, (byte) 0xe8, (byte) 0x74, (byte) 0xf3, (byte) 0xc8,\n-            (byte) 0x46, (byte) 0x25, (byte) 0x5e, (byte) 0xea, (byte) 0xb9, (byte) 0x3f, (byte) 0xc4, (byte) 0x6c,\n-            (byte) 0x3e, (byte) 0xeb, (byte) 0x6d, (byte) 0xf0, (byte) 0xbf, (byte) 0x87, (byte) 0xa3, (byte) 0xc2,\n-            (byte) 0xa0, (byte) 0x5, (byte) 0xc2, (byte) 0xf2, (byte) 0xbb, (byte) 0xcc, (byte) 0x7e, (byte) 0xc3,\n-            (byte) 0xa0, (byte) 0xf9, (byte) 0x9d, (byte) 0x79, (byte) 0x59, (byte) 0xa, (byte) 0x2e, (byte) 0x7,\n-            (byte) 0x4d, (byte) 0x54, (byte) 0x92, (byte) 0x8c, (byte) 0xd8, (byte) 0xdb, (byte) 0x29, (byte) 0x1f,\n-            (byte) 0xe, (byte) 0x55, (byte) 0xbc, (byte) 0x86, (byte) 0x69, (byte) 0xea, (byte) 0x30, (byte) 0xc,\n-            (byte) 0x22, (byte) 0x62, (byte) 0x63, (byte) 0x75, (byte) 0x24, (byte) 0x48, (byte) 0x83, (byte) 0xbe,\n-            (byte) 0x7d, (byte) 0x3b, (byte) 0x75, (byte) 0x3e, (byte) 0x24, (byte) 0xe, (byte) 0xe4, (byte) 0x69,\n-            (byte) 0xe8, (byte) 0xc, (byte) 0x8c, (byte) 0xbb, (byte) 0xd8, (byte) 0xa2, (byte) 0x56, (byte) 0x54,\n-            (byte) 0xd3, (byte) 0x87, (byte) 0x32, (byte) 0x9, (byte) 0x4e, (byte) 0xae, (byte) 0x3a, (byte) 0x5b,\n-            (byte) 0xd3, (byte) 0xaa, (byte) 0x7f, (byte) 0xc0, (byte) 0x7c, (byte) 0x5e, (byte) 0xdb, (byte) 0x2d,\n-            (byte) 0xd1, (byte) 0x5, (byte) 0xd9, (byte) 0x11, (byte) 0x36, (byte) 0xb9, (byte) 0x64, (byte) 0xc3,\n-            (byte) 0x87, (byte) 0x6c, (byte) 0x8, (byte) 0x89, (byte) 0xfb, (byte) 0x86, (byte) 0x7b, (byte) 0xf,\n-            (byte) 0x3d, (byte) 0x59, (byte) 0xe1, (byte) 0x38, (byte) 0x8b, (byte) 0xa0, (byte) 0x7e, (byte) 0x43,\n-            (byte) 0xe5, (byte) 0x3e, (byte) 0x9c, (byte) 0xba, (byte) 0xa1, (byte) 0x6f, (byte) 0x1b, (byte) 0x78,\n-            (byte) 0x6e, (byte) 0x9a, (byte) 0xbe, (byte) 0x98, (byte) 0xd5, (byte) 0x5c, (byte) 0x36, (byte) 0x66,\n-            (byte) 0xd, (byte) 0x9, (byte) 0xb0, (byte) 0xcd, (byte) 0x6f, (byte) 0xd2, (byte) 0x6f, (byte) 0xfe,\n-            (byte) 0xbc, (byte) 0x8f, (byte) 0x4b, (byte) 0xab, (byte) 0xa6, (byte) 0xad, (byte) 0x9a, (byte) 0xf7,\n-            (byte) 0x2b, (byte) 0xa4, (byte) 0xf4, (byte) 0xe7, (byte) 0x86, (byte) 0xc4, (byte) 0xf, (byte) 0xd5,\n-            (byte) 0x65, (byte) 0x85, (byte) 0xc3, (byte) 0xab, (byte) 0x7b, (byte) 0x11, (byte) 0xd0, (byte) 0xe8,\n-            (byte) 0xc5, (byte) 0xaf, (byte) 0xe, (byte) 0x17, (byte) 0x69, (byte) 0xba, (byte) 0xc2, (byte) 0xf2,\n-            (byte) 0x16, (byte) 0x9b, (byte) 0x38, (byte) 0x59, (byte) 0x40, (byte) 0x78, (byte) 0xd6, (byte) 0xf3,\n-            (byte) 0xa7, (byte) 0x8, (byte) 0xee, (byte) 0xe6, (byte) 0x33, (byte) 0xf5, (byte) 0x1a, (byte) 0xec,\n-            (byte) 0xbd, (byte) 0x3c, (byte) 0x8f, (byte) 0x43, (byte) 0xfd, (byte) 0x13, (byte) 0xaa, (byte) 0xea,\n-            (byte) 0xd9, (byte) 0x4f, (byte) 0x1, (byte) 0xe0, (byte) 0x72, (byte) 0x45, (byte) 0x78, (byte) 0x4c,\n-            (byte) 0x2d, (byte) 0xfc, (byte) 0xf4, (byte) 0x39, (byte) 0xb6, (byte) 0xcc, (byte) 0x3e, (byte) 0x5b,\n-            (byte) 0x7c, (byte) 0xd5, (byte) 0xb, (byte) 0x59, (byte) 0xb3, (byte) 0xa0, (byte) 0xd7, (byte) 0x85,\n-            (byte) 0xb5, (byte) 0x53, (byte) 0x3e, (byte) 0xe9, (byte) 0xe6, (byte) 0xc6, (byte) 0x6a, (byte) 0x35,\n-            (byte) 0xe4, (byte) 0x5d, (byte) 0xc1, (byte) 0x9d, (byte) 0x6b, (byte) 0xb0, (byte) 0x21, (byte) 0x9a,\n-            (byte) 0x3c, (byte) 0x64, (byte) 0x7a, (byte) 0x8c, (byte) 0xe9, (byte) 0xa6, (byte) 0xe5, (byte) 0x7,\n-            (byte) 0xfa, (byte) 0xb6, (byte) 0x53, (byte) 0xe5, (byte) 0x74, (byte) 0x9c, (byte) 0x33, (byte) 0xc2,\n-            (byte) 0xf3, (byte) 0x75, (byte) 0x5b, (byte) 0xa5, (byte) 0xdf, (byte) 0x61, (byte) 0xda, (byte) 0x4f,\n-            (byte) 0xc9, (byte) 0xb7, (byte) 0x3d, (byte) 0xc6, (byte) 0x4b, (byte) 0x32, (byte) 0x34, (byte) 0xb,\n-            (byte) 0x65, (byte) 0x47, (byte) 0x53, (byte) 0x0, (byte) 0xc1, (byte) 0x18, (byte) 0xcf, (byte) 0x7f,\n-            (byte) 0xbb, (byte) 0xa7, (byte) 0x99, (byte) 0xf5, (byte) 0x3a, (byte) 0x71, (byte) 0xb1, (byte) 0x49,\n-            (byte) 0x35, (byte) 0xf2, (byte) 0x1d, (byte) 0x96, (byte) 0x6f, (byte) 0x8d, (byte) 0x62, (byte) 0x2f,\n-            (byte) 0xa2, (byte) 0xc5, (byte) 0x44, (byte) 0xf1, (byte) 0x58, (byte) 0x90, (byte) 0xdb, (byte) 0x5b,\n-            (byte) 0x70, (byte) 0xe, (byte) 0xbb, (byte) 0xf5, (byte) 0x6, (byte) 0xc5, (byte) 0x19, (byte) 0xc5,\n-            (byte) 0xd4, (byte) 0xf6, (byte) 0xad, (byte) 0xbe, (byte) 0x18, (byte) 0x2d, (byte) 0x52, (byte) 0x13,\n-            (byte) 0xd9, (byte) 0x2e, (byte) 0x3, (byte) 0x27, (byte) 0x2c, (byte) 0x79, (byte) 0x3c, (byte) 0x84,\n-            (byte) 0x2, (byte) 0xf, (byte) 0x29, (byte) 0x39, (byte) 0xd, (byte) 0xea, (byte) 0x7d, (byte) 0x3b,\n-            (byte) 0x75, (byte) 0xcb, (byte) 0x70, (byte) 0xe7, (byte) 0x75, (byte) 0xe2, (byte) 0x6, (byte) 0xdc,\n-            (byte) 0xfd, (byte) 0x2, (byte) 0x8d, (byte) 0x84, (byte) 0xe2, (byte) 0x74, (byte) 0xfc, (byte) 0x73,\n-            (byte) 0x55, (byte) 0x5d, (byte) 0x1b, (byte) 0xa6, (byte) 0x94, (byte) 0xed, (byte) 0xb1, (byte) 0xb7,\n-            (byte) 0x60, (byte) 0x4f, (byte) 0xc3, (byte) 0x4d, (byte) 0x3d, (byte) 0x2, (byte) 0xb9, (byte) 0xf8,\n-            (byte) 0x3, (byte) 0x88, (byte) 0xdb, (byte) 0x88, (byte) 0xf6, (byte) 0x48, (byte) 0x67, (byte) 0x6d,\n-            (byte) 0xaf, (byte) 0x72, (byte) 0xa5, (byte) 0xcb, (byte) 0x1a, (byte) 0xab, (byte) 0x49, (byte) 0x6e,\n-            (byte) 0x25, (byte) 0x45, (byte) 0x99, (byte) 0x80, (byte) 0xc3, (byte) 0x14, (byte) 0xc3, (byte) 0x12,\n-            (byte) 0x46, (byte) 0x41, (byte) 0xee, (byte) 0x6, (byte) 0x8f, (byte) 0x68, (byte) 0xe7, (byte) 0x32,\n-            (byte) 0xc4, (byte) 0xd2, (byte) 0x79, (byte) 0x6f, (byte) 0xe8, (byte) 0x4a, (byte) 0x2, (byte) 0xc5,\n-            (byte) 0x29, (byte) 0x44, (byte) 0x15, (byte) 0x52, (byte) 0x34, (byte) 0x2, (byte) 0xd1, (byte) 0x72,\n-            (byte) 0x43, (byte) 0x48, (byte) 0xb1, (byte) 0x0, (byte) 0xea, (byte) 0x1, (byte) 0x1d, (byte) 0x88,\n-            (byte) 0x49, (byte) 0xae, (byte) 0xc0, (byte) 0x96, (byte) 0xea, (byte) 0x4f, (byte) 0x5a, (byte) 0x6f,\n-            (byte) 0xd2, (byte) 0x9a, (byte) 0x36, (byte) 0x8d, (byte) 0xbd, (byte) 0x88, (byte) 0xc1, (byte) 0xd4,\n-            (byte) 0x77, (byte) 0x8c, (byte) 0xcd, (byte) 0x2d, (byte) 0x3e, (byte) 0xaa, (byte) 0xce, (byte) 0x37,\n-            (byte) 0x18, (byte) 0x9e, (byte) 0x24, (byte) 0x6e, (byte) 0xe0, (byte) 0xdf, (byte) 0xe0, (byte) 0xb9,\n-            (byte) 0xfa, (byte) 0x4a, (byte) 0xf3, (byte) 0x50, (byte) 0xbd, (byte) 0x3d, (byte) 0x4b, (byte) 0x0,\n-            (byte) 0xac, (byte) 0xd0, (byte) 0xb9, (byte) 0x46, (byte) 0x1e, (byte) 0xa3, (byte) 0xc7, (byte) 0xdb,\n-            (byte) 0x42, (byte) 0xd3, (byte) 0x30, (byte) 0xb4, (byte) 0x90, (byte) 0x56, (byte) 0xaf, (byte) 0x86,\n-            (byte) 0xd4, (byte) 0x89, (byte) 0x58, (byte) 0x1e, (byte) 0xd3, (byte) 0xa1, (byte) 0x4c, (byte) 0x76,\n-            (byte) 0xe1, (byte) 0x1b, (byte) 0xdc, (byte) 0x84, (byte) 0xd9, (byte) 0x23, (byte) 0xe4, (byte) 0x2b,\n-            (byte) 0x7, (byte) 0x91, (byte) 0x73, (byte) 0x8e, (byte) 0x65, (byte) 0x1d, (byte) 0x48, (byte) 0xf7,\n-            (byte) 0x20, (byte) 0x11, (byte) 0xfc, (byte) 0xea, (byte) 0x31, (byte) 0xd1, (byte) 0x59, (byte) 0x55,\n-            (byte) 0x36, (byte) 0x69, (byte) 0x20, (byte) 0x73, (byte) 0x62, (byte) 0x75, (byte) 0x9c, (byte) 0x74,\n-            (byte) 0x1d, (byte) 0x2f, (byte) 0xa5, (byte) 0xfd, (byte) 0xb7, (byte) 0xf6, (byte) 0x52, (byte) 0x7b,\n-            (byte) 0xd3, (byte) 0x52, (byte) 0xde, (byte) 0x52, (byte) 0x2b, (byte) 0x97, (byte) 0xab, (byte) 0x6,\n-            (byte) 0x44, (byte) 0x95, (byte) 0x5a, (byte) 0x34, (byte) 0xce, (byte) 0x3e, (byte) 0x5a, (byte) 0x82,\n-            (byte) 0xa0, (byte) 0x9f, (byte) 0xe, (byte) 0xfd, (byte) 0x7d, (byte) 0x87, (byte) 0xe7, (byte) 0x4c,\n-            (byte) 0xc, (byte) 0xf1, (byte) 0x13, (byte) 0xc2, (byte) 0x36, (byte) 0xb8, (byte) 0x59, (byte) 0xdc,\n-            (byte) 0xf8, (byte) 0x23, (byte) 0xdd, (byte) 0x59, (byte) 0x25, (byte) 0x2d, (byte) 0x35, (byte) 0xdd,\n-            (byte) 0xc3, (byte) 0x0, (byte) 0x9e, (byte) 0xa7, (byte) 0x7b, (byte) 0x77, (byte) 0x20, (byte) 0xe9,\n-            (byte) 0xd9, (byte) 0x1, (byte) 0x7e, (byte) 0xed, (byte) 0xcd, (byte) 0xd4, (byte) 0xc5, (byte) 0x16,\n-            (byte) 0xcc, (byte) 0xcb, (byte) 0x60, (byte) 0xca, (byte) 0xe1, (byte) 0xd, (byte) 0x76, (byte) 0x24,\n-            (byte) 0x16, (byte) 0x70, (byte) 0x70, (byte) 0x1, (byte) 0xfd, (byte) 0xd8, (byte) 0xc7, (byte) 0x5f,\n-            (byte) 0x51, (byte) 0x9e, (byte) 0xd8, (byte) 0xd3, (byte) 0xd1, (byte) 0x42, (byte) 0x1, (byte) 0x11,\n-            (byte) 0xbe, (byte) 0xf7, (byte) 0x3c, (byte) 0xb9, (byte) 0xfd, (byte) 0xd5, (byte) 0x9e, (byte) 0xd,\n-            (byte) 0x1d, (byte) 0x4c, (byte) 0x14, (byte) 0xe7, (byte) 0x10, (byte) 0xa0, (byte) 0x94, (byte) 0x59,\n-            (byte) 0xb7, (byte) 0xce, (byte) 0xc7, (byte) 0xed, (byte) 0xa6, (byte) 0xfa, (byte) 0xfa, (byte) 0x5c,\n-            (byte) 0x6b, (byte) 0xe9, (byte) 0xd4, (byte) 0x9b, (byte) 0x2b, (byte) 0xe3, (byte) 0x82, (byte) 0x23,\n-            (byte) 0x9a, (byte) 0xaf, (byte) 0xc, (byte) 0xd1, (byte) 0xa9, (byte) 0x6a, (byte) 0x8c, (byte) 0xd4,\n-            (byte) 0x6c, (byte) 0x57, (byte) 0x4f, (byte) 0x97, (byte) 0x24, (byte) 0x32, (byte) 0xb2, (byte) 0x3f,\n-            (byte) 0xd5, (byte) 0xdc, (byte) 0xb0, (byte) 0x64, (byte) 0x24, (byte) 0x15, (byte) 0x24, (byte) 0x92,\n-            (byte) 0xe, (byte) 0x7f, (byte) 0x81, (byte) 0xa3, (byte) 0x8a, (byte) 0x48, (byte) 0xf8, (byte) 0x10,\n-            (byte) 0xb6, (byte) 0x2e, (byte) 0x4b, (byte) 0x3c, (byte) 0xc5, (byte) 0xaa, (byte) 0xce, (byte) 0x21,\n-            (byte) 0x5b, (byte) 0x25, (byte) 0x5b, (byte) 0xbf, (byte) 0x59, (byte) 0xbf, (byte) 0x61, (byte) 0xb0,\n-            (byte) 0x1e, (byte) 0xc0, (byte) 0x4, (byte) 0xbe, (byte) 0x6a, (byte) 0xf9, (byte) 0xce, (byte) 0x35,\n-            (byte) 0xe7, (byte) 0x35, (byte) 0x4b, (byte) 0x50, (byte) 0xe, (byte) 0x3c, (byte) 0xe1, (byte) 0x64,\n-            (byte) 0xdc, (byte) 0xe5, (byte) 0x4b, (byte) 0x35, (byte) 0xf1, (byte) 0x15, (byte) 0xe0, (byte) 0x30,\n-            (byte) 0x5b, (byte) 0xc2, (byte) 0x41, (byte) 0xe0, (byte) 0x1b, (byte) 0xfd, (byte) 0xff, (byte) 0x0,\n-            (byte) 0xc2, (byte) 0xae, (byte) 0xae, (byte) 0x97, (byte) 0x89, (byte) 0xa8, (byte) 0xdd, (byte) 0x5d,\n-            (byte) 0x61, (byte) 0x38, (byte) 0xb3, (byte) 0xa8, (byte) 0x8e, (byte) 0x57, (byte) 0x6a, (byte) 0xcf,\n-            (byte) 0xa7, (byte) 0x6f, (byte) 0xd9, (byte) 0x40, (byte) 0xdf, (byte) 0x68, (byte) 0xdc, (byte) 0xab,\n-            (byte) 0x37, (byte) 0x24, (byte) 0xd4, (byte) 0xa6, (byte) 0x38, (byte) 0xf1, (byte) 0x45, (byte) 0xe7,\n-            (byte) 0x1f, (byte) 0x91, (byte) 0xaa, (byte) 0x39, (byte) 0x29, (byte) 0x65, (byte) 0x6e, (byte) 0xed,\n-            (byte) 0x5a, (byte) 0x15, (byte) 0x1e, (byte) 0x37, (byte) 0x47, (byte) 0x30, (byte) 0xd2, (byte) 0x40,\n-            (byte) 0x3b, (byte) 0x9b, (byte) 0x7d, (byte) 0x53, (byte) 0x3d, (byte) 0xaf, (byte) 0x67, (byte) 0xdd,\n-            (byte) 0xf7, (byte) 0x14, (byte) 0x58, (byte) 0xaa, (byte) 0xd1, (byte) 0x9d, (byte) 0xd5, (byte) 0x49,\n-            (byte) 0xc1, (byte) 0x65, (byte) 0xe5, (byte) 0x51, (byte) 0x9c, (byte) 0x7d, (byte) 0xc7, (byte) 0x3,\n-            (byte) 0xc3, (byte) 0x4d, (byte) 0xb2, (byte) 0x92, (byte) 0x69, (byte) 0x8d, (byte) 0x98, (byte) 0xd2,\n-            (byte) 0xa4, (byte) 0x49, (byte) 0x89, (byte) 0x61, (byte) 0x94, (byte) 0xf, (byte) 0x7d, (byte) 0x44,\n-            (byte) 0x92, (byte) 0x0, (byte) 0xe7, (byte) 0xda, (byte) 0xfa, (byte) 0xdc, (byte) 0x9b, (byte) 0x6d,\n-            (byte) 0xa0, (byte) 0xb9, (byte) 0x56, (byte) 0x47, (byte) 0x5, (byte) 0xf0, (byte) 0x2c, (byte) 0x5b,\n-            (byte) 0x4d, (byte) 0x94, (byte) 0xdc, (byte) 0x37, (byte) 0x7, (byte) 0xf9, (byte) 0x97, (byte) 0x81,\n-            (byte) 0xe6, (byte) 0x54, (byte) 0x89, (byte) 0x8a, (byte) 0xa2, (byte) 0x1f, (byte) 0x33, (byte) 0x8c,\n-            (byte) 0x73, (byte) 0x1f, (byte) 0x7e, (byte) 0x9d, (byte) 0x4f, (byte) 0x7d, (byte) 0x5f, (byte) 0xd1,\n-            (byte) 0x61, (byte) 0xdc, (byte) 0x1b, (byte) 0x3e, (byte) 0x53, (byte) 0x72, (byte) 0x36, (byte) 0x1c,\n-            (byte) 0xbf, (byte) 0x9f, (byte) 0xe, (byte) 0xeb, (byte) 0x3a, (byte) 0xc7, (byte) 0xf1, (byte) 0xf8,\n-            (byte) 0xab, (byte) 0x9e, (byte) 0xf6, (byte) 0xd1, (byte) 0x47, (byte) 0x90, (byte) 0x3b, (byte) 0xcc,\n-            (byte) 0xed, (byte) 0x8b, (byte) 0xfb, (byte) 0x81, (byte) 0xa5, (byte) 0xbb, (byte) 0xdc, (byte) 0xf6,\n-            (byte) 0xd4, (byte) 0x2b, (byte) 0x1e, (byte) 0x26, (byte) 0xe6, (byte) 0x41, (byte) 0x9e, (byte) 0xfa,\n-            (byte) 0xb8, (byte) 0xe, (byte) 0xb8, (byte) 0x41, (byte) 0xce, (byte) 0x65, (byte) 0x8a, (byte) 0x5,\n-            (byte) 0xea, (byte) 0x83, (byte) 0xe1, (byte) 0xa7, (byte) 0x4b, (byte) 0x41, (byte) 0x56, (byte) 0x65,\n-            (byte) 0x2d, (byte) 0xbb, (byte) 0xb7, (byte) 0x7, (byte) 0x90, (byte) 0x12, (byte) 0x3c, (byte) 0x34,\n-            (byte) 0xc3, (byte) 0xa3, (byte) 0xd5, (byte) 0x26, (byte) 0xeb, (byte) 0x4c, (byte) 0x5b, (byte) 0x6c,\n-            (byte) 0x68, (byte) 0x73, (byte) 0xca, (byte) 0x33, (byte) 0xa4, (byte) 0xf0, (byte) 0xc0, (byte) 0x49,\n-            (byte) 0x25, (byte) 0x1f, (byte) 0x14, (byte) 0x41, (byte) 0x40, (byte) 0xd7, (byte) 0x53, (byte) 0x64,\n-            (byte) 0x22, (byte) 0x54, (byte) 0x79, (byte) 0x69, (byte) 0x4, (byte) 0xaf, (byte) 0x6, (byte) 0xa2,\n-            (byte) 0xe2, (byte) 0xfa, (byte) 0x53, (byte) 0xd7, (byte) 0x5d, (byte) 0x1a, (byte) 0x4, (byte) 0xd3,\n-            (byte) 0x85, (byte) 0xca, (byte) 0xff, (byte) 0xd9, (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2,\n-            (byte) 0xa, (byte) 0x0, (byte) 0xa, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x37, (byte) 0xa4, (byte) 0x5c, (byte) 0x38, (byte) 0x52, (byte) 0x69, (byte) 0x4c, (byte) 0x69,\n-            (byte) 0x24, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x24, (byte) 0x6, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x1b, (byte) 0x0, (byte) 0x7, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x72, (byte) 0x65, (byte) 0x73, (byte) 0x2f, (byte) 0x64, (byte) 0x72,\n-            (byte) 0x61, (byte) 0x77, (byte) 0x61, (byte) 0x62, (byte) 0x6c, (byte) 0x65, (byte) 0x2f, (byte) 0x73,\n-            (byte) 0x69, (byte) 0x7a, (byte) 0x65, (byte) 0x5f, (byte) 0x34, (byte) 0x38, (byte) 0x78, (byte) 0x34,\n-            (byte) 0x38, (byte) 0x2e, (byte) 0x6a, (byte) 0x70, (byte) 0x67, (byte) 0xfe, (byte) 0xca, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n-            (byte) 0x50, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x64, (byte) 0x6, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0,\n-    };\n-\n-    \/*\n-     * Jar file created by Apache Commons-Compress which creates\n-     * a CEN entry with a Zip64 extra header entry with a size of 0\n-     *    ----------------#1--------------------\n-     *            [Central Directory Header]\n-     *            0x52b: Signature        : 0x02014b50\n-     *            0x52f: Created Zip Spec :       0x2d [4.5]\n-     *            0x530: Created OS       :        0x3 [UNIX]\n-     *            0x531: VerMadeby        :      0x32d [3, 4.5]\n-     *            0x532: VerExtract       :       0x2d [4.5]\n-     *            0x533: Flag             :      0x800\n-     *            0x535: Method           :        0x0 [STORED]\n-     *            0x537: Last Mod Time    : 0x570169c0 [Tue Aug 01 13:14:00 EDT 2023]\n-     *            0x53b: CRC              :        0x0\n-     *            0x53f: Compressed Size  :        0x0\n-     *            0x543: Uncompressed Size:        0x0\n-     *            0x547: Name Length      :        0x9\n-     *            0x549: Extra Length     :        0x8\n-     *            [tag=0x0001, sz=0, data= ]\n-     *                ->ZIP64:\n-     *            [tag=0xcafe, sz=0, data= ]\n-     *                 ->[tag=cafe, size=0]\n-     *            0x54b: Comment Length   :        0x0\n-     *            0x54d: Disk Start       :        0x0\n-     *            0x54f: Attrs            :        0x0\n-     *            0x551: AttrsEx          : 0x41ed0010\n-     *            0x555: Loc Header Offset:        0x0\n-     *            0x559: File Name        : META-INF\/\n-     *\/\n-    public static byte[] COMMONS_COMPRESS_JAR = {\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n-            (byte) 0x0, (byte) 0x0, (byte) 0xc0, (byte) 0x69, (byte) 0x1, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x18, (byte) 0x0, (byte) 0x4d, (byte) 0x45,\n-            (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f, (byte) 0x1,\n-            (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xfe, (byte) 0xca, (byte) 0x0, (byte) 0x0, (byte) 0x50,\n-            (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8,\n-            (byte) 0x0, (byte) 0xbd, (byte) 0x69, (byte) 0x1, (byte) 0x57, (byte) 0x71, (byte) 0xa7, (byte) 0x16,\n-            (byte) 0x53, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0x14, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x4d, (byte) 0x45, (byte) 0x54,\n-            (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f, (byte) 0x4d, (byte) 0x41,\n-            (byte) 0x4e, (byte) 0x49, (byte) 0x46, (byte) 0x45, (byte) 0x53, (byte) 0x54, (byte) 0x2e, (byte) 0x4d,\n-            (byte) 0x46, (byte) 0x1, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x68, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x5b, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xf3, (byte) 0x4d, (byte) 0xcc,\n-            (byte) 0xcb, (byte) 0x4c, (byte) 0x4b, (byte) 0x2d, (byte) 0x2e, (byte) 0xd1, (byte) 0xd, (byte) 0x4b,\n-            (byte) 0x2d, (byte) 0x2a, (byte) 0xce, (byte) 0xcc, (byte) 0xcf, (byte) 0xb3, (byte) 0x52, (byte) 0x30,\n-            (byte) 0xd4, (byte) 0x33, (byte) 0xe0, (byte) 0xe5, (byte) 0x72, (byte) 0xcc, (byte) 0x43, (byte) 0x12,\n-            (byte) 0x71, (byte) 0x2c, (byte) 0x48, (byte) 0x4c, (byte) 0xce, (byte) 0x48, (byte) 0x55, (byte) 0x0,\n-            (byte) 0x8a, (byte) 0x1, (byte) 0x25, (byte) 0xd, (byte) 0xd, (byte) 0xf4, (byte) 0x2c, (byte) 0x78,\n-            (byte) 0xb9, (byte) 0x9c, (byte) 0x8b, (byte) 0x52, (byte) 0x13, (byte) 0x4b, (byte) 0x52, (byte) 0x53,\n-            (byte) 0x74, (byte) 0x9d, (byte) 0x2a, (byte) 0x81, (byte) 0x1a, (byte) 0x2c, (byte) 0xf4, (byte) 0xc,\n-            (byte) 0xf4, (byte) 0x80, (byte) 0x12, (byte) 0xda, (byte) 0x46, (byte) 0xba, (byte) 0x66, (byte) 0xa,\n-            (byte) 0x1a, (byte) 0xfe, (byte) 0x45, (byte) 0x89, (byte) 0xc9, (byte) 0x39, (byte) 0xa9, (byte) 0xa,\n-            (byte) 0xce, (byte) 0xf9, (byte) 0x45, (byte) 0x5, (byte) 0xf9, (byte) 0x45, (byte) 0x89, (byte) 0x25,\n-            (byte) 0x40, (byte) 0x3, (byte) 0x34, (byte) 0x79, (byte) 0xb9, (byte) 0x78, (byte) 0xb9, (byte) 0x0,\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n-            (byte) 0x8, (byte) 0x0, (byte) 0x61, (byte) 0x69, (byte) 0x1, (byte) 0x57, (byte) 0x16, (byte) 0x64,\n-            (byte) 0x9c, (byte) 0xc5, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0x19, (byte) 0x0, (byte) 0x14, (byte) 0x0, (byte) 0x5a, (byte) 0x69,\n-            (byte) 0x70, (byte) 0x46, (byte) 0x69, (byte) 0x6c, (byte) 0x65, (byte) 0x50, (byte) 0x72, (byte) 0x6f,\n-            (byte) 0x70, (byte) 0x65, (byte) 0x72, (byte) 0x74, (byte) 0x79, (byte) 0x54, (byte) 0x65, (byte) 0x73,\n-            (byte) 0x74, (byte) 0x2e, (byte) 0x63, (byte) 0x6c, (byte) 0x61, (byte) 0x73, (byte) 0x73, (byte) 0x1,\n-            (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0xf, (byte) 0x7, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x85, (byte) 0x55, (byte) 0xcf, (byte) 0x53, (byte) 0xdb,\n-            (byte) 0x46, (byte) 0x14, (byte) 0xfe, (byte) 0xd6, (byte) 0x3f, (byte) 0x90, (byte) 0x2d, (byte) 0x8b,\n-            (byte) 0x38, (byte) 0x36, (byte) 0x21, (byte) 0xc1, (byte) 0x34, (byte) 0x4, (byte) 0x12, (byte) 0x70,\n-            (byte) 0x63, (byte) 0xb0, (byte) 0x8d, (byte) 0xdb, (byte) 0x42, (byte) 0xd3, (byte) 0x36, (byte) 0xa6,\n-            (byte) 0xf9, (byte) 0x45, (byte) 0x42, (byte) 0xb, (byte) 0x35, (byte) 0xe0, (byte) 0x62, (byte) 0x87,\n-            (byte) 0xd4, (byte) 0xa4, (byte) 0x6d, (byte) 0x22, (byte) 0xdb, (byte) 0x4a, (byte) 0x22, (byte) 0x2a,\n-            (byte) 0x4b, (byte) 0x1a, (byte) 0x49, (byte) 0x2e, (byte) 0x49, (byte) 0x67, (byte) 0x7a, (byte) 0xe8,\n-            (byte) 0x4c, (byte) 0xcf, (byte) 0x9d, (byte) 0x69, (byte) 0xfe, (byte) 0x82, (byte) 0xde, (byte) 0x38,\n-            (byte) 0xf5, (byte) 0x40, (byte) 0xe, (byte) 0x86, (byte) 0x94, (byte) 0x49, (byte) 0x73, (byte) 0xcb,\n-            (byte) 0x21, (byte) 0xff, (byte) 0x51, (byte) 0x2f, (byte) 0xa5, (byte) 0x6f, (byte) 0x25, (byte) 0xc0,\n-            (byte) 0x86, (byte) 0x98, (byte) 0x29, (byte) 0xcc, (byte) 0x68, (byte) 0x77, (byte) 0xdf, (byte) 0xee,\n-            (byte) 0xf7, (byte) 0xbd, (byte) 0xf7, (byte) 0xbe, (byte) 0xf7, (byte) 0x76, (byte) 0xfd, (byte) 0xf6,\n-            (byte) 0xdf, (byte) 0xbf, (byte) 0xfe, (byte) 0x6, (byte) 0x70, (byte) 0xb, (byte) 0xf, (byte) 0x45,\n-            (byte) 0xf8, (byte) 0xe0, (byte) 0x17, (byte) 0x10, (byte) 0x90, (byte) 0x10, (byte) 0x44, (byte) 0xf,\n-            (byte) 0xc3, (byte) 0xe9, (byte) 0x75, (byte) 0xf9, (byte) 0x47, (byte) 0x39, (byte) 0xa7, (byte) 0xc9,\n-            (byte) 0xfa, (byte) 0xe3, (byte) 0xdc, (byte) 0x72, (byte) 0x75, (byte) 0x5d, (byte) 0xa9, (byte) 0x39,\n-            (byte) 0xc, (byte) 0x3d, (byte) 0x33, (byte) 0xaa, (byte) 0xae, (byte) 0x3a, (byte) 0xd7, (byte) 0x18,\n-            (byte) 0xfc, (byte) 0xa9, (byte) 0xf1, (byte) 0x55, (byte) 0x1, (byte) 0x21, (byte) 0x86, (byte) 0xbe,\n-            (byte) 0x35, (byte) 0xd5, (byte) 0x9c, (byte) 0x53, (byte) 0x35, (byte) 0xa5, (byte) 0x68, (byte) 0x19,\n-            (byte) 0xa6, (byte) 0x62, (byte) 0x39, (byte) 0xcf, (byte) 0xca, (byte) 0x8a, (byte) 0xed, (byte) 0x88,\n-            (byte) 0x10, (byte) 0xe0, (byte) 0xe7, (byte) 0x9f, (byte) 0x88, (byte) 0x4, (byte) 0x89, (byte) 0x33,\n-            (byte) 0x9d, (byte) 0xb2, (byte) 0x14, (byte) 0xb9, (byte) 0x5e, (byte) 0x52, (byte) 0xf5, (byte) 0xc7,\n-            (byte) 0x9a, (byte) 0xc2, (byte) 0xcf, (byte) 0xa, (byte) 0x38, (byte) 0xc5, (byte) 0xd0, (byte) 0xef,\n-            (byte) 0xb2, (byte) 0x37, (byte) 0x1d, (byte) 0x55, (byte) 0xcb, (byte) 0xfd, (byte) 0xa4, (byte) 0x9a,\n-            (byte) 0xb9, (byte) 0x7d, (byte) 0x9a, (byte) 0x10, (byte) 0x4e, (byte) 0x33, (byte) 0x64, (byte) 0x72,\n-            (byte) 0x77, (byte) 0x6d, (byte) 0xc5, (byte) 0xb2, (byte) 0x73, (byte) 0xda, (byte) 0xba, (byte) 0xac,\n-            (byte) 0xd7, (byte) 0xf9, (byte) 0xe4, (byte) 0xb6, (byte) 0xb1, (byte) 0xa1, (byte) 0x6b, (byte) 0x86,\n-            (byte) 0x5c, (byte) 0xb7, (byte) 0x73, (byte) 0x1b, (byte) 0xb5, (byte) 0x29, (byte) 0xab, (byte) 0x6e,\n-            (byte) 0xca, (byte) 0xe4, (byte) 0x48, (byte) 0x53, (byte) 0xab, (byte) 0xf6, (byte) 0xe4, (byte) 0xba,\n-            (byte) 0x6c, (byte) 0x89, (byte) 0xe8, (byte) 0x45, (byte) 0x9c, (byte) 0x47, (byte) 0xdc, (byte) 0x47,\n-            (byte) 0x9c, (byte) 0xa9, (byte) 0x42, (byte) 0x3b, (byte) 0xe6, (byte) 0x92, (byte) 0x63, (byte) 0x91,\n-            (byte) 0xc7, (byte) 0xfc, (byte) 0xf8, (byte) 0x6a, (byte) 0x18, (byte) 0xfd, (byte) 0x38, (byte) 0x2b,\n-            (byte) 0xe0, (byte) 0x9c, (byte) 0x84, (byte) 0x1, (byte) 0x24, (byte) 0x8e, (byte) 0xa4, (byte) 0x55,\n-            (byte) 0x7a, (byte) 0x66, (byte) 0x3b, (byte) 0x4a, (byte) 0x83, (byte) 0xb2, (byte) 0x31, (byte) 0x9a,\n-            (byte) 0x94, (byte) 0x5c, (byte) 0xbf, (byte) 0x7, (byte) 0x56, (byte) 0x8d, (byte) 0x5c, (byte) 0x91,\n-            (byte) 0x90, (byte) 0xe, (byte) 0xe1, (byte) 0x15, (byte) 0xb9, (byte) 0x91, (byte) 0xf, (byte) 0xe1,\n-            (byte) 0x3d, (byte) 0xc2, (byte) 0xf0, (byte) 0xd8, (byte) 0x46, (byte) 0x92, (byte) 0xf6, (byte) 0x8,\n-            (byte) 0x25, (byte) 0xa9, (byte) 0x2b, (byte) 0xf5, (byte) 0xa4, (byte) 0x2e, (byte) 0x62, (byte) 0x8,\n-            (byte) 0x17, (byte) 0x4, (byte) 0xc, (byte) 0x4b, (byte) 0x18, (byte) 0xc1, (byte) 0x45, (byte) 0x52,\n-            (byte) 0xa1, (byte) 0xb, (byte) 0x92, (byte) 0xd4, (byte) 0x32, (byte) 0xf9, (byte) 0xea, (byte) 0x11,\n-            (byte) 0xc3, (byte) 0x4c, (byte) 0x97, (byte) 0xb8, (byte) 0xee, (byte) 0x17, (byte) 0x8e, (byte) 0xcb,\n-            (byte) 0x9b, (byte) 0x1f, (byte) 0xef, (byte) 0x1a, (byte) 0x0, (byte) 0x4f, (byte) 0x70, (byte) 0x54,\n-            (byte) 0xc2, (byte) 0x18, (byte) 0x17, (byte) 0x32, (byte) 0x58, (byte) 0xd3, (byte) 0xc, (byte) 0x9b,\n-            (byte) 0xf4, (byte) 0x7b, (byte) 0xff, (byte) 0xc0, (byte) 0xa5, (byte) 0xb, (byte) 0x2f, (byte) 0x3f,\n-            (byte) 0xb1, (byte) 0x8c, (byte) 0xd, (byte) 0xb9, (byte) 0xaa, (byte) 0x29, (byte) 0x22, (byte) 0x92,\n-            (byte) 0x48, (byte) 0x49, (byte) 0x18, (byte) 0xc7, (byte) 0x4, (byte) 0x43, (byte) 0xaf, (byte) 0x5c,\n-            (byte) 0xaf, (byte) 0x97, (byte) 0x9a, (byte) 0xa6, (byte) 0x69, (byte) 0x29, (byte) 0xb6, (byte) 0xad,\n-            (byte) 0xd4, (byte) 0x19, (byte) 0x6, (byte) 0x3a, (byte) 0x63, (byte) 0x38, (byte) 0x44, (byte) 0xe4,\n-            (byte) 0x79, (byte) 0x19, (byte) 0x33, (byte) 0x1d, (byte) 0x9, (byte) 0xcc, (byte) 0x2f, (byte) 0xdf,\n-            (byte) 0x79, (byte) 0x5a, (byte) 0x53, (byte) 0x4c, (byte) 0x47, (byte) 0x35, (byte) 0x74, (byte) 0x1,\n-            (byte) 0x93, (byte) 0xc, (byte) 0x83, (byte) 0x6d, (byte) 0xd0, (byte) 0x4a, (byte) 0x53, (byte) 0x77,\n-            (byte) 0xd4, (byte) 0x86, (byte) 0x72, (byte) 0xb8, (byte) 0x2f, (byte) 0x22, (byte) 0x8b, (byte) 0xf,\n-            (byte) 0xb8, (byte) 0xf2, (byte) 0x13, (byte) 0x2, (byte) 0x3e, (byte) 0x3a, (byte) 0xaa, (byte) 0xab,\n-            (byte) 0x9b, (byte) 0x62, (byte) 0x4, (byte) 0xd3, (byte) 0xf8, (byte) 0x58, (byte) 0xc0, (byte) 0x15,\n-            (byte) 0x9, (byte) 0x9f, (byte) 0xe0, (byte) 0x53, (byte) 0x86, (byte) 0xb8, (byte) 0xbb, (byte) 0xaf,\n-            (byte) 0x93, (byte) 0x8f, (byte) 0x47, (byte) 0x24, (byte) 0x66, (byte) 0xae, (byte) 0x28, (byte) 0x3b,\n-            (byte) 0x4f, (byte) 0x18, (byte) 0x7c, (byte) 0x6, (byte) 0xc9, (byte) 0x93, (byte) 0xff, (byte) 0x1f,\n-            (byte) 0x79, (byte) 0xe, (byte) 0x2a, (byte) 0x59, (byte) 0x78, (byte) 0x97, (byte) 0x21, (byte) 0x1f,\n-            (byte) 0xc1, (byte) 0x55, (byte) 0xe4, (byte) 0x5, (byte) 0xcc, (byte) 0x70, (byte) 0x27, (byte) 0x9f,\n-            (byte) 0x53, (byte) 0xd6, (byte) 0xed, (byte) 0xae, (byte) 0x5a, (byte) 0x94, (byte) 0x4d, (byte) 0x86,\n-            (byte) 0x58, (byte) 0x6a, (byte) 0x1f, (byte) 0x75, (byte) 0x60, (byte) 0x22, (byte) 0x39, (byte) 0xaf,\n-            (byte) 0xe3, (byte) 0x86, (byte) 0x80, (byte) 0x9b, (byte) 0x12, (byte) 0x75, (byte) 0xfc, (byte) 0x2c,\n-            (byte) 0x43, (byte) 0xe2, (byte) 0x28, (byte) 0x27, (byte) 0xaf, (byte) 0xb3, (byte) 0xd7, (byte) 0x15,\n-            (byte) 0x36, (byte) 0x91, (byte) 0xe9, (byte) 0xca, (byte) 0x46, (byte) 0xdb, (byte) 0xc0, (byte) 0x70,\n-            (byte) 0x3d, (byte) 0xd5, (byte) 0x2d, (byte) 0x82, (byte) 0x63, (byte) 0xfc, (byte) 0xc7, (byte) 0xa3,\n-            (byte) 0x6c, (byte) 0x13, (byte) 0x50, (byte) 0x2b, (byte) 0xdd, (byte) 0x61, (byte) 0x88, (byte) 0x74,\n-            (byte) 0x74, (byte) 0x11, (byte) 0x57, (byte) 0xe8, (byte) 0xb, (byte) 0x9, (byte) 0x5f, (byte) 0x62,\n-            (byte) 0x9e, (byte) 0xee, (byte) 0x88, (byte) 0x63, (byte) 0xdc, (byte) 0xac, (byte) 0xda, (byte) 0x86,\n-            (byte) 0xd6, (byte) 0x74, (byte) 0x14, (byte) 0x4f, (byte) 0x9a, (byte) 0xb3, (byte) 0xa9, (byte) 0x13,\n-            (byte) 0x12, (byte) 0x9e, (byte) 0xc6, (byte) 0x57, (byte) 0x12, (byte) 0xa, (byte) 0x58, (byte) 0x64,\n-            (byte) 0x8, (byte) 0x39, (byte) 0x86, (byte) 0xa7, (byte) 0xd, (byte) 0xc3, (byte) 0x99, (byte) 0x83,\n-            (byte) 0xd3, (byte) 0x9d, (byte) 0x8a, (byte) 0x89, (byte) 0x58, (byte) 0xc6, (byte) 0xa8, (byte) 0x80,\n-            (byte) 0x22, (byte) 0x55, (byte) 0xff, (byte) 0xa4, (byte) 0xa0, (byte) 0x42, (byte) 0x58, (byte) 0xa1,\n-            (byte) 0x22, (byte) 0x27, (byte) 0x75, (byte) 0xfe, (byte) 0x3f, (byte) 0x46, (byte) 0x7f, (byte) 0xbc,\n-            (byte) 0xc9, (byte) 0x97, (byte) 0x96, (byte) 0xcb, (byte) 0x1d, (byte) 0x8d, (byte) 0x9e, (byte) 0x46,\n-            (byte) 0x59, (byte) 0xc2, (byte) 0x5d, (byte) 0xde, (byte) 0x7d, (byte) 0x51, (byte) 0xd3, (byte) 0x6b,\n-            (byte) 0x4b, (byte) 0xb9, (byte) 0xf6, (byte) 0x43, (byte) 0xd9, (byte) 0x92, (byte) 0x6b, (byte) 0xa,\n-            (byte) 0x5, (byte) 0xb0, (byte) 0x36, (byte) 0x5f, (byte) 0x7c, (byte) 0x30, (byte) 0x37, (byte) 0x5f,\n-            (byte) 0xa0, (byte) 0xbc, (byte) 0xe2, (byte) 0xef, (byte) 0xba, (byte) 0x27, (byte) 0x5, (byte) 0x67,\n-            (byte) 0xd, (byte) 0xdd, (byte) 0x76, (byte) 0x64, (byte) 0xdd, (byte) 0x59, (byte) 0x95, (byte) 0xb5,\n-            (byte) 0x26, (byte) 0x9d, (byte) 0xf, (byte) 0xcc, (byte) 0x1a, (byte) 0x75, (byte) 0x1a, (byte) 0xa2,\n-            (byte) 0x5, (byte) 0x55, (byte) 0x57, (byte) 0x96, (byte) 0x9a, (byte) 0x8d, (byte) 0xaa, (byte) 0x62,\n-            (byte) 0x95, (byte) 0x79, (byte) 0x17, (byte) 0xd2, (byte) 0x46, (byte) 0x43, (byte) 0x56, (byte) 0x75,\n-            (byte) 0x9e, (byte) 0x73, (byte) 0xb7, (byte) 0xba, (byte) 0xaf, (byte) 0x12, (byte) 0x91, (byte) 0xeb,\n-            (byte) 0x95, (byte) 0xf4, (byte) 0xdd, (byte) 0x3f, (byte) 0x2f, (byte) 0x96, (byte) 0x8c, (byte) 0xa6,\n-            (byte) 0x55, (byte) 0x73, (byte) 0x5f, (byte) 0x13, (byte) 0x4a, (byte) 0xae, (byte) 0xcb, (byte) 0x1b,\n-            (byte) 0x34, (byte) 0xc9, (byte) 0x69, (byte) 0x70, (byte) 0x91, (byte) 0x1e, (byte) 0x21, (byte) 0x1f,\n-            (byte) 0x3d, (byte) 0x6e, (byte) 0x54, (byte) 0x67, (byte) 0xac, (byte) 0xe2, (byte) 0x1e, (byte) 0x8d,\n-            (byte) 0xdf, (byte) 0xd0, (byte) 0xca, (byte) 0x87, (byte) 0x28, (byte) 0xfc, (byte) 0x34, (byte) 0xa7,\n-            (byte) 0x57, (byte) 0x8e, (byte) 0xbe, (byte) 0x15, (byte) 0xb2, (byte) 0xc, (byte) 0xd1, (byte) 0xc8,\n-            (byte) 0x68, (byte) 0xc, (byte) 0x4e, (byte) 0x6c, (byte) 0x83, (byte) 0x6d, (byte) 0xb9, (byte) 0x80,\n-            (byte) 0x35, (byte) 0xfa, (byte) 0xf6, (byte) 0xb8, (byte) 0xc6, (byte) 0x10, (byte) 0xc2, (byte) 0xb8,\n-            (byte) 0x8f, (byte) 0x6f, (byte) 0xf7, (byte) 0x8f, (byte) 0x5e, (byte) 0x26, (byte) 0x38, (byte) 0xb7,\n-            (byte) 0x46, (byte) 0x76, (byte) 0x21, (byte) 0x54, (byte) 0xb6, (byte) 0x11, (byte) 0x6e, (byte) 0x41,\n-            (byte) 0x6c, (byte) 0x3, (byte) 0x44, (byte) 0xd7, (byte) 0x9b, (byte) 0x4, (byte) 0x7e, (byte) 0x67,\n-            (byte) 0x7d, (byte) 0xfc, (byte) 0xed, (byte) 0xf3, (byte) 0x40, (byte) 0xec, (byte) 0xf, (byte) 0x9a,\n-            (byte) 0x5, (byte) 0x69, (byte) 0xe7, (byte) 0xc5, (byte) 0x2e, (byte) 0x7a, (byte) 0x2b, (byte) 0xf1,\n-            (byte) 0xe8, (byte) 0x36, (byte) 0x62, (byte) 0x85, (byte) 0x17, (byte) 0x38, (byte) 0x13, (byte) 0x1f,\n-            (byte) 0xc, (byte) 0xbc, (byte) 0x82, (byte) 0xaf, (byte) 0xe2, (byte) 0x8f, (byte) 0x47, (byte) 0x4b,\n-            (byte) 0x2d, (byte) 0x9c, (byte) 0xbf, (byte) 0x97, (byte) 0x6e, (byte) 0xe1, (byte) 0xd2, (byte) 0x26,\n-            (byte) 0xfa, (byte) 0x16, (byte) 0xbd, (byte) 0x31, (byte) 0xbc, (byte) 0x94, (byte) 0xc9, (byte) 0xb6,\n-            (byte) 0x70, (byte) 0x39, (byte) 0xf3, (byte) 0x7a, (byte) 0x13, (byte) 0xbd, (byte) 0x85, (byte) 0x5d,\n-            (byte) 0x64, (byte) 0x2b, (byte) 0xe9, (byte) 0x6d, (byte) 0xe4, (byte) 0x5e, (byte) 0xc7, (byte) 0xa3,\n-            (byte) 0xfe, (byte) 0x57, (byte) 0xf8, (byte) 0x70, (byte) 0x7, (byte) 0x53, (byte) 0x85, (byte) 0xf4,\n-            (byte) 0xe, (byte) 0x3e, (byte) 0xdb, (byte) 0xc1, (byte) 0xb5, (byte) 0x45, (byte) 0xce, (byte) 0x73,\n-            (byte) 0xdb, (byte) 0xe3, (byte) 0x49, (byte) 0xbf, (byte) 0xc4, (byte) 0x1c, (byte) 0xc3, (byte) 0x4b,\n-            (byte) 0x2c, (byte) 0x30, (byte) 0xb8, (byte) 0x84, (byte) 0x99, (byte) 0x37, (byte) 0x18, (byte) 0xc9,\n-            (byte) 0xb4, (byte) 0xb0, (byte) 0xb4, (byte) 0x89, (byte) 0xc4, (byte) 0x12, (byte) 0xcd, (byte) 0xe3,\n-            (byte) 0xde, (byte) 0x3c, (byte) 0x72, (byte) 0x35, (byte) 0x90, (byte) 0x4d, (byte) 0x4, (byte) 0x88,\n-            (byte) 0x3a, (byte) 0x4b, (byte) 0xd4, (byte) 0xa3, (byte) 0x2e, (byte) 0xfe, (byte) 0xeb, (byte) 0x13,\n-            (byte) 0xf0, (byte) 0x2d, (byte) 0x94, (byte) 0xb6, (byte) 0x28, (byte) 0x72, (byte) 0x11, (byte) 0xe7,\n-            (byte) 0x31, (byte) 0x4a, (byte) 0x4f, (byte) 0xcb, (byte) 0x18, (byte) 0x52, (byte) 0xd4, (byte) 0xd,\n-            (byte) 0x49, (byte) 0xca, (byte) 0x63, (byte) 0xa, (byte) 0x57, (byte) 0x68, (byte) 0xb6, (byte) 0x82,\n-            (byte) 0x6, (byte) 0x9e, (byte) 0xd2, (byte) 0xfa, (byte) 0x67, (byte) 0xfc, (byte) 0x82, (byte) 0x5f,\n-            (byte) 0x69, (byte) 0x5c, (byte) 0xc0, (byte) 0x6f, (byte) 0xf8, (byte) 0x9d, (byte) 0xec, (byte) 0x3e,\n-            (byte) 0x57, (byte) 0x8b, (byte) 0x39, (byte) 0xc4, (byte) 0xe8, (byte) 0x1b, (byte) 0x23, (byte) 0xf4,\n-            (byte) 0x39, (byte) 0xc2, (byte) 0xf, (byte) 0x10, (byte) 0x43, (byte) 0x8c, (byte) 0x70, (byte) 0x83,\n-            (byte) 0x84, (byte) 0x1c, (byte) 0xa0, (byte) 0xbb, (byte) 0x9a, (byte) 0xc0, (byte) 0xd, (byte) 0xb2,\n-            (byte) 0x2e, (byte) 0x90, (byte) 0xf2, (byte) 0x2b, (byte) 0xb8, (byte) 0x40, (byte) 0x3c, (byte) 0xc3,\n-            (byte) 0xc4, (byte) 0x34, (byte) 0x44, (byte) 0xf8, (byte) 0x4b, (byte) 0xc4, (byte) 0x30, (byte) 0x8c,\n-            (byte) 0xe7, (byte) 0xf4, (byte) 0xac, (byte) 0xfe, (byte) 0x49, (byte) 0xd5, (byte) 0xdb, (byte) 0x22,\n-            (byte) 0xd4, (byte) 0x77, (byte) 0xc4, (byte) 0xf2, (byte) 0x10, (byte) 0xd2, (byte) 0x1e, (byte) 0x4d,\n-            (byte) 0x7d, (byte) 0x2, (byte) 0x4, (byte) 0x81, (byte) 0xa4, (byte) 0x65, (byte) 0x2, (byte) 0x92,\n-            (byte) 0x7b, (byte) 0xfc, (byte) 0x47, (byte) 0xc6, (byte) 0x5b, (byte) 0xd3, (byte) 0xca, (byte) 0x35,\n-            (byte) 0x5, (byte) 0xff, (byte) 0x1, (byte) 0xbb, (byte) 0x25, (byte) 0x20, (byte) 0x1d, (byte) 0xde,\n-            (byte) 0x23, (byte) 0x7, (byte) 0xde, (byte) 0xde, (byte) 0xb4, (byte) 0x40, (byte) 0x57, (byte) 0xc0,\n-            (byte) 0x3b, (byte) 0x1e, (byte) 0x41, (byte) 0xe0, (byte) 0xd0, (byte) 0x74, (byte) 0x80, (byte) 0x10,\n-            (byte) 0xf6, (byte) 0x11, (byte) 0xc3, (byte) 0x54, (byte) 0xa7, (byte) 0xef, (byte) 0xdd, (byte) 0xce,\n-            (byte) 0x78, (byte) 0xf0, (byte) 0x1f, (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d,\n-            (byte) 0x3, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0xc0,\n-            (byte) 0x69, (byte) 0x1, (byte) 0x57, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x9,\n-            (byte) 0x0, (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0xed, (byte) 0x41, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e,\n-            (byte) 0x46, (byte) 0x2f, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xfe, (byte) 0xca,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d, (byte) 0x3,\n-            (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0xbd, (byte) 0x69,\n-            (byte) 0x1, (byte) 0x57, (byte) 0x71, (byte) 0xa7, (byte) 0x16, (byte) 0x53, (byte) 0x5b, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x68, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x14, (byte) 0x0,\n-            (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0xa4, (byte) 0x81, (byte) 0x3f, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46,\n-            (byte) 0x2f, (byte) 0x4d, (byte) 0x41, (byte) 0x4e, (byte) 0x49, (byte) 0x46, (byte) 0x45, (byte) 0x53,\n-            (byte) 0x54, (byte) 0x2e, (byte) 0x4d, (byte) 0x46, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d, (byte) 0x3, (byte) 0x2d, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x61, (byte) 0x69, (byte) 0x1, (byte) 0x57,\n-            (byte) 0x16, (byte) 0x64, (byte) 0x9c, (byte) 0xc5, (byte) 0x0, (byte) 0x4, (byte) 0x0, (byte) 0x0,\n-            (byte) 0xf, (byte) 0x7, (byte) 0x0, (byte) 0x0, (byte) 0x19, (byte) 0x0, (byte) 0x4, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0xa4, (byte) 0x81, (byte) 0xe0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x5a, (byte) 0x69,\n-            (byte) 0x70, (byte) 0x46, (byte) 0x69, (byte) 0x6c, (byte) 0x65, (byte) 0x50, (byte) 0x72, (byte) 0x6f,\n-            (byte) 0x70, (byte) 0x65, (byte) 0x72, (byte) 0x74, (byte) 0x79, (byte) 0x54, (byte) 0x65, (byte) 0x73,\n-            (byte) 0x74, (byte) 0x2e, (byte) 0x63, (byte) 0x6c, (byte) 0x61, (byte) 0x73, (byte) 0x73, (byte) 0x1,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x6, (byte) 0x6, (byte) 0x2c,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2d,\n-            (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xd0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2b, (byte) 0x5, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x6, (byte) 0x7, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xfb, (byte) 0x5, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50,\n-            (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3,\n-            (byte) 0x0, (byte) 0x3, (byte) 0x0, (byte) 0xd0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2b,\n-            (byte) 0x5, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-    };\n-\n-    \/*\n-     * Jar file created by Ant specifying zip64mode=\"always\" and createUnicodeExtraFields=\"always\"\n-     * ----------------#1--------------------\n-     * [Central Directory Header]\n-     * 0x51b: Signature        : 0x02014b50\n-     * 0x51f: Created Zip Spec :       0x2d [4.5]\n-     * 0x520: Created OS       :        0x3 [UNIX]\n-     * 0x521: VerMadeby        :      0x32d [3, 4.5]\n-     * 0x522: VerExtract       :       0x2d [4.5]\n-     * 0x523: Flag             :      0x800\n-     * 0x525: Method           :        0x8 [DEFLATED]\n-     * 0x527: Last Mod Time    : 0x570b3767 [Fri Aug 11 06:59:14 EDT 2023]\n-     * 0x52b: CRC              : 0x5e4fa53f\n-     * 0x52f: Compressed Size  : 0xffffffff\n-     * 0x533: Uncompressed Size: 0xffffffff\n-     * 0x537: Name Length      :       0x10\n-     * 0x539: Extra Length     :       0x35\n-     *      Extra data:[01, 00, 18, 00, 87, 04, 00, 00, 00, 00, 00, 00, c7, 02, 00, 00, 00, 00, 00, 00, 15, 01, 00, 00, 00, 00, 00, 00, 75, 70, 15, 00, 01, 94, 82, 60, 61, 52, 65, 61, 64, 41, 6e, 74, 4a, 61, 72, 2e, 63, 6c, 61, 73, 73]\n-     *      [tag=0x0001, sz=24]\n-     *          ->ZIP64: size *0x487 csize *0x2c7 LOC Off *0x115\n-     *          [data= 87 04 00 00 00 00 00 00 c7 02 00 00 00 00 00 00 15 01 00 00 00 00 00 00 ]\n-     *      [tag=0x7075, sz=21]\n-     *          ->[Unknown tag]\n-     *          [data= 01 94 82 60 61 52 65 61 64 41 6e 74 4a 61 72 2e 63 6c 61 73 73 ]\n-     * 0x53b: Comment Length   :        0x0\n-     * 0x53d: Disk Start       :        0x0\n-     * 0x53f: Attrs            :        0x0\n-     * 0x541: AttrsEx          : 0x81a40000\n-     * 0x545: Loc Header Offset: 0xffffffff\n-     * 0x549: File Name        : ReadAntJar.class\n-     *\/\n-    public static byte[] ANT_ZIP64_UNICODE_EXTRA_JAR = {\n-\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x18, (byte) 0x7e, (byte) 0xe, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x2a, (byte) 0x0, (byte) 0x4d, (byte) 0x45,\n-            (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f, (byte) 0x1,\n-            (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xfe, (byte) 0xca, (byte) 0x0, (byte) 0x0, (byte) 0x75,\n-            (byte) 0x70, (byte) 0xe, (byte) 0x0, (byte) 0x1, (byte) 0x8, (byte) 0xa1, (byte) 0x8c, (byte) 0x13,\n-            (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46,\n-            (byte) 0x2f, (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x17, (byte) 0x7e, (byte) 0xe, (byte) 0x57, (byte) 0x31,\n-            (byte) 0x59, (byte) 0x76, (byte) 0x4d, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x14, (byte) 0x0, (byte) 0x31, (byte) 0x0, (byte) 0x4d,\n-            (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f,\n-            (byte) 0x4d, (byte) 0x41, (byte) 0x4e, (byte) 0x49, (byte) 0x46, (byte) 0x45, (byte) 0x53, (byte) 0x54,\n-            (byte) 0x2e, (byte) 0x4d, (byte) 0x46, (byte) 0x1, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x6e,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x61,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x75,\n-            (byte) 0x70, (byte) 0x19, (byte) 0x0, (byte) 0x1, (byte) 0x85, (byte) 0x85, (byte) 0x84, (byte) 0x2,\n-            (byte) 0x4d, (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46,\n-            (byte) 0x2f, (byte) 0x4d, (byte) 0x41, (byte) 0x4e, (byte) 0x49, (byte) 0x46, (byte) 0x45, (byte) 0x53,\n-            (byte) 0x54, (byte) 0x2e, (byte) 0x4d, (byte) 0x46, (byte) 0xf3, (byte) 0x4d, (byte) 0xcc, (byte) 0xcb,\n-            (byte) 0x4c, (byte) 0x4b, (byte) 0x2d, (byte) 0x2e, (byte) 0xd1, (byte) 0xd, (byte) 0x4b, (byte) 0x2d,\n-            (byte) 0x2a, (byte) 0xce, (byte) 0xcc, (byte) 0xcf, (byte) 0xb3, (byte) 0x52, (byte) 0x30, (byte) 0xd4,\n-            (byte) 0x33, (byte) 0xe0, (byte) 0xe5, (byte) 0x72, (byte) 0xcc, (byte) 0x43, (byte) 0x12, (byte) 0x71,\n-            (byte) 0x2c, (byte) 0x48, (byte) 0x4c, (byte) 0xce, (byte) 0x48, (byte) 0x55, (byte) 0x0, (byte) 0x8a,\n-            (byte) 0x1, (byte) 0x25, (byte) 0xd, (byte) 0xd, (byte) 0xf4, (byte) 0xc, (byte) 0x4d, (byte) 0x12,\n-            (byte) 0x73, (byte) 0xa, (byte) 0x32, (byte) 0x12, (byte) 0x79, (byte) 0xb9, (byte) 0x9c, (byte) 0x8b,\n-            (byte) 0x52, (byte) 0x13, (byte) 0x4b, (byte) 0x52, (byte) 0x53, (byte) 0x74, (byte) 0x9d, (byte) 0x2a,\n-            (byte) 0x81, (byte) 0xda, (byte) 0x2c, (byte) 0xf4, (byte) 0x80, (byte) 0x32, (byte) 0x7a, (byte) 0x86,\n-            (byte) 0xda, (byte) 0x46, (byte) 0xba, (byte) 0x66, (byte) 0xa, (byte) 0x1a, (byte) 0xfe, (byte) 0x45,\n-            (byte) 0x89, (byte) 0xc9, (byte) 0x39, (byte) 0xa9, (byte) 0xa, (byte) 0xce, (byte) 0xf9, (byte) 0x45,\n-            (byte) 0x5, (byte) 0xf9, (byte) 0x45, (byte) 0x89, (byte) 0x25, (byte) 0x40, (byte) 0x63, (byte) 0x34,\n-            (byte) 0x79, (byte) 0xb9, (byte) 0x78, (byte) 0xb9, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x3,\n-            (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x67,\n-            (byte) 0x37, (byte) 0xb, (byte) 0x57, (byte) 0x3f, (byte) 0xa5, (byte) 0x4f, (byte) 0x5e, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x10,\n-            (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x52, (byte) 0x65, (byte) 0x61, (byte) 0x64, (byte) 0x41,\n-            (byte) 0x6e, (byte) 0x74, (byte) 0x4a, (byte) 0x61, (byte) 0x72, (byte) 0x2e, (byte) 0x63, (byte) 0x6c,\n-            (byte) 0x61, (byte) 0x73, (byte) 0x73, (byte) 0x1, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x87,\n-            (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xc7,\n-            (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x75,\n-            (byte) 0x70, (byte) 0x15, (byte) 0x0, (byte) 0x1, (byte) 0x94, (byte) 0x82, (byte) 0x60, (byte) 0x61,\n-            (byte) 0x52, (byte) 0x65, (byte) 0x61, (byte) 0x64, (byte) 0x41, (byte) 0x6e, (byte) 0x74, (byte) 0x4a,\n-            (byte) 0x61, (byte) 0x72, (byte) 0x2e, (byte) 0x63, (byte) 0x6c, (byte) 0x61, (byte) 0x73, (byte) 0x73,\n-            (byte) 0x75, (byte) 0x53, (byte) 0x5b, (byte) 0x57, (byte) 0x12, (byte) 0x51, (byte) 0x18, (byte) 0xdd,\n-            (byte) 0x3, (byte) 0xc3, (byte) 0x1c, (byte) 0x18, (byte) 0x47, (byte) 0x41, (byte) 0xcc, (byte) 0xb,\n-            (byte) 0x96, (byte) 0x89, (byte) 0x25, (byte) 0x89, (byte) 0x17, (byte) 0xa0, (byte) 0x8b, (byte) 0x76,\n-            (byte) 0x41, (byte) 0x33, (byte) 0xab, (byte) 0x95, (byte) 0x99, (byte) 0x21, (byte) 0xb4, (byte) 0x84,\n-            (byte) 0x65, (byte) 0x8b, (byte) 0x7a, (byte) 0x1a, (byte) 0x61, (byte) 0xb2, (byte) 0x51, (byte) 0x98,\n-            (byte) 0x99, (byte) 0x35, (byte) 0xc, (byte) 0x76, (byte) 0x79, (byte) 0xea, (byte) 0xa1, (byte) 0x7e,\n-            (byte) 0x8b, (byte) 0xcf, (byte) 0xf6, (byte) 0x80, (byte) 0x6b, (byte) 0xe5, (byte) 0x2a, (byte) 0xdf,\n-            (byte) 0x7c, (byte) 0xe8, (byte) 0x47, (byte) 0x65, (byte) 0xdf, (byte) 0x19, (byte) 0x50, (byte) 0xb0,\n-            (byte) 0x65, (byte) 0x33, (byte) 0x8b, (byte) 0xef, (byte) 0x70, (byte) 0xbe, (byte) 0xb3, (byte) 0xf7,\n-            (byte) 0xfe, (byte) 0x6e, (byte) 0x73, (byte) 0x7e, (byte) 0xff, (byte) 0xf9, (byte) 0xf1, (byte) 0xb,\n-            (byte) 0xc0, (byte) 0x2c, (byte) 0x1e, (byte) 0xc9, (byte) 0x90, (byte) 0x31, (byte) 0xc6, (byte) 0x70,\n-            (byte) 0x4d, (byte) 0x86, (byte) 0x7, (byte) 0x63, (byte) 0xdc, (byte) 0x5c, (byte) 0xf7, (byte) 0x63,\n-            (byte) 0x9c, (byte) 0x21, (byte) 0x26, (byte) 0x43, (byte) 0xc2, (byte) 0x8d, (byte) 0x0, (byte) 0x26,\n-            (byte) 0x10, (byte) 0xf7, (byte) 0x63, (byte) 0x92, (byte) 0x61, (byte) 0x4a, (byte) 0xc6, (byte) 0x34,\n-            (byte) 0x66, (byte) 0xb8, (byte) 0x33, (byte) 0xc1, (byte) 0x90, (byte) 0x94, (byte) 0xd1, (byte) 0x8d,\n-            (byte) 0x14, (byte) 0xc3, (byte) 0x4d, (byte) 0x3f, (byte) 0x6e, (byte) 0xc9, (byte) 0x8, (byte) 0xe2,\n-            (byte) 0xb6, (byte) 0x0, (byte) 0x69, (byte) 0x41, (byte) 0x37, (byte) 0x74, (byte) 0x67, (byte) 0x51,\n-            (byte) 0x80, (byte) 0x37, (byte) 0x3e, (byte) 0xb9, (byte) 0x21, (byte) 0x40, (byte) 0x7c, (byte) 0x6a,\n-            (byte) 0x96, (byte) 0x35, (byte) 0x1, (byte) 0xc1, (byte) 0x8c, (byte) 0x6e, (byte) 0x68, (byte) 0xd9,\n-            (byte) 0x7a, (byte) 0x75, (byte) 0x53, (byte) 0xb3, (byte) 0xb, (byte) 0xea, (byte) 0x66, (byte) 0x85,\n-            (byte) 0x3c, (byte) 0x62, (byte) 0x55, (byte) 0xd5, (byte) 0xd, (byte) 0x1, (byte) 0x3, (byte) 0xf1,\n-            (byte) 0xb7, (byte) 0x99, (byte) 0x6d, (byte) 0x75, (byte) 0x57, (byte) 0x4d, (byte) 0x55, (byte) 0x54,\n-            (byte) 0x63, (byte) 0x2b, (byte) 0x95, (byte) 0x77, (byte) 0x6c, (byte) 0xdd, (byte) 0xd8, (byte) 0x9a,\n-            (byte) 0xe7, (byte) 0x44, (byte) 0xbf, (byte) 0xad, (byte) 0xa9, (byte) 0xe5, (byte) 0x55, (byte) 0xd5,\n-            (byte) 0xae, (byte) 0x9, (byte) 0xe8, (byte) 0xce, (byte) 0x3b, (byte) 0x6a, (byte) 0x69, (byte) 0x67,\n-            (byte) 0x4d, (byte) 0xb5, (byte) 0x5c, (byte) 0x2a, (byte) 0xa5, (byte) 0xc8, (byte) 0x70, (byte) 0x87,\n-            (byte) 0x12, (byte) 0xa3, (byte) 0xf0, (byte) 0x14, (byte) 0x59, (byte) 0x80, (byte) 0x9c, (byte) 0x37,\n-            (byte) 0xeb, (byte) 0x76, (byte) 0x49, (byte) 0x5b, (byte) 0xd6, (byte) 0xb9, (byte) 0x6c, (byte) 0x70,\n-            (byte) 0x9d, (byte) 0x68, (byte) 0x8f, (byte) 0xd, (byte) 0x87, (byte) 0x98, (byte) 0x49, (byte) 0xae,\n-            (byte) 0xab, (byte) 0x20, (byte) 0x8c, (byte) 0x3e, (byte) 0xc2, (byte) 0xb4, (byte) 0xdd, (byte) 0xa,\n-            (byte) 0x86, (byte) 0xb8, (byte) 0xa7, (byte) 0x47, (byte) 0x35, (byte) 0x9c, (byte) 0x6d, (byte) 0xd5,\n-            (byte) 0x76, (byte) 0xb4, (byte) 0x9a, (byte) 0x43, (byte) 0x40, (byte) 0x5b, (byte) 0x40, (byte) 0xbf,\n-            (byte) 0x9b, (byte) 0x46, (byte) 0xdd, (byte) 0xd1, (byte) 0x2b, (byte) 0xa9, (byte) 0xcf, (byte) 0xba,\n-            (byte) 0x95, (byte) 0x7a, (byte) 0xa3, (byte) 0x5b, (byte) 0x5c, (byte) 0x91, (byte) 0xf3, (byte) 0x67,\n-            (byte) 0x19, (byte) 0xe6, (byte) 0x14, (byte) 0xdc, (byte) 0xc5, (byte) 0x3d, (byte) 0x1, (byte) 0x83,\n-            (byte) 0xb1, (byte) 0x5a, (byte) 0xd4, (byte) 0xb4, (byte) 0x34, (byte) 0x43, (byte) 0x2b, (byte) 0x47,\n-            (byte) 0x77, (byte) 0x75, (byte) 0x35, (byte) 0xda, (byte) 0x2, (byte) 0xc5, (byte) 0xa8, (byte) 0x90,\n-            (byte) 0x50, (byte) 0xbb, (byte) 0x8a, (byte) 0xdc, (byte) 0xe6, (byte) 0xb6, (byte) 0x56, (byte) 0x72,\n-            (byte) 0x18, (byte) 0xee, (byte) 0x2b, (byte) 0x78, (byte) 0x80, (byte) 0xb4, (byte) 0x82, (byte) 0x79,\n-            (byte) 0x1e, (byte) 0xaf, (byte) 0xaf, (byte) 0x7d, (byte) 0x5e, (byte) 0x78, (byte) 0x6f, (byte) 0x9b,\n-            (byte) 0x1f, (byte) 0x78, (byte) 0x29, (byte) 0xa, (byte) 0x16, (byte) 0xf0, (byte) 0xf0, (byte) 0xf4,\n-            (byte) 0x48, (byte) 0x37, (byte) 0x53, (byte) 0x2f, (byte) 0x72, (byte) 0xcf, (byte) 0x3e, (byte) 0x96,\n-            (byte) 0x34, (byte) 0xcb, (byte) 0xd1, (byte) 0x4d, (byte) 0x12, (byte) 0x1c, (byte) 0x8e, (byte) 0x19,\n-            (byte) 0xfc, (byte) 0x1d, (byte) 0xa7, (byte) 0x27, (byte) 0x4a, (byte) 0x51, (byte) 0xb3, (byte) 0xb9,\n-            (byte) 0x42, (byte) 0x2b, (byte) 0x72, (byte) 0xcc, (byte) 0x50, (byte) 0xb0, (byte) 0xc8, (byte) 0x25,\n-            (byte) 0x43, (byte) 0xff, (byte) 0x36, (byte) 0x8e, (byte) 0x8a, (byte) 0x88, (byte) 0x5f, (byte) 0xdc,\n-            (byte) 0xcd, (byte) 0x4e, (byte) 0xe8, (byte) 0xa7, (byte) 0x9a, (byte) 0xa3, (byte) 0x55, (byte) 0x69,\n-            (byte) 0x3e, (byte) 0x66, (byte) 0xdd, (byte) 0x21, (byte) 0x42, (byte) 0xe6, (byte) 0x34, (byte) 0xf8,\n-            (byte) 0x2b, (byte) 0x2, (byte) 0x3b, (byte) 0x44, (byte) 0xd1, (byte) 0xd4, (byte) 0xea, (byte) 0x7c,\n-            (byte) 0x47, (byte) 0x4e, (byte) 0x1d, (byte) 0x6e, (byte) 0x1a, (byte) 0xae, (byte) 0xc5, (byte) 0x77,\n-            (byte) 0xef, (byte) 0x4, (byte) 0x2c, (byte) 0x5c, (byte) 0x10, (byte) 0xa7, (byte) 0x73, (byte) 0x90,\n-            (byte) 0xcd, (byte) 0x16, (byte) 0xcc, (byte) 0x4f, (byte) 0xfe, (byte) 0x47, (byte) 0xdd, (byte) 0x57,\n-            (byte) 0xaa, (byte) 0x98, (byte) 0x35, (byte) 0x9a, (byte) 0x56, (byte) 0xb7, (byte) 0x5a, (byte) 0x2e,\n-            (byte) 0xe7, (byte) 0xeb, (byte) 0x96, (byte) 0x65, (byte) 0x6b, (byte) 0xb5, (byte) 0x9a, (byte) 0x56,\n-            (byte) 0x16, (byte) 0x30, (byte) 0xd4, (byte) 0x29, (byte) 0x7b, (byte) 0xd6, (byte) 0x26, (byte) 0xb7,\n-            (byte) 0x82, (byte) 0xa0, (byte) 0xd5, (byte) 0x54, (byte) 0xa0, (byte) 0x2f, (byte) 0xa1, (byte) 0x60,\n-            (byte) 0xab, (byte) 0x25, (byte) 0xd, (byte) 0x63, (byte) 0xf4, (byte) 0x89, (byte) 0xca, (byte) 0xe0,\n-            (byte) 0x8f, (byte) 0x17, (byte) 0x2, (byte) 0x9f, (byte) 0x32, (byte) 0xd9, (byte) 0x4b, (byte) 0xb4,\n-            (byte) 0x1b, (byte) 0xa1, (byte) 0x55, (byte) 0xa0, (byte) 0xd5, (byte) 0x37, (byte) 0x75, (byte) 0x0,\n-            (byte) 0x61, (byte) 0x9f, (byte) 0xfe, (byte) 0x50, (byte) 0x91, (byte) 0x64, (byte) 0x25, (byte) 0xd7,\n-            (byte) 0x29, (byte) 0x21, (byte) 0x80, (byte) 0x1, (byte) 0xc, (byte) 0xb6, (byte) 0xa0, (byte) 0x13,\n-            (byte) 0x24, (byte) 0xc1, (byte) 0xbd, (byte) 0x5d, (byte) 0x87, (byte) 0xf0, (byte) 0x14, (byte) 0xf,\n-            (byte) 0xe0, (byte) 0x6d, (byte) 0x40, (byte) 0x6c, (byte) 0x13, (byte) 0xf8, (byte) 0x15, (byte) 0x0,\n-            (byte) 0xfc, (byte) 0xb4, (byte) 0x6, (byte) 0xc8, (byte) 0x33, (byte) 0x74, (byte) 0xaa, (byte) 0x2f,\n-            (byte) 0xac, (byte) 0x92, (byte) 0x8, (byte) 0xa3, (byte) 0x93, (byte) 0x6f, (byte) 0x61, (byte) 0x5f,\n-            (byte) 0xe6, (byte) 0x10, (byte) 0x52, (byte) 0x71, (byte) 0xfa, (byte) 0x0, (byte) 0x6c, (byte) 0x4d,\n-            (byte) 0xc8, (byte) 0x7e, (byte) 0x87, (byte) 0x3f, (byte) 0x1c, (byte) 0x10, (byte) 0x7f, (byte) 0x42,\n-            (byte) 0x2e, (byte) 0x7a, (byte) 0xa7, (byte) 0xf3, (byte) 0xd, (byte) 0x74, (byte) 0xbd, (byte) 0x9e,\n-            (byte) 0x39, (byte) 0xc6, (byte) 0xcb, (byte) 0xc4, (byte) 0x31, (byte) 0xfa, (byte) 0x67, (byte) 0x1a,\n-            (byte) 0x50, (byte) 0xf6, (byte) 0xb0, (byte) 0x94, (byte) 0x16, (byte) 0x13, (byte) 0x11, (byte) 0xb1,\n-            (byte) 0x81, (byte) 0x9e, (byte) 0x3d, (byte) 0xcc, (byte) 0x35, (byte) 0x3d, (byte) 0xc9, (byte) 0xb4,\n-            (byte) 0x18, (byte) 0x11, (byte) 0xb3, (byte) 0x11, (byte) 0xf1, (byte) 0x28, (byte) 0xed, (byte) 0x23,\n-            (byte) 0xe8, (byte) 0x48, (byte) 0x1b, (byte) 0x1a, (byte) 0x4e, (byte) 0x4b, (byte) 0x89, (byte) 0x88,\n-            (byte) 0xe4, (byte) 0x42, (byte) 0x19, (byte) 0xf7, (byte) 0x44, (byte) 0x7c, (byte) 0x47, (byte) 0x7b,\n-            (byte) 0x88, (byte) 0xac, (byte) 0xf1, (byte) 0x0, (byte) 0xa1, (byte) 0x73, (byte) 0x1, (byte) 0x1a,\n-            (byte) 0xe8, (byte) 0xdd, (byte) 0xa7, (byte) 0x64, (byte) 0x26, (byte) 0xe8, (byte) 0x42, (byte) 0x26,\n-            (byte) 0xe9, (byte) 0x1e, (byte) 0xf6, (byte) 0x60, (byte) 0x14, (byte) 0x4b, (byte) 0xad, (byte) 0x75,\n-            (byte) 0x85, (byte) 0x12, (byte) 0x5c, (byte) 0xc7, (byte) 0x6, (byte) 0x8a, (byte) 0xb4, (byte) 0x5f,\n-            (byte) 0xc2, (byte) 0xaa, (byte) 0xbb, (byte) 0xf7, (byte) 0x62, (byte) 0x7, (byte) 0x6, (byte) 0x5d,\n-            (byte) 0x52, (byte) 0x8f, (byte) 0x5b, (byte) 0x5e, (byte) 0x12, (byte) 0x5d, (byte) 0x64, (byte) 0x15,\n-            (byte) 0xf2, (byte) 0x72, (byte) 0x6, (byte) 0xe7, (byte) 0x4, (byte) 0x5d, (byte) 0xf6, (byte) 0xa,\n-            (byte) 0xad, (byte) 0x3b, (byte) 0xd4, (byte) 0x4e, (byte) 0x8e, (byte) 0x34, (byte) 0x11, (byte) 0xc2,\n-            (byte) 0x17, (byte) 0xf4, (byte) 0xe2, (byte) 0x2b, (byte) 0x15, (byte) 0x1e, (byte) 0x21, (byte) 0x74,\n-            (byte) 0xe, (byte) 0xf2, (byte) 0x9, (byte) 0x11, (byte) 0x45, (byte) 0x86, (byte) 0x61, (byte) 0x86,\n-            (byte) 0xcb, (byte) 0xc, (byte) 0x57, (byte) 0x18, (byte) 0xef, (byte) 0x36, (byte) 0x19, (byte) 0x79,\n-            (byte) 0x99, (byte) 0xcc, (byte) 0x73, (byte) 0xfa, (byte) 0x9d, (byte) 0x10, (byte) 0x43, (byte) 0x3a,\n-            (byte) 0x77, (byte) 0x7c, (byte) 0x6, (byte) 0xf1, (byte) 0x9e, (byte) 0x50, (byte) 0x64, (byte) 0x4f,\n-            (byte) 0xf3, (byte) 0xc, (byte) 0x78, (byte) 0xc2, (byte) 0x70, (byte) 0xb5, (byte) 0x9f, (byte) 0x3a,\n-            (byte) 0x3a, (byte) 0x4a, (byte) 0xb2, (byte) 0x1e, (byte) 0x44, (byte) 0xff, (byte) 0x2, (byte) 0x50,\n-            (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d, (byte) 0x3, (byte) 0x2d, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x8, (byte) 0x0, (byte) 0x0, (byte) 0x18, (byte) 0x7e, (byte) 0xe, (byte) 0x57, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x9, (byte) 0x0, (byte) 0x32, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0xed,\n-            (byte) 0x41, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x4d, (byte) 0x45, (byte) 0x54,\n-            (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f, (byte) 0x1, (byte) 0x0,\n-            (byte) 0x18, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0xfe, (byte) 0xca, (byte) 0x0, (byte) 0x0, (byte) 0x75, (byte) 0x70,\n-            (byte) 0xe, (byte) 0x0, (byte) 0x1, (byte) 0x8, (byte) 0xa1, (byte) 0x8c, (byte) 0x13, (byte) 0x4d,\n-            (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f,\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d, (byte) 0x3, (byte) 0x2d, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x17, (byte) 0x7e, (byte) 0xe, (byte) 0x57,\n-            (byte) 0x31, (byte) 0x59, (byte) 0x76, (byte) 0x4d, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x14, (byte) 0x0, (byte) 0x39, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0xa4, (byte) 0x81, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x4d, (byte) 0x45,\n-            (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f, (byte) 0x4d,\n-            (byte) 0x41, (byte) 0x4e, (byte) 0x49, (byte) 0x46, (byte) 0x45, (byte) 0x53, (byte) 0x54, (byte) 0x2e,\n-            (byte) 0x4d, (byte) 0x46, (byte) 0x1, (byte) 0x0, (byte) 0x18, (byte) 0x0, (byte) 0x6e, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x61, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x51, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x75, (byte) 0x70,\n-            (byte) 0x19, (byte) 0x0, (byte) 0x1, (byte) 0x85, (byte) 0x85, (byte) 0x84, (byte) 0x2, (byte) 0x4d,\n-            (byte) 0x45, (byte) 0x54, (byte) 0x41, (byte) 0x2d, (byte) 0x49, (byte) 0x4e, (byte) 0x46, (byte) 0x2f,\n-            (byte) 0x4d, (byte) 0x41, (byte) 0x4e, (byte) 0x49, (byte) 0x46, (byte) 0x45, (byte) 0x53, (byte) 0x54,\n-            (byte) 0x2e, (byte) 0x4d, (byte) 0x46, (byte) 0x50, (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d,\n-            (byte) 0x3, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0x67,\n-            (byte) 0x37, (byte) 0xb, (byte) 0x57, (byte) 0x3f, (byte) 0xa5, (byte) 0x4f, (byte) 0x5e, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0x10,\n-            (byte) 0x0, (byte) 0x35, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa4, (byte) 0x81, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0x52, (byte) 0x65, (byte) 0x61, (byte) 0x64, (byte) 0x41, (byte) 0x6e, (byte) 0x74,\n-            (byte) 0x4a, (byte) 0x61, (byte) 0x72, (byte) 0x2e, (byte) 0x63, (byte) 0x6c, (byte) 0x61, (byte) 0x73,\n-            (byte) 0x73, (byte) 0x1, (byte) 0x0, (byte) 0x18, (byte) 0x0, (byte) 0x87, (byte) 0x4, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xc7, (byte) 0x2, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x15, (byte) 0x1, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x75, (byte) 0x70, (byte) 0x15,\n-            (byte) 0x0, (byte) 0x1, (byte) 0x94, (byte) 0x82, (byte) 0x60, (byte) 0x61, (byte) 0x52, (byte) 0x65,\n-            (byte) 0x61, (byte) 0x64, (byte) 0x41, (byte) 0x6e, (byte) 0x74, (byte) 0x4a, (byte) 0x61, (byte) 0x72,\n-            (byte) 0x2e, (byte) 0x63, (byte) 0x6c, (byte) 0x61, (byte) 0x73, (byte) 0x73, (byte) 0x50, (byte) 0x4b,\n-            (byte) 0x6, (byte) 0x6, (byte) 0x2c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x3, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x57, (byte) 0x1,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x37, (byte) 0x4,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b,\n-            (byte) 0x6, (byte) 0x7, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x8e, (byte) 0x5,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x3, (byte) 0x0, (byte) 0x3, (byte) 0x0, (byte) 0x57, (byte) 0x1,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x37, (byte) 0x4, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-    };\n-\n-    \/*\n-     * ----------------#1--------------------\n-     * [Central Directory Header]\n-     * 0x47: Signature        : 0x02014b50\n-     * 0x4b: Created Zip Spec :       0x2d [4.5]\n-     * 0x4c: Created OS       :        0x3 [UNIX]\n-     * 0x4d: VerMadeby        :      0x32d [3, 4.5]\n-     * 0x4e: VerExtract       :       0x2d [4.5]\n-     * 0x4f: Flag             :      0x800\n-     * 0x51: Method           :        0x8 [DEFLATED]\n-     * 0x53: Last Mod Time    : 0x570375bc [Thu Aug 03 14:45:56 EDT 2023]\n-     * 0x57: CRC              :        0x0\n-     * 0x5b: Compressed Size  :        0x2\n-     * 0x5f: Uncompressed Size:        0x0\n-     * * 0x63: Name Length      :        0x5\n-     * 0x65: Extra Length     :       0x12\n-     *       Extra data:[01, 00, 00, 00, 75, 70, 0a, 00, 01, ba, f7, eb, c1, 61, 2e, 74, 78, 74]\n-     *       [tag=0x0001, sz=0]\n-     *           ->ZIP64:\n-     *       [tag=0x7075, sz=10]\n-     *           ->[Unknown tag]\n-     *       [data= 01 ba f7 eb c1 61 2e 74 78 74 ]\n-     * 0x67: Comment Length   :        0x0\n-     * 0x69: Disk Start       :        0x0\n-     * 0x6b: Attrs            :        0x0\n-     * 0x6d: AttrsEx          : 0x81a40000\n-     * 0x71: Loc Header Offset:        0x0\n-     * 0x75: File Name        : a.txt\n-     *\/\n-    public static byte[] ANT_ZIP64_UNICODE_EXTRA_ZIP= {\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x3, (byte) 0x4, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x8,\n-            (byte) 0x8, (byte) 0x0, (byte) 0xbc, (byte) 0x75, (byte) 0x3, (byte) 0x57, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff, (byte) 0xff,\n-            (byte) 0xff, (byte) 0xff, (byte) 0x5, (byte) 0x0, (byte) 0x22, (byte) 0x0, (byte) 0x61, (byte) 0x2e,\n-            (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x10, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x75,\n-            (byte) 0x70, (byte) 0xa, (byte) 0x0, (byte) 0x1, (byte) 0xba, (byte) 0xf7, (byte) 0xeb, (byte) 0xc1,\n-            (byte) 0x61, (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x3, (byte) 0x0, (byte) 0x50,\n-            (byte) 0x4b, (byte) 0x1, (byte) 0x2, (byte) 0x2d, (byte) 0x3, (byte) 0x2d, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x8, (byte) 0x8, (byte) 0x0, (byte) 0xbc, (byte) 0x75, (byte) 0x3, (byte) 0x57, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x2, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x5, (byte) 0x0, (byte) 0x12, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0xa4,\n-            (byte) 0x81, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x61, (byte) 0x2e, (byte) 0x74,\n-            (byte) 0x78, (byte) 0x74, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x75, (byte) 0x70,\n-            (byte) 0xa, (byte) 0x0, (byte) 0x1, (byte) 0xba, (byte) 0xf7, (byte) 0xeb, (byte) 0xc1, (byte) 0x61,\n-            (byte) 0x2e, (byte) 0x74, (byte) 0x78, (byte) 0x74, (byte) 0x50, (byte) 0x4b, (byte) 0x6, (byte) 0x6,\n-            (byte) 0x2c, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x2d, (byte) 0x0, (byte) 0x2d, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x45, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x47, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x50, (byte) 0x4b, (byte) 0x6, (byte) 0x7,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x8c, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x50, (byte) 0x4b, (byte) 0x5, (byte) 0x6, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x1, (byte) 0x0, (byte) 0x1, (byte) 0x0, (byte) 0x45, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-            (byte) 0x47, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0, (byte) 0x0,\n-    };\n-\n-    \/\/ Name of Zip file and Jar File used by the test\n-    public static final Path VALID_APK = Path.of(\"working-apk.zip\");\n-    public static final Path VALID_APACHE_COMPRESS_JAR =\n-            Path.of(\"valid-apache-compress.jar\");\n-    public static final Path VALID_ANT_JAR =\n-            Path.of(\"valid-ant-zip64-unicode-extrafields.jar\");\n-    public static final Path VALID_ANT_ZIP =\n-            Path.of(\"valid-ant-zip64-unicode-extrafields.zip\");\n-    \/**\n-     * Setup method used to create the Zip and Jar files used by the test\n-     * @throws IOException if an error occurs\n-     *\/\n-    public static void setup() throws IOException {\n-        Files.deleteIfExists(VALID_APK);\n-        Files.deleteIfExists(VALID_APACHE_COMPRESS_JAR);\n-        Files.deleteIfExists(VALID_ANT_JAR);\n-        Files.deleteIfExists(VALID_ANT_ZIP);\n-\n-        \/\/ Create the Zip file to read\n-        Files.write(VALID_APK, VALID_APK_FILE);\n-        Files.write(VALID_APACHE_COMPRESS_JAR, COMMONS_COMPRESS_JAR);\n-        Files.write(VALID_ANT_JAR, ANT_ZIP64_UNICODE_EXTRA_JAR);\n-        Files.write(VALID_ANT_ZIP, ANT_ZIP64_UNICODE_EXTRA_ZIP);\n-\n-    }\n-\n-    \/**\n-     * Zip and Jars files to validate we can open\n-     *\/\n-    private static Stream<Path> zipFilesToTest() {\n-        return Stream.of(VALID_APK, VALID_APACHE_COMPRESS_JAR, VALID_ANT_JAR, VALID_ANT_ZIP);\n-    }\n-\n-    \/**\n-     * Validate that a Zip file which contains an extra header with a data size\n-     * 0f 0 can be opened using ZipFile\n-     * @throws IOException if an error occurs\n-     *\/\n-    public void zipFilesToTest(Path jar) throws IOException {\n-        try (ZipFile zf = new ZipFile(jar.toFile())) {\n-            System.out.printf(\"%s opened%n\", jar.toAbsolutePath());\n-        } catch (IOException ie) {\n-            System.out.printf(\"%n%n%n$$$$ %s NOT opened%n\", jar.toAbsolutePath());\n-            throw ie;\n-        }\n-    }\n-\n-    \/**\n-     * Validate that a Zip file which contains an extra header with a data size\n-     * 0f 0 can be opened using ZipFS\n-     * @throws IOException if an error occurs\n-     *\/\n-    public void readZipFSTest(Path jar) throws IOException {\n-        URI uri = URI.create(\"jar:\" + jar.toUri());\n-        try (FileSystem fs = FileSystems.newFileSystem(uri, Map.of())) {\n-            System.out.printf(\"%s opened%n\", jar.toAbsolutePath());\n-        } catch (IOException ie) {\n-            System.out.printf(\"%n%n%n$$$$ %s NOT opened%n\", jar.toAbsolutePath());\n-            throw ie;\n-        }\n-    }\n-    \/**\n-     * Utility method which takes a byte array and converts to byte array\n-     * declaration.  For example:\n-     * <pre>\n-     *     {@code\n-     *        var fooJar = Files.readAllBytes(Path.of(\"foo.jar\"));\n-     *        var result = createByteArray(fooJar, \"FOOBYTES\");\n-     *        System.out.println(result);\n-     *      }\n-     * <\/pre>\n-     *\n-     * @param bytes A byte array used to create a byte array declaration\n-     * @param name  Name to be used in the byte array declaration\n-     * @return The formatted byte array declaration\n-     *\/\n-    public static String createByteArray(byte[] bytes, String name) {\n-        StringBuilder sb = new StringBuilder(bytes.length * 5);\n-        Formatter fmt = new Formatter(sb);\n-        fmt.format(\"    public static byte[] %s = {\", name);\n-        final int linelen = 8;\n-        for (int i = 0; i < bytes.length; i++) {\n-            if (i % linelen == 0) {\n-                fmt.format(\"%n        \");\n-            }\n-            fmt.format(\" (byte) 0x%x,\", bytes[i] & 0xff);\n-        }\n-        fmt.format(\"%n    };%n\");\n-        return sb.toString();\n-    }\n-\n-    public static void main(String[] args) throws Exception {\n-        setup();\n-        var test = new ReadNonStandardExtraHeadersTest();\n-        zipFilesToTest().forEach(path -> {\n-            try {\n-                test.zipFilesToTest(path);\n-                test.readZipFSTest(path);\n-            } catch (IOException e) {\n-                throw new RuntimeException(e);\n-            }\n-        });\n-    }\n-}\n-\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/ReadNonStandardExtraHeadersTest.java","additions":0,"deletions":940,"binary":false,"changes":940,"status":"deleted"},{"patch":"@@ -1,272 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2023, BELLSOFT. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug JDK-8311033\n- * @summary [macos] PrinterJob does not take into account Sides attribute\n- * @run main\/manual SidesAttributeTest\n- *\/\n-\n-import javax.print.PrintService;\n-import javax.print.attribute.Attribute;\n-import javax.print.attribute.HashPrintRequestAttributeSet;\n-import javax.print.attribute.PrintRequestAttributeSet;\n-import javax.print.attribute.standard.Sides;\n-import javax.swing.*;\n-import java.awt.*;\n-import java.awt.event.WindowAdapter;\n-import java.awt.event.WindowEvent;\n-import java.awt.print.PageFormat;\n-import java.awt.print.Printable;\n-import java.awt.print.PrinterException;\n-import java.awt.print.PrinterJob;\n-\n-import java.util.Collections;\n-import java.util.HashSet;\n-import java.util.Set;\n-\n-public class SidesAttributeTest {\n-\n-    private static final long TIMEOUT = 10 * 60_000;\n-    private static volatile boolean testPassed = true;\n-    private static volatile boolean testFinished = false;\n-    private static volatile boolean timeout = false;\n-\n-    private static volatile int testCount;\n-    private static volatile int testTotalCount;\n-\n-    public static void main(String[] args) throws Exception {\n-\n-        SwingUtilities.invokeLater(() -> {\n-\n-            Set<Attribute> supportedSides = getSupportedSidesAttributes();\n-            if (supportedSides.size() > 1) {\n-                testTotalCount = supportedSides.size();\n-                testPrint(Sides.ONE_SIDED, supportedSides);\n-                testPrint(Sides.DUPLEX, supportedSides);\n-                testPrint(Sides.TUMBLE, supportedSides);\n-            }\n-            testFinished = true;\n-        });\n-\n-        long time = System.currentTimeMillis() + TIMEOUT;\n-\n-        while (System.currentTimeMillis() < time) {\n-            if (!testPassed || testFinished) {\n-                break;\n-            }\n-            Thread.sleep(500);\n-        }\n-\n-        timeout = true;\n-\n-        closeDialogs();\n-\n-        if (!testPassed) {\n-            throw new Exception(\"Test failed!\");\n-        }\n-\n-        if (testCount != testTotalCount) {\n-            throw new Exception(\n-                    \"Timeout: \" + testCount + \" tests passed out from \" + testTotalCount);\n-        }\n-    }\n-\n-    private static void print(Sides sides) throws PrinterException {\n-        PrintRequestAttributeSet attr = new HashPrintRequestAttributeSet();\n-        attr.add(sides);\n-\n-        for (Attribute attribute : attr.toArray()) {\n-            System.out.printf(\"Used print request attribute: %s%n\", attribute);\n-        }\n-\n-        PrinterJob job = PrinterJob.getPrinterJob();\n-        job.setPrintable(new SidesAttributePrintable(sides));\n-\n-        job.print(attr);\n-    }\n-\n-    private static class SidesAttributePrintable implements Printable {\n-\n-        private final Sides sidesAttr;\n-\n-        public SidesAttributePrintable(Sides sidesAttr) {\n-            this.sidesAttr = sidesAttr;\n-        }\n-\n-        @Override\n-        public int print(Graphics graphics, PageFormat pageFormat, int pageIndex) throws PrinterException {\n-\n-            if (pageIndex >= 2) {\n-                return NO_SUCH_PAGE;\n-            }\n-\n-            int x = (int) (pageFormat.getImageableX() + pageFormat.getImageableWidth() \/ 10);\n-            int y = (int) (pageFormat.getImageableY() + pageFormat.getImageableHeight() \/ 5);\n-\n-            Graphics2D g = (Graphics2D) graphics;\n-            String text = getPageText(sidesAttr, pageIndex + 1);\n-            g.drawString(text, x, y);\n-            return PAGE_EXISTS;\n-        }\n-    }\n-\n-    private static String getPageText(Sides sides, int page) {\n-        return String.format(\"Page: %d - %s\", page, getSidesText(sides));\n-    }\n-\n-    private static String getSidesText(Sides sides) {\n-        if (Sides.ONE_SIDED.equals(sides)) {\n-            return \"ONE_SIDED\";\n-        } else if (Sides.TWO_SIDED_SHORT_EDGE.equals(sides)) {\n-            return \"TWO_SIDED_SHORT_EDGE (TUMBLE)\";\n-        } else if (Sides.TWO_SIDED_LONG_EDGE.equals(sides)) {\n-            return \"TWO_SIDED_LONG_EDGE (DUPLEX)\";\n-        }\n-        throw new RuntimeException(\"Unknown sides attribute: \" + sides);\n-    }\n-\n-    private static String getSidesDescription(Sides sides) {\n-        if (Sides.ONE_SIDED.equals(sides)) {\n-            return \"a one-sided document\";\n-        } else if (Sides.TWO_SIDED_SHORT_EDGE.equals(sides)) {\n-            return \"double-sided document along the short edge of the paper\";\n-        } else if (Sides.TWO_SIDED_LONG_EDGE.equals(sides)) {\n-            return \"double-sided document along the long edge of the paper\";\n-        }\n-        throw new RuntimeException(\"Unknown sides attribute: \" + sides);\n-    }\n-\n-    private static Set<Attribute> getSupportedSidesAttributes() {\n-        Set<Attribute> supportedSides = new HashSet<>();\n-\n-        PrinterJob printerJob = PrinterJob.getPrinterJob();\n-        PrintService service = printerJob.getPrintService();\n-\n-        Object obj = service.getSupportedAttributeValues(Sides.class, null, null);\n-        if (obj instanceof Attribute[]) {\n-            Attribute[] attr = (Attribute[]) obj;\n-            Collections.addAll(supportedSides, attr);\n-        }\n-\n-        return supportedSides;\n-    }\n-\n-    private static void pass() {\n-        testCount++;\n-    }\n-\n-    private static void fail(Sides sides) {\n-        System.out.printf(\"Failed test: %s%n\", getSidesText(sides));\n-        testPassed = false;\n-    }\n-\n-    private static void runPrint(Sides sides) {\n-        try {\n-            print(sides);\n-        } catch (PrinterException e) {\n-            fail(sides);\n-            e.printStackTrace();\n-        }\n-    }\n-\n-    private static void testPrint(Sides sides, Set<Attribute> supportedSides) {\n-\n-        if (!supportedSides.contains(sides) || !testPassed || timeout) {\n-            return;\n-        }\n-\n-        String[] instructions = {\n-                \"Up to \" + testTotalCount + \" tests will run and it will test all the cases\",\n-                \"supported by the printer.\",\n-                \"\",\n-                \"The test is \" + (testCount + 1) + \" from \" + testTotalCount + \".\",\n-                \"\",\n-                \"On-screen inspection is not possible for this printing-specific\",\n-                \"test therefore its only output is two printed pages (one or two sided).\",\n-                \"To be able to run this test it is required to have a default\",\n-                \"printer configured in your user environment.\",\n-                \"\",\n-                \"Visual inspection of the printed pages is needed.\",\n-                \"A passing test will print 2 pages:\",\n-                \"  - the first page with the text: \" + getPageText(sides, 1),\n-                \"  - the second page with the text: \" + getPageText(sides, 2),\n-                \"\",\n-                \"The test fails if the pages are not printed according to the tested\",\n-                getSidesText(sides) + \" attribute where \" + getSidesDescription(sides),\n-                \"needs to be printed.\",\n-                \"\",\n-        };\n-\n-        String title = String.format(\"Print %s sides test: %d from %d\",\n-                getSidesText(sides), testCount + 1, testTotalCount);\n-        final JDialog dialog = new JDialog((Frame) null, title, Dialog.ModalityType.DOCUMENT_MODAL);\n-        JTextArea textArea = new JTextArea(String.join(\"\\n\", instructions));\n-        textArea.setEditable(false);\n-        final JButton testButton = new JButton(\"Start Test\");\n-        final JButton passButton = new JButton(\"PASS\");\n-        passButton.setEnabled(false);\n-        passButton.addActionListener((e) -> {\n-            pass();\n-            dialog.dispose();\n-        });\n-        final JButton failButton = new JButton(\"FAIL\");\n-        failButton.setEnabled(false);\n-        failButton.addActionListener((e) -> {\n-            fail(sides);\n-            dialog.dispose();\n-        });\n-        testButton.addActionListener((e) -> {\n-            testButton.setEnabled(false);\n-            runPrint(sides);\n-            passButton.setEnabled(true);\n-            failButton.setEnabled(true);\n-        });\n-\n-        JPanel mainPanel = new JPanel(new BorderLayout());\n-        mainPanel.add(textArea, BorderLayout.CENTER);\n-        JPanel buttonPanel = new JPanel(new FlowLayout());\n-        buttonPanel.add(testButton);\n-        buttonPanel.add(passButton);\n-        buttonPanel.add(failButton);\n-        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n-        dialog.add(mainPanel);\n-        dialog.pack();\n-        dialog.setVisible(true);\n-        dialog.addWindowListener(new WindowAdapter() {\n-            @Override\n-            public void windowClosing(WindowEvent e) {\n-                System.out.println(\"Dialog closing\");\n-                fail(sides);\n-            }\n-        });\n-    }\n-\n-    private static void closeDialogs() {\n-        for (Window w : Dialog.getWindows()) {\n-            w.dispose();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/print\/attribute\/SidesAttributeTest.java","additions":0,"deletions":272,"binary":false,"changes":272,"status":"deleted"},{"patch":"@@ -31,1 +31,1 @@\n- * @bug 8266421 8269091\n+ * @bug 8266421\n","filename":"test\/jdk\/javax\/sound\/sampled\/Clip\/SetPositionHang.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,45 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4167850\n-   @summary Verify no exception removing items from an empty list.\n-*\/\n-\n-import javax.swing.JComboBox;\n-\n-public class bug4167850 {\n-\n-    public static void main(String[] args) {\n-        JComboBox comboBox = new JComboBox(\n-            new Object[] {\n-                \"Coma Berenices\",\n-                \"Triangulum\",\n-                \"Camelopardis\",\n-                \"Cassiopea\"});\n-\n-        comboBox.removeAllItems();\n-        comboBox.removeAllItems();\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/bug4167850.java","additions":0,"deletions":45,"binary":false,"changes":45,"status":"deleted"},{"patch":"@@ -1,53 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/* @test\n-   @bug 4209474\n-   @summary setSelectedItem(int) should only fire events if selection changed - avoid recursive calls\n-*\/\n-\n-import javax.swing.JComboBox;\n-import java.awt.event.ActionEvent;\n-import java.awt.event.ActionListener;\n-\n-public class bug4209474 {\n-\n-    public static void main(String[] args) {\n-\n-        JComboBox comboBox = new JComboBox(\n-            new Object[] {\n-                        \"Coma Berenices\",\n-                        \"Triangulum\",\n-                        \"Camelopardis\",\n-                        \"Cassiopea\"});\n-\n-        ActionListener listener = new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                comboBox.setSelectedIndex(0);\n-            }\n-        };\n-\n-        comboBox.addActionListener(listener);\n-        comboBox.setSelectedIndex(0);\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/bug4209474.java","additions":0,"deletions":53,"binary":false,"changes":53,"status":"deleted"},{"patch":"@@ -1,46 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4234119\n-   @summary Tests if adding items to ComboBox is slow\n-*\/\n-\n-import javax.swing.JComboBox;\n-\n-public class bug4234119 {\n-\n-    public static void main(String args[]) {\n-        JComboBox jComboBox1 = new JComboBox();\n-        long startTime = System.currentTimeMillis();\n-        for (int i = 0 ; i < 500; i++) {\n-            jComboBox1.addItem(Integer.valueOf(i));\n-        }\n-        long deltaTime = System.currentTimeMillis() - startTime;\n-        if (deltaTime > 20000) {\n-            throw new Error(\"Test failed: adding items to ComboBox is SLOW! (it took \" + deltaTime + \" ms\");\n-        }\n-        System.out.println(\"Elapsed time: \" + deltaTime);\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/bug4234119.java","additions":0,"deletions":46,"binary":false,"changes":46,"status":"deleted"},{"patch":"@@ -1,154 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4890345\n-   @requires (os.family == \"windows\")\n-   @summary 1.4.2 REGRESSION: JComboBox has problem in JTable in Windows L&F\n-   @key headful\n-*\/\n-\n-import java.util.Vector;\n-import java.awt.BorderLayout;\n-import java.awt.Robot;\n-import java.awt.event.KeyEvent;\n-import javax.swing.DefaultCellEditor;\n-import javax.swing.JComboBox;\n-import javax.swing.JFrame;\n-import javax.swing.JScrollPane;\n-import javax.swing.JTable;\n-import javax.swing.SwingUtilities;\n-import javax.swing.UIManager;\n-import javax.swing.table.DefaultTableModel;\n-import javax.swing.table.TableModel;\n-import javax.swing.event.PopupMenuEvent;\n-import javax.swing.event.PopupMenuListener;\n-\n-public class bug4890345 {\n-\n-    volatile boolean passed = false;\n-    volatile boolean isLafOk = true;\n-\n-    volatile JFrame mainFrame;\n-    volatile JTable tbl;\n-\n-    public static void main(String[] args) throws Exception {\n-        bug4890345 test = new bug4890345();\n-        try {\n-            SwingUtilities.invokeAndWait(test::createUI);\n-            if (!test.isLafOk) {\n-                throw new RuntimeException(\"Could not create Win L&F\");\n-            }\n-            test.test();\n-        } finally {\n-            JFrame f = test.mainFrame;\n-            if (f != null) {\n-                SwingUtilities.invokeAndWait(() -> f.dispose());\n-            }\n-        }\n-    }\n-\n-    void createUI() {\n-        try {\n-            UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.windows.WindowsLookAndFeel\");\n-        } catch (Exception ex) {\n-            System.err.println(\"Can not initialize Windows L&F. Testing skipped.\");\n-            isLafOk = false;\n-        }\n-\n-        if (isLafOk) {\n-            mainFrame = new JFrame(\"Bug4890345\");\n-            String[] items = {\"tt\", \"aa\", \"gg\", \"zz\", \"dd\", \"ll\" };\n-            JComboBox<String> comboBox = new JComboBox<String>(items);\n-\n-            tbl = new JTable();\n-            JScrollPane panel = new JScrollPane(tbl);\n-            TableModel tm = createTableModel();\n-            tbl.setModel(tm);\n-            tbl.setRowHeight(20);\n-            tbl.getColumnModel().getColumn(1).setCellEditor(\n-                new DefaultCellEditor(comboBox));\n-\n-            comboBox.addPopupMenuListener(new PopupMenuListener() {\n-                public void popupMenuWillBecomeVisible(PopupMenuEvent e) {\n-                    passed = true;\n-                }\n-\n-                public void popupMenuWillBecomeInvisible(PopupMenuEvent e) {}\n-                public void popupMenuCanceled(PopupMenuEvent e) {}\n-            });\n-\n-            mainFrame.setLayout(new BorderLayout());\n-            mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n-            mainFrame.add(panel, BorderLayout.CENTER);\n-            mainFrame.pack();\n-            mainFrame.setLocationRelativeTo(null);\n-            mainFrame.setVisible(true);\n-        }\n-    }\n-\n-    public void test() throws Exception {\n-        Robot robo = new Robot();\n-        robo.setAutoDelay(50);\n-        robo.delay(1000);\n-        tbl.editCellAt(0,0);\n-\n-        robo.keyPress(KeyEvent.VK_TAB);\n-        robo.keyRelease(KeyEvent.VK_TAB);\n-\n-        robo.keyPress(KeyEvent.VK_TAB);\n-        robo.keyRelease(KeyEvent.VK_TAB);\n-\n-        robo.keyPress(KeyEvent.VK_F2);\n-        robo.keyRelease(KeyEvent.VK_F2);\n-\n-        robo.keyPress(KeyEvent.VK_DOWN);\n-        robo.keyRelease(KeyEvent.VK_DOWN);\n-\n-        robo.keyPress(KeyEvent.VK_ENTER);\n-        robo.keyRelease(KeyEvent.VK_ENTER);\n-\n-        robo.delay(1000);\n-\n-        if (!passed) {\n-            throw new RuntimeException(\"Popup was not shown after VK_DOWN press. Test failed.\");\n-        }\n-    }\n-\n-    private TableModel createTableModel() {\n-        Vector<String> hdr = new Vector<String>();\n-        hdr.add(\"One\");\n-        hdr.add(\"Two\");\n-        Vector<Vector> data = new Vector<Vector>();\n-        Vector<String> row = new Vector<String>();\n-        row.add(\"tt\");\n-        row.add(\"dd\");\n-        data.add(row);\n-        row = new Vector<String>();\n-        row.add(\"ll\");\n-        row.add(\"jj\");\n-        data.add(row);\n-        return new DefaultTableModel(data, hdr);\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/bug4890345.java","additions":0,"deletions":154,"binary":false,"changes":154,"status":"deleted"},{"patch":"@@ -1,94 +0,0 @@\n-\/*\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4996503\n-   @summary REGRESSION: NotSerializableException: javax.swing.plaf.basic.BasicComboPopup+1\n-   @key headful\n-*\/\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.ObjectOutputStream;\n-import java.io.IOException;\n-import java.awt.Dimension;\n-import java.awt.Point;\n-import java.awt.Robot;\n-import java.awt.event.KeyEvent;\n-import java.awt.event.InputEvent;\n-import javax.swing.JComboBox;\n-import javax.swing.JFrame;\n-import javax.swing.SwingUtilities;\n-\n-public class bug4996503 {\n-\n-    static volatile JFrame frame = null;\n-    static volatile JComboBox<String> comboBox = null;\n-\n-    public static void main(String[] args) throws Exception {\n-        try {\n-            SwingUtilities.invokeAndWait(() -> {\n-                frame = new JFrame(\"bug4996503\");\n-                String[] items = { \"item0\", \"item1\", \"item2\" };\n-                comboBox = new JComboBox<String>(items);\n-                frame.add(comboBox);\n-                frame.pack();\n-                frame.validate();\n-                frame.setLocationRelativeTo(null);\n-                frame.setVisible(true);\n-            });\n-\n-            Robot robot = new Robot();\n-            robot.setAutoDelay(50);\n-            robot.delay(1000);\n-            Point p = comboBox.getLocationOnScreen();\n-            Dimension size = comboBox.getSize();\n-            p.x += size.width \/ 2;\n-            p.y += size.height \/ 2;\n-            robot.mouseMove(p.x, p.y);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.keyPress(KeyEvent.VK_ENTER);\n-            robot.keyRelease(KeyEvent.VK_ENTER);\n-\n-            ObjectOutputStream out = null;\n-\n-            ByteArrayOutputStream byteStream = new ByteArrayOutputStream();\n-            try {\n-                out = new ObjectOutputStream(byteStream);\n-            } catch (IOException e) {}\n-            if (out != null) {\n-                try {\n-                    out.writeObject(comboBox);\n-                } catch (Exception e) {\n-                    System.out.println(e);\n-                    throw new Error(\"Serialization exception. Test failed.\");\n-                }\n-            }\n-        } finally {\n-            if (frame != null) {\n-                 SwingUtilities.invokeAndWait(frame::dispose);\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JComboBox\/bug4996503.java","additions":0,"deletions":94,"binary":false,"changes":94,"status":"deleted"},{"patch":"@@ -1,102 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4170447\n-   @summary JTable: non-Icon data in Icon column.\n-   @key headful\n-*\/\n-\n-import java.io.File;\n-import java.awt.Component;\n-import javax.swing.ImageIcon;\n-import javax.swing.JFrame;\n-import javax.swing.JScrollPane;\n-import javax.swing.JTable;\n-import javax.swing.SwingUtilities;\n-import javax.swing.table.AbstractTableModel;\n-import javax.swing.table.TableCellRenderer;\n-import javax.swing.table.TableModel;\n-\n-public class bug4170447 {\n-\n-    static volatile boolean failed = false;\n-    static volatile JFrame frame = null;\n-\n-    public static void main(String args[]) throws Exception {\n-         SwingUtilities.invokeAndWait(bug4170447::createUI);\n-         Thread.sleep(5000);\n-         SwingUtilities.invokeAndWait(() -> {\n-             if (frame != null) {\n-                frame.dispose();\n-             }\n-         });\n-        if (failed) {\n-            throw new RuntimeException(\"Some exception occurred...\");\n-        }\n-    }\n-\n-    static void createUI() {\n-        String imgDir = System.getProperty(\"test.src\", \".\");\n-        String imgPath = imgDir + File.separator + \"swing.small.gif\";\n-        ImageIcon icn = new ImageIcon(imgPath,\"test\");\n-        final Object data[][] = {\n-            {\"CELL 0 0\", icn},\n-            {\"CELL 1 0\", \"String\"}\n-        };\n-        String[] str = {\"Column 0\", \"Column 1\"};\n-\n-        TableModel dataModel = new AbstractTableModel() {\n-                public int getColumnCount() { return 2; }\n-                public int getRowCount() { return 2; }\n-                public Object getValueAt(int row, int col) {return data[row][col];}\n-                public Class getColumnClass(int c) {return getValueAt(0, c).getClass();}\n-                public boolean isCellEditable(int row, int col) {return getColumnClass(col) == String.class;}\n-                public void setValueAt(Object aValue, int row, int column) {data[row][column] = aValue;}\n-            };\n-\n-        MyTable tbl = new MyTable(dataModel);\n-        JScrollPane sp = new JScrollPane(tbl);\n-        frame = new JFrame(\"bug4170447\");\n-        frame.getContentPane().add(sp);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    static class MyTable extends JTable {\n-        public MyTable(TableModel tm) {\n-            super(tm);\n-        }\n-\n-        public Component prepareRenderer(TableCellRenderer rend, int row, int col) {\n-            try {\n-                return super.prepareRenderer(rend, row, col);\n-            } catch (Exception e) {\n-                e.printStackTrace();\n-                failed = true;\n-                return null;\n-            }\n-        }\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/4170447\/bug4170447.java","additions":0,"deletions":102,"binary":false,"changes":102,"status":"deleted"},{"filename":"test\/jdk\/javax\/swing\/JTable\/4170447\/swing.small.gif","binary":true,"status":"deleted"},{"patch":"@@ -1,41 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4098201\n-   @summary Tests setRowHeight(int row, int height).\n-*\/\n-\n-import javax.swing.JTable;\n-\n-public class bug4098201 {\n-\n-  public static void main(String args[]) {\n-    JTable table = new JTable(4,3);\n-    table.setRowHeight(1, table.getRowHeight()*2);\n-    if (table.getRowHeight(0) * 2 != table.getRowHeight(1)) {\n-        throw new Error(\"Can't set height for specified row...\");\n-    }\n-  }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/bug4098201.java","additions":0,"deletions":41,"binary":false,"changes":41,"status":"deleted"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4130356\n-   @summary JTable.setRowSelectionInterval(int, int) shouldn't accept invalid range\n-*\/\n-\n-import javax.swing.JTable;\n-import javax.swing.ListSelectionModel;\n-\n-public class bug4130356 {\n-\n-  public static void main(String[] argv) {\n-    JTable table = new JTable(4,3);\n-    table.setSelectionMode(ListSelectionModel.SINGLE_SELECTION);\n-    try {\n-      table.setRowSelectionInterval(10,13);\n-      throw new Error(\"Invalid arguments supported!!!\");\n-    } catch (IllegalArgumentException iae) {}\n-  }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/bug4130356.java","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -1,92 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4159300\n-   @summary Tests that JTable processes tableChanged events quickly\n-   @key headful\n-*\/\n-\n-import java.awt.BorderLayout;\n-import java.awt.Container;\n-import java.awt.Rectangle;\n-import javax.swing.JButton;\n-import javax.swing.JFrame;\n-import javax.swing.JScrollPane;\n-import javax.swing.JTable;\n-import javax.swing.SwingUtilities;\n-import javax.swing.table.DefaultTableModel;\n-import java.awt.event.ActionEvent;\n-import java.awt.event.ActionListener;\n-\n-public class bug4159300 {\n-\n-    static volatile JFrame frame = null;\n-    public static void main(String[] args) throws Exception {\n-        SwingUtilities.invokeAndWait(bug4159300::createUI);\n-        Thread.sleep(3000);\n-        SwingUtilities.invokeAndWait(() -> {\n-            if (frame != null) {\n-                frame.dispose();\n-            }\n-        });\n-    }\n-\n-    static void createUI() {\n-        frame = new JFrame(\"bug4159300\");\n-        Container c = frame.getContentPane();\n-        c.setLayout(new BorderLayout());\n-        \/\/ create table\n-        Object[] columnNames = {\"only column\"};\n-        DefaultTableModel model = new DefaultTableModel(columnNames, 0);\n-        Object[] row = makeRow(model.getRowCount());\n-        model.addRow(row);\n-\n-        JTable table = new JTable(model);\n-        c.add(new JScrollPane(table), BorderLayout.CENTER);\n-\n-        \/\/ create button\n-        JButton immediateButton = new JButton(\"Add row\");\n-        immediateButton.addActionListener(new ActionListener() {\n-            public void actionPerformed(ActionEvent e) {\n-                int rowCount = model.getRowCount();\n-                Object[] row = makeRow(rowCount);\n-                model.addRow(row);\n-                int rows = model.getRowCount();\n-                int lastRow = rows - 1;\n-                table.setRowSelectionInterval(lastRow, lastRow);\n-                Rectangle r = table.getCellRect(lastRow, 0, false);\n-                table.scrollRectToVisible(r);\n-            }\n-        });\n-        c.add(immediateButton, BorderLayout.SOUTH);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    static Object[] makeRow(int rowNumber) {\n-        Object[] row = { \"\"+rowNumber };\n-        return row;\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/bug4159300.java","additions":0,"deletions":92,"binary":false,"changes":92,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4243159\n-   @summary Tests that JTable() do not throw ArrayIndexOutOfBoundsException\n-*\/\n-\n-import javax.swing.JTable;\n-\n-public class bug4243159 {\n-\n-    \/* Looks boring, but tests the no-args constructor works *\/\n-    public static void main(String[] argv) {\n-        JTable table = new JTable();\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/bug4243159.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,38 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4243313\n-   @summary Tests that instantiating JTable through reflection\n-            does not throw ClassNotFoundException\n-*\/\n-\n-import java.beans.Beans;\n-\n-public class bug4243313 {\n-\n-    public static void main(String[] argv) throws Exception {\n-        Object table = Beans.instantiate(null, \"javax.swing.JTable\");\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/bug4243313.java","additions":0,"deletions":38,"binary":false,"changes":38,"status":"deleted"},{"patch":"@@ -1,73 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\n-\/*\n-   @test\n-   @bug 4247487\n-   @summary Tests that the following methods of JTable are public:\n-            int getAccessibleColumnAtIndex(int)\n-            int getAccessibleRowAtIndex(int)\n-            int getAccessibleIndexAt(int, int)\n-*\/\n-\n-import javax.swing.JTable;\n-\n-public class bug4247487 {\n-\n-    static class TestTable extends JTable {\n-\n-        public TestTable() {\n-            super(new Object[][]{{\"one\", \"two\"}},\n-                  new Object[]{\"A\", \"B\"});\n-        }\n-\n-        public void test() {\n-            int[] rowIndices = {0, 0, 1, 1};\n-            int[] colIndices = {0, 1, 0, 1};\n-            JTable.AccessibleJTable at =\n-                (JTable.AccessibleJTable)getAccessibleContext();\n-\n-            for (int i=0; i<4; i++) {\n-                if (at.getAccessibleRowAtIndex(i) != rowIndices[i]) {\n-                    throw new Error(\"Failed: wrong row index\");\n-                }\n-                if (at.getAccessibleColumnAtIndex(i) != colIndices[i]) {\n-                    throw new Error(\"Failed: wrong column index\");\n-                }\n-            }\n-            if (at.getAccessibleIndexAt(0,0) != 0 ||\n-                at.getAccessibleIndexAt(0,1) != 1 ||\n-                at.getAccessibleIndexAt(1,0) != 2 ||\n-                at.getAccessibleIndexAt(1,1) != 3) {\n-\n-                throw new Error(\"Failed: wrong index\");\n-            }\n-        }\n-    }\n-\n-    public static void main(String[] argv) {\n-        TestTable test = new TestTable();\n-        test.test();\n-    }\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/bug4247487.java","additions":0,"deletions":73,"binary":false,"changes":73,"status":"deleted"},{"patch":"@@ -1,59 +0,0 @@\n-\/*\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n-   @test\n-   @bug 4248070\n-   @summary cellEditor bound in JTable.\n-*\/\n-\n-import javax.swing.JTable;\n-import java.beans.BeanInfo;\n-import java.beans.Introspector;\n-import java.beans.IntrospectionException;\n-import java.beans.PropertyDescriptor;\n-\n-public class bug4248070 {\n-\n-  public static void main(String[] argv) {\n-\n-    BeanInfo bi = null;\n-\n-    try {\n-        bi = Introspector.getBeanInfo(JTable.class);\n-    } catch (IntrospectionException e) {\n-    }\n-\n-    PropertyDescriptor[] pd = bi.getPropertyDescriptors();\n-    int i;\n-    for (i=0; i<pd.length; i++) {\n-        if (pd[i].getName().equals(\"cellEditor\")) {\n-            break;\n-        }\n-    }\n-    if (!pd[i].isBound()) {\n-       throw new RuntimeException(\"cellEditor property of JTable isn't flagged as bound in bean info...\");\n-    }\n-  }\n-\n-}\n","filename":"test\/jdk\/javax\/swing\/JTable\/bug4248070.java","additions":0,"deletions":59,"binary":false,"changes":59,"status":"deleted"},{"patch":"@@ -26,1 +26,1 @@\n-   @key headful\n+  @key headful\n@@ -29,0 +29,1 @@\n+   @author Alexander Potochkin\n@@ -31,9 +32,1 @@\n-import java.awt.Cursor;\n-import java.awt.Dimension;\n-import java.awt.Point;\n-import java.awt.Rectangle;\n-import java.awt.Robot;\n-import java.awt.Toolkit;\n-import java.awt.image.BufferedImage;\n-import javax.imageio.ImageIO;\n-import javax.swing.JFrame;\n+import javax.swing.*;\n@@ -42,2 +35,1 @@\n-import javax.swing.JTable;\n-import javax.swing.SwingUtilities;\n+import java.awt.*;\n@@ -47,6 +39,0 @@\n-    static JFrame frame;\n-    static Robot robot;\n-    static volatile Point point;\n-    static volatile int width;\n-    static volatile int height;\n-\n@@ -54,3 +40,2 @@\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(100);\n+        Robot robot = new Robot();\n+        robot.setAutoDelay(20);\n@@ -58,3 +43,2 @@\n-            SwingUtilities.invokeAndWait(() -> {\n-                frame = new JFrame();\n-                frame.setUndecorated(true);\n+        final JFrame frame = new JFrame();\n+        frame.setUndecorated(true);\n@@ -62,0 +46,2 @@\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+            public void run() {\n@@ -73,20 +59,0 @@\n-            });\n-            robot.waitForIdle();\n-            robot.delay(1000);\n-            SwingUtilities.invokeAndWait(() -> {\n-                point = frame.getLocationOnScreen();\n-                width = frame.getWidth();\n-                height = frame.getHeight();\n-            });\n-            int shift = 10;\n-            int x = point.x;\n-            int y = point.y + height\/2;\n-            for(int i = -shift; i < width + 2*shift; i++) {\n-                robot.mouseMove(x++, y);\n-                robot.waitForIdle();\n-            }\n-            robot.waitForIdle();\n-            \/\/ 9 is a magic test number\n-            if (MyTableHeaderUI.getTestValue() != 9) {\n-                throw new RuntimeException(\"Unexpected test number \"\n-                        + MyTableHeaderUI.getTestValue());\n@@ -94,6 +60,14 @@\n-        } finally {\n-            SwingUtilities.invokeAndWait(() -> {\n-                if (frame != null) {\n-                    frame.dispose();\n-                }\n-            });\n+        });\n+        robot.waitForIdle();\n+        Point point = frame.getLocationOnScreen();\n+        int shift = 10;\n+        int x = point.x;\n+        int y = point.y + frame.getHeight()\/2;\n+        for(int i = -shift; i < frame.getWidth() + 2*shift; i++) {\n+            robot.mouseMove(x++, y);\n+        }\n+        robot.waitForIdle();\n+        \/\/ 9 is a magic test number\n+        if (MyTableHeaderUI.getTestValue() != 9) {\n+            throw new RuntimeException(\"Unexpected test number \"\n+                    + MyTableHeaderUI.getTestValue());\n@@ -112,9 +86,0 @@\n-                try {\n-                    Dimension screenSize =\n-                               Toolkit.getDefaultToolkit().getScreenSize();\n-                    Rectangle screen = new Rectangle(0, 0,\n-                                               (int) screenSize.getWidth(),\n-                                               (int) screenSize.getHeight());\n-                    BufferedImage img = robot.createScreenCapture(screen);\n-                    ImageIO.write(img, \"png\", new java.io.File(\"image.png\"));\n-                } catch (Exception e) {}\n","filename":"test\/jdk\/javax\/swing\/JTableHeader\/6889007\/bug6889007.java","additions":24,"deletions":59,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,0 +54,1 @@\n+        boolean ocspEnabled = false;\n@@ -60,0 +61,1 @@\n+            ocspEnabled = true;\n@@ -62,4 +64,4 @@\n-        new AmazonCA_1().runTest(pathValidator);\n-        new AmazonCA_2().runTest(pathValidator);\n-        new AmazonCA_3().runTest(pathValidator);\n-        new AmazonCA_4().runTest(pathValidator);\n+        new AmazonCA_1().runTest(pathValidator, ocspEnabled);\n+        new AmazonCA_2().runTest(pathValidator, ocspEnabled);\n+        new AmazonCA_3().runTest(pathValidator, ocspEnabled);\n+        new AmazonCA_4().runTest(pathValidator, ocspEnabled);\n@@ -71,1 +73,1 @@\n-    \/\/ Owner: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n@@ -73,35 +75,4 @@\n-    \/\/ Serial number: 773124a4bcbd44ec7b53beaf194842d3a0fa1\n-    \/\/ Valid from: Tue Aug 23 15:25:30 PDT 2022 until: Fri Aug 23 15:25:30 PDT 2030\n-    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIEXjCCA0agAwIBAgITB3MSSkvL1E7HtTvq8ZSELToPoTANBgkqhkiG9w0BAQsF\\n\" +\n-            \"ADA5MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6\\n\" +\n-            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjUzMFoXDTMwMDgyMzIyMjUzMFowPDEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n-            \"QSAyMDQ4IE0wMjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALtDGMZa\\n\" +\n-            \"qHneKei1by6+pUPPLljTB143Si6VpEWPc6mSkFhZb\/6qrkZyoHlQLbDYnI2D7hD0\\n\" +\n-            \"sdzEqfnuAjIsuXQLG3A8TvX6V3oFNBFVe8NlLJHvBseKY88saLwufxkZVwk74g4n\\n\" +\n-            \"WlNMXzla9Y5F3wwRHwMVH443xGz6UtGSZSqQ94eFx5X7Tlqt8whi8qCaKdZ5rNak\\n\" +\n-            \"+r9nUThOeClqFd4oXych\/\/Rc7Y0eX1KNWHYSI1Nk31mYgiK3JvH063g+K9tHA63Z\\n\" +\n-            \"eTgKgndlh+WI+zv7i44HepRZjA1FYwYZ9Vv\/9UkC5Yz8\/yU65fgjaE+wVHM4e\/Yy\\n\" +\n-            \"C2osrPWE7gJ+dXMCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n-            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n-            \"HQ4EFgQUwDFSzVpQw4J8dHHOy+mc+XrrguIwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n-            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n-            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n-            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n-            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n-            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n-            \"AQAtTi6Fs0Azfi+iwm7jrz+CSxHH+uHl7Law3MQSXVtR8RV53PtR6r\/6gNpqlzdo\\n\" +\n-            \"Zq4FKbADi1v9Bun8RY8D51uedRfjsbeodizeBB8nXmeyD33Ep7VATj4ozcd31YFV\\n\" +\n-            \"fgRhvTSxNrrTlNpWkUk0m3BMPv8sg381HhA6uEYokE5q9uws\/3YkKqRiEz3TsaWm\\n\" +\n-            \"JqIRZhMbgAfp7O7FUwFIb7UIspogZSKxPIWJpxiPo3TcBambbVtQOcNRWz5qCQdD\\n\" +\n-            \"slI2yayq0n2TXoHyNCLEH8rpsJRVILFsg0jc7BaFrMnF462+ajSehgj12IidNeRN\\n\" +\n-            \"4zl+EoNaWdpnWndvSpAEkq2P\\n\" +\n-            \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Owner: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n-    \/\/ Issuer: CN=Amazon Root CA 1, O=Amazon, C=US\n-    \/\/ Serial number: 77312380b9d6688a33b1ed9bf9ccda68e0e0f\n-    \/\/ Valid from: Tue Aug 23 15:21:28 PDT 2022 until: Fri Aug 23 15:21:28 PDT 2030\n-    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIEXjCCA0agAwIBAgITB3MSOAudZoijOx7Zv5zNpo4ODzANBgkqhkiG9w0BAQsF\\n\" +\n+    \/\/ Serial number: 67f9457508c648c09ca652e71791830e72592\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIIERzCCAy+gAwIBAgITBn+UV1CMZIwJymUucXkYMOclkjANBgkqhkiG9w0BAQsF\\n\" +\n@@ -109,22 +80,21 @@\n-            \"b24gUm9vdCBDQSAxMB4XDTIyMDgyMzIyMjEyOFoXDTMwMDgyMzIyMjEyOFowPDEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n-            \"QSAyMDQ4IE0wMTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAOtxLKnL\\n\" +\n-            \"H4gokjIwr4pXD3i3NyWVVYesZ1yX0yLI2qIUZ2t88Gfa4gMqs1YSXca1R\/lnCKeT\\n\" +\n-            \"epWSGA+0+fkQNpp\/L4C2T7oTTsddUx7g3ZYzByDTlrwS5HRQQqEFE3O1T5tEJP4t\\n\" +\n-            \"f+28IoXsNiEzl3UGzicYgtzj2cWCB41eJgEmJmcf2T8TzzK6a614ZPyq\/w4CPAff\\n\" +\n-            \"nAV4coz96nW3AyiE2uhuB4zQUIXvgVSycW7sbWLvj5TDXunEpNCRwC4kkZjK7rol\\n\" +\n-            \"jtT2cbb7W2s4Bkg3R42G3PLqBvt2N32e\/0JOTViCk8\/iccJ4sXqrS1uUN4iB5Nmv\\n\" +\n-            \"JK74csVl+0u0UecCAwEAAaOCAVowggFWMBIGA1UdEwEB\/wQIMAYBAf8CAQAwDgYD\\n\" +\n-            \"VR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjAdBgNV\\n\" +\n-            \"HQ4EFgQUgbgOY4qJEhjl+js7UJWf5uWQE4UwHwYDVR0jBBgwFoAUhBjMhTTsvAyU\\n\" +\n-            \"lC4IWZzHshBOCggwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8v\\n\" +\n-            \"b2NzcC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDov\\n\" +\n-            \"L2NydC5yb290Y2ExLmFtYXpvbnRydXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8E\\n\" +\n-            \"ODA2MDSgMqAwhi5odHRwOi8vY3JsLnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jv\\n\" +\n-            \"b3RjYTEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBCwUAA4IB\\n\" +\n-            \"AQCtAN4CBSMuBjJitGuxlBbkEUDeK\/pZwTXv4KqPK0G50fOHOQAd8j21p0cMBgbG\\n\" +\n-            \"kfMHVwLU7b0XwZCav0h1ogdPMN1KakK1DT0VwA\/+hFvGPJnMV1Kx2G4S1ZaSk0uU\\n\" +\n-            \"5QfoiYIIano01J5k4T2HapKQmmOhS\/iPtuo00wW+IMLeBuKMn3OLn005hcrOGTad\\n\" +\n-            \"hcmeyfhQP7Z+iKHvyoQGi1C0ClymHETx\/chhQGDyYSWqB\/THwnN15AwLQo0E5V9E\\n\" +\n-            \"SJlbe4mBlqeInUsNYugExNf+tOiybcrswBy8OFsd34XOW3rjSUtsuafd9AWySa3h\\n\" +\n-            \"xRRrwszrzX\/WWGm6wyB+f7C4\\n\" +\n+            \"b24gUm9vdCBDQSAxMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENB\\n\" +\n+            \"IDFBMQ8wDQYDVQQDEwZBbWF6b24wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEK\\n\" +\n+            \"AoIBAQCeQM3XCsIZunv8bSJxOqkc\/ed87uL76FDB7teBNThDRB+1J7aITuadbNfH\\n\" +\n+            \"5ZfZykrdZ1qQLKxP6DwHOmJr9u2b4IxjUX9qUMuq4B02ghD2g6yU3YivEosZ7fpo\\n\" +\n+            \"srD2TBN29JpgPGrOrpOE+ArZuIpBjdKFinemu6fTDD0NCeQlfyHXd1NOYyfYRLTa\\n\" +\n+            \"xlpDqr\/2M41BgSkWQfSPHHyRWNQgWBiGsIQaS8TK0g8OWi1ov78+2K9DWT+AHgXW\\n\" +\n+            \"AanjZK91GfygPXJYSlAGxSiBAwH\/KhAMifhaoFYAbH0Yuohmd85B45G2xVsop4TM\\n\" +\n+            \"Dsl007U7qnS7sdJ4jYGzEvva\/a95AgMBAAGjggE5MIIBNTASBgNVHRMBAf8ECDAG\\n\" +\n+            \"AQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHQ4EFgQUYtRCXoZwdWqQvMa40k1g\\n\" +\n+            \"wjS6UTowHwYDVR0jBBgwFoAUhBjMhTTsvAyUlC4IWZzHshBOCggwewYIKwYBBQUH\\n\" +\n+            \"AQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5yb290Y2ExLmFtYXpvbnRy\\n\" +\n+            \"dXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDovL2NydC5yb290Y2ExLmFtYXpvbnRy\\n\" +\n+            \"dXN0LmNvbS9yb290Y2ExLmNlcjA\/BgNVHR8EODA2MDSgMqAwhi5odHRwOi8vY3Js\\n\" +\n+            \"LnJvb3RjYTEuYW1hem9udHJ1c3QuY29tL3Jvb3RjYTEuY3JsMBEGA1UdIAQKMAgw\\n\" +\n+            \"BgYEVR0gADANBgkqhkiG9w0BAQsFAAOCAQEAMHbSWHRFMzGNIE0qhN6gnRahTrTU\\n\" +\n+            \"CDPwe7l9\/q0IA+QBlrpUHnlAreetYeH1jB8uF3qXXzy22gpBU7NqulTkqSPByT1J\\n\" +\n+            \"xOhpT2FpO5R3VAdMPdWfSEgtrED0jkmyUQrR1T+\/A+nBLdJZeQcl+OqLgeY790JM\\n\" +\n+            \"JJTsJnnI6FBWeTGhcDI4Y+n3KS3QCVePeWI7jx1dhrHcXH+QDX8Ywe31hV7YENdr\\n\" +\n+            \"HDpUXrjK6eHN8gazy8G6pndXHFwHp4auiZbJbYAk\/q1peOTRagD2JojcLkm+i3cD\\n\" +\n+            \"843t4By6YT\/PVlePU2PCWejkrJQnKQAPOov7IA8kuO2RDWuzE\/zF6Hotdg==\\n\" +\n@@ -133,4 +103,6 @@\n-    \/\/ Owner: CN=valid.rootca1.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 2048 M02, O=Amazon, C=US\n-    \/\/ Serial number: 60c6e837b2e7586d8464eb34f4a85fe\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca1a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=Private Organization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n+    \/\/ Serial number: 703e4e4bbd78e2b6db5634f36c4ee944cb1a4\n+    \/\/ Valid from: Mon Jul 29 16:53:36 PDT 2019 until: Sat Aug 29 16:53:36 PDT 2020\n@@ -138,33 +110,28 @@\n-            \"MIIGKDCCBRCgAwIBAgIQBgxug3sudYbYRk6zT0qF\/jANBgkqhkiG9w0BAQsFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDIwNDggTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n-            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbTCCASIw\\n\" +\n-            \"DQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAL3hA+omhUcO8nYO8\/+dkpbYz8WI\\n\" +\n-            \"1ms7Y7JA2pPFfp2N\/aWcf6m5ORm1BkyGLOttjTu318Qpa9eahQ1Pi3RNe3BtqjD9\\n\" +\n-            \"jcHncpwAFMsXy1beZA7sZ7AA4vKltA3t6yrU5ruTLUGQwUndeIBBSTW5QpdT9I\/p\\n\" +\n-            \"EM7d+Miwre63kofbJ1lVPAJvN\/udMVqGWNF8V5qscklUUHoSKA3FWWsiCyIgnthg\\n\" +\n-            \"G3u6R1KH66Qionp0ho\/ttvrBCI0C\/bdrdH+wybFv8oFFvAW2U9xn2Azt47\/2kHHm\\n\" +\n-            \"tTRjrgufhDbcz\/MLR6hwBXAJuwVvJZmSqe7B4IILFexu6wjxZfyqVm2FMr8CAwEA\\n\" +\n-            \"AaOCAzMwggMvMB8GA1UdIwQYMBaAFMAxUs1aUMOCfHRxzsvpnPl664LiMB0GA1Ud\\n\" +\n-            \"DgQWBBSkrnsTnjwYhDRAeLy\/9FXm\/7hApDBlBgNVHREEXjBcgiJ2YWxpZC5yb290\\n\" +\n-            \"Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tghpnb29kLnNjYTBhLmFtYXpvbnRydXN0\\n\" +\n-            \"LmNvbYIaZ29vZC5zY2ExYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWg\\n\" +\n-            \"MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAs\\n\" +\n-            \"hipodHRwOi8vY3JsLnIybTAyLmFtYXpvbnRydXN0LmNvbS9yMm0wMi5jcmwwEwYD\\n\" +\n-            \"VR0gBAwwCjAIBgZngQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFo\\n\" +\n-            \"dHRwOi8vb2NzcC5yMm0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0\\n\" +\n-            \"dHA6Ly9jcnQucjJtMDIuYW1hem9udHJ1c3QuY29tL3IybTAyLmNlcjAMBgNVHRMB\\n\" +\n-            \"Af8EAjAAMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520\\n\" +\n-            \"zROiModGfLzs3sNRSFlGcR+1mwAAAYgHvXWVAAAEAwBHMEUCICAs74qT1f9ufSr5\\n\" +\n-            \"PgQqtQFiXBbmbb3i4xwVV78USU5NAiEA\/iJEfnTG+hZZaHYv2wVbg6tUY8fQgIhI\\n\" +\n-            \"2rbl6PrD9FIAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgH\\n\" +\n-            \"vXWWAAAEAwBHMEUCIQDf2nWyee\/5+vSgk\/O8P0BFvXYu89cyAugZHyd919BdAgIg\\n\" +\n-            \"UnGGpQtZmWnPMmdgpzI7jrCLuC370Tn0i7Aktdzj2X8AdgDatr9rP7W2Ip+bwrtc\\n\" +\n-            \"a+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXVpAAAEAwBHMEUCIGN6cT+6uwDospXe\\n\" +\n-            \"gMa8b38oXouXUT66X2gOiJ0SoRyQAiEAjDMu2vEll5tRpUvU8cD4gR2xV4hqoDxx\\n\" +\n-            \"Q+QGW+PvJxcwDQYJKoZIhvcNAQELBQADggEBACtxC3LlQvULeI3lt7ZYFSWndEhm\\n\" +\n-            \"tNUotoeKSXJXdoIpqSr10bzMPX9SHvemgOUtzP3JNqWPHw1uW9YFyeDE6yWj\/B13\\n\" +\n-            \"Xj1hv1cqYIwyaOZBerU\/9PT5PaCn20AC9DHbc7iBv+zs+DYiqlAFJ1GVaprwLul4\\n\" +\n-            \"8wp3gnC3Hjb8NykydCo6vw0AJ2UzjpjiTyVZ93jITzLOiboOUa1gQGnojzWlYaet\\n\" +\n-            \"sXe+RDylBp\/Wuj1ZS7v\/etltzYm5GanPi4y\/p7Ta3Uky6std\/GM6XbPRdBEFboFR\\n\" +\n-            \"B2IP0divd9c74Q+tLgpsAz5yXm9LtYPMcEPC2YRN2PgBg67c5+A7eIOluuw=\\n\" +\n+            \"MIIFEzCCA\/ugAwIBAgITBwPk5LvXjitttWNPNsTulEyxpDANBgkqhkiG9w0BAQsF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMUExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTA3MjkyMzUzMzZaFw0yMDA4\\n\" +\n+            \"MjkyMzUzMzZaMIHaMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwC\\n\" +\n+            \"AQITCERlbGF3YXJlMR0wGwYDVQQPExRQcml2YXRlIE9yZ2FuaXphdGlvbjEQMA4G\\n\" +\n+            \"A1UEBRMHNTg0Njc0MzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x\\n\" +\n+            \"EDAOBgNVBAcTB1NlYXR0bGUxHjAcBgNVBAoTFUFtYXpvbiBUcnVzdCBTZXJ2aWNl\\n\" +\n+            \"czEjMCEGA1UEAxMaZ29vZC5zY2ExYS5hbWF6b250cnVzdC5jb20wggEiMA0GCSqG\\n\" +\n+            \"SIb3DQEBAQUAA4IBDwAwggEKAoIBAQDQyuJ83c2Zf9k29f6iLqd8nJSuHSk1v+SS\\n\" +\n+            \"0sYyG8tjscfCC1HcOdNj37vtiNN65sXh\/e\/kBKH9wvzhCLOJbBqVKRHOZuHdJEpH\\n\" +\n+            \"35R6C\/PbcV\/tp49g6mNmBe+lcmm\/cwwCtYvkL0rgL\/OKB0liFhhRIqy2TPg08op\/\\n\" +\n+            \"RlY2DdbgBA2B3g7wdMo0hK3SO56\/QUccUtLRm43km9Yd4E3U+CEUyDd0Bmc\/YbPa\\n\" +\n+            \"htuXVsXJwiwlwooomujIIENhFw3htdcsu2apRj8EYUrKL8Mvvn+h16gDyobj0f01\\n\" +\n+            \"jWXlUgmH2lzUzca5eGuphfvmWN\/ME\/yqC2mMvWGnWySycqtT8VdJAgMBAAGjggFj\\n\" +\n+            \"MIIBXzAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0OBBYEFFENOZBwFkjVdQX0iK32c77z\\n\" +\n+            \"SUl6MB8GA1UdIwQYMBaAFGLUQl6GcHVqkLzGuNJNYMI0ulE6MB0GA1UdJQQWMBQG\\n\" +\n+            \"CCsGAQUFBwMBBggrBgEFBQcDAjB1BggrBgEFBQcBAQRpMGcwLQYIKwYBBQUHMAGG\\n\" +\n+            \"IWh0dHA6Ly9vY3NwLnNjYTFhLmFtYXpvbnRydXN0LmNvbTA2BggrBgEFBQcwAoYq\\n\" +\n+            \"aHR0cDovL2NydC5zY2ExYS5hbWF6b250cnVzdC5jb20vc2NhMWEuY2VyMCUGA1Ud\\n\" +\n+            \"EQQeMByCGmdvb2Quc2NhMWEuYW1hem9udHJ1c3QuY29tMFAGA1UdIARJMEcwDQYL\\n\" +\n+            \"YIZIAYb9bgEHGAMwNgYFZ4EMAQEwLTArBggrBgEFBQcCARYfaHR0cHM6Ly93d3cu\\n\" +\n+            \"YW1hem9udHJ1c3QuY29tL2NwczANBgkqhkiG9w0BAQsFAAOCAQEAmn7z6Ub1sL77\\n\" +\n+            \"wyUEaCq\/Odqm+2RtYYMJ1MeW6nTXTfAgZ\/iLx\/6hStafd9AK9gHiTCggBpj6KgnF\\n\" +\n+            \"UsGMDeX879jP675fH6SEk710QPDhIrfAzwE0pF\/eUNsd7pLwne32zHX0ouCoAt4d\\n\" +\n+            \"KwBCZkKNUkdj4U+bpOJzvtcTP9JlzziLp9IFRjjQh3xKgfblx57CmRJbqH3fT5JJ\\n\" +\n+            \"IAIDVTz3ZUcqhPTFAnNsO1oNBEyrO5X9rwCiSy7aRijY\/11R75mIIvyA9zyd9ss1\\n\" +\n+            \"kvrrER0GWMTDvC84FZD2vhkXgPTFrB1Dn9f3QgO5APT9GCFY5hdpqqPEXOSdRzQo\\n\" +\n+            \"h9j4OQAqtA==\\n\" +\n@@ -173,4 +140,6 @@\n-    \/\/ Owner: CN=revoked.rootca1.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 2048 M01, O=Amazon, C=US\n-    \/\/ Serial number: e1023665b1268d788cc25bf69a9d05e\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca1a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=PrivateOrganization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 1A, O=Amazon, C=US\n+    \/\/ Serial number: 6f1d774ad5e7b6d251d217661782bbdb6f37d\n+    \/\/ Valid from: Mon Jan 28 15:34:38 PST 2019 until: Thu Apr 28 16:34:38 PDT 2022\n@@ -178,34 +147,26 @@\n-            \"MIIGMjCCBRqgAwIBAgIQDhAjZlsSaNeIzCW\/aanQXjANBgkqhkiG9w0BAQsFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDIwNDggTTAxMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n-            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2ExLmRlbW8uYW1hem9udHJ1c3QuY29tMIIB\\n\" +\n-            \"IjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxSPd1PWACxZohFCAJT1JWuXK\\n\" +\n-            \"GY29wZZ9yY0zoiq6+qYiUIU0crktytUNNI1ZpW\/3qXpEw2ZQkM6WF1LshXtwGwrA\\n\" +\n-            \"zJwSeX1L9T5rOKhoBvoFeqfX7xu4VBM1\/fDGt5X+NRFfD9Op9UfK5OsnL05TYach\\n\" +\n-            \"rdnfOA5wKGvMgFiN5CeOD0AtumXSuAnTZC85ojJTHjPF+hqV893WvrrUxLyyxtvh\\n\" +\n-            \"lq\/WttFOjhfQu2IkfyDAFiH939uzUi0WSTAdsbsHuko5mDTDnOfMRbaaWZu0At01\\n\" +\n-            \"EgaIPeK+kGdi7EYwVndIwTKLeQ4mjIM8aj8Heg\/y2hZ0kOmfCUZdUmJFlNoCIQID\\n\" +\n-            \"AQABo4IDOzCCAzcwHwYDVR0jBBgwFoAUgbgOY4qJEhjl+js7UJWf5uWQE4UwHQYD\\n\" +\n-            \"VR0OBBYEFMeBhIOkuWUY4DYqFrfgbD2eUeFtMG0GA1UdEQRmMGSCJHJldm9rZWQu\\n\" +\n-            \"cm9vdGNhMS5kZW1vLmFtYXpvbnRydXN0LmNvbYIdcmV2b2tlZC5zY2EwYS5hbWF6\\n\" +\n-            \"b250cnVzdC5jb22CHXJldm9rZWQuc2NhMWEuYW1hem9udHJ1c3QuY29tMA4GA1Ud\\n\" +\n-            \"DwEB\/wQEAwIFoDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0f\\n\" +\n-            \"BDQwMjAwoC6gLIYqaHR0cDovL2NybC5yMm0wMS5hbWF6b250cnVzdC5jb20vcjJt\\n\" +\n-            \"MDEuY3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggr\\n\" +\n-            \"BgEFBQcwAYYhaHR0cDovL29jc3AucjJtMDEuYW1hem9udHJ1c3QuY29tMDYGCCsG\\n\" +\n-            \"AQUFBzAChipodHRwOi8vY3J0LnIybTAxLmFtYXpvbnRydXN0LmNvbS9yMm0wMS5j\\n\" +\n-            \"ZXIwDAYDVR0TAQH\/BAIwADCCAX4GCisGAQQB1nkCBAIEggFuBIIBagFoAHYA7s3Q\\n\" +\n-            \"ZNXbGs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB72TggAABAMARzBFAiAZ\\n\" +\n-            \"naLbRHRuaRrE304GSuWX\/79MU\/e+SSlr0cNJ0kNNaAIhAPnz9HayL4txhkTEZiMs\\n\" +\n-            \"nttNnNqD17I0J17JLVOF4i\/4AHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/\\n\" +\n-            \"qznYhHMAAAGIB72TmwAABAMARzBFAiEAgEqT7CYGQ\/u36\/3YcxBH78QfknI9kgcY\\n\" +\n-            \"sgJLkurUF6cCIFZZ\/b803+ek6o+bmdV\/uVx2UlskAyyolZ2okBAb6IscAHYA2ra\/\\n\" +\n-            \"az+1tiKfm8K7XGvocJFxbLtRhIU0vaQ9MEjX+6sAAAGIB72TbQAABAMARzBFAiEA\\n\" +\n-            \"6z2RSoK263hvYF71rj1d0TpC70\/6zagSRR4glHOT6IACICYvaMAnrCNSTSiZ20Wz\\n\" +\n-            \"Ju5roTippO3BWKhQYrTKZuu4MA0GCSqGSIb3DQEBCwUAA4IBAQB4S1JGulFpMIaP\\n\" +\n-            \"NtLUJmjWz8eexQdWLDVF+H8dd6xpZgpiYtig\/Ynphzuk1IIF8DkT3CeK\/9vrezgI\\n\" +\n-            \"igNjneN9B4eIuzi\/rJzIKeUwpZ2k5D+36Ab4esseoc+TopmNerw8hidt2g818jER\\n\" +\n-            \"D71ppSMakeQFPGe\/Hs2\/cVa\/G1DNVcU2XAut45yRZ\/+xsZ0\/mcBDVsG9P5uGCN5O\\n\" +\n-            \"7SAp4J959WnKDqgVuU9WowPE5IjmS9BAv2gjniFYdDV2yksyf7+8edHd1KfSVX06\\n\" +\n-            \"pLx6CuCVZGJFG4Q2Aa1YAh1Wvt9hqWeXXpNRO2\/wChL5rhT4GajsrGepsk4bjxYX\\n\" +\n-            \"Wf2iZ8mX\\n\" +\n+            \"MIIE2zCCA8OgAwIBAgITBvHXdK1ee20lHSF2YXgrvbbzfTANBgkqhkiG9w0BAQsF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMUExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTAxMjgyMzM0MzhaFw0yMjA0\\n\" +\n+            \"MjgyMzM0MzhaMIHcMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwC\\n\" +\n+            \"AQITCERlbGF3YXJlMRwwGgYDVQQPExNQcml2YXRlT3JnYW5pemF0aW9uMRAwDgYD\\n\" +\n+            \"VQQFEwc1ODQ2NzQzMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQ\\n\" +\n+            \"MA4GA1UEBxMHU2VhdHRsZTEeMBwGA1UEChMVQW1hem9uIFRydXN0IFNlcnZpY2Vz\\n\" +\n+            \"MSYwJAYDVQQDEx1yZXZva2VkLnNjYTFhLmFtYXpvbnRydXN0LmNvbTCCASIwDQYJ\\n\" +\n+            \"KoZIhvcNAQEBBQADggEPADCCAQoCggEBANUoHop9sW+QlgVsdtacioraTAWHcSTd\\n\" +\n+            \"MNkOkOEMgJIFPyfdcDvW\/H2NvpdYeIQqzaCgT2kcsONWTZTPJMirCPnzl1ohHOZU\\n\" +\n+            \"uTnOVkamGxvNmQCURLBXmlCMRTCI5RY3CuYntFFbSPAnbumsF+K\/gKqcE6ME53Bw\\n\" +\n+            \"PAwn4qwavB0i5Ib7Jk8XYzxSYXC9l8QLxt6fshPJRlecpXzfmVFvMAm3IbaLcpuv\\n\" +\n+            \"AtD+8I2KwjNtBPRPNYeFsWxwsgUGAyHEGa61oTGUqqAXu5YmPfyK+YTOJdoofsh4\\n\" +\n+            \"Tf3K7AKxnPWuvY3RNTs1pzEVwJYZqSsNwbgyKJJ4+0Xe4iP7qB8SYf8CAwEAAaOC\\n\" +\n+            \"ASkwggElMA4GA1UdDwEB\/wQEAwIFoDAdBgNVHQ4EFgQUGHreoz+LP\/Wr+RKzuexO\\n\" +\n+            \"V8ICtmEwHwYDVR0jBBgwFoAUYtRCXoZwdWqQvMa40k1gwjS6UTowHQYDVR0lBBYw\\n\" +\n+            \"FAYIKwYBBQUHAwEGCCsGAQUFBwMCMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcw\\n\" +\n+            \"AYYhaHR0cDovL29jc3Auc2NhMWEuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAC\\n\" +\n+            \"hipodHRwOi8vY3J0LnNjYTFhLmFtYXpvbnRydXN0LmNvbS9zY2ExYS5jZXIwKAYD\\n\" +\n+            \"VR0RBCEwH4IdcmV2b2tlZC5zY2ExYS5hbWF6b250cnVzdC5jb20wEwYDVR0gBAww\\n\" +\n+            \"CjAIBgZngQwBAgEwDQYJKoZIhvcNAQELBQADggEBABSbe1UCLL7Qay6XK5wD8B5a\\n\" +\n+            \"wvR1XG3UrggpVIz\/w5cutEm\/yE71hzE0gag\/3YPbNYEnaLbJH+9jz4YW9wd\/cEPj\\n\" +\n+            \"xSK5PErAQjCd+aA4LKN1xqkSysgYknl0y47hJBXGnWf+hxvBBHeSoUzM0KIC21pC\\n\" +\n+            \"ZyXrmfaPCQAz13ruYIYdQaETqXGVORmKbf\/a+Zn18\/tfQt0LeeCYVoSopbXWQvcJ\\n\" +\n+            \"gUMtdIqYQmb8aVj0pdZXwKl4yZ2DtlS3Z9MpWNgQNlhRPmiYlu28y2yTtZ9SwD6m\\n\" +\n+            \"2f+cwc19aJrDT4Y280px+jRU7dIE6oZVJU+yBRVIZYpUFAB7extCMVxnTkCf8Dk=\\n\" +\n@@ -214,1 +175,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -217,1 +185,1 @@\n-        pathValidator.validate(new String[]{VALID, INT_VALID},\n+        pathValidator.validate(new String[]{VALID, INT},\n@@ -221,1 +189,1 @@\n-        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n+        pathValidator.validate(new String[]{REVOKED, INT},\n@@ -223,1 +191,1 @@\n-                \"Mon May 15 13:36:57 PDT 2023\", System.out);\n+                \"Mon Jan 28 15:35:56 PST 2019\", System.out);\n@@ -229,1 +197,1 @@\n-    \/\/ Owner: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n@@ -231,2 +199,2 @@\n-    \/\/ Serial number: 773125b0c34c3c940299a9f04a39e5a52ccd9\n-    \/\/ Valid from: Tue Aug 23 15:29:13 PDT 2022 until: Fri Aug 23 15:29:13 PDT 2030\n+    \/\/ Serial number: 67f945755f187a91f8163f3e624620177ff38\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n@@ -234,1 +202,1 @@\n-            \"MIIGXjCCBEagAwIBAgITB3MSWww0w8lAKZqfBKOeWlLM2TANBgkqhkiG9w0BAQwF\\n\" +\n+            \"MIIGRzCCBC+gAwIBAgITBn+UV1Xxh6kfgWPz5iRiAXf\/ODANBgkqhkiG9w0BAQwF\\n\" +\n@@ -236,33 +204,32 @@\n-            \"b24gUm9vdCBDQSAyMB4XDTIyMDgyMzIyMjkxM1oXDTMwMDgyMzIyMjkxM1owPDEL\\n\" +\n-            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEcMBoGA1UEAxMTQW1hem9uIFJT\\n\" +\n-            \"QSA0MDk2IE0wMjCCAiIwDQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAMGMl\/pZ\\n\" +\n-            \"1OsxHY9gw\/YfdON4mmrANkPwi7z2djHA5ELt\/vRI3Su0le6OoipLf03iyoCnYy4Y\\n\" +\n-            \"rpfTbhyDriE8NJpps2ODJ5W1h0rz6FM1Q5Jt35wfk+4CEfATBTegHVlUJ0rJgzK5\\n\" +\n-            \"Yl\/jrk12ZsC4ZeRn54shszcK6bHj4LZIHXhrYIIfetBMMD8V7hlhd54AclEWutUV\\n\" +\n-            \"eBEjkSCzDSk+pQKIjCL0crqvRSPvUNry\/BV65zfGmceSYxpcLmV7k7Spwpo+1z8w\\n\" +\n-            \"+Odfnx2vsm7olPldfaThqk6fXBtInORl4Ef32xF3VDT13UeXtQPolFhnp8UOci64\\n\" +\n-            \"bW+R8tbtGpUXIA8Dhr8SgYPH6NW4jhUD4+AG8yer8ctA1Hl9tq+6tYr26q3yuCLu\\n\" +\n-            \"5rwJdfMG634fWIRXSj+GJi8SfAdGtPyXwu5799NWesV4vUkrkSXdIBK4TQCuK+jx\\n\" +\n-            \"aJ5Y+Zo2l3GFsWyMPNORLjoQXbjF6KAyjTyICLq9VzoQKhyx4Ll2CNrQv8CxqtDC\\n\" +\n-            \"GvXi9kREJYAF6lscOB0xglAAF5lndcaNkVHEVOMdg9ZZtdJywHWm8Qed1Wty2qr+\\n\" +\n-            \"hmA7booWQNRE12nW1niC5D4cP2ykPK9HSgb7xWdUF32VidUc9tNKM6xKjSd\/R\/tP\\n\" +\n-            \"p+XAybNSwEooPt3\/OvyhpVRjLuWoqqbClTKdAgMBAAGjggFaMIIBVjASBgNVHRMB\\n\" +\n-            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n-            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFJ5xHxodk6nZLY7MSFM\/A1TznuZmMB8GA1Ud\\n\" +\n-            \"IwQYMBaAFLAM8Eww9AVYAkj9M+VSr0uE42ZSMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n-            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhMi5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n-            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhMi5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n-            \"dGNhMi5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2EyLmFt\\n\" +\n-            \"YXpvbnRydXN0LmNvbS9yb290Y2EyLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAN\\n\" +\n-            \"BgkqhkiG9w0BAQwFAAOCAgEAl1GgKXOn0j1MWT1KJVSewQ28SGbie3UwZj1dMsjJ\\n\" +\n-            \"amCrQPn2ngSNbLm9+ulFiBDU8xKR9Zx3tZps55IUKWLUPkfMC+vkV7asDBqqzzE0\\n\" +\n-            \"F\/MkekgPfOjx1V9S6Wfg3sSg+9KcluurXFElruqKfOm4cqmkV776X1G+AaaQ7mlU\\n\" +\n-            \"giCYi6NqRQSyhn8zrKkNnbO6QL5a9ICC47kiZYRAR\/hRvZOt11QUK5tCMXJXo0iO\\n\" +\n-            \"4XKkMu+jdnehP1kh4xuZhYznIgKK6MJIITFI\/Jj89U4SOPncyuS94sUuE2EqvvO\/\\n\" +\n-            \"t81qeoey6wThz5iRbU\/0CvDFnTMgebWGUZ2UZJ+az\/rb3KYXGfVWasLIonkvYT7z\\n\" +\n-            \"vHOGNAA9oQ8TTgPOmPfSVyfpplKtO\/aybWp5QSH2csIwuvw5dkmpkc42iD57XHob\\n\" +\n-            \"5LbMJg99z3vQBmod\/ipmOpND95\/BeA2mllBZgZ53S0nvDXDzbzR9Fd81PAz9Qruo\\n\" +\n-            \"dOJKcD6plKQjZjkLzNh1v\/RoCFO8kiJGE4UBMTM8FUk0DXH4bALII4wwmDelrSUu\\n\" +\n-            \"lKvDTDxZvPF4dbEXICNPd51EMGPgETxwboOV+bzWFVI0IWQ8PhZ2VuMPDk2taOMp\\n\" +\n-            \"NsuLtlYc2twPb9r\/Hvgv7G6+ItpBHZwOVt1oI3pHbjMp7P3pOZSPr6G1WkNy9mX8\\n\" +\n-            \"rVc=\\n\" +\n+            \"b24gUm9vdCBDQSAyMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjEL\\n\" +\n+            \"MAkGA1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENB\\n\" +\n+            \"IDJBMQ8wDQYDVQQDEwZBbWF6b24wggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIK\\n\" +\n+            \"AoICAQC0P8hSLewmrZ41CCPBQytZs5NBFMq5ztbnMf+kZUp9S25LPfjNW3zgC\/6E\\n\" +\n+            \"qCTWNVMMHhq7ez9IQJk48qbfBTLlZkuKnUWbA9vowrDfcxUN0mRE4B\/TJbveXyTf\\n\" +\n+            \"vE91iDlqDrERecE9D8sdjzURrtHTp27lZdRkXFvfEVCq4hl3sHkzjodisaQthLp1\\n\" +\n+            \"gLsiA7vKt+8zcL4Aeq52UyYb8r4\/jdZ3KaQp8O\/T4VwDCRKm8ey3kttpJWaflci7\\n\" +\n+            \"eRzNjY7gE3NMANVXCeQwOBfH2GjINFCObmPsqiBuoAnsv2k5aQLNoU1OZk08ClXm\\n\" +\n+            \"mEZ2rI5qZUTX1HuefBJnpMkPugFCw8afaHnB13SkLE7wxX8SZRdDIe5WiwyDL1tR\\n\" +\n+            \"2+8lpz4JsMoFopHmD3GaHyjbN+hkOqHgLltwewOsiyM0u3CZphypN2KeD+1FLjnY\\n\" +\n+            \"TgdIAd1FRgK2ZXDDrEdjnsSEfShKf0l4mFPSBs9E3U6sLmubDRXKLLLpa\/dF4eKu\\n\" +\n+            \"LEKS1bXYT28iM6D5gSCnzho5G4d18jQD\/slmc5XmRo5Pig0RyBwDaLuxeIZuiJ0A\\n\" +\n+            \"J6YFhffbrLYF5dEQl0cU+t3VBK5u\/o1WkWXsZawU038lWn\/AXerodT\/pAcrtWA4E\\n\" +\n+            \"NQEN09WEKMhZVPhqdwhF\/Gusr04mQtKt7T2v6UMQvtVglv5E7wIDAQABo4IBOTCC\\n\" +\n+            \"ATUwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYwHQYDVR0OBBYE\\n\" +\n+            \"FNpDStD8AcBLv1gnjHbNCoHzlC70MB8GA1UdIwQYMBaAFLAM8Eww9AVYAkj9M+VS\\n\" +\n+            \"r0uE42ZSMHsGCCsGAQUFBwEBBG8wbTAvBggrBgEFBQcwAYYjaHR0cDovL29jc3Au\\n\" +\n+            \"cm9vdGNhMi5hbWF6b250cnVzdC5jb20wOgYIKwYBBQUHMAKGLmh0dHA6Ly9jcnQu\\n\" +\n+            \"cm9vdGNhMi5hbWF6b250cnVzdC5jb20vcm9vdGNhMi5jZXIwPwYDVR0fBDgwNjA0\\n\" +\n+            \"oDKgMIYuaHR0cDovL2NybC5yb290Y2EyLmFtYXpvbnRydXN0LmNvbS9yb290Y2Ey\\n\" +\n+            \"LmNybDARBgNVHSAECjAIMAYGBFUdIAAwDQYJKoZIhvcNAQEMBQADggIBAEO5W+iF\\n\" +\n+            \"yChjDyyrmiwFupVWQ0Xy2ReFNQiZq7XKVHvsLQe01moSLnxcBxioOPBKt1KkZO7w\\n\" +\n+            \"Gcbmke0+7AxLaG\/F5NPnzRtK1\/pRhXQ0XdU8pVh\/1\/h4GoqRlZ\/eN0JDarUhZPkV\\n\" +\n+            \"kSr96LUYDTxcsAidF7zkzWfmtcJg\/Aw8mi14xKVEa6aVyKu54c8kKkdlt0WaigOv\\n\" +\n+            \"Z\/xYhxp24AfoFKaIraDNdsD8q2N7eDYeN4WGLzNSlil+iFjzflI9mq1hTuI\/ZNjV\\n\" +\n+            \"rbvob6FUQ8Cc524gMjbpZCNuZ1gfXzwwhGp0AnQF6CJsWF9uwPpZEVFnnnfiWH3M\\n\" +\n+            \"oup41EvBhqaAqOlny0sm5pI82nRUCAE3DLkJ1+eAtdQaYblZQkQrRyTuPmJEm+5y\\n\" +\n+            \"QwdDVw6uHc5OsSj\/tyhh8zJ2Xq3zgh3dMONGjJEysxGaCoIb+61PWwMy2dIarVwI\\n\" +\n+            \"r+c+AY+3PrhgBspNdWZ87JzNHii7ksdjUSVGTTy1vGXgPYrv0lp0IMnKaZP58xiw\\n\" +\n+            \"rDx7uTlQuPVWNOZvCaT3ZcoxTsNKNscIUe+WJjWx5hdzpv\/oksDPY5ltZ0j3hlDS\\n\" +\n+            \"D+Itk95\/cNJVRM\/0HpxI1SX9MTZtOSJoEDdUtOpVaOuBAvEK4gvTzdt0r5L+fuI6\\n\" +\n+            \"o5LAuRo\/LO1xVRH49KFRoaznzU3Ch9+kbPb3\\n\" +\n@@ -271,4 +238,6 @@\n-    \/\/ Owner: CN=valid.rootca2.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n-    \/\/ Serial number: 662f7646d76193cbb76946d111e49fa\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca2a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=Private Organization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n+    \/\/ Serial number: 703e4e70616c90d611fd04a5ecc635665184e\n+    \/\/ Valid from: Mon Jul 29 16:54:06 PDT 2019 until: Sat Aug 29 16:54:06 PDT 2020\n@@ -276,43 +245,38 @@\n-            \"MIIICzCCBfOgAwIBAgIQBmL3ZG12GTy7dpRtER5J+jANBgkqhkiG9w0BAQwFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLTEr\\n\" +\n-            \"MCkGA1UEAxMidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbTCCAiIw\\n\" +\n-            \"DQYJKoZIhvcNAQEBBQADggIPADCCAgoCggIBAON5EbEKoBiujI7Ja8mLZLJbaY7f\\n\" +\n-            \"RtoWIjU\/F0l9ueWFogXmEaA1jWsl97F3WTHTyGKz6ChCjPMSyoXXpY+yoE90QUyX\\n\" +\n-            \"w35uWEhNrc40drMJkyN+QXitSrH346GCOKvpYVvu18UD4W8hDhg8vvbOQYhtmSf7\\n\" +\n-            \"Rfrs7\/qUdXpzpvR9VjWktbQAzJT8fB\/jFNjNQJTknynjGiYO5GF51+peOCLK6qw8\\n\" +\n-            \"9kKYEigR4K8\/aWL283rC4xRxZqVioy433VG02l\/Fwdv8o\/vL9YYIqkyspCB9fpFw\\n\" +\n-            \"Q50yYrwEomxuOz7rXhmdfeNaFYuyTtOUSKff6p2oqO0S7pcLujUVMlO4dYBDELQF\\n\" +\n-            \"cabByNjwblviCtGKJMIzD6Thkgamp3iXQgcU498+P5r7N5CYbMmkJEdcuILg+bgJ\\n\" +\n-            \"\/LUUTT+IMt2txYlO\/ld3N0EHlgVt7rztW5mtm6Ba8jN7cLSh7ZWu6Fr1+oK7bl5T\\n\" +\n-            \"wPxSfqT5W3BwQKS3YptIoKEWUb+VNnS\/dYx\/7IspF9+z6kw4g+V2EY9M4ZYNakzM\\n\" +\n-            \"AI7KIj4thMFoWeYrJq0dUMZ297QCBPRdAwh9hhkq2LYi2x8tMUtcBnhb\/q75sO+E\\n\" +\n-            \"icPqFVv7iMDZ\/8Xep+0UoClF3JGmZW3UNtwcbi7Pn\/OqtaMi7E8xnHUgc4ZchtXO\\n\" +\n-            \"v8VtVvDeZAlY5TjVAgMBAAGjggMWMIIDEjAfBgNVHSMEGDAWgBSecR8aHZOp2S2O\\n\" +\n-            \"zEhTPwNU857mZjAdBgNVHQ4EFgQUnGekBRKIZBYgCEajbpCMC24bp2owSQYDVR0R\\n\" +\n-            \"BEIwQIIidmFsaWQucm9vdGNhMi5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n-            \"Y2EyYS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWgMB0GA1UdJQQWMBQG\\n\" +\n-            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n-            \"LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n-            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5y\\n\" +\n-            \"NG0wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQucjRt\\n\" +\n-            \"MDIuYW1hem9udHJ1c3QuY29tL3I0bTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfQYK\\n\" +\n-            \"KwYBBAHWeQIEAgSCAW0EggFpAWcAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n-            \"SFlGcR+1mwAAAYgHvX9QAAAEAwBHMEUCIQD8qPPCLL2Grd+\/YNALWqAq7LC7YBaa\\n\" +\n-            \"dNg5+6Q4kRDEqgIgEkf\/UMsMNfTRaOZvoOgAK9\/F0xX\/CfdcUTjULhmoA+cAdQBI\\n\" +\n-            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvX8UAAAEAwBGMEQC\\n\" +\n-            \"IBVFDtapMMWJOqyu8Cv6XEhFmbU8N33c2owed\/\/pa80xAiAT9T6Wba3B9DFUmrL5\\n\" +\n-            \"cCGKLqciIEUPhPbvjCuUepelrAB2ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2k\\n\" +\n-            \"PTBI1\/urAAABiAe9ft8AAAQDAEcwRQIhAP2XDC\/RlmVtH4WrfSwVosR\/f\/WXRhG5\\n\" +\n-            \"mk9Nwq+ZOIriAiAopPXSH7VwXa3bEAIiTwcV1l10QIDZaIPCU5olknU5CjANBgkq\\n\" +\n-            \"hkiG9w0BAQwFAAOCAgEAFuwMIJdP5rgz6cqOIj2EgF2OU8CUGi\/wJ45BomXWv4Rv\\n\" +\n-            \"U5mOKB+jHOGZZC9dncjAMa44RwoF2I7\/8Y3qLVaoNm46ObvvS+6UvzTcyQqXM7JU\\n\" +\n-            \"cSmdlf9DkspjKPDvMBokVrM4ak5AoxUjuru5qaia3nvbxq7XKO9\/FGUaUaU8Xlsd\\n\" +\n-            \"V6Fo8VmNwFc88VCqOp8eI\/IicHxMDLl8TKXMvr3CYh8A9nCeFGcV+4CL+7JF2t5K\\n\" +\n-            \"YvV5r074Wyk0QMlRVYMNDl0t+VAEoDJ7RRE+kEvplWcsX9S2wvr4HhkA4iChpwFm\\n\" +\n-            \"2UDTppHskSWyLsuNQvipn0zTzZ8RIxXd\/ei0qCdhKmkV7x9cgbTiyXgaI7iJEtdo\\n\" +\n-            \"RvYNcXc2RmitWjY5Av8yJGOk0eYpCwRrBv6ughbtJe3NMrqUeTyrKidIEo9KnRSA\\n\" +\n-            \"rMokRbHunkroS97VkoK\/9j9pNJki+qAH9XTLYWcm\/5+cTSGRsN+escRgZwV6KWg\/\\n\" +\n-            \"JQQe5LbwU2HHzNqWuk63GC\/ngVlWXjaVFfbNVmYEKZFFazcZchesN1YyDu+WndOx\\n\" +\n-            \"+rTcuke2feOvQ4EnVviM0k85JZNiqPDH2iafAWyqZFUYTnb7XK3HhJflAniv\/SLq\\n\" +\n-            \"DQfbJmtQtNHdJYgVmC1u2RT9gbJDIAj0ZI4vU2WVB5Hmd9F31un6jundEuG4+S4=\\n\" +\n+            \"MIIHEzCCBPugAwIBAgITBwPk5wYWyQ1hH9BKXsxjVmUYTjANBgkqhkiG9w0BAQwF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMkExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTA3MjkyMzU0MDZaFw0yMDA4\\n\" +\n+            \"MjkyMzU0MDZaMIHaMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwC\\n\" +\n+            \"AQITCERlbGF3YXJlMR0wGwYDVQQPExRQcml2YXRlIE9yZ2FuaXphdGlvbjEQMA4G\\n\" +\n+            \"A1UEBRMHNTg0Njc0MzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24x\\n\" +\n+            \"EDAOBgNVBAcTB1NlYXR0bGUxHjAcBgNVBAoTFUFtYXpvbiBUcnVzdCBTZXJ2aWNl\\n\" +\n+            \"czEjMCEGA1UEAxMaZ29vZC5zY2EyYS5hbWF6b250cnVzdC5jb20wggIiMA0GCSqG\\n\" +\n+            \"SIb3DQEBAQUAA4ICDwAwggIKAoICAQC+XjOB3ZCFX+b9y9reP+e6EAQz4ytiMSqU\\n\" +\n+            \"O4s5MyYLkY6n4BIZHmgWeQ2IgW1VrH8ho+Iu3UsTiuhd3\/L\/q\/w+T0OJfcrWngTs\\n\" +\n+            \"uVcIuvUr32ObPeeWbg\/m\/lkN7hqH1jY62iybYVrFXiLo1+0G92PUazcyNvyA20+G\\n\" +\n+            \"HsvGG5jlArWNgRLdc8KUXxvnDUxx5vu4jeHEZnqSwuulV1h9ve0UutkmoK0Sk7Rz\\n\" +\n+            \"HMxYK0LmUT5OvcNQSkUi5nLi+M1FxnYYgsELwSiKSSEDfEdgxooMAiVTgw51Q\/DB\\n\" +\n+            \"lTOjAIDL3K3J0yGfIG3bwLvE1qz2Z5yWn8f3JibIah7LrC4PiZDDLHFM6V9l+YqU\\n\" +\n+            \"RqimJ5BltSyAx7bxQNZ1AW3Lxvvm894i4k6\/Vdf1CDovRuTMPCDAQmKA\/A\/AQ7TN\\n\" +\n+            \"q3bBimX6UyuJu0I8RyvAYKzFhOOqe4vXrbndTbje\/jnzTNQPeIIcuRa9cgXTOrbw\\n\" +\n+            \"86FTUKj6AZXihRWjKWsQpDwdgE0tQETZ3ynCXfbBKfFmn0MSjeX0CEEAZdYHR8EV\\n\" +\n+            \"F271Yt7UJjS\/FP702aHTOWk7zFbIRfFQODvBhn0I8p\/Stk2sDq4\/YsbXVZOe3+ad\\n\" +\n+            \"YavoiODGSAH6ZcZzULumgK9eii0koAOPB\/xqXnkcTS63gEHOKjLQl3hqdVZRCugv\\n\" +\n+            \"1CwUXLvoSwIDAQABo4IBYzCCAV8wDgYDVR0PAQH\/BAQDAgWgMB0GA1UdDgQWBBTa\\n\" +\n+            \"j6dHgPdOxTGLcwaNDeaMnlSxNjAfBgNVHSMEGDAWgBTaQ0rQ\/AHAS79YJ4x2zQqB\\n\" +\n+            \"85Qu9DAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwdQYIKwYBBQUHAQEE\\n\" +\n+            \"aTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5zY2EyYS5hbWF6b250cnVzdC5j\\n\" +\n+            \"b20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2NhMmEuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"L3NjYTJhLmNlcjAlBgNVHREEHjAcghpnb29kLnNjYTJhLmFtYXpvbnRydXN0LmNv\\n\" +\n+            \"bTBQBgNVHSAESTBHMA0GC2CGSAGG\/W4BBxgDMDYGBWeBDAEBMC0wKwYIKwYBBQUH\\n\" +\n+            \"AgEWH2h0dHBzOi8vd3d3LmFtYXpvbnRydXN0LmNvbS9jcHMwDQYJKoZIhvcNAQEM\\n\" +\n+            \"BQADggIBAE6RwZAZvN0i9ygwzqoX9DhSPtvZ3xIO0G0Bhgjkb986+p8XJstU3gEM\\n\" +\n+            \"8P2i1J\/YthXCnRGedm+Odxx+31G6xIYfP5S5g7HyRGkj\/aXNXy4s3KjH8HJgOY9N\\n\" +\n+            \"ra3XfC05OKq5FpyZQDZ+hxCdLrH3Gs+UxREbu+LuIKUpI7nMVEjn9XynKyOdKN21\\n\" +\n+            \"Kq5VsuI0fDWCYvUN1M+lI\/LgE5HbNJVQJs+dB7g1\/kaOeaLia7Wk1ys+uRzB58rp\\n\" +\n+            \"FKAoLk++HWTfNDkbN8vKRfHhJ\/xhI9ju3TWcci6EyFVAym1C62UkJNI0KHgQ+zc7\\n\" +\n+            \"nl1tv\/ytj8N\/eJoysyp23lJ5qrVetlQORfgXryGkWBMYBvYF8zbBb\/f+UXHDKVWt\\n\" +\n+            \"9l1lL6HQGY\/tTo253pj6\/FgDD35bZdjLQeUVmbnz679S5oUmoH5ZtSdnpUTghU3p\\n\" +\n+            \"bae9adBFY9S1pm50Q3ckRVBAwNqNmI0KKUh14Ms8KSAUHg19NvGsBonqwOT2rdbv\\n\" +\n+            \"xZ47N6c2eCl\/cjMvzre0v0NoUO+3og2GHeAoOwVos6480YDbMqp739tOFPxBcsII\\n\" +\n+            \"6SjpDVh+14dkSW6kEKeaCFLR+eChqutri1VQbQ49nmADQWw9Al8vBytSnPv0YN6W\\n\" +\n+            \"XfIE1Qj7YmHu\/UuoeKVsqDqoP\/no29+96dtfd4afJqlIoyZUqXpt\\n\" +\n@@ -321,4 +285,6 @@\n-    \/\/ Owner: CN=revoked.rootca2.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon RSA 4096 M02, O=Amazon, C=US\n-    \/\/ Serial number: 788baa8f47bc5b1c624424216240fd3\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca2a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=PrivateOrganization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/Issuer: CN=Amazon, OU=Server CA 2A, O=Amazon, C=US\n+    \/\/Serial number: 6f1d782c0aa2f4866b7b522c279b939b92369\n+    \/\/Valid from: Mon Jan 28 15:37:45 PST 2019 until: Thu Apr 28 16:37:45 PDT 2022\n@@ -326,44 +292,37 @@\n-            \"MIIIEjCCBfqgAwIBAgIQB4i6qPR7xbHGJEJCFiQP0zANBgkqhkiG9w0BAQwFADA8\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRwwGgYDVQQDExNBbWF6b24g\\n\" +\n-            \"UlNBIDQwOTYgTTAyMB4XDTIzMDUxMDAwMDAwMFoXDTI0MDYwNzIzNTk1OVowLzEt\\n\" +\n-            \"MCsGA1UEAxMkcmV2b2tlZC5yb290Y2EyLmRlbW8uYW1hem9udHJ1c3QuY29tMIIC\\n\" +\n-            \"IjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAzJfddWdrWhA9dSJdmy23veN9\\n\" +\n-            \"oLvSqpM4YaXGZmPtKUmbFMLs2I3vCKrzflRKeOpl3MCc2hh6TH\/3z+Q\/fGugXLsY\\n\" +\n-            \"H8QcjSbiIOd15n+3dUFTLKaoWMyseMcWiOIVaN5rCDVXiAHdt1pc147wyFQIzqNK\\n\" +\n-            \"J\/xiV1u9eT2MFue+4bd7kUNAcmI8M+SXruhto4jtAV8ugpTEChTDlyO\/l8xmaM1Q\\n\" +\n-            \"HkijsHX7Aq72Q\/3PH\/U+wbJ9pmpTp4x2AEJoo45IGfB\/NKDTrv5otLBuiP8Y0M7b\\n\" +\n-            \"K7irRPDFBqMNZw7S7p39SnC+V\/WibJQk5Bo\/8vcwDJX+WnDkw1QD\/uXu3ugDzSDD\\n\" +\n-            \"iBDViMOdN+3K47s4x2kdssoh4WWScMlAVb4vyN7IA3J4TnwA\/1uCWhw4LE1WvY7N\\n\" +\n-            \"etekhVP1eWF8IzNY0oo2u2ie79777xvBtmtp7RnvYLGv7I+xVhjH5qGNzn9fRCUm\\n\" +\n-            \"QDego5HAfJ0PLlMEagdW8asCak1WaC117adnibL6WPtFA2FD2i6gNalTvhXhK2Ex\\n\" +\n-            \"alGxrVd\/BCseT3bMp783jqScJO1g6xRHu0Qx+RyrOGVvcKZa6Y0DcAc8psRpkHaO\\n\" +\n-            \"HZY+lE8O2CIxpAJlwSnD6BoDNo8sg1IqFNkECw3wqfeMPBcg38k6zjAxwRDcIx6U\\n\" +\n-            \"SwDl4d3sjrmy3gOFFXMCAwEAAaOCAxswggMXMB8GA1UdIwQYMBaAFJ5xHxodk6nZ\\n\" +\n-            \"LY7MSFM\/A1TznuZmMB0GA1UdDgQWBBQXpWT7gMHO+HKoHM1gU1VQVnylRzBOBgNV\\n\" +\n-            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTIuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n-            \"dm9rZWQuc2NhMmEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIFoDAdBgNV\\n\" +\n-            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n-            \"cDovL2NybC5yNG0wMi5hbWF6b250cnVzdC5jb20vcjRtMDIuY3JsMBMGA1UdIAQM\\n\" +\n-            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n-            \"L29jc3AucjRtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n-            \"Y3J0LnI0bTAyLmFtYXpvbnRydXN0LmNvbS9yNG0wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n-            \"ADCCAX0GCisGAQQB1nkCBAIEggFtBIIBaQFnAHYA7s3QZNXbGs7FXLedtM0TojKH\\n\" +\n-            \"Rny87N7DUUhZRnEftZsAAAGIB72CzgAABAMARzBFAiEA2vPYIPfGJeynPaZHq\/c0\\n\" +\n-            \"GGvyT6MpvFGMW0s0woLRT28CIEFbZbFSCnKugaqw9QDNi7vYmIF3Gyi3s6G2cCxY\\n\" +\n-            \"4RJXAHYASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72DDgAA\\n\" +\n-            \"BAMARzBFAiAvfNcgtFEwk5C9dvMUYANbIAv0IOdF1new8Umn3cM+JwIhALbs\/3L9\\n\" +\n-            \"0ndF7sRKDZmfronNruptFlrI528P5Qi2P528AHUA2ra\/az+1tiKfm8K7XGvocJFx\\n\" +\n-            \"bLtRhIU0vaQ9MEjX+6sAAAGIB72CxQAABAMARjBEAiBKUns2FPbs0cThb6e7SnyL\\n\" +\n-            \"y4\/qP3V1Q\/ASt\/ZDRTeEQQIgWSQO4Gsz32srtqYuTM9AsFd92WA44kJHincdcGVX\\n\" +\n-            \"XbIwDQYJKoZIhvcNAQEMBQADggIBAAnaNbn2wXylTCS7dtgB3rWdUf6hja1UDuvB\\n\" +\n-            \"uZEL2dUOvyXfVFLNxKdeWBPzqpwEBNNwPQXhoI97TXlyu2x60jLzQamoGoRQ3s0P\\n\" +\n-            \"NLhasLGEIQH\/oYdMV\/yp8EI8fUuRVE3xyw39FRqOrmsUFAnxNQmBO\/09JM7sLcvS\\n\" +\n-            \"wwh14p9dFTTolJHgnL4ZEtmZxSddFG+GBSTJ\/A7dVSmwIudwzd+goA6173BI6yeT\\n\" +\n-            \"hhQumLctQiOM7y1MzFeV8rL+oIpd2xuzyhKKT1EgvU6\/wyt0Ib8QqsFsrXPnUOKk\\n\" +\n-            \"HAq3SeZyq35QUaTKoaH9L1iZMbSCG9Jm6FMb12SdAz53653tYvAiUS76oD8Jot13\\n\" +\n-            \"RZu5NUlWAVLLq0OaEtuGp0bh+cVtzVnCC9m1qa46YpY0SojpvSbakgQMMGIgDlT3\\n\" +\n-            \"wFE7tST4WlsDC1f\/m+H9V5qz\/j0U8D3eNNdowxPqx\/JZq\/sk9ZK5KyMFARrvM+fh\\n\" +\n-            \"YrVYjKt91mu7JaS4pPOyZmJ8OQ14EvrN7BXc7IkNrI1reeaRFe49k5DAETB8VmP5\\n\" +\n-            \"2F0SWou2KkgtJvU4Z7YjlZ2HNHnpjTK5KdPNpRSt7EUy2zn9NCNoyQhnws70FyXv\\n\" +\n-            \"oPFyG92lnUQOKaAUhVRwTr9fvnkdMOzSKg\/spxi2Ogdzym5Jw68eguwi0dVqX2+9\\n\" +\n-            \"3zViP2aH\\n\" +\n+            \"MIIG2zCCBMOgAwIBAgITBvHXgsCqL0hmt7Uiwnm5ObkjaTANBgkqhkiG9w0BAQwF\\n\" +\n+            \"ADBGMQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2\\n\" +\n+            \"ZXIgQ0EgMkExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTAxMjgyMzM3NDVaFw0yMjA0\\n\" +\n+            \"MjgyMzM3NDVaMIHcMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwC\\n\" +\n+            \"AQITCERlbGF3YXJlMRwwGgYDVQQPExNQcml2YXRlT3JnYW5pemF0aW9uMRAwDgYD\\n\" +\n+            \"VQQFEwc1ODQ2NzQzMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQ\\n\" +\n+            \"MA4GA1UEBxMHU2VhdHRsZTEeMBwGA1UEChMVQW1hem9uIFRydXN0IFNlcnZpY2Vz\\n\" +\n+            \"MSYwJAYDVQQDEx1yZXZva2VkLnNjYTJhLmFtYXpvbnRydXN0LmNvbTCCAiIwDQYJ\\n\" +\n+            \"KoZIhvcNAQEBBQADggIPADCCAgoCggIBAKFm418X8hN1YTgD2XpMb4sp78mw8k3j\\n\" +\n+            \"Dq\/vnpX48evVUzNpHpy4qRz\/ZHBR4HUJO4lhfnX+CO0uRqqqx4F0JZRQB3KevaU8\\n\" +\n+            \"QGWHdJGhEddnurDhrgOUa+ZroqUnMCsTJfbyGtC6aiEXeu\/eMhEUFkuBxJH1JtwD\\n\" +\n+            \"dQXMXuMjG07SVjOkhTkbMDzA\/YbUqkDeOIybifDuvA5LEsl+kReY0b6RYFo2Tt\/M\\n\" +\n+            \"dPhJD8q3Wsu+XCiCnbpcwlEVGxiD2RVRXJJ9o3ALGOxqU69V+lYS0kkwNHT7oV9J\\n\" +\n+            \"rhgt7iOCq0aoTAxu2j4FCp0JHNhGoW9pXoMXnmS6kK80hzLNYDxvKEaVaKkiYHw5\\n\" +\n+            \"CV0Vwii05ICa14nrStH\/jcRNLyU+gp+6OeerPV3jpKWshGKWewF+2UiWU2WHTSrd\\n\" +\n+            \"Wis0\/qEfFK\/kSraAxpd+KavEEavKeudoMAHIxMACOk9E\/fF5zhd2y4G1q1BdoRlR\\n\" +\n+            \"KP4GIV2v6qH6Ru2mNSuge9il6kDXxFNucrYKLDbAqkqalohkvDavcPoG9gZT3etv\\n\" +\n+            \"4IcgJriIWRxbJwKPpwJM+6wa6RpwoeJMuEp3ZBP7KDaQ8YX4rlf4zXLAsOKCNA9K\\n\" +\n+            \"OS\/qYQ\/I4g0E1WhfgEKClaLPS2u7jeVR6s1t4txGo4vq5Dkt17KTCew\/WsX3rckf\\n\" +\n+            \"a2p5zvFcfpCNAgMBAAGjggEpMIIBJTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0OBBYE\\n\" +\n+            \"FAF8N1wV8EoYFkMXH6tEnmR\/7vI+MB8GA1UdIwQYMBaAFNpDStD8AcBLv1gnjHbN\\n\" +\n+            \"CoHzlC70MB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjB1BggrBgEFBQcB\\n\" +\n+            \"AQRpMGcwLQYIKwYBBQUHMAGGIWh0dHA6Ly9vY3NwLnNjYTJhLmFtYXpvbnRydXN0\\n\" +\n+            \"LmNvbTA2BggrBgEFBQcwAoYqaHR0cDovL2NydC5zY2EyYS5hbWF6b250cnVzdC5j\\n\" +\n+            \"b20vc2NhMmEuY2VyMCgGA1UdEQQhMB+CHXJldm9rZWQuc2NhMmEuYW1hem9udHJ1\\n\" +\n+            \"c3QuY29tMBMGA1UdIAQMMAowCAYGZ4EMAQIBMA0GCSqGSIb3DQEBDAUAA4ICAQBC\\n\" +\n+            \"VwR1NFk1IYIF4cjU7ML1aj8OIn+8mtakGQnuSJLK6ypSysINJBS48ZDdP6XZXvyD\\n\" +\n+            \"iTS0xEAPjAZHTqrABdNYmvJeL2RnN99DIwVzBpZp4NLTXbiSW7jb0Y5cEPDGJMOo\\n\" +\n+            \"SUAAM6fsiPRfz5vX4XVPznbcF2AwE\/NVV+L3n9LVRt7qv2VqIEvLioR56Dq+5ofR\\n\" +\n+            \"4bw0BVlEYWF4Gsy7WDDTL1iLNBUwZTqBHwTv0fgDRiPqb\/odmLQuRANwcJy8B8Zr\\n\" +\n+            \"s\/yX4SeESaRdA82lAlQilksQitXS2qvQN06GEDOgUxYE6EabFdgklV5JypKqdOly\\n\" +\n+            \"vzpaDpF3z5W8Bj3D4fns1Kjrh1pPh5JRvg+616diKnQRt4X5q+EtmnXhDvIGMISI\\n\" +\n+            \"FuGwj57CNQ2x2MY2HHKWPrOccpQfEEvoSNR+ntYWrtSSttZq948O+zZBk1TXWuXV\\n\" +\n+            \"TVXllqTg8lp6d5cfKgvtHKgt98WkpPOcLVrNuVnMAIfDw6ar54dVKqrvkeEcF6mJ\\n\" +\n+            \"7oMKjJX\/Vu9lYoGViBIfdeqcCPWSI8BpnCKaG7dTQO3Q1ObGmLdGBRlsRh+d+S5l\\n\" +\n+            \"Fq326ckbjx537e5\/ai31lOR7OwVh9TDweKLqIACjs987C0EJSEfoOue25WRww2va\\n\" +\n+            \"iX9SrTPm4GxQ2OJgYwx0+HbezJXFN+dhaOFUavTSFw==\\n\" +\n@@ -372,1 +331,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -381,1 +347,1 @@\n-                \"Mon May 15 13:38:54 PDT 2023\", System.out);\n+                \"Mon Jan 28 15:38:57 PST 2019\", System.out);\n@@ -387,1 +353,1 @@\n-    \/\/ Owner: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n@@ -389,27 +355,4 @@\n-    \/\/ Serial number: 773126de2c2fafd2c47ad88b1566e0182046d\n-    \/\/ Valid from: Tue Aug 23 15:33:24 PDT 2022 until: Fri Aug 23 15:33:24 PDT 2030\n-    private static final String INT_VALID = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIC1DCCAnmgAwIBAgITB3MSbeLC+v0sR62IsVZuAYIEbTAKBggqhkjOPQQDAjA5\\n\" +\n-            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRkwFwYDVQQDExBBbWF6b24g\\n\" +\n-            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzMyNFoXDTMwMDgyMzIyMzMyNFowPTELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n-            \"IDI1NiBNMDIwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAS9vQLD4W\/Kg4AnFRl8\\n\" +\n-            \"x\/FUbLqtd5ICYjUijGsytF9hmgb\/Dyk+Ebt4cw6rAlGbaiOLapSJKZiZr+UQdh3I\\n\" +\n-            \"QOr+o4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n-            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBS7eJrXaDMy\\n\" +\n-            \"nRq7bP2xNEwB3svQdTAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n-            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n-            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n-            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSQAwRgIhAKSYEcDcp3kcPMzh\\n\" +\n-            \"OIYDWZOLu4InPod4fQhRTmc2zBAgAiEAmwdGE4AuNWhw9N8REhf82rJLNm7h9Myg\\n\" +\n-            \"TsR9Wu0bQYU=\\n\" +\n-            \"-----END CERTIFICATE-----\";\n-\n-    \/\/ Owner: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n-    \/\/ Issuer: CN=Amazon Root CA 3, O=Amazon, C=US\n-    \/\/ Serial number: 773126684d577c0fcf8d3a342bea86f94fc8f\n-    \/\/ Valid from: Tue Aug 23 15:31:46 PDT 2022 until: Fri Aug 23 15:31:46 PDT 2030\n-    private static final String INT_REVOKED = \"-----BEGIN CERTIFICATE-----\\n\" +\n-            \"MIIC0zCCAnmgAwIBAgITB3MSZoTVd8D8+NOjQr6ob5T8jzAKBggqhkjOPQQDAjA5\\n\" +\n+    \/\/ Serial number: 67f945758fe55b9ee3f75831d47f07d226c8a\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n+    private static final String INT = \"-----BEGIN CERTIFICATE-----\\n\" +\n+            \"MIICuzCCAmGgAwIBAgITBn+UV1j+VbnuP3WDHUfwfSJsijAKBggqhkjOPQQDAjA5\\n\" +\n@@ -417,14 +360,13 @@\n-            \"Um9vdCBDQSAzMB4XDTIyMDgyMzIyMzE0NloXDTMwMDgyMzIyMzE0NlowPTELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n-            \"IDI1NiBNMDEwWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAAT80w+2RwNHzyXmVUM\/\\n\" +\n-            \"OUKBZpJkTzHyCKDl4sBrUfjzVjot\/lNba9kYzMKSHYv95CUDoMaF2h2KAqx65uLQ\\n\" +\n-            \"Y8ago4IBWjCCAVYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8BAf8EBAMCAYYw\\n\" +\n-            \"HQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMB0GA1UdDgQWBBRPWfy8BhYo\\n\" +\n-            \"v6LI2wj7zxMkumlCXDAfBgNVHSMEGDAWgBSrttvXBp43rDCGB5Fwx5zEGbF4wDB7\\n\" +\n-            \"BggrBgEFBQcBAQRvMG0wLwYIKwYBBQUHMAGGI2h0dHA6Ly9vY3NwLnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tMDoGCCsGAQUFBzAChi5odHRwOi8vY3J0LnJvb3RjYTMu\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tL3Jvb3RjYTMuY2VyMD8GA1UdHwQ4MDYwNKAyoDCGLmh0\\n\" +\n-            \"dHA6Ly9jcmwucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNhMy5jcmwwEwYD\\n\" +\n-            \"VR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwIDSAAwRQIhALRfxq3SQIhj5xA4\\n\" +\n-            \"S5UAY\/KlKqayZDpnbBdCDH8Kqmf\/AiAUVZddALefnqRe+ifxN2FUp461LL6\/cgVM\\n\" +\n-            \"EH3Ty27f1Q==\\n\" +\n+            \"Um9vdCBDQSAzMB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENBIDNB\\n\" +\n+            \"MQ8wDQYDVQQDEwZBbWF6b24wWTATBgcqhkjOPQIBBggqhkjOPQMBBwNCAATYcYsK\\n\" +\n+            \"mYdR0Gj8Xz45E\/lfcTTnXhg2EtAIYBIHyXv\/ZQyyyCas1aptX\/I5T1coT6XK181g\\n\" +\n+            \"nB8hADuKfWlNoIYRo4IBOTCCATUwEgYDVR0TAQH\/BAgwBgEB\/wIBADAOBgNVHQ8B\\n\" +\n+            \"Af8EBAMCAYYwHQYDVR0OBBYEFATc4JXl6LlrlKHvjFsxHhN+VZfaMB8GA1UdIwQY\\n\" +\n+            \"MBaAFKu229cGnjesMIYHkXDHnMQZsXjAMHsGCCsGAQUFBwEBBG8wbTAvBggrBgEF\\n\" +\n+            \"BQcwAYYjaHR0cDovL29jc3Aucm9vdGNhMy5hbWF6b250cnVzdC5jb20wOgYIKwYB\\n\" +\n+            \"BQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhMy5hbWF6b250cnVzdC5jb20vcm9vdGNh\\n\" +\n+            \"My5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2EzLmFtYXpv\\n\" +\n+            \"bnRydXN0LmNvbS9yb290Y2EzLmNybDARBgNVHSAECjAIMAYGBFUdIAAwCgYIKoZI\\n\" +\n+            \"zj0EAwIDSAAwRQIgOl\/vux0qfxNm05W3eofa9lKwz6oKvdu6g6Sc0UlwgRcCIQCS\\n\" +\n+            \"WSQ6F6JHLoeOWLyFFF658eNKEKbkEGMHz34gLX\/N3g==\\n\" +\n@@ -433,4 +375,6 @@\n-    \/\/ Owner: CN=valid.rootca3.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 256 M02, O=Amazon, C=US\n-    \/\/ Serial number: 8e2f14864fb28e4a1da0f15a5118cc8\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca3a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=Private Organization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n+    \/\/ Serial number: 703e4e9bbc2605f37967a0e95f31f4789a677\n+    \/\/ Valid from: Mon Jul 29 16:54:43 PDT 2019 until: Sat Aug 29 16:54:43 PDT 2020\n@@ -438,25 +382,19 @@\n-            \"MIIEfjCCBCWgAwIBAgIQCOLxSGT7KOSh2g8VpRGMyDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMjU2IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n-            \"BgNVBAMTInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6b250cnVzdC5jb20wWTATBgcq\\n\" +\n-            \"hkjOPQIBBggqhkjOPQMBBwNCAAQfWc7gBGBBBmseCb2XWWRQVhCUQDVml3mVgvj5\\n\" +\n-            \"RmnP1y5wpifUTFqu8ELdI7YGZ4JMSnetiKNmLtg5yhTEjzCQo4IDFTCCAxEwHwYD\\n\" +\n-            \"VR0jBBgwFoAUu3ia12gzMp0au2z9sTRMAd7L0HUwHQYDVR0OBBYEFHCE8orvZDUK\\n\" +\n-            \"5TI9MYadzxWR9CZGMEkGA1UdEQRCMECCInZhbGlkLnJvb3RjYTMuZGVtby5hbWF6\\n\" +\n-            \"b250cnVzdC5jb22CGmdvb2Quc2NhM2EuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\\n\" +\n-            \"\/wQEAwIHgDAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQw\\n\" +\n-            \"MjAwoC6gLIYqaHR0cDovL2NybC5lMm0wMi5hbWF6b250cnVzdC5jb20vZTJtMDIu\\n\" +\n-            \"Y3JsMBMGA1UdIAQMMAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEF\\n\" +\n-            \"BQcwAYYhaHR0cDovL29jc3AuZTJtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUF\\n\" +\n-            \"BzAChipodHRwOi8vY3J0LmUybTAyLmFtYXpvbnRydXN0LmNvbS9lMm0wMi5jZXIw\\n\" +\n-            \"DAYDVR0TAQH\/BAIwADCCAXwGCisGAQQB1nkCBAIEggFsBIIBaAFmAHUA7s3QZNXb\\n\" +\n-            \"Gs7FXLedtM0TojKHRny87N7DUUhZRnEftZsAAAGIB71y\/gAABAMARjBEAiAEAXIb\\n\" +\n-            \"aOVR26HgFaI+qoIasCb8w2sOqVxGAxf5iPgX6QIgdAlMjqeoihi1arnJpzN8Bqxy\\n\" +\n-            \"5ULMUO7GK3JEgcogJHMAdgBIsONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiE\\n\" +\n-            \"cwAAAYgHvXLkAAAEAwBHMEUCIF7wDDmWxTHwBZM7Me8eOCM1aQ\/g1c1rJg\/I+NJa\\n\" +\n-            \"HkZYAiEA8p+IviuY5piHBELjUtVlZLiS9XSSMxpQNhUerqC\/YFoAdQDatr9rP7W2\\n\" +\n-            \"Ip+bwrtca+hwkXFsu1GEhTS9pD0wSNf7qwAAAYgHvXKvAAAEAwBGMEQCIFLskZDs\\n\" +\n-            \"UG4+\/88D\/5\/QbD9zT6ZmZlwXiPZ6H2YR\/KiJAiBvi4vvNsb9KNAhJMgI2T2iCg9U\\n\" +\n-            \"CIru+US6y3ua7dKKDTAKBggqhkjOPQQDAgNHADBEAiAzvgzKV\/kvBbKWCT1NNUBD\\n\" +\n-            \"AF9okIEcJx\/ukFgzmYMwUQIgXeJeVf3izkxsgiEUSknwHsErLFs\/cEme2PSRj2AW\\n\" +\n-            \"dYA=\\n\" +\n+            \"MIIDhzCCAy2gAwIBAgITBwPk6bvCYF83lnoOlfMfR4mmdzAKBggqhkjOPQQDAjBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgM0ExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTA3MjkyMzU0NDNaFw0yMDA4Mjky\\n\" +\n+            \"MzU0NDNaMIHaMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQIT\\n\" +\n+            \"CERlbGF3YXJlMR0wGwYDVQQPExRQcml2YXRlIE9yZ2FuaXphdGlvbjEQMA4GA1UE\\n\" +\n+            \"BRMHNTg0Njc0MzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAO\\n\" +\n+            \"BgNVBAcTB1NlYXR0bGUxHjAcBgNVBAoTFUFtYXpvbiBUcnVzdCBTZXJ2aWNlczEj\\n\" +\n+            \"MCEGA1UEAxMaZ29vZC5zY2EzYS5hbWF6b250cnVzdC5jb20wWTATBgcqhkjOPQIB\\n\" +\n+            \"BggqhkjOPQMBBwNCAARl4yxf8XcvWR0LZ+YuBC0CpkwtU2NiMdlIM7eX0lxhQp53\\n\" +\n+            \"NpLlCrPRNzOWrjCJDdn21D0u7PrtN94UHLHOg9X0o4IBYzCCAV8wDgYDVR0PAQH\/\\n\" +\n+            \"BAQDAgeAMB0GA1UdDgQWBBT2cHmOJFLWfg1Op7xAdAnqYcwaPzAfBgNVHSMEGDAW\\n\" +\n+            \"gBQE3OCV5ei5a5Sh74xbMR4TflWX2jAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYB\\n\" +\n+            \"BQUHAwIwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5z\\n\" +\n+            \"Y2EzYS5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuc2Nh\\n\" +\n+            \"M2EuYW1hem9udHJ1c3QuY29tL3NjYTNhLmNlcjAlBgNVHREEHjAcghpnb29kLnNj\\n\" +\n+            \"YTNhLmFtYXpvbnRydXN0LmNvbTBQBgNVHSAESTBHMA0GC2CGSAGG\/W4BBxgDMDYG\\n\" +\n+            \"BWeBDAEBMC0wKwYIKwYBBQUHAgEWH2h0dHBzOi8vd3d3LmFtYXpvbnRydXN0LmNv\\n\" +\n+            \"bS9jcHMwCgYIKoZIzj0EAwIDSAAwRQIgURdcqJVr4PWNIkmWcSKmzgZ1i94hQpGe\\n\" +\n+            \"mWbE9osk4m0CIQDhxIguihwvDa5RsBwdM0aRDgGKLNHigGqJoKqgH0d2qg==\\n\" +\n@@ -465,4 +403,6 @@\n-    \/\/ Owner: CN=revoked.rootca3.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 256 M01, O=Amazon, C=US\n-    \/\/ Serial number: c458bfaeedae16a5e61fe64773fc898\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca3a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=PrivateOrganization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 3A, O=Amazon, C=US\n+    \/\/ Serial number: 6f1d78cf0ca64ce7f551a6f2a0715cc0e8b50\n+    \/\/ Valid from: Mon Jan 28 15:40:01 PST 2019 until: Thu Apr 28 16:40:01 PDT 2022\n@@ -470,25 +410,18 @@\n-            \"MIIEhzCCBC2gAwIBAgIQDEWL+u7a4WpeYf5kdz\/ImDAKBggqhkjOPQQDAjA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMjU2IE0wMTAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n-            \"BgNVBAMTJHJldm9rZWQucm9vdGNhMy5kZW1vLmFtYXpvbnRydXN0LmNvbTBZMBMG\\n\" +\n-            \"ByqGSM49AgEGCCqGSM49AwEHA0IABAsSs5kW5TZlS0SDrMb9iUQAqEaKa12Fc6SN\\n\" +\n-            \"9UR6qtOFdW\/1UuziDq3Hl5dqsAYZJkbJSPCIsD2HTP\/EGTMKITCjggMbMIIDFzAf\\n\" +\n-            \"BgNVHSMEGDAWgBRPWfy8BhYov6LI2wj7zxMkumlCXDAdBgNVHQ4EFgQUeE55ET2e\\n\" +\n-            \"i8KbY7KHTxOuvCkRpTowTgYDVR0RBEcwRYIkcmV2b2tlZC5yb290Y2EzLmRlbW8u\\n\" +\n-            \"YW1hem9udHJ1c3QuY29tgh1yZXZva2VkLnNjYTNhLmFtYXpvbnRydXN0LmNvbTAO\\n\" +\n-            \"BgNVHQ8BAf8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMDsG\\n\" +\n-            \"A1UdHwQ0MDIwMKAuoCyGKmh0dHA6Ly9jcmwuZTJtMDEuYW1hem9udHJ1c3QuY29t\\n\" +\n-            \"L2UybTAxLmNybDATBgNVHSAEDDAKMAgGBmeBDAECATB1BggrBgEFBQcBAQRpMGcw\\n\" +\n-            \"LQYIKwYBBQUHMAGGIWh0dHA6Ly9vY3NwLmUybTAxLmFtYXpvbnRydXN0LmNvbTA2\\n\" +\n-            \"BggrBgEFBQcwAoYqaHR0cDovL2NydC5lMm0wMS5hbWF6b250cnVzdC5jb20vZTJt\\n\" +\n-            \"MDEuY2VyMAwGA1UdEwEB\/wQCMAAwggF9BgorBgEEAdZ5AgQCBIIBbQSCAWkBZwB2\\n\" +\n-            \"AHb\/iD8KtvuVUcJhzPWHujS0pM27KdxoQgqf5mdMWjp0AAABiAe9lQ8AAAQDAEcw\\n\" +\n-            \"RQIgZVFAX5WPZRBpEOqk620v4Rbzxh\/3wrJ5QBMBJ0Mb8B0CIQC0oxFVLfs+PAv7\\n\" +\n-            \"25wawOu2VgDXG9lJAJtCwk3gN8BshQB2AEiw42vapkc0D+VqAvqdMOscUgHLVt0s\\n\" +\n-            \"gdm7v6s52IRzAAABiAe9lQ4AAAQDAEcwRQIhAIPVMj6IfjAUKeGYbpG9s0DRdWbc\\n\" +\n-            \"b8OzsOf+kRqk03NMAiB777hfoFCUMPrN0g8o5v6zp3T3qOhRnYY0TZN4q4NnMgB1\\n\" +\n-            \"ANq2v2s\/tbYin5vCu1xr6HCRcWy7UYSFNL2kPTBI1\/urAAABiAe9lN4AAAQDAEYw\\n\" +\n-            \"RAIgL0qoVbKLFD+Y3f\/V6Rw+euZrPO6d1HEVPQGo7wLzkl8CIGHp3PQmmrEofl76\\n\" +\n-            \"4da7bY0L+csFW0sB8clN0KziMfe6MAoGCCqGSM49BAMCA0gAMEUCIQC+6VdX9X5g\\n\" +\n-            \"x3NSUmJ7py01Zxf26TNBv1ildxqesvZ\/7wIgIrefriRzPiIFDHCUbdjk0VlmMwZR\\n\" +\n-            \"VzXXHINsGCiCKOs=\\n\" +\n+            \"MIIDTzCCAvWgAwIBAgITBvHXjPDKZM5\/VRpvKgcVzA6LUDAKBggqhkjOPQQDAjBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgM0ExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTAxMjgyMzQwMDFaFw0yMjA0Mjgy\\n\" +\n+            \"MzQwMDFaMIHcMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQIT\\n\" +\n+            \"CERlbGF3YXJlMRwwGgYDVQQPExNQcml2YXRlT3JnYW5pemF0aW9uMRAwDgYDVQQF\\n\" +\n+            \"Ewc1ODQ2NzQzMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4G\\n\" +\n+            \"A1UEBxMHU2VhdHRsZTEeMBwGA1UEChMVQW1hem9uIFRydXN0IFNlcnZpY2VzMSYw\\n\" +\n+            \"JAYDVQQDEx1yZXZva2VkLnNjYTNhLmFtYXpvbnRydXN0LmNvbTBZMBMGByqGSM49\\n\" +\n+            \"AgEGCCqGSM49AwEHA0IABJNl90Jq0wddpFj+JbLtmvGR\/1geL5t1tvV406jGpYn2\\n\" +\n+            \"C5lAFjwASFy7pAnazZbfSkIDUU2i2XU0+7Cs+j1S\/EOjggEpMIIBJTAOBgNVHQ8B\\n\" +\n+            \"Af8EBAMCB4AwHQYDVR0OBBYEFPhX3dYays5Sps0xTgouLkZzYLg4MB8GA1UdIwQY\\n\" +\n+            \"MBaAFATc4JXl6LlrlKHvjFsxHhN+VZfaMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggr\\n\" +\n+            \"BgEFBQcDAjB1BggrBgEFBQcBAQRpMGcwLQYIKwYBBQUHMAGGIWh0dHA6Ly9vY3Nw\\n\" +\n+            \"LnNjYTNhLmFtYXpvbnRydXN0LmNvbTA2BggrBgEFBQcwAoYqaHR0cDovL2NydC5z\\n\" +\n+            \"Y2EzYS5hbWF6b250cnVzdC5jb20vc2NhM2EuY2VyMCgGA1UdEQQhMB+CHXJldm9r\\n\" +\n+            \"ZWQuc2NhM2EuYW1hem9udHJ1c3QuY29tMBMGA1UdIAQMMAowCAYGZ4EMAQIBMAoG\\n\" +\n+            \"CCqGSM49BAMCA0gAMEUCICLb16\/50S4fOAFafi5lagdx7q6EDPPm596g19eQDMXk\\n\" +\n+            \"AiEAksCMLypRB4t30FABlsEjhVCBIxay0iIer2OcCIrhfEI=\\n\" +\n@@ -497,1 +430,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -500,1 +440,1 @@\n-        pathValidator.validate(new String[]{VALID, INT_VALID},\n+        pathValidator.validate(new String[]{VALID, INT},\n@@ -504,1 +444,1 @@\n-        pathValidator.validate(new String[]{REVOKED, INT_REVOKED},\n+        pathValidator.validate(new String[]{REVOKED, INT},\n@@ -506,1 +446,1 @@\n-                \"Mon May 15 13:41:22 PDT 2023\", System.out);\n+                \"Mon Jan 28 15:40:35 PST 2019\", System.out);\n@@ -512,1 +452,1 @@\n-    \/\/ Owner: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n+    \/\/ Owner: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n@@ -514,2 +454,2 @@\n-    \/\/ Serial number: 773127dfaa6b9e2b95538aa76dde4307f17c4\n-    \/\/ Valid from: Tue Aug 23 15:36:58 PDT 2022 until: Fri Aug 23 15:36:58 PDT 2030\n+    \/\/ Serial number: 67f94575a8862a9072e3239c37ceba1274e18\n+    \/\/ Valid from: Wed Oct 21 17:00:00 PDT 2015 until: Sat Oct 18 17:00:00 PDT 2025\n@@ -517,1 +457,1 @@\n-            \"MIIDETCCApagAwIBAgITB3MSffqmueK5VTiqdt3kMH8XxDAKBggqhkjOPQQDAzA5\\n\" +\n+            \"MIIC+TCCAn6gAwIBAgITBn+UV1qIYqkHLjI5w3zroSdOGDAKBggqhkjOPQQDAzA5\\n\" +\n@@ -519,15 +459,14 @@\n-            \"Um9vdCBDQSA0MB4XDTIyMDgyMzIyMzY1OFoXDTMwMDgyMzIyMzY1OFowPTELMAkG\\n\" +\n-            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEdMBsGA1UEAxMUQW1hem9uIEVDRFNB\\n\" +\n-            \"IDM4NCBNMDIwdjAQBgcqhkjOPQIBBgUrgQQAIgNiAATNYzWQDXV0NoNmR0hJPwJq\\n\" +\n-            \"hjYOOS9z0B2Z7MQudxg5x3Vsib6N+tJkq8dljRq5o6K0bbh\/kRVfoi9wfKhB03Yz\\n\" +\n-            \"gkerrwRCH7Z9gU5nbBY+Y5+EtImq4yOB0n7JQgQxWemjggFaMIIBVjASBgNVHRMB\\n\" +\n-            \"Af8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcD\\n\" +\n-            \"AQYIKwYBBQUHAwIwHQYDVR0OBBYEFKbZqzuHmTP\/6Gj4i2GDbNCyuq+9MB8GA1Ud\\n\" +\n-            \"IwQYMBaAFNPsxzplbszh2naaVvuc84ZtV+WBMHsGCCsGAQUFBwEBBG8wbTAvBggr\\n\" +\n-            \"BgEFBQcwAYYjaHR0cDovL29jc3Aucm9vdGNhNC5hbWF6b250cnVzdC5jb20wOgYI\\n\" +\n-            \"KwYBBQUHMAKGLmh0dHA6Ly9jcnQucm9vdGNhNC5hbWF6b250cnVzdC5jb20vcm9v\\n\" +\n-            \"dGNhNC5jZXIwPwYDVR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC5yb290Y2E0LmFt\\n\" +\n-            \"YXpvbnRydXN0LmNvbS9yb290Y2E0LmNybDATBgNVHSAEDDAKMAgGBmeBDAECATAK\\n\" +\n-            \"BggqhkjOPQQDAwNpADBmAjEA2zCG6x0xMlgSXWEGLN8+1XN+OCYF5vj0Z1jtVy+A\\n\" +\n-            \"pdLlzuxNt9HBWn3hvqvO2W8KAjEApNdsZOCmk5uZBYiuCSBnDH3jyKhN6dWyuuHW\\n\" +\n-            \"9Wj7SxKnOU5+wYWZA0BQAv1KT62i\\n\" +\n+            \"Um9vdCBDQSA0MB4XDTE1MTAyMjAwMDAwMFoXDTI1MTAxOTAwMDAwMFowRjELMAkG\\n\" +\n+            \"A1UEBhMCVVMxDzANBgNVBAoTBkFtYXpvbjEVMBMGA1UECxMMU2VydmVyIENBIDRB\\n\" +\n+            \"MQ8wDQYDVQQDEwZBbWF6b24wdjAQBgcqhkjOPQIBBgUrgQQAIgNiAASRP0kIW0Ha\\n\" +\n+            \"7+ORvEVhIS5gIgkH66X5W9vBRTX14oG\/1elIyI6LbFZ+E5KAufL0XoWJGI1WbPRm\\n\" +\n+            \"HW246FKSzF0wOEZZyxEROz6tuaVsnXRHRE76roS\/Wr064uJpKH+Lv+SjggE5MIIB\\n\" +\n+            \"NTASBgNVHRMBAf8ECDAGAQH\/AgEAMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHQ4EFgQU\\n\" +\n+            \"pSHN2+tTIZmqytlnQpQlsnv0wuMwHwYDVR0jBBgwFoAU0+zHOmVuzOHadppW+5zz\\n\" +\n+            \"hm1X5YEwewYIKwYBBQUHAQEEbzBtMC8GCCsGAQUFBzABhiNodHRwOi8vb2NzcC5y\\n\" +\n+            \"b290Y2E0LmFtYXpvbnRydXN0LmNvbTA6BggrBgEFBQcwAoYuaHR0cDovL2NydC5y\\n\" +\n+            \"b290Y2E0LmFtYXpvbnRydXN0LmNvbS9yb290Y2E0LmNlcjA\/BgNVHR8EODA2MDSg\\n\" +\n+            \"MqAwhi5odHRwOi8vY3JsLnJvb3RjYTQuYW1hem9udHJ1c3QuY29tL3Jvb3RjYTQu\\n\" +\n+            \"Y3JsMBEGA1UdIAQKMAgwBgYEVR0gADAKBggqhkjOPQQDAwNpADBmAjEA59RAOBaj\\n\" +\n+            \"uh0rT\/OOTWPEv6TBnb9XEadburBaXb8SSrR8il+NdkfS9WXRAzbwrG7LAjEA3ukD\\n\" +\n+            \"1HrQq+WXHBM5sIuViJI\/Zh7MOjsc159Q+dn36PBqLRq03AXqE\/lRjnv8C5nj\\n\" +\n@@ -536,4 +475,6 @@\n-    \/\/ Owner: CN=valid.rootca4.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n-    \/\/ Serial number: f579bed3369f1a147ea5d0e8e6532d3\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=good.sca4a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=Private Organization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n+    \/\/ Serial number: 703e4ec57c72d5669efbc98875c3f6bc3f934\n+    \/\/ Valid from: Mon Jul 29 16:55:17 PDT 2019 until: Sat Aug 29 16:55:17 PDT 2020\n@@ -541,26 +482,21 @@\n-            \"MIIEvjCCBESgAwIBAgIQD1eb7TNp8aFH6l0OjmUy0zAKBggqhkjOPQQDAzA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC0xKzAp\\n\" +\n-            \"BgNVBAMTInZhbGlkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb20wdjAQBgcq\\n\" +\n-            \"hkjOPQIBBgUrgQQAIgNiAAT6\/95JFuvx5t9MVeRZmBtXq63Q2fXZnSwEy2U2F4Qc\\n\" +\n-            \"ejhDwcYfD2HmT6S6GrKqLNJMa5n2YOvet4LZpKJLFF+BQo6FJt5cXkzHHxZ1I4z3\\n\" +\n-            \"8pGU79CpCgFOFy6QUlF68NajggMXMIIDEzAfBgNVHSMEGDAWgBSm2as7h5kz\/+ho\\n\" +\n-            \"+Ithg2zQsrqvvTAdBgNVHQ4EFgQUR\/GnpQkrUsCj8jF6\/JIE1Rs07zswSQYDVR0R\\n\" +\n-            \"BEIwQIIidmFsaWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbYIaZ29vZC5z\\n\" +\n-            \"Y2E0YS5hbWF6b250cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgeAMB0GA1UdJQQWMBQG\\n\" +\n-            \"CCsGAQUFBwMBBggrBgEFBQcDAjA7BgNVHR8ENDAyMDCgLqAshipodHRwOi8vY3Js\\n\" +\n-            \"LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jcmwwEwYDVR0gBAwwCjAIBgZn\\n\" +\n-            \"gQwBAgEwdQYIKwYBBQUHAQEEaTBnMC0GCCsGAQUFBzABhiFodHRwOi8vb2NzcC5l\\n\" +\n-            \"M20wMi5hbWF6b250cnVzdC5jb20wNgYIKwYBBQUHMAKGKmh0dHA6Ly9jcnQuZTNt\\n\" +\n-            \"MDIuYW1hem9udHJ1c3QuY29tL2UzbTAyLmNlcjAMBgNVHRMBAf8EAjAAMIIBfgYK\\n\" +\n-            \"KwYBBAHWeQIEAgSCAW4EggFqAWgAdgDuzdBk1dsazsVct520zROiModGfLzs3sNR\\n\" +\n-            \"SFlGcR+1mwAAAYgHvZA9AAAEAwBHMEUCIQCmzmQOzunsuAg1GpIcNx0isG6ylbhP\\n\" +\n-            \"y9JP4UFclL2hdwIgBtTM89mE7QJDj7h7xr2eRPio1ehgmeYH1PHXxCqHIGYAdgBI\\n\" +\n-            \"sONr2qZHNA\/lagL6nTDrHFIBy1bdLIHZu7+rOdiEcwAAAYgHvZB1AAAEAwBHMEUC\\n\" +\n-            \"IF9hbi82CLU5umfRze4NpX6u4jlT+N8KSaBe6UbhqjBZAiEAi2Y6PTt2+107LxtM\\n\" +\n-            \"oBpHprph7hQvGfjPE+p+rfM\/X+EAdgDatr9rP7W2Ip+bwrtca+hwkXFsu1GEhTS9\\n\" +\n-            \"pD0wSNf7qwAAAYgHvZBeAAAEAwBHMEUCIAI+m4mVE3HtZOEMC5VI7m0nEPdPPJUq\\n\" +\n-            \"fxUKPpeIVmk5AiEA0scVJy7g3Fv+2nTVhbcwWCwn\/Gvc+0txQrc529juflcwCgYI\\n\" +\n-            \"KoZIzj0EAwMDaAAwZQIxAKV837BpqlNHg35EsCCtrJPoQ6RuY9UoHm1O2CdsCXGR\\n\" +\n-            \"Z3kAnlgIV8A\/waI6wQqfsQIwdCqaC+qN60JCnX09YKRD15eQjq1rN3w+llI+lEbS\\n\" +\n-            \"FSMsnoHJcqMZLo9s+4Rf0zS3\\n\" +\n+            \"MIIDxTCCA0qgAwIBAgITBwPk7FfHLVZp77yYh1w\/a8P5NDAKBggqhkjOPQQDAzBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgNEExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTA3MjkyMzU1MTdaFw0yMDA4Mjky\\n\" +\n+            \"MzU1MTdaMIHaMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQIT\\n\" +\n+            \"CERlbGF3YXJlMR0wGwYDVQQPExRQcml2YXRlIE9yZ2FuaXphdGlvbjEQMA4GA1UE\\n\" +\n+            \"BRMHNTg0Njc0MzELMAkGA1UEBhMCVVMxEzARBgNVBAgTCldhc2hpbmd0b24xEDAO\\n\" +\n+            \"BgNVBAcTB1NlYXR0bGUxHjAcBgNVBAoTFUFtYXpvbiBUcnVzdCBTZXJ2aWNlczEj\\n\" +\n+            \"MCEGA1UEAxMaZ29vZC5zY2E0YS5hbWF6b250cnVzdC5jb20wdjAQBgcqhkjOPQIB\\n\" +\n+            \"BgUrgQQAIgNiAAS9fqMYfOBsdXMSsPjqOlTgIGOlOQWA7Wg6XwVvHTr0+UN+XTeC\\n\" +\n+            \"yZN+XjLbEDQ0CF5eryRZ535sDpwh3qNe0lYFO1n1+2iDtDI1jhhLNYNxBpVnR2BU\\n\" +\n+            \"2l9EuRmgRbQpDCajggFjMIIBXzAOBgNVHQ8BAf8EBAMCB4AwHQYDVR0OBBYEFMd0\\n\" +\n+            \"itH5IcE6DpM1uTSBV\/6DLmK7MB8GA1UdIwQYMBaAFKUhzdvrUyGZqsrZZ0KUJbJ7\\n\" +\n+            \"9MLjMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjB1BggrBgEFBQcBAQRp\\n\" +\n+            \"MGcwLQYIKwYBBQUHMAGGIWh0dHA6Ly9vY3NwLnNjYTRhLmFtYXpvbnRydXN0LmNv\\n\" +\n+            \"bTA2BggrBgEFBQcwAoYqaHR0cDovL2NydC5zY2E0YS5hbWF6b250cnVzdC5jb20v\\n\" +\n+            \"c2NhNGEuY2VyMCUGA1UdEQQeMByCGmdvb2Quc2NhNGEuYW1hem9udHJ1c3QuY29t\\n\" +\n+            \"MFAGA1UdIARJMEcwDQYLYIZIAYb9bgEHGAMwNgYFZ4EMAQEwLTArBggrBgEFBQcC\\n\" +\n+            \"ARYfaHR0cHM6Ly93d3cuYW1hem9udHJ1c3QuY29tL2NwczAKBggqhkjOPQQDAwNp\\n\" +\n+            \"ADBmAjEA2RBD1F+rnm394VkqA3ncysM3deoyfWqaoAO5923MNisswPnHfVqnfeXf\\n\" +\n+            \"ZwTAvVTBAjEAiiaPx9GRjEk8IBKvCSbTp9rPogVTN7zDDQGrwA83O0pRP7A0dxtT\\n\" +\n+            \"pn\/0K5Sj8otp\\n\" +\n@@ -569,4 +505,6 @@\n-    \/\/ Owner: CN=revoked.rootca4.demo.amazontrust.com\n-    \/\/ Issuer: CN=Amazon ECDSA 384 M02, O=Amazon, C=US\n-    \/\/ Serial number: 4a5d392936b4decb818b7fb106ebbd8\n-    \/\/ Valid from: Tue May 09 17:00:00 PDT 2023 until: Fri Jun 07 16:59:59 PDT 2024\n+    \/\/ Owner: CN=revoked.sca4a.amazontrust.com, O=Amazon Trust Services, L=Seattle, ST=Washington, C=US, \\\n+    \/\/ SERIALNUMBER=5846743, OID.2.5.4.15=PrivateOrganization, OID.1.3.6.1.4.1.311.60.2.1.2=Delaware, \\\n+    \/\/ OID.1.3.6.1.4.1.311.60.2.1.3=US\n+    \/\/ Issuer: CN=Amazon, OU=Server CA 4A, O=Amazon, C=US\n+    \/\/ Serial number: 6f1d79295c384a699d51c2d756bd46213b5b3\n+    \/\/ Valid from: Mon Jan 28 15:41:16 PST 2019 until: Thu Apr 28 16:41:16 PDT 2022\n@@ -574,26 +512,20 @@\n-            \"MIIExjCCBEygAwIBAgIQBKXTkpNrTey4GLf7EG672DAKBggqhkjOPQQDAzA9MQsw\\n\" +\n-            \"CQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMR0wGwYDVQQDExRBbWF6b24gRUNE\\n\" +\n-            \"U0EgMzg0IE0wMjAeFw0yMzA1MTAwMDAwMDBaFw0yNDA2MDcyMzU5NTlaMC8xLTAr\\n\" +\n-            \"BgNVBAMTJHJldm9rZWQucm9vdGNhNC5kZW1vLmFtYXpvbnRydXN0LmNvbTB2MBAG\\n\" +\n-            \"ByqGSM49AgEGBSuBBAAiA2IABFYfMbv5\/vgqDunZj4ffJiuELtdwfEPXx9QlZnCm\\n\" +\n-            \"rBP3Z4\/GvUVRVmyh5sYdnbCGCEClH\/RxU6BC5SKv+TzhsFLEumhezanljnQXRAIL\\n\" +\n-            \"a1OGbP8zLLP6FuAD0cjY3P3adKOCAx0wggMZMB8GA1UdIwQYMBaAFKbZqzuHmTP\/\\n\" +\n-            \"6Gj4i2GDbNCyuq+9MB0GA1UdDgQWBBSqnGV5pN\/agPCtVdV37CP1z\/DUqjBOBgNV\\n\" +\n-            \"HREERzBFgiRyZXZva2VkLnJvb3RjYTQuZGVtby5hbWF6b250cnVzdC5jb22CHXJl\\n\" +\n-            \"dm9rZWQuc2NhNGEuYW1hem9udHJ1c3QuY29tMA4GA1UdDwEB\/wQEAwIHgDAdBgNV\\n\" +\n-            \"HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwOwYDVR0fBDQwMjAwoC6gLIYqaHR0\\n\" +\n-            \"cDovL2NybC5lM20wMi5hbWF6b250cnVzdC5jb20vZTNtMDIuY3JsMBMGA1UdIAQM\\n\" +\n-            \"MAowCAYGZ4EMAQIBMHUGCCsGAQUFBwEBBGkwZzAtBggrBgEFBQcwAYYhaHR0cDov\\n\" +\n-            \"L29jc3AuZTNtMDIuYW1hem9udHJ1c3QuY29tMDYGCCsGAQUFBzAChipodHRwOi8v\\n\" +\n-            \"Y3J0LmUzbTAyLmFtYXpvbnRydXN0LmNvbS9lM20wMi5jZXIwDAYDVR0TAQH\/BAIw\\n\" +\n-            \"ADCCAX8GCisGAQQB1nkCBAIEggFvBIIBawFpAHYAdv+IPwq2+5VRwmHM9Ye6NLSk\\n\" +\n-            \"zbsp3GhCCp\/mZ0xaOnQAAAGIB72QJQAABAMARzBFAiA74zKrlL+y5rYwSLxBL8fs\\n\" +\n-            \"QYRYXF0s0sGoaSEeAg1DkgIhAPu8Z0TLIFoppmyiv+A5z6S+SG+v\/kOsAYmQmiUO\\n\" +\n-            \"5scIAHcASLDja9qmRzQP5WoC+p0w6xxSActW3SyB2bu\/qznYhHMAAAGIB72QJgAA\\n\" +\n-            \"BAMASDBGAiEAg+x7JBT3oIaZdnfgGN1G6SAiNUL7zR\/tBhbWIG9tz94CIQDGwBiV\\n\" +\n-            \"Tslt11+W3ZaNsS7UtUIiB45YHUc4qKm5ry2fTAB2ANq2v2s\/tbYin5vCu1xr6HCR\\n\" +\n-            \"cWy7UYSFNL2kPTBI1\/urAAABiAe9kAgAAAQDAEcwRQIgPvKfSpMJKRocGk9+GNr3\\n\" +\n-            \"hUj8x8WySB\/\/0X116TNgA0gCIQDhGRqxnEZmEFGEfj5GY9vjEfm0kKwcL0lCuwBu\\n\" +\n-            \"NZG4dzAKBggqhkjOPQQDAwNoADBlAjEA1PLdsrko3tDs50aAeEU9Gn+0CG8QKy7R\\n\" +\n-            \"fQaXBTjGETDgGJk\/7zGNpGelKPr\/UYV9AjASwdA32S8jIADxA8HrqiMsVYDFMnbU\\n\" +\n-            \"jLLwR6CTLtAcWtwVmoQ2x0usvTvN8YJBPoA=\\n\" +\n+            \"MIIDjTCCAxKgAwIBAgITBvHXkpXDhKaZ1RwtdWvUYhO1szAKBggqhkjOPQQDAzBG\\n\" +\n+            \"MQswCQYDVQQGEwJVUzEPMA0GA1UEChMGQW1hem9uMRUwEwYDVQQLEwxTZXJ2ZXIg\\n\" +\n+            \"Q0EgNEExDzANBgNVBAMTBkFtYXpvbjAeFw0xOTAxMjgyMzQxMTZaFw0yMjA0Mjgy\\n\" +\n+            \"MzQxMTZaMIHcMRMwEQYLKwYBBAGCNzwCAQMTAlVTMRkwFwYLKwYBBAGCNzwCAQIT\\n\" +\n+            \"CERlbGF3YXJlMRwwGgYDVQQPExNQcml2YXRlT3JnYW5pemF0aW9uMRAwDgYDVQQF\\n\" +\n+            \"Ewc1ODQ2NzQzMQswCQYDVQQGEwJVUzETMBEGA1UECBMKV2FzaGluZ3RvbjEQMA4G\\n\" +\n+            \"A1UEBxMHU2VhdHRsZTEeMBwGA1UEChMVQW1hem9uIFRydXN0IFNlcnZpY2VzMSYw\\n\" +\n+            \"JAYDVQQDEx1yZXZva2VkLnNjYTRhLmFtYXpvbnRydXN0LmNvbTB2MBAGByqGSM49\\n\" +\n+            \"AgEGBSuBBAAiA2IABLuNpZTcNU3FElNP3Y\/OeXIZcIMXkFTBi\/n92fNwHfqUbEhH\\n\" +\n+            \"H+PovJ26eAGvb5a8bGc275MBFcVnWL0rCVgM+j9KAtBDCRJX3f7mo0D2VKcmtZKu\\n\" +\n+            \"jPxwGPy2kuqM505dGqOCASkwggElMA4GA1UdDwEB\/wQEAwIHgDAdBgNVHQ4EFgQU\\n\" +\n+            \"zUFIhn+hphzCKA2qgAdLztSBzJgwHwYDVR0jBBgwFoAUpSHN2+tTIZmqytlnQpQl\\n\" +\n+            \"snv0wuMwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMHUGCCsGAQUFBwEB\\n\" +\n+            \"BGkwZzAtBggrBgEFBQcwAYYhaHR0cDovL29jc3Auc2NhNGEuYW1hem9udHJ1c3Qu\\n\" +\n+            \"Y29tMDYGCCsGAQUFBzAChipodHRwOi8vY3J0LnNjYTRhLmFtYXpvbnRydXN0LmNv\\n\" +\n+            \"bS9zY2E0YS5jZXIwKAYDVR0RBCEwH4IdcmV2b2tlZC5zY2E0YS5hbWF6b250cnVz\\n\" +\n+            \"dC5jb20wEwYDVR0gBAwwCjAIBgZngQwBAgEwCgYIKoZIzj0EAwMDaQAwZgIxALDA\\n\" +\n+            \"klY3iKwyzwpwVtLfLxzQEl45xvE2VjBJvfJJ60KhJt7Ud0gt0zxkogh29+mpEQIx\\n\" +\n+            \"ANTG1mk8OJB41DU7ru1Pwc6ju8STw1FdwDp\/Eliqhvnm2i0k4\/F1bBHLta2mlC2V\\n\" +\n+            \"hg==\\n\" +\n@@ -602,1 +534,8 @@\n-    public void runTest(ValidatePathWithParams pathValidator) throws Exception {\n+    public void runTest(ValidatePathWithParams pathValidator, boolean ocspEnabled) throws Exception {\n+        \/\/ EE certificates don't have CRLDP extension\n+        if (!ocspEnabled){\n+            pathValidator.validate(new String[]{INT},\n+                    ValidatePathWithParams.Status.GOOD, null, System.out);\n+\n+            return;\n+        }\n@@ -611,1 +550,1 @@\n-                \"Mon May 15 13:42:48 PDT 2023\", System.out);\n+                \"Mon Jan 28 15:41:53 PST 2019\", System.out);\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/AmazonCA.java","additions":400,"deletions":461,"binary":false,"changes":861,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.*;\n+import java.util.*;\n+import java.io.IOException;\n+\n+\/**\n+ * This class provides a partial implementation of the HttpCallback\n+ * interface. Use this class if you want to use the requestURI as a means\n+ * of tracking multiple invocations of a request (on the server).\n+ * In this case, you implement the modified request() method, which includes\n+ * an integer count parameter. This parameter indicates the number of times\n+ * (starting at zero) the request URI has been received.\n+ *\/\n+\n+public abstract class AbstractCallback implements HttpCallback {\n+\n+    Map requests;\n+\n+    static class Request {\n+        URI uri;\n+        int count;\n+\n+        Request (URI u) {\n+            uri = u;\n+            count = 0;\n+        }\n+    }\n+\n+    AbstractCallback () {\n+        requests = Collections.synchronizedMap (new HashMap());\n+    }\n+\n+    \/**\n+     * handle the given request and generate an appropriate response.\n+     * @param msg the transaction containing the request from the\n+     *        client and used to send the response\n+     *\/\n+    public void request (HttpTransaction msg) {\n+        URI uri = msg.getRequestURI();\n+        Request req = (Request) requests.get (uri);\n+        if (req == null) {\n+            req = new Request (uri);\n+            requests.put (uri, req);\n+        }\n+        request (msg, req.count++);\n+    }\n+\n+    \/**\n+     * Same as HttpCallback interface except that the integer n\n+     * is provided to indicate sequencing of repeated requests using\n+     * the same request URI. n starts at zero and is incremented\n+     * for each successive call.\n+     *\n+     * @param msg the transaction containing the request from the\n+     *        client and used to send the response\n+     * @param n value is 0 at first call, and is incremented by 1 for\n+     *        each subsequent call using the same request URI.\n+     *\/\n+    abstract public void request (HttpTransaction msg, int n);\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/AbstractCallback.java","additions":82,"deletions":0,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2012, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- * @library \/test\/lib\n+ * @modules java.base\/sun.net.www\n+ * @build TestHttpsServer HttpCallback\n@@ -35,14 +36,3 @@\n-import java.io.FileInputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.net.HttpRetryException;\n-import java.net.HttpURLConnection;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.Proxy;\n-import java.net.SocketException;\n-import java.net.URL;\n-import java.nio.charset.Charset;\n-import java.security.KeyStore;\n-import java.util.concurrent.Executors;\n+import java.io.*;\n+import java.net.*;\n+import javax.net.ssl.*;\n@@ -51,13 +41,1 @@\n-import javax.net.ssl.HostnameVerifier;\n-import javax.net.ssl.HttpsURLConnection;\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.TrustManagerFactory;\n-\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n-\n-public class ChunkedOutputStream implements HttpHandler {\n+public class ChunkedOutputStream implements HttpCallback {\n@@ -81,28 +59,20 @@\n-    private static String getAuthority() {\n-        InetAddress address = server.getAddress().getAddress();\n-        String hostaddr = address.getHostAddress();\n-        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n-        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n-        return hostaddr + \":\" + server.getAddress().getPort();\n-    }\n-\n-    public void handle(HttpExchange req) throws IOException {\n-        \/\/ this is needed (count++ doesn't work), 'cause we\n-        \/\/ are doing concurrent tests\n-        System.out.println(\"Request Received\");\n-        String path = req.getRequestURI().getPath();\n-        if (path.equals(\"\/d0\")) {\n-            count = 0;\n-        } else if (path.equals(\"\/d01\")) {\n-            count = 1;\n-        } else if (path.equals(\"\/d3\")) {\n-            count = 2;\n-        } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n-            count = 3;\n-        } else if (path.equals(\"\/d6\")) {\n-            count = 3;\n-        }  else if (path.equals(\"\/d7\")) {\n-            count = 4;\n-        }  else if (path.equals(\"\/d8\")) {\n-            count = 5;\n-        }\n+    public void request (HttpTransaction req) {\n+        try {\n+            \/\/ this is needed (count++ doesn't work), 'cause we\n+            \/\/ are doing concurrent tests\n+            String path = req.getRequestURI().getPath();\n+            if (path.equals(\"\/d0\")) {\n+                count = 0;\n+            } else if (path.equals(\"\/d01\")) {\n+                count = 1;\n+            } else if (path.equals(\"\/d3\")) {\n+                count = 2;\n+            } else if (path.equals(\"\/d4\") || path.equals(\"\/d5\")) {\n+                count = 3;\n+            } else if (path.equals(\"\/d6\")) {\n+                count = 3;\n+            }  else if (path.equals(\"\/d7\")) {\n+                count = 4;\n+            }  else if (path.equals(\"\/d8\")) {\n+                count = 5;\n+            }\n@@ -110,1 +80,1 @@\n-        switch (count) {\n+            switch (count) {\n@@ -113,5 +83,1 @@\n-\n-                String reqbody = \"\";\n-                try(InputStream inputStream = req.getRequestBody()) {\n-                    reqbody = new String(inputStream.readAllBytes(), Charset.forName(\"ISO8859_1\"));\n-                }\n+                String reqbody = req.getRequestEntityBody();\n@@ -119,2 +85,2 @@\n-                    req.sendResponseHeaders(500, -1);\n-                    break;\n+                    req.sendResponse (500, \"Internal server error\");\n+                    req.orderlyClose();\n@@ -122,4 +88,4 @@\n-                String chunk = req.getRequestHeaders().getFirst(\"Transfer-encoding\");\n-                if (!\"chunked\".equals(chunk)) {\n-                    req.sendResponseHeaders(501, -1);\n-                    break;\n+                String chunk = req.getRequestHeader (\"Transfer-encoding\");\n+                if (!\"chunked\".equals (chunk)) {\n+                    req.sendResponse (501, \"Internal server error\");\n+                    req.orderlyClose();\n@@ -127,0 +93,1 @@\n+                req.setResponseEntityBody (reqbody);\n@@ -128,1 +95,1 @@\n-                    req.getResponseHeaders().set(\"Connection\", \"close\");\n+                    req.setResponseHeader (\"Connection\", \"close\");\n@@ -130,3 +97,3 @@\n-                req.sendResponseHeaders(200, 0);\n-                try (OutputStream os = req.getResponseBody()) {\n-                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n+                req.sendResponse (200, \"OK\");\n+                if (count == 1) {\n+                    req.orderlyClose();\n@@ -136,1 +103,1 @@\n-                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n+                reqbody = req.getRequestEntityBody();\n@@ -138,2 +105,2 @@\n-                    req.sendResponseHeaders(500, -1);\n-                    break;\n+                    req.sendResponse (500, \"Internal server error\");\n+                    req.orderlyClose();\n@@ -141,1 +108,2 @@\n-                int clen = Integer.parseInt (req.getRequestHeaders().getFirst(\"Content-length\"));\n+                int clen = Integer.parseInt (\n+                        req.getRequestHeader (\"Content-length\"));\n@@ -143,7 +111,2 @@\n-                    req.sendResponseHeaders(501, -1);\n-                    break;\n-                }\n-                req.getResponseHeaders().set(\"Connection\", \"close\");\n-                req.sendResponseHeaders(200, 0);\n-                try (OutputStream os = req.getResponseBody()) {\n-                    os.write(reqbody.getBytes(Charset.forName(\"ISO8859_1\")));\n+                    req.sendResponse (501, \"Internal server error\");\n+                    req.orderlyClose();\n@@ -151,0 +114,4 @@\n+                req.setResponseEntityBody (reqbody);\n+                req.setResponseHeader (\"Connection\", \"close\");\n+                req.sendResponse (200, \"OK\");\n+                req.orderlyClose();\n@@ -153,6 +120,4 @@\n-                if (path.equals(\"\/d6\")) {\n-                    reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n-                }\n-                req.getResponseHeaders().set(\"Location\", \"https:\/\/foo.bar\/\");\n-                req.getResponseHeaders().set(\"Connection\", \"close\");\n-                req.sendResponseHeaders(307, -1);\n+                req.setResponseHeader (\"Location\", \"https:\/\/foo.bar\/\");\n+                req.setResponseHeader (\"Connection\", \"close\");\n+                req.sendResponse (307, \"Temporary Redirect\");\n+                req.orderlyClose();\n@@ -162,4 +127,4 @@\n-                reqbody = new String(req.getRequestBody().readAllBytes(), Charset.forName(\"ISO8859_1\"));\n-                if (reqbody != null && !\"\".equals(reqbody)) {\n-                    req.sendResponseHeaders(501, -1);\n-                    break;\n+                reqbody = req.getRequestEntityBody();\n+                if (reqbody != null && !\"\".equals (reqbody)) {\n+                    req.sendResponse (501, \"Internal server error\");\n+                    req.orderlyClose();\n@@ -167,2 +132,3 @@\n-                req.getResponseHeaders().set(\"Connection\", \"close\");\n-                req.sendResponseHeaders(200, -1);\n+                req.setResponseHeader (\"Connection\", \"close\");\n+                req.sendResponse (200, \"OK\");\n+                req.orderlyClose();\n@@ -171,1 +137,2 @@\n-                req.sendResponseHeaders(404, -1);\n+                req.sendResponse(404, \"Not Found\");\n+                req.orderlyClose();\n@@ -173,0 +140,3 @@\n+            }\n+        } catch (IOException e) {\n+            e.printStackTrace();\n@@ -174,1 +144,7 @@\n-        req.close();\n+    }\n+\n+    public boolean dropPlainTextConnections() {\n+        System.out.println(\"Unrecognized SSL message, plaintext connection?\");\n+        System.out.println(\"TestHttpsServer receveived rogue connection: ignoring it.\");\n+        rogueCount.incrementAndGet();\n+        return true;\n@@ -205,0 +181,3 @@\n+            \/\/ on the client side, and confirm that this::dropPlainTextConnections\n+            \/\/ has ben called.\n+            if (rogueCount.get() == rogue) throw x;\n@@ -219,1 +198,1 @@\n-        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n+        os.write (str1.getBytes());\n@@ -236,1 +215,1 @@\n-        os.write (str2.getBytes(Charset.forName(\"ISO8859_1\")));\n+        os.write (str2.getBytes());\n@@ -253,1 +232,1 @@\n-        os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n+        os.write (str2.getBytes());\n@@ -271,1 +250,1 @@\n-            os.write(str2.getBytes(Charset.forName(\"ISO8859_1\")));\n+            os.write (str2.getBytes());\n@@ -286,1 +265,1 @@\n-        os.write(str1.getBytes(Charset.forName(\"ISO8859_1\")));\n+        os.write (str1.getBytes());\n@@ -333,1 +312,1 @@\n-    static HttpsServer server;\n+    static TestHttpsServer server;\n@@ -336,1 +315,0 @@\n-        ChunkedOutputStream chunkedOutputStream = new ChunkedOutputStream();\n@@ -345,2 +323,0 @@\n-        InetAddress loopback = InetAddress.getLoopbackAddress();\n-\n@@ -357,26 +333,4 @@\n-                \/\/ create and initialize a SSLContext\n-                KeyStore ks = KeyStore.getInstance(\"JKS\");\n-                KeyStore ts = KeyStore.getInstance(\"JKS\");\n-                char[] passphrase = \"passphrase\".toCharArray();\n-\n-                ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n-                ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n-\n-                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-                kmf.init(ks, passphrase);\n-\n-                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-                tmf.init(ts);\n-\n-                SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-                sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-                server = HttpsServer.create(new InetSocketAddress(loopback, 0), 10);\n-                server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n-                server.createContext(\"\/\", chunkedOutputStream);\n-                server.setExecutor(Executors.newSingleThreadExecutor());\n-                server.start();\n-\n-                System.out.println(\"Server started: listening on: \" + getAuthority());\n-                testPlainText(getAuthority());\n+                server = new TestHttpsServer(\n+                        new ChunkedOutputStream(), 1, 10, 0);\n+                System.out.println (\"Server started: listening on port: \" + server.getLocalPort());\n+                testPlainText(server.getAuthority());\n@@ -385,7 +339,7 @@\n-                test1(\"https:\/\/\" + getAuthority() + \"\/d01\");\n-                test3(\"https:\/\/\" + getAuthority() + \"\/d3\");\n-                test4(\"https:\/\/\" + getAuthority() + \"\/d4\");\n-                test5(\"https:\/\/\" + getAuthority() + \"\/d5\");\n-                test6(\"https:\/\/\" + getAuthority() + \"\/d6\");\n-                test7(\"https:\/\/\" + getAuthority() + \"\/d7\");\n-                test8(\"https:\/\/\" + getAuthority() + \"\/d8\");\n+                test1(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d01\");\n+                test3(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d3\");\n+                test4(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d4\");\n+                test5(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d5\");\n+                test6(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d6\");\n+                test7(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d7\");\n+                test8(\"https:\/\/localhost:\"+server.getLocalPort()+\"\/d8\");\n@@ -394,1 +348,1 @@\n-                    server.stop(1);\n+                    server.terminate();\n@@ -398,1 +352,1 @@\n-            server.stop(1);\n+            server.terminate();\n@@ -411,1 +365,1 @@\n-        server.stop(1);\n+        server.terminate();\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/ChunkedOutputStream.java","additions":97,"deletions":143,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * This interface is implemented by classes that wish to handle incoming HTTP\n+ * requests and generate responses. This could be a general purpose HTTP server\n+ * or a test case that expects specific requests from a client.\n+ * <p>\n+ * The incoming request fields can be examined via the {@link HttpTransaction}\n+ * object, and a response can also be generated and sent via the request object.\n+ *\/\n+public interface HttpCallback {\n+    \/**\n+     * handle the given request and generate an appropriate response.\n+     * @param msg the transaction containing the request from the\n+     *        client and used to send the response\n+     *\/\n+    void request (HttpTransaction msg);\n+\n+    \/**\n+     * Tells whether the server should simply close the\n+     * connection and ignore the request when the first\n+     * byte received by the server looks like a plain\n+     * text connection.\n+     * @return true if the request should be ignored.\n+     **\/\n+    default boolean dropPlainTextConnections() {\n+        return false;\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpCallback.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -0,0 +1,330 @@\n+\/*\n+ * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import java.net.*;\n+import sun.net.www.MessageHeader;\n+\n+\/**\n+ * This class encapsulates a HTTP request received and a response to be\n+ * generated in one transaction. It provides methods for examaining the\n+ * request from the client, and for building and sending a reply.\n+ *\/\n+\n+public class HttpTransaction {\n+\n+    String command;\n+    URI requesturi;\n+    TestHttpsServer.ServerWorker server;\n+    MessageHeader reqheaders, reqtrailers;\n+    String reqbody;\n+    byte[] rspbody;\n+    MessageHeader rspheaders, rsptrailers;\n+    SocketChannel ch;\n+    int rspbodylen;\n+    boolean rspchunked;\n+\n+    HttpTransaction (TestHttpsServer.ServerWorker server, String command,\n+                        URI requesturi, MessageHeader headers,\n+                        String body, MessageHeader trailers, SocketChannel ch) {\n+        this.command = command;\n+        this.requesturi = requesturi;\n+        this.reqheaders = headers;\n+        this.reqbody = body;\n+        this.reqtrailers = trailers;\n+        this.ch = ch;\n+        this.server = server;\n+    }\n+\n+    \/**\n+     * Get the value of a request header whose name is specified by the\n+     * String argument.\n+     *\n+     * @param key the name of the request header\n+     * @return the value of the header or null if it does not exist\n+     *\/\n+    public String getRequestHeader (String key) {\n+        return reqheaders.findValue (key);\n+    }\n+\n+    \/**\n+     * Get the value of a response header whose name is specified by the\n+     * String argument.\n+     *\n+     * @param key the name of the response header\n+     * @return the value of the header or null if it does not exist\n+     *\/\n+    public String getResponseHeader (String key) {\n+        return rspheaders.findValue (key);\n+    }\n+\n+    \/**\n+     * Get the request URI\n+     *\n+     * @return the request URI\n+     *\/\n+    public URI getRequestURI () {\n+        return requesturi;\n+    }\n+\n+    public String toString () {\n+        StringBuffer buf = new StringBuffer();\n+        buf.append (\"Request from: \").append (ch.toString()).append(\"\\r\\n\");\n+        buf.append (\"Command: \").append (command).append(\"\\r\\n\");\n+        buf.append (\"Request URI: \").append (requesturi).append(\"\\r\\n\");\n+        buf.append (\"Headers: \").append(\"\\r\\n\");\n+        buf.append (reqheaders.toString()).append(\"\\r\\n\");\n+        buf.append (\"Body: \").append (reqbody).append(\"\\r\\n\");\n+        buf.append (\"---------Response-------\\r\\n\");\n+        buf.append (\"Headers: \").append(\"\\r\\n\");\n+        if (rspheaders != null) {\n+            buf.append (rspheaders.toString()).append(\"\\r\\n\");\n+        }\n+        String rbody = rspbody == null? \"\": new String (rspbody);\n+        buf.append (\"Body: \").append (rbody).append(\"\\r\\n\");\n+        return new String (buf);\n+    }\n+\n+    \/**\n+     * Get the value of a request trailer whose name is specified by\n+     * the String argument.\n+     *\n+     * @param key the name of the request trailer\n+     * @return the value of the trailer or null if it does not exist\n+     *\/\n+    public String getRequestTrailer (String key) {\n+        return reqtrailers.findValue (key);\n+    }\n+\n+    \/**\n+     * Add a response header to the response. Multiple calls with the same\n+     * key value result in multiple header lines with the same key identifier\n+     * @param key the name of the request header to add\n+     * @param val the value of the header\n+     *\/\n+    public void addResponseHeader (String key, String val) {\n+        if (rspheaders == null)\n+            rspheaders = new MessageHeader ();\n+        rspheaders.add (key, val);\n+    }\n+\n+    \/**\n+     * Set a response header. Searches for first header with named key\n+     * and replaces its value with val\n+     * @param key the name of the request header to add\n+     * @param val the value of the header\n+     *\/\n+    public void setResponseHeader (String key, String val) {\n+        if (rspheaders == null)\n+            rspheaders = new MessageHeader ();\n+        rspheaders.set (key, val);\n+    }\n+\n+    \/**\n+     * Add a response trailer to the response. Multiple calls with the same\n+     * key value result in multiple trailer lines with the same key identifier\n+     * @param key the name of the request trailer to add\n+     * @param val the value of the trailer\n+     *\/\n+    public void addResponseTrailer (String key, String val) {\n+        if (rsptrailers == null)\n+            rsptrailers = new MessageHeader ();\n+        rsptrailers.add (key, val);\n+    }\n+\n+    \/**\n+     * Get the request method\n+     *\n+     * @return the request method\n+     *\/\n+    public String getRequestMethod (){\n+        return command;\n+    }\n+\n+    \/**\n+     * Perform an orderly close of the TCP connection associated with this\n+     * request. This method guarantees that any response already sent will\n+     * not be reset (by this end). The implementation does a shutdownOutput()\n+     * of the TCP connection and for a period of time consumes and discards\n+     * data received on the reading side of the connection. This happens\n+     * in the background. After the period has expired the\n+     * connection is completely closed.\n+     *\/\n+\n+    public void orderlyClose () {\n+        try {\n+            server.orderlyCloseChannel (ch);\n+        } catch (IOException e) {\n+            System.out.println (e);\n+        }\n+    }\n+\n+    \/**\n+     * Do an immediate abortive close of the TCP connection associated\n+     * with this request.\n+     *\/\n+    public void abortiveClose () {\n+        try {\n+            server.abortiveCloseChannel(ch);\n+        } catch (IOException e) {\n+            System.out.println (e);\n+        }\n+    }\n+\n+    \/**\n+     * Get the SocketChannel associated with this request\n+     *\n+     * @return the socket channel\n+     *\/\n+    public SocketChannel channel() {\n+        return ch;\n+    }\n+\n+    \/**\n+     * Get the request entity body associated with this request\n+     * as a single String.\n+     *\n+     * @return the entity body in one String\n+     *\/\n+    public String getRequestEntityBody (){\n+        return reqbody;\n+    }\n+\n+    \/**\n+     * Set the entity response body with the given string\n+     * The content length is set to the length of the string\n+     * @param body the string to send in the response\n+     *\/\n+    public void setResponseEntityBody (String body){\n+        rspbody = body.getBytes();\n+        rspbodylen = body.length();\n+        rspchunked = false;\n+        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n+    }\n+    \/**\n+     * Set the entity response body with the given byte[]\n+     * The content length is set to the gven length\n+     * @param body the string to send in the response\n+     *\/\n+    public void setResponseEntityBody (byte[] body, int len){\n+        rspbody = body;\n+        rspbodylen = len;\n+        rspchunked = false;\n+        addResponseHeader (\"Content-length\", Integer.toString (rspbodylen));\n+    }\n+\n+\n+    \/**\n+     * Set the entity response body by reading the given inputstream\n+     *\n+     * @param is the inputstream from which to read the body\n+     *\/\n+    public void setResponseEntityBody (InputStream is) throws IOException {\n+        byte[] buf = new byte [2048];\n+        byte[] total = new byte [2048];\n+        int total_len = 2048;\n+        int c, len=0;\n+        while ((c=is.read (buf)) != -1) {\n+            if (len+c > total_len) {\n+                byte[] total1 = new byte [total_len * 2];\n+                System.arraycopy (total, 0, total1, 0, len);\n+                total = total1;\n+                total_len = total_len * 2;\n+            }\n+            System.arraycopy (buf, 0, total, len, c);\n+            len += c;\n+        }\n+        setResponseEntityBody (total, len);\n+    }\n+\n+    \/* chunked *\/\n+\n+    \/**\n+     * Set the entity response body with the given array of strings\n+     * The content encoding is set to \"chunked\" and each array element\n+     * is sent as one chunk.\n+     * @param body the array of string chunks to send in the response\n+     *\/\n+    public void setResponseEntityBody (String[] body) {\n+        StringBuffer buf = new StringBuffer ();\n+        int len = 0;\n+        for (int i=0; i<body.length; i++) {\n+            String chunklen = Integer.toHexString (body[i].length());\n+            len += body[i].length();\n+            buf.append (chunklen).append (\"\\r\\n\");\n+            buf.append (body[i]).append (\"\\r\\n\");\n+        }\n+        buf.append (\"0\\r\\n\");\n+        rspbody = new String (buf).getBytes();\n+        rspbodylen = rspbody.length;\n+        rspchunked = true;\n+        addResponseHeader (\"Transfer-encoding\", \"chunked\");\n+    }\n+\n+    \/**\n+     * Send the response with the current set of response parameters\n+     * but using the response code and string tag line as specified\n+     * @param rCode the response code to send\n+     * @param rTag the response string to send with the response code\n+     *\/\n+    public void sendResponse (int rCode, String rTag) throws IOException {\n+        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n+        PrintStream ps = new PrintStream (os);\n+        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n+        if (rspheaders != null) {\n+            rspheaders.print (ps);\n+        } else {\n+            ps.print (\"\\r\\n\");\n+        }\n+        ps.flush ();\n+        if (rspbody != null) {\n+            os.write (rspbody, 0, rspbodylen);\n+            os.flush();\n+        }\n+        if (rsptrailers != null) {\n+            rsptrailers.print (ps);\n+        } else if (rspchunked) {\n+            ps.print (\"\\r\\n\");\n+        }\n+        ps.flush();\n+    }\n+\n+    \/* sends one byte less than intended *\/\n+\n+    public void sendPartialResponse (int rCode, String rTag)throws IOException {\n+        OutputStream os = new TestHttpsServer.NioOutputStream(channel(), server.getSSLEngine(), server.outNetBB(), server.outAppBB());\n+        PrintStream ps = new PrintStream (os);\n+        ps.print (\"HTTP\/1.1 \" + rCode + \" \" + rTag + \"\\r\\n\");\n+        ps.flush();\n+        if (rspbody != null) {\n+            os.write (rspbody, 0, rspbodylen-1);\n+            os.flush();\n+        }\n+        if (rsptrailers != null) {\n+            rsptrailers.print (ps);\n+        }\n+        ps.flush();\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpTransaction.java","additions":330,"deletions":0,"binary":false,"changes":330,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2015, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,2 +37,2 @@\n- *        ClosedChannelList\n- *        TunnelProxy\n+ *        HttpCallback TestHttpsServer ClosedChannelList\n+ *        HttpTransaction TunnelProxy\n@@ -43,22 +43,5 @@\n-import java.io.FileInputStream;\n-import java.net.HttpURLConnection;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.NetworkInterface;\n-import java.net.ProxySelector;\n-import java.net.URL;\n-import java.security.KeyStore;\n-import java.util.Optional;\n-import java.util.concurrent.Executors;\n-\n-import javax.net.ssl.HostnameVerifier;\n-import javax.net.ssl.HttpsURLConnection;\n-import javax.net.ssl.KeyManagerFactory;\n-import javax.net.ssl.SSLContext;\n-import javax.net.ssl.SSLSession;\n-import javax.net.ssl.TrustManagerFactory;\n-\n-import com.sun.net.httpserver.HttpExchange;\n-import com.sun.net.httpserver.HttpHandler;\n-import com.sun.net.httpserver.HttpsConfigurator;\n-import com.sun.net.httpserver.HttpsServer;\n+import java.io.*;\n+import java.net.*;\n+import javax.net.ssl.*;\n+import java.util.*;\n+\n@@ -69,1 +52,1 @@\n-    static HttpsServer server;\n+    static TestHttpsServer server;\n@@ -86,0 +69,1 @@\n+\n@@ -87,0 +71,1 @@\n+\n@@ -89,1 +74,3 @@\n-            ProxySelector.setDefault(ProxySelector.of(new InetSocketAddress(firstNonLoAddress, proxy.getLocalPort())));\n+            System.setProperty(\"https.proxyPort\",\n+                        (new Integer(proxy.getLocalPort())).toString() );\n+\n@@ -91,0 +78,4 @@\n+\n+            if (httpTrans.hasBadRequest) {\n+                throw new RuntimeException(\"Test failed : bad http request\");\n+            }\n@@ -96,1 +87,1 @@\n-               server.stop(1);\n+               server.terminate();\n@@ -147,1 +138,1 @@\n-    public static void startHttpServer() throws  Exception {\n+    public static void startHttpServer() throws IOException {\n@@ -151,23 +142,1 @@\n-        \/\/ create and initialize a SSLContext\n-        KeyStore ks = KeyStore.getInstance(\"JKS\");\n-        KeyStore ts = KeyStore.getInstance(\"JKS\");\n-        char[] passphrase = \"passphrase\".toCharArray();\n-\n-        ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n-        ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n-\n-        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n-        kmf.init(ks, passphrase);\n-\n-        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n-        tmf.init(ts);\n-\n-        SSLContext sslCtx = SSLContext.getInstance(\"TLS\");\n-\n-        sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n-\n-        server = HttpsServer.create(new InetSocketAddress(firstNonLoAddress, 0), 10);\n-        server.setHttpsConfigurator(new HttpsConfigurator(sslCtx));\n-        server.createContext(\"\/\", httpTrans);\n-        server.setExecutor(Executors.newSingleThreadExecutor());\n-        server.start();\n+        server = new TestHttpsServer(httpTrans, 1, 10, 0);\n@@ -178,1 +147,1 @@\n-        System.out.println(\"https server listen on: \" + server.getAddress().getPort());\n+        System.out.println(\"https server listen on: \" + server.getLocalPort());\n@@ -181,1 +150,1 @@\n-                            server.getAddress().getPort(), \"\/\");\n+                            server.getLocalPort(), \"\/\");\n@@ -184,4 +153,0 @@\n-        if(uc.getResponseCode() != 200) {\n-            uc.disconnect();\n-            throw new RuntimeException(\"Test failed : bad http request with response code : \"+ uc.getResponseCode());\n-        }\n@@ -198,1 +163,2 @@\n-class SimpleHttpTransaction implements HttpHandler {\n+class SimpleHttpTransaction implements HttpCallback {\n+    public boolean hasBadRequest = false;\n@@ -203,1 +169,1 @@\n-    public void handle(HttpExchange trans) {\n+    public void request(HttpTransaction trans) {\n@@ -209,2 +175,2 @@\n-                trans.getResponseHeaders().set(\"Location\", location);\n-                trans.sendResponseHeaders(302, -1);\n+                trans.addResponseHeader(\"Location\", location);\n+                trans.sendResponse(302, \"Moved Temporarily\");\n@@ -212,1 +178,10 @@\n-                trans.sendResponseHeaders(200, -1);\n+                \/\/ if the bug exsits, it'll send 2 GET commands\n+                \/\/ check 2nd GET here\n+                String duplicatedGet = trans.getRequestHeader(null);\n+                if (duplicatedGet != null &&\n+                    duplicatedGet.toUpperCase().indexOf(\"GET\") >= 0) {\n+                    trans.sendResponse(400, \"Bad Request\");\n+                    hasBadRequest = true;\n+                } else {\n+                    trans.sendResponse(200, \"OK\");\n+                }\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/B6216082.java","additions":38,"deletions":63,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,20 +28,4 @@\n-import java.io.BufferedInputStream;\n-import java.io.BufferedOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.OutputStream;\n-import java.net.InetAddress;\n-import java.net.InetSocketAddress;\n-import java.net.Socket;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.nio.BufferOverflowException;\n-import java.nio.ByteBuffer;\n-import java.nio.channels.SelectionKey;\n-import java.nio.channels.Selector;\n-import java.nio.channels.ServerSocketChannel;\n-import java.nio.channels.SocketChannel;\n-import java.util.HashMap;\n-import java.util.Iterator;\n-import java.util.Set;\n-\n+import java.net.*;\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n@@ -49,0 +33,1 @@\n+import java.util.*;\n@@ -61,0 +46,1 @@\n+     * @param cb the callback object which is invoked to handle each\n@@ -72,0 +58,2 @@\n+     * @param cb the callback object which is invoked to handle each\n+     *     incoming request\n@@ -89,0 +77,2 @@\n+     * @param cb the callback object which is invoked to handle\n+     *  each incoming request\n@@ -241,0 +231,1 @@\n+            HttpTransaction msg;\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/HttpsURLConnection\/TunnelProxy.java","additions":12,"deletions":21,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,961 @@\n+\/*\n+ * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.net.*;\n+import java.io.*;\n+import java.nio.*;\n+import java.nio.channels.*;\n+import sun.net.www.MessageHeader;\n+import java.util.*;\n+import javax.net.ssl.*;\n+import javax.net.ssl.SSLEngineResult.*;\n+import java.security.*;\n+\n+\/**\n+ * This class implements a simple HTTPS server. It uses multiple threads to\n+ * handle connections in parallel, and will spin off a new thread to handle\n+ * each request. (this is easier to implement with SSLEngine)\n+ * <p>\n+ * It must be instantiated with a {@link HttpCallback} object to which\n+ * requests are given and must be handled.\n+ * <p>\n+ * Simple synchronization between the client(s) and server can be done\n+ * using the {@link #waitForCondition(String)}, {@link #setCondition(String)} and\n+ * {@link #rendezvous(String,int)} methods.\n+ *\n+ * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n+ *\n+ * If you make a change in here, please don't forget to make the\n+ * corresponding change in the J2SE equivalent.\n+ *\n+ * NOTE NOTE NOTE NOTE NOTE NOTE NOTE\n+ *\/\n+\n+public class TestHttpsServer {\n+\n+    ServerSocketChannel schan;\n+    int threads;\n+    int cperthread;\n+    HttpCallback cb;\n+    Server[] servers;\n+\n+    \/\/ ssl related fields\n+    static SSLContext sslCtx;\n+\n+    \/**\n+     * Create a <code>TestHttpsServer<code> instance with the specified callback object\n+     * for handling requests. One thread is created to handle requests,\n+     * and up to ten TCP connections will be handled simultaneously.\n+     * @param cb the callback object which is invoked to handle each\n+     *  incoming request\n+     *\/\n+\n+    public TestHttpsServer (HttpCallback cb) throws IOException {\n+        this (cb, 1, 10, 0);\n+    }\n+\n+    \/**\n+     * Create a <code>TestHttpsServer<code> instance with the specified number of\n+     * threads and maximum number of connections per thread. This functions\n+     * the same as the 4 arg constructor, where the port argument is set to zero.\n+     * @param cb the callback object which is invoked to handle each\n+     *     incoming request\n+     * @param threads the number of threads to create to handle requests\n+     *     in parallel\n+     * @param cperthread the number of simultaneous TCP connections to\n+     *     handle per thread\n+     *\/\n+\n+    public TestHttpsServer (HttpCallback cb, int threads, int cperthread)\n+        throws IOException {\n+        this (cb, threads, cperthread, 0);\n+    }\n+\n+    \/**\n+     * Create a <code>TestHttpsServer<code> instance with the specified number\n+     * of threads and maximum number of connections per thread and running on\n+     * the specified port. The specified number of threads are created to\n+     * handle incoming requests, and each thread is allowed\n+     * to handle a number of simultaneous TCP connections.\n+     * @param cb the callback object which is invoked to handle\n+     *  each incoming request\n+     * @param threads the number of threads to create to handle\n+     *  requests in parallel\n+     * @param cperthread the number of simultaneous TCP connections\n+     *  to handle per thread\n+     * @param port the port number to bind the server to. <code>Zero<\/code>\n+     *  means choose any free port.\n+     *\/\n+\n+    public TestHttpsServer (HttpCallback cb, int threads, int cperthread, int port)\n+        throws IOException {\n+        schan = ServerSocketChannel.open ();\n+        InetSocketAddress addr = new InetSocketAddress (port);\n+        schan.socket().bind (addr);\n+        this.threads = threads;\n+        this.cb = cb;\n+        this.cperthread = cperthread;\n+\n+        try {\n+            \/\/ create and initialize a SSLContext\n+            KeyStore ks = KeyStore.getInstance(\"JKS\");\n+            KeyStore ts = KeyStore.getInstance(\"JKS\");\n+            char[] passphrase = \"passphrase\".toCharArray();\n+\n+            ks.load(new FileInputStream(System.getProperty(\"javax.net.ssl.keyStore\")), passphrase);\n+            ts.load(new FileInputStream(System.getProperty(\"javax.net.ssl.trustStore\")), passphrase);\n+\n+            KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+            kmf.init(ks, passphrase);\n+\n+            TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+            tmf.init(ts);\n+\n+            sslCtx = SSLContext.getInstance(\"TLS\");\n+\n+            sslCtx.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);\n+\n+            servers = new Server [threads];\n+            for (int i=0; i<threads; i++) {\n+                servers[i] = new Server (cb, schan, cperthread);\n+                servers[i].start();\n+            }\n+        } catch (Exception ex) {\n+            throw new RuntimeException(\"test failed. cause: \"+ex.getMessage());\n+        }\n+    }\n+\n+    \/** Tell all threads in the server to exit within 5 seconds.\n+     *  This is an abortive termination. Just prior to the thread exiting\n+     *  all channels in that thread waiting to be closed are forceably closed.\n+     *\/\n+\n+    public void terminate () {\n+        for (int i=0; i<threads; i++) {\n+            servers[i].terminate ();\n+        }\n+    }\n+\n+    \/**\n+     * return the local port number to which the server is bound.\n+     * @return the local port number\n+     *\/\n+\n+    public int getLocalPort () {\n+        return schan.socket().getLocalPort ();\n+    }\n+\n+    public String getAuthority() {\n+        InetAddress address = schan.socket().getInetAddress();\n+        String hostaddr = address.getHostAddress();\n+        if (address.isAnyLocalAddress()) hostaddr = \"localhost\";\n+        if (hostaddr.indexOf(':') > -1) hostaddr = \"[\" + hostaddr + \"]\";\n+        return hostaddr + \":\" + getLocalPort();\n+    }\n+\n+    static class Server extends Thread {\n+\n+        ServerSocketChannel schan;\n+        Selector selector;\n+        SelectionKey listenerKey;\n+        SelectionKey key; \/* the current key being processed *\/\n+        HttpCallback cb;\n+        ByteBuffer consumeBuffer;\n+        int maxconn;\n+        int nconn;\n+        ClosedChannelList clist;\n+        boolean shutdown;\n+\n+        Server (HttpCallback cb, ServerSocketChannel schan, int maxconn) {\n+            this.schan = schan;\n+            this.maxconn = maxconn;\n+            this.cb = cb;\n+            nconn = 0;\n+            consumeBuffer = ByteBuffer.allocate (512);\n+            clist = new ClosedChannelList ();\n+            try {\n+                selector = Selector.open ();\n+                schan.configureBlocking (false);\n+                listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n+            } catch (IOException e) {\n+                System.err.println (\"Server could not start: \" + e);\n+            }\n+        }\n+\n+        \/* Stop the thread as soon as possible *\/\n+        public synchronized void terminate () {\n+            shutdown = true;\n+        }\n+\n+        public void run ()  {\n+            try {\n+                while (true) {\n+                    selector.select (1000);\n+                    Set selected = selector.selectedKeys();\n+                    Iterator iter = selected.iterator();\n+                    while (iter.hasNext()) {\n+                        key = (SelectionKey)iter.next();\n+                        if (key.equals (listenerKey)) {\n+                            SocketChannel sock = schan.accept ();\n+                            if (sock == null) {\n+                                \/* false notification *\/\n+                                iter.remove();\n+                                continue;\n+                            }\n+                            sock.configureBlocking (true);\n+                            SSLEngine sslEng = sslCtx.createSSLEngine();\n+                            sslEng.setUseClientMode(false);\n+                            new ServerWorker(cb, sock, sslEng).start();\n+                            nconn ++;\n+                            if (nconn == maxconn) {\n+                                \/* deregister *\/\n+                                listenerKey.cancel ();\n+                                listenerKey = null;\n+                            }\n+                        } else {\n+                            if (key.isReadable()) {\n+                                boolean closed = false;\n+                                SocketChannel chan = (SocketChannel) key.channel();\n+                                if (key.attachment() != null) {\n+                                    closed = consume (chan);\n+                                }\n+\n+                                if (closed) {\n+                                    chan.close ();\n+                                    key.cancel ();\n+                                    if (nconn == maxconn) {\n+                                        listenerKey = schan.register (selector, SelectionKey.OP_ACCEPT);\n+                                    }\n+                                    nconn --;\n+                                }\n+                            }\n+                        }\n+                        iter.remove();\n+                    }\n+                    clist.check();\n+\n+                    synchronized (this) {\n+                        if (shutdown) {\n+                            clist.terminate ();\n+                            return;\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                System.out.println (\"Server exception: \" + e);\n+                \/\/ TODO finish\n+            }\n+        }\n+\n+        \/* read all the data off the channel without looking at it\n+             * return true if connection closed\n+             *\/\n+        boolean consume (SocketChannel chan) {\n+            try {\n+                consumeBuffer.clear ();\n+                int c = chan.read (consumeBuffer);\n+                if (c == -1)\n+                    return true;\n+            } catch (IOException e) {\n+                return true;\n+            }\n+            return false;\n+        }\n+    }\n+\n+    static class ServerWorker extends Thread {\n+        private ByteBuffer inNetBB;\n+        private ByteBuffer outNetBB;\n+        private ByteBuffer inAppBB;\n+        private ByteBuffer outAppBB;\n+\n+        SSLEngine sslEng;\n+        SocketChannel schan;\n+        HttpCallback cb;\n+        HandshakeStatus currentHSStatus;\n+        boolean initialHSComplete;\n+        boolean handshakeStarted;\n+        \/*\n+         * All inbound data goes through this buffer.\n+         *\n+         * It might be nice to use a cache of ByteBuffers so we're\n+         * not alloc\/dealloc'ing all over the place.\n+         *\/\n+\n+        \/*\n+         * Application buffers, also used for handshaking\n+         *\/\n+        private int appBBSize;\n+\n+        ServerWorker (HttpCallback cb, SocketChannel schan, SSLEngine sslEng) {\n+            this.sslEng = sslEng;\n+            this.schan = schan;\n+            this.cb = cb;\n+            currentHSStatus = HandshakeStatus.NEED_UNWRAP;\n+            initialHSComplete = false;\n+            int netBBSize = sslEng.getSession().getPacketBufferSize();\n+            inNetBB =  ByteBuffer.allocate(netBBSize);\n+            outNetBB = ByteBuffer.allocate(netBBSize);\n+            appBBSize = sslEng.getSession().getApplicationBufferSize();\n+            inAppBB = ByteBuffer.allocate(appBBSize);\n+            outAppBB = ByteBuffer.allocate(appBBSize);\n+        }\n+\n+        public SSLEngine getSSLEngine() {\n+            return sslEng;\n+        }\n+\n+        public ByteBuffer outNetBB() {\n+            return outNetBB;\n+        }\n+\n+        public ByteBuffer outAppBB() {\n+            return outAppBB;\n+        }\n+\n+        public void run () {\n+            try {\n+                SSLEngineResult result;\n+\n+                while (!initialHSComplete) {\n+\n+                    switch (currentHSStatus) {\n+\n+                    case NEED_UNWRAP:\n+                        int bytes = schan.read(inNetBB);\n+                        if (!handshakeStarted && bytes > 0) {\n+                            handshakeStarted = true;\n+                            int byte0 = inNetBB.get(0);\n+                            if (byte0 != 0x16) {\n+                                \/\/ first byte of a TLS connection is supposed to be\n+                                \/\/ 0x16. If not it may be a plain text connection.\n+                                \/\/\n+                                \/\/ Sometime a rogue client may try to open a plain\n+                                \/\/ connection with our server. Calling this method\n+                                \/\/ gives a chance to the test logic to ignore such\n+                                \/\/ rogue connections.\n+                                \/\/\n+                                if (cb.dropPlainTextConnections()) {\n+                                    try { schan.close(); } catch (IOException x) { };\n+                                    return;\n+                                }\n+                                \/\/ else sslEng.unwrap will throw later on...\n+                            }\n+                        }\n+\n+needIO:\n+                        while (currentHSStatus == HandshakeStatus.NEED_UNWRAP) {\n+                            \/*\n+                             * Don't need to resize requestBB, since no app data should\n+                             * be generated here.\n+                             *\/\n+                            inNetBB.flip();\n+                            result = sslEng.unwrap(inNetBB, inAppBB);\n+                            inNetBB.compact();\n+                            currentHSStatus = result.getHandshakeStatus();\n+\n+                            switch (result.getStatus()) {\n+\n+                            case OK:\n+                                switch (currentHSStatus) {\n+                                case NOT_HANDSHAKING:\n+                                    throw new IOException(\n+                                                          \"Not handshaking during initial handshake\");\n+\n+                                case NEED_TASK:\n+                                    Runnable task;\n+                                    while ((task = sslEng.getDelegatedTask()) != null) {\n+                                        task.run();\n+                                        currentHSStatus = sslEng.getHandshakeStatus();\n+                                    }\n+                                    break;\n+                                }\n+\n+                                break;\n+\n+                            case BUFFER_UNDERFLOW:\n+                                break needIO;\n+\n+                            default: \/\/ BUFFER_OVERFLOW\/CLOSED:\n+                                throw new IOException(\"Received\" + result.getStatus() +\n+                                                      \"during initial handshaking\");\n+                            }\n+                        }\n+\n+                        \/*\n+                         * Just transitioned from read to write.\n+                         *\/\n+                        if (currentHSStatus != HandshakeStatus.NEED_WRAP) {\n+                            break;\n+                        }\n+\n+                        \/\/ Fall through and fill the write buffer.\n+\n+                    case NEED_WRAP:\n+                        \/*\n+                         * The flush above guarantees the out buffer to be empty\n+                         *\/\n+                        outNetBB.clear();\n+                        result = sslEng.wrap(inAppBB, outNetBB);\n+                        outNetBB.flip();\n+                        schan.write (outNetBB);\n+                        outNetBB.compact();\n+                        currentHSStatus = result.getHandshakeStatus();\n+\n+                        switch (result.getStatus()) {\n+                        case OK:\n+\n+                            if (currentHSStatus == HandshakeStatus.NEED_TASK) {\n+                                Runnable task;\n+                                while ((task = sslEng.getDelegatedTask()) != null) {\n+                                    task.run();\n+                                    currentHSStatus = sslEng.getHandshakeStatus();\n+                                }\n+                            }\n+\n+                            break;\n+\n+                        default: \/\/ BUFFER_OVERFLOW\/BUFFER_UNDERFLOW\/CLOSED:\n+                            throw new IOException(\"Received\" + result.getStatus() +\n+                                                  \"during initial handshaking\");\n+                        }\n+                        break;\n+\n+                    case FINISHED:\n+                        initialHSComplete = true;\n+                        break;\n+                    default: \/\/ NOT_HANDSHAKING\/NEED_TASK\n+                        throw new RuntimeException(\"Invalid Handshaking State\" +\n+                                                   currentHSStatus);\n+                    } \/\/ switch\n+                }\n+                \/\/ read the application data; using non-blocking mode\n+                schan.configureBlocking(false);\n+                read(schan, sslEng);\n+            } catch (Exception ex) {\n+                throw new RuntimeException(ex);\n+            }\n+        }\n+\n+        \/* return true if the connection is closed, false otherwise *\/\n+\n+        private boolean read (SocketChannel chan, SSLEngine sslEng) {\n+            HttpTransaction msg;\n+            boolean res;\n+            try {\n+                InputStream is = new BufferedInputStream (new NioInputStream (chan, sslEng, inNetBB, inAppBB));\n+                String requestline = readLine (is);\n+                MessageHeader mhead = new MessageHeader (is);\n+                String clen = mhead.findValue (\"Content-Length\");\n+                String trferenc = mhead.findValue (\"Transfer-Encoding\");\n+                String data = null;\n+                if (trferenc != null && trferenc.equals (\"chunked\"))\n+                    data = new String (readChunkedData (is));\n+                else if (clen != null)\n+                    data = new String (readNormalData (is, Integer.parseInt (clen)));\n+                String[] req = requestline.split (\" \");\n+                if (req.length < 2) {\n+                    \/* invalid request line *\/\n+                    return false;\n+                }\n+                String cmd = req[0];\n+                URI uri = null;\n+                try {\n+                    uri = new URI (req[1]);\n+                    msg = new HttpTransaction (this, cmd, uri, mhead, data, null, chan);\n+                    cb.request (msg);\n+                } catch (URISyntaxException e) {\n+                    System.err.println (\"Invalid URI: \" + e);\n+                    msg = new HttpTransaction (this, cmd, null, null, null, null, chan);\n+                    msg.sendResponse (501, \"Whatever\");\n+                }\n+                res = false;\n+            } catch (IOException e) {\n+                res = true;\n+            }\n+            return res;\n+        }\n+\n+        byte[] readNormalData (InputStream is, int len) throws IOException {\n+            byte [] buf  = new byte [len];\n+            int c, off=0, remain=len;\n+            while (remain > 0 && ((c=is.read (buf, off, remain))>0)) {\n+                remain -= c;\n+                off += c;\n+            }\n+            return buf;\n+        }\n+\n+        private void readCRLF(InputStream is) throws IOException {\n+            int cr = is.read();\n+            int lf = is.read();\n+\n+            if (((cr & 0xff) != 0x0d) ||\n+                ((lf & 0xff) != 0x0a)) {\n+                throw new IOException(\n+                    \"Expected <CR><LF>:  got '\" + cr + \"\/\" + lf + \"'\");\n+            }\n+        }\n+\n+        byte[] readChunkedData (InputStream is) throws IOException {\n+            LinkedList l = new LinkedList ();\n+            int total = 0;\n+            for (int len=readChunkLen(is); len!=0; len=readChunkLen(is)) {\n+                l.add (readNormalData(is, len));\n+                total += len;\n+                readCRLF(is); \/\/ CRLF at end of chunk\n+            }\n+            readCRLF(is); \/\/ CRLF at end of Chunked Stream.\n+            byte[] buf = new byte [total];\n+            Iterator i = l.iterator();\n+            int x = 0;\n+            while (i.hasNext()) {\n+                byte[] b = (byte[])i.next();\n+                System.arraycopy (b, 0, buf, x, b.length);\n+                x += b.length;\n+            }\n+            return buf;\n+        }\n+\n+        private int readChunkLen (InputStream is) throws IOException {\n+            int c, len=0;\n+            boolean done=false, readCR=false;\n+            while (!done) {\n+                c = is.read ();\n+                if (c == '\\n' && readCR) {\n+                    done = true;\n+                } else {\n+                    if (c == '\\r' && !readCR) {\n+                        readCR = true;\n+                    } else {\n+                        int x=0;\n+                        if (c >= 'a' && c <= 'f') {\n+                            x = c - 'a' + 10;\n+                        } else if (c >= 'A' && c <= 'F') {\n+                            x = c - 'A' + 10;\n+                        } else if (c >= '0' && c <= '9') {\n+                            x = c - '0';\n+                        }\n+                        len = len * 16 + x;\n+                    }\n+                }\n+            }\n+            return len;\n+        }\n+\n+        private String readLine (InputStream is) throws IOException {\n+            boolean done=false, readCR=false;\n+            byte[] b = new byte [512];\n+            int c, l = 0;\n+\n+            while (!done) {\n+                c = is.read ();\n+                if (c == '\\n' && readCR) {\n+                    done = true;\n+                } else {\n+                    if (c == '\\r' && !readCR) {\n+                        readCR = true;\n+                    } else {\n+                        b[l++] = (byte)c;\n+                    }\n+                }\n+            }\n+            return new String (b);\n+        }\n+\n+        \/** close the channel associated with the current key by:\n+         * 1. shutdownOutput (send a FIN)\n+         * 2. mark the key so that incoming data is to be consumed and discarded\n+         * 3. After a period, close the socket\n+         *\/\n+\n+        synchronized void orderlyCloseChannel (SocketChannel ch) throws IOException {\n+            ch.socket().shutdownOutput();\n+        }\n+\n+        synchronized void abortiveCloseChannel (SocketChannel ch) throws IOException {\n+            Socket s = ch.socket ();\n+            s.setSoLinger (true, 0);\n+            ch.close();\n+        }\n+    }\n+\n+\n+    \/**\n+     * Implements blocking reading semantics on top of a non-blocking channel\n+     *\/\n+\n+    static class NioInputStream extends InputStream {\n+        SSLEngine sslEng;\n+        SocketChannel channel;\n+        Selector selector;\n+        ByteBuffer inNetBB;\n+        ByteBuffer inAppBB;\n+        SelectionKey key;\n+        int available;\n+        byte[] one;\n+        boolean closed;\n+        ByteBuffer markBuf; \/* reads may be satisifed from this buffer *\/\n+        boolean marked;\n+        boolean reset;\n+        int readlimit;\n+\n+        public NioInputStream (SocketChannel chan, SSLEngine sslEng, ByteBuffer inNetBB, ByteBuffer inAppBB) throws IOException {\n+            this.sslEng = sslEng;\n+            this.channel = chan;\n+            selector = Selector.open();\n+            this.inNetBB = inNetBB;\n+            this.inAppBB = inAppBB;\n+            key = chan.register (selector, SelectionKey.OP_READ);\n+            available = 0;\n+            one = new byte[1];\n+            closed = marked = reset = false;\n+        }\n+\n+        public synchronized int read (byte[] b) throws IOException {\n+            return read (b, 0, b.length);\n+        }\n+\n+        public synchronized int read () throws IOException {\n+            return read (one, 0, 1);\n+        }\n+\n+        public synchronized int read (byte[] b, int off, int srclen) throws IOException {\n+\n+            int canreturn, willreturn;\n+\n+            if (closed)\n+                return -1;\n+\n+            if (reset) { \/* satisfy from markBuf *\/\n+                canreturn = markBuf.remaining ();\n+                willreturn = canreturn>srclen ? srclen : canreturn;\n+                markBuf.get(b, off, willreturn);\n+                if (canreturn == willreturn) {\n+                    reset = false;\n+                }\n+            } else { \/* satisfy from channel *\/\n+                canreturn = available();\n+                if (canreturn == 0) {\n+                    block ();\n+                    canreturn = available();\n+                }\n+                willreturn = canreturn>srclen ? srclen : canreturn;\n+                inAppBB.get(b, off, willreturn);\n+                available -= willreturn;\n+\n+                if (marked) { \/* copy into markBuf *\/\n+                    try {\n+                        markBuf.put (b, off, willreturn);\n+                    } catch (BufferOverflowException e) {\n+                        marked = false;\n+                    }\n+                }\n+            }\n+            return willreturn;\n+        }\n+\n+        public synchronized int available () throws IOException {\n+            if (closed)\n+                throw new IOException (\"Stream is closed\");\n+\n+            if (reset)\n+                return markBuf.remaining();\n+\n+            if (available > 0)\n+                return available;\n+\n+            inAppBB.clear ();\n+            int bytes = channel.read (inNetBB);\n+\n+            int needed = sslEng.getSession().getApplicationBufferSize();\n+            if (needed > inAppBB.remaining()) {\n+                inAppBB = ByteBuffer.allocate(needed);\n+            }\n+            inNetBB.flip();\n+            SSLEngineResult result = sslEng.unwrap(inNetBB, inAppBB);\n+            inNetBB.compact();\n+            available = result.bytesProduced();\n+\n+            if (available > 0)\n+                inAppBB.flip();\n+            else if (available == -1)\n+                throw new IOException (\"Stream is closed\");\n+            return available;\n+        }\n+\n+        \/**\n+         * block() only called when available==0 and buf is empty\n+         *\/\n+        private synchronized void block () throws IOException {\n+            \/\/assert available == 0;\n+            int n = selector.select ();\n+            \/\/assert n == 1;\n+            selector.selectedKeys().clear();\n+            available ();\n+        }\n+\n+        public void close () throws IOException {\n+            if (closed)\n+                return;\n+            channel.close ();\n+            closed = true;\n+        }\n+\n+        public synchronized void mark (int readlimit) {\n+            if (closed)\n+                return;\n+            this.readlimit = readlimit;\n+            markBuf = ByteBuffer.allocate (readlimit);\n+            marked = true;\n+            reset = false;\n+        }\n+\n+        public synchronized void reset () throws IOException {\n+            if (closed )\n+                return;\n+            if (!marked)\n+                throw new IOException (\"Stream not marked\");\n+            marked = false;\n+            reset = true;\n+            markBuf.flip ();\n+        }\n+    }\n+\n+    static class NioOutputStream extends OutputStream {\n+        SSLEngine sslEng;\n+        SocketChannel channel;\n+        ByteBuffer outNetBB;\n+        ByteBuffer outAppBB;\n+        SelectionKey key;\n+        Selector selector;\n+        boolean closed;\n+        byte[] one;\n+\n+        public NioOutputStream (SocketChannel channel, SSLEngine sslEng, ByteBuffer outNetBB, ByteBuffer outAppBB) throws IOException {\n+            this.sslEng = sslEng;\n+            this.channel = channel;\n+            this.outNetBB = outNetBB;\n+            this.outAppBB = outAppBB;\n+            selector = Selector.open ();\n+            key = channel.register (selector, SelectionKey.OP_WRITE);\n+            closed = false;\n+            one = new byte [1];\n+        }\n+\n+        public synchronized void write (int b) throws IOException {\n+            one[0] = (byte)b;\n+            write (one, 0, 1);\n+        }\n+\n+        public synchronized void write (byte[] b) throws IOException {\n+            write (b, 0, b.length);\n+        }\n+\n+        public synchronized void write (byte[] b, int off, int len) throws IOException {\n+            if (closed)\n+                throw new IOException (\"stream is closed\");\n+\n+            outAppBB = ByteBuffer.allocate (len);\n+            outAppBB.put (b, off, len);\n+            outAppBB.flip ();\n+            int n;\n+            outNetBB.clear();\n+            int needed = sslEng.getSession().getPacketBufferSize();\n+            if (outNetBB.capacity() < needed) {\n+                outNetBB = ByteBuffer.allocate(needed);\n+            }\n+            SSLEngineResult ret = sslEng.wrap(outAppBB, outNetBB);\n+            outNetBB.flip();\n+            int newLen = ret.bytesProduced();\n+            while ((n = channel.write (outNetBB)) < newLen) {\n+                newLen -= n;\n+                if (newLen == 0)\n+                    return;\n+                selector.select ();\n+                selector.selectedKeys().clear ();\n+            }\n+        }\n+\n+        public void close () throws IOException {\n+            if (closed)\n+                return;\n+            channel.close ();\n+            closed = true;\n+        }\n+    }\n+\n+    \/**\n+     * Utilities for synchronization. A condition is\n+     * identified by a string name, and is initialized\n+     * upon first use (ie. setCondition() or waitForCondition()). Threads\n+     * are blocked until some thread calls (or has called) setCondition() for the same\n+     * condition.\n+     * <P>\n+     * A rendezvous built on a condition is also provided for synchronizing\n+     * N threads.\n+     *\/\n+\n+    private static HashMap conditions = new HashMap();\n+\n+    \/*\n+     * Modifiable boolean object\n+     *\/\n+    private static class BValue {\n+        boolean v;\n+    }\n+\n+    \/*\n+     * Modifiable int object\n+     *\/\n+    private static class IValue {\n+        int v;\n+        IValue (int i) {\n+            v =i;\n+        }\n+    }\n+\n+\n+    private static BValue getCond (String condition) {\n+        synchronized (conditions) {\n+            BValue cond = (BValue) conditions.get (condition);\n+            if (cond == null) {\n+                cond = new BValue();\n+                conditions.put (condition, cond);\n+            }\n+            return cond;\n+        }\n+    }\n+\n+    \/**\n+     * Set the condition to true. Any threads that are currently blocked\n+     * waiting on the condition, will be unblocked and allowed to continue.\n+     * Threads that subsequently call waitForCondition() will not block.\n+     * If the named condition did not exist prior to the call, then it is created\n+     * first.\n+     *\/\n+\n+    public static void setCondition (String condition) {\n+        BValue cond = getCond (condition);\n+        synchronized (cond) {\n+            if (cond.v) {\n+                return;\n+            }\n+            cond.v = true;\n+            cond.notifyAll();\n+        }\n+    }\n+\n+    \/**\n+     * If the named condition does not exist, then it is created and initialized\n+     * to false. If the condition exists or has just been created and its value\n+     * is false, then the thread blocks until another thread sets the condition.\n+     * If the condition exists and is already set to true, then this call returns\n+     * immediately without blocking.\n+     *\/\n+\n+    public static void waitForCondition (String condition) {\n+        BValue cond = getCond (condition);\n+        synchronized (cond) {\n+            if (!cond.v) {\n+                try {\n+                    cond.wait();\n+                } catch (InterruptedException e) {}\n+            }\n+        }\n+    }\n+\n+    \/* conditions must be locked when accessing this *\/\n+    static HashMap rv = new HashMap();\n+\n+    \/**\n+     * Force N threads to rendezvous (ie. wait for each other) before proceeding.\n+     * The first thread(s) to call are blocked until the last\n+     * thread makes the call. Then all threads continue.\n+     * <p>\n+     * All threads that call with the same condition name, must use the same value\n+     * for N (or the results may be not be as expected).\n+     * <P>\n+     * Obviously, if fewer than N threads make the rendezvous then the result\n+     * will be a hang.\n+     *\/\n+\n+    public static void rendezvous (String condition, int N) {\n+        BValue cond;\n+        IValue iv;\n+        String name = \"RV_\"+condition;\n+\n+        \/* get the condition *\/\n+\n+        synchronized (conditions) {\n+            cond = (BValue)conditions.get (name);\n+            if (cond == null) {\n+                \/* we are first caller *\/\n+                if (N < 2) {\n+                    throw new RuntimeException (\"rendezvous must be called with N >= 2\");\n+                }\n+                cond = new BValue ();\n+                conditions.put (name, cond);\n+                iv = new IValue (N-1);\n+                rv.put (name, iv);\n+            } else {\n+                \/* already initialised, just decrement the counter *\/\n+                iv = (IValue) rv.get (name);\n+                iv.v --;\n+            }\n+        }\n+\n+        if (iv.v > 0) {\n+            waitForCondition (name);\n+        } else {\n+            setCondition (name);\n+            synchronized (conditions) {\n+                clearCondition (name);\n+                rv.remove (name);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * If the named condition exists and is set then remove it, so it can\n+     * be re-initialized and used again. If the condition does not exist, or\n+     * exists but is not set, then the call returns without doing anything.\n+     * Note, some higher level synchronization\n+     * may be needed between clear and the other operations.\n+     *\/\n+\n+    public static void clearCondition(String condition) {\n+        BValue cond;\n+        synchronized (conditions) {\n+            cond = (BValue) conditions.get (condition);\n+            if (cond == null) {\n+                return;\n+            }\n+            synchronized (cond) {\n+                if (cond.v) {\n+                    conditions.remove (condition);\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/net\/www\/protocol\/https\/TestHttpsServer.java","additions":961,"deletions":0,"binary":false,"changes":961,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 4638015 8248001\n+ * @bug 4638015\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHrefInDocComment\/TestHrefInDocComment.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package pkg;\n-\n-\/**\n- *This class has <a href=\"{@docRoot}\/pkg\/J1.html#functions\">various functions<\/a>,\n- * see <a href=\"ftp:\/\/www.example.com\/\">FTP Site<\/a>,\n- *  <a href=\"file:\/\/\/path\/to\/somefile\">file service<\/a> for further information\n- *<a id=\"functions\">various functions<\/a>\n- *<ul>\n- *<li>function1<\/li>\n- *<li>function2<\/li>\n- *<li>function3<\/li>\n- *<\/ul>\n- *<a id=\"methods\">special methods<\/a>\n- *<ul>\n- *<li>method1<\/li>\n- *<li>method2<\/li>\n- *<li>method3<\/li>\n- *<\/ul>\n- *\/\n-public class J1 {\n-    \/**\n-     *fields.\n-     *\/\n-    protected Object field1;\n-\n-    \/**\n-     *<a href=\"{@docRoot}\/pkg\/J1.html#functions\">Creates an instance which has various functions.<\/a>\n-     *\/\n-    public J1(){\n-    }\n-\n-    \/**\n-     *This is a<a href=\"#methods\">special method<\/a>.\n-     *@param p1 arg1\n-     *\/\n-    public void method1(int p1){\n-    }\n-\n-    \/**\n-     *See <a href=\"ftp:\/\/www.example.com\/\">FTP Site<\/a> for more information.\n-     *@param p1 arg1\n-     *\/\n-    public void method2(int p1){\n-    }\n-\n-    \/**\n-     *See <a href=\"file:\/\/\/path\/to\/somefile\">file service<\/a> for more information.\n-     *@param p1 arg1\n-     *\/\n-    public void method3(int p1){\n-    }\n-}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHrefInDocComment\/pkg\/J1.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"}]}