{"files":[{"patch":"@@ -757,0 +757,51 @@\n+int\n+IsWindows10RS3OrGreater() {\n+    OSVERSIONINFOEXW osvi = { sizeof(osvi), 0, 0, 0, 0, {0}, 0, 0 };\n+    DWORDLONG const cond_mask = VerSetConditionMask(\n+        VerSetConditionMask(\n+          VerSetConditionMask(\n+            0, VER_MAJORVERSION, VER_GREATER_EQUAL),\n+               VER_MINORVERSION, VER_GREATER_EQUAL),\n+               VER_BUILDNUMBER,  VER_GREATER_EQUAL);\n+\n+    osvi.dwMajorVersion = HIBYTE(_WIN32_WINNT_WIN10);\n+    osvi.dwMinorVersion = LOBYTE(_WIN32_WINNT_WIN10);\n+    osvi.dwBuildNumber  = 16299; \/\/ RS3 (Redstone 3)\n+\n+    return VerifyVersionInfoW(&osvi, VER_MAJORVERSION | VER_MINORVERSION | VER_BUILDNUMBER, cond_mask) != 0;\n+}\n+\n+\/**\n+ * Shortens the default Windows socket\n+ * connect timeout. Recommended for usage\n+ * on the loopback adapter only.\n+ *\/\n+JNIEXPORT jint JNICALL\n+NET_EnableFastTcpLoopbackConnect(int fd) {\n+    TCP_INITIAL_RTO_PARAMETERS rto = {\n+        TCP_INITIAL_RTO_UNSPECIFIED_RTT,    \/\/ Use the default or overriden by the Administrator\n+        1                                   \/\/ Minimum possible value before Windows 10 RS3\n+    };\n+\n+    \/**\n+     * In Windows 10 RS3+ we can use the no retransmissions flag to\n+     * completely remove the timeout delay, which is fixed to 500ms\n+     * if Windows receives RST when the destination port is not open.\n+     *\/\n+    if (IsWindows10RS3OrGreater()) {\n+        rto.MaxSynRetransmissions = TCP_INITIAL_RTO_NO_SYN_RETRANSMISSIONS;\n+    }\n+\n+    DWORD result_byte_count = -1;\n+    int result = WSAIoctl(fd,                       \/\/ descriptor identifying a socket\n+                          SIO_TCP_INITIAL_RTO,      \/\/ dwIoControlCode\n+                          &rto,                     \/\/ pointer to TCP_INITIAL_RTO_PARAMETERS structure\n+                          sizeof(rto),              \/\/ size, in bytes, of the input buffer\n+                          NULL,                     \/\/ pointer to output buffer\n+                          0,                        \/\/ size of output buffer\n+                          &result_byte_count,       \/\/ number of bytes returned\n+                          NULL,                     \/\/ OVERLAPPED structure\n+                          NULL);                    \/\/ completion routine\n+    return (result == SOCKET_ERROR) ? WSAGetLastError() : 0;\n+}\n+\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.c","additions":51,"deletions":0,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include <mstcpip.h>\n@@ -89,0 +90,18 @@\n+\/**\n+ * With dual socket implementation the\n+ * IPv4 addresseses might be mapped as IPv6.\n+ * The IPv4 loopback adapter address will\n+ * be mapped as the following IPv6 ::ffff:127.0.0.1.\n+ * For example, this is done by NET_InetAddressToSockaddr.\n+ *\/\n+#define IN6_IS_ADDR_V4MAPPED_LOOPBACK(x) ( \\\n+    (((x)->s6_words[0] == 0)      &&  \\\n+     ((x)->s6_words[1] == 0)      &&  \\\n+     ((x)->s6_words[2] == 0)      &&  \\\n+     ((x)->s6_words[3] == 0)      &&  \\\n+     ((x)->s6_words[4] == 0)      &&  \\\n+     ((x)->s6_words[5] == 0xFFFF) &&  \\\n+     ((x)->s6_words[6] == 0x007F) &&  \\\n+     ((x)->s6_words[7] == 0x0100))    \\\n+)\n+\n@@ -92,1 +111,2 @@\n-        (IN6ADDR_ISLOOPBACK(x)) \\\n+        ((IN6_IS_ADDR_LOOPBACK(&(x)->sa6.sin6_addr)) || \\\n+         (IN6_IS_ADDR_V4MAPPED_LOOPBACK(&(x)->sa6.sin6_addr))) \\\n@@ -122,0 +142,2 @@\n+JNIEXPORT jint JNICALL NET_EnableFastTcpLoopbackConnect(int fd);\n+\n","filename":"src\/java.base\/windows\/native\/libnet\/net_util_md.h","additions":23,"deletions":1,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -197,0 +197,1 @@\n+    int so_rv;\n@@ -199,0 +200,1 @@\n+    int type = 0, optlen = sizeof(type);\n@@ -204,0 +206,10 @@\n+    so_rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&type, &optlen);\n+\n+    \/**\n+     * Windows has a very long socket connect timeout of 2 seconds.\n+     * If it's the loopback adapter we can shorten the wait interval.\n+     *\/\n+    if (so_rv == 0 && type == SOCK_STREAM && IS_LOOPBACK_ADDRESS(&sa)) {\n+        NET_EnableFastTcpLoopbackConnect((jint)s);\n+    }\n+\n@@ -214,3 +226,1 @@\n-        int type = 0, optlen = sizeof(type);\n-        rv = getsockopt(s, SOL_SOCKET, SO_TYPE, (char*)&type, &optlen);\n-        if (rv == 0 && type == SOCK_DGRAM) {\n+        if (so_rv == 0 && type == SOCK_DGRAM) {\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/Net.c","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"}]}