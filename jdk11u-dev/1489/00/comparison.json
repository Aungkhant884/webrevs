{"files":[{"patch":"@@ -0,0 +1,209 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8193682 8278794 8284771\n+ * @summary Test Infinite loop while writing on closed Deflater and Inflater.\n+ * @run testng CloseInflaterDeflaterTest\n+ *\/\n+import java.io.*;\n+import java.util.Random;\n+import java.util.jar.JarOutputStream;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.DeflaterOutputStream;\n+import java.util.zip.GZIPOutputStream;\n+import java.util.zip.InflaterOutputStream;\n+import java.util.zip.ZipOutputStream;\n+import java.util.zip.ZipEntry;\n+\n+import org.testng.annotations.BeforeTest;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertThrows;\n+\n+\n+public class CloseInflaterDeflaterTest {\n+\n+    \/\/ Number of bytes to write\/read from Deflater\/Inflater\n+    private static final int INPUT_LENGTH= 512;\n+    \/\/ OutputStream that will throw an exception during a write operation\n+    private static OutputStream outStream = new OutputStream() {\n+        @Override\n+        public void write(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public void write(byte[] b) throws IOException {}\n+        @Override\n+        public void write(int b) throws IOException {}\n+    };\n+    \/\/ InputStream that will throw an exception during a read operation\n+    private static InputStream inStream = new InputStream() {\n+        @Override\n+        public int read(byte[] b, int off, int len) throws IOException {\n+            throw new IOException();\n+        }\n+        @Override\n+        public int read(byte[] b) throws IOException { throw new IOException();}\n+        @Override\n+        public int read() throws IOException { throw new IOException();}\n+    };\n+    \/\/ Input bytes for read\/write operation\n+    private static byte[] inputBytes = new byte[INPUT_LENGTH];\n+    \/\/ Random function to add bytes to inputBytes\n+    private static Random rand = new Random();\n+\n+    \/**\n+     * DataProvider to specify whether to use close() or finish() of OutputStream\n+     *\n+     * @return Entry object indicating which method to use for closing OutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testOutputStreams() {\n+     return new Object[][] {\n+      { true },\n+      { false },\n+     };\n+    }\n+\n+    \/**\n+     * DataProvider to specify on which outputstream closeEntry() has to be called\n+     *\n+     * @return Entry object returning either JarOutputStream or ZipOutputStream\n+     *\/\n+    @DataProvider\n+    public Object[][] testZipAndJar() throws IOException{\n+     return new Object[][] {\n+      { new JarOutputStream(outStream)},\n+      { new ZipOutputStream(outStream)},\n+     };\n+    }\n+\n+    \/**\n+     * Add inputBytes array with random bytes to write into OutputStream\n+     *\/\n+    @BeforeTest\n+    public void before_test()\n+    {\n+       rand.nextBytes(inputBytes);\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed GZIPOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testGZip(boolean useCloseMethod) throws IOException {\n+        GZIPOutputStream gzip = new GZIPOutputStream(outStream);\n+        gzip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close GZIPOutputStream\n+            if (useCloseMethod) {\n+                gzip.close();\n+            } else {\n+                gzip.finish();\n+            }\n+        });\n+        \/\/ Write on a closed GZIPOutputStream, closed Deflater IOException expected\n+        assertThrows(NullPointerException.class , () -> gzip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed DeflaterOutputStream\n+     *\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\")\n+    public void testDeflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        DeflaterOutputStream def = new DeflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class, () -> {\n+            \/\/ Close DeflaterOutputStream\n+            if (useCloseMethod) {\n+                def.close();\n+            } else {\n+                def.finish();\n+            }\n+        });\n+        \/\/ Write on a closed DeflaterOutputStream, 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> def.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by reading bytes from closed DeflaterInputStream\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void testDeflaterInputStream() throws IOException {\n+        DeflaterInputStream def = new DeflaterInputStream(inStream);\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+        \/\/ Close DeflaterInputStream\n+        def.close();\n+        \/\/ Read from a closed DeflaterInputStream, closed Deflater IOException expected\n+        assertThrows(IOException.class , () -> def.read(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed InflaterOutputStream\n+     *\n+     * Note: Disabling this test as it is failing intermittently.\n+     * @param useCloseMethod indicates whether to use Close() or finish() method\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testOutputStreams\",enabled=false)\n+    public void testInflaterOutputStream(boolean useCloseMethod) throws IOException {\n+        InflaterOutputStream inf = new InflaterOutputStream(outStream);\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+        assertThrows(IOException.class , () -> {\n+            \/\/ Close InflaterOutputStream\n+            if (useCloseMethod) {\n+                inf.close();\n+            } else {\n+                inf.finish();\n+            }\n+        });\n+        \/\/ Write on a closed InflaterOutputStream , closed Inflater IOException expected\n+        assertThrows(IOException.class , () -> inf.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+    \/**\n+     * Test for infinite loop by writing bytes to closed ZipOutputStream\/JarOutputStream\n+     *\n+     * @param zip will be the instance of either JarOutputStream or ZipOutputStream\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test(dataProvider = \"testZipAndJar\")\n+    public void testZipCloseEntry(ZipOutputStream zip) throws IOException {\n+        assertThrows(IOException.class , () -> zip.putNextEntry(new ZipEntry(\"\")));\n+        zip.write(inputBytes, 0, INPUT_LENGTH);\n+        assertThrows(IOException.class , () -> zip.closeEntry());\n+        \/\/ Write on a closed ZipOutputStream , 'Deflater has been closed' NPE is expected\n+        assertThrows(NullPointerException.class , () -> zip.write(inputBytes, 0, INPUT_LENGTH));\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/util\/zip\/CloseInflaterDeflaterTest.java","additions":209,"deletions":0,"binary":false,"changes":209,"status":"added"}]}