{"files":[{"patch":"@@ -61,6 +61,9 @@\n-    public synchronized void close() throws IOException {\n-        if (!isClosed) {\n-            if (fragmenter != null && fragmenter.hasAlert()) {\n-                isCloseWaiting = true;\n-            } else {\n-                super.close();\n+    public void close() throws IOException {\n+        recordLock.lock();\n+        try {\n+            if (!isClosed) {\n+                if (fragmenter != null && fragmenter.hasAlert()) {\n+                    isCloseWaiting = true;\n+                } else {\n+                    super.close();\n+                }\n@@ -68,0 +71,2 @@\n+        } finally {\n+            recordLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSOutputRecord.java","additions":11,"deletions":6,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -46,1 +47,1 @@\n-    TransportContext            tc;\n+    TransportContext    tc;\n@@ -49,1 +50,1 @@\n-    boolean             isClosed;\n+    volatile boolean    isClosed;\n@@ -59,0 +60,2 @@\n+    final ReentrantLock recordLock = new ReentrantLock();\n+\n@@ -95,4 +98,9 @@\n-    public synchronized void close() throws IOException {\n-        if (!isClosed) {\n-            isClosed = true;\n-            readCipher.dispose();\n+    public void close() throws IOException {\n+        recordLock.lock();\n+        try {\n+            if (!isClosed) {\n+                isClosed = true;\n+                readCipher.dispose();\n+            }\n+        } finally {\n+            recordLock.unlock();\n@@ -102,1 +110,1 @@\n-    synchronized boolean isClosed() {\n+    boolean isClosed() {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/InputRecord.java","additions":16,"deletions":8,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -71,0 +72,2 @@\n+    final ReentrantLock recordLock = new ReentrantLock();\n+\n@@ -92,2 +95,7 @@\n-    synchronized void setVersion(ProtocolVersion protocolVersion) {\n-        this.protocolVersion = protocolVersion;\n+    void setVersion(ProtocolVersion protocolVersion) {\n+        recordLock.lock();\n+        try {\n+            this.protocolVersion = protocolVersion;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -99,2 +107,7 @@\n-    synchronized void setHelloVersion(ProtocolVersion helloVersion) {\n-        this.helloVersion = helloVersion;\n+    void setHelloVersion(ProtocolVersion helloVersion) {\n+        recordLock.lock();\n+        try {\n+            this.helloVersion = helloVersion;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -111,2 +124,4 @@\n-    synchronized boolean seqNumIsHuge() {\n-        return (writeCipher.authenticator != null) &&\n+    boolean seqNumIsHuge() {\n+        recordLock.lock();\n+        try {\n+            return (writeCipher.authenticator != null) &&\n@@ -114,0 +129,3 @@\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -151,1 +169,1 @@\n-    synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,\n+    void changeWriteCiphers(SSLWriteCipher writeCipher,\n@@ -153,4 +171,8 @@\n-        if (isClosed()) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n-                    \"change_cipher_spec message\");\n+        recordLock.lock();\n+        try {\n+            if (isClosed()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n+                        \"change_cipher_spec message\");\n+                }\n+                return;\n@@ -158,2 +180,0 @@\n-            return;\n-        }\n@@ -161,13 +181,3 @@\n-        if (useChangeCipherSpec) {\n-            encodeChangeCipherSpec();\n-        }\n-\n-        \/*\n-         * Dispose of any intermediate state in the underlying cipher.\n-         * For PKCS11 ciphers, this will release any attached sessions,\n-         * and thus make finalization faster.\n-         *\n-         * Since MAC's doFinal() is called for every SSL\/TLS packet, it's\n-         * not necessary to do the same with MAC's.\n-         *\/\n-        writeCipher.dispose();\n+            if (useChangeCipherSpec) {\n+                encodeChangeCipherSpec();\n+            }\n@@ -175,2 +185,15 @@\n-        this.writeCipher = writeCipher;\n-        this.isFirstAppOutputRecord = true;\n+            \/*\n+             * Dispose of any intermediate state in the underlying cipher.\n+             * For PKCS11 ciphers, this will release any attached sessions,\n+             * and thus make finalization faster.\n+             *\n+             * Since MAC's doFinal() is called for every SSL\/TLS packet, it's\n+             * not necessary to do the same with MAC's.\n+             *\/\n+            writeCipher.dispose();\n+\n+            this.writeCipher = writeCipher;\n+            this.isFirstAppOutputRecord = true;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -180,1 +203,1 @@\n-    synchronized void changeWriteCiphers(SSLWriteCipher writeCipher,\n+    void changeWriteCiphers(SSLWriteCipher writeCipher,\n@@ -182,4 +205,8 @@\n-        if (isClosed()) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n-                    \"key_update handshake message\");\n+        recordLock.lock();\n+        try {\n+            if (isClosed()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n+                        \"key_update handshake message\");\n+                }\n+                return;\n@@ -187,2 +214,0 @@\n-            return;\n-        }\n@@ -190,5 +215,5 @@\n-        \/\/ encode the handshake message, KeyUpdate\n-        byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();\n-        hm[hm.length - 1] = keyUpdateRequest;\n-        encodeHandshake(hm, 0, hm.length);\n-        flush();\n+            \/\/ encode the handshake message, KeyUpdate\n+            byte[] hm = HANDSHAKE_MESSAGE_KEY_UPDATE.clone();\n+            hm[hm.length - 1] = keyUpdateRequest;\n+            encodeHandshake(hm, 0, hm.length);\n+            flush();\n@@ -196,2 +221,2 @@\n-        \/\/ Dispose of any intermediate state in the underlying cipher.\n-        writeCipher.dispose();\n+            \/\/ Dispose of any intermediate state in the underlying cipher.\n+            writeCipher.dispose();\n@@ -199,2 +224,5 @@\n-        this.writeCipher = writeCipher;\n-        this.isFirstAppOutputRecord = true;\n+            this.writeCipher = writeCipher;\n+            this.isFirstAppOutputRecord = true;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -203,2 +231,7 @@\n-    synchronized void changePacketSize(int packetSize) {\n-        this.packetSize = packetSize;\n+    void changePacketSize(int packetSize) {\n+        recordLock.lock();\n+        try {\n+            this.packetSize = packetSize;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -207,2 +240,7 @@\n-    synchronized void changeFragmentSize(int fragmentSize) {\n-        this.fragmentSize = fragmentSize;\n+    void changeFragmentSize(int fragmentSize) {\n+        recordLock.lock();\n+        try {\n+            this.fragmentSize = fragmentSize;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -211,2 +249,7 @@\n-    synchronized int getMaxPacketSize() {\n-        return packetSize;\n+    int getMaxPacketSize() {\n+        recordLock.lock();\n+        try {\n+            return packetSize;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -231,4 +274,6 @@\n-    public synchronized void close() throws IOException {\n-        if (isClosed) {\n-            return;\n-        }\n+    public void close() throws IOException {\n+        recordLock.lock();\n+        try {\n+            if (isClosed) {\n+                return;\n+            }\n@@ -236,2 +281,5 @@\n-        isClosed = true;\n-        writeCipher.dispose();\n+            isClosed = true;\n+            writeCipher.dispose();\n+        } finally {\n+            recordLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/OutputRecord.java","additions":105,"deletions":57,"binary":false,"changes":162,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,6 +54,9 @@\n-    public synchronized void close() throws IOException {\n-        if (!isClosed) {\n-            if (fragmenter != null && fragmenter.hasAlert()) {\n-                isCloseWaiting = true;\n-            } else {\n-                super.close();\n+    public void close() throws IOException {\n+        recordLock.lock();\n+        try {\n+            if (!isClosed) {\n+                if (fragmenter != null && !fragmenter.isEmpty()) {\n+                    isCloseWaiting = true;\n+                } else {\n+                    super.close();\n+                }\n@@ -61,0 +64,2 @@\n+        } finally {\n+            recordLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineOutputRecord.java","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -662,5 +663,53 @@\n-        try {\n-            synchronized (conContext.outputRecord) {\n-                \/\/ send a user_canceled alert if needed.\n-                if (useUserCanceled) {\n-                    conContext.warning(Alert.USER_CANCELED);\n+        int linger = getSoLinger();\n+        if (linger >= 0) {\n+            \/\/ don't wait more than SO_LINGER for obtaining the\n+            \/\/ the lock.\n+            \/\/\n+            \/\/ keep and clear the current thread interruption status.\n+            boolean interrupted = Thread.interrupted();\n+            try {\n+                if (conContext.outputRecord.recordLock.tryLock() ||\n+                        conContext.outputRecord.recordLock.tryLock(\n+                                linger, TimeUnit.SECONDS)) {\n+                    try {\n+                        handleClosedNotifyAlert(useUserCanceled);\n+                    } finally {\n+                        conContext.outputRecord.recordLock.unlock();\n+                    }\n+                } else {\n+                    \/\/ For layered, non-autoclose sockets, we are not\n+                    \/\/ able to bring them into a usable state, so we\n+                    \/\/ treat it as fatal error.\n+                    if (!super.isOutputShutdown()) {\n+                        if (isLayered() && !autoClose) {\n+                            throw new SSLException(\n+                                    \"SO_LINGER timeout, \" +\n+                                    \"close_notify message cannot be sent.\");\n+                        } else {\n+                            super.shutdownOutput();\n+                            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                                SSLLogger.warning(\n+                                    \"SSLSocket output duplex close failed: \" +\n+                                    \"SO_LINGER timeout, \" +\n+                                    \"close_notify message cannot be sent.\");\n+                            }\n+                        }\n+                    }\n+\n+                    \/\/ RFC2246 requires that the session becomes\n+                    \/\/ unresumable if any connection is terminated\n+                    \/\/ without proper close_notify messages with\n+                    \/\/ level equal to warning.\n+                    \/\/\n+                    \/\/ RFC4346 no longer requires that a session not be\n+                    \/\/ resumed if failure to properly close a connection.\n+                    \/\/\n+                    \/\/ We choose to make the session unresumable if\n+                    \/\/ failed to send the close_notify message.\n+                    \/\/\n+                    conContext.conSession.invalidate();\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                        SSLLogger.warning(\n+                                \"Invalidate the session: SO_LINGER timeout, \" +\n+                                \"close_notify message cannot be sent.\");\n+                    }\n@@ -668,0 +717,4 @@\n+            } catch (InterruptedException ex) {\n+                \/\/ keep interrupted status\n+                interrupted = true;\n+            }\n@@ -669,2 +722,3 @@\n-                \/\/ send a close_notify alert\n-                conContext.warning(Alert.CLOSE_NOTIFY);\n+            \/\/ restore the interrupted status\n+            if (interrupted) {\n+                Thread.currentThread().interrupt();\n@@ -672,0 +726,20 @@\n+        } else {\n+            conContext.outputRecord.recordLock.lock();\n+            try {\n+                handleClosedNotifyAlert(useUserCanceled);\n+            } finally {\n+                conContext.outputRecord.recordLock.unlock();\n+            }\n+        }\n+    }\n+\n+    private void handleClosedNotifyAlert(\n+            boolean useUserCanceled) throws IOException {\n+        try {\n+            \/\/ send a user_canceled alert if needed.\n+            if (useUserCanceled) {\n+                conContext.warning(Alert.USER_CANCELED);\n+            }\n+\n+            \/\/ send a close_notify alert\n+            conContext.warning(Alert.CLOSE_NOTIFY);\n@@ -677,1 +751,2 @@\n-            if ((autoClose || !isLayered()) && !super.isOutputShutdown()) {\n+            if (!super.isOutputShutdown() &&\n+                    (autoClose || !isLayered())) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":83,"deletions":8,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,6 +54,9 @@\n-    synchronized void encodeAlert(\n-            byte level, byte description) throws IOException {\n-        if (isClosed()) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n-                    \"alert message: \" + Alert.nameOf(description));\n+    void encodeAlert(byte level, byte description) throws IOException {\n+        recordLock.lock();\n+        try {\n+            if (isClosed()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n+                        \"alert message: \" + Alert.nameOf(description));\n+                }\n+                return;\n@@ -61,2 +64,0 @@\n-            return;\n-        }\n@@ -64,12 +65,2 @@\n-        \/\/ use the buf of ByteArrayOutputStream\n-        int position = headerSize + writeCipher.getExplicitNonceSize();\n-        count = position;\n-\n-        write(level);\n-        write(description);\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n-            SSLLogger.fine(\"WRITE: \" + protocolVersion.name +\n-                    \" \" + ContentType.ALERT.name +\n-                    \"(\" + Alert.nameOf(description) + \")\" +\n-                    \", length = \" + (count - headerSize));\n-        }\n+            \/\/ use the buf of ByteArrayOutputStream\n+            count = headerSize + writeCipher.getExplicitNonceSize();\n@@ -77,2 +68,8 @@\n-        \/\/ Encrypt the fragment and wrap up a record.\n-        encrypt(writeCipher, ContentType.ALERT.id, headerSize);\n+            write(level);\n+            write(description);\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+                SSLLogger.fine(\"WRITE: \" + protocolVersion.name +\n+                        \" \" + ContentType.ALERT.name +\n+                        \"(\" + Alert.nameOf(description) + \")\" +\n+                        \", length = \" + (count - headerSize));\n+            }\n@@ -80,3 +77,2 @@\n-        \/\/ deliver this message\n-        deliverStream.write(buf, 0, count);    \/\/ may throw IOException\n-        deliverStream.flush();                 \/\/ may throw IOException\n+            \/\/ Encrypt the fragment and wrap up a record.\n+            encrypt(writeCipher, ContentType.ALERT.id, headerSize);\n@@ -84,4 +80,3 @@\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n-            SSLLogger.fine(\"Raw write\",\n-                    (new ByteArrayInputStream(buf, 0, count)));\n-        }\n+            \/\/ deliver this message\n+            deliverStream.write(buf, 0, count);    \/\/ may throw IOException\n+            deliverStream.flush();                 \/\/ may throw IOException\n@@ -89,2 +84,10 @@\n-        \/\/ reset the internal buffer\n-        count = 0;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+                SSLLogger.fine(\"Raw write\",\n+                        (new ByteArrayInputStream(buf, 0, count)));\n+            }\n+\n+            \/\/ reset the internal buffer\n+            count = 0;\n+        } finally {\n+            recordLock.unlock();\n+        }\n@@ -94,1 +97,1 @@\n-    synchronized void encodeHandshake(byte[] source,\n+    void encodeHandshake(byte[] source,\n@@ -96,5 +99,9 @@\n-        if (isClosed()) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n-                        \"handshake message\",\n-                        ByteBuffer.wrap(source, offset, length));\n+        recordLock.lock();\n+        try {\n+            if (isClosed()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n+                            \"handshake message\",\n+                            ByteBuffer.wrap(source, offset, length));\n+                }\n+                return;\n@@ -102,2 +109,0 @@\n-            return;\n-        }\n@@ -105,2 +110,2 @@\n-        if (firstMessage) {\n-            firstMessage = false;\n+            if (firstMessage) {\n+                firstMessage = false;\n@@ -108,2 +113,2 @@\n-            if ((helloVersion == ProtocolVersion.SSL20Hello) &&\n-                (source[offset] == SSLHandshake.CLIENT_HELLO.id) &&\n+                if ((helloVersion == ProtocolVersion.SSL20Hello) &&\n+                    (source[offset] == SSLHandshake.CLIENT_HELLO.id) &&\n@@ -111,1 +116,1 @@\n-                (source[offset + 4 + 2 + 32] == 0)) {\n+                    (source[offset + 4 + 2 + 32] == 0)) {\n@@ -117,2 +122,30 @@\n-                ByteBuffer v2ClientHello = encodeV2ClientHello(\n-                        source, (offset + 4), (length - 4));\n+                    ByteBuffer v2ClientHello = encodeV2ClientHello(\n+                            source, (offset + 4), (length - 4));\n+\n+                    \/\/ array offset is zero\n+                    byte[] record = v2ClientHello.array();\n+                    int limit = v2ClientHello.limit();\n+                    handshakeHash.deliver(record, 2, (limit - 2));\n+\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+                        SSLLogger.fine(\n+                                \"WRITE: SSLv2 ClientHello message\" +\n+                                \", length = \" + limit);\n+                    }\n+\n+                    \/\/ deliver this message\n+                    \/\/\n+                    \/\/ Version 2 ClientHello message should be plaintext.\n+                    \/\/\n+                    \/\/ No max fragment length negotiation.\n+                    deliverStream.write(record, 0, limit);\n+                    deliverStream.flush();\n+\n+                    if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+                        SSLLogger.fine(\"Raw write\",\n+                                (new ByteArrayInputStream(record, 0, limit)));\n+                    }\n+\n+                    return;\n+                }\n+            }\n@@ -120,3 +153,26 @@\n-                byte[] record = v2ClientHello.array();  \/\/ array offset is zero\n-                int limit = v2ClientHello.limit();\n-                handshakeHash.deliver(record, 2, (limit - 2));\n+            byte handshakeType = source[0];\n+            if (handshakeHash.isHashable(handshakeType)) {\n+                handshakeHash.deliver(source, offset, length);\n+            }\n+\n+            int fragLimit = getFragLimit();\n+            int position = headerSize + writeCipher.getExplicitNonceSize();\n+            if (count == 0) {\n+                count = position;\n+            }\n+\n+            if ((count - position) < (fragLimit - length)) {\n+                write(source, offset, length);\n+                return;\n+            }\n+\n+            for (int limit = (offset + length); offset < limit;) {\n+\n+                int remains = (limit - offset) + (count - position);\n+                int fragLen = Math.min(fragLimit, remains);\n+\n+                \/\/ use the buf of ByteArrayOutputStream\n+                write(source, offset, fragLen);\n+                if (remains < fragLimit) {\n+                    return;\n+                }\n@@ -126,2 +182,3 @@\n-                            \"WRITE: SSLv2 ClientHello message\" +\n-                            \", length = \" + limit);\n+                            \"WRITE: \" + protocolVersion.name +\n+                            \" \" + ContentType.HANDSHAKE.name +\n+                            \", length = \" + (count - headerSize));\n@@ -130,0 +187,3 @@\n+                \/\/ Encrypt the fragment and wrap up a record.\n+                encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);\n+\n@@ -131,6 +191,2 @@\n-                \/\/\n-                \/\/ Version 2 ClientHello message should be plaintext.\n-                \/\/\n-                \/\/ No max fragment length negotiation.\n-                deliverStream.write(record, 0, limit);\n-                deliverStream.flush();\n+                deliverStream.write(buf, 0, count);    \/\/ may throw IOException\n+                deliverStream.flush();                 \/\/ may throw IOException\n@@ -140,1 +196,1 @@\n-                            (new ByteArrayInputStream(record, 0, limit)));\n+                            (new ByteArrayInputStream(buf, 0, count)));\n@@ -143,1 +199,5 @@\n-                return;\n+                \/\/ reset the offset\n+                offset += fragLen;\n+\n+                \/\/ reset the internal buffer\n+                count = position;\n@@ -145,0 +205,2 @@\n+        } finally {\n+            recordLock.unlock();\n@@ -146,0 +208,1 @@\n+    }\n@@ -147,4 +210,11 @@\n-        byte handshakeType = source[0];\n-        if (handshakeHash.isHashable(handshakeType)) {\n-            handshakeHash.deliver(source, offset, length);\n-        }\n+    @Override\n+    void encodeChangeCipherSpec() throws IOException {\n+        recordLock.lock();\n+        try {\n+            if (isClosed()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n+                        \"change_cipher_spec message\");\n+                }\n+                return;\n+            }\n@@ -152,5 +222,2 @@\n-        int fragLimit = getFragLimit();\n-        int position = headerSize + writeCipher.getExplicitNonceSize();\n-        if (count == 0) {\n-            count = position;\n-        }\n+            \/\/ use the buf of ByteArrayOutputStream\n+            count = headerSize + writeCipher.getExplicitNonceSize();\n@@ -158,4 +225,1 @@\n-        if ((count - position) < (fragLimit - length)) {\n-            write(source, offset, length);\n-            return;\n-        }\n+            write((byte)1);         \/\/ byte 1: change_cipher_spec(\n@@ -163,1 +227,2 @@\n-        for (int limit = (offset + length); offset < limit;) {\n+            \/\/ Encrypt the fragment and wrap up a record.\n+            encrypt(writeCipher, ContentType.CHANGE_CIPHER_SPEC.id, headerSize);\n@@ -165,2 +230,3 @@\n-            int remains = (limit - offset) + (count - position);\n-            int fragLen = Math.min(fragLimit, remains);\n+            \/\/ deliver this message\n+            deliverStream.write(buf, 0, count);        \/\/ may throw IOException\n+            \/\/ deliverStream.flush();                  \/\/ flush in Finished\n@@ -168,3 +234,18 @@\n-            \/\/ use the buf of ByteArrayOutputStream\n-            write(source, offset, fragLen);\n-            if (remains < fragLimit) {\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+                SSLLogger.fine(\"Raw write\",\n+                        (new ByteArrayInputStream(buf, 0, count)));\n+            }\n+\n+            \/\/ reset the internal buffer\n+            count = 0;\n+        } finally {\n+            recordLock.unlock();\n+        }\n+    }\n+\n+    @Override\n+    public void flush() throws IOException {\n+        recordLock.lock();\n+        try {\n+            int position = headerSize + writeCipher.getExplicitNonceSize();\n+            if (count <= position) {\n@@ -193,3 +274,0 @@\n-            \/\/ reset the offset\n-            offset += fragLen;\n-\n@@ -197,1 +275,3 @@\n-            count = position;\n+            count = 0;      \/\/ DON'T use position\n+        } finally {\n+            recordLock.unlock();\n@@ -202,5 +282,6 @@\n-    synchronized void encodeChangeCipherSpec() throws IOException {\n-        if (isClosed()) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.warning(\"outbound has closed, ignore outbound \" +\n-                    \"change_cipher_spec message\");\n+    void deliver(byte[] source, int offset, int length) throws IOException {\n+        recordLock.lock();\n+        try {\n+            if (isClosed()) {\n+                throw new SocketException(\n+                        \"Connection or outbound has been closed\");\n@@ -208,41 +289,0 @@\n-            return;\n-        }\n-\n-        \/\/ use the buf of ByteArrayOutputStream\n-        int position = headerSize + writeCipher.getExplicitNonceSize();\n-        count = position;\n-\n-        write((byte)1);         \/\/ byte 1: change_cipher_spec(\n-\n-        \/\/ Encrypt the fragment and wrap up a record.\n-        encrypt(writeCipher, ContentType.CHANGE_CIPHER_SPEC.id, headerSize);\n-\n-        \/\/ deliver this message\n-        deliverStream.write(buf, 0, count);        \/\/ may throw IOException\n-        \/\/ deliverStream.flush();                  \/\/ flush in Finished\n-\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n-            SSLLogger.fine(\"Raw write\",\n-                    (new ByteArrayInputStream(buf, 0, count)));\n-        }\n-\n-        \/\/ reset the internal buffer\n-        count = 0;\n-    }\n-\n-    @Override\n-    public synchronized void flush() throws IOException {\n-        int position = headerSize + writeCipher.getExplicitNonceSize();\n-        if (count <= position) {\n-            return;\n-        }\n-\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n-            SSLLogger.fine(\n-                    \"WRITE: \" + protocolVersion.name +\n-                    \" \" + ContentType.HANDSHAKE.name +\n-                    \", length = \" + (count - headerSize));\n-        }\n-\n-        \/\/ Encrypt the fragment and wrap up a record.\n-        encrypt(writeCipher, ContentType.HANDSHAKE.id, headerSize);\n@@ -250,19 +290,6 @@\n-        \/\/ deliver this message\n-        deliverStream.write(buf, 0, count);    \/\/ may throw IOException\n-        deliverStream.flush();                 \/\/ may throw IOException\n-\n-        if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n-            SSLLogger.fine(\"Raw write\",\n-                    (new ByteArrayInputStream(buf, 0, count)));\n-        }\n-\n-        \/\/ reset the internal buffer\n-        count = 0;      \/\/ DON'T use position\n-    }\n-\n-    @Override\n-    synchronized void deliver(\n-            byte[] source, int offset, int length) throws IOException {\n-        if (isClosed()) {\n-            throw new SocketException(\"Connection or outbound has been closed\");\n-        }\n+            if (writeCipher.authenticator.seqNumOverflow()) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n+                    SSLLogger.fine(\n+                        \"sequence number extremely close to overflow \" +\n+                        \"(2^64-1 packets). Closing connection.\");\n+                }\n@@ -270,5 +297,1 @@\n-        if (writeCipher.authenticator.seqNumOverflow()) {\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl\")) {\n-                SSLLogger.fine(\n-                    \"sequence number extremely close to overflow \" +\n-                    \"(2^64-1 packets). Closing connection.\");\n+                throw new SSLHandshakeException(\"sequence number overflow\");\n@@ -277,2 +300,12 @@\n-            throw new SSLHandshakeException(\"sequence number overflow\");\n-        }\n+            boolean isFirstRecordOfThePayload = true;\n+            for (int limit = (offset + length); offset < limit;) {\n+                int fragLen;\n+                if (packetSize > 0) {\n+                    fragLen = Math.min(maxRecordSize, packetSize);\n+                    fragLen = writeCipher.calculateFragmentSize(\n+                            fragLen, headerSize);\n+\n+                    fragLen = Math.min(fragLen, Record.maxDataSize);\n+                } else {\n+                    fragLen = Record.maxDataSize;\n+                }\n@@ -280,12 +313,2 @@\n-        boolean isFirstRecordOfThePayload = true;\n-        for (int limit = (offset + length); offset < limit;) {\n-            int fragLen;\n-            if (packetSize > 0) {\n-                fragLen = Math.min(maxRecordSize, packetSize);\n-                fragLen =\n-                        writeCipher.calculateFragmentSize(fragLen, headerSize);\n-\n-                fragLen = Math.min(fragLen, Record.maxDataSize);\n-            } else {\n-                fragLen = Record.maxDataSize;\n-            }\n+                \/\/ Calculate more impact, for example TLS 1.3 padding.\n+                fragLen = calculateFragmentSize(fragLen);\n@@ -293,2 +316,6 @@\n-            \/\/ Calculate more impact, for example TLS 1.3 padding.\n-            fragLen = calculateFragmentSize(fragLen);\n+                if (isFirstRecordOfThePayload && needToSplitPayload()) {\n+                    fragLen = 1;\n+                    isFirstRecordOfThePayload = false;\n+                } else {\n+                    fragLen = Math.min(fragLen, (limit - offset));\n+                }\n@@ -296,6 +323,4 @@\n-            if (isFirstRecordOfThePayload && needToSplitPayload()) {\n-                fragLen = 1;\n-                isFirstRecordOfThePayload = false;\n-            } else {\n-                fragLen = Math.min(fragLen, (limit - offset));\n-            }\n+                \/\/ use the buf of ByteArrayOutputStream\n+                int position = headerSize + writeCipher.getExplicitNonceSize();\n+                count = position;\n+                write(source, offset, fragLen);\n@@ -303,4 +328,6 @@\n-            \/\/ use the buf of ByteArrayOutputStream\n-            int position = headerSize + writeCipher.getExplicitNonceSize();\n-            count = position;\n-            write(source, offset, fragLen);\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n+                    SSLLogger.fine(\n+                            \"WRITE: \" + protocolVersion.name +\n+                            \" \" + ContentType.APPLICATION_DATA.name +\n+                            \", length = \" + (count - position));\n+                }\n@@ -308,6 +335,3 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"record\")) {\n-                SSLLogger.fine(\n-                        \"WRITE: \" + protocolVersion.name +\n-                        \" \" + ContentType.APPLICATION_DATA.name +\n-                        \", length = \" + (count - position));\n-            }\n+                \/\/ Encrypt the fragment and wrap up a record.\n+                encrypt(writeCipher,\n+                        ContentType.APPLICATION_DATA.id, headerSize);\n@@ -315,2 +339,3 @@\n-            \/\/ Encrypt the fragment and wrap up a record.\n-            encrypt(writeCipher, ContentType.APPLICATION_DATA.id, headerSize);\n+                \/\/ deliver this message\n+                deliverStream.write(buf, 0, count);    \/\/ may throw IOException\n+                deliverStream.flush();                 \/\/ may throw IOException\n@@ -318,3 +343,4 @@\n-            \/\/ deliver this message\n-            deliverStream.write(buf, 0, count);    \/\/ may throw IOException\n-            deliverStream.flush();                 \/\/ may throw IOException\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n+                    SSLLogger.fine(\"Raw write\",\n+                            (new ByteArrayInputStream(buf, 0, count)));\n+                }\n@@ -322,4 +348,2 @@\n-            if (SSLLogger.isOn && SSLLogger.isOn(\"packet\")) {\n-                SSLLogger.fine(\"Raw write\",\n-                        (new ByteArrayInputStream(buf, 0, count)));\n-            }\n+                \/\/ reset the internal buffer\n+                count = 0;\n@@ -327,2 +351,3 @@\n-            \/\/ reset the internal buffer\n-            count = 0;\n+                if (isFirstAppOutputRecord) {\n+                    isFirstAppOutputRecord = false;\n+                }\n@@ -330,2 +355,1 @@\n-            if (isFirstAppOutputRecord) {\n-                isFirstAppOutputRecord = false;\n+                offset += fragLen;\n@@ -333,2 +357,2 @@\n-\n-            offset += fragLen;\n+        } finally {\n+            recordLock.unlock();\n@@ -339,2 +363,7 @@\n-    synchronized void setDeliverStream(OutputStream outputStream) {\n-        this.deliverStream = outputStream;\n+    void setDeliverStream(OutputStream outputStream) {\n+        recordLock.lock();\n+        try {\n+            this.deliverStream = outputStream;\n+        } finally {\n+            recordLock.unlock();\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketOutputRecord.java","additions":231,"deletions":202,"binary":false,"changes":433,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -265,1 +265,2 @@\n-            synchronized (outputRecord) {\n+            outputRecord.recordLock.lock();\n+            try {\n@@ -277,0 +278,2 @@\n+            } finally {\n+                outputRecord.recordLock.unlock();\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/TransportContext.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,0 +56,3 @@\n+        \/\/ Set SO_LINGER in case of slow socket\n+        socket.setSoLinger(true, 10);\n+\n@@ -84,0 +87,3 @@\n+        \/\/ Set SO_LINGER in case of slow socket\n+        socket.setSoLinger(true, 10);\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSocket\/Tls13PacketSize.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,147 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/\n+\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n+\/\/ system properties in samevm\/agentvm mode.\n+\/\/\n+\n+\/*\n+ * @test\n+ * @bug 8224829\n+ * @summary AsyncSSLSocketClose.java has timing issue\n+ * @run main\/othervm BlockedAsyncClose\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.io.*;\n+import java.net.SocketException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class BlockedAsyncClose implements Runnable {\n+    SSLSocket socket;\n+    SSLServerSocket ss;\n+\n+    \/\/ Is the socket ready to close?\n+    private final CountDownLatch closeCondition = new CountDownLatch(1);\n+\n+    \/\/ Where do we find the keystores?\n+    static String pathToStores = \"..\/..\/..\/..\/javax\/net\/ssl\/etc\";\n+    static String keyStoreFile = \"keystore\";\n+    static String trustStoreFile = \"truststore\";\n+    static String passwd = \"passphrase\";\n+\n+    public static void main(String[] args) throws Exception {\n+        String keyFilename =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+                \"\/\" + keyStoreFile;\n+        String trustFilename =\n+            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n+                \"\/\" + trustStoreFile;\n+\n+        System.setProperty(\"javax.net.ssl.keyStore\", keyFilename);\n+        System.setProperty(\"javax.net.ssl.keyStorePassword\", passwd);\n+        System.setProperty(\"javax.net.ssl.trustStore\", trustFilename);\n+        System.setProperty(\"javax.net.ssl.trustStorePassword\", passwd);\n+\n+        new BlockedAsyncClose();\n+    }\n+\n+    public BlockedAsyncClose() throws Exception {\n+        SSLServerSocketFactory sslssf =\n+                (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();\n+        InetAddress loopback = InetAddress.getLoopbackAddress();\n+        ss = (SSLServerSocket)sslssf.createServerSocket();\n+        ss.bind(new InetSocketAddress(loopback, 0));\n+\n+        SSLSocketFactory sslsf =\n+            (SSLSocketFactory)SSLSocketFactory.getDefault();\n+        socket = (SSLSocket)sslsf.createSocket(loopback, ss.getLocalPort());\n+        SSLSocket serverSoc = (SSLSocket)ss.accept();\n+        ss.close();\n+\n+        (new Thread(this)).start();\n+        serverSoc.startHandshake();\n+\n+        boolean closeIsReady = closeCondition.await(90L, TimeUnit.SECONDS);\n+        if (!closeIsReady) {\n+            System.out.println(\n+                    \"Ignore, the closure is not ready yet in 90 seconds.\");\n+            return;\n+        }\n+\n+        socket.setSoLinger(true, 10);\n+        System.out.println(\"Calling Socket.close\");\n+\n+        \/\/ Sleep for a while so that the write thread blocks by hitting the\n+        \/\/ output stream buffer limit.\n+        Thread.sleep(1000);\n+\n+        socket.close();\n+        System.out.println(\"ssl socket get closed\");\n+        System.out.flush();\n+    }\n+\n+    \/\/ block in write\n+    public void run() {\n+        byte[] ba = new byte[1024];\n+        for (int i = 0; i < ba.length; i++) {\n+            ba[i] = 0x7A;\n+        }\n+\n+        try {\n+            OutputStream os = socket.getOutputStream();\n+            int count = 0;\n+\n+            \/\/ 1st round write\n+            count += ba.length;\n+            System.out.println(count + \" bytes to be written\");\n+            os.write(ba);\n+            System.out.println(count + \" bytes written\");\n+\n+            \/\/ Signal, ready to close.\n+            closeCondition.countDown();\n+\n+            \/\/ write more\n+            while (true) {\n+                count += ba.length;\n+                System.out.println(count + \" bytes to be written\");\n+                os.write(ba);\n+                System.out.println(count + \" bytes written\");\n+            }\n+        } catch (SocketException se) {\n+            \/\/ the closing may be in progress\n+            System.out.println(\"interrupted? \" + se);\n+        } catch (Exception e) {\n+            if (socket.isClosed() || socket.isOutputShutdown()) {\n+                System.out.println(\"interrupted, the socket is closed\");\n+            } else {\n+                throw new RuntimeException(\"interrupted?\", e);\n+            }\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSocketImpl\/BlockedAsyncClose.java","additions":147,"deletions":0,"binary":false,"changes":147,"status":"added"}]}