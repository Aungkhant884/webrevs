{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,0 +88,2 @@\n+    private static final float precisionScale = 1000.0f;\n+\n@@ -1720,0 +1722,5 @@\n+    private void precisionScaleUp(float[] values, int size) {\n+        for (int i = 0; i < size; i++) {\n+            values[i] = values[i] * precisionScale;\n+        }\n+    }\n@@ -1744,0 +1751,1 @@\n+        wPrinterJob.scaleTransform(1.0f \/ precisionScale);\n@@ -1751,0 +1759,1 @@\n+                precisionScaleUp(segment, 2);\n@@ -1755,0 +1764,1 @@\n+                precisionScaleUp(segment, 2);\n@@ -1761,0 +1771,1 @@\n+                precisionScaleUp(segment, 4);\n@@ -1773,0 +1784,1 @@\n+                precisionScaleUp(segment, 6);\n@@ -1788,0 +1800,1 @@\n+        wPrinterJob.restoreTransform();\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPathGraphics.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -365,0 +365,3 @@\n+    private int graphicsMode;\n+    private double[] worldTransform = new double[6];\n+\n@@ -963,0 +966,11 @@\n+    protected void scaleTransform(float scale) {\n+        graphicsMode = setAdvancedGraphicsMode();\n+        getWorldTransform(worldTransform);\n+        scale(scale, scale);\n+    }\n+\n+    protected void restoreTransform() {\n+        setWorldTransform(worldTransform);\n+        setGraphicsMode(graphicsMode);\n+    }\n+\n@@ -998,0 +1012,38 @@\n+    \/**\n+     * Set the GDI graphics mode to {@code GM_ADVANCED}.\n+     *\/\n+    private int setAdvancedGraphicsMode() {\n+        return setAdvancedGraphicsMode(getPrintDC());\n+    }\n+\n+    \/**\n+     * Set the GDI graphics mode.\n+     * The {@code mode} should\n+     * be one of the following Windows constants:\n+     * {@code GM_COMPATIBLE} or {@code GM_ADVANCED}.\n+     *\/\n+    private void setGraphicsMode(int mode) {\n+        setGraphicsMode(getPrintDC(), mode);\n+    }\n+\n+    \/**\n+     * Scale the GDI World Transform.\n+     *\/\n+    private void scale(double scaleX, double scaleY) {\n+        scale(getPrintDC(), scaleX, scaleY);\n+    }\n+\n+    \/**\n+     * Get the GDI World Transform.\n+     *\/\n+    private void getWorldTransform(double[] transform) {\n+        getWorldTransform(getPrintDC(), transform);\n+    }\n+\n+    \/**\n+     * Set the GDI World Transform.\n+     *\/\n+    private void setWorldTransform(double[] transform) {\n+        setWorldTransform(getPrintDC(), transform);\n+    }\n+\n@@ -1477,0 +1529,33 @@\n+    \/**\n+     * Set the GDI graphics mode to {@code GM_ADVANCED}\n+     * into the device context {@code printDC}.\n+     *\/\n+    protected native int setAdvancedGraphicsMode(long printDC);\n+\n+    \/**\n+     * Set the GDI graphics {@code mode}\n+     * into the device context {@code printDC}.\n+     * The {@code mode} should\n+     * be one of the following Windows constants:\n+     * {@code GM_COMPATIBLE} or {@code GM_ADVANCED}.\n+     *\/\n+    protected native void setGraphicsMode(long printDC, int mode);\n+\n+    \/**\n+     * Scale the GDI World Transform\n+     * of the device context {@code printDC}.\n+     *\/\n+    protected native void scale(long printDC, double scaleX, double scaleY);\n+\n+    \/**\n+     * Get the GDI World Transform\n+     * from the device context {@code printDC}.\n+     *\/\n+    protected native void getWorldTransform(long printDC, double[] transform);\n+\n+    \/**\n+     * Set the GDI World Transform\n+     * into the device context {@code printDC}.\n+     *\/\n+    protected native void setWorldTransform(long printDC, double[] transform);\n+\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WPrinterJob.java","additions":86,"deletions":1,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1930,0 +1930,111 @@\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setAdvancedGraphicsMode\n+ * Signature: (J)I\n+ *\/\n+JNIEXPORT jint JNICALL Java_sun_awt_windows_WPrinterJob_setAdvancedGraphicsMode\n+(JNIEnv *env, jobject self, jlong printDC) {\n+    TRY;\n+\n+    int oldGraphicsMode = ::SetGraphicsMode((HDC)printDC, GM_ADVANCED);\n+    DASSERT(oldGraphicsMode != 0);\n+    return (jint) oldGraphicsMode;\n+\n+    CATCH_BAD_ALLOC_RET(0);\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setGraphicsMode\n+ * Signature: (JI)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_setGraphicsMode\n+(JNIEnv *env, jobject self, jlong printDC, jint mode) {\n+    TRY;\n+\n+    int oldGraphicsMode = ::SetGraphicsMode((HDC)printDC, mode);\n+    DASSERT(oldGraphicsMode != 0);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    scale\n+ * Signature: (JDD)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_scale\n+(JNIEnv *env, jobject self, jlong printDC, jdouble scaleX, jdouble scaleY) {\n+    TRY;\n+\n+    XFORM xForm;\n+\n+    xForm.eM11 = (FLOAT) scaleX;\n+    xForm.eM12 = (FLOAT) 0;\n+    xForm.eM21 = (FLOAT) 0;\n+    xForm.eM22 = (FLOAT) scaleY;\n+    xForm.eDx  = (FLOAT) 0;\n+    xForm.eDy  = (FLOAT) 0;\n+\n+    BOOL result = ::ModifyWorldTransform((HDC)printDC, &xForm, MWT_RIGHTMULTIPLY);\n+    DASSERT(result);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    getWorldTransform\n+ * Signature: (J[D)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_getWorldTransform\n+(JNIEnv* env, jobject self, jlong printDC, jdoubleArray transform) {\n+    TRY;\n+\n+    double elems[6];\n+    XFORM xForm;\n+\n+    BOOL result = ::GetWorldTransform((HDC)printDC, &xForm);\n+    DASSERT(result);\n+\n+    elems[0] = (double) xForm.eM11;\n+    elems[1] = (double) xForm.eM12;\n+    elems[2] = (double) xForm.eM21;\n+    elems[3] = (double) xForm.eM22;\n+    elems[4] = (double) xForm.eDx;\n+    elems[5] = (double) xForm.eDy;\n+\n+    env->SetDoubleArrayRegion(transform, 0, 6, elems);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n+\/*\n+ * Class:     sun_awt_windows_WPrinterJob\n+ * Method:    setWorldTransform\n+ * Signature: (J[D)V\n+ *\/\n+JNIEXPORT void JNICALL Java_sun_awt_windows_WPrinterJob_setWorldTransform\n+(JNIEnv* env, jobject self, jlong printDC, jdoubleArray transform) {\n+    TRY;\n+\n+    double *elems;\n+    XFORM xForm;\n+\n+    elems = env->GetDoubleArrayElements(transform, 0);\n+\n+    xForm.eM11 = (FLOAT) elems[0];\n+    xForm.eM12 = (FLOAT) elems[1];\n+    xForm.eM21 = (FLOAT) elems[2];\n+    xForm.eM22 = (FLOAT) elems[3];\n+    xForm.eDx  = (FLOAT) elems[4];\n+    xForm.eDy  = (FLOAT) elems[5];\n+\n+    env->ReleaseDoubleArrayElements(transform, elems, 0);\n+\n+    BOOL result = ::SetWorldTransform((HDC)printDC, &xForm);\n+    DASSERT(result);\n+\n+    CATCH_BAD_ALLOC;\n+}\n+\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_PrintJob.cpp","additions":112,"deletions":1,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -0,0 +1,265 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262470\n+ * @requires (os.family == \"windows\")\n+ * @summary Check thay shapes are properly painted with the precision scale factor\n+ * @run main\/othervm\/manual PathPrecisionScaleFactorShapeTest\n+ *\/\n+\n+import javax.print.PrintServiceLookup;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Line2D;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.geom.QuadCurve2D;\n+import java.awt.geom.CubicCurve2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PathPrecisionScaleFactorShapeTest {\n+\n+    private static final String DESCRIPTION =\n+            \" 1. Setup 'Microsoft Print to PDF' printer on Windows.\\n\" +\n+                    \" 2. Press Print button to print shapes with labels to PDF.\\n\" +\n+                    \" 3. Choose 'Microsoft Print to PDF' on the print dialog and press OK\\n\" +\n+                    \" 3. Open the PDF file and check that following shapes with labels are printed:\\n\" +\n+                    \"    Line\\n\" +\n+                    \"    Line2D\\n\" +\n+                    \"    QuadCurve2D\\n\" +\n+                    \"    CubicCurve2D\\n\" +\n+                    \" 4. If so, press PASS button, otherwise press FAIL button.\\n\";\n+\n+    private static final CountDownLatch testEndedSignal = new CountDownLatch(1);\n+    private static final int testTimeout = 300000;\n+    private static volatile String testFailureMsg;\n+    private static volatile boolean testPassed;\n+    private static volatile boolean testFinished;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        SwingUtilities.invokeLater(() -> createAndShowTestDialog());\n+\n+        try {\n+            if (!testEndedSignal.await(testTimeout, TimeUnit.MILLISECONDS)) {\n+                throw new RuntimeException(String.format(\n+                        \"Test timeout '%d ms' elapsed.\", testTimeout));\n+            }\n+            if (!testPassed) {\n+                String failureMsg = testFailureMsg;\n+                if ((failureMsg != null) && (!failureMsg.trim().isEmpty())) {\n+                    throw new RuntimeException(failureMsg);\n+                } else {\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } finally {\n+            testFinished = true;\n+        }\n+    }\n+\n+    private static void pass() {\n+        testPassed = true;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static void fail(String failureMsg) {\n+        testFailureMsg = failureMsg;\n+        testPassed = false;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static String convertMillisToTimeStr(int millis) {\n+        if (millis < 0) {\n+            return \"00:00:00\";\n+        }\n+        int hours = millis \/ 3600000;\n+        int minutes = (millis - hours * 3600000) \/ 60000;\n+        int seconds = (millis - hours * 3600000 - minutes * 60000) \/ 1000;\n+        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    private static void createAndShowTestDialog() {\n+\n+        final JDialog dialog = new JDialog();\n+        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+                fail(\"Main dialog was closed.\");\n+            }\n+        });\n+\n+        final JLabel testTimeoutLabel = new JLabel(String.format(\n+                \"Test timeout: %s\", convertMillisToTimeStr(testTimeout)));\n+        final long startTime = System.currentTimeMillis();\n+        final Timer timer = new Timer(0, null);\n+        timer.setDelay(1000);\n+        timer.addActionListener((e) -> {\n+            int leftTime = testTimeout - (int) (System.currentTimeMillis() - startTime);\n+            if ((leftTime < 0) || testFinished) {\n+                timer.stop();\n+                dialog.dispose();\n+            }\n+            testTimeoutLabel.setText(String.format(\n+                    \"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n+        });\n+        timer.start();\n+\n+        JTextArea textArea = new JTextArea(DESCRIPTION);\n+        textArea.setEditable(false);\n+\n+        final JButton testButton = new JButton(\"Print\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        final JButton failButton = new JButton(\"FAIL\");\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            new Thread(() -> {\n+                try {\n+                    doTest();\n+\n+                    SwingUtilities.invokeLater(() -> {\n+                        passButton.setEnabled(true);\n+                        failButton.setEnabled(true);\n+                    });\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    dialog.dispose();\n+                    fail(\"Exception occurred in a thread executing the test.\");\n+                }\n+            }).start();\n+        });\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            pass();\n+        });\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            fail(\"TitledBorder label is cut off\");\n+        });\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        JPanel labelPanel = new JPanel(new FlowLayout());\n+        labelPanel.add(testTimeoutLabel);\n+        mainPanel.add(labelPanel, BorderLayout.NORTH);\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                new PathPrecisionScaleFactorPrintable();\n+            } catch (PrinterException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private static class PathPrecisionScaleFactorPrintable implements Printable {\n+\n+        PathPrecisionScaleFactorPrintable() throws PrinterException {\n+            PrinterJob job = PrinterJob.getPrinterJob();\n+            job.setPrintService(PrintServiceLookup.lookupDefaultPrintService());\n+            job.setPrintable(this);\n+\n+            if (job.printDialog()) {\n+                job.print();\n+            } else {\n+                throw new RuntimeException(\"Printing was canceled!\");\n+            }\n+        }\n+\n+        void paint(Graphics2D g) {\n+\n+            Rectangle clip = g.getClipBounds();\n+\n+            int x =  (int) clip.getX() + 10;\n+            int y = (int) clip.getY() + 20;\n+            int dy = ((int) clip.getHeight() - y) \/ 8;\n+\n+            int l = 80;\n+            int sx = x + l + 10;\n+\n+            g.drawLine(x, y, x + l, y);\n+            drawGlyphVector(g, sx, y, \"Line\");\n+\n+            y+= dy;\n+            g.draw(new Line2D.Float(x, y, x + l, y));\n+            drawGlyphVector(g, sx, y, \"Line2D\");\n+\n+            y+= dy;\n+            g.draw(new QuadCurve2D.Float(x, y, x + l \/ 2, y + l \/ 2, x + l, y));\n+            drawGlyphVector(g, sx, y, \"QuadCurve2D\");\n+\n+            y+= dy;\n+            g.draw(new CubicCurve2D.Float(x, y, x + l \/ 3, y + l \/ 3, x + 2 * l \/ 3, y - l \/ 3, x + l, y));\n+            drawGlyphVector(g, sx, y, \"CubicCurve2D\");\n+        }\n+\n+        private static void drawGlyphVector(Graphics2D g, int x, int y, String text) {\n+\n+            Font font = new Font(\"Times New Roman\", Font.PLAIN, 8);\n+            g.setFont(font);\n+            FontRenderContext frc = new FontRenderContext(new AffineTransform(), false, true);\n+\n+            GlyphVector gv = font.createGlyphVector(frc, text);\n+            g.fill(gv.getOutline(x, y));\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int index) {\n+            if (index == 0) {\n+                paint((Graphics2D) graphics);\n+                return PAGE_EXISTS;\n+            } else {\n+                return NO_SUCH_PAGE;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PathPrecisionScaleFactor\/PathPrecisionScaleFactorShapeTest.java","additions":265,"deletions":0,"binary":false,"changes":265,"status":"added"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, BELLSOFT. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8262470\n+ * @requires (os.family == \"windows\")\n+ * @summary Check that a GlyphVector outline is printed with good quility on low dpi printers\n+ * @run main\/othervm\/manual PathPrecisionScaleFactorTextTest\n+ *\/\n+\n+import javax.print.PrintServiceLookup;\n+import javax.swing.*;\n+import java.awt.*;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.awt.font.FontRenderContext;\n+import java.awt.font.GlyphVector;\n+import java.awt.geom.AffineTransform;\n+import java.awt.geom.Rectangle2D;\n+import java.awt.print.PageFormat;\n+import java.awt.print.Printable;\n+import java.awt.print.PrinterException;\n+import java.awt.print.PrinterJob;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+public class PathPrecisionScaleFactorTextTest {\n+\n+    private static final String DESCRIPTION =\n+            \" 1. Setup 'Microsoft Print to PDF' printer on Windows.\\n\" +\n+                    \" 2. Press Print button to print the text to PDF.\\n\" +\n+                    \" 3. Choose 'Microsoft Print to PDF' on the print dialog and press OK\\n\" +\n+                    \"    Two strings should be printed.\\n\" +\n+                    \"    The first line is printed using drawString() method\\n\" +\n+                    \"    and the second line is printed using filling glyph vector outline.\\n\" +\n+                    \" 3. Open the PDF file, zoom in the text and check that chars on the second line\\n\" +\n+                    \"    (especially 'a' and 's') are not distorted and have the similar quality\\n\" +\n+                    \"     as on the first line.\\n\" +\n+                    \" 4. If so, press PASS button, otherwise press FAIL button.\\n\";\n+\n+    private static final CountDownLatch testEndedSignal = new CountDownLatch(1);\n+    private static final int testTimeout = 300000;\n+    private static volatile String testFailureMsg;\n+    private static volatile boolean testPassed;\n+    private static volatile boolean testFinished;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        SwingUtilities.invokeLater(() -> createAndShowTestDialog());\n+\n+        try {\n+            if (!testEndedSignal.await(testTimeout, TimeUnit.MILLISECONDS)) {\n+                throw new RuntimeException(String.format(\n+                        \"Test timeout '%d ms' elapsed.\", testTimeout));\n+            }\n+            if (!testPassed) {\n+                String failureMsg = testFailureMsg;\n+                if ((failureMsg != null) && (!failureMsg.trim().isEmpty())) {\n+                    throw new RuntimeException(failureMsg);\n+                } else {\n+                    throw new RuntimeException(\"Test failed.\");\n+                }\n+            }\n+        } catch (InterruptedException ie) {\n+            throw new RuntimeException(ie);\n+        } finally {\n+            testFinished = true;\n+        }\n+    }\n+\n+    private static void pass() {\n+        testPassed = true;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static void fail(String failureMsg) {\n+        testFailureMsg = failureMsg;\n+        testPassed = false;\n+        testEndedSignal.countDown();\n+    }\n+\n+    private static String convertMillisToTimeStr(int millis) {\n+        if (millis < 0) {\n+            return \"00:00:00\";\n+        }\n+        int hours = millis \/ 3600000;\n+        int minutes = (millis - hours * 3600000) \/ 60000;\n+        int seconds = (millis - hours * 3600000 - minutes * 60000) \/ 1000;\n+        return String.format(\"%02d:%02d:%02d\", hours, minutes, seconds);\n+    }\n+\n+    private static void createAndShowTestDialog() {\n+\n+        final JDialog dialog = new JDialog();\n+        dialog.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n+        dialog.addWindowListener(new WindowAdapter() {\n+            @Override\n+            public void windowClosing(WindowEvent e) {\n+                dialog.dispose();\n+                fail(\"Main dialog was closed.\");\n+            }\n+        });\n+\n+        final JLabel testTimeoutLabel = new JLabel(String.format(\n+                \"Test timeout: %s\", convertMillisToTimeStr(testTimeout)));\n+        final long startTime = System.currentTimeMillis();\n+        final Timer timer = new Timer(0, null);\n+        timer.setDelay(1000);\n+        timer.addActionListener((e) -> {\n+            int leftTime = testTimeout - (int) (System.currentTimeMillis() - startTime);\n+            if ((leftTime < 0) || testFinished) {\n+                timer.stop();\n+                dialog.dispose();\n+            }\n+            testTimeoutLabel.setText(String.format(\n+                    \"Test timeout: %s\", convertMillisToTimeStr(leftTime)));\n+        });\n+        timer.start();\n+\n+        JTextArea textArea = new JTextArea(DESCRIPTION);\n+        textArea.setEditable(false);\n+\n+        final JButton testButton = new JButton(\"Print\");\n+        final JButton passButton = new JButton(\"PASS\");\n+        final JButton failButton = new JButton(\"FAIL\");\n+        testButton.addActionListener((e) -> {\n+            testButton.setEnabled(false);\n+            new Thread(() -> {\n+                try {\n+                    doTest();\n+\n+                    SwingUtilities.invokeLater(() -> {\n+                        passButton.setEnabled(true);\n+                        failButton.setEnabled(true);\n+                    });\n+                } catch (Throwable t) {\n+                    t.printStackTrace();\n+                    dialog.dispose();\n+                    fail(\"Exception occurred in a thread executing the test.\");\n+                }\n+            }).start();\n+        });\n+        passButton.setEnabled(false);\n+        passButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            pass();\n+        });\n+        failButton.setEnabled(false);\n+        failButton.addActionListener((e) -> {\n+            dialog.dispose();\n+            fail(\"TitledBorder label is cut off\");\n+        });\n+\n+        JPanel mainPanel = new JPanel(new BorderLayout());\n+        JPanel labelPanel = new JPanel(new FlowLayout());\n+        labelPanel.add(testTimeoutLabel);\n+        mainPanel.add(labelPanel, BorderLayout.NORTH);\n+        mainPanel.add(textArea, BorderLayout.CENTER);\n+        JPanel buttonPanel = new JPanel(new FlowLayout());\n+        buttonPanel.add(testButton);\n+        buttonPanel.add(passButton);\n+        buttonPanel.add(failButton);\n+        mainPanel.add(buttonPanel, BorderLayout.SOUTH);\n+        dialog.add(mainPanel);\n+\n+        dialog.pack();\n+        dialog.setVisible(true);\n+    }\n+\n+    private static void doTest() throws Exception {\n+        SwingUtilities.invokeAndWait(() -> {\n+            try {\n+                new PathPrecisionScaleFactorPrintable();\n+            } catch (PrinterException e) {\n+                throw new RuntimeException(e);\n+            }\n+        });\n+    }\n+\n+    private static class PathPrecisionScaleFactorPrintable implements Printable {\n+\n+        PathPrecisionScaleFactorPrintable() throws PrinterException {\n+            PrinterJob job = PrinterJob.getPrinterJob();\n+            job.setPrintService(PrintServiceLookup.lookupDefaultPrintService());\n+            job.setPrintable(this);\n+\n+            if (job.printDialog()) {\n+                job.print();\n+            } else {\n+                throw new RuntimeException(\"Printing was canceled!\");\n+            }\n+        }\n+\n+        void paint(Graphics2D g) {\n+\n+            String text = \"abcdefghijklmnopqrstuvwxyz\";\n+            Font font = new Font(\"Times New Roman\", Font.PLAIN, 8);\n+            drawText(g, font, text);\n+        }\n+\n+        private static void drawText(Graphics2D g, Font font, String text) {\n+\n+            g.setFont(font);\n+            FontRenderContext frc = new FontRenderContext(new AffineTransform(), false, true);\n+\n+            Rectangle clip = g.getClipBounds();\n+            int cx = (int) clip.getCenterX();\n+            int cy = (int) clip.getCenterY();\n+\n+            FontMetrics metrics = g.getFontMetrics();\n+            int w = metrics.stringWidth(text);\n+            int h = metrics.getHeight();\n+\n+            int x = cx - w \/ 2;\n+            int y = cy - h \/ 2;\n+\n+            g.drawString(text + \" [draw string]\", x, y);\n+            GlyphVector gv = font.createGlyphVector(frc, text + \" [glyph vector]\");\n+            g.fill(gv.getOutline(x, y + h));\n+        }\n+\n+        @Override\n+        public int print(Graphics graphics, PageFormat pageFormat, int index) {\n+            if (index == 0) {\n+                paint((Graphics2D) graphics);\n+                return PAGE_EXISTS;\n+            } else {\n+                return NO_SUCH_PAGE;\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/print\/PathPrecisionScaleFactor\/PathPrecisionScaleFactorTextTest.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"}]}