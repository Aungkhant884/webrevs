{"files":[{"patch":"@@ -0,0 +1,187 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\/*\n+ * @test\n+ * @bug 8271459\n+ * @requires vm.compiler2.enabled\n+ * @summary C2 applies string opts to StringBuilder object created with a negative size and misses the NegativeArraySizeException.\n+ * @run testng TestNegativeStringBuilderCapacity\n+ *\/\n+class TestNegativeStringBuilderCapacity {\n+\n+    static final int pass_count = 100;\n+\n+    static final String doIdenticalPositiveConst() throws Throwable {\n+        \/\/ C2 knows that argument is 5 and applies string opts without runtime check.\n+        StringBuilder sb = new StringBuilder(5); \/\/ StringBuilder object optimized away by string opts.\n+        return sb.toString(); \/\/ Call optimized away by string opts.\n+    }\n+\n+    @Test\n+    static final void testIdenticalPositiveConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doIdenticalPositiveConst();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, 0, String.format(\"%d exception were thrown, 0 expected\", throw_count));\n+    }\n+\n+    static final String doIdenticalNegativeConst() throws Throwable {\n+        \/\/ C2 knows that we always have a negative int -> bail out of string opts\n+        StringBuilder sb = new StringBuilder(-5);\n+        return sb.toString(); \/\/ Call stays due to bailout.\n+    }\n+\n+    @Test\n+    static final void testIdenticalNegativeConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doIdenticalNegativeConst();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count));\n+    }\n+\n+    static int aField;\n+\n+    static final String doField() throws Throwable {\n+        \/\/ C2 does not know if iFld is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter\n+        StringBuilder sb = new StringBuilder(aField);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    static final void testPositiveField() {\n+        aField = 4;\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doField();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, 0, String.format(\"%d exception were thrown, 0 expected\", throw_count));\n+    }\n+\n+    @Test\n+    static final void testNegativeField() {\n+        aField = -4;\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doField();\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count));\n+    }\n+\n+    static final String doPossiblyNegativeConst(boolean flag) throws Throwable {\n+        \/\/ C2 knows that cap is between -5 and 5. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path is sometimes taken and sometimes not.\n+        final int capacity = flag ? 5 : -5;\n+        StringBuilder sb = new StringBuilder(capacity);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    static final void testPossiblyNegativeConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doPossiblyNegativeConst((pass % 2) == 0);\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count\/2, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count\/2));\n+    }\n+\n+    static final String doPositiveConst(boolean flag) throws Throwable {\n+        \/\/ C2 knows that cap is between 1 and 100 and applies string opts without runtime check.\n+        final int capacity = flag ? 1 : 100;\n+        StringBuilder sb = new StringBuilder(capacity);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    static final void testPositiveConst() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doPositiveConst((pass % 2) == 0);\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, 0, String.format(\"%d exception were thrown, 0 expected\", throw_count));\n+    }\n+\n+    static final String doArg(int capacity) throws Throwable {\n+        \/\/ C2 does not know if cap is positive or negative. It applies string opts but inserts a runtime check to\n+        \/\/ bail out to interpreter. This path is always taken because cap is always negative.\n+        StringBuilder sb = new StringBuilder(capacity);\n+        return sb.toString();\n+    }\n+\n+    @Test\n+    static final void testArg() {\n+        int throw_count = 0;\n+        for ( int pass = 0; pass < pass_count; pass++ ) {\n+            try {\n+                String s = doArg((pass % 2) == 0 ? 3 : -3 );\n+            } catch (NegativeArraySizeException e) {\n+                throw_count++;\n+            } catch (Throwable e) {\n+                Assert.fail(\"Unexpected exception thrown\");\n+            }\n+        }\n+        Assert.assertEquals( throw_count, pass_count\/2, String.format(\"%d exception were thrown, %d expected\", throw_count, pass_count\/2));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestNegativeStringBuilderCapacity.java","additions":187,"deletions":0,"binary":false,"changes":187,"status":"added"}]}