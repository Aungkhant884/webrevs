{"files":[{"patch":"@@ -1848,0 +1848,20 @@\n+\/\/ This function is used by find_unique_concrete_method(non vtable based)\n+\/\/ to check whether subtype method overrides the base method.\n+static bool overrides(Method* sub_m, Method* base_m) {\n+  assert(base_m != NULL, \"base method should be non null\");\n+  if (sub_m == NULL) {\n+    return false;\n+  }\n+  \/**\n+   *  If base_m is public or protected then sub_m always overrides.\n+   *  If base_m is !public, !protected and !private (i.e. base_m is package private)\n+   *  then sub_m should be in the same package as that of base_m.\n+   *  For package private base_m this is conservative approach as it allows only subset of all allowed cases in\n+   *  the jvm specification.\n+   **\/\n+  if (base_m->is_public() || base_m->is_protected() ||\n+      base_m->method_holder()->is_same_class_package(sub_m->method_holder())) {\n+    return true;\n+  }\n+  return false;\n+}\n@@ -1876,0 +1896,3 @@\n+  } else if (!overrides(fm, m)) {\n+    \/\/ Found method doesn't override abstract root method.\n+    return NULL;\n","filename":"src\/hotspot\/share\/code\/dependencies.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2839,0 +2839,12 @@\n+      if (!ok->is_instance_klass()) {\n+        \/\/ If the outer class is not an instance klass then it cannot have\n+        \/\/ declared any inner classes.\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(\n+          THREAD_AND_LOCATION,\n+          vmSymbols::java_lang_IncompatibleClassChangeError(),\n+          \"%s and %s disagree on InnerClasses attribute\",\n+          ok->external_name(),\n+          external_name());\n+        return NULL;\n+      }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -811,1 +811,1 @@\n-                throw new OutOfMemoryError(\"Required array size too large\");\n+                throw new IOException(\"Unsupported size: \" + uncompressedSize);\n","filename":"src\/java.base\/share\/classes\/java\/util\/jar\/JarFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -570,0 +570,3 @@\n+        \/\/ A map used to check duplicated handshake messages.\n+        HashMap<Byte, Integer> messageSeqMap;\n+\n@@ -580,0 +583,1 @@\n+            this.messageSeqMap = new HashMap<>(5);\n@@ -601,0 +605,1 @@\n+            hf.messageSeqMap = new HashMap<>(this.messageSeqMap);\n@@ -643,1 +648,1 @@\n-        void queueUpHandshake(HandshakeFragment hsf) {\n+        void queueUpHandshake(HandshakeFragment hsf) throws SSLProtocolException {\n@@ -710,0 +715,1 @@\n+                handshakeFlight.messageSeqMap.put(hsf.handshakeType, hsf.messageSeq);\n@@ -781,1 +787,2 @@\n-        void queueUpChangeCipherSpec(RecordFragment rf) {\n+        void queueUpChangeCipherSpec(RecordFragment rf)\n+                throws SSLProtocolException {\n@@ -810,1 +817,1 @@\n-        void queueUpFragment(RecordFragment rf) {\n+        void queueUpFragment(RecordFragment rf) throws SSLProtocolException {\n@@ -898,1 +905,1 @@\n-        private boolean isDesirable(RecordFragment rf) {\n+        private boolean isDesirable(RecordFragment rf) throws SSLProtocolException {\n@@ -973,0 +980,21 @@\n+            \/\/ Unexpected duplicated handshake messages.\n+            if (rf.recordEpoch == handshakeEpoch &&\n+                    \/\/ For handshake messages only.\n+                    rf instanceof HandshakeFragment) {\n+                HandshakeFragment hsf = (HandshakeFragment) rf;\n+                                    \/\/ Check on the received handshake messages.\n+                if (handshakeFlight.holesMap.containsKey(hsf.handshakeType)) {\n+                    Integer cachedMsgSeq = handshakeFlight.messageSeqMap.get(\n+                            hsf.handshakeType);\n+                    if (cachedMsgSeq != null && cachedMsgSeq != hsf.messageSeq) {\n+                        \/\/ Handshake messages of the same type but with different\n+                        \/\/ message sequence numbers are not allowed.\n+                        throw new SSLProtocolException(\n+                                \"Two message sequence numbers are used for the \"\n+                              + \"same handshake message (\"\n+                              + SSLHandshake.nameOf(hsf.handshakeType)\n+                              + \")\");\n+                    }\n+                }\n+            }\n+\n@@ -1089,0 +1117,3 @@\n+            \/\/ cleanup handshake message sequence numbers map\n+            handshakeFlight.messageSeqMap.clear();\n+\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSInputRecord.java","additions":35,"deletions":4,"binary":false,"changes":39,"status":"modified"}]}