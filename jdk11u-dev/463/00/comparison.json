{"files":[{"patch":"@@ -49,11 +49,7 @@\n-\/\/------------------------------is_loop_iv-------------------------------------\n-\/\/ Determine if a node is Counted loop induction variable.\n-\/\/ The method is declared in node.hpp.\n-const Node* Node::is_loop_iv() const {\n-  if (this->is_Phi() && !this->as_Phi()->is_copy() &&\n-      this->as_Phi()->region()->is_CountedLoop() &&\n-      this->as_Phi()->region()->as_CountedLoop()->phi() == this) {\n-    return this;\n-  } else {\n-    return NULL;\n-  }\n+\/\/--------------------------is_cloop_ind_var-----------------------------------\n+\/\/ Determine if a node is a counted loop induction variable.\n+\/\/ NOTE: The method is declared in \"node.hpp\".\n+bool Node::is_cloop_ind_var() const {\n+  return (is_Phi() && !as_Phi()->is_copy() &&\n+          as_Phi()->region()->is_CountedLoop() &&\n+          as_Phi()->region()->as_CountedLoop()->phi() == this);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -1024,3 +1024,3 @@\n-  \/\/ Determine if a node is Counted loop induction variable.\n-  \/\/ The method is defined in loopnode.cpp.\n-  const Node* is_loop_iv() const;\n+  \/\/ Determine if a node is a counted loop induction variable.\n+  \/\/ NOTE: The method is defined in \"loopnode.cpp\".\n+  bool is_cloop_ind_var() const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -117,1 +117,0 @@\n-\n@@ -119,22 +118,14 @@\n-static bool ok_to_convert(Node* inc, Node* iv) {\n-    \/\/ Do not collapse (x+c0)-y if \"+\" is a loop increment, because the\n-    \/\/ \"-\" is loop invariant and collapsing extends the live-range of \"x\"\n-    \/\/ to overlap with the \"+\", forcing another register to be used in\n-    \/\/ the loop.\n-    \/\/ This test will be clearer with '&&' (apply DeMorgan's rule)\n-    \/\/ but I like the early cutouts that happen here.\n-    const PhiNode *phi;\n-    if( ( !inc->in(1)->is_Phi() ||\n-          !(phi=inc->in(1)->as_Phi()) ||\n-          phi->is_copy() ||\n-          !phi->region()->is_CountedLoop() ||\n-          inc != phi->region()->as_CountedLoop()->incr() )\n-       &&\n-        \/\/ Do not collapse (x+c0)-iv if \"iv\" is a loop induction variable,\n-        \/\/ because \"x\" maybe invariant.\n-        ( !iv->is_loop_iv() )\n-      ) {\n-      return true;\n-    } else {\n-      return false;\n-    }\n+\n+static bool is_cloop_increment(Node* inc) {\n+  precond(inc->Opcode() == Op_AddI || inc->Opcode() == Op_AddL);\n+\n+  if (!inc->in(1)->is_Phi()) {\n+    return false;\n+  }\n+  const PhiNode* phi = inc->in(1)->as_Phi();\n+\n+  if (phi->is_copy() || !phi->region()->is_CountedLoop()) {\n+    return false;\n+  }\n+\n+  return inc == phi->region()->as_CountedLoop()->incr();\n@@ -142,0 +133,15 @@\n+\n+\/\/ Given the expression '(x + C) - v', or\n+\/\/                      'v - (x + C)', we examine nodes '+' and 'v':\n+\/\/\n+\/\/  1. Do not convert if '+' is a counted-loop increment, because the '-' is\n+\/\/     loop invariant and converting extends the live-range of 'x' to overlap\n+\/\/     with the '+', forcing another register to be used in the loop.\n+\/\/\n+\/\/  2. Do not convert if 'v' is a counted-loop induction variable, because\n+\/\/     'x' might be invariant.\n+\/\/\n+static bool ok_to_convert(Node* inc, Node* var) {\n+  return !(is_cloop_increment(inc) || var->is_cloop_ind_var());\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":29,"deletions":23,"binary":false,"changes":52,"status":"modified"}]}