{"files":[{"patch":"@@ -289,0 +289,3 @@\n+\n+  if (!phase->may_require_nodes(10, 10)) return NULL;\n+\n@@ -340,1 +343,1 @@\n-    };\n+    }\n@@ -345,4 +348,14 @@\n-\/\/ Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can\n-\/\/ make some loop-invariant test (usually a null-check) happen before the loop.\n-bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) const {\n-  IdealLoopTree *loop = (IdealLoopTree*)this;\n+\/\/ Return TRUE if the loop should be peeled, otherwise return FALSE. Peeling\n+\/\/ is applicable if we can make a loop-invariant test (usually a null-check)\n+\/\/ execute before we enter the loop. When TRUE, the estimated node budget is\n+\/\/ also requested.\n+bool IdealLoopTree::policy_peeling(PhaseIdealLoop *phase) {\n+  uint estimate = estimate_peeling(phase);\n+\n+  return estimate == 0 ? false : phase->may_require_nodes(estimate);\n+}\n+\n+\/\/ Perform actual policy and size estimate for the loop peeling transform, and\n+\/\/ return the estimated loop size if peeling is applicable, otherwise return\n+\/\/ zero. No node budget is allocated.\n+uint IdealLoopTree::estimate_peeling(PhaseIdealLoop *phase) {\n@@ -353,4 +366,3 @@\n-  uint body_size = loop->_body.size();\n-  \/\/ Peeling does loop cloning which can result in O(N^2) node construction\n-  if (body_size > 255) {\n-    return false;   \/\/ Prevent overflow for large body size\n+  \/\/ Peeling does loop cloning which can result in O(N^2) node construction.\n+  if (_body.size() > 255) {\n+    return 0;   \/\/ Suppress too large body size.\n@@ -358,1 +370,4 @@\n-  uint estimate = body_size * body_size;\n+  \/\/ Optimistic estimate that approximates loop body complexity via data and\n+  \/\/ control flow fan-out (instead of using the more pessimistic: BodySize^2).\n+  uint estimate = est_loop_clone_sz(2);\n+\n@@ -360,1 +375,1 @@\n-    return false;   \/\/ Too large to safely clone\n+    return 0;   \/\/ Too large to safely clone.\n@@ -363,1 +378,1 @@\n-  \/\/ check for vectorized loops, any peeling done was already applied\n+  \/\/ Check for vectorized loops, any peeling done was already applied.\n@@ -367,1 +382,1 @@\n-      return false;\n+      return 0;\n@@ -371,1 +386,1 @@\n-  Node* test = loop->tail();\n+  Node* test = tail();\n@@ -373,2 +388,2 @@\n-  while (test != _head) {       \/\/ Scan till run off top of loop\n-    if (test->is_If()) {        \/\/ Test?\n+  while (test != _head) {   \/\/ Scan till run off top of loop\n+    if (test->is_If()) {    \/\/ Test?\n@@ -377,1 +392,1 @@\n-        return false;           \/\/ Found dead test on live IF?  No peeling!\n+        return 0;           \/\/ Found dead test on live IF?  No peeling!\n@@ -379,1 +394,1 @@\n-      \/\/ Standard IF only has one input value to check for loop invariance\n+      \/\/ Standard IF only has one input value to check for loop invariance.\n@@ -386,2 +401,1 @@\n-        \/\/ Found reason to peel!\n-        return phase->may_require_nodes(estimate);\n+        return estimate;    \/\/ Found reason to peel!\n@@ -390,2 +404,2 @@\n-    \/\/ Walk up dominators to loop _head looking for test which is\n-    \/\/ executed on every path thru loop.\n+    \/\/ Walk up dominators to loop _head looking for test which is executed on\n+    \/\/ every path through the loop.\n@@ -394,1 +408,1 @@\n-  return false;\n+  return 0;\n@@ -645,1 +659,0 @@\n-\n@@ -647,0 +660,1 @@\n+\n@@ -664,1 +678,19 @@\n-#define EMPTY_LOOP_SIZE 7 \/\/ number of nodes in an empty loop\n+\/\/ The Estimated Loop Unroll Size: UnrollFactor * (106% * BodySize + BC) + CC,\n+\/\/ where BC  and CC are  (totally) ad-hoc\/magic \"body\" and  \"clone\" constants,\n+\/\/ respectively, used to ensure that node usage estimates made are on the safe\n+\/\/ side, for the  most part.  This is  a simplified version of  the loop clone\n+\/\/ size calculation in est_loop_clone_sz(),  defined for unroll factors larger\n+\/\/ than one  (>1), performing  an overflow check  and returning  'UINT_MAX' in\n+\/\/ case of an overflow.\n+static uint est_loop_unroll_sz(uint factor, uint size) {\n+  precond(0 < factor);\n+\n+  uint const bc = 5;\n+  uint const cc = 7;\n+  uint const sz = size + (size + 15) \/ 16;\n+  uint estimate = factor * (sz + bc) + cc;\n+\n+  return (estimate - cc) \/ factor == sz + bc ? estimate : UINT_MAX;\n+}\n+\n+#define EMPTY_LOOP_SIZE 7   \/\/ Number of nodes in an empty loop.\n@@ -667,2 +699,3 @@\n-\/\/ Calculate exact loop trip count and return true if loop can be maximally\n-\/\/ unrolled.\n+\/\/ Calculate the exact  loop trip-count and return TRUE if loop can be fully,\n+\/\/ i.e. maximally, unrolled, otherwise return FALSE. When TRUE, the estimated\n+\/\/ node budget is also requested.\n@@ -700,1 +733,1 @@\n-  uint new_body_size = est_loop_clone_sz(trip_count, body_size - EMPTY_LOOP_SIZE);\n+  uint new_body_size = est_loop_unroll_sz(trip_count, body_size - EMPTY_LOOP_SIZE);\n@@ -749,2 +782,3 @@\n-\/\/ Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if the\n-\/\/ loop is a CountedLoop and the body is small enough.\n+\/\/ Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll if\n+\/\/ the loop is  a counted loop and  the loop body is small  enough. When TRUE,\n+\/\/ the estimated node budget is also requested.\n@@ -894,1 +928,1 @@\n-  uint estimate = est_loop_clone_sz(2, body_size);\n+  uint estimate = est_loop_clone_sz(2);\n@@ -965,2 +999,4 @@\n-\/\/ Return TRUE or FALSE if the loop should be range-check-eliminated.\n-\/\/ Actually we do iteration-splitting, a more powerful form of RCE.\n+\/\/ Return TRUE or FALSE if the loop should be range-check-eliminated or not.\n+\/\/ When TRUE, the estimated node budget is also requested.\n+\/\/\n+\/\/ We will actually perform iteration-splitting, a more powerful form of RCE.\n@@ -974,3 +1010,3 @@\n-  \/\/ If we unrolled with no intention of doing RCE and we later\n-  \/\/ changed our minds, we got no pre-loop.  Either we need to\n-  \/\/ make a new pre-loop, or we gotta disallow RCE.\n+  \/\/ If we unrolled  with no intention of doing RCE and we  later changed our\n+  \/\/ minds, we got no pre-loop.  Either we need to make a new pre-loop, or we\n+  \/\/ have to disallow RCE.\n@@ -1023,3 +1059,3 @@\n-      \/\/ Found a test like 'trip+off vs  limit'.  Test is an IfNode, has two\n-      \/\/ (2) projections.  If BOTH are in  the loop we need loop unswitching\n-      \/\/ instead of iteration splitting.\n+      \/\/ Found a test like 'trip+off vs limit'. Test is an IfNode, has two (2)\n+      \/\/ projections. If BOTH are in the loop we need loop unswitching instead\n+      \/\/ of iteration splitting.\n@@ -1029,1 +1065,1 @@\n-        return phase->may_require_nodes(est_loop_clone_sz(2, _body.size()));\n+        return phase->may_require_nodes(est_loop_clone_sz(2));\n@@ -1612,3 +1648,0 @@\n-  if (!may_require_nodes(est_loop_clone_sz(2, loop->_body.size()))) {\n-    return;\n-  }\n@@ -1626,0 +1659,4 @@\n+  if (!may_require_nodes(loop->est_loop_clone_sz(2))) {\n+    return;\n+  }\n+\n@@ -3262,3 +3299,0 @@\n-  bool should_peel     = policy_peeling(phase);\n-  bool should_unswitch = policy_unswitching(phase);\n-\n@@ -3272,1 +3306,1 @@\n-    if (should_peel) {            \/\/ Should we peel?\n+    if (policy_peeling(phase)) {    \/\/ Should we peel?\n@@ -3274,2 +3308,2 @@\n-      phase->do_peeling(this,old_new);\n-    } else if (should_unswitch) {\n+      phase->do_peeling(this, old_new);\n+    } else if (policy_unswitching(phase)) {\n@@ -3294,1 +3328,1 @@\n-    if (should_unswitch) {\n+    if (policy_unswitching(phase)) {\n@@ -3298,2 +3332,1 @@\n-    bool should_maximally_unroll = policy_maximally_unroll(phase);\n-    if (should_maximally_unroll) {\n+    if (policy_maximally_unroll(phase)) {\n@@ -3307,0 +3340,3 @@\n+  uint est_peeling = estimate_peeling(phase);\n+  bool should_peel = 0 < est_peeling;\n+\n@@ -3337,1 +3373,2 @@\n-      if (!phase->may_require_nodes(est_loop_clone_sz(3, _body.size()))) {\n+      uint estimate = est_loop_clone_sz(3);\n+      if (!phase->may_require_nodes(estimate)) {\n@@ -3340,1 +3377,1 @@\n-      phase->insert_pre_post_loops(this,old_new, !may_rce_align);\n+      phase->insert_pre_post_loops(this, old_new, !may_rce_align);\n@@ -3342,3 +3379,3 @@\n-    \/\/ Adjust the pre- and main-loop limits to let the pre and post loops run\n-    \/\/ with full checks, but the main-loop with no checks.  Remove said\n-    \/\/ checks from the main body.\n+    \/\/ Adjust the pre- and main-loop limits to let the pre and  post loops run\n+    \/\/ with full checks, but the main-loop with no checks.  Remove said checks\n+    \/\/ from the main body.\n@@ -3378,1 +3415,3 @@\n-      phase->do_peeling(this,old_new);\n+      if (phase->may_require_nodes(est_peeling)) {\n+        phase->do_peeling(this, old_new);\n+      }\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":97,"deletions":58,"binary":false,"changes":155,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2006, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  return phase->may_require_nodes(est_loop_clone_sz(3, _body.size()));\n+  return phase->may_require_nodes(est_loop_clone_sz(2));\n@@ -119,1 +119,1 @@\n-void PhaseIdealLoop::do_unswitching (IdealLoopTree *loop, Node_List &old_new) {\n+void PhaseIdealLoop::do_unswitching(IdealLoopTree *loop, Node_List &old_new) {\n","filename":"src\/hotspot\/share\/opto\/loopUnswitch.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -2472,0 +2472,50 @@\n+\n+\/\/ The Estimated Loop Clone Size:\n+\/\/   CloneFactor * (~112% * BodySize + BC) + CC + FanOutTerm,\n+\/\/ where  BC and  CC are  totally ad-hoc\/magic  \"body\" and \"clone\" constants,\n+\/\/ respectively, used to ensure that the node usage estimates made are on the\n+\/\/ safe side, for the most part. The FanOutTerm is an attempt to estimate the\n+\/\/ possible additional\/excessive nodes generated due to data and control flow\n+\/\/ merging, for edges reaching outside the loop.\n+uint IdealLoopTree::est_loop_clone_sz(uint factor) const {\n+\n+  precond(0 < factor && factor < 16);\n+\n+  uint const bc = 13;\n+  uint const cc = 17;\n+  uint const sz = _body.size() + (_body.size() + 7) \/ 8;\n+  uint estimate = factor * (sz + bc) + cc;\n+\n+  assert((estimate - cc) \/ factor == sz + bc, \"overflow\");\n+\n+  uint ctrl_edge_out_cnt = 0;\n+  uint data_edge_out_cnt = 0;\n+\n+  for (uint i = 0; i < _body.size(); i++) {\n+    Node* node = _body.at(i);\n+    uint outcnt = node->outcnt();\n+\n+    for (uint k = 0; k < outcnt; k++) {\n+      Node* out = node->raw_out(k);\n+\n+      if (out->is_CFG()) {\n+        if (!is_member(_phase->get_loop(out))) {\n+          ctrl_edge_out_cnt++;\n+        }\n+      } else {\n+        Node* ctrl = _phase->get_ctrl(out);\n+        assert(ctrl->is_CFG(), \"must be\");\n+        if (!is_member(_phase->get_loop(ctrl))) {\n+          data_edge_out_cnt++;\n+        }\n+      }\n+    }\n+  }\n+  \/\/ Add data (x1.5) and control (x1.0) count to estimate iff both are > 0.\n+  if (ctrl_edge_out_cnt > 0 && data_edge_out_cnt > 0) {\n+    estimate += ctrl_edge_out_cnt + data_edge_out_cnt + data_edge_out_cnt \/ 2;\n+  }\n+\n+  return estimate;\n+}\n+\n@@ -2475,2 +2525,2 @@\n-void IdealLoopTree::dump_head( ) const {\n-  for (uint i=0; i<_nest; i++)\n+void IdealLoopTree::dump_head() const {\n+  for (uint i = 0; i < _nest; i++) {\n@@ -2478,0 +2528,1 @@\n+  }\n@@ -2546,1 +2597,1 @@\n-void IdealLoopTree::dump( ) const {\n+void IdealLoopTree::dump() const {\n@@ -2973,2 +3024,2 @@\n-  if(VerifyLoopOptimizations) verify();\n-  if(TraceLoopOpts && C->has_loops()) {\n+  if (VerifyLoopOptimizations) verify();\n+  if (TraceLoopOpts && C->has_loops()) {\n@@ -3005,1 +3056,0 @@\n-    AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);\n@@ -3013,4 +3063,6 @@\n-      if (is_counted && lpt->_head->as_CountedLoop()->is_unroll_only()) continue;\n-\n-      lpt->reassociate_invariants(this);\n-\n+      if (is_counted && lpt->_head->as_CountedLoop()->is_unroll_only()) {\n+        continue;\n+      } else {\n+        AutoNodeBudget node_budget(this);\n+        lpt->reassociate_invariants(this);\n+      }\n@@ -3021,0 +3073,1 @@\n+        AutoNodeBudget node_budget(this, AutoNodeBudget::NO_BUDGET_CHECK);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":64,"deletions":11,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -595,4 +595,5 @@\n-  \/\/ Return TRUE or FALSE if the loop should be peeled or not.  Peel if we can\n-  \/\/ make some loop-invariant test (usually a null-check) happen before the\n-  \/\/ loop.\n-  bool policy_peeling( PhaseIdealLoop *phase ) const;\n+  \/\/ Return TRUE or FALSE if the loop should be peeled or not. Peel if we can\n+  \/\/ move some loop-invariant test (usually a null-check) before the loop.\n+  bool policy_peeling(PhaseIdealLoop *phase);\n+\n+  uint estimate_peeling(PhaseIdealLoop *phase);\n@@ -602,1 +603,1 @@\n-  bool policy_maximally_unroll( PhaseIdealLoop *phase ) const;\n+  bool policy_maximally_unroll(PhaseIdealLoop *phase) const;\n@@ -604,2 +605,2 @@\n-  \/\/ Return TRUE or FALSE if the loop should be unrolled or not.  Unroll if\n-  \/\/ the loop is a CountedLoop and the body is small enough.\n+  \/\/ Return TRUE or FALSE if the loop should be unrolled or not. Apply unroll\n+  \/\/ if the loop is a counted loop and the loop body is small enough.\n@@ -626,0 +627,3 @@\n+  \/\/ Estimate the number of nodes required when cloning a loop (body).\n+  uint est_loop_clone_sz(uint factor) const;\n+\n@@ -1355,0 +1359,11 @@\n+  enum { REQUIRE_MIN = 70 };\n+\n+  uint nodes_required() const { return _nodes_required; }\n+\n+  \/\/ Given the _currently_  available number of nodes, check  whether there is\n+  \/\/ \"room\" for an additional request or not, considering the already required\n+  \/\/ number of  nodes.  Return TRUE if  the new request is  exceeding the node\n+  \/\/ budget limit, otherwise return FALSE.  Note that this interpretation will\n+  \/\/ act pessimistic on  additional requests when new nodes  have already been\n+  \/\/ generated since the 'begin'.  This behaviour fits with the intention that\n+  \/\/ node estimates\/requests should be made upfront.\n@@ -1361,1 +1376,1 @@\n-  uint require_nodes(uint require) {\n+  uint require_nodes(uint require, uint minreq = REQUIRE_MIN) {\n@@ -1364,0 +1379,1 @@\n+    _nodes_required += MAX2(require, minreq);\n@@ -1367,2 +1383,2 @@\n-  bool may_require_nodes(uint require) {\n-    return !exceeding_node_budget(require) && require_nodes(require) > 0;\n+  bool may_require_nodes(uint require, uint minreq = REQUIRE_MIN) {\n+    return !exceeding_node_budget(require) && require_nodes(require, minreq) > 0;\n@@ -1371,1 +1387,1 @@\n-  void require_nodes_begin() {\n+  uint require_nodes_begin() {\n@@ -1374,0 +1390,1 @@\n+    return C->live_nodes();\n@@ -1376,12 +1393,5 @@\n-  \/\/ Final check  that the requested nodes  did not exceed the  limit and that\n-  \/\/ the request  was reasonably  correct with  respect to  the number  of new\n-  \/\/ nodes introduced by any transform since the last 'begin'.\n-  void require_nodes_final_check(uint live_at_begin) {\n-    uint required = _nodes_required;\n-    require_nodes_final();\n-    uint delta = C->live_nodes() - live_at_begin;\n-    assert(delta <= 2 * required, \"Bad node estimate (actual: %d, request: %d)\",\n-           delta, required);\n-  }\n-\n-  void require_nodes_final() {\n+  \/\/ When a node request is final,  optionally check that the requested number\n+  \/\/ of nodes was  reasonably correct with respect to the  number of new nodes\n+  \/\/ introduced since the last 'begin'. Always check that we have not exceeded\n+  \/\/ the maximum node limit.\n+  void require_nodes_final(uint live_at_begin, bool check_estimate) {\n@@ -1389,1 +1399,15 @@\n-    assert(!exceeding_node_budget(), \"Too many NODES required!\");\n+\n+    if (check_estimate) {\n+      \/\/ Assert that the node budget request was not off by too much (x2).\n+      \/\/ Should this be the case we _surely_ need to improve the estimates\n+      \/\/ used in our budget calculations.\n+      assert(C->live_nodes() - live_at_begin <= 2 * _nodes_required,\n+             \"Bad node estimate: actual = %d >> request = %d\",\n+             C->live_nodes() - live_at_begin, _nodes_required);\n+    }\n+    \/\/ Assert that we have stayed within the node budget limit.\n+    assert(C->live_nodes() < C->max_node_limit(),\n+           \"Exceeding node budget limit: %d + %d > %d (request = %d)\",\n+           C->live_nodes() - live_at_begin, live_at_begin,\n+           C->max_node_limit(), _nodes_required);\n+\n@@ -1400,2 +1424,0 @@\n-  uint nodes_required() const { return _nodes_required; }\n-\n@@ -1446,2 +1468,1 @@\n-    _nodes_at_begin = _phase->C->live_nodes();\n-    _phase->require_nodes_begin();\n+    _nodes_at_begin = _phase->require_nodes_begin();\n@@ -1451,1 +1472,0 @@\n-    if (_check_at_final) {\n@@ -1453,8 +1473,13 @@\n-      if (TraceLoopOpts) {\n-        uint request = _phase->nodes_required();\n-\n-        if (request > 0) {\n-          uint delta = _phase->C->live_nodes() - _nodes_at_begin;\n-\n-          if (request < delta) {\n-            tty->print_cr(\"Exceeding node budget: %d < %d\", request, delta);\n+    if (TraceLoopOpts) {\n+      uint request = _phase->nodes_required();\n+      uint delta   = _phase->C->live_nodes() - _nodes_at_begin;\n+\n+      if (request < delta) {\n+        tty->print_cr(\"Exceeding node budget: %d < %d\", request, delta);\n+      } else {\n+        uint const REQUIRE_MIN = PhaseIdealLoop::REQUIRE_MIN;\n+        \/\/ Identify the worst estimates as \"poor\" ones.\n+        if (request > REQUIRE_MIN && delta > 0) {\n+          if ((delta >  REQUIRE_MIN && request >  3 * delta) ||\n+              (delta <= REQUIRE_MIN && request > 10 * delta)) {\n+            tty->print_cr(\"Poor node estimate: %d >> %d\", request, delta);\n@@ -1464,4 +1489,0 @@\n-#endif\n-      _phase->require_nodes_final_check(_nodes_at_begin);\n-    } else {\n-      _phase->require_nodes_final();\n@@ -1469,0 +1490,2 @@\n+#endif \/\/ PRODUCT\n+    _phase->require_nodes_final(_nodes_at_begin, _check_at_final);\n@@ -1477,11 +1500,0 @@\n-\/\/ The Estimated Loop Clone Size: CloneFactor * (BodySize + BC) + CC, where BC\n-\/\/ and CC are totally ad-hoc\/magic \"body\" and \"clone\" constants, respectively,\n-\/\/ used to ensure that node usage estimates made are on the safe side, for the\n-\/\/ most part.\n-static inline uint est_loop_clone_sz(uint fact, uint size) {\n-  uint const bc = 31;\n-  uint const cc = 41;\n-  uint estimate = fact * (size + bc) + cc;\n-  return (estimate - cc) \/ fact == size + bc ? estimate : UINT_MAX;\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":64,"deletions":52,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -3085,3 +3085,3 @@\n-    return false;  }\n-\n-  LoopNode *head  = loop->_head->as_Loop();\n+    return false;\n+  }\n+  LoopNode *head = loop->_head->as_Loop();\n@@ -3094,1 +3094,1 @@\n-  for(uint ii = 0; ii < loop->_body.size(); ii++ ) {\n+  for (uint ii = 0; ii < loop->_body.size(); ii++) {\n@@ -3121,2 +3121,2 @@\n-  while( iff != head ) {\n-    if( iff->is_If() ) {\n+  while (iff != head) {\n+    if (iff->is_If()) {\n@@ -3126,1 +3126,1 @@\n-      if( loop->is_member(get_loop(ctrl)) &&\n+      if (loop->is_member(get_loop(ctrl)) &&\n@@ -3140,0 +3140,1 @@\n+\n@@ -3187,1 +3188,1 @@\n-  if (!may_require_nodes(est_loop_clone_sz(2, loop->_body.size()))) {\n+  if (!may_require_nodes(loop->est_loop_clone_sz(2))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":10,"deletions":9,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,168 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8223502\n+ * @summary Node estimate for loop unswitching is not correct:\n+ *          assert(delta <= 2 * required) failed: Bad node estimate\n+ *\n+ * @requires !vm.graal.enabled\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation\n+ *      -XX:-UseOnStackReplacement -XX:CompileOnly=LoopUnswitchingBadNodeBudget::test\n+ *      -XX:CompileCommand=dontinline,LoopUnswitchingBadNodeBudget::helper\n+ *      -XX:+UnlockExperimentalVMOptions -XX:-UseSwitchProfiling LoopUnswitchingBadNodeBudget\n+ *\n+ *\/\n+\n+public class LoopUnswitchingBadNodeBudget {\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 20_000; i++) {\n+            for (int j = 0; j < 100; j++) {\n+                test(j, true, 0, 0, 0);\n+                test(j, false, 0, 0, 0);\n+            }\n+        }\n+    }\n+\n+    private static int test(int j, boolean flag, int k, int l, int m) {\n+        int res = 0;\n+        for (int i = 0; i < 24; i++) {\n+            if (flag) {\n+                k = k \/ 2;\n+                l = l * 2;\n+                m = m + 2;\n+            }\n+            switch (j) {\n+                case  0: break;\n+                case  1: return helper(j, k, l, m);\n+                case  2: return helper(j, k, l, m);\n+                case  3: return helper(j, k, l, m);\n+                case  4: return helper(j, k, l, m);\n+                case  5: return helper(j, k, l, m);\n+                case  6: return helper(j, k, l, m);\n+                case  7: return helper(j, k, l, m);\n+                case  8: return helper(j, k, l, m);\n+                case  9: return helper(j, k, l, m);\n+                case 10: return helper(j, k, l, m);\n+                case 11: return helper(j, k, l, m);\n+                case 12: return helper(j, k, l, m);\n+                case 13: return helper(j, k, l, m);\n+                case 14: return helper(j, k, l, m);\n+                case 15: return helper(j, k, l, m);\n+                case 16: return helper(j, k, l, m);\n+                case 17: return helper(j, k, l, m);\n+                case 18: return helper(j, k, l, m);\n+                case 19: return helper(j, k, l, m);\n+                case 20: return helper(j, k, l, m);\n+                case 21: return helper(j, k, l, m);\n+                case 22: return helper(j, k, l, m);\n+                case 23: return helper(j, k, l, m);\n+                case 24: return helper(j, k, l, m);\n+                case 25: return helper(j, k, l, m);\n+                case 26: return helper(j, k, l, m);\n+                case 27: return helper(j, k, l, m);\n+                case 28: return helper(j, k, l, m);\n+                case 29: return helper(j, k, l, m);\n+                case 30: return helper(j, k, l, m);\n+                case 31: return helper(j, k, l, m);\n+                case 32: return helper(j, k, l, m);\n+                case 33: return helper(j, k, l, m);\n+                case 34: return helper(j, k, l, m);\n+                case 35: return helper(j, k, l, m);\n+                case 36: return helper(j, k, l, m);\n+                case 37: return helper(j, k, l, m);\n+                case 38: return helper(j, k, l, m);\n+                case 39: return helper(j, k, l, m);\n+                case 40: return helper(j, k, l, m);\n+                case 41: return helper(j, k, l, m);\n+                case 42: return helper(j, k, l, m);\n+                case 43: return helper(j, k, l, m);\n+                case 44: return helper(j, k, l, m);\n+                case 45: return helper(j, k, l, m);\n+                case 46: return helper(j, k, l, m);\n+                case 47: return helper(j, k, l, m);\n+                case 48: return helper(j, k, l, m);\n+                case 49: return helper(j, k, l, m);\n+                case 50: return helper(j, k, l, m);\n+                case 51: return helper(j, k, l, m);\n+                case 52: return helper(j, k, l, m);\n+                case 53: return helper(j, k, l, m);\n+                case 54: return helper(j, k, l, m);\n+                case 55: return helper(j, k, l, m);\n+                case 56: return helper(j, k, l, m);\n+                case 57: return helper(j, k, l, m);\n+                case 58: return helper(j, k, l, m);\n+                case 59: return helper(j, k, l, m);\n+                case 60: return helper(j, k, l, m);\n+                case 61: return helper(j, k, l, m);\n+                case 62: return helper(j, k, l, m);\n+                case 63: return helper(j, k, l, m);\n+                case 64: return helper(j, k, l, m);\n+                case 65: return helper(j, k, l, m);\n+                case 66: return helper(j, k, l, m);\n+                case 67: return helper(j, k, l, m);\n+                case 68: return helper(j, k, l, m);\n+                case 69: return helper(j, k, l, m);\n+                case 70: return helper(j, k, l, m);\n+                case 71: return helper(j, k, l, m);\n+                case 72: return helper(j, k, l, m);\n+                case 73: return helper(j, k, l, m);\n+                case 74: return helper(j, k, l, m);\n+                case 75: return helper(j, k, l, m);\n+                case 76: return helper(j, k, l, m);\n+                case 77: return helper(j, k, l, m);\n+                case 78: return helper(j, k, l, m);\n+                case 79: return helper(j, k, l, m);\n+                case 80: return helper(j, k, l, m);\n+                case 81: return helper(j, k, l, m);\n+                case 82: return helper(j, k, l, m);\n+                case 83: return helper(j, k, l, m);\n+                case 84: return helper(j, k, l, m);\n+                case 85: return helper(j, k, l, m);\n+                case 86: return helper(j, k, l, m);\n+                case 87: return helper(j, k, l, m);\n+                case 88: return helper(j, k, l, m);\n+                case 89: return helper(j, k, l, m);\n+                case 90: return helper(j, k, l, m);\n+                case 91: return helper(j, k, l, m);\n+                case 92: return helper(j, k, l, m);\n+                case 93: return helper(j, k, l, m);\n+                case 94: return helper(j, k, l, m);\n+                case 95: return helper(j, k, l, m);\n+                case 96: return helper(j, k, l, m);\n+                case 97: return helper(j, k, l, m);\n+                case 98: return helper(j, k, l, m);\n+                case 99: return helper(j, k, l, m);\n+            }\n+            res += helper(j, k, l, m);\n+        }\n+        return res;\n+    }\n+\n+    private static int helper(int j, int k, int l, int m) {\n+        return j + k;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LoopUnswitchingBadNodeBudget.java","additions":168,"deletions":0,"binary":false,"changes":168,"status":"added"}]}