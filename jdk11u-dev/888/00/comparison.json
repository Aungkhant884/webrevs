{"files":[{"patch":"@@ -678,20 +678,0 @@\n-\/\/ The Estimated Loop Unroll Size: UnrollFactor * (106% * BodySize + BC) + CC,\n-\/\/ where BC  and CC are  (totally) ad-hoc\/magic \"body\" and  \"clone\" constants,\n-\/\/ respectively, used to ensure that node usage estimates made are on the safe\n-\/\/ side, for the  most part.  This is  a simplified version of  the loop clone\n-\/\/ size calculation in est_loop_clone_sz(),  defined for unroll factors larger\n-\/\/ than one  (>1), performing  an overflow check  and returning  'UINT_MAX' in\n-\/\/ case of an overflow.\n-static uint est_loop_unroll_sz(uint factor, uint size) {\n-  precond(0 < factor);\n-\n-  uint const bc = 5;\n-  uint const cc = 7;\n-  uint const sz = size + (size + 15) \/ 16;\n-  uint estimate = factor * (sz + bc) + cc;\n-\n-  return (estimate - cc) \/ factor == sz + bc ? estimate : UINT_MAX;\n-}\n-\n-#define EMPTY_LOOP_SIZE 7   \/\/ Number of nodes in an empty loop.\n-\n@@ -702,2 +682,2 @@\n-bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop *phase) const {\n-  CountedLoopNode *cl = _head->as_CountedLoop();\n+bool IdealLoopTree::policy_maximally_unroll(PhaseIdealLoop* phase) const {\n+  CountedLoopNode* cl = _head->as_CountedLoop();\n@@ -706,1 +686,1 @@\n-    return false; \/\/ Malformed counted loop\n+    return false;   \/\/ Malformed counted loop.\n@@ -709,2 +689,1 @@\n-    \/\/ Trip count is not exact.\n-    return false;\n+    return false;   \/\/ Trip count is not exact.\n@@ -716,1 +695,1 @@\n-  assert(trip_count < max_juint, \"exact trip_count should be less than max_uint.\");\n+  assert(trip_count < max_juint, \"exact trip_count should be less than max_juint.\");\n@@ -721,4 +700,1 @@\n-  \/\/ Real policy: if we maximally unroll, does it get too big?\n-  \/\/ Allow the unrolled mess to get larger than standard loop\n-  \/\/ size.  After all, it will no longer be a loop.\n-  uint body_size    = _body.size();\n+  \/\/ Allow the unrolled body to get larger than the standard loop size limit.\n@@ -727,1 +703,1 @@\n-  if (trip_count > unroll_limit || body_size > unroll_limit) {\n+  if (trip_count > unroll_limit || _body.size() > unroll_limit) {\n@@ -731,3 +707,1 @@\n-  \/\/ Take into account that after unroll conjoined heads and tails will fold,\n-  \/\/ otherwise policy_unroll() may allow more unrolling than max unrolling.\n-  uint new_body_size = est_loop_unroll_sz(trip_count, body_size - EMPTY_LOOP_SIZE);\n+  uint new_body_size = est_loop_unroll_sz(trip_count);\n@@ -739,2 +713,3 @@\n-  \/\/ Fully unroll a loop with few iterations regardless next conditions since\n-  \/\/ following loop optimizations will split such loop anyway (pre-main-post).\n+  \/\/ Fully unroll a loop with few iterations, regardless of other conditions,\n+  \/\/ since the following (general) loop optimizations will split such loop in\n+  \/\/ any case (into pre-main-post).\n@@ -745,3 +720,2 @@\n-  if (new_body_size > unroll_limit ||\n-      \/\/ Unrolling can result in a large amount of node construction\n-      phase->exceeding_node_budget(new_body_size)) {\n+  \/\/ Reject if unrolling will result in too much node construction.\n+  if (new_body_size > unroll_limit || phase->exceeding_node_budget(new_body_size)) {\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":13,"deletions":39,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2491,0 +2491,33 @@\n+  return estimate + est_loop_flow_merge_sz();\n+}\n+\n+\/\/ The Estimated Loop (full-) Unroll Size:\n+\/\/   UnrollFactor * (~106% * BodySize) + CC + FanOutTerm,\n+\/\/ where CC is a (totally) ad-hoc\/magic \"clone\" constant, used to ensure that\n+\/\/ node usage estimates made are on the safe side, for the most part. This is\n+\/\/ a \"light\" version of the loop clone size calculation (above), based on the\n+\/\/ assumption that most of the loop-construct overhead will be unraveled when\n+\/\/ (fully) unrolled. Defined for unroll factors larger or equal to one (>=1),\n+\/\/ including an overflow check and returning UINT_MAX in case of an overflow.\n+uint IdealLoopTree::est_loop_unroll_sz(uint factor) const {\n+\n+  precond(factor > 0);\n+\n+  \/\/ Take into account that after unroll conjoined heads and tails will fold.\n+  uint const b0 = _body.size() - EMPTY_LOOP_SIZE;\n+  uint const cc = 7;\n+  uint const sz = b0 + (b0 + 15) \/ 16;\n+  uint estimate = factor * sz + cc;\n+\n+  if ((estimate - cc) \/ factor != sz) {\n+    return UINT_MAX;\n+  }\n+\n+  return estimate + est_loop_flow_merge_sz();\n+}\n+\n+\/\/ Estimate the growth effect (in nodes) of merging control and data flow when\n+\/\/ cloning a loop body, based on the amount of  control and data flow reaching\n+\/\/ outside of the (current) loop body.\n+uint IdealLoopTree::est_loop_flow_merge_sz() const {\n+\n@@ -2514,1 +2547,1 @@\n-  \/\/ Add data and control count (x2.0) to estimate iff both are > 0. This is\n+  \/\/ Use data and control count (x2.0) in estimate iff both are > 0. This is\n@@ -2518,1 +2551,1 @@\n-    estimate += 2 * (ctrl_edge_out_cnt + data_edge_out_cnt);\n+    return 2 * (ctrl_edge_out_cnt + data_edge_out_cnt);\n@@ -2520,2 +2553,1 @@\n-\n-  return estimate;\n+  return 0;\n@@ -2528,4 +2560,2 @@\n-  for (uint i = 0; i < _nest; i++) {\n-    tty->print(\"  \");\n-  }\n-  tty->print(\"Loop: N%d\/N%d \",_head->_idx,_tail->_idx);\n+  tty->sp(2 * _nest);\n+  tty->print(\"Loop: N%d\/N%d \", _head->_idx, _tail->_idx);\n@@ -4633,1 +4663,1 @@\n-void PhaseIdealLoop::dump( ) const {\n+void PhaseIdealLoop::dump() const {\n@@ -4640,1 +4670,1 @@\n-  rpo( C->root(), stack, visited, rpo_list );\n+  rpo(C->root(), stack, visited, rpo_list);\n@@ -4642,1 +4672,1 @@\n-  dump( _ltree_root, rpo_list.size(), rpo_list );\n+  dump(_ltree_root, rpo_list.size(), rpo_list);\n@@ -4645,1 +4675,1 @@\n-void PhaseIdealLoop::dump( IdealLoopTree *loop, uint idx, Node_List &rpo_list ) const {\n+void PhaseIdealLoop::dump(IdealLoopTree* loop, uint idx, Node_List &rpo_list) const {\n@@ -4649,3 +4679,3 @@\n-  for( uint j=idx; j > 0;  j-- ) {\n-    Node *n = rpo_list[j-1];\n-    if( !_nodes[n->_idx] )      \/\/ Skip dead nodes\n+  for (uint j = idx; j > 0; j--) {\n+    Node* n = rpo_list[j-1];\n+    if (!_nodes[n->_idx])      \/\/ Skip dead nodes\n@@ -4653,4 +4683,5 @@\n-    if( get_loop(n) != loop ) { \/\/ Wrong loop nest\n-      if( get_loop(n)->_head == n &&    \/\/ Found nested loop?\n-          get_loop(n)->_parent == loop )\n-        dump(get_loop(n),rpo_list.size(),rpo_list);     \/\/ Print it nested-ly\n+\n+    if (get_loop(n) != loop) { \/\/ Wrong loop nest\n+      if (get_loop(n)->_head == n &&    \/\/ Found nested loop?\n+          get_loop(n)->_parent == loop)\n+        dump(get_loop(n), rpo_list.size(), rpo_list);     \/\/ Print it nested-ly\n@@ -4661,2 +4692,1 @@\n-    for( uint x = 0; x < loop->_nest; x++ )\n-      tty->print(\"  \");\n+    tty->sp(2 * loop->_nest);\n@@ -4664,1 +4694,1 @@\n-    if( n == C->root() ) {\n+    if (n == C->root()) {\n@@ -4668,2 +4698,2 @@\n-      Node *computed_idom = n->in(0);\n-      if( n->is_Region() ) {\n+      Node* computed_idom = n->in(0);\n+      if (n->is_Region()) {\n@@ -4676,1 +4706,1 @@\n-      tty->print(\" ID:%d\",computed_idom->_idx);\n+      tty->print(\" ID:%d\", computed_idom->_idx);\n@@ -4678,1 +4708,1 @@\n-      if( cached_idom != computed_idom ) {\n+      if (cached_idom != computed_idom) {\n@@ -4684,1 +4714,1 @@\n-    for( uint k = 0; k < _nodes.Size(); k++ ) {\n+    for (uint k = 0; k < _nodes.Size(); k++) {\n@@ -4687,2 +4717,2 @@\n-        Node *m = C->root()->find(k);\n-        if( m && m->outcnt() > 0 ) {\n+        Node* m = C->root()->find(k);\n+        if (m && m->outcnt() > 0) {\n@@ -4693,3 +4723,1 @@\n-          for( uint j = 0; j < loop->_nest; j++ )\n-            tty->print(\"  \");\n-          tty->print(\" \");\n+          tty->sp(2 * loop->_nest + 1);\n@@ -4719,1 +4747,1 @@\n-void PhaseIdealLoop::rpo( Node *start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list ) const {\n+void PhaseIdealLoop::rpo(Node* start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list) const {\n@@ -4742,1 +4770,1 @@\n-\/\/------------------------------LoopTreeIterator-----------------------------------\n+\/\/------------------------------LoopTreeIterator-------------------------------\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":62,"deletions":34,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -629,0 +629,2 @@\n+  \/\/ Estimate the number of nodes required when unrolling a loop (body).\n+  uint est_loop_unroll_sz(uint factor) const;\n@@ -660,1 +662,1 @@\n-  void dump_head( ) const;      \/\/ Dump loop head only\n+  void dump_head() const;       \/\/ Dump loop head only\n@@ -665,0 +667,5 @@\n+ private:\n+  enum { EMPTY_LOOP_SIZE = 7 }; \/\/ Number of nodes in an empty loop.\n+\n+  \/\/ Estimate the number of nodes resulting from control and data flow merge.\n+  uint est_loop_flow_merge_sz() const;\n@@ -680,1 +687,1 @@\n-  IdealLoopTree *_ltree_root;\n+  IdealLoopTree* _ltree_root;\n@@ -1022,1 +1029,1 @@\n-  virtual Node *transform( Node *a_node ) { return 0; }\n+  virtual Node* transform(Node* n) { return 0; }\n@@ -1024,1 +1031,1 @@\n-  bool is_counted_loop(Node* x, IdealLoopTree*& loop);\n+  bool is_counted_loop(Node* n, IdealLoopTree* &loop);\n@@ -1039,1 +1046,1 @@\n-  IdealLoopTree *ltree_root() const { return _ltree_root; }\n+  IdealLoopTree* ltree_root() const { return _ltree_root; }\n@@ -1310,1 +1317,1 @@\n-  \/\/ Conversion of fill\/copy patterns into intrisic versions\n+  \/\/ Conversion of fill\/copy patterns into intrinsic versions\n@@ -1426,1 +1433,1 @@\n-  void register_new_node( Node *n, Node *blk );\n+  void register_new_node(Node* n, Node* blk);\n@@ -1435,1 +1442,1 @@\n-  void dump(IdealLoopTree *loop, uint rpo_idx, Node_List &rpo_list) const;\n+  void dump(IdealLoopTree* loop, uint rpo_idx, Node_List &rpo_list) const;\n@@ -1437,2 +1444,2 @@\n-  void verify_compare(Node *n, const PhaseIdealLoop *loop_verify, VectorSet &visited) const;\n-  IdealLoopTree *get_loop_idx(Node* n) const {\n+  void verify_compare(Node* n, const PhaseIdealLoop* loop_verify, VectorSet &visited) const;\n+  IdealLoopTree* get_loop_idx(Node* n) const {\n@@ -1448,1 +1455,1 @@\n-  void rpo( Node *start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list ) const;\n+  void rpo(Node* start, Node_Stack &stk, VectorSet &visited, Node_List &rpo_list) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8229499\n+ * @summary Node estimate for loop unrolling is not correct\/sufficient:\n+ *          assert(delta <= 2 * required) failed: Bad node estimate ...\n+ *\n+ * @requires !vm.graal.enabled\n+ *\n+ * @run main\/othervm -XX:-TieredCompilation -XX:-BackgroundCompilation\n+ *                   LoopUnrollBadNodeBudget\n+ *\n+ *\/\n+\n+public class LoopUnrollBadNodeBudget {\n+\n+    int a;\n+    long b;\n+    int c;\n+    int d(long e, short f, int g) {\n+        int h, j = 2, k, l[][] = new int[a][];\n+        for (h = 8; h < 58; ++h)\n+            for (k = 1; 7 > k; ++k)\n+                switch (h % 9 * 5 + 43) {\n+                    case 70:\n+                    case 65:\n+                    case 86:\n+                    case 81:\n+                    case 62:\n+                    case 69:\n+                    case 74:\n+                        g = j;\n+                }\n+        long m = u(l);\n+        return (int)m;\n+    }\n+    void n(int p, int o) { d(b, (short)0, p); }\n+    void r(String[] q) {\n+        int i = 4;\n+        n(i, c);\n+    }\n+    long u(int[][] a) {\n+        long sum = 0;\n+        return sum;\n+    }\n+    public static void main(String[] t) {\n+        try {\n+            LoopUnrollBadNodeBudget s = new LoopUnrollBadNodeBudget();\n+            for (int i = 5000; i > 0; i--)\n+                s.r(t);\n+        } catch (Exception ex) {\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/LoopUnrollBadNodeBudget.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}