{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.lang.ref.Reference;\n@@ -40,0 +41,1 @@\n+import java.util.List;\n@@ -159,1 +161,1 @@\n-                throw new RuntimeException(\"Too many bootsrap threads found\");\n+                throw new RuntimeException(\"Too many bootstrap threads found\");\n@@ -295,3 +297,18 @@\n-            Stream<Thread> stream = Thread.getAllStackTraces().keySet().stream();\n-            stream.filter((t) -> t.getName().startsWith(\"BootstrapMessageLoggerTask-\"))\n-                    .forEach(t -> LogStream.err.println(t));\n+            \/\/ Though unlikely, it is not impossible that the bootstrap logger\n+            \/\/ executor may have released its first thread and spawned a new one.\n+            \/\/ If that happened then the executor itself might have been GC'ed\n+            \/\/ as well and a new one might have been created.\n+            \/\/ The code below will lookup the executor threads again and\n+            \/\/ join them.\n+            \/\/ Only one may be active at a given time, but that might not\n+            \/\/ be the one referenced by threadRef.\n+            \/\/ We're just making sure all of them have stopped running\n+            \/\/ before verifying that the executor is eventually GC'ed.\n+            final WeakReference<Thread> previous = threadRef;\n+            Stream<WeakReference<Thread>> stream = Thread.getAllStackTraces().keySet().stream()\n+               .filter((t) -> t.getName().startsWith(\"BootstrapMessageLoggerTask-\"))\n+               .filter((t) -> previous == null ? true : t != previous.get())\n+               .map((t) -> new WeakReference<>(t, queue));\n+            List<WeakReference<Thread>> threads = stream.collect(Collectors.toList());\n+            if (previous != null) threads.add(previous);\n+            threads.forEach(t -> LogStream.err.println(t.get()));\n@@ -299,5 +316,14 @@\n-            if (threadRef != null && test == TestCase.SECURE_AND_WAIT) {\n-                Thread t = threadRef.get();\n-                if (t != null) {\n-                    if (!(Boolean)isAlive.invoke(null)) {\n-                        throw new RuntimeException(\"Executor already terminated\");\n+\n+            if (test == TestCase.SECURE_AND_WAIT) {\n+                \/\/ First wait for all executor threads to terminate\n+                for (var ref : threads) {\n+                    Thread t = ref.get();\n+                    if (t != null) {\n+                        if (!(Boolean)isAlive.invoke(null) && t.isAlive()) {\n+                            throw new RuntimeException(\"Executor already terminated\");\n+                        } else {\n+                            LogStream.err.println(\"Executor still alive as expected: \" + t.getName());\n+                        }\n+                        LogStream.err.println(\"Waiting for \" + t.getName() + \" to terminate (join)\");\n+                        t.join(60_000);\n+                        t = null;\n@@ -305,1 +331,7 @@\n-                        LogStream.err.println(\"Executor still alive as expected.\");\n+                        LogStream.err.println(\"WeakReference<Thread> is already cleared.\");\n+                        long count = Thread.getAllStackTraces().keySet().stream()\n+                            .filter((tr) -> tr.getName().startsWith(\"BootstrapMessageLoggerTask-\"))\n+                            .count();\n+                        if (count != 0) {\n+                            LogStream.err.println(\"There are \" + count + \" threads still lingering.\");\n+                        }\n@@ -307,3 +339,0 @@\n-                    LogStream.err.println(\"Waiting for \" + t.getName() + \" to terminate (join)\");\n-                    t.join(60_000);\n-                    t = null;\n@@ -311,4 +340,2 @@\n-                LogStream.err.println(\"Calling System.gc()\");\n-                System.gc();\n-                LogStream.err.println(\"Waiting for BootstrapMessageLoggerTask to be gc'ed\");\n-                while (queue.remove(1000) == null) {\n+                \/\/ Then wait until all the executor threads are GC'ed\n+                while (!threads.isEmpty()) {\n@@ -317,1 +344,6 @@\n-                }\n+                    LogStream.err.println(\"Waiting for BootstrapMessageLoggerTask to be gc'ed\");\n+                    Reference<?> tref;\n+                    while ((tref = queue.remove(1000)) == null) {\n+                        LogStream.err.println(\"Calling System.gc()\");\n+                        System.gc();\n+                    }\n@@ -319,6 +351,3 @@\n-                \/\/ Call the reference here to make sure threadRef will not be\n-                \/\/ eagerly garbage collected before the thread it references.\n-                \/\/ otherwise, it might not be enqueued, resulting in the\n-                \/\/ queue.remove() call above to always return null....\n-                if (threadRef.get() != null) {\n-                    throw new RuntimeException(\"Reference should have been cleared\");\n+                    threads.remove(tref);\n+                    LogStream.err.println(\"BootstrapMessageLoggerTask has been gc'ed: \"\n+                                          + threads.size() + \" remaining...\");\n@@ -326,3 +355,3 @@\n-\n-                LogStream.err.println(\"BootstrapMessageLoggerTask has been gc'ed\");\n-                \/\/ Wait for the executor to be gc'ed...\n+                \/\/ Then wait for the executor to be gc'ed...\n+                LogStream.err.println(\"Waiting for the executor to be gc'ed: Calling System.gc()\");\n+                System.gc();\n@@ -330,2 +359,0 @@\n-                    LogStream.err.println(\"Calling System.gc()\");\n-                    System.gc();\n@@ -335,0 +362,2 @@\n+                    LogStream.err.println(\"Calling System.gc()\");\n+                    System.gc();\n","filename":"test\/jdk\/java\/lang\/System\/LoggerFinder\/internal\/BootstrapLogger\/BootstrapLoggerTest.java","additions":59,"deletions":30,"binary":false,"changes":89,"status":"modified"}]}