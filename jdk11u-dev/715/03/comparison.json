{"files":[{"patch":"@@ -3,1 +3,2 @@\n-# Copyright (c) 2012, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -109,0 +110,8 @@\n+# Test and fix cpu on macos-aarch64, uname -p reports arm, buildsys expects aarch64\n+echo $OUT | grep arm-apple-darwin > \/dev\/null 2> \/dev\/null\n+if test $? = 0; then\n+  if [ `uname -m` = arm64 ]; then\n+    OUT=aarch64`echo $OUT | sed -e 's\/[^-]*\/\/'`\n+  fi\n+fi\n+\n","filename":"make\/autoconf\/build-aux\/config.guess","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -114,0 +114,3 @@\n+    # The expected format for <version> is either nn.n.n or nn.nn.nn. See\n+    # \/Applications\/Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/AvailabilityVersions.h\n+\n@@ -119,1 +122,5 @@\n-    MACOSX_VERSION_MIN=10.9.0\n+    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = xaarch64; then\n+      MACOSX_VERSION_MIN=11.00.00\n+    else\n+      MACOSX_VERSION_MIN=10.9.0\n+    fi\n@@ -125,2 +132,1 @@\n-    # link to macosx APIs that are newer than the given OS version. The expected\n-    # format for <version> is either nn.n.n or nn.nn.nn. See \/usr\/include\/AvailabilityMacros.h.\n+    # link to macosx APIs that are newer than the given OS version.\n","filename":"make\/autoconf\/flags.m4","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -277,0 +277,8 @@\n+  # Disable CDS on macos-aarch64\n+  if test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\" && test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+    ENABLE_CDS=\"false\"\n+    if test \"x$enable_cds\" = \"xyes\"; then\n+      AC_MSG_ERROR([CDS is currently not supported on macOS\/aarch64. Remove --enable-cds.])\n+    fi\n+  fi\n+\n","filename":"make\/autoconf\/hotspot.m4","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1216,1 +1216,1 @@\n-\t\t  $(CODESIGN) -s \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp --options runtime \\\n+\t\t  $(CODESIGN) -f -s \"$(MACOSX_CODESIGN_IDENTITY)\" --timestamp --options runtime \\\n","filename":"make\/common\/NativeCompilation.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,3 @@\n+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)\n+      ADLCFLAGS += -DR18_RESERVED\n+    endif\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-       undef missing-field-initializers\n+       undef missing-field-initializers deprecated-declarations c++11-narrowing\n","filename":"make\/lib\/Awt2dLibraries.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  SA_CFLAGS := -Damd64 -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \\\n+  SA_CFLAGS := -D_GNU_SOURCE -mno-omit-leaf-frame-pointer \\\n","filename":"make\/lib\/Lib-jdk.hotspot.agent.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-#if defined(_WIN64)\n+#if defined(__APPLE__) || defined(_WIN64)\n","filename":"src\/hotspot\/cpu\/aarch64\/globalDefinitions_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -61,1 +62,6 @@\n-int InterpreterRuntime::SignatureHandlerGenerator::next_stack_offset() {\n+\/\/ On macos\/aarch64 native stack is packed, int\/float are using only 4 bytes\n+\/\/ on stack. Natural alignment for types are still in place,\n+\/\/ for example double\/long should be 8 bytes aligned.\n+\n+int InterpreterRuntime::SignatureHandlerGenerator::next_stack_offset(unsigned elem_size) {\n+  MACOS_ONLY(_stack_offset = align_up(_stack_offset, elem_size));\n@@ -63,1 +69,1 @@\n-  _stack_offset += wordSize;\n+  _stack_offset += NOT_MACOS(wordSize) MACOS_ONLY(elem_size);\n@@ -75,0 +81,24 @@\n+void InterpreterRuntime::SignatureHandlerGenerator::pass_byte() {\n+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));\n+\n+  Register reg = next_gpr();\n+  if (reg != noreg) {\n+    __ ldr(reg, src);\n+  } else {\n+    __ ldrb(r0, src);\n+    __ strb(r0, Address(to(), next_stack_offset(sizeof(jbyte))));\n+  }\n+}\n+\n+void InterpreterRuntime::SignatureHandlerGenerator::pass_short() {\n+  const Address src(from(), Interpreter::local_offset_in_bytes(offset()));\n+\n+  Register reg = next_gpr();\n+  if (reg != noreg) {\n+    __ ldr(reg, src);\n+  } else {\n+    __ ldrh(r0, src);\n+    __ strh(r0, Address(to(), next_stack_offset(sizeof(jshort))));\n+  }\n+}\n+\n@@ -83,1 +113,1 @@\n-    __ strw(r0, Address(to(), next_stack_offset()));\n+    __ strw(r0, Address(to(), next_stack_offset(sizeof(jint))));\n@@ -95,1 +125,1 @@\n-    __ str(r0, Address(to(), next_stack_offset()));\n+    __ str(r0, Address(to(), next_stack_offset(sizeof(jlong))));\n@@ -107,1 +137,1 @@\n-    __ strw(r0, Address(to(), next_stack_offset()));\n+    __ strw(r0, Address(to(), next_stack_offset(sizeof(jfloat))));\n@@ -119,1 +149,1 @@\n-    __ str(r0, Address(to(), next_stack_offset()));\n+    __ str(r0, Address(to(), next_stack_offset(sizeof(jdouble))));\n@@ -143,1 +173,2 @@\n-    __ str(r0, Address(to(), next_stack_offset()));\n+    STATIC_ASSERT(sizeof(jobject) == wordSize);\n+    __ str(r0, Address(to(), next_stack_offset(sizeof(jobject))));\n@@ -168,1 +199,1 @@\n-  intptr_t* _to;\n+  char*     _to;\n@@ -203,2 +234,19 @@\n-  void pass_stack(intptr_t value) {\n-    *_to++ = value;\n+  template<typename T>\n+  void pass_stack(T value) {\n+    MACOS_ONLY(_to = align_up(_to, sizeof(value)));\n+    *(T *)_to = value;\n+    _to += NOT_MACOS(wordSize) MACOS_ONLY(sizeof(value));\n+  }\n+\n+  virtual void pass_byte() {\n+    jbyte value = *(jbyte*)single_slot_addr();\n+    if (pass_gpr(value) < 0) {\n+      pass_stack<>(value);\n+    }\n+  }\n+\n+  virtual void pass_short() {\n+    jshort value = *(jshort*)single_slot_addr();\n+    if (pass_gpr(value) < 0) {\n+      pass_stack<>(value);\n+    }\n@@ -210,1 +258,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -217,1 +265,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -225,1 +273,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -232,1 +280,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -242,1 +290,1 @@\n-      pass_stack(value);\n+      pass_stack<>(value);\n@@ -251,1 +299,1 @@\n-    _to   = to;\n+    _to   = (char *)to;\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.cpp","additions":65,"deletions":17,"binary":false,"changes":82,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -41,0 +42,2 @@\n+  void pass_byte();\n+  void pass_short();\n@@ -49,1 +52,1 @@\n-  int next_stack_offset();\n+  int next_stack_offset(unsigned elem_size);\n","filename":"src\/hotspot\/cpu\/aarch64\/interpreterRT_aarch64.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -54,0 +55,42 @@\n+\/\/ On macos\/aarch64 we need to ensure WXExec mode when running generated\n+\/\/ FastGetXXXField, as these functions can be called from WXWrite context\n+\/\/ (8262896).  So each FastGetXXXField is wrapped into a C++ statically\n+\/\/ compiled template function that optionally switches to WXExec if necessary.\n+\n+#ifdef __APPLE__\n+\n+static address generated_fast_get_field[T_LONG + 1 - T_BOOLEAN];\n+\n+template<int BType> struct BasicTypeToJni {};\n+template<> struct BasicTypeToJni<T_BOOLEAN> { static const jboolean jni_type; };\n+template<> struct BasicTypeToJni<T_BYTE>    { static const jbyte    jni_type; };\n+template<> struct BasicTypeToJni<T_CHAR>    { static const jchar    jni_type; };\n+template<> struct BasicTypeToJni<T_SHORT>   { static const jshort   jni_type; };\n+template<> struct BasicTypeToJni<T_INT>     { static const jint     jni_type; };\n+template<> struct BasicTypeToJni<T_LONG>    { static const jlong    jni_type; };\n+template<> struct BasicTypeToJni<T_FLOAT>   { static const jfloat   jni_type; };\n+template<> struct BasicTypeToJni<T_DOUBLE>  { static const jdouble  jni_type; };\n+\n+template<int BType>\n+decltype(BasicTypeToJni<BType>::jni_type) static_fast_get_field_wrapper(JNIEnv *env, jobject obj, jfieldID fieldID) {\n+  JavaThread* thread = JavaThread::thread_from_jni_environment(env);\n+  ThreadWXEnable wx(WXExec, thread);\n+  address get_field_addr = generated_fast_get_field[BType - T_BOOLEAN];\n+  return ((decltype(BasicTypeToJni<BType>::jni_type)(*)(JNIEnv *env, jobject obj, jfieldID fieldID))get_field_addr)(env, obj, fieldID);\n+}\n+\n+template<int BType>\n+address JNI_FastGetField::generate_fast_get_int_field1() {\n+  generated_fast_get_field[BType - T_BOOLEAN] = generate_fast_get_int_field0((BasicType)BType);\n+  return (address)static_fast_get_field_wrapper<BType>;\n+}\n+\n+#else \/\/ __APPLE__\n+\n+template<int BType>\n+address JNI_FastGetField::generate_fast_get_int_field1() {\n+  return generate_fast_get_int_field0((BasicType)BType);\n+}\n+\n+#endif \/\/ __APPLE__\n+\n@@ -150,1 +193,1 @@\n-  return generate_fast_get_int_field0(T_BOOLEAN);\n+  return generate_fast_get_int_field1<T_BOOLEAN>();\n@@ -154,1 +197,1 @@\n-  return generate_fast_get_int_field0(T_BYTE);\n+  return generate_fast_get_int_field1<T_BYTE>();\n@@ -158,1 +201,1 @@\n-  return generate_fast_get_int_field0(T_CHAR);\n+  return generate_fast_get_int_field1<T_CHAR>();\n@@ -162,1 +205,1 @@\n-  return generate_fast_get_int_field0(T_SHORT);\n+  return generate_fast_get_int_field1<T_SHORT>();\n@@ -166,1 +209,1 @@\n-  return generate_fast_get_int_field0(T_INT);\n+  return generate_fast_get_int_field1<T_INT>();\n@@ -170,1 +213,1 @@\n-  return generate_fast_get_int_field0(T_LONG);\n+  return generate_fast_get_int_field1<T_LONG>();\n@@ -174,1 +217,1 @@\n-  return generate_fast_get_int_field0(T_FLOAT);\n+  return generate_fast_get_int_field1<T_FLOAT>();\n@@ -178,1 +221,1 @@\n-  return generate_fast_get_int_field0(T_DOUBLE);\n+  return generate_fast_get_int_field1<T_DOUBLE>();\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":51,"deletions":8,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"runtime\/vm_version.hpp\"\n@@ -91,1 +92,1 @@\n-             > (1UL << log2_intptr(Universe::narrow_klass_range()))));\n+             > (1UL << log2_intptr((uintptr_t)Universe::narrow_klass_range()))));\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -718,1 +719,1 @@\n-int SharedRuntime::c_calling_convention(const BasicType *sig_bt,\n+static int c_calling_convention_priv(const BasicType *sig_bt,\n@@ -749,0 +750,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code is unable to handle this so bailout.\n+          return -1;\n+#endif\n@@ -771,0 +777,5 @@\n+#ifdef __APPLE__\n+          \/\/ Less-than word types are stored one after another.\n+          \/\/ The code is unable to handle this so bailout.\n+          return -1;\n+#endif\n@@ -797,0 +808,10 @@\n+int SharedRuntime::c_calling_convention(const BasicType *sig_bt,\n+                                         VMRegPair *regs,\n+                                         VMRegPair *regs2,\n+                                         int total_args_passed)\n+{\n+  int result = c_calling_convention_priv(sig_bt, regs, regs2, total_args_passed);\n+  guarantee(result >= 0, \"Unsupported arguments configuration\");\n+  return result;\n+}\n+\n@@ -1343,1 +1364,5 @@\n-  out_arg_slots = c_calling_convention(out_sig_bt, out_regs, NULL, total_c_args);\n+  out_arg_slots = c_calling_convention_priv(out_sig_bt, out_regs, NULL, total_c_args);\n+\n+  if (out_arg_slots < 0) {\n+    return NULL;\n+  }\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+  \/\/ Arm can assign codes that are not published in the manual.\n+  \/\/ Apple's code is defined in\n+  \/\/ https:\/\/github.com\/apple\/darwin-xnu\/blob\/33eb983\/osfmk\/arm\/cpuid.h#L62\n@@ -82,0 +85,1 @@\n+    CPU_APPLE     = 'a',\n@@ -114,0 +118,5 @@\n+\n+#ifdef __APPLE__\n+  \/\/ Is the CPU running emulated (for example macOS Rosetta running x86_64 code on M1 ARM (aarch64)\n+  static bool is_cpu_emulated();\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -242,0 +242,2 @@\n+#elif defined(AARCH64)\n+static char cpu_arch[] = \"aarch64\";\n@@ -3072,10 +3074,2 @@\n-    \/\/ In Mac OS X 10.4, CrashReporter will write a crash log for all 'fatal' signals, including\n-    \/\/ signals caught and handled by the JVM. To work around this, we reset the mach task\n-    \/\/ signal handler that's placed on our process by CrashReporter. This disables\n-    \/\/ CrashReporter-based reporting.\n-    \/\/\n-    \/\/ This work-around is not necessary for 10.5+, as CrashReporter no longer intercedes\n-    \/\/ on caught fatal signals.\n-    \/\/\n-    \/\/ Additionally, gdb installs both standard BSD signal handlers, and mach exception\n-    \/\/ handlers. By replacing the existing task exception handler, we disable gdb's mach\n+    \/\/ lldb (gdb) installs both standard BSD signal handlers, and mach exception\n+    \/\/ handlers. By replacing the existing task exception handler, we disable lldb's mach\n@@ -3083,0 +3077,4 @@\n+    \/\/\n+    \/\/ EXC_MASK_BAD_ACCESS needed by all architectures for NULL ptr checking\n+    \/\/ EXC_MASK_ARITHMETIC needed by all architectures for div by 0 checking\n+    \/\/ EXC_MASK_BAD_INSTRUCTION needed by aarch64 to initiate deoptimization\n@@ -3085,1 +3083,2 @@\n-                                  EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC,\n+                                  EXC_MASK_BAD_ACCESS | EXC_MASK_ARITHMETIC\n+                                    AARCH64_ONLY(| EXC_MASK_BAD_INSTRUCTION),\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,82 @@\n+\/*\n+ * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_ATOMIC_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_VM_ATOMIC_BSD_AARCH64_HPP\n+\n+\/\/ Implementation of class atomic\n+\/\/ Note that memory_order_conservative requires a full barrier after atomic stores.\n+\/\/ See https:\/\/patchwork.kernel.org\/patch\/3575821\/\n+\n+#define FULL_MEM_BARRIER  __sync_synchronize()\n+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformAdd\n+  : Atomic::AddAndFetch<Atomic::PlatformAdd<byte_size> >\n+{\n+  template<typename I, typename D>\n+  D add_and_fetch(I add_value, D volatile* dest, atomic_memory_order order) const {\n+    D res = __atomic_add_fetch(dest, add_value, __ATOMIC_RELEASE);\n+    FULL_MEM_BARRIER;\n+    return res;\n+  }\n+};\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T Atomic::PlatformXchg<byte_size>::operator()(T exchange_value,\n+                                                     T volatile* dest,\n+                                                     atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  T res = __atomic_exchange_n(dest, exchange_value, __ATOMIC_RELEASE);\n+  FULL_MEM_BARRIER;\n+  return res;\n+}\n+\n+template<size_t byte_size>\n+template<typename T>\n+inline T Atomic::PlatformCmpxchg<byte_size>::operator()(T exchange_value,\n+                                                        T volatile* dest,\n+                                                        T compare_value,\n+                                                        atomic_memory_order order) const {\n+  STATIC_ASSERT(byte_size == sizeof(T));\n+  if (order == memory_order_relaxed) {\n+    T value = compare_value;\n+    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+    return value;\n+  } else {\n+    T value = compare_value;\n+    FULL_MEM_BARRIER;\n+    __atomic_compare_exchange(dest, &value, &exchange_value, \/*weak*\/false,\n+                              __ATOMIC_RELAXED, __ATOMIC_RELAXED);\n+    FULL_MEM_BARRIER;\n+    return value;\n+  }\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_ATOMIC_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/atomic_bsd_aarch64.hpp","additions":82,"deletions":0,"binary":false,"changes":82,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_BYTES_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_VM_BYTES_BSD_AARCH64_INLINE_HPP\n+\n+#ifdef __APPLE__\n+#include <libkern\/OSByteOrder.h>\n+#endif\n+\n+#if defined(__APPLE__)\n+#  define bswap_16(x) OSSwapInt16(x)\n+#  define bswap_32(x) OSSwapInt32(x)\n+#  define bswap_64(x) OSSwapInt64(x)\n+#else\n+#  error \"Unimplemented\"\n+#endif\n+\n+\/\/ Efficient swapping of data bytes from Java byte\n+\/\/ ordering to native byte ordering and vice versa.\n+inline u2   Bytes::swap_u2(u2 x) {\n+  return bswap_16(x);\n+}\n+\n+inline u4   Bytes::swap_u4(u4 x) {\n+  return bswap_32(x);\n+}\n+\n+inline u8 Bytes::swap_u8(u8 x) {\n+  return bswap_64(x);\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_BYTES_BSD_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/bytes_bsd_aarch64.inline.hpp","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,188 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_COPY_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_VM_COPY_BSD_AARCH64_INLINE_HPP\n+\n+#define COPY_SMALL(from, to, count)                                     \\\n+{                                                                       \\\n+        long tmp0, tmp1, tmp2, tmp3;                                    \\\n+        long tmp4, tmp5, tmp6, tmp7;                                    \\\n+  __asm volatile(                                                       \\\n+\"       adr     %[t0], 0f;\\n\"                                           \\\n+\"       add     %[t0], %[t0], %[cnt], lsl #5;\\n\"                        \\\n+\"       br      %[t0];\\n\"                                               \\\n+\"       .align  5;\\n\"                                                   \\\n+\"0:\"                                                                    \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldr     %[t0], [%[s], #0];\\n\"                                   \\\n+\"       str     %[t0], [%[d], #0];\\n\"                                   \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldr     %[t2], [%[s], #16];\\n\"                                  \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       str     %[t2], [%[d], #16];\\n\"                                  \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldr     %[t4], [%[s], #32];\\n\"                                  \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       str     %[t4], [%[d], #32];\\n\"                                  \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n+\"2:\"                                                                    \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n+\"       b       1f;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldr     %[t6], [%[s], #0];\\n\"                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #8];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #24];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #40];\\n\"                           \\\n+\"       str     %[t6], [%[d]], #8;\\n\"                                   \\\n+\"       b       2b;\\n\"                                                  \\\n+\"       .align  5;\\n\"                                                   \\\n+\"       ldp     %[t0], %[t1], [%[s], #0];\\n\"                            \\\n+\"       ldp     %[t2], %[t3], [%[s], #16];\\n\"                           \\\n+\"       ldp     %[t4], %[t5], [%[s], #32];\\n\"                           \\\n+\"       ldp     %[t6], %[t7], [%[s], #48];\\n\"                           \\\n+\"       stp     %[t0], %[t1], [%[d], #0];\\n\"                            \\\n+\"       stp     %[t2], %[t3], [%[d], #16];\\n\"                           \\\n+\"       stp     %[t4], %[t5], [%[d], #32];\\n\"                           \\\n+\"       stp     %[t6], %[t7], [%[d], #48];\\n\"                           \\\n+\"1:\"                                                                    \\\n+                                                                        \\\n+  : [s]\"+r\"(from), [d]\"+r\"(to), [cnt]\"+r\"(count),                       \\\n+    [t0]\"=&r\"(tmp0), [t1]\"=&r\"(tmp1), [t2]\"=&r\"(tmp2), [t3]\"=&r\"(tmp3), \\\n+    [t4]\"=&r\"(tmp4), [t5]\"=&r\"(tmp5), [t6]\"=&r\"(tmp6), [t7]\"=&r\"(tmp7)  \\\n+  :                                                                     \\\n+  : \"memory\", \"cc\");                                                    \\\n+}\n+\n+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_conjoint_words(from, to, count);\n+}\n+\n+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  if (__builtin_constant_p(count)) {\n+    memcpy(to, from, count * sizeof(HeapWord));\n+    return;\n+  }\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_disjoint_words(from, to, count);\n+}\n+\n+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n+  __asm volatile( \"prfm pldl1strm, [%[s], #0];\" :: [s]\"r\"(from) : \"memory\");\n+  if (__builtin_expect(count <= 8, 1)) {\n+    COPY_SMALL(from, to, count);\n+    return;\n+  }\n+  _Copy_disjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_words(from, to, count);\n+}\n+\n+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words(from, to, count);\n+}\n+\n+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n+  (void)memmove(to, from, count);\n+}\n+\n+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n+  pd_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+  _Copy_conjoint_jshorts_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+  _Copy_conjoint_jints_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+  _Copy_conjoint_jlongs_atomic(from, to, count);\n+}\n+\n+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jshorts(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n+   _Copy_arrayof_conjoint_jints(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n+  assert(!UseCompressedOops, \"foo!\");\n+  assert(BytesPerLong == BytesPerOop, \"jlongs and oops must be the same size\");\n+  _Copy_arrayof_conjoint_jlongs(from, to, count);\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_COPY_BSD_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/copy_bsd_aarch64.inline.hpp","additions":188,"deletions":0,"binary":false,"changes":188,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2016, Linaro Ltd. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#define CFUNC(x) _##x\n+\n+        .global CFUNC(_Copy_conjoint_words)\n+        .global CFUNC(_Copy_disjoint_words)\n+\n+s       .req    x0\n+d       .req    x1\n+count   .req    x2\n+t0      .req    x3\n+t1      .req    x4\n+t2      .req    x5\n+t3      .req    x6\n+t4      .req    x7\n+t5      .req    x8\n+t6      .req    x9\n+t7      .req    x10\n+\n+        .align  6\n+CFUNC(_Copy_disjoint_words):\n+        \/\/ Ensure 2 word aligned\n+        tbz     s, #3, fwd_copy_aligned\n+        ldr     t0, [s], #8\n+        str     t0, [d], #8\n+        sub     count, count, #1\n+\n+fwd_copy_aligned:\n+        \/\/ Bias s & d so we only pre index on the last copy\n+        sub     s, s, #16\n+        sub     d, d, #16\n+\n+        ldp     t0, t1, [s, #16]\n+        ldp     t2, t3, [s, #32]\n+        ldp     t4, t5, [s, #48]\n+        ldp     t6, t7, [s, #64]!\n+\n+        subs    count, count, #16\n+        blo     fwd_copy_drain\n+\n+fwd_copy_again:\n+        prfm    pldl1keep, [s, #256]\n+        stp     t0, t1, [d, #16]\n+        ldp     t0, t1, [s, #16]\n+        stp     t2, t3, [d, #32]\n+        ldp     t2, t3, [s, #32]\n+        stp     t4, t5, [d, #48]\n+        ldp     t4, t5, [s, #48]\n+        stp     t6, t7, [d, #64]!\n+        ldp     t6, t7, [s, #64]!\n+        subs    count, count, #8\n+        bhs     fwd_copy_again\n+\n+fwd_copy_drain:\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        stp     t4, t5, [d, #48]\n+        stp     t6, t7, [d, #64]!\n+\n+        \/\/ count is now -8..-1 for 0..7 words to copy\n+        adr     t0, 0f\n+        add     t0, t0, count, lsl #5\n+        br      t0\n+\n+        .align  5\n+        ret                             \/\/ -8 == 0 words\n+        .align  5\n+        ldr     t0, [s, #16]            \/\/ -7 == 1 word\n+        str     t0, [d, #16]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -6 = 2 words\n+        stp     t0, t1, [d, #16]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -5 = 3 words\n+        ldr     t2, [s, #32]\n+        stp     t0, t1, [d, #16]\n+        str     t2, [d, #32]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -4 = 4 words\n+        ldp     t2, t3, [s, #32]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -3 = 5 words\n+        ldp     t2, t3, [s, #32]\n+        ldr     t4, [s, #48]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        str     t4, [d, #48]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -2 = 6 words\n+        ldp     t2, t3, [s, #32]\n+        ldp     t4, t5, [s, #48]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        stp     t4, t5, [d, #48]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #16]        \/\/ -1 = 7 words\n+        ldp     t2, t3, [s, #32]\n+        ldp     t4, t5, [s, #48]\n+        ldr     t6, [s, #64]\n+        stp     t0, t1, [d, #16]\n+        stp     t2, t3, [d, #32]\n+        stp     t4, t5, [d, #48]\n+        str     t6, [d, #64]\n+        \/\/ Is always aligned here, code for 7 words is one instruction\n+        \/\/ too large so it just falls through.\n+        .align  5\n+0:\n+        ret\n+\n+        .align  6\n+CFUNC(_Copy_conjoint_words):\n+        sub     t0, d, s\n+        cmp     t0, count, lsl #3\n+        bhs     CFUNC(_Copy_disjoint_words)\n+\n+        add     s, s, count, lsl #3\n+        add     d, d, count, lsl #3\n+\n+        \/\/ Ensure 2 word aligned\n+        tbz     s, #3, bwd_copy_aligned\n+        ldr     t0, [s, #-8]!\n+        str     t0, [d, #-8]!\n+        sub     count, count, #1\n+\n+bwd_copy_aligned:\n+        ldp     t0, t1, [s, #-16]\n+        ldp     t2, t3, [s, #-32]\n+        ldp     t4, t5, [s, #-48]\n+        ldp     t6, t7, [s, #-64]!\n+\n+        subs    count, count, #16\n+        blo     bwd_copy_drain\n+\n+bwd_copy_again:\n+        prfum   pldl1keep, [s, #-256]\n+        stp     t0, t1, [d, #-16]\n+        ldp     t0, t1, [s, #-16]\n+        stp     t2, t3, [d, #-32]\n+        ldp     t2, t3, [s, #-32]\n+        stp     t4, t5, [d, #-48]\n+        ldp     t4, t5, [s, #-48]\n+        stp     t6, t7, [d, #-64]!\n+        ldp     t6, t7, [s, #-64]!\n+        subs    count, count, #8\n+        bhs     bwd_copy_again\n+\n+bwd_copy_drain:\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        stp     t4, t5, [d, #-48]\n+        stp     t6, t7, [d, #-64]!\n+\n+        \/\/ count is now -8..-1 for 0..7 words to copy\n+        adr     t0, 0f\n+        add     t0, t0, count, lsl #5\n+        br      t0\n+\n+        .align  5\n+        ret                             \/\/ -8 == 0 words\n+        .align  5\n+        ldr     t0, [s, #-8]            \/\/ -7 == 1 word\n+        str     t0, [d, #-8]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -6 = 2 words\n+        stp     t0, t1, [d, #-16]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -5 = 3 words\n+        ldr     t2, [s, #-24]\n+        stp     t0, t1, [d, #-16]\n+        str     t2, [d, #-24]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -4 = 4 words\n+        ldp     t2, t3, [s, #-32]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -3 = 5 words\n+        ldp     t2, t3, [s, #-32]\n+        ldr     t4, [s, #-40]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        str     t4, [d, #-40]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -2 = 6 words\n+        ldp     t2, t3, [s, #-32]\n+        ldp     t4, t5, [s, #-48]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        stp     t4, t5, [d, #-48]\n+        ret\n+        .align  5\n+        ldp     t0, t1, [s, #-16]       \/\/ -1 = 7 words\n+        ldp     t2, t3, [s, #-32]\n+        ldp     t4, t5, [s, #-48]\n+        ldr     t6, [s, #-56]\n+        stp     t0, t1, [d, #-16]\n+        stp     t2, t3, [d, #-32]\n+        stp     t4, t5, [d, #-48]\n+        str     t6, [d, #-56]\n+        \/\/ Is always aligned here, code for 7 words is one instruction\n+        \/\/ too large so it just falls through.\n+        .align  5\n+0:\n+        ret\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/copy_bsd_aarch64.s","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_GLOBALS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_VM_GLOBALS_BSD_AARCH64_HPP\n+\n+\/\/ Sets the default values for platform dependent flags used by the runtime system.\n+\/\/ (see globals.hpp)\n+\n+define_pd_global(bool, DontYieldALot,            false);\n+define_pd_global(intx, ThreadStackSize,          2048); \/\/ 0 => use system default\n+define_pd_global(intx, VMThreadStackSize,        2048);\n+\n+define_pd_global(intx, CompilerThreadStackSize,  2048);\n+\n+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);\n+\n+\/\/ Used on 64 bit platforms for UseCompressedOops base address\n+define_pd_global(uintx,HeapBaseMinAddress,       2*G);\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_GLOBALS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/globals_bsd_aarch64.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP\n+\n+\/\/ Interface for updating the instruction cache.  Whenever the VM\n+\/\/ modifies code, part of the processor instruction cache potentially\n+\/\/ has to be flushed.\n+\n+class ICache : public AbstractICache {\n+ public:\n+  static void initialize();\n+  static void invalidate_word(address addr) {\n+    __clear_cache((char *)addr, (char *)(addr + 4));\n+  }\n+  static void invalidate_range(address start, int nbytes) {\n+    __clear_cache((char *)start, (char *)(start + nbytes));\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_ICACHE_AARCH64_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/icache_bsd_aarch64.hpp","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_ORDERACCESS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_VM_ORDERACCESS_BSD_AARCH64_HPP\n+\n+\/\/ Included in orderAccess.hpp header file.\n+\n+\/\/ Implementation of class OrderAccess.\n+\n+inline void OrderAccess::loadload()   { acquire(); }\n+inline void OrderAccess::storestore() { release(); }\n+inline void OrderAccess::loadstore()  { acquire(); }\n+inline void OrderAccess::storeload()  { fence(); }\n+\n+#define FULL_MEM_BARRIER  __sync_synchronize()\n+#define READ_MEM_BARRIER  __atomic_thread_fence(__ATOMIC_ACQUIRE);\n+#define WRITE_MEM_BARRIER __atomic_thread_fence(__ATOMIC_RELEASE);\n+\n+inline void OrderAccess::acquire() {\n+  READ_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::release() {\n+  WRITE_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::fence() {\n+  FULL_MEM_BARRIER;\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_ORDERACCESS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/orderAccess_bsd_aarch64.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,753 @@\n+\/*\n+ * Copyright (c) 1999, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ no precompiled headers\n+#include \"jvm.h\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/icBuffer.hpp\"\n+#include \"code\/vtableStubs.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"os_share_bsd.hpp\"\n+#include \"prims\/jniFastGetField.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/extendedPC.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"utilities\/align.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+\/\/ put OS-includes here\n+# include <sys\/types.h>\n+# include <sys\/mman.h>\n+# include <pthread.h>\n+# include <signal.h>\n+# include <errno.h>\n+# include <dlfcn.h>\n+# include <stdlib.h>\n+# include <stdio.h>\n+# include <unistd.h>\n+# include <sys\/resource.h>\n+# include <sys\/stat.h>\n+# include <sys\/time.h>\n+# include <sys\/utsname.h>\n+# include <sys\/socket.h>\n+# include <sys\/wait.h>\n+# include <pwd.h>\n+# include <poll.h>\n+#ifndef __OpenBSD__\n+ # include <ucontext.h>\n+#endif\n+\n+#if !defined(__APPLE__) && !defined(__NetBSD__)\n+# include <pthread_np.h>\n+#endif\n+\n+#define SPELL_REG_SP \"sp\"\n+#define SPELL_REG_FP \"fp\"\n+\n+#ifdef __APPLE__\n+\/\/ see darwin-xnu\/osfmk\/mach\/arm\/_structs.h\n+\n+\/\/ 10.5 UNIX03 member name prefixes\n+#define DU3_PREFIX(s, m) __ ## s.__ ## m\n+#endif\n+\n+#define context_x    uc_mcontext->DU3_PREFIX(ss,x)\n+#define context_fp   uc_mcontext->DU3_PREFIX(ss,fp)\n+#define context_lr   uc_mcontext->DU3_PREFIX(ss,lr)\n+#define context_sp   uc_mcontext->DU3_PREFIX(ss,sp)\n+#define context_pc   uc_mcontext->DU3_PREFIX(ss,pc)\n+#define context_cpsr uc_mcontext->DU3_PREFIX(ss,cpsr)\n+#define context_esr  uc_mcontext->DU3_PREFIX(es,esr)\n+\n+address os::current_stack_pointer() {\n+#if defined(__clang__) || defined(__llvm__)\n+  void *sp;\n+  __asm__(\"mov %0, \" SPELL_REG_SP : \"=r\"(sp));\n+  return (address) sp;\n+#else\n+  register void *sp __asm__ (SPELL_REG_SP);\n+  return (address) sp;\n+#endif\n+}\n+\n+char* os::non_memory_address_word() {\n+  \/\/ Must never look like an address returned by reserve_memory,\n+  \/\/ even in its subfields (as defined by the CPU immediate fields,\n+  \/\/ if the CPU splits constants across multiple instructions).\n+\n+  \/\/ the return value used in computation of Universe::non_oop_word(), which\n+  \/\/ is loaded by cpu\/aarch64 by MacroAssembler::movptr(Register, uintptr_t)\n+  return (char*) 0xffffffffffff;\n+}\n+\n+address os::Bsd::ucontext_get_pc(const ucontext_t * uc) {\n+  return (address)uc->context_pc;\n+}\n+\n+void os::Bsd::ucontext_set_pc(ucontext_t * uc, address pc) {\n+  uc->context_pc = (intptr_t)pc;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_sp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_sp;\n+}\n+\n+intptr_t* os::Bsd::ucontext_get_fp(const ucontext_t * uc) {\n+  return (intptr_t*)uc->context_fp;\n+}\n+\n+\/\/ For Forte Analyzer AsyncGetCallTrace profiling support - thread\n+\/\/ is currently interrupted by SIGPROF.\n+\/\/ os::Solaris::fetch_frame_from_ucontext() tries to skip nested signal\n+\/\/ frames. Currently we don't do that on Linux, so it's the same as\n+\/\/ os::fetch_frame_from_context().\n+ExtendedPC os::Bsd::fetch_frame_from_ucontext(Thread* thread,\n+  const ucontext_t* uc, intptr_t** ret_sp, intptr_t** ret_fp) {\n+\n+  assert(thread != NULL, \"just checking\");\n+  assert(ret_sp != NULL, \"just checking\");\n+  assert(ret_fp != NULL, \"just checking\");\n+\n+  return os::fetch_frame_from_context(uc, ret_sp, ret_fp);\n+}\n+\n+ExtendedPC os::fetch_frame_from_context(const void* ucVoid,\n+                    intptr_t** ret_sp, intptr_t** ret_fp) {\n+\n+  ExtendedPC  epc;\n+  const ucontext_t* uc = (const ucontext_t*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = ExtendedPC(os::Bsd::ucontext_get_pc(uc));\n+    if (ret_sp) *ret_sp = os::Bsd::ucontext_get_sp(uc);\n+    if (ret_fp) *ret_fp = os::Bsd::ucontext_get_fp(uc);\n+  } else {\n+    \/\/ construct empty ExtendedPC for return value checking\n+    epc = ExtendedPC(NULL);\n+    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n+    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n+  }\n+\n+  return epc;\n+}\n+\n+frame os::fetch_frame_from_context(const void* ucVoid) {\n+  intptr_t* sp;\n+  intptr_t* fp;\n+  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n+  return frame(sp, fp, epc.pc());\n+}\n+\n+bool os::Bsd::get_frame_at_stack_banging_point(JavaThread* thread, ucontext_t* uc, frame* fr) {\n+  address pc = (address) os::Bsd::ucontext_get_pc(uc);\n+  if (Interpreter::contains(pc)) {\n+    \/\/ interpreter performs stack banging after the fixed frame header has\n+    \/\/ been generated while the compilers perform it before. To maintain\n+    \/\/ semantic consistency between interpreted and compiled frames, the\n+    \/\/ method returns the Java sender of the current frame.\n+    *fr = os::fetch_frame_from_context(uc);\n+    if (!fr->is_first_java_frame()) {\n+      assert(fr->safe_for_sender(thread), \"Safety check\");\n+      *fr = fr->java_sender();\n+    }\n+  } else {\n+    \/\/ more complex code with compiled code\n+    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n+      \/\/ Not sure where the pc points to, fallback to default\n+      \/\/ stack overflow handling\n+      return false;\n+    } else {\n+      \/\/ In compiled code, the stack banging is performed before LR\n+      \/\/ has been saved in the frame.  LR is live, and SP and FP\n+      \/\/ belong to the caller.\n+      intptr_t* fp = os::Bsd::ucontext_get_fp(uc);\n+      intptr_t* sp = os::Bsd::ucontext_get_sp(uc);\n+      address pc = (address)(uc->context_lr\n+                         - NativeInstruction::instruction_size);\n+      *fr = frame(sp, fp, pc);\n+      if (!fr->is_java_frame()) {\n+        assert(fr->safe_for_sender(thread), \"Safety check\");\n+        assert(!fr->is_first_frame(), \"Safety check\");\n+        *fr = fr->java_sender();\n+      }\n+    }\n+  }\n+  assert(fr->is_java_frame(), \"Safety check\");\n+  return true;\n+}\n+\n+\/\/ JVM compiled with -fno-omit-frame-pointer, so RFP is saved on the stack.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n+}\n+\n+NOINLINE frame os::current_frame() {\n+  intptr_t *fp = *(intptr_t **)__builtin_frame_address(0);\n+  frame myframe((intptr_t*)os::current_stack_pointer(),\n+                (intptr_t*)fp,\n+                CAST_FROM_FN_PTR(address, os::current_frame));\n+  if (os::is_first_C_frame(&myframe)) {\n+    \/\/ stack is not walkable\n+    return frame();\n+  } else {\n+    return os::get_sender_for_C_frame(&myframe);\n+  }\n+}\n+\n+\/\/ Utility functions\n+extern \"C\" JNIEXPORT int\n+JVM_handle_bsd_signal(int sig,\n+                        siginfo_t* info,\n+                        void* ucVoid,\n+                        int abort_if_unrecognized) {\n+  ucontext_t* uc = (ucontext_t*) ucVoid;\n+\n+  Thread* t = Thread::current_or_null_safe();\n+\n+  \/\/ Must do this before SignalHandlerMark, if crash protection installed we will longjmp away\n+  \/\/ (no destructors can be run)\n+  os::ThreadCrashProtection::check_crash_protection(sig, t);\n+\n+  SignalHandlerMark shm(t);\n+\n+  \/\/ Note: it's not uncommon that JNI code uses signal\/sigset to install\n+  \/\/ then restore certain signal handler (e.g. to temporarily block SIGPIPE,\n+  \/\/ or have a SIGILL handler when detecting CPU type). When that happens,\n+  \/\/ JVM_handle_bsd_signal() might be invoked with junk info\/ucVoid. To\n+  \/\/ avoid unnecessary crash when libjsig is not preloaded, try handle signals\n+  \/\/ that do not require siginfo\/ucontext first.\n+\n+  if (sig == SIGPIPE || sig == SIGXFSZ) {\n+    \/\/ allow chained handler to go first\n+    if (os::Bsd::chained_handler(sig, info, ucVoid)) {\n+      return true;\n+    } else {\n+      \/\/ Ignoring SIGPIPE\/SIGXFSZ - see bugs 4229104 or 6499219\n+      return true;\n+    }\n+  }\n+\n+#ifdef CAN_SHOW_REGISTERS_ON_ASSERT\n+  if ((sig == SIGSEGV || sig == SIGBUS) && info != NULL && info->si_addr == g_assert_poison) {\n+    if (handle_assert_poison_fault(ucVoid, info->si_addr)) {\n+      return 1;\n+    }\n+  }\n+#endif\n+\n+  JavaThread* thread = NULL;\n+  VMThread* vmthread = NULL;\n+  if (os::Bsd::signal_handlers_are_installed) {\n+    if (t != NULL ){\n+      if(t->is_Java_thread()) {\n+        thread = (JavaThread*)t;\n+      }\n+      else if(t->is_VM_thread()){\n+        vmthread = (VMThread *)t;\n+      }\n+    }\n+  }\n+\n+  \/\/ Handle SafeFetch faults:\n+  if (uc != NULL) {\n+    address const pc = (address) os::Bsd::ucontext_get_pc(uc);\n+    if (pc && StubRoutines::is_safefetch_fault(pc)) {\n+      os::Bsd::ucontext_set_pc(uc, StubRoutines::continuation_for_safefetch_fault(pc));\n+      return 1;\n+    }\n+  }\n+\n+  \/\/ decide if this trap can be handled by a stub\n+  address stub = NULL;\n+\n+  address pc          = NULL;\n+\n+  \/\/%note os_trap_1\n+  if (info != NULL && uc != NULL && thread != NULL) {\n+    pc = (address) os::Bsd::ucontext_get_pc(uc);\n+\n+    \/\/ Handle ALL stack overflow variations here\n+    if (sig == SIGSEGV || sig == SIGBUS) {\n+      address addr = (address) info->si_addr;\n+\n+      \/\/ check if fault address is within thread stack\n+      if (thread->on_local_stack(addr)) {\n+        ThreadWXEnable wx(WXWrite, thread);\n+        \/\/ stack overflow\n+        if (thread->in_stack_yellow_reserved_zone(addr)) {\n+          if (thread->thread_state() == _thread_in_Java) {\n+            if (thread->in_stack_reserved_zone(addr)) {\n+              frame fr;\n+              if (os::Bsd::get_frame_at_stack_banging_point(thread, uc, &fr)) {\n+                assert(fr.is_java_frame(), \"Must be a Java frame\");\n+                frame activation =\n+                  SharedRuntime::look_for_reserved_stack_annotated_method(thread, fr);\n+                if (activation.sp() != NULL) {\n+                  thread->disable_stack_reserved_zone();\n+                  if (activation.is_interpreted_frame()) {\n+                    thread->set_reserved_stack_activation((address)(\n+                      activation.fp() + frame::interpreter_frame_initial_sp_offset));\n+                  } else {\n+                    thread->set_reserved_stack_activation((address)activation.unextended_sp());\n+                  }\n+                  return 1;\n+                }\n+              }\n+            }\n+            \/\/ Throw a stack overflow exception.  Guard pages will be reenabled\n+            \/\/ while unwinding the stack.\n+            thread->disable_stack_yellow_reserved_zone();\n+            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::STACK_OVERFLOW);\n+          } else {\n+            \/\/ Thread was in the vm or native code.  Return and try to finish.\n+            thread->disable_stack_yellow_reserved_zone();\n+            return 1;\n+          }\n+        } else if (thread->in_stack_red_zone(addr)) {\n+          \/\/ Fatal red zone violation.  Disable the guard pages and fall through\n+          \/\/ to handle_unexpected_exception way down below.\n+          thread->disable_stack_red_zone();\n+          tty->print_raw_cr(\"An irrecoverable stack overflow has occurred.\");\n+        }\n+      }\n+    }\n+\n+    \/\/ We test if stub is already set (by the stack overflow code\n+    \/\/ above) so it is not overwritten by the code that follows. This\n+    \/\/ check is not required on other platforms, because on other\n+    \/\/ platforms we check for SIGSEGV only or SIGBUS only, where here\n+    \/\/ we have to check for both SIGSEGV and SIGBUS.\n+    if (thread->thread_state() == _thread_in_Java && stub == NULL) {\n+      \/\/ Java thread running in Java code => find exception handler if any\n+      \/\/ a fault inside compiled code, the interpreter, or a stub\n+      ThreadWXEnable wx(WXWrite, thread);\n+      \/\/ Handle signal from NativeJump::patch_verified_entry().\n+      if ((sig == SIGILL)\n+          && nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: zombie_not_entrant\");\n+        }\n+        stub = SharedRuntime::get_handle_wrong_method_stub();\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) && os::is_poll_address((address)info->si_addr)) {\n+        stub = SharedRuntime::get_poll_stub(pc);\n+#if defined(__APPLE__)\n+      \/\/ 32-bit Darwin reports a SIGBUS for nearly all memory access exceptions.\n+      \/\/ 64-bit Darwin may also use a SIGBUS (seen with compressed oops).\n+      \/\/ Catching SIGBUS here prevents the implicit SIGBUS NULL check below from\n+      \/\/ being called, so only do so if the implicit NULL check is not necessary.\n+      } else if (sig == SIGBUS && MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {\n+#else\n+      } else if (sig == SIGBUS \/* && info->si_code == BUS_OBJERR *\/) {\n+#endif\n+        \/\/ BugId 4454115: A read from a MappedByteBuffer can fault\n+        \/\/ here if the underlying file has been truncated.\n+        \/\/ Do not crash the VM in such a case.\n+        CodeBlob* cb = CodeCache::find_blob_unsafe(pc);\n+        CompiledMethod* nm = (cb != NULL) ? cb->as_compiled_method_or_null() : NULL;\n+        if ((nm != NULL && nm->has_unsafe_access())) {\n+          address next_pc = pc + NativeCall::instruction_size;\n+          stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+        }\n+      }\n+      else\n+\n+      if (sig == SIGFPE  &&\n+          (info->si_code == FPE_INTDIV || info->si_code == FPE_FLTDIV)) {\n+        stub =\n+          SharedRuntime::\n+          continuation_for_implicit_exception(thread,\n+                                              pc,\n+                                              SharedRuntime::\n+                                              IMPLICIT_DIVIDE_BY_ZERO);\n+#ifdef __APPLE__\n+      } else if (sig == SIGFPE && info->si_code == FPE_NOOP) {\n+        Unimplemented();\n+#endif \/* __APPLE__ *\/\n+\n+      } else if ((sig == SIGSEGV || sig == SIGBUS) &&\n+                 !MacroAssembler::needs_explicit_null_check((intptr_t)info->si_addr)) {\n+          \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n+          stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n+      }\n+    } else if ((thread->thread_state() == _thread_in_vm ||\n+                 thread->thread_state() == _thread_in_native) &&\n+               sig == SIGBUS && \/* info->si_code == BUS_OBJERR && *\/\n+               thread->doing_unsafe_access()) {\n+      address next_pc = pc + NativeCall::instruction_size;\n+      stub = SharedRuntime::handle_unsafe_access(thread, next_pc);\n+    }\n+\n+    \/\/ jni_fast_Get<Primitive>Field can trap at certain pc's if a GC kicks in\n+    \/\/ and the heap gets shrunk before the field access.\n+    if ((sig == SIGSEGV) || (sig == SIGBUS)) {\n+      address addr = JNI_FastGetField::find_slowcase_pc(pc);\n+      if (addr != (address)-1) {\n+        stub = addr;\n+      }\n+    }\n+\n+    \/\/ Check to see if we caught the safepoint code in the\n+    \/\/ process of write protecting the memory serialization page.\n+    \/\/ It write enables the page immediately after protecting it\n+    \/\/ so we can just return to retry the write.\n+    if ((sig == SIGSEGV) &&\n+        os::is_memory_serialize_page(thread, (address) info->si_addr)) {\n+      \/\/ Block current thread until the memory serialize page permission restored.\n+      os::block_on_serialize_page_trap();\n+      return true;\n+    }\n+  }\n+\n+  if (stub != NULL) {\n+    \/\/ save all thread context in case we need to restore it\n+    if (thread != NULL) thread->set_saved_exception_pc(pc);\n+\n+    os::Bsd::ucontext_set_pc(uc, stub);\n+    return true;\n+  }\n+\n+  \/\/ signal-chaining\n+  if (os::Bsd::chained_handler(sig, info, ucVoid)) {\n+     return true;\n+  }\n+\n+  if (!abort_if_unrecognized) {\n+    \/\/ caller wants another chance, so give it to him\n+    return false;\n+  }\n+\n+  if (pc == NULL && uc != NULL) {\n+    pc = os::Bsd::ucontext_get_pc(uc);\n+  }\n+\n+  \/\/ unmask current signal\n+  sigset_t newset;\n+  sigemptyset(&newset);\n+  sigaddset(&newset, sig);\n+  sigprocmask(SIG_UNBLOCK, &newset, NULL);\n+\n+  VMError::report_and_die(t, sig, pc, info, ucVoid);\n+\n+  ShouldNotReachHere();\n+  return true; \/\/ Mute compiler\n+}\n+\n+void os::Bsd::init_thread_fpu_state(void) {\n+}\n+\n+bool os::is_allocatable(size_t bytes) {\n+  return true;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ thread stack\n+\n+\/\/ Minimum usable stack sizes required to get to user code. Space for\n+\/\/ HotSpot guard pages is added later.\n+size_t os::Posix::_compiler_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_java_thread_min_stack_allowed = 72 * K;\n+size_t os::Posix::_vm_internal_thread_min_stack_allowed = 72 * K;\n+\n+\/\/ return default stack size for thr_type\n+size_t os::Posix::default_stack_size(os::ThreadType thr_type) {\n+  \/\/ default stack size (compiler thread needs larger stack)\n+  size_t s = (thr_type == os::compiler_thread ? 4 * M : 1 * M);\n+  return s;\n+}\n+\n+static void current_stack_region(address * bottom, size_t * size) {\n+#ifdef __APPLE__\n+  pthread_t self = pthread_self();\n+  void *stacktop = pthread_get_stackaddr_np(self);\n+  *size = pthread_get_stacksize_np(self);\n+  *bottom = (address) stacktop - *size;\n+#elif defined(__OpenBSD__)\n+  stack_t ss;\n+  int rslt = pthread_stackseg_np(pthread_self(), &ss);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_stackseg_np failed with error = %d\", rslt);\n+\n+  *bottom = (address)((char *)ss.ss_sp - ss.ss_size);\n+  *size   = ss.ss_size;\n+#else\n+  pthread_attr_t attr;\n+\n+  int rslt = pthread_attr_init(&attr);\n+\n+  \/\/ JVM needs to know exact stack location, abort if it fails\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_init failed with error = %d\", rslt);\n+\n+  rslt = pthread_attr_get_np(pthread_self(), &attr);\n+\n+  if (rslt != 0)\n+    fatal(\"pthread_attr_get_np failed with error = %d\", rslt);\n+\n+  if (pthread_attr_getstackaddr(&attr, (void **)bottom) != 0 ||\n+    pthread_attr_getstacksize(&attr, size) != 0) {\n+    fatal(\"Can not locate current stack attributes!\");\n+  }\n+\n+  pthread_attr_destroy(&attr);\n+#endif\n+  assert(os::current_stack_pointer() >= *bottom &&\n+         os::current_stack_pointer() < *bottom + *size, \"just checking\");\n+}\n+\n+address os::current_stack_base() {\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return (bottom + size);\n+}\n+\n+size_t os::current_stack_size() {\n+  \/\/ stack size includes normal stack and HotSpot guard pages\n+  address bottom;\n+  size_t size;\n+  current_stack_region(&bottom, &size);\n+  return size;\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ helper functions for fatal error handler\n+\n+void os::print_context(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+  st->print_cr(\"Registers:\");\n+  st->print( \" x0=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 0]);\n+  st->print(\"  x1=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 1]);\n+  st->print(\"  x2=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 2]);\n+  st->print(\"  x3=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 3]);\n+  st->cr();\n+  st->print( \" x4=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 4]);\n+  st->print(\"  x5=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 5]);\n+  st->print(\"  x6=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 6]);\n+  st->print(\"  x7=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 7]);\n+  st->cr();\n+  st->print( \" x8=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 8]);\n+  st->print(\"  x9=\" INTPTR_FORMAT, (intptr_t)uc->context_x[ 9]);\n+  st->print(\" x10=\" INTPTR_FORMAT, (intptr_t)uc->context_x[10]);\n+  st->print(\" x11=\" INTPTR_FORMAT, (intptr_t)uc->context_x[11]);\n+  st->cr();\n+  st->print( \"x12=\" INTPTR_FORMAT, (intptr_t)uc->context_x[12]);\n+  st->print(\" x13=\" INTPTR_FORMAT, (intptr_t)uc->context_x[13]);\n+  st->print(\" x14=\" INTPTR_FORMAT, (intptr_t)uc->context_x[14]);\n+  st->print(\" x15=\" INTPTR_FORMAT, (intptr_t)uc->context_x[15]);\n+  st->cr();\n+  st->print( \"x16=\" INTPTR_FORMAT, (intptr_t)uc->context_x[16]);\n+  st->print(\" x17=\" INTPTR_FORMAT, (intptr_t)uc->context_x[17]);\n+  st->print(\" x18=\" INTPTR_FORMAT, (intptr_t)uc->context_x[18]);\n+  st->print(\" x19=\" INTPTR_FORMAT, (intptr_t)uc->context_x[19]);\n+  st->cr();\n+  st->print( \"x20=\" INTPTR_FORMAT, (intptr_t)uc->context_x[20]);\n+  st->print(\" x21=\" INTPTR_FORMAT, (intptr_t)uc->context_x[21]);\n+  st->print(\" x22=\" INTPTR_FORMAT, (intptr_t)uc->context_x[22]);\n+  st->print(\" x23=\" INTPTR_FORMAT, (intptr_t)uc->context_x[23]);\n+  st->cr();\n+  st->print( \"x24=\" INTPTR_FORMAT, (intptr_t)uc->context_x[24]);\n+  st->print(\" x25=\" INTPTR_FORMAT, (intptr_t)uc->context_x[25]);\n+  st->print(\" x26=\" INTPTR_FORMAT, (intptr_t)uc->context_x[26]);\n+  st->print(\" x27=\" INTPTR_FORMAT, (intptr_t)uc->context_x[27]);\n+  st->cr();\n+  st->print( \"x28=\" INTPTR_FORMAT, (intptr_t)uc->context_x[28]);\n+  st->print(\"  fp=\" INTPTR_FORMAT, (intptr_t)uc->context_fp);\n+  st->print(\"  lr=\" INTPTR_FORMAT, (intptr_t)uc->context_lr);\n+  st->print(\"  sp=\" INTPTR_FORMAT, (intptr_t)uc->context_sp);\n+  st->cr();\n+  st->print(  \"pc=\" INTPTR_FORMAT,  (intptr_t)uc->context_pc);\n+  st->print(\" cpsr=\" INTPTR_FORMAT, (intptr_t)uc->context_cpsr);\n+  st->cr();\n+\n+  intptr_t *sp = (intptr_t *)os::Bsd::ucontext_get_sp(uc);\n+  st->print_cr(\"Top of Stack: (sp=\" INTPTR_FORMAT \")\", (intptr_t)sp);\n+  print_hex_dump(st, (address)sp, (address)(sp + 8*sizeof(intptr_t)), sizeof(intptr_t));\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = os::Bsd::ucontext_get_pc(uc);\n+  print_instructions(st, pc, sizeof(char));\n+  st->cr();\n+}\n+\n+void os::print_register_info(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const ucontext_t *uc = (const ucontext_t*)context;\n+\n+  st->print_cr(\"Register to memory mapping:\");\n+  st->cr();\n+\n+  \/\/ this is horrendously verbose but the layout of the registers in the\n+  \/\/ context does not match how we defined our abstract Register set, so\n+  \/\/ we can't just iterate through the gregs area\n+\n+  \/\/ this is only for the \"general purpose\" registers\n+\n+  st->print(\" x0=\"); print_location(st, uc->context_x[ 0]);\n+  st->print(\" x1=\"); print_location(st, uc->context_x[ 1]);\n+  st->print(\" x2=\"); print_location(st, uc->context_x[ 2]);\n+  st->print(\" x3=\"); print_location(st, uc->context_x[ 3]);\n+  st->print(\" x4=\"); print_location(st, uc->context_x[ 4]);\n+  st->print(\" x5=\"); print_location(st, uc->context_x[ 5]);\n+  st->print(\" x6=\"); print_location(st, uc->context_x[ 6]);\n+  st->print(\" x7=\"); print_location(st, uc->context_x[ 7]);\n+  st->print(\" x8=\"); print_location(st, uc->context_x[ 8]);\n+  st->print(\" x9=\"); print_location(st, uc->context_x[ 9]);\n+  st->print(\"x10=\"); print_location(st, uc->context_x[10]);\n+  st->print(\"x11=\"); print_location(st, uc->context_x[11]);\n+  st->print(\"x12=\"); print_location(st, uc->context_x[12]);\n+  st->print(\"x13=\"); print_location(st, uc->context_x[13]);\n+  st->print(\"x14=\"); print_location(st, uc->context_x[14]);\n+  st->print(\"x15=\"); print_location(st, uc->context_x[15]);\n+  st->print(\"x16=\"); print_location(st, uc->context_x[16]);\n+  st->print(\"x17=\"); print_location(st, uc->context_x[17]);\n+  st->print(\"x18=\"); print_location(st, uc->context_x[18]);\n+  st->print(\"x19=\"); print_location(st, uc->context_x[19]);\n+  st->print(\"x20=\"); print_location(st, uc->context_x[20]);\n+  st->print(\"x21=\"); print_location(st, uc->context_x[21]);\n+  st->print(\"x22=\"); print_location(st, uc->context_x[22]);\n+  st->print(\"x23=\"); print_location(st, uc->context_x[23]);\n+  st->print(\"x24=\"); print_location(st, uc->context_x[24]);\n+  st->print(\"x25=\"); print_location(st, uc->context_x[25]);\n+  st->print(\"x26=\"); print_location(st, uc->context_x[26]);\n+  st->print(\"x27=\"); print_location(st, uc->context_x[27]);\n+  st->print(\"x28=\"); print_location(st, uc->context_x[28]);\n+\n+  st->cr();\n+}\n+\n+void os::setup_fpu() {\n+}\n+\n+#ifndef PRODUCT\n+void os::verify_stack_alignment() {\n+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+}\n+#endif\n+\n+int os::extra_bang_size_in_bytes() {\n+  \/\/ AArch64 does not require the additional stack bang.\n+  return 0;\n+}\n+\n+void os::current_thread_enable_wx(WXMode mode) {\n+  pthread_jit_write_protect_np(mode == WXExec);\n+}\n+\n+extern \"C\" {\n+  int SpinPause() {\n+    return 0;\n+  }\n+\n+  void _Copy_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+    if (from > to) {\n+      const jshort *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jshort *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+    if (from > to) {\n+      const jint *end = from + count;\n+      while (from < end)\n+        *(to++) = *(from++);\n+    }\n+    else if (from < to) {\n+      const jint *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        *(to--) = *(from--);\n+    }\n+  }\n+  void _Copy_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+    if (from > to) {\n+      const jlong *end = from + count;\n+      while (from < end)\n+        os::atomic_copy64(from++, to++);\n+    }\n+    else if (from < to) {\n+      const jlong *end = from;\n+      from += count - 1;\n+      to   += count - 1;\n+      while (from >= end)\n+        os::atomic_copy64(from--, to--);\n+    }\n+  }\n+\n+  void _Copy_arrayof_conjoint_bytes(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count);\n+  }\n+  void _Copy_arrayof_conjoint_jshorts(const HeapWord* from,\n+                                      HeapWord* to,\n+                                      size_t    count) {\n+    memmove(to, from, count * 2);\n+  }\n+  void _Copy_arrayof_conjoint_jints(const HeapWord* from,\n+                                    HeapWord* to,\n+                                    size_t    count) {\n+    memmove(to, from, count * 4);\n+  }\n+  void _Copy_arrayof_conjoint_jlongs(const HeapWord* from,\n+                                     HeapWord* to,\n+                                     size_t    count) {\n+    memmove(to, from, count * 8);\n+  }\n+};\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":753,"deletions":0,"binary":false,"changes":753,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_OS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_VM_OS_BSD_AARCH64_HPP\n+\n+  static void setup_fpu();\n+\n+  static bool is_allocatable(size_t bytes);\n+\n+  \/\/ Used to register dynamic code cache area with the OS\n+  \/\/ Note: Currently only used in 64 bit Windows implementations\n+  static bool register_code_area(char *low, char *high) { return true; }\n+\n+  \/\/ Atomically copy 64 bits of data\n+  static void atomic_copy64(const volatile void *src, volatile void *dst) {\n+    *(jlong *) dst = *(const jlong *) src;\n+  }\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_OS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_PAUTH_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_VM_PAUTH_BSD_AARCH64_INLINE_HPP\n+\n+#ifdef __APPLE__\n+#include <ptrauth.h>\n+#endif\n+\n+\/\/ Only the PAC instructions in the NOP space can be used. This ensures the\n+\/\/ binaries work on systems without PAC. Write these instructions using their\n+\/\/ alternate \"hint\" instructions to ensure older compilers can still be used.\n+\/\/ For Apple, use the provided interface as this may provide additional\n+\/\/ optimization.\n+\n+#define XPACLRI \"hint #0x7;\"\n+\n+inline address pauth_strip_pointer(address ptr) {\n+#ifdef __APPLE__\n+  return ptrauth_strip(ptr, ptrauth_key_asib);\n+#else\n+  register address result __asm__(\"x30\") = ptr;\n+  asm (XPACLRI : \"+r\"(result));\n+  return result;\n+#endif\n+}\n+\n+#undef XPACLRI\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_PAUTH_BSD_AARCH64_INLINE_HPP\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/pauth_bsd_aarch64.inline.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2003, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_PREFETCH_BSD_AARCH64_INLINE_HPP\n+#define OS_CPU_BSD_AARCH64_VM_PREFETCH_BSD_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/prefetch.hpp\"\n+\n+\n+inline void Prefetch::read (void *loc, intx interval) {\n+  if (interval >= 0)\n+    asm(\"prfm PLDL1KEEP, [%0, %1]\" : : \"r\"(loc), \"r\"(interval));\n+}\n+\n+inline void Prefetch::write(void *loc, intx interval) {\n+  if (interval >= 0)\n+    asm(\"prfm PSTL1KEEP, [%0, %1]\" : : \"r\"(loc), \"r\"(interval));\n+}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_PREFETCH_BSD_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/prefetch_bsd_aarch64.inline.hpp","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+frame JavaThread::pd_last_frame() {\n+  assert(has_last_Java_frame(), \"must have last_Java_sp() when suspended\");\n+  vmassert(_anchor.last_Java_pc() != NULL, \"not walkable\");\n+  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());\n+}\n+\n+\/\/ For Forte Analyzer AsyncGetCallTrace profiling support - thread is\n+\/\/ currently interrupted by SIGPROF\n+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,\n+  void* ucontext, bool isInJava) {\n+\n+  assert(Thread::current() == this, \"caller must be current thread\");\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava) {\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {\n+  assert(this->is_Java_thread(), \"must be JavaThread\");\n+  JavaThread* jt = (JavaThread *)this;\n+\n+  \/\/ If we have a last_Java_frame, then we should use it even if\n+  \/\/ isInJava == true.  It should be more reliable than ucontext info.\n+  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {\n+    *fr_addr = jt->pd_last_frame();\n+    return true;\n+  }\n+\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the ucontext\n+  \/\/ if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    ucontext_t* uc = (ucontext_t*) ucontext;\n+\n+    intptr_t* ret_fp;\n+    intptr_t* ret_sp;\n+    ExtendedPC addr = os::fetch_frame_from_context(uc, &ret_sp, &ret_fp);\n+    if (addr.pc() == NULL || ret_sp == NULL ) {\n+      \/\/ ucontext wasn't useful\n+      return false;\n+    }\n+\n+    if (MetaspaceShared::is_in_trampoline_frame(addr.pc())) {\n+      \/\/ In the middle of a trampoline call. Bail out for safety.\n+      \/\/ This happens rarely so shouldn't affect profiling.\n+      return false;\n+    }\n+\n+    frame ret_frame(ret_sp, ret_fp, addr.pc());\n+    if (!ret_frame.safe_for_sender(jt)) {\n+#ifdef COMPILER2\n+      frame ret_frame2(ret_sp, NULL, addr.pc());\n+      if (!ret_frame2.safe_for_sender(jt)) {\n+        \/\/ nothing else to try if the frame isn't good\n+        return false;\n+      }\n+      ret_frame = ret_frame2;\n+#else\n+      \/\/ nothing else to try if the frame isn't good\n+      return false;\n+#endif \/* COMPILER2 *\/\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+\n+  \/\/ nothing else to try\n+  return false;\n+}\n+\n+void JavaThread::cache_global_variables() { }\n+\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_THREAD_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_VM_THREAD_BSD_AARCH64_HPP\n+\n+ private:\n+\n+  void pd_initialize() {\n+    _anchor.clear();\n+  }\n+\n+  frame pd_last_frame();\n+\n+ public:\n+  \/\/ Mutators are highly dangerous....\n+  intptr_t* last_Java_fp()                       { return _anchor.last_Java_fp(); }\n+  void  set_last_Java_fp(intptr_t* fp)           { _anchor.set_last_Java_fp(fp);   }\n+\n+  void set_base_of_stack_pointer(intptr_t* base_sp) {\n+  }\n+\n+  static ByteSize last_Java_fp_offset()          {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n+  }\n+\n+  intptr_t* base_of_stack_pointer() {\n+    return NULL;\n+  }\n+  void record_base_of_stack_pointer() {\n+  }\n+\n+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n+    bool isInJava);\n+\n+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n+private:\n+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n+public:\n+\n+  static Thread *aarch64_get_thread_helper() {\n+    return Thread::current();\n+  }\n+\n+  \/\/ These routines are only used on cpu architectures that\n+  \/\/ have separate register stacks (Itanium).\n+  static bool register_stack_overflow() { return false; }\n+  static void enable_register_stack_guard() {}\n+  static void disable_register_stack_guard() {}\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_THREAD_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/thread_bsd_aarch64.hpp","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_BSD_AARCH64_VM_VMSTRUCTS_BSD_AARCH64_HPP\n+#define OS_CPU_BSD_AARCH64_VM_VMSTRUCTS_BSD_AARCH64_HPP\n+\n+\/\/ These are the OS and CPU-specific fields, types and integer\n+\/\/ constants required by the Serviceability Agent. This file is\n+\/\/ referenced by vmStructs.cpp.\n+\n+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \\\n+                                                                                                                                     \\\n+  \/******************************\/                                                                                                   \\\n+  \/* Threads (NOTE: incomplete) *\/                                                                                                   \\\n+  \/******************************\/                                                                                                   \\\n+  nonstatic_field(OSThread,                      _thread_id,                                      OSThread::thread_id_t)             \\\n+  nonstatic_field(OSThread,                      _unique_thread_id,                               uint64_t)\n+\n+\n+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \\\n+                                                                          \\\n+  \/**********************\/                                                \\\n+  \/* Thread IDs         *\/                                                \\\n+  \/**********************\/                                                \\\n+                                                                          \\\n+  declare_unsigned_integer_type(OSThread::thread_id_t)\n+\n+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#endif \/\/ OS_CPU_BSD_AARCH64_VM_VMSTRUCTS_BSD_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vmStructs_bsd_aarch64.hpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2006, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include <sys\/sysctl.h>\n+\n+static bool cpu_has(const char* optional) {\n+  uint32_t val;\n+  size_t len = sizeof(val);\n+  if (sysctlbyname(optional, &val, &len, NULL, 0)) {\n+    return false;\n+  }\n+  return val;\n+}\n+\n+void VM_Version::get_os_cpu_info() {\n+  size_t sysctllen;\n+\n+  \/\/ hw.optional.floatingpoint always returns 1, see\n+  \/\/ https:\/\/github.com\/apple\/darwin-xnu\/blob\/master\/bsd\/kern\/kern_mib.c#L416.\n+  \/\/ ID_AA64PFR0_EL1 describes AdvSIMD always equals to FP field.\n+  assert(cpu_has(\"hw.optional.floatingpoint\"), \"should be\");\n+  assert(cpu_has(\"hw.optional.neon\"), \"should be\");\n+  _features = CPU_FP | CPU_ASIMD;\n+\n+  \/\/ Only few features are available via sysctl, see line 614\n+  \/\/ https:\/\/opensource.apple.com\/source\/xnu\/xnu-6153.141.1\/bsd\/kern\/kern_mib.c.auto.html\n+  if (cpu_has(\"hw.optional.armv8_crc32\"))     _features |= CPU_CRC32;\n+  if (cpu_has(\"hw.optional.armv8_1_atomics\")) _features |= CPU_LSE;\n+\n+  int cache_line_size;\n+  int hw_conf_cache_line[] = { CTL_HW, HW_CACHELINE };\n+  sysctllen = sizeof(cache_line_size);\n+  if (sysctl(hw_conf_cache_line, 2, &cache_line_size, &sysctllen, NULL, 0)) {\n+    cache_line_size = 16;\n+  }\n+  _icache_line_size = 16; \/\/ minimal line lenght CCSIDR_EL1 can hold\n+  _dcache_line_size = cache_line_size;\n+\n+  uint64_t dczid_el0;\n+  __asm__ (\n+    \"mrs %0, DCZID_EL0\\n\"\n+    : \"=r\"(dczid_el0)\n+  );\n+  if (!(dczid_el0 & 0x10)) {\n+    _zva_length = 4 << (dczid_el0 & 0xf);\n+  }\n+  int family;\n+  sysctllen = sizeof(family);\n+  if (sysctlbyname(\"hw.cpufamily\", &family, &sysctllen, NULL, 0)) {\n+    family = 0;\n+   }\n+  _model = family;\n+  _cpu = CPU_APPLE;\n+}\n+\n+#ifdef __APPLE__\n+\n+bool VM_Version::is_cpu_emulated() {\n+  return false;\n+}\n+\n+#endif\n\\ No newline at end of file\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/vm_version_bsd_aarch64.cpp","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -837,0 +837,4 @@\n+  \/\/ Enable WXWrite: the function is called by c1 stub as a runtime function\n+  \/\/ (see another implementation above).\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1018,0 +1018,3 @@\n+  \/\/ Enable WXWrite: the function is called directly by interpreter.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -244,0 +244,2 @@\n+  void pass_byte()                               { \/* ignore *\/ }\n+  void pass_short()                              { \/* ignore *\/ }\n","filename":"src\/hotspot\/share\/interpreter\/oopMapCache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread)); \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -1447,0 +1448,4 @@\n+\n+  \/\/ Enable WXWrite: the function called directly by compiled code.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4,0 +4,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -4058,0 +4059,1 @@\n+    MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -4213,0 +4215,1 @@\n+  MACOS_AARCH64_ONLY(thread->init_wx());\n@@ -4287,0 +4290,1 @@\n+  MACOS_AARCH64_ONLY(thread->enable_wx(WXExec));\n@@ -4357,0 +4361,4 @@\n+  \/\/ Go to the execute mode, the initial state of the thread on creation.\n+  \/\/ Use os interface as the thread is not a JavaThread anymore.\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -103,0 +103,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thr));         \\\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+#ifdef AARCH64\n+  template<int BType>\n+  static address generate_fast_get_int_field1();\n+#endif \/\/ AARCH64\n+\n","filename":"src\/hotspot\/share\/prims\/jniFastGetField.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -435,0 +435,2 @@\n+    <xsl:text>MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));<\/xsl:text>\n+    <xsl:value-of select=\"$space\"\/>\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnter.xsl","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, current_thread));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,2 @@\n-  ClearPendingJniExcCheck _clearCheck(env);\n+  ClearPendingJniExcCheck _clearCheck(env); \\\n+  MACOS_AARCH64_ONLY(ThreadWXEnable _wx(WXWrite, thread));\n","filename":"src\/hotspot\/share\/prims\/whitebox.inline.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -2076,0 +2077,3 @@\n+  \/\/ Enable WXWrite: current function is called from methods compiled by C2 directly\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -35,0 +36,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -406,0 +408,2 @@\n+  MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite,                    \\\n+                                         Thread::current()));        \\\n@@ -443,0 +447,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -456,0 +461,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -464,0 +470,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -477,1 +484,2 @@\n-    ThreadInVMfromJavaNoAsyncException __tiv(thread);                \\\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n+    ThreadInVMfromJava __tiv(thread);                                \\\n@@ -485,0 +493,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -515,0 +524,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -551,0 +561,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n@@ -560,0 +571,1 @@\n+    MACOS_AARCH64_ONLY(ThreadWXEnable __wx(WXWrite, thread));        \\\n","filename":"src\/hotspot\/share\/runtime\/interfaceSupport.inline.hpp","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -82,1 +83,0 @@\n-\n@@ -116,0 +116,2 @@\n+\n+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXExec));\n@@ -122,0 +124,2 @@\n+  MACOS_AARCH64_ONLY(_thread->enable_wx(WXWrite));\n+\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -84,0 +84,5 @@\n+enum WXMode {\n+  WXWrite,\n+  WXExec\n+};\n+\n@@ -967,0 +972,5 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+  \/\/ Enables write or execute access to writeable and executable pages.\n+  static void current_thread_enable_wx(WXMode mode);\n+#endif \/\/ __APPLE__ && AARCH64\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -34,0 +35,5 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+  Thread* thread = Thread::current_or_null_safe();\n+  assert(thread != NULL, \"required for W^X management\");\n+  ThreadWXEnable wx(WXExec, thread);\n+#endif \/\/ __APPLE__ && AARCH64\n@@ -39,0 +45,5 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+  Thread* thread = Thread::current_or_null_safe();\n+  assert(thread != NULL, \"required for W^X management\");\n+  ThreadWXEnable wx(WXExec, thread);\n+#endif \/\/ __APPLE__ && AARCH64\n","filename":"src\/hotspot\/share\/runtime\/safefetch.inline.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -957,0 +958,3 @@\n+  \/\/ Enable WXWrite: the function is called implicitly from java code.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -285,2 +286,2 @@\n-  void do_bool  ()                     { pass_int();    _jni_offset++; _offset++;       }\n-  void do_char  ()                     { pass_int();    _jni_offset++; _offset++;       }\n+  void do_bool  ()                     { pass_byte();   _jni_offset++; _offset++;       }\n+  void do_char  ()                     { pass_short();  _jni_offset++; _offset++;       }\n@@ -293,2 +294,2 @@\n-  void do_byte  ()                     { pass_int();    _jni_offset++; _offset++;       }\n-  void do_short ()                     { pass_int();    _jni_offset++; _offset++;       }\n+  void do_byte  ()                     { pass_byte();   _jni_offset++; _offset++;       }\n+  void do_short ()                     { pass_short();  _jni_offset++; _offset++;       }\n@@ -315,0 +316,2 @@\n+  virtual void pass_byte()             { pass_int(); };\n+  virtual void pass_short()            { pass_int(); };\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -292,0 +292,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXExec));\n+\n@@ -372,0 +374,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -100,0 +101,1 @@\n+#include \"runtime\/threadWXSetters.inline.hpp\"\n@@ -320,0 +322,2 @@\n+\n+  MACOS_AARCH64_ONLY(DEBUG_ONLY(_wx_init = false));\n@@ -373,0 +377,2 @@\n+  MACOS_AARCH64_ONLY(this->init_wx());\n+\n@@ -2541,0 +2547,3 @@\n+  \/\/ Enable WXWrite: called directly from interpreter native wrapper.\n+  MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXWrite, thread));\n+\n@@ -3685,0 +3694,2 @@\n+  MACOS_AARCH64_ONLY(os::current_thread_enable_wx(WXWrite));\n+\n@@ -3788,0 +3799,1 @@\n+  MACOS_AARCH64_ONLY(main_thread->init_wx());\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -755,0 +756,9 @@\n+\n+#if defined(__APPLE__) && defined(AARCH64)\n+ private:\n+  DEBUG_ONLY(bool _wx_init);\n+  WXMode _wx_state;\n+ public:\n+  void init_wx();\n+  WXMode enable_wx(WXMode new_state);\n+#endif \/\/ __APPLE__ && AARCH64\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -96,0 +97,21 @@\n+#if defined(__APPLE__) && defined(AARCH64)\n+inline void Thread::init_wx() {\n+  assert(this == Thread::current(), \"should only be called for current thread\");\n+  assert(!_wx_init, \"second init\");\n+  _wx_state = WXWrite;\n+  os::current_thread_enable_wx(_wx_state);\n+  DEBUG_ONLY(_wx_init = true);\n+}\n+\n+inline WXMode Thread::enable_wx(WXMode new_state) {\n+  assert(this == Thread::current(), \"should only be called for current thread\");\n+  assert(_wx_init, \"should be inited\");\n+  WXMode old = _wx_state;\n+  if (_wx_state != new_state) {\n+    _wx_state = new_state;\n+    os::current_thread_enable_wx(new_state);\n+  }\n+  return old;\n+}\n+#endif \/\/ __APPLE__ && AARCH64\n+\n","filename":"src\/hotspot\/share\/runtime\/thread.inline.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP\n+#define SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP\n+\n+#include \"runtime\/thread.inline.hpp\"\n+\n+#if defined(__APPLE__) && defined(AARCH64)\n+class ThreadWXEnable  {\n+  Thread* _thread;\n+  WXMode _old_mode;\n+public:\n+  ThreadWXEnable(WXMode new_mode, Thread* thread) :\n+    _thread(thread),\n+    _old_mode(_thread ? _thread->enable_wx(new_mode) : WXWrite)\n+  { }\n+  ~ThreadWXEnable() {\n+    if (_thread) {\n+      _thread->enable_wx(_old_mode);\n+    }\n+  }\n+};\n+#endif \/\/ __APPLE__ && AARCH64\n+\n+#endif \/\/ SHARE_RUNTIME_THREADWXSETTERS_INLINE_HPP\n+\n","filename":"src\/hotspot\/share\/runtime\/threadWXSetters.inline.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -598,0 +598,2 @@\n+#define MACOS_AARCH64_ONLY(x) MACOS_ONLY(AARCH64_ONLY(x))\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64))\n+#if (defined(_NMT_NOINLINE_) || defined(_WINDOWS) || !defined(_LP64) || (defined(BSD) && defined (__aarch64__)))\n","filename":"src\/hotspot\/share\/utilities\/nativeCallStack.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,0 +213,2 @@\n+#elif defined(__aarch64__)\n+        preferredJVM = \"server\";\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,3 @@\n-#if TARGET_OS_MAC\n+\/\/ Condition was copied from\n+\/\/ Xcode.app\/Contents\/Developer\/Platforms\/MacOSX.platform\/Developer\/SDKs\/MacOSX.sdk\/usr\/include\/gssapi\/gssapi.h\n+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))\n@@ -698,1 +700,1 @@\n-#if TARGET_OS_MAC\n+#if TARGET_OS_MAC && (defined(__ppc__) || defined(__ppc64__) || defined(__i386__) || defined(__x86_64__))\n","filename":"src\/java.security.jgss\/share\/native\/libj2gss\/gssapi.h","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -45,7 +46,1 @@\n-#define UNSUPPORTED_ARCH \"Unsupported architecture!\"\n-\n-#if defined(x86_64) && !defined(amd64)\n-#define amd64 1\n-#endif\n-\n-#if amd64\n+#if defined(amd64)\n@@ -53,0 +48,2 @@\n+#elif defined(aarch64)\n+#include \"sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h\"\n@@ -165,8 +162,1 @@\n-#if defined(__i386__)\n-    #define hsdb_thread_state_t     x86_thread_state32_t\n-    #define hsdb_float_state_t      x86_float_state32_t\n-    #define HSDB_THREAD_STATE       x86_THREAD_STATE32\n-    #define HSDB_FLOAT_STATE        x86_FLOAT_STATE32\n-    #define HSDB_THREAD_STATE_COUNT x86_THREAD_STATE32_COUNT\n-    #define HSDB_FLOAT_STATE_COUNT  x86_FLOAT_STATE32_COUNT\n-#elif defined(__x86_64__)\n+#if defined(amd64)\n@@ -179,0 +169,7 @@\n+#elif defined(aarch64)\n+    #define hsdb_thread_state_t     arm_thread_state64_t\n+    #define hsdb_float_state_t      arm_neon_state64_t\n+    #define HSDB_THREAD_STATE       ARM_THREAD_STATE64\n+    #define HSDB_FLOAT_STATE        ARM_NEON_STATE64\n+    #define HSDB_THREAD_STATE_COUNT ARM_THREAD_STATE64_COUNT\n+    #define HSDB_FLOAT_STATE_COUNT  ARM_NEON_STATE64_COUNT\n@@ -496,0 +493,1 @@\n+#if defined(amd64)\n@@ -501,0 +499,9 @@\n+#elif defined(aarch64)\n+      if ((regs.r_sp < end && regs.r_sp >= beg) ||\n+          (regs.r_fp < end && regs.r_fp >= beg)) {\n+        set_lwp_id(ph, i, uid);\n+        break;\n+      }\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -532,1 +539,1 @@\n-#if amd64\n+#if defined(amd64)\n@@ -535,0 +542,6 @@\n+#elif defined(aarch64)\n+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG\n+#define REG_INDEX(reg) sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_##reg\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -540,0 +553,2 @@\n+#if defined(amd64)\n+\n@@ -568,1 +583,40 @@\n-#endif \/* amd64 *\/\n+#elif defined(aarch64)\n+\n+  regs[REG_INDEX(R0)] = gregs.r_r0;\n+  regs[REG_INDEX(R1)] = gregs.r_r1;\n+  regs[REG_INDEX(R2)] = gregs.r_r2;\n+  regs[REG_INDEX(R3)] = gregs.r_r3;\n+  regs[REG_INDEX(R4)] = gregs.r_r4;\n+  regs[REG_INDEX(R5)] = gregs.r_r5;\n+  regs[REG_INDEX(R6)] = gregs.r_r6;\n+  regs[REG_INDEX(R7)] = gregs.r_r7;\n+  regs[REG_INDEX(R8)] = gregs.r_r8;\n+  regs[REG_INDEX(R9)] = gregs.r_r9;\n+  regs[REG_INDEX(R10)] = gregs.r_r10;\n+  regs[REG_INDEX(R11)] = gregs.r_r11;\n+  regs[REG_INDEX(R12)] = gregs.r_r12;\n+  regs[REG_INDEX(R13)] = gregs.r_r13;\n+  regs[REG_INDEX(R14)] = gregs.r_r14;\n+  regs[REG_INDEX(R15)] = gregs.r_r15;\n+  regs[REG_INDEX(R16)] = gregs.r_r16;\n+  regs[REG_INDEX(R17)] = gregs.r_r17;\n+  regs[REG_INDEX(R18)] = gregs.r_r18;\n+  regs[REG_INDEX(R19)] = gregs.r_r19;\n+  regs[REG_INDEX(R20)] = gregs.r_r20;\n+  regs[REG_INDEX(R21)] = gregs.r_r21;\n+  regs[REG_INDEX(R22)] = gregs.r_r22;\n+  regs[REG_INDEX(R23)] = gregs.r_r23;\n+  regs[REG_INDEX(R24)] = gregs.r_r24;\n+  regs[REG_INDEX(R25)] = gregs.r_r25;\n+  regs[REG_INDEX(R26)] = gregs.r_r26;\n+  regs[REG_INDEX(R27)] = gregs.r_r27;\n+  regs[REG_INDEX(R28)] = gregs.r_r28;\n+  regs[REG_INDEX(FP)] = gregs.r_fp;\n+  regs[REG_INDEX(LR)] = gregs.r_lr;\n+  regs[REG_INDEX(SP)] = gregs.r_sp;\n+  regs[REG_INDEX(PC)] = gregs.r_pc;\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n+\n@@ -658,1 +712,2 @@\n-#if amd64\n+#undef NPRGREG\n+#if defined(amd64)\n@@ -660,2 +715,5 @@\n-#undef REG_INDEX\n-#define REG_INDEX(reg) sun_jvm_hotspot_debugger_amd64_AMD64ThreadContext_##reg\n+#elif defined(aarch64)\n+#define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -669,0 +727,2 @@\n+#if defined(amd64)\n+\n@@ -697,1 +757,0 @@\n-  print_debug(\"set registers\\n\");\n@@ -699,1 +758,35 @@\n-  (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);\n+#elif defined(aarch64)\n+\n+  primitiveArray[REG_INDEX(R0)] = state.__x[0];\n+  primitiveArray[REG_INDEX(R1)] = state.__x[1];\n+  primitiveArray[REG_INDEX(R2)] = state.__x[2];\n+  primitiveArray[REG_INDEX(R3)] = state.__x[3];\n+  primitiveArray[REG_INDEX(R4)] = state.__x[4];\n+  primitiveArray[REG_INDEX(R5)] = state.__x[5];\n+  primitiveArray[REG_INDEX(R6)] = state.__x[6];\n+  primitiveArray[REG_INDEX(R7)] = state.__x[7];\n+  primitiveArray[REG_INDEX(R8)] = state.__x[8];\n+  primitiveArray[REG_INDEX(R9)] = state.__x[9];\n+  primitiveArray[REG_INDEX(R10)] = state.__x[10];\n+  primitiveArray[REG_INDEX(R11)] = state.__x[11];\n+  primitiveArray[REG_INDEX(R12)] = state.__x[12];\n+  primitiveArray[REG_INDEX(R13)] = state.__x[13];\n+  primitiveArray[REG_INDEX(R14)] = state.__x[14];\n+  primitiveArray[REG_INDEX(R15)] = state.__x[15];\n+  primitiveArray[REG_INDEX(R16)] = state.__x[16];\n+  primitiveArray[REG_INDEX(R17)] = state.__x[17];\n+  primitiveArray[REG_INDEX(R18)] = state.__x[18];\n+  primitiveArray[REG_INDEX(R19)] = state.__x[19];\n+  primitiveArray[REG_INDEX(R20)] = state.__x[20];\n+  primitiveArray[REG_INDEX(R21)] = state.__x[21];\n+  primitiveArray[REG_INDEX(R22)] = state.__x[22];\n+  primitiveArray[REG_INDEX(R23)] = state.__x[23];\n+  primitiveArray[REG_INDEX(R24)] = state.__x[24];\n+  primitiveArray[REG_INDEX(R25)] = state.__x[25];\n+  primitiveArray[REG_INDEX(R26)] = state.__x[26];\n+  primitiveArray[REG_INDEX(R27)] = state.__x[27];\n+  primitiveArray[REG_INDEX(R28)] = state.__x[28];\n+  primitiveArray[REG_INDEX(FP)] = state.__fp;\n+  primitiveArray[REG_INDEX(LR)] = state.__lr;\n+  primitiveArray[REG_INDEX(SP)] = state.__sp;\n+  primitiveArray[REG_INDEX(PC)] = state.__pc;\n@@ -703,1 +796,3 @@\n-#endif \/* amd64 *\/\n+#endif\n+\n+  print_debug(\"set registers\\n\");\n@@ -705,0 +800,1 @@\n+  (*env)->ReleaseLongArrayElements(env, registerArray, primitiveArray, 0);\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":119,"deletions":23,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2003, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -33,0 +34,10 @@\n+#define UNSUPPORTED_ARCH \"Unsupported architecture!\"\n+\n+#if defined(__x86_64__) && !defined(amd64)\n+#define amd64 1\n+#endif\n+\n+#if defined(__arm64__) && !defined(aarch64)\n+#define aarch64 1\n+#endif\n+\n@@ -44,0 +55,1 @@\n+#if defined(amd64)\n@@ -74,0 +86,42 @@\n+#elif defined(aarch64)\n+\/*** registers copied from bsd\/arm64 *\/\n+typedef struct reg {\n+  register_t      r_r0;\n+  register_t      r_r1;\n+  register_t      r_r2;\n+  register_t      r_r3;\n+  register_t      r_r4;\n+  register_t      r_r5;\n+  register_t      r_r6;\n+  register_t      r_r7;\n+  register_t      r_r8;\n+  register_t      r_r9;\n+  register_t      r_r10;\n+  register_t      r_r11;\n+  register_t      r_r12;\n+  register_t      r_r13;\n+  register_t      r_r14;\n+  register_t      r_r15;\n+  register_t      r_r16;\n+  register_t      r_r17;\n+  register_t      r_r18;\n+  register_t      r_r19;\n+  register_t      r_r20;\n+  register_t      r_r21;\n+  register_t      r_r22;\n+  register_t      r_r23;\n+  register_t      r_r24;\n+  register_t      r_r25;\n+  register_t      r_r26;\n+  register_t      r_r27;\n+  register_t      r_r28;\n+  register_t      r_fp;\n+  register_t      r_lr;\n+  register_t      r_sp;\n+  register_t      r_pc;\n+} reg;\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n+\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/libproc_impl.h","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -35,0 +36,1 @@\n+#if defined(amd64)\n@@ -36,0 +38,4 @@\n+#elif defined(aarch64)\n+#include \"sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h\"\n+#else\n+#error UNSUPPORTED_ARCH\n@@ -37,0 +43,1 @@\n+#endif \/* __APPLE__ *\/\n@@ -523,0 +530,2 @@\n+\n+#if defined(amd64)\n@@ -544,0 +553,39 @@\n+\n+#elif defined(aarch64)\n+  print_debug(\" r_r0:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r0);\n+  print_debug(\" r_r1:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r1);\n+  print_debug(\" r_r2:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r2);\n+  print_debug(\" r_r3:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r3);\n+  print_debug(\" r_r4:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r4);\n+  print_debug(\" r_r5:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r5);\n+  print_debug(\" r_r6:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r6);\n+  print_debug(\" r_r7:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r7);\n+  print_debug(\" r_r8:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r8);\n+  print_debug(\" r_r9:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r9);\n+  print_debug(\" r_r10: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r10);\n+  print_debug(\" r_r11: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r11);\n+  print_debug(\" r_r12: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r12);\n+  print_debug(\" r_r13: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r13);\n+  print_debug(\" r_r14: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r14);\n+  print_debug(\" r_r15: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r15);\n+  print_debug(\" r_r16: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r16);\n+  print_debug(\" r_r17: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r17);\n+  print_debug(\" r_r18: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r18);\n+  print_debug(\" r_r19: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r19);\n+  print_debug(\" r_r20: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r20);\n+  print_debug(\" r_r21: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r21);\n+  print_debug(\" r_r22: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r22);\n+  print_debug(\" r_r23: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r23);\n+  print_debug(\" r_r24: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r24);\n+  print_debug(\" r_r25: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r25);\n+  print_debug(\" r_r26: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r26);\n+  print_debug(\" r_r27: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r27);\n+  print_debug(\" r_r28: 0x%\" PRIx64 \"\\n\", threadinfo->regs.r_r28);\n+  print_debug(\" r_fp:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_fp);\n+  print_debug(\" r_lr:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_lr);\n+  print_debug(\" r_sp:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_sp);\n+  print_debug(\" r_pc:  0x%\" PRIx64 \"\\n\", threadinfo->regs.r_pc);\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n@@ -595,0 +643,1 @@\n+#if defined(amd64)\n@@ -654,0 +703,84 @@\n+\n+#elif defined(aarch64)\n+        if (fc.flavor == ARM_THREAD_STATE64) {\n+          arm_thread_state64_t thrstate;\n+          if (read(fd, (void *)&thrstate, sizeof(arm_thread_state64_t)) != sizeof(arm_thread_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_thread_state64_t);\n+          \/\/ create thread info list, update lwp_id later\n+          sa_thread_info* newthr = add_thread_info(ph, (pthread_t) -1, (lwpid_t) num_threads++);\n+          if (newthr == NULL) {\n+            printf(\"create thread_info failed\\n\");\n+            goto err;\n+          }\n+\n+          \/\/ note __DARWIN_UNIX03 depengs on other definitions\n+#if __DARWIN_UNIX03\n+#define get_register_v(regst, regname) \\\n+  regst.__##regname\n+#else\n+#define get_register_v(regst, regname) \\\n+  regst.##regname\n+#endif \/\/ __DARWIN_UNIX03\n+          newthr->regs.r_r0  = get_register_v(thrstate, x[0]);\n+          newthr->regs.r_r1  = get_register_v(thrstate, x[1]);\n+          newthr->regs.r_r2  = get_register_v(thrstate, x[2]);\n+          newthr->regs.r_r3  = get_register_v(thrstate, x[3]);\n+          newthr->regs.r_r4  = get_register_v(thrstate, x[4]);\n+          newthr->regs.r_r5  = get_register_v(thrstate, x[5]);\n+          newthr->regs.r_r6  = get_register_v(thrstate, x[6]);\n+          newthr->regs.r_r7  = get_register_v(thrstate, x[7]);\n+          newthr->regs.r_r8  = get_register_v(thrstate, x[8]);\n+          newthr->regs.r_r9  = get_register_v(thrstate, x[9]);\n+          newthr->regs.r_r10 = get_register_v(thrstate, x[10]);\n+          newthr->regs.r_r11 = get_register_v(thrstate, x[11]);\n+          newthr->regs.r_r12 = get_register_v(thrstate, x[12]);\n+          newthr->regs.r_r13 = get_register_v(thrstate, x[13]);\n+          newthr->regs.r_r14 = get_register_v(thrstate, x[14]);\n+          newthr->regs.r_r15 = get_register_v(thrstate, x[15]);\n+          newthr->regs.r_r16 = get_register_v(thrstate, x[16]);\n+          newthr->regs.r_r17 = get_register_v(thrstate, x[17]);\n+          newthr->regs.r_r18 = get_register_v(thrstate, x[18]);\n+          newthr->regs.r_r19 = get_register_v(thrstate, x[19]);\n+          newthr->regs.r_r20 = get_register_v(thrstate, x[20]);\n+          newthr->regs.r_r21 = get_register_v(thrstate, x[21]);\n+          newthr->regs.r_r22 = get_register_v(thrstate, x[22]);\n+          newthr->regs.r_r23 = get_register_v(thrstate, x[23]);\n+          newthr->regs.r_r24 = get_register_v(thrstate, x[24]);\n+          newthr->regs.r_r25 = get_register_v(thrstate, x[25]);\n+          newthr->regs.r_r26 = get_register_v(thrstate, x[26]);\n+          newthr->regs.r_r27 = get_register_v(thrstate, x[27]);\n+          newthr->regs.r_r28 = get_register_v(thrstate, x[28]);\n+          newthr->regs.r_fp  = get_register_v(thrstate, fp);\n+          newthr->regs.r_lr  = get_register_v(thrstate, lr);\n+          newthr->regs.r_sp  = get_register_v(thrstate, sp);\n+          newthr->regs.r_pc  = get_register_v(thrstate, pc);\n+          print_thread(newthr);\n+        } else if (fc.flavor == ARM_NEON_STATE64) {\n+          arm_neon_state64_t flstate;\n+          if (read(fd, (void *)&flstate, sizeof(arm_neon_state64_t)) != sizeof(arm_neon_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_neon_state64_t);\n+        } else if (fc.flavor == ARM_EXCEPTION_STATE64) {\n+          arm_exception_state64_t excpstate;\n+          if (read(fd, (void *)&excpstate, sizeof(arm_exception_state64_t)) != sizeof(arm_exception_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_exception_state64_t);\n+        } else if (fc.flavor == ARM_DEBUG_STATE64) {\n+          arm_debug_state64_t dbgstate;\n+          if (read(fd, (void *)&dbgstate, sizeof(arm_debug_state64_t)) != sizeof(arm_debug_state64_t)) {\n+            printf(\"Reading flavor, count failed.\\n\");\n+            goto err;\n+          }\n+          size += sizeof(arm_debug_state64_t);\n+        }\n+\n+#else\n+#error UNSUPPORTED_ARCH\n+#endif\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/ps_core.c","additions":134,"deletions":1,"binary":false,"changes":135,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -655,0 +656,2 @@\n+        } else if (cpu.equals(\"aarch64\")) {\n+            machDesc = new MachineDescriptionAArch64();\n@@ -656,1 +659,1 @@\n-            throw new DebuggerException(\"Darwin only supported on x86_64. Current arch: \" + cpu);\n+            throw new DebuggerException(\"Darwin only supported on x86_64\/aarch64. Current arch: \" + cpu);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2003, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -33,0 +34,1 @@\n+import sun.jvm.hotspot.debugger.aarch64.*;\n@@ -35,0 +37,1 @@\n+import sun.jvm.hotspot.debugger.bsd.aarch64.*;\n@@ -100,0 +103,7 @@\n+    } else if (cpu.equals(\"aarch64\")) {\n+       AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();\n+       Address fp = context.getRegisterAsAddress(AARCH64ThreadContext.FP);\n+       if (fp == null) return null;\n+       Address pc  = context.getRegisterAsAddress(AARCH64ThreadContext.PC);\n+       if (pc == null) return null;\n+       return new BsdAARCH64CFrame(dbg, fp, pc);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdCDebugger.java","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import sun.jvm.hotspot.debugger.bsd.aarch64.*;\n@@ -38,0 +39,2 @@\n+      } else if (cpu.equals(\"aarch64\")) {\n+         return new BsdAARCH64ThreadContext(dbg);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdThreadContextFactory.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, Red Hat Inc.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.bsd.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.bsd.*;\n+import sun.jvm.hotspot.debugger.cdbg.*;\n+import sun.jvm.hotspot.debugger.cdbg.basic.*;\n+\n+final public class BsdAARCH64CFrame extends BasicCFrame {\n+   public BsdAARCH64CFrame(BsdDebugger dbg, Address fp, Address pc) {\n+      super(dbg.getCDebugger());\n+      this.fp = fp;\n+      this.pc = pc;\n+      this.dbg = dbg;\n+   }\n+\n+   \/\/ override base class impl to avoid ELF parsing\n+   public ClosestSymbol closestSymbolToPC() {\n+      \/\/ try native lookup in debugger.\n+      return dbg.lookup(dbg.getAddressValue(pc()));\n+   }\n+\n+   public Address pc() {\n+      return pc;\n+   }\n+\n+   public Address localVariableBase() {\n+      return fp;\n+   }\n+\n+   public CFrame sender(ThreadProxy thread) {\n+      AARCH64ThreadContext context = (AARCH64ThreadContext) thread.getContext();\n+      Address rsp = context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+\n+      if ((fp == null) || fp.lessThan(rsp)) {\n+        return null;\n+      }\n+\n+      \/\/ Check alignment of fp\n+      if (dbg.getAddressValue(fp) % (2 * ADDRESS_SIZE) != 0) {\n+        return null;\n+      }\n+\n+      Address nextFP = fp.getAddressAt(0 * ADDRESS_SIZE);\n+      if (nextFP == null || nextFP.lessThanOrEqual(fp)) {\n+        return null;\n+      }\n+      Address nextPC  = fp.getAddressAt(1 * ADDRESS_SIZE);\n+      if (nextPC == null) {\n+        return null;\n+      }\n+      return new BsdAARCH64CFrame(dbg, nextFP, nextPC);\n+   }\n+\n+   \/\/ package\/class internals only\n+   private static final int ADDRESS_SIZE = 8;\n+   private Address pc;\n+   private Address sp;\n+   private Address fp;\n+   private BsdDebugger dbg;\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64CFrame.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.bsd.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.bsd.*;\n+\n+public class BsdAARCH64ThreadContext extends AARCH64ThreadContext {\n+  private BsdDebugger debugger;\n+\n+  public BsdAARCH64ThreadContext(BsdDebugger debugger) {\n+    super();\n+    this.debugger = debugger;\n+  }\n+\n+  public void setRegisterAsAddress(int index, Address value) {\n+    setRegister(index, debugger.getAddressValue(value));\n+  }\n+\n+  public Address getRegisterAsAddress(int index) {\n+    return debugger.newAddress(getRegister(index));\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/aarch64\/BsdAARCH64ThreadContext.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,0 +45,1 @@\n+import sun.jvm.hotspot.runtime.bsd_aarch64.BsdAARCH64JavaThreadPDAccess;\n@@ -121,0 +122,2 @@\n+            } else if (cpu.equals(\"aarch64\")) {\n+                access = new BsdAARCH64JavaThreadPDAccess();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime.bsd_aarch64;\n+\n+import java.io.*;\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.bsd.BsdDebugger;\n+import sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.aarch64.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+\n+public class BsdAARCH64JavaThreadPDAccess implements JavaThreadPDAccess {\n+  private static AddressField  lastJavaFPField;\n+  private static AddressField  osThreadField;\n+\n+  \/\/ Field from OSThread\n+  private static CIntegerField osThreadThreadIDField;\n+  private static CIntegerField osThreadUniqueThreadIDField;\n+\n+  \/\/ This is currently unneeded but is being kept in case we change\n+  \/\/ the currentFrameGuess algorithm\n+  private static final long GUESS_SCAN_RANGE = 128 * 1024;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"JavaThread\");\n+    osThreadField           = type.getAddressField(\"_osthread\");\n+\n+    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n+    lastJavaFPField         = anchorType.getAddressField(\"_last_Java_fp\");\n+\n+    Type osThreadType = db.lookupType(\"OSThread\");\n+    osThreadThreadIDField   = osThreadType.getCIntegerField(\"_thread_id\");\n+    osThreadUniqueThreadIDField = osThreadType.getCIntegerField(\"_unique_thread_id\");\n+  }\n+\n+  public Address getLastJavaFP(Address addr) {\n+    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));\n+  }\n+\n+  public Address getLastJavaPC(Address addr) {\n+    return null;\n+  }\n+\n+  public Address getBaseOfStackPointer(Address addr) {\n+    return null;\n+  }\n+\n+  public Frame getLastFramePD(JavaThread thread, Address addr) {\n+    Address fp = thread.getLastJavaFP();\n+    if (fp == null) {\n+      return null; \/\/ no information\n+    }\n+    return new AARCH64Frame(thread.getLastJavaSP(), fp);\n+  }\n+\n+  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {\n+    return new AARCH64RegisterMap(thread, updateMap);\n+  }\n+\n+  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    AARCH64CurrentFrameGuess guesser = new AARCH64CurrentFrameGuess(context, thread);\n+    if (!guesser.run(GUESS_SCAN_RANGE)) {\n+      return null;\n+    }\n+    if (guesser.getPC() == null) {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP());\n+    } else {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n+    }\n+  }\n+\n+  public void printThreadIDOn(Address addr, PrintStream tty) {\n+    tty.print(getThreadProxy(addr));\n+  }\n+\n+  public void printInfoOn(Address threadAddr, PrintStream tty) {\n+    tty.print(\"Thread id: \");\n+    printThreadIDOn(threadAddr, tty);\n+\/\/    tty.println(\"\\nPostJavaState: \" + getPostJavaState(threadAddr));\n+  }\n+\n+  public Address getLastSP(Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    return context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+  }\n+\n+  public ThreadProxy getThreadProxy(Address addr) {\n+    \/\/ Addr is the address of the JavaThread.\n+    \/\/ Fetch the OSThread (for now and for simplicity, not making a\n+    \/\/ separate \"OSThread\" class in this package)\n+    Address osThreadAddr = osThreadField.getValue(addr);\n+    \/\/ Get the address of the _thread_id from the OSThread\n+    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());\n+    Address uniqueThreadIdAddr = osThreadAddr.addOffsetTo(osThreadUniqueThreadIDField.getOffset());\n+\n+    BsdDebuggerLocal debugger = (BsdDebuggerLocal) VM.getVM().getDebugger();\n+    return debugger.getThreadForIdentifierAddress(threadIdAddr, uniqueThreadIdAddr);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/bsd_aarch64\/BsdAARCH64JavaThreadPDAccess.java","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -2,1 +2,2 @@\n-# Copyright (c) 2008, 2017, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2008, 2021, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n@@ -115,1 +116,4 @@\n-ARCH=$(ARCH1:i686=i386)\n+ARCH2=$(ARCH1:arm64=aarch64)\n+ARCH=$(ARCH2:i686=i386)\n+CONFIGURE_ARGS\/aarch64= --enable-targets=aarch64-darwin\n+CONFIGURE_ARGS = $(CONFIGURE_ARGS\/$(ARCH))\n@@ -120,1 +124,1 @@\n-ARCH=$(ARCH1:amd64=i386)\n+ARCH=$(ARCH2:amd64=i386)\n@@ -124,0 +128,3 @@\n+ifeq ($(CPU), arm64)\n+CFLAGS\/aarch64  += -m64\n+endif # arm64\n","filename":"src\/utils\/hsdis\/Makefile","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,2 @@\n+#include \"runtime\/thread.inline.hpp\"\n+\n@@ -94,1 +96,8 @@\n-  return JNI_CreateJavaVM(&jvm, (void**)&env, &args);\n+  int ret = JNI_CreateJavaVM(&jvm, (void**)&env, &args);\n+  if (ret == JNI_OK) {\n+    \/\/ CreateJavaVM leaves WXExec context, while gtests\n+    \/\/ calls internal functions assuming running in WXWwrite.\n+    \/\/ Switch to WXWrite once for all test cases.\n+    MACOS_AARCH64_ONLY(Thread::current()->enable_wx(WXWrite));\n+  }\n+  return ret;\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n- * @requires vm.bits == 64 & vm.opt.final.UseCompressedOops == true & os.family != \"windows\"\n+ * @requires vm.bits == 64 & vm.opt.final.UseCompressedOops == true & os.family != \"windows\" & !(os.family == \"mac\" & os.arch==\"aarch64\")\n","filename":"test\/hotspot\/jtreg\/runtime\/CompressedOops\/CompressedClassPointers.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @requires os.arch == \"aarch64\" & os.family == \"mac\"\n+ * @run main\/othervm\/native TestCodegenAttach\n+ *\/\n+\n+public class TestCodegenAttach {\n+\n+    static native void testCodegenAttach();\n+\n+    static {\n+        System.loadLibrary(\"codegenAttach\");\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        testCodegenAttach();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/codegenAttachThread\/TestCodegenAttach.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Azul Systems, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h>\n+\n+#include \"jni.h\"\n+\n+#if defined(__APPLE__) && defined(__aarch64__)\n+\n+#include <pthread.h>\n+#include <sys\/mman.h>\n+\n+JavaVM* jvm;\n+\n+static void* codegen;\n+\n+static int thread_start2(int val) {\n+  JNIEnv *env;\n+  jclass class_id;\n+  jmethodID method_id;\n+  int res;\n+\n+  printf(\"Native thread is running and attaching ...\\n\");\n+\n+  res = (*jvm)->AttachCurrentThread(jvm, (void **)&env, NULL);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't attach current thread: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  res = (*jvm)->DetachCurrentThread(jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't detach current thread: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  printf(\"Native thread is about to finish\\n\");\n+  return 1 + val;\n+}\n+\n+static int trampoline(int(*fn)(int), int arg) {\n+  int val = fn(arg);\n+  \/\/ ensure code in MAP_JIT area after target function returns\n+  return 1 + val;\n+}\n+\n+static void * thread_start(void* unused) {\n+  int val = ((int(*)(int(*)(int),int))codegen)(thread_start2, 10);\n+  printf(\"return val = %d\\n\", val);\n+  return NULL;\n+}\n+\n+JNIEXPORT void JNICALL\n+Java_TestCodegenAttach_testCodegenAttach\n+(JNIEnv *env, jclass cls) {\n+\n+  codegen = mmap(NULL, 0x1000,\n+      PROT_READ | PROT_WRITE | PROT_EXEC,\n+      MAP_PRIVATE | MAP_ANONYMOUS | MAP_JIT, -1, 0);\n+  if (codegen == MAP_FAILED) {\n+    perror(\"mmap\");\n+    exit(1);\n+  }\n+\n+  pthread_jit_write_protect_np(false);\n+\n+  memcpy(codegen, trampoline, 128);\n+\n+  pthread_jit_write_protect_np(true);\n+\n+  pthread_t thread;\n+  int res = (*env)->GetJavaVM(env, &jvm);\n+  if (res != JNI_OK) {\n+    fprintf(stderr, \"Test ERROR. Can't extract JavaVM: %d\\n\", res);\n+    exit(1);\n+  }\n+\n+  if ((res = pthread_create(&thread, NULL, thread_start, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_create failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+\n+  if ((res = pthread_join(thread, NULL)) != 0) {\n+    fprintf(stderr, \"TEST ERROR: pthread_join failed: %s (%d)\\n\", strerror(res), res);\n+    exit(1);\n+  }\n+}\n+\n+#else\n+\n+JNIEXPORT void JNICALL\n+Java_TestCodegenAttach_testCodegenAttach\n+(JNIEnv *env, jclass cls) {\n+  printf(\"should not reach here\\n\");\n+  exit(1);\n+}\n+\n+#endif \/\/ __APPLE__ && __aarch64__\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/codegenAttachThread\/libcodegenAttach.c","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -541,0 +541,2 @@\n+        {\"macosx-aarch64\",  \"com.sun.jdi.SharedMemoryAttach\"},\n+        {\"mac-aarch64\",     \"com.sun.jdi.SharedMemoryAttach\"},\n@@ -571,0 +573,2 @@\n+        {\"macosx-aarch64\",  \"com.sun.jdi.SharedMemoryListen\"},\n+        {\"mac-aarch64\",     \"com.sun.jdi.SharedMemoryListen\"},\n@@ -650,2 +654,8 @@\n-        {\"mac-x64\",         \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n-        {\"mac-x64\",         \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n+        {\"mac-x64\",          \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n+        {\"mac-x64\",          \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n+\n+        {\"macosx-aarch64\",   \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n+        {\"macosx-aarch64\",   \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n+\n+        {\"mac-aarch64\",      \"com.sun.jdi.CommandLineLaunch\", \"dt_shmem\"},\n+        {\"mac-aarch64\",      \"com.sun.jdi.RawCommandLineLaunch\", \"dt_shmem\"},\n@@ -675,0 +685,2 @@\n+        {\"macosx-aarch64\",  \"dt_shmem\"},\n+        {\"mac-aarch64\",     \"dt_shmem\"},\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdi\/ArgumentHandler.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"}]}