{"files":[{"patch":"@@ -45,1 +45,1 @@\n- * AES with GCM mode.\n+ * AES cipher in GCM mode and CHACHA20-POLY1305 cipher.\n@@ -48,6 +48,4 @@\n- * its own padding impl. In addition, NSS CKM_AES_GCM only supports single-part\n- * encryption\/decryption, thus the current impl uses PKCS#11 C_Encrypt\/C_Decrypt\n- * calls and buffers data until doFinal is called.\n- *\n- * Note that PKCS#11 standard currently only supports GCM and CCM AEAD modes.\n- * There are no provisions for other AEAD modes yet.\n+ * its own padding impl. In addition, some vendors such as NSS may not support\n+ * multi-part encryption\/decryption for AEAD cipher algorithms, thus the\n+ * current impl uses PKCS#11 C_Encrypt\/C_Decrypt calls and buffers data until\n+ * doFinal is called.\n@@ -59,2 +57,4 @@\n-    \/\/ mode constant for GCM mode\n-    private static final int MODE_GCM = 10;\n+    \/\/ supported AEAD algorithms\/transformations\n+    private enum Transformation {\n+        AES_GCM(\"AES\", \"GCM\", \"NOPADDING\", 16, 16),\n+        CHACHA20_POLY1305(\"CHACHA20\", \"NONE\", \"NOPADDING\", 12, 16);\n@@ -62,3 +62,5 @@\n-    \/\/ default constants for GCM\n-    private static final int GCM_DEFAULT_TAG_LEN = 16;\n-    private static final int GCM_DEFAULT_IV_LEN = 16;\n+        final String keyAlgo;\n+        final String mode;\n+        final String padding;\n+        final int defIvLen; \/\/ in bytes\n+        final int defTagLen; \/\/ in bytes\n@@ -66,1 +68,9 @@\n-    private static final String ALGO = \"AES\";\n+        Transformation(String keyAlgo, String mode, String padding,\n+                int defIvLen, int defTagLen) {\n+            this.keyAlgo = keyAlgo;\n+            this.mode = mode;\n+            this.padding = padding;\n+            this.defIvLen = defIvLen;\n+            this.defTagLen = defTagLen;\n+        }\n+    }\n@@ -74,2 +84,2 @@\n-    \/\/ mode, one of MODE_* above\n-    private final int blockMode;\n+    \/\/ type of this AEAD cipher, one of Transformation enum above\n+    private final Transformation type;\n@@ -77,1 +87,1 @@\n-    \/\/ acceptable key size, -1 if more than 1 key sizes are accepted\n+    \/\/ acceptable key size in bytes, -1 if more than 1 key sizes are accepted\n@@ -114,11 +124,38 @@\n-        if (algoParts.length != 3) {\n-            throw new ProviderException(\"Unsupported Transformation format: \" +\n-                    algorithm);\n-        }\n-        if (!algoParts[0].startsWith(\"AES\")) {\n-            throw new ProviderException(\"Only support AES for AEAD cipher mode\");\n-        }\n-        int index = algoParts[0].indexOf('_');\n-        if (index != -1) {\n-            \/\/ should be well-formed since we specify what we support\n-            fixedKeySize = Integer.parseInt(algoParts[0].substring(index+1)) >> 3;\n+        if (algoParts[0].startsWith(\"AES\")) {\n+            \/\/ for AES_GCM, need 3 parts\n+            if (algoParts.length != 3) {\n+                throw new AssertionError(\"Invalid Transformation format: \" +\n+                        algorithm);\n+            }\n+            int index = algoParts[0].indexOf('_');\n+            if (index != -1) {\n+                \/\/ should be well-formed since we specify what we support\n+                fixedKeySize = Integer.parseInt(algoParts[0].substring(index+1)) >> 3;\n+            } else {\n+                fixedKeySize = -1;\n+            }\n+            this.type = Transformation.AES_GCM;\n+            engineSetMode(algoParts[1]);\n+            try {\n+                engineSetPadding(algoParts[2]);\n+            } catch (NoSuchPaddingException e) {\n+                throw new NoSuchAlgorithmException();\n+            }\n+        } else if (algoParts[0].equals(\"ChaCha20-Poly1305\")) {\n+            fixedKeySize = 32;\n+            this.type = Transformation.CHACHA20_POLY1305;\n+            if (algoParts.length > 3) {\n+                throw new AssertionError(\n+                        \"Invalid Transformation format: \" + algorithm);\n+            } else {\n+                if (algoParts.length > 1) {\n+                    engineSetMode(algoParts[1]);\n+                }\n+                try {\n+                    if (algoParts.length > 2) {\n+                        engineSetPadding(algoParts[2]);\n+                    }\n+                } catch (NoSuchPaddingException e) {\n+                    throw new NoSuchAlgorithmException();\n+                }\n+            }\n@@ -126,5 +163,1 @@\n-            fixedKeySize = -1;\n-        }\n-        this.blockMode = parseMode(algoParts[1]);\n-        if (!algoParts[2].equals(\"NoPadding\")) {\n-            throw new ProviderException(\"Only NoPadding is supported for AEAD cipher mode\");\n+            throw new AssertionError(\"Unsupported transformation \" + algorithm);\n@@ -134,0 +167,1 @@\n+    @Override\n@@ -135,11 +169,1 @@\n-        \/\/ Disallow change of mode for now since currently it's explicitly\n-        \/\/ defined in transformation strings\n-        throw new NoSuchAlgorithmException(\"Unsupported mode \" + mode);\n-    }\n-\n-    private int parseMode(String mode) throws NoSuchAlgorithmException {\n-        mode = mode.toUpperCase(Locale.ENGLISH);\n-        int result;\n-        if (mode.equals(\"GCM\")) {\n-            result = MODE_GCM;\n-        } else {\n+        if (!mode.toUpperCase(Locale.ENGLISH).equals(type.mode)) {\n@@ -148,1 +172,0 @@\n-        return result;\n@@ -152,0 +175,1 @@\n+    @Override\n@@ -154,3 +178,3 @@\n-        \/\/ Disallow change of padding for now since currently it's explicitly\n-        \/\/ defined in transformation strings\n-        throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        if (!padding.toUpperCase(Locale.ENGLISH).equals(type.padding)) {\n+            throw new NoSuchPaddingException(\"Unsupported padding \" + padding);\n+        }\n@@ -160,0 +184,1 @@\n+    @Override\n@@ -161,1 +186,5 @@\n-        return 16; \/\/ constant; only AES is supported\n+        switch (type) {\n+            case AES_GCM: return 16;\n+            case CHACHA20_POLY1305: return 0;\n+            default: throw new AssertionError(\"Unsupported type \" + type);\n+        }\n@@ -165,0 +194,1 @@\n+    @Override\n@@ -170,0 +200,1 @@\n+    @Override\n@@ -176,17 +207,11 @@\n-        if (encrypt && iv == null && tagLen == -1) {\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    iv = new byte[GCM_DEFAULT_IV_LEN];\n-                    tagLen = GCM_DEFAULT_TAG_LEN;\n-                    break;\n-                default:\n-                    throw new ProviderException(\"Unsupported mode\");\n-            }\n-            random.nextBytes(iv);\n-        }\n-        try {\n-            AlgorithmParameterSpec spec;\n-            String apAlgo;\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    apAlgo = \"GCM\";\n+        String apAlgo;\n+        AlgorithmParameterSpec spec = null;\n+        switch (type) {\n+            case AES_GCM:\n+                apAlgo = \"GCM\";\n+                if (encrypt && iv == null && tagLen == -1) {\n+                    iv = new byte[type.defIvLen];\n+                    tagLen = type.defTagLen;\n+                    random.nextBytes(iv);\n+                }\n+                if (iv != null) {\n@@ -194,3 +219,25 @@\n-                    break;\n-                default:\n-                    throw new ProviderException(\"Unsupported mode\");\n+                }\n+            break;\n+            case CHACHA20_POLY1305:\n+                if (encrypt && iv == null) {\n+                    iv = new byte[type.defIvLen];\n+                    random.nextBytes(iv);\n+                }\n+                apAlgo = \"ChaCha20-Poly1305\";\n+                if (iv != null) {\n+                    spec = new IvParameterSpec(iv);\n+                }\n+            break;\n+            default:\n+                throw new AssertionError(\"Unsupported type \" + type);\n+        }\n+        if (spec != null) {\n+            try {\n+                AlgorithmParameters params =\n+                    AlgorithmParameters.getInstance(apAlgo);\n+                params.init(spec);\n+                return params;\n+            } catch (GeneralSecurityException e) {\n+                \/\/ NoSuchAlgorithmException, NoSuchProviderException\n+                \/\/ InvalidParameterSpecException\n+                throw new ProviderException(\"Could not encode parameters\", e);\n@@ -198,8 +245,0 @@\n-            AlgorithmParameters params =\n-                AlgorithmParameters.getInstance(apAlgo);\n-            params.init(spec);\n-            return params;\n-        } catch (GeneralSecurityException e) {\n-            \/\/ NoSuchAlgorithmException, NoSuchProviderException\n-            \/\/ InvalidParameterSpecException\n-            throw new ProviderException(\"Could not encode parameters\", e);\n@@ -207,0 +246,1 @@\n+        return null;\n@@ -234,6 +274,19 @@\n-        if (params != null) {\n-            switch (blockMode) {\n-            case MODE_GCM:\n-                if (!(params instanceof GCMParameterSpec)) {\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Only GCMParameterSpec is supported\");\n+        switch (type) {\n+            case AES_GCM:\n+                if (params != null) {\n+                    if (!(params instanceof GCMParameterSpec)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Only GCMParameterSpec is supported\");\n+                    }\n+                    ivValue = ((GCMParameterSpec) params).getIV();\n+                    tagLen = ((GCMParameterSpec) params).getTLen() >> 3;\n+                }\n+            break;\n+            case CHACHA20_POLY1305:\n+                if (params != null) {\n+                    if (!(params instanceof IvParameterSpec)) {\n+                        throw new InvalidAlgorithmParameterException\n+                                (\"Only IvParameterSpec is supported\");\n+                    }\n+                    ivValue = ((IvParameterSpec) params).getIV();\n+                    tagLen = type.defTagLen;\n@@ -241,2 +294,0 @@\n-                ivValue = ((GCMParameterSpec) params).getIV();\n-                tagLen = ((GCMParameterSpec) params).getTLen() >> 3;\n@@ -245,3 +296,2 @@\n-                throw new ProviderException(\"Unsupported mode\");\n-            }\n-        }\n+                throw new AssertionError(\"Unsupported type \" + type);\n+        };\n@@ -263,2 +313,2 @@\n-                switch (blockMode) {\n-                    case MODE_GCM:\n+                switch (type) {\n+                    case AES_GCM:\n@@ -268,0 +318,4 @@\n+                    case CHACHA20_POLY1305:\n+                        paramSpec =\n+                            params.getParameterSpec(IvParameterSpec.class);\n+                        break;\n@@ -269,1 +323,1 @@\n-                        throw new ProviderException(\"Unsupported mode\");\n+                        throw new AssertionError(\"Unsupported type \" + type);\n@@ -288,1 +342,2 @@\n-        P11Key newKey = P11SecretKeyFactory.convertKey(token, key, ALGO);\n+        P11Key newKey = P11SecretKeyFactory.convertKey(token, key,\n+                type.keyAlgo);\n@@ -295,2 +350,2 @@\n-                    throw new InvalidAlgorithmParameterException\n-                        (\"Cannot reuse iv for GCM encryption\");\n+                    throw new InvalidAlgorithmParameterException(\n+                            \"Cannot reuse the same key and iv pair\");\n@@ -312,0 +367,1 @@\n+\n@@ -314,3 +370,8 @@\n-            switch (blockMode) {\n-                case MODE_GCM:\n-                    iv = new byte[GCM_DEFAULT_IV_LEN];\n+            switch (type) {\n+                case AES_GCM:\n+                    iv = new byte[type.defIvLen];\n+                    this.random.nextBytes(iv);\n+                    tagLen = type.defTagLen;\n+                    break;\n+                case CHACHA20_POLY1305:\n+                    iv = new byte[type.defIvLen];\n@@ -318,1 +379,1 @@\n-                    tagLen = GCM_DEFAULT_TAG_LEN;\n+                    tagLen = type.defTagLen;\n@@ -321,1 +382,1 @@\n-                    throw new ProviderException(\"Unsupported mode\");\n+                    throw new AssertionError(\"Unsupported type \" + type);\n@@ -385,1 +446,1 @@\n-                (\"Must use either different key or iv for GCM encryption\");\n+                (\"Must use either different key or iv\");\n@@ -395,2 +456,2 @@\n-            switch (blockMode) {\n-                case MODE_GCM:\n+            switch (type) {\n+                case AES_GCM:\n@@ -400,0 +461,4 @@\n+                case CHACHA20_POLY1305:\n+                    mechWithParams = new CK_MECHANISM(mechanism,\n+                        new CK_SALSA20_CHACHA20_POLY1305_PARAMS(iv, aad));\n+                    break;\n@@ -401,1 +466,1 @@\n-                    throw new ProviderException(\"Unsupported mode: \" + blockMode);\n+                    throw new AssertionError(\"Unsupported type: \" + type);\n@@ -434,2 +499,5 @@\n-            \/\/ PKCS11Exception: CKR_BUFFER_TOO_SMALL\n-            \/\/result -= tagLen;\n+            \/\/ In earlier NSS versions, AES_GCM would report\n+            \/\/ CKR_BUFFER_TOO_SMALL error if minus tagLen\n+            if (type == Transformation.CHACHA20_POLY1305) {\n+                result -= tagLen;\n+            }\n@@ -437,1 +505,1 @@\n-        return result;\n+        return (result > 0? result : 0);\n@@ -495,1 +563,1 @@\n-                (\"Must use either different key or iv for GCM encryption\");\n+                (\"Must use either different key or iv for encryption\");\n@@ -598,0 +666,1 @@\n+\n@@ -715,0 +784,1 @@\n+            inBuffer.position(inBuffer.limit());\n@@ -751,2 +821,2 @@\n-            throw (BadPaddingException)\n-                    (new BadPaddingException(e.toString()).initCause(e));\n+            throw (AEADBadTagException)\n+                    (new AEADBadTagException(e.toString()).initCause(e));\n@@ -775,1 +845,1 @@\n-                (token, key, ALGO).length();\n+                (token, key, type.keyAlgo).length();\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11AEADCipher.java","additions":179,"deletions":109,"binary":false,"changes":288,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -197,0 +197,4 @@\n+        case (int)CKM_CHACHA20_KEY_GEN:\n+            keySize = 256;\n+            keyType = CKK_CHACHA20;\n+            break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11KeyGenerator.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+        addKeyType(\"ChaCha20\", CKK_CHACHA20);\n@@ -240,0 +241,4 @@\n+                case (int)CKK_CHACHA20:\n+                    keyLength = P11KeyGenerator.checkKeySize(\n+                        CKM_CHACHA20_KEY_GEN, n, token);\n+                    break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/P11SecretKeyFactory.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+import com.sun.crypto.provider.ChaCha20Poly1305Parameters;\n+\n@@ -603,0 +605,2 @@\n+        d(KG,  \"ChaCha20\",      P11KeyGenerator,\n+                m(CKM_CHACHA20_KEY_GEN));\n@@ -629,0 +633,5 @@\n+        d(AGP, \"ChaCha20-Poly1305\",\n+                \"com.sun.crypto.provider.ChaCha20Poly1305Parameters\",\n+                s(\"1.2.840.113549.1.9.16.3.18\", \"OID.1.2.840.113549.1.9.16.3.18\"),\n+                m(CKM_CHACHA20_POLY1305));\n+\n@@ -645,0 +654,2 @@\n+        d(SKF, \"ChaCha20\",      P11SecretKeyFactory,\n+                m(CKM_CHACHA20_POLY1305));\n@@ -712,0 +723,4 @@\n+        d(CIP, \"ChaCha20-Poly1305\",             P11AEADCipher,\n+                s(\"1.2.840.113549.1.9.16.3.18\", \"OID.1.2.840.113549.1.9.16.3.18\"),\n+                m(CKM_CHACHA20_POLY1305));\n+\n@@ -1168,1 +1183,2 @@\n-                } else if (algorithm.endsWith(\"GCM\/NoPadding\")) {\n+                } else if (algorithm.endsWith(\"GCM\/NoPadding\") ||\n+                           algorithm.startsWith(\"ChaCha20-Poly1305\")) {\n@@ -1221,0 +1237,2 @@\n+                } else if (algorithm == \"ChaCha20-Poly1305\") {\n+                    return new ChaCha20Poly1305Parameters(); \/\/ from SunJCE\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/SunPKCS11.java","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -158,0 +158,5 @@\n+    public CK_MECHANISM(long mechanism,\n+            CK_SALSA20_CHACHA20_POLY1305_PARAMS params) {\n+        init(mechanism, params);\n+    }\n+\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_MECHANISM.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package sun.security.pkcs11.wrapper;\n+\n+\/**\n+ * This class represents the necessary parameters required by the\n+ * CKM_CHACHA20_POLY1305 and CKM_SALSA20_POLY1305 mechanisms as defined in\n+ * CK_SALSA20_CHACHA20_POLY1305_PARAMS structure.<p>\n+ * <B>PKCS#11 structure:<\/B>\n+ * <PRE>\n+ * typedef struct CK_SALSA20_CHACHA20_POLY1305_PARAMS {\n+ *   CK_BYTE_PTR  pNonce;\n+ *   CK_ULONG     ulNonceLen;\n+ *   CK_BYTE_PTR  pAAD;\n+ *   CK_ULONG     ulAADLen;\n+ * } CK_SALSA20_CHACHA20_POLY1305_PARAMS;\n+ * <\/PRE>\n+ *\n+ * @since   17\n+ *\/\n+public class CK_SALSA20_CHACHA20_POLY1305_PARAMS {\n+\n+    private final byte[] nonce;\n+    private final byte[] aad;\n+\n+    public CK_SALSA20_CHACHA20_POLY1305_PARAMS(byte[] nonce, byte[] aad) {\n+        this.nonce = nonce;\n+        this.aad = aad;\n+    }\n+\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+\n+        sb.append(Constants.INDENT);\n+        sb.append(\"Nonce: \");\n+        if (nonce == null) {\n+            sb.append(\"null\");\n+        } else {\n+            sb.append(\"0x\");\n+            for (byte b: nonce) {\n+                sb.append(String.format(\"%02x\", b));\n+            }\n+        }\n+        sb.append(Constants.NEWLINE);\n+        sb.append(Constants.INDENT);\n+        sb.append(\"AAD: \");\n+        if (aad == null) {\n+            sb.append(\"null\");\n+        } else {\n+            sb.append(\"0x\");\n+            for (byte b: aad) {\n+                sb.append(String.format(\"%02x\", b));\n+            }\n+        }\n+        return sb.toString();\n+    }\n+}\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/CK_SALSA20_CHACHA20_POLY1305_PARAMS.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -1162,0 +1162,67 @@\n+\/*\n+ * converts the Java CK_SALSA20_CHACHA20_POLY1305_PARAMS object to a\n+ * CK_SALSA20_CHACHA20_POLY1305_PARAMS pointer\n+ *\n+ * @param env - used to call JNI functions to get the Java classes and objects\n+ * @param jParam - the Java CK_SALSA20_CHACHA20_POLY1305_PARAMS object to\n+ *         convert\n+ * @param pLength - length of the allocated memory of the returned pointer\n+ * @return pointer to the new CK_SALSA20_CHACHA20_POLY1305_PARAMS structure\n+ *\/\n+CK_SALSA20_CHACHA20_POLY1305_PARAMS_PTR\n+jSalsaChaChaPolyParamsToCKSalsaChaChaPolyParamPtr(\n+        JNIEnv *env, jobject jParam, CK_ULONG *pLength)\n+{\n+    CK_SALSA20_CHACHA20_POLY1305_PARAMS_PTR ckParamPtr;\n+    jclass jParamsClass;\n+    jfieldID fieldID;\n+    jobject jNonce, jAad;\n+\n+    if (pLength != NULL) {\n+        *pLength = 0;\n+    }\n+\n+    \/\/ retrieve java values\n+    jParamsClass = (*env)->FindClass(env,\n+            CLASS_SALSA20_CHACHA20_POLY1305_PARAMS);\n+    if (jParamsClass == NULL) { return NULL; }\n+    if (!(*env)->IsInstanceOf(env, jParam, jParamsClass)) {\n+        return NULL;\n+    }\n+    fieldID = (*env)->GetFieldID(env, jParamsClass, \"nonce\", \"[B\");\n+    if (fieldID == NULL) { return NULL; }\n+    jNonce = (*env)->GetObjectField(env, jParam, fieldID);\n+    fieldID = (*env)->GetFieldID(env, jParamsClass, \"aad\", \"[B\");\n+    if (fieldID == NULL) { return NULL; }\n+    jAad = (*env)->GetObjectField(env, jParam, fieldID);\n+    \/\/ allocate memory for CK_SALSA20_CHACHA20_POLY1305_PARAMS pointer\n+    ckParamPtr = calloc(1, sizeof(CK_SALSA20_CHACHA20_POLY1305_PARAMS));\n+    if (ckParamPtr == NULL) {\n+        throwOutOfMemoryError(env, 0);\n+        return NULL;\n+    }\n+\n+    \/\/ populate using java values\n+    jByteArrayToCKByteArray(env, jNonce, &(ckParamPtr->pNonce),\n+            &(ckParamPtr->ulNonceLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    jByteArrayToCKByteArray(env, jAad, &(ckParamPtr->pAAD),\n+            &(ckParamPtr->ulAADLen));\n+    if ((*env)->ExceptionCheck(env)) {\n+        goto cleanup;\n+    }\n+\n+    if (pLength != NULL) {\n+        *pLength = sizeof(CK_SALSA20_CHACHA20_POLY1305_PARAMS);\n+    }\n+    return ckParamPtr;\n+cleanup:\n+    free(ckParamPtr->pNonce);\n+    free(ckParamPtr->pAAD);\n+    free(ckParamPtr);\n+    return NULL;\n+}\n+\n@@ -1440,0 +1507,5 @@\n+       case CKM_CHACHA20_POLY1305:\n+            ckpParamPtr =\n+                    jSalsaChaChaPolyParamsToCKSalsaChaChaPolyParamPtr(env,\n+                    jParam, ckpLength);\n+            break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_convert.c","additions":73,"deletions":1,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -326,0 +326,5 @@\n+                 case CKM_CHACHA20_POLY1305:\n+                     TRACE0(\"[ CK_SALSA20_CHACHA20_POLY1305_PARAMS ]\\n\");\n+                     free(((CK_SALSA20_CHACHA20_POLY1305_PARAMS*)tmp)->pNonce);\n+                     free(((CK_SALSA20_CHACHA20_POLY1305_PARAMS*)tmp)->pAAD);\n+                     break;\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/p11_util.c","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -259,0 +259,2 @@\n+#define CLASS_SALSA20_CHACHA20_POLY1305_PARAMS \\\n+        \"sun\/security\/pkcs11\/wrapper\/CK_SALSA20_CHACHA20_POLY1305_PARAMS\"\n","filename":"src\/jdk.crypto.cryptoki\/share\/native\/libj2pkcs11\/pkcs11wrapper.h","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,323 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestChaChaPoly\n+ * @summary test for PKCS#11 ChaCha20-Poly1305 Cipher.\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.AlgorithmParameters;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidParameterSpecException;\n+import java.util.Arrays;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.NoSuchPaddingException;\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestChaChaPoly extends PKCS11Test {\n+\n+    private static final byte[] NONCE\n+            = HexToBytes(\"012345670123456701234567\");\n+    private static final SecretKeySpec KEY = new SecretKeySpec(\n+            HexToBytes(\"0123456701234567012345670123456701234567012345670123456701234567\"),\n+            \"ChaCha20\");\n+    private static final ChaCha20ParameterSpec CHACHA20_PARAM_SPEC\n+            = new ChaCha20ParameterSpec(NONCE, 0);\n+    private static final IvParameterSpec IV_PARAM_SPEC\n+            = new IvParameterSpec(NONCE);\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+    private static final SecureRandom RAND = new SecureRandom();\n+    private static Provider p;\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+        this.p = p;\n+        testTransformations();\n+        testInit();\n+        testAEAD();\n+        testGetBlockSize();\n+        testGetIV();\n+        testInterop(\"SunJCE\");\n+    }\n+\n+    private static void testTransformations() throws Exception {\n+        System.out.println(\"== transformations ==\");\n+\n+        checkTransformation(p, ALGO, true);\n+        checkTransformation(p, ALGO + \"\/None\/NoPadding\", true);\n+        checkTransformation(p, ALGO + \"\/ECB\/NoPadding\", false);\n+        checkTransformation(p, ALGO + \"\/None\/PKCS5Padding\", false);\n+    }\n+\n+    private static void checkTransformation(Provider p, String t,\n+            boolean expected) throws Exception {\n+        try {\n+            Cipher.getInstance(t, p);\n+            if (!expected) {\n+                throw new RuntimeException( \"Should reject transformation: \" +\n+                        t);\n+            } else {\n+                System.out.println(\"Accepted transformation: \" + t);\n+            }\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {\n+            if (!expected) {\n+                System.out.println(\"Rejected transformation: \" + t);\n+            } else {\n+                throw new RuntimeException(\"Should accept transformation: \" +\n+                        t, e);\n+            }\n+        }\n+    }\n+\n+    private static void testInit() throws Exception {\n+        testInitOnCrypt(Cipher.ENCRYPT_MODE);\n+        testInitOnCrypt(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testInitOnCrypt(int opMode) throws Exception {\n+        System.out.println(\"== init (\" + getOpModeName(opMode) + \") ==\");\n+\n+        \/\/ Need to acquire new Cipher object as ChaCha20-Poly1305 cipher\n+        \/\/ disallow reusing the same key and iv pair\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, IV_PARAM_SPEC);\n+        Cipher c = Cipher.getInstance(ALGO, p);\n+        c.init(opMode, KEY, IV_PARAM_SPEC, RAND);\n+        AlgorithmParameters params = c.getParameters();\n+        Cipher.getInstance(ALGO, p).init(opMode, KEY, params, RAND);\n+\n+        try {\n+            \/\/ try with invalid param\n+            Cipher.getInstance(ALGO, p).init(opMode, KEY, CHACHA20_PARAM_SPEC);\n+            throw new RuntimeException(\"Should reject non-IvparameterSpec\");\n+        } catch (InvalidAlgorithmParameterException e) {\n+            System.out.println(\"Expected IAPE - \" + e);\n+        }\n+    }\n+\n+    private static void testAEAD() throws Exception {\n+        byte[] expectedPt = HexToBytes(\"01234567\");\n+        byte[] ct = testUpdateAAD(Cipher.ENCRYPT_MODE, expectedPt);\n+        byte[] pt = testUpdateAAD(Cipher.DECRYPT_MODE, ct);\n+        if (pt != null && !Arrays.equals(pt, expectedPt)) {\n+            System.out.println(\"ciphertext: \" + Arrays.toString(ct));\n+            System.out.println(\"plaintext: \" + Arrays.toString(pt));\n+            throw new RuntimeException(\"AEAD failed\");\n+        }\n+    }\n+\n+    private static byte[] testUpdateAAD(int opMode, byte[] input)\n+            throws Exception {\n+        String opModeName = getOpModeName(opMode);\n+        System.out.println(\"== updateAAD (\" + opModeName + \") ==\");\n+\n+        byte[] aad = HexToBytes(\"0000\");\n+        ByteBuffer aadBuf = ByteBuffer.wrap(aad);\n+\n+        Cipher ccp = Cipher.getInstance(ALGO, p);\n+        try {\n+            ccp.updateAAD(aadBuf);\n+            throw new RuntimeException(\n+                    \"Should throw ISE for setting AAD on uninit'ed Cipher\");\n+        } catch (IllegalStateException e) {\n+            System.out.println(\"Expected ISE - \" + e);\n+        }\n+\n+        ccp.init(opMode, KEY, IV_PARAM_SPEC);\n+        ccp.update(input);\n+        try {\n+            ccp.updateAAD(aad);\n+            throw new RuntimeException(\n+                    \"Should throw ISE for setting AAD after update\");\n+        } catch (IllegalStateException e) {\n+            System.out.println(\"Expected ISE - \" + e);\n+        }\n+\n+        ccp.init(opMode, KEY, IV_PARAM_SPEC);\n+        ccp.updateAAD(aadBuf);\n+        return ccp.doFinal(input);\n+    }\n+\n+    private static void testGetBlockSize() throws Exception {\n+        testGetBlockSize(Cipher.ENCRYPT_MODE);\n+        testGetBlockSize(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testGetBlockSize(int opMode) throws Exception {\n+        System.out.println(\"== getBlockSize (\" + getOpModeName(opMode) + \") ==\");\n+        Cipher c = Cipher.getInstance(ALGO, p);\n+        if (c.getBlockSize() != 0) {\n+            throw new RuntimeException(\"Block size must be 0\");\n+        }\n+    }\n+\n+    private static void testGetIV() throws Exception {\n+        testGetIV(Cipher.ENCRYPT_MODE);\n+        testGetIV(Cipher.DECRYPT_MODE);\n+    }\n+\n+    private static void testGetIV(int opMode) throws Exception {\n+        System.out.println(\"== getIv (\" + getOpModeName(opMode) + \") ==\");\n+\n+        try {\n+            Cipher.getInstance(ALGO, p).getIV();\n+            Cipher.getInstance(ALGO, p).getParameters();\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Should not throw ex\", e);\n+        }\n+        \/\/ first init w\/ key only\n+        AlgorithmParameters params = null;\n+        for (int i = 0; i < 6; i++) {\n+            System.out.println(\"IV test# \" + i);\n+            Cipher c = Cipher.getInstance(ALGO, p);\n+            byte[] expectedIV = NONCE;\n+            try {\n+                switch (i) {\n+                case 0: {\n+                    c.init(opMode, KEY);\n+                    expectedIV = null; \/\/ randomly-generated\n+                    break;\n+                }\n+                case 1: {\n+                    c.init(opMode, KEY, RAND);\n+                    expectedIV = null; \/\/ randomly-generated\n+                    break;\n+                }\n+                case 2: {\n+                    c.init(opMode, KEY, IV_PARAM_SPEC);\n+                    params = c.getParameters();\n+                    if (params == null) {\n+                        throw new RuntimeException(\"Params should not be null\");\n+                    }\n+                    break;\n+                }\n+                case 3: c.init(opMode, KEY, IV_PARAM_SPEC, RAND); break;\n+                case 4: c.init(opMode, KEY, params); break;\n+                case 5: c.init(opMode, KEY, params, RAND); break;\n+                }\n+                checkIV(c, expectedIV);\n+                System.out.println(\"=> Passed\");\n+            } catch (GeneralSecurityException e) {\n+                if (opMode == Cipher.DECRYPT_MODE && i < 2) {\n+                    System.out.println(\"=> Passed: Expected Ex thrown\");\n+                } else {\n+                    throw new RuntimeException(\"Should not throw ex\", e);\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void checkIV(Cipher c, byte[] expectedIv) {\n+        \/\/ the specified cipher has been initialized; the returned IV and\n+        \/\/ AlgorithmParameters object should be non-null\n+        byte[] iv = c.getIV();\n+        AlgorithmParameters params = c.getParameters();\n+        \/\/ fail if either is null\n+        if (iv == null || params == null) {\n+            throw new RuntimeException(\"getIV()\/getParameters() should \" +\n+                    \"not return null\");\n+        }\n+\n+        \/\/ check iv matches if not null\n+        if (expectedIv != null && !Arrays.equals(expectedIv, iv)) {\n+            throw new RuntimeException(\"IV should match expected value\");\n+        }\n+\n+        try {\n+            byte[] iv2 = params.getParameterSpec(IvParameterSpec.class).getIV();\n+            if (!Arrays.equals(iv, iv2)) {\n+                throw new RuntimeException(\"IV values should be consistent\");\n+            }\n+        } catch (InvalidParameterSpecException ipe) {\n+            \/\/ should never happen\n+            throw new AssertionError();\n+        }\n+    }\n+\n+    private static void testInterop(String interopProv) throws Exception {\n+        testInterop(Cipher.getInstance(ALGO, p),\n+                Cipher.getInstance(ALGO, interopProv));\n+        testInterop(Cipher.getInstance(ALGO, interopProv),\n+                Cipher.getInstance(ALGO, p));\n+    }\n+\n+    private static void testInterop(Cipher encCipher, Cipher decCipher)\n+            throws Exception {\n+        System.out.println(\"Interop: \" + encCipher.getProvider().getName() +\n+                \" -> \" + encCipher.getProvider().getName());\n+        byte[] pt = HexToBytes(\"012345678901234567890123456789\");\n+        encCipher.init(Cipher.ENCRYPT_MODE, KEY);\n+        byte[] ct = encCipher.doFinal(pt);\n+        decCipher.init(Cipher.DECRYPT_MODE, KEY, encCipher.getParameters());\n+        byte[] pt2 = decCipher.doFinal(ct);\n+        if (!Arrays.equals(pt, pt2)) {\n+            System.out.println(\"HexDump\/pt: \" + toHexString(pt));\n+            System.out.println(\"HexDump\/pt2: \" + toHexString(pt2));\n+            throw new RuntimeException(\"Recovered data should match\");\n+        }\n+        System.out.println(\"=> Passed\");\n+    }\n+\n+    private static String getOpModeName(int opMode) {\n+        switch (opMode) {\n+        case Cipher.ENCRYPT_MODE:\n+            return \"ENCRYPT\";\n+\n+        case Cipher.DECRYPT_MODE:\n+            return \"DECRYPT\";\n+\n+        case Cipher.WRAP_MODE:\n+            return \"WRAP\";\n+\n+        case Cipher.UNWRAP_MODE:\n+            return \"UNWRAP\";\n+\n+        default:\n+            return \"\";\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPoly(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPoly.java","additions":323,"deletions":0,"binary":false,"changes":323,"status":"added"},{"patch":"@@ -0,0 +1,233 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @build jdk.test.lib.Convert\n+ * @run main\/othervm TestChaChaPolyKAT\n+ * @summary ChaCha20-Poly1305 Cipher Implementation (KAT)\n+ *\/\n+\n+import java.util.*;\n+import java.security.GeneralSecurityException;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.AEADBadTagException;\n+import java.nio.ByteBuffer;\n+import jdk.test.lib.Convert;\n+\n+public class TestChaChaPolyKAT extends PKCS11Test {\n+\n+    public static class TestData {\n+        public TestData(String name, String keyStr, String nonceStr, int ctr,\n+                int dir, String inputStr, String aadStr, String outStr) {\n+            testName = Objects.requireNonNull(name);\n+            key = HexToBytes(Objects.requireNonNull(keyStr));\n+            nonce = HexToBytes(Objects.requireNonNull(nonceStr));\n+            if ((counter = ctr) < 0) {\n+                throw new IllegalArgumentException(\n+                        \"counter must be 0 or greater\");\n+            }\n+            direction = dir;\n+            if ((direction != Cipher.ENCRYPT_MODE) &&\n+                    (direction != Cipher.DECRYPT_MODE)) {\n+                throw new IllegalArgumentException(\n+                        \"Direction must be ENCRYPT_MODE or DECRYPT_MODE\");\n+            }\n+            input = HexToBytes(Objects.requireNonNull(inputStr));\n+            aad = (aadStr != null) ? HexToBytes(aadStr) : null;\n+            expOutput = HexToBytes(Objects.requireNonNull(outStr));\n+        }\n+\n+        public final String testName;\n+        public final byte[] key;\n+        public final byte[] nonce;\n+        public final int counter;\n+        public final int direction;\n+        public final byte[] input;\n+        public final byte[] aad;\n+        public final byte[] expOutput;\n+    }\n+\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+\n+    public static final List<TestData> aeadTestList =\n+            new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 7539 Sample AEAD Test Vector\",\n+            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+            \"070000004041424344454647\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+            \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+            \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+            \"637265656e20776f756c642062652069742e\",\n+            \"50515253c0c1c2c3c4c5c6c7\",\n+            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d6\" +\n+            \"3dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b36\" +\n+            \"92ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc\" +\n+            \"3ff4def08e4b7a9de576d26586cec64b61161ae10b594f09e26a7e902ecbd060\" +\n+            \"0691\"));\n+        add(new TestData(\"RFC 7539 A.5 Sample Decryption\",\n+            \"1c9240a5eb55d38af333888604f6b5f0473917c1402b80099dca5cbc207075c0\",\n+            \"000000000102030405060708\",\n+            1, Cipher.DECRYPT_MODE,\n+            \"64a0861575861af460f062c79be643bd5e805cfd345cf389f108670ac76c8cb2\" +\n+            \"4c6cfc18755d43eea09ee94e382d26b0bdb7b73c321b0100d4f03b7f355894cf\" +\n+            \"332f830e710b97ce98c8a84abd0b948114ad176e008d33bd60f982b1ff37c855\" +\n+            \"9797a06ef4f0ef61c186324e2b3506383606907b6a7c02b0f9f6157b53c867e4\" +\n+            \"b9166c767b804d46a59b5216cde7a4e99040c5a40433225ee282a1b0a06c523e\" +\n+            \"af4534d7f83fa1155b0047718cbc546a0d072b04b3564eea1b422273f548271a\" +\n+            \"0bb2316053fa76991955ebd63159434ecebb4e466dae5a1073a6727627097a10\" +\n+            \"49e617d91d361094fa68f0ff77987130305beaba2eda04df997b714d6c6f2c29\" +\n+            \"a6ad5cb4022b02709beead9d67890cbb22392336fea1851f38\",\n+            \"f33388860000000000004e91\",\n+            \"496e7465726e65742d4472616674732061726520647261667420646f63756d65\" +\n+            \"6e74732076616c696420666f722061206d6178696d756d206f6620736978206d\" +\n+            \"6f6e74687320616e64206d617920626520757064617465642c207265706c6163\" +\n+            \"65642c206f72206f62736f6c65746564206279206f7468657220646f63756d65\" +\n+            \"6e747320617420616e792074696d652e20497420697320696e617070726f7072\" +\n+            \"6961746520746f2075736520496e7465726e65742d4472616674732061732072\" +\n+            \"65666572656e6365206d6174657269616c206f7220746f206369746520746865\" +\n+            \"6d206f74686572207468616e206173202fe2809c776f726b20696e2070726f67\" +\n+            \"726573732e2fe2809d\"));\n+    }};\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        System.out.println(\"----- AEAD Tests -----\");\n+        for (TestData test : aeadTestList) {\n+            System.out.println(\"*** Test \" + ++testNumber + \": \" +\n+                    test.testName);\n+            if (runAEADTest(p, test)) {\n+                testsPassed++;\n+            }\n+        }\n+        System.out.println();\n+\n+        System.out.println(\"Total tests: \" + testNumber +\n+                \", Passed: \" + testsPassed + \", Failed: \" +\n+                (testNumber - testsPassed));\n+        if (testsPassed != testNumber) {\n+            throw new RuntimeException(\"One or more tests failed.  \" +\n+                    \"Check output for details\");\n+        }\n+    }\n+\n+    private static boolean runAEADTest(Provider p, TestData testData)\n+            throws GeneralSecurityException {\n+        boolean result = false;\n+\n+        Cipher mambo = Cipher.getInstance(ALGO, p);\n+        SecretKeySpec mamboKey = new SecretKeySpec(testData.key, \"ChaCha20\");\n+        IvParameterSpec mamboSpec = new IvParameterSpec(testData.nonce);\n+\n+        mambo.init(testData.direction, mamboKey, mamboSpec);\n+\n+        byte[] out = new byte[mambo.getOutputSize(testData.input.length)];\n+        int outOff = 0;\n+        try {\n+            mambo.updateAAD(testData.aad);\n+            outOff += mambo.update(testData.input, 0, testData.input.length,\n+                    out, outOff);\n+            outOff += mambo.doFinal(out, outOff);\n+        } catch (AEADBadTagException abte) {\n+            \/\/ If we get a bad tag or derive a tag mismatch, log it\n+            \/\/ and register it as a failure\n+            System.out.println(\"FAIL: \" + abte);\n+            return false;\n+        }\n+\n+        if (!Arrays.equals(out, 0, outOff, testData.expOutput, 0, outOff)) {\n+            System.out.println(\"ERROR - Output Mismatch!\");\n+            System.out.println(\"Expected:\\n\" +\n+                    dumpHexBytes(testData.expOutput, 16, \"\\n\", \" \"));\n+            System.out.println(\"Actual:\\n\" +\n+                    dumpHexBytes(out, 16, \"\\n\", \" \"));\n+            System.out.println();\n+        } else {\n+            result = true;\n+        }\n+\n+        return result;\n+    }\n+\n+    \/**\n+     * Dump the hex bytes of a buffer into string form.\n+     *\n+     * @param data The array of bytes to dump to stdout.\n+     * @param itemsPerLine The number of bytes to display per line\n+     *      if the {@code lineDelim} character is blank then all bytes\n+     *      will be printed on a single line.\n+     * @param lineDelim The delimiter between lines\n+     * @param itemDelim The delimiter between bytes\n+     *\n+     * @return The hexdump of the byte array\n+     *\/\n+    private static String dumpHexBytes(byte[] data, int itemsPerLine,\n+            String lineDelim, String itemDelim) {\n+        return dumpHexBytes(ByteBuffer.wrap(data), itemsPerLine, lineDelim,\n+                itemDelim);\n+    }\n+\n+    private static String dumpHexBytes(ByteBuffer data, int itemsPerLine,\n+            String lineDelim, String itemDelim) {\n+        StringBuilder sb = new StringBuilder();\n+        if (data != null) {\n+            data.mark();\n+            int i = 0;\n+            while (data.remaining() > 0) {\n+                if (i % itemsPerLine == 0 && i != 0) {\n+                    sb.append(lineDelim);\n+                }\n+                sb.append(String.format(\"%02X\", data.get())).append(itemDelim);\n+                i++;\n+            }\n+            data.reset();\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPolyKAT(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyKAT.java","additions":233,"deletions":0,"binary":false,"changes":233,"status":"added"},{"patch":"@@ -0,0 +1,267 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestChaChaPolyNoReuse\n+ * @summary Test PKCS#11 ChaCha20-Poly1305 Cipher Implementation\n+ * (key\/nonce reuse check)\n+ *\/\n+\n+import java.util.*;\n+import javax.crypto.Cipher;\n+import java.security.spec.AlgorithmParameterSpec;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import javax.crypto.AEADBadTagException;\n+import javax.crypto.SecretKey;\n+import java.security.InvalidKeyException;\n+import java.security.InvalidAlgorithmParameterException;\n+\n+public class TestChaChaPolyNoReuse extends PKCS11Test {\n+\n+    private static final String KEY_ALGO = \"ChaCha20\";\n+    private static final String CIPHER_ALGO = \"ChaCha20-Poly1305\";\n+\n+    \/**\n+     * Basic TestMethod interface definition\n+     *\/\n+    public interface TestMethod {\n+        \/**\n+         * Runs the actual test case\n+         *\n+         * @param provider the provider to provide the requested Cipher obj.\n+         *\n+         * @return true if the test passes, false otherwise.\n+         *\/\n+        boolean run(Provider p);\n+    }\n+\n+    public static class TestData {\n+        public TestData(String name, String keyStr, String nonceStr, int ctr,\n+                int dir, String inputStr, String aadStr, String outStr) {\n+            testName = Objects.requireNonNull(name);\n+            key = HexToBytes(keyStr);\n+            nonce = HexToBytes(nonceStr);\n+            if ((counter = ctr) < 0) {\n+                throw new IllegalArgumentException(\n+                        \"counter must be 0 or greater\");\n+            }\n+            direction = dir;\n+            if (direction != Cipher.ENCRYPT_MODE) {\n+                throw new IllegalArgumentException(\n+                        \"Direction must be ENCRYPT_MODE\");\n+            }\n+            input = HexToBytes(inputStr);\n+            aad = (aadStr != null) ? HexToBytes(aadStr) : null;\n+            expOutput = HexToBytes(outStr);\n+        }\n+\n+        public final String testName;\n+        public final byte[] key;\n+        public final byte[] nonce;\n+        public final int counter;\n+        public final int direction;\n+        public final byte[] input;\n+        public final byte[] aad;\n+        public final byte[] expOutput;\n+    }\n+\n+    public static final List<TestData> aeadTestList =\n+            new LinkedList<TestData>() {{\n+        add(new TestData(\"RFC 7539 Sample AEAD Test Vector\",\n+            \"808182838485868788898a8b8c8d8e8f909192939495969798999a9b9c9d9e9f\",\n+            \"070000004041424344454647\",\n+            1, Cipher.ENCRYPT_MODE,\n+            \"4c616469657320616e642047656e746c656d656e206f662074686520636c6173\" +\n+            \"73206f66202739393a204966204920636f756c64206f6666657220796f75206f\" +\n+            \"6e6c79206f6e652074697020666f7220746865206675747572652c2073756e73\" +\n+            \"637265656e20776f756c642062652069742e\",\n+            \"50515253c0c1c2c3c4c5c6c7\",\n+            \"d31a8d34648e60db7b86afbc53ef7ec2a4aded51296e08fea9e2b5a736ee62d6\" +\n+            \"3dbea45e8ca9671282fafb69da92728b1a71de0a9e060b2905d6a5b67ecd3b36\" +\n+            \"92ddbd7f2d778b8c9803aee328091b58fab324e4fad675945585808b4831d7bc\" +\n+            \"3ff4def08e4b7a9de576d26586cec64b61161ae10b594f09e26a7e902ecbd060\" +\n+            \"0691\"));\n+    }};\n+\n+    \/**\n+     * Make sure we do not use this Cipher object without initializing it\n+     * at all\n+     *\/\n+    public static final TestMethod noInitTest = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- No Init Test -----\");\n+            try {\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+\n+                \/\/ Attempting to use the cipher without initializing it\n+                \/\/ should throw an IllegalStateException\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Attempt to run two full encryption operations without an init in\n+     * between.\n+     *\/\n+    public static final TestMethod encTwiceNoInit = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Encrypt 2nd time without init -----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize and encrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First encryption complete\");\n+\n+                \/\/ Now attempt to encrypt again without changing the key\/IV\n+                \/\/ This should fail.\n+                try {\n+                    cipher.updateAAD(testData.aad);\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+                try {\n+                    cipher.doFinal(testData.input);\n+                    throw new RuntimeException(\n+                            \"Expected IllegalStateException not thrown\");\n+                } catch (IllegalStateException ise) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    \/**\n+     * Encrypt once successfully, then attempt to init with the same\n+     * key and nonce.\n+     *\/\n+    public static final TestMethod encTwiceInitSameParams = new TestMethod() {\n+        @Override\n+        public boolean run(Provider p) {\n+            System.out.println(\"----- Encrypt, then init with same params \" +\n+                     \"-----\");\n+            try {\n+                AlgorithmParameterSpec spec;\n+                Cipher cipher = Cipher.getInstance(CIPHER_ALGO, p);\n+                TestData testData = aeadTestList.get(0);\n+                spec = new IvParameterSpec(testData.nonce);\n+                SecretKey key = new SecretKeySpec(testData.key, KEY_ALGO);\n+\n+                \/\/ Initialize then encrypt\n+                cipher.init(testData.direction, key, spec);\n+                cipher.updateAAD(testData.aad);\n+                cipher.doFinal(testData.input);\n+                System.out.println(\"First encryption complete\");\n+\n+                \/\/ Initializing after the completed encryption with\n+                \/\/ the same key and nonce should fail.\n+                try {\n+                    cipher.init(testData.direction, key, spec);\n+                    throw new RuntimeException(\n+                            \"Expected IKE or IAPE not thrown\");\n+                } catch (InvalidKeyException |\n+                        InvalidAlgorithmParameterException e) {\n+                    \/\/ Do nothing, this is what we expected to happen\n+                }\n+            } catch (Exception exc) {\n+                System.out.println(\"Unexpected exception: \" + exc);\n+                exc.printStackTrace();\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+    };\n+\n+    public static final List<TestMethod> testMethodList =\n+            Arrays.asList(noInitTest, encTwiceNoInit, encTwiceInitSameParams);\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(CIPHER_ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + CIPHER_ALGO);\n+            return;\n+        }\n+\n+        int testsPassed = 0;\n+        int testNumber = 0;\n+\n+        for (TestMethod tm : testMethodList) {\n+            testNumber++;\n+            boolean result = tm.run(p);\n+            System.out.println(\"Result: \" + (result ? \"PASS\" : \"FAIL\"));\n+            if (result) {\n+                testsPassed++;\n+            }\n+        }\n+\n+        System.out.println(\"Total Tests: \" + testNumber +\n+                \", Tests passed: \" + testsPassed);\n+        if (testsPassed < testNumber) {\n+            throw new RuntimeException(\n+                    \"Not all tests passed.  See output for failure info\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaChaPolyNoReuse(), args);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyNoReuse.java","additions":267,"deletions":0,"binary":false,"changes":267,"status":"added"},{"patch":"@@ -0,0 +1,164 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8255410\n+ * @summary Check ChaCha20-Poly1305 cipher output size\n+ * @library \/test\/lib ..\n+ * @build jdk.test.lib.Convert\n+ * @run main TestChaChaPolyOutputSize\n+ *\/\n+\n+import java.nio.ByteBuffer;\n+import java.security.GeneralSecurityException;\n+import java.security.Key;\n+import java.security.SecureRandom;\n+import java.security.Provider;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.Cipher;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestChaChaPolyOutputSize extends PKCS11Test {\n+\n+    private static final SecureRandom SR = new SecureRandom();\n+\n+    private static final SecretKeySpec KEY = new SecretKeySpec(new byte[32],\n+            \"ChaCha20\");\n+\n+    private static final String ALGO = \"ChaCha20-Poly1305\";\n+\n+    public static void main(String args[]) throws Exception {\n+        main(new TestChaChaPolyOutputSize(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws GeneralSecurityException {\n+        System.out.println(\"Testing \" + p.getName());\n+        try {\n+            Cipher.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+        testGetOutSize(p);\n+        testMultiPartAEADDec(p);\n+    }\n+\n+    private static void testGetOutSize(Provider p)\n+            throws GeneralSecurityException {\n+\n+        Cipher ccp = Cipher.getInstance(ALGO, p);\n+        ccp.init(Cipher.ENCRYPT_MODE, KEY,\n+                new IvParameterSpec(getRandBuf(12)));\n+\n+        \/\/ Encryption lengths are calculated as the input length plus the tag\n+        \/\/ length (16).\n+        testOutLen(ccp, 0, 16);\n+        testOutLen(ccp, 5, 21);\n+        testOutLen(ccp, 5120, 5136);\n+        \/\/ perform an update, then test with a final block\n+        byte[] input = new byte[5120];\n+        SR.nextBytes(input);\n+        byte[] updateOut = ccp.update(input);\n+        testOutLen(ccp, 1024, 1040 +\n+                (5120 - (updateOut == null? 0 : updateOut.length)));\n+\n+        \/\/ Decryption lengths are handled differently for AEAD mode.  The length\n+        \/\/ should be zero for anything up to and including the first 16 bytes\n+        \/\/ (since that's the tag).  Anything above that should be the input\n+        \/\/ length plus any unprocessed input (via update calls), minus the\n+        \/\/ 16 byte tag.\n+        ccp.init(Cipher.DECRYPT_MODE, KEY, new IvParameterSpec(getRandBuf(12)));\n+        testOutLen(ccp, 0, 0);\n+        testOutLen(ccp, 5, 0);\n+        testOutLen(ccp, 16, 0);\n+        testOutLen(ccp, 5120, 5104);\n+        \/\/ Perform an update, then test with the length of a final chunk\n+        \/\/ of data.\n+        updateOut = ccp.update(input);\n+        testOutLen(ccp, 1024, 6128 - (updateOut == null? 0 : updateOut.length));\n+    }\n+\n+    private static void testMultiPartAEADDec(Provider p)\n+            throws GeneralSecurityException {\n+        IvParameterSpec ivps = new IvParameterSpec(getRandBuf(12));\n+\n+        \/\/ Encrypt some data so we can test decryption.\n+        byte[] pText = getRandBuf(2048);\n+        ByteBuffer pTextBase = ByteBuffer.wrap(pText);\n+\n+        Cipher enc = Cipher.getInstance(ALGO, p);\n+        enc.init(Cipher.ENCRYPT_MODE, KEY, ivps);\n+        ByteBuffer ctBuf = ByteBuffer.allocateDirect(\n+                enc.getOutputSize(pText.length));\n+        enc.doFinal(pTextBase, ctBuf);\n+\n+        \/\/ Create a new direct plain text ByteBuffer which will catch the\n+        \/\/ decrypted data.\n+        ByteBuffer ptBuf = ByteBuffer.allocateDirect(pText.length);\n+\n+        \/\/ Set the cipher text buffer limit to roughly half the data so we can\n+        \/\/ do an update\/final sequence.\n+        ctBuf.position(0).limit(1024);\n+\n+        Cipher dec = Cipher.getInstance(ALGO, p);\n+        dec.init(Cipher.DECRYPT_MODE, KEY, ivps);\n+        dec.update(ctBuf, ptBuf);\n+        System.out.println(\"CTBuf: \" + ctBuf);\n+        System.out.println(\"PTBuf: \" + ptBuf);\n+        ctBuf.limit(ctBuf.capacity());\n+        dec.doFinal(ctBuf, ptBuf);\n+\n+        \/\/ NOTE: do not use flip() which will set limit based on current\n+        \/\/ position. ptBuf curr pos = 2048 vs pTextBase pos = 0\n+        ptBuf.flip();\n+        pTextBase.flip();\n+        System.out.println(\"PT Base:\" + pTextBase);\n+        System.out.println(\"PT Actual:\" + ptBuf);\n+\n+        if (pTextBase.compareTo(ptBuf) != 0) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Plaintext mismatch: Original: \").\n+                    append(pTextBase.toString()).append(\"\\nActual :\").\n+                    append(ptBuf);\n+            throw new RuntimeException(sb.toString());\n+        }\n+    }\n+\n+    private static void testOutLen(Cipher c, int inLen, int expOut) {\n+        int actualOut = c.getOutputSize(inLen);\n+        if (actualOut != expOut) {\n+            throw new RuntimeException(\"Cipher \" + c + \", in: \" + inLen +\n+                    \", expOut: \" + expOut + \", actual: \" + actualOut);\n+        }\n+    }\n+\n+    private static byte[] getRandBuf(int len) {\n+        byte[] buf = new byte[len];\n+        SR.nextBytes(buf);\n+        return buf;\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestChaChaPolyOutputSize.java","additions":164,"deletions":0,"binary":false,"changes":164,"status":"added"},{"patch":"@@ -42,12 +42,0 @@\n-    \/\/ Utility methods\n-    private static byte[] HexToBytes(String hexVal) {\n-        if (hexVal == null) return new byte[0];\n-        byte[] result = new byte[hexVal.length()\/2];\n-        for (int i = 0; i < result.length; i++) {\n-            \/\/ 2 characters at a time\n-            String byteVal = hexVal.substring(2*i, 2*i +2);\n-            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n-        }\n-        return result;\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/Cipher\/TestKATForGCM.java","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @modules jdk.crypto.cryptoki\n+ * @summary Check ChaCha20 key generator.\n+ * @library \/test\/lib ..\n+ * @run main\/othervm TestChaCha20\n+ *\/\n+import java.security.Provider;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidParameterException;\n+import java.security.NoSuchAlgorithmException;\n+\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.ChaCha20ParameterSpec;\n+\n+public class TestChaCha20 extends PKCS11Test {\n+\n+    private static final String ALGO = \"ChaCha20\";\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestChaCha20(), args);\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+        System.out.println(\"Testing \" + p.getName());\n+        KeyGenerator kg;\n+        try {\n+            kg = KeyGenerator.getInstance(ALGO, p);\n+        } catch (NoSuchAlgorithmException nsae) {\n+            System.out.println(\"Skip; no support for \" + ALGO);\n+            return;\n+        }\n+\n+        try {\n+            kg.init(new ChaCha20ParameterSpec(new byte[12], 0));\n+            throw new RuntimeException(\n+                    \"ChaCha20 key generation should not need any paramSpec\");\n+        } catch (InvalidAlgorithmParameterException e) {\n+            System.out.println(\"Expected IAPE: \" + e.getMessage());\n+        }\n+\n+        for (int keySize : new int[] { 32, 64, 128, 256, 512, 1024 }) {\n+            try {\n+                kg.init(keySize);\n+                if (keySize != 256) {\n+                    throw new RuntimeException(keySize + \" is invalid keysize\");\n+                }\n+            } catch (InvalidParameterException e) {\n+                if (keySize == 256) {\n+                    throw new RuntimeException(\"IPE thrown for valid keySize\");\n+                } else {\n+                    System.out.println(\"Expected IPE thrown for \" + keySize);\n+                }\n+            }\n+        }\n+\n+        \/\/kg.init(256);\n+        SecretKey key = kg.generateKey();\n+        byte[] keyValue = key.getEncoded();\n+        System.out.println(\"Key: \" + toHexString(keyValue));\n+        if (keyValue.length != 32) {\n+            throw new RuntimeException(\"The size of generated key must be 256\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/KeyGenerator\/TestChaCha20.java","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -114,0 +114,34 @@\n+    \/\/ Utility methods\n+    \/\/ Used to backport HexFormat from 17.\n+    protected static byte[] HexToBytes(String hexVal) {\n+        if (hexVal == null) return new byte[0];\n+        byte[] result = new byte[hexVal.length()\/2];\n+        for (int i = 0; i < result.length; i++) {\n+            \/\/ 2 characters at a time\n+            String byteVal = hexVal.substring(2*i, 2*i +2);\n+            result[i] = Integer.valueOf(byteVal, 16).byteValue();\n+        }\n+        return result;\n+    }\n+    private static void byte2hex(byte b, StringBuffer buf) {\n+        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n+                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n+        int high = ((b & 0xf0) >> 4);\n+        int low = (b & 0x0f);\n+        buf.append(hexChars[high]);\n+        buf.append(hexChars[low]);\n+    }\n+    protected static String toHexString(byte[] block) {\n+        StringBuffer buf = new StringBuffer();\n+\n+        int len = block.length;\n+\n+        for (int i = 0; i < len; i++) {\n+             byte2hex(block[i], buf);\n+             if (i < len-1) {\n+                 buf.append(\":\");\n+             }\n+        }\n+        return buf.toString();\n+    }\n+\n","filename":"test\/jdk\/sun\/security\/pkcs11\/PKCS11Test.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8255410\n+ * @summary test the general SecretKeyFactory functionality\n+ * @library \/test\/lib ..\n+ * @modules jdk.crypto.cryptoki\n+ * @run main\/othervm TestGeneral\n+ *\/\n+\n+import java.security.NoSuchAlgorithmException;\n+import java.security.Provider;\n+import java.security.SecureRandom;\n+import java.util.Arrays;\n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+public class TestGeneral extends PKCS11Test {\n+\n+    private enum TestResult {\n+        PASS,\n+        FAIL,\n+        TBD \/\/ unused for now\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        main(new TestGeneral(), args);\n+    }\n+\n+    private void test(String algorithm, SecretKey key, Provider p,\n+            TestResult expected) throws RuntimeException {\n+        System.out.println(\"Testing \" + algorithm + \" SKF from \" + p.getName());\n+        SecretKeyFactory skf;\n+        try {\n+            skf = SecretKeyFactory.getInstance(algorithm, p);\n+        } catch (NoSuchAlgorithmException e) {\n+            System.out.println(\"Not supported, skipping: \" + e);\n+            return;\n+        }\n+        try {\n+            SecretKey key2 = skf.translateKey(key);\n+            if (expected == TestResult.FAIL) {\n+                throw new RuntimeException(\"translateKey() should FAIL\");\n+            }\n+            System.out.println(\"=> translated key\");\n+            if (!key2.getAlgorithm().equalsIgnoreCase(algorithm)) {\n+                throw new RuntimeException(\"translated key algorithm mismatch\");\n+            }\n+            System.out.println(\"=> checked key algorithm\");\n+\n+            \/\/ proceed to check encodings if format match\n+            if (key2.getFormat().equalsIgnoreCase(key.getFormat())) {\n+                if (key2.getEncoded() != null &&\n+                        !Arrays.equals(key.getEncoded(), key2.getEncoded())) {\n+                    throw new RuntimeException(\n+                            \"translated key encoding mismatch\");\n+                }\n+                System.out.println(\"=> checked key format and encoding\");\n+            }\n+        } catch (Exception e) {\n+            if (expected == TestResult.PASS) {\n+                e.printStackTrace();\n+                throw new RuntimeException(\"translateKey() should pass\", e);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void main(Provider p) throws Exception {\n+\n+        byte[] rawBytes = new byte[32];\n+        new SecureRandom().nextBytes(rawBytes);\n+\n+        SecretKey aes_128Key = new SecretKeySpec(rawBytes, 0, 16, \"AES\");\n+        SecretKey aes_256Key = new SecretKeySpec(rawBytes, 0, 32, \"AES\");\n+        SecretKey bf_128Key = new SecretKeySpec(rawBytes, 0, 16, \"Blowfish\");\n+        SecretKey cc20Key = new SecretKeySpec(rawBytes, 0, 32, \"ChaCha20\");\n+\n+        \/\/ fixed key length\n+        test(\"AES\", aes_128Key, p, TestResult.PASS);\n+        test(\"AES\", aes_256Key, p, TestResult.PASS);\n+        test(\"AES\", cc20Key, p, TestResult.FAIL);\n+\n+        test(\"ChaCha20\", aes_128Key, p, TestResult.FAIL);\n+        test(\"ChaCha20\", aes_256Key, p, TestResult.FAIL);\n+        test(\"ChaCha20\", cc20Key, p, TestResult.PASS);\n+\n+        \/\/ variable key length\n+        \/\/ Different PKCS11 impls may have different ranges\n+        \/\/ of supported key sizes for variable-key-length\n+        \/\/ algorithms.\n+        test(\"Blowfish\", aes_128Key, p, TestResult.FAIL);\n+        test(\"Blowfish\", cc20Key, p, TestResult.FAIL);\n+        test(\"Blowfish\", bf_128Key, p, TestResult.PASS);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/pkcs11\/SecretKeyFactory\/TestGeneral.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -110,29 +110,0 @@\n-    \/*\n-     * Converts a byte to hex digit and writes to the supplied buffer\n-     *\/\n-    private void byte2hex(byte b, StringBuffer buf) {\n-        char[] hexChars = { '0', '1', '2', '3', '4', '5', '6', '7', '8',\n-                            '9', 'A', 'B', 'C', 'D', 'E', 'F' };\n-        int high = ((b & 0xf0) >> 4);\n-        int low = (b & 0x0f);\n-        buf.append(hexChars[high]);\n-        buf.append(hexChars[low]);\n-    }\n-\n-    \/*\n-     * Converts a byte array to hex string\n-     *\/\n-    private String toHexString(byte[] block) {\n-        StringBuffer buf = new StringBuffer();\n-\n-        int len = block.length;\n-\n-        for (int i = 0; i < len; i++) {\n-             byte2hex(block[i], buf);\n-             if (i < len-1) {\n-                 buf.append(\":\");\n-             }\n-        }\n-        return buf.toString();\n-    }\n-\n","filename":"test\/jdk\/sun\/security\/pkcs11\/tls\/TestLeadingZeroesP11.java","additions":0,"deletions":29,"binary":false,"changes":29,"status":"modified"}]}