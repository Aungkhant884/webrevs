{"files":[{"patch":"@@ -215,5 +215,5 @@\n-static const juint starttime_offset = sizeof(jlong);\n-static const juint duration_offset = starttime_offset + sizeof(jlong);\n-static const juint flushpoint_offset = duration_offset + sizeof(jlong);\n-static const juint types_offset = flushpoint_offset + sizeof(juint);\n-static const juint payload_offset = types_offset + sizeof(juint);\n+static const size_t starttime_offset = sizeof(int64_t);\n+static const size_t duration_offset = starttime_offset + sizeof(int64_t);\n+static const size_t flushpoint_offset = duration_offset + sizeof(int64_t);\n+static const size_t types_offset = flushpoint_offset + sizeof(uint32_t);\n+static const size_t payload_offset = types_offset + sizeof(uint32_t);\n@@ -226,2 +226,4 @@\n-static jlong total_size(const u1* data) {\n-  return read_data<jlong>(data);\n+static size_t total_size(const u1* data) {\n+  const int64_t size = read_data<int64_t>(data);\n+  assert(size > 0, \"invariant\");\n+  return static_cast<size_t>(size);\n@@ -230,2 +232,2 @@\n-static jlong starttime(const u1* data) {\n-  return read_data<jlong>(data + starttime_offset);\n+static int64_t starttime(const u1* data) {\n+  return read_data<int64_t>(data + starttime_offset);\n@@ -234,2 +236,2 @@\n-static jlong duration(const u1* data) {\n-  return read_data<jlong>(data + duration_offset);\n+static int64_t duration(const u1* data) {\n+  return read_data<int64_t>(data + duration_offset);\n@@ -239,1 +241,1 @@\n-  return read_data<juint>(data + flushpoint_offset) == (juint)1;\n+  return read_data<uint32_t>(data + flushpoint_offset) == (uint32_t)1;\n@@ -242,2 +244,2 @@\n-static juint number_of_types(const u1* data) {\n-  return read_data<juint>(data + types_offset);\n+static uint32_t number_of_types(const u1* data) {\n+  return read_data<uint32_t>(data + types_offset);\n@@ -246,8 +248,2 @@\n-static void write_checkpoint_header(JfrChunkWriter& cw, int64_t offset_prev_cp_event, const u1* data) {\n-  cw.reserve(sizeof(u4));\n-  cw.write<u8>(EVENT_CHECKPOINT);\n-  cw.write(starttime(data));\n-  cw.write(duration(data));\n-  cw.write(offset_prev_cp_event);\n-  cw.write(is_flushpoint(data));\n-  cw.write(number_of_types(data));\n+static size_t payload_size(const u1* data) {\n+  return total_size(data) - sizeof(JfrCheckpointEntry);\n@@ -256,1 +252,1 @@\n-static void write_checkpoint_content(JfrChunkWriter& cw, const u1* data, size_t size) {\n+static uint64_t calculate_event_size_bytes(JfrChunkWriter& cw, const u1* data, int64_t event_begin, int64_t delta_to_last_checkpoint) {\n@@ -258,1 +254,8 @@\n-  cw.write_unbuffered(data + payload_offset, size - sizeof(JfrCheckpointEntry));\n+  size_t bytes = cw.size_in_bytes(EVENT_CHECKPOINT);\n+  bytes += cw.size_in_bytes(starttime(data));\n+  bytes += cw.size_in_bytes(duration(data));\n+  bytes += cw.size_in_bytes(delta_to_last_checkpoint);\n+  bytes += cw.size_in_bytes(is_flushpoint(data));\n+  bytes += cw.size_in_bytes(number_of_types(data));\n+  bytes += payload_size(data); \/\/ in bytes already.\n+  return bytes + cw.size_in_bytes(bytes + cw.size_in_bytes(bytes));\n@@ -265,6 +268,0 @@\n-  const int64_t delta = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n-  const int64_t checkpoint_size = total_size(data);\n-  write_checkpoint_header(cw, delta, data);\n-  write_checkpoint_content(cw, data, checkpoint_size);\n-  const int64_t event_size = cw.current_offset() - event_begin;\n-  cw.write_padded_at_offset<u4>(event_size, event_begin);\n@@ -272,1 +269,12 @@\n-  return (size_t)checkpoint_size;\n+  const int64_t delta_to_last_checkpoint = last_checkpoint_event == 0 ? 0 : last_checkpoint_event - event_begin;\n+  const uint64_t event_size = calculate_event_size_bytes(cw, data, event_begin, delta_to_last_checkpoint);\n+  cw.write(event_size);\n+  cw.write(EVENT_CHECKPOINT);\n+  cw.write(starttime(data));\n+  cw.write(duration(data));\n+  cw.write(delta_to_last_checkpoint);\n+  cw.write(is_flushpoint(data));\n+  cw.write(number_of_types(data));\n+  cw.write_unbuffered(data + payload_offset, payload_size(data));\n+  assert(static_cast<uint64_t>(cw.current_offset() - event_begin) == event_size, \"invariant\");\n+  return total_size(data);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/jfrCheckpointManager.cpp","additions":39,"deletions":31,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -132,0 +135,11 @@\n+template <typename T>\n+inline size_t BigEndianEncoderImpl::size_in_bytes(T value) {\n+  switch (sizeof(T)) {\n+    case 1: return 1;\n+    case 2: return 2;\n+    case 4: return 4;\n+    case 8:return 8;\n+  }\n+  ShouldNotReachHere();\n+  return 0;\n+}\n@@ -163,0 +177,3 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value);\n+\n@@ -298,0 +315,30 @@\n+template <typename T>\n+inline size_t Varint128EncoderImpl::size_in_bytes(T value) {\n+  const u8 v = to_u8(value);\n+  if (LESS_THAN_128(v)) {\n+    return 1;\n+  }\n+  if (LESS_THAN_128(v >> 7)) {\n+    return 2;\n+  }\n+  if (LESS_THAN_128(v >> 14)) {\n+    return 3;\n+  }\n+  if (LESS_THAN_128(v >> 21)) {\n+    return 4;\n+  }\n+  if (LESS_THAN_128(v >> 28)) {\n+    return 5;\n+  }\n+  if (LESS_THAN_128(v >> 35)) {\n+    return 6;\n+  }\n+  if (LESS_THAN_128(v >> 42)) {\n+    return 7;\n+  }\n+  if (LESS_THAN_128(v >> 49)) {\n+    return 8;\n+  }\n+  return 9;\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoders.hpp","additions":48,"deletions":1,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -72,0 +72,5 @@\n+  template <typename T>\n+  static size_t size_in_bytes(T value) {\n+    return IntegerEncoder::size_in_bytes(value);\n+  }\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrEncoding.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+  template <typename T>\n+  size_t size_in_bytes(T value);\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -362,0 +362,6 @@\n+template <typename BE, typename IE, typename WriterPolicyImpl>\n+template <typename T>\n+inline size_t WriterHost<BE, IE, WriterPolicyImpl>::size_in_bytes(T value) {\n+  return IE::size_in_bytes(value);\n+}\n+\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrWriterHost.inline.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-            int size = input.readInt();\n+            long size = input.readLong();\n@@ -105,1 +105,1 @@\n-            int size = input.readInt(); \/\/ size\n+            long size = input.readLong(); \/\/ size\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/consumer\/ChunkParser.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}