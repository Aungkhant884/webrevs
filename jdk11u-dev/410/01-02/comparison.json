{"files":[{"patch":"@@ -120,1 +120,1 @@\n-  product(bool, TraceTraps, false, \"Trace all traps the signal handler\")\\\n+  product(bool, TraceTraps, false, \"Trace all traps the signal handler\") \\\n@@ -124,1 +124,3 @@\n-          range(-1, 4096)\n+          range(-1, 4096)                                               \\\n+  product(bool, UseAESGCMIntrinsics, false,                             \\\n+          \"Use fast interleaved SIMD for AES\/GCM\")\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1295,4 +1295,0 @@\n-  void ghash_multiply_wide(int index,\n-                           FloatRegister result_lo, FloatRegister result_hi,\n-                           FloatRegister a, FloatRegister b, FloatRegister a1_xor_a0,\n-                           FloatRegister tmp1, FloatRegister tmp2, FloatRegister tmp3);\n@@ -1301,2 +1297,0 @@\n-  void ghash_reduce_wide(int index, FloatRegister result, FloatRegister lo, FloatRegister hi,\n-                    FloatRegister p, FloatRegister z, FloatRegister t1);\n@@ -1305,1 +1299,4 @@\n-\n+  void ghash_modmul (FloatRegister result,\n+                     FloatRegister result_lo, FloatRegister result_hi, FloatRegister b,\n+                     FloatRegister a, FloatRegister vzr, FloatRegister a1_xor_a0, FloatRegister p,\n+                     FloatRegister t1, FloatRegister t2, FloatRegister t3);\n@@ -1315,5 +1312,1 @@\n-  void ghash_modmul (FloatRegister result,\n-                     FloatRegister result_lo, FloatRegister result_hi, FloatRegister b,\n-                     FloatRegister a, FloatRegister vzr, FloatRegister a1_xor_a0, FloatRegister p,\n-                     FloatRegister t1, FloatRegister t2, FloatRegister t3);\n-  void ghash_load_wide(int index, Register data, FloatRegister result, FloatRegister state);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":5,"deletions":12,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2478,0 +2478,2 @@\n+    Label L_doLast;\n+\n@@ -2488,2 +2490,69 @@\n-    __ aesenc_loadkeys(key, keylen);\n-    __ aesecb_encrypt(from, to, keylen);\n+    __ ld1(v0, __ T16B, from); \/\/ get 16 bytes of input\n+\n+    __ ld1(v1, v2, v3, v4, __ T16B, __ post(key, 64));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+    __ rev32(v3, __ T16B, v3);\n+    __ rev32(v4, __ T16B, v4);\n+    __ aese(v0, v1);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v2);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v3);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v4);\n+    __ aesmc(v0, v0);\n+\n+    __ ld1(v1, v2, v3, v4, __ T16B, __ post(key, 64));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+    __ rev32(v3, __ T16B, v3);\n+    __ rev32(v4, __ T16B, v4);\n+    __ aese(v0, v1);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v2);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v3);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v4);\n+    __ aesmc(v0, v0);\n+\n+    __ ld1(v1, v2, __ T16B, __ post(key, 32));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+\n+    __ cmpw(keylen, 44);\n+    __ br(Assembler::EQ, L_doLast);\n+\n+    __ aese(v0, v1);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v2);\n+    __ aesmc(v0, v0);\n+\n+    __ ld1(v1, v2, __ T16B, __ post(key, 32));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+\n+    __ cmpw(keylen, 52);\n+    __ br(Assembler::EQ, L_doLast);\n+\n+    __ aese(v0, v1);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v2);\n+    __ aesmc(v0, v0);\n+\n+    __ ld1(v1, v2, __ T16B, __ post(key, 32));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+\n+    __ BIND(L_doLast);\n+\n+    __ aese(v0, v1);\n+    __ aesmc(v0, v0);\n+    __ aese(v0, v2);\n+\n+    __ ld1(v1, __ T16B, key);\n+    __ rev32(v1, __ T16B, v1);\n+    __ eor(v0, __ T16B, v0, v1);\n+\n+    __ st1(v0, __ T16B, to);\n@@ -2522,1 +2591,70 @@\n-    __ aesecb_decrypt(from, to, key, keylen);\n+    __ ld1(v0, __ T16B, from); \/\/ get 16 bytes of input\n+\n+    __ ld1(v5, __ T16B, __ post(key, 16));\n+    __ rev32(v5, __ T16B, v5);\n+\n+    __ ld1(v1, v2, v3, v4, __ T16B, __ post(key, 64));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+    __ rev32(v3, __ T16B, v3);\n+    __ rev32(v4, __ T16B, v4);\n+    __ aesd(v0, v1);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v2);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v3);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v4);\n+    __ aesimc(v0, v0);\n+\n+    __ ld1(v1, v2, v3, v4, __ T16B, __ post(key, 64));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+    __ rev32(v3, __ T16B, v3);\n+    __ rev32(v4, __ T16B, v4);\n+    __ aesd(v0, v1);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v2);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v3);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v4);\n+    __ aesimc(v0, v0);\n+\n+    __ ld1(v1, v2, __ T16B, __ post(key, 32));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+\n+    __ cmpw(keylen, 44);\n+    __ br(Assembler::EQ, L_doLast);\n+\n+    __ aesd(v0, v1);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v2);\n+    __ aesimc(v0, v0);\n+\n+    __ ld1(v1, v2, __ T16B, __ post(key, 32));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+\n+    __ cmpw(keylen, 52);\n+    __ br(Assembler::EQ, L_doLast);\n+\n+    __ aesd(v0, v1);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v2);\n+    __ aesimc(v0, v0);\n+\n+    __ ld1(v1, v2, __ T16B, __ post(key, 32));\n+    __ rev32(v1, __ T16B, v1);\n+    __ rev32(v2, __ T16B, v2);\n+\n+    __ BIND(L_doLast);\n+\n+    __ aesd(v0, v1);\n+    __ aesimc(v0, v0);\n+    __ aesd(v0, v2);\n+\n+    __ eor(v0, __ T16B, v0, v5);\n+\n+    __ st1(v0, __ T16B, to);\n@@ -3649,0 +3787,63 @@\n+  void ghash_multiply(FloatRegister result_lo, FloatRegister result_hi,\n+                      FloatRegister a, FloatRegister b, FloatRegister a1_xor_a0,\n+                      FloatRegister tmp1, FloatRegister tmp2, FloatRegister tmp3, FloatRegister tmp4) {\n+    \/\/ Karatsuba multiplication performs a 128*128 -> 256-bit\n+    \/\/ multiplication in three 128-bit multiplications and a few\n+    \/\/ additions.\n+    \/\/\n+    \/\/ (C1:C0) = A1*B1, (D1:D0) = A0*B0, (E1:E0) = (A0+A1)(B0+B1)\n+    \/\/ (A1:A0)(B1:B0) = C1:(C0+C1+D1+E1):(D1+C0+D0+E0):D0\n+    \/\/\n+    \/\/ Inputs:\n+    \/\/\n+    \/\/ A0 in a.d[0]     (subkey)\n+    \/\/ A1 in a.d[1]\n+    \/\/ (A1+A0) in a1_xor_a0.d[0]\n+    \/\/\n+    \/\/ B0 in b.d[0]     (state)\n+    \/\/ B1 in b.d[1]\n+\n+    __ ext(tmp1, __ T16B, b, b, 0x08);\n+    __ pmull2(result_hi, __ T1Q, b, a, __ T2D);  \/\/ A1*B1\n+    __ eor(tmp1, __ T16B, tmp1, b);            \/\/ (B1+B0)\n+    __ pmull(result_lo,  __ T1Q, b, a, __ T1D);  \/\/ A0*B0\n+    __ pmull(tmp2, __ T1Q, tmp1, a1_xor_a0, __ T1D); \/\/ (A1+A0)(B1+B0)\n+\n+    __ ext(tmp4, __ T16B, result_lo, result_hi, 0x08);\n+    __ eor(tmp3, __ T16B, result_hi, result_lo); \/\/ A1*B1+A0*B0\n+    __ eor(tmp2, __ T16B, tmp2, tmp4);\n+    __ eor(tmp2, __ T16B, tmp2, tmp3);\n+\n+    \/\/ Register pair <result_hi:result_lo> holds the result of carry-less multiplication\n+    __ ins(result_hi, __ D, tmp2, 0, 1);\n+    __ ins(result_lo, __ D, tmp2, 1, 0);\n+  }\n+\n+  void ghash_reduce(FloatRegister result, FloatRegister lo, FloatRegister hi,\n+                    FloatRegister p, FloatRegister z, FloatRegister t1) {\n+    const FloatRegister t0 = result;\n+\n+    \/\/ The GCM field polynomial f is z^128 + p(z), where p =\n+    \/\/ z^7+z^2+z+1.\n+    \/\/\n+    \/\/    z^128 === -p(z)  (mod (z^128 + p(z)))\n+    \/\/\n+    \/\/ so, given that the product we're reducing is\n+    \/\/    a == lo + hi * z^128\n+    \/\/ substituting,\n+    \/\/      === lo - hi * p(z)  (mod (z^128 + p(z)))\n+    \/\/\n+    \/\/ we reduce by multiplying hi by p(z) and subtracting the result\n+    \/\/ from (i.e. XORing it with) lo.  Because p has no nonzero high\n+    \/\/ bits we can do this with two 64-bit multiplications, lo*p and\n+    \/\/ hi*p.\n+\n+    __ pmull2(t0, __ T1Q, hi, p, __ T2D);\n+    __ ext(t1, __ T16B, t0, z, 8);\n+    __ eor(hi, __ T16B, hi, t1);\n+    __ ext(t1, __ T16B, z, t0, 8);\n+    __ eor(lo, __ T16B, lo, t1);\n+    __ pmull(t0, __ T1Q, hi, p, __ T1D);\n+    __ eor(result, __ T16B, lo, t0);\n+  }\n+\n@@ -4703,2 +4904,0 @@\n-    __ ldrq(v24, p);    \/\/ The field polynomial\n-\n@@ -4713,2 +4912,4 @@\n-    __ ext(v4, __ T16B, v1, v1, 0x08); \/\/ long-swap subkeyH into v1\n-    __ eor(v4, __ T16B, v4, v1);       \/\/ xor subkeyH into subkeyL (Karatsuba: (A1+A0))\n+    __ ldrq(v26, p);\n+\n+    __ ext(v16, __ T16B, v1, v1, 0x08); \/\/ long-swap subkeyH into v1\n+    __ eor(v16, __ T16B, v16, v1);      \/\/ xor subkeyH into subkeyL (Karatsuba: (A1+A0))\n@@ -4726,3 +4927,3 @@\n-      __ ghash_multiply(\/*result_lo*\/v5, \/*result_hi*\/v7,\n-                        \/*a*\/v1, \/*b*\/v2, \/*a1_xor_a0*\/v4,\n-                        \/*temps*\/v6, v3, \/*reuse\/clobber b*\/v2);\n+      ghash_multiply(\/*result_lo*\/v5, \/*result_hi*\/v7,\n+                     \/*a*\/v1, \/*b*\/v2, \/*a1_xor_a0*\/v16,\n+                     \/*temps*\/v6, v20, v18, v21);\n@@ -4730,1 +4931,1 @@\n-      __ ghash_reduce(\/*result*\/v0, \/*lo*\/v5, \/*hi*\/v7, \/*p*\/v24, vzr, \/*temp*\/v3);\n+      ghash_reduce(v0, v5, v7, v26, vzr, v20);\n@@ -4737,2 +4938,2 @@\n-    __ rev64(v0, __ T16B, v0);\n-    __ rbit(v0, __ T16B, v0);\n+    __ rev64(v1, __ T16B, v0);\n+    __ rbit(v1, __ T16B, v1);\n@@ -4740,1 +4941,1 @@\n-    __ st1(v0, __ T16B, state);\n+    __ st1(v1, __ T16B, state);\n@@ -6157,1 +6358,5 @@\n-      StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks_wide();\n+      if (UseAESGCMIntrinsics) {\n+        StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks_wide();\n+      } else {\n+        StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks();\n+      }\n@@ -6169,0 +6374,3 @@\n+    }\n+\n+    if (UseAESGCMIntrinsics) {\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":223,"deletions":15,"binary":false,"changes":238,"status":"modified"}]}