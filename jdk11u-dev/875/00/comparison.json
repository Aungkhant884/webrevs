{"files":[{"patch":"@@ -270,0 +270,2 @@\n+\n+ public:\n@@ -274,2 +276,0 @@\n- public:\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,3 @@\n-                                          Handle protection_domain, TRAPS) {\n+                                          Handle protection_domain,\n+                                          const ClassFileStream *cfs,\n+                                          TRAPS) {\n@@ -53,1 +55,0 @@\n-\n@@ -59,6 +60,5 @@\n-    JvmtiCachedClassFileData* archived_class_data = ik->get_archived_class_data();\n-    assert(archived_class_data != NULL, \"shared class has no archived class data\");\n-    unsigned char* ptr =\n-        VM_RedefineClasses::get_cached_class_file_bytes(archived_class_data);\n-    unsigned char* end_ptr =\n-        ptr + VM_RedefineClasses::get_cached_class_file_len(archived_class_data);\n+    if (cfs == NULL) {\n+      cfs = FileMapInfo::open_stream_for_jvmti(ik, CHECK_NULL);\n+    }\n+    unsigned char* ptr = (unsigned char*)cfs->buffer();\n+    unsigned char* end_ptr = ptr + cfs->length();\n@@ -78,16 +78,0 @@\n-      const char* pathname;\n-      if (path_index < 0) {\n-        \/\/ shared classes loaded by user defined class loader\n-        \/\/ do not have shared_classpath_index\n-        ModuleEntry* mod_entry = ik->module();\n-        if (mod_entry != NULL && (mod_entry->location() != NULL)) {\n-          ResourceMark rm;\n-          pathname = (const char*)(mod_entry->location()->as_C_string());\n-        } else {\n-          pathname = \"\";\n-        }\n-      } else {\n-        SharedClassPathEntry* ent =\n-          (SharedClassPathEntry*)FileMapInfo::shared_path(path_index);\n-        pathname = ent == NULL ? NULL : ent->name();\n-      }\n@@ -96,1 +80,1 @@\n-                                                    pathname,\n+                                                    cfs->source(),\n@@ -243,18 +227,0 @@\n-#if INCLUDE_JVMTI\n-    assert(cached_class_file == NULL, \"Sanity\");\n-    \/\/ Archive the class stream data into the optional data section\n-    JvmtiCachedClassFileData *p;\n-    int len;\n-    const unsigned char *bytes;\n-    \/\/ event based tracing might set cached_class_file\n-    if ((bytes = result->get_cached_class_file_bytes()) != NULL) {\n-      len = result->get_cached_class_file_len();\n-    } else {\n-      len = stream->length();\n-      bytes = stream->buffer();\n-    }\n-    p = (JvmtiCachedClassFileData*)os::malloc(offset_of(JvmtiCachedClassFileData, data) + len, mtInternal);\n-    p->length = len;\n-    memcpy(p->data, bytes, len);\n-    result->set_archived_class_data(p);\n-#endif \/\/ INCLUDE_JVMTI\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.cpp","additions":10,"deletions":44,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -83,1 +83,3 @@\n-                                          Handle protection_domain, TRAPS);\n+                                          Handle protection_domain,\n+                                          const ClassFileStream *cfs,\n+                                          TRAPS);\n","filename":"src\/hotspot\/share\/classfile\/klassFactory.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1174,1 +1174,1 @@\n-    return load_shared_class(ik, class_loader, protection_domain, THREAD);\n+    return load_shared_class(ik, class_loader, protection_domain, NULL, THREAD);\n@@ -1274,1 +1274,3 @@\n-                                                   Handle protection_domain, TRAPS) {\n+                                                   Handle protection_domain,\n+                                                   const ClassFileStream *cfs,\n+                                                   TRAPS) {\n@@ -1321,1 +1323,1 @@\n-        ik, class_name, class_loader, protection_domain, CHECK_NULL);\n+        ik, class_name, class_loader, protection_domain, cfs, CHECK_NULL);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -658,0 +658,1 @@\n+                                          const ClassFileStream *cfs,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -544,1 +544,1 @@\n-      return load_shared_class(ik, class_loader, protection_domain, THREAD);\n+      return load_shared_class(ik, class_loader, protection_domain, NULL, THREAD);\n@@ -624,1 +624,2 @@\n-                                          protection_domain, THREAD);\n+                                          protection_domain, cfs,\n+                                          THREAD);\n@@ -631,0 +632,1 @@\n+                   const ClassFileStream *cfs,\n@@ -651,1 +653,2 @@\n-  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain, THREAD);\n+  InstanceKlass* shared_klass = load_shared_class(ik, class_loader, protection_domain,\n+                                                  cfs, THREAD);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -284,0 +284,1 @@\n+                                 const ClassFileStream* cfs,\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -501,0 +502,10 @@\n+\n+#if INCLUDE_JVMTI\n+  if (_classpath_entries_for_jvmti != NULL) {\n+    os::free(_classpath_entries_for_jvmti);\n+  }\n+  size_t sz = sizeof(ClassPathEntry*) *  _shared_path_table_size;\n+  _classpath_entries_for_jvmti = (ClassPathEntry**)os::malloc(sz, mtClass);\n+  memset(_classpath_entries_for_jvmti, 0, sz);\n+#endif\n+\n@@ -1439,0 +1450,54 @@\n+\n+#if INCLUDE_JVMTI\n+ClassPathEntry** FileMapInfo::_classpath_entries_for_jvmti = NULL;\n+\n+ClassPathEntry* FileMapInfo::get_classpath_entry_for_jvmti(int i, TRAPS) {\n+  ClassPathEntry* ent = _classpath_entries_for_jvmti[i];\n+  if (ent == NULL) {\n+    if (i == 0) {\n+      ent = ClassLoader:: get_jrt_entry();\n+      assert(ent != NULL, \"must be\");\n+    } else {\n+      SharedClassPathEntry* scpe = shared_path(i);\n+      assert(scpe->is_jar(), \"must be\"); \/\/ other types of scpe will not produce archived classes\n+\n+      const char* path = scpe->name();\n+      struct stat st;\n+      if (os::stat(path, &st) != 0) {\n+        char *msg = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(path) + 128); ;\n+        jio_snprintf(msg, strlen(path) + 127, \"error in opening JAR file %s\", path);\n+        THROW_MSG_(vmSymbols::java_io_IOException(), msg, NULL);\n+      } else {\n+        ent = ClassLoader::create_class_path_entry(path, &st, \/*throw_exception=*\/true, false, CHECK_NULL);\n+      }\n+    }\n+\n+    MutexLocker mu(CDSClassFileStream_lock, THREAD);\n+    if (_classpath_entries_for_jvmti[i] == NULL) {\n+      _classpath_entries_for_jvmti[i] = ent;\n+    } else {\n+      \/\/ Another thread has beat me to creating this entry\n+      delete ent;\n+      ent = _classpath_entries_for_jvmti[i];\n+    }\n+  }\n+\n+  return ent;\n+}\n+\n+ClassFileStream* FileMapInfo::open_stream_for_jvmti(InstanceKlass* ik, TRAPS) {\n+  int path_index = ik->shared_classpath_index();\n+  assert(path_index >= 0, \"should be called for shared built-in classes only\");\n+  assert(path_index < (int)_shared_path_table_size, \"sanity\");\n+\n+  ClassPathEntry* cpe = get_classpath_entry_for_jvmti(path_index, CHECK_NULL);\n+  assert(cpe != NULL, \"must be\");\n+\n+  Symbol* name = ik->name();\n+  const char* const class_name = name->as_C_string();\n+  const char* const file_name = ClassLoader::file_name_for_class_name(class_name,\n+                                                                      name->utf8_length());\n+  return cpe->open_stream(file_name, THREAD);\n+}\n+\n+#endif\n","filename":"src\/hotspot\/share\/memory\/filemap.cpp","additions":66,"deletions":1,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -302,0 +302,4 @@\n+#if INCLUDE_JVMTI\n+  static ClassFileStream* open_stream_for_jvmti(InstanceKlass* ik, TRAPS);\n+#endif\n+\n@@ -348,0 +352,5 @@\n+\n+#if INCLUDE_JVMTI\n+  static ClassPathEntry** _classpath_entries_for_jvmti;\n+  static ClassPathEntry* get_classpath_entry_for_jvmti(int i, TRAPS);\n+#endif\n","filename":"src\/hotspot\/share\/memory\/filemap.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -201,1 +201,1 @@\n-DumpRegion _mc_region(\"mc\"), _ro_region(\"ro\"), _rw_region(\"rw\"), _md_region(\"md\"), _od_region(\"od\");\n+DumpRegion _mc_region(\"mc\"), _ro_region(\"ro\"), _rw_region(\"rw\"), _md_region(\"md\");\n@@ -566,19 +566,0 @@\n-#if INCLUDE_JVMTI\n-static void relocate_cached_class_file() {\n-  for (int i = 0; i < _global_klass_objects->length(); i++) {\n-    Klass* k = _global_klass_objects->at(i);\n-    if (k->is_instance_klass()) {\n-      InstanceKlass* ik = InstanceKlass::cast(k);\n-      JvmtiCachedClassFileData* p = ik->get_archived_class_data();\n-      if (p != NULL) {\n-        int size = offset_of(JvmtiCachedClassFileData, data) + p->length;\n-        JvmtiCachedClassFileData* q = (JvmtiCachedClassFileData*)_od_region.allocate(size);\n-        q->length = p->length;\n-        memcpy(q->data, p->data, p->length);\n-        ik->set_archived_class_data(q);\n-      }\n-    }\n-  }\n-}\n-#endif \/\/ INCLUDE_JVMTI\n-\n@@ -1442,5 +1423,1 @@\n-  _md_region.pack(&_od_region);\n-\n-  \/\/ Relocate the archived class file data into the od region\n-  JVMTI_ONLY(relocate_cached_class_file();)\n-  _od_region.pack();\n+  _md_region.pack();\n@@ -1448,1 +1425,1 @@\n-  \/\/ The 5 core spaces are allocated consecutively mc->rw->ro->md->od, so there total size\n+  \/\/ The 4 core spaces are allocated consecutively mc->rw->ro->md->od, so there total size\n@@ -1450,1 +1427,1 @@\n-  size_t core_spaces_size = _od_region.end() - _mc_region.base();\n+  size_t core_spaces_size = _md_region.end() - _mc_region.base();\n@@ -1491,1 +1468,0 @@\n-    write_region(mapinfo, MetaspaceShared::od, &_od_region, \/*read_only=*\/true, \/*allow_exec=*\/false);\n@@ -1530,1 +1506,0 @@\n-                                _od_region.reserved()  +\n@@ -1535,1 +1510,0 @@\n-                             _od_region.used()  +\n@@ -1544,1 +1518,0 @@\n-  _od_region.print(total_reserved);\n@@ -2084,1 +2057,0 @@\n-  char* od_base = NULL; char* od_top;\n@@ -2091,1 +2063,0 @@\n-      (od_base = mapinfo->map_region(od, &od_top)) != NULL &&\n@@ -2098,1 +2069,1 @@\n-    \/\/ We require that mc->rw->ro->md->od to be laid out consecutively, with no\n+    \/\/ We require that mc->rw->ro->md to be laid out consecutively, with no\n@@ -2102,2 +2073,2 @@\n-    assert(mc_base < ro_base && mc_base < rw_base && mc_base < md_base && mc_base < od_base, \"must be\");\n-    assert(od_top  > ro_top  && od_top  > rw_top  && od_top  > md_top  && od_top  > mc_top , \"must be\");\n+    assert(mc_base < ro_base && mc_base < rw_base && mc_base < md_base, \"must be\");\n+    assert(md_top  > ro_top  && md_top  > rw_top  && md_top  > mc_top , \"must be\");\n@@ -2107,1 +2078,0 @@\n-    assert(md_top == od_base, \"must be\");\n@@ -2109,1 +2079,1 @@\n-    MetaspaceObj::set_shared_metaspace_range((void*)mc_base, (void*)od_top);\n+    MetaspaceObj::set_shared_metaspace_range((void*)mc_base, (void*)md_top);\n@@ -2118,1 +2088,0 @@\n-    if (od_base != NULL) mapinfo->unmap_region(od);\n@@ -2218,1 +2187,0 @@\n-  _od_region.print_out_of_space_msg(name, needed_bytes);\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.cpp","additions":8,"deletions":40,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -74,4 +74,1 @@\n-    \/\/ optional mapped spaces\n-    \/\/ Currently it only contains class file data.\n-    od = num_core_spaces,\n-    num_non_heap_spaces = od + 1,\n+    num_non_heap_spaces = 4,\n@@ -80,1 +77,1 @@\n-    first_string = od + 1, \/\/ index of first string region\n+    first_string = md + 1, \/\/ index of first string region\n","filename":"src\/hotspot\/share\/memory\/metaspaceShared.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2324,0 +2324,1 @@\n+  _cached_class_file = NULL;\n@@ -2475,1 +2476,1 @@\n-  if (_cached_class_file != NULL && !MetaspaceShared::is_in_shared_metaspace(_cached_class_file)) {\n+  if (_cached_class_file != NULL) {\n@@ -4007,6 +4008,1 @@\n-  if (MetaspaceShared::is_in_shared_metaspace(_cached_class_file)) {\n-    \/\/ Ignore the archived class stream data\n-    return NULL;\n-  } else {\n-    return _cached_class_file;\n-  }\n+  return _cached_class_file;\n@@ -4022,15 +4018,0 @@\n-\n-#if INCLUDE_CDS\n-JvmtiCachedClassFileData* InstanceKlass::get_archived_class_data() {\n-  if (DumpSharedSpaces) {\n-    return _cached_class_file;\n-  } else {\n-    assert(this->is_shared(), \"class should be shared\");\n-    if (MetaspaceShared::is_in_shared_metaspace(_cached_class_file)) {\n-      return _cached_class_file;\n-    } else {\n-      return NULL;\n-    }\n-  }\n-}\n-#endif\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":3,"deletions":22,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -866,8 +866,0 @@\n-\n-#if INCLUDE_CDS\n-  void set_archived_class_data(JvmtiCachedClassFileData* data) {\n-    _cached_class_file = data;\n-  }\n-\n-  JvmtiCachedClassFileData * get_archived_class_data();\n-#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -144,0 +144,3 @@\n+#if INCLUDE_CDS && INCLUDE_JVMTI\n+Mutex*   CDSClassFileStream_lock      = NULL;\n+#endif\n@@ -346,0 +349,3 @@\n+#if INCLUDE_CDS && INCLUDE_JVMTI\n+  def(CDSClassFileStream_lock      , PaddedMutex  , max_nonleaf, false, Monitor::_safepoint_check_always);\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+#if INCLUDE_CDS && INCLUDE_JVMTI\n+extern Mutex*   CDSClassFileStream_lock;         \/\/ FileMapInfo::open_stream_for_jvmti\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,2 +105,2 @@\n-        if (checked.size() != 5) {\n-          throw new RuntimeException(\"Must have 5 consecutive, fully utilized regions\");\n+        if (checked.size() != 4) {\n+          throw new RuntimeException(\"Must have 4 consecutive, fully utilized regions\");\n","filename":"test\/hotspot\/jtreg\/runtime\/SharedArchiveFile\/SpaceUtilizationCheck.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}