{"files":[{"patch":"@@ -675,0 +675,10 @@\n+###############################################################################\n+# Evaluates platform specific overrides for build devkit variables.\n+# $1: Name of variable\n+AC_DEFUN([BASIC_EVAL_BUILD_DEVKIT_VARIABLE],\n+[\n+  if test \"x[$]$1\" = x; then\n+    eval $1=\"\\${$1_${OPENJDK_BUILD_CPU}}\"\n+  fi\n+])\n+\n","filename":"make\/autoconf\/basics.m4","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -384,1 +384,0 @@\n-    AC_MSG_CHECKING([if fixpath can be created])\n@@ -386,1 +385,0 @@\n-    FIXPATH_BIN=\"$CONFIGURESUPPORT_OUTPUTDIR\/bin\/fixpath.exe\"\n@@ -388,0 +386,36 @@\n+\n+    if test \"x$OPENJDK_TARGET_CPU\" != \"xaarch64\"; then\n+      AC_MSG_CHECKING([if fixpath can be created])\n+\n+      FIXPATH_BIN=\"$CONFIGURESUPPORT_OUTPUTDIR\/bin\/fixpath.exe\"\n+      FIXPATH_SRC_W=\"$FIXPATH_SRC\"\n+      FIXPATH_BIN_W=\"$FIXPATH_BIN\"\n+      BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([FIXPATH_SRC_W])\n+      BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([FIXPATH_BIN_W])\n+      $RM -rf $FIXPATH_BIN $FIXPATH_DIR\n+      $MKDIR -p $FIXPATH_DIR $CONFIGURESUPPORT_OUTPUTDIR\/bin\n+      cd $FIXPATH_DIR\n+      $CC $FIXPATH_SRC_W -Fe$FIXPATH_BIN_W > $FIXPATH_DIR\/fixpath1.log 2>&1\n+      cd $CURDIR\n+\n+      if test ! -x $FIXPATH_BIN; then\n+        AC_MSG_RESULT([no])\n+        cat $FIXPATH_DIR\/fixpath1.log\n+        AC_MSG_ERROR([Could not create $FIXPATH_BIN])\n+      fi\n+      AC_MSG_RESULT([yes])\n+\n+    else # OPENJDK_TARGET_CPU is aarch64\n+      AC_MSG_CHECKING([if fixpath is in place])\n+\n+      FIXPATH_BIN=\"$TOPDIR\/fixpath.exe\"\n+      $RM -rf $FIXPATH_DIR\n+      $MKDIR -p $FIXPATH_DIR\n+\n+      if test ! -x $FIXPATH_BIN; then\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([Could not find fixpath.exe under $TOPDIR])\n+      fi\n+      AC_MSG_RESULT([yes])\n+    fi\n+\n@@ -399,9 +433,0 @@\n-    FIXPATH_SRC_W=\"$FIXPATH_SRC\"\n-    FIXPATH_BIN_W=\"$FIXPATH_BIN\"\n-    BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([FIXPATH_SRC_W])\n-    BASIC_WINDOWS_REWRITE_AS_WINDOWS_MIXED_PATH([FIXPATH_BIN_W])\n-    $RM -rf $FIXPATH_BIN $FIXPATH_DIR\n-    $MKDIR -p $FIXPATH_DIR $CONFIGURESUPPORT_OUTPUTDIR\/bin\n-    cd $FIXPATH_DIR\n-    $CC $FIXPATH_SRC_W -Fe$FIXPATH_BIN_W > $FIXPATH_DIR\/fixpath1.log 2>&1\n-    cd $CURDIR\n@@ -409,6 +434,0 @@\n-    if test ! -x $FIXPATH_BIN; then\n-      AC_MSG_RESULT([no])\n-      cat $FIXPATH_DIR\/fixpath1.log\n-      AC_MSG_ERROR([Could not create $FIXPATH_BIN])\n-    fi\n-    AC_MSG_RESULT([yes])\n","filename":"make\/autoconf\/basics_windows.m4","additions":36,"deletions":17,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -698,1 +698,3 @@\n-    if test \"x$FLAGS_CPU\" = xx86_64; then\n+    if test \"x$FLAGS_CPU\" = xaarch64; then\n+      $1_DEFINES_CPU_JDK=\"${$1_DEFINES_CPU_JDK} -D_ARM64_ -Darm64\"\n+    elif test \"x$FLAGS_CPU\" = xx86_64; then\n","filename":"make\/autoconf\/flags-cflags.m4","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -188,1 +188,1 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+ elif test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n@@ -194,0 +194,2 @@\n+    elif test \"x${OPENJDK_$1_CPU}\" = \"xaarch64\"; then\n+      $1_CPU_EXECUTABLE_LDFLAGS=\"-stack:1048576\"\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\" ; then\n@@ -243,1 +243,1 @@\n-        AC_MSG_ERROR([AOT is currently only supported on x86_64 and aarch64. Remove --enable-aot.])\n+        AC_MSG_ERROR([AOT is currently only supported on x86_64 and linux-aarch64. Remove --enable-aot.])\n@@ -358,1 +358,1 @@\n-    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xx86\" || test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xx86\" || test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\" ; then\n@@ -415,1 +415,1 @@\n-       test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+       test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\" ; then\n","filename":"make\/autoconf\/hotspot.m4","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -921,1 +921,1 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_NAME])\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_NAME])\n@@ -923,1 +923,1 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_EXTRA_PATH])\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_EXTRA_PATH])\n@@ -925,1 +925,1 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_TOOLCHAIN_PATH])\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_TOOLCHAIN_PATH])\n@@ -927,2 +927,6 @@\n-          BASIC_EVAL_DEVKIT_VARIABLE([BUILD_DEVKIT_SYSROOT])\n-          # Skip the Window specific parts\n+          BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_SYSROOT])\n+\n+          if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+            BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_VS_INCLUDE])\n+            BASIC_EVAL_BUILD_DEVKIT_VARIABLE([BUILD_DEVKIT_VS_LIB])\n+          fi\n@@ -938,1 +942,1 @@\n-        BUILD_SYSROOT=\"$BUILD_DEVKIT_SYSROOT\"\n+        PATH=\"$BUILD_DEVKIT_EXTRA_PATH:$PATH\"\n@@ -940,1 +944,1 @@\n-         # Fallback default of just \/bin if DEVKIT_PATH is not defined\n+        # Fallback default of just \/bin if DEVKIT_PATH is not defined\n@@ -944,1 +948,10 @@\n-        PATH=\"$BUILD_DEVKIT_TOOLCHAIN_PATH:$BUILD_DEVKIT_EXTRA_PATH\"\n+        PATH=\"$BUILD_DEVKIT_TOOLCHAIN_PATH:$PATH\"\n+\n+        BUILD_SYSROOT=\"$BUILD_DEVKIT_SYSROOT\"\n+\n+        if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+          BUILD_VS_INCLUDE=\"$BUILD_DEVKIT_VS_INCLUDE\"\n+          BUILD_VS_LIB=\"$BUILD_DEVKIT_VS_LIB\"\n+\n+          TOOLCHAIN_SETUP_VISUAL_STUDIO_SYSROOT_FLAGS([BUILD_])\n+        fi\n@@ -970,3 +983,31 @@\n-    # Just like for the target compiler, use the compiler as linker\n-    BUILD_LD=\"$BUILD_CC\"\n-    BUILD_LDCXX=\"$BUILD_CXX\"\n+    if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+      # In the Microsoft toolchain we have a separate LD command \"link\".\n+      # Make sure we reject \/usr\/bin\/link (as determined in CYGWIN_LINK), which is\n+      # a cygwin program for something completely different.\n+      AC_CHECK_PROG([BUILD_LD], [link$EXE_SUFFIX],[link$EXE_SUFFIX],,, [$CYGWIN_LINK])\n+      BASIC_FIXUP_EXECUTABLE(BUILD_LD)\n+      # Verify that we indeed succeeded with this trick.\n+      AC_MSG_CHECKING([if the found link.exe is actually the Visual Studio linker])\n+\n+      # Reset PATH since it can contain a mix of WSL\/linux paths and Windows paths from VS,\n+      # which, in combination with WSLENV, will make the WSL layer complain\n+      old_path=\"$PATH\"\n+      PATH=\n+\n+      \"$BUILD_LD\" --version > \/dev\/null\n+\n+      if test $? -eq 0 ; then\n+        AC_MSG_RESULT([no])\n+        AC_MSG_ERROR([This is the Cygwin link tool. Please check your PATH and rerun configure.])\n+      else\n+        AC_MSG_RESULT([yes])\n+      fi\n+\n+      PATH=\"$old_path\"\n+\n+      BUILD_LDCXX=\"$BUILD_LD\"\n+    else\n+      # Just like for the target compiler, use the compiler as linker\n+      BUILD_LD=\"$BUILD_CC\"\n+      BUILD_LDCXX=\"$BUILD_CXX\"\n+    fi\n@@ -1028,0 +1069,4 @@\n+    elif test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+      if test \"x$COMPILER_CPU_TEST\" != \"xARM64\"; then\n+        AC_MSG_ERROR([Target CPU mismatch. We are building for $OPENJDK_TARGET_CPU but CL is for \"$COMPILER_CPU_TEST\"; expected \"arm64\".])\n+      fi\n","filename":"make\/autoconf\/toolchain.m4","additions":56,"deletions":11,"binary":false,"changes":67,"status":"modified"},{"patch":"@@ -129,1 +129,1 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -131,1 +131,1 @@\n-      else\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -134,0 +134,4 @@\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+        # for host x86-64, target aarch64\n+        VCVARSFILES=\"vc\/auxiliary\/build\/vcvarsamd64_arm64.bat \\\n+            vc\/auxiliary\/build\/vcvarsx86_arm64.bat\"\n@@ -173,1 +177,1 @@\n-        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+        if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -175,1 +179,1 @@\n-        else\n+        elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -177,0 +181,2 @@\n+        elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+          VS_ENV_ARGS=\"\/arm64\"\n@@ -492,35 +498,1 @@\n-      # Convert VS_INCLUDE into SYSROOT_CFLAGS\n-      OLDIFS=\"$IFS\"\n-      IFS=\";\"\n-      for i in $VS_INCLUDE; do\n-        ipath=$i\n-        # Only process non-empty elements\n-        if test \"x$ipath\" != x; then\n-          IFS=\"$OLDIFS\"\n-          # Check that directory exists before calling fixup_path\n-          testpath=$ipath\n-          BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([testpath])\n-          if test -d \"$testpath\"; then\n-            BASIC_FIXUP_PATH([ipath])\n-            SYSROOT_CFLAGS=\"$SYSROOT_CFLAGS -I$ipath\"\n-          fi\n-          IFS=\";\"\n-        fi\n-      done\n-      # Convert VS_LIB into SYSROOT_LDFLAGS\n-      for i in $VS_LIB; do\n-        libpath=$i\n-        # Only process non-empty elements\n-        if test \"x$libpath\" != x; then\n-          IFS=\"$OLDIFS\"\n-          # Check that directory exists before calling fixup_path\n-          testpath=$libpath\n-          BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([testpath])\n-          if test -d \"$testpath\"; then\n-            BASIC_FIXUP_PATH([libpath])\n-            SYSROOT_LDFLAGS=\"$SYSROOT_LDFLAGS -libpath:$libpath\"\n-          fi\n-          IFS=\";\"\n-        fi\n-      done\n-      IFS=\"$OLDIFS\"\n+      TOOLCHAIN_SETUP_VISUAL_STUDIO_SYSROOT_FLAGS\n@@ -563,1 +535,1 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x32; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -565,1 +537,1 @@\n-      else\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n@@ -567,0 +539,5 @@\n+      elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+        # The cygwin 'file' command only returns \"PE32+ executable (DLL) (console), for MS Windows\",\n+        # without specifying which architecture it is for specifically. This has been fixed upstream.\n+        # https:\/\/github.com\/file\/file\/commit\/b849b1af098ddd530094bf779b58431395db2e10#diff-ff2eced09e6860de75057dd731d092aeR142\n+        CORRECT_MSVCR_ARCH=\"PE32+ executable\"\n@@ -586,0 +563,8 @@\n+  if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n+    vs_target_cpu=x86\n+  elif test \"x$OPENJDK_TARGET_CPU\" = xx86_64; then\n+    vs_target_cpu=x64\n+  elif test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+    vs_target_cpu=arm64\n+  fi\n+\n@@ -592,5 +577,1 @@\n-        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n-          POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/x64\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n-        else\n-          POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/x86\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n-        fi\n+        POSSIBLE_MSVC_DLL=\"$CYGWIN_VC_INSTALL_DIR\/redist\/$vs_target_cpu\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME\"\n@@ -601,5 +582,1 @@\n-        if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n-          POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_TOOLS_REDIST_DIR\/x64\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n-        else\n-          POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_TOOLS_REDIST_DIR\/x86\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n-        fi\n+        POSSIBLE_MSVC_DLL=\"`ls $CYGWIN_VC_TOOLS_REDIST_DIR\/$vs_target_cpu\/Microsoft.VC${VS_VERSION_INTERNAL}.CRT\/$DLL_NAME`\"\n@@ -637,7 +614,2 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n-        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n-\t    | $GREP -i \/x64\/ | $HEAD --lines 1`\n-      else\n-        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n-\t    | $GREP -i \/x86\/ | $HEAD --lines 1`\n-      fi\n+      POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VS_TOOLS_DIR\" -name $DLL_NAME \\\n+        | $GREP -i \/$vs_target_cpu\/ | $HEAD --lines 1`\n@@ -653,4 +625,1 @@\n-      if test \"x$OPENJDK_TARGET_CPU_BITS\" = x64; then\n-        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VC_INSTALL_DIR\" -name $DLL_NAME \\\n-\t    | $GREP x64 | $HEAD --lines 1`\n-      else\n+      if test \"x$OPENJDK_TARGET_CPU\" = xx86; then\n@@ -658,1 +627,1 @@\n-\t    | $GREP x86 | $GREP -v ia64 | $GREP -v x64 | $HEAD --lines 1`\n+        | $GREP x86 | $GREP -v ia64 | $GREP -v x64 | $GREP -v arm64 | $HEAD --lines 1`\n@@ -664,0 +633,3 @@\n+      else\n+        POSSIBLE_MSVC_DLL=`$FIND \"$CYGWIN_VC_INSTALL_DIR\" -name $DLL_NAME \\\n+          | $GREP $vs_target_cpu | $HEAD --lines 1`\n@@ -747,1 +719,3 @@\n-      if test \"x$dll_subdir\" = \"xx86_64\"; then\n+      if test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+        dll_subdir=\"arm64\"\n+      elif test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n@@ -749,0 +723,2 @@\n+      elif test \"x$OPENJDK_TARGET_CPU\" = \"xx86\"; then\n+        dll_subdir=\"x86\"\n@@ -771,0 +747,46 @@\n+\n+# Setup the sysroot flags and add them to global CFLAGS and LDFLAGS so\n+# that configure can use them while detecting compilers.\n+# TOOLCHAIN_TYPE is available here.\n+# Param 1 - Optional prefix to all variables. (e.g BUILD_)\n+AC_DEFUN([TOOLCHAIN_SETUP_VISUAL_STUDIO_SYSROOT_FLAGS],\n+[\n+  # Convert $1VS_INCLUDE into $1SYSROOT_CFLAGS\n+  OLDIFS=\"$IFS\"\n+  IFS=\";\"\n+  for i in [$]$1VS_INCLUDE; do\n+    ipath=$i\n+    # Only process non-empty elements\n+    if test \"x$ipath\" != x; then\n+      IFS=\"$OLDIFS\"\n+      # Check that directory exists before calling fixup_path\n+      testpath=$ipath\n+      BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([testpath])\n+      if test -d \"$testpath\"; then\n+        BASIC_FIXUP_PATH([ipath])\n+        $1SYSROOT_CFLAGS=\"[$]$1SYSROOT_CFLAGS -I$ipath\"\n+      fi\n+      IFS=\";\"\n+    fi\n+  done\n+  # Convert $1VS_LIB into $1SYSROOT_LDFLAGS\n+  for i in [$]$1VS_LIB; do\n+    libpath=$i\n+    # Only process non-empty elements\n+    if test \"x$libpath\" != x; then\n+      IFS=\"$OLDIFS\"\n+      # Check that directory exists before calling fixup_path\n+      testpath=$libpath\n+      BASIC_WINDOWS_REWRITE_AS_UNIX_PATH([testpath])\n+      if test -d \"$testpath\"; then\n+        BASIC_FIXUP_PATH([libpath])\n+        $1SYSROOT_LDFLAGS=\"[$]$1SYSROOT_LDFLAGS -libpath:$libpath\"\n+      fi\n+      IFS=\";\"\n+    fi\n+  done\n+  IFS=\"$OLDIFS\"\n+\n+  AC_SUBST($1SYSROOT_CFLAGS)\n+  AC_SUBST($1SYSROOT_LDFLAGS)\n+])\n","filename":"make\/autoconf\/toolchain_windows.m4","additions":86,"deletions":64,"binary":false,"changes":150,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/bin\/Hostx64\/arm64\" $DEVKIT_ROOT\/VC\/bin\/\n@@ -95,0 +96,1 @@\n+    cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/lib\/arm64\" $DEVKIT_ROOT\/VC\/lib\/\n@@ -99,0 +101,1 @@\n+    cp -r \"$VS_INSTALL_DIR\/${VC_SUBDIR}\/atlmfc\/lib\/arm64\" $DEVKIT_ROOT\/VC\/atlmfc\/lib\/\n@@ -105,0 +108,1 @@\n+    cp -r \"$VS_INSTALL_DIR\/$REDIST_SUBDIR\/arm64\" $DEVKIT_ROOT\/VC\/redist\/\n@@ -114,0 +118,2 @@\n+    cp $DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCR_DLL $DEVKIT_ROOT\/VC\/bin\/arm64\n+    cp $DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCP_DLL $DEVKIT_ROOT\/VC\/bin\/arm64\n@@ -131,0 +137,1 @@\n+    cp -r \"$SDK_INSTALL_DIR\/lib\/$SDK_FULL_VERSION\/um\/arm64\" $DEVKIT_ROOT\/$SDK_VERSION\/lib\/\n@@ -133,0 +140,1 @@\n+    cp -r \"$SDK_INSTALL_DIR\/lib\/$SDK_FULL_VERSION\/ucrt\/arm64\" $DEVKIT_ROOT\/$SDK_VERSION\/lib\/\n@@ -167,0 +175,7 @@\n+echo-info \"\"\n+echo-info \"DEVKIT_TOOLCHAIN_PATH_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/bin\/arm64:\\$DEVKIT_ROOT\/$SDK_VERSION\/bin\/x64:\\$DEVKIT_ROOT\/$SDK_VERSION\/bin\/x86\\\"\"\n+echo-info \"DEVKIT_VS_INCLUDE_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/include;\\$DEVKIT_ROOT\/VC\/atlmfc\/include;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/shared;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/ucrt;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/um;\\$DEVKIT_ROOT\/$SDK_VERSION\/include\/winrt\\\"\"\n+echo-info \"DEVKIT_VS_LIB_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/lib\/arm64;\\$DEVKIT_ROOT\/VC\/atlmfc\/lib\/arm64;\\$DEVKIT_ROOT\/$SDK_VERSION\/lib\/arm64\\\"\"\n+echo-info \"DEVKIT_MSVCR_DLL_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCR_DLL\\\"\"\n+echo-info \"DEVKIT_MSVCP_DLL_aarch64=\\\"\\$DEVKIT_ROOT\/VC\/redist\/arm64\/$MSVCP_DLL\\\"\"\n+echo-info \"DEVKIT_UCRT_DLL_DIR_aarch64=\\\"\\$DEVKIT_ROOT\/10\/Redist\/ucrt\/DLLs\/arm64\\\"\"\n","filename":"make\/devkit\/createWindowsDevkit2017.sh","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -66,0 +66,6 @@\n+\n+  ifeq ($(OPENJDK_TARGET_CPU),aarch64)\n+    # cl.exe does only recognize few file extensions as valid (ex: .c, .h, .cpp), so\n+    # make sure *.java.template files are recognized as valid input files\n+    CPP_FILEPREFIX = -Tc\n+  endif\n@@ -78,1 +84,1 @@\n-\t  $(CPP) $(CPP_FLAGS) $(SYSROOT_CFLAGS) $(CFLAGS_JDKLIB) $< \\\n+\t  $(CPP) $(CPP_FLAGS) $(SYSROOT_CFLAGS) $(CFLAGS_JDKLIB) $(CPP_FILEPREFIX) $< \\\n","filename":"make\/gensrc\/GensrcMisc.gmk","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -102,0 +102,7 @@\n+  else ifeq ($(OPENJDK_TARGET_OS), windows)\n+    ifeq ($(call isTargetCpuBits, 64), true)\n+      ADLCFLAGS += -D_WIN64=1\n+    endif\n+    ifeq ($(HOTSPOT_TARGET_CPU_ARCH), aarch64)\n+      ADLCFLAGS += -DR18_RESERVED=1\n+    endif\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1786,0 +1786,4 @@\n+\n+address Assembler::locate_next_instruction(address inst) {\n+  return inst + Assembler::instruction_size;\n+}\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,13 @@\n+#ifdef __GNUC__\n+\n+\/\/ __nop needs volatile so that compiler doesn't optimize it away\n+#define NOP() asm volatile (\"nop\");\n+\n+#elif defined(_MSC_VER)\n+\n+\/\/ Use MSVC instrinsic: https:\/\/docs.microsoft.com\/en-us\/cpp\/intrinsics\/arm64-intrinsics?view=vs-2019#I\n+#define NOP() __nop();\n+\n+#endif\n+\n+\n@@ -621,1 +634,1 @@\n-      asm volatile (\"nop\");\n+      NOP();\n@@ -653,0 +666,2 @@\n+  static address locate_next_instruction(address inst);\n+\n@@ -1521,0 +1536,5 @@\n+#ifdef _WIN64\n+\/\/ In MSVC, `mvn` is defined as a macro and it affects compilation\n+#undef mvn\n+#endif\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/assembler_aarch64.hpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"precompiled.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_FpuStackSim_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -29,14 +29,1 @@\n-\/\/ Interface for updating the instruction cache.  Whenever the VM\n-\/\/ modifies code, part of the processor instruction cache potentially\n-\/\/ has to be flushed.\n-\n-class ICache : public AbstractICache {\n- public:\n-  static void initialize();\n-  static void invalidate_word(address addr) {\n-    __clear_cache((char *)addr, (char *)(addr + 3));\n-  }\n-  static void invalidate_range(address start, int nbytes) {\n-    __clear_cache((char *)start, (char *)(start + nbytes));\n-  }\n-};\n+#include OS_CPU_HEADER(icache)\n","filename":"src\/hotspot\/cpu\/aarch64\/icache_aarch64.hpp","additions":1,"deletions":14,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -27,0 +27,3 @@\n+\n+#include \"precompiled.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -247,1 +250,4 @@\n-static void initLITables() __attribute__ ((constructor));\n+static void initLITables();\n+\/\/ Use an empty struct with a construtor as MSVC doesn't support `__attribute__ ((constructor))`\n+\/\/ See https:\/\/stackoverflow.com\/questions\/1113409\/attribute-constructor-equivalent-in-vc\n+static struct initLITables_t { initLITables_t(void) { initLITables(); } } _initLITables;\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-    unsigned long offset;\n+    uint64_t offset;\n@@ -1495,1 +1495,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\"PRIX64, (uint64_t)imm64);\n+    snprintf(buffer, sizeof(buffer), PTR64_FORMAT, imm64);\n@@ -1558,1 +1558,1 @@\n-    snprintf(buffer, sizeof(buffer), \"0x%\"PRIX64, imm64);\n+    snprintf(buffer, sizeof(buffer), PTR64_FORMAT, imm64);\n@@ -1671,1 +1671,1 @@\n-      snprintf(buffer, sizeof(buffer), \"0x%\"PRIX32, imm32);\n+      snprintf(buffer, sizeof(buffer), PTR32_FORMAT, imm32);\n@@ -4210,1 +4210,1 @@\n-    unsigned long off;\n+    uint64_t off;\n@@ -4808,1 +4808,1 @@\n-      DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n+      DIFF, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,\n@@ -4895,1 +4895,1 @@\n-    cbnz(rscratch2, DIFFERENCE);\n+    cbnz(rscratch2, DIFF);\n@@ -4921,1 +4921,1 @@\n-    b(DIFFERENCE);\n+    b(DIFF);\n@@ -4924,1 +4924,1 @@\n-    cbnz(rscratch2, DIFFERENCE);\n+    cbnz(rscratch2, DIFF);\n@@ -4948,1 +4948,1 @@\n-    bind(DIFFERENCE);\n+    bind(DIFF);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -188,0 +188,7 @@\n+\/\/ Microsoft's MSVC team thinks that the __FUNCSIG__ is approximately (sympathy for calling conventions) equivalent to __PRETTY_FUNCTION__\n+\/\/ Also, from Clang patch: \"It is very similar to GCC's PRETTY_FUNCTION, except it prints the calling convention.\"\n+\/\/ https:\/\/reviews.llvm.org\/D3311\n+\n+#ifdef _WIN64\n+#define call_Unimplemented() _call_Unimplemented((address)__FUNCSIG__)\n+#else\n@@ -189,0 +196,1 @@\n+#endif\n@@ -508,1 +516,1 @@\n-  void tbr(Condition cond, Register Rt, int bitpos, Label &dest, bool far = false) {\n+  void tbr(Condition cond, Register Rt, int bitpos, Label &dest, bool isfar = false) {\n@@ -511,1 +519,1 @@\n-    if (far)\n+    if (isfar)\n@@ -520,1 +528,1 @@\n-    if (far) {\n+    if (isfar) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"precompiled.hpp\"\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_ext_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"code\/nativeInst.hpp\"\n@@ -123,1 +124,3 @@\n-#ifdef _M_AMD64\n+#if defined(_M_ARM64)\n+  #define __CPU__ aarch64\n+#elif defined(_M_AMD64)\n@@ -129,0 +132,5 @@\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+PVOID  topLevelVectoredExceptionHandler = NULL;\n+LPTOP_LEVEL_EXCEPTION_FILTER previousUnhandledExceptionFilter = NULL;\n+#endif\n+\n@@ -147,0 +155,6 @@\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+    if (topLevelVectoredExceptionHandler != NULL) {\n+      RemoveVectoredExceptionHandler(topLevelVectoredExceptionHandler);\n+      topLevelVectoredExceptionHandler = NULL;\n+    }\n+#endif\n@@ -457,0 +471,6 @@\n+#ifdef USE_VECTORED_EXCEPTION_HANDLING\n+  \/\/ Any exception is caught by the Vectored Exception Handler, so VM can\n+  \/\/ generate error dump when an exception occurred in non-Java thread\n+  \/\/ (e.g. VM thread).\n+  thread->call_run();\n+#else\n@@ -466,0 +486,1 @@\n+#endif\n@@ -1429,1 +1450,2 @@\n-    {IMAGE_FILE_MACHINE_AMD64,     (char*)\"AMD 64\"}\n+    {IMAGE_FILE_MACHINE_AMD64,     (char*)\"AMD 64\"},\n+    {IMAGE_FILE_MACHINE_ARM64,     (char*)\"ARM 64\"}\n@@ -1431,1 +1453,3 @@\n-#if (defined _M_AMD64)\n+#if (defined _M_ARM64)\n+  static const uint16_t running_arch = IMAGE_FILE_MACHINE_ARM64;\n+#elif (defined _M_AMD64)\n@@ -1437,1 +1461,1 @@\n-         is defined :_M_AMD64 or _M_IX86\n+         is defined :_M_AMD64 or _M_IX86 or _M_ARM64\n@@ -1740,1 +1764,2 @@\n-  if (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) {\n+  if ((si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_AMD64) ||\n+      (si.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_ARM64)) {\n@@ -2152,0 +2177,2 @@\n+#elif defined(_M_ARM64)\n+  #define PC_NAME Pc\n@@ -2246,1 +2273,11 @@\n-#ifdef  _M_AMD64\n+#if defined(_M_ARM64)\n+  PCONTEXT ctx = exceptionInfo->ContextRecord;\n+  address pc = (address)ctx->Sp;\n+  assert(pc[0] == 0x83, \"not an sdiv opcode\"); \/\/Fixme did i get the right opcode?\n+  assert(ctx->X4 == min_jint, \"unexpected idiv exception\");\n+  \/\/ set correct result values and continue after idiv instruction\n+  ctx->Pc = (uint64_t)pc + 4;        \/\/ idiv reg, reg, reg  is 4 bytes\n+  ctx->X4 = (uint64_t)min_jint;      \/\/ result\n+  ctx->X5 = (uint64_t)0;             \/\/ remainder\n+  \/\/ Continue the execution\n+#elif defined(_M_AMD64)\n@@ -2277,0 +2314,1 @@\n+#if defined(_M_AMD64) || defined(_M_IX86)\n@@ -2322,0 +2360,1 @@\n+#endif\n@@ -2331,35 +2370,0 @@\n-bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,\n-        struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {\n-  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n-  address addr = (address) exceptionRecord->ExceptionInformation[1];\n-  if (Interpreter::contains(pc)) {\n-    *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n-    if (!fr->is_first_java_frame()) {\n-      \/\/ get_frame_at_stack_banging_point() is only called when we\n-      \/\/ have well defined stacks so java_sender() calls do not need\n-      \/\/ to assert safe_for_sender() first.\n-      *fr = fr->java_sender();\n-    }\n-  } else {\n-    \/\/ more complex code with compiled code\n-    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n-    CodeBlob* cb = CodeCache::find_blob(pc);\n-    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n-      \/\/ Not sure where the pc points to, fallback to default\n-      \/\/ stack overflow handling\n-      return false;\n-    } else {\n-      *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n-      \/\/ in compiled code, the stack banging is performed just after the return pc\n-      \/\/ has been pushed on the stack\n-      *fr = frame(fr->sp() + 1, fr->fp(), (address)*(fr->sp()));\n-      if (!fr->is_java_frame()) {\n-        \/\/ See java_sender() comment above.\n-        *fr = fr->java_sender();\n-      }\n-    }\n-  }\n-  assert(fr->is_java_frame(), \"Safety check\");\n-  return true;\n-}\n-\n@@ -2372,1 +2376,3 @@\n-#ifdef _M_AMD64\n+#if defined(_M_ARM64)\n+  address pc = (address) exceptionInfo->ContextRecord->Pc;\n+#elif defined(_M_AMD64)\n@@ -2455,0 +2461,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2457,0 +2464,1 @@\n+#endif\n@@ -2476,0 +2484,2 @@\n+\n+#if defined(_M_AMD64) || defined(_M_IX86)\n@@ -2480,0 +2490,1 @@\n+#endif\n@@ -2511,0 +2522,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2513,0 +2525,1 @@\n+#endif\n@@ -2568,0 +2581,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2570,0 +2584,1 @@\n+#endif\n@@ -2587,0 +2602,13 @@\n+#ifdef _M_ARM64\n+    if (in_java &&\n+        (exception_code == EXCEPTION_ILLEGAL_INSTRUCTION ||\n+         exception_code == EXCEPTION_ILLEGAL_INSTRUCTION_2)) {\n+      if (nativeInstruction_at(pc)->is_sigill_zombie_not_entrant()) {\n+        if (TraceTraps) {\n+          tty->print_cr(\"trap: zombie_not_entrant\");\n+        }\n+        return Handle_Exception(exceptionInfo, SharedRuntime::get_handle_wrong_method_stub());\n+      }\n+    }\n+#endif\n+\n@@ -2597,0 +2625,2 @@\n+\n+#if defined(_M_AMD64) || defined(_M_IX86)\n@@ -2601,0 +2631,1 @@\n+#endif\n@@ -2603,0 +2634,1 @@\n+#if !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -2607,0 +2639,29 @@\n+#endif\n+  return EXCEPTION_CONTINUE_SEARCH;\n+}\n+\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+LONG WINAPI topLevelVectoredExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n+  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n+#if defined(_M_ARM64)\n+  address pc = (address) exceptionInfo->ContextRecord->Pc;\n+#elif defined(_M_AMD64)\n+  address pc = (address) exceptionInfo->ContextRecord->Rip;\n+#else\n+  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+#endif\n+\n+  \/\/ Fast path for code part of the code cache\n+  if (CodeCache::low_bound() <= pc && pc < CodeCache::high_bound()) {\n+    return topLevelExceptionFilter(exceptionInfo);\n+  }\n+\n+  \/\/ Handle the case where we get an implicit exception in AOT generated\n+  \/\/ code.  AOT DLL's loaded are not registered for structured exceptions.\n+  \/\/ If the exception occurred in the codeCache or AOT code, pass control\n+  \/\/ to our normal exception handler.\n+  CodeBlob* cb = CodeCache::find_blob(pc);\n+  if (cb != NULL) {\n+    return topLevelExceptionFilter(exceptionInfo);\n+  }\n+\n@@ -2609,0 +2670,23 @@\n+#endif\n+\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+LONG WINAPI topLevelUnhandledExceptionFilter(struct _EXCEPTION_POINTERS* exceptionInfo) {\n+  if (InterceptOSException) goto exit;\n+  DWORD exception_code = exceptionInfo->ExceptionRecord->ExceptionCode;\n+#if defined(_M_ARM64)\n+  address pc = (address)exceptionInfo->ContextRecord->Pc;\n+#elif defined(_M_AMD64)\n+  address pc = (address) exceptionInfo->ContextRecord->Rip;\n+#else\n+  address pc = (address) exceptionInfo->ContextRecord->Eip;\n+#endif\n+  Thread* t = Thread::current_or_null_safe();\n+\n+  if (exception_code != EXCEPTION_BREAKPOINT) {\n+    report_error(t, exception_code, pc, exceptionInfo->ExceptionRecord,\n+                 exceptionInfo->ContextRecord);\n+  }\n+exit:\n+  return previousUnhandledExceptionFilter ? previousUnhandledExceptionFilter(exceptionInfo) : EXCEPTION_CONTINUE_SEARCH;\n+}\n+#endif\n@@ -3458,0 +3542,4 @@\n+#ifdef _M_ARM64\n+  \/\/ AArch64 has a maximum addressable space of 48-bits\n+  return (char*)((1ull << 48) - 1);\n+#else\n@@ -3459,0 +3547,1 @@\n+#endif\n@@ -4132,0 +4221,5 @@\n+#if defined(USE_VECTORED_EXCEPTION_HANDLING)\n+  topLevelVectoredExceptionHandler = AddVectoredExceptionHandler(1, topLevelVectoredExceptionFilter);\n+  previousUnhandledExceptionFilter = SetUnhandledExceptionFilter(topLevelUnhandledExceptionFilter);\n+#endif\n+\n@@ -5504,1 +5598,1 @@\n-#elif defined (AMD64)\n+#elif defined(AMD64) || defined(_M_ARM64)\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":137,"deletions":43,"binary":false,"changes":180,"status":"modified"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_LINUX_AARCH64_ICACHE_AARCH64_HPP\n+#define OS_CPU_LINUX_AARCH64_ICACHE_AARCH64_HPP\n+\n+\/\/ Interface for updating the instruction cache.  Whenever the VM\n+\/\/ modifies code, part of the processor instruction cache potentially\n+\/\/ has to be flushed.\n+\n+class ICache : public AbstractICache {\n+ public:\n+  static void initialize();\n+  static void invalidate_word(address addr) {\n+    __builtin___clear_cache((char *)addr, (char *)(addr + 4));\n+  }\n+  static void invalidate_range(address start, int nbytes) {\n+    __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_LINUX_AARCH64_ICACHE_AARCH64_HPP\n\\ No newline at end of file\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,26 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/\/ nothing required here\n+#include \"precompiled.hpp\"\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/assembler_windows_aarch64.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"added"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n+\n+#include <intrin.h>\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\n+\/\/ As per atomic.hpp all read-modify-write operations have to provide two-way\n+\/\/ barriers semantics. The memory_order parameter is ignored - we always provide\n+\/\/ the strongest\/most-conservative ordering\n+\/\/\n+\/\/ For AARCH64 we add explicit barriers in the stubs.\n+\n+template<size_t byte_size>\n+struct Atomic::PlatformAdd\n+  : Atomic::AddAndFetch<Atomic::PlatformAdd<byte_size> >\n+{\n+  template<typename I, typename D>\n+  D add_and_fetch(I add_value, D volatile* dest, atomic_memory_order order) const;\n+};\n+\n+\/\/ The Interlocked* APIs only take long and will not accept __int32. That is\n+\/\/ acceptable on Windows, since long is a 32-bits integer type.\n+\n+#define DEFINE_INTRINSIC_ADD(IntrinsicName, IntrinsicType)                \\\n+  template<>                                                              \\\n+  template<typename I, typename D>                                        \\\n+  inline D Atomic::PlatformAdd<sizeof(IntrinsicType)>::add_and_fetch(I add_value, \\\n+                                                                     D volatile* dest, \\\n+                                                                     atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(D));                    \\\n+    return PrimitiveConversions::cast<D>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(add_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_ADD(InterlockedAdd,   long)\n+DEFINE_INTRINSIC_ADD(InterlockedAdd64, __int64)\n+\n+#undef DEFINE_INTRINSIC_ADD\n+\n+#define DEFINE_INTRINSIC_XCHG(IntrinsicName, IntrinsicType)               \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T Atomic::PlatformXchg<sizeof(IntrinsicType)>::operator()(T exchange_value, \\\n+                                                                   T volatile* dest, \\\n+                                                                   atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange,   long)\n+DEFINE_INTRINSIC_XCHG(InterlockedExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_XCHG\n+\n+\/\/ Note: the order of the parameters is different between\n+\/\/ Atomic::PlatformCmpxchg<*>::operator() and the\n+\/\/ InterlockedCompareExchange* API.\n+\n+#define DEFINE_INTRINSIC_CMPXCHG(IntrinsicName, IntrinsicType)            \\\n+  template<>                                                              \\\n+  template<typename T>                                                    \\\n+  inline T Atomic::PlatformCmpxchg<sizeof(IntrinsicType)>::operator()(T exchange_value, \\\n+                                                                      T volatile* dest, \\\n+                                                                      T compare_value, \\\n+                                                                      atomic_memory_order order) const { \\\n+    STATIC_ASSERT(sizeof(IntrinsicType) == sizeof(T));                    \\\n+    return PrimitiveConversions::cast<T>(                                 \\\n+      IntrinsicName(reinterpret_cast<IntrinsicType volatile *>(dest),     \\\n+                    PrimitiveConversions::cast<IntrinsicType>(exchange_value), \\\n+                    PrimitiveConversions::cast<IntrinsicType>(compare_value))); \\\n+  }\n+\n+DEFINE_INTRINSIC_CMPXCHG(_InterlockedCompareExchange8, char) \/\/ Use the intrinsic as InterlockedCompareExchange8 does not exist\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange,   long)\n+DEFINE_INTRINSIC_CMPXCHG(InterlockedCompareExchange64, __int64)\n+\n+#undef DEFINE_INTRINSIC_CMPXCHG\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_ATOMIC_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/atomic_windows_aarch64.hpp","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_BYTES_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_BYTES_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include <stdlib.h>\n+\n+\/\/ Efficient swapping of data bytes from Java byte\n+\/\/ ordering to native byte ordering and vice versa.\n+inline u2   Bytes::swap_u2(u2 x) {\n+  return _byteswap_ushort(x);\n+}\n+\n+inline u4   Bytes::swap_u4(u4 x) {\n+  return _byteswap_ulong(x);\n+}\n+\n+inline u8 Bytes::swap_u8(u8 x) {\n+  return _byteswap_uint64(x);\n+}\n+\n+#pragma warning(default: 4035) \/\/ Enable warning 4035: no return value\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_BYTES_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/bytes_windows_aarch64.inline.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,158 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_COPY_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_COPY_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include <string.h>\n+\n+static void pd_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  (void)memmove(to, from, count * HeapWordSize);\n+}\n+\n+static void pd_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  switch (count) {\n+  case 8:  to[7] = from[7];\n+  case 7:  to[6] = from[6];\n+  case 6:  to[5] = from[5];\n+  case 5:  to[4] = from[4];\n+  case 4:  to[3] = from[3];\n+  case 3:  to[2] = from[2];\n+  case 2:  to[1] = from[1];\n+  case 1:  to[0] = from[0];\n+  case 0:  break;\n+  default:\n+    (void)memcpy(to, from, count * HeapWordSize);\n+    break;\n+  }\n+}\n+\n+static void pd_disjoint_words_atomic(const HeapWord* from, HeapWord* to, size_t count) {\n+  switch (count) {\n+  case 8:  to[7] = from[7];\n+  case 7:  to[6] = from[6];\n+  case 6:  to[5] = from[5];\n+  case 5:  to[4] = from[4];\n+  case 4:  to[3] = from[3];\n+  case 3:  to[2] = from[2];\n+  case 2:  to[1] = from[1];\n+  case 1:  to[0] = from[0];\n+  case 0:  break;\n+  default: while (count-- > 0) {\n+             *to++ = *from++;\n+           }\n+           break;\n+  }\n+}\n+\n+static void pd_aligned_conjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+ \/\/ pd_conjoint_words(from, to, count);\n+  (void)memmove(to, from, count * HeapWordSize);\n+}\n+\n+static void pd_aligned_disjoint_words(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_disjoint_words(from, to, count);\n+}\n+\n+static void pd_conjoint_bytes(const void* from, void* to, size_t count) {\n+  (void)memmove(to, from, count);\n+}\n+\n+static void pd_conjoint_bytes_atomic(const void* from, void* to, size_t count) {\n+  pd_conjoint_bytes(from, to, count);\n+}\n+\n+static void pd_conjoint_jshorts_atomic(const jshort* from, jshort* to, size_t count) {\n+  if (from > to) {\n+    while (count-- > 0) {\n+      \/\/ Copy forwards\n+      *to++ = *from++;\n+    }\n+  } else {\n+    from += count - 1;\n+    to   += count - 1;\n+    while (count-- > 0) {\n+      \/\/ Copy backwards\n+      *to-- = *from--;\n+    }\n+  }\n+}\n+\n+static void pd_conjoint_jints_atomic(const jint* from, jint* to, size_t count) {\n+  if (from > to) {\n+    while (count-- > 0) {\n+      \/\/ Copy forwards\n+      *to++ = *from++;\n+    }\n+  } else {\n+    from += count - 1;\n+    to   += count - 1;\n+    while (count-- > 0) {\n+      \/\/ Copy backwards\n+      *to-- = *from--;\n+    }\n+  }\n+}\n+\n+static void pd_conjoint_jlongs_atomic(const jlong* from, jlong* to, size_t count) {\n+  pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n+}\n+\n+static void pd_conjoint_oops_atomic(const oop* from, oop* to, size_t count) {\n+ if (from > to) {\n+    while (count-- > 0) {\n+      \/\/ Copy forwards\n+      *to++ = *from++;\n+    }\n+  } else {\n+    from += count - 1;\n+    to   += count - 1;\n+    while (count-- > 0) {\n+      \/\/ Copy backwards\n+      *to-- = *from--;\n+    }\n+  }\n+}\n+\n+static void pd_arrayof_conjoint_bytes(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_bytes_atomic(from, to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jshorts(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_jshorts_atomic((const jshort*)from, (jshort*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jints(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_jints_atomic((const jint*)from, (jint*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_jlongs(const HeapWord* from, HeapWord* to, size_t count) {\n+  pd_conjoint_jlongs_atomic((const jlong*)from, (jlong*)to, count);\n+}\n+\n+static void pd_arrayof_conjoint_oops(const HeapWord* from, HeapWord* to, size_t count) {\n+ pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_COPY_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/copy_windows_aarch64.inline.hpp","additions":158,"deletions":0,"binary":false,"changes":158,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_GLOBALS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_GLOBALS_WINDOWS_AARCH64_HPP\n+\n+\/\/ Sets the default values for platform dependent flags used by the runtime system.\n+\/\/ (see globals.hpp)\n+\n+define_pd_global(bool, DontYieldALot,            false);\n+\n+\/\/ Default stack size on Windows is determined by the executable (java.exe\n+\/\/ has a default value of 320K\/1MB [32bit\/64bit]). Depending on Windows version, changing\n+\/\/ ThreadStackSize to non-zero may have significant impact on memory usage.\n+\/\/ See comments in os_windows.cpp.\n+define_pd_global(intx, ThreadStackSize,          0); \/\/ 0 => use system default\n+define_pd_global(intx, VMThreadStackSize,        0);\n+\n+#ifdef ASSERT\n+define_pd_global(intx, CompilerThreadStackSize,  1024);\n+#else\n+define_pd_global(intx, CompilerThreadStackSize,  0);\n+#endif\n+\n+define_pd_global(uintx,JVMInvokeMethodSlack,     8192);\n+\n+\/\/ Used on 64 bit platforms for UseCompressedOops base address\n+define_pd_global(uintx,HeapBaseMinAddress,       2*G);\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_GLOBALS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/globals_windows_aarch64.hpp","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_ICACHE_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_ICACHE_AARCH64_HPP\n+\n+\/\/ Interface for updating the instruction cache.  Whenever the VM\n+\/\/ modifies code, part of the processor instruction cache potentially\n+\/\/ has to be flushed.\n+\n+class ICache : public AbstractICache {\n+ public:\n+  static void initialize();\n+  static void invalidate_word(address addr) {\n+    invalidate_range(addr, 4);\n+  }\n+  static void invalidate_range(address start, int nbytes) {\n+    FlushInstructionCache((HANDLE)GetCurrentProcess(), start, (SIZE_T)(nbytes));\n+  }\n+};\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_ICACHE_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/icache_windows_aarch64.hpp","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_ORDERACCESS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_ORDERACCESS_WINDOWS_AARCH64_HPP\n+\n+\/\/ Included in orderAccess.hpp header file.\n+#include <atomic>\n+using std::atomic_thread_fence;\n+#include <intrin.h>\n+#include \"vm_version_aarch64.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+\/\/ Implementation of class OrderAccess.\n+\n+inline void OrderAccess::loadload()   { acquire(); }\n+inline void OrderAccess::storestore() { release(); }\n+inline void OrderAccess::loadstore()  { acquire(); }\n+inline void OrderAccess::storeload()  { fence(); }\n+\n+#define READ_MEM_BARRIER atomic_thread_fence(std::memory_order_acquire);\n+#define WRITE_MEM_BARRIER atomic_thread_fence(std::memory_order_release);\n+#define FULL_MEM_BARRIER atomic_thread_fence(std::memory_order_seq_cst);\n+\n+inline void OrderAccess::acquire() {\n+  READ_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::release() {\n+  WRITE_MEM_BARRIER;\n+}\n+\n+inline void OrderAccess::fence() {\n+  FULL_MEM_BARRIER;\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_ORDERACCESS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/orderAccess_windows_aarch64.hpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -0,0 +1,312 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"jvm.h\"\n+#include \"asm\/macroAssembler.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/systemDictionary.hpp\"\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"code\/codeCache.hpp\"\n+#include \"code\/icBuffer.hpp\"\n+#include \"code\/vtableStubs.hpp\"\n+#include \"code\/nativeInst.hpp\"\n+#include \"interpreter\/interpreter.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"prims\/jniFastGetField.hpp\"\n+#include \"prims\/jvm_misc.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/java.hpp\"\n+#include \"runtime\/javaCalls.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/osThread.hpp\"\n+#include \"runtime\/sharedRuntime.hpp\"\n+#include \"runtime\/stubRoutines.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+#include \"runtime\/timer.hpp\"\n+#include \"unwind_windows_aarch64.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/events.hpp\"\n+#include \"utilities\/vmError.hpp\"\n+\n+\n+\/\/ put OS-includes here\n+# include <sys\/types.h>\n+# include <signal.h>\n+# include <errno.h>\n+# include <stdlib.h>\n+# include <stdio.h>\n+# include <intrin.h>\n+\n+void os::os_exception_wrapper(java_call_t f, JavaValue* value, const methodHandle& method, JavaCallArguments* args, Thread* thread) {\n+  f(value, method, args, thread);\n+}\n+\n+#pragma warning(disable: 4172)\n+\n+\/\/ Returns an estimate of the current stack pointer. Result must be guaranteed\n+\/\/ to point into the calling threads stack, and be no lower than the current\n+\/\/ stack pointer.\n+address os::current_stack_pointer() {\n+  int dummy;\n+  address sp = (address)&dummy;\n+  return sp;\n+}\n+\n+#pragma warning(default: 4172)\n+\n+ExtendedPC os::fetch_frame_from_context(const void* ucVoid,\n+                    intptr_t** ret_sp, intptr_t** ret_fp) {\n+  ExtendedPC  epc;\n+  CONTEXT* uc = (CONTEXT*)ucVoid;\n+\n+  if (uc != NULL) {\n+    epc = ExtendedPC((address)uc->Pc);\n+    if (ret_sp) *ret_sp = (intptr_t*)uc->Sp;\n+    if (ret_fp) *ret_fp = (intptr_t*)uc->Fp;\n+  } else {\n+    \/\/ construct empty ExtendedPC for return value checking\n+    epc = NULL;\n+    if (ret_sp) *ret_sp = (intptr_t *)NULL;\n+    if (ret_fp) *ret_fp = (intptr_t *)NULL;\n+  }\n+  return epc;\n+}\n+\n+frame os::fetch_frame_from_context(const void* ucVoid) {\n+  intptr_t* sp;\n+  intptr_t* fp;\n+  ExtendedPC epc = fetch_frame_from_context(ucVoid, &sp, &fp);\n+  return frame(sp, fp, epc.pc());\n+}\n+\n+bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,\n+        struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {\n+  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n+  address addr = (address) exceptionRecord->ExceptionInformation[1];\n+  if (Interpreter::contains(pc)) {\n+    *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n+    if (!fr->is_first_java_frame()) {\n+      \/\/ get_frame_at_stack_banging_point() is only called when we\n+      \/\/ have well defined stacks so java_sender() calls do not need\n+      \/\/ to assert safe_for_sender() first.\n+      *fr = fr->java_sender();\n+    }\n+  } else {\n+    \/\/ more complex code with compiled code\n+    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n+      \/\/ Not sure where the pc points to, fallback to default\n+      \/\/ stack overflow handling\n+      return false;\n+    } else {\n+      \/\/ In compiled code, the stack banging is performed before LR\n+      \/\/ has been saved in the frame.  LR is live, and SP and FP\n+      \/\/ belong to the caller.\n+      intptr_t* fp = (intptr_t*)exceptionInfo->ContextRecord->Fp;\n+      intptr_t* sp = (intptr_t*)exceptionInfo->ContextRecord->Sp;\n+      address pc = (address)(exceptionInfo->ContextRecord->Lr\n+                         - NativeInstruction::instruction_size);\n+      *fr = frame(sp, fp, pc);\n+      if (!fr->is_java_frame()) {\n+        assert(fr->safe_for_sender(thread), \"Safety check\");\n+        assert(!fr->is_first_frame(), \"Safety check\");\n+        *fr = fr->java_sender();\n+      }\n+    }\n+  }\n+  assert(fr->is_java_frame(), \"Safety check\");\n+  return true;\n+}\n+\n+\/\/ By default, gcc always saves frame pointer rfp on this stack. This\n+\/\/ may get turned off by -fomit-frame-pointer.\n+frame os::get_sender_for_C_frame(frame* fr) {\n+  return frame(fr->link(), fr->link(), fr->sender_pc());\n+}\n+\n+frame os::current_frame() {\n+  typedef intptr_t*      get_fp_func           ();\n+  get_fp_func* func = CAST_TO_FN_PTR(get_fp_func*,\n+                                     StubRoutines::aarch64::get_previous_fp_entry());\n+  if (func == NULL) return frame();\n+  intptr_t* fp = (*func)();\n+  if (fp == NULL) {\n+    return frame();\n+  }\n+\n+  frame myframe((intptr_t*)os::current_stack_pointer(),\n+                (intptr_t*)fp,\n+                CAST_FROM_FN_PTR(address, os::current_frame));\n+  if (os::is_first_C_frame(&myframe)) {\n+\n+    \/\/ stack is not walkable\n+    return frame();\n+  } else {\n+    return os::get_sender_for_C_frame(&myframe);\n+  }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ thread stack\n+\n+\/\/ Minimum usable stack sizes required to get to user code. Space for\n+\/\/ HotSpot guard pages is added later.\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\/\/ helper functions for fatal error handler\n+\n+void os::print_context(outputStream *st, const void *context) {\n+  if (context == NULL) return;\n+\n+  const CONTEXT* uc = (const CONTEXT*)context;\n+\n+  st->print_cr(\"Registers:\");\n+\n+  st->print(  \"X0 =\" INTPTR_FORMAT, uc->X0);\n+  st->print(\", X1 =\" INTPTR_FORMAT, uc->X1);\n+  st->print(\", X2 =\" INTPTR_FORMAT, uc->X2);\n+  st->print(\", X3 =\" INTPTR_FORMAT, uc->X3);\n+  st->cr();\n+  st->print(  \"X4 =\" INTPTR_FORMAT, uc->X4);\n+  st->print(\", X5 =\" INTPTR_FORMAT, uc->X5);\n+  st->print(\", X6 =\" INTPTR_FORMAT, uc->X6);\n+  st->print(\", X7 =\" INTPTR_FORMAT, uc->X7);\n+  st->cr();\n+  st->print(  \"X8 =\" INTPTR_FORMAT, uc->X8);\n+  st->print(\", X9 =\" INTPTR_FORMAT, uc->X9);\n+  st->print(\", X10=\" INTPTR_FORMAT, uc->X10);\n+  st->print(\", X11=\" INTPTR_FORMAT, uc->X11);\n+  st->cr();\n+  st->print(  \"X12=\" INTPTR_FORMAT, uc->X12);\n+  st->print(\", X13=\" INTPTR_FORMAT, uc->X13);\n+  st->print(\", X14=\" INTPTR_FORMAT, uc->X14);\n+  st->print(\", X15=\" INTPTR_FORMAT, uc->X15);\n+  st->cr();\n+  st->print(  \"X16=\" INTPTR_FORMAT, uc->X16);\n+  st->print(\", X17=\" INTPTR_FORMAT, uc->X17);\n+  st->print(\", X18=\" INTPTR_FORMAT, uc->X18);\n+  st->print(\", X19=\" INTPTR_FORMAT, uc->X19);\n+  st->cr();\n+  st->print(\", X20=\" INTPTR_FORMAT, uc->X20);\n+  st->print(\", X21=\" INTPTR_FORMAT, uc->X21);\n+  st->print(\", X22=\" INTPTR_FORMAT, uc->X22);\n+  st->print(\", X23=\" INTPTR_FORMAT, uc->X23);\n+  st->cr();\n+  st->print(\", X24=\" INTPTR_FORMAT, uc->X24);\n+  st->print(\", X25=\" INTPTR_FORMAT, uc->X25);\n+  st->print(\", X26=\" INTPTR_FORMAT, uc->X26);\n+  st->print(\", X27=\" INTPTR_FORMAT, uc->X27);\n+  st->print(\", X28=\" INTPTR_FORMAT, uc->X28);\n+  st->cr();\n+  st->cr();\n+\n+  intptr_t *sp = (intptr_t *)uc->Sp;\n+  st->print_cr(\"Top of Stack: (sp=\" PTR_FORMAT \")\", sp);\n+  print_hex_dump(st, (address)sp, (address)(sp + 32), sizeof(intptr_t));\n+  st->cr();\n+\n+  \/\/ Note: it may be unsafe to inspect memory near pc. For example, pc may\n+  \/\/ point to garbage if entry point in an nmethod is corrupted. Leave\n+  \/\/ this at the end, and hope for the best.\n+  address pc = (address)uc->Pc;\n+  st->print_cr(\"Instructions: (pc=\" PTR_FORMAT \")\", pc);\n+  print_hex_dump(st, pc - 32, pc + 32, sizeof(char));\n+  st->cr();\n+\n+}\n+\n+void os::print_register_info(outputStream *st, const void *context) {\n+ if (context == NULL) return;\n+\n+  const CONTEXT* uc = (const CONTEXT*)context;\n+\n+  st->print_cr(\"Register to memory mapping:\");\n+  st->cr();\n+  \/\/ this is only for the \"general purpose\" registers\n+  st->print(\" X0=\"); print_location(st, uc->X0);\n+  st->print(\" X1=\"); print_location(st, uc->X1);\n+  st->print(\" X2=\"); print_location(st, uc->X2);\n+  st->print(\" X3=\"); print_location(st, uc->X3);\n+  st->cr();\n+  st->print(\" X4=\"); print_location(st, uc->X4);\n+  st->print(\" X5=\"); print_location(st, uc->X5);\n+  st->print(\" X6=\"); print_location(st, uc->X6);\n+  st->print(\" X7=\"); print_location(st, uc->X7);\n+  st->cr();\n+  st->print(\" X8=\"); print_location(st, uc->X8);\n+  st->print(\" X9=\"); print_location(st, uc->X9);\n+  st->print(\"X10=\"); print_location(st, uc->X10);\n+  st->print(\"X11=\"); print_location(st, uc->X11);\n+  st->cr();\n+  st->print(\"X12=\"); print_location(st, uc->X12);\n+  st->print(\"X13=\"); print_location(st, uc->X13);\n+  st->print(\"X14=\"); print_location(st, uc->X14);\n+  st->print(\"X15=\"); print_location(st, uc->X15);\n+  st->cr();\n+  st->print(\"X16=\"); print_location(st, uc->X16);\n+  st->print(\"X17=\"); print_location(st, uc->X17);\n+  st->print(\"X18=\"); print_location(st, uc->X18);\n+  st->print(\"X19=\"); print_location(st, uc->X19);\n+  st->cr();\n+  st->print(\"X20=\"); print_location(st, uc->X20);\n+  st->print(\"X21=\"); print_location(st, uc->X21);\n+  st->print(\"X22=\"); print_location(st, uc->X22);\n+  st->print(\"X23=\"); print_location(st, uc->X23);\n+  st->cr();\n+  st->print(\"X24=\"); print_location(st, uc->X24);\n+  st->print(\"X25=\"); print_location(st, uc->X25);\n+  st->print(\"X26=\"); print_location(st, uc->X26);\n+  st->print(\"X27=\"); print_location(st, uc->X27);\n+  st->print(\"X28=\"); print_location(st, uc->X28);\n+\n+  st->cr();\n+}\n+\n+void os::setup_fpu() {\n+}\n+\n+bool os::supports_sse() {\n+  return true;\n+}\n+\n+#ifndef PRODUCT\n+void os::verify_stack_alignment() {\n+  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+}\n+#endif\n+\n+int os::extra_bang_size_in_bytes() {\n+  \/\/ AArch64 does not require the additional stack bang.\n+  return 0;\n+}\n+\n+extern \"C\" {\n+  int SpinPause() {\n+    return 0;\n+  }\n+};\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.cpp","additions":312,"deletions":0,"binary":false,"changes":312,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP\n+\n+  static void setup_fpu();\n+  static bool supports_sse();\n+\n+  static bool      register_code_area(char *low, char *high) {\n+    \/\/ Using Vectored Exception Handling\n+    return true;\n+  }\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.hpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,30 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/os.hpp\"\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_OS_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/os_windows_aarch64.inline.hpp","additions":30,"deletions":0,"binary":false,"changes":30,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+\n+inline address pauth_strip_pointer(address ptr) {\n+  \/\/ No PAC support in windows as of yet.\n+  return ptr;\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_PAUTH_WINDOWS_AARCH64_INLINE_HPP\n+\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/pauth_windows_aarch64.inline.hpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_PREFETCH_WINDOWS_AARCH64_INLINE_HPP\n+#define OS_CPU_WINDOWS_AARCH64_PREFETCH_WINDOWS_AARCH64_INLINE_HPP\n+\n+#include \"runtime\/prefetch.hpp\"\n+\n+\n+inline void Prefetch::read (void *loc, intx interval) {\n+}\n+\n+inline void Prefetch::write(void *loc, intx interval) {\n+}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_PREFETCH_WINDOWS_AARCH64_INLINE_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/prefetch_windows_aarch64.inline.hpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"memory\/metaspaceShared.hpp\"\n+#include \"runtime\/frame.inline.hpp\"\n+#include \"runtime\/thread.inline.hpp\"\n+\n+frame JavaThread::pd_last_frame() {\n+  assert(has_last_Java_frame(), \"must have last_Java_sp() when suspended\");\n+  vmassert(_anchor.last_Java_pc() != NULL, \"not walkable\");\n+  return frame(_anchor.last_Java_sp(), _anchor.last_Java_fp(), _anchor.last_Java_pc());\n+}\n+\n+\/\/ For Forte Analyzer AsyncGetCallTrace profiling support - thread is\n+\/\/ currently interrupted by SIGPROF\n+bool JavaThread::pd_get_top_frame_for_signal_handler(frame* fr_addr,\n+  void* ucontext, bool isInJava) {\n+\n+  assert(Thread::current() == this, \"caller must be current thread\");\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava) {\n+  return pd_get_top_frame(fr_addr, ucontext, isInJava);\n+}\n+\n+bool JavaThread::pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava) {\n+\n+  assert(this->is_Java_thread(), \"must be JavaThread\");\n+\n+  JavaThread* jt = (JavaThread *)this;\n+\n+  \/\/ If we have a last_Java_frame, then we should use it even if\n+  \/\/ isInJava == true.  It should be more reliable than CONTEXT info.\n+  if (jt->has_last_Java_frame() && jt->frame_anchor()->walkable()) {\n+    *fr_addr = jt->pd_last_frame();\n+    return true;\n+  }\n+\n+  \/\/ At this point, we don't have a last_Java_frame, so\n+  \/\/ we try to glean some information out of the CONTEXT\n+  \/\/ if we were running Java code when SIGPROF came in.\n+  if (isInJava) {\n+    frame ret_frame = os::fetch_frame_from_context(ucontext);\n+    if (ret_frame.pc() == NULL || ret_frame.sp() == NULL ) {\n+      \/\/ CONTEXT wasn't useful\n+      return false;\n+    }\n+\n+    if (MetaspaceShared::is_in_trampoline_frame(ret_frame.pc())) {\n+      \/\/ In the middle of a trampoline call. Bail out for safety.\n+      \/\/ This happens rarely so shouldn't affect profiling.\n+      return false;\n+    }\n+\n+    if (!ret_frame.safe_for_sender(jt)) {\n+#if COMPILER2_OR_JVMCI\n+      \/\/ C2 and JVMCI use ebp as a general register see if NULL fp helps\n+      frame ret_frame2(ret_frame.sp(), NULL, ret_frame.pc());\n+      if (!ret_frame2.safe_for_sender(jt)) {\n+        \/\/ nothing else to try if the frame isn't good\n+        return false;\n+      }\n+      ret_frame = ret_frame2;\n+#else\n+      \/\/ nothing else to try if the frame isn't good\n+      return false;\n+#endif \/\/ COMPILER2_OR_JVMCI\n+    }\n+    *fr_addr = ret_frame;\n+    return true;\n+  }\n+\n+  \/\/ nothing else to try\n+  return false;\n+}\n+\n+void JavaThread::cache_global_variables() { }\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.cpp","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n+\n+ private:\n+\n+#ifdef ASSERT\n+  \/\/ spill stack holds N callee-save registers at each Java call and\n+  \/\/ grows downwards towards limit\n+  \/\/ we need limit to check we have space for a spill and base so we\n+  \/\/ can identify all live spill frames at GC (eventually)\n+  address          _spill_stack;\n+  address          _spill_stack_base;\n+  address          _spill_stack_limit;\n+#endif \/\/ ASSERT\n+\n+  void pd_initialize() {\n+    _anchor.clear();\n+  }\n+\n+  frame pd_last_frame();\n+\n+ public:\n+  \/\/ Mutators are highly dangerous....\n+  intptr_t* last_Java_fp()                       { return _anchor.last_Java_fp(); }\n+  void  set_last_Java_fp(intptr_t* fp)           { _anchor.set_last_Java_fp(fp);   }\n+\n+  void set_base_of_stack_pointer(intptr_t* base_sp)  {}\n+\n+  static ByteSize last_Java_fp_offset()          {\n+    return byte_offset_of(JavaThread, _anchor) + JavaFrameAnchor::last_Java_fp_offset();\n+  }\n+\n+  intptr_t* base_of_stack_pointer()              { return NULL; }\n+  void record_base_of_stack_pointer()            {}\n+\n+  bool pd_get_top_frame_for_signal_handler(frame* fr_addr, void* ucontext,\n+    bool isInJava);\n+\n+  bool pd_get_top_frame_for_profiling(frame* fr_addr, void* ucontext, bool isInJava);\n+private:\n+  bool pd_get_top_frame(frame* fr_addr, void* ucontext, bool isInJava);\n+public:\n+\n+  static Thread *aarch64_get_thread_helper() {\n+     return Thread::current();\n+  }\n+\n+ public:\n+  \/\/ These routines are only used on cpu architectures that\n+  \/\/ have separate register stacks (Itanium).\n+  static bool register_stack_overflow() { return false; }\n+  static void enable_register_stack_guard() {}\n+  static void disable_register_stack_guard() {}\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_THREAD_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/thread_windows_aarch64.hpp","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_UNWIND_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_UNWIND_WINDOWS_AARCH64_HPP\n+\n+\n+typedef unsigned char UBYTE;\n+\n+#if _MSC_VER < 1700\n+\n+\/* Not needed for VS2012 compiler, comes from winnt.h. *\/\n+#define UNW_FLAG_EHANDLER  0x01\n+#define UNW_FLAG_UHANDLER  0x02\n+#define UNW_FLAG_CHAININFO 0x04\n+\n+#endif\n+\n+\/\/ See https:\/\/docs.microsoft.com\/en-us\/cpp\/build\/arm64-exception-handling#xdata-records\n+typedef struct _UNWIND_INFO_EH_ONLY {\n+    DWORD FunctionLength : 18;\n+    DWORD Version        : 2;\n+    DWORD X              : 1; \/\/ = 1\n+    DWORD E              : 1; \/\/ = 1\n+    DWORD EpilogCount    : 5; \/\/ = 0\n+    DWORD CodeWords      : 5; \/\/ = 1\n+    DWORD UnwindCode0    : 8;\n+    DWORD UnwindCode1    : 8;\n+    DWORD UnwindCode2    : 8;\n+    DWORD UnwindCode3    : 8;\n+    DWORD ExceptionHandler;\n+} UNWIND_INFO_EH_ONLY, *PUNWIND_INFO_EH_ONLY;\n+\n+\/*\n+typedef struct _RUNTIME_FUNCTION {\n+    DWORD BeginAddress;\n+    union {\n+        DWORD UnwindData;\n+        struct {\n+            DWORD Flag : 2;\n+            DWORD FunctionLength : 11;\n+            DWORD RegF : 3;\n+            DWORD RegI : 4;\n+            DWORD H : 1;\n+            DWORD CR : 2;\n+            DWORD FrameSize : 9;\n+        } DUMMYSTRUCTNAME;\n+    } DUMMYUNIONNAME;\n+} RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;\n+*\/\n+\n+#if _MSC_VER < 1700\n+\n+\/* Not needed for VS2012 compiler, comes from winnt.h. *\/\n+typedef struct _DISPATCHER_CONTEXT {\n+    ULONG64 ControlPc;\n+    ULONG64 ImageBase;\n+    PRUNTIME_FUNCTION FunctionEntry;\n+    ULONG64 EstablisherFrame;\n+    ULONG64 TargetIp;\n+    PCONTEXT ContextRecord;\n+\/\/    PEXCEPTION_ROUTINE LanguageHandler;\n+    char * LanguageHandler; \/\/ double dependency problem\n+    PVOID HandlerData;\n+} DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;\n+\n+#endif\n+\n+#if _MSC_VER < 1500\n+\n+\/* Not needed for VS2008 compiler, comes from winnt.h. *\/\n+typedef EXCEPTION_DISPOSITION (*PEXCEPTION_ROUTINE) (\n+    IN PEXCEPTION_RECORD ExceptionRecord,\n+    IN ULONG64 EstablisherFrame,\n+    IN OUT PCONTEXT ContextRecord,\n+    IN OUT PDISPATCHER_CONTEXT DispatcherContext\n+);\n+\n+#endif\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_UNWIND_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/unwind_windows_aarch64.hpp","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef OS_CPU_WINDOWS_AARCH64_VMSTRUCTS_WINDOWS_AARCH64_HPP\n+#define OS_CPU_WINDOWS_AARCH64_VMSTRUCTS_WINDOWS_AARCH64_HPP\n+\n+\/\/ These are the OS and CPU-specific fields, types and integer\n+\/\/ constants required by the Serviceability Agent. This file is\n+\/\/ referenced by vmStructs.cpp.\n+\n+#define VM_STRUCTS_OS_CPU(nonstatic_field, static_field, unchecked_nonstatic_field, volatile_nonstatic_field, nonproduct_nonstatic_field, c2_nonstatic_field, unchecked_c1_static_field, unchecked_c2_static_field) \\\n+                                                                                                                                     \\\n+  \/******************************\/                                                                                                   \\\n+  \/* Threads (NOTE: incomplete) *\/                                                                                                   \\\n+  \/******************************\/                                                                                                   \\\n+                                                                                                                                     \\\n+  nonstatic_field(OSThread,                    _thread_id,                                    OSThread::thread_id_t)                 \\\n+  unchecked_nonstatic_field(OSThread,          _thread_handle,                                sizeof(HANDLE)) \/* NOTE: no type *\/\n+\n+#define VM_TYPES_OS_CPU(declare_type, declare_toplevel_type, declare_oop_type, declare_integer_type, declare_unsigned_integer_type, declare_c1_toplevel_type, declare_c2_type, declare_c2_toplevel_type) \\\n+                                                                          \\\n+  declare_unsigned_integer_type(OSThread::thread_id_t)\n+\n+#define VM_INT_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#define VM_LONG_CONSTANTS_OS_CPU(declare_constant, declare_preprocessor_constant, declare_c1_constant, declare_c2_constant, declare_c2_preprocessor_constant)\n+\n+#endif \/\/ OS_CPU_WINDOWS_AARCH64_VMSTRUCTS_WINDOWS_AARCH64_HPP\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/vmStructs_windows_aarch64.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+\n+void VM_Version::get_os_cpu_info() {\n+\n+  if (IsProcessorFeaturePresent(PF_ARM_V8_CRC32_INSTRUCTIONS_AVAILABLE))   _features |= CPU_CRC32;\n+  if (IsProcessorFeaturePresent(PF_ARM_V8_CRYPTO_INSTRUCTIONS_AVAILABLE))  _features |= CPU_AES | CPU_SHA1 | CPU_SHA2;\n+  if (IsProcessorFeaturePresent(PF_ARM_VFP_32_REGISTERS_AVAILABLE))        _features |= CPU_ASIMD;\n+  \/\/ No check for CPU_PMULL\n+\n+  __int64 dczid_el0 = _ReadStatusReg(0x5807 \/* ARM64_DCZID_EL0 *\/);\n+\n+  if (!(dczid_el0 & 0x10)) {\n+    _zva_length = 4 << (dczid_el0 & 0xf);\n+  }\n+\n+  {\n+    PSYSTEM_LOGICAL_PROCESSOR_INFORMATION buffer = NULL;\n+    DWORD returnLength = 0;\n+\n+    \/\/ See https:\/\/docs.microsoft.com\/en-us\/windows\/win32\/api\/sysinfoapi\/nf-sysinfoapi-getlogicalprocessorinformation\n+    GetLogicalProcessorInformation(NULL, &returnLength);\n+    assert(GetLastError() == ERROR_INSUFFICIENT_BUFFER, \"Unexpected return from GetLogicalProcessorInformation\");\n+\n+    buffer = (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION)os::malloc(returnLength, mtInternal);\n+    BOOL rc = GetLogicalProcessorInformation(buffer, &returnLength);\n+    assert(rc, \"Unexpected return from GetLogicalProcessorInformation\");\n+\n+    _icache_line_size = _dcache_line_size = -1;\n+    for (PSYSTEM_LOGICAL_PROCESSOR_INFORMATION ptr = buffer; ptr < buffer + returnLength \/ sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION); ptr++) {\n+      switch (ptr->Relationship) {\n+      case RelationCache:\n+        \/\/ Cache data is in ptr->Cache, one CACHE_DESCRIPTOR structure for each cache.\n+        PCACHE_DESCRIPTOR Cache = &ptr->Cache;\n+        if (Cache->Level == 1) {\n+            _icache_line_size = _dcache_line_size = Cache->LineSize;\n+        }\n+        break;\n+      }\n+    }\n+    os::free(buffer);\n+  }\n+\n+  {\n+    char* buf = ::getenv(\"PROCESSOR_IDENTIFIER\");\n+    if (buf && strstr(buf, \"Ampere(TM)\") != NULL) {\n+      _cpu = CPU_AMCC;\n+    } else if (buf && strstr(buf, \"Cavium Inc.\") != NULL) {\n+      _cpu = CPU_CAVIUM;\n+    } else {\n+      log_info(os)(\"VM_Version: unknown CPU model\");\n+    }\n+\n+    if (_cpu) {\n+      SYSTEM_INFO si;\n+      GetSystemInfo(&si);\n+      _model = si.wProcessorLevel;\n+      _variant = si.wProcessorRevision \/ 0xFF;\n+      _revision = si.wProcessorRevision & 0xFF;\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/vm_version_windows_aarch64.cpp","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -491,0 +491,35 @@\n+bool os::win32::get_frame_at_stack_banging_point(JavaThread* thread,\n+        struct _EXCEPTION_POINTERS* exceptionInfo, address pc, frame* fr) {\n+  PEXCEPTION_RECORD exceptionRecord = exceptionInfo->ExceptionRecord;\n+  address addr = (address) exceptionRecord->ExceptionInformation[1];\n+  if (Interpreter::contains(pc)) {\n+    *fr = os::fetch_frame_from_context((void*)exceptionInfo->ContextRecord);\n+    if (!fr->is_first_java_frame()) {\n+      \/\/ get_frame_at_stack_banging_point() is only called when we\n+      \/\/ have well defined stacks so java_sender() calls do not need\n+      \/\/ to assert safe_for_sender() first.\n+      *fr = fr->java_sender();\n+    }\n+  } else {\n+    \/\/ more complex code with compiled code\n+    assert(!Interpreter::contains(pc), \"Interpreted methods should have been handled above\");\n+    CodeBlob* cb = CodeCache::find_blob(pc);\n+    if (cb == NULL || !cb->is_nmethod() || cb->is_frame_complete_at(pc)) {\n+      \/\/ Not sure where the pc points to, fallback to default\n+      \/\/ stack overflow handling\n+      return false;\n+    } else {\n+      \/\/ in compiled code, the stack banging is performed just after the return pc\n+      \/\/ has been pushed on the stack\n+      intptr_t* fp = (intptr_t*)exceptionInfo->ContextRecord->REG_FP;\n+      intptr_t* sp = (intptr_t*)exceptionInfo->ContextRecord->REG_SP;\n+      *fr = frame(sp + 1, fp, (address)*sp);\n+      if (!fr->is_java_frame()) {\n+        \/\/ See java_sender() comment above.\n+        *fr = fr->java_sender();\n+      }\n+    }\n+  }\n+  assert(fr->is_java_frame(), \"Safety check\");\n+  return true;\n+}\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -100,1 +100,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -4096,1 +4096,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -4100,1 +4100,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -4168,1 +4168,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n@@ -4172,1 +4172,1 @@\n-#ifdef _WIN32\n+#if defined(_WIN32) && !defined(USE_VECTORED_EXCEPTION_HANDLING)\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -175,0 +175,4 @@\n+#ifdef _M_ARM64\n+#define USE_VECTORED_EXCEPTION_HANDLING\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions_visCPP.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -593,0 +593,2 @@\n+#elif defined(_M_ARM64)\n+        sprops.os_arch = \"aarch64\";\n","filename":"src\/java.base\/windows\/native\/libjava\/java_props_md.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-        if (!arch.equals(\"x86\") && !arch.equals(\"amd64\")) {\n+        if (!arch.equals(\"x86\") && !arch.equals(\"amd64\") && !arch.equals(\"aarch64\")) {\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/AttachProviderImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -558,0 +558,2 @@\n+        } else if (cpu.equals(\"aarch64\")) {\n+            machDesc = new MachineDescriptionAArch64();\n@@ -559,1 +561,1 @@\n-            throw new DebuggerException(\"Win32 supported under x86 and amd64 only\");\n+            throw new DebuggerException(\"Win32 supported under x86, amd64 and aarch64 only\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/HotSpotAgent.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import sun.jvm.hotspot.debugger.aarch64.*;\n@@ -33,0 +34,1 @@\n+import sun.jvm.hotspot.debugger.windbg.aarch64.*;\n@@ -116,0 +118,2 @@\n+    } else if (cpu.equals(\"aarch64\")) {\n+      threadFactory = new WindbgAARCH64ThreadFactory(this);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.windbg.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.windbg.*;\n+\n+class WindbgAARCH64Thread implements ThreadProxy {\n+  private WindbgDebugger debugger;\n+  private long           sysId;\n+  private boolean        gotID;\n+  private long           id;\n+\n+  \/\/ The address argument must be the address of the OSThread::_thread_id\n+  WindbgAARCH64Thread(WindbgDebugger debugger, Address addr) {\n+    this.debugger = debugger;\n+    this.sysId    = (long)addr.getCIntegerAt(0, 4, true);\n+    gotID         = false;\n+  }\n+\n+  WindbgAARCH64Thread(WindbgDebugger debugger, long sysId) {\n+    this.debugger = debugger;\n+    this.sysId    = sysId;\n+    gotID         = false;\n+  }\n+\n+  public ThreadContext getContext() throws IllegalThreadStateException {\n+    long[] data = debugger.getThreadIntegerRegisterSet(getThreadID());\n+    WindbgAARCH64ThreadContext context = new WindbgAARCH64ThreadContext(debugger);\n+    for (int i = 0; i < data.length; i++) {\n+      context.setRegister(i, data[i]);\n+    }\n+    return context;\n+  }\n+\n+  public boolean canSetContext() throws DebuggerException {\n+    return false;\n+  }\n+\n+  public void setContext(ThreadContext thrCtx)\n+    throws IllegalThreadStateException, DebuggerException {\n+    throw new DebuggerException(\"Unimplemented\");\n+  }\n+\n+  public boolean equals(Object obj) {\n+    if ((obj == null) || !(obj instanceof WindbgAARCH64Thread)) {\n+      return false;\n+    }\n+\n+    return (((WindbgAARCH64Thread) obj).getThreadID() == getThreadID());\n+  }\n+\n+  public int hashCode() {\n+    return (int) getThreadID();\n+  }\n+\n+  public String toString() {\n+    return Long.toString(getThreadID());\n+  }\n+\n+  \/** Retrieves the thread ID of this thread by examining the Thread\n+      Information Block. *\/\n+  private long getThreadID() {\n+    if (!gotID) {\n+       id = debugger.getThreadIdFromSysId(sysId);\n+    }\n+\n+    return id;\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/aarch64\/WindbgAARCH64Thread.java","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.windbg.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.debugger.windbg.*;\n+\n+class WindbgAARCH64ThreadContext extends AARCH64ThreadContext {\n+  private WindbgDebugger debugger;\n+\n+  public WindbgAARCH64ThreadContext(WindbgDebugger debugger) {\n+    super();\n+    this.debugger = debugger;\n+  }\n+\n+  public void setRegisterAsAddress(int index, Address value) {\n+    setRegister(index, debugger.getAddressValue(value));\n+  }\n+\n+  public Address getRegisterAsAddress(int index) {\n+    return debugger.newAddress(getRegister(index));\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/aarch64\/WindbgAARCH64ThreadContext.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.debugger.windbg.aarch64;\n+\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.windbg.*;\n+\n+public class WindbgAARCH64ThreadFactory implements WindbgThreadFactory {\n+  private WindbgDebugger debugger;\n+\n+  public WindbgAARCH64ThreadFactory(WindbgDebugger debugger) {\n+    this.debugger = debugger;\n+  }\n+\n+  public ThreadProxy createThreadWrapper(Address threadIdentifierAddr) {\n+    return new WindbgAARCH64Thread(debugger, threadIdentifierAddr);\n+  }\n+\n+  public ThreadProxy createThreadWrapper(long id) {\n+    return new WindbgAARCH64Thread(debugger, id);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/aarch64\/WindbgAARCH64ThreadFactory.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -31,0 +31,1 @@\n+\n@@ -34,1 +35,0 @@\n-import sun.jvm.hotspot.runtime.win32_amd64.Win32AMD64JavaThreadPDAccess;\n@@ -36,0 +36,2 @@\n+import sun.jvm.hotspot.runtime.win32_amd64.Win32AMD64JavaThreadPDAccess;\n+import sun.jvm.hotspot.runtime.win32_aarch64.Win32AARCH64JavaThreadPDAccess;\n@@ -85,0 +87,2 @@\n+            } else if (cpu.equals(\"aarch64\")) {\n+                access =  new Win32AARCH64JavaThreadPDAccess();\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/Threads.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,138 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Microsoft Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package sun.jvm.hotspot.runtime.win32_aarch64;\n+\n+import java.io.*;\n+import java.util.*;\n+import sun.jvm.hotspot.debugger.*;\n+import sun.jvm.hotspot.debugger.aarch64.*;\n+import sun.jvm.hotspot.runtime.*;\n+import sun.jvm.hotspot.runtime.aarch64.*;\n+import sun.jvm.hotspot.types.*;\n+import sun.jvm.hotspot.utilities.*;\n+\n+\/** This class is only public to allow using the VMObjectFactory to\n+    instantiate these.\n+*\/\n+\n+public class Win32AARCH64JavaThreadPDAccess implements JavaThreadPDAccess {\n+  private static AddressField  lastJavaFPField;\n+  private static AddressField  osThreadField;\n+\n+  \/\/ Field from OSThread\n+  private static Field         osThreadThreadIDField;\n+\n+  \/\/ This is currently unneeded but is being kept in case we change\n+  \/\/ the currentFrameGuess algorithm\n+  private static final long GUESS_SCAN_RANGE = 128 * 1024;\n+\n+  static {\n+    VM.registerVMInitializedObserver(new Observer() {\n+        public void update(Observable o, Object data) {\n+          initialize(VM.getVM().getTypeDataBase());\n+        }\n+      });\n+  }\n+\n+  private static synchronized void initialize(TypeDataBase db) {\n+    Type type = db.lookupType(\"JavaThread\");\n+    osThreadField = type.getAddressField(\"_osthread\");\n+\n+    Type anchorType = db.lookupType(\"JavaFrameAnchor\");\n+    lastJavaFPField = anchorType.getAddressField(\"_last_Java_fp\");\n+\n+    Type osThreadType = db.lookupType(\"OSThread\");\n+    osThreadThreadIDField = osThreadType.getField(\"_thread_id\");\n+  }\n+\n+  public Address getLastJavaFP(Address addr) {\n+    return lastJavaFPField.getValue(addr.addOffsetTo(sun.jvm.hotspot.runtime.JavaThread.getAnchorField().getOffset()));\n+  }\n+\n+  public Address getLastJavaPC(Address addr) {\n+    return null;\n+  }\n+\n+  public Address getBaseOfStackPointer(Address addr) {\n+    return null;\n+  }\n+\n+  public Frame getLastFramePD(JavaThread thread, Address addr) {\n+    Address fp = thread.getLastJavaFP();\n+    if (fp == null) {\n+      return null; \/\/ no information\n+    }\n+    Address pc =  thread.getLastJavaPC();\n+    if ( pc != null ) {\n+      return new AARCH64Frame(thread.getLastJavaSP(), fp, pc);\n+    } else {\n+      return new AARCH64Frame(thread.getLastJavaSP(), fp);\n+    }\n+  }\n+\n+  public RegisterMap newRegisterMap(JavaThread thread, boolean updateMap) {\n+    return new AARCH64RegisterMap(thread, updateMap);\n+  }\n+\n+  public Frame getCurrentFrameGuess(JavaThread thread, Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    AARCH64CurrentFrameGuess guesser = new AARCH64CurrentFrameGuess(context, thread);\n+    if (!guesser.run(GUESS_SCAN_RANGE)) {\n+      return null;\n+    }\n+    if (guesser.getPC() == null) {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP());\n+    } else {\n+      return new AARCH64Frame(guesser.getSP(), guesser.getFP(), guesser.getPC());\n+    }\n+  }\n+\n+  public void printThreadIDOn(Address addr, PrintStream tty) {\n+    tty.print(getThreadProxy(addr));\n+  }\n+\n+  public void printInfoOn(Address threadAddr, PrintStream tty) {\n+  }\n+\n+  public Address getLastSP(Address addr) {\n+    ThreadProxy t = getThreadProxy(addr);\n+    AARCH64ThreadContext context = (AARCH64ThreadContext) t.getContext();\n+    return context.getRegisterAsAddress(AARCH64ThreadContext.SP);\n+  }\n+\n+  public ThreadProxy getThreadProxy(Address addr) {\n+    \/\/ Addr is the address of the JavaThread.\n+    \/\/ Fetch the OSThread (for now and for simplicity, not making a\n+    \/\/ separate \"OSThread\" class in this package)\n+    Address osThreadAddr = osThreadField.getValue(addr);\n+    \/\/ Get the address of the thread_id within the OSThread\n+    Address threadIdAddr = osThreadAddr.addOffsetTo(osThreadThreadIDField.getOffset());\n+\n+    JVMDebugger debugger = VM.getVM().getDebugger();\n+    return debugger.getThreadForIdentifierAddress(threadIdAddr);\n+  }\n+}\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/win32_aarch64\/Win32AARCH64JavaThreadPDAccess.java","additions":138,"deletions":0,"binary":false,"changes":138,"status":"added"},{"patch":"@@ -39,0 +39,3 @@\n+#elif _M_ARM64\n+  #include \"sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext.h\"\n+  #define NPRGREG sun_jvm_hotspot_debugger_aarch64_AARCH64ThreadContext_NPRGREG\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"}]}