{"files":[{"patch":"@@ -1660,0 +1660,37 @@\n+\/\/ Is this Phi's region or some inputs to the region enqueued for IGVN\n+\/\/ and so could cause the region to be optimized out?\n+bool PhiNode::wait_for_region_igvn(PhaseGVN* phase) {\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  Unique_Node_List& worklist = igvn->_worklist;\n+  bool delay = false;\n+  Node* r = in(0);\n+  for (uint j = 1; j < req(); j++) {\n+    Node* rc = r->in(j);\n+    Node* n = in(j);\n+    if (rc != NULL &&\n+        rc->is_Proj()) {\n+      if (worklist.member(rc)) {\n+        delay = true;\n+      } else if (rc->in(0) != NULL &&\n+                 rc->in(0)->is_If()) {\n+        if (worklist.member(rc->in(0))) {\n+          delay = true;\n+        } else if (rc->in(0)->in(1) != NULL &&\n+                   rc->in(0)->in(1)->is_Bool()) {\n+          if (worklist.member(rc->in(0)->in(1))) {\n+            delay = true;\n+          } else if (rc->in(0)->in(1)->in(1) != NULL &&\n+                     rc->in(0)->in(1)->in(1)->is_Cmp()) {\n+            if (worklist.member(rc->in(0)->in(1)->in(1))) {\n+              delay = true;\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+  if (delay) {\n+    worklist.push(this);\n+  }\n+  return delay;\n+}\n@@ -1713,1 +1750,4 @@\n-  if (uin == NULL && can_reshape) {\n+  if (uin == NULL && can_reshape &&\n+      \/\/ If there is a chance that the region can be optimized out do\n+      \/\/ not add a cast node that we can't remove yet.\n+      !wait_for_region_igvn(phase)) {\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":41,"deletions":1,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -138,0 +138,1 @@\n+  bool wait_for_region_igvn(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,76 @@\n+\/*\n+ * Copyright (c) 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8240335\n+ * @summary C2: assert(found_sfpt) failed: no node in loop that's not input to safepoint\n+ *\n+ * @run main\/othervm -Xcomp -XX:CompileOnly=TestCastIIAfterUnrollingInOuterLoop TestCastIIAfterUnrollingInOuterLoop\n+ *\n+ *\/\n+\n+public class TestCastIIAfterUnrollingInOuterLoop {\n+    public static final int N = 400;\n+\n+    public static long instanceCount=727275458L;\n+    public static int iFld=-10;\n+    public static volatile short sFld=-2966;\n+    public static float fFld=1.682F;\n+    public static int iArrFld[]=new int[N];\n+\n+    public static void vMeth1(int i1) {\n+        int i3=4;\n+        long lArr[]=new long[N], lArr1[]=new long[N];\n+\n+        boolean b = (Integer.reverseBytes(i1 << 5) < (instanceCount++));\n+        for (int i2 = 1; i2 < 146; i2++) {\n+            iFld >>= (++i3);\n+        }\n+        if (b) {\n+            for (int i4 = 4; i4 < 218; ++i4) {\n+                instanceCount = iArrFld[i4 - 1];\n+                int i10 = 1;\n+                while (++i10 < 8) {\n+                    lArr1[i4] += 61384L;\n+                }\n+                lArr[i4 + 1] = i4;\n+                i3 += sFld;\n+            }\n+        }\n+    }\n+\n+    public void mainTest(String[] strArr1) {\n+        vMeth1(iFld);\n+        for (int i19 = 2; i19 < 190; i19++) {\n+            int i20 = (int)instanceCount;\n+            instanceCount += (((i19 * i20) + i20) - fFld);\n+        }\n+    }\n+    public static void main(String[] strArr) {\n+        TestCastIIAfterUnrollingInOuterLoop _instance = new TestCastIIAfterUnrollingInOuterLoop();\n+        for (int i = 0; i < 10; i++) {\n+            _instance.mainTest(strArr);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestCastIIAfterUnrollingInOuterLoop.java","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"}]}