{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2010, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2019, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,2 +26,4 @@\n- * @bug 4533243\n- * @summary Closing a keep alive stream gives NullPointerException\n+ * @bug 4533243 8263364\n+ * @summary Closing a keep alive stream should not give NullPointerException and should accept a connection from  a\n+ *          client only from this test\n+ * @library \/test\/lib\n@@ -33,0 +35,4 @@\n+import jdk.test.lib.net.URIBuilder;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.ServerSocketChannel;\n+import java.nio.channels.SocketChannel;\n@@ -36,5 +42,2 @@\n-    static class XServer extends Thread {\n-        ServerSocket srv;\n-        Socket s;\n-        InputStream is;\n-        OutputStream os;\n+    private final static String path = \"\/KeepAliveStreamCloseWithWrongContentLength\";\n+    private final static String getRequest1stLine = \"GET \/KeepAliveStreamCloseWithWrongContentLength\";\n@@ -42,2 +45,14 @@\n-        XServer (ServerSocket s) {\n-            srv = s;\n+    static class XServer extends Thread implements AutoCloseable {\n+\n+        final ServerSocket serverSocket;\n+        volatile Socket clientSocket;\n+\n+        XServer (InetAddress address) throws IOException {\n+            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();\n+            ServerSocket serversocket = serverSocketChannel.socket();\n+            serversocket.bind(new InetSocketAddress(address, 0));\n+            this.serverSocket = serversocket;\n+        }\n+\n+        public int getLocalPort() {\n+            return serverSocket.getLocalPort();\n@@ -47,0 +62,1 @@\n+\n@@ -48,6 +64,26 @@\n-                s = srv.accept ();\n-                \/\/ read HTTP request from client\n-                InputStream is = s.getInputStream();\n-                \/\/ read the first ten bytes\n-                for (int i=0; i<10; i++) {\n-                    is.read();\n+                ByteArrayOutputStream clientBytes;\n+                clientSocket = null;\n+\n+                \/\/ in a concurrent test environment it can happen that other rouge clients connect to this server\n+                \/\/ so we need to identify and connect only to the client from this test\n+                \/\/ if the rouge client sends as least bytes as there is in getRequest1stLine it will be discarded and\n+                \/\/ the test should proceed otherwise it should timeout on readNBytes below\n+                do {\n+                    if (clientSocket != null) {\n+                        final String client =\n+                            clientSocket.getInetAddress().getHostAddress() + \":\" +\n+                            clientSocket.getPort();\n+                        try {\n+                            clientSocket.close();\n+                        }\n+                        catch (IOException ioe) {\n+                            ioe.printStackTrace();\n+                        }\n+                        finally {\n+                            System.err.println(\"rogue client (\" + client + \") connection attempt, ignoring\");\n+                        }\n+                    }\n+                    clientSocket = serverSocket.accept();\n+                    \/\/ read HTTP request from client\n+                    clientBytes = new ByteArrayOutputStream();\n+                    clientBytes.write(clientSocket.getInputStream().readNBytes(getRequest1stLine.getBytes().length));\n@@ -55,3 +91,8 @@\n-                OutputStreamWriter ow =\n-                    new OutputStreamWriter((os = s.getOutputStream()));\n-                ow.write(\"HTTP\/1.0 200 OK\\n\");\n+                while(!getRequest1stLine.equals(clientBytes.toString()));\n+            }\n+            catch (Exception e) {\n+                e.printStackTrace();\n+            }\n+            try  {\n+                OutputStreamWriter outputStreamWriter = new OutputStreamWriter(clientSocket.getOutputStream());\n+                outputStreamWriter.write(\"HTTP\/1.0 200 OK\\n\");\n@@ -60,2 +101,2 @@\n-                ow.write(\"Content-Length: 10\\n\");\n-                ow.write(\"Content-Type: text\/html\\n\");\n+                outputStreamWriter.write(\"Content-Length: 10\\n\");\n+                outputStreamWriter.write(\"Content-Type: text\/html\\n\");\n@@ -64,2 +105,2 @@\n-                ow.write(\"Connection: Keep-Alive\\n\");\n-                ow.write(\"\\n\");\n+                outputStreamWriter.write(\"Connection: Keep-Alive\\n\");\n+                outputStreamWriter.write(\"\\n\");\n@@ -68,5 +109,6 @@\n-                ow.write(\"123456789\");\n-                ow.flush();\n-            } catch (Exception e) {\n-            } finally {\n-                try {if (os != null) { os.close(); }} catch (IOException e) {}\n+                outputStreamWriter.write(\"123456789\");\n+                outputStreamWriter.flush();\n+                clientSocket.getChannel().shutdownOutput();\n+            }\n+            catch (Exception e) {\n+                e.printStackTrace();\n@@ -75,0 +117,14 @@\n+\n+        @Override\n+        public void close() throws Exception {\n+            final var clientSocket = this.clientSocket;\n+            try {\n+                long drained = drain(clientSocket.getChannel());\n+                System.err.printf(\"Server drained %d bytes from the channel%n\", drained);\n+            } catch (Exception x) {\n+                System.err.println(\"Server failed to drain client socket: \" + x);\n+                x.printStackTrace();\n+            }\n+            serverSocket.close();\n+        }\n+\n@@ -77,2 +133,6 @@\n-    public static void main (String[] args) throws Exception {\n-        ServerSocket serversocket = new ServerSocket (0);\n+    static long drain(SocketChannel channel) throws IOException {\n+        if (!channel.isOpen()) return 0;\n+        System.err.println(\"Not reading server: draining socket\");\n+        var blocking = channel.isBlocking();\n+        if (blocking) channel.configureBlocking(false);\n+        long count = 0;\n@@ -80,6 +140,29 @@\n-            int port = serversocket.getLocalPort ();\n-            XServer server = new XServer (serversocket);\n-            server.start ();\n-            URL url = new URL (\"http:\/\/localhost:\"+port);\n-            HttpURLConnection urlc = (HttpURLConnection)url.openConnection ();\n-            InputStream is = urlc.getInputStream ();\n+            ByteBuffer buffer = ByteBuffer.allocateDirect(8 * 1024);\n+            int read;\n+            while ((read = channel.read(buffer)) > 0) {\n+                count += read;\n+                buffer.clear();\n+            }\n+            return count;\n+        } finally {\n+            if (blocking != channel.isBlocking()) {\n+                channel.configureBlocking(blocking);\n+            }\n+        }\n+    }\n+\n+\n+    public static void main (String[] args) throws Exception {\n+\n+        final InetAddress loopback = InetAddress.getLoopbackAddress();\n+\n+        try (XServer server = new XServer(loopback)) {\n+            server.start();\n+            URL url = URIBuilder.newBuilder()\n+                .scheme(\"http\")\n+                .loopback()\n+                .path(path)\n+                .port(server.getLocalPort())\n+                .toURL();\n+            HttpURLConnection urlc = (HttpURLConnection)url.openConnection(Proxy.NO_PROXY);\n+            InputStream is = urlc.getInputStream();\n@@ -90,0 +173,1 @@\n+                    System.out.println(\"client reads: \"+c);\n@@ -96,6 +180,0 @@\n-        } catch (IOException e) {\n-            return;\n-        } catch (NullPointerException e) {\n-            throw new RuntimeException (e);\n-        } finally {\n-            if (serversocket != null) serversocket.close();\n@@ -103,0 +181,1 @@\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveStream\/KeepAliveStreamCloseWithWrongContentLength.java","additions":121,"deletions":42,"binary":false,"changes":163,"status":"modified"}]}