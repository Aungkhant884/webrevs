{"files":[{"patch":"@@ -54,0 +54,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1.0;\n+}\n+\n","filename":"src\/jdk.management\/aix\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#define NS_PER_SEC 1000000000\n@@ -368,0 +369,25 @@\n+\/\/ Return the host cpu ticks since boot in nanoseconds\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    if (perfInit() == 0) {\n+        if (get_totalticks(-1, &counters.cpuTicks) < 0) {\n+            return -1;\n+        } else {\n+            long ticks_per_sec = sysconf(_SC_CLK_TCK);\n+            jlong result = (jlong)counters.cpuTicks.total;\n+            if (ticks_per_sec <= NS_PER_SEC) {\n+                long scale_factor = NS_PER_SEC\/ticks_per_sec;\n+                result = result * scale_factor;\n+            } else {\n+                long scale_factor = ticks_per_sec\/NS_PER_SEC;\n+                result = result \/ scale_factor;\n+            }\n+            return result;\n+        }\n+    } else {\n+        return -1;\n+    }\n+}\n+\n","filename":"src\/jdk.management\/linux\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -170,0 +170,7 @@\n+JNIEXPORT jlong JNICALL\n+Java_com_sun_management_internal_OperatingSystemImpl_getHostTotalCpuTicks0\n+(JNIEnv *env, jobject mbean)\n+{\n+    return -1.0;\n+}\n+\n","filename":"src\/jdk.management\/macosx\/native\/libmanagement_ext\/UnixOperatingSystem.c","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+    private long usageTicks = 0; \/\/ used for cpu load calculation\n+    private long totalTicks = 0; \/\/ used for cpu load calculation\n@@ -136,0 +138,32 @@\n+    private double getUsageDividesTotal(long usageTicks, long totalTicks) {\n+        \/\/ If cpu quota or cpu shares are in effect calculate the cpu load\n+        \/\/ based on the following formula (similar to how\n+        \/\/ getCpuLoad0() is being calculated):\n+        \/\/\n+        \/\/   | usageTicks - usageTicks' |\n+        \/\/  ------------------------------\n+        \/\/   | totalTicks - totalTicks' |\n+        \/\/\n+        \/\/ where usageTicks' and totalTicks' are historical values\n+        \/\/ retrieved via an earlier call of this method.\n+        \/\/\n+        \/\/ Total ticks should be scaled to the container effective number\n+        \/\/ of cpus, if cpu shares are in effect.\n+        if (usageTicks < 0 || totalTicks <= 0) {\n+            return -1;\n+        }\n+        long distance = usageTicks - this.usageTicks;\n+        this.usageTicks = usageTicks;\n+        long totalDistance = totalTicks - this.totalTicks;\n+        this.totalTicks = totalTicks;\n+\n+        double systemLoad = 0.0;\n+        if (distance > 0 && totalDistance > 0) {\n+            systemLoad = ((double)distance) \/ totalDistance;\n+        }\n+        \/\/ Ensure the return value is in the range 0.0 -> 1.0\n+        systemLoad = Math.max(0.0, systemLoad);\n+        systemLoad = Math.min(1.0, systemLoad);\n+        return systemLoad;\n+    }\n+\n@@ -139,0 +173,2 @@\n+            long share = containerMetrics.getCpuShares();\n+            long usageNanos = containerMetrics.getCpuUsage();\n@@ -140,1 +176,0 @@\n-                long periodLength = containerMetrics.getCpuPeriod();\n@@ -142,10 +177,9 @@\n-                long usageNanos = containerMetrics.getCpuUsage();\n-                if (periodLength > 0 && numPeriods > 0 && usageNanos > 0) {\n-                    long elapsedNanos = TimeUnit.MICROSECONDS.toNanos(periodLength * numPeriods);\n-                    double systemLoad = (double) usageNanos \/ elapsedNanos;\n-                    \/\/ Ensure the return value is in the range 0.0 -> 1.0\n-                    systemLoad = Math.max(0.0, systemLoad);\n-                    systemLoad = Math.min(1.0, systemLoad);\n-                    return systemLoad;\n-                }\n-                return -1;\n+                long quotaNanos = TimeUnit.MICROSECONDS.toNanos(quota * numPeriods);\n+                return getUsageDividesTotal(usageNanos, quotaNanos);\n+            } else if (share > 0) {\n+                long hostTicks = getHostTotalCpuTicks0();\n+                int totalCPUs = getHostOnlineCpuCount0();\n+                int containerCPUs = getAvailableProcessors();\n+                \/\/ scale the total host load to the actual container cpus\n+                hostTicks = hostTicks * containerCPUs \/ totalCPUs;\n+                return getUsageDividesTotal(usageNanos, hostTicks);\n@@ -153,1 +187,1 @@\n-                \/\/ If CPU quotas are not active then find the average system load for\n+                \/\/ If CPU quotas and shares are not active then find the average system load for\n@@ -208,0 +242,2 @@\n+    \/\/ CPU ticks since boot in nanoseconds\n+    private native long getHostTotalCpuTicks0();\n","filename":"src\/jdk.management\/unix\/classes\/com\/sun\/management\/internal\/OperatingSystemImpl.java","additions":48,"deletions":12,"binary":false,"changes":60,"status":"modified"}]}