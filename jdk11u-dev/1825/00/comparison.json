{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2021, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,2 @@\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n@@ -60,1 +62,1 @@\n-    \/\/    a Connection: keep-alive header was sent by server\n+    \/\/ a Connection: keep-alive header was sent by server\n@@ -73,1 +75,1 @@\n-            new GetIntegerAction(keepAliveProp+type, -1)).intValue();\n+            new GetIntegerAction(keepAliveProp + type, -1)).intValue();\n@@ -82,1 +84,2 @@\n-    \/* maximum # keep-alive connections to maintain at once\n+    \/*\n+     * maximum # keep-alive connections to maintain at once\n@@ -84,1 +87,2 @@\n-     * a larger value is more appropriate. So we now set a default of 5, and the value\n+     * a larger value is more appropriate. So we now set a default of 5, and the\n+     * value\n@@ -90,0 +94,2 @@\n+\n+    @SuppressWarnings(\"removal\")\n@@ -104,0 +110,3 @@\n+    \/\/ This class is never serialized (see writeObject\/readObject).\n+    private final ReentrantLock cacheLock = new ReentrantLock();\n+    @SuppressWarnings(\"serial\") \/\/ Type of field is not Serializable\n@@ -109,1 +118,2 @@\n-    public KeepAliveCache() {}\n+    public KeepAliveCache() {\n+    }\n@@ -113,0 +123,1 @@\n+     *\n@@ -116,23 +127,14 @@\n-    public synchronized void put(final URL url, Object obj, HttpClient http) {\n-        boolean startThread = (keepAliveTimer == null);\n-        if (!startThread) {\n-            if (!keepAliveTimer.isAlive()) {\n-                startThread = true;\n-            }\n-        }\n-        if (startThread) {\n-            clear();\n-            \/* Unfortunately, we can't always believe the keep-alive timeout we got\n-             * back from the server.  If I'm connected through a Netscape proxy\n-             * to a server that sent me a keep-alive\n-             * time of 15 sec, the proxy unilaterally terminates my connection\n-             * The robustness to get around this is in HttpClient.parseHTTP()\n-             *\/\n-            final KeepAliveCache cache = this;\n-            AccessController.doPrivileged(new PrivilegedAction<>() {\n-                public Void run() {\n-                    keepAliveTimer = InnocuousThread.newSystemThread(\"Keep-Alive-Timer\", cache);\n-                    keepAliveTimer.setDaemon(true);\n-                    keepAliveTimer.setPriority(Thread.MAX_PRIORITY - 2);\n-                    keepAliveTimer.start();\n-                    return null;\n+    @SuppressWarnings(\"removal\")\n+    public void put(final URL url, Object obj, HttpClient http) {\n+        \/\/ this method may need to close an HttpClient, either because\n+        \/\/ it is not cacheable, or because the cache is at its capacity.\n+        \/\/ In the latter case, we close the least recently used client.\n+        \/\/ The client to close is stored in oldClient, and is closed\n+        \/\/ after cacheLock is released.\n+        HttpClient oldClient = null;\n+        cacheLock.lock();\n+        try {\n+            boolean startThread = (keepAliveTimer == null);\n+            if (!startThread) {\n+                if (!keepAliveTimer.isAlive()) {\n+                    startThread = true;\n@@ -140,2 +142,21 @@\n-            });\n-        }\n+            }\n+            if (startThread) {\n+                clear();\n+                \/*\n+                 * Unfortunately, we can't always believe the keep-alive timeout we got\n+                 * back from the server. If I'm connected through a Netscape proxy\n+                 * to a server that sent me a keep-alive\n+                 * time of 15 sec, the proxy unilaterally terminates my connection\n+                 * The robustness to get around this is in HttpClient.parseHTTP()\n+                 *\/\n+                final KeepAliveCache cache = this;\n+                AccessController.doPrivileged(new PrivilegedAction<>() {\n+                    public Void run() {\n+                        keepAliveTimer = InnocuousThread.newSystemThread(\"Keep-Alive-Timer\", cache);\n+                        keepAliveTimer.setDaemon(true);\n+                        keepAliveTimer.setPriority(Thread.MAX_PRIORITY - 2);\n+                        keepAliveTimer.start();\n+                        return null;\n+                    }\n+                });\n+            }\n@@ -143,2 +164,2 @@\n-        KeepAliveKey key = new KeepAliveKey(url, obj);\n-        ClientVector v = super.get(key);\n+            KeepAliveKey key = new KeepAliveKey(url, obj);\n+            ClientVector v = super.get(key);\n@@ -146,2 +167,2 @@\n-        if (v == null) {\n-            int keepAliveTimeout = http.getKeepAliveTimeout();\n+            if (v == null) {\n+                int keepAliveTimeout = http.getKeepAliveTimeout();\n@@ -167,1 +188,1 @@\n-                    http.closeServer();\n+                    oldClient = http;\n@@ -173,2 +194,9 @@\n-        } else {\n-            v.put(http);\n+            } else {\n+                oldClient = v.put(http);\n+            }\n+        } finally {\n+            cacheLock.unlock();\n+        }\n+        \/\/ close after releasing locks\n+        if (oldClient != null) {\n+            oldClient.closeServer();\n@@ -183,13 +211,2 @@\n-    \/* remove an obsolete HttpClient from its VectorCache *\/\n-    public synchronized void remove(HttpClient h, Object obj) {\n-        KeepAliveKey key = new KeepAliveKey(h.url, obj);\n-        ClientVector v = super.get(key);\n-        if (v != null) {\n-            v.remove(h);\n-            if (v.isEmpty()) {\n-                removeVector(key);\n-            }\n-        }\n-    }\n-\n-    \/* called by a clientVector thread when all its connections have timed out\n+    \/*\n+     * called by a clientVector thread when all its connections have timed out\n@@ -198,1 +215,2 @@\n-    synchronized void removeVector(KeepAliveKey k) {\n+    private void removeVector(KeepAliveKey k) {\n+        assert cacheLock.isHeldByCurrentThread();\n@@ -205,5 +223,11 @@\n-    public synchronized HttpClient get(URL url, Object obj) {\n-        KeepAliveKey key = new KeepAliveKey(url, obj);\n-        ClientVector v = super.get(key);\n-        if (v == null) { \/\/ nothing in cache yet\n-            return null;\n+    public HttpClient get(URL url, Object obj) {\n+        cacheLock.lock();\n+        try {\n+            KeepAliveKey key = new KeepAliveKey(url, obj);\n+            ClientVector v = super.get(key);\n+            if (v == null) { \/\/ nothing in cache yet\n+                return null;\n+            }\n+            return v.get();\n+        } finally {\n+            cacheLock.unlock();\n@@ -211,1 +235,0 @@\n-        return v.get();\n@@ -214,1 +237,2 @@\n-    \/* Sleeps for an alloted timeout, then checks for timed out connections.\n+    \/*\n+     * Sleeps for an alloted timeout, then checks for timed out connections.\n@@ -223,1 +247,3 @@\n-            } catch (InterruptedException e) {}\n+            } catch (InterruptedException e) {\n+            }\n+            List<HttpClient> closeList = null;\n@@ -226,1 +252,2 @@\n-            synchronized (this) {\n+            cacheLock.lock();\n+            try {\n@@ -232,2 +259,3 @@\n-                    synchronized (v) {\n-                        KeepAliveEntry e = v.peek();\n+                    v.lock();\n+                    try {\n+                        KeepAliveEntry e = v.peekLast();\n@@ -236,2 +264,5 @@\n-                                v.poll();\n-                                e.hc.closeServer();\n+                                v.pollLast();\n+                                if (closeList == null) {\n+                                    closeList = new ArrayList<>();\n+                                }\n+                                closeList.add(e.hc);\n@@ -241,1 +272,1 @@\n-                            e = v.peek();\n+                            e = v.peekLast();\n@@ -247,0 +278,2 @@\n+                    } finally {\n+                        v.unlock();\n@@ -253,0 +286,8 @@\n+            } finally {\n+                cacheLock.unlock();\n+                \/\/ close connections outside cacheLock\n+                if (closeList != null) {\n+                    for (HttpClient hc : closeList) {\n+                        hc.closeServer();\n+                    }\n+                }\n@@ -265,2 +306,1 @@\n-        throws IOException, ClassNotFoundException\n-    {\n+            throws IOException, ClassNotFoundException {\n@@ -271,2 +311,3 @@\n-\/* FILO order for recycling HttpClients, should run in a thread\n- * to time them out.  If > maxConns are in use, block.\n+\/*\n+ * LIFO order for reusing HttpClients. Most recent entries at the front.\n+ * If > maxConns are in use, discard oldest.\n@@ -276,0 +317,1 @@\n+    private final ReentrantLock lock = new ReentrantLock();\n@@ -284,10 +326,10 @@\n-    synchronized HttpClient get() {\n-        if (isEmpty()) {\n-            return null;\n-        }\n-\n-        \/\/ Loop until we find a connection that has not timed out\n-        HttpClient hc = null;\n-        long currentTime = System.currentTimeMillis();\n-        do {\n-            KeepAliveEntry e = pop();\n+    \/* return a still valid, idle HttpClient *\/\n+    HttpClient get() {\n+        lock();\n+        try {\n+            \/\/ check the most recent connection, use if still valid\n+            KeepAliveEntry e = peekFirst();\n+            if (e == null) {\n+                return null;\n+            }\n+            long currentTime = System.currentTimeMillis();\n@@ -295,1 +337,1 @@\n-                e.hc.closeServer();\n+                return null; \/\/ all connections stale - will be cleaned up later\n@@ -297,1 +339,1 @@\n-                hc = e.hc;\n+                pollFirst();\n@@ -300,1 +342,1 @@\n-                        + Long.toString(currentTime - e.idleStartTime);\n+                            + Long.toString(currentTime - e.idleStartTime);\n@@ -303,0 +345,1 @@\n+                return e.hc;\n@@ -304,10 +347,2 @@\n-        } while ((hc == null) && (!isEmpty()));\n-        return hc;\n-    }\n-\n-    \/* return a still valid, unused HttpClient *\/\n-    synchronized void put(HttpClient h) {\n-        if (size() >= KeepAliveCache.getMaxConnections()) {\n-            h.closeServer(); \/\/ otherwise the connection remains in limbo\n-        } else {\n-            push(new KeepAliveEntry(h, System.currentTimeMillis()));\n+        } finally {\n+            unlock();\n@@ -317,5 +352,8 @@\n-    \/* remove an HttpClient *\/\n-    synchronized boolean remove(HttpClient h) {\n-        for (KeepAliveEntry curr : this) {\n-            if (curr.hc == h) {\n-                return super.remove(curr);\n+    HttpClient put(HttpClient h) {\n+        HttpClient staleClient = null;\n+        lock();\n+        try {\n+            assert KeepAliveCache.getMaxConnections() > 0;\n+            if (size() >= KeepAliveCache.getMaxConnections()) {\n+                \/\/ remove oldest connection\n+                staleClient = removeLast().hc;\n@@ -323,0 +361,3 @@\n+            addFirst(new KeepAliveEntry(h, System.currentTimeMillis()));\n+        } finally {\n+            unlock();\n@@ -324,1 +365,10 @@\n-        return false;\n+        \/\/ close after releasing the locks\n+        return staleClient;\n+    }\n+\n+    final void lock() {\n+        lock.lock();\n+    }\n+\n+    final void unlock() {\n+        lock.unlock();\n@@ -335,2 +385,1 @@\n-        throws IOException, ClassNotFoundException\n-    {\n+            throws IOException, ClassNotFoundException {\n@@ -342,4 +391,4 @@\n-    private String      protocol = null;\n-    private String      host = null;\n-    private int         port = 0;\n-    private Object      obj = null; \/\/ additional key, such as socketfactory\n+    private final String protocol;\n+    private final String host;\n+    private final int port;\n+    private final Object obj; \/\/ additional key, such as socketfactory\n@@ -366,1 +415,1 @@\n-        KeepAliveKey kae = (KeepAliveKey)obj;\n+        KeepAliveKey kae = (KeepAliveKey) obj;\n@@ -368,3 +417,3 @@\n-            && (port == kae.port)\n-            && protocol.equals(kae.protocol)\n-            && this.obj == kae.obj;\n+                && (port == kae.port)\n+                && protocol.equals(kae.protocol)\n+                && this.obj == kae.obj;\n@@ -379,3 +428,2 @@\n-        String str = protocol+host+port;\n-        return this.obj == null? str.hashCode() :\n-            str.hashCode() + this.obj.hashCode();\n+        String str = protocol + host + port;\n+        return this.obj == null ? str.hashCode() : str.hashCode() + this.obj.hashCode();\n@@ -386,2 +434,2 @@\n-    HttpClient hc;\n-    long idleStartTime;\n+    final HttpClient hc;\n+    final long idleStartTime;\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/http\/KeepAliveCache.java","additions":162,"deletions":114,"binary":false,"changes":276,"status":"modified"},{"patch":"@@ -431,0 +431,9 @@\n+    @Override\n+    public void closeServer() {\n+        try {\n+            \/\/ SSLSocket.close may block up to timeout. Make sure it's short.\n+            serverSocket.setSoTimeout(1);\n+        } catch (Exception e) {}\n+        super.closeServer();\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,238 @@\n+\/*\n+ * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293562\n+ * @library \/test\/lib\n+ * @run main\/othervm -Dhttp.keepAlive.time.server=1 B8293562\n+ * @summary Http keep-alive thread should close sockets without holding a lock\n+ *\/\n+\n+import com.sun.net.httpserver.HttpServer;\n+\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Proxy;\n+import java.net.Socket;\n+import java.net.URL;\n+import java.net.UnknownHostException;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+\n+public class B8293562 {\n+    static HttpServer server;\n+    static CountDownLatch closing = new CountDownLatch(1);\n+    static CountDownLatch secondRequestDone = new CountDownLatch(1);\n+    static CompletableFuture<Void> result = new CompletableFuture<>();\n+\n+    public static void main(String[] args) throws Exception {\n+        startHttpServer();\n+        clientHttpCalls();\n+    }\n+\n+    public static void startHttpServer() throws Exception {\n+        server = HttpServer.create(new InetSocketAddress(InetAddress.getLoopbackAddress(), 0), 10);\n+        server.setExecutor(Executors.newCachedThreadPool());\n+        server.start();\n+    }\n+\n+    public static void clientHttpCalls() throws Exception {\n+        try {\n+            System.out.println(\"http server listen on: \" + server.getAddress().getPort());\n+            String hostAddr = InetAddress.getLoopbackAddress().getHostAddress();\n+            if (hostAddr.indexOf(':') > -1) hostAddr = \"[\" + hostAddr + \"]\";\n+            String baseURLStr = \"https:\/\/\" + hostAddr + \":\" + server.getAddress().getPort() + \"\/\";\n+\n+            URL testUrl = new URL (baseURLStr);\n+\n+            \/\/ SlowCloseSocketFactory is not a real SSLSocketFactory;\n+            \/\/ it produces regular non-SSL sockets. Effectively, the request\n+            \/\/ is made over http.\n+            HttpsURLConnection.setDefaultSSLSocketFactory(new SlowCloseSocketFactory());\n+            System.out.println(\"Performing first request\");\n+            HttpsURLConnection uc = (HttpsURLConnection)testUrl.openConnection(Proxy.NO_PROXY);\n+            byte[] buf = new byte[1024];\n+            try {\n+                uc.getInputStream();\n+                throw new RuntimeException(\"Expected 404 here\");\n+            } catch (FileNotFoundException ignored) { }\n+            try (InputStream is = uc.getErrorStream()) {\n+                while (is.read(buf) >= 0) {\n+                }\n+            }\n+            System.out.println(\"First request completed\");\n+            closing.await();\n+            \/\/ KeepAliveThread is closing the connection now\n+            System.out.println(\"Performing second request\");\n+            HttpsURLConnection uc2 = (HttpsURLConnection)testUrl.openConnection(Proxy.NO_PROXY);\n+\n+            try {\n+                uc2.getInputStream();\n+                throw new RuntimeException(\"Expected 404 here\");\n+            } catch (FileNotFoundException ignored) { }\n+            try (InputStream is = uc2.getErrorStream()) {\n+                while (is.read(buf) >= 0) {\n+                }\n+            }\n+            System.out.println(\"Second request completed\");\n+            \/\/ let the socket know it can close now\n+            secondRequestDone.countDown();\n+            result.get();\n+            System.out.println(\"Test completed successfully\");\n+        } finally {\n+            server.stop(1);\n+        }\n+    }\n+\n+    static class SlowCloseSocket extends SSLSocket {\n+        @Override\n+        public synchronized void close() throws IOException {\n+            String threadName = Thread.currentThread().getName();\n+            System.out.println(\"Connection closing, thread name: \" + threadName);\n+            closing.countDown();\n+            super.close();\n+            if (threadName.equals(\"Keep-Alive-Timer\")) {\n+                try {\n+                    if (secondRequestDone.await(5, TimeUnit.SECONDS)) {\n+                        result.complete(null);\n+                    } else {\n+                        result.completeExceptionally(new RuntimeException(\n+                                \"Wait for second request timed out\"));\n+                    }\n+                } catch (InterruptedException e) {\n+                    result.completeExceptionally(new RuntimeException(\n+                            \"Wait for second request was interrupted\"));\n+                }\n+            } else {\n+                result.completeExceptionally(new RuntimeException(\n+                        \"Close invoked from unexpected thread\"));\n+            }\n+            System.out.println(\"Connection closed\");\n+        }\n+\n+        \/\/ required abstract method overrides\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledCipherSuites(String[] suites) { }\n+        @Override\n+        public String[] getSupportedProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getEnabledProtocols() {\n+            return new String[0];\n+        }\n+        @Override\n+        public void setEnabledProtocols(String[] protocols) { }\n+        @Override\n+        public SSLSession getSession() {\n+            return null;\n+        }\n+        @Override\n+        public void addHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) { }\n+        @Override\n+        public void startHandshake() throws IOException { }\n+        @Override\n+        public void setUseClientMode(boolean mode) { }\n+        @Override\n+        public boolean getUseClientMode() {\n+            return false;\n+        }\n+        @Override\n+        public void setNeedClientAuth(boolean need) { }\n+        @Override\n+        public boolean getNeedClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setWantClientAuth(boolean want) { }\n+        @Override\n+        public boolean getWantClientAuth() {\n+            return false;\n+        }\n+        @Override\n+        public void setEnableSessionCreation(boolean flag) { }\n+        @Override\n+        public boolean getEnableSessionCreation() {\n+            return false;\n+        }\n+    }\n+\n+    static class SlowCloseSocketFactory extends SSLSocketFactory {\n+\n+        @Override\n+        public Socket createSocket() throws IOException {\n+            return new SlowCloseSocket();\n+        }\n+        \/\/ required abstract method overrides\n+        @Override\n+        public Socket createSocket(String host, int port) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException, UnknownHostException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress host, int port) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+        @Override\n+        public String[] getDefaultCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public String[] getSupportedCipherSuites() {\n+            return new String[0];\n+        }\n+        @Override\n+        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/sun\/net\/www\/http\/KeepAliveCache\/B8293562.java","additions":238,"deletions":0,"binary":false,"changes":238,"status":"added"}]}