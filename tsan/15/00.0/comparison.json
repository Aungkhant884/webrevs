{"files":[{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR JCOV, \\\n+    SINGLE_KEYWORDS := JOBS TIMEOUT_FACTOR JCOV JCOV_DIFF_CHANGESET, \\\n@@ -240,10 +240,0 @@\n-  ifeq ($(call isTargetCpuArch, sparc), true)\n-    # For smaller SPARC machines we see reasonable scaling of throughput up to\n-    # cpus\/4 without affecting test reliability. On the bigger machines, cpus\/4\n-    # causes intermittent timeouts.\n-    ifeq ($(shell $(EXPR) $(NUM_CORES) \\> 16), 1)\n-      CORES_DIVIDER := 5\n-    else\n-      CORES_DIVIDER := 4\n-    endif\n-  endif\n@@ -355,0 +345,1 @@\n+lib-test_JTREG_NATIVEPATH := $(TEST_IMAGE_DIR)\/lib-test\/jtreg\/native\n@@ -359,1 +350,1 @@\n-nashorn_JTREG_PROBLEM_LIST += $(TOPDIR)\/test\/nashorn\/ProblemList.txt\n+lib-test_JTREG_PROBLEM_LIST += $(TOPDIR)\/test\/lib-test\/ProblemList.txt\n@@ -694,2 +685,0 @@\n-  # Set library path for native dependencies\n-  $1_MICRO_JAVA_OPTIONS += -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native\n@@ -703,0 +692,3 @@\n+  # Set library path for native dependencies\n+  $1_JMH_JVM_ARGS := -Djava.library.path=$$(TEST_IMAGE_DIR)\/micro\/native\n+\n@@ -704,2 +696,1 @@\n-    JMH_JVM_ARGS := $$(MICRO_VM_OPTIONS) $$(MICRO_JAVA_OPTIONS)\n-    $1_MICRO_VM_OPTIONS := -jvmArgs $(call ShellQuote,$$(JMH_JVM_ARGS))\n+    $1_JMH_JVM_ARGS += $$(MICRO_VM_OPTIONS) $$(MICRO_JAVA_OPTIONS)\n@@ -708,0 +699,2 @@\n+  $1_MICRO_VM_OPTIONS := -jvmArgs $(call ShellQuote,$$($1_JMH_JVM_ARGS))\n+\n@@ -847,6 +840,2 @@\n-  # SPARC is in general slower per core so need to scale up timeouts a bit.\n-  ifeq ($(call isTargetCpuArch, sparc), true)\n-    JTREG_TIMEOUT_FACTOR ?= 8\n-  else\n-    JTREG_TIMEOUT_FACTOR ?= 4\n-  endif\n+  JTREG_TIMEOUT_FACTOR ?= 4\n+\n@@ -1061,1 +1050,1 @@\n-        TestMake.gmk $$($1_TEST_ARGS))\n+        TestMake.gmk $$($1_TEST_ARGS) TEST_SUPPORT_DIR=\"$$($1_TEST_SUPPORT_DIR)\")\n@@ -1278,0 +1267,26 @@\n+  ifneq ($(TEST_OPTS_JCOV_DIFF_CHANGESET), )\n+\n+    JCOV_SOURCE_DIFF := $(JCOV_OUTPUT_DIR)\/source_diff\n+    JCOV_DIFF_COVERAGE_REPORT := $(JCOV_OUTPUT_DIR)\/diff_coverage_report\n+\n+    ifneq ($(and $(HG), $(wildcard $(TOPDIR)\/.hg)), )\n+      DIFF_COMMAND := $(HG) -R $(TOPDIR) diff -r $(TEST_OPTS_JCOV_DIFF_CHANGESET) > $(JCOV_SOURCE_DIFF)\n+    else ifneq ($(and $(GIT), $(wildcard $(TOPDIR)\/.git)), )\n+      DIFF_COMMAND := $(GIT) -C $(TOPDIR) diff $(TEST_OPTS_JCOV_DIFF_CHANGESET) > $(JCOV_SOURCE_DIFF)\n+    else\n+      $(info Error: Must be either hg or git source tree for diff coverage.)\n+      $(error Neither hg nor git source tree.)\n+    endif\n+\n+    jcov-gen-diffcoverage: jcov-stop-grabber\n+\t$(call LogWarn, Generating diff coverage with changeset $(TEST_OPTS_JCOV_DIFF_CHANGESET) ... )\n+\t$(DIFF_COMMAND)\n+\t$(JAVA) -Xmx4g -jar $(JCOV_HOME)\/lib\/jcov.jar \\\n+\t  DiffCoverage -replaceDiff \"src\/.*\/classes\/:\" -all \\\n+\t    $(JCOV_RESULT_FILE) $(JCOV_SOURCE_DIFF) > \\\n+\t    $(JCOV_DIFF_COVERAGE_REPORT)\n+\n+    TARGETS += jcov-gen-diffcoverage\n+\n+  endif\n+\n@@ -1283,1 +1298,7 @@\n-  jcov-gen-report: run-all-tests\n+  ifneq ($(TEST_OPTS_JCOV_DIFF_CHANGESET), )\n+\n+    post-run-test: jcov-gen-diffcoverage\n+\n+  endif\n+\n+  jcov-stop-grabber: run-all-tests\n","filename":"make\/RunTests.gmk","additions":46,"deletions":25,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-    C_FLAG_REORDER=''\n-\n@@ -48,2 +46,0 @@\n-    C_FLAG_REORDER=''\n-\n@@ -74,9 +70,0 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    C_FLAG_REORDER='-xF'\n-    SHARED_LIBRARY_FLAGS=\"-G\"\n-    SET_EXECUTABLE_ORIGIN='-R\\$$ORIGIN[$]1'\n-    SET_SHARED_LIBRARY_ORIGIN=\"$SET_EXECUTABLE_ORIGIN\"\n-    SET_SHARED_LIBRARY_NAME='-h [$]1'\n-    SET_SHARED_LIBRARY_MAPFILE='-M[$]1'\n-\n-    C_FLAG_REORDER=''\n@@ -91,1 +78,0 @@\n-    C_FLAG_REORDER=''\n@@ -99,1 +85,0 @@\n-  AC_SUBST(C_FLAG_REORDER)\n@@ -120,3 +105,0 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    # -g0 enables debug symbols without disabling inlining.\n-    CFLAGS_DEBUG_SYMBOLS=\"-g0 -xs\"\n@@ -135,18 +117,2 @@\n-  AC_ARG_ENABLE([warnings-as-errors], [AS_HELP_STRING([--disable-warnings-as-errors],\n-      [do not consider native warnings to be an error @<:@enabled@:>@])])\n-\n-  if test \"x$TOOLCHAIN_TYPE\" = xxlc; then\n-    WARNINGS_AS_ERRORS=false\n-  else\n-    WARNINGS_AS_ERRORS=true\n-  fi\n-\n-  AC_MSG_CHECKING([if native warnings are errors])\n-  if test \"x$enable_warnings_as_errors\" = \"xyes\"; then\n-    AC_MSG_RESULT([yes (explicitly set)])\n-    WARNINGS_AS_ERRORS=true\n-  elif test \"x$enable_warnings_as_errors\" = \"xno\"; then\n-    AC_MSG_RESULT([no (explicitly set)])\n-    WARNINGS_AS_ERRORS=false\n-  elif test \"x$enable_warnings_as_errors\" = \"x\"; then\n-    AC_MSG_RESULT([${WARNINGS_AS_ERRORS} (default)])\n+  if test \"x$TOOLCHAIN_TYPE\" != xxlc; then\n+    WARNINGS_AS_ERRORS_DEFAULT=true\n@@ -155,1 +121,1 @@\n-    AC_MSG_ERROR([--enable-warnings-as-errors accepts no argument])\n+    WARNINGS_AS_ERRORS_DEFAULT=false\n@@ -158,0 +124,4 @@\n+  UTIL_ARG_ENABLE(NAME: warnings-as-errors, DEFAULT: $WARNINGS_AS_ERRORS_DEFAULT,\n+      RESULT: WARNINGS_AS_ERRORS,\n+      DEFAULT_DESC: [auto],\n+      DESC: [consider native warnings to be an error])\n@@ -169,11 +139,0 @@\n-    solstudio)\n-      DISABLE_WARNING_PREFIX=\"-erroff=\"\n-      CFLAGS_WARNINGS_ARE_ERRORS=\"-errwarn=%all\"\n-\n-      WARNINGS_ENABLE_ALL_CFLAGS=\"-v -fd -xtransition\"\n-      WARNINGS_ENABLE_ALL_CXXFLAGS=\"+w +w2\"\n-\n-      DISABLED_WARNINGS_C=\"E_OLD_STYLE_FUNC_DECL E_OLD_STYLE_FUNC_DEF E_SEMANTICS_OF_OP_CHG_IN_ANSI_C E_NO_REPLACEMENT_IN_STRING E_DECLARATION_IN_CODE\"\n-      DISABLED_WARNINGS_CXX=\"inllargeuse inllargeint notused wemptydecl notemsource\"\n-      ;;\n-\n@@ -259,19 +218,1 @@\n-  if test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    CC_HIGHEST=\"-fns -fsimple -fsingle -xbuiltin=%all -xdepend -xrestrict -xlibmil\"\n-\n-    C_O_FLAG_HIGHEST_JVM=\"-xO4\"\n-    C_O_FLAG_DEBUG_JVM=\"\"\n-    C_O_FLAG_SIZE=\"\"\n-    C_O_FLAG_DEBUG=\"\"\n-    C_O_FLAG_NONE=\"\"\n-    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xx86\"; then\n-      C_O_FLAG_HIGHEST=\"-xO4 -Wu,-O4~yz $CC_HIGHEST\"\n-      C_O_FLAG_HI=\"-xO4 -Wu,-O4~yz\"\n-      C_O_FLAG_NORM=\"-xO2 -Wu,-O2~yz\"\n-    elif test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xsparc\"; then\n-      C_O_FLAG_HIGHEST=\"-xO4 -Wc,-Qrm-s -Wc,-Qiselect-T0 \\\n-          -xprefetch=auto,explicit $CC_HIGHEST\"\n-      C_O_FLAG_HI=\"-xO4 -Wc,-Qrm-s -Wc,-Qiselect-T0\"\n-      C_O_FLAG_NORM=\"-xO2 -Wc,-Qrm-s -Wc,-Qiselect-T0\"\n-    fi\n-  elif test \"x$TOOLCHAIN_TYPE\" = xgcc; then\n+  if test \"x$TOOLCHAIN_TYPE\" = xgcc; then\n@@ -303,3 +244,1 @@\n-    if test \"x$OPENJDK_TARGET_OS\" = xmacosx || test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n-      # On MacOSX we optimize for size, something\n-      # we should do for all platforms?\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n@@ -351,5 +290,0 @@\n-  if test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    # In solstudio, also add this to C (but not C++) flags...\n-    C_O_FLAG_HIGHEST=\"$C_O_FLAG_HIGHEST -xalias_level=basic\"\n-  fi\n-\n@@ -448,3 +382,0 @@\n-  elif test \"x$OPENJDK_TARGET_OS\" = xsolaris; then\n-    CFLAGS_OS_DEF_JVM=\"-DSOLARIS\"\n-    CFLAGS_OS_DEF_JDK=\"-D__solaris__\"\n@@ -486,3 +417,0 @@\n-    if test \"x$OPENJDK_TARGET_OS\" = xsolaris; then\n-      DEBUG_CFLAGS_JDK=\"$DEBUG_CFLAGS_JDK -DTRIMMED\"\n-    fi\n@@ -511,4 +439,0 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    ALWAYS_DEFINES_JVM=\"-DSPARC_WORKS -D_Crun_inline_placement\"\n-    ALWAYS_DEFINES_JDK=\"-DTRACING -DMACRO_MEMSYS_OPS -DBREAKPTS\"\n-    ALWAYS_DEFINES_JDK_CXXONLY=\"-DCC_NOEX\"\n@@ -577,14 +501,0 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    TOOLCHAIN_FLAGS=\"-errtags -errfmt\"\n-    TOOLCHAIN_CFLAGS=\"-errshort=tags\"\n-\n-    TOOLCHAIN_CFLAGS_JDK=\"-mt $TOOLCHAIN_FLAGS\"\n-    TOOLCHAIN_CFLAGS_JDK_CONLY=\"-W0,-noglobal $TOOLCHAIN_CFLAGS\" # C only\n-    TOOLCHAIN_CFLAGS_JDK_CXXONLY=\"-features=no%except -norunpath -xnolib\" # CXX only\n-    TOOLCHAIN_CFLAGS_JVM=\"-template=no%extdef -features=no%split_init \\\n-        -library=stlport4 -mt -features=no%except $TOOLCHAIN_FLAGS\"\n-    if test \"x$DEBUG_LEVEL\" = xslowdebug; then\n-      # Previously -g was used instead of -g0 for slowdebug; this is equivalent\n-      # to setting +d.\n-      TOOLCHAIN_CFLAGS_JVM=\"$TOOLCHAIN_CFLAGS_JVM +d\"\n-    fi\n@@ -611,5 +521,0 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    # We can't turn on -std=c99 without breaking compilation of the splashscreen\/png\n-    # utilities. But we can enable c99 as below (previously achieved by using -Xa).\n-    # It is the no_lib that makes the difference.\n-    LANGSTD_CFLAGS=\"-xc99=all,no_lib\"\n@@ -636,5 +541,0 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    WARNING_CFLAGS_JDK_CONLY=\"$WARNINGS_ENABLE_ALL_CFLAGS\"\n-    WARNING_CFLAGS_JDK_CXXONLY=\"$WARNINGS_ENABLE_ALL_CXXFLAGS\"\n-    WARNING_CFLAGS_JVM=\"$WARNINGS_ENABLE_ALL_CXXFLAGS\"\n-\n@@ -664,2 +564,1 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    PICFLAG=\"-KPIC\"\n+    PIEFLAG=\"-fPIE\"\n@@ -720,1 +619,4 @@\n-    STATIC_LIBS_CFLAGS=\"$STATIC_LIBS_CFLAGS -ffunction-sections -fdata-sections\"\n+    STATIC_LIBS_CFLAGS=\"$STATIC_LIBS_CFLAGS -ffunction-sections -fdata-sections \\\n+      -DJNIEXPORT='__attribute__((visibility(\\\"hidden\\\")))'\"\n+  else\n+    STATIC_LIBS_CFLAGS=\"$STATIC_LIBS_CFLAGS -DJNIEXPORT=\"\n@@ -744,9 +646,1 @@\n-  fi\n-  if test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    # The macro _LITTLE_ENDIAN needs to be defined the same to avoid the\n-    #   Sun C compiler warning message: warning: macro redefined: _LITTLE_ENDIAN\n-    if test \"x$FLAGS_CPU_ENDIAN\" = xlittle; then\n-      $1_DEFINES_CPU_JDK=\"-D_LITTLE_ENDIAN=\"\n-    else\n-      $1_DEFINES_CPU_JDK=\"-D_BIG_ENDIAN=\"\n-    fi\n+    $1_DEFINES_CPU_JDK=\"-D_LITTLE_ENDIAN\"\n@@ -754,5 +648,1 @@\n-    if test \"x$FLAGS_CPU_ENDIAN\" = xlittle; then\n-      $1_DEFINES_CPU_JDK=\"-D_LITTLE_ENDIAN\"\n-    else\n-      $1_DEFINES_CPU_JDK=\"-D_BIG_ENDIAN\"\n-    fi\n+    $1_DEFINES_CPU_JDK=\"-D_BIG_ENDIAN\"\n@@ -771,2 +661,1 @@\n-    if test \"x$FLAGS_OS\" != xsolaris && test \"x$FLAGS_OS\" != xaix; then\n-      # Solaris does not have _LP64=1 in the old build.\n+    if test \"x$FLAGS_OS\" != xaix; then\n@@ -779,5 +668,1 @@\n-  if test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    if test \"x$FLAGS_CPU_ARCH\" = xx86; then\n-      $1_DEFINES_CPU_JDK=\"${$1_DEFINES_CPU_JDK} -DcpuIntel -Di586 -D$FLAGS_CPU_LEGACY_LIB\"\n-    fi\n-  elif test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n+  if test \"x$TOOLCHAIN_TYPE\" = xmicrosoft; then\n@@ -801,1 +686,4 @@\n-    if test \"x$FLAGS_CPU\" = xarm; then\n+    if test \"x$FLAGS_CPU\" = xaarch64; then\n+      # -Wno-psabi to get rid of annoying \"note: parameter passing for argument of type '<type> changed in GCC 9.1\"\n+      $1_CFLAGS_CPU=\"-Wno-psabi\"\n+    elif test \"x$FLAGS_CPU\" = xarm; then\n@@ -841,9 +729,0 @@\n-  elif test \"x$TOOLCHAIN_TYPE\" = xsolstudio; then\n-    if test \"x$FLAGS_CPU\" = xx86_64; then\n-      # NOTE: -xregs=no%frameptr is supposed to be default on x64\n-      $1_CFLAGS_CPU_JDK=\"-xregs=no%frameptr\"\n-    elif test \"x$FLAGS_CPU\" = xsparcv9; then\n-      $1_CFLAGS_CPU_JVM=\"-xarch=sparc\"\n-      $1_CFLAGS_CPU_JDK_LIBONLY=\"-xregs=no%appl\"\n-    fi\n-\n@@ -874,11 +753,19 @@\n-  if test \"x$TOOLCHAIN_TYPE\" = xgcc || test \"x$TOOLCHAIN_TYPE\" = xclang; then\n-    # Check if compiler supports -fmacro-prefix-map. If so, use that to make\n-    # the __FILE__ macro resolve to paths relative to the workspace root.\n-    workspace_root_trailing_slash=\"${WORKSPACE_ROOT%\/}\/\"\n-    FILE_MACRO_CFLAGS=\"-fmacro-prefix-map=${workspace_root_trailing_slash}=\"\n-    FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${FILE_MACRO_CFLAGS}],\n-        PREFIX: $3,\n-        IF_FALSE: [\n-            FILE_MACRO_CFLAGS=\n-        ]\n-    )\n+  # Prevent the __FILE__ macro from generating absolute paths into the built\n+  # binaries. Depending on toolchain, different mitigations are possible.\n+  # * GCC and Clang of new enough versions have -fmacro-prefix-map.\n+  # * For most other toolchains, supplying all source files and -I flags as\n+  #   relative paths fixes the issue.\n+  FILE_MACRO_CFLAGS=\n+  if test \"x$ALLOW_ABSOLUTE_PATHS_IN_OUTPUT\" = \"xfalse\"; then\n+    if test \"x$TOOLCHAIN_TYPE\" = xgcc || test \"x$TOOLCHAIN_TYPE\" = xclang; then\n+      # Check if compiler supports -fmacro-prefix-map. If so, use that to make\n+      # the __FILE__ macro resolve to paths relative to the workspace root.\n+      workspace_root_trailing_slash=\"${WORKSPACE_ROOT%\/}\/\"\n+      FILE_MACRO_CFLAGS=\"-fmacro-prefix-map=${workspace_root_trailing_slash}=\"\n+      FLAGS_COMPILER_CHECK_ARGUMENTS(ARGUMENT: [${FILE_MACRO_CFLAGS}],\n+          PREFIX: $3,\n+          IF_FALSE: [\n+              FILE_MACRO_CFLAGS=\n+          ]\n+      )\n+    fi\n@@ -886,0 +773,1 @@\n+  AC_SUBST(FILE_MACRO_CFLAGS)\n@@ -914,4 +802,6 @@\n-  $2CFLAGS_JDKEXE=\"$CFLAGS_JDK_COMMON $CFLAGS_JDK_COMMON_CONLY ${$1_CFLAGS_JDK}\"\n-  $2CXXFLAGS_JDKEXE=\"$CFLAGS_JDK_COMMON $CFLAGS_JDK_COMMON_CXXONLY ${$1_CFLAGS_JDK}\"\n-  $2CFLAGS_JDKLIB=\"${$2CFLAGS_JDKEXE} $JDK_PICFLAG ${$1_CFLAGS_CPU_JDK_LIBONLY}\"\n-  $2CXXFLAGS_JDKLIB=\"${$2CXXFLAGS_JDKEXE} $JDK_PICFLAG ${$1_CFLAGS_CPU_JDK_LIBONLY}\"\n+  $2CFLAGS_JDKEXE=\"$CFLAGS_JDK_COMMON $CFLAGS_JDK_COMMON_CONLY ${$1_CFLAGS_JDK} $PIEFLAG\"\n+  $2CXXFLAGS_JDKEXE=\"$CFLAGS_JDK_COMMON $CFLAGS_JDK_COMMON_CXXONLY ${$1_CFLAGS_JDK} $PIEFLAG\"\n+  $2CFLAGS_JDKLIB=\"$CFLAGS_JDK_COMMON $CFLAGS_JDK_COMMON_CONLY ${$1_CFLAGS_JDK} \\\n+      $JDK_PICFLAG ${$1_CFLAGS_CPU_JDK_LIBONLY}\"\n+  $2CXXFLAGS_JDKLIB=\"$CFLAGS_JDK_COMMON $CFLAGS_JDK_COMMON_CXXONLY ${$1_CFLAGS_JDK} \\\n+      $JDK_PICFLAG ${$1_CFLAGS_CPU_JDK_LIBONLY}\"\n@@ -960,24 +850,0 @@\n-\n-# Documentation on common flags used for solstudio in HIGHEST.\n-#\n-# WARNING: Use of OPTIMIZATION_LEVEL=HIGHEST in your Makefile needs to be\n-#          done with care, there are some assumptions below that need to\n-#          be understood about the use of pointers, and IEEE behavior.\n-#\n-# -fns: Use non-standard floating point mode (not IEEE 754)\n-# -fsimple: Do some simplification of floating point arithmetic (not IEEE 754)\n-# -fsingle: Use single precision floating point with 'float'\n-# -xalias_level=basic: Assume memory references via basic pointer types do not alias\n-#   (Source with excessing pointer casting and data access with mixed\n-#    pointer types are not recommended)\n-# -xbuiltin=%all: Use intrinsic or inline versions for math\/std functions\n-#   (If you expect perfect errno behavior, do not use this)\n-# -xdepend: Loop data dependency optimizations (need -xO3 or higher)\n-# -xrestrict: Pointer parameters to functions do not overlap\n-#   (Similar to -xalias_level=basic usage, but less obvious sometimes.\n-#    If you pass in multiple pointers to the same data, do not use this)\n-# -xlibmil: Inline some library routines\n-#   (If you expect perfect errno behavior, do not use this)\n-# -xlibmopt: Use optimized math routines (CURRENTLY DISABLED)\n-#   (If you expect perfect errno behavior, do not use this)\n-#  Can cause undefined external on Solaris 8 X86 on __sincos, removing for now\n","filename":"make\/autoconf\/flags-cflags.m4","additions":48,"deletions":182,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -0,0 +1,722 @@\n+#\n+# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+###############################################################################\n+# Terminology used in this file:\n+#\n+# Valid features      == All possible features that the JVM knows about.\n+# Deprecated features == Previously known features (not considered valid).\n+# Available features  == Features that are possible to use in this configuration.\n+# Default features    == Features that are on by default in this configuration.\n+# Enabled features    == Features requested by the user to be present.\n+# Disabled features   == Features excluded from being used by the user.\n+# Active features     == The exact set of features to be used for a JVM variant.\n+#\n+# All valid features are considered available, unless listed as unavailable.\n+# All available features will be turned on as default, unless listed in a filter.\n+###############################################################################\n+\n+# We need these as m4 defines to be able to loop over them using m4 later on.\n+\n+# All valid JVM features, regardless of platform\n+m4_define(jvm_features_valid, m4_normalize( \\\n+    ifdef([custom_jvm_features_valid], custom_jvm_features_valid) \\\n+    \\\n+    aot cds compiler1 compiler2 dtrace epsilongc g1gc graal jfr jni-check \\\n+    jvmci jvmti link-time-opt management minimal nmt opt-size parallelgc \\\n+    serialgc services shenandoahgc static-build tsan vm-structs zero zgc \\\n+))\n+\n+# Deprecated JVM features (these are ignored, but with a warning)\n+m4_define(jvm_features_deprecated, m4_normalize(\n+    cmsgc trace \\\n+))\n+\n+# Feature descriptions\n+m4_define(jvm_feature_desc_aot, [enable ahead of time compilation (AOT)])\n+m4_define(jvm_feature_desc_cds, [enable class data sharing (CDS)])\n+m4_define(jvm_feature_desc_compiler1, [enable hotspot compiler C1])\n+m4_define(jvm_feature_desc_compiler2, [enable hotspot compiler C2])\n+m4_define(jvm_feature_desc_dtrace, [enable dtrace support])\n+m4_define(jvm_feature_desc_epsilongc, [include the epsilon (no-op) garbage collector])\n+m4_define(jvm_feature_desc_g1gc, [include the G1 garbage collector])\n+m4_define(jvm_feature_desc_graal, [enable Graal (jdk.internal.vm.compiler)])\n+m4_define(jvm_feature_desc_jfr, [enable JDK Flight Recorder (JFR)])\n+m4_define(jvm_feature_desc_jni_check, [enable -Xcheck:jni support])\n+m4_define(jvm_feature_desc_jvmci, [enable JVM Compiler Interface (JVMCI)])\n+m4_define(jvm_feature_desc_jvmti, [enable Java Virtual Machine Tool Interface (JVM TI)])\n+m4_define(jvm_feature_desc_link_time_opt, [enable link time optimization])\n+m4_define(jvm_feature_desc_management, [enable java.lang.management API support])\n+m4_define(jvm_feature_desc_minimal, [support building variant 'minimal'])\n+m4_define(jvm_feature_desc_nmt, [include native memory tracking (NMT)])\n+m4_define(jvm_feature_desc_opt_size, [optimize the JVM library for size])\n+m4_define(jvm_feature_desc_parallelgc, [include the parallel garbage collector])\n+m4_define(jvm_feature_desc_serialgc, [include the serial garbage collector])\n+m4_define(jvm_feature_desc_services, [enable diagnostic services and client attaching])\n+m4_define(jvm_feature_desc_shenandoahgc, [include the Shenandoah garbage collector])\n+m4_define(jvm_feature_desc_static_build, [build static library instead of dynamic])\n+m4_define(jvm_feature_desc_tsan, [enable ThreadSanitizer support])\n+m4_define(jvm_feature_desc_vm_structs, [export JVM structures to the Serviceablility Agent])\n+m4_define(jvm_feature_desc_zero, [support building variant 'zero'])\n+m4_define(jvm_feature_desc_zgc, [include the Z garbage collector])\n+\n+###############################################################################\n+# Parse command line options for JVM feature selection. After this function\n+# has run $JVM_FEATURES_ENABLED, $JVM_FEATURES_DISABLED and $JVM_FEATURES_VALID\n+# can be used.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_PARSE_OPTIONS],\n+[\n+  # Setup shell variables from the m4 lists\n+  UTIL_SORT_LIST(JVM_FEATURES_VALID, \"jvm_features_valid\")\n+  UTIL_SORT_LIST(JVM_FEATURES_DEPRECATED, \"jvm_features_deprecated\")\n+\n+  # For historical reasons, some jvm features have their own, shorter names.\n+  # Keep those as aliases for the --enable-jvm-feature-* style arguments.\n+  UTIL_ALIASED_ARG_ENABLE(aot, --enable-jvm-feature-aot)\n+  UTIL_ALIASED_ARG_ENABLE(cds, --enable-jvm-feature-cds)\n+  UTIL_ALIASED_ARG_ENABLE(dtrace, --enable-jvm-feature-dtrace)\n+\n+  # First check for features using the\n+  # --with-jvm-features=\"<[-]feature>[,<[-]feature> ...]\" syntax.\n+  AC_ARG_WITH([jvm-features], [AS_HELP_STRING([--with-jvm-features],\n+      [JVM features to enable (foo) or disable (-foo), separated by comma. Use\n+      '--help' to show possible values @<:@none@:>@])])\n+  if test \"x$with_jvm_features\" != x; then\n+    # Replace \",\"  with \" \".\n+    user_jvm_feature_list=${with_jvm_features\/\/,\/ }\n+    JVM_FEATURES_ENABLED=`$ECHO $user_jvm_feature_list | \\\n+        $AWK '{ for (i=1; i<=NF; i++) if (!match($i, \/^-.*\/)) printf(\"%s \", $i) }'`\n+    JVM_FEATURES_DISABLED=`$ECHO $user_jvm_feature_list | \\\n+        $AWK '{ for (i=1; i<=NF; i++) if (match($i, \/^-.*\/)) printf(\"%s \", substr($i, 2))}'`\n+\n+    # Verify that the user has provided only valid (or deprecated) features\n+    UTIL_GET_NON_MATCHING_VALUES(invalid_features, $JVM_FEATURES_ENABLED \\\n+        $JVM_FEATURES_DISABLED, $JVM_FEATURES_VALID $JVM_FEATURES_DEPRECATED)\n+    if test \"x$invalid_features\" != x; then\n+      AC_MSG_NOTICE([Unknown JVM features specified: '$invalid_features'])\n+      AC_MSG_NOTICE([The available JVM features are: '$JVM_FEATURES_VALID'])\n+      AC_MSG_ERROR([Cannot continue])\n+    fi\n+\n+    # Check if the user has provided deprecated features\n+    UTIL_GET_MATCHING_VALUES(deprecated_features, $JVM_FEATURES_ENABLED \\\n+        $JVM_FEATURES_DISABLED, $JVM_FEATURES_DEPRECATED)\n+    if test \"x$deprecated_features\" != x; then\n+      AC_MSG_WARN([Deprecated JVM features specified (will be ignored): '$deprecated_features'])\n+      # Filter out deprecated features\n+      UTIL_GET_NON_MATCHING_VALUES(JVM_FEATURES_ENABLED, \\\n+          $JVM_FEATURES_ENABLED, $deprecated_features)\n+      UTIL_GET_NON_MATCHING_VALUES(JVM_FEATURES_DISABLED, \\\n+          $JVM_FEATURES_DISABLED, $deprecated_features)\n+    fi\n+  fi\n+\n+  # Then check for features using the \"--enable-jvm-feature-<feature>\" syntax.\n+  # Using m4, loop over all features with the variable FEATURE.\n+  m4_foreach(FEATURE, m4_split(jvm_features_valid), [\n+    # Create an m4 variable containing a shell variable name (like\n+    # \"enable_jvm_feature_static_build\"), and the description.\n+    m4_define(FEATURE_SHELL, [enable_jvm_feature_]m4_translit(FEATURE, -, _))\n+    m4_define(FEATURE_DESCRIPTION, [jvm_feature_desc_]m4_translit(FEATURE, -, _))\n+\n+    AC_ARG_ENABLE(jvm-feature-FEATURE, AS_HELP_STRING(\n+        [--enable-jvm-feature-FEATURE], [enable jvm feature 'FEATURE' (FEATURE_DESCRIPTION)]))\n+\n+    if test \"x$FEATURE_SHELL\" = xyes; then\n+      JVM_FEATURES_ENABLED=\"$JVM_FEATURES_ENABLED FEATURE\"\n+    elif test \"x$FEATURE_SHELL\" = xno; then\n+      JVM_FEATURES_DISABLED=\"$JVM_FEATURES_DISABLED FEATURE\"\n+    elif test \"x$FEATURE_SHELL\" != x; then\n+      AC_MSG_ERROR([Invalid value for --enable-jvm-feature-FEATURE: '$FEATURE_SHELL'])\n+    fi\n+\n+    m4_undefine([FEATURE_SHELL])\n+    m4_undefine([FEATURE_DESCRIPTION])\n+  ])\n+\n+  # Likewise, check for deprecated arguments.\n+  m4_foreach(FEATURE, m4_split(jvm_features_deprecated), [\n+    AC_ARG_ENABLE(jvm-feature-FEATURE, AS_HELP_STRING(\n+        [--enable-jvm-feature-FEATURE], \n+        [Deprecated. Option is kept for backwards compatibility and is ignored]))\n+\n+    m4_define(FEATURE_SHELL, [enable_jvm_feature_]m4_translit(FEATURE, -, _))\n+\n+    if test \"x$FEATURE_SHELL\" != x; then\n+      AC_MSG_WARN([Deprecated JVM feature, will be ignored: --enable-jvm-feature-FEATURE])\n+    fi\n+\n+    m4_undefine([FEATURE_SHELL])\n+  ])\n+\n+  # Check if the user has both enabled and disabled a feature\n+  UTIL_GET_MATCHING_VALUES(enabled_and_disabled, $JVM_FEATURES_ENABLED, \\\n+      $JVM_FEATURES_DISABLED)\n+  if test \"x$enabled_and_disabled\" != x; then\n+    AC_MSG_NOTICE([These feature are both enabled and disabled: '$enabled_and_disabled'])\n+    AC_MSG_NOTICE([This can happen if you mix --with-jvm-features and --enable-jvm-feature-*])\n+    AC_MSG_NOTICE([The recommendation is to only use --enable-jvm-feature-*])\n+    AC_MSG_ERROR([Cannot continue])\n+  fi\n+\n+  # Clean up lists and announce results to user\n+  UTIL_SORT_LIST(JVM_FEATURES_ENABLED, $JVM_FEATURES_ENABLED)\n+  AC_MSG_CHECKING([for JVM features enabled by the user])\n+  if test \"x$JVM_FEATURES_ENABLED\" != x; then\n+    AC_MSG_RESULT(['$JVM_FEATURES_ENABLED'])\n+  else\n+    AC_MSG_RESULT([none])\n+  fi\n+\n+  UTIL_SORT_LIST(JVM_FEATURES_DISABLED, $JVM_FEATURES_DISABLED)\n+  AC_MSG_CHECKING([for JVM features disabled by the user])\n+  if test \"x$JVM_FEATURES_DISABLED\" != x; then\n+    AC_MSG_RESULT(['$JVM_FEATURES_DISABLED'])\n+  else\n+    AC_MSG_RESULT([none])\n+  fi\n+\n+  # Makefiles use VALID_JVM_FEATURES in check-jvm-feature to verify correctness.\n+  VALID_JVM_FEATURES=\"$JVM_FEATURES_VALID\"\n+  AC_SUBST(VALID_JVM_FEATURES)\n+])\n+\n+###############################################################################\n+# Helper function for the JVM_FEATURES_CHECK_* suite.\n+# The code in the code block should assign 'false' to the variable AVAILABLE\n+# if the feature is not available, and this function will handle everything\n+# else that is needed.\n+#\n+# arg 1: The name of the feature to test\n+# arg 2: The code block to execute\n+#\n+AC_DEFUN([JVM_FEATURES_CHECK_AVAILABILITY],\n+[\n+  # Assume that feature is available\n+  AVAILABLE=true\n+\n+  # Execute feature test block\n+  $2\n+\n+  AC_MSG_CHECKING([if JVM feature '$1' is available])\n+  if test \"x$AVAILABLE\" = \"xtrue\"; then\n+    AC_MSG_RESULT([yes])\n+  else\n+    AC_MSG_RESULT([no])\n+    JVM_FEATURES_PLATFORM_UNAVAILABLE=\"$JVM_FEATURES_PLATFORM_UNAVAILABLE $1\"\n+  fi\n+])\n+\n+###############################################################################\n+# Check if the feature 'aot' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_AOT],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(aot, [\n+    AC_MSG_CHECKING([if platform is supported by AOT])\n+    # AOT is only available where JVMCI is available since it requires JVMCI.\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+\n+    AC_MSG_CHECKING([if AOT source code is present])\n+    if test -e \"${TOPDIR}\/src\/jdk.internal.vm.compiler\" && \\\n+        test -e \"${TOPDIR}\/src\/jdk.aot\"; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, missing src\/jdk.internal.vm.compiler or src\/jdk.aot])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'cds' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_CDS],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(cds, [\n+    AC_MSG_CHECKING([if platform is supported by CDS])\n+    if test \"x$OPENJDK_TARGET_OS\" != xaix; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'dtrace' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_DTRACE],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(dtrace, [\n+    AC_MSG_CHECKING([for dtrace tool])\n+    if test \"x$DTRACE\" != \"x\" && test -x \"$DTRACE\"; then\n+      AC_MSG_RESULT([$DTRACE])\n+    else\n+      AC_MSG_RESULT([no])\n+      AVAILABLE=false\n+    fi\n+\n+    AC_CHECK_HEADERS([sys\/sdt.h], [dtrace_headers_ok=true])\n+    if test \"x$dtrace_headers_ok\" != \"xtrue\"; then\n+      HELP_MSG_MISSING_DEPENDENCY([dtrace])\n+      AC_MSG_NOTICE([Cannot enable dtrace with missing dependencies. See above.])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'graal' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_GRAAL],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(graal, [\n+    AC_MSG_CHECKING([if platform is supported by Graal])\n+    # Graal is only available where JVMCI is available since it requires JVMCI.\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'jfr' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_JFR],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(jfr, [\n+    AC_MSG_CHECKING([if platform is supported by JFR])\n+    if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    else\n+      AC_MSG_RESULT([yes])\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'jvmci' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_JVMCI],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(jvmci, [\n+    AC_MSG_CHECKING([if platform is supported by JVMCI])\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'shenandoahgc' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_SHENANDOAHGC],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(shenandoahgc, [\n+    AC_MSG_CHECKING([if platform is supported by Shenandoah])\n+    if test \"x$OPENJDK_TARGET_CPU_ARCH\" = \"xx86\" || \\\n+        test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\" ; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'static-build' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_STATIC_BUILD],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(static-build, [\n+    AC_MSG_CHECKING([if static-build is enabled in configure])\n+    if test \"x$STATIC_BUILD\" = \"xtrue\"; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, use --enable-static-build to enable static build.])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Check if the feature 'tsan' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_TSAN],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(tsan, [\n+    AC_MSG_CHECKING([if platform is supported by TSAN])\n+    if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\" && \\\n+        (test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n+         test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"); then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Support for --<enable|disable>-tsan-launcher flag.\n+#\n+# TODO(tsan-dev): Ideally we should use AC_DEFUN_ONCE. However, with AC_DEFUN_ONCE,\n+# we cannot read variables such as $INCLUDE_TSAN or $JVM_FEATURES_ACTIVE. They would\n+# become empty value.\n+AC_DEFUN([JVM_FEATURES_TSAN_LAUNCHER_FLAG],\n+[\n+  # Add a configure option --<enable|disable>-tsan-launcher to allow\n+  # more control on whether to link TSAN runtime with the launcher.\n+  AC_ARG_ENABLE(tsan-launcher, AS_HELP_STRING(\n+        [--enable-tsan-launcher],\n+        [link tsan runtime with the default JDK launcher. Default is consistent with whether tsan feature is enabled.]))\n+  AC_MSG_CHECKING([if tsan should be linked with JDK launcher])\n+  if test \"x$INCLUDE_TSAN\" = \"xtrue\"; then\n+    if test \"x$enable_tsan_launcher\" = \"xno\"; then\n+      AC_MSG_RESULT([no, forced])\n+      INCLUDE_TSAN=\"false\"\n+    else\n+      AC_MSG_RESULT([yes])\n+    fi\n+  else\n+    AC_MSG_RESULT([no, tsan feature is disabled])\n+    if test \"x$enable_tsan_launcher\" = \"xyes\"; then\n+      AC_MSG_ERROR([--enable-tsan-launcher can only be used when tsan feature is enabled.])\n+    fi\n+  fi\n+])\n+\n+###############################################################################\n+# Check if the feature 'zgc' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_ZGC],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(zgc, [\n+    AC_MSG_CHECKING([if platform is supported by ZGC])\n+    if test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\"; then\n+      if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\" || \\\n+          test \"x$OPENJDK_TARGET_OS\" = \"xwindows\" || \\\n+          test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\"; then\n+        AC_MSG_RESULT([yes])\n+      else\n+        AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n+        AVAILABLE=false\n+      fi\n+    elif test \"x$OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU\" = \"xlinux-aarch64\"; then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+\n+    if test \"x$OPENJDK_TARGET_OS\" = \"xwindows\"; then\n+      AC_MSG_CHECKING([if Windows APIs required for ZGC is present])\n+      AC_COMPILE_IFELSE(\n+        [AC_LANG_PROGRAM([[#include <windows.h>]],\n+          [[struct MEM_EXTENDED_PARAMETER x;]])\n+        ],\n+        [\n+          AC_MSG_RESULT([yes])\n+        ],\n+        [\n+          AC_MSG_RESULT([no, missing required APIs])\n+          AVAILABLE=false\n+        ]\n+      )\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Setup JVM_FEATURES_PLATFORM_UNAVAILABLE and JVM_FEATURES_PLATFORM_FILTER\n+# to contain those features that are unavailable, or should be off by default,\n+# for this platform, regardless of JVM variant.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_PREPARE_PLATFORM],\n+[\n+  # The checks below should add unavailable features to\n+  # JVM_FEATURES_PLATFORM_UNAVAILABLE.\n+\n+  JVM_FEATURES_CHECK_AOT\n+  JVM_FEATURES_CHECK_CDS\n+  JVM_FEATURES_CHECK_DTRACE\n+  JVM_FEATURES_CHECK_GRAAL\n+  JVM_FEATURES_CHECK_JFR\n+  JVM_FEATURES_CHECK_JVMCI\n+  JVM_FEATURES_CHECK_SHENANDOAHGC\n+  JVM_FEATURES_CHECK_STATIC_BUILD\n+  JVM_FEATURES_CHECK_TSAN\n+  JVM_FEATURES_CHECK_ZGC\n+\n+  # Filter out features by default for all variants on certain platforms.\n+  # Make sure to just add to JVM_FEATURES_PLATFORM_FILTER, since it could\n+  # have a value already from custom extensions.\n+  if test \"x$OPENJDK_TARGET_OS\" = xaix; then\n+    JVM_FEATURES_PLATFORM_FILTER=\"$JVM_FEATURES_PLATFORM_FILTER jfr\"\n+  fi\n+])\n+\n+###############################################################################\n+# Setup JVM_FEATURES_VARIANT_UNAVAILABLE and JVM_FEATURES_VARIANT_FILTER\n+# to contain those features that are unavailable, or should be off by default,\n+# for this particular JVM variant.\n+#\n+# arg 1: JVM variant\n+#\n+AC_DEFUN([JVM_FEATURES_PREPARE_VARIANT],\n+[\n+  variant=$1\n+\n+  # Check which features are unavailable for this JVM variant.\n+  # This means that is not possible to build these features for this variant.\n+  if test \"x$variant\" = \"xminimal\"; then\n+    JVM_FEATURES_VARIANT_UNAVAILABLE=\"cds zero\"\n+  elif test \"x$variant\" = \"xcore\"; then\n+    JVM_FEATURES_VARIANT_UNAVAILABLE=\"cds minimal zero\"\n+  elif test \"x$variant\" = \"xzero\"; then\n+    JVM_FEATURES_VARIANT_UNAVAILABLE=\"aot cds compiler1 compiler2 \\\n+        epsilongc g1gc graal jvmci minimal shenandoahgc zgc\"\n+  else\n+    JVM_FEATURES_VARIANT_UNAVAILABLE=\"minimal zero\"\n+  fi\n+\n+  # Check which features should be off by default for this JVM variant.\n+  if test \"x$variant\" = \"xclient\"; then\n+    JVM_FEATURES_VARIANT_FILTER=\"aot compiler2 graal jvmci link-time-opt opt-size\"\n+  elif test \"x$variant\" = \"xminimal\"; then\n+    JVM_FEATURES_VARIANT_FILTER=\"aot cds compiler2 dtrace epsilongc g1gc \\\n+        graal jfr jni-check jvmci jvmti management nmt parallelgc services \\\n+        shenandoahgc vm-structs zgc\"\n+    if test \"x$OPENJDK_TARGET_CPU\" = xarm ; then\n+      JVM_FEATURES_VARIANT_FILTER=\"$JVM_FEATURES_VARIANT_FILTER opt-size\"\n+    else\n+      # Only arm-32 should have link-time-opt enabled as default.\n+      JVM_FEATURES_VARIANT_FILTER=\"$JVM_FEATURES_VARIANT_FILTER \\\n+          link-time-opt\"\n+    fi\n+  elif test \"x$variant\" = \"xcore\"; then\n+    JVM_FEATURES_VARIANT_FILTER=\"aot compiler1 compiler2 graal jvmci \\\n+        link-time-opt opt-size\"\n+  elif test \"x$variant\" = \"xzero\"; then\n+    JVM_FEATURES_VARIANT_FILTER=\"jfr link-time-opt opt-size\"\n+  else\n+    JVM_FEATURES_VARIANT_FILTER=\"link-time-opt opt-size\"\n+  fi\n+])\n+\n+###############################################################################\n+# Calculate the actual set of active JVM features for this JVM variant. Store\n+# the result in JVM_FEATURES_ACTIVE.\n+#\n+# arg 1: JVM variant\n+#\n+AC_DEFUN([JVM_FEATURES_CALCULATE_ACTIVE],\n+[\n+  variant=$1\n+\n+  # The default is set to all valid features except those unavailable or listed\n+  # in a filter.\n+  if test \"x$variant\" != xcustom; then\n+    UTIL_GET_NON_MATCHING_VALUES(default_for_variant, $JVM_FEATURES_VALID, \\\n+        $JVM_FEATURES_PLATFORM_UNAVAILABLE $JVM_FEATURES_VARIANT_UNAVAILABLE \\\n+        $JVM_FEATURES_PLATFORM_FILTER $JVM_FEATURES_VARIANT_FILTER)\n+  else\n+    # Except for the 'custom' variant, where the default is to start with an\n+    # empty set.\n+    default_for_variant=\"\"\n+  fi\n+\n+  # Verify that explicitly enabled features are available\n+  UTIL_GET_MATCHING_VALUES(enabled_but_unavailable, $JVM_FEATURES_ENABLED, \\\n+      $JVM_FEATURES_PLATFORM_UNAVAILABLE $JVM_FEATURES_VARIANT_UNAVAILABLE)\n+  if test \"x$enabled_but_unavailable\" != x; then\n+    AC_MSG_NOTICE([ERROR: Unavailable JVM features explicitly enabled for '$variant': '$enabled_but_unavailable'])\n+    AC_MSG_ERROR([Cannot continue])\n+  fi\n+\n+  # Notify the user if their command line options has no real effect\n+  UTIL_GET_MATCHING_VALUES(enabled_but_default, $JVM_FEATURES_ENABLED, \\\n+      $default_for_variant)\n+  if test \"x$enabled_but_default\" != x; then\n+    AC_MSG_NOTICE([Default JVM features explicitly enabled for '$variant': '$enabled_but_default'])\n+  fi\n+  UTIL_GET_MATCHING_VALUES(disabled_but_unavailable, $JVM_FEATURES_DISABLED, \\\n+      $JVM_FEATURES_PLATFORM_UNAVAILABLE $JVM_FEATURES_VARIANT_UNAVAILABLE)\n+  if test \"x$disabled_but_unavailable\" != x; then\n+    AC_MSG_NOTICE([Unavailable JVM features explicitly disabled for '$variant': '$disabled_but_unavailable'])\n+  fi\n+\n+  # JVM_FEATURES_ACTIVE is the set of all default features and all explicitly\n+  # enabled features, with the explicitly disabled features filtered out.\n+  UTIL_GET_NON_MATCHING_VALUES(JVM_FEATURES_ACTIVE, $default_for_variant \\\n+      $JVM_FEATURES_ENABLED, $JVM_FEATURES_DISABLED)\n+])\n+\n+###############################################################################\n+# Helper function for JVM_FEATURES_VERIFY. Check if the specified JVM\n+# feature is active. To be used in shell if constructs, like this:\n+# 'if JVM_FEATURES_IS_ACTIVE(jvmti); then'\n+#\n+# Definition kept in one line to allow inlining in if statements.\n+# Additional [] needed to keep m4 from mangling shell constructs.\n+AC_DEFUN([JVM_FEATURES_IS_ACTIVE],\n+[ [ [[ \" $JVM_FEATURES_ACTIVE \" =~ ' '$1' ' ]] ] ])\n+\n+###############################################################################\n+# Verify that the resulting set of features is consistent and legal.\n+#\n+# arg 1: JVM variant\n+#\n+AC_DEFUN([JVM_FEATURES_VERIFY],\n+[\n+  variant=$1\n+\n+  # Verify that dependencies are met for inter-feature relations.\n+  if JVM_FEATURES_IS_ACTIVE(aot) && ! JVM_FEATURES_IS_ACTIVE(graal); then\n+    AC_MSG_ERROR([Specified JVM feature 'aot' requires feature 'graal' for variant '$variant'])\n+  fi\n+\n+  if JVM_FEATURES_IS_ACTIVE(graal) && ! JVM_FEATURES_IS_ACTIVE(jvmci); then\n+    AC_MSG_ERROR([Specified JVM feature 'graal' requires feature 'jvmci' for variant '$variant'])\n+  fi\n+\n+  if JVM_FEATURES_IS_ACTIVE(jvmci) && ! (JVM_FEATURES_IS_ACTIVE(compiler1) || \\\n+      JVM_FEATURES_IS_ACTIVE(compiler2)); then\n+    AC_MSG_ERROR([Specified JVM feature 'jvmci' requires feature 'compiler2' or 'compiler1' for variant '$variant'])\n+  fi\n+\n+  if JVM_FEATURES_IS_ACTIVE(jvmti) && ! JVM_FEATURES_IS_ACTIVE(services); then\n+    AC_MSG_ERROR([Specified JVM feature 'jvmti' requires feature 'services' for variant '$variant'])\n+  fi\n+\n+  if JVM_FEATURES_IS_ACTIVE(management) && ! JVM_FEATURES_IS_ACTIVE(nmt); then\n+    AC_MSG_ERROR([Specified JVM feature 'management' requires feature 'nmt' for variant '$variant'])\n+  fi\n+\n+  # For backwards compatibility, disable a feature \"globally\" if one variant\n+  # is missing the feature.\n+  if ! JVM_FEATURES_IS_ACTIVE(aot); then\n+    ENABLE_AOT=\"false\"\n+  fi\n+  if ! JVM_FEATURES_IS_ACTIVE(cds); then\n+    ENABLE_CDS=\"false\"\n+  fi\n+  if ! JVM_FEATURES_IS_ACTIVE(graal); then\n+    INCLUDE_GRAAL=\"false\"\n+  fi\n+  if ! JVM_FEATURES_IS_ACTIVE(jvmci); then\n+    INCLUDE_JVMCI=\"false\"\n+  fi\n+  if ! JVM_FEATURES_IS_ACTIVE(tsan); then\n+    INCLUDE_TSAN=\"false\"\n+  fi\n+\n+  # Verify that we have at least one gc selected (i.e., feature named \"*gc\").\n+  if ! JVM_FEATURES_IS_ACTIVE(.*gc); then\n+      AC_MSG_NOTICE([At least one gc needed for variant '$variant'.])\n+      AC_MSG_NOTICE([Specified features: '$JVM_FEATURES_ACTIVE'])\n+      AC_MSG_ERROR([Cannot continue])\n+  fi\n+])\n+\n+###############################################################################\n+# Set up all JVM features for each enabled JVM variant. Requires that\n+# JVM_FEATURES_PARSE_OPTIONS has been called.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_SETUP],\n+[\n+  # Set up variant-independent factors\n+  JVM_FEATURES_PREPARE_PLATFORM\n+\n+  # For backwards compatibility, tentatively enable these features \"globally\",\n+  # and disable them in JVM_FEATURES_VERIFY if a variant is found that are\n+  # missing any of them.\n+  ENABLE_AOT=\"true\"\n+  ENABLE_CDS=\"true\"\n+  INCLUDE_GRAAL=\"true\"\n+  INCLUDE_JVMCI=\"true\"\n+  INCLUDE_TSAN=\"true\"\n+\n+  for variant in $JVM_VARIANTS; do\n+    # Figure out if any features are unavailable, or should be filtered out\n+    # by default, for this variant.\n+    # Store the result in JVM_FEATURES_VARIANT_UNAVAILABLE and\n+    # JVM_FEATURES_VARIANT_FILTER.\n+    JVM_FEATURES_PREPARE_VARIANT($variant)\n+\n+    # Calculate the resulting set of enabled features for this variant.\n+    # The result is stored in JVM_FEATURES_ACTIVE.\n+    JVM_FEATURES_CALCULATE_ACTIVE($variant)\n+\n+    # Verify consistency for JVM_FEATURES_ACTIVE.\n+    JVM_FEATURES_VERIFY($variant)\n+\n+    # Keep feature list sorted and free of duplicates\n+    UTIL_SORT_LIST(JVM_FEATURES_ACTIVE, $JVM_FEATURES_ACTIVE)\n+    AC_MSG_CHECKING([JVM features to use for variant '$variant'])\n+    AC_MSG_RESULT(['$JVM_FEATURES_ACTIVE'])\n+\n+    # Save this as e.g. JVM_FEATURES_server, using indirect variable\n+    # referencing.\n+    features_var_name=JVM_FEATURES_$variant\n+    eval $features_var_name=\\\"$JVM_FEATURES_ACTIVE\\\"\n+  done\n+\n+  JVM_FEATURES_TSAN_LAUNCHER_FLAG($INCLUDE_TSAN)\n+\n+  # Unfortunately AC_SUBST does not work with non-literally named variables,\n+  # so list all variants here.\n+  AC_SUBST(JVM_FEATURES_server)\n+  AC_SUBST(JVM_FEATURES_client)\n+  AC_SUBST(JVM_FEATURES_minimal)\n+  AC_SUBST(JVM_FEATURES_core)\n+  AC_SUBST(JVM_FEATURES_zero)\n+  AC_SUBST(JVM_FEATURES_custom)\n+\n+  AC_SUBST(ENABLE_AOT)\n+  AC_SUBST(INCLUDE_GRAAL)\n+  AC_SUBST(INCLUDE_JVMCI)\n+  AC_SUBST(INCLUDE_TSAN)\n+\n+])\n","filename":"make\/autoconf\/jvm-features.m4","additions":722,"deletions":0,"binary":false,"changes":722,"status":"added"},{"patch":"@@ -86,1 +86,0 @@\n-OPENJDK_TARGET_CPU_ISADIR:=@OPENJDK_TARGET_CPU_ISADIR@\n@@ -122,0 +121,3 @@\n+SOURCE_DATE := @SOURCE_DATE@\n+ENABLE_REPRODUCIBLE_BUILD := @ENABLE_REPRODUCIBLE_BUILD@\n+\n@@ -159,0 +161,1 @@\n+HOTSPOT_BUILD_TIME:=@HOTSPOT_BUILD_TIME@\n@@ -248,1 +251,1 @@\n-  # VersionProps.java.template in the jdk for \"vm.vendor\" and\n+  # VersionProps.java.template in the jdk for \"java.vendor\" and\n@@ -292,3 +295,0 @@\n-# Control whether Hotspot builds gtest tests\n-BUILD_GTEST := @BUILD_GTEST@\n-\n@@ -306,0 +306,3 @@\n+# Ship debug symbols (e.g. pdbs on Windows)\n+SHIP_DEBUG_SYMBOLS := @SHIP_DEBUG_SYMBOLS@\n+\n@@ -337,0 +340,2 @@\n+ALLOW_ABSOLUTE_PATHS_IN_OUTPUT := @ALLOW_ABSOLUTE_PATHS_IN_OUTPUT@\n+\n@@ -352,6 +357,3 @@\n-# Enable sjavac support = use a javac server,\n-# multi core javac compilation and dependency tracking.\n-ENABLE_SJAVAC:=@ENABLE_SJAVAC@\n-# Store sjavac server synchronization files here, and\n-# the sjavac server log files.\n-SJAVAC_SERVER_DIR=$(MAKESUPPORT_OUTPUTDIR)\/javacservers\n+# Store javac server synchronization files here, and\n+# the javac server log files.\n+JAVAC_SERVER_DIR=$(MAKESUPPORT_OUTPUTDIR)\/javacservers\n@@ -380,0 +382,1 @@\n+FILE_MACRO_CFLAGS := @FILE_MACRO_CFLAGS@\n@@ -389,0 +392,2 @@\n+GTEST_FRAMEWORK_SRC := @GTEST_FRAMEWORK_SRC@\n+\n@@ -423,1 +428,1 @@\n-# Toolchain type: gcc, clang, solstudio, lxc, microsoft...\n+# Toolchain type: gcc, clang, xlc, microsoft...\n@@ -466,1 +471,0 @@\n-LDFLAGS_WARNINGS_ARE_ERRORS:=@LDFLAGS_WARNINGS_ARE_ERRORS@\n@@ -520,1 +524,0 @@\n-GLOBAL_LIBS:=@GLOBAL_LIBS@\n@@ -570,4 +573,0 @@\n-# Options for C\/CXX compiler to be used if linking is performed\n-#   using reorder file\n-C_FLAG_REORDER:=@C_FLAG_REORDER@\n-\n@@ -616,1 +615,1 @@\n-JAVA_FLAGS_JAVAC:=@JAVA_FLAGS_JAVAC@\n+BUILDJDK_JAVA_FLAGS_SMALL:=@BUILDJDK_JAVA_FLAGS_SMALL@\n@@ -618,1 +617,0 @@\n-SJAVAC_SERVER_JAVA_FLAGS:=@SJAVAC_SERVER_JAVA_FLAGS@\n@@ -630,1 +628,0 @@\n-SJAVAC_SERVER_JAVA_CMD:=@SJAVAC_SERVER_JAVA@\n@@ -635,1 +632,1 @@\n-JAVA_JAVAC=@FIXPATH@ $(JAVA_CMD) $(JAVA_FLAGS_JAVAC) $(JAVA_FLAGS)\n+JAVA_DETACH =@FIXPATH@ @FIXPATH_DETACH_FLAG@ $(JAVA_CMD) $(JAVA_FLAGS_BIG) $(JAVA_FLAGS)\n@@ -639,1 +636,1 @@\n-JLINK = @FIXPATH@ $(JLINK_CMD) $(JAVA_TOOL_FLAGS_SMALL)\n+JLINK = @FIXPATH@ $(JLINK_CMD)\n@@ -642,9 +639,0 @@\n-# A specific java binary with specific options can be used to run\n-# the long running background sjavac servers and other long running tasks.\n-SJAVAC_SERVER_JAVA=@FIXPATH@ @FIXPATH_DETACH_FLAG@ $(SJAVAC_SERVER_JAVA_CMD) \\\n-    $(SJAVAC_SERVER_JAVA_FLAGS)\n-\n-# Hotspot sets this variable before reading the SPEC when compiling sa-jdi.jar. Avoid\n-# overriding that value by using ?=.\n-JAVAC_FLAGS?=@JAVAC_FLAGS@\n-\n@@ -656,1 +644,1 @@\n-# Interim langtools and rmic modules and arguments\n+# Interim langtools modules and arguments\n@@ -663,0 +651,1 @@\n+    --add-exports java.base\/sun.invoke.util=jdk.compiler.interim \\\n@@ -675,9 +664,0 @@\n-INTERIM_RMIC_BASE_MODULES := jdk.rmic\n-INTERIM_RMIC_MODULES := $(addsuffix .interim, $(INTERIM_RMIC_BASE_MODULES))\n-    #\n-# Use = to delay expansion of PathList since it's not available in this file.\n-INTERIM_RMIC_ARGS = --limit-modules java.base,jdk.compiler,jdk.javadoc \\\n-    --module-path $(call PathList, $(BUILDTOOLS_OUTPUTDIR)\/interim_rmic_modules \\\n-        $(BUILDTOOLS_OUTPUTDIR)\/interim_langtools_modules) \\\n-    #\n-\n@@ -760,1 +740,0 @@\n-ELFEDIT:=@ELFEDIT@\n@@ -770,1 +749,0 @@\n-JTREGEXE:=@JTREGEXE@\n@@ -778,1 +756,0 @@\n-TAR_CREATE_EXTRA_PARAM:=@TAR_CREATE_EXTRA_PARAM@\n@@ -792,0 +769,1 @@\n+VCRUNTIME_1_DLL:=@VCRUNTIME_1_DLL@\n@@ -794,1 +772,0 @@\n-STLPORT_LIB:=@STLPORT_LIB@\n","filename":"make\/autoconf\/spec.gmk.in","additions":23,"deletions":46,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -0,0 +1,275 @@\n+#\n+# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include JdkNativeCompilation.gmk\n+include Modules.gmk\n+include ProcessMarkdown.gmk\n+include ToolsJdk.gmk\n+\n+# Tell the compiler not to export any functions unless declared so in\n+# the source code. On Windows, this is the default and cannot be changed.\n+# On Mac, we have always exported all symbols, probably due to oversight\n+# and\/or misunderstanding. To emulate this, don't hide any symbols\n+# by default.\n+# On AIX\/xlc we need at least xlc 13.1 for the symbol hiding (see JDK-8214063)\n+# Also provide an override for non-conformant libraries.\n+ifeq ($(TOOLCHAIN_TYPE), gcc)\n+  LAUNCHER_CFLAGS += -fvisibility=hidden\n+  LDFLAGS_JDKEXE += -Wl,--exclude-libs,ALL\n+else ifeq ($(TOOLCHAIN_TYPE), clang)\n+  LAUNCHER_CFLAGS += -fvisibility=hidden\n+endif\n+\n+LAUNCHER_SRC := $(TOPDIR)\/src\/java.base\/share\/native\/launcher\n+LAUNCHER_CFLAGS += -I$(TOPDIR)\/src\/java.base\/share\/native\/launcher \\\n+    -I$(TOPDIR)\/src\/java.base\/share\/native\/libjli \\\n+    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS_TYPE)\/native\/libjli \\\n+    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS)\/native\/libjli \\\n+    #\n+GLOBAL_VERSION_INFO_RESOURCE := $(TOPDIR)\/src\/java.base\/windows\/native\/common\/version.rc\n+MACOSX_PLIST_DIR := $(TOPDIR)\/src\/java.base\/macosx\/native\/launcher\n+JAVA_MANIFEST := $(TOPDIR)\/src\/java.base\/windows\/native\/launcher\/java.manifest\n+\n+################################################################################\n+# Build standard launcher.\n+\n+# Setup make rules for building a standard launcher.\n+#\n+# Parameter 1 is the name of the rule. This name is used as variable prefix,\n+# and the targets generated are listed in a variable by that name. It is also\n+# used as the name of the executable.\n+#\n+# Remaining parameters are named arguments. These include:\n+# MAIN_MODULE  The module of the main class to launch if different from the\n+#     current module\n+# MAIN_CLASS   The Java main class to launch\n+# JAVA_ARGS   Processed into a -DJAVA_ARGS and added to CFLAGS\n+# EXTRA_JAVA_ARGS Processed into a -DEXTRA_JAVA_ARGS and is prepended\n+#     before JAVA_ARGS to CFLAGS, primarily to allow long string literal\n+#     compile time defines exceeding Visual Studio 2013 limitations.\n+# CFLAGS   Additional CFLAGS\n+# CFLAGS_windows   Additional CFLAGS_windows\n+# EXTRA_RC_FLAGS   Additional EXTRA_RC_FLAGS\n+# MACOSX_PRIVILEGED   On macosx, allow to access other processes\n+# OPTIMIZATION   Override default optimization level (LOW)\n+# OUTPUT_DIR   Override default output directory\n+# VERSION_INFO_RESOURCE   Override default Windows resource file\n+# INCLUDE_TSAN   If true, pass compiler and linker flags for TSAN.\n+SetupBuildLauncher = $(NamedParamsMacroTemplate)\n+define SetupBuildLauncherBody\n+  # Setup default values (unless overridden)\n+  ifeq ($$($1_OPTIMIZATION), )\n+    $1_OPTIMIZATION := LOW\n+  endif\n+\n+  ifeq ($$($1_MAIN_MODULE), )\n+    $1_MAIN_MODULE := $(MODULE)\n+  endif\n+\n+  $1_JAVA_ARGS += -ms8m\n+  ifneq ($$($1_MAIN_CLASS), )\n+    $1_LAUNCHER_CLASS := -m $$($1_MAIN_MODULE)\/$$($1_MAIN_CLASS)\n+  endif\n+\n+  ifneq ($$($1_EXTRA_JAVA_ARGS), )\n+    $1_EXTRA_JAVA_ARGS_STR := '{ $$(strip $$(foreach a, \\\n+      $$(addprefix -J, $$($1_EXTRA_JAVA_ARGS)), \"$$a\"$(COMMA) )) }'\n+    $1_CFLAGS += -DEXTRA_JAVA_ARGS=$$($1_EXTRA_JAVA_ARGS_STR)\n+  endif\n+  $1_JAVA_ARGS_STR := '{ $$(strip $$(foreach a, \\\n+      $$(addprefix -J, $$($1_JAVA_ARGS)) $$($1_LAUNCHER_CLASS), \"$$a\"$(COMMA) )) }'\n+  $1_CFLAGS += -DJAVA_ARGS=$$($1_JAVA_ARGS_STR)\n+\n+  ifeq ($(call isTargetOs, macosx), true)\n+    ifeq ($$($1_MACOSX_PRIVILEGED), true)\n+      $1_PLIST_SRC_FILE := Info-privileged.plist\n+    else\n+      $1_PLIST_SRC_FILE := Info-cmdline.plist\n+    endif\n+\n+    $1_PLIST_FILE := $$(SUPPORT_OUTPUTDIR)\/native\/$$(MODULE)\/$1\/Info.plist\n+\n+    $$(eval $$(call SetupTextFileProcessing, BUILD_PLIST_$1, \\\n+        SOURCE_FILES := $$(TOPDIR)\/src\/java.base\/macosx\/native\/launcher\/$$($1_PLIST_SRC_FILE), \\\n+        OUTPUT_FILE := $$($1_PLIST_FILE), \\\n+        REPLACEMENTS := \\\n+            @@ID@@ => $(MACOSX_BUNDLE_ID_BASE).$(VERSION_SHORT).$1 ; \\\n+            @@VERSION@@ => $(VERSION_NUMBER) ; \\\n+    ))\n+\n+    $1_LDFLAGS += -sectcreate __TEXT __info_plist $$($1_PLIST_FILE)\n+\n+    ifeq ($(STATIC_BUILD), true)\n+      $1_LDFLAGS += -exported_symbols_list \\\n+              $(SUPPORT_OUTPUTDIR)\/build-static\/exported.symbols\n+      $1_LIBS += \\\n+          $$(shell $(FIND) $(SUPPORT_OUTPUTDIR)\/modules_libs\/java.base -name \"*.a\") \\\n+          $(SUPPORT_OUTPUTDIR)\/modules_libs\/jdk.jdwp.agent\/libdt_socket.a \\\n+          $(SUPPORT_OUTPUTDIR)\/modules_libs\/jdk.jdwp.agent\/libjdwp.a \\\n+          $(SUPPORT_OUTPUTDIR)\/native\/java.base\/$(LIBRARY_PREFIX)fdlibm$(STATIC_LIBRARY_SUFFIX) \\\n+          -framework CoreFoundation \\\n+          -framework Foundation \\\n+          -framework SystemConfiguration \\\n+          -lstdc++ -liconv\n+    endif\n+  endif\n+\n+  ifeq ($(USE_EXTERNAL_LIBZ), true)\n+    $1_LIBS += -lz\n+  endif\n+\n+  ifeq ($$($1_INCLUDE_TSAN), true)\n+    $1_CFLAGS += -DINCLUDE_TSAN\n+    # TSAN runtime needs to be statically or dynamically linked with the launcher\n+    # instead of libjvm.so, because initialization of TSAN runtime has to happen\n+    # early at program start.\n+    # '-fsanitize=thread' works as a link-only flag for either GCC or Clang.\n+    # With GCC, it dynamically links with libtsan.so; with Clang, it statically\n+    # links the runtime into the launcher's executable.\n+    $1_LDFLAGS += -fsanitize=thread\n+  endif\n+\n+  $1_WINDOWS_JLI_LIB := $(call FindStaticLib, java.base, jli, \/libjli)\n+\n+  $$(eval $$(call SetupJdkExecutable, BUILD_LAUNCHER_$1, \\\n+      NAME := $1, \\\n+      EXTRA_FILES := $(LAUNCHER_SRC)\/main.c, \\\n+      OPTIMIZATION := $$($1_OPTIMIZATION), \\\n+      CFLAGS := $$(CFLAGS_JDKEXE) \\\n+          $$(LAUNCHER_CFLAGS) \\\n+          $$(VERSION_CFLAGS) \\\n+          -DLAUNCHER_NAME='\"$$(LAUNCHER_NAME)\"' \\\n+          -DPROGNAME='\"$1\"' \\\n+          $$($1_CFLAGS), \\\n+      CFLAGS_windows := $$($1_CFLAGS_windows), \\\n+      DISABLED_WARNINGS_gcc := unused-function, \\\n+      LDFLAGS := $$(LDFLAGS_JDKEXE) \\\n+          $$(call SET_EXECUTABLE_ORIGIN) \\\n+          $$($1_LDFLAGS), \\\n+      LDFLAGS_linux := $$(call SET_EXECUTABLE_ORIGIN,\/..\/lib) \\\n+          -L$(call FindLibDirForModule, java.base), \\\n+      LDFLAGS_macosx := $$(call SET_EXECUTABLE_ORIGIN,\/..\/lib) \\\n+          -L$(call FindLibDirForModule, java.base), \\\n+      LDFLAGS_aix := -L$(SUPPORT_OUTPUTDIR)\/native\/java.base, \\\n+      LIBS := $(JDKEXE_LIBS) $$($1_LIBS), \\\n+      LIBS_linux := -ljli -lpthread $(LIBDL), \\\n+      LIBS_macosx := -ljli -framework Cocoa -framework Security \\\n+          -framework ApplicationServices, \\\n+      LIBS_aix := -ljli_static, \\\n+      LIBS_windows := $$($1_WINDOWS_JLI_LIB) \\\n+          $(SUPPORT_OUTPUTDIR)\/native\/java.base\/libjava\/java.lib, \\\n+      OUTPUT_DIR := $$($1_OUTPUT_DIR), \\\n+      VERSIONINFO_RESOURCE := $$($1_VERSION_INFO_RESOURCE), \\\n+      EXTRA_RC_FLAGS := $$($1_EXTRA_RC_FLAGS), \\\n+      MANIFEST := $(JAVA_MANIFEST), \\\n+      MANIFEST_VERSION := $(VERSION_NUMBER_FOUR_POSITIONS), \\\n+  ))\n+\n+  $1 += $$(BUILD_LAUNCHER_$1)\n+  TARGETS += $$($1)\n+\n+  $$(BUILD_LAUNCHER_$1): $$(BUILD_PLIST_$1)\n+\n+  ifeq ($(call isTargetOs, aix), true)\n+    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, jli_static)\n+  endif\n+\n+  ifeq ($(call isTargetOs, windows), true)\n+    $$(BUILD_LAUNCHER_$1): $(call FindStaticLib, java.base, java, \/libjava) \\\n+        $$($1_WINDOWS_JLI_LIB)\n+  endif\n+endef\n+\n+################################################################################\n+# Create man pages for jmod to pick up. There should be a one-to-one\n+# relationship between executables and man pages (even if this is not always\n+# the case), so piggyback man page generation on the launcher compilation.\n+\n+ifeq ($(call isTargetOsType, unix), true)\n+  # Only build manpages on unix systems.\n+  # We assume all our man pages should reside in section 1.\n+\n+  MAN_FILES_MD := $(wildcard $(addsuffix \/*.md, $(call FindModuleManDirs, $(MODULE))))\n+  MAN_FILES_TROFF := $(wildcard $(addsuffix \/*.1, $(call FindModuleManDirs, $(MODULE))))\n+\n+  ifneq ($(MAN_FILES_MD), )\n+    # If we got markdown files, ignore the troff files\n+    ifeq ($(ENABLE_PANDOC), false)\n+      $(info Warning: pandoc not found. Not generating man pages)\n+    else\n+      # Create dynamic man pages from markdown using pandoc. We need\n+      # PANDOC_TROFF_MANPAGE_FILTER, a wrapper around\n+      # PANDOC_TROFF_MANPAGE_FILTER_JAVASCRIPT. This is created by buildtools-jdk.\n+\n+      # We should also depend on the source code for the filter\n+      PANDOC_TROFF_MANPAGE_FILTER_SOURCE := $(call FindFiles, \\\n+          $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/pandocfilter)\n+\n+      # The norm in man pages is to display code literals as bold, but pandoc\n+      # \"correctly\" converts these constructs (encoded in markdown using `...`\n+      # or ```...```) to \\f[C]. Ideally, we should use the filter to encapsulate\n+      # the Code\/CodeBlock in Strong. While this works for Code, pandoc cannot\n+      # correctly render man page output for CodeBlock wrapped in Strong. So we\n+      # take the easy way out, and post-process the troff output, replacing\n+      # \\f[C] with \\f[CB]. This has the added benefit of working correctly on\n+      # pandoc prior to version 2.0, which cannot properly produced nested\n+      # formatting in man pages (see https:\/\/github.com\/jgm\/pandoc\/issues\/3568).\n+      #\n+      # As of pandoc 2.3, the termination of formatting is still broken\n+      # (see https:\/\/github.com\/jgm\/pandoc\/issues\/4973). We need to replace\n+      # \\f[] with \\f[R].\n+      MAN_POST_PROCESS := $(SED) -e 's\/\\\\f\\[C\\]\/\\\\f\\[CB\\]\/g' \\\n+          -e 's\/\\\\f\\[\\]\/\\\\f\\[R\\]\/g'\n+\n+      # Now generate the man pages from markdown using pandoc\n+      $(eval $(call SetupProcessMarkdown, BUILD_MAN_PAGES, \\\n+          DEST := $(SUPPORT_OUTPUTDIR)\/modules_man\/$(MODULE)\/man1, \\\n+          FILES := $(MAN_FILES_MD), \\\n+          FORMAT := man, \\\n+          FILTER := $(PANDOC_TROFF_MANPAGE_FILTER), \\\n+          POST_PROCESS := $(MAN_POST_PROCESS), \\\n+          REPLACEMENTS := \\\n+\t\t@@COPYRIGHT_YEAR@@ => $(COPYRIGHT_YEAR) ; \\\n+\t\t@@VERSION_SHORT@@ => $(VERSION_SHORT) ; \\\n+\t\t@@VERSION_SPECIFICATION@@ => $(VERSION_SPECIFICATION), \\\n+          EXTRA_DEPS := $(PANDOC_TROFF_MANPAGE_FILTER) \\\n+              $(PANDOC_TROFF_MANPAGE_FILTER_SOURCE), \\\n+      ))\n+\n+      TARGETS += $(BUILD_MAN_PAGES)\n+    endif\n+  else\n+    # No markdown man pages present\n+    ifeq ($(BUILD_MANPAGES), true)\n+      # BUILD_MANPAGES is a mis-nomer. It really means \"copy the pre-generated man pages\".\n+      $(eval $(call SetupCopyFiles, COPY_MAN_PAGES, \\\n+          DEST := $(SUPPORT_OUTPUTDIR)\/modules_man\/$(MODULE)\/man1, \\\n+          FILES := $(MAN_FILES_TROFF), \\\n+      ))\n+\n+      TARGETS += $(COPY_MAN_PAGES)\n+    endif\n+  endif\n+endif\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":275,"deletions":0,"binary":false,"changes":275,"status":"added"},{"patch":"@@ -53,3 +53,4 @@\n-  ifeq ($(call isTargetCpu, sparcv9), true)\n-    BUILD_LIBJVM_EXTRA_FILES := $(TOPDIR)\/src\/hotspot\/cpu\/sparc\/memset_with_concurrent_readers_sparc.cpp\n-  endif\n+endif\n+\n+ifeq ($(JVM_VARIANT), custom)\n+  JVM_CFLAGS_FEATURES += -DVMTYPE=\\\"Custom\\\"\n@@ -154,2 +155,0 @@\n-  # If serial is disabled, we cannot use serial as OldGC in parallel\n-  JVM_EXCLUDE_FILES += psMarkSweep.cpp psMarkSweepDecorator.cpp\n@@ -176,0 +175,1 @@\n+  JVM_EXCLUDE_FILES += compilerEvent.cpp\n@@ -194,85 +194,84 @@\n-ifeq ($(call check-jvm-feature, minimal), true)\n-  ifeq ($(call check-jvm-feature, link-time-opt), false)\n-    JVM_OPTIMIZATION := SIZE\n-    OPT_SPEED_SRC := \\\n-        allocation.cpp \\\n-        assembler.cpp \\\n-        barrierSet.cpp \\\n-        basicLock.cpp \\\n-        biasedLocking.cpp \\\n-        bytecode.cpp \\\n-        bytecodeInterpreter.cpp \\\n-        c1_Compilation.cpp \\\n-        c1_Compiler.cpp \\\n-        c1_GraphBuilder.cpp \\\n-        c1_LinearScan.cpp \\\n-        c1_LIR.cpp \\\n-        ciEnv.cpp \\\n-        ciObjectFactory.cpp \\\n-        codeBlob.cpp \\\n-        constantPool.cpp \\\n-        constMethod.cpp \\\n-        classLoader.cpp \\\n-        classLoaderData.cpp \\\n-        classFileParser.cpp \\\n-        classFileStream.cpp \\\n-        cpCache.cpp \\\n-        defNewGeneration.cpp \\\n-        frame_arm.cpp \\\n-        frame_aarch64.cpp \\\n-        frame_ppc.cpp \\\n-        frame_s390.cpp \\\n-        frame_x86.cpp \\\n-        genCollectedHeap.cpp \\\n-        generation.cpp \\\n-        genMarkSweep.cpp \\\n-        growableArray.cpp \\\n-        handles.cpp \\\n-        hashtable.cpp \\\n-        heap.cpp \\\n-        icache.cpp \\\n-        icache_arm.cpp \\\n-        icache_aarch64.cpp \\\n-        icache_ppc.cpp \\\n-        icache_s390.cpp \\\n-        icache_x86.cpp \\\n-        instanceKlass.cpp \\\n-        invocationCounter.cpp \\\n-        iterator.cpp \\\n-        javaCalls.cpp \\\n-        javaClasses.cpp \\\n-        jniFastGetField_arm.cpp \\\n-        jvm.cpp \\\n-        linkResolver.cpp \\\n-        klass.cpp \\\n-        klassVtable.cpp \\\n-        markSweep.cpp \\\n-        memRegion.cpp \\\n-        memoryPool.cpp \\\n-        method.cpp \\\n-        methodHandles.cpp \\\n-        methodHandles_arm.cpp \\\n-        methodLiveness.cpp \\\n-        metaspace.cpp \\\n-        mutex.cpp \\\n-        mutexLocker.cpp \\\n-        nativeLookup.cpp \\\n-        objArrayKlass.cpp \\\n-        os_linux.cpp \\\n-        os_linux_arm.cpp \\\n-        resourceArea.cpp \\\n-        rewriter.cpp \\\n-        sharedRuntime.cpp \\\n-        signature.cpp \\\n-        space.cpp \\\n-        stackMapTable.cpp \\\n-        symbolTable.cpp \\\n-        systemDictionary.cpp \\\n-        symbol.cpp \\\n-        synchronizer.cpp \\\n-        timer.cpp \\\n-        typeArrayKlass.cpp \\\n-        unsafe.cpp \\\n-        utf8.cpp \\\n-        vmSymbols.cpp \\\n-        #\n+ifeq ($(call check-jvm-feature, opt-size), true)\n+  JVM_OPTIMIZATION := SIZE\n+  OPT_SPEED_SRC := \\\n+      allocation.cpp \\\n+      assembler.cpp \\\n+      barrierSet.cpp \\\n+      basicLock.cpp \\\n+      biasedLocking.cpp \\\n+      bytecode.cpp \\\n+      bytecodeInterpreter.cpp \\\n+      c1_Compilation.cpp \\\n+      c1_Compiler.cpp \\\n+      c1_GraphBuilder.cpp \\\n+      c1_LinearScan.cpp \\\n+      c1_LIR.cpp \\\n+      ciEnv.cpp \\\n+      ciObjectFactory.cpp \\\n+      codeBlob.cpp \\\n+      constantPool.cpp \\\n+      constMethod.cpp \\\n+      classLoader.cpp \\\n+      classLoaderData.cpp \\\n+      classFileParser.cpp \\\n+      classFileStream.cpp \\\n+      cpCache.cpp \\\n+      defNewGeneration.cpp \\\n+      frame_arm.cpp \\\n+      frame_aarch64.cpp \\\n+      frame_ppc.cpp \\\n+      frame_s390.cpp \\\n+      frame_x86.cpp \\\n+      genCollectedHeap.cpp \\\n+      generation.cpp \\\n+      genMarkSweep.cpp \\\n+      growableArray.cpp \\\n+      handles.cpp \\\n+      hashtable.cpp \\\n+      heap.cpp \\\n+      icache.cpp \\\n+      icache_arm.cpp \\\n+      icache_aarch64.cpp \\\n+      icache_ppc.cpp \\\n+      icache_s390.cpp \\\n+      icache_x86.cpp \\\n+      instanceKlass.cpp \\\n+      invocationCounter.cpp \\\n+      iterator.cpp \\\n+      javaCalls.cpp \\\n+      javaClasses.cpp \\\n+      jniFastGetField_arm.cpp \\\n+      jvm.cpp \\\n+      linkResolver.cpp \\\n+      klass.cpp \\\n+      klassVtable.cpp \\\n+      markSweep.cpp \\\n+      memRegion.cpp \\\n+      memoryPool.cpp \\\n+      method.cpp \\\n+      methodHandles.cpp \\\n+      methodHandles_arm.cpp \\\n+      methodLiveness.cpp \\\n+      metaspace.cpp \\\n+      mutex.cpp \\\n+      mutexLocker.cpp \\\n+      nativeLookup.cpp \\\n+      objArrayKlass.cpp \\\n+      os_linux.cpp \\\n+      os_linux_arm.cpp \\\n+      resourceArea.cpp \\\n+      rewriter.cpp \\\n+      sharedRuntime.cpp \\\n+      signature.cpp \\\n+      space.cpp \\\n+      stackMapTable.cpp \\\n+      symbolTable.cpp \\\n+      systemDictionary.cpp \\\n+      symbol.cpp \\\n+      synchronizer.cpp \\\n+      timer.cpp \\\n+      typeArrayKlass.cpp \\\n+      unsafe.cpp \\\n+      utf8.cpp \\\n+      vmSymbols.cpp \\\n+      #\n@@ -280,2 +279,2 @@\n-    $(foreach s, $(OPT_SPEED_SRC), \\\n-        $(eval BUILD_LIBJVM_$s_OPTIMIZATION := HIGHEST_JVM))\n+  $(foreach s, $(OPT_SPEED_SRC), \\\n+      $(eval BUILD_LIBJVM_$s_OPTIMIZATION := HIGHEST_JVM))\n@@ -283,0 +282,1 @@\n+  ifneq ($(filter $(TOOLCHAIN_TYPE), gcc clang), )\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":92,"deletions":92,"binary":false,"changes":184,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2019, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -122,0 +122,1 @@\n+JVM_GetPermittedSubclasses\n@@ -125,0 +126,1 @@\n+JVM_GetRandomSeedForCDSDump\n@@ -145,0 +147,2 @@\n+JVM_IsCDSDumpingEnabled\n+JVM_IsCDSSharingEnabled\n@@ -146,0 +150,1 @@\n+JVM_IsHiddenClass\n@@ -155,0 +160,2 @@\n+JVM_LookupDefineClass\n+JVM_LookupLambdaProxyClassFromArchive\n@@ -171,0 +178,1 @@\n+JVM_RegisterLambdaProxyClassForArchiving\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -0,0 +1,92 @@\n+#\n+# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+include LauncherCommon.gmk\n+\n+# Hook to include the corresponding custom file, if present.\n+$(eval $(call IncludeCustomExtension, modules\/java.base\/Launcher.gmk))\n+\n+JAVA_VERSION_INFO_RESOURCE := $(TOPDIR)\/src\/java.base\/windows\/native\/launcher\/java.rc\n+\n+JAVA_RC_FLAGS += -I$(TOPDIR)\/src\/java.base\/windows\/native\/common\n+JAVA_RC_FLAGS += -I$(TOPDIR)\/src\/java.base\/windows\/native\/launcher\/icons\n+\n+################################################################################\n+\n+$(eval $(call SetupBuildLauncher, java, \\\n+    CFLAGS := -DEXPAND_CLASSPATH_WILDCARDS -DENABLE_ARG_FILES, \\\n+    EXTRA_RC_FLAGS := $(JAVA_RC_FLAGS), \\\n+    VERSION_INFO_RESOURCE := $(JAVA_VERSION_INFO_RESOURCE), \\\n+    OPTIMIZATION := HIGH, \\\n+    INCLUDE_TSAN := $(INCLUDE_TSAN), \\\n+))\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  $(eval $(call SetupBuildLauncher, javaw, \\\n+      CFLAGS := -DJAVAW -DEXPAND_CLASSPATH_WILDCARDS -DENABLE_ARG_FILES, \\\n+      EXTRA_RC_FLAGS := $(JAVA_RC_FLAGS), \\\n+      VERSION_INFO_RESOURCE := $(JAVA_VERSION_INFO_RESOURCE), \\\n+  ))\n+endif\n+\n+$(eval $(call SetupBuildLauncher, keytool, \\\n+    MAIN_CLASS := sun.security.tools.keytool.Main, \\\n+))\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, linux), true)\n+  $(eval $(call SetupJdkExecutable, BUILD_JEXEC, \\\n+      NAME := jexec, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/launcher, \\\n+      INCLUDE_FILES := jexec.c, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE) \\\n+          -I$(TOPDIR)\/src\/$(MODULE)\/share\/native\/libjli, \\\n+      CFLAGS_linux := -fPIC, \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+\n+  TARGETS += $(BUILD_JEXEC)\n+endif\n+\n+################################################################################\n+\n+ifeq ($(call isTargetOs, macosx aix linux), true)\n+  $(eval $(call SetupJdkExecutable, BUILD_JSPAWNHELPER, \\\n+      NAME := jspawnhelper, \\\n+      SRC := $(TOPDIR)\/src\/$(MODULE)\/unix\/native\/jspawnhelper, \\\n+      OPTIMIZATION := LOW, \\\n+      CFLAGS := $(CFLAGS_JDKEXE) -I$(TOPDIR)\/src\/$(MODULE)\/unix\/native\/libjava, \\\n+      EXTRA_OBJECT_FILES := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjava\/childproc.o, \\\n+      LDFLAGS := $(LDFLAGS_JDKEXE), \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/modules_libs\/$(MODULE), \\\n+  ))\n+\n+  TARGETS += $(BUILD_JSPAWNHELPER)\n+endif\n+\n+################################################################################\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -0,0 +1,242 @@\n+#\n+# Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+##########################################################################################\n+# libfdlibm is statically linked with libjava below and not delivered into the\n+# product on its own.\n+\n+BUILD_LIBFDLIBM_OPTIMIZATION := NONE\n+\n+# If FDLIBM_CFLAGS is non-empty we know that we can optimize\n+# fdlibm when adding those extra C flags. Currently GCC,\n+# and clang only.\n+ifneq ($(FDLIBM_CFLAGS), )\n+  BUILD_LIBFDLIBM_OPTIMIZATION := LOW\n+endif\n+\n+LIBFDLIBM_SRC := $(TOPDIR)\/src\/java.base\/share\/native\/libfdlibm\n+LIBFDLIBM_CFLAGS := -I$(LIBFDLIBM_SRC) $(FDLIBM_CFLAGS)\n+\n+$(eval $(call SetupNativeCompilation, BUILD_LIBFDLIBM, \\\n+    NAME := fdlibm, \\\n+    TYPE := STATIC_LIBRARY, \\\n+    OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE), \\\n+    SRC := $(LIBFDLIBM_SRC), \\\n+    OPTIMIZATION := $(BUILD_LIBFDLIBM_OPTIMIZATION), \\\n+    CFLAGS := $(CFLAGS_JDKLIB) $(LIBFDLIBM_CFLAGS), \\\n+    CFLAGS_windows_debug := -DLOGGING, \\\n+    CFLAGS_aix := -qfloat=nomaf, \\\n+    DISABLED_WARNINGS_gcc := sign-compare misleading-indentation array-bounds, \\\n+    DISABLED_WARNINGS_clang := sign-compare, \\\n+    DISABLED_WARNINGS_microsoft := 4146 4244 4018, \\\n+    ARFLAGS := $(ARFLAGS), \\\n+    OBJECT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libfdlibm, \\\n+))\n+\n+##########################################################################################\n+\n+LIBVERIFY_OPTIMIZATION := HIGH\n+ifeq ($(call isTargetOs, linux), true)\n+  ifeq ($(COMPILE_WITH_DEBUG_SYMBOLS), true)\n+    LIBVERIFY_OPTIMIZATION := LOW\n+  endif\n+endif\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBVERIFY, \\\n+    NAME := verify, \\\n+    OPTIMIZATION := $(LIBVERIFY_OPTIMIZATION), \\\n+    CFLAGS := $(CFLAGS_JDKLIB), \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+        $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS_unix := -ljvm, \\\n+    LIBS_windows := jvm.lib, \\\n+))\n+\n+TARGETS += $(BUILD_LIBVERIFY)\n+\n+##########################################################################################\n+\n+LIBJAVA_CFLAGS := -DARCHPROPNAME='\"$(OPENJDK_TARGET_CPU_OSARCH)\"'\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  BUILD_LIBJAVA_java_props_md.c_CFLAGS := -x objective-c\n+  BUILD_LIBJAVA_java_props_macosx.c_CFLAGS := -x objective-c\n+endif\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBJAVA, \\\n+    NAME := java, \\\n+    OPTIMIZATION := HIGH, \\\n+    CFLAGS := $(CFLAGS_JDKLIB) \\\n+        $(LIBJAVA_CFLAGS), \\\n+    jdk_util.c_CFLAGS := $(VERSION_CFLAGS), \\\n+    EXTRA_HEADER_DIRS := libfdlibm, \\\n+    WARNINGS_AS_ERRORS_xlc := false, \\\n+    DISABLED_WARNINGS_gcc := unused-result unused-function, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+        $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LDFLAGS_macosx := -L$(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/, \\\n+    LDFLAGS_windows := -delayload:shell32.dll, \\\n+    LIBS := $(BUILD_LIBFDLIBM_TARGET), \\\n+    LIBS_unix := -ljvm, \\\n+    LIBS_linux := $(LIBDL), \\\n+    LIBS_aix := $(LIBDL) $(LIBM),\\\n+    LIBS_macosx := -framework CoreFoundation \\\n+        -framework Foundation \\\n+        -framework SystemConfiguration, \\\n+    LIBS_windows := jvm.lib \\\n+        shell32.lib delayimp.lib \\\n+        advapi32.lib version.lib, \\\n+))\n+\n+TARGETS += $(BUILD_LIBJAVA)\n+\n+$(BUILD_LIBJAVA): $(BUILD_LIBVERIFY)\n+\n+$(BUILD_LIBJAVA): $(BUILD_LIBFDLIBM)\n+\n+##########################################################################################\n+\n+BUILD_LIBZIP_EXCLUDES :=\n+ifeq ($(USE_EXTERNAL_LIBZ), true)\n+  LIBZIP_EXCLUDES += zlib\n+endif\n+\n+ifeq ($(LIBZIP_CAN_USE_MMAP), true)\n+  BUILD_LIBZIP_MMAP := -DUSE_MMAP\n+endif\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBZIP, \\\n+    NAME := zip, \\\n+    OPTIMIZATION := LOW, \\\n+    EXCLUDES := $(LIBZIP_EXCLUDES), \\\n+    CFLAGS := $(CFLAGS_JDKLIB) \\\n+        $(LIBZ_CFLAGS), \\\n+    CFLAGS_unix := $(BUILD_LIBZIP_MMAP) -UDEBUG, \\\n+    DISABLED_WARNINGS_gcc := unused-function implicit-fallthrough, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+        $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS_unix := -ljvm -ljava $(LIBZ_LIBS), \\\n+    LIBS_windows := jvm.lib $(WIN_JAVA_LIB), \\\n+))\n+\n+$(BUILD_LIBZIP): $(BUILD_LIBJAVA)\n+\n+TARGETS += $(BUILD_LIBZIP)\n+\n+##########################################################################################\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBJIMAGE, \\\n+    NAME := jimage, \\\n+    TOOLCHAIN := TOOLCHAIN_LINK_CXX, \\\n+    OPTIMIZATION := LOW, \\\n+    CFLAGS := $(CFLAGS_JDKLIB), \\\n+    CXXFLAGS := $(CXXFLAGS_JDKLIB), \\\n+    CFLAGS_unix := -UDEBUG, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) $(LDFLAGS_CXX_JDK) \\\n+        $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS_unix := -ljvm -ldl $(LIBCXX), \\\n+    LIBS_macosx := -lc++, \\\n+    LIBS_windows := jvm.lib, \\\n+))\n+\n+$(BUILD_LIBJIMAGE): $(BUILD_LIBJAVA)\n+\n+TARGETS += $(BUILD_LIBJIMAGE)\n+\n+##########################################################################################\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  LIBJLI_EXCLUDE_FILES += java_md.c\n+endif\n+\n+ifeq ($(call isTargetOs, windows), true)\n+  # Supply the name of the C runtime lib.\n+  LIBJLI_CFLAGS += -DMSVCR_DLL_NAME='\"$(notdir $(MSVCR_DLL))\"'\n+  ifneq ($(VCRUNTIME_1_DLL), )\n+    LIBJLI_CFLAGS += -DVCRUNTIME_1_DLL_NAME='\"$(notdir $(VCRUNTIME_1_DLL))\"'\n+  endif\n+  ifneq ($(MSVCP_DLL), )\n+    LIBJLI_CFLAGS += -DMSVCP_DLL_NAME='\"$(notdir $(MSVCP_DLL))\"'\n+  endif\n+endif\n+\n+LIBJLI_CFLAGS += $(LIBZ_CFLAGS)\n+\n+ifeq ($(INCLUDE_TSAN), true)\n+  LIBJLI_CFLAGS += -DINCLUDE_TSAN\n+endif\n+\n+ifneq ($(USE_EXTERNAL_LIBZ), true)\n+  LIBJLI_EXTRA_FILES += \\\n+      $(addprefix $(TOPDIR)\/src\/java.base\/share\/native\/libzip\/zlib\/, \\\n+          inflate.c \\\n+          inftrees.c \\\n+          inffast.c \\\n+          zadler32.c \\\n+          zcrc32.c \\\n+          zutil.c \\\n+      )\n+endif\n+\n+$(eval $(call SetupJdkLibrary, BUILD_LIBJLI, \\\n+    NAME := jli, \\\n+    OUTPUT_DIR := $(INSTALL_LIBRARIES_HERE), \\\n+    EXCLUDE_FILES := $(LIBJLI_EXCLUDE_FILES), \\\n+    EXTRA_FILES := $(LIBJLI_EXTRA_FILES), \\\n+    OPTIMIZATION := HIGH, \\\n+    CFLAGS := $(CFLAGS_JDKLIB) $(LIBJLI_CFLAGS), \\\n+    DISABLED_WARNINGS_gcc := unused-function implicit-fallthrough, \\\n+    DISABLED_WARNINGS_clang := sometimes-uninitialized format-nonliteral, \\\n+    LDFLAGS := $(LDFLAGS_JDKLIB) \\\n+        $(call SET_SHARED_LIBRARY_ORIGIN), \\\n+    LIBS_unix := $(LIBZ_LIBS), \\\n+    LIBS_linux := $(LIBDL) -lpthread, \\\n+    LIBS_aix := $(LIBDL),\\\n+    LIBS_macosx := -framework Cocoa -framework Security -framework ApplicationServices, \\\n+    LIBS_windows := advapi32.lib comctl32.lib user32.lib, \\\n+))\n+\n+TARGETS += $(BUILD_LIBJLI)\n+\n+LIBJLI_SRC_DIRS := $(call FindSrcDirsForComponent, java.base, libjli)\n+\n+ifeq ($(call isTargetOs, aix), true)\n+  # AIX also requires a static libjli because the compiler doesn't support '-rpath'\n+  $(eval $(call SetupNativeCompilation, BUILD_LIBJLI_STATIC, \\\n+      NAME := jli_static, \\\n+      TYPE := STATIC_LIBRARY, \\\n+      OUTPUT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE), \\\n+      SRC := $(LIBJLI_SRC_DIRS), \\\n+      EXCLUDE_FILES := $(LIBJLI_EXCLUDE_FILES), \\\n+      EXTRA_FILES := $(LIBJLI_EXTRA_FILES), \\\n+      OPTIMIZATION := HIGH, \\\n+      CFLAGS := $(STATIC_LIBRARY_FLAGS) $(CFLAGS_JDKLIB) $(LIBJLI_CFLAGS) \\\n+          $(addprefix -I, $(LIBJLI_SRC_DIRS)), \\\n+      ARFLAGS := $(ARFLAGS), \\\n+      OBJECT_DIR := $(SUPPORT_OUTPUTDIR)\/native\/$(MODULE)\/libjli_static))\n+\n+  TARGETS += $(BUILD_LIBJLI_STATIC)\n+\n+endif\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":242,"deletions":0,"binary":false,"changes":242,"status":"added"},{"patch":"@@ -853,4 +853,0 @@\n-ifeq ($(call And, $(call isTargetOs, solaris) $(call isTargetCpuArch, sparc)), false)\n-  BUILD_HOTSPOT_JTREG_EXCLUDE += liboverflow.c exeThreadSignalMask.c\n-endif\n-\n@@ -883,4 +879,0 @@\n-ifeq ($(call isTargetOs, solaris), true)\n-    BUILD_HOTSPOT_JTREG_EXCLUDE += libterminatedThread.c\n-endif\n-\n@@ -890,2 +882,1 @@\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := jvm.lib\n-\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit := jvm.lib\n@@ -893,1 +884,0 @@\n-    BUILD_HOTSPOT_JTREG_EXECUTABLES_LIBS_exejvm-test-launcher := -ljvm\n@@ -1527,0 +1517,1 @@\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_LIBS_libatExit += -ljvm\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":2,"deletions":11,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -472,2 +472,1 @@\n-  bool needs_thread_local_poll = generate_poll &&\n-    SafepointMechanism::uses_thread_local_poll() && table != safepoint_table;\n+  bool needs_thread_local_poll = generate_poll && table != safepoint_table;\n@@ -1176,27 +1175,0 @@\n-#if INCLUDE_JVMCI\n-    if (MethodProfileWidth == 0) {\n-      update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));\n-    }\n-#else \/\/ INCLUDE_JVMCI\n-    update_mdp_by_constant(mdp,\n-                           in_bytes(VirtualCallData::\n-                                    virtual_call_data_size()));\n-#endif \/\/ INCLUDE_JVMCI\n-    bind(profile_continue);\n-  }\n-}\n-\n-#if INCLUDE_JVMCI\n-void InterpreterMacroAssembler::profile_called_method(Register method, Register mdp, Register reg2) {\n-  assert_different_registers(method, mdp, reg2);\n-  if (ProfileInterpreter && MethodProfileWidth > 0) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    Label done;\n-    record_item_in_profile_helper(method, mdp, reg2, 0, done, MethodProfileWidth,\n-      &VirtualCallData::method_offset, &VirtualCallData::method_count_offset, in_bytes(VirtualCallData::nonprofiled_receiver_count_offset()));\n-    bind(done);\n-\n@@ -1207,1 +1179,0 @@\n-#endif \/\/ INCLUDE_JVMCI\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":2,"deletions":31,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2014, 2019, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2014, 2020, Red Hat Inc. All rights reserved.\n@@ -32,0 +32,1 @@\n+#include \"gc\/shared\/barrierSetAssembler.hpp\"\n@@ -47,1 +48,1 @@\n-#if COMPILER2_OR_JVMCI\n+#ifdef COMPILER2\n@@ -173,1 +174,1 @@\n-#ifndef COMPILER2\n+#if !COMPILER2_OR_JVMCI\n@@ -178,0 +179,1 @@\n+\n@@ -734,0 +736,3 @@\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->c2i_entry_barrier(masm);\n+\n@@ -1127,1 +1132,1 @@\n-static void rt_call(MacroAssembler* masm, address dest, int gpargs, int fpargs, int type) {\n+static void rt_call(MacroAssembler* masm, address dest) {\n@@ -1132,2 +1137,0 @@\n-    assert((unsigned)gpargs < 256, \"eek!\");\n-    assert((unsigned)fpargs < 32, \"eek!\");\n@@ -1506,0 +1509,3 @@\n+  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n+  bs->nmethod_entry_barrier(masm);\n+\n@@ -1815,27 +1821,1 @@\n-  {\n-    int return_type = 0;\n-    switch (ret_type) {\n-    case T_VOID: break;\n-      return_type = 0; break;\n-    case T_CHAR:\n-    case T_BYTE:\n-    case T_SHORT:\n-    case T_INT:\n-    case T_BOOLEAN:\n-    case T_LONG:\n-      return_type = 1; break;\n-    case T_ARRAY:\n-    case T_OBJECT:\n-      return_type = 1; break;\n-    case T_FLOAT:\n-      return_type = 2; break;\n-    case T_DOUBLE:\n-      return_type = 3; break;\n-    default:\n-      ShouldNotReachHere();\n-    }\n-    rt_call(masm, native_func,\n-            int_args + 2, \/\/ AArch64 passes up to 8 args in int registers\n-            float_args,   \/\/ and up to 8 float args\n-            return_type);\n-  }\n+  rt_call(masm, native_func);\n@@ -2067,1 +2047,1 @@\n-    rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C), 3, 0, 1);\n+    rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::complete_monitor_unlocking_C));\n@@ -2094,1 +2074,1 @@\n-  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages), 0, 0, 0);\n+  rt_call(masm, CAST_FROM_FN_PTR(address, SharedRuntime::reguard_yellow_pages));\n@@ -2573,1 +2553,1 @@\n-#if COMPILER2_OR_JVMCI\n+#ifdef COMPILER2\n@@ -2764,1 +2744,1 @@\n-#endif \/\/ COMPILER2_OR_JVMCI\n+#endif \/\/ COMPILER2\n@@ -2842,1 +2822,1 @@\n-  if (SafepointMechanism::uses_thread_local_poll() && !cause_return) {\n+  if (!cause_return) {\n@@ -2972,1 +2952,1 @@\n-#if COMPILER2_OR_JVMCI\n+#ifdef COMPILER2\n@@ -3101,1 +3081,1 @@\n-#endif \/\/ COMPILER2_OR_JVMCI\n+#endif \/\/ COMPILER2\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":20,"deletions":40,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2621,1 +2621,1 @@\n-  if (! UseBarriersForVolatile) {\n+  if (!is_c1_or_interpreter_only()){\n@@ -3136,0 +3136,3 @@\n+  \/\/ Must prevent reordering of the following cp cache loads with bytecode load\n+  __ membar(MacroAssembler::LoadLoad);\n+\n@@ -3231,0 +3234,4 @@\n+\n+  \/\/ Must prevent reordering of the following cp cache loads with bytecode load\n+  __ membar(MacroAssembler::LoadLoad);\n+\n@@ -3247,1 +3254,1 @@\n-  if (! UseBarriersForVolatile) {\n+  if (!is_c1_or_interpreter_only()) {\n@@ -3312,1 +3319,1 @@\n-  if (! UseBarriersForVolatile) {\n+  if (!is_c1_or_interpreter_only()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-  verify_oop(obj);\n+  interp_verify_oop(obj, atos);\n@@ -62,1 +62,2 @@\n-  load_klass(obj, obj);\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  load_klass(obj, obj, tmp_load_klass);\n@@ -352,1 +353,1 @@\n-               verify_oop(rax, state);              break;\n+               interp_verify_oop(rax, state);         break;\n@@ -373,1 +374,1 @@\n-               verify_oop(rax, state);                break;\n+               interp_verify_oop(rax, state);         break;\n@@ -659,1 +660,1 @@\n-  verify_oop(rax, state);\n+  interp_verify_oop(rax, state);\n@@ -663,1 +664,1 @@\n-  verify_oop(rax, state);\n+  interp_verify_oop(rax, state);\n@@ -725,1 +726,1 @@\n-  verify_oop(rax, state);\n+  interp_verify_oop(rax, state);\n@@ -748,1 +749,1 @@\n-  verify_oop(rax, state);\n+  interp_verify_oop(rax, state);\n@@ -847,1 +848,1 @@\n-    verify_oop(rax, state);\n+    interp_verify_oop(rax, state);\n@@ -853,1 +854,1 @@\n-  if (SafepointMechanism::uses_thread_local_poll() && table != safepoint_table && generate_poll) {\n+  if (table != safepoint_table && generate_poll) {\n@@ -869,1 +870,1 @@\n-  if (SafepointMechanism::uses_thread_local_poll() && table != safepoint_table && generate_poll) {\n+  if (table != safepoint_table && generate_poll) {\n@@ -1201,1 +1202,2 @@\n-      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, false, done, &slow_case);\n+      Register rklass_decode_tmp = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+      biased_locking_enter(lock_reg, obj_reg, swap_reg, tmp_reg, rklass_decode_tmp, false, done, &slow_case);\n@@ -1642,27 +1644,0 @@\n-#if INCLUDE_JVMCI\n-    if (MethodProfileWidth == 0) {\n-      update_mdp_by_constant(mdp, in_bytes(VirtualCallData::virtual_call_data_size()));\n-    }\n-#else \/\/ INCLUDE_JVMCI\n-    update_mdp_by_constant(mdp,\n-                           in_bytes(VirtualCallData::\n-                                    virtual_call_data_size()));\n-#endif \/\/ INCLUDE_JVMCI\n-    bind(profile_continue);\n-  }\n-}\n-\n-#if INCLUDE_JVMCI\n-void InterpreterMacroAssembler::profile_called_method(Register method, Register mdp, Register reg2) {\n-  assert_different_registers(method, mdp, reg2);\n-  if (ProfileInterpreter && MethodProfileWidth > 0) {\n-    Label profile_continue;\n-\n-    \/\/ If no method data exists, go to profile_continue.\n-    test_method_data_pointer(mdp, profile_continue);\n-\n-    Label done;\n-    record_item_in_profile_helper(method, mdp, reg2, 0, done, MethodProfileWidth,\n-      &VirtualCallData::method_offset, &VirtualCallData::method_count_offset, in_bytes(VirtualCallData::nonprofiled_receiver_count_offset()));\n-    bind(done);\n-\n@@ -1673,1 +1648,0 @@\n-#endif \/\/ INCLUDE_JVMCI\n@@ -1980,1 +1954,1 @@\n-void InterpreterMacroAssembler::verify_oop(Register reg, TosState state) {\n+void InterpreterMacroAssembler::_interp_verify_oop(Register reg, TosState state, const char* file, int line) {\n@@ -1982,1 +1956,1 @@\n-    MacroAssembler::verify_oop(reg);\n+    MacroAssembler::_verify_oop(reg, \"broken oop\", file, line);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":17,"deletions":43,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -958,1 +958,1 @@\n-    __ load_klass(temp, receiver);\n+    __ load_klass(temp, receiver, rscratch1);\n@@ -2142,1 +2142,1 @@\n-  __ load_klass(rscratch1, receiver);\n+  __ load_klass(rscratch1, receiver, rscratch2);\n@@ -2495,1 +2495,1 @@\n-      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, false, lock_done, &slow_path_lock);\n+      __ biased_locking_enter(lock_reg, obj_reg, swap_reg, rscratch1, rscratch2, false, lock_done, &slow_path_lock);\n@@ -3548,1 +3548,1 @@\n-  if (SafepointMechanism::uses_thread_local_poll() && !cause_return) {\n+  if (!cause_return) {\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -1240,0 +1240,1 @@\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n@@ -1241,1 +1242,1 @@\n-  __ load_klass(rbx, rax);\n+  __ load_klass(rbx, rax, tmp_load_klass);\n@@ -1243,1 +1244,1 @@\n-  __ load_klass(rax, rdx);\n+  __ load_klass(rax, rdx, tmp_load_klass);\n@@ -1286,1 +1287,2 @@\n-  __ load_klass(rcx, rdx);\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  __ load_klass(rcx, rdx, tmp_load_klass);\n@@ -2756,1 +2758,2 @@\n-    __ load_klass(rdi, robj);\n+    Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ load_klass(rdi, robj, tmp_load_klass);\n@@ -2767,1 +2770,1 @@\n-  if (SafepointMechanism::uses_thread_local_poll() && _desc->bytecode() != Bytecodes::_return_register_finalizer) {\n+  if (_desc->bytecode() != Bytecodes::_return_register_finalizer) {\n@@ -3912,1 +3915,2 @@\n-  __ load_klass(rax, recv);\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  __ load_klass(rax, recv, tmp_load_klass);\n@@ -3918,1 +3922,0 @@\n-  __ profile_called_method(method, rdx, rbcp);\n@@ -4005,1 +4008,2 @@\n-  __ load_klass(rlocals, rcx);\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  __ load_klass(rlocals, rcx, tmp_load_klass);\n@@ -4028,1 +4032,1 @@\n-  __ load_klass(rdx, rcx);\n+  __ load_klass(rdx, rcx, tmp_load_klass);\n@@ -4070,1 +4074,0 @@\n-  __ profile_called_method(rbx, rbcp, rdx);\n@@ -4290,1 +4293,2 @@\n-    __ store_klass(rax, rcx);  \/\/ klass\n+    Register tmp_store_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+    __ store_klass(rax, rcx, tmp_store_klass);  \/\/ klass\n@@ -4392,1 +4396,2 @@\n-  __ load_klass(rbx, rdx);\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  __ load_klass(rbx, rdx, tmp_load_klass);\n@@ -4449,1 +4454,2 @@\n-  __ load_klass(rdx, rdx);\n+  Register tmp_load_klass = LP64_ONLY(rscratch1) NOT_LP64(noreg);\n+  __ load_klass(rdx, rdx, tmp_load_klass);\n@@ -4454,1 +4460,1 @@\n-  __ load_klass(rdx, rax);\n+  __ load_klass(rdx, rax, tmp_load_klass);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -365,0 +365,14 @@\n+\/\/ On Posix platforms, reservations are done using mmap which can be released in parts. So splitting is a no-op.\n+void os::split_reserved_memory(char *base, size_t size, size_t split) {\n+  char* const split_address = base + split;\n+  assert(size > 0, \"Sanity\");\n+  assert(size > split, \"Sanity\");\n+  assert(split > 0, \"Sanity\");\n+  assert(is_aligned(base, os::vm_allocation_granularity()), \"Sanity\");\n+  assert(is_aligned(split_address, os::vm_allocation_granularity()), \"Sanity\");\n+\n+  \/\/ NMT: tell NMT to track both parts individually from now on.\n+  MemTracker::record_virtual_memory_split_reserved(base, size, split);\n+\n+}\n+\n@@ -385,1 +399,1 @@\n-  st->print(\"load average:\");\n+  st->print(\"load average: \");\n@@ -416,3 +430,2 @@\n-\n-void os::Posix::print_rlimit_info(outputStream* st) {\n-  st->print(\"rlimit:\");\n+static void print_rlimit(outputStream* st, const char* msg,\n+                         int resource, bool output_k = false) {\n@@ -421,4 +434,20 @@\n-  st->print(\" STACK \");\n-  getrlimit(RLIMIT_STACK, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT \"k\", uint64_t(rlim.rlim_cur) \/ 1024);\n+  st->print(\" %s \", msg);\n+  int res = getrlimit(resource, &rlim);\n+  if (res == -1) {\n+    st->print(\"could not obtain value\");\n+  } else {\n+    \/\/ soft limit\n+    if (rlim.rlim_cur == RLIM_INFINITY) { st->print(\"infinity\"); }\n+    else {\n+      if (output_k) { st->print(UINT64_FORMAT \"k\", uint64_t(rlim.rlim_cur) \/ 1024); }\n+      else { st->print(UINT64_FORMAT, uint64_t(rlim.rlim_cur)); }\n+    }\n+    \/\/ hard limit\n+    st->print(\"\/\");\n+    if (rlim.rlim_max == RLIM_INFINITY) { st->print(\"infinity\"); }\n+    else {\n+      if (output_k) { st->print(UINT64_FORMAT \"k\", uint64_t(rlim.rlim_max) \/ 1024); }\n+      else { st->print(UINT64_FORMAT, uint64_t(rlim.rlim_max)); }\n+    }\n+  }\n+}\n@@ -426,4 +455,4 @@\n-  st->print(\", CORE \");\n-  getrlimit(RLIMIT_CORE, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT \"k\", uint64_t(rlim.rlim_cur) \/ 1024);\n+void os::Posix::print_rlimit_info(outputStream* st) {\n+  st->print(\"rlimit (soft\/hard):\");\n+  print_rlimit(st, \"STACK\", RLIMIT_STACK, true);\n+  print_rlimit(st, \", CORE\", RLIMIT_CORE, true);\n@@ -431,1 +460,0 @@\n-  \/\/ Isn't there on solaris\n@@ -435,14 +463,4 @@\n-  st->print(\", THREADS \");\n-  getrlimit(RLIMIT_THREADS, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));\n-#elif !defined(SOLARIS)\n-  st->print(\", NPROC \");\n-  getrlimit(RLIMIT_NPROC, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));\n-#endif\n-  st->print(\", NOFILE \");\n-  getrlimit(RLIMIT_NOFILE, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));\n+  print_rlimit(st, \", THREADS\", RLIMIT_THREADS);\n+#else\n+  print_rlimit(st, \", NPROC\", RLIMIT_NPROC);\n+#endif\n@@ -451,4 +469,4 @@\n-  st->print(\", AS \");\n-  getrlimit(RLIMIT_AS, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT \"k\", uint64_t(rlim.rlim_cur) \/ 1024);\n+  print_rlimit(st, \", NOFILE\", RLIMIT_NOFILE);\n+  print_rlimit(st, \", AS\", RLIMIT_AS, true);\n+  print_rlimit(st, \", CPU\", RLIMIT_CPU);\n+  print_rlimit(st, \", DATA\", RLIMIT_DATA, true);\n@@ -456,4 +474,2 @@\n-  st->print(\", CPU \");\n-  getrlimit(RLIMIT_CPU, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT, uint64_t(rlim.rlim_cur));\n+  \/\/ maximum size of files that the process may create\n+  print_rlimit(st, \", FSIZE\", RLIMIT_FSIZE, true);\n@@ -461,4 +477,5 @@\n-  st->print(\", DATA \");\n-  getrlimit(RLIMIT_DATA, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT \"k\", uint64_t(rlim.rlim_cur) \/ 1024);\n+#if defined(LINUX) || defined(__APPLE__)\n+  \/\/ maximum number of bytes of memory that may be locked into RAM\n+  \/\/ (rounded down to the nearest  multiple of system pagesize)\n+  print_rlimit(st, \", MEMLOCK\", RLIMIT_MEMLOCK, true);\n+#endif\n@@ -466,4 +483,4 @@\n-  st->print(\", FSIZE \");\n-  getrlimit(RLIMIT_FSIZE, &rlim);\n-  if (rlim.rlim_cur == RLIM_INFINITY) st->print(\"infinity\");\n-  else st->print(UINT64_FORMAT \"k\", uint64_t(rlim.rlim_cur) \/ 1024);\n+  \/\/ MacOS; The maximum size (in bytes) to which a process's resident set size may grow.\n+#if defined(__APPLE__)\n+  print_rlimit(st, \", RSS\", RLIMIT_RSS, true);\n+#endif\n@@ -476,1 +493,1 @@\n-  st->print(\"uname:\");\n+  st->print(\"uname: \");\n@@ -1112,15 +1129,0 @@\n-#if defined(__sparc) && defined(SOLARIS)\n-\/\/ define Solaris Sparc M7 ADI SEGV signals\n-#if !defined(SEGV_ACCADI)\n-#define SEGV_ACCADI 3\n-#endif\n-    { SIGSEGV, SEGV_ACCADI,  \"SEGV_ACCADI\",  \"ADI not enabled for mapped object.\" },\n-#if !defined(SEGV_ACCDERR)\n-#define SEGV_ACCDERR 4\n-#endif\n-    { SIGSEGV, SEGV_ACCDERR, \"SEGV_ACCDERR\", \"ADI disrupting exception.\" },\n-#if !defined(SEGV_ACCPERR)\n-#define SEGV_ACCPERR 5\n-#endif\n-    { SIGSEGV, SEGV_ACCPERR, \"SEGV_ACCPERR\", \"ADI precise exception.\" },\n-#endif \/\/ defined(__sparc) && defined(SOLARIS)\n@@ -1285,6 +1287,0 @@\n-#if defined (SOLARIS)\n-    \/\/ Note: we cannot use pthread_kill on Solaris - not because\n-    \/\/ its missing, but because we do not have the pthread_t id.\n-    int status = thr_kill(osthread->thread_id(), sig);\n-#else\n-#endif\n@@ -1312,2 +1308,0 @@\n-#elif defined(SOLARIS)\n-   return Solaris::ucontext_get_pc(ctx);\n@@ -1326,2 +1320,0 @@\n-#elif defined(SOLARIS)\n-   Solaris::ucontext_set_pc(ctx, pc);\n@@ -1432,1 +1424,1 @@\n-  size_t os_min_stack_allowed = SOLARIS_ONLY(thr_min_stack()) NOT_SOLARIS(PTHREAD_STACK_MIN);\n+  size_t os_min_stack_allowed = PTHREAD_STACK_MIN;\n@@ -1642,2 +1634,1 @@\n-  \/\/ Solaris has it's own PlatformMutex, distinct from the one for POSIX.\n-  NOT_SOLARIS(os::PlatformMutex::init();)\n+  os::PlatformMutex::init();\n@@ -1646,1 +1637,0 @@\n-#ifndef SOLARIS\n@@ -1662,1 +1652,0 @@\n-#endif\n@@ -1679,0 +1668,2 @@\n+bool os::Posix::_supports_monotonic_clock = false;\n+\n@@ -1694,1 +1685,1 @@\n-  \/\/ For linux we need librt, for other OS we can find\n+  \/\/ For older linux we need librt, for other OS we can find\n@@ -1714,0 +1705,2 @@\n+    _clock_gettime = clock_gettime_func;\n+    _clock_getres = clock_getres_func;\n@@ -1721,9 +1714,1 @@\n-      _clock_gettime = clock_gettime_func;\n-      _clock_getres = clock_getres_func;\n-    } else {\n-#ifdef NEEDS_LIBRT\n-      \/\/ Close librt if there is no monotonic clock.\n-      if (handle != RTLD_DEFAULT) {\n-        dlclose(handle);\n-      }\n-#endif\n+      _supports_monotonic_clock = true;\n@@ -1747,1 +1732,0 @@\n-#ifndef SOLARIS\n@@ -1762,2 +1746,0 @@\n-#endif \/\/ !SOLARIS\n-\n@@ -1767,1 +1749,0 @@\n-#ifndef SOLARIS\n@@ -1775,1 +1756,0 @@\n-#endif \/\/ !SOLARIS\n@@ -1785,1 +1765,0 @@\n-#ifndef SOLARIS\n@@ -1790,1 +1769,0 @@\n-#endif \/\/ !SOLARIS\n@@ -1931,1 +1909,0 @@\n-#ifndef SOLARIS\n@@ -1984,1 +1961,2 @@\n-      assert_status(status == 0, status, \"cond_wait\");\n+      assert_status(status == 0 MACOS_ONLY(|| status == ETIMEDOUT),\n+                    status, \"cond_wait\");\n@@ -2175,1 +2153,2 @@\n-    assert_status(status == 0, status, \"cond_timedwait\");\n+    assert_status(status == 0 MACOS_ONLY(|| status == ETIMEDOUT),\n+                  status, \"cond_wait\");\n@@ -2356,1 +2335,2 @@\n-    assert_status(status == 0, status, \"cond_wait\");\n+    assert_status(status == 0 MACOS_ONLY(|| status == ETIMEDOUT),\n+                  status, \"cond_wait\");\n@@ -2360,2 +2340,0 @@\n-\n-#endif \/\/ !SOLARIS\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":75,"deletions":97,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+#include \"runtime\/safepointMechanism.hpp\"\n@@ -97,12 +98,1 @@\n-#ifdef SPARC_WORKS\n-  void *esp;\n-  __asm__(\"mov %%\" SPELL_REG_SP \", %0\":\"=r\"(esp));\n-  return (address) ((char*)esp + sizeof(long)*2);\n-#elif defined(__clang__)\n-  void* esp;\n-  __asm__ __volatile__ (\"mov %%\" SPELL_REG_SP \", %0\":\"=r\"(esp):);\n-  return (address) esp;\n-#else\n-  register void *esp __asm__ (SPELL_REG_SP);\n-  return (address) esp;\n-#endif\n+  return (address)__builtin_frame_address(0);\n@@ -231,4 +221,1 @@\n-#ifdef SPARC_WORKS\n-  intptr_t **ebp;\n-  __asm__(\"mov %%\" SPELL_REG_FP \", %0\":\"=r\"(ebp));\n-#elif defined(__clang__)\n+#if defined(__clang__)\n@@ -362,1 +349,1 @@\n-      if (thread->on_local_stack(addr)) {\n+      if (thread->is_in_full_stack(addr)) {\n@@ -431,1 +418,1 @@\n-      if (sig == SIGSEGV && os::is_poll_address((address)info->si_addr)) {\n+      if (sig == SIGSEGV && SafepointMechanism::is_poll_address((address)info->si_addr)) {\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -1099,1 +1099,1 @@\n-  ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name);\n+  ID annotation_index(const ClassLoaderData* loader_data, const Symbol* name, bool can_access_vm_annotations);\n@@ -1237,0 +1237,1 @@\n+                              const bool can_access_vm_annotations,\n@@ -1282,1 +1283,1 @@\n-    AnnotationCollector::ID id = coll->annotation_index(loader_data, aname);\n+    AnnotationCollector::ID id = coll->annotation_index(loader_data, aname, can_access_vm_annotations);\n@@ -1408,0 +1409,1 @@\n+                          _can_access_vm_annotations,\n@@ -2078,1 +2080,2 @@\n-                                      const Symbol* name) {\n+                                      const Symbol* name,\n+                                      const bool can_access_vm_annotations) {\n@@ -2081,1 +2084,1 @@\n-  const bool privileged = loader_data->is_the_null_class_loader_data() ||\n+  const bool privileged = loader_data->is_boot_class_loader_data() ||\n@@ -2083,1 +2086,1 @@\n-                          loader_data->is_unsafe_anonymous();\n+                          can_access_vm_annotations;\n@@ -2703,0 +2706,1 @@\n+                          _can_access_vm_annotations,\n@@ -2897,0 +2901,4 @@\n+  if (is_hidden()) { \/\/ Mark methods in hidden classes as 'hidden'.\n+    m->set_hidden(true);\n+  }\n+\n@@ -3236,0 +3244,35 @@\n+u2 ClassFileParser::parse_classfile_permitted_subclasses_attribute(const ClassFileStream* const cfs,\n+                                                                   const u1* const permitted_subclasses_attribute_start,\n+                                                                   TRAPS) {\n+  const u1* const current_mark = cfs->current();\n+  u2 length = 0;\n+  if (permitted_subclasses_attribute_start != NULL) {\n+    cfs->set_current(permitted_subclasses_attribute_start);\n+    cfs->guarantee_more(2, CHECK_0);  \/\/ length\n+    length = cfs->get_u2_fast();\n+  }\n+  if (length < 1) {\n+    classfile_parse_error(\"PermittedSubclasses attribute is empty in class file %s\", CHECK_0);\n+  }\n+  const int size = length;\n+  Array<u2>* const permitted_subclasses = MetadataFactory::new_array<u2>(_loader_data, size, CHECK_0);\n+  _permitted_subclasses = permitted_subclasses;\n+\n+  int index = 0;\n+  cfs->guarantee_more(2 * length, CHECK_0);\n+  for (int n = 0; n < length; n++) {\n+    const u2 class_info_index = cfs->get_u2_fast();\n+    check_property(\n+      valid_klass_reference_at(class_info_index),\n+      \"Permitted subclass class_info_index %u has bad constant type in class file %s\",\n+      class_info_index, CHECK_0);\n+    permitted_subclasses->at_put(index++, class_info_index);\n+  }\n+  assert(index == size, \"wrong size\");\n+\n+  \/\/ Restore buffer's current position.\n+  cfs->set_current(current_mark);\n+\n+  return length;\n+}\n+\n@@ -3500,0 +3543,6 @@\n+bool ClassFileParser::supports_sealed_types() {\n+  return _major_version == JVM_CLASSFILE_MAJOR_VERSION &&\n+         _minor_version == JAVA_PREVIEW_MINOR_VERSION &&\n+         Arguments::enable_preview();\n+}\n+\n@@ -3502,2 +3551,2 @@\n-    _minor_version == JAVA_PREVIEW_MINOR_VERSION &&\n-    Arguments::enable_preview();\n+         _minor_version == JAVA_PREVIEW_MINOR_VERSION &&\n+         Arguments::enable_preview();\n@@ -3518,0 +3567,2 @@\n+  \/\/ Set _permitted_subclasses attribute to default sentinel\n+  _permitted_subclasses = Universe::the_empty_short_array();\n@@ -3523,0 +3574,1 @@\n+  bool parsed_permitted_subclasses_attribute = false;\n@@ -3546,0 +3598,2 @@\n+  const u1* permitted_subclasses_attribute_start = NULL;\n+  u4  permitted_subclasses_attribute_length = 0;\n@@ -3628,0 +3682,1 @@\n+                          _can_access_vm_annotations,\n@@ -3761,0 +3816,20 @@\n+          } else if (_major_version >= JAVA_15_VERSION) {\n+            \/\/ Check for PermittedSubclasses tag\n+            if (tag == vmSymbols::tag_permitted_subclasses()) {\n+              if (supports_sealed_types()) {\n+                if (parsed_permitted_subclasses_attribute) {\n+                  classfile_parse_error(\"Multiple PermittedSubclasses attributes in class file %s\", CHECK);\n+                }\n+                \/\/ Classes marked ACC_FINAL cannot have a PermittedSubclasses attribute.\n+                if (_access_flags.is_final()) {\n+                  classfile_parse_error(\"PermittedSubclasses attribute in final class file %s\", CHECK);\n+                }\n+                parsed_permitted_subclasses_attribute = true;\n+                permitted_subclasses_attribute_start = cfs->current();\n+                permitted_subclasses_attribute_length = attribute_length;\n+              }\n+              cfs->skip_u1(attribute_length, CHECK);\n+            } else {\n+              \/\/ Unknown attribute\n+              cfs->skip_u1(attribute_length, CHECK);\n+            }\n@@ -3829,0 +3904,12 @@\n+  if (parsed_permitted_subclasses_attribute) {\n+    const u2 num_subclasses = parse_classfile_permitted_subclasses_attribute(\n+                            cfs,\n+                            permitted_subclasses_attribute_start,\n+                            CHECK);\n+    if (_need_verify) {\n+      guarantee_property(\n+        permitted_subclasses_attribute_length == sizeof(num_subclasses) + sizeof(u2) * num_subclasses,\n+        \"Wrong PermittedSubclasses attribute length in class file %s\", CHECK);\n+    }\n+  }\n+\n@@ -3894,1 +3981,1 @@\n-  this_klass->set_local_interfaces(_local_interfaces);\n+  this_klass->set_permitted_subclasses(_permitted_subclasses);\n@@ -3897,2 +3984,3 @@\n-  \/\/ Delay the setting of _transitive_interfaces until after initialize_supers() in\n-  \/\/ fill_instance_klass(). It is because the _transitive_interfaces may be shared with\n+  \/\/ Delay the setting of _local_interfaces and _transitive_interfaces until after\n+  \/\/ initialize_supers() in fill_instance_klass(). It is because the _local_interfaces could\n+  \/\/ be shared with _transitive_interfaces and _transitive_interfaces may be shared with\n@@ -4223,17 +4311,0 @@\n-  \/\/ The next classes have predefined hard-coded fields offsets\n-  \/\/ (see in JavaClasses::compute_hard_coded_offsets()).\n-  \/\/ Use default fields allocation order for them.\n-  if (_loader_data->class_loader() == NULL &&\n-      (_class_name == vmSymbols::java_lang_ref_Reference() ||\n-       _class_name == vmSymbols::java_lang_Boolean() ||\n-       _class_name == vmSymbols::java_lang_Character() ||\n-       _class_name == vmSymbols::java_lang_Float() ||\n-       _class_name == vmSymbols::java_lang_Double() ||\n-       _class_name == vmSymbols::java_lang_Byte() ||\n-       _class_name == vmSymbols::java_lang_Short() ||\n-       _class_name == vmSymbols::java_lang_Integer() ||\n-       _class_name == vmSymbols::java_lang_Long())) {\n-    allocate_oops_first = true;     \/\/ Allocate oops first\n-    compact_fields   = false; \/\/ Don't compact fields\n-  }\n-\n@@ -4721,0 +4792,23 @@\n+    const InstanceKlass* super_ik = InstanceKlass::cast(super);\n+\n+    if (super->is_final()) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_VerifyError(),\n+        \"class %s cannot inherit from final class %s\",\n+        this_klass->external_name(),\n+        super_ik->external_name());\n+      return;\n+    }\n+\n+    if (super_ik->is_sealed() && !super_ik->has_as_permitted_subclass(this_klass)) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_IncompatibleClassChangeError(),\n+        \"class %s cannot inherit from sealed class %s\",\n+        this_klass->external_name(),\n+        super_ik->external_name());\n+      return;\n+    }\n@@ -4726,1 +4820,0 @@\n-      assert(super->is_instance_klass(), \"super is not instance klass\");\n@@ -4782,0 +4875,13 @@\n+\n+    if (k->is_sealed() && !k->has_as_permitted_subclass(this_klass)) {\n+      ResourceMark rm(THREAD);\n+      Exceptions::fthrow(\n+        THREAD_AND_LOCATION,\n+        vmSymbols::java_lang_IncompatibleClassChangeError(),\n+        \"class %s cannot %s sealed interface %s\",\n+        this_klass->external_name(),\n+        this_klass->is_interface() ? \"extend\" : \"implement\",\n+        k->external_name());\n+      return;\n+    }\n+\n@@ -5306,1 +5412,1 @@\n-                                  CHECK_0);\n+                                  CHECK_NULL);\n@@ -5318,1 +5424,1 @@\n-        classfile_parse_error(\"Array type descriptor has more than 255 dimensions in class file %s\", CHECK_0);\n+        classfile_parse_error(\"Array type descriptor has more than 255 dimensions in class file %s\", CHECK_NULL);\n@@ -5624,1 +5730,3 @@\n-InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook, TRAPS) {\n+InstanceKlass* ClassFileParser::create_instance_klass(bool changed_by_loadhook,\n+                                                      const ClassInstanceInfo& cl_inst_info,\n+                                                      TRAPS) {\n@@ -5632,1 +5740,5 @@\n-  fill_instance_klass(ik, changed_by_loadhook, CHECK_NULL);\n+  if (is_hidden()) {\n+    mangle_hidden_class_name(ik);\n+  }\n+\n+  fill_instance_klass(ik, changed_by_loadhook, cl_inst_info, CHECK_NULL);\n@@ -5658,1 +5770,4 @@\n-void ClassFileParser::fill_instance_klass(InstanceKlass* ik, bool changed_by_loadhook, TRAPS) {\n+void ClassFileParser::fill_instance_klass(InstanceKlass* ik,\n+                                          bool changed_by_loadhook,\n+                                          const ClassInstanceInfo& cl_inst_info,\n+                                          TRAPS) {\n@@ -5694,0 +5809,5 @@\n+  \/\/ can only set dynamic nest-host after static nest information is set\n+  if (cl_inst_info.dynamic_nest_host() != NULL) {\n+    ik->set_nest_host(cl_inst_info.dynamic_nest_host(), THREAD);\n+  }\n+\n@@ -5700,1 +5820,0 @@\n-  assert(NULL == _local_interfaces, \"invariant\");\n@@ -5703,0 +5822,1 @@\n+  assert(NULL == _permitted_subclasses, \"invariant\");\n@@ -5718,1 +5838,1 @@\n-  if (is_unsafe_anonymous()) {\n+  if (_is_hidden || is_unsafe_anonymous()) {\n@@ -5720,3 +5840,3 @@\n-    \/\/ anonymous class itself. If this class needs to refer to its own methods or\n-    \/\/ fields, it would use a CONSTANT_MethodRef, etc, which would reference\n-    \/\/ _this_class_index. However, because this class is anonymous (it's\n+    \/\/ hidden or anonymous class itself. If this class needs to refer to its own\n+    \/\/ methods or fields, it would use a CONSTANT_MethodRef, etc, which would reference\n+    \/\/ _this_class_index. However, because this class is hidden or anonymous (it's\n@@ -5738,0 +5858,3 @@\n+  if (_is_hidden) {\n+    ik->set_is_hidden();\n+  }\n@@ -5743,1 +5866,1 @@\n-  ik->set_package(cld, CHECK);\n+  ik->set_package(cld, NULL, CHECK);\n@@ -5770,0 +5893,1 @@\n+  ik->set_local_interfaces(_local_interfaces);\n@@ -5771,0 +5895,1 @@\n+  _local_interfaces = NULL;\n@@ -5817,0 +5942,1 @@\n+                                 cl_inst_info.class_data(),\n@@ -5921,1 +6047,0 @@\n-\n@@ -5929,2 +6054,2 @@\n-  const char* host_pkg_name =\n-    ClassLoader::package_from_name(unsafe_anonymous_host->name()->as_C_string(), NULL);\n+  TempNewSymbol host_pkg_name =\n+    ClassLoader::package_from_class_name(unsafe_anonymous_host->name());\n@@ -5933,1 +6058,1 @@\n-    int host_pkg_len = (int)strlen(host_pkg_name);\n+    int host_pkg_len = host_pkg_name->utf8_length();\n@@ -5937,2 +6062,2 @@\n-    int n = os::snprintf(new_anon_name, symbol_len + 1, \"%s\/%.*s\",\n-                         host_pkg_name, class_name_len, _class_name->base());\n+    int n = os::snprintf(new_anon_name, symbol_len + 1, \"%.*s\/%.*s\",\n+                         host_pkg_len, host_pkg_name->base(), class_name_len, _class_name->base());\n@@ -5974,2 +6099,2 @@\n-  bool trusted = (loader_data->is_the_null_class_loader_data() ||\n-                  SystemDictionary::is_platform_class_loader(loader_data->class_loader()));\n+  bool trusted = loader_data->is_boot_class_loader_data() ||\n+                 loader_data->is_platform_class_loader_data();\n@@ -5987,3 +6112,1 @@\n-                                 Handle protection_domain,\n-                                 const InstanceKlass* unsafe_anonymous_host,\n-                                 GrowableArray<Handle>* cp_patches,\n+                                 const ClassLoadInfo* cl_info,\n@@ -5993,1 +6116,0 @@\n-  _requested_name(name),\n@@ -5996,2 +6118,4 @@\n-  _unsafe_anonymous_host(unsafe_anonymous_host),\n-  _cp_patches(cp_patches),\n+  _unsafe_anonymous_host(cl_info->unsafe_anonymous_host()),\n+  _cp_patches(cl_info->cp_patches()),\n+  _is_hidden(cl_info->is_hidden()),\n+  _can_access_vm_annotations(cl_info->can_access_vm_annotations()),\n@@ -6009,0 +6133,1 @@\n+  _permitted_subclasses(NULL),\n@@ -6028,1 +6153,1 @@\n-  _protection_domain(protection_domain),\n+  _protection_domain(cl_info->protection_domain()),\n@@ -6117,1 +6242,1 @@\n-  _local_interfaces = NULL;\n+  _permitted_subclasses = NULL;\n@@ -6153,0 +6278,4 @@\n+  if (_permitted_subclasses != NULL && _permitted_subclasses != Universe::the_empty_short_array()) {\n+    MetadataFactory::free_array<u2>(_loader_data, _permitted_subclasses);\n+  }\n+\n@@ -6181,0 +6310,1 @@\n+  _local_interfaces = NULL;\n@@ -6231,2 +6361,8 @@\n-  if (int(cp_size) + _max_num_patched_klasses > 0xffff) {\n-    THROW_MSG(vmSymbols::java_lang_InternalError(), \"not enough space for patched classes\");\n+  if (is_hidden()) { \/\/ Add a slot for hidden class name.\n+    assert(_max_num_patched_klasses == 0, \"Sanity check\");\n+    cp_size++;\n+  } else {\n+    if (int(cp_size) + _max_num_patched_klasses > 0xffff) {\n+      THROW_MSG(vmSymbols::java_lang_InternalError(), \"not enough space for patched classes\");\n+    }\n+    cp_size += _max_num_patched_klasses;\n@@ -6234,1 +6370,0 @@\n-  cp_size += _max_num_patched_klasses;\n@@ -6285,3 +6420,0 @@\n-  \/\/ Update _class_name to reflect the name in the constant pool\n-  update_class_name(class_name_in_cp);\n-\n@@ -6292,1 +6424,1 @@\n-    guarantee_property(_class_name->char_at(0) != JVM_SIGNATURE_ARRAY,\n+    guarantee_property(class_name_in_cp->char_at(0) != JVM_SIGNATURE_ARRAY,\n@@ -6297,11 +6429,9 @@\n-  \/\/ Checks if name in class file matches requested name\n-  if (_requested_name != NULL && _requested_name != _class_name) {\n-    ResourceMark rm(THREAD);\n-    Exceptions::fthrow(\n-      THREAD_AND_LOCATION,\n-      vmSymbols::java_lang_NoClassDefFoundError(),\n-      \"%s (wrong name: %s)\",\n-      _class_name->as_C_string(),\n-      _requested_name != NULL ? _requested_name->as_C_string() : \"NoName\"\n-    );\n-    return;\n+#ifdef ASSERT\n+  \/\/ Basic sanity checks\n+  assert(!(_is_hidden && (_unsafe_anonymous_host != NULL)), \"mutually exclusive variants\");\n+\n+  if (_unsafe_anonymous_host != NULL) {\n+    assert(_class_name == vmSymbols::unknown_class_name(), \"A named anonymous class???\");\n+  }\n+  if (_is_hidden) {\n+    assert(_class_name != vmSymbols::unknown_class_name(), \"hidden classes should have a special name\");\n@@ -6309,0 +6439,12 @@\n+#endif\n+\n+  \/\/ Update the _class_name as needed depending on whether this is a named,\n+  \/\/ un-named, hidden or unsafe-anonymous class.\n+\n+  if (_is_hidden) {\n+    assert(_class_name != NULL, \"Unexpected null _class_name\");\n+#ifdef ASSERT\n+    if (_need_verify) {\n+      verify_legal_class_name(_class_name, CHECK);\n+    }\n+#endif\n@@ -6310,1 +6452,4 @@\n-  \/\/ if this is an anonymous class fix up its name if it's in the unnamed\n+  \/\/ NOTE: !_is_hidden does not imply \"findable\" as it could be an old-style\n+  \/\/       \"hidden\" unsafe-anonymous class\n+\n+  \/\/ If this is an anonymous class fix up its name if it is in the unnamed\n@@ -6313,1 +6458,2 @@\n-  if (_unsafe_anonymous_host != NULL) {\n+  } else if (_unsafe_anonymous_host != NULL) {\n+    update_class_name(class_name_in_cp);\n@@ -6315,0 +6461,20 @@\n+\n+  } else {\n+    \/\/ Check if name in class file matches given name\n+    if (_class_name != class_name_in_cp) {\n+      if (_class_name != vmSymbols::unknown_class_name()) {\n+        ResourceMark rm(THREAD);\n+        Exceptions::fthrow(THREAD_AND_LOCATION,\n+                           vmSymbols::java_lang_NoClassDefFoundError(),\n+                           \"%s (wrong name: %s)\",\n+                           class_name_in_cp->as_C_string(),\n+                           _class_name->as_C_string()\n+                           );\n+        return;\n+      } else {\n+        \/\/ The class name was not known by the caller so we set it from\n+        \/\/ the value in the CP.\n+        update_class_name(class_name_in_cp);\n+      }\n+      \/\/ else nothing to do: the expected class name matches what is in the CP\n+    }\n@@ -6339,0 +6505,1 @@\n+                 !_is_hidden &&\n@@ -6341,1 +6508,1 @@\n-        \/\/ Unsafe anonymous classes such as generated LambdaForm classes are also not included.\n+        \/\/ Hidden and unsafe anonymous classes such as generated LambdaForm classes are also not included.\n@@ -6436,0 +6603,29 @@\n+void ClassFileParser::mangle_hidden_class_name(InstanceKlass* const ik) {\n+  ResourceMark rm;\n+  \/\/ Construct hidden name from _class_name, \"+\", and &ik. Note that we can't\n+  \/\/ use a '\/' because that confuses finding the class's package.  Also, can't\n+  \/\/ use an illegal char such as ';' because that causes serialization issues\n+  \/\/ and issues with hidden classes that create their own hidden classes.\n+  char addr_buf[20];\n+  jio_snprintf(addr_buf, 20, INTPTR_FORMAT, p2i(ik));\n+  size_t new_name_len = _class_name->utf8_length() + 2 + strlen(addr_buf);\n+  char* new_name = NEW_RESOURCE_ARRAY(char, new_name_len);\n+  jio_snprintf(new_name, new_name_len, \"%s+%s\",\n+               _class_name->as_C_string(), addr_buf);\n+  update_class_name(SymbolTable::new_symbol(new_name));\n+\n+  \/\/ Add a Utf8 entry containing the hidden name.\n+  assert(_class_name != NULL, \"Unexpected null _class_name\");\n+  int hidden_index = _orig_cp_size; \/\/ this is an extra slot we added\n+  _cp->symbol_at_put(hidden_index, _class_name);\n+\n+  \/\/ Update this_class_index's slot in the constant pool with the new Utf8 entry.\n+  \/\/ We have to update the resolved_klass_index and the name_index together\n+  \/\/ so extract the existing resolved_klass_index first.\n+  CPKlassSlot cp_klass_slot = _cp->klass_slot_at(_this_class_index);\n+  int resolved_klass_index = cp_klass_slot.resolved_klass_index();\n+  _cp->unresolved_klass_at_put(_this_class_index, hidden_index, resolved_klass_index);\n+  assert(_cp->klass_slot_at(_this_class_index).name_index() == _orig_cp_size,\n+         \"Bad name_index\");\n+}\n+\n@@ -6485,4 +6681,0 @@\n-    \/\/ Make sure super class is not final\n-    if (_super_klass->is_final()) {\n-      THROW_MSG(vmSymbols::java_lang_VerifyError(), \"Cannot inherit from final class\");\n-    }\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":272,"deletions":80,"binary":false,"changes":352,"status":"modified"},{"patch":"@@ -180,10 +180,0 @@\n-int java_lang_String::value_offset  = 0;\n-int java_lang_String::hash_offset   = 0;\n-int java_lang_String::hashIsZero_offset = 0;\n-int java_lang_String::coder_offset  = 0;\n-\n-bool java_lang_String::initialized  = false;\n-\n-bool java_lang_String::is_instance(oop obj) {\n-  return is_instance_inlined(obj);\n-}\n@@ -199,0 +189,14 @@\n+\n+\/\/ java_lang_String\n+\n+int java_lang_String::_value_offset;\n+int java_lang_String::_hash_offset;\n+int java_lang_String::_hashIsZero_offset;\n+int java_lang_String::_coder_offset;\n+\n+bool java_lang_String::_initialized;\n+\n+bool java_lang_String::is_instance(oop obj) {\n+  return is_instance_inlined(obj);\n+}\n+\n@@ -200,4 +204,4 @@\n-  macro(value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \\\n-  macro(hash_offset,  k, \"hash\",                  int_signature,        false); \\\n-  macro(hashIsZero_offset, k, \"hashIsZero\",       bool_signature,       false); \\\n-  macro(coder_offset, k, \"coder\",                 byte_signature,       false);\n+  macro(_value_offset, k, vmSymbols::value_name(), byte_array_signature, false); \\\n+  macro(_hash_offset,  k, \"hash\",                  int_signature,        false); \\\n+  macro(_hashIsZero_offset, k, \"hashIsZero\",       bool_signature,       false); \\\n+  macro(_coder_offset, k, \"coder\",                 byte_signature,       false);\n@@ -206,1 +210,1 @@\n-  if (initialized) {\n+  if (_initialized) {\n@@ -213,1 +217,1 @@\n-  initialized = true;\n+  _initialized = true;\n@@ -219,1 +223,1 @@\n-  f->do_bool(&initialized);\n+  f->do_bool(&_initialized);\n@@ -246,1 +250,1 @@\n-  assert(initialized, \"Must be initialized\");\n+  assert(_initialized, \"Must be initialized\");\n@@ -289,2 +293,1 @@\n-      tty->print_cr(\"Unicode conversion failure: %s --> %s\", expected, actual);\n-      ShouldNotReachHere();\n+      fatal(\"Unicode conversion failure: %s --> %s\", expected, actual);\n@@ -299,1 +302,1 @@\n-  Handle h_obj = create_from_unicode(unicode, length, CHECK_0);\n+  Handle h_obj = create_from_unicode(unicode, length, CHECK_NULL);\n@@ -327,1 +330,1 @@\n-  \/\/ This check is too strict because the input string is not necessarily valid UTF8.\n+  \/\/ This check is too strict when the input string is not a valid UTF8.\n@@ -329,2 +332,1 @@\n-  \/*\n-  {\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {\n@@ -335,2 +337,1 @@\n-      tty->print_cr(\"String conversion failure: %s --> %s\", expected, actual);\n-      ShouldNotReachHere();\n+      fatal(\"String conversion failure: %s --> %s\", expected, actual);\n@@ -339,1 +340,0 @@\n-  *\/\n@@ -346,1 +346,1 @@\n-  Handle h_obj = create_from_str(utf8_str, CHECK_0);\n+  Handle h_obj = create_from_str(utf8_str, CHECK_NULL);\n@@ -379,2 +379,1 @@\n-      tty->print_cr(\"Symbol conversion failure: %s --> %s\", expected, actual);\n-      ShouldNotReachHere();\n+      fatal(\"Symbol conversion failure: %s --> %s\", expected, actual);\n@@ -549,1 +548,1 @@\n-  assert(initialized && (hash_offset > 0) && (hashIsZero_offset > 0), \"Must be initialized\");\n+  assert(_initialized && (_hash_offset > 0) && (_hashIsZero_offset > 0), \"Must be initialized\");\n@@ -551,1 +550,1 @@\n-    return java_string->int_field(hash_offset);\n+    return java_string->int_field(_hash_offset);\n@@ -568,1 +567,1 @@\n-    java_string->int_field_put(hash_offset, hash);\n+    java_string->int_field_put(_hash_offset, hash);\n@@ -570,1 +569,1 @@\n-    java_string->bool_field_put(hashIsZero_offset, true);\n+    java_string->bool_field_put(_hashIsZero_offset, true);\n@@ -652,3 +651,8 @@\n-  typeArrayOop value  = java_lang_String::value(java_string);\n-  int          length = java_lang_String::length(java_string, value);\n-  bool      is_latin1 = java_lang_String::is_latin1(java_string);\n+  int length;\n+  return as_utf8_string(java_string, length);\n+}\n+\n+char* java_lang_String::as_utf8_string(oop java_string, int& length) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  length             = java_lang_String::length(java_string, value);\n+  bool     is_latin1 = java_lang_String::is_latin1(java_string);\n@@ -664,0 +668,23 @@\n+\/\/ Uses a provided buffer if it's sufficiently large, otherwise allocates\n+\/\/ a resource array to fit\n+char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int& utf8_len) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  int            len = java_lang_String::length(java_string, value);\n+  bool     is_latin1 = java_lang_String::is_latin1(java_string);\n+  if (!is_latin1) {\n+    jchar *position = (len == 0) ? NULL : value->char_at_addr(0);\n+    utf8_len = UNICODE::utf8_length(position, len);\n+    if (utf8_len >= buflen) {\n+      buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);\n+    }\n+    return UNICODE::as_utf8(position, len, buf, utf8_len + 1);\n+  } else {\n+    jbyte *position = (len == 0) ? NULL : value->byte_at_addr(0);\n+    utf8_len = UNICODE::utf8_length(position, len);\n+    if (utf8_len >= buflen) {\n+      buf = NEW_RESOURCE_ARRAY(char, utf8_len + 1);\n+    }\n+    return UNICODE::as_utf8(position, len, buf, utf8_len + 1);\n+  }\n+}\n+\n@@ -774,0 +801,20 @@\n+\/\/ java_lang_Class\n+\n+int java_lang_Class::_klass_offset;\n+int java_lang_Class::_array_klass_offset;\n+int java_lang_Class::_oop_size_offset;\n+int java_lang_Class::_static_oop_field_count_offset;\n+int java_lang_Class::_class_loader_offset;\n+int java_lang_Class::_module_offset;\n+int java_lang_Class::_protection_domain_offset;\n+int java_lang_Class::_component_mirror_offset;\n+int java_lang_Class::_init_lock_offset;\n+int java_lang_Class::_signers_offset;\n+int java_lang_Class::_name_offset;\n+int java_lang_Class::_source_file_offset;\n+int java_lang_Class::_classData_offset;\n+int java_lang_Class::_classRedefinedCount_offset;\n+\n+bool java_lang_Class::_offsets_computed = false;\n+GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;\n+GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = NULL;\n@@ -851,1 +898,1 @@\n-      k->set_java_mirror_handle(NULL);\n+      k->set_java_mirror_handle(OopHandle());\n@@ -855,1 +902,1 @@\n-  create_mirror(k, Handle(), Handle(), Handle(), CHECK);\n+  create_mirror(k, Handle(), Handle(), Handle(), Handle(), CHECK);\n@@ -861,0 +908,1 @@\n+                                               Handle classData,\n@@ -873,0 +921,3 @@\n+\n+ \/\/ Set classData\n+  set_class_data(mirror(), classData());\n@@ -926,1 +977,2 @@\n-                                    Handle module, Handle protection_domain, TRAPS) {\n+                                    Handle module, Handle protection_domain,\n+                                    Handle classData, TRAPS) {\n@@ -973,1 +1025,1 @@\n-      initialize_mirror_fields(k, mirror, protection_domain, THREAD);\n+      initialize_mirror_fields(k, mirror, protection_domain, classData, THREAD);\n@@ -1152,1 +1204,1 @@\n-      k->set_java_mirror_handle(NULL);\n+      k->set_java_mirror_handle(OopHandle());\n@@ -1258,4 +1310,1 @@\n-  if (MetaspaceShared::relocation_delta() != 0) {\n-    Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));\n-    archived_mirror->metadata_field_put(_klass_offset,\n-        (Klass*)(address(k) + MetaspaceShared::relocation_delta()));\n+  assert(MetaspaceShared::relocation_delta() != 0, \"must be\");\n@@ -1263,5 +1312,8 @@\n-    Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n-    if (ak != NULL) {\n-      archived_mirror->metadata_field_put(_array_klass_offset,\n-          (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n-    }\n+  Klass* k = ((Klass*)archived_mirror->metadata_field(_klass_offset));\n+  archived_mirror->metadata_field_put(_klass_offset,\n+      (Klass*)(address(k) + MetaspaceShared::relocation_delta()));\n+\n+  Klass* ak = ((Klass*)archived_mirror->metadata_field(_array_klass_offset));\n+  if (ak != NULL) {\n+    archived_mirror->metadata_field_put(_array_klass_offset,\n+        (Klass*)(address(ak) + MetaspaceShared::relocation_delta()));\n@@ -1294,1 +1346,0 @@\n-  update_archived_mirror_native_pointers(m);\n@@ -1408,0 +1459,8 @@\n+oop java_lang_Class::class_data(oop java_class) {\n+  assert(_classData_offset != 0, \"must be set\");\n+  return java_class->obj_field(_classData_offset);\n+}\n+void java_lang_Class::set_class_data(oop java_class, oop class_data) {\n+  assert(_classData_offset != 0, \"must be set\");\n+  java_class->obj_field_put(_classData_offset, class_data);\n+}\n@@ -1452,1 +1511,1 @@\n-  oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())->allocate_instance(NULL, CHECK_0);\n+  oop java_class = InstanceMirrorKlass::cast(SystemDictionary::Class_klass())->allocate_instance(NULL, CHECK_NULL);\n@@ -1466,8 +1525,0 @@\n-Klass* java_lang_Class::as_Klass(oop java_class) {\n-  \/\/%note memory_2\n-  assert(java_lang_Class::is_instance(java_class), \"must be a Class object\");\n-  Klass* k = ((Klass*)java_class->metadata_field(_klass_offset));\n-  assert(k == NULL || k->is_klass(), \"type check\");\n-  return k;\n-}\n-\n@@ -1602,8 +1653,6 @@\n-bool java_lang_Class::offsets_computed = false;\n-int  java_lang_Class::classRedefinedCount_offset = -1;\n-\n-  macro(classRedefinedCount_offset, k, \"classRedefinedCount\", int_signature,         false); \\\n-  macro(_class_loader_offset,       k, \"classLoader\",         classloader_signature, false); \\\n-  macro(_component_mirror_offset,   k, \"componentType\",       class_signature,       false); \\\n-  macro(_module_offset,             k, \"module\",              module_signature,      false); \\\n-  macro(_name_offset,               k, \"name\",                string_signature,      false); \\\n+  macro(_classRedefinedCount_offset, k, \"classRedefinedCount\", int_signature,         false); \\\n+  macro(_class_loader_offset,        k, \"classLoader\",         classloader_signature, false); \\\n+  macro(_component_mirror_offset,    k, \"componentType\",       class_signature,       false); \\\n+  macro(_module_offset,              k, \"module\",              module_signature,      false); \\\n+  macro(_name_offset,                k, \"name\",                string_signature,      false); \\\n+  macro(_classData_offset,           k, \"classData\",           object_signature,      false);\n@@ -1613,1 +1662,1 @@\n-  if (offsets_computed) {\n+  if (_offsets_computed) {\n@@ -1617,1 +1666,1 @@\n-  offsets_computed = true;\n+  _offsets_computed = true;\n@@ -1632,1 +1681,1 @@\n-  f->do_bool(&offsets_computed);\n+  f->do_bool(&_offsets_computed);\n@@ -1642,2 +1691,2 @@\n-  assert(classRedefinedCount_offset != -1, \"offsets should have been initialized\");\n-  return the_class_mirror->int_field(classRedefinedCount_offset);\n+  assert(_classRedefinedCount_offset != 0, \"offsets should have been initialized\");\n+  return the_class_mirror->int_field(_classRedefinedCount_offset);\n@@ -1647,2 +1696,2 @@\n-  assert(classRedefinedCount_offset != -1, \"offsets should have been initialized\");\n-  the_class_mirror->int_field_put(classRedefinedCount_offset, value);\n+  assert(_classRedefinedCount_offset != 0, \"offsets should have been initialized\");\n+  the_class_mirror->int_field_put(_classRedefinedCount_offset, value);\n@@ -1660,13 +1709,13 @@\n-int java_lang_Thread::_name_offset = 0;\n-int java_lang_Thread::_group_offset = 0;\n-int java_lang_Thread::_contextClassLoader_offset = 0;\n-int java_lang_Thread::_inheritedAccessControlContext_offset = 0;\n-int java_lang_Thread::_priority_offset = 0;\n-int java_lang_Thread::_eetop_offset = 0;\n-int java_lang_Thread::_interrupted_offset = 0;\n-int java_lang_Thread::_daemon_offset = 0;\n-int java_lang_Thread::_stillborn_offset = 0;\n-int java_lang_Thread::_stackSize_offset = 0;\n-int java_lang_Thread::_tid_offset = 0;\n-int java_lang_Thread::_thread_status_offset = 0;\n-int java_lang_Thread::_park_blocker_offset = 0;\n+int java_lang_Thread::_name_offset;\n+int java_lang_Thread::_group_offset;\n+int java_lang_Thread::_contextClassLoader_offset;\n+int java_lang_Thread::_inheritedAccessControlContext_offset;\n+int java_lang_Thread::_priority_offset;\n+int java_lang_Thread::_eetop_offset;\n+int java_lang_Thread::_interrupted_offset;\n+int java_lang_Thread::_daemon_offset;\n+int java_lang_Thread::_stillborn_offset;\n+int java_lang_Thread::_stackSize_offset;\n+int java_lang_Thread::_tid_offset;\n+int java_lang_Thread::_thread_status_offset;\n+int java_lang_Thread::_park_blocker_offset;\n@@ -1834,9 +1883,9 @@\n-int java_lang_ThreadGroup::_parent_offset = 0;\n-int java_lang_ThreadGroup::_name_offset = 0;\n-int java_lang_ThreadGroup::_threads_offset = 0;\n-int java_lang_ThreadGroup::_groups_offset = 0;\n-int java_lang_ThreadGroup::_maxPriority_offset = 0;\n-int java_lang_ThreadGroup::_destroyed_offset = 0;\n-int java_lang_ThreadGroup::_daemon_offset = 0;\n-int java_lang_ThreadGroup::_nthreads_offset = 0;\n-int java_lang_ThreadGroup::_ngroups_offset = 0;\n+int java_lang_ThreadGroup::_parent_offset;\n+int java_lang_ThreadGroup::_name_offset;\n+int java_lang_ThreadGroup::_threads_offset;\n+int java_lang_ThreadGroup::_groups_offset;\n+int java_lang_ThreadGroup::_maxPriority_offset;\n+int java_lang_ThreadGroup::_destroyed_offset;\n+int java_lang_ThreadGroup::_daemon_offset;\n+int java_lang_ThreadGroup::_nthreads_offset;\n+int java_lang_ThreadGroup::_ngroups_offset;\n@@ -1922,0 +1971,8 @@\n+\/\/ java_lang_Throwable\n+\n+int java_lang_Throwable::_backtrace_offset;\n+int java_lang_Throwable::_detailMessage_offset;\n+int java_lang_Throwable::_stackTrace_offset;\n+int java_lang_Throwable::_depth_offset;\n+int java_lang_Throwable::_static_unassigned_stacktrace_offset;\n+\n@@ -1923,5 +1980,5 @@\n-  macro(backtrace_offset,     k, \"backtrace\",     object_signature,                  false); \\\n-  macro(detailMessage_offset, k, \"detailMessage\", string_signature,                  false); \\\n-  macro(stackTrace_offset,    k, \"stackTrace\",    java_lang_StackTraceElement_array, false); \\\n-  macro(depth_offset,         k, \"depth\",         int_signature,                     false); \\\n-  macro(static_unassigned_stacktrace_offset, k, \"UNASSIGNED_STACK\", java_lang_StackTraceElement_array, true)\n+  macro(_backtrace_offset,     k, \"backtrace\",     object_signature,                  false); \\\n+  macro(_detailMessage_offset, k, \"detailMessage\", string_signature,                  false); \\\n+  macro(_stackTrace_offset,    k, \"stackTrace\",    java_lang_StackTraceElement_array, false); \\\n+  macro(_depth_offset,         k, \"depth\",         int_signature,                     false); \\\n+  macro(_static_unassigned_stacktrace_offset, k, \"UNASSIGNED_STACK\", java_lang_StackTraceElement_array, true)\n@@ -1943,1 +2000,1 @@\n-  return base->obj_field(static_unassigned_stacktrace_offset);\n+  return base->obj_field(_static_unassigned_stacktrace_offset);\n@@ -1947,1 +2004,1 @@\n-  return throwable->obj_field_acquire(backtrace_offset);\n+  return throwable->obj_field_acquire(_backtrace_offset);\n@@ -1952,1 +2009,1 @@\n-  throwable->release_obj_field_put(backtrace_offset, value);\n+  throwable->release_obj_field_put(_backtrace_offset, value);\n@@ -1956,1 +2013,1 @@\n-  return throwable->int_field(depth_offset);\n+  return throwable->int_field(_depth_offset);\n@@ -1960,1 +2017,1 @@\n-  throwable->int_field_put(depth_offset, value);\n+  throwable->int_field_put(_depth_offset, value);\n@@ -1964,1 +2021,1 @@\n-  return throwable->obj_field(detailMessage_offset);\n+  return throwable->obj_field(_detailMessage_offset);\n@@ -1979,1 +2036,1 @@\n-  throwable->obj_field_put(detailMessage_offset, value);\n+  throwable->obj_field_put(_detailMessage_offset, value);\n@@ -1984,1 +2041,1 @@\n-  throwable->obj_field_put(stackTrace_offset, st_element_array);\n+  throwable->obj_field_put(_stackTrace_offset, st_element_array);\n@@ -2025,4 +2082,2 @@\n-  \/\/ This is set to a java.lang.Boolean(true) if the top frame\n-  \/\/ of the backtrace is omitted because it shall be hidden.\n-  \/\/ Else it is null.\n-  oop             _has_hidden_top_frame;\n+  \/\/ True if the top frame of the backtrace is omitted because it shall be hidden.\n+  bool            _has_hidden_top_frame;\n@@ -2064,1 +2119,1 @@\n-  static oop get_has_hidden_top_frame(objArrayHandle chunk) {\n+  static bool has_hidden_top_frame(objArrayHandle chunk) {\n@@ -2066,1 +2121,1 @@\n-    return hidden;\n+    return hidden != NULL;\n@@ -2072,1 +2127,1 @@\n-  BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(NULL) {\n+  BacktraceBuilder(TRAPS): _head(NULL), _methods(NULL), _bcis(NULL), _mirrors(NULL), _names(NULL), _has_hidden_top_frame(false) {\n@@ -2083,1 +2138,1 @@\n-    _has_hidden_top_frame = get_has_hidden_top_frame(backtrace);\n+    _has_hidden_top_frame = has_hidden_top_frame(backtrace);\n@@ -2163,1 +2218,1 @@\n-    if (_has_hidden_top_frame == NULL) {\n+    if (!_has_hidden_top_frame) {\n@@ -2167,3 +2222,2 @@\n-      \/\/ Therefor let's just use an arbitrary legal oop\n-      \/\/ available right here. We only test for != null\n-      \/\/ anyways. _methods is a short[].\n+      \/\/ Therefore let's just use an arbitrary legal oop\n+      \/\/ available right here. _methods is a short[].\n@@ -2171,2 +2225,2 @@\n-      _has_hidden_top_frame = _methods;\n-      _head->obj_at_put(trace_hidden_offset, _has_hidden_top_frame);\n+      _has_hidden_top_frame = true;\n+      _head->obj_at_put(trace_hidden_offset, _methods);\n@@ -2175,1 +2229,0 @@\n-\n@@ -2658,1 +2711,1 @@\n-    k->initialize(CHECK_0);\n+    k->initialize(CHECK_NULL);\n@@ -2661,1 +2714,1 @@\n-  Handle element = k->allocate_instance_handle(CHECK_0);\n+  Handle element = k->allocate_instance_handle(CHECK_NULL);\n@@ -2664,1 +2717,1 @@\n-  fill_in(element, method->method_holder(), method, version, bci, method->name(), CHECK_0);\n+  fill_in(element, method->method_holder(), method, version, bci, method->name(), CHECK_NULL);\n@@ -2767,0 +2820,23 @@\n+\/\/ java_lang_StackFrameInfo\n+\n+int java_lang_StackFrameInfo::_memberName_offset;\n+int java_lang_StackFrameInfo::_bci_offset;\n+int java_lang_StackFrameInfo::_version_offset;\n+\n+#define STACKFRAMEINFO_FIELDS_DO(macro) \\\n+  macro(_memberName_offset,     k, \"memberName\",  object_signature, false); \\\n+  macro(_bci_offset,            k, \"bci\",         int_signature,    false)\n+\n+void java_lang_StackFrameInfo::compute_offsets() {\n+  InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();\n+  STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {\n+  STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n@@ -2806,8 +2882,2 @@\n-#define STACKFRAMEINFO_FIELDS_DO(macro) \\\n-  macro(_memberName_offset,     k, \"memberName\",  object_signature, false); \\\n-  macro(_bci_offset,            k, \"bci\",         int_signature,    false)\n-\n-void java_lang_StackFrameInfo::compute_offsets() {\n-  InstanceKlass* k = SystemDictionary::StackFrameInfo_klass();\n-  STACKFRAMEINFO_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n-  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_COMPUTE_OFFSET);\n+void java_lang_StackFrameInfo::set_version(oop element, short value) {\n+  element->short_field_put(_version_offset, value);\n@@ -2816,4 +2886,3 @@\n-#if INCLUDE_CDS\n-void java_lang_StackFrameInfo::serialize_offsets(SerializeClosure* f) {\n-  STACKFRAMEINFO_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n-  STACKFRAMEINFO_INJECTED_FIELDS(INJECTED_FIELD_SERIALIZE_OFFSET);\n+void java_lang_StackFrameInfo::set_bci(oop element, int value) {\n+  assert(value >= 0 && value < max_jushort, \"must be a valid bci value\");\n+  element->int_field_put(_bci_offset, value);\n@@ -2821,1 +2890,5 @@\n-#endif\n+\n+int java_lang_LiveStackFrameInfo::_monitors_offset;\n+int java_lang_LiveStackFrameInfo::_locals_offset;\n+int java_lang_LiveStackFrameInfo::_operands_offset;\n+int java_lang_LiveStackFrameInfo::_mode_offset;\n@@ -2840,0 +2913,21 @@\n+void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {\n+  element->obj_field_put(_monitors_offset, value);\n+}\n+\n+void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {\n+  element->obj_field_put(_locals_offset, value);\n+}\n+\n+void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {\n+  element->obj_field_put(_operands_offset, value);\n+}\n+\n+void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {\n+  element->int_field_put(_mode_offset, value);\n+}\n+\n+\n+\/\/ java_lang_AccessibleObject\n+\n+int java_lang_reflect_AccessibleObject::_override_offset;\n+\n@@ -2841,1 +2935,1 @@\n-  macro(override_offset, k, \"override\", bool_signature, false)\n+  macro(_override_offset, k, \"override\", bool_signature, false)\n@@ -2855,2 +2949,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return (jboolean) reflect->bool_field(override_offset);\n+  return (jboolean) reflect->bool_field(_override_offset);\n@@ -2860,2 +2953,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  reflect->bool_field_put(override_offset, (int) value);\n+  reflect->bool_field_put(_override_offset, (int) value);\n@@ -2864,0 +2956,14 @@\n+\/\/ java_lang_reflect_Method\n+\n+int java_lang_reflect_Method::_clazz_offset;\n+int java_lang_reflect_Method::_name_offset;\n+int java_lang_reflect_Method::_returnType_offset;\n+int java_lang_reflect_Method::_parameterTypes_offset;\n+int java_lang_reflect_Method::_exceptionTypes_offset;\n+int java_lang_reflect_Method::_slot_offset;\n+int java_lang_reflect_Method::_modifiers_offset;\n+int java_lang_reflect_Method::_signature_offset;\n+int java_lang_reflect_Method::_annotations_offset;\n+int java_lang_reflect_Method::_parameter_annotations_offset;\n+int java_lang_reflect_Method::_annotation_default_offset;\n+\n@@ -2865,11 +2971,11 @@\n-  macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \\\n-  macro(name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \\\n-  macro(returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \\\n-  macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \\\n-  macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \\\n-  macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \\\n-  macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \\\n-  macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \\\n-  macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \\\n-  macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \\\n-  macro(annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);\n+  macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \\\n+  macro(_name_offset,           k, vmSymbols::name_name(),           string_signature,      false); \\\n+  macro(_returnType_offset,     k, vmSymbols::returnType_name(),     class_signature,       false); \\\n+  macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \\\n+  macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \\\n+  macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \\\n+  macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \\\n+  macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \\\n+  macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \\\n+  macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false); \\\n+  macro(_annotation_default_offset,    k, vmSymbols::annotation_default_name(),    byte_array_signature, false);\n@@ -2898,2 +3004,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return reflect->obj_field(clazz_offset);\n+  return reflect->obj_field(_clazz_offset);\n@@ -2903,2 +3008,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-   reflect->obj_field_put(clazz_offset, value);\n+   reflect->obj_field_put(_clazz_offset, value);\n@@ -2908,2 +3012,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return reflect->int_field(slot_offset);\n+  return reflect->int_field(_slot_offset);\n@@ -2913,2 +3016,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  reflect->int_field_put(slot_offset, value);\n+  reflect->int_field_put(_slot_offset, value);\n@@ -2918,2 +3020,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(name_offset, value);\n+  method->obj_field_put(_name_offset, value);\n@@ -2923,2 +3024,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return method->obj_field(returnType_offset);\n+  return method->obj_field(_returnType_offset);\n@@ -2928,2 +3028,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(returnType_offset, value);\n+  method->obj_field_put(_returnType_offset, value);\n@@ -2933,2 +3032,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return method->obj_field(parameterTypes_offset);\n+  return method->obj_field(_parameterTypes_offset);\n@@ -2938,2 +3036,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(parameterTypes_offset, value);\n+  method->obj_field_put(_parameterTypes_offset, value);\n@@ -2943,2 +3040,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(exceptionTypes_offset, value);\n+  method->obj_field_put(_exceptionTypes_offset, value);\n@@ -2948,2 +3044,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->int_field_put(modifiers_offset, value);\n+  method->int_field_put(_modifiers_offset, value);\n@@ -2953,2 +3048,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(signature_offset, value);\n+  method->obj_field_put(_signature_offset, value);\n@@ -2958,2 +3052,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(annotations_offset, value);\n+  method->obj_field_put(_annotations_offset, value);\n@@ -2963,2 +3056,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(parameter_annotations_offset, value);\n+  method->obj_field_put(_parameter_annotations_offset, value);\n@@ -2968,2 +3060,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(annotation_default_offset, value);\n+  method->obj_field_put(_annotation_default_offset, value);\n@@ -2972,0 +3063,9 @@\n+int java_lang_reflect_Constructor::_clazz_offset;\n+int java_lang_reflect_Constructor::_parameterTypes_offset;\n+int java_lang_reflect_Constructor::_exceptionTypes_offset;\n+int java_lang_reflect_Constructor::_slot_offset;\n+int java_lang_reflect_Constructor::_modifiers_offset;\n+int java_lang_reflect_Constructor::_signature_offset;\n+int java_lang_reflect_Constructor::_annotations_offset;\n+int java_lang_reflect_Constructor::_parameter_annotations_offset;\n+\n@@ -2973,8 +3073,8 @@\n-  macro(clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \\\n-  macro(parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \\\n-  macro(exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \\\n-  macro(slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \\\n-  macro(modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \\\n-  macro(signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \\\n-  macro(annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \\\n-  macro(parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);\n+  macro(_clazz_offset,          k, vmSymbols::clazz_name(),          class_signature,       false); \\\n+  macro(_parameterTypes_offset, k, vmSymbols::parameterTypes_name(), class_array_signature, false); \\\n+  macro(_exceptionTypes_offset, k, vmSymbols::exceptionTypes_name(), class_array_signature, false); \\\n+  macro(_slot_offset,           k, vmSymbols::slot_name(),           int_signature,         false); \\\n+  macro(_modifiers_offset,      k, vmSymbols::modifiers_name(),      int_signature,         false); \\\n+  macro(_signature_offset,             k, vmSymbols::signature_name(),             string_signature,     false); \\\n+  macro(_annotations_offset,           k, vmSymbols::annotations_name(),           byte_array_signature, false); \\\n+  macro(_parameter_annotations_offset, k, vmSymbols::parameter_annotations_name(), byte_array_signature, false);\n@@ -3004,2 +3104,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return reflect->obj_field(clazz_offset);\n+  return reflect->obj_field(_clazz_offset);\n@@ -3009,2 +3108,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-   reflect->obj_field_put(clazz_offset, value);\n+   reflect->obj_field_put(_clazz_offset, value);\n@@ -3014,2 +3112,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return constructor->obj_field(parameterTypes_offset);\n+  return constructor->obj_field(_parameterTypes_offset);\n@@ -3019,2 +3116,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  constructor->obj_field_put(parameterTypes_offset, value);\n+  constructor->obj_field_put(_parameterTypes_offset, value);\n@@ -3024,2 +3120,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  constructor->obj_field_put(exceptionTypes_offset, value);\n+  constructor->obj_field_put(_exceptionTypes_offset, value);\n@@ -3029,2 +3124,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return reflect->int_field(slot_offset);\n+  return reflect->int_field(_slot_offset);\n@@ -3034,2 +3128,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  reflect->int_field_put(slot_offset, value);\n+  reflect->int_field_put(_slot_offset, value);\n@@ -3039,2 +3132,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  constructor->int_field_put(modifiers_offset, value);\n+  constructor->int_field_put(_modifiers_offset, value);\n@@ -3044,2 +3136,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  constructor->obj_field_put(signature_offset, value);\n+  constructor->obj_field_put(_signature_offset, value);\n@@ -3049,2 +3140,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  constructor->obj_field_put(annotations_offset, value);\n+  constructor->obj_field_put(_annotations_offset, value);\n@@ -3054,2 +3144,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  method->obj_field_put(parameter_annotations_offset, value);\n+  method->obj_field_put(_parameter_annotations_offset, value);\n@@ -3058,0 +3147,9 @@\n+int java_lang_reflect_Field::_clazz_offset;\n+int java_lang_reflect_Field::_name_offset;\n+int java_lang_reflect_Field::_type_offset;\n+int java_lang_reflect_Field::_slot_offset;\n+int java_lang_reflect_Field::_modifiers_offset;\n+int java_lang_reflect_Field::_trusted_final_offset;\n+int java_lang_reflect_Field::_signature_offset;\n+int java_lang_reflect_Field::_annotations_offset;\n+\n@@ -3059,7 +3157,8 @@\n-  macro(clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \\\n-  macro(name_offset,      k, vmSymbols::name_name(),      string_signature, false); \\\n-  macro(type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \\\n-  macro(slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \\\n-  macro(modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \\\n-  macro(signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \\\n-  macro(annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);\n+  macro(_clazz_offset,     k, vmSymbols::clazz_name(),     class_signature,  false); \\\n+  macro(_name_offset,      k, vmSymbols::name_name(),      string_signature, false); \\\n+  macro(_type_offset,      k, vmSymbols::type_name(),      class_signature,  false); \\\n+  macro(_slot_offset,      k, vmSymbols::slot_name(),      int_signature,    false); \\\n+  macro(_modifiers_offset, k, vmSymbols::modifiers_name(), int_signature,    false); \\\n+  macro(_trusted_final_offset,    k, vmSymbols::trusted_final_name(),    bool_signature,       false); \\\n+  macro(_signature_offset,        k, vmSymbols::signature_name(),        string_signature,     false); \\\n+  macro(_annotations_offset,      k, vmSymbols::annotations_name(),      byte_array_signature, false);\n@@ -3089,2 +3188,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return reflect->obj_field(clazz_offset);\n+  return reflect->obj_field(_clazz_offset);\n@@ -3094,2 +3192,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-   reflect->obj_field_put(clazz_offset, value);\n+  reflect->obj_field_put(_clazz_offset, value);\n@@ -3099,2 +3196,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return field->obj_field(name_offset);\n+  return field->obj_field(_name_offset);\n@@ -3104,2 +3200,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  field->obj_field_put(name_offset, value);\n+  field->obj_field_put(_name_offset, value);\n@@ -3109,2 +3204,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return field->obj_field(type_offset);\n+  return field->obj_field(_type_offset);\n@@ -3114,2 +3208,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  field->obj_field_put(type_offset, value);\n+  field->obj_field_put(_type_offset, value);\n@@ -3119,2 +3212,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return reflect->int_field(slot_offset);\n+  return reflect->int_field(_slot_offset);\n@@ -3124,2 +3216,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  reflect->int_field_put(slot_offset, value);\n+  reflect->int_field_put(_slot_offset, value);\n@@ -3129,2 +3220,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return field->int_field(modifiers_offset);\n+  return field->int_field(_modifiers_offset);\n@@ -3134,2 +3224,5 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  field->int_field_put(modifiers_offset, value);\n+  field->int_field_put(_modifiers_offset, value);\n+}\n+\n+void java_lang_reflect_Field::set_trusted_final(oop field) {\n+  field->bool_field_put(_trusted_final_offset, true);\n@@ -3139,2 +3232,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  field->obj_field_put(signature_offset, value);\n+  field->obj_field_put(_signature_offset, value);\n@@ -3144,2 +3236,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  field->obj_field_put(annotations_offset, value);\n+  field->obj_field_put(_annotations_offset, value);\n@@ -3177,1 +3268,1 @@\n-    accessor_method = holder->find_instance_method(name, full_sig);\n+    accessor_method = holder->find_instance_method(name, full_sig, Klass::find_private);\n@@ -3206,0 +3297,2 @@\n+int reflect_ConstantPool::_oop_offset;\n+\n@@ -3221,0 +3314,5 @@\n+int java_lang_reflect_Parameter::_name_offset;\n+int java_lang_reflect_Parameter::_modifiers_offset;\n+int java_lang_reflect_Parameter::_index_offset;\n+int java_lang_reflect_Parameter::_executable_offset;\n+\n@@ -3222,4 +3320,4 @@\n-  macro(name_offset,        k, vmSymbols::name_name(),        string_signature, false); \\\n-  macro(modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \\\n-  macro(index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \\\n-  macro(executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)\n+  macro(_name_offset,        k, vmSymbols::name_name(),        string_signature, false); \\\n+  macro(_modifiers_offset,   k, vmSymbols::modifiers_name(),   int_signature,    false); \\\n+  macro(_index_offset,       k, vmSymbols::index_name(),       int_signature,    false); \\\n+  macro(_executable_offset,  k, vmSymbols::executable_name(),  executable_signature, false)\n@@ -3249,2 +3347,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return param->obj_field(name_offset);\n+  return param->obj_field(_name_offset);\n@@ -3254,2 +3351,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  param->obj_field_put(name_offset, value);\n+  param->obj_field_put(_name_offset, value);\n@@ -3259,2 +3355,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return param->int_field(modifiers_offset);\n+  return param->int_field(_modifiers_offset);\n@@ -3264,2 +3359,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  param->int_field_put(modifiers_offset, value);\n+  param->int_field_put(_modifiers_offset, value);\n@@ -3269,2 +3363,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return param->int_field(index_offset);\n+  return param->int_field(_index_offset);\n@@ -3274,2 +3367,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  param->int_field_put(index_offset, value);\n+  param->int_field_put(_index_offset, value);\n@@ -3279,2 +3371,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return param->obj_field(executable_offset);\n+  return param->obj_field(_executable_offset);\n@@ -3284,2 +3375,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  param->obj_field_put(executable_offset, value);\n+  param->obj_field_put(_executable_offset, value);\n@@ -3288,0 +3378,1 @@\n+\/\/ java_lang_Module\n@@ -3289,3 +3380,3 @@\n-int java_lang_Module::loader_offset;\n-int java_lang_Module::name_offset;\n-int java_lang_Module::_module_entry_offset = -1;\n+int java_lang_Module::_loader_offset;\n+int java_lang_Module::_name_offset;\n+int java_lang_Module::_module_entry_offset;\n@@ -3301,2 +3392,2 @@\n-  macro(loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \\\n-  macro(name_offset,    k, vmSymbols::name_name(),    string_signature,      false)\n+  macro(_loader_offset,  k, vmSymbols::loader_name(),  classloader_signature, false); \\\n+  macro(_name_offset,    k, vmSymbols::name_name(),    string_signature,      false)\n@@ -3318,2 +3409,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return module->obj_field(loader_offset);\n+  return module->obj_field(_loader_offset);\n@@ -3323,2 +3413,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  module->obj_field_put(loader_offset, value);\n+  module->obj_field_put(_loader_offset, value);\n@@ -3328,2 +3417,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  return module->obj_field(name_offset);\n+  return module->obj_field(_name_offset);\n@@ -3333,2 +3421,1 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n-  module->obj_field_put(name_offset, value);\n+  module->obj_field_put(_name_offset, value);\n@@ -3338,1 +3425,1 @@\n-  assert(_module_entry_offset != -1, \"Uninitialized module_entry_offset\");\n+  assert(_module_entry_offset != 0, \"Uninitialized module_entry_offset\");\n@@ -3355,1 +3442,1 @@\n-  assert(_module_entry_offset != -1, \"Uninitialized module_entry_offset\");\n+  assert(_module_entry_offset != 0, \"Uninitialized module_entry_offset\");\n@@ -3371,1 +3458,0 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n@@ -3378,1 +3464,0 @@\n-  assert(Universe::is_fully_initialized(), \"Need to find another solution to the reflection problem\");\n@@ -3392,0 +3477,2 @@\n+int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;\n+\n@@ -3406,0 +3493,67 @@\n+\/\/ Support for java_lang_ref_Reference\n+\n+bool java_lang_ref_Reference::_offsets_initialized;\n+\n+int java_lang_ref_Reference::_referent_offset;\n+int java_lang_ref_Reference::_queue_offset;\n+int java_lang_ref_Reference::_next_offset;\n+int java_lang_ref_Reference::_discovered_offset;\n+\n+#define REFERENCE_FIELDS_DO(macro) \\\n+  macro(_referent_offset,   k, \"referent\", object_signature, false); \\\n+  macro(_queue_offset,      k, \"queue\", referencequeue_signature, false); \\\n+  macro(_next_offset,       k, \"next\", reference_signature, false); \\\n+  macro(_discovered_offset, k, \"discovered\", reference_signature, false);\n+\n+void java_lang_ref_Reference::compute_offsets() {\n+  if (_offsets_initialized) {\n+    return;\n+  }\n+  _offsets_initialized = true;\n+  InstanceKlass* k = SystemDictionary::Reference_klass();\n+  REFERENCE_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_ref_Reference::serialize_offsets(SerializeClosure* f) {\n+  f->do_bool(&_offsets_initialized);\n+  REFERENCE_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n+bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {\n+  assert(obj != NULL, \"sanity\");\n+  if (offset != _referent_offset) {\n+    return false;\n+  }\n+\n+  Klass* k = obj->klass();\n+  if (!k->is_instance_klass()) {\n+    return false;\n+  }\n+\n+  InstanceKlass* ik = InstanceKlass::cast(obj->klass());\n+  bool is_reference = ik->reference_type() != REF_NONE;\n+  assert(!is_reference || ik->is_subclass_of(SystemDictionary::Reference_klass()), \"sanity\");\n+  return is_reference;\n+}\n+\n+int java_lang_boxing_object::_value_offset;\n+int java_lang_boxing_object::_long_value_offset;\n+\n+#define BOXING_FIELDS_DO(macro) \\\n+  macro(_value_offset,      integerKlass, \"value\", int_signature, false); \\\n+  macro(_long_value_offset, longKlass, \"value\", long_signature, false);\n+\n+void java_lang_boxing_object::compute_offsets() {\n+  InstanceKlass* integerKlass = SystemDictionary::Integer_klass();\n+  InstanceKlass* longKlass = SystemDictionary::Long_klass();\n+  BOXING_FIELDS_DO(FIELD_COMPUTE_OFFSET);\n+}\n+\n+#if INCLUDE_CDS\n+void java_lang_boxing_object::serialize_offsets(SerializeClosure* f) {\n+  BOXING_FIELDS_DO(FIELD_SERIALIZE_OFFSET);\n+}\n+#endif\n+\n@@ -3410,1 +3564,1 @@\n-  if (!ik->is_initialized())  ik->initialize(CHECK_0);\n+  if (!ik->is_initialized())  ik->initialize(CHECK_NULL);\n@@ -3416,1 +3570,1 @@\n-  oop box = initialize_and_allocate(type, CHECK_0);\n+  oop box = initialize_and_allocate(type, CHECK_NULL);\n@@ -3420,1 +3574,1 @@\n-      box->bool_field_put(value_offset, value->z);\n+      box->bool_field_put(_value_offset, value->z);\n@@ -3423,1 +3577,1 @@\n-      box->char_field_put(value_offset, value->c);\n+      box->char_field_put(_value_offset, value->c);\n@@ -3426,1 +3580,1 @@\n-      box->float_field_put(value_offset, value->f);\n+      box->float_field_put(_value_offset, value->f);\n@@ -3429,1 +3583,1 @@\n-      box->double_field_put(long_value_offset, value->d);\n+      box->double_field_put(_long_value_offset, value->d);\n@@ -3432,1 +3586,1 @@\n-      box->byte_field_put(value_offset, value->b);\n+      box->byte_field_put(_value_offset, value->b);\n@@ -3435,1 +3589,1 @@\n-      box->short_field_put(value_offset, value->s);\n+      box->short_field_put(_value_offset, value->s);\n@@ -3438,1 +3592,1 @@\n-      box->int_field_put(value_offset, value->i);\n+      box->int_field_put(_value_offset, value->i);\n@@ -3441,1 +3595,1 @@\n-      box->long_field_put(long_value_offset, value->j);\n+      box->long_field_put(_long_value_offset, value->j);\n@@ -3463,1 +3617,1 @@\n-    value->z = box->bool_field(value_offset);\n+    value->z = box->bool_field(_value_offset);\n@@ -3466,1 +3620,1 @@\n-    value->c = box->char_field(value_offset);\n+    value->c = box->char_field(_value_offset);\n@@ -3469,1 +3623,1 @@\n-    value->f = box->float_field(value_offset);\n+    value->f = box->float_field(_value_offset);\n@@ -3472,1 +3626,1 @@\n-    value->d = box->double_field(long_value_offset);\n+    value->d = box->double_field(_long_value_offset);\n@@ -3475,1 +3629,1 @@\n-    value->b = box->byte_field(value_offset);\n+    value->b = box->byte_field(_value_offset);\n@@ -3478,1 +3632,1 @@\n-    value->s = box->short_field(value_offset);\n+    value->s = box->short_field(_value_offset);\n@@ -3481,1 +3635,1 @@\n-    value->i = box->int_field(value_offset);\n+    value->i = box->int_field(_value_offset);\n@@ -3484,1 +3638,1 @@\n-    value->j = box->long_field(long_value_offset);\n+    value->j = box->long_field(_long_value_offset);\n@@ -3497,1 +3651,1 @@\n-    box->bool_field_put(value_offset, value->z);\n+    box->bool_field_put(_value_offset, value->z);\n@@ -3500,1 +3654,1 @@\n-    box->char_field_put(value_offset, value->c);\n+    box->char_field_put(_value_offset, value->c);\n@@ -3503,1 +3657,1 @@\n-    box->float_field_put(value_offset, value->f);\n+    box->float_field_put(_value_offset, value->f);\n@@ -3506,1 +3660,1 @@\n-    box->double_field_put(long_value_offset, value->d);\n+    box->double_field_put(_long_value_offset, value->d);\n@@ -3509,1 +3663,1 @@\n-    box->byte_field_put(value_offset, value->b);\n+    box->byte_field_put(_value_offset, value->b);\n@@ -3512,1 +3666,1 @@\n-    box->short_field_put(value_offset, value->s);\n+    box->short_field_put(_value_offset, value->s);\n@@ -3515,1 +3669,1 @@\n-    box->int_field_put(value_offset, value->i);\n+    box->int_field_put(_value_offset, value->i);\n@@ -3518,1 +3672,1 @@\n-    box->long_field_put(long_value_offset, value->j);\n+    box->long_field_put(_long_value_offset, value->j);\n@@ -3541,18 +3695,0 @@\n-\/\/ Support for java_lang_ref_Reference\n-\n-bool java_lang_ref_Reference::is_referent_field(oop obj, ptrdiff_t offset) {\n-  assert(obj != NULL, \"sanity\");\n-  if (offset != java_lang_ref_Reference::referent_offset) {\n-    return false;\n-  }\n-\n-  Klass* k = obj->klass();\n-  if (!k->is_instance_klass()) {\n-    return false;\n-  }\n-\n-  InstanceKlass* ik = InstanceKlass::cast(obj->klass());\n-  bool is_reference = ik->reference_type() != REF_NONE;\n-  assert(!is_reference || ik->is_subclass_of(SystemDictionary::Reference_klass()), \"sanity\");\n-  return is_reference;\n-}\n@@ -3563,0 +3699,3 @@\n+int java_lang_ref_SoftReference::_timestamp_offset;\n+int java_lang_ref_SoftReference::_static_clock_offset;\n+\n@@ -3564,2 +3703,2 @@\n-  macro(timestamp_offset,    k, \"timestamp\", long_signature, false); \\\n-  macro(static_clock_offset, k, \"clock\",     long_signature, true)\n+  macro(_timestamp_offset,    k, \"timestamp\", long_signature, false); \\\n+  macro(_static_clock_offset, k, \"clock\",     long_signature, true)\n@@ -3579,1 +3718,1 @@\n-  return ref->long_field(timestamp_offset);\n+  return ref->long_field(_timestamp_offset);\n@@ -3585,1 +3724,1 @@\n-  return base->long_field(static_clock_offset);\n+  return base->long_field(_static_clock_offset);\n@@ -3591,1 +3730,1 @@\n-  base->long_field_put(static_clock_offset, value);\n+  base->long_field_put(_static_clock_offset, value);\n@@ -3602,1 +3741,1 @@\n-  return dmh->obj_field(member_offset_in_bytes());\n+  return dmh->obj_field(_member_offset);\n@@ -4020,4 +4159,4 @@\n-int java_security_AccessControlContext::_context_offset = 0;\n-int java_security_AccessControlContext::_privilegedContext_offset = 0;\n-int java_security_AccessControlContext::_isPrivileged_offset = 0;\n-int java_security_AccessControlContext::_isAuthorized_offset = -1;\n+int java_security_AccessControlContext::_context_offset;\n+int java_security_AccessControlContext::_privilegedContext_offset;\n+int java_security_AccessControlContext::_isPrivileged_offset;\n+int java_security_AccessControlContext::_isAuthorized_offset;\n@@ -4045,1 +4184,1 @@\n-  assert(_isAuthorized_offset != -1, \"offsets should have been initialized\");\n+  assert(_isAuthorized_offset != 0, \"offsets should have been initialized\");\n@@ -4047,1 +4186,1 @@\n-  SystemDictionary::AccessControlContext_klass()->initialize(CHECK_0);\n+  SystemDictionary::AccessControlContext_klass()->initialize(CHECK_NULL);\n@@ -4049,1 +4188,1 @@\n-  oop result = SystemDictionary::AccessControlContext_klass()->allocate_instance(CHECK_0);\n+  oop result = SystemDictionary::AccessControlContext_klass()->allocate_instance(CHECK_NULL);\n@@ -4062,6 +4201,6 @@\n-bool java_lang_ClassLoader::offsets_computed = false;\n-int  java_lang_ClassLoader::_loader_data_offset = -1;\n-int  java_lang_ClassLoader::parallelCapable_offset = -1;\n-int  java_lang_ClassLoader::name_offset = -1;\n-int  java_lang_ClassLoader::nameAndId_offset = -1;\n-int  java_lang_ClassLoader::unnamedModule_offset = -1;\n+int  java_lang_ClassLoader::_loader_data_offset;\n+int  java_lang_ClassLoader::_parallelCapable_offset;\n+int  java_lang_ClassLoader::_name_offset;\n+int  java_lang_ClassLoader::_nameAndId_offset;\n+int  java_lang_ClassLoader::_unnamedModule_offset;\n+int  java_lang_ClassLoader::_parent_offset;\n@@ -4088,5 +4227,5 @@\n-  macro(parallelCapable_offset, k1, \"parallelLockMap\",      concurrenthashmap_signature, false); \\\n-  macro(name_offset,            k1, vmSymbols::name_name(), string_signature, false); \\\n-  macro(nameAndId_offset,       k1, \"nameAndId\",            string_signature, false); \\\n-  macro(unnamedModule_offset,   k1, \"unnamedModule\",        module_signature, false); \\\n-  macro(parent_offset,          k1, \"parent\",               classloader_signature, false)\n+  macro(_parallelCapable_offset, k1, \"parallelLockMap\",      concurrenthashmap_signature, false); \\\n+  macro(_name_offset,            k1, vmSymbols::name_name(), string_signature, false); \\\n+  macro(_nameAndId_offset,       k1, \"nameAndId\",            string_signature, false); \\\n+  macro(_unnamedModule_offset,   k1, \"unnamedModule\",        module_signature, false); \\\n+  macro(_parent_offset,          k1, \"parent\",               classloader_signature, false)\n@@ -4095,3 +4234,0 @@\n-  assert(!offsets_computed, \"offsets should be initialized only once\");\n-  offsets_computed = true;\n-\n@@ -4113,1 +4249,1 @@\n-  return loader->obj_field(parent_offset);\n+  return loader->obj_field(_parent_offset);\n@@ -4120,1 +4256,1 @@\n-  return loader->obj_field(name_offset);\n+  return loader->obj_field(_name_offset);\n@@ -4131,1 +4267,1 @@\n-  return loader->obj_field(nameAndId_offset);\n+  return loader->obj_field(_nameAndId_offset);\n@@ -4159,2 +4295,2 @@\n-  assert(parallelCapable_offset != -1, \"offsets should have been initialized\");\n-  return (class_loader->obj_field(parallelCapable_offset) != NULL);\n+  assert(_parallelCapable_offset != 0, \"offsets should have been initialized\");\n+  return (class_loader->obj_field(_parallelCapable_offset) != NULL);\n@@ -4199,1 +4335,1 @@\n-  return loader->obj_field(unnamedModule_offset);\n+  return loader->obj_field(_unnamedModule_offset);\n@@ -4204,0 +4340,6 @@\n+\n+int java_lang_System::_static_in_offset;\n+int java_lang_System::_static_out_offset;\n+int java_lang_System::_static_err_offset;\n+int java_lang_System::_static_security_offset;\n+\n@@ -4205,4 +4347,4 @@\n-  macro(static_in_offset,  k, \"in\",  input_stream_signature, true); \\\n-  macro(static_out_offset, k, \"out\", print_stream_signature, true); \\\n-  macro(static_err_offset, k, \"err\", print_stream_signature, true); \\\n-  macro(static_security_offset, k, \"security\", security_manager_signature, true)\n+  macro(_static_in_offset,  k, \"in\",  input_stream_signature, true); \\\n+  macro(_static_out_offset, k, \"out\", print_stream_signature, true); \\\n+  macro(_static_err_offset, k, \"err\", print_stream_signature, true); \\\n+  macro(_static_security_offset, k, \"security\", security_manager_signature, true)\n@@ -4221,4 +4363,0 @@\n-int java_lang_System::in_offset_in_bytes() { return static_in_offset; }\n-int java_lang_System::out_offset_in_bytes() { return static_out_offset; }\n-int java_lang_System::err_offset_in_bytes() { return static_err_offset; }\n-\n@@ -4271,101 +4409,1 @@\n-int java_lang_Class::_klass_offset;\n-int java_lang_Class::_array_klass_offset;\n-int java_lang_Class::_oop_size_offset;\n-int java_lang_Class::_static_oop_field_count_offset;\n-int java_lang_Class::_class_loader_offset;\n-int java_lang_Class::_module_offset;\n-int java_lang_Class::_protection_domain_offset;\n-int java_lang_Class::_component_mirror_offset;\n-int java_lang_Class::_init_lock_offset;\n-int java_lang_Class::_signers_offset;\n-int java_lang_Class::_name_offset;\n-int java_lang_Class::_source_file_offset;\n-GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = NULL;\n-GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = NULL;\n-int java_lang_Throwable::backtrace_offset;\n-int java_lang_Throwable::detailMessage_offset;\n-int java_lang_Throwable::stackTrace_offset;\n-int java_lang_Throwable::depth_offset;\n-int java_lang_Throwable::static_unassigned_stacktrace_offset;\n-int java_lang_reflect_AccessibleObject::override_offset;\n-int java_lang_reflect_Method::clazz_offset;\n-int java_lang_reflect_Method::name_offset;\n-int java_lang_reflect_Method::returnType_offset;\n-int java_lang_reflect_Method::parameterTypes_offset;\n-int java_lang_reflect_Method::exceptionTypes_offset;\n-int java_lang_reflect_Method::slot_offset;\n-int java_lang_reflect_Method::modifiers_offset;\n-int java_lang_reflect_Method::signature_offset;\n-int java_lang_reflect_Method::annotations_offset;\n-int java_lang_reflect_Method::parameter_annotations_offset;\n-int java_lang_reflect_Method::annotation_default_offset;\n-int java_lang_reflect_Constructor::clazz_offset;\n-int java_lang_reflect_Constructor::parameterTypes_offset;\n-int java_lang_reflect_Constructor::exceptionTypes_offset;\n-int java_lang_reflect_Constructor::slot_offset;\n-int java_lang_reflect_Constructor::modifiers_offset;\n-int java_lang_reflect_Constructor::signature_offset;\n-int java_lang_reflect_Constructor::annotations_offset;\n-int java_lang_reflect_Constructor::parameter_annotations_offset;\n-int java_lang_reflect_Field::clazz_offset;\n-int java_lang_reflect_Field::name_offset;\n-int java_lang_reflect_Field::type_offset;\n-int java_lang_reflect_Field::slot_offset;\n-int java_lang_reflect_Field::modifiers_offset;\n-int java_lang_reflect_Field::signature_offset;\n-int java_lang_reflect_Field::annotations_offset;\n-int java_lang_reflect_Parameter::name_offset;\n-int java_lang_reflect_Parameter::modifiers_offset;\n-int java_lang_reflect_Parameter::index_offset;\n-int java_lang_reflect_Parameter::executable_offset;\n-int java_lang_boxing_object::value_offset;\n-int java_lang_boxing_object::long_value_offset;\n-int java_lang_ref_Reference::referent_offset;\n-int java_lang_ref_Reference::queue_offset;\n-int java_lang_ref_Reference::next_offset;\n-int java_lang_ref_Reference::discovered_offset;\n-int java_lang_ref_SoftReference::timestamp_offset;\n-int java_lang_ref_SoftReference::static_clock_offset;\n-int java_lang_ClassLoader::parent_offset;\n-int java_lang_System::static_in_offset;\n-int java_lang_System::static_out_offset;\n-int java_lang_System::static_err_offset;\n-int java_lang_System::static_security_offset;\n-int java_lang_StackTraceElement::methodName_offset;\n-int java_lang_StackTraceElement::fileName_offset;\n-int java_lang_StackTraceElement::lineNumber_offset;\n-int java_lang_StackTraceElement::moduleName_offset;\n-int java_lang_StackTraceElement::moduleVersion_offset;\n-int java_lang_StackTraceElement::classLoaderName_offset;\n-int java_lang_StackTraceElement::declaringClass_offset;\n-int java_lang_StackTraceElement::declaringClassObject_offset;\n-int java_lang_StackFrameInfo::_memberName_offset;\n-int java_lang_StackFrameInfo::_bci_offset;\n-int java_lang_StackFrameInfo::_version_offset;\n-int java_lang_LiveStackFrameInfo::_monitors_offset;\n-int java_lang_LiveStackFrameInfo::_locals_offset;\n-int java_lang_LiveStackFrameInfo::_operands_offset;\n-int java_lang_LiveStackFrameInfo::_mode_offset;\n-int java_lang_AssertionStatusDirectives::classes_offset;\n-int java_lang_AssertionStatusDirectives::classEnabled_offset;\n-int java_lang_AssertionStatusDirectives::packages_offset;\n-int java_lang_AssertionStatusDirectives::packageEnabled_offset;\n-int java_lang_AssertionStatusDirectives::deflt_offset;\n-int java_nio_Buffer::_limit_offset;\n-int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;\n-int reflect_ConstantPool::_oop_offset;\n-int reflect_UnsafeStaticFieldAccessorImpl::_base_offset;\n-int java_lang_Integer_IntegerCache::_static_cache_offset;\n-int java_lang_Long_LongCache::_static_cache_offset;\n-int java_lang_Character_CharacterCache::_static_cache_offset;\n-int java_lang_Short_ShortCache::_static_cache_offset;\n-int java_lang_Byte_ByteCache::_static_cache_offset;\n-int java_lang_Boolean::_static_TRUE_offset;\n-int java_lang_Boolean::_static_FALSE_offset;\n-int java_lang_reflect_RecordComponent::clazz_offset;\n-int java_lang_reflect_RecordComponent::name_offset;\n-int java_lang_reflect_RecordComponent::type_offset;\n-int java_lang_reflect_RecordComponent::accessor_offset;\n-int java_lang_reflect_RecordComponent::signature_offset;\n-int java_lang_reflect_RecordComponent::annotations_offset;\n-int java_lang_reflect_RecordComponent::typeAnnotations_offset;\n+\/\/ java_lang_StackTraceElement\n@@ -4374,0 +4412,8 @@\n+int java_lang_StackTraceElement::_methodName_offset;\n+int java_lang_StackTraceElement::_fileName_offset;\n+int java_lang_StackTraceElement::_lineNumber_offset;\n+int java_lang_StackTraceElement::_moduleName_offset;\n+int java_lang_StackTraceElement::_moduleVersion_offset;\n+int java_lang_StackTraceElement::_classLoaderName_offset;\n+int java_lang_StackTraceElement::_declaringClass_offset;\n+int java_lang_StackTraceElement::_declaringClassObject_offset;\n@@ -4376,8 +4422,8 @@\n-  macro(declaringClassObject_offset,  k, \"declaringClassObject\", class_signature, false); \\\n-  macro(classLoaderName_offset, k, \"classLoaderName\", string_signature, false); \\\n-  macro(moduleName_offset,      k, \"moduleName\",      string_signature, false); \\\n-  macro(moduleVersion_offset,   k, \"moduleVersion\",   string_signature, false); \\\n-  macro(declaringClass_offset,  k, \"declaringClass\",  string_signature, false); \\\n-  macro(methodName_offset,      k, \"methodName\",      string_signature, false); \\\n-  macro(fileName_offset,        k, \"fileName\",        string_signature, false); \\\n-  macro(lineNumber_offset,      k, \"lineNumber\",      int_signature,    false)\n+  macro(_declaringClassObject_offset,  k, \"declaringClassObject\", class_signature, false); \\\n+  macro(_classLoaderName_offset, k, \"classLoaderName\", string_signature, false); \\\n+  macro(_moduleName_offset,      k, \"moduleName\",      string_signature, false); \\\n+  macro(_moduleVersion_offset,   k, \"moduleVersion\",   string_signature, false); \\\n+  macro(_declaringClass_offset,  k, \"declaringClass\",  string_signature, false); \\\n+  macro(_methodName_offset,      k, \"methodName\",      string_signature, false); \\\n+  macro(_fileName_offset,        k, \"fileName\",        string_signature, false); \\\n+  macro(_lineNumber_offset,      k, \"lineNumber\",      int_signature,    false)\n@@ -4398,1 +4444,1 @@\n-  element->obj_field_put(fileName_offset, value);\n+  element->obj_field_put(_fileName_offset, value);\n@@ -4402,1 +4448,1 @@\n-  element->obj_field_put(declaringClass_offset, value);\n+  element->obj_field_put(_declaringClass_offset, value);\n@@ -4406,1 +4452,1 @@\n-  element->obj_field_put(methodName_offset, value);\n+  element->obj_field_put(_methodName_offset, value);\n@@ -4410,1 +4456,1 @@\n-  element->int_field_put(lineNumber_offset, value);\n+  element->int_field_put(_lineNumber_offset, value);\n@@ -4414,1 +4460,1 @@\n-  element->obj_field_put(moduleName_offset, value);\n+  element->obj_field_put(_moduleName_offset, value);\n@@ -4418,1 +4464,1 @@\n-  element->obj_field_put(moduleVersion_offset, value);\n+  element->obj_field_put(_moduleVersion_offset, value);\n@@ -4422,1 +4468,1 @@\n-  element->obj_field_put(classLoaderName_offset, value);\n+  element->obj_field_put(_classLoaderName_offset, value);\n@@ -4426,1 +4472,1 @@\n-  element->obj_field_put(declaringClassObject_offset, value);\n+  element->obj_field_put(_declaringClassObject_offset, value);\n@@ -4429,7 +4475,1 @@\n-void java_lang_StackFrameInfo::set_version(oop element, short value) {\n-  element->short_field_put(_version_offset, value);\n-}\n-void java_lang_StackFrameInfo::set_bci(oop element, int value) {\n-  assert(value >= 0 && value < max_jushort, \"must be a valid bci value\");\n-  element->int_field_put(_bci_offset, value);\n-}\n+\/\/ java_lang_AssertionStatusDirectives\n@@ -4438,15 +4478,5 @@\n-void java_lang_LiveStackFrameInfo::set_monitors(oop element, oop value) {\n-  element->obj_field_put(_monitors_offset, value);\n-}\n-\n-void java_lang_LiveStackFrameInfo::set_locals(oop element, oop value) {\n-  element->obj_field_put(_locals_offset, value);\n-}\n-\n-void java_lang_LiveStackFrameInfo::set_operands(oop element, oop value) {\n-  element->obj_field_put(_operands_offset, value);\n-}\n-\n-void java_lang_LiveStackFrameInfo::set_mode(oop element, int value) {\n-  element->int_field_put(_mode_offset, value);\n-}\n+int java_lang_AssertionStatusDirectives::_classes_offset;\n+int java_lang_AssertionStatusDirectives::_classEnabled_offset;\n+int java_lang_AssertionStatusDirectives::_packages_offset;\n+int java_lang_AssertionStatusDirectives::_packageEnabled_offset;\n+int java_lang_AssertionStatusDirectives::_deflt_offset;\n@@ -4456,5 +4486,5 @@\n-  macro(classes_offset,        k, \"classes\",        string_array_signature, false); \\\n-  macro(classEnabled_offset,   k, \"classEnabled\",   bool_array_signature, false); \\\n-  macro(packages_offset,       k, \"packages\",       string_array_signature, false); \\\n-  macro(packageEnabled_offset, k, \"packageEnabled\", bool_array_signature,   false); \\\n-  macro(deflt_offset,          k, \"deflt\",          bool_signature,         false)\n+  macro(_classes_offset,        k, \"classes\",        string_array_signature, false); \\\n+  macro(_classEnabled_offset,   k, \"classEnabled\",   bool_array_signature, false); \\\n+  macro(_packages_offset,       k, \"packages\",       string_array_signature, false); \\\n+  macro(_packageEnabled_offset, k, \"packageEnabled\", bool_array_signature,   false); \\\n+  macro(_deflt_offset,          k, \"deflt\",          bool_signature,         false)\n@@ -4474,1 +4504,1 @@\n-  o->obj_field_put(classes_offset, val);\n+  o->obj_field_put(_classes_offset, val);\n@@ -4478,1 +4508,1 @@\n-  o->obj_field_put(classEnabled_offset, val);\n+  o->obj_field_put(_classEnabled_offset, val);\n@@ -4482,1 +4512,1 @@\n-  o->obj_field_put(packages_offset, val);\n+  o->obj_field_put(_packages_offset, val);\n@@ -4486,1 +4516,1 @@\n-  o->obj_field_put(packageEnabled_offset, val);\n+  o->obj_field_put(_packageEnabled_offset, val);\n@@ -4490,1 +4520,1 @@\n-  o->bool_field_put(deflt_offset, val);\n+  o->bool_field_put(_deflt_offset, val);\n@@ -4495,3 +4525,2 @@\n-int java_nio_Buffer::limit_offset() {\n-  return _limit_offset;\n-}\n+\n+int java_nio_Buffer::_limit_offset;\n@@ -4514,0 +4543,2 @@\n+int java_util_concurrent_locks_AbstractOwnableSynchronizer::_owner_offset;\n+\n@@ -4533,0 +4564,6 @@\n+int java_lang_Integer_IntegerCache::_static_cache_offset;\n+int java_lang_Long_LongCache::_static_cache_offset;\n+int java_lang_Character_CharacterCache::_static_cache_offset;\n+int java_lang_Short_ShortCache::_static_cache_offset;\n+int java_lang_Byte_ByteCache::_static_cache_offset;\n+\n@@ -4682,0 +4719,4 @@\n+\n+int java_lang_Boolean::_static_TRUE_offset;\n+int java_lang_Boolean::_static_FALSE_offset;\n+\n@@ -4719,3 +4760,9 @@\n-static int member_offset(int hardcoded_offset) {\n-  return (hardcoded_offset * heapOopSize) + instanceOopDesc::base_offset_in_bytes();\n-}\n+\/\/ java_lang_reflect_RecordComponent\n+\n+int java_lang_reflect_RecordComponent::_clazz_offset;\n+int java_lang_reflect_RecordComponent::_name_offset;\n+int java_lang_reflect_RecordComponent::_type_offset;\n+int java_lang_reflect_RecordComponent::_accessor_offset;\n+int java_lang_reflect_RecordComponent::_signature_offset;\n+int java_lang_reflect_RecordComponent::_annotations_offset;\n+int java_lang_reflect_RecordComponent::_typeAnnotations_offset;\n@@ -4724,7 +4771,7 @@\n-  macro(clazz_offset,       k, \"clazz\",       class_signature,  false); \\\n-  macro(name_offset,        k, \"name\",        string_signature, false); \\\n-  macro(type_offset,        k, \"type\",        class_signature,  false); \\\n-  macro(accessor_offset,    k, \"accessor\",    reflect_method_signature, false); \\\n-  macro(signature_offset,   k, \"signature\",   string_signature, false); \\\n-  macro(annotations_offset, k, \"annotations\", byte_array_signature,     false); \\\n-  macro(typeAnnotations_offset, k, \"typeAnnotations\", byte_array_signature, false);\n+  macro(_clazz_offset,       k, \"clazz\",       class_signature,  false); \\\n+  macro(_name_offset,        k, \"name\",        string_signature, false); \\\n+  macro(_type_offset,        k, \"type\",        class_signature,  false); \\\n+  macro(_accessor_offset,    k, \"accessor\",    reflect_method_signature, false); \\\n+  macro(_signature_offset,   k, \"signature\",   string_signature, false); \\\n+  macro(_annotations_offset, k, \"annotations\", byte_array_signature,     false); \\\n+  macro(_typeAnnotations_offset, k, \"typeAnnotations\", byte_array_signature, false);\n@@ -4745,1 +4792,1 @@\n-  element->obj_field_put(clazz_offset, value);\n+  element->obj_field_put(_clazz_offset, value);\n@@ -4749,1 +4796,1 @@\n-  element->obj_field_put(name_offset, value);\n+  element->obj_field_put(_name_offset, value);\n@@ -4753,1 +4800,1 @@\n-  element->obj_field_put(type_offset, value);\n+  element->obj_field_put(_type_offset, value);\n@@ -4757,1 +4804,1 @@\n-  element->obj_field_put(accessor_offset, value);\n+  element->obj_field_put(_accessor_offset, value);\n@@ -4761,1 +4808,1 @@\n-  element->obj_field_put(signature_offset, value);\n+  element->obj_field_put(_signature_offset, value);\n@@ -4765,1 +4812,1 @@\n-  element->obj_field_put(annotations_offset, value);\n+  element->obj_field_put(_annotations_offset, value);\n@@ -4769,17 +4816,1 @@\n-  element->obj_field_put(typeAnnotations_offset, value);\n-}\n-\n-\/\/ Compute hard-coded offsets\n-\/\/ Invoked before SystemDictionary::initialize, so pre-loaded classes\n-\/\/ are not available to determine the offset_of_static_fields.\n-void JavaClasses::compute_hard_coded_offsets() {\n-\n-  \/\/ java_lang_boxing_object\n-  java_lang_boxing_object::value_offset      = member_offset(java_lang_boxing_object::hc_value_offset);\n-  java_lang_boxing_object::long_value_offset = align_up(member_offset(java_lang_boxing_object::hc_value_offset), BytesPerLong);\n-\n-  \/\/ java_lang_ref_Reference\n-  java_lang_ref_Reference::referent_offset    = member_offset(java_lang_ref_Reference::hc_referent_offset);\n-  java_lang_ref_Reference::queue_offset       = member_offset(java_lang_ref_Reference::hc_queue_offset);\n-  java_lang_ref_Reference::next_offset        = member_offset(java_lang_ref_Reference::hc_next_offset);\n-  java_lang_ref_Reference::discovered_offset  = member_offset(java_lang_ref_Reference::hc_discovered_offset);\n+  element->obj_field_put(_typeAnnotations_offset, value);\n@@ -4790,1 +4821,1 @@\n-\/\/ Compute non-hard-coded field offsets of all the classes in this file\n+\/\/ Compute field offsets of all the classes in this file\n@@ -4793,3 +4824,3 @@\n-    assert(JvmtiExport::is_early_phase() && !(JvmtiExport::should_post_class_file_load_hook() &&\n-                                              JvmtiExport::has_early_class_hook_env()),\n-           \"JavaClasses::compute_offsets() must be called in early JVMTI phase.\");\n+    JVMTI_ONLY(assert(JvmtiExport::is_early_phase() && !(JvmtiExport::should_post_class_file_load_hook() &&\n+                                                         JvmtiExport::has_early_class_hook_env()),\n+                      \"JavaClasses::compute_offsets() must be called in early JVMTI phase.\"));\n@@ -4797,1 +4828,1 @@\n-    \/\/ JMVTI ClassFileLoadHook.\n+    \/\/ JVMTI ClassFileLoadHook.\n@@ -4804,2 +4835,2 @@\n-  \/\/ BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String and java_lang_Class)\n-  \/\/ earlier inside SystemDictionary::resolve_well_known_classes()\n+  \/\/ BASIC_JAVA_CLASSES_DO_PART1 classes (java_lang_String, java_lang_Class and\n+  \/\/ java_lang_ref_Reference) earlier inside SystemDictionary::resolve_well_known_classes()\n@@ -4842,2 +4873,1 @@\n-\/\/ These functions exist to assert the validity of hard-coded field offsets to guard\n-\/\/ against changes in the class files\n+\/\/ These functions exist to assert the validity of de-serialized offsets in boxing object as a sanity check.\n@@ -4845,1 +4875,2 @@\n-bool JavaClasses::check_offset(const char *klass_name, int hardcoded_offset, const char *field_name, const char* field_sig) {\n+bool JavaClasses::check_offset(const char *klass_name, int deserialized_offset, const char *field_name,\n+                               const char* field_sig) {\n@@ -4861,1 +4892,1 @@\n-  if (fd.offset() == hardcoded_offset ) {\n+  if (fd.offset() == deserialized_offset ) {\n@@ -4864,2 +4895,2 @@\n-    tty->print_cr(\"Offset of nonstatic field %s.%s is hardcoded as %d but should really be %d.\",\n-                  klass_name, field_name, hardcoded_offset, fd.offset());\n+    tty->print_cr(\"Offset of nonstatic field %s.%s is deserialized as %d but should really be %d.\",\n+                  klass_name, field_name, deserialized_offset, fd.offset());\n@@ -4870,2 +4901,0 @@\n-\/\/ Check the hard-coded field offsets of all the classes in this file\n-\n@@ -4876,1 +4905,1 @@\n-  valid &= check_offset(klass_name, cpp_klass_name :: field_name ## _offset, #field_name, field_sig)\n+  valid &= check_offset(klass_name, cpp_klass_name :: _##field_name ## _offset, #field_name, field_sig)\n@@ -4879,1 +4908,1 @@\n-  valid &= check_offset(klass_name, cpp_klass_name :: long_ ## field_name ## _offset, #field_name, field_sig)\n+  valid &= check_offset(klass_name, cpp_klass_name :: _##long_ ## field_name ## _offset, #field_name, field_sig)\n@@ -4892,9 +4921,1 @@\n-  \/\/ java.lang.ref.Reference\n-\n-  CHECK_OFFSET(\"java\/lang\/ref\/Reference\", java_lang_ref_Reference, referent, \"Ljava\/lang\/Object;\");\n-  CHECK_OFFSET(\"java\/lang\/ref\/Reference\", java_lang_ref_Reference, queue, \"Ljava\/lang\/ref\/ReferenceQueue;\");\n-  CHECK_OFFSET(\"java\/lang\/ref\/Reference\", java_lang_ref_Reference, next, \"Ljava\/lang\/ref\/Reference;\");\n-  \/\/ Fake field\n-  \/\/CHECK_OFFSET(\"java\/lang\/ref\/Reference\", java_lang_ref_Reference, discovered, \"Ljava\/lang\/ref\/Reference;\");\n-\n-  if (!valid) vm_exit_during_initialization(\"Hard-coded field offset verification failed\");\n+  if (!valid) vm_exit_during_initialization(\"Field offset verification failed\");\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":604,"deletions":583,"binary":false,"changes":1187,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,14 +36,0 @@\n-\/\/\n-\/\/ All dependencies on layout of actual Java classes should be kept here.\n-\/\/ If the layout of any of the classes above changes the offsets must be adjusted.\n-\/\/\n-\/\/ For most classes we hardwire the offsets for performance reasons. In certain\n-\/\/ cases (e.g. java.security.AccessControlContext) we compute the offsets at\n-\/\/ startup since the layout here differs between JDK1.2 and JDK1.3.\n-\/\/\n-\/\/ Note that fields (static and non-static) are arranged with oops before non-oops\n-\/\/ on a per class basis. The offsets below have to reflect this ordering.\n-\/\/\n-\/\/ When editing the layouts please update the check_offset verification code\n-\/\/ correspondingly. The names in the enums must be identical to the actual field\n-\/\/ names in order for the verification code to work.\n@@ -54,0 +40,1 @@\n+  f(java_lang_ref_Reference) \\\n@@ -89,0 +76,1 @@\n+  f(java_lang_boxing_object) \\\n@@ -95,0 +83,2 @@\n+#define CHECK_INIT(offset)  assert(offset != 0, \"should be initialized\"); return offset;\n+\n@@ -106,4 +96,4 @@\n-  static int value_offset;\n-  static int hash_offset;\n-  static int hashIsZero_offset;\n-  static int coder_offset;\n+  static int _value_offset;\n+  static int _hash_offset;\n+  static int _hashIsZero_offset;\n+  static int _coder_offset;\n@@ -111,1 +101,1 @@\n-  static bool initialized;\n+  static bool _initialized;\n@@ -139,16 +129,2 @@\n-  static int value_offset_in_bytes()  {\n-    assert(initialized && (value_offset > 0), \"Must be initialized\");\n-    return value_offset;\n-  }\n-  static int hash_offset_in_bytes()   {\n-    assert(initialized && (hash_offset > 0), \"Must be initialized\");\n-    return hash_offset;\n-  }\n-  static int hashIsZero_offset_in_bytes()   {\n-    assert(initialized && (hashIsZero_offset > 0), \"Must be initialized\");\n-    return hashIsZero_offset;\n-  }\n-  static int coder_offset_in_bytes()   {\n-    assert(initialized && (coder_offset > 0), \"Must be initialized\");\n-    return coder_offset;\n-  }\n+  static int value_offset() { CHECK_INIT(_value_offset); }\n+  static int coder_offset() { CHECK_INIT(_coder_offset); }\n@@ -171,0 +147,2 @@\n+  static char*  as_utf8_string(oop java_string, int& length);\n+  static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int& length);\n@@ -250,0 +228,1 @@\n+\n@@ -266,0 +245,2 @@\n+  static int _classData_offset;\n+  static int _classRedefinedCount_offset;\n@@ -267,2 +248,1 @@\n-  static bool offsets_computed;\n-  static int classRedefinedCount_offset;\n+  static bool _offsets_computed;\n@@ -277,1 +257,2 @@\n-  static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain, TRAPS);\n+  static void initialize_mirror_fields(Klass* k, Handle mirror, Handle protection_domain,\n+                                       Handle classData, TRAPS);\n@@ -285,1 +266,1 @@\n-                            Handle protection_domain, TRAPS);\n+                            Handle protection_domain, Handle classData, TRAPS);\n@@ -321,2 +302,2 @@\n-  static int klass_offset_in_bytes()                { return _klass_offset; }\n-  static int array_klass_offset_in_bytes()          { return _array_klass_offset; }\n+  static int klass_offset()                { CHECK_INIT(_klass_offset); }\n+  static int array_klass_offset()          { CHECK_INIT(_array_klass_offset); }\n@@ -334,0 +315,3 @@\n+  static void clear_init_lock(oop java_class) {\n+    set_init_lock(java_class, NULL);\n+  }\n@@ -337,0 +321,2 @@\n+  static oop  class_data(oop java_class);\n+  static void set_class_data(oop java_class, oop classData);\n@@ -370,2 +356,0 @@\n-  friend class InstanceKlass;   \/\/ verification code accesses offsets\n-  friend class ClassFileParser; \/\/ access to number_of_fake_fields\n@@ -530,7 +514,0 @@\n-  \/\/ Offsets\n-  enum {\n-    hc_backtrace_offset     =  0,\n-    hc_detailMessage_offset =  1,\n-    hc_cause_offset         =  2,  \/\/ New since 1.4\n-    hc_stackTrace_offset    =  3   \/\/ New since 1.4\n-  };\n@@ -549,5 +526,5 @@\n-  static int backtrace_offset;\n-  static int detailMessage_offset;\n-  static int stackTrace_offset;\n-  static int depth_offset;\n-  static int static_unassigned_stacktrace_offset;\n+  static int _backtrace_offset;\n+  static int _detailMessage_offset;\n+  static int _stackTrace_offset;\n+  static int _depth_offset;\n+  static int _static_unassigned_stacktrace_offset;\n@@ -567,3 +544,1 @@\n-  \/\/ Needed by JVMTI to filter out this internal field.\n-  static int get_backtrace_offset() { return backtrace_offset;}\n-  static int get_detailMessage_offset() { return detailMessage_offset;}\n+  static int get_detailMessage_offset() { CHECK_INIT(_detailMessage_offset); }\n@@ -606,1 +581,1 @@\n-  static int override_offset;\n+  static int _override_offset;\n@@ -628,11 +603,11 @@\n-  static int clazz_offset;\n-  static int name_offset;\n-  static int returnType_offset;\n-  static int parameterTypes_offset;\n-  static int exceptionTypes_offset;\n-  static int slot_offset;\n-  static int modifiers_offset;\n-  static int signature_offset;\n-  static int annotations_offset;\n-  static int parameter_annotations_offset;\n-  static int annotation_default_offset;\n+  static int _clazz_offset;\n+  static int _name_offset;\n+  static int _returnType_offset;\n+  static int _parameterTypes_offset;\n+  static int _exceptionTypes_offset;\n+  static int _slot_offset;\n+  static int _modifiers_offset;\n+  static int _signature_offset;\n+  static int _annotations_offset;\n+  static int _parameter_annotations_offset;\n+  static int _annotation_default_offset;\n@@ -680,8 +655,8 @@\n-  static int clazz_offset;\n-  static int parameterTypes_offset;\n-  static int exceptionTypes_offset;\n-  static int slot_offset;\n-  static int modifiers_offset;\n-  static int signature_offset;\n-  static int annotations_offset;\n-  static int parameter_annotations_offset;\n+  static int _clazz_offset;\n+  static int _parameterTypes_offset;\n+  static int _exceptionTypes_offset;\n+  static int _slot_offset;\n+  static int _modifiers_offset;\n+  static int _signature_offset;\n+  static int _annotations_offset;\n+  static int _parameter_annotations_offset;\n@@ -723,7 +698,8 @@\n-  static int clazz_offset;\n-  static int name_offset;\n-  static int type_offset;\n-  static int slot_offset;\n-  static int modifiers_offset;\n-  static int signature_offset;\n-  static int annotations_offset;\n+  static int _clazz_offset;\n+  static int _name_offset;\n+  static int _type_offset;\n+  static int _slot_offset;\n+  static int _modifiers_offset;\n+  static int _trusted_final_offset;\n+  static int _signature_offset;\n+  static int _annotations_offset;\n@@ -755,0 +731,2 @@\n+  static void set_trusted_final(oop field);\n+\n@@ -768,4 +746,4 @@\n-  static int name_offset;\n-  static int modifiers_offset;\n-  static int index_offset;\n-  static int executable_offset;\n+  static int _name_offset;\n+  static int _modifiers_offset;\n+  static int _index_offset;\n+  static int _executable_offset;\n@@ -802,2 +780,2 @@\n-    static int loader_offset;\n-    static int name_offset;\n+    static int _loader_offset;\n+    static int _name_offset;\n@@ -805,0 +783,1 @@\n+\n@@ -846,3 +825,1 @@\n-  static int oop_offset() {\n-    return _oop_offset;\n-  }\n+  static int oop_offset() { CHECK_INIT(_oop_offset); }\n@@ -865,3 +842,1 @@\n-  static int base_offset() {\n-    return _base_offset;\n-  }\n+  static int base_offset() { CHECK_INIT(_base_offset); }\n@@ -887,5 +862,2 @@\n-  enum {\n-   hc_value_offset = 0\n-  };\n-  static int value_offset;\n-  static int long_value_offset;\n+  static int _value_offset;\n+  static int _long_value_offset;\n@@ -893,0 +865,1 @@\n+  static void compute_offsets();\n@@ -906,3 +879,2 @@\n-  static int value_offset_in_bytes(BasicType type) {\n-    return ( type == T_LONG || type == T_DOUBLE ) ? long_value_offset :\n-                                                    value_offset;\n+  static int value_offset(BasicType type) {\n+    return is_double_word_type(type) ? _long_value_offset : _value_offset;\n@@ -911,0 +883,2 @@\n+  static void serialize_offsets(SerializeClosure* f);\n+\n@@ -920,7 +894,4 @@\n- public:\n-  enum {\n-   hc_referent_offset   = 0,\n-   hc_queue_offset      = 1,\n-   hc_next_offset       = 2,\n-   hc_discovered_offset = 3  \/\/ Is not last, see SoftRefs.\n-  };\n+  static int _referent_offset;\n+  static int _queue_offset;\n+  static int _next_offset;\n+  static int _discovered_offset;\n@@ -928,4 +899,1 @@\n-  static int referent_offset;\n-  static int queue_offset;\n-  static int next_offset;\n-  static int discovered_offset;\n+  static bool _offsets_initialized;\n@@ -933,0 +901,1 @@\n+ public:\n@@ -951,0 +920,8 @@\n+\n+  static int referent_offset()    { CHECK_INIT(_referent_offset); }\n+  static int queue_offset()       { CHECK_INIT(_queue_offset); }\n+  static int next_offset()        { CHECK_INIT(_next_offset); }\n+  static int discovered_offset()  { CHECK_INIT(_discovered_offset); }\n+\n+  static void compute_offsets();\n+  static void serialize_offsets(SerializeClosure* f) NOT_CDS_RETURN;\n@@ -957,3 +934,2 @@\n- public:\n-  static int timestamp_offset;\n-  static int static_clock_offset;\n+  static int _timestamp_offset;\n+  static int _static_clock_offset;\n@@ -961,0 +937,1 @@\n+ public:\n@@ -1002,2 +979,2 @@\n-  static int type_offset_in_bytes()             { return _type_offset; }\n-  static int form_offset_in_bytes()             { return _form_offset; }\n+  static int type_offset()             { CHECK_INIT(_type_offset); }\n+  static int form_offset()             { CHECK_INIT(_form_offset); }\n@@ -1029,1 +1006,1 @@\n-  static int member_offset_in_bytes()           { return _member_offset; }\n+  static int member_offset()           { CHECK_INIT(_member_offset); }\n@@ -1058,1 +1035,1 @@\n-  static int vmentry_offset_in_bytes()          { return _vmentry_offset; }\n+  static int vmentry_offset()          { CHECK_INIT(_vmentry_offset); }\n@@ -1079,1 +1056,1 @@\n-  static int vmtarget_offset_in_bytes() { return _vmtarget_offset; }\n+  static int vmtarget_offset() { CHECK_INIT(_vmtarget_offset); }\n@@ -1149,7 +1126,8 @@\n-    MN_IS_METHOD            = 0x00010000, \/\/ method (not constructor)\n-    MN_IS_CONSTRUCTOR       = 0x00020000, \/\/ constructor\n-    MN_IS_FIELD             = 0x00040000, \/\/ field\n-    MN_IS_TYPE              = 0x00080000, \/\/ nested type\n-    MN_CALLER_SENSITIVE     = 0x00100000, \/\/ @CallerSensitive annotation detected\n-    MN_REFERENCE_KIND_SHIFT = 24, \/\/ refKind\n-    MN_REFERENCE_KIND_MASK  = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n+    MN_IS_METHOD             = 0x00010000, \/\/ method (not constructor)\n+    MN_IS_CONSTRUCTOR        = 0x00020000, \/\/ constructor\n+    MN_IS_FIELD              = 0x00040000, \/\/ field\n+    MN_IS_TYPE               = 0x00080000, \/\/ nested type\n+    MN_CALLER_SENSITIVE      = 0x00100000, \/\/ @CallerSensitive annotation detected\n+    MN_TRUSTED_FINAL         = 0x00200000, \/\/ trusted final field\n+    MN_REFERENCE_KIND_SHIFT  = 24, \/\/ refKind\n+    MN_REFERENCE_KIND_MASK   = 0x0F000000 >> MN_REFERENCE_KIND_SHIFT,\n@@ -1157,2 +1135,6 @@\n-    MN_SEARCH_SUPERCLASSES  = 0x00100000, \/\/ walk super classes\n-    MN_SEARCH_INTERFACES    = 0x00200000  \/\/ walk implemented interfaces\n+    MN_SEARCH_SUPERCLASSES   = 0x00100000, \/\/ walk super classes\n+    MN_SEARCH_INTERFACES     = 0x00200000, \/\/ walk implemented interfaces\n+    MN_NESTMATE_CLASS        = 0x00000001,\n+    MN_HIDDEN_CLASS          = 0x00000002,\n+    MN_STRONG_LOADER_LINK    = 0x00000004,\n+    MN_ACCESS_VM_ANNOTATIONS = 0x00000008\n@@ -1162,6 +1144,5 @@\n-  static int clazz_offset_in_bytes()            { return _clazz_offset; }\n-  static int type_offset_in_bytes()             { return _type_offset; }\n-  static int name_offset_in_bytes()             { return _name_offset; }\n-  static int flags_offset_in_bytes()            { return _flags_offset; }\n-  static int method_offset_in_bytes()           { return _method_offset; }\n-  static int vmindex_offset_in_bytes()          { return _vmindex_offset; }\n+  static int clazz_offset()   { CHECK_INIT(_clazz_offset); }\n+  static int type_offset()    { CHECK_INIT(_type_offset); }\n+  static int flags_offset()   { CHECK_INIT(_flags_offset); }\n+  static int method_offset()  { CHECK_INIT(_method_offset); }\n+  static int vmindex_offset() { CHECK_INIT(_vmindex_offset); }\n@@ -1202,2 +1183,2 @@\n-  static int rtype_offset_in_bytes()            { return _rtype_offset; }\n-  static int ptypes_offset_in_bytes()           { return _ptypes_offset; }\n+  static int rtype_offset()  { CHECK_INIT(_rtype_offset); }\n+  static int ptypes_offset() { CHECK_INIT(_ptypes_offset); }\n@@ -1234,1 +1215,2 @@\n-  static int target_offset_in_bytes()           { return _target_offset; }\n+  static int target_offset()  { CHECK_INIT(_target_offset); }\n+  static int context_offset() { CHECK_INIT(_context_offset); }\n@@ -1317,6 +1299,5 @@\n-  static bool offsets_computed;\n-  static int parent_offset;\n-  static int parallelCapable_offset;\n-  static int name_offset;\n-  static int nameAndId_offset;\n-  static int unnamedModule_offset;\n+  static int _parent_offset;\n+  static int _parallelCapable_offset;\n+  static int _name_offset;\n+  static int _nameAndId_offset;\n+  static int _unnamedModule_offset;\n@@ -1324,1 +1305,2 @@\n- public:\n+\n+ public:\n@@ -1359,1 +1341,0 @@\n-  friend class ClassFileParser; \/\/ access to number_of_fake_fields\n@@ -1367,4 +1348,4 @@\n-  static int  static_in_offset;\n-  static int static_out_offset;\n-  static int static_err_offset;\n-  static int static_security_offset;\n+  static int _static_in_offset;\n+  static int _static_out_offset;\n+  static int _static_err_offset;\n+  static int _static_security_offset;\n@@ -1373,3 +1354,3 @@\n-  static int  in_offset_in_bytes();\n-  static int out_offset_in_bytes();\n-  static int err_offset_in_bytes();\n+  static int  in_offset() { CHECK_INIT(_static_in_offset); }\n+  static int out_offset() { CHECK_INIT(_static_out_offset); }\n+  static int err_offset() { CHECK_INIT(_static_err_offset); }\n@@ -1389,8 +1370,8 @@\n-  static int declaringClassObject_offset;\n-  static int classLoaderName_offset;\n-  static int moduleName_offset;\n-  static int moduleVersion_offset;\n-  static int declaringClass_offset;\n-  static int methodName_offset;\n-  static int fileName_offset;\n-  static int lineNumber_offset;\n+  static int _declaringClassObject_offset;\n+  static int _classLoaderName_offset;\n+  static int _moduleName_offset;\n+  static int _moduleVersion_offset;\n+  static int _declaringClass_offset;\n+  static int _methodName_offset;\n+  static int _fileName_offset;\n+  static int _lineNumber_offset;\n@@ -1500,7 +1481,7 @@\n-  static int clazz_offset;\n-  static int name_offset;\n-  static int type_offset;\n-  static int accessor_offset;\n-  static int signature_offset;\n-  static int annotations_offset;\n-  static int typeAnnotations_offset;\n+  static int _clazz_offset;\n+  static int _name_offset;\n+  static int _type_offset;\n+  static int _accessor_offset;\n+  static int _signature_offset;\n+  static int _annotations_offset;\n+  static int _typeAnnotations_offset;\n@@ -1533,5 +1514,5 @@\n-  static int classes_offset;\n-  static int classEnabled_offset;\n-  static int packages_offset;\n-  static int packageEnabled_offset;\n-  static int deflt_offset;\n+  static int _classes_offset;\n+  static int _classEnabled_offset;\n+  static int _packages_offset;\n+  static int _packageEnabled_offset;\n+  static int _deflt_offset;\n@@ -1560,1 +1541,1 @@\n-  static int  limit_offset();\n+  static int  limit_offset() { CHECK_INIT(_limit_offset); }\n@@ -1728,1 +1709,0 @@\n-  static void compute_hard_coded_offsets();\n@@ -1738,0 +1718,1 @@\n+#undef CHECK_INIT\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":161,"deletions":180,"binary":false,"changes":341,"status":"modified"},{"patch":"@@ -49,2 +49,0 @@\n-#include \"gc\/shared\/oopStorage.inline.hpp\"\n-#include \"gc\/shared\/oopStorageSet.hpp\"\n@@ -71,0 +69,1 @@\n+#include \"oops\/oopHandle.inline.hpp\"\n@@ -87,0 +86,1 @@\n+#include \"utilities\/utf8.hpp\"\n@@ -100,2 +100,0 @@\n-oop         SystemDictionary::_system_loader_lock_obj     =  NULL;\n-\n@@ -107,2 +105,4 @@\n-oop         SystemDictionary::_java_system_loader         =  NULL;\n-oop         SystemDictionary::_java_platform_loader       =  NULL;\n+\n+OopHandle   SystemDictionary::_system_loader_lock_obj;\n+OopHandle   SystemDictionary::_java_system_loader;\n+OopHandle   SystemDictionary::_java_platform_loader;\n@@ -114,0 +114,40 @@\n+ClassLoadInfo::ClassLoadInfo() {\n+  _protection_domain = Handle();\n+  _unsafe_anonymous_host = NULL;\n+  _cp_patches = NULL;\n+  _class_hidden_info._dynamic_nest_host = NULL;\n+  _class_hidden_info._class_data = Handle();\n+  _is_hidden = false;\n+  _is_strong_hidden = false;\n+  _can_access_vm_annotations = false;\n+}\n+\n+ClassLoadInfo::ClassLoadInfo(Handle protection_domain) {\n+  _protection_domain = protection_domain;\n+  _unsafe_anonymous_host = NULL;\n+  _cp_patches = NULL;\n+  _class_hidden_info._dynamic_nest_host = NULL;\n+  _class_hidden_info._class_data = Handle();\n+  _is_hidden = false;\n+  _is_strong_hidden = false;\n+  _can_access_vm_annotations = false;\n+}\n+\n+ClassLoadInfo::ClassLoadInfo(Handle protection_domain,\n+                             const InstanceKlass* unsafe_anonymous_host,\n+                             GrowableArray<Handle>* cp_patches,\n+                             InstanceKlass* dynamic_nest_host,\n+                             Handle class_data,\n+                             bool is_hidden,\n+                             bool is_strong_hidden,\n+                             bool can_access_vm_annotations) {\n+  _protection_domain = protection_domain;\n+  _unsafe_anonymous_host = unsafe_anonymous_host;\n+  _cp_patches = cp_patches;\n+  _class_hidden_info._dynamic_nest_host = dynamic_nest_host;\n+  _class_hidden_info._class_data = class_data;\n+  _is_hidden = is_hidden;\n+  _is_strong_hidden = is_strong_hidden;\n+  _can_access_vm_annotations = can_access_vm_annotations;\n+}\n+\n@@ -117,0 +157,4 @@\n+oop SystemDictionary::system_loader_lock() {\n+  return _system_loader_lock_obj.resolve();\n+}\n+\n@@ -118,1 +162,1 @@\n-  return _java_system_loader;\n+  return _java_system_loader.resolve();\n@@ -122,1 +166,1 @@\n-  return _java_platform_loader;\n+  return _java_platform_loader.resolve();\n@@ -134,1 +178,1 @@\n-  _java_system_loader = (oop)result.get_jobject();\n+  _java_system_loader = OopHandle::create((oop)result.get_jobject());\n@@ -142,1 +186,1 @@\n-  _java_platform_loader = (oop)result.get_jobject();\n+  _java_platform_loader = OopHandle::create((oop)result.get_jobject());\n@@ -145,3 +189,8 @@\n-ClassLoaderData* SystemDictionary::register_loader(Handle class_loader) {\n-  if (class_loader() == NULL) return ClassLoaderData::the_null_class_loader_data();\n-  return ClassLoaderDataGraph::find_or_create(class_loader);\n+ClassLoaderData* SystemDictionary::register_loader(Handle class_loader, bool create_mirror_cld) {\n+  if (create_mirror_cld) {\n+    \/\/ Add a new class loader data to the graph.\n+    return ClassLoaderDataGraph::add(class_loader, true);\n+  } else {\n+    return (class_loader() == NULL) ? ClassLoaderData::the_null_class_loader_data() :\n+                                      ClassLoaderDataGraph::find_or_create(class_loader);\n+  }\n@@ -176,1 +225,1 @@\n-         class_loader == _java_system_loader);\n+         class_loader == _java_system_loader.peek());\n@@ -190,0 +239,21 @@\n+Symbol* SystemDictionary::class_name_symbol(const char* name, Symbol* exception, TRAPS) {\n+  if (name == NULL) {\n+    THROW_MSG_0(exception, \"No class name given\");\n+  }\n+  if ((int)strlen(name) > Symbol::max_length()) {\n+    \/\/ It's impossible to create this class;  the name cannot fit\n+    \/\/ into the constant pool.\n+    Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                       \"Class name exceeds maximum length of %d: %s\",\n+                       Symbol::max_length(),\n+                       name);\n+    return NULL;\n+  }\n+  \/\/ Callers should ensure that the name is never an illegal UTF8 string.\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),\n+         \"Class name is not a valid utf8 string.\");\n+\n+  \/\/ Make a new symbol for the class name.\n+  return SymbolTable::new_symbol(name);\n+}\n+\n@@ -539,1 +609,2 @@\n-  assert((lockObject() != _system_loader_lock_obj && !is_parallelCapable(lockObject)), \"unexpected double_lock_wait\");\n+  assert((lockObject() != _system_loader_lock_obj.resolve() &&\n+         !is_parallelCapable(lockObject)), \"unexpected double_lock_wait\");\n@@ -642,1 +713,1 @@\n-static void post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {\n+void SystemDictionary::post_class_load_event(EventClassLoad* event, const InstanceKlass* k, const ClassLoaderData* init_cld) {\n@@ -832,1 +903,1 @@\n-        \/\/ Klass is already loaded, so return it after checking\/adding protection domain\n+          \/\/ Klass is already loaded, so return it after checking\/adding protection domain\n@@ -979,2 +1050,1 @@\n-      Symbol* obj_class = ss.as_symbol();\n-      k = SystemDictionary::find(obj_class, class_loader, protection_domain, THREAD);\n+      k = SystemDictionary::find(ss.as_symbol(), class_loader, protection_domain, THREAD);\n@@ -993,2 +1063,2 @@\n-\/\/ Handles unsafe_DefineAnonymousClass and redefineclasses\n-\/\/ RedefinedClasses do not add to the class hierarchy\n+\/\/ Handles Lookup.defineClass hidden, unsafe_DefineAnonymousClass\n+\/\/ and redefineclasses. RedefinedClasses do not add to the class hierarchy.\n@@ -997,3 +1067,1 @@\n-                                              Handle protection_domain,\n-                                              const InstanceKlass* unsafe_anonymous_host,\n-                                              GrowableArray<Handle>* cp_patches,\n+                                              const ClassLoadInfo& cl_info,\n@@ -1004,6 +1072,12 @@\n-\n-  if (unsafe_anonymous_host != NULL) {\n-    \/\/ Create a new CLD for an unsafe anonymous class, that uses the same class loader\n-    \/\/ as the unsafe_anonymous_host\n-    guarantee(unsafe_anonymous_host->class_loader() == class_loader(), \"should be the same\");\n-    loader_data = ClassLoaderData::unsafe_anonymous_class_loader_data(class_loader);\n+  bool is_unsafe_anon_class = cl_info.unsafe_anonymous_host() != NULL;\n+\n+  \/\/ - for unsafe anonymous class: create a new CLD whith a class holder that uses\n+  \/\/                               the same class loader as the unsafe_anonymous_host.\n+  \/\/ - for hidden classes that are not strong: create a new CLD that has a class holder and\n+  \/\/                                           whose loader is the Lookup class's loader.\n+  \/\/ - for hidden class: add the class to the Lookup class's loader's CLD.\n+  if (is_unsafe_anon_class || cl_info.is_hidden()) {\n+    guarantee(!is_unsafe_anon_class || cl_info.unsafe_anonymous_host()->class_loader() == class_loader(),\n+              \"should be NULL or the same\");\n+    bool create_mirror_cld = is_unsafe_anon_class || !cl_info.is_strong_hidden();\n+    loader_data = register_loader(class_loader, create_mirror_cld);\n@@ -1026,3 +1100,1 @@\n-                                                      protection_domain,\n-                                                      unsafe_anonymous_host,\n-                                                      cp_patches,\n+                                                      cl_info,\n@@ -1031,4 +1103,7 @@\n-  if (unsafe_anonymous_host != NULL && k != NULL) {\n-    \/\/ Unsafe anonymous classes must update ClassLoaderData holder (was unsafe_anonymous_host loader)\n-    \/\/ so that they can be unloaded when the mirror is no longer referenced.\n-    k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));\n+  if ((cl_info.is_hidden() || is_unsafe_anon_class) && k != NULL) {\n+    \/\/ Hidden classes that are not strong and unsafe anonymous classes must update\n+    \/\/ ClassLoaderData holder so that they can be unloaded when the mirror is no\n+    \/\/ longer referenced.\n+    if (!cl_info.is_strong_hidden() || is_unsafe_anon_class) {\n+      k->class_loader_data()->initialize_holder(Handle(THREAD, k->java_mirror()));\n+    }\n@@ -1047,2 +1122,2 @@\n-    if (cp_patches != NULL) {\n-      k->constants()->patch_resolved_references(cp_patches);\n+    if (cl_info.cp_patches() != NULL) {\n+      k->constants()->patch_resolved_references(cl_info.cp_patches());\n@@ -1052,1 +1127,3 @@\n-    k->eager_initialize(CHECK_NULL);\n+    if (is_unsafe_anon_class) {\n+      k->eager_initialize(CHECK_NULL);\n+    }\n@@ -1063,1 +1140,1 @@\n-  assert(unsafe_anonymous_host != NULL || NULL == cp_patches,\n+  assert(is_unsafe_anon_class || NULL == cl_info.cp_patches(),\n@@ -1118,7 +1195,2 @@\n-    k = KlassFactory::create_from_stream(st,\n-                                         class_name,\n-                                         loader_data,\n-                                         protection_domain,\n-                                         NULL, \/\/ unsafe_anonymous_host\n-                                         NULL, \/\/ cp_patches\n-                                         CHECK_NULL);\n+    ClassLoadInfo cl_info(protection_domain);\n+    k = KlassFactory::create_from_stream(st, class_name, loader_data, cl_info, CHECK_NULL);\n@@ -1168,0 +1240,1 @@\n+                                                        PackageEntry* pkg_entry,\n@@ -1169,0 +1242,1 @@\n+  assert(UseSharedSpaces, \"Sanity check\");\n@@ -1171,1 +1245,1 @@\n-    return load_shared_class(ik, Handle(), Handle(), NULL, THREAD);\n+    return load_shared_class(ik, Handle(), Handle(), NULL, pkg_entry, THREAD);\n@@ -1184,0 +1258,1 @@\n+                                               PackageEntry* pkg_entry,\n@@ -1187,4 +1262,1 @@\n-  ResourceMark rm(THREAD);\n-  int path_index = ik->shared_classpath_index();\n-  ClassLoaderData* loader_data = class_loader_data(class_loader);\n-  if (path_index < 0) {\n+  if (ik->shared_classpath_index() < 0) {\n@@ -1193,1 +1265,1 @@\n-    if (loader_data->is_builtin_class_loader_data()) {\n+    if (is_builtin_class_loader(class_loader())) {\n@@ -1199,0 +1271,15 @@\n+\n+  \/\/ skip class visibility check\n+  if (MetaspaceShared::use_optimized_module_handling()) {\n+    assert(SystemDictionary::is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD), \"Optimizing module handling failed.\");\n+    return true;\n+  }\n+  return is_shared_class_visible_impl(class_name, ik, pkg_entry, class_loader, THREAD);\n+}\n+\n+bool SystemDictionary::is_shared_class_visible_impl(Symbol* class_name,\n+                                               InstanceKlass* ik,\n+                                               PackageEntry* pkg_entry,\n+                                               Handle class_loader, TRAPS) {\n+  int path_index = ik->shared_classpath_index();\n+  ClassLoaderData* loader_data = class_loader_data(class_loader);\n@@ -1208,3 +1295,2 @@\n-  TempNewSymbol pkg_name = NULL;\n-  PackageEntry* pkg_entry = NULL;\n-  pkg_name = InstanceKlass::package_from_name(class_name, CHECK_false);\n+  TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry->name() :\n+                                               ClassLoader::package_from_class_name(class_name);\n@@ -1214,4 +1300,8 @@\n-      pkg_entry = loader_data->packages()->lookup_only(pkg_name);\n-    }\n-    if (pkg_entry != NULL) {\n-      mod_entry = pkg_entry->module();\n+      if (pkg_entry != NULL) {\n+        mod_entry = pkg_entry->module();\n+        \/\/ If the archived class is from a module that has been patched at runtime,\n+        \/\/ the class cannot be loaded from the archive.\n+        if (mod_entry != NULL && mod_entry->is_patched()) {\n+          return false;\n+        }\n+      }\n@@ -1221,6 +1311,0 @@\n-  \/\/ If the archived class is from a module that has been patched at runtime,\n-  \/\/ the class cannot be loaded from the archive.\n-  if (mod_entry != NULL && mod_entry->is_patched()) {\n-    return false;\n-  }\n-\n@@ -1266,8 +1350,4 @@\n-InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,\n-                                                   Handle class_loader,\n-                                                   Handle protection_domain,\n-                                                   const ClassFileStream *cfs,\n-                                                   TRAPS) {\n-  assert(ik != NULL, \"sanity\");\n-  assert(!ik->is_unshareable_info_restored(), \"shared class can be loaded only once\");\n-  Symbol* class_name = ik->name();\n+bool SystemDictionary::check_shared_class_super_type(InstanceKlass* child, InstanceKlass* super_type,\n+                                                     Handle class_loader,  Handle protection_domain,\n+                                                     bool is_superclass, TRAPS) {\n+  assert(super_type->is_shared(), \"must be\");\n@@ -1275,4 +1355,8 @@\n-  bool visible = is_shared_class_visible(\n-                          class_name, ik, class_loader, CHECK_NULL);\n-  if (!visible) {\n-    return NULL;\n+  Klass *found = resolve_super_or_fail(child->name(), super_type->name(),\n+                                       class_loader, protection_domain, is_superclass, CHECK_0);\n+  if (found == super_type) {\n+    return true;\n+  } else {\n+    \/\/ The dynamically resolved super type is not the same as the one we used during dump time,\n+    \/\/ so we cannot use the child class.\n+    return false;\n@@ -1280,0 +1364,1 @@\n+}\n@@ -1281,1 +1366,3 @@\n-  \/\/ Resolve the superclass and interfaces. They must be the same\n+bool SystemDictionary::check_shared_class_super_types(InstanceKlass* ik, Handle class_loader,\n+                                                      Handle protection_domain, TRAPS) {\n+  \/\/ Check the superclass and interfaces. They must be the same\n@@ -1288,11 +1375,4 @@\n-  if (ik->super() != NULL) {\n-    Symbol*  cn = ik->super()->name();\n-    Klass *s = resolve_super_or_fail(class_name, cn,\n-                                     class_loader, protection_domain, true, CHECK_NULL);\n-    if (s != ik->super()) {\n-      \/\/ The dynamically resolved super class is not the same as the one we used during dump time,\n-      \/\/ so we cannot use ik.\n-      return NULL;\n-    } else {\n-      assert(s->is_shared(), \"must be\");\n-    }\n+  if (ik->super() != NULL &&\n+      !check_shared_class_super_type(ik, InstanceKlass::cast(ik->super()),\n+                                     class_loader, protection_domain, true, THREAD)) {\n+    return false;\n@@ -1304,9 +1384,2 @@\n-    InstanceKlass* k = interfaces->at(index);\n-    Symbol* name  = k->name();\n-    Klass* i = resolve_super_or_fail(class_name, name, class_loader, protection_domain, false, CHECK_NULL);\n-    if (k != i) {\n-      \/\/ The dynamically resolved interface class is not the same as the one we used during dump time,\n-      \/\/ so we cannot use ik.\n-      return NULL;\n-    } else {\n-      assert(i->is_shared(), \"must be\");\n+    if (!check_shared_class_super_type(ik, interfaces->at(index), class_loader, protection_domain, false, THREAD)) {\n+      return false;\n@@ -1316,1 +1389,59 @@\n-  InstanceKlass* new_ik = KlassFactory::check_shared_class_file_load_hook(\n+  return true;\n+}\n+\n+InstanceKlass* SystemDictionary::load_shared_lambda_proxy_class(InstanceKlass* ik,\n+                                                                Handle class_loader,\n+                                                                Handle protection_domain,\n+                                                                PackageEntry* pkg_entry,\n+                                                                TRAPS) {\n+  InstanceKlass* shared_nest_host = SystemDictionaryShared::get_shared_nest_host(ik);\n+  assert(shared_nest_host->is_shared(), \"nest host must be in CDS archive\");\n+  Symbol* cn = shared_nest_host->name();\n+  Klass *s = resolve_or_fail(cn, class_loader, protection_domain, true, CHECK_NULL);\n+  if (s != shared_nest_host) {\n+    \/\/ The dynamically resolved nest_host is not the same as the one we used during dump time,\n+    \/\/ so we cannot use ik.\n+    return NULL;\n+  } else {\n+    assert(s->is_shared(), \"must be\");\n+  }\n+\n+  \/\/ The lambda proxy class and its nest host have the same class loader and class loader data,\n+  \/\/ as verified in SystemDictionaryShared::add_lambda_proxy_class()\n+  assert(shared_nest_host->class_loader() == class_loader(), \"mismatched class loader\");\n+  assert(shared_nest_host->class_loader_data() == ClassLoaderData::class_loader_data(class_loader()), \"mismatched class loader data\");\n+  ik->set_nest_host(shared_nest_host, THREAD);\n+\n+  InstanceKlass* loaded_ik = load_shared_class(ik, class_loader, protection_domain, NULL, pkg_entry, CHECK_NULL);\n+\n+  assert(shared_nest_host->is_same_class_package(ik),\n+         \"lambda proxy class and its nest host must be in the same package\");\n+\n+  return loaded_ik;\n+}\n+\n+InstanceKlass* SystemDictionary::load_shared_class(InstanceKlass* ik,\n+                                                   Handle class_loader,\n+                                                   Handle protection_domain,\n+                                                   const ClassFileStream *cfs,\n+                                                   PackageEntry* pkg_entry,\n+                                                   TRAPS) {\n+  assert(ik != NULL, \"sanity\");\n+  assert(!ik->is_unshareable_info_restored(), \"shared class can be loaded only once\");\n+  Symbol* class_name = ik->name();\n+\n+  bool visible = is_shared_class_visible(\n+                          class_name, ik, pkg_entry, class_loader, CHECK_NULL);\n+  if (!visible) {\n+    return NULL;\n+  }\n+\n+  if (!check_shared_class_super_types(ik, class_loader, protection_domain, THREAD)) {\n+    return NULL;\n+  }\n+\n+  InstanceKlass* new_ik = NULL;\n+  \/\/ CFLH check is skipped for VM hidden or anonymous classes (see KlassFactory::create_from_stream).\n+  \/\/ It will be skipped for shared VM hidden lambda proxy classes.\n+  if (!SystemDictionaryShared::is_hidden_lambda_proxy(ik)) {\n+    new_ik = KlassFactory::check_shared_class_file_load_hook(\n@@ -1318,0 +1449,1 @@\n+  }\n@@ -1343,1 +1475,1 @@\n-    ik->restore_unshareable_info(loader_data, protection_domain, CHECK_NULL);\n+    ik->restore_unshareable_info(loader_data, protection_domain, pkg_entry, CHECK_NULL);\n@@ -1346,0 +1478,5 @@\n+  load_shared_class_misc(ik, loader_data, CHECK_NULL);\n+  return ik;\n+}\n+\n+void SystemDictionary::load_shared_class_misc(InstanceKlass* ik, ClassLoaderData* loader_data, TRAPS) {\n@@ -1350,1 +1487,1 @@\n-  if (class_loader.is_null()) {\n+  if (loader_data->is_the_null_class_loader_data()) {\n@@ -1352,2 +1489,1 @@\n-    ResourceMark rm(THREAD);\n-    ClassLoader::add_package(ik->name()->as_C_string(), path_index, THREAD);\n+    ik->set_classpath_index(path_index, THREAD);\n@@ -1382,0 +1518,1 @@\n+}\n@@ -1383,1 +1520,29 @@\n-  return ik;\n+void SystemDictionary::quick_resolve(InstanceKlass* klass, ClassLoaderData* loader_data, Handle domain, TRAPS) {\n+  assert(!Universe::is_fully_initialized(), \"We can make short cuts only during VM initialization\");\n+  assert(klass->is_shared(), \"Must be shared class\");\n+  if (klass->class_loader_data() != NULL) {\n+    return;\n+  }\n+\n+  \/\/ add super and interfaces first\n+  Klass* super = klass->super();\n+  if (super != NULL && super->class_loader_data() == NULL) {\n+    assert(super->is_instance_klass(), \"Super should be instance klass\");\n+    quick_resolve(InstanceKlass::cast(super), loader_data, domain, CHECK);\n+  }\n+\n+  Array<InstanceKlass*>* ifs = klass->local_interfaces();\n+  for (int i = 0; i < ifs->length(); i++) {\n+    InstanceKlass* ik = ifs->at(i);\n+    if (ik->class_loader_data()  == NULL) {\n+      quick_resolve(ik, loader_data, domain, CHECK);\n+    }\n+  }\n+\n+  klass->restore_unshareable_info(loader_data, domain, NULL, THREAD);\n+  load_shared_class_misc(klass, loader_data, CHECK);\n+  Dictionary* dictionary = loader_data->dictionary();\n+  unsigned int hash = dictionary->compute_hash(klass->name());\n+  dictionary->add_klass(hash, klass->name(), klass);\n+  add_to_hierarchy(klass, CHECK);\n+  assert(klass->is_loaded(), \"Must be in at least loaded state\");\n@@ -1396,1 +1561,1 @@\n-    TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK_NULL);\n+    TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n@@ -1454,1 +1619,1 @@\n-    {\n+\n@@ -1456,0 +1621,2 @@\n+    if (UseSharedSpaces)\n+    {\n@@ -1457,2 +1624,1 @@\n-      k = load_shared_boot_class(class_name, THREAD);\n-#endif\n+      k = load_shared_boot_class(class_name, pkg_entry, THREAD);\n@@ -1460,0 +1626,1 @@\n+#endif\n@@ -1718,1 +1885,1 @@\n-    return Handle(THREAD, _system_loader_lock_obj);\n+    return Handle(THREAD, _system_loader_lock_obj.resolve());\n@@ -1739,1 +1906,1 @@\n-    if (loader_lock() == _system_loader_lock_obj) {\n+    if (loader_lock() == _system_loader_lock_obj.resolve()) {\n@@ -1795,1 +1962,3 @@\n-  assert_locked_or_safepoint(Compile_lock);\n+  if (Universe::is_fully_initialized()) {\n+    assert_locked_or_safepoint(Compile_lock);\n+  }\n@@ -1808,1 +1977,3 @@\n-  CodeCache::flush_dependents_on(k);\n+  if (Universe::is_fully_initialized()) {\n+    CodeCache::flush_dependents_on(k);\n+  }\n@@ -1852,14 +2023,0 @@\n-void SystemDictionary::oops_do(OopClosure* f, bool include_handles) {\n-  f->do_oop(&_java_system_loader);\n-  f->do_oop(&_java_platform_loader);\n-  f->do_oop(&_system_loader_lock_obj);\n-  CDS_ONLY(SystemDictionaryShared::oops_do(f);)\n-\n-  \/\/ Visit extra methods\n-  invoke_method_table()->oops_do(f);\n-\n-  if (include_handles) {\n-    OopStorageSet::vm_global()->oops_do(f);\n-  }\n-}\n-\n@@ -1893,1 +2050,3 @@\n-  _system_loader_lock_obj = oopFactory::new_intArray(0, CHECK);\n+  oop lock_obj = oopFactory::new_intArray(0, CHECK);\n+  _system_loader_lock_obj = OopHandle::create(lock_obj);\n+\n@@ -1927,2 +2086,13 @@\n-  if ((*klassp) == NULL) {\n-    Klass* k = resolve_or_fail(symbol, true, CHECK_0);\n+#if INCLUDE_CDS\n+  if (UseSharedSpaces && !JvmtiExport::should_post_class_prepare()) {\n+    InstanceKlass* k = *klassp;\n+    assert(k->is_shared_boot_class(), \"must be\");\n+\n+    ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n+    quick_resolve(k, loader_data, Handle(), CHECK_false);\n+    return true;\n+  }\n+#endif \/\/ INCLUDE_CDS\n+\n+  if (!is_wk_klass_loaded(*klassp)) {\n+    Klass* k = resolve_or_fail(symbol, true, CHECK_false);\n@@ -1946,1 +2116,1 @@\n-  assert(WK_KLASS(Object_klass) == NULL, \"well-known classes should only be initialized once\");\n+  assert(!Object_klass_loaded(), \"well-known classes should only be initialized once\");\n@@ -1994,4 +2164,0 @@\n-  \/\/ These calls iterate over the objects currently in the perm gen\n-  \/\/ so calling them at this point is matters (not before when there\n-  \/\/ are fewer objects and not later after there are more objects\n-  \/\/ in the perm gen.\n@@ -2004,0 +2170,7 @@\n+  \/\/ The offsets for jlr.Reference must be computed before\n+  \/\/ InstanceRefKlass::update_nonstatic_oop_maps is called. That function uses\n+  \/\/ the offsets to remove the referent and discovered fields from the oop maps,\n+  \/\/ as they are treated in a special way by the GC. Removing these oops from the\n+  \/\/ oop maps must be done before the usual subclasses of jlr.Reference are loaded.\n+  java_lang_ref_Reference::compute_offsets();\n+\n@@ -2035,2 +2208,2 @@\n-    assert(JvmtiExport::is_early_phase(),\n-           \"All well known classes must be resolved in JVMTI early phase\");\n+    JVMTI_ONLY(assert(JvmtiExport::is_early_phase(),\n+                      \"All well known classes must be resolved in JVMTI early phase\"));\n@@ -2203,1 +2376,1 @@\n-\n+                                             Klass* klass_being_linked,\n@@ -2242,0 +2415,8 @@\n+#if INCLUDE_CDS\n+    if (Arguments::is_dumping_archive() && klass_being_linked != NULL &&\n+        !klass_being_linked->is_shared()) {\n+         SystemDictionaryShared::record_linking_constraint(constraint_name,\n+                                     InstanceKlass::cast(klass_being_linked),\n+                                     class_loader1, class_loader2, THREAD);\n+    }\n+#endif \/\/ INCLUDE_CDS\n@@ -2283,0 +2464,36 @@\n+\/\/ Add an entry to resolution error table to record an error in resolving or\n+\/\/ validating a nest host. This is used to construct informative error\n+\/\/ messages when IllegalAccessError's occur. If an entry already exists it will\n+\/\/ be updated with the nest host error message.\n+void SystemDictionary::add_nest_host_error(const constantPoolHandle& pool,\n+                                           int which,\n+                                           const char* message) {\n+  unsigned int hash = resolution_errors()->compute_hash(pool, which);\n+  int index = resolution_errors()->hash_to_index(hash);\n+  {\n+    MutexLocker ml(Thread::current(), SystemDictionary_lock);\n+    ResolutionErrorEntry* entry = resolution_errors()->find_entry(index, hash, pool, which);\n+    if (entry != NULL) {\n+      assert(entry->nest_host_error() == NULL, \"Nest host error message already set!\");\n+      entry->set_nest_host_error(message);\n+    } else {\n+      resolution_errors()->add_entry(index, hash, pool, which, message);\n+    }\n+  }\n+}\n+\n+\/\/ Lookup any nest host error\n+const char* SystemDictionary::find_nest_host_error(const constantPoolHandle& pool, int which) {\n+  unsigned int hash = resolution_errors()->compute_hash(pool, which);\n+  int index = resolution_errors()->hash_to_index(hash);\n+  {\n+    MutexLocker ml(Thread::current(), SystemDictionary_lock);\n+    ResolutionErrorEntry* entry = resolution_errors()->find_entry(index, hash, pool, which);\n+    if (entry != NULL) {\n+      return entry->nest_host_error();\n+    } else {\n+      return NULL;\n+    }\n+  }\n+}\n+\n@@ -2327,1 +2544,1 @@\n-\/\/ SystemDictionary::check_signature_loaders(sig, l1, l2)\n+\/\/ SystemDictionary::check_signature_loaders(sig, klass_being_linked, l1, l2)\n@@ -2335,0 +2552,1 @@\n+                                               Klass* klass_being_linked,\n@@ -2348,1 +2566,1 @@\n-      if (!add_loader_constraint(sig, loader1, loader2, THREAD)) {\n+      if (!add_loader_constraint(sig, klass_being_linked, loader1, loader2, THREAD)) {\n@@ -2356,1 +2574,0 @@\n-\n@@ -2412,8 +2629,8 @@\n-      if (TraceMethodHandles) {\n-    #ifndef PRODUCT\n-        ttyLocker ttyl;\n-        tty->print(\"Linked method=\" INTPTR_FORMAT \": \", p2i(m));\n-        m->print();\n-        if (appendix != NULL) { tty->print(\"appendix = \"); appendix->print(); }\n-        tty->cr();\n-    #endif \/\/PRODUCT\n+      LogTarget(Info, methodhandles) lt;\n+      if (lt.develop_is_enabled()) {\n+        ResourceMark rm(THREAD);\n+        LogStream ls(lt);\n+        ls.print(\"Linked method=\" INTPTR_FORMAT \": \", p2i(m));\n+        m->print_on(&ls);\n+        if (appendix != NULL) { ls.print(\"appendix = \"); appendix->print_on(&ls); }\n+        ls.cr();\n@@ -2421,0 +2638,1 @@\n+\n@@ -2492,2 +2710,2 @@\n-\/\/ Find or construct the Java mirror (java.lang.Class instance) for a\n-\/\/ for the given field type signature, as interpreted relative to the\n+\/\/ Find or construct the Java mirror (java.lang.Class instance) for\n+\/\/ the given field type signature, as interpreted relative to the\n@@ -2503,2 +2721,0 @@\n-  Handle empty;\n-\n@@ -2508,2 +2724,0 @@\n-  SignatureStream ss(signature, false);\n-\n@@ -2513,25 +2727,10 @@\n-  if (ss.is_primitive() || (ss.type() == T_VOID)) {\n-\n-    \/\/ It's a primitive.  (Void has a primitive mirror too.)\n-    return Handle(THREAD, java_lang_Class::primitive_mirror(ss.type()));\n-\n-  } else if (ss.is_reference()) {\n-\n-    \/\/ It's a reference type.\n-    if (accessing_klass != NULL) {\n-      class_loader      = Handle(THREAD, accessing_klass->class_loader());\n-      protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n-    }\n-    Klass* constant_type_klass;\n-    if (failure_mode == SignatureStream::ReturnNull) {\n-      constant_type_klass = resolve_or_null(signature, class_loader, protection_domain,\n-                                            CHECK_(empty));\n-    } else {\n-      bool throw_error = (failure_mode == SignatureStream::NCDFError);\n-      constant_type_klass = resolve_or_fail(signature, class_loader, protection_domain,\n-                                            throw_error, CHECK_(empty));\n-    }\n-    if (constant_type_klass == NULL) {\n-      return Handle();  \/\/ report failure this way\n-    }\n-    Handle mirror(THREAD, constant_type_klass->java_mirror());\n+  if (accessing_klass != NULL) {\n+    class_loader      = Handle(THREAD, accessing_klass->class_loader());\n+    protection_domain = Handle(THREAD, accessing_klass->protection_domain());\n+  }\n+  ResolvingSignatureStream ss(signature, class_loader, protection_domain, false);\n+  oop mirror_oop = ss.as_java_mirror(failure_mode, CHECK_NH);\n+  if (mirror_oop == NULL) {\n+    return Handle();  \/\/ report failure this way\n+  }\n+  Handle mirror(THREAD, mirror_oop);\n@@ -2539,0 +2738,1 @@\n+  if (accessing_klass != NULL) {\n@@ -2540,5 +2740,3 @@\n-    if (accessing_klass != NULL) {\n-      Klass* sel_klass = constant_type_klass;\n-      bool fold_type_to_class = true;\n-      LinkResolver::check_klass_accessability(accessing_klass, sel_klass,\n-                                              fold_type_to_class, CHECK_(empty));\n+    Klass* sel_klass = java_lang_Class::as_Klass(mirror());\n+    if (sel_klass != NULL) {\n+      LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_NH);\n@@ -2546,7 +2744,1 @@\n-\n-    return mirror;\n-\n-\n-  \/\/ Fall through to an error.\n-  assert(false, \"unsupported mirror syntax\");\n-  THROW_MSG_(vmSymbols::java_lang_InternalError(), \"unsupported mirror syntax\", empty);\n+  return mirror;\n@@ -2615,3 +2807,1 @@\n-      bool fold_type_to_class = true;\n-      LinkResolver::check_klass_accessability(accessing_klass, sel_klass,\n-                                              fold_type_to_class, CHECK_(empty));\n+      LinkResolver::check_klass_accessibility(accessing_klass, sel_klass, CHECK_(empty));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":386,"deletions":196,"binary":false,"changes":582,"status":"modified"},{"patch":"@@ -68,1 +68,0 @@\n-  template(java_lang_ClassLoader_NativeLibrary,       \"java\/lang\/ClassLoader\\x024NativeLibrary\")  \\\n@@ -133,0 +132,1 @@\n+  template(jdk_internal_loader_NativeLibraries,       \"jdk\/internal\/loader\/NativeLibraries\")      \\\n@@ -176,0 +176,1 @@\n+  template(tag_permitted_subclasses,                  \"PermittedSubclasses\")                      \\\n@@ -269,0 +270,1 @@\n+  template(trusted_final_name,                        \"trustedFinal\")                             \\\n@@ -440,2 +442,0 @@\n-  template(definePackage_name,                        \"definePackage\")                            \\\n-  template(definePackage_signature,                   \"(Ljava\/lang\/String;Ljava\/lang\/Module;)Ljava\/lang\/Package;\") \\\n@@ -558,0 +558,1 @@\n+  template(referencequeue_signature,                  \"Ljava\/lang\/ref\/ReferenceQueue;\")                           \\\n@@ -888,0 +889,2 @@\n+  do_intrinsic(_isHidden,                 java_lang_Class,        isHidden_name, void_boolean_signature,         F_RN)  \\\n+   do_name(     isHidden_name,                                   \"isHidden\")                                            \\\n@@ -1539,1 +1542,1 @@\n-    log2_SID_LIMIT = 10         \/\/ checked by an assert at start-up\n+    log2_SID_LIMIT = 11         \/\/ checked by an assert at start-up\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -436,7 +436,0 @@\n-  \/\/ Print all GC threads (other than the VM thread)\n-  \/\/ used by this heap.\n-  virtual void print_gc_threads_on(outputStream* st) const = 0;\n-  \/\/ The default behavior is to call print_gc_threads_on() on tty.\n-  void print_gc_threads() {\n-    print_gc_threads_on(tty);\n-  }\n@@ -466,18 +459,3 @@\n-  \/\/ Return true if concurrent phase control (via\n-  \/\/ request_concurrent_phase_control) is supported by this collector.\n-  \/\/ The default implementation returns false.\n-  virtual bool supports_concurrent_phase_control() const;\n-\n-  \/\/ Request the collector enter the indicated concurrent phase, and\n-  \/\/ wait until it does so.  Supports WhiteBox testing.  Only one\n-  \/\/ request may be active at a time.  Phases are designated by name;\n-  \/\/ the set of names and their meaning is GC-specific.  Once the\n-  \/\/ requested phase has been reached, the collector will attempt to\n-  \/\/ avoid transitioning to a new phase until a new request is made.\n-  \/\/ [Note: A collector might not be able to remain in a given phase.\n-  \/\/ For example, a full collection might cancel an in-progress\n-  \/\/ concurrent collection.]\n-  \/\/\n-  \/\/ Returns true when the phase is reached.  Returns false for an\n-  \/\/ unknown phase.  The default implementation returns false.\n-  virtual bool request_concurrent_phase(const char* phase);\n+  \/\/ Return true if concurrent gc control via WhiteBox is supported by\n+  \/\/ this collector.  The default implementation returns false.\n+  virtual bool supports_concurrent_gc_breakpoints() const;\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":26,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Red Hat, Inc. All rights reserved.\n+ * Copyright (c) 2017, 2020, Red Hat, Inc. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"jfr\/jfrEvents.hpp\"\n@@ -33,2 +34,0 @@\n-class ShenandoahWorkerTimings;\n-class ShenandoahTerminationTimings;\n@@ -37,302 +36,21 @@\n-#define SHENANDOAH_GC_PHASE_DO(f)                                                       \\\n-  f(total_pause_gross,                              \"Total Pauses (G)\")                 \\\n-  f(total_pause,                                    \"Total Pauses (N)\")                 \\\n-  f(init_mark_gross,                                \"Pause Init Mark (G)\")              \\\n-  f(init_mark,                                      \"Pause Init Mark (N)\")              \\\n-  f(make_parsable,                                  \"  Make Parsable\")                  \\\n-  f(clear_liveness,                                 \"  Clear Liveness\")                 \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(scan_roots,                                     \"  Scan Roots\")                     \\\n-  f(scan_thread_roots,                              \"    S: Thread Roots\")              \\\n-  f(scan_code_roots,                                \"    S: Code Cache Roots\")          \\\n-  f(scan_universe_roots,                            \"    S: Universe Roots\")            \\\n-  f(scan_jni_roots,                                 \"    S: JNI Roots\")                 \\\n-  f(scan_jvmti_weak_roots,                          \"    S: JVMTI Weak Roots\")          \\\n-  f(scan_jfr_weak_roots,                            \"    S: JFR Weak Roots\")            \\\n-  f(scan_jni_weak_roots,                            \"    S: JNI Weak Roots\")            \\\n-  f(scan_stringtable_roots,                         \"    S: String Table Roots\")        \\\n-  f(scan_resolved_method_table_roots,               \"    S: Resolved Table Roots\")      \\\n-  f(scan_vm_global_roots,                           \"    S: VM Global Roots\")           \\\n-  f(scan_vm_weak_roots,                             \"    S: VM Weak Roots\")             \\\n-  f(scan_synchronizer_roots,                        \"    S: Synchronizer Roots\")        \\\n-  f(scan_management_roots,                          \"    S: Management Roots\")          \\\n-  f(scan_system_dictionary_roots,                   \"    S: System Dict Roots\")         \\\n-  f(scan_cldg_roots,                                \"    S: CLDG Roots\")                \\\n-  f(scan_jvmti_roots,                               \"    S: JVMTI Roots\")               \\\n-  f(scan_string_dedup_table_roots,                  \"    S: Dedup Table Roots\")         \\\n-  f(scan_string_dedup_queue_roots,                  \"    S: Dedup Queue Roots\")         \\\n-  f(scan_finish_queues,                             \"    S: Finish Queues\" )            \\\n-                                                                                        \\\n-  f(resize_tlabs,                                   \"  Resize TLABs\")                   \\\n-                                                                                        \\\n-  f(final_mark_gross,                               \"Pause Final Mark (G)\")             \\\n-  f(final_mark,                                     \"Pause Final Mark (N)\")             \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(update_roots,                                   \"  Update Roots\")                   \\\n-  f(update_thread_roots,                            \"    U: Thread Roots\")              \\\n-  f(update_code_roots,                              \"    U: Code Cache Roots\")          \\\n-  f(update_universe_roots,                          \"    U: Universe Roots\")            \\\n-  f(update_jni_roots,                               \"    U: JNI Roots\")                 \\\n-  f(update_jvmti_weak_roots,                        \"    U: JVMTI Weak Roots\")          \\\n-  f(update_jfr_weak_roots,                          \"    U: JFR Weak Roots\")            \\\n-  f(update_jni_weak_roots,                          \"    U: JNI Weak Roots\")            \\\n-  f(update_stringtable_roots,                       \"    U: String Table Roots\")        \\\n-  f(update_resolved_method_table_roots,             \"    U: Resolved Table Roots\")      \\\n-  f(update_vm_global_roots,                         \"    U: VM Global Roots\")           \\\n-  f(update_vm_weak_roots,                           \"    U: VM Weak Roots\")             \\\n-  f(update_synchronizer_roots,                      \"    U: Synchronizer Roots\")        \\\n-  f(update_management_roots,                        \"    U: Management Roots\")          \\\n-  f(update_system_dictionary_roots,                 \"    U: System Dict Roots\")         \\\n-  f(update_cldg_roots,                              \"    U: CLDG Roots\")                \\\n-  f(update_jvmti_roots,                             \"    U: JVMTI Roots\")               \\\n-  f(update_string_dedup_table_roots,                \"    U: Dedup Table Roots\")         \\\n-  f(update_string_dedup_queue_roots,                \"    U: Dedup Queue Roots\")         \\\n-  f(update_finish_queues,                           \"    U: Finish Queues\")             \\\n-                                                                                        \\\n-  f(finish_queues,                                  \"  Finish Queues\")                  \\\n-  f(termination,                                    \"    Termination\")                  \\\n-  f(weakrefs,                                       \"  Weak References\")                \\\n-  f(weakrefs_process,                               \"    Process\")                      \\\n-  f(weakrefs_termination,                           \"      Termination\")                \\\n-  f(purge,                                          \"  System Purge\")                   \\\n-  f(purge_class_unload,                             \"    Unload Classes\")               \\\n-  f(purge_par,                                      \"    Parallel Cleanup\")             \\\n-  f(purge_cldg,                                     \"    CLDG\")                         \\\n-  f(complete_liveness,                              \"  Complete Liveness\")              \\\n-  f(retire_tlabs,                                   \"  Retire TLABs\")                   \\\n-  f(sync_pinned,                                    \"  Sync Pinned\")                    \\\n-  f(trash_cset,                                     \"  Trash CSet\")                     \\\n-  f(prepare_evac,                                   \"  Prepare Evacuation\")             \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(init_evac,                                      \"  Initial Evacuation\")             \\\n-  f(evac_thread_roots,                              \"    E: Thread Roots\")              \\\n-  f(evac_code_roots,                                \"    E: Code Cache Roots\")          \\\n-  f(evac_universe_roots,                            \"    E: Universe Roots\")            \\\n-  f(evac_jni_roots,                                 \"    E: JNI Roots\")                 \\\n-  f(evac_jvmti_weak_roots,                          \"    E: JVMTI Weak Roots\")          \\\n-  f(evac_jfr_weak_roots,                            \"    E: JFR Weak Roots\")            \\\n-  f(evac_jni_weak_roots,                            \"    E: JNI Weak Roots\")            \\\n-  f(evac_stringtable_roots,                         \"    E: String Table Roots\")        \\\n-  f(evac_resolved_method_table_roots,               \"    E: Resolved Table Roots\")      \\\n-  f(evac_vm_global_roots,                           \"    E: VM Global Roots\")           \\\n-  f(evac_vm_weak_roots,                             \"    E: VM Weak Roots\")             \\\n-  f(evac_synchronizer_roots,                        \"    E: Synchronizer Roots\")        \\\n-  f(evac_management_roots,                          \"    E: Management Roots\")          \\\n-  f(evac_system_dictionary_roots,                   \"    E: System Dict Roots\")         \\\n-  f(evac_cldg_roots,                                \"    E: CLDG Roots\")                \\\n-  f(evac_jvmti_roots,                               \"    E: JVMTI Roots\")               \\\n-  f(evac_string_dedup_table_roots,                  \"    E: String Dedup Table Roots\")  \\\n-  f(evac_string_dedup_queue_roots,                  \"    E: String Dedup Queue Roots\")  \\\n-  f(evac_finish_queues,                             \"    E: Finish Queues\")             \\\n-                                                                                        \\\n-  f(final_evac_gross,                               \"Pause Final Evac (G)\")             \\\n-  f(final_evac,                                     \"Pause Final Evac (N)\")             \\\n-  f(final_evac_retire_gclabs,                       \"  Retire GCLABs\")                  \\\n-                                                                                        \\\n-  f(init_update_refs_gross,                         \"Pause Init  Update Refs (G)\")      \\\n-  f(init_update_refs,                               \"Pause Init  Update Refs (N)\")      \\\n-  f(init_update_refs_retire_gclabs,                 \"  Retire GCLABs\")                  \\\n-  f(init_update_refs_prepare,                       \"  Prepare\")                        \\\n-                                                                                        \\\n-  f(final_update_refs_gross,                         \"Pause Final Update Refs (G)\")     \\\n-  f(final_update_refs,                               \"Pause Final Update Refs (N)\")     \\\n-  f(final_update_refs_finish_work,                   \"  Finish Work\")                   \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(final_update_refs_roots,                         \"  Update Roots\")                  \\\n-  f(final_update_refs_thread_roots,                  \"    UR: Thread Roots\")            \\\n-  f(final_update_refs_code_roots,                    \"    UR: Code Cache Roots\")        \\\n-  f(final_update_refs_universe_roots,                \"    UR: Universe Roots\")          \\\n-  f(final_update_refs_jni_roots,                     \"    UR: JNI Roots\")               \\\n-  f(final_update_jvmti_weak_roots,                   \"    UR: JVMTI Weak Roots\")        \\\n-  f(final_update_jfr_weak_roots,                     \"    UR: JFR Weak Roots\")          \\\n-  f(final_update_jni_weak_roots,                     \"    UR: JNI Weak Roots\")          \\\n-  f(final_update_stringtable_roots,                  \"    UR: String Table Roots\")      \\\n-  f(final_update_resolved_method_table_roots,        \"    UR: Resolved Table Roots\")    \\\n-  f(final_update_vm_global_roots,                    \"    UR: VM Global Roots\")         \\\n-  f(final_update_vm_weak_roots,                      \"    UR: VM Weak Roots\")           \\\n-  f(final_update_refs_synchronizer_roots,            \"    UR: Synchronizer Roots\")      \\\n-  f(final_update_refs_management_roots,              \"    UR: Management Roots\")        \\\n-  f(final_update_refs_system_dict_roots,             \"    UR: System Dict Roots\")       \\\n-  f(final_update_refs_cldg_roots,                    \"    UR: CLDG Roots\")              \\\n-  f(final_update_refs_jvmti_roots,                   \"    UR: JVMTI Roots\")             \\\n-  f(final_update_refs_string_dedup_table_roots,      \"    UR: Dedup Table Roots\")       \\\n-  f(final_update_refs_string_dedup_queue_roots,      \"    UR: Dedup Queue Roots\")       \\\n-  f(final_update_refs_finish_queues,                 \"    UR: Finish Queues\")           \\\n-                                                                                        \\\n-  f(final_update_refs_sync_pinned,                   \"  Sync Pinned\")                   \\\n-  f(final_update_refs_trash_cset,                    \"  Trash CSet\")                    \\\n-                                                                                        \\\n-  f(degen_gc_gross,                                  \"Pause Degenerated GC (G)\")        \\\n-  f(degen_gc,                                        \"Pause Degenerated GC (N)\")        \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(degen_gc_update_roots,                           \"  Degen Update Roots\")            \\\n-  f(degen_gc_update_thread_roots,                    \"    DU: Thread Roots\")            \\\n-  f(degen_gc_update_code_roots,                      \"    DU: Code Cache Roots\")        \\\n-  f(degen_gc_update_universe_roots,                  \"    DU: Universe Roots\")          \\\n-  f(degen_gc_update_jni_roots,                       \"    DU: JNI Roots\")               \\\n-  f(degen_gc_update_jvmti_weak_roots,                \"    DU: JVMTI Weak Roots\")        \\\n-  f(degen_gc_update_jfr_weak_roots,                  \"    DU: JFR Weak Roots\")          \\\n-  f(degen_gc_update_jni_weak_roots,                  \"    DU: JNI Weak Roots\")          \\\n-  f(degen_gc_update_stringtable_roots,               \"    DU: String Table Roots\")      \\\n-  f(degen_gc_update_resolved_method_table_roots,     \"    DU: Resolved Table Roots\")    \\\n-  f(degen_gc_update_vm_global_roots,                 \"    DU: VM Global Roots\")         \\\n-  f(degen_gc_update_vm_weak_roots,                   \"    DU: VM Weak Roots\")           \\\n-  f(degen_gc_update_synchronizer_roots,              \"    DU: Synchronizer Roots\")      \\\n-  f(degen_gc_update_management_roots,                \"    DU: Management Roots\")        \\\n-  f(degen_gc_update_system_dict_roots,               \"    DU: System Dict Roots\")       \\\n-  f(degen_gc_update_cldg_roots,                      \"    DU: CLDG Roots\")              \\\n-  f(degen_gc_update_jvmti_roots,                     \"    DU: JVMTI Roots\")             \\\n-  f(degen_gc_update_string_dedup_table_roots,        \"    DU: Dedup Table Roots\")       \\\n-  f(degen_gc_update_string_dedup_queue_roots,        \"    DU: Dedup Queue Roots\")       \\\n-  f(degen_gc_update_finish_queues,                   \"    DU: Finish Queues\")           \\\n-                                                                                        \\\n-  f(init_traversal_gc_gross,                         \"Pause Init Traversal (G)\")        \\\n-  f(init_traversal_gc,                               \"Pause Init Traversal (N)\")        \\\n-  f(traversal_gc_prepare,                            \"  Prepare\")                       \\\n-  f(traversal_gc_make_parsable,                      \"    Make Parsable\")               \\\n-  f(traversal_gc_resize_tlabs,                       \"    Resize TLABs\")                \\\n-  f(traversal_gc_prepare_sync_pinned,                \"    Sync Pinned\")                 \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(init_traversal_gc_work,                          \"  Work\")                          \\\n-  f(init_traversal_gc_thread_roots,                  \"    TI: Thread Roots\")            \\\n-  f(init_traversal_gc_code_roots,                    \"    TI: Code Cache Roots\")        \\\n-  f(init_traversal_gc_universe_roots,                \"    TI: Universe Roots\")          \\\n-  f(init_traversal_gc_jni_roots,                     \"    TI: JNI Roots\")               \\\n-  f(init_traversal_gc_jvmti_weak_roots,              \"    TI: JVMTI Weak Roots\")        \\\n-  f(init_traversal_gc_jfr_weak_roots,                \"    TI: JFR Weak Roots\")          \\\n-  f(init_traversal_gc_jni_weak_roots,                \"    TI: JNI Weak Roots\")          \\\n-  f(init_traversal_gc_stringtable_roots,             \"    TI: String Table Roots\")      \\\n-  f(init_traversal_gc_resolved_method_table_roots,   \"    TI: Resolved Table Roots\")    \\\n-  f(init_traversal_gc_vm_global_roots,               \"    TI: VM Global Roots\")         \\\n-  f(init_traversal_gc_vm_weak_roots,                 \"    TI: VM Weak Roots\")           \\\n-  f(init_traversal_gc_synchronizer_roots,            \"    TI: Synchronizer Roots\")      \\\n-  f(init_traversal_gc_management_roots,              \"    TI: Management Roots\")        \\\n-  f(init_traversal_gc_system_dict_roots,             \"    TI: System Dict Roots\")       \\\n-  f(init_traversal_gc_cldg_roots,                    \"    TI: CLDG Roots\")              \\\n-  f(init_traversal_gc_jvmti_roots,                   \"    TI: JVMTI Roots\")             \\\n-  f(init_traversal_gc_string_dedup_table_roots,      \"    TI: Dedup Table Roots\")       \\\n-  f(init_traversal_gc_string_dedup_queue_roots,      \"    TI: Dedup Queue Roots\")       \\\n-  f(init_traversal_gc_finish_queues,                 \"    TI: Finish Queues\")           \\\n-                                                                                        \\\n-  f(final_traversal_gc_gross,                        \"Pause Final Traversal (G)\")       \\\n-  f(final_traversal_gc,                              \"Pause Final Traversal (N)\")       \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(final_traversal_gc_work,                         \"  Work\")                          \\\n-  f(final_traversal_gc_thread_roots,                 \"    TF: Thread Roots\")            \\\n-  f(final_traversal_gc_code_roots,                   \"    TF: Code Cache Roots\")        \\\n-  f(final_traversal_gc_universe_roots,               \"    TF: Universe Roots\")          \\\n-  f(final_traversal_gc_jni_roots,                    \"    TF: JNI Roots\")               \\\n-  f(final_traversal_gc_jvmti_weak_roots,             \"    TF: JVMTI Weak Roots\")        \\\n-  f(final_traversal_gc_jfr_weak_roots,               \"    TF: JFR Weak Roots\")          \\\n-  f(final_traversal_gc_jni_weak_roots,               \"    TF: JNI Weak Roots\")          \\\n-  f(final_traversal_gc_stringtable_roots,            \"    TF: String Table Roots\")      \\\n-  f(final_traversal_gc_resolved_method_table_roots,  \"    TF: Resolved Table Roots\")    \\\n-  f(final_traversal_gc_vm_global_roots,              \"    TF: VM Global Roots\")         \\\n-  f(final_traversal_gc_vm_weak_roots,                \"    TF: VM Weak Roots\")           \\\n-  f(final_traversal_gc_synchronizer_roots,           \"    TF: Synchronizer Roots\")      \\\n-  f(final_traversal_gc_management_roots,             \"    TF: Management Roots\")        \\\n-  f(final_traversal_gc_system_dict_roots,            \"    TF: System Dict Roots\")       \\\n-  f(final_traversal_gc_cldg_roots,                   \"    TF: CLDG Roots\")              \\\n-  f(final_traversal_gc_jvmti_roots,                  \"    TF: JVMTI Roots\")             \\\n-  f(final_traversal_gc_string_dedup_table_roots,     \"    TF: Dedup Table Roots\")       \\\n-  f(final_traversal_gc_string_dedup_queue_roots,     \"    TF: Dedup Queue Roots\")       \\\n-  f(final_traversal_gc_finish_queues,                \"    TF: Finish Queues\")           \\\n-  f(final_traversal_gc_termination,                  \"    TF:   Termination\")           \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(final_traversal_update_roots,                       \"  Update Roots\")               \\\n-  f(final_traversal_update_thread_roots,                \"    TU: Thread Roots\")         \\\n-  f(final_traversal_update_code_roots,                  \"    TU: Code Cache Roots\")     \\\n-  f(final_traversal_update_universe_roots,              \"    TU: Universe Roots\")       \\\n-  f(final_traversal_update_jni_roots,                   \"    TU: JNI Roots\")            \\\n-  f(final_traversal_update_jvmti_weak_roots,            \"    TU: JVMTI Weak Roots\")     \\\n-  f(final_traversal_update_jfr_weak_roots,              \"    TU: JFR Weak Roots\")       \\\n-  f(final_traversal_update_jni_weak_roots,              \"    TU: JNI Weak Roots\")       \\\n-  f(final_traversal_update_stringtable_roots,           \"    TU: String Table Roots\")   \\\n-  f(final_traversal_update_resolved_method_table_roots, \"    TU: Resolved Table Roots\") \\\n-  f(final_traversal_update_vm_global_roots,             \"    TU: VM Global Roots\")      \\\n-  f(final_traversal_update_vm_weak_roots,               \"    TU: VM Weak Roots\")        \\\n-  f(final_traversal_update_synchronizer_roots,          \"    TU: Synchronizer Roots\")   \\\n-  f(final_traversal_update_management_roots,            \"    TU: Management Roots\")     \\\n-  f(final_traversal_update_system_dict_roots,           \"    TU: System Dict Roots\")    \\\n-  f(final_traversal_update_cldg_roots,                  \"    TU: CLDG Roots\")           \\\n-  f(final_traversal_update_jvmti_roots,                 \"    TU: JVMTI Roots\")          \\\n-  f(final_traversal_update_string_dedup_table_roots,    \"    TU: Dedup Table Roots\")    \\\n-  f(final_traversal_update_string_dedup_queue_roots,    \"    TU: Dedup Queue Roots\")    \\\n-  f(final_traversal_update_finish_queues,               \"    TU: Finish Queues\")        \\\n-                                                                                        \\\n-  f(traversal_gc_sync_pinned,                        \"  Sync Pinned\")                   \\\n-  f(traversal_gc_cleanup,                            \"  Cleanup\")                       \\\n-                                                                                        \\\n-  f(full_gc_gross,                                   \"Pause Full GC (G)\")               \\\n-  f(full_gc,                                         \"Pause Full GC (N)\")               \\\n-  f(full_gc_heapdumps,                               \"  Heap Dumps\")                    \\\n-  f(full_gc_prepare,                                 \"  Prepare\")                       \\\n-                                                                                        \\\n-  \/* Per-thread timer block, should have \"roots\" counters in consistent order *\/        \\\n-  f(full_gc_roots,                                   \"  Roots\")                         \\\n-  f(full_gc_thread_roots,                            \"    F: Thread Roots\")             \\\n-  f(full_gc_code_roots,                              \"    F: Code Cache Roots\")         \\\n-  f(full_gc_universe_roots,                          \"    F: Universe Roots\")           \\\n-  f(full_gc_jni_roots,                               \"    F: JNI Roots\")                \\\n-  f(full_gc_jvmti_weak_roots,                        \"    F: JVMTI Weak Roots\")         \\\n-  f(full_gc_jfr_weak_roots,                          \"    F: JFR Weak Roots\")           \\\n-  f(full_gc_jni_weak_roots,                          \"    F: JNI Weak Roots\")           \\\n-  f(full_gc_stringtable_roots,                       \"    F: String Table Roots\")       \\\n-  f(full_gc_resolved_method_table_roots,             \"    F: Resolved Table Roots\")     \\\n-  f(full_gc_vm_global_roots,                         \"    F: VM Global Roots\")          \\\n-  f(full_gc_vm_weak_roots,                           \"    F: VM Weak Roots\")            \\\n-  f(full_gc_synchronizer_roots,                      \"    F: Synchronizer Roots\")       \\\n-  f(full_gc_management_roots,                        \"    F: Management Roots\")         \\\n-  f(full_gc_system_dictionary_roots,                 \"    F: System Dict Roots\")        \\\n-  f(full_gc_cldg_roots,                              \"    F: CLDG Roots\")               \\\n-  f(full_gc_jvmti_roots,                             \"    F: JVMTI Roots\")              \\\n-  f(full_gc_string_dedup_table_roots,                \"    F: Dedup Table Roots\")        \\\n-  f(full_gc_string_dedup_queue_roots,                \"    F: Dedup Queue Roots\")        \\\n-  f(full_gc_finish_queues,                           \"    F: Finish Queues\")            \\\n-                                                                                        \\\n-  f(full_gc_mark,                                    \"  Mark\")                          \\\n-  f(full_gc_mark_finish_queues,                      \"    Finish Queues\")               \\\n-  f(full_gc_mark_termination,                        \"      Termination\")               \\\n-  f(full_gc_weakrefs,                                \"    Weak References\")             \\\n-  f(full_gc_weakrefs_process,                        \"      Process\")                   \\\n-  f(full_gc_weakrefs_termination,                    \"        Termination\")             \\\n-  f(full_gc_purge,                                   \"    System Purge\")                \\\n-  f(full_gc_purge_class_unload,                      \"      Unload Classes\")            \\\n-  f(full_gc_purge_par,                               \"    Parallel Cleanup\")            \\\n-  f(full_gc_purge_cldg,                              \"    CLDG\")                        \\\n-  f(full_gc_calculate_addresses,                     \"  Calculate Addresses\")           \\\n-  f(full_gc_calculate_addresses_regular,             \"    Regular Objects\")             \\\n-  f(full_gc_calculate_addresses_humong,              \"    Humongous Objects\")           \\\n-  f(full_gc_adjust_pointers,                         \"  Adjust Pointers\")               \\\n-  f(full_gc_copy_objects,                            \"  Copy Objects\")                  \\\n-  f(full_gc_copy_objects_regular,                    \"    Regular Objects\")             \\\n-  f(full_gc_copy_objects_humong,                     \"    Humongous Objects\")           \\\n-  f(full_gc_copy_objects_reset_complete,             \"    Reset Complete Bitmap\")       \\\n-  f(full_gc_copy_objects_rebuild,                    \"    Rebuild Region Sets\")         \\\n-  f(full_gc_resize_tlabs,                            \"  Resize TLABs\")                  \\\n-                                                                                        \\\n-  \/* Longer concurrent phases at the end *\/                                             \\\n-  f(conc_reset,                                      \"Concurrent Reset\")                \\\n-  f(conc_mark,                                       \"Concurrent Marking\")              \\\n-  f(conc_termination,                                \"  Termination\")                   \\\n-  f(conc_preclean,                                   \"Concurrent Precleaning\")          \\\n-  f(conc_roots,                                      \"Concurrent Roots\")                \\\n-  f(conc_evac,                                       \"Concurrent Evacuation\")           \\\n-  f(conc_update_refs,                                \"Concurrent Update Refs\")          \\\n-  f(conc_cleanup,                                    \"Concurrent Cleanup\")              \\\n-  f(conc_traversal,                                  \"Concurrent Traversal\")            \\\n-  f(conc_traversal_termination,                      \"  Termination\")                   \\\n-                                                                                        \\\n-  f(conc_uncommit,                                   \"Concurrent Uncommit\")             \\\n-                                                                                        \\\n-  \/* Unclassified *\/                                                                    \\\n-  f(pause_other,                                     \"Pause Other\")                     \\\n-  f(conc_other,                                      \"Concurrent Other\")                \\\n+#define SHENANDOAH_PAR_PHASE_DO(CNT_PREFIX, DESC_PREFIX, f)                            \\\n+  f(CNT_PREFIX ## TotalWork,                DESC_PREFIX \"<total>\")                     \\\n+  f(CNT_PREFIX ## ThreadRoots,              DESC_PREFIX \"Thread Roots\")                \\\n+  f(CNT_PREFIX ## CodeCacheRoots,           DESC_PREFIX \"Code Cache Roots\")            \\\n+  f(CNT_PREFIX ## UniverseRoots,            DESC_PREFIX \"Universe Roots\")              \\\n+  f(CNT_PREFIX ## JNIRoots,                 DESC_PREFIX \"JNI Handles Roots\")           \\\n+  f(CNT_PREFIX ## JVMTIWeakRoots,           DESC_PREFIX \"JVMTI Weak Roots\")            \\\n+  f(CNT_PREFIX ## JFRWeakRoots,             DESC_PREFIX \"JFR Weak Roots\")              \\\n+  f(CNT_PREFIX ## TSANWeakRoots,            DESC_PREFIX \"TSAN Weak Roots\")             \\\n+  f(CNT_PREFIX ## JNIWeakRoots,             DESC_PREFIX \"JNI Weak Roots\")              \\\n+  f(CNT_PREFIX ## StringTableRoots,         DESC_PREFIX \"String Table Roots\")          \\\n+  f(CNT_PREFIX ## ResolvedMethodTableRoots, DESC_PREFIX \"Resolved Table Roots\")        \\\n+  f(CNT_PREFIX ## VMGlobalRoots,            DESC_PREFIX \"VM Global Roots\")             \\\n+  f(CNT_PREFIX ## VMWeakRoots,              DESC_PREFIX \"VM Weak Roots\")               \\\n+  f(CNT_PREFIX ## ObjectSynchronizerRoots,  DESC_PREFIX \"Synchronizer Roots\")          \\\n+  f(CNT_PREFIX ## ManagementRoots,          DESC_PREFIX \"Management Roots\")            \\\n+  f(CNT_PREFIX ## CLDGRoots,                DESC_PREFIX \"CLDG Roots\")                  \\\n+  f(CNT_PREFIX ## JVMTIRoots,               DESC_PREFIX \"JVMTI Roots\")                 \\\n+  f(CNT_PREFIX ## StringDedupTableRoots,    DESC_PREFIX \"Dedup Table Roots\")           \\\n+  f(CNT_PREFIX ## StringDedupQueueRoots,    DESC_PREFIX \"Dedup Queue Roots\")           \\\n+  f(CNT_PREFIX ## FinishQueues,             DESC_PREFIX \"Finish Queues\")               \\\n@@ -341,21 +59,118 @@\n-#define SHENANDOAH_GC_PAR_PHASE_DO(f)                           \\\n-  f(ThreadRoots,              \"Thread Roots (ms):\")              \\\n-  f(CodeCacheRoots,           \"CodeCache Roots (ms):\")           \\\n-  f(UniverseRoots,            \"Universe Roots (ms):\")            \\\n-  f(JNIRoots,                 \"JNI Handles Roots (ms):\")         \\\n-  f(JVMTIWeakRoots,           \"JVMTI Weak Roots (ms):\")          \\\n-  f(JFRWeakRoots,             \"JFR Weak Roots (ms):\")            \\\n-  f(TSANWeakRoots,            \"TSAN Weak Roots (ms):\")           \\\n-  f(JNIWeakRoots,             \"JNI Weak Roots (ms):\")            \\\n-  f(StringTableRoots,         \"StringTable Roots(ms):\")          \\\n-  f(ResolvedMethodTableRoots, \"Resolved Table Roots(ms):\")       \\\n-  f(VMGlobalRoots,            \"VM Global Roots(ms)\")             \\\n-  f(VMWeakRoots,              \"VM Weak Roots(ms)\")               \\\n-  f(ObjectSynchronizerRoots,  \"ObjectSynchronizer Roots (ms):\")  \\\n-  f(ManagementRoots,          \"Management Roots (ms):\")          \\\n-  f(SystemDictionaryRoots,    \"SystemDictionary Roots (ms):\")    \\\n-  f(CLDGRoots,                \"CLDG Roots (ms):\")                \\\n-  f(JVMTIRoots,               \"JVMTI Roots (ms):\")               \\\n-  f(StringDedupTableRoots,    \"String Dedup Table Roots (ms):\")  \\\n-  f(StringDedupQueueRoots,    \"String Dedup Queue Roots (ms):\")  \\\n-  f(FinishQueues,             \"Finish Queues (ms):\")             \\\n+#define SHENANDOAH_PHASE_DO(f)                                                         \\\n+  f(conc_reset,                                     \"Concurrent Reset\")                \\\n+                                                                                       \\\n+  f(init_mark_gross,                                \"Pause Init Mark (G)\")             \\\n+  f(init_mark,                                      \"Pause Init Mark (N)\")             \\\n+  f(make_parsable,                                  \"  Make Parsable\")                 \\\n+  f(init_update_region_states,                      \"  Update Region States\")          \\\n+  f(scan_roots,                                     \"  Scan Roots\")                    \\\n+  SHENANDOAH_PAR_PHASE_DO(scan_,                    \"    S: \", f)                      \\\n+  f(resize_tlabs,                                   \"  Resize TLABs\")                  \\\n+                                                                                       \\\n+  f(conc_mark,                                      \"Concurrent Marking\")              \\\n+  f(conc_mark_roots,                                \"  Roots \")                        \\\n+  SHENANDOAH_PAR_PHASE_DO(conc_mark_roots,          \"    CM: \", f)                     \\\n+                                                                                       \\\n+  f(conc_preclean,                                  \"Concurrent Precleaning\")          \\\n+                                                                                       \\\n+  f(final_mark_gross,                               \"Pause Final Mark (G)\")            \\\n+  f(final_mark,                                     \"Pause Final Mark (N)\")            \\\n+  f(update_roots,                                   \"  Update Roots\")                  \\\n+  SHENANDOAH_PAR_PHASE_DO(update_,                  \"    U: \", f)                      \\\n+  f(finish_queues,                                  \"  Finish Queues\")                 \\\n+  f(weakrefs,                                       \"  Weak References\")               \\\n+  f(weakrefs_process,                               \"    Process\")                     \\\n+  f(purge,                                          \"  System Purge\")                  \\\n+  f(purge_class_unload,                             \"    Unload Classes\")              \\\n+  SHENANDOAH_PAR_PHASE_DO(purge_cu_par_,            \"      CU: \", f)                   \\\n+  f(purge_weak_par,                                 \"    Weak Roots\")                  \\\n+  SHENANDOAH_PAR_PHASE_DO(purge_weak_par_,          \"      WR: \", f)                   \\\n+  f(purge_cldg,                                     \"    CLDG\")                        \\\n+  f(final_update_region_states,                     \"  Update Region States\")          \\\n+  f(retire_tlabs,                                   \"  Retire TLABs\")                  \\\n+  f(choose_cset,                                    \"  Choose Collection Set\")         \\\n+  f(final_rebuild_freeset,                          \"  Rebuild Free Set\")              \\\n+  f(init_evac,                                      \"  Initial Evacuation\")            \\\n+  SHENANDOAH_PAR_PHASE_DO(evac_,                    \"    E: \", f)                      \\\n+                                                                                       \\\n+  f(conc_weak_roots,                                \"Concurrent Weak Roots\")           \\\n+  f(conc_weak_roots_work,                           \"  Roots\")                         \\\n+  SHENANDOAH_PAR_PHASE_DO(conc_weak_roots_work_,    \"    CWR: \", f)                    \\\n+  f(conc_weak_roots_rendezvous,                     \"  Rendezvous\")                    \\\n+  f(conc_cleanup_early,                             \"Concurrent Cleanup\")              \\\n+  f(conc_class_unload,                              \"Concurrent Class Unloading\")      \\\n+  f(conc_class_unload_unlink,                       \"  Unlink Stale\")                  \\\n+  f(conc_class_unload_unlink_sd,                    \"    System Dictionary\")           \\\n+  f(conc_class_unload_unlink_weak_klass,            \"    Weak Class Links\")            \\\n+  f(conc_class_unload_unlink_code_roots,            \"    Code Roots\")                  \\\n+  f(conc_class_unload_rendezvous,                   \"  Rendezvous\")                    \\\n+  f(conc_class_unload_purge,                        \"  Purge Unlinked\")                \\\n+  f(conc_class_unload_purge_coderoots,              \"    Code Roots\")                  \\\n+  f(conc_class_unload_purge_cldg,                   \"    CLDG\")                        \\\n+  f(conc_class_unload_purge_ec,                     \"    Exception Caches\")            \\\n+  f(conc_strong_roots,                              \"Concurrent Strong Roots\")         \\\n+  SHENANDOAH_PAR_PHASE_DO(conc_strong_roots_,       \"  CSR: \", f)                      \\\n+  f(conc_evac,                                      \"Concurrent Evacuation\")           \\\n+                                                                                       \\\n+  f(init_update_refs_gross,                         \"Pause Init  Update Refs (G)\")     \\\n+  f(init_update_refs,                               \"Pause Init  Update Refs (N)\")     \\\n+  f(init_update_refs_retire_gclabs,                 \"  Retire GCLABs\")                 \\\n+                                                                                       \\\n+  f(conc_update_refs,                               \"Concurrent Update Refs\")          \\\n+                                                                                       \\\n+  f(final_update_refs_gross,                        \"Pause Final Update Refs (G)\")     \\\n+  f(final_update_refs,                              \"Pause Final Update Refs (N)\")     \\\n+  f(final_update_refs_finish_work,                  \"  Finish Work\")                   \\\n+  f(final_update_refs_roots,                        \"  Update Roots\")                  \\\n+  SHENANDOAH_PAR_PHASE_DO(final_update_,            \"    UR: \", f)                     \\\n+  f(final_update_refs_update_region_states,         \"  Update Region States\")          \\\n+  f(final_update_refs_trash_cset,                   \"  Trash Collection Set\")          \\\n+  f(final_update_refs_rebuild_freeset,              \"  Rebuild Free Set\")              \\\n+                                                                                       \\\n+  f(conc_cleanup_complete,                          \"Concurrent Cleanup\")              \\\n+                                                                                       \\\n+  f(degen_gc_gross,                                 \"Pause Degenerated GC (G)\")        \\\n+  f(degen_gc,                                       \"Pause Degenerated GC (N)\")        \\\n+  f(degen_gc_scan_conc_roots,                       \"  Degen Mark Roots\")              \\\n+  SHENANDOAH_PAR_PHASE_DO(degen_gc_conc_mark_,      \"    DM: \", f)                     \\\n+  f(degen_gc_update_roots,                          \"  Degen Update Roots\")            \\\n+  SHENANDOAH_PAR_PHASE_DO(degen_gc_update_,         \"    DU: \", f)                     \\\n+                                                                                       \\\n+  f(full_gc_gross,                                  \"Pause Full GC (G)\")               \\\n+  f(full_gc,                                        \"Pause Full GC (N)\")               \\\n+  f(full_gc_heapdump_pre,                           \"  Pre Heap Dump\")                 \\\n+  f(full_gc_prepare,                                \"  Prepare\")                       \\\n+  f(full_gc_scan_roots,                             \"  Scan Roots\")                    \\\n+  SHENANDOAH_PAR_PHASE_DO(full_gc_scan_roots_,      \"    FS: \", f)                     \\\n+  f(full_gc_scan_conc_roots,                        \"  Scan Concurrent Roots\")         \\\n+  SHENANDOAH_PAR_PHASE_DO(full_gc_scan_conc_roots,  \"    FCS: \", f)                    \\\n+  f(full_gc_update_roots,                           \"  Update Roots\")                  \\\n+  SHENANDOAH_PAR_PHASE_DO(full_gc_update_roots_,    \"    FU: \", f)                     \\\n+  f(full_gc_mark,                                   \"  Mark\")                          \\\n+  f(full_gc_mark_finish_queues,                     \"    Finish Queues\")               \\\n+  f(full_gc_weakrefs,                               \"    Weak References\")             \\\n+  f(full_gc_weakrefs_process,                       \"      Process\")                   \\\n+  f(full_gc_purge,                                  \"    System Purge\")                \\\n+  f(full_gc_purge_class_unload,                     \"      Unload Classes\")            \\\n+  SHENANDOAH_PAR_PHASE_DO(full_gc_purge_cu_par_,    \"        CU: \", f)                 \\\n+  f(full_gc_purge_weak_par,                         \"      Weak Roots\")                \\\n+  SHENANDOAH_PAR_PHASE_DO(full_gc_purge_weak_p_,    \"        WR: \", f)                 \\\n+  f(full_gc_purge_cldg,                             \"      CLDG\")                      \\\n+  f(full_gc_calculate_addresses,                    \"  Calculate Addresses\")           \\\n+  f(full_gc_calculate_addresses_regular,            \"    Regular Objects\")             \\\n+  f(full_gc_calculate_addresses_humong,             \"    Humongous Objects\")           \\\n+  f(full_gc_adjust_pointers,                        \"  Adjust Pointers\")               \\\n+  f(full_gc_adjust_roots,                           \"  Adjust Roots\")                  \\\n+  SHENANDOAH_PAR_PHASE_DO(full_gc_adjust_roots_,    \"    FA: \", f)                     \\\n+  f(full_gc_copy_objects,                           \"  Copy Objects\")                  \\\n+  f(full_gc_copy_objects_regular,                   \"    Regular Objects\")             \\\n+  f(full_gc_copy_objects_humong,                    \"    Humongous Objects\")           \\\n+  f(full_gc_copy_objects_reset_complete,            \"    Reset Complete Bitmap\")       \\\n+  f(full_gc_copy_objects_rebuild,                   \"    Rebuild Region Sets\")         \\\n+  f(full_gc_resize_tlabs,                           \"  Resize TLABs\")                  \\\n+  f(full_gc_heapdump_post,                          \"  Post Heap Dump\")                \\\n+                                                                                       \\\n+  f(conc_uncommit,                                  \"Concurrent Uncommit\")             \\\n+                                                                                       \\\n+  f(heap_iteration_roots,                           \"Heap Iteration\")                  \\\n+  SHENANDOAH_PAR_PHASE_DO(heap_iteration_roots_,    \"  HI: \", f)                       \\\n@@ -364,0 +179,2 @@\n+typedef WorkerDataArray<double> ShenandoahWorkerData;\n+\n@@ -365,0 +182,2 @@\n+  friend class ShenandoahGCPhase;\n+  friend class ShenandoahWorkerTimingsTracker;\n@@ -366,1 +185,1 @@\n-#define GC_PHASE_DECLARE_ENUM(type, title)   type,\n+#define SHENANDOAH_PHASE_DECLARE_ENUM(type, title)   type,\n@@ -369,2 +188,3 @@\n-    SHENANDOAH_GC_PHASE_DO(GC_PHASE_DECLARE_ENUM)\n-    _num_phases\n+    SHENANDOAH_PHASE_DO(SHENANDOAH_PHASE_DECLARE_ENUM)\n+    _num_phases,\n+    _invalid_phase = _num_phases\n@@ -373,6 +193,3 @@\n-  \/\/ These are the subphases of GC phases (scan_roots, update_roots,\n-  \/\/ init_evac, final_update_refs_roots and full_gc_roots).\n-  \/\/ Make sure they are following this order.\n-  enum GCParPhases {\n-    SHENANDOAH_GC_PAR_PHASE_DO(GC_PHASE_DECLARE_ENUM)\n-    GCParPhasesSentinel\n+  enum ParPhase {\n+    SHENANDOAH_PAR_PHASE_DO(,, SHENANDOAH_PHASE_DECLARE_ENUM)\n+    _num_par_phases\n@@ -381,7 +198,1 @@\n-#undef GC_PHASE_DECLARE_ENUM\n-\n-private:\n-  struct TimingData {\n-    HdrSeq _secs;\n-    double _start;\n-  };\n+#undef SHENANDOAH_PHASE_DECLARE_ENUM\n@@ -390,1 +201,3 @@\n-  TimingData          _timing_data[_num_phases];\n+  uint                _max_workers;\n+  double              _cycle_data[_num_phases];\n+  HdrSeq              _global_data[_num_phases];\n@@ -393,3 +206,1 @@\n-  ShenandoahWorkerTimings*      _worker_times;\n-  ShenandoahTerminationTimings* _termination_times;\n-\n+  ShenandoahWorkerData* _worker_data[_num_phases];\n@@ -398,2 +209,2 @@\n-public:\n-  ShenandoahPhaseTimings();\n+  static bool is_worker_phase(Phase phase);\n+  static bool is_root_work_phase(Phase phase);\n@@ -401,2 +212,8 @@\n-  ShenandoahWorkerTimings* const worker_times() const { return _worker_times; }\n-  ShenandoahTerminationTimings* const termination_times() const { return _termination_times; }\n+  ShenandoahWorkerData* worker_data(Phase phase, ParPhase par_phase);\n+  Phase worker_par_phase(Phase phase, ParPhase par_phase);\n+\n+  void set_cycle_data(Phase phase, double time);\n+  static double uninitialized() { return -1; }\n+\n+public:\n+  ShenandoahPhaseTimings(uint max_workers);\n@@ -404,5 +221,0 @@\n-  \/\/ record phase start\n-  void record_phase_start(Phase phase);\n-  \/\/ record phase end and return elapsed time in seconds for the phase\n-  void record_phase_end(Phase phase);\n-  \/\/ record an elapsed time for the phase\n@@ -414,0 +226,3 @@\n+  void flush_par_workers_to_cycle();\n+  void flush_cycle_to_global();\n+\n@@ -419,5 +234,2 @@\n-  void print_on(outputStream* out) const;\n-\n-private:\n-  void init_phase_names();\n-  void print_summary_sd(outputStream* out, const char* str, const HdrSeq* seq) const;\n+  void print_cycle_on(outputStream* out) const;\n+  void print_global_on(outputStream* out) const;\n@@ -426,1 +238,1 @@\n-class ShenandoahWorkerTimings : public CHeapObj<mtGC> {\n+class ShenandoahWorkerTimingsTracker : public StackObj {\n@@ -428,13 +240,4 @@\n-  uint _max_gc_threads;\n-  WorkerDataArray<double>* _gc_par_phases[ShenandoahPhaseTimings::GCParPhasesSentinel];\n-\n-public:\n-  ShenandoahWorkerTimings(uint max_gc_threads);\n-\n-  \/\/ record the time a phase took in seconds\n-  void record_time_secs(ShenandoahPhaseTimings::GCParPhases phase, uint worker_i, double secs);\n-\n-  double average(uint i) const;\n-  void reset(uint i);\n-  void print() const;\n-};\n+  ShenandoahPhaseTimings*          const _timings;\n+  ShenandoahPhaseTimings::Phase    const _phase;\n+  ShenandoahPhaseTimings::ParPhase const _par_phase;\n+  uint const _worker_id;\n@@ -442,3 +245,2 @@\n-class ShenandoahTerminationTimings : public CHeapObj<mtGC> {\n-private:\n-  WorkerDataArray<double>* _gc_termination_phase;\n+  double _start_time;\n+  EventGCPhaseParallel _event;\n@@ -446,9 +248,2 @@\n-  ShenandoahTerminationTimings(uint max_gc_threads);\n-\n-  \/\/ record the time a phase took in seconds\n-  void record_time_secs(uint worker_i, double secs);\n-\n-  double average() const;\n-  void reset();\n-\n-  void print() const;\n+  ShenandoahWorkerTimingsTracker(ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase, uint worker_id);\n+  ~ShenandoahWorkerTimingsTracker();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":181,"deletions":386,"binary":false,"changes":567,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-#include \"classfile\/systemDictionary.hpp\"\n+#include \"code\/nmethod.hpp\"\n@@ -34,1 +34,1 @@\n-#include \"gc\/shenandoah\/shenandoahHeap.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n@@ -37,1 +37,0 @@\n-#include \"gc\/shenandoah\/shenandoahTimingTracker.hpp\"\n@@ -47,2 +46,3 @@\n-ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do, ShenandoahPhaseTimings::GCParPhases phase) :\n-  _oops_do(oops_do), _phase(phase) {\n+ShenandoahSerialRoot::ShenandoahSerialRoot(ShenandoahSerialRoot::OopsDo oops_do,\n+  ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase) :\n+  _oops_do(oops_do), _phase(phase), _par_phase(par_phase) {\n@@ -53,2 +53,1 @@\n-    ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();\n-    ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);\n+    ShenandoahWorkerTimingsTracker timer(_phase, _par_phase, worker_id);\n@@ -59,11 +58,5 @@\n-\/\/ Overwrite the second argument for SD::oops_do, don't include vm global oop storage.\n-static void system_dictionary_oops_do(OopClosure* cl) {\n-  SystemDictionary::oops_do(cl, false);\n-}\n-\n-ShenandoahSerialRoots::ShenandoahSerialRoots() :\n-  _universe_root(&Universe::oops_do, ShenandoahPhaseTimings::UniverseRoots),\n-  _object_synchronizer_root(&ObjectSynchronizer::oops_do, ShenandoahPhaseTimings::ObjectSynchronizerRoots),\n-  _management_root(&Management::oops_do, ShenandoahPhaseTimings::ManagementRoots),\n-  _system_dictionary_root(&system_dictionary_oops_do, ShenandoahPhaseTimings::SystemDictionaryRoots),\n-  _jvmti_root(&JvmtiExport::oops_do, ShenandoahPhaseTimings::JVMTIRoots) {\n+ShenandoahSerialRoots::ShenandoahSerialRoots(ShenandoahPhaseTimings::Phase phase) :\n+  _universe_root(&Universe::oops_do, phase, ShenandoahPhaseTimings::UniverseRoots),\n+  _object_synchronizer_root(&ObjectSynchronizer::oops_do, phase, ShenandoahPhaseTimings::ObjectSynchronizerRoots),\n+  _management_root(&Management::oops_do, phase, ShenandoahPhaseTimings::ManagementRoots),\n+  _jvmti_root(&JvmtiExport::oops_do, phase, ShenandoahPhaseTimings::JVMTIRoots) {\n@@ -76,1 +69,0 @@\n-  _system_dictionary_root.oops_do(cl, worker_id);\n@@ -80,2 +72,3 @@\n-ShenandoahWeakSerialRoot::ShenandoahWeakSerialRoot(ShenandoahWeakSerialRoot::WeakOopsDo weak_oops_do, ShenandoahPhaseTimings::GCParPhases phase) :\n-  _weak_oops_do(weak_oops_do), _phase(phase) {\n+ShenandoahWeakSerialRoot::ShenandoahWeakSerialRoot(ShenandoahWeakSerialRoot::WeakOopsDo weak_oops_do,\n+  ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase) :\n+  _weak_oops_do(weak_oops_do), _phase(phase), _par_phase(par_phase) {\n@@ -86,2 +79,1 @@\n-    ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();\n-    ShenandoahWorkerTimingsTracker timer(worker_times, _phase, worker_id);\n+    ShenandoahWorkerTimingsTracker timer(_phase, _par_phase, worker_id);\n@@ -93,2 +85,2 @@\n-ShenandoahJVMTIWeakRoot::ShenandoahJVMTIWeakRoot() :\n-  ShenandoahWeakSerialRoot(&JvmtiExport::weak_oops_do, ShenandoahPhaseTimings::JVMTIWeakRoots) {\n+ShenandoahJVMTIWeakRoot::ShenandoahJVMTIWeakRoot(ShenandoahPhaseTimings::Phase phase) :\n+  ShenandoahWeakSerialRoot(&JvmtiExport::weak_oops_do, phase, ShenandoahPhaseTimings::JVMTIWeakRoots) {\n@@ -99,2 +91,2 @@\n-ShenandoahJFRWeakRoot::ShenandoahJFRWeakRoot() :\n-  ShenandoahWeakSerialRoot(&Jfr::weak_oops_do, ShenandoahPhaseTimings::JFRWeakRoots) {\n+ShenandoahJFRWeakRoot::ShenandoahJFRWeakRoot(ShenandoahPhaseTimings::Phase phase) :\n+  ShenandoahWeakSerialRoot(&Jfr::weak_oops_do, phase, ShenandoahPhaseTimings::JFRWeakRoots) {\n@@ -105,2 +97,2 @@\n-ShenandoahTSANWeakRoot::ShenandoahTSANWeakRoot() :\n-  ShenandoahWeakSerialRoot(&TsanOopMap::weak_oops_do, ShenandoahPhaseTimings::TSANWeakRoots) {\n+ShenandoahTSANWeakRoot::ShenandoahTSANWeakRoot(ShenandoahPhaseTimings::Phase phase) :\n+  ShenandoahWeakSerialRoot(&TsanOopMap::weak_oops_do, phase, ShenandoahPhaseTimings::TSANWeakRoots) {\n@@ -121,1 +113,2 @@\n-ShenandoahThreadRoots::ShenandoahThreadRoots(bool is_par) : _is_par(is_par) {\n+ShenandoahThreadRoots::ShenandoahThreadRoots(ShenandoahPhaseTimings::Phase phase, bool is_par) :\n+  _phase(phase), _is_par(is_par) {\n@@ -126,2 +119,1 @@\n-  ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();\n-  ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);\n+  ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::ThreadRoots, worker_id);\n@@ -133,2 +125,1 @@\n-  ShenandoahWorkerTimings* worker_times = ShenandoahHeap::heap()->phase_timings()->worker_times();\n-  ShenandoahWorkerTimingsTracker timer(worker_times, ShenandoahPhaseTimings::ThreadRoots, worker_id);\n+  ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::ThreadRoots, worker_id);\n@@ -143,1 +134,1 @@\n-ShenandoahStringDedupRoots::ShenandoahStringDedupRoots() {\n+ShenandoahStringDedupRoots::ShenandoahStringDedupRoots(ShenandoahPhaseTimings::Phase phase) : _phase(phase) {\n@@ -157,1 +148,1 @@\n-    ShenandoahStringDedup::parallel_oops_do(is_alive, keep_alive, worker_id);\n+    ShenandoahStringDedup::parallel_oops_do(_phase, is_alive, keep_alive, worker_id);\n@@ -161,1 +152,2 @@\n-ShenandoahConcurrentStringDedupRoots::ShenandoahConcurrentStringDedupRoots() {\n+ShenandoahConcurrentStringDedupRoots::ShenandoahConcurrentStringDedupRoots(ShenandoahPhaseTimings::Phase phase) :\n+  _phase(phase) {\n@@ -183,2 +175,9 @@\n-    StringDedupQueue::unlink_or_oops_do(&sd_cl);\n-    StringDedupTable::unlink_or_oops_do(&sd_cl, worker_id);\n+    {\n+      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::StringDedupQueueRoots, worker_id);\n+      StringDedupQueue::unlink_or_oops_do(&sd_cl);\n+    }\n+\n+    {\n+      ShenandoahWorkerTimingsTracker x(_phase, ShenandoahPhaseTimings::StringDedupTableRoots, worker_id);\n+      StringDedupTable::unlink_or_oops_do(&sd_cl, worker_id);\n+    }\n@@ -188,0 +187,13 @@\n+ShenandoahCodeCacheRoots::ShenandoahCodeCacheRoots(ShenandoahPhaseTimings::Phase phase) : _phase(phase) {\n+  nmethod::oops_do_marking_prologue();\n+}\n+\n+void ShenandoahCodeCacheRoots::code_blobs_do(CodeBlobClosure* blob_cl, uint worker_id) {\n+  ShenandoahWorkerTimingsTracker timer(_phase, ShenandoahPhaseTimings::CodeCacheRoots, worker_id);\n+  _coderoots_iterator.possibly_parallel_blobs_do(blob_cl);\n+}\n+\n+ShenandoahCodeCacheRoots::~ShenandoahCodeCacheRoots() {\n+  nmethod::oops_do_marking_epilogue();\n+}\n+\n@@ -190,1 +202,2 @@\n-  _phase(phase) {\n+  _phase(phase),\n+  _worker_phase(phase) {\n@@ -192,1 +205,0 @@\n-  _heap->phase_timings()->record_workers_start(_phase);\n@@ -195,3 +207,52 @@\n-ShenandoahRootProcessor::~ShenandoahRootProcessor() {\n-  assert(SafepointSynchronize::is_at_safepoint(), \"Must at safepoint\");\n-  _heap->phase_timings()->record_workers_end(_phase);\n+ShenandoahRootScanner::ShenandoahRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase) :\n+  ShenandoahRootProcessor(phase),\n+  _serial_roots(phase),\n+  _thread_roots(phase, n_workers > 1) {\n+  nmethod::oops_do_marking_prologue();\n+}\n+\n+ShenandoahRootScanner::~ShenandoahRootScanner() {\n+  nmethod::oops_do_marking_epilogue();\n+}\n+\n+void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops) {\n+  CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);\n+  MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations);\n+  roots_do(worker_id, oops, &clds_cl, &blobs_cl);\n+}\n+\n+void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops) {\n+  CLDToOopClosure clds_cl(oops, ClassLoaderData::_claim_strong);\n+  MarkingCodeBlobClosure blobs_cl(oops, !CodeBlobToOopClosure::FixRelocations);\n+  strong_roots_do(worker_id, oops, &clds_cl, &blobs_cl);\n+}\n+\n+void ShenandoahRootScanner::roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure *tc) {\n+  assert(!ShenandoahSafepoint::is_at_shenandoah_safepoint() ||\n+         !ShenandoahHeap::heap()->unload_classes(),\n+          \"Expect class unloading when Shenandoah cycle is running\");\n+  assert(clds != NULL, \"Only possible with CLD closure\");\n+\n+  AlwaysTrueClosure always_true;\n+  ShenandoahParallelOopsDoThreadClosure tc_cl(oops, code, tc);\n+\n+  ResourceMark rm;\n+\n+  \/\/ Process serial-claiming roots first\n+  _serial_roots.oops_do(oops, worker_id);\n+\n+  \/\/ Process heavy-weight\/fully parallel roots the last\n+  _thread_roots.threads_do(&tc_cl, worker_id);\n+}\n+\n+void ShenandoahRootScanner::strong_roots_do(uint worker_id, OopClosure* oops, CLDClosure* clds, CodeBlobClosure* code, ThreadClosure* tc) {\n+  assert(ShenandoahHeap::heap()->unload_classes(), \"Should be used during class unloading\");\n+  ShenandoahParallelOopsDoThreadClosure tc_cl(oops, code, tc);\n+\n+  ResourceMark rm;\n+\n+  \/\/ Process serial-claiming roots first\n+  _serial_roots.oops_do(oops, worker_id);\n+\n+  \/\/ Process heavy-weight\/fully parallel roots the last\n+  _thread_roots.threads_do(&tc_cl, worker_id);\n@@ -202,2 +263,2 @@\n-                                                 bool include_concurrent_roots,\n-                                                 bool include_concurrent_code_roots) :\n+                                                 bool stw_roots_processing,\n+                                                 bool stw_class_unloading) :\n@@ -205,3 +266,10 @@\n-  _thread_roots(n_workers > 1),\n-  _include_concurrent_roots(include_concurrent_roots),\n-  _include_concurrent_code_roots(include_concurrent_code_roots) {\n+  _serial_roots(phase),\n+  _vm_roots(phase),\n+  _cld_roots(phase, n_workers),\n+  _thread_roots(phase, n_workers > 1),\n+  _serial_weak_roots(phase),\n+  _weak_roots(phase),\n+  _dedup_roots(phase),\n+  _code_roots(phase),\n+  _stw_roots_processing(stw_roots_processing),\n+  _stw_class_unloading(stw_class_unloading) {\n@@ -218,0 +286,1 @@\n+  \/\/ Process serial-claiming roots first\n@@ -220,2 +289,3 @@\n-  if (_include_concurrent_roots) {\n-    CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);\n+\n+  \/\/ Process light-weight\/limited parallel roots then\n+  if (_stw_roots_processing) {\n@@ -223,1 +293,0 @@\n-    _cld_roots.cld_do(&clds, worker_id);\n@@ -227,0 +296,4 @@\n+  if (_stw_class_unloading) {\n+    CLDToOopClosure clds(oops, ClassLoaderData::_claim_strong);\n+    _cld_roots.cld_do(&clds, worker_id);\n+  }\n@@ -228,1 +301,2 @@\n-  if (_include_concurrent_code_roots) {\n+  \/\/ Process heavy-weight\/fully parallel roots the last\n+  if (_stw_class_unloading) {\n@@ -238,1 +312,8 @@\n-  _thread_roots(n_workers > 1) {\n+  _serial_roots(phase),\n+  _vm_roots(phase),\n+  _cld_roots(phase, n_workers),\n+  _thread_roots(phase, n_workers > 1),\n+  _serial_weak_roots(phase),\n+  _weak_roots(phase),\n+  _dedup_roots(phase),\n+  _code_roots(phase) {\n@@ -243,1 +324,8 @@\n-  _thread_roots(n_workers > 1) {\n+  _serial_roots(phase),\n+  _vm_roots(phase),\n+  _cld_roots(phase, n_workers),\n+  _thread_roots(phase, n_workers > 1),\n+  _serial_weak_roots(phase),\n+  _weak_roots(phase),\n+  _dedup_roots(phase),\n+  _code_roots(phase) {\n@@ -256,0 +344,1 @@\n+  \/\/ Process serial-claiming roots first\n@@ -257,6 +346,3 @@\n-  _vm_roots.oops_do(oops, worker_id);\n-\n-  _thread_roots.oops_do(oops, NULL, worker_id);\n-  _cld_roots.cld_do(&adjust_cld_closure, worker_id);\n-  _code_roots.code_blobs_do(adjust_code_closure, worker_id);\n-\n+\n+  \/\/ Process light-weight\/limited parallel roots then\n+  _vm_roots.oops_do(oops, worker_id);\n@@ -266,0 +352,5 @@\n+  _cld_roots.cld_do(&adjust_cld_closure, worker_id);\n+\n+  \/\/ Process heavy-weight\/fully parallel roots the last\n+  _code_roots.code_blobs_do(adjust_code_closure, worker_id);\n+  _thread_roots.oops_do(oops, NULL, worker_id);\n@@ -268,3 +359,10 @@\n- ShenandoahHeapIterationRootScanner::ShenandoahHeapIterationRootScanner() :\n-   ShenandoahRootProcessor(ShenandoahPhaseTimings::_num_phases),\n-   _thread_roots(false \/*is par*\/) {\n+ShenandoahHeapIterationRootScanner::ShenandoahHeapIterationRootScanner() :\n+   ShenandoahRootProcessor(ShenandoahPhaseTimings::heap_iteration_roots),\n+   _serial_roots(ShenandoahPhaseTimings::heap_iteration_roots),\n+   _thread_roots(ShenandoahPhaseTimings::heap_iteration_roots, false \/*is par*\/),\n+   _vm_roots(ShenandoahPhaseTimings::heap_iteration_roots),\n+   _cld_roots(ShenandoahPhaseTimings::heap_iteration_roots, 1),\n+   _serial_weak_roots(ShenandoahPhaseTimings::heap_iteration_roots),\n+   _weak_roots(ShenandoahPhaseTimings::heap_iteration_roots),\n+   _dedup_roots(ShenandoahPhaseTimings::heap_iteration_roots),\n+   _code_roots(ShenandoahPhaseTimings::heap_iteration_roots) {\n@@ -280,0 +378,1 @@\n+\n@@ -282,0 +381,1 @@\n+   \/\/ Process serial-claiming roots first\n@@ -283,5 +383,3 @@\n-   _vm_roots.oops_do(oops, 0);\n-   _cld_roots.cld_do(&clds, 0);\n-   _thread_roots.threads_do(&tc_cl, 0);\n-   _code_roots.code_blobs_do(&code, 0);\n-\n+\n+   \/\/ Process light-weight\/limited parallel roots then\n+   _vm_roots.oops_do(oops, 0);\n@@ -291,9 +389,1 @@\n- }\n-\n- void ShenandoahHeapIterationRootScanner::strong_roots_do(OopClosure* oops) {\n-   assert(Thread::current()->is_VM_thread(), \"Only by VM thread\");\n-   \/\/ Must use _claim_none to avoid interfering with concurrent CLDG iteration\n-   CLDToOopClosure clds(oops, ClassLoaderData::_claim_none);\n-   MarkingCodeBlobClosure code(oops, !CodeBlobToOopClosure::FixRelocations);\n-   ShenandoahParallelOopsDoThreadClosure tc_cl(oops, &code, NULL);\n-   ResourceMark rm;\n+   _cld_roots.cld_do(&clds, 0);\n@@ -301,3 +391,2 @@\n-   _serial_roots.oops_do(oops, 0);\n-   _vm_roots.oops_do(oops, 0);\n-   _cld_roots.always_strong_cld_do(&clds, 0);\n+   \/\/ Process heavy-weight\/fully parallel roots the last\n+   _code_roots.code_blobs_do(&code, 0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":170,"deletions":81,"binary":false,"changes":251,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"gc\/shenandoah\/shenandoahUtils.hpp\"\n@@ -40,3 +41,4 @@\n-  ShenandoahSharedFlag                      _claimed;\n-  const OopsDo                              _oops_do;\n-  const ShenandoahPhaseTimings::GCParPhases _phase;\n+  ShenandoahSharedFlag                   _claimed;\n+  const OopsDo                           _oops_do;\n+  const ShenandoahPhaseTimings::Phase    _phase;\n+  const ShenandoahPhaseTimings::ParPhase _par_phase;\n@@ -45,1 +47,2 @@\n-  ShenandoahSerialRoot(OopsDo oops_do, ShenandoahPhaseTimings::GCParPhases);\n+  ShenandoahSerialRoot(OopsDo oops_do,\n+          ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);\n@@ -54,1 +57,0 @@\n-  ShenandoahSerialRoot  _system_dictionary_root;\n@@ -57,1 +59,1 @@\n-  ShenandoahSerialRoots();\n+  ShenandoahSerialRoots(ShenandoahPhaseTimings::Phase phase);\n@@ -64,3 +66,4 @@\n-  ShenandoahSharedFlag                      _claimed;\n-  const WeakOopsDo                          _weak_oops_do;\n-  const ShenandoahPhaseTimings::GCParPhases _phase;\n+  ShenandoahSharedFlag                   _claimed;\n+  const WeakOopsDo                       _weak_oops_do;\n+  const ShenandoahPhaseTimings::Phase    _phase;\n+  const ShenandoahPhaseTimings::ParPhase _par_phase;\n@@ -69,1 +72,2 @@\n-  ShenandoahWeakSerialRoot(WeakOopsDo oops_do, ShenandoahPhaseTimings::GCParPhases);\n+  ShenandoahWeakSerialRoot(WeakOopsDo oops_do,\n+          ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);\n@@ -76,1 +80,1 @@\n-  ShenandoahJVMTIWeakRoot();\n+  ShenandoahJVMTIWeakRoot(ShenandoahPhaseTimings::Phase phase);\n@@ -83,1 +87,1 @@\n-  ShenandoahJFRWeakRoot();\n+  ShenandoahJFRWeakRoot(ShenandoahPhaseTimings::Phase phase);\n@@ -90,1 +94,1 @@\n-  ShenandoahTSANWeakRoot();\n+  ShenandoahTSANWeakRoot(ShenandoahPhaseTimings::Phase phase);\n@@ -100,0 +104,4 @@\n+  ShenandoahSerialWeakRoots(ShenandoahPhaseTimings::Phase phase) :\n+  JVMTI_ONLY(_jvmti_weak_roots(phase))\n+  JFR_ONLY(JVMTI_ONLY(COMMA)_jfr_weak_roots(phase))\n+  TSAN_ONLY(JVMTI_ONLY(COMMA)_tsan_weak_roots(phase)) {};\n@@ -108,1 +116,2 @@\n-  const ShenandoahPhaseTimings::GCParPhases _phase;\n+  const ShenandoahPhaseTimings::Phase    _phase;\n+  const ShenandoahPhaseTimings::ParPhase _par_phase;\n@@ -110,1 +119,2 @@\n-  ShenandoahVMRoot(OopStorage* storage, ShenandoahPhaseTimings::GCParPhases phase);\n+  ShenandoahVMRoot(OopStorage* storage,\n+          ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);\n@@ -119,1 +129,2 @@\n-  ShenandoahWeakRoot(OopStorage* storage, ShenandoahPhaseTimings::GCParPhases phase);\n+  ShenandoahWeakRoot(OopStorage* storage,\n+          ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);\n@@ -126,1 +137,2 @@\n-  const ShenandoahPhaseTimings::GCParPhases _phase;\n+  const ShenandoahPhaseTimings::Phase    _phase;\n+  const ShenandoahPhaseTimings::ParPhase _par_phase;\n@@ -129,1 +141,2 @@\n-  ShenandoahWeakRoot(OopStorage* storage, ShenandoahPhaseTimings::GCParPhases phase);\n+  ShenandoahWeakRoot(OopStorage* storage,\n+          ShenandoahPhaseTimings::Phase phase, ShenandoahPhaseTimings::ParPhase par_phase);\n@@ -147,1 +160,1 @@\n-  void oops_do(Closure* cl, uint worker_id = 0);\n+  void oops_do(Closure* cl, uint worker_id);\n@@ -158,1 +171,1 @@\n-  ShenandoahWeakRoots();\n+  ShenandoahWeakRoots(ShenandoahPhaseTimings::Phase phase);\n@@ -161,1 +174,1 @@\n-  void oops_do(Closure* cl, uint worker_id = 0);\n+  void oops_do(Closure* cl, uint worker_id);\n@@ -174,1 +187,1 @@\n-  ShenandoahVMRoots();\n+  ShenandoahVMRoots(ShenandoahPhaseTimings::Phase phase);\n@@ -177,1 +190,1 @@\n-  void oops_do(T* cl, uint worker_id = 0);\n+  void oops_do(T* cl, uint worker_id);\n@@ -182,0 +195,1 @@\n+  ShenandoahPhaseTimings::Phase _phase;\n@@ -184,1 +198,1 @@\n-  ShenandoahThreadRoots(bool is_par);\n+  ShenandoahThreadRoots(ShenandoahPhaseTimings::Phase phase, bool is_par);\n@@ -192,0 +206,2 @@\n+private:\n+  ShenandoahPhaseTimings::Phase _phase;\n@@ -193,1 +209,1 @@\n-  ShenandoahStringDedupRoots();\n+  ShenandoahStringDedupRoots(ShenandoahPhaseTimings::Phase phase);\n@@ -200,0 +216,3 @@\n+private:\n+  ShenandoahPhaseTimings::Phase _phase;\n+\n@@ -201,1 +220,1 @@\n-  ShenandoahConcurrentStringDedupRoots();\n+  ShenandoahConcurrentStringDedupRoots(ShenandoahPhaseTimings::Phase phase);\n@@ -207,1 +226,0 @@\n-template <typename ITR>\n@@ -210,1 +228,2 @@\n-  ITR _coderoots_iterator;\n+  ShenandoahPhaseTimings::Phase _phase;\n+  ShenandoahCodeRootsIterator   _coderoots_iterator;\n@@ -212,1 +231,1 @@\n-  ShenandoahCodeCacheRoots();\n+  ShenandoahCodeCacheRoots(ShenandoahPhaseTimings::Phase phase);\n@@ -220,0 +239,11 @@\n+private:\n+  ShenandoahSharedSemaphore     _semaphore;\n+  ShenandoahPhaseTimings::Phase _phase;\n+\n+  static uint worker_count(uint n_workers) {\n+    \/\/ Limit concurrency a bit, otherwise it wastes resources when workers are tripping\n+    \/\/ over each other. This also leaves free workers to process other parts of the root\n+    \/\/ set, while admitted workers are busy with doing the CLDG walk.\n+    return MAX2(1u, MIN2(ShenandoahSharedSemaphore::max_tokens(), n_workers \/ 2));\n+  }\n+\n@@ -221,1 +251,1 @@\n-  ShenandoahClassLoaderDataRoots();\n+  ShenandoahClassLoaderDataRoots(ShenandoahPhaseTimings::Phase phase, uint n_workers);\n@@ -224,2 +254,2 @@\n-  void always_strong_cld_do(CLDClosure* clds, uint worker_id = 0);\n-  void cld_do(CLDClosure* clds, uint worker_id = 0);\n+  void always_strong_cld_do(CLDClosure* clds, uint worker_id);\n+  void cld_do(CLDClosure* clds, uint worker_id);\n@@ -232,0 +262,1 @@\n+  const ShenandoahGCWorkerPhase       _worker_phase;\n@@ -234,1 +265,0 @@\n-  ~ShenandoahRootProcessor();\n@@ -239,1 +269,0 @@\n-template <typename ITR>\n@@ -244,5 +273,1 @@\n-  ShenandoahCodeCacheRoots<ITR>                             _code_roots;\n-  ShenandoahVMRoots<false \/*concurrent*\/ >                  _vm_roots;\n-  ShenandoahStringDedupRoots                                _dedup_roots;\n-  ShenandoahClassLoaderDataRoots<false \/*concurrent*\/, false \/*single threaded*\/>\n-                                                            _cld_roots;\n+\n@@ -251,0 +276,1 @@\n+  ~ShenandoahRootScanner();\n@@ -263,2 +289,16 @@\n-typedef ShenandoahRootScanner<ShenandoahAllCodeRootsIterator> ShenandoahAllRootScanner;\n-typedef ShenandoahRootScanner<ShenandoahCsetCodeRootsIterator> ShenandoahCSetRootScanner;\n+template <bool CONCURRENT>\n+class ShenandoahConcurrentRootScanner {\n+private:\n+  ShenandoahVMRoots<CONCURRENT>            _vm_roots;\n+  ShenandoahClassLoaderDataRoots<CONCURRENT, false \/* single-threaded*\/>\n+                                           _cld_roots;\n+  ShenandoahConcurrentStringDedupRoots     _dedup_roots;\n+  ShenandoahNMethodTableSnapshot*          _codecache_snapshot;\n+  ShenandoahPhaseTimings::Phase            _phase;\n+\n+public:\n+  ShenandoahConcurrentRootScanner(uint n_workers, ShenandoahPhaseTimings::Phase phase);\n+  ~ShenandoahConcurrentRootScanner();\n+\n+  void oops_do(OopClosure* oops, uint worker_id);\n+};\n@@ -278,1 +318,1 @@\n-  ShenandoahCodeCacheRoots<ShenandoahAllCodeRootsIterator> _code_roots;\n+  ShenandoahCodeCacheRoots                                 _code_roots;\n@@ -284,1 +324,0 @@\n-  void strong_roots_do(OopClosure* cl);\n@@ -298,3 +337,3 @@\n-  ShenandoahCodeCacheRoots<ShenandoahAllCodeRootsIterator>  _code_roots;\n-  bool                                                      _include_concurrent_roots;\n-  bool                                                      _include_concurrent_code_roots;\n+  ShenandoahCodeCacheRoots                                  _code_roots;\n+  bool                                                      _stw_roots_processing;\n+  bool                                                      _stw_class_unloading;\n@@ -303,1 +342,1 @@\n-                          bool include_concurrent_roots, bool _include_concurrent_code_roots);\n+                          bool stw_roots_processing, bool stw_class_unloading);\n@@ -319,1 +358,1 @@\n-  ShenandoahCodeCacheRoots<ShenandoahAllCodeRootsIterator>  _code_roots;\n+  ShenandoahCodeCacheRoots                                  _code_roots;\n@@ -339,1 +378,1 @@\n-  ShenandoahCodeCacheRoots<ShenandoahAllCodeRootsIterator>  _code_roots;\n+  ShenandoahCodeCacheRoots                                  _code_roots;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":88,"deletions":49,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,0 +179,27 @@\n+JNIEXPORT void JNICALL\n+JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env, jclass caller,\n+                                         jstring invokedName,\n+                                         jobject invokedType,\n+                                         jobject methodType,\n+                                         jobject implMethodMember,\n+                                         jobject instantiatedMethodType,\n+                                         jclass lambdaProxyClass);\n+\n+JNIEXPORT jclass JNICALL\n+JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env, jclass caller,\n+                                      jstring invokedName,\n+                                      jobject invokedType,\n+                                      jobject methodType,\n+                                      jobject implMethodMember,\n+                                      jobject instantiatedMethodType,\n+                                      jboolean initialize);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsCDSDumpingEnabled(JNIEnv* env);\n+\n+JNIEXPORT jboolean JNICALL\n+JVM_IsCDSSharingEnabled(JNIEnv* env);\n+\n+JNIEXPORT jlong JNICALL\n+JVM_GetRandomSeedForCDSDump();\n+\n@@ -397,0 +424,15 @@\n+\/*\n+ * Define a class with the specified lookup class.\n+ *  lookup:  Lookup class\n+ *  name:    the name of the class\n+ *  buf:     class bytes\n+ *  len:     length of class bytes\n+ *  pd:      protection domain\n+ *  init:    initialize the class\n+ *  flags:   properties of the class\n+ *  classData: private static pre-initialized field; may be null\n+ *\/\n+JNIEXPORT jclass JNICALL\n+JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,\n+                      jsize len, jobject pd, jboolean init, int flags, jobject classData);\n+\n@@ -408,2 +450,1 @@\n- *  packages:     list of packages in the module\n- *  num_packages: number of packages in the module\n+ *  packages:     array of packages in the module\n@@ -413,1 +454,1 @@\n-                 jstring location, const char* const* packages, jsize num_packages);\n+                 jstring location, jobjectArray packages);\n@@ -429,1 +470,1 @@\n-JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module);\n+JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module);\n@@ -437,1 +478,1 @@\n-JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package);\n+JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package);\n@@ -445,1 +486,1 @@\n-JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package);\n+JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package);\n@@ -483,0 +524,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsHiddenClass(JNIEnv *env, jclass cls);\n+\n@@ -556,0 +600,5 @@\n+\/* Sealed types - since JDK 15 *\/\n+\n+JNIEXPORT jobjectArray JNICALL\n+JVM_GetPermittedSubclasses(JNIEnv *env, jclass current);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":56,"deletions":7,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -77,15 +77,0 @@\n-class UnlockFlagSaver {\n-  private:\n-    JavaThread* _thread;\n-    bool _do_not_unlock;\n-  public:\n-    UnlockFlagSaver(JavaThread* t) {\n-      _thread = t;\n-      _do_not_unlock = t->do_not_unlock_if_synchronized();\n-      t->set_do_not_unlock_if_synchronized(false);\n-    }\n-    ~UnlockFlagSaver() {\n-      _thread->set_do_not_unlock_if_synchronized(_do_not_unlock);\n-    }\n-};\n-\n@@ -217,1 +202,1 @@\n-    int offset = java_lang_boxing_object::value_offset_in_bytes(type);\n+    int offset = java_lang_boxing_object::value_offset(type);\n@@ -1073,0 +1058,3 @@\n+  if (HAS_PENDING_EXCEPTION) {\n+    return NULL;\n+  }\n@@ -1083,1 +1071,0 @@\n-  assert(!HAS_PENDING_EXCEPTION, \"Should not have any exceptions pending\");\n@@ -1126,0 +1113,3 @@\n+  if (HAS_PENDING_EXCEPTION) {\n+    return;\n+  }\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":17,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/timerTrace.hpp\"\n@@ -195,1 +194,0 @@\n-bool                       TemplateTable::_is_initialized = false;\n@@ -201,1 +199,0 @@\n-BarrierSet*                TemplateTable::_bs;\n@@ -212,3 +209,0 @@\n-  const int ubcp = 1 << Template::uses_bcp_bit;\n-  const int disp = 1 << Template::does_dispatch_bit;\n-  const int clvm = 1 << Template::calls_vm_bit;\n@@ -250,6 +244,5 @@\n-  if (_is_initialized) return;\n-\n-  \/\/ Initialize table\n-  TraceTime timer(\"TemplateTable initialization\", TRACETIME_LOG(Info, startuptime));\n-\n-  _bs = BarrierSet::barrier_set();\n+#ifdef ASSERT\n+  static bool is_initialized = false;\n+  assert(!is_initialized, \"must only initialize once\");\n+  is_initialized = true;\n+#endif\n@@ -534,2 +527,0 @@\n-\n-  _is_initialized = true;\n@@ -538,5 +529,0 @@\n-void templateTable_init() {\n-  TemplateTable::initialize();\n-}\n-\n-\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":5,"deletions":19,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-class BarrierSet;\n@@ -90,1 +89,0 @@\n-  static bool            _is_initialized;        \/\/ true if TemplateTable has been initialized\n@@ -96,2 +94,0 @@\n-\n-  static BarrierSet*     _bs;                    \/\/ Cache the barrier set.\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+#include \"logging\/logStream.hpp\"\n@@ -417,9 +418,12 @@\n-  if (TraceInvokeDynamic) {\n-    ttyLocker ttyl;\n-    tty->print_cr(\"set_method_handle bc=%d appendix=\" PTR_FORMAT \"%s method=\" PTR_FORMAT \" (local signature) \",\n-                  invoke_code,\n-                  p2i(appendix()),\n-                  (has_appendix ? \"\" : \" (unused)\"),\n-                  p2i(adapter));\n-    adapter->print();\n-    if (has_appendix)  appendix()->print();\n+  LogStream* log_stream = NULL;\n+  LogStreamHandle(Debug, methodhandles, indy) lsh_indy;\n+  if (lsh_indy.is_enabled()) {\n+    ResourceMark rm;\n+    log_stream = &lsh_indy;\n+    log_stream->print_cr(\"set_method_handle bc=%d appendix=\" PTR_FORMAT \"%s method=\" PTR_FORMAT \" (local signature) \",\n+                         invoke_code,\n+                         p2i(appendix()),\n+                         (has_appendix ? \"\" : \" (unused)\"),\n+                         p2i(adapter));\n+    adapter->print_on(log_stream);\n+    if (has_appendix)  appendix()->print_on(log_stream);\n@@ -461,3 +465,3 @@\n-  if (TraceInvokeDynamic) {\n-    ttyLocker ttyl;\n-    this->print(tty, 0);\n+\n+  if (log_stream != NULL) {\n+    this->print(log_stream, 0);\n@@ -562,8 +566,5 @@\n-  if (log_is_enabled(Info, redefine, class, update)) {\n-    ResourceMark rm;\n-    if (!(*trace_name_printed)) {\n-      log_info(redefine, class, update)(\"adjust: name=%s\", old_method->method_holder()->external_name());\n-      *trace_name_printed = true;\n-    }\n-    log_debug(redefine, class, update, constantpool)\n-          (\"cpc %s entry update: %s(%s)\", entry_type, new_method->name()->as_C_string(), new_method->signature()->as_C_string());\n+  ResourceMark rm;\n+\n+  if (!(*trace_name_printed)) {\n+    log_info(redefine, class, update)(\"adjust: name=%s\", old_method->method_holder()->external_name());\n+    *trace_name_printed = true;\n@@ -571,0 +572,2 @@\n+  log_trace(redefine, class, update, constantpool)\n+    (\"cpc %s entry update: %s\", entry_type, new_method->external_name());\n@@ -768,1 +771,1 @@\n-  set_resolved_references(NULL);\n+  set_resolved_references(OopHandle());\n@@ -810,0 +813,1 @@\n+  ResourceMark rm;\n@@ -811,2 +815,5 @@\n-    if (entry_at(i)->get_interesting_method_entry() != NULL &&\n-        !entry_at(i)->check_no_old_or_obsolete_entries()) {\n+    Method* m = entry_at(i)->get_interesting_method_entry();\n+    if (m != NULL && !entry_at(i)->check_no_old_or_obsolete_entries()) {\n+      log_trace(redefine, class, update, constantpool)\n+        (\"cpcache check found old method entry: class: %s, old: %d, obsolete: %d, method: %s\",\n+         constant_pool()->pool_holder()->external_name(), m->is_old(), m->is_obsolete(), m->external_name());\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":31,"deletions":24,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+#include \"classfile\/resolutionErrors.hpp\"\n@@ -140,0 +141,1 @@\n+\n@@ -159,1 +161,3 @@\n-\/\/ called to verify that k is a member of this nest\n+\/\/ private: called to verify that k is a static member of this nest.\n+\/\/ We know that k is an instance class in the same package and hence the\n+\/\/ same classloader.\n@@ -161,0 +165,1 @@\n+  assert(!is_hidden(), \"unexpected hidden class\");\n@@ -181,1 +186,3 @@\n-      Klass* k2 = _constants->klass_at(cp_index, CHECK_false);\n+      Klass* k2 = _constants->klass_at(cp_index, THREAD);\n+      assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n+             \"Exceptions should not be possible here\");\n@@ -192,9 +199,8 @@\n-        \/\/ Names match so check actual klass - this may trigger class loading if\n-        \/\/ it doesn't match (though that should be impossible). But to be safe we\n-        \/\/ have to check for a compiler thread executing here.\n-        if (!THREAD->can_call_java() && !_constants->tag_at(cp_index).is_klass()) {\n-          log_trace(class, nestmates)(\"- validation required resolution in an unsuitable thread\");\n-          return false;\n-        }\n-\n-        Klass* k2 = _constants->klass_at(cp_index, CHECK_false);\n+        \/\/ Names match so check actual klass. This may trigger class loading if\n+        \/\/ it doesn't match though that should be impossible as it means one classloader\n+        \/\/ has defined two different classes with the same name! A compiler thread won't be\n+        \/\/ able to perform that loading but we can't exclude the compiler threads from\n+        \/\/ executing this logic. But it should actually be impossible to trigger loading here.\n+        Klass* k2 = _constants->klass_at(cp_index, THREAD);\n+        assert(!HAS_PENDING_EXCEPTION || PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass()),\n+               \"Exceptions should not be possible here\");\n@@ -218,0 +224,51 @@\n+\/\/ Called to verify that k is a permitted subclass of this class\n+bool InstanceKlass::has_as_permitted_subclass(const InstanceKlass* k) const {\n+  Thread* THREAD = Thread::current();\n+  assert(k != NULL, \"sanity check\");\n+  assert(_permitted_subclasses != NULL && _permitted_subclasses != Universe::the_empty_short_array(),\n+         \"unexpected empty _permitted_subclasses array\");\n+\n+  if (log_is_enabled(Trace, class, sealed)) {\n+    ResourceMark rm(THREAD);\n+    log_trace(class, sealed)(\"Checking for permitted subclass of %s in %s\",\n+                             k->external_name(), this->external_name());\n+  }\n+\n+  \/\/ Check that the class and its super are in the same module.\n+  if (k->module() != this->module()) {\n+    ResourceMark rm(THREAD);\n+    log_trace(class, sealed)(\"Check failed for same module of permitted subclass %s and sealed class %s\",\n+                             k->external_name(), this->external_name());\n+    return false;\n+  }\n+\n+  if (!k->is_public() && !is_same_class_package(k)) {\n+    ResourceMark rm(THREAD);\n+    log_trace(class, sealed)(\"Check failed, subclass %s not public and not in the same package as sealed class %s\",\n+                             k->external_name(), this->external_name());\n+    return false;\n+  }\n+\n+  \/\/ Check for a resolved cp entry, else fall back to a name check.\n+  \/\/ We don't want to resolve any class other than the one being checked.\n+  for (int i = 0; i < _permitted_subclasses->length(); i++) {\n+    int cp_index = _permitted_subclasses->at(i);\n+    if (_constants->tag_at(cp_index).is_klass()) {\n+      Klass* k2 = _constants->klass_at(cp_index, THREAD);\n+      assert(!HAS_PENDING_EXCEPTION, \"Unexpected exception\");\n+      if (k2 == k) {\n+        log_trace(class, sealed)(\"- class is listed at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n+        return true;\n+      }\n+    } else {\n+      Symbol* name = _constants->klass_name_at(cp_index);\n+      if (name == k->name()) {\n+        log_trace(class, sealed)(\"- Found it at permitted_subclasses[%d] => cp[%d]\", i, cp_index);\n+        return true;\n+      }\n+    }\n+  }\n+  log_trace(class, sealed)(\"- class is NOT a permitted subclass!\");\n+  return false;\n+}\n+\n@@ -219,1 +276,1 @@\n-\/\/ In cases where this is called from a thread that can not do classloading\n+\/\/ In cases where this is called from a thread that cannot do classloading\n@@ -222,2 +279,10 @@\n-\/\/ from a more suitable environment later.\n-InstanceKlass* InstanceKlass::nest_host(Symbol* validationException, TRAPS) {\n+\/\/ from a more suitable environment later. Otherwise the _nest_host is always\n+\/\/ set once this method returns.\n+\/\/ Any errors from nest-host resolution must be preserved so they can be queried\n+\/\/ from higher-level access checking code, and reported as part of access checking\n+\/\/ exceptions.\n+\/\/ VirtualMachineErrors are propagated with a NULL return.\n+\/\/ Under any conditions where the _nest_host can be set to non-NULL the resulting\n+\/\/ value of it and, if applicable, the nest host resolution\/validation error,\n+\/\/ are idempotent.\n+InstanceKlass* InstanceKlass::nest_host(TRAPS) {\n@@ -225,15 +290,3 @@\n-  if (nest_host_k == NULL) {\n-    \/\/ need to resolve and save our nest-host class. This could be attempted\n-    \/\/ concurrently but as the result is idempotent and we don't use the class\n-    \/\/ then we do not need any synchronization beyond what is implicitly used\n-    \/\/ during class loading.\n-    if (_nest_host_index != 0) { \/\/ we have a real nest_host\n-      \/\/ Before trying to resolve check if we're in a suitable context\n-      if (!THREAD->can_call_java() && !_constants->tag_at(_nest_host_index).is_klass()) {\n-        if (log_is_enabled(Trace, class, nestmates)) {\n-          ResourceMark rm(THREAD);\n-          log_trace(class, nestmates)(\"Rejected resolution of nest-host of %s in unsuitable thread\",\n-                                      this->external_name());\n-        }\n-        return NULL;\n-      }\n+  if (nest_host_k != NULL) {\n+    return nest_host_k;\n+  }\n@@ -241,6 +294,1 @@\n-      if (log_is_enabled(Trace, class, nestmates)) {\n-        ResourceMark rm(THREAD);\n-        log_trace(class, nestmates)(\"Resolving nest-host of %s using cp entry for %s\",\n-                                    this->external_name(),\n-                                    _constants->klass_name_at(_nest_host_index)->as_C_string());\n-      }\n+  ResourceMark rm(THREAD);\n@@ -248,17 +296,17 @@\n-      Klass* k = _constants->klass_at(_nest_host_index, THREAD);\n-      if (HAS_PENDING_EXCEPTION) {\n-        Handle exc_h = Handle(THREAD, PENDING_EXCEPTION);\n-        if (exc_h->is_a(SystemDictionary::NoClassDefFoundError_klass())) {\n-          \/\/ throw a new CDNFE with the original as its cause, and a clear msg\n-          ResourceMark rm(THREAD);\n-          char buf[200];\n-          CLEAR_PENDING_EXCEPTION;\n-          jio_snprintf(buf, sizeof(buf),\n-                       \"Unable to load nest-host class (%s) of %s\",\n-                       _constants->klass_name_at(_nest_host_index)->as_C_string(),\n-                       this->external_name());\n-          log_trace(class, nestmates)(\"%s - NoClassDefFoundError\", buf);\n-          THROW_MSG_CAUSE_NULL(vmSymbols::java_lang_NoClassDefFoundError(), buf, exc_h);\n-        }\n-        \/\/ All other exceptions pass through (OOME, StackOverflowError, LinkageErrors etc).\n-        return NULL;\n+  \/\/ need to resolve and save our nest-host class.\n+  if (_nest_host_index != 0) { \/\/ we have a real nest_host\n+    \/\/ Before trying to resolve check if we're in a suitable context\n+    if (!THREAD->can_call_java() && !_constants->tag_at(_nest_host_index).is_klass()) {\n+      log_trace(class, nestmates)(\"Rejected resolution of nest-host of %s in unsuitable thread\",\n+                                  this->external_name());\n+      return NULL; \/\/ sentinel to say \"try again from a different context\"\n+    }\n+\n+    log_trace(class, nestmates)(\"Resolving nest-host of %s using cp entry for %s\",\n+                                this->external_name(),\n+                                _constants->klass_name_at(_nest_host_index)->as_C_string());\n+\n+    Klass* k = _constants->klass_at(_nest_host_index, THREAD);\n+    if (HAS_PENDING_EXCEPTION) {\n+      if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+        return NULL; \/\/ propagate VMEs\n@@ -266,0 +314,9 @@\n+      stringStream ss;\n+      char* target_host_class = _constants->klass_name_at(_nest_host_index)->as_C_string();\n+      ss.print(\"Nest host resolution of %s with host %s failed: \",\n+               this->external_name(), target_host_class);\n+      java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n+      const char* msg = ss.as_string(true \/* on C-heap *\/);\n+      constantPoolHandle cph(THREAD, constants());\n+      SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);\n+      CLEAR_PENDING_EXCEPTION;\n@@ -267,0 +324,2 @@\n+      log_trace(class, nestmates)(\"%s\", msg);\n+    } else {\n@@ -268,3 +327,2 @@\n-      \/\/ class as a nest member. If any of these conditions are not met we post the\n-      \/\/ requested exception type (if any) and return NULL\n-\n+      \/\/ class as a nest member. If any of these conditions are not met the class is\n+      \/\/ its own nest-host.\n@@ -275,1 +333,0 @@\n-\n@@ -280,0 +337,5 @@\n+          bool is_member = nest_host_k->has_nest_member(this, THREAD);\n+          \/\/ exception is rare, perhaps impossible\n+          if (!HAS_PENDING_EXCEPTION) {\n+            if (is_member) {\n+              _nest_host = nest_host_k; \/\/ save resolved nest-host value\n@@ -281,7 +343,0 @@\n-          bool is_member = nest_host_k->has_nest_member(this, CHECK_NULL);\n-          if (is_member) {\n-            \/\/ save resolved nest-host value\n-            _nest_host = nest_host_k;\n-\n-            if (log_is_enabled(Trace, class, nestmates)) {\n-              ResourceMark rm(THREAD);\n@@ -290,0 +345,3 @@\n+              return nest_host_k;\n+            } else {\n+              error = \"current type is not listed as a nest member\";\n@@ -291,1 +349,8 @@\n-            return nest_host_k;\n+          } else {\n+            if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+              return NULL; \/\/ propagate VMEs\n+            }\n+            stringStream ss;\n+            ss.print(\"exception on member check: \");\n+            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n+            error = ss.as_string();\n@@ -293,0 +358,2 @@\n+        } else {\n+          error = \"host is not an instance class\";\n@@ -294,1 +361,0 @@\n-        error = \"current type is not listed as a nest member\";\n@@ -299,30 +365,13 @@\n-      if (log_is_enabled(Trace, class, nestmates)) {\n-        ResourceMark rm(THREAD);\n-        log_trace(class, nestmates)\n-          (\"Type %s (loader: %s) is not a nest member of \"\n-           \"resolved type %s (loader: %s): %s\",\n-           this->external_name(),\n-           this->class_loader_data()->loader_name_and_id(),\n-           k->external_name(),\n-           k->class_loader_data()->loader_name_and_id(),\n-           error);\n-      }\n-\n-      if (validationException != NULL && THREAD->can_call_java()) {\n-        ResourceMark rm(THREAD);\n-        Exceptions::fthrow(THREAD_AND_LOCATION,\n-                           validationException,\n-                           \"Type %s (loader: %s) is not a nest member of %s (loader: %s): %s\",\n-                           this->external_name(),\n-                           this->class_loader_data()->loader_name_and_id(),\n-                           k->external_name(),\n-                           k->class_loader_data()->loader_name_and_id(),\n-                           error\n-                           );\n-      }\n-      return NULL;\n-    } else {\n-      if (log_is_enabled(Trace, class, nestmates)) {\n-        ResourceMark rm(THREAD);\n-        log_trace(class, nestmates)(\"Type %s is not part of a nest: setting nest-host to self\",\n-                                    this->external_name());\n+      \/\/ something went wrong, so record what and log it\n+      {\n+        stringStream ss;\n+        ss.print(\"Type %s (loader: %s) is not a nest member of type %s (loader: %s): %s\",\n+                 this->external_name(),\n+                 this->class_loader_data()->loader_name_and_id(),\n+                 k->external_name(),\n+                 k->class_loader_data()->loader_name_and_id(),\n+                 error);\n+        const char* msg = ss.as_string(true \/* on C-heap *\/);\n+        constantPoolHandle cph(THREAD, constants());\n+        SystemDictionary::add_nest_host_error(cph, _nest_host_index, msg);\n+        log_trace(class, nestmates)(\"%s\", msg);\n@@ -330,2 +379,44 @@\n-      \/\/ save resolved nest-host value\n-      return (_nest_host = this);\n+  } else {\n+    log_trace(class, nestmates)(\"Type %s is not part of a nest: setting nest-host to self\",\n+                                this->external_name());\n+  }\n+\n+  \/\/ Either not in an explicit nest, or else an error occurred, so\n+  \/\/ the nest-host is set to `this`. Any thread that sees this assignment\n+  \/\/ will also see any setting of nest_host_error(), if applicable.\n+  return (_nest_host = this);\n+}\n+\n+\/\/ Dynamic nest member support: set this class's nest host to the given class.\n+\/\/ This occurs as part of the class definition, as soon as the instanceKlass\n+\/\/ has been created and doesn't require further resolution. The code:\n+\/\/    lookup().defineHiddenClass(bytes_for_X, NESTMATE);\n+\/\/ results in:\n+\/\/    class_of_X.set_nest_host(lookup().lookupClass().getNestHost())\n+\/\/ If it has an explicit _nest_host_index or _nest_members, these will be ignored.\n+\/\/ We also know the \"host\" is a valid nest-host in the same package so we can\n+\/\/ assert some of those facts.\n+void InstanceKlass::set_nest_host(InstanceKlass* host, TRAPS) {\n+  assert(is_hidden(), \"must be a hidden class\");\n+  assert(host != NULL, \"NULL nest host specified\");\n+  assert(_nest_host == NULL, \"current class has resolved nest-host\");\n+  assert(nest_host_error(THREAD) == NULL, \"unexpected nest host resolution error exists: %s\",\n+         nest_host_error(THREAD));\n+  assert((host->_nest_host == NULL && host->_nest_host_index == 0) ||\n+         (host->_nest_host == host), \"proposed host is not a valid nest-host\");\n+  \/\/ Can't assert this as package is not set yet:\n+  \/\/ assert(is_same_class_package(host), \"proposed host is in wrong package\");\n+\n+  if (log_is_enabled(Trace, class, nestmates)) {\n+    ResourceMark rm(THREAD);\n+    const char* msg = \"\";\n+    \/\/ a hidden class does not expect a statically defined nest-host\n+    if (_nest_host_index > 0) {\n+      msg = \"(the NestHost attribute in the current class is ignored)\";\n+    } else if (_nest_members != NULL && _nest_members != Universe::the_empty_short_array()) {\n+      msg = \"(the NestMembers attribute in the current class is ignored)\";\n+    }\n+    log_trace(class, nestmates)(\"Injected type %s into the nest of %s %s\",\n+                                this->external_name(),\n+                                host->external_name(),\n+                                msg);\n@@ -334,1 +425,5 @@\n-  return nest_host_k;\n+  \/\/ set dynamic nest host\n+  _nest_host = host;\n+  \/\/ Record dependency to keep nest host from being unloaded before this class.\n+  ClassLoaderData* this_key = class_loader_data();\n+  this_key->record_dependency(host);\n@@ -339,1 +434,2 @@\n-\/\/ resolved_nest_hosts\n+\/\/ resolved_nest_hosts.\n+\/\/ Any exceptions (i.e. VMEs) are propagated.\n@@ -345,3 +441,1 @@\n-  \/\/ the target class k. Resolution exceptions will be passed on by upper\n-  \/\/ layers. IncompatibleClassChangeErrors from membership validation failures\n-  \/\/ will also be passed through.\n+  \/\/ the target class k.\n@@ -349,2 +443,1 @@\n-  Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();\n-  InstanceKlass* cur_host = nest_host(icce, CHECK_false);\n+  InstanceKlass* cur_host = nest_host(CHECK_false);\n@@ -355,1 +448,1 @@\n-  Klass* k_nest_host = k->nest_host(icce, CHECK_false);\n+  Klass* k_nest_host = k->nest_host(CHECK_false);\n@@ -362,8 +455,5 @@\n-  if (log_is_enabled(Trace, class, nestmates)) {\n-    ResourceMark rm(THREAD);\n-    log_trace(class, nestmates)(\"Class %s does %shave nestmate access to %s\",\n-                                this->external_name(),\n-                                access ? \"\" : \"NOT \",\n-                                k->external_name());\n-  }\n-\n+  ResourceMark rm(THREAD);\n+  log_trace(class, nestmates)(\"Class %s does %shave nestmate access to %s\",\n+                              this->external_name(),\n+                              access ? \"\" : \"NOT \",\n+                              k->external_name());\n@@ -373,0 +463,9 @@\n+const char* InstanceKlass::nest_host_error(TRAPS) {\n+  if (_nest_host_index == 0) {\n+    return NULL;\n+  } else {\n+    constantPoolHandle cph(THREAD, constants());\n+    return SystemDictionary::find_nest_host_error(cph, (int)_nest_host_index);\n+  }\n+}\n+\n@@ -374,0 +473,1 @@\n+  bool is_hidden_or_anonymous = parser.is_hidden() || parser.is_unsafe_anonymous();\n@@ -379,1 +479,1 @@\n-                                       should_store_fingerprint(parser.is_unsafe_anonymous()));\n+                                       should_store_fingerprint(is_hidden_or_anonymous));\n@@ -399,1 +499,1 @@\n-      ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_misc_kind_other);\n+      ik = new (loader_data, size, THREAD) InstanceKlass(parser, InstanceKlass::_kind_other);\n@@ -440,1 +540,1 @@\n-  _nest_host_index(0),\n+  _permitted_subclasses(NULL),\n@@ -446,1 +546,1 @@\n-  _init_thread(NULL),\n+  _nest_host_index(0),\n@@ -448,1 +548,2 @@\n-  _reference_type(parser.reference_type())\n+  _reference_type(parser.reference_type()),\n+  _init_thread(NULL)\n@@ -453,0 +554,1 @@\n+  if (parser.is_hidden()) set_is_hidden();\n@@ -461,4 +563,0 @@\n-  if (Arguments::is_dumping_archive()) {\n-    SystemDictionaryShared::init_dumptime_info(this);\n-  }\n-\n@@ -543,1 +641,1 @@\n-  \/\/ Release C heap allocated data that this might point to, which includes\n+  \/\/ Release C heap allocated data that this points to, which includes\n@@ -545,1 +643,1 @@\n-  release_C_heap_structures();\n+  release_C_heap_structures_internal();\n@@ -625,0 +723,7 @@\n+  if (permitted_subclasses() != NULL &&\n+      permitted_subclasses() != Universe::the_empty_short_array() &&\n+      !permitted_subclasses()->is_shared()) {\n+    MetadataFactory::free_array<jushort>(loader_data, permitted_subclasses());\n+  }\n+  set_permitted_subclasses(NULL);\n+\n@@ -636,0 +741,6 @@\n+bool InstanceKlass::is_sealed() const {\n+  return _permitted_subclasses != NULL &&\n+         _permitted_subclasses != Universe::the_empty_short_array() &&\n+         _permitted_subclasses->length() > 0;\n+}\n+\n@@ -694,1 +805,1 @@\n-  java_lang_Class::set_init_lock(java_mirror(), NULL);\n+  java_lang_Class::clear_init_lock(java_mirror());\n@@ -783,1 +894,1 @@\n-  if (DumpSharedSpaces && is_in_error_state()) {\n+  if (DumpSharedSpaces && SystemDictionaryShared::has_class_failed_verification(this)) {\n@@ -889,5 +1000,9 @@\n-      \/\/ initialize_vtable and initialize_itable need to be rerun for\n-      \/\/ a shared class if the class is not loaded by the NULL classloader.\n-      ClassLoaderData * loader_data = class_loader_data();\n-      if (!(is_shared() &&\n-            loader_data->is_the_null_class_loader_data())) {\n+      \/\/ initialize_vtable and initialize_itable need to be rerun\n+      \/\/ for a shared class if\n+      \/\/ 1) the class is loaded by custom class loader or\n+      \/\/ 2) the class is loaded by built-in class loader but failed to add archived loader constraints\n+      bool need_init_table = true;\n+      if (is_shared() && SystemDictionaryShared::check_linking_constraints(this, THREAD)) {\n+        need_init_table = false;\n+      }\n+      if (need_init_table) {\n@@ -898,5 +1013,3 @@\n-      else {\n-        vtable().verify(tty, true);\n-        \/\/ In case itable verification is ever added.\n-        \/\/ itable().verify(tty, true);\n-      }\n+      vtable().verify(tty, true);\n+      \/\/ In case itable verification is ever added.\n+      \/\/ itable().verify(tty, true);\n@@ -1180,1 +1293,3 @@\n-  assert_lock_strong(Compile_lock);\n+  if (Universe::is_fully_initialized()) {\n+    assert_lock_strong(Compile_lock);\n+  }\n@@ -1353,1 +1468,1 @@\n-        Klass*    k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n+        ObjArrayKlass* k = ObjArrayKlass::allocate_objArray_klass(class_loader_data(), 1, this, CHECK_NULL);\n@@ -1360,1 +1475,1 @@\n-  ObjArrayKlass* oak = (ObjArrayKlass*)array_klasses();\n+  ObjArrayKlass* oak = array_klasses();\n@@ -1599,1 +1714,1 @@\n-    ArrayKlass::cast(array_klasses())->array_klasses_do(f, THREAD);\n+    array_klasses()->array_klasses_do(f, THREAD);\n@@ -1604,1 +1719,1 @@\n-    ArrayKlass::cast(array_klasses())->array_klasses_do(f);\n+    array_klasses()->array_klasses_do(f);\n@@ -2301,1 +2416,1 @@\n-bool InstanceKlass::should_store_fingerprint(bool is_unsafe_anonymous) {\n+bool InstanceKlass::should_store_fingerprint(bool is_hidden_or_anonymous) {\n@@ -2312,2 +2427,2 @@\n-  if (UseAOT && is_unsafe_anonymous) {\n-    \/\/ (3) We are using AOT code from a shared library and see an unsafe anonymous class\n+  if (UseAOT && is_hidden_or_anonymous) {\n+    \/\/ (3) We are using AOT code from a shared library and see a hidden or unsafe anonymous class\n@@ -2361,1 +2476,0 @@\n-  it->push(&_array_name);\n@@ -2392,0 +2506,1 @@\n+  it->push(&_permitted_subclasses);\n@@ -2398,1 +2513,1 @@\n-  if (is_in_error_state()) {\n+  if (SystemDictionaryShared::has_class_failed_verification(this)) {\n@@ -2401,3 +2516,1 @@\n-    \/\/ Check in_error state first because in_error is > linked state, so\n-    \/\/ is_linked() is true.\n-    \/\/ If there's a linking error, there is nothing else to remove.\n+    \/\/ If the class has failed verification, there is nothing else to remove.\n@@ -2460,1 +2573,2 @@\n-void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain, TRAPS) {\n+void InstanceKlass::restore_unshareable_info(ClassLoaderData* loader_data, Handle protection_domain,\n+                                             PackageEntry* pkg_entry, TRAPS) {\n@@ -2465,1 +2579,1 @@\n-  set_package(loader_data, CHECK);\n+  set_package(loader_data, pkg_entry, CHECK);\n@@ -2498,33 +2612,1 @@\n-\/\/ returns true IFF is_in_error_state() has been changed as a result of this call.\n-bool InstanceKlass::check_sharing_error_state() {\n-  assert(DumpSharedSpaces, \"should only be called during dumping\");\n-  bool old_state = is_in_error_state();\n-\n-  if (!is_in_error_state()) {\n-    bool bad = false;\n-    for (InstanceKlass* sup = java_super(); sup; sup = sup->java_super()) {\n-      if (sup->is_in_error_state()) {\n-        bad = true;\n-        break;\n-      }\n-    }\n-    if (!bad) {\n-      Array<InstanceKlass*>* interfaces = transitive_interfaces();\n-      for (int i = 0; i < interfaces->length(); i++) {\n-        InstanceKlass* iface = interfaces->at(i);\n-        if (iface->is_in_error_state()) {\n-          bad = true;\n-          break;\n-        }\n-      }\n-    }\n-\n-    if (bad) {\n-      set_in_error_state();\n-    }\n-  }\n-\n-  return (old_state != is_in_error_state());\n-}\n-\n-void InstanceKlass::set_class_loader_type(s2 loader_type) {\n+void InstanceKlass::set_shared_class_loader_type(s2 loader_type) {\n@@ -2547,0 +2629,13 @@\n+void InstanceKlass::assign_class_loader_type() {\n+  ClassLoaderData *cld = class_loader_data();\n+  if (cld->is_boot_class_loader_data()) {\n+    set_shared_class_loader_type(ClassLoader::BOOT_LOADER);\n+  }\n+  else if (cld->is_platform_class_loader_data()) {\n+    set_shared_class_loader_type(ClassLoader::PLATFORM_LOADER);\n+  }\n+  else if (cld->is_system_class_loader_data()) {\n+    set_shared_class_loader_type(ClassLoader::APP_LOADER);\n+  }\n+}\n+\n@@ -2589,1 +2684,2 @@\n-void InstanceKlass::release_C_heap_structures(InstanceKlass* ik) {\n+void InstanceKlass::release_C_heap_structures() {\n+\n@@ -2591,2 +2687,2 @@\n-  ik->release_C_heap_structures();\n-  ik->constants()->release_C_heap_structures();\n+  release_C_heap_structures_internal();\n+  constants()->release_C_heap_structures();\n@@ -2595,2 +2691,1 @@\n-  ik->methods_do(method_release_C_heap_structures);\n-\n+  methods_do(method_release_C_heap_structures);\n@@ -2599,1 +2694,3 @@\n-void InstanceKlass::release_C_heap_structures() {\n+void InstanceKlass::release_C_heap_structures_internal() {\n+  Klass::release_C_heap_structures();\n+\n@@ -2637,5 +2734,0 @@\n-  \/\/ Decrement symbol reference counts associated with the unloaded class.\n-  if (_name != NULL) _name->decrement_refcount();\n-  \/\/ unreference array name derived from this class name (arrays of an unloaded\n-  \/\/ class can't be referenced anymore).\n-  if (_array_name != NULL)  _array_name->decrement_refcount();\n@@ -2689,0 +2781,9 @@\n+  if (is_hidden()) { \/\/ Replace the last '+' with a '.'.\n+    for (int index = (int)src_length; index > 0; index--) {\n+      if (dest[index] == '+') {\n+        dest[index] = JVM_SIGNATURE_DOT;\n+        break;\n+      }\n+    }\n+  }\n+\n@@ -2700,18 +2801,0 @@\n-\/\/ Used to obtain the package name from a fully qualified class name.\n-Symbol* InstanceKlass::package_from_name(const Symbol* name, TRAPS) {\n-  if (name == NULL) {\n-    return NULL;\n-  } else {\n-    if (name->utf8_length() <= 0) {\n-      return NULL;\n-    }\n-    ResourceMark rm(THREAD);\n-    const char* package_name = ClassLoader::package_from_name((const char*) name->as_C_string());\n-    if (package_name == NULL) {\n-      return NULL;\n-    }\n-    Symbol* pkg_name = SymbolTable::new_symbol(package_name);\n-    return pkg_name;\n-  }\n-}\n-\n@@ -2725,0 +2808,19 @@\n+  if (is_hidden() &&\n+      in_unnamed_package() &&\n+      class_loader_data()->has_class_mirror_holder()) {\n+    \/\/ For a non-strong hidden class defined to an unnamed package,\n+    \/\/ its (class held) CLD will not have an unnamed module created for it.\n+    \/\/ Two choices to find the correct ModuleEntry:\n+    \/\/ 1. If hidden class is within a nest, use nest host's module\n+    \/\/ 2. Find the unnamed module off from the class loader\n+    \/\/ For now option #2 is used since a nest host is not set until\n+    \/\/ after the instance class is created in jvm_lookup_define_class().\n+    if (class_loader_data()->is_boot_class_loader_data()) {\n+      return ClassLoaderData::the_null_class_loader_data()->unnamed_module();\n+    } else {\n+      oop module = java_lang_ClassLoader::unnamedModule(class_loader_data()->class_loader());\n+      assert(java_lang_Module::is_instance(module), \"Not an instance of java.lang.Module\");\n+      return java_lang_Module::module_entry(module);\n+    }\n+  }\n+\n@@ -2734,1 +2836,1 @@\n-void InstanceKlass::set_package(ClassLoaderData* loader_data, TRAPS) {\n+void InstanceKlass::set_package(ClassLoaderData* loader_data, PackageEntry* pkg_entry, TRAPS) {\n@@ -2737,1 +2839,4 @@\n-  check_prohibited_package(name(), loader_data, CHECK);\n+  \/\/ not needed for shared class since CDS does not archive prohibited classes.\n+  if (!is_shared()) {\n+    check_prohibited_package(name(), loader_data, CHECK);\n+  }\n@@ -2739,1 +2844,1 @@\n-  TempNewSymbol pkg_name = package_from_name(name(), CHECK);\n+  TempNewSymbol pkg_name = pkg_entry != NULL ? pkg_entry->name() : ClassLoader::package_from_class_name(name());\n@@ -2744,1 +2849,1 @@\n-    _package_entry = loader_data->packages()->lookup_only(pkg_name);\n+    _package_entry = pkg_entry != NULL ? pkg_entry : loader_data->packages()->lookup_only(pkg_name);\n@@ -2750,1 +2855,0 @@\n-      ResourceMark rm(THREAD);\n@@ -2766,0 +2870,1 @@\n+      DEBUG_ONLY(ResourceMark rm(THREAD));\n@@ -2788,0 +2893,17 @@\n+\/\/ Function set_classpath_index checks if the package of the InstanceKlass is in the\n+\/\/ boot loader's package entry table.  If so, then it sets the classpath_index\n+\/\/ in the package entry record.\n+\/\/\n+\/\/ The classpath_index field is used to find the entry on the boot loader class\n+\/\/ path for packages with classes loaded by the boot loader from -Xbootclasspath\/a\n+\/\/ in an unnamed module.  It is also used to indicate (for all packages whose\n+\/\/ classes are loaded by the boot loader) that at least one of the package's\n+\/\/ classes has been loaded.\n+void InstanceKlass::set_classpath_index(s2 path_index, TRAPS) {\n+  if (_package_entry != NULL) {\n+    DEBUG_ONLY(PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()->packages();)\n+    assert(pkg_entry_tbl->lookup_only(_package_entry->name()) == _package_entry, \"Should be same\");\n+    assert(path_index != -1, \"Unexpected classpath_index\");\n+    _package_entry->set_classpath_index(path_index);\n+  }\n+}\n@@ -2835,2 +2957,1 @@\n-    const char* other_pkg =\n-      ClassLoader::package_from_name((const char*) other_class_name->as_C_string(), &bad_class_name);\n+    TempNewSymbol other_pkg = ClassLoader::package_from_class_name(other_class_name, &bad_class_name);\n@@ -2840,2 +2961,2 @@\n-    \/\/ Check that package_from_name() returns NULL, not \"\", if there is no package.\n-    assert(other_pkg == NULL || strlen(other_pkg) > 0, \"package name is empty string\");\n+    \/\/ Check that package_from_class_name() returns NULL, not \"\", if there is no package.\n+    assert(other_pkg == NULL || other_pkg->utf8_length() > 0, \"package name is empty string\");\n@@ -2849,1 +2970,1 @@\n-      return (const char*)this_package_name == other_pkg;\n+      return this_package_name == other_pkg;\n@@ -2853,1 +2974,1 @@\n-    return this_package_name->equals(other_pkg);\n+    return this_package_name->fast_compare(other_pkg) == 0;\n@@ -2887,1 +3008,1 @@\n-      TempNewSymbol pkg_name = InstanceKlass::package_from_name(class_name, CHECK);\n+      TempNewSymbol pkg_name = ClassLoader::package_from_class_name(class_name);\n@@ -2936,1 +3057,1 @@\n-      \/\/ It may be unsafe anonymous; try for that.\n+      \/\/ It may be a local or anonymous class; try for that.\n@@ -3072,3 +3193,3 @@\n-      nmethod * prev = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), n->comp_level(), true);\n-      assert(prev == NULL || !prev->is_in_use(),\n-      \"redundunt OSR recompilation detected. memory leak in CodeCache!\");\n+    nmethod* prev = lookup_osr_nmethod(n->method(), n->osr_entry_bci(), n->comp_level(), true);\n+    assert(prev == NULL || !prev->is_in_use() COMPILER2_PRESENT(|| StressRecompilation),\n+           \"redundant OSR recompilation detected. memory leak in CodeCache!\");\n@@ -3327,0 +3448,1 @@\n+  st->print(BULLET\"permitted subclasses:     \"); permitted_subclasses()->print_value_on(st);     st->cr();\n@@ -3697,3 +3819,0 @@\n-  if (array_klasses() != NULL) {\n-    guarantee(array_klasses()->is_klass(), \"should be klass\");\n-  }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":351,"deletions":232,"binary":false,"changes":583,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"classfile\/classLoaderData.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"memory\/dynamicArchive.hpp\"\n@@ -77,0 +79,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -98,0 +101,3 @@\n+#if INCLUDE_JFR\n+#include \"jfr\/jfr.hpp\"\n+#endif\n@@ -474,0 +480,4 @@\n+  \/\/ Link all classes for dynamic CDS dumping before vm exit.\n+  if (DynamicDumpSharedSpaces) {\n+    MetaspaceShared::link_and_cleanup_shared_classes(THREAD);\n+  }\n@@ -491,0 +501,5 @@\n+    if (AsyncDeflateIdleMonitors) {\n+      \/\/ AsyncDeflateIdleMonitors needs to know when System.gc() is\n+      \/\/ called so any special deflation can be done at a safepoint.\n+      ObjectSynchronizer::set_is_special_deflation_requested(true);\n+    }\n@@ -563,1 +578,1 @@\n-    oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_0);\n+    oop result = java_lang_String::create_oop_from_str(ss.base(), CHECK_NULL);\n@@ -811,1 +826,1 @@\n-  \/\/ Java libraries should ensure that name is never null...\n+  \/\/ Java libraries should ensure that name is never null or illegal.\n@@ -817,0 +832,1 @@\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false), \"illegal UTF name\");\n@@ -835,7 +851,3 @@\n-  \/\/ Java libraries should ensure that name is never null...\n-  if (name == NULL || (int)strlen(name) > Symbol::max_length()) {\n-    \/\/ It's impossible to create this class;  the name cannot fit\n-    \/\/ into the constant pool.\n-    THROW_MSG_0(vmSymbols::java_lang_ClassNotFoundException(), name);\n-  }\n-  TempNewSymbol h_name = SymbolTable::new_symbol(name);\n+  TempNewSymbol h_name =\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),\n+                                           CHECK_NULL);\n@@ -871,14 +883,3 @@\n-  if (name == NULL) {\n-    THROW_MSG_0(vmSymbols::java_lang_NoClassDefFoundError(), \"No class name given\");\n-  }\n-  if ((int)strlen(name) > Symbol::max_length()) {\n-    \/\/ It's impossible to create this class;  the name cannot fit\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION,\n-                       vmSymbols::java_lang_NoClassDefFoundError(),\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n-    return 0;\n-  }\n-  TempNewSymbol h_name = SymbolTable::new_symbol(name);\n+  TempNewSymbol h_name =\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_ClassNotFoundException(),\n+                                           CHECK_NULL);\n@@ -950,17 +951,4 @@\n-  \/\/ Since exceptions can be thrown, class initialization can take place\n-  \/\/ if name is NULL no check for class name in .class stream has to be made.\n-  TempNewSymbol class_name = NULL;\n-  if (name != NULL) {\n-    const int str_len = (int)strlen(name);\n-    if (str_len > Symbol::max_length()) {\n-      \/\/ It's impossible to create this class;  the name cannot fit\n-      \/\/ into the constant pool.\n-      Exceptions::fthrow(THREAD_AND_LOCATION,\n-                         vmSymbols::java_lang_NoClassDefFoundError(),\n-                         \"Class name exceeds maximum length of %d: %s\",\n-                         Symbol::max_length(),\n-                         name);\n-      return 0;\n-    }\n-    class_name = SymbolTable::new_symbol(name, str_len);\n-  }\n+  \/\/ Class resolution will get the class name from the .class stream if the name is null.\n+  TempNewSymbol class_name = name == NULL ? NULL :\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),\n+                                           CHECK_NULL);\n@@ -990,0 +978,134 @@\n+enum {\n+  NESTMATE              = java_lang_invoke_MemberName::MN_NESTMATE_CLASS,\n+  HIDDEN_CLASS          = java_lang_invoke_MemberName::MN_HIDDEN_CLASS,\n+  STRONG_LOADER_LINK    = java_lang_invoke_MemberName::MN_STRONG_LOADER_LINK,\n+  ACCESS_VM_ANNOTATIONS = java_lang_invoke_MemberName::MN_ACCESS_VM_ANNOTATIONS\n+};\n+\n+\/*\n+ * Define a class with the specified flags that indicates if it's a nestmate,\n+ * hidden, or strongly referenced from class loader.\n+ *\/\n+static jclass jvm_lookup_define_class(JNIEnv *env, jclass lookup, const char *name,\n+                                      const jbyte *buf, jsize len, jobject pd,\n+                                      jboolean init, int flags, jobject classData, TRAPS) {\n+  assert(THREAD->is_Java_thread(), \"must be a JavaThread\");\n+  JavaThread* jt = (JavaThread*) THREAD;\n+  ResourceMark rm(THREAD);\n+\n+  Klass* lookup_k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(lookup));\n+  \/\/ Lookup class must be a non-null instance\n+  if (lookup_k == NULL) {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class is null\");\n+  }\n+  assert(lookup_k->is_instance_klass(), \"Lookup class must be an instance klass\");\n+\n+  Handle class_loader (THREAD, lookup_k->class_loader());\n+\n+  bool is_nestmate = (flags & NESTMATE) == NESTMATE;\n+  bool is_hidden = (flags & HIDDEN_CLASS) == HIDDEN_CLASS;\n+  bool is_strong = (flags & STRONG_LOADER_LINK) == STRONG_LOADER_LINK;\n+  bool vm_annotations = (flags & ACCESS_VM_ANNOTATIONS) == ACCESS_VM_ANNOTATIONS;\n+\n+  InstanceKlass* host_class = NULL;\n+  if (is_nestmate) {\n+    host_class = InstanceKlass::cast(lookup_k)->nest_host(CHECK_NULL);\n+  }\n+\n+  log_info(class, nestmates)(\"LookupDefineClass: %s - %s%s, %s, %s, %s\",\n+                             name,\n+                             is_nestmate ? \"with dynamic nest-host \" : \"non-nestmate\",\n+                             is_nestmate ? host_class->external_name() : \"\",\n+                             is_hidden ? \"hidden\" : \"not hidden\",\n+                             is_strong ? \"strong\" : \"weak\",\n+                             vm_annotations ? \"with vm annotations\" : \"without vm annotation\");\n+\n+  if (!is_hidden) {\n+    \/\/ classData is only applicable for hidden classes\n+    if (classData != NULL) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"classData is only applicable for hidden classes\");\n+    }\n+    if (is_nestmate) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"dynamic nestmate is only applicable for hidden classes\");\n+    }\n+    if (!is_strong) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"an ordinary class must be strongly referenced by its defining loader\");\n+    }\n+    if (vm_annotations) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"vm annotations only allowed for hidden classes\");\n+    }\n+    if (flags != STRONG_LOADER_LINK) {\n+      THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n+                  err_msg(\"invalid flag 0x%x\", flags));\n+    }\n+  }\n+\n+  \/\/ Class resolution will get the class name from the .class stream if the name is null.\n+  TempNewSymbol class_name = name == NULL ? NULL :\n+       SystemDictionary::class_name_symbol(name, vmSymbols::java_lang_NoClassDefFoundError(),\n+                                           CHECK_NULL);\n+\n+  Handle protection_domain (THREAD, JNIHandles::resolve(pd));\n+  const char* source = is_nestmate ? host_class->external_name() : \"__JVM_LookupDefineClass__\";\n+  ClassFileStream st((u1*)buf, len, source, ClassFileStream::verify);\n+\n+  Klass* defined_k;\n+  InstanceKlass* ik = NULL;\n+  if (!is_hidden) {\n+    defined_k = SystemDictionary::resolve_from_stream(class_name,\n+                                                      class_loader,\n+                                                      protection_domain,\n+                                                      &st,\n+                                                      CHECK_NULL);\n+\n+    if (log_is_enabled(Debug, class, resolve) && defined_k != NULL) {\n+      trace_class_resolution(defined_k);\n+    }\n+    ik = InstanceKlass::cast(defined_k);\n+  } else { \/\/ hidden\n+    Handle classData_h(THREAD, JNIHandles::resolve(classData));\n+    ClassLoadInfo cl_info(protection_domain,\n+                          NULL, \/\/ unsafe_anonymous_host\n+                          NULL, \/\/ cp_patches\n+                          host_class,\n+                          classData_h,\n+                          is_hidden,\n+                          is_strong,\n+                          vm_annotations);\n+    defined_k = SystemDictionary::parse_stream(class_name,\n+                                               class_loader,\n+                                               &st,\n+                                               cl_info,\n+                                               CHECK_NULL);\n+    if (defined_k == NULL) {\n+      THROW_MSG_0(vmSymbols::java_lang_Error(), \"Failure to define a hidden class\");\n+    }\n+\n+    ik = InstanceKlass::cast(defined_k);\n+\n+    \/\/ The hidden class loader data has been artificially been kept alive to\n+    \/\/ this point. The mirror and any instances of this class have to keep\n+    \/\/ it alive afterwards.\n+    ik->class_loader_data()->dec_keep_alive();\n+\n+    if (is_nestmate && log_is_enabled(Debug, class, nestmates)) {\n+      ModuleEntry* module = ik->module();\n+      const char * module_name = module->is_named() ? module->name()->as_C_string() : UNNAMED_MODULE;\n+      log_debug(class, nestmates)(\"Dynamic nestmate: %s\/%s, nest_host %s, %s\",\n+                                  module_name,\n+                                  ik->external_name(),\n+                                  host_class->external_name(),\n+                                  ik->is_hidden() ? \"is hidden\" : \"is not hidden\");\n+    }\n+  }\n+  assert(Reflection::is_same_class_package(lookup_k, defined_k),\n+         \"lookup class and defined class are in different packages\");\n+\n+  if (init) {\n+    ik->initialize(CHECK_NULL);\n+  } else {\n+    ik->link_class(CHECK_NULL);\n+  }\n+\n+  return (jclass) JNIHandles::make_local(env, defined_k->java_mirror());\n+}\n@@ -997,0 +1119,23 @@\n+\/*\n+ * Define a class with the specified lookup class.\n+ *  lookup:  Lookup class\n+ *  name:    the name of the class\n+ *  buf:     class bytes\n+ *  len:     length of class bytes\n+ *  pd:      protection domain\n+ *  init:    initialize the class\n+ *  flags:   properties of the class\n+ *  classData: private static pre-initialized field\n+ *\/\n+JVM_ENTRY(jclass, JVM_LookupDefineClass(JNIEnv *env, jclass lookup, const char *name, const jbyte *buf,\n+          jsize len, jobject pd, jboolean initialize, int flags, jobject classData))\n+  JVMWrapper(\"JVM_LookupDefineClass\");\n+\n+  if (lookup == NULL) {\n+    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), \"Lookup class is null\");\n+  }\n+\n+  assert(buf != NULL, \"buf must not be NULL\");\n+\n+  return jvm_lookup_define_class(env, lookup, name, buf, len, pd, initialize, flags, classData, THREAD);\n+JVM_END\n@@ -1059,1 +1204,1 @@\n-                                 jstring location, const char* const* packages, jsize num_packages))\n+                                 jstring location, jobjectArray packages))\n@@ -1061,1 +1206,1 @@\n-  Modules::define_module(module, is_open, version, location, packages, num_packages, CHECK);\n+  Modules::define_module(module, is_open, version, location, packages, CHECK);\n@@ -1069,1 +1214,1 @@\n-JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, const char* package, jobject to_module))\n+JVM_ENTRY(void, JVM_AddModuleExports(JNIEnv *env, jobject from_module, jstring package, jobject to_module))\n@@ -1074,1 +1219,1 @@\n-JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, const char* package))\n+JVM_ENTRY(void, JVM_AddModuleExportsToAllUnnamed(JNIEnv *env, jobject from_module, jstring package))\n@@ -1079,1 +1224,1 @@\n-JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, const char* package))\n+JVM_ENTRY(void, JVM_AddModuleExportsToAll(JNIEnv *env, jobject from_module, jstring package))\n@@ -1159,0 +1304,9 @@\n+JVM_ENTRY(jboolean, JVM_IsHiddenClass(JNIEnv *env, jclass cls))\n+  JVMWrapper(\"JVM_IsHiddenClass\");\n+  oop mirror = JNIHandles::resolve_non_null(cls);\n+  if (java_lang_Class::is_primitive(mirror)) {\n+    return JNI_FALSE;\n+  }\n+  Klass* k = java_lang_Class::as_Klass(mirror);\n+  return k->is_hidden();\n+JVM_END\n@@ -1426,1 +1580,1 @@\n-  if (!inner_is_member)  return NULL;     \/\/ an anonymous class (inside a method)\n+  if (!inner_is_member)  return NULL;     \/\/ a hidden or unsafe anonymous class (inside a method)\n@@ -1876,2 +2030,1 @@\n-  \/\/ Don't post exceptions if validation fails\n-  InstanceKlass* host = ck->nest_host(NULL, THREAD);\n+  InstanceKlass* host = ck->nest_host(THREAD);\n@@ -1887,0 +2040,1 @@\n+  ResourceMark rm(THREAD);\n@@ -1890,3 +2044,1 @@\n-  \/\/ Get the nest host for this nest - throw ICCE if validation fails\n-  Symbol* icce = vmSymbols::java_lang_IncompatibleClassChangeError();\n-  InstanceKlass* host = ck->nest_host(icce, CHECK_NULL);\n+  InstanceKlass* host = ck->nest_host(THREAD);\n@@ -1894,0 +2046,2 @@\n+  log_trace(class, nestmates)(\"Calling GetNestMembers for type %s with nest-host %s\",\n+                              ck->external_name(), host->external_name());\n@@ -1898,0 +2052,3 @@\n+\n+    log_trace(class, nestmates)(\" - host has %d listed nest members\", length);\n+\n@@ -1901,1 +2058,1 @@\n-    objArrayHandle result (THREAD, r);\n+    objArrayHandle result(THREAD, r);\n@@ -1904,35 +2061,46 @@\n-      int i;\n-      for (i = 0; i < length; i++) {\n-         int cp_index = members->at(i);\n-         Klass* k = host->constants()->klass_at(cp_index, CHECK_NULL);\n-         if (k->is_instance_klass()) {\n-           InstanceKlass* nest_host_k =\n-             InstanceKlass::cast(k)->nest_host(icce, CHECK_NULL);\n-           if (nest_host_k == host) {\n-             result->obj_at_put(i+1, k->java_mirror());\n-           }\n-           else {\n-             \/\/ k's nest host is legal but it isn't our host so\n-             \/\/ throw ICCE\n-             ResourceMark rm(THREAD);\n-             Exceptions::fthrow(THREAD_AND_LOCATION,\n-                                icce,\n-                                \"Nest member %s in %s declares a different nest host of %s\",\n-                                k->external_name(),\n-                                host->external_name(),\n-                                nest_host_k->external_name()\n-                           );\n-             return NULL;\n-           }\n-         }\n-         else {\n-           \/\/ we have a bad nest member entry - throw ICCE\n-           ResourceMark rm(THREAD);\n-           Exceptions::fthrow(THREAD_AND_LOCATION,\n-                              icce,\n-                              \"Class %s can not be a nest member of %s\",\n-                              k->external_name(),\n-                              host->external_name()\n-                              );\n-           return NULL;\n-         }\n+      int count = 0;\n+      for (int i = 0; i < length; i++) {\n+        int cp_index = members->at(i);\n+        Klass* k = host->constants()->klass_at(cp_index, THREAD);\n+        if (HAS_PENDING_EXCEPTION) {\n+          if (PENDING_EXCEPTION->is_a(SystemDictionary::VirtualMachineError_klass())) {\n+            return NULL; \/\/ propagate VMEs\n+          }\n+          if (log_is_enabled(Trace, class, nestmates)) {\n+            stringStream ss;\n+            char* target_member_class = host->constants()->klass_name_at(cp_index)->as_C_string();\n+            ss.print(\" - resolution of nest member %s failed: \", target_member_class);\n+            java_lang_Throwable::print(PENDING_EXCEPTION, &ss);\n+            log_trace(class, nestmates)(\"%s\", ss.as_string());\n+          }\n+          CLEAR_PENDING_EXCEPTION;\n+          continue;\n+        }\n+        if (k->is_instance_klass()) {\n+          InstanceKlass* ik = InstanceKlass::cast(k);\n+          InstanceKlass* nest_host_k = ik->nest_host(CHECK_NULL);\n+          if (nest_host_k == host) {\n+            result->obj_at_put(count+1, k->java_mirror());\n+            count++;\n+            log_trace(class, nestmates)(\" - [%d] = %s\", count, ik->external_name());\n+          } else {\n+            log_trace(class, nestmates)(\" - skipping member %s with different host %s\",\n+                                        ik->external_name(), nest_host_k->external_name());\n+          }\n+        } else {\n+          log_trace(class, nestmates)(\" - skipping member %s that is not an instance class\",\n+                                      k->external_name());\n+        }\n+      }\n+      if (count < length) {\n+        \/\/ we had invalid entries so we need to compact the array\n+        log_trace(class, nestmates)(\" - compacting array from length %d to %d\",\n+                                    length + 1, count + 1);\n+\n+        objArrayOop r2 = oopFactory::new_objArray(SystemDictionary::Class_klass(),\n+                                                  count + 1, CHECK_NULL);\n+        objArrayHandle result2(THREAD, r2);\n+        for (int i = 0; i < count + 1; i++) {\n+          result2->obj_at_put(i, result->obj_at(i));\n+        }\n+        return (jobjectArray)JNIHandles::make_local(THREAD, result2());\n@@ -1942,1 +2110,28 @@\n-      assert(host == ck, \"must be singleton nest\");\n+      assert(host == ck || ck->is_hidden(), \"must be singleton nest or dynamic nestmate\");\n+    }\n+    return (jobjectArray)JNIHandles::make_local(THREAD, result());\n+  }\n+}\n+JVM_END\n+\n+JVM_ENTRY(jobjectArray, JVM_GetPermittedSubclasses(JNIEnv* env, jclass current))\n+{\n+  JVMWrapper(\"JVM_GetPermittedSubclasses\");\n+  assert(!java_lang_Class::is_primitive(JNIHandles::resolve_non_null(current)), \"should not be\");\n+  Klass* c = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(current));\n+  assert(c->is_instance_klass(), \"must be\");\n+  InstanceKlass* ik = InstanceKlass::cast(c);\n+  {\n+    JvmtiVMObjectAllocEventCollector oam;\n+    Array<u2>* subclasses = ik->permitted_subclasses();\n+    int length = subclasses == NULL ? 0 : subclasses->length();\n+    objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),\n+                                             length, CHECK_NULL);\n+    objArrayHandle result(THREAD, r);\n+    for (int i = 0; i < length; i++) {\n+      int cp_index = subclasses->at(i);\n+      \/\/ This returns <package-name>\/<class-name>.\n+      Symbol* klass_name = ik->constants()->klass_name_at(cp_index);\n+      assert(klass_name != NULL, \"Unexpected null klass_name\");\n+      Handle perm_subtype_h = java_lang_String::create_from_symbol(klass_name, CHECK_NULL);\n+      result->obj_at_put(i, perm_subtype_h());\n@@ -2888,0 +3083,9 @@\n+#if INCLUDE_JFR\n+  if (Jfr::is_recording() && EventThreadStart::is_enabled() &&\n+      EventThreadStart::is_stacktrace_enabled()) {\n+    JfrThreadLocal* tl = native_thread->jfr_thread_local();\n+    \/\/ skip Thread.start() and Thread.start0()\n+    tl->set_cached_stack_trace_id(JfrStackTraceRepository::record(thread, 2));\n+  }\n+#endif\n+\n@@ -3545,0 +3749,135 @@\n+JVM_ENTRY(void, JVM_RegisterLambdaProxyClassForArchiving(JNIEnv* env,\n+                                              jclass caller,\n+                                              jstring invokedName,\n+                                              jobject invokedType,\n+                                              jobject methodType,\n+                                              jobject implMethodMember,\n+                                              jobject instantiatedMethodType,\n+                                              jclass lambdaProxyClass))\n+  JVMWrapper(\"JVM_RegisterLambdaProxyClassForArchiving\");\n+#if INCLUDE_CDS\n+  if (!DynamicDumpSharedSpaces) {\n+    return;\n+  }\n+\n+  Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));\n+  InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);\n+  if (caller_ik->is_hidden() || caller_ik->is_unsafe_anonymous()) {\n+    \/\/ VM anonymous classes and hidden classes not of type lambda proxy classes are currently not being archived.\n+    \/\/ If the caller_ik is of one of the above types, the corresponding lambda proxy class won't be\n+    \/\/ registered for archiving.\n+    return;\n+  }\n+  Klass* lambda_k = java_lang_Class::as_Klass(JNIHandles::resolve(lambdaProxyClass));\n+  InstanceKlass* lambda_ik = InstanceKlass::cast(lambda_k);\n+  assert(lambda_ik->is_hidden(), \"must be a hidden class\");\n+  assert(!lambda_ik->is_non_strong_hidden(), \"expected a strong hidden class\");\n+\n+  Symbol* invoked_name = NULL;\n+  if (invokedName != NULL) {\n+    invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n+  }\n+  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n+  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+\n+  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n+  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+\n+  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n+  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+\n+  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n+  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+\n+  SystemDictionaryShared::add_lambda_proxy_class(caller_ik, lambda_ik, invoked_name, invoked_type,\n+                                                 method_type, m, instantiated_method_type);\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(jclass, JVM_LookupLambdaProxyClassFromArchive(JNIEnv* env,\n+                                                        jclass caller,\n+                                                        jstring invokedName,\n+                                                        jobject invokedType,\n+                                                        jobject methodType,\n+                                                        jobject implMethodMember,\n+                                                        jobject instantiatedMethodType,\n+                                                        jboolean initialize))\n+  JVMWrapper(\"JVM_LookupLambdaProxyClassFromArchive\");\n+#if INCLUDE_CDS\n+  if (!DynamicArchive::is_mapped()) {\n+    return NULL;\n+  }\n+\n+  if (invokedName == NULL || invokedType == NULL || methodType == NULL ||\n+      implMethodMember == NULL || instantiatedMethodType == NULL) {\n+    THROW_(vmSymbols::java_lang_NullPointerException(), NULL);\n+  }\n+\n+  Klass* caller_k = java_lang_Class::as_Klass(JNIHandles::resolve(caller));\n+  InstanceKlass* caller_ik = InstanceKlass::cast(caller_k);\n+  if (!caller_ik->is_shared()) {\n+    \/\/ there won't be a shared lambda class if the caller_ik is not in the shared archive.\n+    return NULL;\n+  }\n+\n+  Symbol* invoked_name = java_lang_String::as_symbol(JNIHandles::resolve_non_null(invokedName));\n+  Handle invoked_type_oop(THREAD, JNIHandles::resolve_non_null(invokedType));\n+  Symbol* invoked_type = java_lang_invoke_MethodType::as_signature(invoked_type_oop(), true);\n+\n+  Handle method_type_oop(THREAD, JNIHandles::resolve_non_null(methodType));\n+  Symbol* method_type = java_lang_invoke_MethodType::as_signature(method_type_oop(), true);\n+\n+  Handle impl_method_member_oop(THREAD, JNIHandles::resolve_non_null(implMethodMember));\n+  assert(java_lang_invoke_MemberName::is_method(impl_method_member_oop()), \"must be\");\n+  Method* m = java_lang_invoke_MemberName::vmtarget(impl_method_member_oop());\n+\n+  Handle instantiated_method_type_oop(THREAD, JNIHandles::resolve_non_null(instantiatedMethodType));\n+  Symbol* instantiated_method_type = java_lang_invoke_MethodType::as_signature(instantiated_method_type_oop(), true);\n+\n+  InstanceKlass* lambda_ik = SystemDictionaryShared::get_shared_lambda_proxy_class(caller_ik, invoked_name, invoked_type,\n+                                                                                   method_type, m, instantiated_method_type);\n+  jclass jcls = NULL;\n+  if (lambda_ik != NULL) {\n+    InstanceKlass* loaded_lambda = SystemDictionaryShared::prepare_shared_lambda_proxy_class(lambda_ik, caller_ik, initialize, THREAD);\n+    jcls = loaded_lambda == NULL ? NULL : (jclass) JNIHandles::make_local(env, loaded_lambda->java_mirror());\n+  }\n+  return jcls;\n+#else\n+  return NULL;\n+#endif \/\/ INCLUDE_CDS\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsCDSDumpingEnabled(JNIEnv* env))\n+    JVMWrapper(\"JVM_IsCDSDumpingEnable\");\n+    return DynamicDumpSharedSpaces;\n+JVM_END\n+\n+JVM_ENTRY(jboolean, JVM_IsCDSSharingEnabled(JNIEnv* env))\n+    JVMWrapper(\"JVM_IsCDSSharingEnable\");\n+    return UseSharedSpaces;\n+JVM_END\n+\n+JVM_ENTRY_NO_ENV(jlong, JVM_GetRandomSeedForCDSDump())\n+  JVMWrapper(\"JVM_GetRandomSeedForCDSDump\");\n+  if (DumpSharedSpaces) {\n+    const char* release = Abstract_VM_Version::vm_release();\n+    const char* dbg_level = Abstract_VM_Version::jdk_debug_level();\n+    const char* version = VM_Version::internal_vm_info_string();\n+    jlong seed = (jlong)(java_lang_String::hash_code((const jbyte*)release, (int)strlen(release)) ^\n+                         java_lang_String::hash_code((const jbyte*)dbg_level, (int)strlen(dbg_level)) ^\n+                         java_lang_String::hash_code((const jbyte*)version, (int)strlen(version)));\n+    seed += (jlong)Abstract_VM_Version::vm_major_version();\n+    seed += (jlong)Abstract_VM_Version::vm_minor_version();\n+    seed += (jlong)Abstract_VM_Version::vm_security_version();\n+    seed += (jlong)Abstract_VM_Version::vm_patch_version();\n+    if (seed == 0) { \/\/ don't let this ever be zero.\n+      seed = 0x87654321;\n+    }\n+    log_debug(cds)(\"JVM_GetRandomSeedForCDSDump() = \" JLONG_FORMAT, seed);\n+    return seed;\n+  } else {\n+    return 0;\n+  }\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":427,"deletions":88,"binary":false,"changes":515,"status":"modified"},{"patch":"@@ -220,1 +220,0 @@\n-\n@@ -1214,1 +1213,1 @@\n-  \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n+  \/\/ thread. All other usage needs to use a direct handshake for safety.\n@@ -1218,4 +1217,3 @@\n-    \/\/ JVMTI get monitors info at safepoint. Do not require target thread to\n-    \/\/ be suspended.\n-    VM_GetOwnedMonitorInfo op(this, calling_thread, java_thread, owned_monitors_list);\n-    VMThread::execute(&op);\n+    \/\/ get owned monitors info with handshake\n+    GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);\n+    Handshake::execute_direct(&op, java_thread);\n@@ -1253,1 +1251,1 @@\n-  JavaThread* calling_thread  = JavaThread::current();\n+  JavaThread* calling_thread = JavaThread::current();\n@@ -1260,1 +1258,1 @@\n-  \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n+  \/\/ thread. All other usage needs to use a direct handshake for safety.\n@@ -1264,4 +1262,3 @@\n-    \/\/ JVMTI get owned monitors info at safepoint. Do not require target thread to\n-    \/\/ be suspended.\n-    VM_GetOwnedMonitorInfo op(this, calling_thread, java_thread, owned_monitors_list);\n-    VMThread::execute(&op);\n+    \/\/ get owned monitors info with handshake\n+    GetOwnedMonitorInfoClosure op(calling_thread, this, owned_monitors_list);\n+    Handshake::execute_direct(&op, java_thread);\n@@ -1302,1 +1299,1 @@\n-  JavaThread* calling_thread  = JavaThread::current();\n+  JavaThread* calling_thread = JavaThread::current();\n@@ -1305,1 +1302,1 @@\n-  \/\/ thread. All other usage needs to use a vm-safepoint-op for safety.\n+  \/\/ thread. All other usage needs to use a direct handshake for safety.\n@@ -1309,3 +1306,3 @@\n-    \/\/ get contended monitor information at safepoint.\n-    VM_GetCurrentContendedMonitor op(this, calling_thread, java_thread, monitor_ptr);\n-    VMThread::execute(&op);\n+    \/\/ get contended monitor information with handshake\n+    GetCurrentContendedMonitorClosure op(calling_thread, this, monitor_ptr);\n+    Handshake::execute_direct(&op, java_thread);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":14,"deletions":17,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2637,8 +2637,0 @@\n-    if (kind == JVMTI_HEAP_REFERENCE_SYSTEM_CLASS) {\n-      \/\/ SystemDictionary::oops_do reports the application\n-      \/\/ class loader as a root. We want this root to be reported as\n-      \/\/ a root kind of \"OTHER\" rather than \"SYSTEM_CLASS\".\n-      if (!o->is_instance() || !InstanceKlass::cast(o->klass())->is_mirror_instance_klass()) {\n-        kind = JVMTI_HEAP_REFERENCE_OTHER;\n-      }\n-    }\n@@ -3076,1 +3068,0 @@\n-  SystemDictionary::oops_do(&blk);\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/javaClasses.inline.hpp\"\n@@ -36,0 +37,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -401,2 +403,2 @@\n-  ThreadToNativeFromVM ttnfv(thread);\n-  return env->AllocObject(cls);\n+  instanceOop i = InstanceKlass::allocate_instance(JNIHandles::resolve_non_null(cls), CHECK_NULL);\n+  return JNIHandles::make_local(env, i);\n@@ -898,0 +900,9 @@\n+  ClassLoadInfo cl_info(host_domain,\n+                        InstanceKlass::cast(host_klass),\n+                        cp_patches,\n+                        NULL,     \/\/ dynamic_nest_host\n+                        Handle(), \/\/ classData\n+                        false,    \/\/ is_hidden\n+                        false,    \/\/ is_strong_hidden\n+                        true);    \/\/ can_access_vm_annotations\n+\n@@ -900,3 +911,1 @@\n-                                                host_domain,\n-                                                InstanceKlass::cast(host_klass),\n-                                                cp_patches,\n+                                                cl_info,\n@@ -1019,0 +1028,1 @@\n+  GuardUnsafeAccess guard(thread);\n@@ -1032,0 +1042,1 @@\n+  GuardUnsafeAccess guard(thread);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-size_t Arguments::_SharedBaseAddress            = SharedBaseAddress;\n+size_t Arguments::_default_SharedBaseAddress    = SharedBaseAddress;\n@@ -525,1 +525,0 @@\n-  { \"MonitorBound\",                 JDK_Version::jdk(14), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n@@ -528,0 +527,11 @@\n+  { \"ForceNUMA\",                    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"UseBiasedLocking\",             JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"BiasedLockingStartupDelay\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"PrintBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"BiasedLockingBulkRebiasThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"BiasedLockingBulkRevokeThreshold\",    JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"BiasedLockingDecayTime\",              JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"UseOptoBiasInlining\",                 JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"PrintPreciseBiasedLockingStatistics\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"InitialBootClassLoaderMetaspaceSize\", JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n+  { \"UseLargePagesInMetaspace\",            JDK_Version::jdk(15), JDK_Version::jdk(16), JDK_Version::jdk(17) },\n@@ -548,0 +558,11 @@\n+#ifndef X86\n+  { \"UseSSE\",                        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+#endif \/\/ !X86\n+  { \"UseAdaptiveGCBoundary\",         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"MonitorBound\",                  JDK_Version::jdk(14),     JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+#ifdef AARCH64\n+  { \"UseBarriersForVolatile\",        JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+#endif\n+  { \"UseLWPSynchronization\",         JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"BranchOnRegister\",              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"LIRFillDelaySlots\",             JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n@@ -560,0 +581,10 @@\n+#ifndef COMPILER2\n+  \/\/ These flags were generally available, but are C2 only, now.\n+  { \"MaxInlineLevel\",               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"MaxRecursiveInlineLevel\",      JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"InlineSmallCode\",              JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"MaxInlineSize\",                JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"FreqInlineSize\",               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+  { \"MaxTrivialSize\",               JDK_Version::undefined(), JDK_Version::jdk(15), JDK_Version::jdk(16) },\n+#endif\n+\n@@ -577,1 +608,0 @@\n-  { \"PrintCompressedOopsMode\",   LogLevel::Info,  true,  LOG_TAGS(gc, heap, coops) },\n@@ -586,0 +616,1 @@\n+  { \"TraceInvokeDynamic\",        LogLevel::Debug, true,  LOG_TAGS(methodhandles, indy) },\n@@ -587,0 +618,1 @@\n+  { \"TraceMethodHandles\",        LogLevel::Info,  true,  LOG_TAGS(methodhandles) },\n@@ -718,1 +750,1 @@\n-\/\/ check for stale flags when we hit build 20 (which is far enough into the 6 month\n+\/\/ check for stale flags when we hit build 25 (which is far enough into the 6 month\n@@ -724,1 +756,1 @@\n-static const int SPECIAL_FLAG_VALIDATION_BUILD = 20;\n+static const int SPECIAL_FLAG_VALIDATION_BUILD = 25;\n@@ -1438,0 +1470,8 @@\n+#if INCLUDE_CDS\n+  if (is_internal_module_property(key) ||\n+      strcmp(key, \"jdk.module.main\") == 0) {\n+    MetaspaceShared::disable_optimized_module_handling();\n+    log_info(cds)(\"Using optimized module handling disabled due to incompatible property: %s=%s\", key, value);\n+  }\n+#endif\n+\n@@ -1662,1 +1702,3 @@\n-      FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n+      if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n+        FLAG_SET_DEFAULT(UseCompressedClassPointers, false);\n+      }\n@@ -1675,2 +1717,8 @@\n-  \/\/ UseCompressedOops must be on for UseCompressedClassPointers to be on.\n-  if (!UseCompressedOops) {\n+  \/\/ On some architectures, the use of UseCompressedClassPointers implies the use of\n+  \/\/ UseCompressedOops. The reason is that the rheap_base register of said platforms\n+  \/\/ is reused to perform some optimized spilling, in order to use rheap_base as a\n+  \/\/ temp register. But by treating it as any other temp register, spilling can typically\n+  \/\/ be completely avoided instead. So it is better not to perform this trick. And by\n+  \/\/ not having that reliance, large heaps, or heaps not supporting compressed oops,\n+  \/\/ can still use compressed class pointers.\n+  if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS && !UseCompressedOops) {\n@@ -1805,4 +1853,1 @@\n-    if (UseCompressedOops) {\n-      \/\/ Limit the heap size to the maximum possible when using compressed oops\n-      julong max_coop_heap = (julong)max_heap_for_compressed_oops();\n-\n+    if (UseCompressedOops || UseCompressedClassPointers) {\n@@ -1821,0 +1866,4 @@\n+    }\n+    if (UseCompressedOops) {\n+      \/\/ Limit the heap size to the maximum possible when using compressed oops\n+      julong max_coop_heap = (julong)max_heap_for_compressed_oops();\n@@ -1839,1 +1888,3 @@\n-          FLAG_SET_ERGO(UseCompressedClassPointers, false);\n+          if (COMPRESSED_CLASS_POINTERS_DEPENDS_ON_COMPRESSED_OOPS) {\n+            FLAG_SET_ERGO(UseCompressedClassPointers, false);\n+          }\n@@ -2106,1 +2157,1 @@\n-    if (!create_numbered_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n+    if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.internal.vm.ci\", addmods_count++)) {\n@@ -2170,1 +2221,3 @@\n-bool Arguments::create_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {\n+bool Arguments::create_module_property(const char* prop_name, const char* prop_value, PropertyInternal internal) {\n+  assert(is_internal_module_property(prop_name) ||\n+         strcmp(prop_name, \"jdk.module.illegalAccess\") == 0, \"unknown module property: '%s'\", prop_name);\n@@ -2178,1 +2231,6 @@\n-  bool added = add_property(property, UnwriteableProperty, internal);\n+  \/\/ These are not strictly writeable properties as they cannot be set via -Dprop=val. But that\n+  \/\/ is enforced by checking is_internal_module_property(). We need the property to be writeable so\n+  \/\/ that multiple occurrences of the associated flag just causes the existing property value to be\n+  \/\/ replaced (\"last option wins\"). Otherwise we would need to keep track of the flags and only convert\n+  \/\/ to a property after we have finished flag processing.\n+  bool added = add_property(property, WriteableProperty, internal);\n@@ -2183,1 +2241,2 @@\n-bool Arguments::create_numbered_property(const char* prop_base_name, const char* prop_value, unsigned int count) {\n+bool Arguments::create_numbered_module_property(const char* prop_base_name, const char* prop_value, unsigned int count) {\n+  assert(is_internal_module_property(prop_base_name), \"unknown module property: '%s'\", prop_base_name);\n@@ -2233,2 +2292,2 @@\n-  \/\/ CDS dumping always write the archive to the default value of SharedBaseAddress.\n-  Arguments::_SharedBaseAddress = SharedBaseAddress;\n+  \/\/ Remember the default value of SharedBaseAddress.\n+  Arguments::_default_SharedBaseAddress = SharedBaseAddress;\n@@ -2345,1 +2404,1 @@\n-      if (!create_numbered_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.patch\", patch_mod_tail, patch_mod_count++)) {\n@@ -2462,0 +2521,4 @@\n+#if INCLUDE_CDS\n+      MetaspaceShared::disable_optimized_module_handling();\n+      log_info(cds)(\"Using optimized module handling disabled due to bootclasspath was appended\");\n+#endif\n@@ -2490,1 +2553,1 @@\n-      if (!create_numbered_property(\"jdk.module.addreads\", tail, addreads_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addreads\", tail, addreads_count++)) {\n@@ -2494,1 +2557,1 @@\n-      if (!create_numbered_property(\"jdk.module.addexports\", tail, addexports_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addexports\", tail, addexports_count++)) {\n@@ -2498,1 +2561,1 @@\n-      if (!create_numbered_property(\"jdk.module.addopens\", tail, addopens_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addopens\", tail, addopens_count++)) {\n@@ -2502,1 +2565,1 @@\n-      if (!create_numbered_property(\"jdk.module.addmods\", tail, addmods_count++)) {\n+      if (!create_numbered_module_property(\"jdk.module.addmods\", tail, addmods_count++)) {\n@@ -2506,1 +2569,1 @@\n-      if (!create_property(\"jdk.module.limitmods\", tail, InternalProperty)) {\n+      if (!create_module_property(\"jdk.module.limitmods\", tail, InternalProperty)) {\n@@ -2510,1 +2573,1 @@\n-      if (!create_property(\"jdk.module.path\", tail, ExternalProperty)) {\n+      if (!create_module_property(\"jdk.module.path\", tail, ExternalProperty)) {\n@@ -2514,1 +2577,1 @@\n-      if (!create_property(\"jdk.module.upgrade.path\", tail, ExternalProperty)) {\n+      if (!create_module_property(\"jdk.module.upgrade.path\", tail, ExternalProperty)) {\n@@ -2524,1 +2587,1 @@\n-      if (!create_property(\"jdk.module.illegalAccess\", tail, ExternalProperty)) {\n+      if (!create_module_property(\"jdk.module.illegalAccess\", tail, ExternalProperty)) {\n@@ -2568,1 +2631,1 @@\n-        if (!create_numbered_property(\"jdk.module.addmods\", \"java.instrument\", addmods_count++)) {\n+        if (!create_numbered_module_property(\"jdk.module.addmods\", \"java.instrument\", addmods_count++)) {\n@@ -2749,1 +2812,1 @@\n-        if (!create_numbered_property(\"jdk.module.addmods\", \"jdk.management.agent\", addmods_count++)) {\n+        if (!create_numbered_module_property(\"jdk.module.addmods\", \"jdk.management.agent\", addmods_count++)) {\n@@ -2994,0 +3057,4 @@\n+      \/\/ Just continue, since \"-XX:+EnableJVMCIProduct\" has been specified before\n+      if (EnableJVMCIProduct) {\n+        continue;\n+      }\n@@ -3496,1 +3563,1 @@\n-void Arguments::set_shared_spaces_flags() {\n+jint Arguments::set_shared_spaces_flags_and_archive_paths() {\n@@ -3503,0 +3570,8 @@\n+#if INCLUDE_CDS\n+  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n+  \/\/ This must be after set_ergonomics_flags() called so flag UseCompressedOops is set properly.\n+  if (!init_shared_archive_paths()) {\n+    return JNI_ENOMEM;\n+  }\n+#endif  \/\/ INCLUDE_CDS\n+  return JNI_OK;\n@@ -3518,1 +3593,2 @@\n-  jio_snprintf(default_archive_path, len, \"%s%sclasses.jsa\",\n+  jio_snprintf(default_archive_path, len,\n+               UseCompressedOops ? \"%s%sclasses.jsa\": \"%s%sclasses_nocoops.jsa\",\n@@ -3963,7 +4039,0 @@\n-#if INCLUDE_CDS\n-  \/\/ Initialize shared archive paths which could include both base and dynamic archive paths\n-  if (!init_shared_archive_paths()) {\n-    return JNI_ENOMEM;\n-  }\n-#endif\n-\n@@ -4069,1 +4138,2 @@\n-  set_shared_spaces_flags();\n+  result = set_shared_spaces_flags_and_archive_paths();\n+  if (result != JNI_OK) return result;\n@@ -4166,8 +4236,0 @@\n-    \/\/ UseNUMAInterleaving is set to ON for all collectors and platforms when\n-    \/\/ UseNUMA is set to ON. NUMA-aware collectors will interleave old gen and\n-    \/\/ survivor spaces on top of NUMA allocation policy for the eden space.\n-    \/\/ Non NUMA-aware collectors will interleave all of the heap spaces across\n-    \/\/ NUMA nodes.\n-    if (FLAG_IS_DEFAULT(UseNUMAInterleaving)) {\n-      FLAG_SET_ERGO(UseNUMAInterleaving, true);\n-    }\n@@ -4293,1 +4355,2 @@\n-  \/\/ If property key exist then update with new value.\n+  \/\/ If property key exists and is writeable, then update with new value.\n+  \/\/ Trying to update a non-writeable property is silently ignored.\n@@ -4298,1 +4361,1 @@\n-        prop->append_value(v);\n+        prop->append_writeable_value(v);\n@@ -4300,1 +4363,1 @@\n-        prop->set_value(v);\n+        prop->set_writeable_value(v);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":114,"deletions":51,"binary":false,"changes":165,"status":"modified"},{"patch":"@@ -181,1 +181,1 @@\n-          \"Use large page memory in metaspace. \"                            \\\n+          \"(Deprecated) Use large page memory in metaspace. \"               \\\n@@ -195,1 +195,1 @@\n-          \"Force NUMA optimizations on single-node\/UMA systems\")            \\\n+          \"(Deprecated) Force NUMA optimizations on single-node\/UMA systems\") \\\n@@ -217,4 +217,0 @@\n-  product(intx, UseSSE, 99,                                                 \\\n-          \"Highest supported SSE instructions set on x86\/x64\")              \\\n-          range(0, 99)                                                      \\\n-                                                                            \\\n@@ -416,1 +412,1 @@\n-          \"Bump the number of file descriptors to maximum in Solaris\")      \\\n+          \"Bump the number of file descriptors to maximum (Unix only)\")     \\\n@@ -624,1 +620,1 @@\n-  manageable(bool, ShowCodeDetailsInExceptionMessages, false,               \\\n+  manageable(bool, ShowCodeDetailsInExceptionMessages, true,                \\\n@@ -686,4 +682,0 @@\n-  develop(bool, UseDetachedThreads, true,                                   \\\n-          \"Use detached threads that are recycled upon termination \"        \\\n-          \"(for Solaris only)\")                                             \\\n-                                                                            \\\n@@ -694,3 +686,2 @@\n-  product(bool, UseLWPSynchronization, true,                                \\\n-          \"Use LWP-based instead of libthread-based synchronization \"       \\\n-          \"(SPARC only)\")                                                   \\\n+  diagnostic(bool, AsyncDeflateIdleMonitors, true,                          \\\n+          \"Deflate idle monitors using the ServiceThread.\")                 \\\n@@ -698,1 +689,5 @@\n-  product(intx, MonitorBound, 0, \"(Deprecated) Bound Monitor population\")   \\\n+  \/* notice: the max range value here is max_jint, not max_intx  *\/         \\\n+  \/* because of overflow issue                                   *\/         \\\n+  diagnostic(intx, AsyncDeflationInterval, 250,                             \\\n+          \"Async deflate idle monitors every so many milliseconds when \"    \\\n+          \"MonitorUsedDeflationThreshold is exceeded (0 is off).\")          \\\n@@ -702,4 +697,4 @@\n-                \"Percentage of used monitors before triggering cleanup \"    \\\n-                \"safepoint which deflates monitors (0 is off). \"            \\\n-                \"The check is performed on GuaranteedSafepointInterval.\")   \\\n-                range(0, 100)                                               \\\n+          \"Percentage of used monitors before triggering deflation (0 is \"  \\\n+          \"off). The check is performed on GuaranteedSafepointInterval \"    \\\n+          \"or AsyncDeflationInterval.\")                                     \\\n+          range(0, 100)                                                     \\\n@@ -714,4 +709,0 @@\n-  develop(bool, UsePthreads, false,                                         \\\n-          \"Use pthread-based instead of libthread-based synchronization \"   \\\n-          \"(SPARC only)\")                                                   \\\n-                                                                            \\\n@@ -733,1 +724,1 @@\n-          \"(Solaris & Linux only)\")                                         \\\n+          \"(Unix only)\")                                                    \\\n@@ -737,1 +728,1 @@\n-          \"by the application (Solaris & Linux only)\")                      \\\n+          \"by the application (Unix only)\")                                 \\\n@@ -787,2 +778,2 @@\n-  product(bool, UseBiasedLocking, true,                                     \\\n-          \"Enable biased locking in JVM\")                                   \\\n+  product(bool, UseBiasedLocking, false,                                    \\\n+          \"(Deprecated) Enable biased locking in JVM\")                      \\\n@@ -791,1 +782,2 @@\n-          \"Number of milliseconds to wait before enabling biased locking\")  \\\n+          \"(Deprecated) Number of milliseconds to wait before enabling \"    \\\n+          \"biased locking\")                                                 \\\n@@ -796,1 +788,1 @@\n-          \"Print statistics of biased locking in JVM\")                      \\\n+          \"(Deprecated) Print statistics of biased locking in JVM\")         \\\n@@ -799,2 +791,2 @@\n-          \"Threshold of number of revocations per type to try to \"          \\\n-          \"rebias all objects in the heap of that type\")                    \\\n+          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n+          \"try to rebias all objects in the heap of that type\")             \\\n@@ -805,2 +797,3 @@\n-          \"Threshold of number of revocations per type to permanently \"     \\\n-          \"revoke biases of all objects in the heap of that type\")          \\\n+          \"(Deprecated) Threshold of number of revocations per type to \"    \\\n+          \"permanently revoke biases of all objects in the heap of that \"   \\\n+          \"type\")                                                           \\\n@@ -811,2 +804,2 @@\n-          \"Decay time (in milliseconds) to re-enable bulk rebiasing of a \"  \\\n-          \"type after previous bulk rebias\")                                \\\n+          \"(Deprecated) Decay time (in milliseconds) to re-enable bulk \"    \\\n+          \"rebiasing of a type after previous bulk rebias\")                 \\\n@@ -903,1 +896,1 @@\n-          \"Initial size of the boot class loader data metaspace\")           \\\n+          \"(Deprecated) Initial size of the boot class loader data metaspace\") \\\n@@ -1463,8 +1456,0 @@\n-  product(intx, MaxInlineLevel, 15,                                         \\\n-          \"maximum number of nested calls that are inlined\")                \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxRecursiveInlineLevel, 1,                                 \\\n-          \"maximum number of nested recursive calls that are inlined\")      \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n@@ -1476,17 +1461,0 @@\n-  product_pd(intx, InlineSmallCode,                                         \\\n-          \"Only inline already compiled methods if their code size is \"     \\\n-          \"less than this\")                                                 \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxInlineSize, 35,                                          \\\n-          \"The maximum bytecode size of a method to be inlined\")            \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product_pd(intx, FreqInlineSize,                                          \\\n-          \"The maximum bytecode size of a frequent method to be inlined\")   \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n-  product(intx, MaxTrivialSize, 6,                                          \\\n-          \"The maximum bytecode size of a trivial method to be inlined\")    \\\n-          range(0, max_jint)                                                \\\n-                                                                            \\\n@@ -1727,0 +1695,5 @@\n+  product(double, SweeperThreshold, 0.5,                                    \\\n+          \"Threshold controlling when code cache sweeper is invoked.\"       \\\n+          \"Value is percentage of ReservedCodeCacheSize.\")                  \\\n+          range(0.0, 100.0)                                                 \\\n+                                                                            \\\n@@ -1840,4 +1813,2 @@\n-          \"    applications. On Solaris NORM_PRIORITY and above are mapped \"\\\n-          \"    to normal native priority. Java priorities below \"           \\\n-          \"    NORM_PRIORITY map to lower native priority values. On       \"\\\n-          \"    Windows applications are allowed to use higher native       \"\\\n+          \"    applications.                                               \"\\\n+          \"    On Windows applications are allowed to use higher native    \"\\\n@@ -1868,1 +1839,0 @@\n-          constraint(CompilerThreadPriorityConstraintFunc, AfterErgo)       \\\n@@ -2305,3 +2275,0 @@\n-  develop(bool, TraceMethodHandles, false,                                  \\\n-          \"trace internal method handle operations\")                        \\\n-                                                                            \\\n@@ -2320,3 +2287,0 @@\n-  develop(bool, TraceInvokeDynamic, false,                                  \\\n-          \"trace internal invoke dynamic operations\")                       \\\n-                                                                            \\\n@@ -2412,2 +2376,1 @@\n-  experimental(size_t, ArrayAllocatorMallocLimit,                           \\\n-          SOLARIS_ONLY(64*K) NOT_SOLARIS((size_t)-1),                       \\\n+  experimental(size_t, ArrayAllocatorMallocLimit, (size_t)-1,               \\\n@@ -2496,0 +2459,3 @@\n+  diagnostic(bool, DeoptimizeNMethodBarriersALot, false,                    \\\n+                \"Make nmethod barriers deoptimise a lot.\")                  \\\n+                                                                            \\\n@@ -2507,1 +2473,0 @@\n-\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":41,"deletions":76,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,2 +70,3 @@\n-void interpreter_init();       \/\/ before any methods loaded\n-void invocationCounter_init(); \/\/ before any methods loaded\n+void interpreter_init_stub();  \/\/ before any methods loaded\n+void interpreter_init_code();  \/\/ after methods loaded, but before they are linked\n+void invocationCounter_init(); \/\/ after methods loaded, but before they are linked\n@@ -73,1 +74,0 @@\n-void templateTable_init();\n@@ -78,1 +78,1 @@\n-void vmStructs_init();\n+void vmStructs_init() NOT_DEBUG_RETURN;\n@@ -130,3 +130,2 @@\n-  gc_barrier_stubs_init();   \/\/ depends on universe_init, must be before interpreter_init\n-  interpreter_init();        \/\/ before any methods loaded\n-  invocationCounter_init();  \/\/ before any methods loaded\n+  gc_barrier_stubs_init();  \/\/ depends on universe_init, must be before interpreter_init\n+  interpreter_init_stub();  \/\/ before methods get loaded\n@@ -134,2 +133,1 @@\n-  templateTable_init();\n-  VMRegImpl::set_regName();  \/\/ need this before generate_stubs (for printing oop maps).\n+  VMRegImpl::set_regName(); \/\/ need this before generate_stubs (for printing oop maps).\n@@ -140,0 +138,2 @@\n+  interpreter_init_code();  \/\/ after javaClasses_init and before any method gets linked\n+  invocationCounter_init(); \/\/ after javaClasses_init and before any method gets linked\n@@ -166,6 +166,0 @@\n-#if INCLUDE_NMT\n-  \/\/ Solaris stack is walkable only after stubRoutines are set up.\n-  \/\/ On Other platforms, the stack is always walkable.\n-  NMT_stack_walkable = true;\n-#endif \/\/ INCLUDE_NMT\n-\n@@ -192,2 +186,6 @@\n-      \/\/ ObjectSynchronizer::finish_deflate_idle_monitors()'s call\n-      \/\/ to audit_and_print_stats() is done at the Debug level.\n+      \/\/ These other two audit_and_print_stats() calls are done at the\n+      \/\/ Debug level at a safepoint:\n+      \/\/ - for safepoint based deflation auditing:\n+      \/\/   ObjectSynchronizer::finish_deflate_idle_monitors()\n+      \/\/ - for async deflation auditing:\n+      \/\/   ObjectSynchronizer::do_safepoint_work()\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":16,"deletions":18,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+Monitor* CodeSweeper_lock             = NULL;\n@@ -77,0 +78,1 @@\n+Mutex*   G1DetachedRefinementStats_lock = NULL;\n@@ -81,1 +83,1 @@\n-Monitor* CGCPhaseManager_lock         = NULL;\n+Monitor* ConcurrentGCBreakpoints_lock = NULL;\n@@ -122,0 +124,1 @@\n+Monitor* Zip_lock                     = NULL;\n@@ -154,0 +157,1 @@\n+Mutex*   CDSLambda_lock               = NULL;\n@@ -195,1 +199,1 @@\n-  if (Thread::current()->is_VM_thread() && thread->is_vmthread_processing_handshake()) return;\n+  if (Thread::current() == thread->active_handshaker()) return;\n@@ -219,0 +223,2 @@\n+    def(G1DetachedRefinementStats_lock, PaddedMutex, leaf    ,   true, _safepoint_check_never);\n+\n@@ -235,2 +241,1 @@\n-  def(ParGCRareEvent_lock          , PaddedMutex  , leaf     ,   true,  _safepoint_check_always);\n-  def(CGCPhaseManager_lock         , PaddedMonitor, leaf,        false, _safepoint_check_always);\n+  def(ParGCRareEvent_lock          , PaddedMutex  , leaf,        true,  _safepoint_check_always);\n@@ -238,0 +243,1 @@\n+  def(CodeSweeper_lock             , PaddedMonitor, special-2,   true,  _safepoint_check_never);\n@@ -277,1 +283,1 @@\n-  def(NonJavaThreadsList_lock      , PaddedMutex,   leaf,        true,  _safepoint_check_never);\n+  def(NonJavaThreadsList_lock      , PaddedMutex,   barrier,     true,  _safepoint_check_never);\n@@ -302,0 +308,1 @@\n+  def(ConcurrentGCBreakpoints_lock , PaddedMonitor, nonleaf,     true,  _safepoint_check_always);\n@@ -313,0 +320,1 @@\n+  def(Zip_lock                     , PaddedMonitor, leaf,        true,  _safepoint_check_never);\n@@ -322,1 +330,1 @@\n-  def(JfrStacktrace_lock           , PaddedMutex  , special,     true,  _safepoint_check_never);\n+  def(JfrStacktrace_lock           , PaddedMutex  , special - 1, true,  _safepoint_check_never);\n@@ -347,1 +355,2 @@\n-  def(DumpTimeTable_lock           , PaddedMutex  , leaf,        true,  _safepoint_check_never);\n+  def(DumpTimeTable_lock           , PaddedMutex  , leaf - 1,        true,  _safepoint_check_never);\n+  def(CDSLambda_lock               , PaddedMutex  , leaf,        true,  _safepoint_check_never);\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+extern Monitor* CodeSweeper_lock;                \/\/ a lock used by the sweeper only for wait notify\n@@ -60,1 +61,0 @@\n-extern Monitor* CGCPhaseManager_lock;            \/\/ a lock to protect a concurrent GC's phase management\n@@ -75,0 +75,1 @@\n+extern Mutex*   G1DetachedRefinementStats_lock;  \/\/ Lock protecting detached refinement stats\n@@ -79,0 +80,1 @@\n+extern Monitor* ConcurrentGCBreakpoints_lock;    \/\/ Protects concurrent GC breakpoint management\n@@ -117,0 +119,1 @@\n+extern Monitor* Zip_lock;                        \/\/ synchronize initialization of zip library\n@@ -129,0 +132,1 @@\n+extern Mutex*   CDSLambda_lock;                  \/\/ SystemDictionaryShared::get_shared_lambda_proxy_class\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+#include \"runtime\/synchronizer.hpp\"\n@@ -2249,3 +2250,1 @@\n-\n-\/\/ Handles the uncommon case in locking, i.e., contention or an inflated lock.\n-JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* _obj, BasicLock* lock, JavaThread* thread))\n+void SharedRuntime::monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {\n@@ -2255,1 +2254,1 @@\n-    if (ObjectSynchronizer::quick_enter(_obj, thread, lock)) return;\n+    if (ObjectSynchronizer::quick_enter(obj, thread, lock)) return;\n@@ -2262,1 +2261,0 @@\n-  oop obj(_obj);\n@@ -2270,1 +2268,1 @@\n-JRT_END\n+}\n@@ -2272,22 +2270,4 @@\n-\/\/ Handles the uncommon cases of monitor unlocking in compiled code\n-JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* _obj, BasicLock* lock, JavaThread * THREAD))\n-   oop obj(_obj);\n-  assert(JavaThread::current() == THREAD, \"invariant\");\n-  \/\/ I'm not convinced we need the code contained by MIGHT_HAVE_PENDING anymore\n-  \/\/ testing was unable to ever fire the assert that guarded it so I have removed it.\n-  assert(!HAS_PENDING_EXCEPTION, \"Do we need code below anymore?\");\n-#undef MIGHT_HAVE_PENDING\n-#ifdef MIGHT_HAVE_PENDING\n-  \/\/ Save and restore any pending_exception around the exception mark.\n-  \/\/ While the slow_exit must not throw an exception, we could come into\n-  \/\/ this routine with one set.\n-  oop pending_excep = NULL;\n-  const char* pending_file;\n-  int pending_line;\n-  if (HAS_PENDING_EXCEPTION) {\n-    pending_excep = PENDING_EXCEPTION;\n-    pending_file  = THREAD->exception_file();\n-    pending_line  = THREAD->exception_line();\n-    CLEAR_PENDING_EXCEPTION;\n-  }\n-#endif \/* MIGHT_HAVE_PENDING *\/\n+\/\/ Handles the uncommon case in locking, i.e., contention or an inflated lock.\n+JRT_BLOCK_ENTRY(void, SharedRuntime::complete_monitor_locking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))\n+  SharedRuntime::monitor_enter_helper(obj, lock, thread);\n+JRT_END\n@@ -2295,5 +2275,6 @@\n-  {\n-    \/\/ Exit must be non-blocking, and therefore no exceptions can be thrown.\n-    EXCEPTION_MARK;\n-    ObjectSynchronizer::exit(obj, lock, THREAD);\n-  }\n+void SharedRuntime::monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread) {\n+  assert(JavaThread::current() == thread, \"invariant\");\n+  \/\/ Exit must be non-blocking, and therefore no exceptions can be thrown.\n+  EXCEPTION_MARK;\n+  ObjectSynchronizer::exit(obj, lock, THREAD);\n+}\n@@ -2301,5 +2282,3 @@\n-#ifdef MIGHT_HAVE_PENDING\n-  if (pending_excep != NULL) {\n-    THREAD->set_pending_exception(pending_excep, pending_file, pending_line);\n-  }\n-#endif \/* MIGHT_HAVE_PENDING *\/\n+\/\/ Handles the uncommon cases of monitor unlocking in compiled code\n+JRT_LEAF(void, SharedRuntime::complete_monitor_unlocking_C(oopDesc* obj, BasicLock* lock, JavaThread* thread))\n+  SharedRuntime::monitor_exit_helper(obj, lock, thread);\n@@ -3050,0 +3029,6 @@\n+#if defined(AARCH64)\n+      \/\/ On AArch64 with ZGC and nmethod entry barriers, we need all oops to be\n+      \/\/ in the constant pool to ensure ordering between the barrier and oops\n+      \/\/ accesses. For native_wrappers we need a constant.\n+      buffer.initialize_consts_size(8);\n+#endif\n@@ -3263,2 +3248,5 @@\n-      \/\/ Inflate so the displaced header becomes position-independent\n-      if (lock->displaced_header().is_unlocked())\n+      \/\/ Inflate so the object's header no longer refers to the BasicLock.\n+      if (lock->displaced_header().is_unlocked()) {\n+        \/\/ The object is locked and the resulting ObjectMonitor* will also be\n+        \/\/ locked so it can't be async deflated until ownership is dropped.\n+        \/\/ See the big comment in basicLock.cpp: BasicLock::move_to().\n@@ -3266,1 +3254,3 @@\n-      \/\/ Now the displaced header is free to move\n+      }\n+      \/\/ Now the displaced header is free to move because the\n+      \/\/ object's header no longer refers to it.\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":31,"deletions":41,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -435,0 +435,3 @@\n+  static void monitor_enter_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n+\n+  static void monitor_exit_helper(oopDesc* obj, BasicLock* lock, JavaThread* thread);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/handshake.hpp\"\n@@ -45,0 +46,1 @@\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n@@ -121,0 +123,3 @@\n+bool volatile ObjectSynchronizer::_is_async_deflation_requested = false;\n+bool volatile ObjectSynchronizer::_is_special_deflation_requested = false;\n+jlong ObjectSynchronizer::_last_async_deflation_time_ns = 0;\n@@ -137,0 +142,7 @@\n+  \/\/ Global ObjectMonitor wait list. Deflated ObjectMonitors wait on\n+  \/\/ this list until after a handshake or a safepoint for platforms\n+  \/\/ that don't support handshakes. After the handshake or safepoint,\n+  \/\/ the deflated ObjectMonitors are prepended to free_list.\n+  ObjectMonitor* _wait_list;\n+  DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(ObjectMonitor*));\n+\n@@ -138,1 +150,1 @@\n-  DEFINE_PAD_MINUS_SIZE(3, OM_CACHE_LINE_SIZE, sizeof(int));\n+  DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));\n@@ -141,1 +153,1 @@\n-  DEFINE_PAD_MINUS_SIZE(4, OM_CACHE_LINE_SIZE, sizeof(int));\n+  DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));\n@@ -144,1 +156,4 @@\n-  DEFINE_PAD_MINUS_SIZE(5, OM_CACHE_LINE_SIZE, sizeof(int));\n+  DEFINE_PAD_MINUS_SIZE(6, OM_CACHE_LINE_SIZE, sizeof(int));\n+\n+  int _wait_count;    \/\/ # on wait_list\n+  DEFINE_PAD_MINUS_SIZE(7, OM_CACHE_LINE_SIZE, sizeof(int));\n@@ -162,1 +177,1 @@\n-  return ((intptr_t)om->next_om() & OM_LOCK_BIT) == OM_LOCK_BIT;\n+  return ((intptr_t)om->next_om_acquire() & OM_LOCK_BIT) == OM_LOCK_BIT;\n@@ -203,1 +218,1 @@\n-  om->set_next_om(next);\n+  om->release_set_next_om(next);\n@@ -210,0 +225,3 @@\n+    \/\/ Acquire semantics not needed on this list load since we're\n+    \/\/ checking for NULL here or following up with a cmpxchg() via\n+    \/\/ try_om_lock() below and we retry on cmpxchg() failure.\n@@ -215,0 +233,2 @@\n+      \/\/ Acquire semantics not needed on this list load since memory is\n+      \/\/ already consistent due to the cmpxchg() via try_om_lock() above.\n@@ -237,0 +257,3 @@\n+    \/\/ Acquire semantics not needed on this list load since we're\n+    \/\/ following up with a cmpxchg() via try_om_lock() below and we\n+    \/\/ retry on cmpxchg() failure.\n@@ -243,0 +266,2 @@\n+    \/\/ Release semantics not needed on this \"unlock\" since memory is\n+    \/\/ already consistent due to the cmpxchg() via try_om_lock() above.\n@@ -302,0 +327,9 @@\n+\/\/ Prepend a list of ObjectMonitors to om_list_globals._wait_list.\n+\/\/ 'tail' is the last ObjectMonitor in the list and there are 'count'\n+\/\/ on the list. Also updates om_list_globals._wait_count.\n+static void prepend_list_to_global_wait_list(ObjectMonitor* list,\n+                                             ObjectMonitor* tail, int count) {\n+  prepend_list_to_common(list, tail, count, &om_list_globals._wait_list,\n+                         &om_list_globals._wait_count);\n+}\n+\n@@ -319,1 +353,1 @@\n-    \/\/ thread:\n+    \/\/ or async deflater thread (which only races in om_in_use_list):\n@@ -321,1 +355,3 @@\n-      \/\/ List head is now locked so we can safely switch it.\n+      \/\/ List head is now locked so we can safely switch it. Release\n+      \/\/ semantics not needed on this \"unlock\" since memory is already\n+      \/\/ consistent due to the cmpxchg() via get_list_head_locked() above.\n@@ -323,0 +359,1 @@\n+      OrderAccess::storestore();  \/\/ Make sure set_next_om() is seen first.\n@@ -329,0 +366,2 @@\n+    \/\/ Release semantics not needed on this \"unlock\" since memory\n+    \/\/ is already consistent.\n@@ -357,1 +396,1 @@\n-  \/\/ thread:\n+  \/\/ or async deflater thread (which only races in om_list_globals._free_list):\n@@ -363,1 +402,3 @@\n-  \/\/ leaves take locked):\n+  \/\/ leaves take locked). Release semantics not needed on this \"unlock\"\n+  \/\/ since memory is already consistent due to the cmpxchg() via\n+  \/\/ get_list_head_locked() above.\n@@ -466,0 +507,1 @@\n+\n@@ -470,1 +512,10 @@\n-    assert(m->object() == obj, \"invariant\");\n+    if (AsyncDeflateIdleMonitors) {\n+      \/\/ An async deflation can race us before we manage to make the\n+      \/\/ ObjectMonitor busy by setting the owner below. If we detect\n+      \/\/ that race we just bail out to the slow-path here.\n+      if (m->object() == NULL) {\n+        return false;\n+      }\n+    } else {\n+      assert(m->object() == obj, \"invariant\");\n+    }\n@@ -550,1 +601,9 @@\n-  inflate(THREAD, obj(), inflate_cause_monitor_enter)->enter(THREAD);\n+  \/\/ An async deflation can race after the inflate() call and before\n+  \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n+  \/\/ we have lost the race to async deflation and we simply try again.\n+  while (true) {\n+    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_monitor_enter);\n+    if (monitor->enter(THREAD)) {\n+      return;\n+    }\n+  }\n@@ -599,1 +658,4 @@\n-  inflate(THREAD, object, inflate_cause_vm_internal)->exit(true, THREAD);\n+  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n+  ObjectMonitor* monitor = inflate(THREAD, object, inflate_cause_vm_internal);\n+  monitor->exit(true, THREAD);\n@@ -628,0 +690,2 @@\n+  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n@@ -629,2 +693,2 @@\n-\n-  return monitor->complete_exit(THREAD);\n+  intptr_t ret_code = monitor->complete_exit(THREAD);\n+  return ret_code;\n@@ -640,3 +704,10 @@\n-  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);\n-\n-  monitor->reenter(recursions, THREAD);\n+  \/\/ An async deflation can race after the inflate() call and before\n+  \/\/ reenter() -> enter() can make the ObjectMonitor busy. reenter() ->\n+  \/\/ enter() returns false if we have lost the race to async deflation\n+  \/\/ and we simply try again.\n+  while (true) {\n+    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_vm_internal);\n+    if (monitor->reenter(recursions, THREAD)) {\n+      return;\n+    }\n+  }\n@@ -644,0 +715,1 @@\n+\n@@ -654,1 +726,9 @@\n-  inflate(THREAD, obj(), inflate_cause_jni_enter)->enter(THREAD);\n+  \/\/ An async deflation can race after the inflate() call and before\n+  \/\/ enter() can make the ObjectMonitor busy. enter() returns false if\n+  \/\/ we have lost the race to async deflation and we simply try again.\n+  while (true) {\n+    ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_jni_enter);\n+    if (monitor->enter(THREAD)) {\n+      break;\n+    }\n+  }\n@@ -668,0 +748,2 @@\n+  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n@@ -712,0 +794,3 @@\n+  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n+  \/\/ field is incremented before ownership is dropped and decremented\n+  \/\/ after ownership is regained.\n@@ -730,1 +815,2 @@\n-  return dtrace_waited_probe(monitor, obj, THREAD);\n+  int ret_code = dtrace_waited_probe(monitor, obj, THREAD);\n+  return ret_code;\n@@ -741,0 +827,3 @@\n+  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n+  \/\/ field is incremented before ownership is dropped and decremented\n+  \/\/ after ownership is regained.\n@@ -761,1 +850,4 @@\n-  inflate(THREAD, obj(), inflate_cause_notify)->notify(THREAD);\n+  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+  \/\/ dropped by the calling thread.\n+  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);\n+  monitor->notify(THREAD);\n@@ -775,1 +867,4 @@\n-  inflate(THREAD, obj(), inflate_cause_notify)->notifyAll(THREAD);\n+  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+  \/\/ dropped by the calling thread.\n+  ObjectMonitor* monitor = inflate(THREAD, obj(), inflate_cause_notify);\n+  monitor->notifyAll(THREAD);\n@@ -812,1 +907,0 @@\n-static int _forceMonitorScavenge = 0; \/\/ Scavenge required and pending\n@@ -968,4 +1062,5 @@\n-  ObjectMonitor* monitor = NULL;\n-  markWord temp, test;\n-  intptr_t hash;\n-  markWord mark = read_stable_mark(obj);\n+  while (true) {\n+    ObjectMonitor* monitor = NULL;\n+    markWord temp, test;\n+    intptr_t hash;\n+    markWord mark = read_stable_mark(obj);\n@@ -973,2 +1068,2 @@\n-  \/\/ object should remain ineligible for biased locking\n-  assert(!mark.has_bias_pattern(), \"invariant\");\n+    \/\/ object should remain ineligible for biased locking\n+    assert(!mark.has_bias_pattern(), \"invariant\");\n@@ -976,1 +1071,72 @@\n-  if (mark.is_neutral()) {            \/\/ if this is a normal header\n+    if (mark.is_neutral()) {            \/\/ if this is a normal header\n+      hash = mark.hash();\n+      if (hash != 0) {                  \/\/ if it has a hash, just return it\n+        return hash;\n+      }\n+      hash = get_next_hash(self, obj);  \/\/ get a new hash\n+      temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n+                                        \/\/ try to install the hash\n+      test = obj->cas_set_mark(temp, mark);\n+      if (test == mark) {               \/\/ if the hash was installed, return it\n+        return hash;\n+      }\n+      \/\/ Failed to install the hash. It could be that another thread\n+      \/\/ installed the hash just before our attempt or inflation has\n+      \/\/ occurred or... so we fall thru to inflate the monitor for\n+      \/\/ stability and then install the hash.\n+    } else if (mark.has_monitor()) {\n+      monitor = mark.monitor();\n+      temp = monitor->header();\n+      assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n+      hash = temp.hash();\n+      if (hash != 0) {\n+        \/\/ It has a hash.\n+\n+        \/\/ Separate load of dmw\/header above from the loads in\n+        \/\/ is_being_async_deflated().\n+        if (support_IRIW_for_not_multiple_copy_atomic_cpu) {\n+          \/\/ A non-multiple copy atomic (nMCA) machine needs a bigger\n+          \/\/ hammer to separate the load above and the loads below.\n+          OrderAccess::fence();\n+        } else {\n+          OrderAccess::loadload();\n+        }\n+        if (monitor->is_being_async_deflated()) {\n+          \/\/ But we can't safely use the hash if we detect that async\n+          \/\/ deflation has occurred. So we attempt to restore the\n+          \/\/ header\/dmw to the object's header so that we only retry\n+          \/\/ once if the deflater thread happens to be slow.\n+          monitor->install_displaced_markword_in_object(obj);\n+          continue;\n+        }\n+        return hash;\n+      }\n+      \/\/ Fall thru so we only have one place that installs the hash in\n+      \/\/ the ObjectMonitor.\n+    } else if (self->is_lock_owned((address)mark.locker())) {\n+      \/\/ This is a stack lock owned by the calling thread so fetch the\n+      \/\/ displaced markWord from the BasicLock on the stack.\n+      temp = mark.displaced_mark_helper();\n+      assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n+      hash = temp.hash();\n+      if (hash != 0) {                  \/\/ if it has a hash, just return it\n+        return hash;\n+      }\n+      \/\/ WARNING:\n+      \/\/ The displaced header in the BasicLock on a thread's stack\n+      \/\/ is strictly immutable. It CANNOT be changed in ANY cases.\n+      \/\/ So we have to inflate the stack lock into an ObjectMonitor\n+      \/\/ even if the current thread owns the lock. The BasicLock on\n+      \/\/ a thread's stack can be asynchronously read by other threads\n+      \/\/ during an inflate() call so any change to that stack memory\n+      \/\/ may not propagate to other threads correctly.\n+    }\n+\n+    \/\/ Inflate the monitor to set the hash.\n+\n+    \/\/ An async deflation can race after the inflate() call and before we\n+    \/\/ can update the ObjectMonitor's header with the hash value below.\n+    monitor = inflate(self, obj, inflate_cause_hash_code);\n+    \/\/ Load ObjectMonitor's header\/dmw field and see if it has a hash.\n+    mark = monitor->header();\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n@@ -978,68 +1144,28 @@\n-    if (hash != 0) {                  \/\/ if it has a hash, just return it\n-      return hash;\n-    }\n-    hash = get_next_hash(self, obj);  \/\/ get a new hash\n-    temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n-                                      \/\/ try to install the hash\n-    test = obj->cas_set_mark(temp, mark);\n-    if (test == mark) {               \/\/ if the hash was installed, return it\n-      return hash;\n-    }\n-    \/\/ Failed to install the hash. It could be that another thread\n-    \/\/ installed the hash just before our attempt or inflation has\n-    \/\/ occurred or... so we fall thru to inflate the monitor for\n-    \/\/ stability and then install the hash.\n-  } else if (mark.has_monitor()) {\n-    monitor = mark.monitor();\n-    temp = monitor->header();\n-    assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n-    hash = temp.hash();\n-    if (hash != 0) {                  \/\/ if it has a hash, just return it\n-      return hash;\n-    }\n-    \/\/ Fall thru so we only have one place that installs the hash in\n-    \/\/ the ObjectMonitor.\n-  } else if (self->is_lock_owned((address)mark.locker())) {\n-    \/\/ This is a stack lock owned by the calling thread so fetch the\n-    \/\/ displaced markWord from the BasicLock on the stack.\n-    temp = mark.displaced_mark_helper();\n-    assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n-    hash = temp.hash();\n-    if (hash != 0) {                  \/\/ if it has a hash, just return it\n-      return hash;\n-    }\n-    \/\/ WARNING:\n-    \/\/ The displaced header in the BasicLock on a thread's stack\n-    \/\/ is strictly immutable. It CANNOT be changed in ANY cases.\n-    \/\/ So we have to inflate the stack lock into an ObjectMonitor\n-    \/\/ even if the current thread owns the lock. The BasicLock on\n-    \/\/ a thread's stack can be asynchronously read by other threads\n-    \/\/ during an inflate() call so any change to that stack memory\n-    \/\/ may not propagate to other threads correctly.\n-  }\n-\n-  \/\/ Inflate the monitor to set the hash.\n-  monitor = inflate(self, obj, inflate_cause_hash_code);\n-  \/\/ Load ObjectMonitor's header\/dmw field and see if it has a hash.\n-  mark = monitor->header();\n-  assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n-  hash = mark.hash();\n-  if (hash == 0) {                    \/\/ if it does not have a hash\n-    hash = get_next_hash(self, obj);  \/\/ get a new hash\n-    temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n-    assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n-    uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());\n-    test = markWord(v);\n-    if (test != mark) {\n-      \/\/ The attempt to update the ObjectMonitor's header\/dmw field\n-      \/\/ did not work. This can happen if another thread managed to\n-      \/\/ merge in the hash just before our cmpxchg().\n-      \/\/ If we add any new usages of the header\/dmw field, this code\n-      \/\/ will need to be updated.\n-      hash = test.hash();\n-      assert(test.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, test.value());\n-      assert(hash != 0, \"should only have lost the race to a thread that set a non-zero hash\");\n-    }\n-  }\n-  \/\/ We finally get the hash.\n-  return hash;\n+    if (hash == 0) {                    \/\/ if it does not have a hash\n+      hash = get_next_hash(self, obj);  \/\/ get a new hash\n+      temp = mark.copy_set_hash(hash);  \/\/ merge the hash into header\n+      assert(temp.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, temp.value());\n+      uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());\n+      test = markWord(v);\n+      if (test != mark) {\n+        \/\/ The attempt to update the ObjectMonitor's header\/dmw field\n+        \/\/ did not work. This can happen if another thread managed to\n+        \/\/ merge in the hash just before our cmpxchg().\n+        \/\/ If we add any new usages of the header\/dmw field, this code\n+        \/\/ will need to be updated.\n+        hash = test.hash();\n+        assert(test.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, test.value());\n+        assert(hash != 0, \"should only have lost the race to a thread that set a non-zero hash\");\n+      }\n+      if (monitor->is_being_async_deflated()) {\n+        \/\/ If we detect that async deflation has occurred, then we\n+        \/\/ attempt to restore the header\/dmw to the object's header\n+        \/\/ so that we only retry once if the deflater thread happens\n+        \/\/ to be slow.\n+        monitor->install_displaced_markword_in_object(obj);\n+        continue;\n+      }\n+    }\n+    \/\/ We finally get the hash.\n+    return hash;\n+  }\n@@ -1073,0 +1199,2 @@\n+    \/\/ The first stage of async deflation does not affect any field\n+    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n@@ -1114,1 +1242,1 @@\n-  \/\/ not at a safepoint.\n+  \/\/ not at a safepoint and AsyncDeflateIdleMonitors is false.\n@@ -1116,1 +1244,4 @@\n-    void* owner = mark.monitor()->_owner;\n+    \/\/ The first stage of async deflation does not affect any field\n+    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n+    ObjectMonitor* monitor = mark.monitor();\n+    void* owner = monitor->owner();\n@@ -1150,0 +1281,2 @@\n+    \/\/ The first stage of async deflation does not affect any field\n+    \/\/ used by this comparison so the ObjectMonitor* is usable here.\n@@ -1176,2 +1309,1 @@\n-      oop object = (oop)mid->object();\n-      if (object != NULL) {\n+      if (mid->object() != NULL) {\n@@ -1179,0 +1311,7 @@\n+\n+        \/\/ monitors_iterate() is only called at a safepoint or when the\n+        \/\/ target thread is suspended or when the target thread is\n+        \/\/ operating on itself. The current closures in use today are\n+        \/\/ only interested in an owned ObjectMonitor and ownership\n+        \/\/ cannot be dropped under the calling contexts so the\n+        \/\/ ObjectMonitor cannot be async deflated.\n@@ -1194,1 +1333,2 @@\n-    int monitors_used = population - Atomic::load(&om_list_globals._free_count);\n+    int monitors_used = population - Atomic::load(&om_list_globals._free_count) -\n+                        Atomic::load(&om_list_globals._wait_count);\n@@ -1201,10 +1341,6 @@\n-\/\/ Returns true if MonitorBound is set (> 0) and if the specified\n-\/\/ cnt is > MonitorBound. Otherwise returns false.\n-static bool is_MonitorBound_exceeded(const int cnt) {\n-  const int mx = MonitorBound;\n-  return mx > 0 && cnt > mx;\n-}\n-\n-bool ObjectSynchronizer::is_cleanup_needed() {\n-  if (monitors_used_above_threshold()) {\n-    \/\/ Too many monitors in use.\n+bool ObjectSynchronizer::is_async_deflation_needed() {\n+  if (!AsyncDeflateIdleMonitors) {\n+    return false;\n+  }\n+  if (is_async_deflation_requested()) {\n+    \/\/ Async deflation request.\n@@ -1213,1 +1349,11 @@\n-  return needs_monitor_scavenge();\n+  if (AsyncDeflationInterval > 0 &&\n+      time_since_last_async_deflation_ms() > AsyncDeflationInterval &&\n+      monitors_used_above_threshold()) {\n+    \/\/ It's been longer than our specified deflate interval and there\n+    \/\/ are too many monitors in use. We don't deflate more frequently\n+    \/\/ than AsyncDeflationInterval (unless is_async_deflation_requested)\n+    \/\/ in order to not swamp the ServiceThread.\n+    _last_async_deflation_time_ns = os::javaTimeNanos();\n+    return true;\n+  }\n+  return false;\n@@ -1216,3 +1362,11 @@\n-bool ObjectSynchronizer::needs_monitor_scavenge() {\n-  if (Atomic::load(&_forceMonitorScavenge) == 1) {\n-    log_info(monitorinflation)(\"Monitor scavenge needed, triggering safepoint cleanup.\");\n+bool ObjectSynchronizer::is_safepoint_deflation_needed() {\n+  if (!AsyncDeflateIdleMonitors) {\n+    if (monitors_used_above_threshold()) {\n+      \/\/ Too many monitors in use.\n+      return true;\n+    }\n+    return false;\n+  }\n+  if (is_special_deflation_requested()) {\n+    \/\/ For AsyncDeflateIdleMonitors only do a safepoint deflation\n+    \/\/ if there is a special deflation request.\n@@ -1224,0 +1378,4 @@\n+jlong ObjectSynchronizer::time_since_last_async_deflation_ms() {\n+  return (os::javaTimeNanos() - _last_async_deflation_time_ns) \/ (NANOUNITS \/ MILLIUNITS);\n+}\n+\n@@ -1232,0 +1390,1 @@\n+  \/\/ Acquire semantics not needed since we're at a safepoint.\n@@ -1257,1 +1416,1 @@\n-\/\/ STW-time -- disassociates idle monitors from objects.\n+\/\/ STW-time or asynchronously -- disassociates idle monitors from objects.\n@@ -1268,35 +1427,0 @@\n-\n-\/\/ Constraining monitor pool growth via MonitorBound ...\n-\/\/\n-\/\/ If MonitorBound is not set (<= 0), MonitorBound checks are disabled.\n-\/\/\n-\/\/ The monitor pool is grow-only.  We scavenge at STW safepoint-time, but the\n-\/\/ the rate of scavenging is driven primarily by GC.  As such,  we can find\n-\/\/ an inordinate number of monitors in circulation.\n-\/\/ To avoid that scenario we can artificially induce a STW safepoint\n-\/\/ if the pool appears to be growing past some reasonable bound.\n-\/\/ Generally we favor time in space-time tradeoffs, but as there's no\n-\/\/ natural back-pressure on the # of extant monitors we need to impose some\n-\/\/ type of limit.  Beware that if MonitorBound is set to too low a value\n-\/\/ we could just loop. In addition, if MonitorBound is set to a low value\n-\/\/ we'll incur more safepoints, which are harmful to performance.\n-\/\/ See also: GuaranteedSafepointInterval\n-\/\/\n-\/\/ If MonitorBound is set, the boundry applies to\n-\/\/     (om_list_globals._population - om_list_globals._free_count)\n-\/\/ i.e., if there are not enough ObjectMonitors on the global free list,\n-\/\/ then a safepoint deflation is induced. Picking a good MonitorBound value\n-\/\/ is non-trivial.\n-\n-static void InduceScavenge(Thread* self, const char * Whence) {\n-  \/\/ Induce STW safepoint to trim monitors\n-  \/\/ Ultimately, this results in a call to deflate_idle_monitors() in the near future.\n-  \/\/ More precisely, trigger a cleanup safepoint as the number\n-  \/\/ of active monitors passes the specified threshold.\n-  \/\/ TODO: assert thread state is reasonable\n-\n-  if (Atomic::xchg(&_forceMonitorScavenge, 1) == 0) {\n-    VMThread::check_for_forced_cleanup();\n-  }\n-}\n-\n@@ -1312,1 +1436,0 @@\n-  stringStream ss;\n@@ -1325,0 +1448,1 @@\n+      m->set_allocation_state(ObjectMonitor::New);\n@@ -1332,0 +1456,3 @@\n+    \/\/ Acquire semantics not needed on this list load since memory\n+    \/\/ is already consistent due to the cmpxchg() via\n+    \/\/ take_from_start_of_om_free_list() above.\n@@ -1342,0 +1469,18 @@\n+        if (AsyncDeflateIdleMonitors) {\n+          \/\/ We allowed 3 field values to linger during async deflation.\n+          \/\/ Clear or restore them as appropriate.\n+          take->set_header(markWord::zero());\n+          \/\/ DEFLATER_MARKER is the only non-NULL value we should see here.\n+          take->try_set_owner_from(DEFLATER_MARKER, NULL);\n+          if (take->contentions() < 0) {\n+            \/\/ Add back max_jint to restore the contentions field to its\n+            \/\/ proper value.\n+            take->add_to_contentions(max_jint);\n+\n+#ifdef ASSERT\n+            jint l_contentions = take->contentions();\n+#endif\n+            assert(l_contentions >= 0, \"must not be negative: l_contentions=%d, contentions=%d\",\n+                   l_contentions, take->contentions());\n+          }\n+        }\n@@ -1343,0 +1488,4 @@\n+        \/\/ Since we're taking from the global free-list, take must be Free.\n+        \/\/ om_release() also sets the allocation state to Free because it\n+        \/\/ is called from other code paths.\n+        assert(take->is_free(), \"invariant\");\n@@ -1347,9 +1496,0 @@\n-\n-      if (is_MonitorBound_exceeded(Atomic::load(&om_list_globals._population) -\n-                                   Atomic::load(&om_list_globals._free_count))) {\n-        \/\/ Not enough ObjectMonitors on the global free list.\n-        \/\/ We can't safely induce a STW safepoint from om_alloc() as our thread\n-        \/\/ state may not be appropriate for such activities and callers may hold\n-        \/\/ naked oops, so instead we defer the action.\n-        InduceScavenge(self, \"om_alloc\");\n-      }\n@@ -1385,0 +1525,1 @@\n+      assert(temp[i].is_free(), \"invariant\");\n@@ -1410,2 +1551,2 @@\n-\/\/ scavenger -- deflate_monitor_list() -- from reclaiming them while we\n-\/\/ are trying to release them.\n+\/\/ scavenger -- deflate_monitor_list() or deflate_monitor_list_using_JT()\n+\/\/ -- from reclaiming them while we are trying to release them.\n@@ -1419,4 +1560,6 @@\n-  stringStream ss;\n-  guarantee((m->is_busy() | m->_recursions) == 0, \"freeing in-use monitor: \"\n-            \"%s, recursions=\" INTX_FORMAT, m->is_busy_to_string(&ss),\n-            m->_recursions);\n+  if ((m->is_busy() | m->_recursions) != 0) {\n+    stringStream ss;\n+    fatal(\"freeing in-use monitor: %s, recursions=\" INTX_FORMAT,\n+          m->is_busy_to_string(&ss), m->_recursions);\n+  }\n+  m->set_allocation_state(ObjectMonitor::Free);\n@@ -1430,4 +1573,3 @@\n-    \/\/ This list walk can only race with another list walker since\n-    \/\/ deflation can only happen at a safepoint so we don't have to\n-    \/\/ worry about an ObjectMonitor being removed from this list\n-    \/\/ while we are walking it.\n+    \/\/ This list walk can race with another list walker or with async\n+    \/\/ deflation so we have to worry about an ObjectMonitor being\n+    \/\/ removed from this list while we are walking it.\n@@ -1435,1 +1577,2 @@\n-    \/\/ Lock the list head to avoid racing with another list walker.\n+    \/\/ Lock the list head to avoid racing with another list walker\n+    \/\/ or with async deflation.\n@@ -1444,1 +1587,3 @@\n-      \/\/ mid locked:\n+      \/\/ mid locked. Release semantics not needed on this \"unlock\" since\n+      \/\/ memory is already consistent due to the get_list_head_locked()\n+      \/\/ above.\n@@ -1451,1 +1596,3 @@\n-      \/\/ Lock mid to prevent races with a list walker:\n+      \/\/ Lock mid to prevent races with a list walker or an async\n+      \/\/ deflater thread that's ahead of us. The locked list head\n+      \/\/ prevents races from behind us.\n@@ -1456,1 +1603,3 @@\n-      \/\/ list head, but leaves the extracted mid locked:\n+      \/\/ list head, but leaves the extracted mid locked. Release semantics\n+      \/\/ not needed on this \"unlock\" since memory is already consistent\n+      \/\/ due to the get_list_head_locked() above.\n@@ -1460,1 +1609,0 @@\n-      om_unlock(mid);  \/\/ unlock the list head\n@@ -1466,0 +1614,5 @@\n+      \/\/ Lock anchor to prevent races with a list walker or an async\n+      \/\/ deflater thread that's ahead of us. The locked list head\n+      \/\/ prevents races from behind us.\n+      om_lock(anchor);\n+      om_unlock(mid);  \/\/ Unlock the list head now that anchor is locked.\n@@ -1469,1 +1622,0 @@\n-          om_lock(anchor);  \/\/ Lock the anchor so we can safely modify it.\n@@ -1473,1 +1625,4 @@\n-          \/\/ anchor, but leaves the extracted mid locked:\n+          \/\/ anchor, but leaves the extracted mid locked. Release semantics\n+          \/\/ not needed on this \"unlock\" since memory is already consistent\n+          \/\/ due to the om_unlock() above before entering the loop or the\n+          \/\/ om_unlock() below before looping again.\n@@ -1477,1 +1632,7 @@\n-          anchor = mid;\n+          \/\/ Lock the next anchor to prevent races with a list walker\n+          \/\/ or an async deflater thread that's ahead of us. The locked\n+          \/\/ current anchor prevents races from behind us.\n+          om_lock(mid);\n+          \/\/ Unlock current anchor now that next anchor is locked:\n+          om_unlock(anchor);\n+          anchor = mid;  \/\/ Advance to new anchor and try again.\n@@ -1498,0 +1659,1 @@\n+  guarantee(m->is_free(), \"invariant\");\n@@ -1512,0 +1674,5 @@\n+\/\/\n+\/\/ With AsyncDeflateIdleMonitors, deflate_global_idle_monitors_using_JT()\n+\/\/ and deflate_per_thread_idle_monitors_using_JT() (in another thread) can\n+\/\/ run at the same time as om_flush() so we have to follow a careful\n+\/\/ protocol to prevent list corruption.\n@@ -1520,2 +1687,5 @@\n-  \/\/ This function can race with a list walker thread so we lock the\n-  \/\/ list head to prevent confusion.\n+  \/\/ This function can race with a list walker or with an async\n+  \/\/ deflater thread so we lock the list head to prevent confusion.\n+  \/\/ An async deflater thread checks to see if the target thread\n+  \/\/ is exiting, but if it has made it past that check before we\n+  \/\/ started exiting, then it is racing to get to the in-use list.\n@@ -1536,1 +1706,1 @@\n-    for (ObjectMonitor* cur_om = unmarked_next(in_use_list); cur_om != NULL; cur_om = unmarked_next(cur_om)) {\n+    for (ObjectMonitor* cur_om = unmarked_next(in_use_list); cur_om != NULL;) {\n@@ -1538,2 +1708,2 @@\n-        \/\/ cur_om is locked so there must be a racing walker thread ahead\n-        \/\/ of us so we'll give it a chance to finish.\n+        \/\/ cur_om is locked so there must be a racing walker or async\n+        \/\/ deflater thread ahead of us so we'll give it a chance to finish.\n@@ -1543,0 +1713,11 @@\n+        \/\/ Refetch the possibly changed next field and try again.\n+        cur_om = unmarked_next(in_use_tail);\n+        continue;\n+      }\n+      if (cur_om->object() == NULL) {\n+        \/\/ cur_om was deflated and the object ref was cleared while it\n+        \/\/ was locked. We happened to see it just after it was unlocked\n+        \/\/ (and added to the free list). Refetch the possibly changed\n+        \/\/ next field and try again.\n+        cur_om = unmarked_next(in_use_tail);\n+        continue;\n@@ -1546,0 +1727,1 @@\n+      cur_om = unmarked_next(cur_om);\n@@ -1549,2 +1731,2 @@\n-    assert(l_om_in_use_count == in_use_count, \"in-use counts don't match: \"\n-          \"l_om_in_use_count=%d, in_use_count=%d\", l_om_in_use_count, in_use_count);\n+    ADIM_guarantee(l_om_in_use_count == in_use_count, \"in-use counts don't match: \"\n+                   \"l_om_in_use_count=%d, in_use_count=%d\", l_om_in_use_count, in_use_count);\n@@ -1552,0 +1734,1 @@\n+    OrderAccess::storestore();  \/\/ Make sure counter update is seen first.\n@@ -1585,2 +1768,4 @@\n-      stringStream ss;\n-      guarantee(!s->is_busy(), \"must be !is_busy: %s\", s->is_busy_to_string(&ss));\n+      if (s->is_busy()) {\n+        stringStream ss;\n+        fatal(\"must be !is_busy: %s\", s->is_busy_to_string(&ss));\n+      }\n@@ -1590,2 +1775,2 @@\n-    assert(l_om_free_count == free_count, \"free counts don't match: \"\n-           \"l_om_free_count=%d, free_count=%d\", l_om_free_count, free_count);\n+    ADIM_guarantee(l_om_free_count == free_count, \"free counts don't match: \"\n+                   \"l_om_free_count=%d, free_count=%d\", l_om_free_count, free_count);\n@@ -1593,0 +1778,1 @@\n+    OrderAccess::storestore();  \/\/ Make sure counter update is seen first.\n@@ -1636,2 +1822,4 @@\n-    assert(ObjectSynchronizer::verify_objmon_isinpool(mark.monitor()), \"monitor is invalid\");\n-    assert(mark.monitor()->header().is_neutral(), \"monitor must record a good object header\");\n+    ObjectMonitor* monitor = mark.monitor();\n+    assert(ObjectSynchronizer::verify_objmon_isinpool(monitor), \"monitor=\" INTPTR_FORMAT \" is invalid\", p2i(monitor));\n+    markWord dmw = monitor->header();\n+    assert(dmw.is_neutral(), \"sanity check: header=\" INTPTR_FORMAT, dmw.value());\n@@ -1640,1 +1828,1 @@\n-  inflate(Thread::current(), obj, inflate_cause_vm_internal);\n+  (void)inflate(Thread::current(), obj, inflate_cause_vm_internal);\n@@ -1643,2 +1831,2 @@\n-ObjectMonitor* ObjectSynchronizer::inflate(Thread* self,\n-                                           oop object, const InflateCause cause) {\n+ObjectMonitor* ObjectSynchronizer::inflate(Thread* self, oop object,\n+                                           const InflateCause cause) {\n@@ -1668,1 +1856,1 @@\n-      assert(inf->object() == object, \"invariant\");\n+      assert(AsyncDeflateIdleMonitors || inf->object() == object, \"invariant\");\n@@ -1716,0 +1904,1 @@\n+        \/\/ om_release() will reset the allocation state from New to Free.\n@@ -1753,1 +1942,1 @@\n-      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      ADIM_guarantee(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n@@ -1763,1 +1952,5 @@\n-      m->set_owner_from(NULL, mark.locker());\n+      if (AsyncDeflateIdleMonitors) {\n+        m->set_owner_from(NULL, DEFLATER_MARKER, mark.locker());\n+      } else {\n+        m->set_owner_from(NULL, mark.locker());\n+      }\n@@ -1770,0 +1963,1 @@\n+      \/\/ Release semantics so that above set_object() is seen first.\n@@ -1772,0 +1966,6 @@\n+      \/\/ Once ObjectMonitor is configured and the object is associated\n+      \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+      assert(m->is_new(), \"freshly allocated monitor must be new\");\n+      \/\/ Release semantics needed to keep allocation_state from floating up.\n+      m->release_set_allocation_state(ObjectMonitor::Old);\n+\n@@ -1798,1 +1998,1 @@\n-    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ADIM_guarantee(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n@@ -1803,0 +2003,4 @@\n+    if (AsyncDeflateIdleMonitors) {\n+      \/\/ DEFLATER_MARKER is the only non-NULL value we should see here.\n+      m->try_set_owner_from(DEFLATER_MARKER, NULL);\n+    }\n@@ -1811,0 +2015,1 @@\n+      \/\/ om_release() will reset the allocation state from New to Free.\n@@ -1819,0 +2024,7 @@\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    assert(m->is_new(), \"freshly allocated monitor must be new\");\n+    \/\/ Release semantics are not needed to keep allocation_state from\n+    \/\/ floating up since cas_set_mark() takes care of it.\n+    m->set_allocation_state(ObjectMonitor::Old);\n+\n@@ -1838,0 +2050,1 @@\n+\/\/ For safepoint based deflation:\n@@ -1856,0 +2069,34 @@\n+\/\/\n+\/\/ For async deflation:\n+\/\/ If a special deflation request is made, then the safepoint based\n+\/\/ deflation mechanism is used. Otherwise, an async deflation request\n+\/\/ is registered with the ServiceThread and it is notified.\n+\n+void ObjectSynchronizer::do_safepoint_work(DeflateMonitorCounters* counters) {\n+  assert(SafepointSynchronize::is_at_safepoint(), \"must be at safepoint\");\n+\n+  \/\/ The per-thread in-use lists are handled in\n+  \/\/ ParallelSPCleanupThreadClosure::do_thread().\n+\n+  if (!AsyncDeflateIdleMonitors || is_special_deflation_requested()) {\n+    \/\/ Use the older mechanism for the global in-use list or if a\n+    \/\/ special deflation has been requested before the safepoint.\n+    ObjectSynchronizer::deflate_idle_monitors(counters);\n+    return;\n+  }\n+\n+  log_debug(monitorinflation)(\"requesting async deflation of idle monitors.\");\n+  \/\/ Request deflation of idle monitors by the ServiceThread:\n+  set_is_async_deflation_requested(true);\n+  MonitorLocker ml(Service_lock, Mutex::_no_safepoint_check_flag);\n+  ml.notify_all();\n+\n+  if (log_is_enabled(Debug, monitorinflation)) {\n+    \/\/ exit_globals()'s call to audit_and_print_stats() is done\n+    \/\/ at the Info level and not at a safepoint.\n+    \/\/ For safepoint based deflation, audit_and_print_stats() is called\n+    \/\/ in ObjectSynchronizer::finish_deflate_idle_monitors() at the\n+    \/\/ Debug level at a safepoint.\n+    ObjectSynchronizer::audit_and_print_stats(false \/* on_exit *\/);\n+  }\n+}\n@@ -1890,0 +2137,1 @@\n+    \/\/ XXX - I have no rationale for this \"release\", but it's been here forever.\n@@ -1891,0 +2139,5 @@\n+    if (AsyncDeflateIdleMonitors) {\n+      \/\/ clear() expects the owner field to be NULL.\n+      \/\/ DEFLATER_MARKER is the only non-NULL value we should see here.\n+      mid->try_set_owner_from(DEFLATER_MARKER, NULL);\n+    }\n@@ -1895,0 +2148,1 @@\n+    assert(mid->is_free(), \"invariant\");\n@@ -1923,0 +2177,122 @@\n+\/\/ Deflate the specified ObjectMonitor if not in-use using a JavaThread.\n+\/\/ Returns true if it was deflated and false otherwise.\n+\/\/\n+\/\/ The async deflation protocol sets owner to DEFLATER_MARKER and\n+\/\/ makes contentions negative as signals to contending threads that\n+\/\/ an async deflation is in progress. There are a number of checks\n+\/\/ as part of the protocol to make sure that the calling thread has\n+\/\/ not lost the race to a contending thread.\n+\/\/\n+\/\/ The ObjectMonitor has been successfully async deflated when:\n+\/\/   (contentions < 0)\n+\/\/ Contending threads that see that condition know to retry their operation.\n+\/\/\n+bool ObjectSynchronizer::deflate_monitor_using_JT(ObjectMonitor* mid,\n+                                                  ObjectMonitor** free_head_p,\n+                                                  ObjectMonitor** free_tail_p) {\n+  assert(AsyncDeflateIdleMonitors, \"sanity check\");\n+  assert(Thread::current()->is_Java_thread(), \"precondition\");\n+  \/\/ A newly allocated ObjectMonitor should not be seen here so we\n+  \/\/ avoid an endless inflate\/deflate cycle.\n+  assert(mid->is_old(), \"must be old: allocation_state=%d\",\n+         (int) mid->allocation_state());\n+\n+  if (mid->is_busy()) {\n+    \/\/ Easy checks are first - the ObjectMonitor is busy so no deflation.\n+    return false;\n+  }\n+\n+  \/\/ Set a NULL owner to DEFLATER_MARKER to force any contending thread\n+  \/\/ through the slow path. This is just the first part of the async\n+  \/\/ deflation dance.\n+  if (mid->try_set_owner_from(NULL, DEFLATER_MARKER) != NULL) {\n+    \/\/ The owner field is no longer NULL so we lost the race since the\n+    \/\/ ObjectMonitor is now busy.\n+    return false;\n+  }\n+\n+  if (mid->contentions() > 0 || mid->_waiters != 0) {\n+    \/\/ Another thread has raced to enter the ObjectMonitor after\n+    \/\/ mid->is_busy() above or has already entered and waited on\n+    \/\/ it which makes it busy so no deflation. Restore owner to\n+    \/\/ NULL if it is still DEFLATER_MARKER.\n+    if (mid->try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+      \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n+      mid->add_to_contentions(-1);\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Make a zero contentions field negative to force any contending threads\n+  \/\/ to retry. This is the second part of the async deflation dance.\n+  if (Atomic::cmpxchg(&mid->_contentions, (jint)0, -max_jint) != 0) {\n+    \/\/ Contentions was no longer 0 so we lost the race since the\n+    \/\/ ObjectMonitor is now busy. Restore owner to NULL if it is\n+    \/\/ still DEFLATER_MARKER:\n+    if (mid->try_set_owner_from(DEFLATER_MARKER, NULL) != DEFLATER_MARKER) {\n+      \/\/ Deferred decrement for the JT EnterI() that cancelled the async deflation.\n+      mid->add_to_contentions(-1);\n+    }\n+    return false;\n+  }\n+\n+  \/\/ Sanity checks for the races:\n+  guarantee(mid->owner_is_DEFLATER_MARKER(), \"must be deflater marker\");\n+  guarantee(mid->contentions() < 0, \"must be negative: contentions=%d\",\n+            mid->contentions());\n+  guarantee(mid->_waiters == 0, \"must be 0: waiters=%d\", mid->_waiters);\n+  guarantee(mid->_cxq == NULL, \"must be no contending threads: cxq=\"\n+            INTPTR_FORMAT, p2i(mid->_cxq));\n+  guarantee(mid->_EntryList == NULL,\n+            \"must be no entering threads: EntryList=\" INTPTR_FORMAT,\n+            p2i(mid->_EntryList));\n+\n+  const oop obj = (oop) mid->object();\n+  if (log_is_enabled(Trace, monitorinflation)) {\n+    ResourceMark rm;\n+    log_trace(monitorinflation)(\"deflate_monitor_using_JT: \"\n+                                \"object=\" INTPTR_FORMAT \", mark=\"\n+                                INTPTR_FORMAT \", type='%s'\",\n+                                p2i(obj), obj->mark().value(),\n+                                obj->klass()->external_name());\n+  }\n+\n+  \/\/ Install the old mark word if nobody else has already done it.\n+  mid->install_displaced_markword_in_object(obj);\n+  mid->clear_common();\n+\n+  assert(mid->object() == NULL, \"must be NULL: object=\" INTPTR_FORMAT,\n+         p2i(mid->object()));\n+  assert(mid->is_free(), \"must be free: allocation_state=%d\",\n+         (int)mid->allocation_state());\n+\n+  \/\/ Move the deflated ObjectMonitor to the working free list\n+  \/\/ defined by free_head_p and free_tail_p.\n+  if (*free_head_p == NULL) {\n+    \/\/ First one on the list.\n+    *free_head_p = mid;\n+  }\n+  if (*free_tail_p != NULL) {\n+    \/\/ We append to the list so the caller can use mid->_next_om\n+    \/\/ to fix the linkages in its context.\n+    ObjectMonitor* prevtail = *free_tail_p;\n+    \/\/ prevtail should have been cleaned up by the caller:\n+#ifdef ASSERT\n+    ObjectMonitor* l_next_om = unmarked_next(prevtail);\n+#endif\n+    assert(l_next_om == NULL, \"must be NULL: _next_om=\" INTPTR_FORMAT, p2i(l_next_om));\n+    om_lock(prevtail);\n+    prevtail->set_next_om(mid);  \/\/ prevtail now points to mid (and is unlocked)\n+  }\n+  *free_tail_p = mid;\n+\n+  \/\/ At this point, mid->_next_om still refers to its current\n+  \/\/ value and another ObjectMonitor's _next_om field still\n+  \/\/ refers to this ObjectMonitor. Those linkages have to be\n+  \/\/ cleaned up by the caller who has the complete context.\n+\n+  \/\/ We leave owner == DEFLATER_MARKER and contentions < 0\n+  \/\/ to force any racing threads to retry.\n+  return true;  \/\/ Success, ObjectMonitor has been deflated.\n+}\n+\n@@ -1964,1 +2340,2 @@\n-      \/\/ mid is current tail in the free_head_p list so NULL terminate it:\n+      \/\/ mid is current tail in the free_head_p list so NULL terminate it.\n+      \/\/ No release semantics needed since Atomic::dec() already provides it.\n@@ -1973,0 +2350,148 @@\n+\/\/ Walk a given ObjectMonitor list and deflate idle ObjectMonitors using\n+\/\/ a JavaThread. Returns the number of deflated ObjectMonitors. The given\n+\/\/ list could be a per-thread in-use list or the global in-use list.\n+\/\/ If a safepoint has started, then we save state via saved_mid_in_use_p\n+\/\/ and return to the caller to honor the safepoint.\n+\/\/\n+int ObjectSynchronizer::deflate_monitor_list_using_JT(ObjectMonitor** list_p,\n+                                                      int* count_p,\n+                                                      ObjectMonitor** free_head_p,\n+                                                      ObjectMonitor** free_tail_p,\n+                                                      ObjectMonitor** saved_mid_in_use_p) {\n+  assert(AsyncDeflateIdleMonitors, \"sanity check\");\n+  JavaThread* self = JavaThread::current();\n+\n+  ObjectMonitor* cur_mid_in_use = NULL;\n+  ObjectMonitor* mid = NULL;\n+  ObjectMonitor* next = NULL;\n+  ObjectMonitor* next_next = NULL;\n+  int deflated_count = 0;\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ We use the more complicated lock-cur_mid_in_use-and-mid-as-we-go\n+  \/\/ protocol because om_release() can do list deletions in parallel;\n+  \/\/ this also prevents races with a list walker thread. We also\n+  \/\/ lock-next-next-as-we-go to prevent an om_flush() that is behind\n+  \/\/ this thread from passing us.\n+  if (*saved_mid_in_use_p == NULL) {\n+    \/\/ No saved state so start at the beginning.\n+    \/\/ Lock the list head so we can possibly deflate it:\n+    if ((mid = get_list_head_locked(list_p)) == NULL) {\n+      return 0;  \/\/ The list is empty so nothing to deflate.\n+    }\n+    next = unmarked_next(mid);\n+  } else {\n+    \/\/ We're restarting after a safepoint so restore the necessary state\n+    \/\/ before we resume.\n+    cur_mid_in_use = *saved_mid_in_use_p;\n+    \/\/ Lock cur_mid_in_use so we can possibly update its\n+    \/\/ next field to extract a deflated ObjectMonitor.\n+    om_lock(cur_mid_in_use);\n+    mid = unmarked_next(cur_mid_in_use);\n+    if (mid == NULL) {\n+      om_unlock(cur_mid_in_use);\n+      *saved_mid_in_use_p = NULL;\n+      return 0;  \/\/ The remainder is empty so nothing more to deflate.\n+    }\n+    \/\/ Lock mid so we can possibly deflate it:\n+    om_lock(mid);\n+    next = unmarked_next(mid);\n+  }\n+\n+  while (true) {\n+    \/\/ The current mid is locked at this point. If we have a\n+    \/\/ cur_mid_in_use, then it is also locked at this point.\n+\n+    if (next != NULL) {\n+      \/\/ We lock next so that an om_flush() thread that is behind us\n+      \/\/ cannot pass us when we unlock the current mid.\n+      om_lock(next);\n+      next_next = unmarked_next(next);\n+    }\n+\n+    \/\/ Only try to deflate if there is an associated Java object and if\n+    \/\/ mid is old (is not newly allocated and is not newly freed).\n+    if (mid->object() != NULL && mid->is_old() &&\n+        deflate_monitor_using_JT(mid, free_head_p, free_tail_p)) {\n+      \/\/ Deflation succeeded and already updated free_head_p and\n+      \/\/ free_tail_p as needed. Finish the move to the local free list\n+      \/\/ by unlinking mid from the global or per-thread in-use list.\n+      if (cur_mid_in_use == NULL) {\n+        \/\/ mid is the list head and it is locked. Switch the list head\n+        \/\/ to next which is also locked (if not NULL) and also leave\n+        \/\/ mid locked. Release semantics needed since not all code paths\n+        \/\/ in deflate_monitor_using_JT() ensure memory consistency.\n+        Atomic::release_store(list_p, next);\n+      } else {\n+        ObjectMonitor* locked_next = mark_om_ptr(next);\n+        \/\/ mid and cur_mid_in_use are locked. Switch cur_mid_in_use's\n+        \/\/ next field to locked_next and also leave mid locked.\n+        \/\/ Release semantics needed since not all code paths in\n+        \/\/ deflate_monitor_using_JT() ensure memory consistency.\n+        cur_mid_in_use->release_set_next_om(locked_next);\n+      }\n+      \/\/ At this point mid is disconnected from the in-use list so\n+      \/\/ its lock longer has any effects on in-use list.\n+      deflated_count++;\n+      Atomic::dec(count_p);\n+      \/\/ mid is current tail in the free_head_p list so NULL terminate\n+      \/\/ it (which also unlocks it). No release semantics needed since\n+      \/\/ Atomic::dec() already provides it.\n+      mid->set_next_om(NULL);\n+\n+      \/\/ All the list management is done so move on to the next one:\n+      mid = next;  \/\/ mid keeps non-NULL next's locked state\n+      next = next_next;\n+    } else {\n+      \/\/ mid is considered in-use if it does not have an associated\n+      \/\/ Java object or mid is not old or deflation did not succeed.\n+      \/\/ A mid->is_new() node can be seen here when it is freshly\n+      \/\/ returned by om_alloc() (and skips the deflation code path).\n+      \/\/ A mid->is_old() node can be seen here when deflation failed.\n+      \/\/ A mid->is_free() node can be seen here when a fresh node from\n+      \/\/ om_alloc() is released by om_release() due to losing the race\n+      \/\/ in inflate().\n+\n+      \/\/ All the list management is done so move on to the next one:\n+      if (cur_mid_in_use != NULL) {\n+        om_unlock(cur_mid_in_use);\n+      }\n+      \/\/ The next cur_mid_in_use keeps mid's lock state so\n+      \/\/ that it is stable for a possible next field change. It\n+      \/\/ cannot be modified by om_release() while it is locked.\n+      cur_mid_in_use = mid;\n+      mid = next;  \/\/ mid keeps non-NULL next's locked state\n+      next = next_next;\n+\n+      if (SafepointMechanism::should_block(self) &&\n+          \/\/ Acquire semantics are not needed on this list load since\n+          \/\/ it is not dependent on the following load which does have\n+          \/\/ acquire semantics.\n+          cur_mid_in_use != Atomic::load(list_p) && cur_mid_in_use->is_old()) {\n+        \/\/ If a safepoint has started and cur_mid_in_use is not the list\n+        \/\/ head and is old, then it is safe to use as saved state. Return\n+        \/\/ to the caller before blocking.\n+        *saved_mid_in_use_p = cur_mid_in_use;\n+        om_unlock(cur_mid_in_use);\n+        if (mid != NULL) {\n+          om_unlock(mid);\n+        }\n+        return deflated_count;\n+      }\n+    }\n+    if (mid == NULL) {\n+      if (cur_mid_in_use != NULL) {\n+        om_unlock(cur_mid_in_use);\n+      }\n+      break;  \/\/ Reached end of the list so nothing more to deflate.\n+    }\n+\n+    \/\/ The current mid's next field is locked at this point. If we have\n+    \/\/ a cur_mid_in_use, then it is also locked at this point.\n+  }\n+  \/\/ We finished the list without a safepoint starting so there's\n+  \/\/ no need to save state.\n+  *saved_mid_in_use_p = NULL;\n+  return deflated_count;\n+}\n+\n@@ -1983,0 +2508,9 @@\n+\n+  if (AsyncDeflateIdleMonitors) {\n+    \/\/ Nothing to do when global idle ObjectMonitors are deflated using\n+    \/\/ a JavaThread unless a special deflation has been requested.\n+    if (!is_special_deflation_requested()) {\n+      return;\n+    }\n+  }\n+\n@@ -1998,0 +2532,1 @@\n+  \/\/ Acquire semantics not needed since we are at a safepoint.\n@@ -2035,0 +2570,199 @@\n+class HandshakeForDeflation : public HandshakeClosure {\n+ public:\n+  HandshakeForDeflation() : HandshakeClosure(\"HandshakeForDeflation\") {}\n+\n+  void do_thread(Thread* thread) {\n+    log_trace(monitorinflation)(\"HandshakeForDeflation::do_thread: thread=\"\n+                                INTPTR_FORMAT, p2i(thread));\n+  }\n+};\n+\n+void ObjectSynchronizer::deflate_idle_monitors_using_JT() {\n+  assert(AsyncDeflateIdleMonitors, \"sanity check\");\n+\n+  \/\/ Deflate any global idle monitors.\n+  deflate_global_idle_monitors_using_JT();\n+\n+  int count = 0;\n+  for (JavaThreadIteratorWithHandle jtiwh; JavaThread *jt = jtiwh.next(); ) {\n+    if (Atomic::load(&jt->om_in_use_count) > 0 && !jt->is_exiting()) {\n+      \/\/ This JavaThread is using ObjectMonitors so deflate any that\n+      \/\/ are idle unless this JavaThread is exiting; do not race with\n+      \/\/ ObjectSynchronizer::om_flush().\n+      deflate_per_thread_idle_monitors_using_JT(jt);\n+      count++;\n+    }\n+  }\n+  if (count > 0) {\n+    log_debug(monitorinflation)(\"did async deflation of idle monitors for %d thread(s).\", count);\n+  }\n+\n+  log_info(monitorinflation)(\"async global_population=%d, global_in_use_count=%d, \"\n+                             \"global_free_count=%d, global_wait_count=%d\",\n+                             Atomic::load(&om_list_globals._population),\n+                             Atomic::load(&om_list_globals._in_use_count),\n+                             Atomic::load(&om_list_globals._free_count),\n+                             Atomic::load(&om_list_globals._wait_count));\n+\n+  \/\/ The ServiceThread's async deflation request has been processed.\n+  set_is_async_deflation_requested(false);\n+\n+  if (Atomic::load(&om_list_globals._wait_count) > 0) {\n+    \/\/ There are deflated ObjectMonitors waiting for a handshake\n+    \/\/ (or a safepoint) for safety.\n+\n+    ObjectMonitor* list = Atomic::load(&om_list_globals._wait_list);\n+    ADIM_guarantee(list != NULL, \"om_list_globals._wait_list must not be NULL\");\n+    int count = Atomic::load(&om_list_globals._wait_count);\n+    Atomic::store(&om_list_globals._wait_count, 0);\n+    OrderAccess::storestore();  \/\/ Make sure counter update is seen first.\n+    Atomic::store(&om_list_globals._wait_list, (ObjectMonitor*)NULL);\n+\n+    \/\/ Find the tail for prepend_list_to_common(). No need to mark\n+    \/\/ ObjectMonitors for this list walk since only the deflater\n+    \/\/ thread manages the wait list.\n+    int l_count = 0;\n+    ObjectMonitor* tail = NULL;\n+    for (ObjectMonitor* n = list; n != NULL; n = unmarked_next(n)) {\n+      tail = n;\n+      l_count++;\n+    }\n+    ADIM_guarantee(count == l_count, \"count=%d != l_count=%d\", count, l_count);\n+\n+    \/\/ Will execute a safepoint if !ThreadLocalHandshakes:\n+    HandshakeForDeflation hfd_hc;\n+    Handshake::execute(&hfd_hc);\n+\n+    prepend_list_to_common(list, tail, count, &om_list_globals._free_list,\n+                           &om_list_globals._free_count);\n+\n+    log_info(monitorinflation)(\"moved %d idle monitors from global waiting list to global free list\", count);\n+  }\n+}\n+\n+\/\/ Deflate global idle ObjectMonitors using a JavaThread.\n+\/\/\n+void ObjectSynchronizer::deflate_global_idle_monitors_using_JT() {\n+  assert(AsyncDeflateIdleMonitors, \"sanity check\");\n+  assert(Thread::current()->is_Java_thread(), \"precondition\");\n+  JavaThread* self = JavaThread::current();\n+\n+  deflate_common_idle_monitors_using_JT(true \/* is_global *\/, self);\n+}\n+\n+\/\/ Deflate the specified JavaThread's idle ObjectMonitors using a JavaThread.\n+\/\/\n+void ObjectSynchronizer::deflate_per_thread_idle_monitors_using_JT(JavaThread* target) {\n+  assert(AsyncDeflateIdleMonitors, \"sanity check\");\n+  assert(Thread::current()->is_Java_thread(), \"precondition\");\n+\n+  deflate_common_idle_monitors_using_JT(false \/* !is_global *\/, target);\n+}\n+\n+\/\/ Deflate global or per-thread idle ObjectMonitors using a JavaThread.\n+\/\/\n+void ObjectSynchronizer::deflate_common_idle_monitors_using_JT(bool is_global, JavaThread* target) {\n+  JavaThread* self = JavaThread::current();\n+\n+  int deflated_count = 0;\n+  ObjectMonitor* free_head_p = NULL;  \/\/ Local SLL of scavenged ObjectMonitors\n+  ObjectMonitor* free_tail_p = NULL;\n+  ObjectMonitor* saved_mid_in_use_p = NULL;\n+  elapsedTimer timer;\n+\n+  if (log_is_enabled(Info, monitorinflation)) {\n+    timer.start();\n+  }\n+\n+  if (is_global) {\n+    OM_PERFDATA_OP(MonExtant, set_value(Atomic::load(&om_list_globals._in_use_count)));\n+  } else {\n+    OM_PERFDATA_OP(MonExtant, inc(Atomic::load(&target->om_in_use_count)));\n+  }\n+\n+  do {\n+    if (saved_mid_in_use_p != NULL) {\n+      \/\/ We looped around because deflate_monitor_list_using_JT()\n+      \/\/ detected a pending safepoint. Honoring the safepoint is good,\n+      \/\/ but as long as is_special_deflation_requested() is supported,\n+      \/\/ we can't safely restart using saved_mid_in_use_p. That saved\n+      \/\/ ObjectMonitor could have been deflated by safepoint based\n+      \/\/ deflation and would no longer be on the in-use list where we\n+      \/\/ originally found it.\n+      saved_mid_in_use_p = NULL;\n+    }\n+    int local_deflated_count;\n+    if (is_global) {\n+      local_deflated_count =\n+          deflate_monitor_list_using_JT(&om_list_globals._in_use_list,\n+                                        &om_list_globals._in_use_count,\n+                                        &free_head_p, &free_tail_p,\n+                                        &saved_mid_in_use_p);\n+    } else {\n+      local_deflated_count =\n+          deflate_monitor_list_using_JT(&target->om_in_use_list,\n+                                        &target->om_in_use_count, &free_head_p,\n+                                        &free_tail_p, &saved_mid_in_use_p);\n+    }\n+    deflated_count += local_deflated_count;\n+\n+    if (free_head_p != NULL) {\n+      \/\/ Move the deflated ObjectMonitors to the global free list.\n+      guarantee(free_tail_p != NULL && local_deflated_count > 0, \"free_tail_p=\" INTPTR_FORMAT \", local_deflated_count=%d\", p2i(free_tail_p), local_deflated_count);\n+      \/\/ Note: The target thread can be doing an om_alloc() that\n+      \/\/ is trying to prepend an ObjectMonitor on its in-use list\n+      \/\/ at the same time that we have deflated the current in-use\n+      \/\/ list head and put it on the local free list. prepend_to_common()\n+      \/\/ will detect the race and retry which avoids list corruption,\n+      \/\/ but the next field in free_tail_p can flicker to marked\n+      \/\/ and then unmarked while prepend_to_common() is sorting it\n+      \/\/ all out.\n+#ifdef ASSERT\n+      ObjectMonitor* l_next_om = unmarked_next(free_tail_p);\n+#endif\n+      assert(l_next_om == NULL, \"must be NULL: _next_om=\" INTPTR_FORMAT, p2i(l_next_om));\n+\n+      prepend_list_to_global_wait_list(free_head_p, free_tail_p, local_deflated_count);\n+\n+      OM_PERFDATA_OP(Deflations, inc(local_deflated_count));\n+    }\n+\n+    if (saved_mid_in_use_p != NULL) {\n+      \/\/ deflate_monitor_list_using_JT() detected a safepoint starting.\n+      timer.stop();\n+      {\n+        if (is_global) {\n+          log_debug(monitorinflation)(\"pausing deflation of global idle monitors for a safepoint.\");\n+        } else {\n+          log_debug(monitorinflation)(\"jt=\" INTPTR_FORMAT \": pausing deflation of per-thread idle monitors for a safepoint.\", p2i(target));\n+        }\n+        assert(SafepointMechanism::should_block(self), \"sanity check\");\n+        ThreadBlockInVM blocker(self);\n+      }\n+      \/\/ Prepare for another loop after the safepoint.\n+      free_head_p = NULL;\n+      free_tail_p = NULL;\n+      if (log_is_enabled(Info, monitorinflation)) {\n+        timer.start();\n+      }\n+    }\n+  } while (saved_mid_in_use_p != NULL);\n+  timer.stop();\n+\n+  LogStreamHandle(Debug, monitorinflation) lsh_debug;\n+  LogStreamHandle(Info, monitorinflation) lsh_info;\n+  LogStream* ls = NULL;\n+  if (log_is_enabled(Debug, monitorinflation)) {\n+    ls = &lsh_debug;\n+  } else if (deflated_count != 0 && log_is_enabled(Info, monitorinflation)) {\n+    ls = &lsh_info;\n+  }\n+  if (ls != NULL) {\n+    if (is_global) {\n+      ls->print_cr(\"async-deflating global idle monitors, %3.7f secs, %d monitors\", timer.seconds(), deflated_count);\n+    } else {\n+      ls->print_cr(\"jt=\" INTPTR_FORMAT \": async-deflating per-thread idle monitors, %3.7f secs, %d monitors\", p2i(target), timer.seconds(), deflated_count);\n+    }\n+  }\n+}\n+\n@@ -2042,0 +2776,7 @@\n+  bool needs_special_deflation = is_special_deflation_requested();\n+  if (AsyncDeflateIdleMonitors && !needs_special_deflation) {\n+    \/\/ Nothing to do when idle ObjectMonitors are deflated using\n+    \/\/ a JavaThread unless a special deflation has been requested.\n+    return;\n+  }\n+\n@@ -2045,0 +2786,3 @@\n+    \/\/ For async deflation, audit_and_print_stats() is called in\n+    \/\/ ObjectSynchronizer::do_safepoint_work() at the Debug level\n+    \/\/ at a safepoint.\n@@ -2048,1 +2792,1 @@\n-                               \"global_free_count=%d\",\n+                               \"global_free_count=%d, global_wait_count=%d\",\n@@ -2051,1 +2795,2 @@\n-                               Atomic::load(&om_list_globals._free_count));\n+                               Atomic::load(&om_list_globals._free_count),\n+                               Atomic::load(&om_list_globals._wait_count));\n@@ -2054,2 +2799,0 @@\n-  Atomic::store(&_forceMonitorScavenge, 0);    \/\/ Reset\n-\n@@ -2061,0 +2804,4 @@\n+\n+  if (needs_special_deflation) {\n+    set_is_special_deflation_requested(false);  \/\/ special deflation is done\n+  }\n@@ -2066,0 +2813,5 @@\n+  if (AsyncDeflateIdleMonitors && !is_special_deflation_requested()) {\n+    \/\/ Nothing to do if a special deflation has NOT been requested.\n+    return;\n+  }\n+\n@@ -2243,0 +2995,3 @@\n+  \/\/ Check om_list_globals._wait_list and om_list_globals._wait_count:\n+  chk_global_wait_list_and_count(ls, &error_cnt);\n+\n@@ -2293,1 +3048,2 @@\n-    } else {\n+      *error_cnt_p = *error_cnt_p + 1;\n+    } else if (!AsyncDeflateIdleMonitors) {\n@@ -2297,0 +3053,1 @@\n+      *error_cnt_p = *error_cnt_p + 1;\n@@ -2298,1 +3055,0 @@\n-    *error_cnt_p = *error_cnt_p + 1;\n@@ -2365,0 +3121,30 @@\n+\/\/ Check the global wait list and count; log the results of the checks.\n+void ObjectSynchronizer::chk_global_wait_list_and_count(outputStream * out,\n+                                                        int *error_cnt_p) {\n+  int chk_om_wait_count = 0;\n+  ObjectMonitor* cur = NULL;\n+  if ((cur = get_list_head_locked(&om_list_globals._wait_list)) != NULL) {\n+    \/\/ Marked the global wait list head so process the list.\n+    while (true) {\n+      \/\/ Rules for om_list_globals._wait_list are the same as for\n+      \/\/ om_list_globals._free_list:\n+      chk_free_entry(NULL \/* jt *\/, cur, out, error_cnt_p);\n+      chk_om_wait_count++;\n+\n+      cur = lock_next_for_traversal(cur);\n+      if (cur == NULL) {\n+        break;\n+      }\n+    }\n+  }\n+  if (Atomic::load(&om_list_globals._wait_count) == chk_om_wait_count) {\n+    out->print_cr(\"global_wait_count=%d equals chk_om_wait_count=%d\",\n+                  Atomic::load(&om_list_globals._wait_count), chk_om_wait_count);\n+  } else {\n+    out->print_cr(\"ERROR: global_wait_count=%d is not equal to \"\n+                  \"chk_om_wait_count=%d\",\n+                  Atomic::load(&om_list_globals._wait_count), chk_om_wait_count);\n+    *error_cnt_p = *error_cnt_p + 1;\n+  }\n+}\n+\n@@ -2588,3 +3374,3 @@\n-  out->print_cr(\"%18s  %10s  %10s  %10s\",\n-                \"Global Lists:\", \"InUse\", \"Free\", \"Total\");\n-  out->print_cr(\"==================  ==========  ==========  ==========\");\n+  out->print_cr(\"%18s  %10s  %10s  %10s  %10s\",\n+                \"Global Lists:\", \"InUse\", \"Free\", \"Wait\", \"Total\");\n+  out->print_cr(\"==================  ==========  ==========  ==========  ==========\");\n@@ -2593,3 +3379,5 @@\n-  out->print_cr(\"%18s  %10d  %10d  %10d\", \"\", l_in_use_count,\n-                l_free_count, Atomic::load(&om_list_globals._population));\n-  pop_count += l_in_use_count + l_free_count;\n+  int l_wait_count = Atomic::load(&om_list_globals._wait_count);\n+  out->print_cr(\"%18s  %10d  %10d  %10d  %10d\", \"\", l_in_use_count,\n+                l_free_count, l_wait_count,\n+                Atomic::load(&om_list_globals._population));\n+  pop_count += l_in_use_count + l_free_count + l_wait_count;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":1001,"deletions":213,"binary":false,"changes":1214,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+  JVM_ACC_IS_HIDDEN_CLASS         = 0x04000000,     \/\/ True if klass is hidden\n@@ -154,0 +155,1 @@\n+  bool is_hidden_class         () const { return (_flags & JVM_ACC_IS_HIDDEN_CLASS        ) != 0; }\n@@ -229,0 +231,1 @@\n+  void set_is_hidden_class()           { atomic_set_bits(JVM_ACC_IS_HIDDEN_CLASS);         }\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -264,0 +264,1 @@\n+#define NOT_JFR_RETURN()      \/* next token must be ; *\/\n@@ -267,0 +268,1 @@\n+#define NOT_JFR_RETURN()      {}\n@@ -424,0 +426,8 @@\n+#ifdef __APPLE__\n+#define MACOS_ONLY(code) code\n+#define NOT_MACOS(code)\n+#else\n+#define MACOS_ONLY(code)\n+#define NOT_MACOS(code) code\n+#endif\n+\n@@ -432,8 +442,0 @@\n-#ifdef SOLARIS\n-#define SOLARIS_ONLY(code) code\n-#define NOT_SOLARIS(code)\n-#else\n-#define SOLARIS_ONLY(code)\n-#define NOT_SOLARIS(code) code\n-#endif\n-\n@@ -521,8 +523,0 @@\n-#ifdef SPARC\n-#define SPARC_ONLY(code) code\n-#define NOT_SPARC(code)\n-#else\n-#define SPARC_ONLY(code)\n-#define NOT_SPARC(code) code\n-#endif\n-\n@@ -613,3 +607,3 @@\n-\/\/ Example: INCLUDE_SUFFIX_OS=_linux \/ INCLUDE_SUFFIX_CPU=_sparc\n-\/\/   CPU_HEADER_INLINE(macroAssembler) --> macroAssembler_sparc.inline.hpp\n-\/\/   OS_CPU_HEADER(vmStructs)          --> vmStructs_linux_sparc.hpp\n+\/\/ Example: INCLUDE_SUFFIX_OS=_linux \/ INCLUDE_SUFFIX_CPU=_x86\n+\/\/   CPU_HEADER_INLINE(macroAssembler) --> macroAssembler_x86.inline.hpp\n+\/\/   OS_CPU_HEADER(vmStructs)          --> vmStructs_linux_x86.hpp\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,2 @@\n- * <dl>\n- * <dt class=\"simpleTagLabel\" style=\"font-family:'DejaVu Sans', Arial, Helvetica, sans serif\">Providers:<\/dt>\n+ * <dl class=\"notes\">\n+ * <dt>Providers:<\/dt>\n@@ -176,2 +176,1 @@\n-        jdk.jlink,\n-        jdk.scripting.nashorn;\n+        jdk.jlink;\n@@ -182,2 +181,1 @@\n-        jdk.jfr,\n-        jdk.scripting.nashorn;\n+        jdk.jfr;\n@@ -185,4 +183,1 @@\n-        jdk.jfr,\n-        jdk.scripting.nashorn;\n-    exports jdk.internal.org.objectweb.asm.signature to\n-        jdk.scripting.nashorn;\n+        jdk.jfr;\n@@ -208,2 +203,0 @@\n-        jdk.scripting.nashorn,\n-        jdk.scripting.nashorn.shell,\n@@ -234,1 +227,0 @@\n-        jdk.scripting.nashorn,\n@@ -241,0 +233,1 @@\n+        jdk.incubator.foreign,\n@@ -242,0 +235,2 @@\n+    exports jdk.internal.util to\n+            jdk.incubator.foreign;\n@@ -288,0 +283,1 @@\n+        jdk.crypto.ec,\n@@ -305,0 +301,1 @@\n+        jdk.crypto.ec,\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -252,1 +252,1 @@\n-    jlong start, end;\n+    jlong start = 0, end = 0;\n@@ -303,1 +303,1 @@\n-        start = CounterGet();\n+        start = CurrentTimeMicros();\n@@ -314,1 +314,1 @@\n-        end   = CounterGet();\n+        end   = CurrentTimeMicros();\n@@ -317,2 +317,1 @@\n-    JLI_TraceLauncher(\"%ld micro seconds to LoadJavaVM\\n\",\n-             (long)(jint)Counter2Micros(end-start));\n+    JLI_TraceLauncher(\"%ld micro seconds to LoadJavaVM\\n\", (long)(end-start));\n@@ -422,1 +421,1 @@\n-    jlong start, end;\n+    jlong start = 0, end = 0;\n@@ -427,1 +426,1 @@\n-    start = CounterGet();\n+    start = CurrentTimeMicros();\n@@ -481,3 +480,2 @@\n-        end = CounterGet();\n-        JLI_TraceLauncher(\"%ld micro seconds to InitializeJVM\\n\",\n-               (long)(jint)Counter2Micros(end-start));\n+        end = CurrentTimeMicros();\n+        JLI_TraceLauncher(\"%ld micro seconds to InitializeJVM\\n\", (long)(end-start));\n@@ -1632,1 +1630,1 @@\n-    jlong start, end;\n+    jlong start = 0, end = 0;\n@@ -1636,1 +1634,1 @@\n-        start = CounterGet();\n+        start = CurrentTimeMicros();\n@@ -1647,3 +1645,2 @@\n-        end   = CounterGet();\n-        printf(\"%ld micro seconds to load main class\\n\",\n-               (long)(jint)Counter2Micros(end-start));\n+        end = CurrentTimeMicros();\n+        printf(\"%ld micro seconds to load main class\\n\", (long)(end-start));\n@@ -1972,1 +1969,1 @@\n-    NULL_CHECK(joptString = (*env)->NewStringUTF(env, optString));\n+    NULL_CHECK(joptString = NewPlatformString(env, optString));\n@@ -2094,1 +2091,1 @@\n-    jlong start, end;\n+    jlong start = 0, end = 0;\n@@ -2101,1 +2098,1 @@\n-        start = CounterGet();\n+        start = CurrentTimeMicros();\n@@ -2186,3 +2183,2 @@\n-        end   = CounterGet();\n-        printf(\"%ld micro seconds to parse jvm.cfg\\n\",\n-               (long)(jint)Counter2Micros(end-start));\n+        end = CurrentTimeMicros();\n+        printf(\"%ld micro seconds to parse jvm.cfg\\n\", (long)(end-start));\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":18,"deletions":22,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,0 +183,1 @@\n+jlong CurrentTimeMicros();\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,720 @@\n+\/*\n+ * Copyright (c) 1998, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"java.h\"\n+#include \"jvm_md.h\"\n+#include <dirent.h>\n+#include <dlfcn.h>\n+#include <fcntl.h>\n+#include <inttypes.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <sys\/stat.h>\n+#include <unistd.h>\n+#include <sys\/types.h>\n+#include \"manifest_info.h\"\n+\n+\n+#define JVM_DLL \"libjvm.so\"\n+#define JAVA_DLL \"libjava.so\"\n+#ifdef AIX\n+#define LD_LIBRARY_PATH \"LIBPATH\"\n+#else\n+#define LD_LIBRARY_PATH \"LD_LIBRARY_PATH\"\n+#endif\n+\n+\/* help jettison the LD_LIBRARY_PATH settings in the future *\/\n+#ifndef SETENV_REQUIRED\n+#define SETENV_REQUIRED\n+#endif\n+\n+\/*\n+ * Flowchart of launcher execs and options processing on unix\n+ *\n+ * The selection of the proper vm shared library to open depends on\n+ * several classes of command line options, including vm \"flavor\"\n+ * options (-client, -server).\n+ * The vm selection options are not passed to the running\n+ * virtual machine; they must be screened out by the launcher.\n+ *\n+ * The version specification (if any) is processed first by the\n+ * platform independent routine SelectVersion.  This may result in\n+ * the exec of the specified launcher version.\n+ *\n+ * Previously the launcher modified the LD_LIBRARY_PATH appropriately for the\n+ * desired data model path, regardless if data models matched or not. The\n+ * launcher subsequently exec'ed the desired executable, in order to make the\n+ * LD_LIBRARY_PATH path available, for the runtime linker.\n+ *\n+ * Now, in most cases,the launcher will dlopen the target libjvm.so. All\n+ * required libraries are loaded by the runtime linker, using the\n+ * $RPATH\/$ORIGIN baked into the shared libraries at compile time. Therefore,\n+ * in most cases, the launcher will only exec, if the data models are\n+ * mismatched, and will not set any environment variables, regardless of the\n+ * data models.\n+ *\n+ * However, if the environment contains a LD_LIBRARY_PATH, this will cause the\n+ * launcher to inspect the LD_LIBRARY_PATH. The launcher will check\n+ *  a. if the LD_LIBRARY_PATH's first component is the path to the desired\n+ *     libjvm.so\n+ *  b. if any other libjvm.so is found in any of the paths.\n+ * If case b is true, then the launcher will set the LD_LIBRARY_PATH to the\n+ * desired JRE and reexec, in order to propagate the environment.\n+ *\n+ *  Main\n+ *  (incoming argv)\n+ *  |\n+ * \\|\/\n+ * CreateExecutionEnvironment\n+ * (determines desired data model)\n+ *  |\n+ *  |\n+ * \\|\/\n+ *  Have Desired Model ? --> NO --> Exit(with error)\n+ *  |\n+ *  |\n+ * \\|\/\n+ * YES\n+ *  |\n+ *  |\n+ * \\|\/\n+ * CheckJvmType\n+ * (removes -client, -server, etc.)\n+ *  |\n+ *  |\n+ * \\|\/\n+ * TranslateDashJArgs...\n+ * (Prepare to pass args to vm)\n+ *  |\n+ *  |\n+ * \\|\/\n+ * ParseArguments\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * RequiresSetenv\n+ * Is LD_LIBRARY_PATH\n+ * and friends set ? --> NO --> Continue\n+ *  YES\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Path is desired JRE ? YES --> Continue\n+ *  NO\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Paths have well known\n+ * jvm paths ?       --> NO --> Error\/Exit\n+ *  YES\n+ *   |\n+ *   |\n+ *  \\|\/\n+ *  Does libjvm.so exist\n+ *  in any of them ? --> NO  --> Continue\n+ *   YES\n+ *   |\n+ *   |\n+ *  \\|\/\n+ *  Set the LD_LIBRARY_PATH\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Re-exec\n+ *   |\n+ *   |\n+ *  \\|\/\n+ * Main\n+ *\/\n+\n+\/* Store the name of the executable once computed *\/\n+static char *execname = NULL;\n+\n+\/*\n+ * execname accessor from other parts of platform dependent logic\n+ *\/\n+const char *\n+GetExecName() {\n+    return execname;\n+}\n+\n+#ifdef SETENV_REQUIRED\n+static jboolean\n+JvmExists(const char *path) {\n+    char tmp[PATH_MAX + 1];\n+    struct stat statbuf;\n+    JLI_Snprintf(tmp, PATH_MAX, \"%s\/%s\", path, JVM_DLL);\n+    if (stat(tmp, &statbuf) == 0) {\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\/*\n+ * contains a lib\/{server,client}\/libjvm.so ?\n+ *\/\n+static jboolean\n+ContainsLibJVM(const char *env) {\n+    \/* the usual suspects *\/\n+    char clientPattern[] = \"lib\/client\";\n+    char serverPattern[] = \"lib\/server\";\n+    char *envpath;\n+    char *path;\n+    char* save_ptr = NULL;\n+    jboolean clientPatternFound;\n+    jboolean serverPatternFound;\n+\n+    \/* fastest path *\/\n+    if (env == NULL) {\n+        return JNI_FALSE;\n+    }\n+\n+    \/* to optimize for time, test if any of our usual suspects are present. *\/\n+    clientPatternFound = JLI_StrStr(env, clientPattern) != NULL;\n+    serverPatternFound = JLI_StrStr(env, serverPattern) != NULL;\n+    if (clientPatternFound == JNI_FALSE && serverPatternFound == JNI_FALSE) {\n+        return JNI_FALSE;\n+    }\n+\n+    \/*\n+     * we have a suspicious path component, check if it contains a libjvm.so\n+     *\/\n+    envpath = JLI_StringDup(env);\n+    for (path = strtok_r(envpath, \":\", &save_ptr); path != NULL; path = strtok_r(NULL, \":\", &save_ptr)) {\n+        if (clientPatternFound && JLI_StrStr(path, clientPattern) != NULL) {\n+            if (JvmExists(path)) {\n+                JLI_MemFree(envpath);\n+                return JNI_TRUE;\n+            }\n+        }\n+        if (serverPatternFound && JLI_StrStr(path, serverPattern)  != NULL) {\n+            if (JvmExists(path)) {\n+                JLI_MemFree(envpath);\n+                return JNI_TRUE;\n+            }\n+        }\n+    }\n+    JLI_MemFree(envpath);\n+    return JNI_FALSE;\n+}\n+\n+\/*\n+ * Test whether the environment variable needs to be set, see flowchart.\n+ *\/\n+static jboolean\n+RequiresSetenv(const char *jvmpath) {\n+    char jpath[PATH_MAX + 1];\n+    char *llp;\n+    char *dmllp = NULL;\n+    char *p; \/* a utility pointer *\/\n+\n+#ifdef AIX\n+    \/* We always have to set the LIBPATH on AIX because ld doesn't support $ORIGIN. *\/\n+    return JNI_TRUE;\n+#endif\n+\n+    llp = getenv(\"LD_LIBRARY_PATH\");\n+    \/* no environment variable is a good environment variable *\/\n+    if (llp == NULL && dmllp == NULL) {\n+        return JNI_FALSE;\n+    }\n+#ifdef __linux\n+    \/*\n+     * On linux, if a binary is running as sgid or suid, glibc sets\n+     * LD_LIBRARY_PATH to the empty string for security purposes. (In contrast,\n+     * on Solaris the LD_LIBRARY_PATH variable for a privileged binary does not\n+     * lose its settings; but the dynamic linker does apply more scrutiny to the\n+     * path.) The launcher uses the value of LD_LIBRARY_PATH to prevent an exec\n+     * loop, here and further downstream. Therefore, if we are running sgid or\n+     * suid, this function's setting of LD_LIBRARY_PATH will be ineffective and\n+     * we should case a return from the calling function.  Getting the right\n+     * libraries will be handled by the RPATH. In reality, this check is\n+     * redundant, as the previous check for a non-null LD_LIBRARY_PATH will\n+     * return back to the calling function forthwith, it is left here to safe\n+     * guard against any changes, in the glibc's existing security policy.\n+     *\/\n+    if ((getgid() != getegid()) || (getuid() != geteuid())) {\n+        return JNI_FALSE;\n+    }\n+#endif \/* __linux *\/\n+\n+    \/*\n+     * Prevent recursions. Since LD_LIBRARY_PATH is the one which will be set by\n+     * previous versions of the JRE, thus it is the only path that matters here.\n+     * So we check to see if the desired JRE is set.\n+     *\/\n+    JLI_StrNCpy(jpath, jvmpath, PATH_MAX);\n+    p = JLI_StrRChr(jpath, '\/');\n+    *p = '\\0';\n+    if (llp != NULL && JLI_StrNCmp(llp, jpath, JLI_StrLen(jpath)) == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    \/* scrutinize all the paths further *\/\n+    if (llp != NULL &&  ContainsLibJVM(llp)) {\n+        return JNI_TRUE;\n+    }\n+    if (dmllp != NULL && ContainsLibJVM(dmllp)) {\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+#endif \/* SETENV_REQUIRED *\/\n+\n+void\n+CreateExecutionEnvironment(int *pargc, char ***pargv,\n+                           char jrepath[], jint so_jrepath,\n+                           char jvmpath[], jint so_jvmpath,\n+                           char jvmcfg[],  jint so_jvmcfg) {\n+\n+    char * jvmtype = NULL;\n+    int argc = *pargc;\n+    char **argv = *pargv;\n+\n+#ifdef SETENV_REQUIRED\n+    jboolean mustsetenv = JNI_FALSE;\n+    char *runpath = NULL; \/* existing effective LD_LIBRARY_PATH setting *\/\n+    char* new_runpath = NULL; \/* desired new LD_LIBRARY_PATH string *\/\n+    char* newpath = NULL; \/* path on new LD_LIBRARY_PATH *\/\n+    char* lastslash = NULL;\n+    char** newenvp = NULL; \/* current environment *\/\n+    size_t new_runpath_size;\n+#endif  \/* SETENV_REQUIRED *\/\n+\n+    \/* Compute\/set the name of the executable *\/\n+    SetExecname(*pargv);\n+\n+    \/* Check to see if the jvmpath exists *\/\n+    \/* Find out where the JRE is that we will be using. *\/\n+    if (!GetJREPath(jrepath, so_jrepath, JNI_FALSE)) {\n+        JLI_ReportErrorMessage(JRE_ERROR1);\n+        exit(2);\n+    }\n+    JLI_Snprintf(jvmcfg, so_jvmcfg, \"%s%slib%sjvm.cfg\",\n+            jrepath, FILESEP, FILESEP);\n+    \/* Find the specified JVM type *\/\n+    if (ReadKnownVMs(jvmcfg, JNI_FALSE) < 1) {\n+        JLI_ReportErrorMessage(CFG_ERROR7);\n+        exit(1);\n+    }\n+\n+    jvmpath[0] = '\\0';\n+    jvmtype = CheckJvmType(pargc, pargv, JNI_FALSE);\n+    if (JLI_StrCmp(jvmtype, \"ERROR\") == 0) {\n+        JLI_ReportErrorMessage(CFG_ERROR9);\n+        exit(4);\n+    }\n+\n+    if (!GetJVMPath(jrepath, jvmtype, jvmpath, so_jvmpath)) {\n+        JLI_ReportErrorMessage(CFG_ERROR8, jvmtype, jvmpath);\n+        exit(4);\n+    }\n+    \/*\n+     * we seem to have everything we need, so without further ado\n+     * we return back, otherwise proceed to set the environment.\n+     *\/\n+#ifdef SETENV_REQUIRED\n+    mustsetenv = RequiresSetenv(jvmpath);\n+    JLI_TraceLauncher(\"mustsetenv: %s\\n\", mustsetenv ? \"TRUE\" : \"FALSE\");\n+\n+    if (mustsetenv == JNI_FALSE) {\n+        return;\n+    }\n+#else\n+    return;\n+#endif \/* SETENV_REQUIRED *\/\n+\n+#ifdef SETENV_REQUIRED\n+    if (mustsetenv) {\n+        \/*\n+         * We will set the LD_LIBRARY_PATH as follows:\n+         *\n+         *     o          $JVMPATH (directory portion only)\n+         *     o          $JRE\/lib\n+         *     o          $JRE\/..\/lib\n+         *\n+         * followed by the user's previous effective LD_LIBRARY_PATH, if\n+         * any.\n+         *\/\n+\n+        runpath = getenv(LD_LIBRARY_PATH);\n+\n+        \/* runpath contains current effective LD_LIBRARY_PATH setting *\/\n+        { \/* New scope to declare local variable *\/\n+            char *new_jvmpath = JLI_StringDup(jvmpath);\n+            new_runpath_size = ((runpath != NULL) ? JLI_StrLen(runpath) : 0) +\n+                    2 * JLI_StrLen(jrepath) +\n+                    JLI_StrLen(new_jvmpath) + 52;\n+            new_runpath = JLI_MemAlloc(new_runpath_size);\n+            newpath = new_runpath + JLI_StrLen(LD_LIBRARY_PATH \"=\");\n+\n+\n+            \/*\n+             * Create desired LD_LIBRARY_PATH value for target data model.\n+             *\/\n+            {\n+                \/* remove the name of the .so from the JVM path *\/\n+                lastslash = JLI_StrRChr(new_jvmpath, '\/');\n+                if (lastslash)\n+                    *lastslash = '\\0';\n+\n+                sprintf(new_runpath, LD_LIBRARY_PATH \"=\"\n+                        \"%s:\"\n+                        \"%s\/lib:\"\n+                        \"%s\/..\/lib\",\n+                        new_jvmpath,\n+                        jrepath,\n+                        jrepath\n+                        );\n+\n+                JLI_MemFree(new_jvmpath);\n+\n+                \/*\n+                 * Check to make sure that the prefix of the current path is the\n+                 * desired environment variable setting, though the RequiresSetenv\n+                 * checks if the desired runpath exists, this logic does a more\n+                 * comprehensive check.\n+                 *\/\n+                if (runpath != NULL &&\n+                        JLI_StrNCmp(newpath, runpath, JLI_StrLen(newpath)) == 0 &&\n+                        (runpath[JLI_StrLen(newpath)] == 0 ||\n+                        runpath[JLI_StrLen(newpath)] == ':')) {\n+                    JLI_MemFree(new_runpath);\n+                    return;\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Place the desired environment setting onto the prefix of\n+         * LD_LIBRARY_PATH.  Note that this prevents any possible infinite\n+         * loop of execv() because we test for the prefix, above.\n+         *\/\n+        if (runpath != 0) {\n+            \/* ensure storage for runpath + colon + NULL *\/\n+            if ((JLI_StrLen(runpath) + 1 + 1) > new_runpath_size) {\n+                JLI_ReportErrorMessageSys(JRE_ERROR11);\n+                exit(1);\n+            }\n+            JLI_StrCat(new_runpath, \":\");\n+            JLI_StrCat(new_runpath, runpath);\n+        }\n+\n+        if (putenv(new_runpath) != 0) {\n+            \/* problem allocating memory; LD_LIBRARY_PATH not set properly *\/\n+            exit(1);\n+        }\n+\n+        \/*\n+         * Unix systems document that they look at LD_LIBRARY_PATH only\n+         * once at startup, so we have to re-exec the current executable\n+         * to get the changed environment variable to have an effect.\n+         *\/\n+\n+        newenvp = environ;\n+    }\n+#endif \/* SETENV_REQUIRED *\/\n+    {\n+        char *newexec = execname;\n+        JLI_TraceLauncher(\"TRACER_MARKER:About to EXEC\\n\");\n+        (void) fflush(stdout);\n+        (void) fflush(stderr);\n+#ifdef SETENV_REQUIRED\n+        if (mustsetenv) {\n+            execve(newexec, argv, newenvp);\n+        } else {\n+            execv(newexec, argv);\n+        }\n+#else \/* !SETENV_REQUIRED *\/\n+        execv(newexec, argv);\n+#endif \/* SETENV_REQUIRED *\/\n+        JLI_ReportErrorMessageSys(JRE_ERROR4, newexec);\n+    }\n+    exit(1);\n+}\n+\n+\n+static jboolean\n+GetJVMPath(const char *jrepath, const char *jvmtype,\n+           char *jvmpath, jint jvmpathsize)\n+{\n+    struct stat s;\n+\n+    if (JLI_StrChr(jvmtype, '\/')) {\n+        JLI_Snprintf(jvmpath, jvmpathsize, \"%s\/\" JVM_DLL, jvmtype);\n+    } else {\n+        JLI_Snprintf(jvmpath, jvmpathsize, \"%s\/lib\/%s\/\" JVM_DLL, jrepath, jvmtype);\n+    }\n+\n+    JLI_TraceLauncher(\"Does `%s' exist ... \", jvmpath);\n+\n+    if (stat(jvmpath, &s) == 0) {\n+        JLI_TraceLauncher(\"yes.\\n\");\n+        return JNI_TRUE;\n+    } else {\n+        JLI_TraceLauncher(\"no.\\n\");\n+        return JNI_FALSE;\n+    }\n+}\n+\n+\/*\n+ * Find path to JRE based on .exe's location or registry settings.\n+ *\/\n+static jboolean\n+GetJREPath(char *path, jint pathsize, jboolean speculative)\n+{\n+    char libjava[MAXPATHLEN];\n+    struct stat s;\n+\n+    if (GetApplicationHome(path, pathsize)) {\n+        \/* Is JRE co-located with the application? *\/\n+        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+        if (access(libjava, F_OK) == 0) {\n+            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            return JNI_TRUE;\n+        }\n+        \/* ensure storage for path + \/jre + NULL *\/\n+        if ((JLI_StrLen(path) + 4  + 1) > (size_t) pathsize) {\n+            JLI_TraceLauncher(\"Insufficient space to store JRE path\\n\");\n+            return JNI_FALSE;\n+        }\n+        \/* Does the app ship a private JRE in <apphome>\/jre directory? *\/\n+        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/jre\/lib\/\" JAVA_DLL, path);\n+        if (access(libjava, F_OK) == 0) {\n+            JLI_StrCat(path, \"\/jre\");\n+            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            return JNI_TRUE;\n+        }\n+    }\n+\n+    if (GetApplicationHomeFromDll(path, pathsize)) {\n+        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+        if (stat(libjava, &s) == 0) {\n+            JLI_TraceLauncher(\"JRE path is %s\\n\", path);\n+            return JNI_TRUE;\n+        }\n+    }\n+\n+    if (!speculative)\n+      JLI_ReportErrorMessage(JRE_ERROR8 JAVA_DLL);\n+    return JNI_FALSE;\n+}\n+\n+jboolean\n+LoadJavaVM(const char *jvmpath, InvocationFunctions *ifn)\n+{\n+    void *libjvm;\n+\n+    JLI_TraceLauncher(\"JVM path is %s\\n\", jvmpath);\n+\n+    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n+    if (libjvm == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR1, __LINE__);\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+    ifn->CreateJavaVM = (CreateJavaVM_t)\n+        dlsym(libjvm, \"JNI_CreateJavaVM\");\n+    if (ifn->CreateJavaVM == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+    ifn->GetDefaultJavaVMInitArgs = (GetDefaultJavaVMInitArgs_t)\n+        dlsym(libjvm, \"JNI_GetDefaultJavaVMInitArgs\");\n+    if (ifn->GetDefaultJavaVMInitArgs == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+    ifn->GetCreatedJavaVMs = (GetCreatedJavaVMs_t)\n+        dlsym(libjvm, \"JNI_GetCreatedJavaVMs\");\n+    if (ifn->GetCreatedJavaVMs == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+\n+#ifdef INCLUDE_TSAN\n+    ifn->TsanSymbolize = (TsanSymbolize_t)\n+        dlsym(libjvm, \"TsanSymbolize\");\n+    if (ifn->TsanSymbolize == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+#endif\n+\n+    return JNI_TRUE;\n+}\n+\n+\/*\n+ * Compute the name of the executable\n+ *\n+ * In order to re-exec securely we need the absolute path of the\n+ * executable. On Solaris getexecname(3c) may not return an absolute\n+ * path so we use dladdr to get the filename of the executable and\n+ * then use realpath to derive an absolute path. From Solaris 9\n+ * onwards the filename returned in DL_info structure from dladdr is\n+ * an absolute pathname so technically realpath isn't required.\n+ * On Linux we read the executable name from \/proc\/self\/exe.\n+ * As a fallback, and for platforms other than Solaris and Linux,\n+ * we use FindExecName to compute the executable name.\n+ *\/\n+const char*\n+SetExecname(char **argv)\n+{\n+    char* exec_path = NULL;\n+#if defined(__linux__)\n+    {\n+        const char* self = \"\/proc\/self\/exe\";\n+        char buf[PATH_MAX+1];\n+        int len = readlink(self, buf, PATH_MAX);\n+        if (len >= 0) {\n+            buf[len] = '\\0';            \/* readlink(2) doesn't NUL terminate *\/\n+            exec_path = JLI_StringDup(buf);\n+        }\n+    }\n+#else \/* !__linux__ *\/\n+    {\n+        \/* Not implemented *\/\n+    }\n+#endif\n+\n+    if (exec_path == NULL) {\n+        exec_path = FindExecName(argv[0]);\n+    }\n+    execname = exec_path;\n+    return exec_path;\n+}\n+\n+\/* --- Splash Screen shared library support --- *\/\n+static const char* SPLASHSCREEN_SO = JNI_LIB_NAME(\"splashscreen\");\n+static void* hSplashLib = NULL;\n+\n+void* SplashProcAddress(const char* name) {\n+    if (!hSplashLib) {\n+        int ret;\n+        char jrePath[MAXPATHLEN];\n+        char splashPath[MAXPATHLEN];\n+\n+        if (!GetJREPath(jrePath, sizeof(jrePath), JNI_FALSE)) {\n+            JLI_ReportErrorMessage(JRE_ERROR1);\n+            return NULL;\n+        }\n+        ret = JLI_Snprintf(splashPath, sizeof(splashPath), \"%s\/lib\/%s\",\n+                     jrePath, SPLASHSCREEN_SO);\n+\n+        if (ret >= (int) sizeof(splashPath)) {\n+            JLI_ReportErrorMessage(JRE_ERROR11);\n+            return NULL;\n+        }\n+        if (ret < 0) {\n+            JLI_ReportErrorMessage(JRE_ERROR13);\n+            return NULL;\n+        }\n+        hSplashLib = dlopen(splashPath, RTLD_LAZY | RTLD_GLOBAL);\n+        JLI_TraceLauncher(\"Info: loaded %s\\n\", splashPath);\n+    }\n+    if (hSplashLib) {\n+        void* sym = dlsym(hSplashLib, name);\n+        return sym;\n+    } else {\n+        return NULL;\n+    }\n+}\n+\n+\/*\n+ * Signature adapter for pthread_create() or thr_create().\n+ *\/\n+static void* ThreadJavaMain(void* args) {\n+    return (void*)(intptr_t)JavaMain(args);\n+}\n+\n+\/*\n+ * Block current thread and continue execution in a new thread.\n+ *\/\n+int\n+CallJavaMainInNewThread(jlong stack_size, void* args) {\n+    int rslt;\n+    pthread_t tid;\n+    pthread_attr_t attr;\n+    pthread_attr_init(&attr);\n+    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE);\n+\n+    if (stack_size > 0) {\n+        pthread_attr_setstacksize(&attr, stack_size);\n+    }\n+    pthread_attr_setguardsize(&attr, 0); \/\/ no pthread guard page on java threads\n+\n+    if (pthread_create(&tid, &attr, ThreadJavaMain, args) == 0) {\n+        void* tmp;\n+        pthread_join(tid, &tmp);\n+        rslt = (int)(intptr_t)tmp;\n+    } else {\n+       \/*\n+        * Continue execution in current thread if for some reason (e.g. out of\n+        * memory\/LWP)  a new thread can't be created. This will likely fail\n+        * later in JavaMain as JNI_CreateJavaVM needs to create quite a\n+        * few new threads, anyway, just give it a try..\n+        *\/\n+        rslt = JavaMain(args);\n+    }\n+\n+    pthread_attr_destroy(&attr);\n+    return rslt;\n+}\n+\n+\/* Coarse estimation of number of digits assuming the worst case is a 64-bit pid. *\/\n+#define MAX_PID_STR_SZ   20\n+\n+int\n+JVMInit(InvocationFunctions* ifn, jlong threadStackSize,\n+        int argc, char **argv,\n+        int mode, char *what, int ret)\n+{\n+    ShowSplashScreen();\n+    return ContinueInNewThread(ifn, threadStackSize, argc, argv, mode, what, ret);\n+}\n+\n+void\n+PostJVMInit(JNIEnv *env, jclass mainClass, JavaVM *vm)\n+{\n+    \/\/ stubbed out for windows and *nixes.\n+}\n+\n+void\n+RegisterThread()\n+{\n+    \/\/ stubbed out for windows and *nixes.\n+}\n+\n+\/*\n+ * on unix, we return a false to indicate this option is not applicable\n+ *\/\n+jboolean\n+ProcessPlatformOption(const char *arg)\n+{\n+    return JNI_FALSE;\n+}\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":720,"deletions":0,"binary":false,"changes":720,"status":"added"}]}