{"files":[{"patch":"@@ -852,0 +852,9 @@\n+  # With tsan enabled, process reaper often causes SOE. it makes jtreg test failure.\n+  ifeq ($(INCLUDE_TSAN), true)\n+    ifeq ($(call isTargetCpuArch, aarch64), true)\n+      $1_JTREG_BASIC_OPTIONS += -vmoption:-Djdk.lang.processReaperUseDefaultStackSize=true\n+      $1_JTREG_LAUNCHER_OPTIONS += -Djdk.lang.processReaperUseDefaultStackSize=true\n+      $$(info tsan enabled, process reaper will use default JVM stack size.)\n+    endif\n+  endif\n+\n","filename":"make\/RunTests.gmk","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -242,5 +242,15 @@\n-    C_O_FLAG_HIGHEST_JVM=\"-O3\"\n-    C_O_FLAG_HIGHEST=\"-O3\"\n-    C_O_FLAG_HI=\"-O3\"\n-    C_O_FLAG_NORM=\"-O2\"\n-    C_O_FLAG_DEBUG_JVM=\"-O0\"\n+    # Use -Os on aarch64 to work around known llvm issue,\n+    # (see https:\/\/bugs.llvm.org\/show_bug.cgi?id=44581) which makes release build crash in aarch64.\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      C_O_FLAG_HIGHEST_JVM=\"-Os\"\n+      C_O_FLAG_HIGHEST=\"-Os\"\n+      C_O_FLAG_HI=\"-Os\"\n+      C_O_FLAG_NORM=\"-Os\"\n+      C_O_FLAG_DEBUG_JVM=\"\"\n+    else\n+      C_O_FLAG_HIGHEST_JVM=\"-O3\"\n+      C_O_FLAG_HIGHEST=\"-O3\"\n+      C_O_FLAG_HI=\"-O3\"\n+      C_O_FLAG_NORM=\"-O2\"\n+      C_O_FLAG_DEBUG_JVM=\"-O0\"\n+    fi\n@@ -486,0 +496,6 @@\n+    # Disable experimental isel due to a known issue in llvm-8, which generates wrong debug info.\n+    # (see https:\/\/bugs.llvm.org\/show_bug.cgi?id=40887)\n+    if test \"x$OPENJDK_TARGET_CPU\" = xaarch64; then\n+      TOOLCHAIN_CFLAGS_JVM=\"$TOOLCHAIN_CFLAGS_JVM -fno-experimental-isel\"\n+    fi\n+\n","filename":"make\/autoconf\/flags-cflags.m4","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-    serialgc services shenandoahgc static-build vm-structs zero zgc \\\n+    serialgc services shenandoahgc static-build tsan vm-structs zero zgc \\\n@@ -80,0 +80,1 @@\n+m4_define(jvm_feature_desc_tsan, [enable ThreadSanitizer support])\n@@ -382,0 +383,47 @@\n+###############################################################################\n+# Check if the feature 'tsan' is available on this platform.\n+#\n+AC_DEFUN_ONCE([JVM_FEATURES_CHECK_TSAN],\n+[\n+  JVM_FEATURES_CHECK_AVAILABILITY(tsan, [\n+    AC_MSG_CHECKING([if platform is supported by TSAN])\n+    if test \"x$OPENJDK_TARGET_OS\" = \"xlinux\" && \\\n+        (test \"x$OPENJDK_TARGET_CPU\" = \"xx86_64\" || \\\n+         test \"x$OPENJDK_TARGET_CPU\" = \"xaarch64\"); then\n+      AC_MSG_RESULT([yes])\n+    else\n+      AC_MSG_RESULT([no, $OPENJDK_TARGET_OS-$OPENJDK_TARGET_CPU])\n+      AVAILABLE=false\n+    fi\n+  ])\n+])\n+\n+###############################################################################\n+# Support for --<enable|disable>-tsan-launcher flag.\n+#\n+# TODO(tsan-dev): Ideally we should use AC_DEFUN_ONCE. However, with AC_DEFUN_ONCE,\n+# we cannot read variables such as $INCLUDE_TSAN or $JVM_FEATURES_ACTIVE. They would\n+# become empty value.\n+AC_DEFUN([JVM_FEATURES_TSAN_LAUNCHER_FLAG],\n+[\n+  # Add a configure option --<enable|disable>-tsan-launcher to allow\n+  # more control on whether to link TSAN runtime with the launcher.\n+  AC_ARG_ENABLE(tsan-launcher, AS_HELP_STRING(\n+        [--enable-tsan-launcher],\n+        [link tsan runtime with the default JDK launcher. Default is consistent with whether tsan feature is enabled.]))\n+  AC_MSG_CHECKING([if tsan should be linked with JDK launcher])\n+  if test \"x$INCLUDE_TSAN\" = \"xtrue\"; then\n+    if test \"x$enable_tsan_launcher\" = \"xno\"; then\n+      AC_MSG_RESULT([no, forced])\n+      INCLUDE_TSAN=\"false\"\n+    else\n+      AC_MSG_RESULT([yes])\n+    fi\n+  else\n+    AC_MSG_RESULT([no, tsan feature is disabled])\n+    if test \"x$enable_tsan_launcher\" = \"xyes\"; then\n+      AC_MSG_ERROR([--enable-tsan-launcher can only be used when tsan feature is enabled.])\n+    fi\n+  fi\n+])\n+\n@@ -441,0 +489,1 @@\n+  JVM_FEATURES_CHECK_TSAN\n@@ -602,0 +651,3 @@\n+  if ! JVM_FEATURES_IS_ACTIVE(tsan); then\n+    INCLUDE_TSAN=\"false\"\n+  fi\n@@ -627,0 +679,1 @@\n+  INCLUDE_TSAN=\"true\"\n@@ -653,0 +706,2 @@\n+  JVM_FEATURES_TSAN_LAUNCHER_FLAG($INCLUDE_TSAN)\n+\n@@ -665,0 +720,1 @@\n+  AC_SUBST(INCLUDE_TSAN)\n","filename":"make\/autoconf\/jvm-features.m4","additions":57,"deletions":1,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -847,0 +847,1 @@\n+INCLUDE_TSAN:=@INCLUDE_TSAN@\n","filename":"make\/autoconf\/spec.gmk.in","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -79,0 +79,1 @@\n+# INCLUDE_TSAN   If true, pass compiler and linker flags for TSAN.\n@@ -142,0 +143,11 @@\n+  ifeq ($$($1_INCLUDE_TSAN), true)\n+    $1_CFLAGS += -DINCLUDE_TSAN\n+    # TSAN runtime needs to be statically or dynamically linked with the launcher\n+    # instead of libjvm.so, because initialization of TSAN runtime has to happen\n+    # early at program start.\n+    # '-fsanitize=thread' works as a link-only flag for either GCC or Clang.\n+    # With GCC, it dynamically links with libtsan.so; with Clang, it statically\n+    # links the runtime into the launcher's executable.\n+    $1_LDFLAGS += -fsanitize=thread\n+  endif\n+\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -178,0 +178,5 @@\n+ifneq ($(call check-jvm-feature, tsan), true)\n+  JVM_CFLAGS_FEATURES += -DINCLUDE_TSAN=0\n+  JVM_EXCLUDE_PATTERNS += tsan\n+endif\n+\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+JVM_GetTsanEnabled\n","filename":"make\/hotspot\/symbols\/symbols-unix","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+    INCLUDE_TSAN := $(INCLUDE_TSAN), \\\n","filename":"make\/modules\/java.base\/Launcher.gmk","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -187,0 +187,4 @@\n+ifeq ($(INCLUDE_TSAN), true)\n+  LIBJLI_CFLAGS += -DINCLUDE_TSAN\n+endif\n+\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -865,0 +865,7 @@\n+\n+    BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libAbstractNativeLoop := -fsanitize=thread\n+    ifeq ($(TOOLCHAIN_TYPE), gcc)\n+      # Ignore unresolved symbols from TSAN's runtime.\n+      # The symbols will be available at runtime as TSAN runtime is linked with the launcher.\n+      BUILD_HOTSPOT_JTREG_LIBRARIES_LDFLAGS_libAbstractNativeLoop := -Wl,--unresolved-symbols=ignore-in-object-files\n+    endif\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -707,0 +707,3 @@\n+\n+  TSAN_RUNTIME_ONLY(push_ptr(lock_reg));\n+\n@@ -789,0 +792,9 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    pop_ptr(lock_reg);\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),\n+            lock_reg);\n+    popa();\n+  );\n@@ -807,0 +819,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),\n+            lock_reg);\n+    popa();\n+  );\n+\n@@ -1483,0 +1503,4 @@\n+  TSAN_RUNTIME_ONLY(call_VM(noreg,\n+                            CAST_FROM_FN_PTR(address,\n+                            SharedRuntime::tsan_interp_method_entry)));\n+\n@@ -1516,0 +1540,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    push(state);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                 SharedRuntime::tsan_interp_method_exit));\n+    pop(state);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -1710,0 +1710,9 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ protect the args we've loaded\n+    save_args(masm, total_c_args, c_arg, out_regs);\n+    __ call_VM(noreg,\n+      CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),\n+      rthread);\n+    restore_args(masm, total_c_args, c_arg, out_regs);\n+  );\n+\n@@ -1789,0 +1798,8 @@\n+\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),\n+                 obj_reg);\n+      __ popa();\n+    );\n@@ -1879,0 +1896,9 @@\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_unlock),\n+                 obj_reg);\n+      __ popa();\n+    );\n+\n+\n@@ -1915,0 +1941,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    save_native_result(masm, ret_type, stack_slots);\n+    __ call_VM_leaf(\n+         CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));\n+    restore_native_result(masm, ret_type, stack_slots);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -756,0 +756,81 @@\n+#if INCLUDE_TSAN\n+\n+void TemplateTable::tsan_observe_load_or_store(const Address& field,\n+                                               TsanMemoryReadWriteFunction tsan_function) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+  if (!ThreadSanitizerJavaMemory) {\n+    return;\n+  }\n+\n+  __ pusha();\n+  __ push_d(v0);\n+  __ lea(c_rarg0, field);\n+  __ get_method(c_rarg1);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                  c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+  __ pop_d(v0);\n+  __ popa();\n+}\n+\n+void TemplateTable::tsan_observe_get_or_put(const Address &field,\n+                                            Register flags,\n+                                            TsanMemoryReadWriteFunction tsan_function,\n+                                            TosState tos) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+\n+  TsanMemoryReleaseAcquireFunction releaseAcquireFunction =\n+      tsan_release_acquire_method(tsan_function);\n+\n+  Label done, notAcquireRelease;\n+\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save v0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(v0);\n+  \/\/ For volatile reads\/writes use an acquire\/release.\n+  \/\/ If a reference is annotated to be ignored, assume it's safe to\n+  \/\/ access the object it's referring to and create a happens-before relation\n+  \/\/ between the accesses to this reference.\n+  if (tos == atos) {\n+    int32_t acquire_release_mask = 1 << ConstantPoolCacheEntry::is_volatile_shift |\n+      1 << ConstantPoolCacheEntry::is_tsan_ignore_shift;\n+    \/\/ acquire_release_mask (0x8200000) can not be encoded into 'tst', but it can be\n+    \/\/ encoded into just one 'mov' instruction.\n+    __ mov(rscratch1, acquire_release_mask);\n+    __ tst(flags, rscratch1);\n+    __ br(Assembler::EQ, notAcquireRelease);\n+  } else {\n+    __ tbz(flags, ConstantPoolCacheEntry::is_volatile_shift, notAcquireRelease);\n+  }\n+\n+  __ lea(c_rarg0, field);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);\n+  if (ThreadSanitizerJavaMemory) {\n+    __ b(done);\n+    __ bind(notAcquireRelease);\n+\n+    \/\/ Ignore reads\/writes to final fields. They can't be racy.\n+    __ tbnz(flags, ConstantPoolCacheEntry::is_final_shift, done);\n+\n+    \/\/ Don't report races on tsan ignored fields.\n+    __ tbnz(flags, ConstantPoolCacheEntry::is_tsan_ignore_shift, done);\n+\n+    __ lea(c_rarg0, field);\n+    __ get_method(c_rarg1);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                    c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+\n+    __ bind(done);\n+  } else {\n+    __ bind(notAcquireRelease);\n+  }\n+  __ pop_d(v0);\n+  __ popa();\n+}\n+\n+\n+#endif\n+\n@@ -765,1 +846,3 @@\n-  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -777,1 +860,3 @@\n-  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -789,1 +874,3 @@\n-  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(2)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -801,1 +888,3 @@\n-  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(3)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -813,4 +902,4 @@\n-  do_oop_load(_masm,\n-              Address(r0, r1, Address::uxtw(LogBytesPerHeapOop)),\n-              r0,\n-              IS_ARRAY);\n+  Address addr(r0, r1, Address::uxtw(LogBytesPerHeapOop));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, UseCompressedOops ? SharedRuntime::tsan_read4\n+                                                                       : SharedRuntime::tsan_read8));\n+  do_oop_load(_masm, addr, r0, IS_ARRAY);\n@@ -828,1 +917,3 @@\n-  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(0)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(0));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));\n+  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -840,1 +931,3 @@\n-  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -846,0 +939,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -869,1 +965,3 @@\n-  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, Address(r0, r1, Address::uxtw(1)), noreg, noreg);\n+  Address addr(r0, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, r0, addr, noreg, noreg);\n@@ -1063,1 +1161,3 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -1075,1 +1175,3 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -1087,1 +1189,3 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(2)), noreg \/* ftos *\/, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(2));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg \/* ftos *\/, noreg, noreg);\n@@ -1099,1 +1203,3 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(3)), noreg \/* dtos *\/, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(3));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg \/* dtos *\/, noreg, noreg);\n@@ -1114,1 +1220,3 @@\n-\n+  \/\/ do tsan write after r4 has been defined.\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(element_address, UseCompressedOops ? SharedRuntime::tsan_write4\n+                                                                                  : SharedRuntime::tsan_write8));\n@@ -1176,1 +1284,3 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(0)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(0));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -1189,1 +1299,3 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, Address(r3, r1, Address::uxtw(1)), r0, noreg, noreg);\n+  Address addr(r3, r1, Address::uxtw(1));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, r0, noreg, noreg);\n@@ -2381,0 +2493,19 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Draw a happens-before edge from the class's static initializer to\n+      \/\/ this lookup.\n+\n+      \/\/ java_lang_Class::_init_lock_offset may not have been initialized\n+      \/\/ when generating code. It will be initialized at runtime though.\n+      \/\/ So calculate its address and read from it at runtime.\n+      __ pusha();\n+      __ mov(c_rarg0, obj);\n+      Address init_lock_offset_address((address) java_lang_Class::init_lock_offset_addr(),\n+                                       relocInfo::none);\n+      __ lea(rscratch1, init_lock_offset_address);\n+      __ ldrw(rscratch1, Address(rscratch1, 0));\n+      __ add(c_rarg0, c_rarg0, rscratch1);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                       SharedRuntime::tsan_acquire),\n+                                       c_rarg0);\n+      __ popa();\n+    );\n@@ -2516,0 +2647,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, btos));\n@@ -2529,0 +2661,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read1, ztos));\n@@ -2542,0 +2675,5 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,\n+                                            raw_flags,\n+                                            UseCompressedOops ? SharedRuntime::tsan_read4\n+                                                              : SharedRuntime::tsan_read8,\n+                                            atos));\n@@ -2553,0 +2691,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, itos));\n@@ -2565,0 +2704,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, ctos));\n@@ -2577,0 +2717,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read2, stos));\n@@ -2589,0 +2730,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, ltos));\n@@ -2601,0 +2743,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read4, ftos));\n@@ -2615,0 +2758,1 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, raw_flags, SharedRuntime::tsan_read8, dtos));\n@@ -2722,0 +2866,1 @@\n+  \/\/ save raw flags in r5\n@@ -2751,0 +2896,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, btos));\n@@ -2766,0 +2912,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write1, ztos));\n@@ -2781,0 +2928,5 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field,\n+                                              r5,\n+                                              UseCompressedOops ? SharedRuntime::tsan_write4\n+                                                                : SharedRuntime::tsan_write8,\n+                                              atos));\n@@ -2797,0 +2949,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, itos));\n@@ -2812,0 +2965,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, ctos));\n@@ -2827,0 +2981,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write2, stos));\n@@ -2842,0 +2997,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, ltos));\n@@ -2857,0 +3013,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write4, ftos));\n@@ -2874,0 +3031,1 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, r5, SharedRuntime::tsan_write8, dtos));\n@@ -3047,0 +3205,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -3140,0 +3301,3 @@\n+#ifdef ASSERT\n+  TSAN_RUNTIME_ONLY(__ stop(\"bytecode rewrite should have been disabled in TSAN\"););\n+#endif\n@@ -3641,0 +3805,8 @@\n+\n+     TSAN_RUNTIME_ONLY(\n+      \/\/ return value of new oop is in r0.\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj), r0);\n+      __ pop(atos);\n+    );\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":190,"deletions":18,"binary":false,"changes":208,"status":"modified"},{"patch":"@@ -1178,0 +1178,1 @@\n+  TSAN_RUNTIME_ONLY(push_ptr(lock_reg));\n@@ -1257,0 +1258,9 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    pop_ptr(lock_reg);\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_lock),\n+            lock_reg);\n+    popa();\n+  );\n@@ -1276,0 +1286,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    pusha();\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_unlock),\n+            lock_reg);\n+    popa();\n+  );\n+\n@@ -1992,0 +2010,4 @@\n+  TSAN_RUNTIME_ONLY(call_VM(noreg,\n+                            CAST_FROM_FN_PTR(address,\n+                                             SharedRuntime::tsan_interp_method_entry)));\n+\n@@ -2029,0 +2051,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    push(state);\n+    call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                  SharedRuntime::tsan_interp_method_exit));\n+    pop(state);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -2445,0 +2445,9 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ protect the args we've loaded\n+    save_args(masm, total_c_args, c_arg, out_regs);\n+    __ call_VM(noreg,\n+      CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_entry),\n+      r15_thread);\n+    restore_args(masm, total_c_args, c_arg, out_regs);\n+  );\n+\n@@ -2524,0 +2533,8 @@\n+\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg,\n+                 CAST_FROM_FN_PTR(address, SharedRuntime::tsan_oop_lock),\n+                 obj_reg);\n+      __ popa();\n+    );\n@@ -2659,0 +2676,8 @@\n+    TSAN_RUNTIME_ONLY(\n+      __ pusha();\n+      __ call_VM(noreg, CAST_FROM_FN_PTR(address,\n+                                         SharedRuntime::tsan_oop_unlock),\n+                 obj_reg);\n+      __ popa();\n+    );\n+\n@@ -2695,0 +2720,8 @@\n+\n+  TSAN_RUNTIME_ONLY(\n+    save_native_result(masm, ret_type, stack_slots);\n+    __ call_VM_leaf(\n+         CAST_FROM_FN_PTR(address, SharedRuntime::tsan_interp_method_exit));\n+    restore_native_result(masm, ret_type, stack_slots);\n+  );\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -770,0 +770,97 @@\n+#if INCLUDE_TSAN\n+\n+void TemplateTable::tsan_observe_get_or_put(\n+    const Address &field,\n+    Register flags,\n+    TsanMemoryReadWriteFunction tsan_function,\n+    TosState tos) {\n+  assert(flags == rdx, \"flags should be in rdx register\");\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+\n+  TsanMemoryReleaseAcquireFunction releaseAcquireFunction =\n+      tsan_release_acquire_method(tsan_function);\n+\n+  Label done, notAcquireRelease;\n+\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save xmm0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(xmm0);\n+  DEBUG_ONLY(\n+    __ pusha();\n+    __ movptr(c_rarg0, field.base());\n+    __ leaq(c_rarg1, field);\n+    __ subq(c_rarg1, field.base());\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),\n+                    c_rarg0 \/* oop *\/, c_rarg1 \/* index *\/);\n+    __ popa();\n+  );\n+  \/\/ For volatile reads\/writes use an acquire\/release.\n+  \/\/ If a reference is annotated to be ignored, assume it's safe to\n+  \/\/ access the object it's referring to and create a happens-before relation\n+  \/\/ between the accesses to this reference.\n+  int32_t acquire_release_mask = 1 << ConstantPoolCacheEntry::is_volatile_shift |\n+      ((tos == atos) ? 1 << ConstantPoolCacheEntry::is_tsan_ignore_shift : 0);\n+  __ testl(flags, acquire_release_mask);\n+  __ jcc(Assembler::zero, notAcquireRelease);\n+\n+  __ leaq(c_rarg0, field);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, releaseAcquireFunction), c_rarg0);\n+  if (ThreadSanitizerJavaMemory) {\n+    __ jmp(done);\n+\n+    __ bind(notAcquireRelease);\n+    \/\/ Ignore reads\/writes to final fields. They can't be racy.\n+    int32_t ignore_mask = 1 << ConstantPoolCacheEntry::is_final_shift |\n+        1 << ConstantPoolCacheEntry::is_tsan_ignore_shift;\n+    __ testl(flags, ignore_mask);\n+    __ jcc(Assembler::notZero, done);\n+\n+    __ leaq(c_rarg0, field);\n+    __ get_method(c_rarg1);\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                    c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+\n+    __ bind(done);\n+  } else {\n+    __ bind(notAcquireRelease);\n+  }\n+  __ pop_d(xmm0);\n+  __ popa();\n+}\n+\n+void TemplateTable::tsan_observe_load_or_store(\n+    const Address& field, TsanMemoryReadWriteFunction tsan_function) {\n+  assert(ThreadSanitizer, \"ThreadSanitizer should be set\");\n+  if (!ThreadSanitizerJavaMemory) {\n+    return;\n+  }\n+  \/\/ We could save some instructions by only saving the registers we need.\n+  __ pusha();\n+  \/\/ pusha() doesn't save xmm0, which tsan_function clobbers and the\n+  \/\/ interpreter still needs.\n+  \/\/ This really only needs to be done for some of the float\/double accesses,\n+  \/\/ but it's here because it's cleaner.\n+  __ push_d(xmm0);\n+  DEBUG_ONLY(\n+    __ pusha();\n+    __ movptr(c_rarg0, field.base());\n+    __ leaq(c_rarg1, field);\n+    __ subq(c_rarg1, field.base());\n+    __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::verify_oop_index),\n+                    c_rarg0 \/* oop *\/, c_rarg1 \/* index *\/);\n+    __ popa();\n+  );\n+  __ leaq(c_rarg0, field);\n+  __ get_method(c_rarg1);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, tsan_function),\n+                  c_rarg0 \/* addr *\/, c_rarg1 \/* method *\/, rbcp \/* bcp *\/);\n+  __ pop_d(xmm0);\n+  __ popa();\n+}\n+\n+#endif  \/\/ INCLUDE_TSAN\n+\n@@ -775,4 +872,4 @@\n-  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_4,\n-                            arrayOopDesc::base_offset_in_bytes(T_INT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_INT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_INT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -788,4 +885,5 @@\n-  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg \/* ltos *\/,\n-                    Address(rdx, rbx, Address::times_8,\n-                            arrayOopDesc::base_offset_in_bytes(T_LONG)),\n-                    noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_LONG));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_LONG, IN_HEAP | IS_ARRAY, noreg \/* ltos *\/, addr, noreg,\n+                    noreg);\n@@ -801,5 +899,5 @@\n-  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg \/* ftos *\/,\n-                    Address(rdx, rax,\n-                            Address::times_4,\n-                            arrayOopDesc::base_offset_in_bytes(T_FLOAT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_FLOAT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read4));\n+  __ access_load_at(T_FLOAT, IN_HEAP | IS_ARRAY, noreg \/* ftos *\/, addr, noreg,\n+                    noreg);\n@@ -813,5 +911,5 @@\n-  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg \/* dtos *\/,\n-                    Address(rdx, rax,\n-                            Address::times_8,\n-                            arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_DOUBLE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read8));\n+  __ access_load_at(T_DOUBLE, IN_HEAP | IS_ARRAY, noreg \/* dtos *\/, addr, noreg,\n+                    noreg);\n@@ -825,6 +923,7 @@\n-  do_oop_load(_masm,\n-              Address(rdx, rax,\n-                      UseCompressedOops ? Address::times_4 : Address::times_ptr,\n-                      arrayOopDesc::base_offset_in_bytes(T_OBJECT)),\n-              rax,\n-              IS_ARRAY);\n+  Address addr(rdx, rax,\n+               UseCompressedOops ? Address::times_4 : Address::times_ptr,\n+               arrayOopDesc::base_offset_in_bytes(T_OBJECT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(\n+      addr, UseCompressedOops ? SharedRuntime::tsan_read4\n+                              : SharedRuntime::tsan_read8));\n+  do_oop_load(_masm, addr, rax, IS_ARRAY);\n@@ -838,3 +937,4 @@\n-  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_1, arrayOopDesc::base_offset_in_bytes(T_BYTE)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_1,\n+               arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read1));\n+  __ access_load_at(T_BYTE, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -848,3 +948,4 @@\n-  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_CHAR)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_CHAR, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -874,3 +975,4 @@\n-  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax,\n-                    Address(rdx, rax, Address::times_2, arrayOopDesc::base_offset_in_bytes(T_SHORT)),\n-                    noreg, noreg);\n+  Address addr(rdx, rax, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_SHORT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_read2));\n+  __ access_load_at(T_SHORT, IN_HEAP | IS_ARRAY, rax, addr, noreg, noreg);\n@@ -1068,4 +1170,4 @@\n-  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_4,\n-                             arrayOopDesc::base_offset_in_bytes(T_INT)),\n-                     rax, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_INT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_INT, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);\n@@ -1082,4 +1184,5 @@\n-  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY,\n-                     Address(rcx, rbx, Address::times_8,\n-                             arrayOopDesc::base_offset_in_bytes(T_LONG)),\n-                     noreg \/* ltos *\/, noreg, noreg);\n+  Address addr(rcx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_LONG));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_LONG, IN_HEAP | IS_ARRAY, addr, noreg \/* ltos *\/, noreg,\n+                     noreg);\n@@ -1096,4 +1199,5 @@\n-  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_4,\n-                             arrayOopDesc::base_offset_in_bytes(T_FLOAT)),\n-                     noreg \/* ftos *\/, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_4,\n+               arrayOopDesc::base_offset_in_bytes(T_FLOAT));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write4));\n+  __ access_store_at(T_FLOAT, IN_HEAP | IS_ARRAY, addr, noreg \/* ftos *\/, noreg,\n+                     noreg);\n@@ -1109,4 +1213,5 @@\n-  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_8,\n-                             arrayOopDesc::base_offset_in_bytes(T_DOUBLE)),\n-                     noreg \/* dtos *\/, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_8,\n+               arrayOopDesc::base_offset_in_bytes(T_DOUBLE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write8));\n+  __ access_store_at(T_DOUBLE, IN_HEAP | IS_ARRAY, addr, noreg \/* dtos *\/,\n+                     noreg, noreg);\n@@ -1127,0 +1232,4 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(\n+      element_address, UseCompressedOops ? SharedRuntime::tsan_write4\n+                                         : SharedRuntime::tsan_write8));\n+\n@@ -1187,4 +1296,4 @@\n-  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx,Address::times_1,\n-                             arrayOopDesc::base_offset_in_bytes(T_BYTE)),\n-                     rax, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_1,\n+               arrayOopDesc::base_offset_in_bytes(T_BYTE));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write1));\n+  __ access_store_at(T_BYTE, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);\n@@ -1200,4 +1309,4 @@\n-  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY,\n-                     Address(rdx, rbx, Address::times_2,\n-                             arrayOopDesc::base_offset_in_bytes(T_CHAR)),\n-                     rax, noreg, noreg);\n+  Address addr(rdx, rbx, Address::times_2,\n+               arrayOopDesc::base_offset_in_bytes(T_CHAR));\n+  TSAN_RUNTIME_ONLY(tsan_observe_load_or_store(addr, SharedRuntime::tsan_write2));\n+  __ access_store_at(T_CHAR, IN_HEAP | IS_ARRAY, addr, rax, noreg, noreg);\n@@ -2797,0 +2906,20 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Draw a happens-before edge from the class's static initializer to\n+      \/\/ this lookup.\n+\n+      \/\/ java_lang_Class::_init_lock_offset may not have been initialized\n+      \/\/ when generating code. It will be initialized at runtime though.\n+      \/\/ So calculate its address and read from it at runtime.\n+      __ pusha();\n+      __ movq(c_rarg0, obj);\n+      AddressLiteral init_lock_offset_address(\n+          (address) java_lang_Class::init_lock_offset_addr(),\n+          relocInfo::none);\n+      __ lea(rax, init_lock_offset_address);\n+      __ movl(rax, Address(rax, 0));\n+      __ addq(c_rarg0, rax);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address,\n+                                       SharedRuntime::tsan_acquire),\n+                      c_rarg0);\n+      __ popa();\n+    );\n@@ -2892,0 +3021,5 @@\n+  \/\/ During a TSAN instrumented run, move flags into rdx so we can later\n+  \/\/ examine whether the field is volatile or has been annotated to be ignored\n+  \/\/ by Tsan.\n+  TSAN_RUNTIME_ONLY(__ movl(rdx, flags));\n+\n@@ -2904,0 +3038,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read1, btos));\n@@ -2917,0 +3053,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read1, ztos));\n@@ -2930,0 +3068,4 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, UseCompressedOops ? SharedRuntime::tsan_read4\n+                                    : SharedRuntime::tsan_read8,\n+      atos));\n@@ -2941,0 +3083,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read4, itos));\n@@ -2953,0 +3097,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read2, ctos));\n@@ -2965,0 +3111,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read2, stos));\n@@ -2979,0 +3127,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read8, ltos));\n@@ -2990,0 +3140,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read4, ftos));\n@@ -3006,0 +3158,2 @@\n+  TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+      field, rdx, SharedRuntime::tsan_read8, dtos));\n@@ -3141,2 +3295,0 @@\n-  __ shrl(rdx, ConstantPoolCacheEntry::is_volatile_shift);\n-  __ andl(rdx, 0x1);\n@@ -3145,1 +3297,1 @@\n-  __ testl(rdx, rdx);\n+  __ testl(rdx, 1 << ConstantPoolCacheEntry::is_volatile_shift);\n@@ -3182,0 +3334,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write1, btos));\n@@ -3197,0 +3351,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write1, ztos));\n@@ -3212,0 +3368,4 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(field, rdx,\n+        UseCompressedOops ? SharedRuntime::tsan_write4\n+                          : SharedRuntime::tsan_write8,\n+        atos));\n@@ -3228,0 +3388,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write4, itos));\n@@ -3243,0 +3405,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write2, ctos));\n@@ -3258,0 +3422,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write2, stos));\n@@ -3273,0 +3439,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write8, ltos));\n@@ -3291,0 +3459,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write4, ftos));\n@@ -3309,0 +3479,2 @@\n+    TSAN_RUNTIME_ONLY(tsan_observe_get_or_put(\n+        field, rdx, SharedRuntime::tsan_write8, dtos));\n@@ -4133,0 +4305,8 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ return value of new oop is in rax.\n+      __ push(atos);\n+      __ call_VM_leaf(CAST_FROM_FN_PTR(address, SharedRuntime::tsan_track_obj),\n+                      rax);\n+      __ pop(atos);\n+    );\n+\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":240,"deletions":60,"binary":false,"changes":300,"status":"modified"},{"patch":"@@ -557,0 +557,23 @@\n+\n+#if (INCLUDE_TSAN) && defined(AARCH64)\n+  \/\/ Current TSAN memory mapping for 48bits aarch64, a large continuous space could be allocated between\n+  \/\/ kMidAppMemBeg = 0x0aaaa00000000ull and kMidAppMemEnd = 0x0aaaf00000000ull, which is only 20GB size.\n+  \/\/ Take 16GB here for safer allocation.\n+  const julong max_avail_vmspace = 16ULL * G; \/\/ 16GB\n+  const u8 msb_in_aarch64 = 47; \/\/ Only support 48-bits space now.\n+\n+  \/\/ Based on tsan memory mapping for 48bits aarch64,\n+  \/\/ libjvm.so will be loaded between kHiAppMemBeg = 0x0ffff00000000ull and kHiAppMemEnd = 0x1000000000000ull\n+  u8 vm_addr_u8 = reinterpret_cast<u8>(&__FUNCTION__);\n+  \/\/ High address in 48bits user space is like 0x0000ffffxxxxxxxx.\n+  assert((vm_addr_u8  >> msb_in_aarch64) == 0x1, \"warning: allocation could fail in non 48-bit address space.\");\n+\n+  if (result) {\n+    *limit = MIN2(*limit, max_avail_vmspace);\n+  } else {\n+    *limit = max_avail_vmspace;\n+  }\n+\n+  result = true;\n+#endif\n+\n","filename":"src\/hotspot\/os\/posix\/os_posix.cpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -814,1 +814,2 @@\n-  assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n+  \/\/ TODO: TSAN requires being built with Clang, but stack alignment assertion fails with Clang.\n+  \/\/ assert(((intptr_t)os::current_stack_pointer() & (StackAlignmentInBytes-1)) == 0, \"incorrect stack alignment\");\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -39,0 +39,3 @@\n+#if INCLUDE_TSAN\n+#include \"classfile\/tsanIgnoreList.hpp\"\n+#endif \/\/ INCLUDE_TSAN\n@@ -1082,0 +1085,1 @@\n+    _field_TsanIgnore,\n@@ -1118,0 +1122,5 @@\n+\n+#if INCLUDE_TSAN\n+  void set_tsan_ignore(bool tsan_ignore) { set_annotation(_field_TsanIgnore); }\n+  bool is_tsan_ignore() const { return has_annotation(_field_TsanIgnore); }\n+#endif  \/\/ INCLUDE_TSAN\n@@ -1692,0 +1701,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      if (ThreadSanitizerIgnoreFile != NULL &&\n+          TsanIgnoreList::match(_class_name, name, type)) {\n+        parsed_annotations.set_tsan_ignore(true);\n+      }\n+    );\n+\n@@ -2126,0 +2142,8 @@\n+#if INCLUDE_TSAN\n+    case vmSymbols::VM_SYMBOL_ENUM_NAME(java_util_concurrent_annotation_LazyInit): {\n+      if (_location != _in_field) {\n+        break;  \/\/ only allow for fields\n+      }\n+      return _field_TsanIgnore;\n+    }\n+#endif  \/\/ INCLUDE_TSAN\n@@ -2138,0 +2162,5 @@\n+  TSAN_RUNTIME_ONLY(\n+    if (is_tsan_ignore())\n+      f->set_tsan_ignore(true);\n+  );\n+\n@@ -5937,0 +5966,20 @@\n+#if INCLUDE_TSAN\n+  if (ThreadSanitizer && !ik->is_interface()) {\n+    ik->ensure_space_for_methodids(0);\n+    int num_methods = ik->methods()->length();\n+    for (int index = 0; index < num_methods; index++) {\n+      \/\/ Make sure each method has a jmethodID.\n+      \/\/ This allows us to avoid allocating jmethodIDs during program execution.\n+      jmethodID id = ik->methods()->at(index)->jmethod_id();\n+#ifdef ASSERT\n+      u8 id_u8 = reinterpret_cast<u8>(id);\n+      assert((id_u8 & right_n_bits(3)) == 0, \"jmethodID is not aligned\");\n+      AMD64_ONLY(assert((id_u8 & left_n_bits(17)) == 0, \"jmethodID is not aligned\");)\n+      AARCH64_ONLY(id_u8 >>= 36;\n+                   assert(id_u8 == 0 || id_u8 == 0xaaa || id_u8 == 0xfff, \"jmethodID is not aligned\");\n+                   )\n+#endif\n+    }\n+  }\n+#endif \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -1437,0 +1437,8 @@\n+\n+#if INCLUDE_TSAN\n+oop* java_lang_Class::init_lock_addr(oop java_class) {\n+  assert(_init_lock_offset != 0, \"must be set\");\n+  return java_class->obj_field_addr_raw<oop>(_init_lock_offset);\n+}\n+#endif  \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -311,0 +311,4 @@\n+#if INCLUDE_TSAN\n+  static oop* init_lock_addr(oop java_class);\n+  static const int* init_lock_offset_addr() { return &_init_lock_offset; }\n+#endif  \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -612,0 +612,6 @@\n+\n+  TSAN_ONLY(int tsan_rec = 0;)\n+  TSAN_RUNTIME_ONLY(\n+    tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, lockObject());\n+    assert(tsan_rec > 0, \"tsan: unlocking unlocked mutex\");\n+  );\n@@ -616,0 +622,1 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, lockObject(), tsan_rec));\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -236,0 +236,1 @@\n+  template(java_util_concurrent_annotation_LazyInit,                         \"Ljava\/util\/concurrent\/annotation\/LazyInit;\") \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -206,0 +206,4 @@\n+  \/\/ TODO(tsan): _reserved MemRegion is not available to all collectors.\n+  \/\/ Should we support collectors without _reserved MemRegion? See 8224815.\n+  TSAN_ONLY(MemRegion reserved_region() const { return _reserved; })\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/collectedHeap.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  f(CNT_PREFIX ## TSANWeakRoots,            DESC_PREFIX \"TSAN Weak Roots\")             \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+#include \"tsan\/tsanOopMap.hpp\"\n@@ -95,0 +96,6 @@\n+#if INCLUDE_TSAN\n+ShenandoahTSANWeakRoot::ShenandoahTSANWeakRoot(ShenandoahPhaseTimings::Phase phase) :\n+  ShenandoahWeakSerialRoot(&TsanOopMap::weak_oops_do, phase, ShenandoahPhaseTimings::TSANWeakRoots) {\n+}\n+#endif \/\/ INCLUDE_TSAN\n+\n@@ -98,0 +105,1 @@\n+  TSAN_ONLY(_tsan_weak_roots.weak_oops_do(is_alive, keep_alive, worker_id);)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,0 +91,7 @@\n+#if INCLUDE_TSAN\n+class ShenandoahTSANWeakRoot : public ShenandoahWeakSerialRoot {\n+public:\n+  ShenandoahTSANWeakRoot(ShenandoahPhaseTimings::Phase phase);\n+};\n+#endif \/\/ INCLUDE_TSAN\n+\n@@ -95,0 +102,1 @@\n+  TSAN_ONLY(ShenandoahTSANWeakRoot   _tsan_weak_roots;)\n@@ -98,1 +106,2 @@\n-  JFR_ONLY(JVMTI_ONLY(COMMA)_jfr_weak_roots(phase)) {};\n+  JFR_ONLY(JVMTI_ONLY(COMMA)_jfr_weak_roots(phase))\n+  TSAN_ONLY(JVMTI_ONLY(COMMA)_tsan_weak_roots(phase)) {};\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRootProcessor.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -312,0 +312,6 @@\n+\/*\n+ * java.lang.ref.Finalizer\n+ *\/\n+JNIEXPORT jboolean JNICALL\n+JVM_GetTsanEnabled(JNIEnv *env);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -727,0 +727,5 @@\n+  bool is_tsan_ignore = false;\n+#if INCLUDE_TSAN\n+  is_tsan_ignore = info.access_flags().is_stable() || info.access_flags().is_tsan_ignore();\n+#endif  \/\/ INCLUDE_TSAN\n+\n@@ -736,0 +741,1 @@\n+    is_tsan_ignore,\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#if INCLUDE_TSAN\n+#include \"runtime\/sharedRuntime.hpp\"\n+#endif\n@@ -70,0 +73,21 @@\n+#if INCLUDE_TSAN\n+\n+TemplateTable::TsanMemoryReleaseAcquireFunction TemplateTable::tsan_release_acquire_method(\n+    TsanMemoryReadWriteFunction tsan_function) {\n+  if (tsan_function == SharedRuntime::tsan_read1\n+      || tsan_function == SharedRuntime::tsan_read2\n+      || tsan_function == SharedRuntime::tsan_read4\n+      || tsan_function == SharedRuntime::tsan_read8) {\n+    return SharedRuntime::tsan_acquire;\n+  } else if (tsan_function == SharedRuntime::tsan_write1\n+      || tsan_function == SharedRuntime::tsan_write2\n+      || tsan_function == SharedRuntime::tsan_write4\n+      || tsan_function == SharedRuntime::tsan_write8) {\n+    return SharedRuntime::tsan_release;\n+  }\n+  ShouldNotReachHere();\n+  return NULL;\n+}\n+\n+#endif\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2020, Oracle and\/or its affiliates. All rights reserved.\n@@ -350,0 +350,33 @@\n+#if INCLUDE_TSAN\n+   typedef void (*TsanMemoryReleaseAcquireFunction)(void* \/* address *\/);\n+\n+   typedef void (*TsanMemoryReadWriteFunction)(void* \/* address *\/,\n+                                               Method* \/* method *\/,\n+                                               address \/* bcp *\/);\n+\n+   \/\/ The corresponding tsan_acquire\/release function for a\n+   \/\/ TsanMemoryReadWriteFunction.\n+   static TsanMemoryReleaseAcquireFunction tsan_release_acquire_method(TsanMemoryReadWriteFunction tsan_function);\n+\n+   \/\/ Tell tsan that a member\/static variable has been read from or written to.\n+   \/\/ tsan_function must be one of the SharedRuntime::tsan_read\/write*\n+   \/\/ functions.\n+   \/\/ Flags is the register that contains the field cache entry flags bitfield.\n+   \/\/ Because the field may be volatile, for a write, this function must be\n+   \/\/ called before the write; for a read, this function must be called after\n+   \/\/ the read. This way the acquire\/release is ordered correctly relative to the\n+   \/\/ read\/write.\n+   static void tsan_observe_get_or_put(const Address &field,\n+                                       Register flags,\n+                                       TsanMemoryReadWriteFunction tsan_function,\n+                                       TosState tos);\n+\n+   \/\/ Tell tsan that an array has been read from or written to.\n+   \/\/ tsan_function must be one of the SharedRuntime::tsan_read\/write*\n+   \/\/ functions.\n+   \/\/ Unlike tsan_observe_get_or_put(), the ordering relative to the\n+   \/\/ read\/write does not matter since array loads\/stores are never volatile.\n+   static void tsan_observe_load_or_store(const Address& address,\n+                                          TsanMemoryReadWriteFunction tsan_function);\n+#endif\n+\n","filename":"src\/hotspot\/share\/interpreter\/templateTable.hpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -136,0 +136,1 @@\n+                                       bool is_tsan_ignore,\n@@ -143,1 +144,2 @@\n-                  ((is_final    ? 1 : 0) << is_final_shift),\n+                  ((is_final    ? 1 : 0) << is_final_shift) |\n+                  ((is_tsan_ignore ? 1 : 0) << is_tsan_ignore_shift),\n","filename":"src\/hotspot\/share\/oops\/cpCache.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -92,0 +92,3 @@\n+#if INCLUDE_TSAN\n+#include \"runtime\/sharedRuntime.hpp\"\n+#endif\n@@ -828,0 +831,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and the later checking if it's initialized.\n+      void* const lock_address = reinterpret_cast<void*>(\n+          java_lang_Class::init_lock_addr(java_mirror()));\n+      SharedRuntime::tsan_release(lock_address);\n+    );\n@@ -849,0 +859,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and here.\n+      void* const lock_address = reinterpret_cast<void*>(\n+          java_lang_Class::init_lock_addr(java_mirror()));\n+      SharedRuntime::tsan_acquire(lock_address);\n+    );\n@@ -1211,0 +1228,7 @@\n+    TSAN_RUNTIME_ONLY(\n+      \/\/ Construct a happens-before edge between the write of _init_state to\n+      \/\/ fully_initialized and the later checking if it's initialized.\n+      void* const lock_address = reinterpret_cast<void*>(\n+          java_lang_Class::init_lock_addr(java_mirror()));\n+      SharedRuntime::tsan_release(lock_address);\n+    );\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -88,0 +88,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -3410,0 +3413,9 @@\n+\/\/ java.lang.ref.Finalizer \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n+JVM_ENTRY(jboolean, JVM_GetTsanEnabled(JNIEnv *env))\n+  JVMWrapper(\"JVM_GetTsanEnabled\");\n+  TSAN_ONLY(return ThreadSanitizer;)\n+  NOT_TSAN(return JNI_FALSE;)\n+JVM_END\n+\n+\n@@ -3632,1 +3644,3 @@\n-  return new os::PlatformMutex();\n+  void *mon = new os::PlatformMutex();\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(mon));\n+  return mon;\n@@ -3639,0 +3653,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(mon));\n@@ -3647,0 +3662,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(mon));\n@@ -3654,0 +3670,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(mon));\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -76,0 +76,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -3226,0 +3229,4 @@\n+\/\/ Tsan note: The JVMTI raw monitors are instrumented at JvmtiRawMonitor call\n+\/\/ sites instead of inside the JvmtiRawMonitor implementation. This seems\n+\/\/ cleaner, and mirrors instrumentation of JVM_RawMonitor* functions.\n+\n@@ -3235,0 +3242,2 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_CREATE(rmonitor));\n+\n@@ -3257,0 +3266,1 @@\n+        TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3275,0 +3285,1 @@\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_DESTROY(rmonitor));\n@@ -3318,0 +3329,1 @@\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));\n@@ -3336,0 +3348,1 @@\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3349,0 +3362,4 @@\n+\n+  \/\/ A wait is modeled in Tsan as a simple release-acquire pair.\n+  \/\/ The matching release annotation is below.\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(rmonitor));\n@@ -3350,0 +3367,2 @@\n+  \/\/ The matching acquire annotation is above.\n+  TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(rmonitor));\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -62,0 +62,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsan.hpp\"\n+#endif  \/\/ INCLUDE_TSAN\n@@ -380,0 +383,16 @@\n+\/\/ Tsan should know that the JVMTI TagMap is protected by a mutex.\n+class TsanMutexScope : public StackObj {\n+ private:\n+  Mutex *_lock;  \/\/ Keep my own reference, for destructor.\n+\n+ public:\n+  \/\/ Don't actually lock it, just tell tsan we did.\n+  TsanMutexScope(Mutex* mutex) : _lock(mutex) {\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_ACQUIRED(_lock));\n+  }\n+\n+  ~TsanMutexScope() {\n+    TSAN_RUNTIME_ONLY(TSAN_RAW_LOCK_RELEASED(_lock));\n+  }\n+};\n+\n@@ -448,0 +467,18 @@\n+  \/\/ TSAN Note: we cannot tell TSAN about the creation of this lock due to\n+  \/\/ this being seen as racy though is not really.\n+  \/\/\n+  \/\/ The JvmtiTagMap gets created by the first thread to call tag_map_for; which\n+  \/\/ uses a lock to create it if need be.\n+  \/\/\n+  \/\/ This means that this lock is created under a mutex but then,\n+  \/\/ subsequent uses do not have a lock to protect it (because not\n+  \/\/ needed in this case), however TSAN sees it as being needed because:\n+  \/\/  - Another thread can come and get the newly created JvmtiTagMap without a\n+  \/\/  lock and acquire the lock.\n+  \/\/  - This provokes a race for TSAN on the lock itself, though there is no\n+  \/\/  real issue.\n+  \/\/\n+  \/\/  Not creating the lock or having a fence mechanism to tell TSAN this is\n+  \/\/  safe (a fake lock around this lock for example) seem to be the only\n+  \/\/  solutions.\n+\n@@ -457,1 +494,0 @@\n-\n@@ -484,0 +520,2 @@\n+\n+  \/\/ TSAN Note: see above for the Tsan creation note.\n@@ -735,0 +773,1 @@\n+  TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -767,0 +806,1 @@\n+  TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -1266,0 +1306,2 @@\n+  JvmtiTagMap* _tag_map;\n+\n@@ -1267,1 +1309,4 @@\n-  VM_HeapIterateOperation(ObjectClosure* blk) { _blk = blk; }\n+  VM_HeapIterateOperation(ObjectClosure* blk, JvmtiTagMap* tag_map) {\n+    _blk = blk;\n+    _tag_map = tag_map;\n+  }\n@@ -1271,0 +1316,6 @@\n+    \/\/ Simulates barrier synchronization on safepoint.\n+    \/\/ This annotation is reasonably minimal in number of tsan callbacks.\n+    \/\/ By passing the lock directly, we are not actually locking it, just\n+    \/\/ telling TSAN we are to \"simulate\" the lock.\n+    TSAN_ONLY(TsanMutexScope tms(_tag_map->lock()));\n+\n@@ -1497,1 +1548,1 @@\n-  VM_HeapIterateOperation op(&blk);\n+  VM_HeapIterateOperation op(&blk, this);\n@@ -1514,1 +1565,1 @@\n-  VM_HeapIterateOperation op(&blk);\n+  VM_HeapIterateOperation op(&blk, this);\n@@ -1610,0 +1661,1 @@\n+    TSAN_ONLY(TsanMutexScope tms(lock()));\n@@ -3216,0 +3268,5 @@\n+  \/\/ This annotation is reasonably minimal in number of tsan callbacks.\n+  \/\/ By passing the lock directly, we are not actually locking it, just\n+  \/\/ telling TSAN we are to \"simulate\" the lock.\n+  TSAN_ONLY(TsanMutexScope tms(_tag_map->lock()));\n+\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":61,"deletions":4,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsanExternalDecls.hpp\"\n+#endif\n@@ -268,0 +271,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    if (UseCompressedOops) {\n+      __tsan_read4_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    } else {\n+      __tsan_read8_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    }\n+  );\n@@ -275,0 +286,8 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    if (UseCompressedOops) {\n+      __tsan_write4_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    } else {\n+      __tsan_write8_pc(addr, SharedRuntime::tsan_code_location(0, 0));\n+    }\n+  );\n@@ -282,0 +301,4 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    __tsan_java_acquire(addr);\n+  );\n@@ -289,0 +312,4 @@\n+  TSAN_RUNTIME_ONLY(\n+    void* addr = index_oop_from_field_offset_long(p, offset);\n+    __tsan_java_release(addr);\n+  );\n@@ -297,1 +324,1 @@\n-#define DEFINE_GETSETOOP(java_type, Type) \\\n+#define DEFINE_GETSETOOP(java_type, Type, size) \\\n@@ -300,1 +327,6 @@\n-  return MemoryAccess<java_type>(thread, obj, offset).get(); \\\n+  java_type ret = MemoryAccess<java_type>(thread, obj, offset).get(); \\\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_read##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \\\n+  ); \\\n+  return ret; \\\n@@ -304,0 +336,4 @@\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_write##size##_pc(addr, SharedRuntime::tsan_code_location(0, 0)); \\\n+  ); \\\n@@ -309,8 +345,8 @@\n-DEFINE_GETSETOOP(jboolean, Boolean)\n-DEFINE_GETSETOOP(jbyte, Byte)\n-DEFINE_GETSETOOP(jshort, Short);\n-DEFINE_GETSETOOP(jchar, Char);\n-DEFINE_GETSETOOP(jint, Int);\n-DEFINE_GETSETOOP(jlong, Long);\n-DEFINE_GETSETOOP(jfloat, Float);\n-DEFINE_GETSETOOP(jdouble, Double);\n+DEFINE_GETSETOOP(jboolean, Boolean, 1)\n+DEFINE_GETSETOOP(jbyte, Byte, 1)\n+DEFINE_GETSETOOP(jshort, Short, 2);\n+DEFINE_GETSETOOP(jchar, Char, 2);\n+DEFINE_GETSETOOP(jint, Int, 4);\n+DEFINE_GETSETOOP(jlong, Long, 8);\n+DEFINE_GETSETOOP(jfloat, Float, 4);\n+DEFINE_GETSETOOP(jdouble, Double, 8);\n@@ -323,1 +359,6 @@\n-  return MemoryAccess<java_type>(thread, obj, offset).get_volatile(); \\\n+  java_type ret = MemoryAccess<java_type>(thread, obj, offset).get_volatile(); \\\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_java_acquire(addr); \\\n+  ); \\\n+  return ret; \\\n@@ -327,0 +368,4 @@\n+  TSAN_RUNTIME_ONLY( \\\n+    void* addr = index_oop_from_field_offset_long(JNIHandles::resolve(obj), offset); \\\n+    __tsan_java_release(addr); \\\n+  ); \\\n@@ -911,0 +956,24 @@\n+\/\/ Calls __tsan_java_release() on construct and __tsan_java_acquire() on destruct.\n+class ScopedReleaseAcquire: public StackObj {\n+private:\n+  void* _addr;\n+public:\n+  ScopedReleaseAcquire(volatile void* addr) {\n+    TSAN_RUNTIME_ONLY(\n+      _addr = const_cast<void*>(addr);\n+      __tsan_java_release(_addr);\n+    );\n+  }\n+\n+  ScopedReleaseAcquire(oop obj, jlong offset) {\n+    TSAN_RUNTIME_ONLY(\n+      _addr = index_oop_from_field_offset_long(obj, offset);\n+      __tsan_java_release(_addr);\n+    );\n+  }\n+\n+  ~ScopedReleaseAcquire() {\n+    TSAN_RUNTIME_ONLY(__tsan_java_acquire(_addr));\n+  }\n+};\n+\n@@ -916,0 +985,1 @@\n+  ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -924,0 +994,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -927,0 +998,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -935,0 +1007,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -938,0 +1011,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -947,0 +1021,1 @@\n+  ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -956,0 +1031,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -959,0 +1035,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n@@ -968,0 +1045,1 @@\n+    ScopedReleaseAcquire releaseAcquire(addr);\n@@ -971,0 +1049,1 @@\n+    ScopedReleaseAcquire releaseAcquire(p, offset);\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":90,"deletions":11,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -4113,0 +4113,12 @@\n+  TSAN_RUNTIME_ONLY(\n+    \/\/ Currently TSAN is only implemented for interpreter.\n+    set_mode_flags(_int);\n+    \/\/ TSAN instrumentation is not implemented for the RewriteBytecodes\n+    \/\/ code paths because TSAN slows down the application so much that the\n+    \/\/ performance benefits from rewriting bytecodes is negligible.\n+    FLAG_SET_ERGO(RewriteBytecodes, false);\n+    FLAG_SET_ERGO(RewriteFrequentPairs, false);\n+    \/\/ Turn off CDS, it interferes with eagerly allocating jmethodIDs.\n+    no_shared_spaces(\"CDS is not compatible with TSAN\");\n+  );\n+\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2461,0 +2461,11 @@\n+                                                                            \\\n+  TSAN_ONLY(product(bool, ThreadSanitizer, false,                           \\\n+          \"Enable ThreadSanitizer lock instrumentation\"))                   \\\n+                                                                            \\\n+  TSAN_ONLY(product(bool, ThreadSanitizerJavaMemory, true,                  \\\n+          \"Detect Java data races with ThreadSanitizer. \"                   \\\n+          \"This is only enabled if -XX:+ThreadSanitizer is set.\"))          \\\n+                                                                            \\\n+  TSAN_ONLY(product(ccstr, ThreadSanitizerIgnoreFile, NULL,                 \\\n+          \"File containing a list of ignored field patterns for \"           \\\n+          \"ThreadSanitizer.\"))                                              \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+TSAN_ONLY(jint tsan_init();)\n@@ -95,0 +96,1 @@\n+TSAN_ONLY(void tsan_exit();)\n@@ -107,1 +109,0 @@\n-\n@@ -122,0 +123,7 @@\n+  TSAN_RUNTIME_ONLY(\n+    status = tsan_init();\n+    if (status != JNI_OK) {\n+      return status;\n+    }\n+  );\n+\n@@ -172,0 +180,3 @@\n+\n+    TSAN_RUNTIME_ONLY(tsan_exit());\n+\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -134,0 +134,4 @@\n+#if INCLUDE_TSAN\n+Mutex*   TsanOopMap_lock              = NULL;\n+#endif\n+\n@@ -330,0 +334,4 @@\n+  TSAN_RUNTIME_ONLY(\n+    def(TsanOopMap_lock            , PaddedMutex  , special,     true,  _safepoint_check_never);\n+  );\n+\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -141,0 +141,3 @@\n+#if INCLUDE_TSAN\n+extern Mutex*   TsanOopMap_lock;                 \/\/ guards shared map of oops\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -80,0 +80,4 @@\n+#if INCLUDE_TSAN\n+#include \"tsan\/tsanExternalDecls.hpp\"\n+#include \"tsan\/tsanOopMap.hpp\"\n+#endif\n@@ -1012,0 +1016,170 @@\n+#if INCLUDE_TSAN\n+\n+JRT_LEAF(void, SharedRuntime::verify_oop_index(oopDesc* obj, int index))\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(index >= 0, \"index is less than 0\");\n+  int obj_size_in_bytes = obj->size() * HeapWordSize;\n+  assert(index < obj_size_in_bytes, \"index %d >= obj size %d\", index, obj_size_in_bytes);\n+JRT_END\n+\n+\/\/ TSAN: method entry callback from interpreter\n+\/\/ (1) In order to have the line numbers in the call stack, we use the caller\n+\/\/     address instead of the method that's being called. This also matches\n+\/\/     the entry\/exit convention that TSAN uses for C++.\n+\/\/ We use JRT_ENTRY since call_VM_leaf doesn't set _last_Java_sp that we need.\n+JRT_ENTRY(void, SharedRuntime::tsan_interp_method_entry(JavaThread *thread))\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  DEBUG_ONLY(NoHandleMark nhm;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+\n+  RegisterMap unused_reg_map(thread, false);\n+\n+  \/\/ These asserts should be removed once\n+  \/\/ we support more than just the interpreter for TSAN.\n+  assert(!thread->last_frame().is_compiled_frame(),\n+         \"Current frame should not be a compiled frame\");\n+  const frame sender = thread->last_frame().real_sender(&unused_reg_map);\n+  assert(!sender.is_compiled_frame(), \"Sender should not be a compiled frame\");\n+\n+  jmethodID jmethod_id = 0;\n+  u2 bci = 0;\n+  \/\/ TODO: is (0, 0) really the best we can do\n+  \/\/ when the sender isn't an interpreted frame?\n+  if (sender.is_interpreted_frame()) {\n+    jmethod_id = sender.interpreter_frame_method()->find_jmethod_id_or_null();\n+    bci = sender.interpreter_frame_bci();\n+  }\n+  __tsan_func_entry(tsan_code_location(jmethod_id, bci));\n+JRT_END\n+\n+\/\/ TSAN: method exit callback from interpreter\n+JRT_LEAF(void, SharedRuntime::tsan_interp_method_exit())\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  __tsan_func_exit();\n+JRT_END\n+\n+void SharedRuntime::tsan_oop_lock(Thread* thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+\n+  TsanOopMap::add_oop(obj);\n+  __tsan_java_mutex_lock((julong)(oopDesc*)obj);\n+}\n+\n+void SharedRuntime::tsan_oop_unlock(Thread *thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(TsanOopMap::exists(obj), \"oop seen in unlock but not tracked\");\n+\n+  __tsan_java_mutex_unlock((julong)(oopDesc*)obj);\n+}\n+\n+void SharedRuntime::tsan_oop_rec_lock(Thread* thread, oop obj, int rec) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+\n+  TsanOopMap::add_oop(obj);\n+  __tsan_java_mutex_lock_rec((julong)(oopDesc*)obj, rec);\n+}\n+\n+int SharedRuntime::tsan_oop_rec_unlock(Thread *thread, oop obj) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(thread != NULL, \"null thread\");\n+  assert(obj != NULL, \"null oop\");\n+  assert(oopDesc::is_oop(obj), \"invalid oop\");\n+  assert(TsanOopMap::exists(obj), \"oop seen in unlock but not tracked\");\n+\n+  return __tsan_java_mutex_unlock_rec((julong)(oopDesc*)obj);\n+}\n+\n+JRT_LEAF(void, SharedRuntime::tsan_interp_lock(JavaThread* thread,\n+                                               BasicObjectLock* elem))\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+  assert(elem != NULL, \"null elem\");\n+\n+  oop obj = elem->obj();\n+  tsan_oop_lock(thread, obj);\n+\n+  assert(obj == elem->obj(), \"oop changed\");\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+JRT_END\n+\n+JRT_LEAF(void, SharedRuntime::tsan_interp_unlock(JavaThread* thread,\n+                                                 BasicObjectLock* elem))\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+  assert(elem != NULL, \"null elem\");\n+\n+  oop obj = elem->obj();\n+  tsan_oop_unlock(thread, obj);\n+\n+  assert(obj == elem->obj(), \"oop changed\");\n+  DEBUG_ONLY(thread->last_frame().interpreter_frame_verify_monitor(elem);)\n+JRT_END\n+\n+\/\/ Should be JRT_LEAF, but this is called very early during VM startup, so we\n+\/\/ are sometimes in '_thread_in_vm' state.\n+\/\/ NOTE: DO NOT add operations that can safepoint, enter GC, or throw an\n+\/\/ exception!\n+void SharedRuntime::tsan_track_obj_with_size(oopDesc* obj, int size) {\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(oopDesc::is_oop(obj), \"Bad oopDesc passed to tsan_track_obj_with_size().\");\n+  TsanOopMap::add_oop_with_size(obj, size);\n+}\n+\n+JRT_LEAF(void, SharedRuntime::tsan_track_obj(oopDesc* obj))\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(oopDesc::is_oop(obj), \"Bad oopDesc passed to tsan_track_obj().\");\n+  TsanOopMap::add_oop(obj);\n+JRT_END\n+\n+\/\/ TODO: Make tsan_acquire\/release JRT_LEAF\n+\/\/ Currently it can't be JRT_LEAF because there are calls from the VM\n+\/\/ (instanceKlass.cpp), and JRT_LEAF only allows calls from Java\/native code.\n+\/\/ We need to figure out a better way of being able to call TSAN functions from\n+\/\/ the VM.\n+void SharedRuntime::tsan_acquire(void* address) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(address != NULL, \"Cannot acquire at address 0\");\n+  __tsan_java_acquire(address);\n+}\n+\n+void SharedRuntime::tsan_release(void* address) {\n+  DEBUG_ONLY(NoSafepointVerifier nsv;)\n+  assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");\n+  assert(address != NULL, \"Cannot release at address 0\");\n+  __tsan_java_release(address);\n+}\n+\n+#define TSAN_MEMORY_ACCESS(name)                                               \\\n+  JRT_LEAF(void, SharedRuntime::tsan_##name(                                   \\\n+      void* addr,                                                              \\\n+      Method* method,                                                          \\\n+      address bcp))                                                            \\\n+    assert(ThreadSanitizer, \"Need -XX:+ThreadSanitizer\");                      \\\n+    assert(ThreadSanitizerJavaMemory, \"Need -XX:+ThreadSanitizerJavaMemory\");  \\\n+    jmethodID mid = method->find_jmethod_id_or_null();                         \\\n+    int bci = method->bci_from(bcp);                                           \\\n+    __tsan_##name##_pc(addr, tsan_code_location(mid, bci));                    \\\n+  JRT_END\n+\n+TSAN_MEMORY_ACCESS(read1)\n+TSAN_MEMORY_ACCESS(read2)\n+TSAN_MEMORY_ACCESS(read4)\n+TSAN_MEMORY_ACCESS(read8)\n+TSAN_MEMORY_ACCESS(write1)\n+TSAN_MEMORY_ACCESS(write2)\n+TSAN_MEMORY_ACCESS(write4)\n+TSAN_MEMORY_ACCESS(write8)\n+\n+#endif \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":174,"deletions":0,"binary":false,"changes":174,"status":"modified"},{"patch":"@@ -281,0 +281,91 @@\n+#if INCLUDE_TSAN\n+  \/\/ TSAN instrumentation\n+\n+  \/\/ TSAN uses a 64-bit value to identify code location.\n+  \/\/ TSAN uses the uppermost 3 bits (63:61) for the internal purposes.\n+  \/\/ If bit 60 is set, TSAN recognizes that the code location belongs to the\n+  \/\/ JVM, and will call __tsan_symbolize_external_ex() for symbolization rather\n+  \/\/ than TSAN's own symbolizer. See __sanitizer::kExternalPCBit and\n+  \/\/ __tsan::__tsan_symbolize_external_ex() in TSAN for more details.\n+  \/\/ The lower 60 bits may contain either a packed bytecode location, or an\n+  \/\/ instruction address inside the code generated by JIT compiler.\n+  \/\/ A packed code location has the method ID in bits 59:16 and the bytecode\n+  \/\/offset within method in bits 15:0. 44 bits (59:16) are enough to encode any\n+  \/\/ 47-bit 8-byte-aligned address, which is the maximum address space TSAN\n+  \/\/ allows. The next 16 bits are used for storing the bci.\n+  \/\/ | Tsan: 3 | TsanJava: 1 | jmethodID: 44 | BCI: 16 |\n+  static const int tsan_method_id_alignment_bits = 3;\n+  static const int tsan_bci_bits = 16;\n+  static const u8 tsan_bci_mask = right_n_bits(tsan_bci_bits);\n+  static const int tsan_method_id_shift = tsan_bci_bits -\n+      tsan_method_id_alignment_bits;\n+  static const u8 tsan_fake_pc_bit = 1L << 60;\n+  static void * tsan_code_location(jmethodID jmethod_id_ptr, u2 bci) {\n+    return (void *)(tsan_fake_pc_bit |\n+      (((u8)(jmethod_id_ptr)) << tsan_method_id_shift) | bci);\n+  }\n+  static jmethodID tsan_method_id_from_code_location(u8 loc) {\n+    u8 id =\n+        (loc & ~(tsan_fake_pc_bit | tsan_bci_mask)) >> tsan_method_id_shift;\n+\n+    \/\/ Typical method ID in aarch64 is like 0xffff_xxxx_xxxx_xxxx, which couldn't be represented by 47-bits.\n+    \/\/ But there are only 3 application memory regions in tsan for 48bits aarch64, the highest 4 bits\n+    \/\/ of addresses are 0x0, 0xa and 0xf respectively. The encoding function tsan_code_location() will\n+    \/\/ overwrite bit 47 for internal purpose, Therefore, we restore bit 47 here according to\n+    \/\/ the value of bits 46:44. if it is 0x2 or 0x7, restore bit 47 to 1.\n+#ifdef AARCH64\n+    u8 highest4bits = id >> 44;\n+    if (highest4bits == 0x7ULL || highest4bits == 0x2ULL) {\n+      id |= (0x1ULL << 47);\n+    }\n+#endif\n+\n+    return (jmethodID)id;\n+  }\n+  static u2 tsan_bci_from_code_location(u8 loc) {\n+    return (u2)(loc & tsan_bci_mask);\n+  }\n+\n+  \/\/ These functions are wrappers around TSAN callbacks,\n+  \/\/ which are listed in tsanExternalDecls.hpp. The VM uses only these\n+  \/\/ functions to push events to ThreadSanitizer.\n+\n+  \/\/ Verify that an oop is valid and that the index is within the object size.\n+  static void verify_oop_index(oopDesc* obj, int index);\n+\n+  \/\/ Java method entry\/exit from code run by template interpreter\n+  static void tsan_interp_method_entry(JavaThread *thread);\n+  static void tsan_interp_method_exit();\n+\n+  \/\/ Monitor acquire\/release in VM code\n+  \/\/ (e.g., generated native method wrapper, JNI heavyweight locks)\n+  static void tsan_oop_lock(Thread* thread, oop obj);\n+  static void tsan_oop_unlock(Thread* thread, oop obj);\n+  \/\/ Monitor acquire\/release in VM code; recursive lock variant (e.g., wait())\n+  static void tsan_oop_rec_lock(Thread* thread, oop obj, int rec);\n+  static int tsan_oop_rec_unlock(Thread* thread, oop obj);\n+\n+  \/\/ Monitor acquire\/release from code run by template interpreter\n+  static void tsan_interp_lock(JavaThread* thread, BasicObjectLock* elem);\n+  static void tsan_interp_unlock(JavaThread* thread, BasicObjectLock* elem);\n+\n+  \/\/ Address must point to an object in the Java heap.\n+  static void tsan_acquire(void* address);\n+  static void tsan_release(void* address);\n+\n+  \/\/ Called whenever an obj is created.\n+  static void tsan_track_obj_with_size(oopDesc* obj, int size);\n+  static void tsan_track_obj(oopDesc* obj);\n+\n+  \/\/ Memory reads\/writes from code run by template interpreter\n+  static void tsan_read1(void* addr, Method* method, address bcp);\n+  static void tsan_read2(void* addr, Method* method, address bcp);\n+  static void tsan_read4(void* addr, Method* method, address bcp);\n+  static void tsan_read8(void* addr, Method* method, address bcp);\n+  static void tsan_write1(void* addr, Method* method, address bcp);\n+  static void tsan_write2(void* addr, Method* method, address bcp);\n+  static void tsan_write4(void* addr, Method* method, address bcp);\n+  static void tsan_write8(void* addr, Method* method, address bcp);\n+\n+#endif \/\/ INCLUDE_TSAN\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":91,"deletions":0,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -676,0 +676,8 @@\n+\/\/ NOTE(TSAN): We cannot instrument complete_exit\/reenter in ObjectSynchronizer\n+\/\/             in a manner similar to wait and waitUninterruptibly, because\n+\/\/             (1) recursion count stored by inflated monitor is different from\n+\/\/             the absolute recursion count tracked by Tsan, and (2) in the\n+\/\/             general case, we cannot merely store Tsan's recursion count\n+\/\/             once: we must track it for *each invocation* of complete_exit.\n+\/\/             Hence, the best place to instrument for Tsan is at the call site\n+\/\/             for complete_exit\/reenter. Luckily, there is only one call site.\n@@ -728,0 +736,1 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(THREAD, obj()));\n@@ -746,0 +755,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(THREAD, obj));\n@@ -761,0 +771,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_lock(_thread, _obj()));\n@@ -766,0 +777,1 @@\n+    TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_unlock(_thread, _obj()));\n@@ -788,0 +800,7 @@\n+\n+  TSAN_ONLY(int tsan_rec = 0;)\n+  TSAN_RUNTIME_ONLY(\n+    tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());\n+    assert(tsan_rec > 0, \"tsan: unlocking unlocked mutex\");\n+  );\n+\n@@ -790,0 +809,2 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));\n+\n@@ -810,0 +831,5 @@\n+  TSAN_ONLY(int tsan_rec;)\n+  TSAN_RUNTIME_ONLY(\n+    tsan_rec = SharedRuntime::tsan_oop_rec_unlock(THREAD, obj());\n+    assert(tsan_rec > 0, \"tsan: unlocking unlocked mutex\");\n+  );\n@@ -811,0 +837,1 @@\n+  TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_lock(THREAD, obj(), tsan_rec));\n@@ -2847,0 +2874,4 @@\n+      \/\/ Note well -- this occurs ONLY on thread exit, and is a last ditch\n+      \/\/ effort to release all locks. Hence, we don't need to record tsan's\n+      \/\/ recursion count -- it will never be locked again.\n+      TSAN_RUNTIME_ONLY(SharedRuntime::tsan_oop_rec_unlock(THREAD, (oop)mid->object()));\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":31,"deletions":0,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -89,0 +89,1 @@\n+  JVM_ACC_FIELD_TSAN_IGNORE               = 0x00000200, \/\/ TSAN should ignore memory accesses to this field, same as JVM_ACC_INTERFACE\n@@ -94,1 +95,2 @@\n-                                       JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE,\n+                                       JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE |\n+                                       JVM_ACC_FIELD_TSAN_IGNORE,\n@@ -171,0 +173,3 @@\n+#if INCLUDE_TSAN\n+  bool is_tsan_ignore() const           { return (_flags & JVM_ACC_FIELD_TSAN_IGNORE) != 0; }\n+#endif  \/\/ INCLUDE_TSAN\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -272,0 +272,19 @@\n+#ifndef INCLUDE_TSAN\n+#define INCLUDE_TSAN 1\n+#endif\n+\n+#if INCLUDE_TSAN\n+#define TSAN_ONLY(code) code\n+#define TSAN_RUNTIME_ONLY(code) \\\n+    do { \\\n+      if (ThreadSanitizer) { \\\n+        code; \\\n+      } \\\n+    } while (0)\n+#define NOT_TSAN(code)\n+#else\n+#define TSAN_ONLY(code)\n+#define TSAN_RUNTIME_ONLY(code)\n+#define NOT_TSAN(code) code\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -112,0 +112,1 @@\n+    exports java.util.concurrent.annotation;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -222,0 +222,8 @@\n+#ifdef INCLUDE_TSAN\n+\/*\n+ * Function pointer to JVM's TSAN symbolize function.\n+ *\/\n+__attribute__((visibility(\"default\")))\n+TsanSymbolize_t tsan_symbolize_func = NULL;\n+#endif\n+\n@@ -301,0 +309,3 @@\n+#ifdef INCLUDE_TSAN\n+    tsan_symbolize_func = ifn.TsanSymbolize;\n+#endif\n","filename":"src\/java.base\/share\/native\/libjli\/java.c","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -76,0 +76,7 @@\n+#ifdef INCLUDE_TSAN\n+typedef void (*TsanSymbolizeAddFrameFunc)(\n+    void *ctx, const char *function, const char *file, int line, int column);\n+typedef void (JNICALL *TsanSymbolize_t)(uint64_t, TsanSymbolizeAddFrameFunc, void *);\n+extern TsanSymbolize_t tsan_symbolize_func;\n+#endif\n+\n@@ -87,0 +94,3 @@\n+#ifdef INCLUDE_TSAN\n+    TsanSymbolize_t TsanSymbolize;\n+#endif\n","filename":"src\/java.base\/share\/native\/libjli\/java.h","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -560,0 +560,9 @@\n+#ifdef INCLUDE_TSAN\n+    ifn->TsanSymbolize = (TsanSymbolize_t)\n+        dlsym(libjvm, \"TsanSymbolize\");\n+    if (ifn->TsanSymbolize == NULL) {\n+        JLI_ReportErrorMessage(DLL_ERROR2, jvmpath, dlerror());\n+        return JNI_FALSE;\n+    }\n+#endif\n+\n","filename":"src\/java.base\/unix\/native\/libjli\/java_md.c","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}