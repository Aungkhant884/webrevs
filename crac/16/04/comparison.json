{"files":[{"patch":"@@ -227,0 +227,4 @@\n+$(eval $(call SetupBuildDemo, JavaCompilerCRaC, \\\n+    DEMO_SUBDIR := crac, \\\n+))\n+\n","filename":"make\/CompileDemos.gmk","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,5 @@\n+public class Compile {\n+    public static void main(String... args) throws Exception {\n+        JavaCompilerCRaC.runJavac(args);\n+    }\n+}\n","filename":"src\/demo\/share\/crac\/JavaCompilerCRaC\/Compile.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -0,0 +1,29 @@\n+import java.util.Arrays;\n+import jdk.crac.Core;\n+\n+public class JavaCompilerCRaC {\n+\n+    static void runJavac(String... args) {\n+        System.out.println(\"javac \" + String.join(\" \", args));\n+        int status = com.sun.tools.javac.Main.compile(args);\n+        if (status != 0) {\n+            System.exit(status);\n+        }\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        int startIdx = 0;\n+        for (int endIdx = 1; endIdx < args.length; ++endIdx) {\n+            if (args[endIdx].equals(\"--\")) {\n+                runJavac(Arrays.copyOfRange(args, startIdx, endIdx));\n+                startIdx = endIdx + 1;\n+            }\n+        }\n+\n+        if (startIdx < args.length) {\n+            runJavac(Arrays.copyOfRange(args, startIdx, args.length));\n+        }\n+\n+        Core.checkpointRestore();\n+    }\n+}\n","filename":"src\/demo\/share\/crac\/JavaCompilerCRaC\/JavaCompilerCRaC.java","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -289,0 +289,1 @@\n+  char* _new_args;\n@@ -293,1 +294,2 @@\n-    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal))\n+    _failures(new (ResourceObj::C_HEAP, mtInternal) GrowableArray<CracFailDep>(0, mtInternal)),\n+    _new_args(NULL)\n@@ -298,0 +300,3 @@\n+    if (_new_args) {\n+      FREE_C_HEAP_ARRAY(char, _new_args);\n+    }\n@@ -301,1 +306,0 @@\n-\n@@ -303,0 +307,2 @@\n+  char* new_args() { return _new_args; }\n+\n@@ -5838,1 +5844,63 @@\n-static int checkpoint_restore() {\n+static int set_new_args(int id, const char *args) {\n+    char shmpath[128];\n+    int shmpathlen = snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n+    if (shmpathlen < 0 || sizeof(shmpath) <= (size_t)shmpathlen) {\n+      fprintf(stderr, \"shmpath is too long: %d\\n\", shmpathlen);\n+      return -1;\n+    }\n+\n+    int shmfd = shm_open(shmpath, O_RDWR | O_CREAT, 0600);\n+    if (-1 == shmfd) {\n+        perror(\"shm_open\");\n+        return -1;\n+    }\n+\n+    int argslen = strlen(args);\n+    int wret = write(shmfd, args, argslen);\n+    if (argslen != wret) {\n+        if (wret < 0) {\n+            perror(\"write shm\");\n+        } else {\n+            fprintf(stderr, \"write shm truncated\");\n+        }\n+        close(shmfd);\n+        shm_unlink(shmpath);\n+        return -1;\n+    }\n+\n+    close(shmfd);\n+    return 0;\n+}\n+\n+static char* get_new_args(int id) {\n+    char shmpath[128];\n+    snprintf(shmpath, sizeof(shmpath), \"\/crac_%d\", id);\n+\n+    int shmfd = shm_open(shmpath, O_RDONLY, 0600);\n+    if (-1 == shmfd) {\n+      perror(\"shm_open (ignoring new args)\");\n+      return NULL;\n+    }\n+\n+    shm_unlink(shmpath);\n+\n+    struct stat st;\n+    if (fstat(shmfd, &st)) {\n+      perror(\"shm_open (ignoring new args)\");\n+      close(shmfd);\n+      return NULL;\n+    }\n+\n+    char *args = NEW_C_HEAP_ARRAY(char, st.st_size + 1, mtInternal);\n+    if (read(shmfd, args, st.st_size) < 0) {\n+      perror(\"read (ignoring new args)\");\n+      close(shmfd);\n+      FREE_C_HEAP_ARRAY(char, args);\n+      return NULL;\n+    }\n+\n+    args[st.st_size] = '\\0';\n+    return args;\n+}\n+\n+static int checkpoint_restore(char** argp) {\n@@ -5872,1 +5940,5 @@\n-  return info.si_int;\n+  if (0 < info.si_int) {\n+    *argp = get_new_args(info.si_int);\n+  }\n+\n+  return JVM_CHECKPOINT_OK;\n@@ -6065,1 +6137,1 @@\n-  int ret = checkpoint_restore();\n+  int ret = checkpoint_restore(&_new_args);\n@@ -6149,2 +6221,2 @@\n-static Handle ret_cr(int ret, Handle codes, Handle msgs, TRAPS) {\n-  objArrayOop bundleObj = oopFactory::new_objectArray(3, CHECK_NH);\n+static Handle ret_cr(int ret, Handle new_args, Handle err_codes, Handle err_msgs, TRAPS) {\n+  objArrayOop bundleObj = oopFactory::new_objectArray(4, CHECK_NH);\n@@ -6155,2 +6227,3 @@\n-  bundle->obj_at_put(1, codes());\n-  bundle->obj_at_put(2, msgs());\n+  bundle->obj_at_put(1, new_args());\n+  bundle->obj_at_put(2, err_codes());\n+  bundle->obj_at_put(3, err_msgs());\n@@ -6160,4 +6233,0 @@\n-static Handle ret_cr(int ret, TRAPS) {\n-  return ret_cr(ret, Handle(), Handle(), THREAD);\n-}\n-\n@@ -6168,1 +6237,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n@@ -6173,1 +6242,1 @@\n-    return ret_cr(JVM_CHECKPOINT_NONE, THREAD);\n+    return ret_cr(JVM_CHECKPOINT_NONE, Handle(), Handle(), Handle(), THREAD);\n@@ -6186,1 +6255,5 @@\n-    return ret_cr(JVM_CHECKPOINT_OK, THREAD);\n+    oop new_args = NULL;\n+    if (cr.new_args()) {\n+      new_args = java_lang_String::create_oop_from_str(cr.new_args(), CHECK_NH);\n+    }\n+    return ret_cr(JVM_CHECKPOINT_OK, Handle(THREAD, new_args), Handle(), Handle(), THREAD);\n@@ -6203,1 +6276,1 @@\n-  return ret_cr(JVM_CHECKPOINT_ERROR, codes, msgs, THREAD);\n+  return ret_cr(JVM_CHECKPOINT_ERROR, Handle(), codes, msgs, THREAD);\n@@ -6211,0 +6284,10 @@\n+  int id = getpid();\n+  const char* args = Arguments::java_command() ? Arguments::java_command() : \"\";\n+  if (set_new_args(id, args)) {\n+    id = 0;\n+  }\n+\n+  char strid[32];\n+  snprintf(strid, sizeof(strid), \"%d\", id);\n+  setenv(\"CRAC_NEW_ARGS_ID\", strid, true);\n+\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":100,"deletions":17,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -33,0 +33,2 @@\n+import jdk.internal.reflect.CallerSensitive;\n+import jdk.internal.reflect.Reflection;\n@@ -35,0 +37,4 @@\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.Arrays;\n+\n@@ -118,2 +124,3 @@\n-        final int[] codes = (int[])bundle[1];\n-        final String[] messages = (String[])bundle[2];\n+        final String newArguments = (String)bundle[1];\n+        final int[] codes = (int[])bundle[2];\n+        final String[] messages = (String[])bundle[3];\n@@ -143,0 +150,1 @@\n+        RestoreException restoreException = null;\n@@ -147,1 +155,5 @@\n-                throw re;\n+                restoreException = re;\n+            } else {\n+                for (Throwable t : re.getSuppressed()) {\n+                    checkpointException.addSuppressed(t);\n+                }\n@@ -149,2 +161,24 @@\n-            for (Throwable t : re.getSuppressed()) {\n-                checkpointException.addSuppressed(t);\n+        }\n+\n+        if (newArguments != null && newArguments.length() > 0) {\n+            String[] args = newArguments.split(\" \");\n+            if (args.length > 0) {\n+                try {\n+                    Class<?> newMainClass = Class.forName(args[0], false,\n+                        ClassLoader.getSystemClassLoader());\n+                    Method newMain = newMainClass.getDeclaredMethod(\"main\",\n+                        String[].class);\n+                    newMain.setAccessible(true);\n+                    newMain.invoke(null,\n+                        (Object)Arrays.copyOfRange(args, 1, args.length));\n+                } catch (ClassNotFoundException    |\n+                         InvocationTargetException |\n+                         NoSuchMethodException     |\n+                         IllegalAccessException e) {\n+                    assert checkpointException == null :\n+                        \"should not have new arguments\";\n+                    if (restoreException == null) {\n+                        restoreException = new RestoreException();\n+                    }\n+                    restoreException.addSuppressed(e);\n+                }\n@@ -153,0 +187,2 @@\n+\n+        assert checkpointException == null || restoreException == null;\n@@ -155,0 +191,2 @@\n+        } else if (restoreException != null) {\n+            throw restoreException;\n","filename":"src\/java.base\/share\/classes\/jdk\/crac\/Core.java","additions":43,"deletions":5,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -193,7 +193,2 @@\n-    union sigval sv = { .sival_int = 0 };\n-    if (-1 == sigqueue(pid, RESTORE_SIGNAL, sv)) {\n-        perror(MSGPREFIX \"sigqueue\");\n-        return 1;\n-    }\n-\n-    return 0;\n+    char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+    return kickjvm(pid, atoi(strid));\n","filename":"src\/java.base\/unix\/native\/criuengine\/criuengine.c","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include <stdlib.h>\n@@ -80,1 +81,2 @@\n-        if (kickjvm(jvm, 0)) {\n+        char *strid = getenv(\"CRAC_NEW_ARGS_ID\");\n+        if (kickjvm(jvm, atoi(strid))) {\n","filename":"src\/java.base\/unix\/native\/pauseengine\/pauseengine.c","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include <stdlib.h>\n@@ -47,0 +48,2 @@\n+        const char* argsidstr = getenv(\"SIM_CRAC_NEW_ARGS_ID\");\n+        int argsid = argsidstr ? atoi(argsidstr) : 0;\n@@ -48,1 +51,1 @@\n-        kickjvm(jvm, 0);\n+        kickjvm(jvm, argsid);\n@@ -50,1 +53,1 @@\n-        \/* should not be called and nothing to do *\/\n+        printf(\"SIM_CRAC_NEW_ARGS_ID=%s\\n\", getenv(\"CRAC_NEW_ARGS_ID\"));\n","filename":"src\/java.base\/unix\/native\/simengine\/simengine.c","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"}]}